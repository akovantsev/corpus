<!DOCTYPE html>
<body><style>body {font-family: Monaco, Menlo, Consolas, "Courier New"; font-size: 12px;}</style><style>pre, code {
    font-family: Monaco, Menlo, Consolas, "Courier New", monospace;
    color: #333;
}</style><style>code {line-height: 1.2;
    white-space: normal;
    color: #c25;
    background-color: #f7f7f9;
    border: 1px solid #e1e1e8;}</style><style>pre {
    margin: .5rem 0 .2rem;
    font-size: .75rem;
    line-height: 1.15rem;</style><style>pre {
    background: #fbfaf8;
    padding: .5rem;
    word-break: normal;
    display: block;
    border: 1px solid rgba(0, 0, 0, .15);
    white-space: pre-wrap;
    word-wrap: break-word;
    border-radius: 4px;
}</style><style>span.u {margin-top: 3px;    margin-left: 10px;
    margin-right: 10px;
    background-color: lavender;}</style><style>span {white-space: pre-wrap;}</style><style id="css-filter"></style><h3>instaparse, last update time: 2020:11:17 10:01:23</h3><h3>up until: <a href="https://clojurians-log.clojureverse.org/instaparse/2020-11-16">https://clojurians-log.clojureverse.org/instaparse/2020-11-16</a></h3><input id="filter" onkeyup="debfilter(this.value)" placeholder="filter" style="position: fixed" type="string" /><script>
const filterInput = document.getElementById("filter");
const filterStryle = document.getElementById("css-filter");

function filter(text) {
    var style = '';
    if (text.trim() !== '') {
        text.split(' ').forEach(function (t) {
            if (t !== '') {
                style = style + "div:not([data-t*='" + t + "' i]) {display: none}";
            }
        });
    }
    filterStryle.innerHTML = style;
}

function filterSelection (e) {
    let sel = document.getSelection();
    let txt;
    if (sel.anchorNode.parentElement.nodeName === "CODE") {
        txt = sel.focusNode.textContent.substring(0, sel.focusOffset);
    } else if (sel.focusNode.parentElement.nodeName === "CODE") {
        txt = sel.anchorNode.textContent.substring(sel.anchorOffset, sel.anchorNode.textContent.length);
    } else {
        txt = sel.toString();
    }

    if (txt.length > 0) {
        filterInput.value = (txt || "");
        filter(txt);
    }
}
function debounce1(callback, delay) {
    let timeout;
    return function(arg) {
        clearTimeout(timeout);
        timeout = setTimeout(callback, delay, arg);
    }
}
const debfilter = debounce1(filter, 200);

function keyUp (e) {
    if (e.code === "KeyF" && e.ctrlKey) {
        let txt = document.getSelection().toString();
        if (txt.length > 0) {
            filterInput.value = (txt || "");
            filter(txt);
        }
    }
}

document.ondblclick = filterSelection;
document.onkeyup = keyUp;
filterInput.focus();
</script><div data-t="aengelberg @mhuebert: Re: recent instaparse-live changes: The memoization worked like a charm, the parsing is a lot faster now when only changing the sample. Great idea!"><span class="u" id="1434257103.000012">2015:06:14 04:45:03       aengelberg </span><span>@mhuebert: Re: recent instaparse-live changes: The memoization worked like a charm, the parsing is a lot faster now when only changing the sample. Great idea!</span></div><div data-t="lucasbradstreet Howdy. instaparse-cljs 1.4.0.0-SNAPSHOT works with Clojure 1.7 now. Recent fixes from v1.3.5-1.4.0 haven&apos;t been ported to cljs yet. "><span class="u" id="1434420027.000016">2015:06:16 02:00:27  lucasbradstreet </span><span>Howdy. instaparse-cljs 1.4.0.0-SNAPSHOT works with Clojure 1.7 now. Recent fixes from v1.3.5-1.4.0 haven&apos;t been ported to cljs yet. </span></div><div data-t="aengelberg cc @canweriotnow"><span class="u" id="1434420135.000017">2015:06:16 02:02:15       aengelberg </span><span>cc @canweriotnow</span></div><div data-t="aengelberg @lucasbradstreet sweet!!! any plans to include tracing features? or is that not as applicable to cljs?"><span class="u" id="1434420177.000019">2015:06:16 02:02:57       aengelberg </span><span>@lucasbradstreet sweet!!! any plans to include tracing features? or is that not as applicable to cljs?</span></div><div data-t="aengelberg A lot of the hacky namespace reloading would probably be not doable on the cljs side. So maybe it would hit performance a little bit to include conditional tracing everywhere"><span class="u" id="1434420281.000020">2015:06:16 02:04:41       aengelberg </span><span>A lot of the hacky namespace reloading would probably be not doable on the cljs side. So maybe it would hit performance a little bit to include conditional tracing everywhere</span></div><div data-t="lucasbradstreet Depends on how hard it is to support. I can&apos;t throw too much more time into this for now. I think it usually makes sense to dev the parser in CLJ first, though instaparse-live may have changed my mind ;)"><span class="u" id="1434420285.000021">2015:06:16 02:04:45  lucasbradstreet </span><span>Depends on how hard it is to support. I can&apos;t throw too much more time into this for now. I think it usually makes sense to dev the parser in CLJ first, though instaparse-live may have changed my mind ;)</span></div><div data-t="lucasbradstreet Ah, yeah, if that&apos;s required I&apos;ll probably pass on it for now. "><span class="u" id="1434420330.000022">2015:06:16 02:05:30  lucasbradstreet </span><span>Ah, yeah, if that&apos;s required I&apos;ll probably pass on it for now. </span></div><div data-t="canweriotnow @lucasbradstreet: awesome. We&apos;re digging to find issues with processing certain chars or ranges in the cljs port...  “%x41-57” works, but “%x41” doesn’t. “%x79-7A” doesn’t... possibly one of the char fns in instaparse.abnf (cljs) - clj version works fine."><span class="u" id="1434497680.000025">2015:06:16 23:34:40     canweriotnow </span><span>@lucasbradstreet: awesome. We&apos;re digging to find issues with processing certain chars or ranges in the cljs port...  “%x41-57” works, but “%x41” doesn’t. “%x79-7A” doesn’t... possibly one of the char fns in instaparse.abnf (cljs) - clj version works fine.</span></div><div data-t="canweriotnow We&apos;ll submit an issue (or hopefully PR) when we track it down."><span class="u" id="1434497701.000026">2015:06:16 23:35:01     canweriotnow </span><span>We&apos;ll submit an issue (or hopefully PR) when we track it down.</span></div><div data-t="aengelberg Yeah, playing around in my REPL, the %x41 does not work for some reason."><span class="u" id="1434497960.000027">2015:06:16 23:39:20       aengelberg </span><span>Yeah, playing around in my REPL, the %x41 does not work for some reason.</span></div><div data-t="aengelberg https://github.com/lbradstreet/instaparse-cljs/blob/master/src/cljs/instaparse/abnf.cljs#L118"><span class="u" id="1434498318.000028">2015:06:16 23:45:18       aengelberg </span><a href="https://github.com/lbradstreet/instaparse-cljs/blob/master/src/cljs/instaparse/abnf.cljs#L118">https://github.com/lbradstreet/instaparse-cljs/blob/master/src/cljs/instaparse/abnf.cljs#L118</a></div><div data-t="aengelberg Should be (string (apply str (coerce-char (char-codes num1)))))"><span class="u" id="1434498396.000030">2015:06:16 23:46:36       aengelberg </span><span>Should be (string (apply str (coerce-char (char-codes num1)))))</span></div><div data-t="lucasbradstreet Ah cool. I won&apos;t have much time to push these changes atm but if you want to send me a PR I&apos;ll merge it. "><span class="u" id="1434498444.000031">2015:06:16 23:47:24  lucasbradstreet </span><span>Ah cool. I won&apos;t have much time to push these changes atm but if you want to send me a PR I&apos;ll merge it. </span></div><div data-t="canweriotnow Wow, awesome"><span class="u" id="1434498537.000032">2015:06:16 23:48:57     canweriotnow </span><span>Wow, awesome</span></div><div data-t="aengelberg @lucasbradstreet Actually I can&apos;t really tell what the purpose of char-codes is."><span class="u" id="1434498545.000033">2015:06:16 23:49:05       aengelberg </span><span>@lucasbradstreet Actually I can&apos;t really tell what the purpose of char-codes is.</span></div><div data-t="aengelberg It seems to take a character (possibly unicode) and split it into two characters. but at the REPL it doesn&apos;t seem to do that."><span class="u" id="1434498562.000034">2015:06:16 23:49:22       aengelberg </span><span>It seems to take a character (possibly unicode) and split it into two characters. but at the REPL it doesn&apos;t seem to do that.</span></div><div data-t="lucasbradstreet Just off the top of my head it is to deal with multibyte chars by getting each byte (charCodeAt)"><span class="u" id="1434498758.000035">2015:06:16 23:52:38  lucasbradstreet </span><span>Just off the top of my head it is to deal with multibyte chars by getting each byte (charCodeAt)</span></div><div data-t="canweriotnow hmm.. maybe  %x41-57  didn&apos;t actually work, but just didn&apos;t throw like  %x41 ... need to dig deeper."><span class="u" id="1434499063.000037">2015:06:16 23:57:43     canweriotnow </span><span>hmm.. maybe </span><code>%x41-57</code><span> didn&apos;t actually work, but just didn&apos;t throw like </span><code>%x41</code><span>... need to dig deeper.</span></div><div data-t="canweriotnow The thing we&apos;re doing is generating parsers for various URI/IRI schemes from the ABNF in their respective RFCs, so we&apos;re problably hitting edge cases like crazy  simple_smile"><span class="u" id="1434499185.000038">2015:06:16 23:59:45     canweriotnow </span><span>The thing we&apos;re doing is generating parsers for various URI/IRI schemes from the ABNF in their respective RFCs, so we&apos;re problably hitting edge cases like crazy </span><b>simple_smile</b></div><div data-t="aengelberg That part of the abnf namespace seems not properly designed for supplementary characters altogether..."><span class="u" id="1434499594.000039">2015:06:17 00:06:34       aengelberg </span><span>That part of the abnf namespace seems not properly designed for supplementary characters altogether...</span></div><div data-t="aengelberg It isn&apos;t using any utility (unlike the clj version) to turn an oversized integer into a series of two characters."><span class="u" id="1434499669.000040">2015:06:17 00:07:49       aengelberg </span><span>It isn&apos;t using any utility (unlike the clj version) to turn an oversized integer into a series of two characters.</span></div><div data-t="aengelberg The  get-char-combinator  function needs a rework, so ABNF terminals like  %x5D-10FFFF  can work."><span class="u" id="1434506978.000041">2015:06:17 02:09:38       aengelberg </span><span>The </span><code>get-char-combinator</code><span> function needs a rework, so ABNF terminals like </span><code>%x5D-10FFFF</code><span> can work.</span></div><div data-t="aengelberg JavaScript, unlike Java, does not seem to support regular expressions with  \x{10FFFF} ."><span class="u" id="1434507043.000042">2015:06:17 02:10:43       aengelberg </span><span>JavaScript, unlike Java, does not seem to support regular expressions with </span><code>\x{10FFFF}</code><span>.</span></div><div data-t="aengelberg In instaparse for Clojure, single characters are represented as a string combinator with the surrogate pair (two 16-bit chars side by side), and a character range uses the regex  \x{10FFF}  syntax. ClojureScript or JavaScript appear to not have much support for either of these things. It may be impossible to support Unicode character ranges in ABNF without introducing third-party js libraries."><span class="u" id="1434507204.000043">2015:06:17 02:13:24       aengelberg </span><span>In instaparse for Clojure, single characters are represented as a string combinator with the surrogate pair (two 16-bit chars side by side), and a character range uses the regex </span><code>\x{10FFF}</code><span> syntax. ClojureScript or JavaScript appear to not have much support for either of these things. It may be impossible to support Unicode character ranges in ABNF without introducing third-party js libraries.</span></div><div data-t="aengelberg OK, the former is doable via goog.i18n.uChar/fromCharCode."><span class="u" id="1434508812.000044">2015:06:17 02:40:12       aengelberg </span><span>OK, the former is doable via goog.i18n.uChar/fromCharCode.</span></div><div data-t="lucasbradstreet Nice! Yeah, this character support code is probably the weakest part of the port. "><span class="u" id="1434513826.000045">2015:06:17 04:03:46  lucasbradstreet </span><span>Nice! Yeah, this character support code is probably the weakest part of the port. </span></div><div data-t="lucasbradstreet I&apos;m glad that you&apos;re finding these issues. I had a feeling there were some lurking issues there."><span class="u" id="1434513878.000046">2015:06:17 04:04:38  lucasbradstreet </span><span>I&apos;m glad that you&apos;re finding these issues. I had a feeling there were some lurking issues there.</span></div><div data-t="aengelberg goog has some utils to work with surrogate strings, but the regex (char range) seems impossible without pulling in an external dependency like Regenerate.  https://github.com/mathiasbynens/regenerate"><span class="u" id="1434517003.000047">2015:06:17 04:56:43       aengelberg </span><span>goog has some utils to work with surrogate strings, but the regex (char range) seems impossible without pulling in an external dependency like Regenerate. </span><a href="https://github.com/mathiasbynens/regenerate">https://github.com/mathiasbynens/regenerate</a></div><div data-t="lucasbradstreet Ah, yeah, I think I’d rather recreate the functionality internally than pull in extra deps. Definitely a bit of a pain though."><span class="u" id="1434519918.000049">2015:06:17 05:45:18  lucasbradstreet </span><span>Ah, yeah, I think I’d rather recreate the functionality internally than pull in extra deps. Definitely a bit of a pain though.</span></div><div data-t="lucasbradstreet Interesting  https://mathiasbynens.be/notes/javascript-unicode"><span class="u" id="1434520044.000050">2015:06:17 05:47:24  lucasbradstreet </span><span>Interesting </span><a href="https://mathiasbynens.be/notes/javascript-unicode">https://mathiasbynens.be/notes/javascript-unicode</a></div><div data-t="lucasbradstreet I wonder if this issue is true for all browsers"><span class="u" id="1434520064.000051">2015:06:17 05:47:44  lucasbradstreet </span><span>I wonder if this issue is true for all browsers</span></div><div data-t="lucasbradstreet https://mathiasbynens.be/notes/es6-unicode-regex"><span class="u" id="1434520065.000052">2015:06:17 05:47:45  lucasbradstreet </span><a href="https://mathiasbynens.be/notes/es6-unicode-regex">https://mathiasbynens.be/notes/es6-unicode-regex</a></div><div data-t="lucasbradstreet Actually, if you could create a PR with a failing cljs test case that would be a good place to start"><span class="u" id="1434520129.000053">2015:06:17 05:48:49  lucasbradstreet </span><span>Actually, if you could create a PR with a failing cljs test case that would be a good place to start</span></div><div data-t="aengelberg https://github.com/lbradstreet/instaparse-cljs/pull/9"><span class="u" id="1434560441.000054">2015:06:17 17:00:41       aengelberg </span><a href="https://github.com/lbradstreet/instaparse-cljs/pull/9">https://github.com/lbradstreet/instaparse-cljs/pull/9</a></div><div data-t="aengelberg Hmm, now I&apos;m mildly concerned because circleci is passing... ;)"><span class="u" id="1434562897.000056">2015:06:17 17:41:37       aengelberg </span><span>Hmm, now I&apos;m mildly concerned because circleci is passing... ;)</span></div><div data-t="aengelberg Hmm, I think that&apos;s because there isn&apos;t really a notion of the cljs tests &quot;passing&quot; or &quot;failing&quot; (no exit codes)"><span class="u" id="1434563526.000057">2015:06:17 17:52:06       aengelberg </span><span>Hmm, I think that&apos;s because there isn&apos;t really a notion of the cljs tests &quot;passing&quot; or &quot;failing&quot; (no exit codes)</span></div><div data-t="lucasbradstreet @aengelberg: I gave you commit access to instaparse-cljs, feel free to push anything you want, or create PRs and I’ll review them"><span class="u" id="1434610056.000059">2015:06:18 06:47:36  lucasbradstreet </span><span>@aengelberg: I gave you commit access to instaparse-cljs, feel free to push anything you want, or create PRs and I’ll review them</span></div><div data-t="aengelberg Thanks @lucasbradstreet! I&apos;m working on some changes to clj instaparse that add special combinators for Unicode char ranges; it improves performance and makes it more portable to cljs."><span class="u" id="1434639795.000060">2015:06:18 15:03:15       aengelberg </span><span>Thanks @lucasbradstreet! I&apos;m working on some changes to clj instaparse that add special combinators for Unicode char ranges; it improves performance and makes it more portable to cljs.</span></div><div data-t="aengelberg @lucasbradstreet: have you considered using cljx for the instaparse source code as well, so it&apos;s easier to merge upstream changes?"><span class="u" id="1434680449.000062">2015:06:19 02:20:49       aengelberg </span><span>@lucasbradstreet: have you considered using cljx for the instaparse source code as well, so it&apos;s easier to merge upstream changes?</span></div><div data-t="lucasbradstreet Yes, that one is a bit of a trade off. There will definitely be more merge issues and it does kinda uglify the code a lot. It mostly depends on whether Mark would prefer separate cljs and clj, or cljx in an eventual upstream merge"><span class="u" id="1434680732.000063">2015:06:19 02:25:32  lucasbradstreet </span><span>Yes, that one is a bit of a trade off. There will definitely be more merge issues and it does kinda uglify the code a lot. It mostly depends on whether Mark would prefer separate cljs and clj, or cljx in an eventual upstream merge</span></div><div data-t="aengelberg I was thinking it might actually make it easier to merge upstream changes, because currently if a feature is changed in the clj version, it is quietly merged into the clj source without changing the cljs side at all."><span class="u" id="1434681165.000064">2015:06:19 02:32:45       aengelberg </span><span>I was thinking it might actually make it easier to merge upstream changes, because currently if a feature is changed in the clj version, it is quietly merged into the clj source without changing the cljs side at all.</span></div><div data-t="aengelberg [ANN] Instaparse 1.4.1  https://github.com/Engelberg/instaparse/blob/master/CHANGES.md#141"><span class="u" id="1435077246.000066">2015:06:23 16:34:06       aengelberg </span><span>[ANN] Instaparse 1.4.1 </span><a href="https://github.com/Engelberg/instaparse/blob/master/CHANGES.md#141">https://github.com/Engelberg/instaparse/blob/master/CHANGES.md#141</a></div><div data-t="aengelberg @lucasbradstreet: I&apos;ve started a  cljs-1.4.1  branch, that has the upstream commits merged in as well as a cljs port of the Unicode support (the unicode test case now passes!)"><span class="u" id="1435092584.000068">2015:06:23 20:49:44       aengelberg </span><span>@lucasbradstreet: I&apos;ve started a </span><code>cljs-1.4.1</code><span> branch, that has the upstream commits merged in as well as a cljs port of the Unicode support (the unicode test case now passes!)</span></div><div data-t="lucasbradstreet Nicely done!"><span class="u" id="1435111345.000069">2015:06:24 02:02:25  lucasbradstreet </span><span>Nicely done!</span></div><div data-t="lucasbradstreet @aengelberg: you&apos;re a machine!"><span class="u" id="1435123099.000070">2015:06:24 05:18:19  lucasbradstreet </span><span>@aengelberg: you&apos;re a machine!</span></div><div data-t="lucasbradstreet I&apos;ll review the PR. Assuming all is well, I&apos;ll push a new snapshot and we can get ready for a prod artefact "><span class="u" id="1435123163.000071">2015:06:24 05:19:23  lucasbradstreet </span><span>I&apos;ll review the PR. Assuming all is well, I&apos;ll push a new snapshot and we can get ready for a prod artefact </span></div><div data-t="aengelberg @lucasbradstreet: Thanks!"><span class="u" id="1435123478.000072">2015:06:24 05:24:38       aengelberg </span><span>@lucasbradstreet: Thanks!</span></div><div data-t="lucasbradstreet New 1.4.1.0-SNAPSHOT on clojars  simple_smile"><span class="u" id="1435124619.000073">2015:06:24 05:43:39  lucasbradstreet </span><span>New 1.4.1.0-SNAPSHOT on clojars </span><b>simple_smile</b></div><div data-t="lucasbradstreet I’ll push 1.4.1.0 to clojars once mhuebert gives the OK"><span class="u" id="1435124643.000074">2015:06:24 05:44:03  lucasbradstreet </span><span>I’ll push 1.4.1.0 to clojars once mhuebert gives the OK</span></div><div data-t="lucasbradstreet (or once we’ve got instaparse-live#8 figured out)"><span class="u" id="1435124660.000075">2015:06:24 05:44:20  lucasbradstreet </span><span>(or once we’ve got instaparse-live#8 figured out)</span></div><div data-t="lucasbradstreet It’s great that we’re in sync again"><span class="u" id="1435124678.000076">2015:06:24 05:44:38  lucasbradstreet </span><span>It’s great that we’re in sync again</span></div><div data-t="aengelberg Would recommend giving instaparse live &quot;the poop test&quot; a.k.a. insert  :shit:  at various places in the UI and see what breaks"><span class="u" id="1435124877.000077">2015:06:24 05:47:57       aengelberg </span><span>Would recommend giving instaparse live &quot;the poop test&quot; a.k.a. insert </span><b>:shit:</b><span> at various places in the UI and see what breaks</span></div><div data-t="aengelberg U+1F4A9"><span class="u" id="1435124914.000078">2015:06:24 05:48:34       aengelberg </span><span>U+1F4A9</span></div><div data-t="aengelberg (or any Unicode supplementary character, but poop is the most fun :D)"><span class="u" id="1435125044.000079">2015:06:24 05:50:44       aengelberg </span><span>(or any Unicode supplementary character, but poop is the most fun :D)</span></div><div data-t="aengelberg Yay, it works!  http://instaparse-live.matt.is/#/-JsdFiDFdOmHFG9kb6YZ"><span class="u" id="1435211420.000080">2015:06:25 05:50:20       aengelberg </span><span>Yay, it works! </span><a href="http://instaparse-live.matt.is/#/-JsdFiDFdOmHFG9kb6YZ">http://instaparse-live.matt.is/#/-JsdFiDFdOmHFG9kb6YZ</a></div><div data-t="lucasbradstreet sweet!"><span class="u" id="1435218578.000081">2015:06:25 07:49:38  lucasbradstreet </span><span>sweet!</span></div><div data-t="lucasbradstreet I’ll put out a release artifact then  simple_smile"><span class="u" id="1435218584.000082">2015:06:25 07:49:44  lucasbradstreet </span><span>I’ll put out a release artifact then </span><b>simple_smile</b></div><div data-t="lucasbradstreet 1.4.1.0 artifact is up  simple_smile"><span class="u" id="1435223779.000083">2015:06:25 09:16:19  lucasbradstreet </span><span>1.4.1.0 artifact is up </span><b>simple_smile</b></div><div data-t="lucasbradstreet Good work"><span class="u" id="1435223787.000084">2015:06:25 09:16:27  lucasbradstreet </span><span>Good work</span></div><div data-t="aengelberg Thanks for being responsive / receptive to my changes! Looking forward to getting feedback from users on the new version."><span class="u" id="1435248243.000085">2015:06:25 16:04:03       aengelberg </span><span>Thanks for being responsive / receptive to my changes! Looking forward to getting feedback from users on the new version.</span></div><div data-t="aengelberg cc @canweriotnow, unicode char ranges have now been restored to sanity  😄"><span class="u" id="1435248272.000086">2015:06:25 16:04:32       aengelberg </span><span>cc @canweriotnow, unicode char ranges have now been restored to sanity </span><b>😄</b></div><div data-t="aengelberg ABNF char ranges, that is. (unicode support is also there if needed)"><span class="u" id="1435248285.000087">2015:06:25 16:04:45       aengelberg </span><span>ABNF char ranges, that is. (unicode support is also there if needed)</span></div><div data-t="canweriotnow @aengelberg thx, awesome!"><span class="u" id="1435274039.000088">2015:06:25 23:13:59     canweriotnow </span><span>@aengelberg thx, awesome!</span></div><div data-t="lucasbradstreet @aengelberg: not a problem. I’m really happy the port is getting some use  simple_smile"><span class="u" id="1435297459.000089">2015:06:26 05:44:19  lucasbradstreet </span><span>@aengelberg: not a problem. I’m really happy the port is getting some use </span><b>simple_smile</b></div><div data-t="aengelberg I know, I&apos;m excited as well ;)"><span class="u" id="1435297548.000090">2015:06:26 05:45:48       aengelberg </span><span>I know, I&apos;m excited as well ;)</span></div><div data-t="marcofiset What are some approaches you guys use to interpret your parse tree?"><span class="u" id="1437513242.000003">2015:07:21 21:14:02       marcofiset </span><span>What are some approaches you guys use to interpret your parse tree?</span></div><div data-t="socksy you can use multimethods dispatching on node type"><span class="u" id="1437513739.000004">2015:07:21 21:22:19           socksy </span><span>you can use multimethods dispatching on node type</span></div><div data-t="socksy use a zipper to navigate the tree"><span class="u" id="1437513905.000005">2015:07:21 21:25:05           socksy </span><span>use a zipper to navigate the tree</span></div><div data-t="socksy or heck, just use  https://clojure.github.io/clojure/clojure.walk-api.html"><span class="u" id="1437514436.000006">2015:07:21 21:33:56           socksy </span><span>or heck, just use </span><a href="https://clojure.github.io/clojure/clojure.walk-api.html">https://clojure.github.io/clojure/clojure.walk-api.html</a></div><div data-t="socksy recommend using postwalk, and then writing a function to do whatever you’re thinking"><span class="u" id="1437514510.000007">2015:07:21 21:35:10           socksy </span><span>recommend using postwalk, and then writing a function to do whatever you’re thinking</span></div><div data-t="socksy depends on how you want to eval, it’s a wee bit harder for compilation, but not much. You just need to make sure you emit a string. One solution would be to treat it as a side effect of whatever function you use"><span class="u" id="1437514562.000008">2015:07:21 21:36:02           socksy </span><span>depends on how you want to eval, it’s a wee bit harder for compilation, but not much. You just need to make sure you emit a string. One solution would be to treat it as a side effect of whatever function you use</span></div><div data-t="socksy admittedly, when I last did this I wasn’t using an instaparse’d parse tree, so maybe the technique varies a bit"><span class="u" id="1437514604.000009">2015:07:21 21:36:44           socksy </span><span>admittedly, when I last did this I wasn’t using an instaparse’d parse tree, so maybe the technique varies a bit</span></div><div data-t="socksy think I re-implemented postwalk also"><span class="u" id="1437514623.000010">2015:07:21 21:37:03           socksy </span><span>think I re-implemented postwalk also</span></div><div data-t="socksy seems instaparse you could maybe just use insta/transform"><span class="u" id="1437514771.000011">2015:07:21 21:39:31           socksy </span><span>seems instaparse you could maybe just use insta/transform</span></div><div data-t="socksy which must do a walk of the tree, and takes a map of node type to function"><span class="u" id="1437514804.000012">2015:07:21 21:40:04           socksy </span><span>which must do a walk of the tree, and takes a map of node type to function</span></div><div data-t="aengelberg @marcofiset  insta/transform  has always been sufficient for my use cases. Is there more sophisticated functionality you&apos;re looking for? If so,  clojure.walk/[pre|post]walk  might be the next step up."><span class="u" id="1437516996.000013">2015:07:21 22:16:36       aengelberg </span><span>@marcofiset </span><code>insta/transform</code><span> has always been sufficient for my use cases. Is there more sophisticated functionality you&apos;re looking for? If so, </span><code>clojure.walk/[pre|post]walk</code><span> might be the next step up.</span></div><div data-t="marcofiset I am not looking for anything particular, just wanted to start a discussion on the subject. I&apos;m using multi methods for the moment and I was curious about what other people might be using. "><span class="u" id="1437517272.000014">2015:07:21 22:21:12       marcofiset </span><span>I am not looking for anything particular, just wanted to start a discussion on the subject. I&apos;m using multi methods for the moment and I was curious about what other people might be using. </span></div><div data-t="marcofiset I didn&apos;t know about insta/transform, I&apos;ll definitely take a look."><span class="u" id="1437517431.000015">2015:07:21 22:23:51       marcofiset </span><span>I didn&apos;t know about insta/transform, I&apos;ll definitely take a look.</span></div><div data-t="aengelberg Yeah,  instaparse.core/transform  is a simple function that does the trick for simple parse tree consumption."><span class="u" id="1437517505.000016">2015:07:21 22:25:05       aengelberg </span><span>Yeah, </span><code>instaparse.core/transform</code><span> is a simple function that does the trick for simple parse tree consumption.</span></div><div data-t="aengelberg Hey, that rhymes"><span class="u" id="1437517520.000017">2015:07:21 22:25:20       aengelberg </span><span>Hey, that rhymes</span></div><div data-t="aengelberg @marcofiset Take a look at this section of the readme:  https://github.com/engelberg/instaparse#transforming-the-tree"><span class="u" id="1437517550.000018">2015:07:21 22:25:50       aengelberg </span><span>@marcofiset Take a look at this section of the readme: </span><a href="https://github.com/engelberg/instaparse#transforming-the-tree">https://github.com/engelberg/instaparse#transforming-the-tree</a></div><div data-t="marcofiset Wow, I&apos;m really impressed with the arithmetic example! Very straightforward and simple. My multi methods solution is going to the trash and will be replaced by something similar  😃"><span class="u" id="1437518172.000020">2015:07:21 22:36:12       marcofiset </span><span>Wow, I&apos;m really impressed with the arithmetic example! Very straightforward and simple. My multi methods solution is going to the trash and will be replaced by something similar </span><b>😃</b></div><div data-t="marcofiset I’ve been noticing something with a new project using instaparse. It seems that everything I get out of the parser is wrapped in a list. I don’t recall having seen this behaviour before. Can someone enlighten me?  simple_smile"><span class="u" id="1437564004.000021">2015:07:22 11:20:04       marcofiset </span><span>I’ve been noticing something with a new project using instaparse. It seems that everything I get out of the parser is wrapped in a list. I don’t recall having seen this behaviour before. Can someone enlighten me? </span><b>simple_smile</b></div><div data-t="marcofiset After a couple of quick tests, it seems to be my particular grammar that causes this, but I&apos;m not sure why."><span class="u" id="1437566567.000022">2015:07:22 12:02:47       marcofiset </span><span>After a couple of quick tests, it seems to be my particular grammar that causes this, but I&apos;m not sure why.</span></div><div data-t="aengelberg @marcofiset: are you hiding the root tag (`&lt;S&gt; = ...`)? If so, this is by design as explained in this section of the readme:  https://github.com/engelberg/instaparse#hiding-tags"><span class="u" id="1437582944.000023">2015:07:22 16:35:44       aengelberg </span><span>@marcofiset: are you hiding the root tag (`&lt;S&gt; = ...`)? If so, this is by design as explained in this section of the readme: </span><a href="https://github.com/engelberg/instaparse#hiding-tags">https://github.com/engelberg/instaparse#hiding-tags</a></div><div data-t="marcofiset You&apos;re right, that was it."><span class="u" id="1437597114.000025">2015:07:22 20:31:54       marcofiset </span><span>You&apos;re right, that was it.</span></div><div data-t="marcofiset I decided not to ignore it instead, and introduced a hidden sub-expression which handles the recursivity."><span class="u" id="1437597153.000026">2015:07:22 20:32:33       marcofiset </span><span>I decided not to ignore it instead, and introduced a hidden sub-expression which handles the recursivity.</span></div><div data-t="micha hello everyone, is there a grammar for clojure source that i can use in instaparse?"><span class="u" id="1438909199.000028">2015:08:07 00:59:59            micha </span><span>hello everyone, is there a grammar for clojure source that i can use in instaparse?</span></div><div data-t="micha or EDN would probably work in a pinch too"><span class="u" id="1438909233.000029">2015:08:07 01:00:33            micha </span><span>or EDN would probably work in a pinch too</span></div><div data-t="aengelberg Not that I know of. Maybe this would help, you could port the ANTLR grammar into EBNF somehow  https://stackoverflow.com/questions/3902813/is-there-a-language-spec-for-clojure"><span class="u" id="1438909483.000030">2015:08:07 01:04:43       aengelberg </span><span>Not that I know of. Maybe this would help, you could port the ANTLR grammar into EBNF somehow </span><a href="https://stackoverflow.com/questions/3902813/is-there-a-language-spec-for-clojure">https://stackoverflow.com/questions/3902813/is-there-a-language-spec-for-clojure</a></div><div data-t="aengelberg Although an EDN parser wouldn&apos;t be too hard to make from scratch. It&apos;s mostly balanced parens with various types of leafs or delimiters. The hard part is strings, handling all the  \&quot;  stuff"><span class="u" id="1438909609.000032">2015:08:07 01:06:49       aengelberg </span><span>Although an EDN parser wouldn&apos;t be too hard to make from scratch. It&apos;s mostly balanced parens with various types of leafs or delimiters. The hard part is strings, handling all the </span><code>\&quot;</code><span> stuff</span></div><div data-t="aengelberg And comments"><span class="u" id="1438909642.000033">2015:08:07 01:07:22       aengelberg </span><span>And comments</span></div><div data-t="micha yeah i was thinking that also, really i just need curly braces, because i only want to parse maps"><span class="u" id="1438909651.000034">2015:08:07 01:07:31            micha </span><span>yeah i was thinking that also, really i just need curly braces, because i only want to parse maps</span></div><div data-t="micha but curlies can appear in strings"><span class="u" id="1438909669.000036">2015:08:07 01:07:49            micha </span><span>but curlies can appear in strings</span></div><div data-t="aengelberg Maps with no lists / sets as keys or values?"><span class="u" id="1438909671.000037">2015:08:07 01:07:51       aengelberg </span><span>Maps with no lists / sets as keys or values?</span></div><div data-t="micha yeah the map can contain anything, but i can presumably slurp that in and just look for the matching curly"><span class="u" id="1438909715.000038">2015:08:07 01:08:35            micha </span><span>yeah the map can contain anything, but i can presumably slurp that in and just look for the matching curly</span></div><div data-t="aengelberg If you get the string terminal right, Instaparse will be smart about closing parens even if parens appear within the string"><span class="u" id="1438909736.000039">2015:08:07 01:08:56       aengelberg </span><span>If you get the string terminal right, Instaparse will be smart about closing parens even if parens appear within the string</span></div><div data-t="micha how about indentation-based languages?"><span class="u" id="1438909780.000040">2015:08:07 01:09:40            micha </span><span>how about indentation-based languages?</span></div><div data-t="aengelberg ehhhhhh"><span class="u" id="1438909787.000041">2015:08:07 01:09:47       aengelberg </span><span>ehhhhhh</span></div><div data-t="micha haha yeah"><span class="u" id="1438909853.000042">2015:08:07 01:10:53            micha </span><span>haha yeah</span></div><div data-t="aengelberg &quot;You&apos;re thinking in the wrong mindset&quot;  https://imgur.com/gallery/M5wl14r"><span class="u" id="1438909873.000043">2015:08:07 01:11:13       aengelberg </span><span>&quot;You&apos;re thinking in the wrong mindset&quot; </span><a href="https://imgur.com/gallery/M5wl14r">https://imgur.com/gallery/M5wl14r</a></div><div data-t="micha hahahaha excellent reference there"><span class="u" id="1438909932.000045">2015:08:07 01:12:12            micha </span><span>hahahaha excellent reference there</span></div><div data-t="micha the project i&apos;m working on is a generalized, abstract sort of markdown"><span class="u" id="1438909960.000046">2015:08:07 01:12:40            micha </span><span>the project i&apos;m working on is a generalized, abstract sort of markdown</span></div><div data-t="micha it&apos;s designed to mix well with prose, so indentation based structure is a big win"><span class="u" id="1438909991.000047">2015:08:07 01:13:11            micha </span><span>it&apos;s designed to mix well with prose, so indentation based structure is a big win</span></div><div data-t="aengelberg So like, prose at the top level, important stuff indented?"><span class="u" id="1438910057.000048">2015:08:07 01:14:17       aengelberg </span><span>So like, prose at the top level, important stuff indented?</span></div><div data-t="micha # This is line 1 of a certain type of block.
  The block continues here because of the indentation.

* This could be a list item

  p With a paragraph in it
    that continues on multiple lines...and
    has a strange #(inline something or other
    delimited by hash-parens)#...

  ~~~{:foo &quot;bar&quot;, :baz 123} tags can also have
    attributes parsed as EDN...

* here is the next list item
"><span class="u" id="1438910222.000049">2015:08:07 01:17:02            micha </span><pre># This is line 1 of a certain type of block.
  The block continues here because of the indentation.

* This could be a list item

  p With a paragraph in it
    that continues on multiple lines...and
    has a strange #(inline something or other
    delimited by hash-parens)#...

  ~~~{:foo &quot;bar&quot;, :baz 123} tags can also have
    attributes parsed as EDN...

* here is the next list item
</pre></div><div data-t="micha there we go"><span class="u" id="1438910292.000052">2015:08:07 01:18:12            micha </span><span>there we go</span></div><div data-t="micha the parser will be a macro really"><span class="u" id="1438910300.000053">2015:08:07 01:18:20            micha </span><span>the parser will be a macro really</span></div><div data-t="micha it will emit s-expressions"><span class="u" id="1438910307.000054">2015:08:07 01:18:27            micha </span><span>it will emit s-expressions</span></div><div data-t="micha calling multimethods"><span class="u" id="1438910315.000055">2015:08:07 01:18:35            micha </span><span>calling multimethods</span></div><div data-t="micha so you can implement dispatches for any tags you like"><span class="u" id="1438910329.000056">2015:08:07 01:18:49            micha </span><span>so you can implement dispatches for any tags you like</span></div><div data-t="micha so what  # foo  means is up to you"><span class="u" id="1438910350.000057">2015:08:07 01:19:10            micha </span><span>so what </span><code># foo</code><span> means is up to you</span></div><div data-t="micha the indentation is crucial for making the thing general without special cases and hardcoded things"><span class="u" id="1438910397.000058">2015:08:07 01:19:57            micha </span><span>the indentation is crucial for making the thing general without special cases and hardcoded things</span></div><div data-t="aengelberg The reason &quot;ehhhh&quot; is the visceral response to indentation based langs in instaparse is because in CFGs it&apos;s difficult if not impossible to remember how many spaces / tabs you&apos;re looking for on each line."><span class="u" id="1438910433.000059">2015:08:07 01:20:33       aengelberg </span><span>The reason &quot;ehhhh&quot; is the visceral response to indentation based langs in instaparse is because in CFGs it&apos;s difficult if not impossible to remember how many spaces / tabs you&apos;re looking for on each line.</span></div><div data-t="aengelberg So it&apos;s really only a problem if you have chunks within chunks that are indented even more."><span class="u" id="1438910455.000060">2015:08:07 01:20:55       aengelberg </span><span>So it&apos;s really only a problem if you have chunks within chunks that are indented even more.</span></div><div data-t="micha yeah, and i want to support even more tricky things, like indentation plus extra whitespace at the front of the line"><span class="u" id="1438910480.000061">2015:08:07 01:21:20            micha </span><span>yeah, and i want to support even more tricky things, like indentation plus extra whitespace at the front of the line</span></div><div data-t="micha i have a naive handmade parser now to parse the blocks"><span class="u" id="1438910497.000062">2015:08:07 01:21:37            micha </span><span>i have a naive handmade parser now to parse the blocks</span></div><div data-t="micha it looks for tags that can start a block"><span class="u" id="1438910512.000063">2015:08:07 01:21:52            micha </span><span>it looks for tags that can start a block</span></div><div data-t="micha then it looks for the &quot;outdent&quot;"><span class="u" id="1438910520.000064">2015:08:07 01:22:00            micha </span><span>then it looks for the &quot;outdent&quot;</span></div><div data-t="micha so it doesn&apos;t look for a specific amount of indentation"><span class="u" id="1438910531.000065">2015:08:07 01:22:11            micha </span><span>so it doesn&apos;t look for a specific amount of indentation</span></div><div data-t="aengelberg Example?"><span class="u" id="1438910547.000066">2015:08:07 01:22:27       aengelberg </span><span>Example?</span></div><div data-t="micha it looks for a minimum amount of indentation, but you can use more"><span class="u" id="1438910554.000067">2015:08:07 01:22:34            micha </span><span>it looks for a minimum amount of indentation, but you can use more</span></div><div data-t="micha # This is all
  part of the
    same block
  and the next
  block
    doesnt
      start until the
  an &quot;outdent&quot; is seen

This is an outdent, so
the above block will 
have been ended.
"><span class="u" id="1438910640.000068">2015:08:07 01:24:00            micha </span><pre># This is all
  part of the
    same block
  and the next
  block
    doesnt
      start until the
  an &quot;outdent&quot; is seen

This is an outdent, so
the above block will 
have been ended.
</pre></div><div data-t="micha however,"><span class="u" id="1438910674.000069">2015:08:07 01:24:34            micha </span><span>however,</span></div><div data-t="micha # This is not
  all part of the same
  # block because this
    tag creates a nested
    block
"><span class="u" id="1438910727.000070">2015:08:07 01:25:27            micha </span><pre># This is not
  all part of the same
  # block because this
    tag creates a nested
    block
</pre></div><div data-t="aengelberg Hmm, what if you parse each block and then run the parser AGAIN on the text in the block to find subblocks?"><span class="u" id="1438910815.000071">2015:08:07 01:26:55       aengelberg </span><span>Hmm, what if you parse each block and then run the parser AGAIN on the text in the block to find subblocks?</span></div><div data-t="micha hm"><span class="u" id="1438910832.000072">2015:08:07 01:27:12            micha </span><span>hm</span></div><div data-t="micha i think i could give up the leading extra spaces thing, too"><span class="u" id="1438910866.000073">2015:08:07 01:27:46            micha </span><span>i think i could give up the leading extra spaces thing, too</span></div><div data-t="micha and set indentation to some configurable fixed size"><span class="u" id="1438910884.000074">2015:08:07 01:28:04            micha </span><span>and set indentation to some configurable fixed size</span></div><div data-t="aengelberg (my-parser text) =&gt; ([:block &quot;This is not&quot; &quot;all part of the same&quot; &quot;# block because this&quot; &quot;   tag ...&quot;])
(insta/transform *1 {:block (fn [&amp; strs] (my-parser (str/join &quot;\n&quot; strs)))})
"><span class="u" id="1438910904.000075">2015:08:07 01:28:24       aengelberg </span><pre>(my-parser text) =&gt; ([:block &quot;This is not&quot; &quot;all part of the same&quot; &quot;# block because this&quot; &quot;   tag ...&quot;])
(insta/transform *1 {:block (fn [&amp; strs] (my-parser (str/join &quot;\n&quot; strs)))})
</pre></div><div data-t="aengelberg Except recursively smarter"><span class="u" id="1438910930.000077">2015:08:07 01:28:50       aengelberg </span><span>Except recursively smarter</span></div><div data-t="micha interesting"><span class="u" id="1438910939.000078">2015:08:07 01:28:59            micha </span><span>interesting</span></div><div data-t="aengelberg I just thought of this, it might end up being impractical."><span class="u" id="1438910951.000079">2015:08:07 01:29:11       aengelberg </span><span>I just thought of this, it might end up being impractical.</span></div><div data-t="aengelberg But that might be the way to do it."><span class="u" id="1438910960.000080">2015:08:07 01:29:20       aengelberg </span><span>But that might be the way to do it.</span></div><div data-t="micha i will play around with it and let you know how it works out"><span class="u" id="1438911021.000081">2015:08:07 01:30:21            micha </span><span>i will play around with it and let you know how it works out</span></div><div data-t="micha i can at least instaparse the inline stuff, if not the blocks"><span class="u" id="1438911047.000082">2015:08:07 01:30:47            micha </span><span>i can at least instaparse the inline stuff, if not the blocks</span></div><div data-t="aengelberg True"><span class="u" id="1438911139.000083">2015:08:07 01:32:19       aengelberg </span><span>True</span></div><div data-t="aengelberg Anyway, now that I think about it, this trick may be applicable to any indentation-based language"><span class="u" id="1438911170.000084">2015:08:07 01:32:50       aengelberg </span><span>Anyway, now that I think about it, this trick may be applicable to any indentation-based language</span></div><div data-t="micha it&apos;s also an interesting case because i need to parse &quot;any character that isn&apos;t a tag&quot;"><span class="u" id="1438911250.000085">2015:08:07 01:34:10            micha </span><span>it&apos;s also an interesting case because i need to parse &quot;any character that isn&apos;t a tag&quot;</span></div><div data-t="micha like the text in between tags"><span class="u" id="1438911261.000086">2015:08:07 01:34:21            micha </span><span>like the text in between tags</span></div><div data-t="micha i think i can use negative lookahead with regex like  #&quot;.&quot;"><span class="u" id="1438911285.000087">2015:08:07 01:34:45            micha </span><span>i think i can use negative lookahead with regex like </span><code>#&quot;.&quot;</code></div><div data-t="micha anyway thanks for the help! i&apos;ll let you know how it all works out"><span class="u" id="1438911347.000088">2015:08:07 01:35:47            micha </span><span>anyway thanks for the help! i&apos;ll let you know how it all works out</span></div><div data-t="aengelberg No problem, I&apos;d love to hear how it goes"><span class="u" id="1438911576.000089">2015:08:07 01:39:36       aengelberg </span><span>No problem, I&apos;d love to hear how it goes</span></div><div data-t="micha @aengelberg: made some progress this weekend with my instaparse project!  https://github.com/adzerk-oss/zerkdown"><span class="u" id="1439821846.000092">2015:08:17 14:30:46            micha </span><span>@aengelberg: made some progress this weekend with my instaparse project! </span><a href="https://github.com/adzerk-oss/zerkdown">https://github.com/adzerk-oss/zerkdown</a></div><div data-t="micha it&apos;s a work in progress of course"><span class="u" id="1439821888.000094">2015:08:17 14:31:28            micha </span><span>it&apos;s a work in progress of course</span></div><div data-t="micha it does a braindead parsing of clojure maps/vectors"><span class="u" id="1439821914.000095">2015:08:17 14:31:54            micha </span><span>it does a braindead parsing of clojure maps/vectors</span></div><div data-t="micha https://github.com/adzerk-oss/zerkdown/blob/master/src/adzerk/zerkdown/grammar.ebnf"><span class="u" id="1439821934.000096">2015:08:17 14:32:14            micha </span><a href="https://github.com/adzerk-oss/zerkdown/blob/master/src/adzerk/zerkdown/grammar.ebnf">https://github.com/adzerk-oss/zerkdown/blob/master/src/adzerk/zerkdown/grammar.ebnf</a></div><div data-t="micha feedback appreciated  simple_smile"><span class="u" id="1439821959.000097">2015:08:17 14:32:39            micha </span><span>feedback appreciated </span><b>simple_smile</b></div><div data-t="aengelberg @micha this project is very cool"><span class="u" id="1439842701.000098">2015:08:17 20:18:21       aengelberg </span><span>@micha this project is very cool</span></div><div data-t="aengelberg Does your ebnf allow  [{] ?"><span class="u" id="1439842724.000099">2015:08:17 20:18:44       aengelberg </span><span>Does your ebnf allow </span><code>[{]</code><span>?</span></div><div data-t="micha not in a  :CLJ  or  :VEC  block"><span class="u" id="1439842755.000100">2015:08:17 20:19:15            micha </span><span>not in a </span><code>:CLJ</code><span> or </span><code>:VEC</code><span> block</span></div><div data-t="micha [&quot;{&quot;]  would be ok though"><span class="u" id="1439842771.000101">2015:08:17 20:19:31            micha </span><code>[&quot;{&quot;]</code><span> would be ok though</span></div><div data-t="aengelberg &lt;VEC-CHAR&gt;              = !(LSB | RSB | DQ) ANY-CHAR  looks like it would allow mismatched map delimiters inside it"><span class="u" id="1439842805.000102">2015:08:17 20:20:05       aengelberg </span><code>&lt;VEC-CHAR&gt;              = !(LSB | RSB | DQ) ANY-CHAR</code><span> looks like it would allow mismatched map delimiters inside it</span></div><div data-t="micha oh interesting"><span class="u" id="1439842832.000103">2015:08:17 20:20:32            micha </span><span>oh interesting</span></div><div data-t="micha yeah it&apos;s ambiguous"><span class="u" id="1439842852.000104">2015:08:17 20:20:52            micha </span><span>yeah it&apos;s ambiguous</span></div><div data-t="micha !(LSB | RSB | STRING | MAP) ANY-CHAR  would be nice there"><span class="u" id="1439842884.000105">2015:08:17 20:21:24            micha </span><code>!(LSB | RSB | STRING | MAP) ANY-CHAR</code><span> would be nice there</span></div><div data-t="aengelberg then it would still allow mismatched quotes and delimiters because strings and maps don&apos;t successfully parse  simple_smile"><span class="u" id="1439842920.000106">2015:08:17 20:22:00       aengelberg </span><span>then it would still allow mismatched quotes and delimiters because strings and maps don&apos;t successfully parse </span><b>simple_smile</b></div><div data-t="micha hmm"><span class="u" id="1439842956.000107">2015:08:17 20:22:36            micha </span><span>hmm</span></div><div data-t="aengelberg maybe  (!(LSB | RSB | LCB | RCB | DQ) ANY-CHAR) | STRING | CLJ"><span class="u" id="1439842997.000108">2015:08:17 20:23:17       aengelberg </span><span>maybe </span><code>(!(LSB | RSB | LCB | RCB | DQ) ANY-CHAR) | STRING | CLJ</code></div><div data-t="micha yeah"><span class="u" id="1439843004.000109">2015:08:17 20:23:24            micha </span><span>yeah</span></div><div data-t="micha i will try that"><span class="u" id="1439843022.000110">2015:08:17 20:23:42            micha </span><span>i will try that</span></div><div data-t="micha i am planning to do the recursion from clojure btw"><span class="u" id="1439843034.000111">2015:08:17 20:23:54            micha </span><span>i am planning to do the recursion from clojure btw</span></div><div data-t="micha i will parse one level of indentation, then for each  :BLOCK  call insta again on the body"><span class="u" id="1439843064.000112">2015:08:17 20:24:24            micha </span><span>i will parse one level of indentation, then for each </span><code>:BLOCK</code><span> call insta again on the body</span></div><div data-t="micha it seems like it will be straightforward, i hope"><span class="u" id="1439843110.000113">2015:08:17 20:25:10            micha </span><span>it seems like it will be straightforward, i hope</span></div><div data-t="aengelberg cool"><span class="u" id="1439843122.000114">2015:08:17 20:25:22       aengelberg </span><span>cool</span></div><div data-t="aengelberg Just make sure instaparse Failures are returned / shortcircuited properly  simple_smile"><span class="u" id="1439843163.000115">2015:08:17 20:26:03       aengelberg </span><span>Just make sure instaparse Failures are returned / shortcircuited properly </span><b>simple_smile</b></div><div data-t="micha how do you mean?"><span class="u" id="1439843188.000116">2015:08:17 20:26:28            micha </span><span>how do you mean?</span></div><div data-t="aengelberg if a &quot;sub-parse&quot; returns a failure, then what?"><span class="u" id="1439843211.000117">2015:08:17 20:26:51       aengelberg </span><span>if a &quot;sub-parse&quot; returns a failure, then what?</span></div><div data-t="aengelberg I imagine it will be most idiomatic to call  insta/parse  again within the transformer. But my point is, if a parse failure arises (malformed zerkdown) within that, you will need to propagate that error properly  simple_smile"><span class="u" id="1439843383.000118">2015:08:17 20:29:43       aengelberg </span><span>I imagine it will be most idiomatic to call </span><code>insta/parse</code><span> again within the transformer. But my point is, if a parse failure arises (malformed zerkdown) within that, you will need to propagate that error properly </span><b>simple_smile</b></div><div data-t="micha ah right"><span class="u" id="1439843520.000119">2015:08:17 20:32:00            micha </span><span>ah right</span></div><div data-t="micha what did you mean before about strings and maps not successfully parsing?"><span class="u" id="1439843558.000120">2015:08:17 20:32:38            micha </span><span>what did you mean before about strings and maps not successfully parsing?</span></div><div data-t="aengelberg negative lookahead = make sure this thing does not successfully parse"><span class="u" id="1439843623.000121">2015:08:17 20:33:43       aengelberg </span><span>negative lookahead = make sure this thing does not successfully parse</span></div><div data-t="aengelberg !STRING x  means no &quot;complete well-formed strings&quot; allowed, but you probably wanted &quot;no double-quotes of any kind really&quot;"><span class="u" id="1439843831.000122">2015:08:17 20:37:11       aengelberg </span><code>!STRING x</code><span> means no &quot;complete well-formed strings&quot; allowed, but you probably wanted &quot;no double-quotes of any kind really&quot;</span></div><div data-t="aengelberg and then you can add in  | STRING  to allow well-formed strings"><span class="u" id="1439844084.000123">2015:08:17 20:41:24       aengelberg </span><span>and then you can add in </span><code>| STRING</code><span> to allow well-formed strings</span></div><div data-t="micha oh i see"><span class="u" id="1439844643.000124">2015:08:17 20:50:43            micha </span><span>oh i see</span></div><div data-t="micha i actually don&apos;t care about double quotes"><span class="u" id="1439844651.000125">2015:08:17 20:50:51            micha </span><span>i actually don&apos;t care about double quotes</span></div><div data-t="micha i just don&apos;t want well formed strings, because those can legitimately contain {}[] etc"><span class="u" id="1439844670.000126">2015:08:17 20:51:10            micha </span><span>i just don&apos;t want well formed strings, because those can legitimately contain {}[] etc</span></div><div data-t="micha i&apos;m not trying to fully parse the clojure data, i just need to know where it ends"><span class="u" id="1439844699.000127">2015:08:17 20:51:39            micha </span><span>i&apos;m not trying to fully parse the clojure data, i just need to know where it ends</span></div><div data-t="micha i send it as a string and use  clojure.core/read-string  on it later"><span class="u" id="1439844719.000128">2015:08:17 20:51:59            micha </span><span>i send it as a string and use </span><code>clojure.core/read-string</code><span> on it later</span></div><div data-t="aengelberg that&apos;s fair, but if  [{]}]  is allowed it&apos;s not exactly obvious where it ends  simple_smile"><span class="u" id="1439844740.000129">2015:08:17 20:52:20       aengelberg </span><span>that&apos;s fair, but if </span><code>[{]}]</code><span> is allowed it&apos;s not exactly obvious where it ends </span><b>simple_smile</b></div><div data-t="micha haha yes"><span class="u" id="1439844753.000130">2015:08:17 20:52:33            micha </span><span>haha yes</span></div><div data-t="micha very interesting"><span class="u" id="1439844801.000131">2015:08:17 20:53:21            micha </span><span>very interesting</span></div><div data-t="aengelberg anyway I don&apos;t think it&apos;s super hard to make the delimiters correct.  (!(LSB | RSB | LCB | RCB | DQ) ANY-CHAR) | STRING | CLJ"><span class="u" id="1439844809.000132">2015:08:17 20:53:29       aengelberg </span><span>anyway I don&apos;t think it&apos;s super hard to make the delimiters correct. </span><code>(!(LSB | RSB | LCB | RCB | DQ) ANY-CHAR) | STRING | CLJ</code></div><div data-t="aengelberg That basically says &quot;no double-quotes, UNLESS there is a well formed string&quot;"><span class="u" id="1439844820.000133">2015:08:17 20:53:40       aengelberg </span><span>That basically says &quot;no double-quotes, UNLESS there is a well formed string&quot;</span></div><div data-t="micha yes that&apos;s awesome"><span class="u" id="1439844848.000134">2015:08:17 20:54:08            micha </span><span>yes that&apos;s awesome</span></div><div data-t="micha testing was pretty easy to do, by configuring with different start rules"><span class="u" id="1439844876.000135">2015:08:17 20:54:36            micha </span><span>testing was pretty easy to do, by configuring with different start rules</span></div><div data-t="aengelberg yeah. just don&apos;t forget negative testing  simple_smile"><span class="u" id="1439844895.000136">2015:08:17 20:54:55       aengelberg </span><span>yeah. just don&apos;t forget negative testing </span><b>simple_smile</b></div><div data-t="micha ah right"><span class="u" id="1439844910.000137">2015:08:17 20:55:10            micha </span><span>ah right</span></div><div data-t="micha yeah i didn&apos;t think of that"><span class="u" id="1439844919.000138">2015:08:17 20:55:19            micha </span><span>yeah i didn&apos;t think of that</span></div><div data-t="aengelberg really cool idea. what is the intended use case for zerkdown?"><span class="u" id="1439845033.000139">2015:08:17 20:57:13       aengelberg </span><span>really cool idea. what is the intended use case for zerkdown?</span></div><div data-t="micha well i want to use it for just about everything!"><span class="u" id="1439846216.000140">2015:08:17 21:16:56            micha </span><span>well i want to use it for just about everything!</span></div><div data-t="micha mostly for websites"><span class="u" id="1439846222.000141">2015:08:17 21:17:02            micha </span><span>mostly for websites</span></div><div data-t="micha but i can imagine using it for literate programming and things like that"><span class="u" id="1439846234.000142">2015:08:17 21:17:14            micha </span><span>but i can imagine using it for literate programming and things like that</span></div><div data-t="micha but for making webapps it&apos;s really nice to have a &quot;prose&quot; syntax you can customize for your use case"><span class="u" id="1439846272.000143">2015:08:17 21:17:52            micha </span><span>but for making webapps it&apos;s really nice to have a &quot;prose&quot; syntax you can customize for your use case</span></div><div data-t="micha like normally you have like
 # My Title
 
that compiles down to
 &lt;h1&gt;My Title&lt;/h1&gt;
"><span class="u" id="1439846317.000144">2015:08:17 21:18:37            micha </span><span>like normally you have like
</span><pre># My Title
</pre><span>
that compiles down to
</span><pre>&lt;h1&gt;My Title&lt;/h1&gt;
</pre></div><div data-t="micha but what if you need something like
 &lt;h1&gt;My Title &lt;small&gt;The Best Thing Ever&lt;/small&gt;&lt;/h1&gt;
 
i want to be able to just define a new inline tag for that, like
 # My Title &lt;&lt;The Best Thing Ever&gt;&gt;
"><span class="u" id="1439846421.000145">2015:08:17 21:20:21            micha </span><span>but what if you need something like
</span><pre>&lt;h1&gt;My Title &lt;small&gt;The Best Thing Ever&lt;/small&gt;&lt;/h1&gt;
</pre><span>
i want to be able to just define a new inline tag for that, like
</span><pre># My Title &lt;&lt;The Best Thing Ever&gt;&gt;
</pre></div><div data-t="micha or even more complex things with behavior and everything, like forms and buttons"><span class="u" id="1439846438.000146">2015:08:17 21:20:38            micha </span><span>or even more complex things with behavior and everything, like forms and buttons</span></div><div data-t="micha i got the recursive parser construction working! one weird trick instaparse doesn&apos;t want you to know about...  https://github.com/adzerk-oss/zerkdown/blob/master/src/adzerk/zerkdown/parser.clj#L48-L60"><span class="u" id="1439901225.000147">2015:08:18 12:33:45            micha </span><span>i got the recursive parser construction working! one weird trick instaparse doesn&apos;t want you to know about... </span><a href="https://github.com/adzerk-oss/zerkdown/blob/master/src/adzerk/zerkdown/parser.clj#L48-L60">https://github.com/adzerk-oss/zerkdown/blob/master/src/adzerk/zerkdown/parser.clj#L48-L60</a></div><div data-t="aengelberg A programmer used this one weird trick to handle indented languages... click here to see what! (Lexer-based libraries HATE this!)"><span class="u" id="1439910588.000150">2015:08:18 15:09:48       aengelberg </span><span>A programmer used this one weird trick to handle indented languages... click here to see what! (Lexer-based libraries HATE this!)</span></div><div data-t="nodename I’m having a little trouble with a simple parser:"><span class="u" id="1440630015.000003">2015:08:26 23:00:15         nodename </span><span>I’m having a little trouble with a simple parser:</span></div><div data-t="nodename (def exp-parser
  (insta/parser
    &quot;S = Sexp
    Sexp = Term | &apos;(&apos; Term* &apos;)&apos;
    Term = Char+
    Char = #&apos;[a-z]&apos;&quot;))"><span class="u" id="1440630019.000004">2015:08:26 23:00:19         nodename </span><span>(def exp-parser
  (insta/parser
    &quot;S = Sexp
    Sexp = Term | &apos;(&apos; Term* &apos;)&apos;
    Term = Char+
    Char = #&apos;[a-z]&apos;&quot;))</span></div><div data-t="nodename user=&gt; (exp-parser &quot;(hi)&quot;)
[:S [:Sexp &quot;(&quot; [:Term [:Char &quot;h&quot;]] [:Term [:Char &quot;i&quot;]] &quot;)&quot;]]
I thought the Char+ would make “hi” a single Term..."><span class="u" id="1440630070.000005">2015:08:26 23:01:10         nodename </span><span>user=&gt; (exp-parser &quot;(hi)&quot;)
[:S [:Sexp &quot;(&quot; [:Term [:Char &quot;h&quot;]] [:Term [:Char &quot;i&quot;]] &quot;)&quot;]]
I thought the Char+ would make “hi” a single Term...</span></div><div data-t="ska @nodename: One Char is a character from the range given in the regexp.  You allow many Chars with the +.  Maybe you want Term = Char"><span class="u" id="1440660658.000006">2015:08:27 07:30:58              ska </span><span>@nodename: One Char is a character from the range given in the regexp.  You allow many Chars with the +.  Maybe you want Term = Char</span></div><div data-t="ska Char = #&apos;[a-z]+&apos;"><span class="u" id="1440660674.000007">2015:08:27 07:31:14              ska </span><span>Char = #&apos;[a-z]+&apos;</span></div><div data-t="ska So that the regexp eats the characters.  Of course then &quot;Char&quot; is not a really good name anymore and might become sth like Symbol or Name"><span class="u" id="1440660723.000008">2015:08:27 07:32:03              ska </span><span>So that the regexp eats the characters.  Of course then &quot;Char&quot; is not a really good name anymore and might become sth like Symbol or Name</span></div><div data-t="nodename Yes, that works, but I expected what I had to work too. Don’t see why not."><span class="u" id="1440660777.000009">2015:08:27 07:32:57         nodename </span><span>Yes, that works, but I expected what I had to work too. Don’t see why not.</span></div><div data-t="ska It actually does that, it&apos;s just not the first result.  Your grammar is ambiguous.  See the result of insta/parses"><span class="u" id="1440661797.000010">2015:08:27 07:49:57              ska </span><span>It actually does that, it&apos;s just not the first result.  Your grammar is ambiguous.  See the result of insta/parses</span></div><div data-t="ska The reason is, that + in instaparse is not greedy but allows all possible paths whereas + in the regexp would be greedy"><span class="u" id="1440661825.000011">2015:08:27 07:50:25              ska </span><span>The reason is, that + in instaparse is not greedy but allows all possible paths whereas + in the regexp would be greedy</span></div><div data-t="nodename Ah, thanks. Do you know how I could modify Term to make it greedy?"><span class="u" id="1440661892.000012">2015:08:27 07:51:32         nodename </span><span>Ah, thanks. Do you know how I could modify Term to make it greedy?</span></div><div data-t="ska My approach would be to use the regexp mentioned above.  To me that is kinda the tokenization step in instaparse.  I don&apos;t know if other solutions exists from the top off my head"><span class="u" id="1440661987.000013">2015:08:27 07:53:07              ska </span><span>My approach would be to use the regexp mentioned above.  To me that is kinda the tokenization step in instaparse.  I don&apos;t know if other solutions exists from the top off my head</span></div><div data-t="ska Looks like I tried that already and came to the conclusion that there is no other way:  https://github.com/ska2342/sourcetalk14/blob/master/de.skamphausen.stt14/src/de/skamphausen/stt14.clj#L460"><span class="u" id="1440662063.000014">2015:08:27 07:54:23              ska </span><span>Looks like I tried that already and came to the conclusion that there is no other way: </span><a href="https://github.com/ska2342/sourcetalk14/blob/master/de.skamphausen.stt14/src/de/skamphausen/stt14.clj#L460">https://github.com/ska2342/sourcetalk14/blob/master/de.skamphausen.stt14/src/de/skamphausen/stt14.clj#L460</a></div><div data-t="nodename Ha, OK, will read! Thanks!"><span class="u" id="1440662121.000016">2015:08:27 07:55:21         nodename </span><span>Ha, OK, will read! Thanks!</span></div><div data-t="aengelberg @nodename you could use negative lookahead, i.e.  Term = Char+ !Char"><span class="u" id="1440802362.000017">2015:08:28 22:52:42       aengelberg </span><span>@nodename you could use negative lookahead, i.e. </span><code>Term = Char+ !Char</code></div><div data-t="nodename @aengelberg thanks!"><span class="u" id="1440826874.000018">2015:08:29 05:41:14         nodename </span><span>@aengelberg thanks!</span></div><div data-t="ska interesting, wasn&apos;t aware of that"><span class="u" id="1441006496.000019">2015:08:31 07:34:56              ska </span><span>interesting, wasn&apos;t aware of that</span></div><div data-t="aaelony has anyone tried parsing between sql flavors? For example make a Redshift legal sql query a Hive legal sql query, assuming identical table and column names ? Would instaparse be a good fit for this kind of translation?"><span class="u" id="1444861405.000004">2015:10:14 22:23:25          aaelony </span><span>has anyone tried parsing between sql flavors? For example make a Redshift legal sql query a Hive legal sql query, assuming identical table and column names ? Would instaparse be a good fit for this kind of translation?</span></div><div data-t="aengelberg I&apos;m not familiar with the differences of Redshift and Hive formats; how many gotchas are there when going between the two styles?"><span class="u" id="1444862310.000005">2015:10:14 22:38:30       aengelberg </span><span>I&apos;m not familiar with the differences of Redshift and Hive formats; how many gotchas are there when going between the two styles?</span></div><div data-t="aengelberg @aaelony: ^"><span class="u" id="1444862650.000006">2015:10:14 22:44:10       aengelberg </span><span>@aaelony: ^</span></div><div data-t="aaelony there are differences in data types in create table statements, there are also differences in syntax and function calls"><span class="u" id="1444864996.000007">2015:10:14 23:23:16          aaelony </span><span>there are differences in data types in create table statements, there are also differences in syntax and function calls</span></div><div data-t="aaelony just trying to gauge if such translations are a good fit to try in instaparse"><span class="u" id="1444865043.000008">2015:10:14 23:24:03          aaelony </span><span>just trying to gauge if such translations are a good fit to try in instaparse</span></div><div data-t="aengelberg Instaparse&apos;s job is to fully parse a string and return its meaning as a tree of data. If you need to fully parse a sql query and examine the data before you know what to do with it, Instaparse is a good choice. But if the problem could be solved by a regular expression searching the string for patterns, Instaparse might be overkill."><span class="u" id="1444866430.000009">2015:10:14 23:47:10       aengelberg </span><span>Instaparse&apos;s job is to fully parse a string and return its meaning as a tree of data. If you need to fully parse a sql query and examine the data before you know what to do with it, Instaparse is a good choice. But if the problem could be solved by a regular expression searching the string for patterns, Instaparse might be overkill.</span></div><div data-t="aaelony That is useful, thank you. I think there are things idiomatic to each but maybe regexes are sufficient after all "><span class="u" id="1444870338.000010">2015:10:15 00:52:18          aaelony </span><span>That is useful, thank you. I think there are things idiomatic to each but maybe regexes are sufficient after all </span></div><div data-t="ska Funny enough, I spent the morning writing a grammar for some SQL inspired tiny query language  simple_smile"><span class="u" id="1444900470.000011">2015:10:15 09:14:30              ska </span><span>Funny enough, I spent the morning writing a grammar for some SQL inspired tiny query language </span><b>simple_smile</b></div><div data-t="aaelony yes, my initial thoughts were that sql syntax docs could be parsed in some way, e.g.  https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_TABLE_NEW.html  compared to  https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL"><span class="u" id="1444927045.000012">2015:10:15 16:37:25          aaelony </span><span>yes, my initial thoughts were that sql syntax docs could be parsed in some way, e.g. </span><a href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_TABLE_NEW.html">https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_TABLE_NEW.html</a><span> compared to </span><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL</a></div><div data-t="meow what is performance like for instaparse - someone I&apos;m working with had a problem in the past with it being slow but never tracked down the source of the problem"><span class="u" id="1452585712.000009">2016:01:12 08:01:52             meow </span><span>what is performance like for instaparse - someone I&apos;m working with had a problem in the past with it being slow but never tracked down the source of the problem</span></div><div data-t="ska When parsing becomes slow, it might be due to the grammar being ambiguous.  In general, I&apos;d say that Instparse is good enough for many use cases, even if I&apos;ve read papers complaining about the perf.  The one that I still have was written in German, though."><span class="u" id="1452593548.000010">2016:01:12 10:12:28              ska </span><span>When parsing becomes slow, it might be due to the grammar being ambiguous.  In general, I&apos;d say that Instparse is good enough for many use cases, even if I&apos;ve read papers complaining about the perf.  The one that I still have was written in German, though.</span></div><div data-t="meow I&apos;ll tell the #C0J20813K devs to come here to find out how to parse fast"><span class="u" id="1452594473.000011">2016:01:12 10:27:53             meow </span><span>I&apos;ll tell the #C0J20813K devs to come here to find out how to parse fast</span></div><div data-t="meow @rafd: ^"><span class="u" id="1452594499.000012">2016:01:12 10:28:19             meow </span><span>@rafd: ^</span></div><div data-t="meow @ska: thanks for the info!  simple_smile"><span class="u" id="1452594541.000013">2016:01:12 10:29:01             meow </span><span>@ska: thanks for the info! </span><b>simple_smile</b></div><div data-t="rafd @jamesnvc ^"><span class="u" id="1452603997.000016">2016:01:12 13:06:37             rafd </span><span>@jamesnvc ^</span></div><div data-t="jamesnvc hello"><span class="u" id="1452613640.000019">2016:01:12 15:47:20         jamesnvc </span><span>hello</span></div><div data-t="jamesnvc Yeah, I really like using instaparse server-side, but I tried writing one in cljs (pretty simple, just extracting links) and it was noticeably slow..."><span class="u" id="1452613672.000020">2016:01:12 15:47:52         jamesnvc </span><span>Yeah, I really like using instaparse server-side, but I tried writing one in cljs (pretty simple, just extracting links) and it was noticeably slow...</span></div><div data-t="jamesnvc it was being called on a lot of text, but is there something I should be doing?"><span class="u" id="1452613686.000021">2016:01:12 15:48:06         jamesnvc </span><span>it was being called on a lot of text, but is there something I should be doing?</span></div><div data-t="ska @jamesnvc: sometimes it is possible to chunk the text before parsing it.  For example, when parsing logfiles use instaparse just for the lines not the whole file."><span class="u" id="1452614109.000022">2016:01:12 15:55:09              ska </span><span>@jamesnvc: sometimes it is possible to chunk the text before parsing it.  For example, when parsing logfiles use instaparse just for the lines not the whole file.</span></div><div data-t="jamesnvc This is a bunch of little chunks of text; being called on the text of each message in a chat client"><span class="u" id="1452614145.000023">2016:01:12 15:55:45         jamesnvc </span><span>This is a bunch of little chunks of text; being called on the text of each message in a chat client</span></div><div data-t="jamesnvc I’ll try writing the grammar again and make sure it isn’t ambiguous"><span class="u" id="1452614176.000024">2016:01:12 15:56:16         jamesnvc </span><span>I’ll try writing the grammar again and make sure it isn’t ambiguous</span></div><div data-t="ghadi I have a new parser that should be much faster than instaparse if you have no ambiguity"><span class="u" id="1452615312.000025">2016:01:12 16:15:12            ghadi </span><span>I have a new parser that should be much faster than instaparse if you have no ambiguity</span></div><div data-t="ghadi https://github.com/ghadishayban/pex"><span class="u" id="1452615331.000026">2016:01:12 16:15:31            ghadi </span><a href="https://github.com/ghadishayban/pex">https://github.com/ghadishayban/pex</a></div><div data-t="ghadi needs better docs  😃"><span class="u" id="1452615356.000028">2016:01:12 16:15:56            ghadi </span><span>needs better docs </span><b>😃</b></div><div data-t="ghadi https://groups.google.com/d/msg/clojure/2ph-6o_Zydc/0O2DRDXBAwAJ"><span class="u" id="1452615376.000029">2016:01:12 16:16:16            ghadi </span><a href="https://groups.google.com/d/msg/clojure/2ph-6o_Zydc/0O2DRDXBAwAJ">https://groups.google.com/d/msg/clojure/2ph-6o_Zydc/0O2DRDXBAwAJ</a></div><div data-t="jamesnvc oh cool, I’ll give that a shot, thanks!"><span class="u" id="1452616551.000030">2016:01:12 16:35:51         jamesnvc </span><span>oh cool, I’ll give that a shot, thanks!</span></div><div data-t="jamesnvc @ghadi oh, does this work in clojurescript though? That is my issue with instaparse — my clj perf is fine, but cljs leaves something to be desired"><span class="u" id="1452616652.000031">2016:01:12 16:37:32         jamesnvc </span><span>@ghadi oh, does this work in clojurescript though? That is my issue with instaparse — my clj perf is fine, but cljs leaves something to be desired</span></div><div data-t="ghadi oh, no it doesn&apos;t"><span class="u" id="1452616675.000032">2016:01:12 16:37:55            ghadi </span><span>oh, no it doesn&apos;t</span></div><div data-t="ghadi should perform well there too, want to port a virtual machine ?  😉"><span class="u" id="1452616695.000033">2016:01:12 16:38:15            ghadi </span><span>should perform well there too, want to port a virtual machine ? </span><b>😉</b></div><div data-t="ghadi https://github.com/ghadishayban/pex/blob/master/src-java/com/champbacon/pex/impl/PEGByteCodeVM.java"><span class="u" id="1452616716.000034">2016:01:12 16:38:36            ghadi </span><a href="https://github.com/ghadishayban/pex/blob/master/src-java/com/champbacon/pex/impl/PEGByteCodeVM.java">https://github.com/ghadishayban/pex/blob/master/src-java/com/champbacon/pex/impl/PEGByteCodeVM.java</a></div><div data-t="jamesnvc Oh, interesting..."><span class="u" id="1452617408.000037">2016:01:12 16:50:08         jamesnvc </span><span>Oh, interesting...</span></div><div data-t="jamesnvc I may consider that, if just as a fun project!"><span class="u" id="1452617435.000038">2016:01:12 16:50:35         jamesnvc </span><span>I may consider that, if just as a fun project!</span></div><div data-t="ghadi Peg.js is pretty nice, IMHO"><span class="u" id="1452618437.000039">2016:01:12 17:07:17            ghadi </span><span>Peg.js is pretty nice, IMHO</span></div><div data-t="lucasbradstreet Hi @jamesnvc, cljs perf is definitely a bit slow. You need to be using advanced mode compile otherwise it’s incredibly slow."><span class="u" id="1452647479.000040">2016:01:13 01:11:19  lucasbradstreet </span><span>Hi @jamesnvc, cljs perf is definitely a bit slow. You need to be using advanced mode compile otherwise it’s incredibly slow.</span></div><div data-t="lucasbradstreet I’m the guy who did the port"><span class="u" id="1452647484.000041">2016:01:13 01:11:24  lucasbradstreet </span><span>I’m the guy who did the port</span></div><div data-t="jamesnvc @lucasbradstreet: Cool, thanks  simple_smile  Good to know I’m (maybe) not just doing something crazy"><span class="u" id="1452647520.000042">2016:01:13 01:12:00         jamesnvc </span><span>@lucasbradstreet: Cool, thanks </span><b>simple_smile</b><span> Good to know I’m (maybe) not just doing something crazy</span></div><div data-t="lucasbradstreet Depending on what you’re doing, you can also serialise the parser definition and load it in directly"><span class="u" id="1452647534.000043">2016:01:13 01:12:14  lucasbradstreet </span><span>Depending on what you’re doing, you can also serialise the parser definition and load it in directly</span></div><div data-t="lucasbradstreet Creating the initial parser in cljs can take quite a while, but the parsing itself can be pretty acceptable"><span class="u" id="1452647558.000044">2016:01:13 01:12:38  lucasbradstreet </span><span>Creating the initial parser in cljs can take quite a while, but the parsing itself can be pretty acceptable</span></div><div data-t="meow and my money was on crazy @jamesnvc"><span class="u" id="1452647943.000045">2016:01:13 01:19:03             meow </span><span>and my money was on crazy @jamesnvc</span></div><div data-t="meow can any of that &quot;job&quot; be split between client and server?"><span class="u" id="1452648018.000046">2016:01:13 01:20:18             meow </span><span>can any of that &quot;job&quot; be split between client and server?</span></div><div data-t="meow say for a chat app"><span class="u" id="1452648028.000047">2016:01:13 01:20:28             meow </span><span>say for a chat app</span></div><div data-t="meow just send the user keystrokes to the server - do it in clj there"><span class="u" id="1452648078.000048">2016:01:13 01:21:18             meow </span><span>just send the user keystrokes to the server - do it in clj there</span></div><div data-t="meow just brainstorming"><span class="u" id="1452648090.000049">2016:01:13 01:21:30             meow </span><span>just brainstorming</span></div><div data-t="meow outloud"><span class="u" id="1452648094.000050">2016:01:13 01:21:34             meow </span><span>outloud</span></div><div data-t="meow doesn&apos;t each keystroke go to the server already - that&apos;s how you can display the fact that the user is typing"><span class="u" id="1452648225.000051">2016:01:13 01:23:45             meow </span><span>doesn&apos;t each keystroke go to the server already - that&apos;s how you can display the fact that the user is typing</span></div><div data-t="meow so don&apos;t do any processing on the client - do the instaparse on the server"><span class="u" id="1452648247.000052">2016:01:13 01:24:07             meow </span><span>so don&apos;t do any processing on the client - do the instaparse on the server</span></div><div data-t="meow and use yada or onyx or something to scale it"><span class="u" id="1452648274.000053">2016:01:13 01:24:34             meow </span><span>and use yada or onyx or something to scale it</span></div><div data-t="meow we can segregrate services on the server and compose them"><span class="u" id="1452648299.000054">2016:01:13 01:24:59             meow </span><span>we can segregrate services on the server and compose them</span></div><div data-t="meow compose microservices on the server and keep the client relatively stupid whenever the data is already on the server"><span class="u" id="1452648348.000055">2016:01:13 01:25:48             meow </span><span>compose microservices on the server and keep the client relatively stupid whenever the data is already on the server</span></div><div data-t="lucasbradstreet I was parsing excel formulas on the client and it was good enough"><span class="u" id="1452648987.000056">2016:01:13 01:36:27  lucasbradstreet </span><span>I was parsing excel formulas on the client and it was good enough</span></div><div data-t="lucasbradstreet Certainly faster than a round-trip to the server"><span class="u" id="1452649001.000057">2016:01:13 01:36:41  lucasbradstreet </span><span>Certainly faster than a round-trip to the server</span></div><div data-t="meow ok"><span class="u" id="1452649307.000058">2016:01:13 01:41:47             meow </span><span>ok</span></div><div data-t="meow I&apos;ll defer to @jamesnvc since I&apos;m just blowing smoke"><span class="u" id="1452649326.000059">2016:01:13 01:42:06             meow </span><span>I&apos;ll defer to @jamesnvc since I&apos;m just blowing smoke</span></div><div data-t="lucasbradstreet My overall experience was that creating the initial parser was very expensive, but overall parsing was OK, but that it had to be in advanced mode. All with a big chunk of “your mileage may vary”. Unfortunately I don’t have any time to work on performance any further"><span class="u" id="1452649525.000060">2016:01:13 01:45:25  lucasbradstreet </span><span>My overall experience was that creating the initial parser was very expensive, but overall parsing was OK, but that it had to be in advanced mode. All with a big chunk of “your mileage may vary”. Unfortunately I don’t have any time to work on performance any further</span></div><div data-t="jamesnvc Cool, I was thinking of splitting it between client and server, but I will give it a shot with advanced compliation too"><span class="u" id="1452683280.000061">2016:01:13 11:08:00         jamesnvc </span><span>Cool, I was thinking of splitting it between client and server, but I will give it a shot with advanced compliation too</span></div><div data-t="lucasbradstreet Also works. I’d measure how long it takes to do the individual parses, not just page load time - because that will be affected by creating the initial parser"><span class="u" id="1452683715.000062">2016:01:13 11:15:15  lucasbradstreet </span><span>Also works. I’d measure how long it takes to do the individual parses, not just page load time - because that will be affected by creating the initial parser</span></div><div data-t="meow @jamesnvc: we should test both and not make assumptions either way, imnsho"><span class="u" id="1452691241.000063">2016:01:13 13:20:41             meow </span><span>@jamesnvc: we should test both and not make assumptions either way, imnsho</span></div><div data-t="meow @lucasbradstreet: thanks for the help and suggestions - much appreciated"><span class="u" id="1452691261.000064">2016:01:13 13:21:01             meow </span><span>@lucasbradstreet: thanks for the help and suggestions - much appreciated</span></div><div data-t="lucasbradstreet Agreed. Though you have to assume some variability in request latency when testing the other method, which is why I ultimately went with the client side approach. That said, you can have slow CPU clients too. "><span class="u" id="1452691422.000065">2016:01:13 13:23:42  lucasbradstreet </span><span>Agreed. Though you have to assume some variability in request latency when testing the other method, which is why I ultimately went with the client side approach. That said, you can have slow CPU clients too. </span></div><div data-t="meow then we should simulate issues with both environments and various combinations/permutations"><span class="u" id="1452691595.000066">2016:01:13 13:26:35             meow </span><span>then we should simulate issues with both environments and various combinations/permutations</span></div><div data-t="meow ask the #C0J20813K team how good I am at doing that"><span class="u" id="1452691610.000067">2016:01:13 13:26:50             meow </span><span>ask the #C0J20813K team how good I am at doing that</span></div><div data-t="meow issues, oh yeah, I got issues"><span class="u" id="1452691626.000068">2016:01:13 13:27:06             meow </span><span>issues, oh yeah, I got issues</span></div><div data-t="lucasbradstreet ha  👍"><span class="u" id="1452696484.000069">2016:01:13 14:48:04  lucasbradstreet </span><span>ha </span><b>👍</b></div><div data-t="meow simple_smile"><span class="u" id="1452697587.000070">2016:01:13 15:06:27             meow </span><b>simple_smile</b></div><div data-t="wongiseng Hi, very basic question probably not specific to instaparse. From this basic example :
&quot;S = N | (N (&apos;+&apos; N)+);
  N = &apos;0&apos; | &apos;1&apos; | &apos;2&apos; | &apos;3&apos; | &apos;4&apos; | &apos;5&apos; | &apos;6&apos; | &apos;7&apos; | &apos;8&apos; | &apos;9&apos;;&quot;

if I want to enforce that not all N are 0s, should this be done in the grammar definition or by adding some logic on processing the parsed result ? I suspect the latter, but just in case anyone knows other ways to enforce this restriction directly in the grammar, I&apos;d like to know. TIA"><span class="u" id="1454964122.000004">2016:02:08 20:42:02        wongiseng </span><span>Hi, very basic question probably not specific to instaparse. From this basic example :
&quot;S = N | (N (&apos;+&apos; N)+);
  N = &apos;0&apos; | &apos;1&apos; | &apos;2&apos; | &apos;3&apos; | &apos;4&apos; | &apos;5&apos; | &apos;6&apos; | &apos;7&apos; | &apos;8&apos; | &apos;9&apos;;&quot;

if I want to enforce that not all N are 0s, should this be done in the grammar definition or by adding some logic on processing the parsed result ? I suspect the latter, but just in case anyone knows other ways to enforce this restriction directly in the grammar, I&apos;d like to know. TIA</span></div><div data-t="aengelberg Hi @wongiseng, I saw your question on gitter as well. Instaparse&apos;s job is to turn strings into meaningful data; any validation you want to do on that data probably should happen after the parse."><span class="u" id="1454967132.000006">2016:02:08 21:32:12       aengelberg </span><span>Hi @wongiseng, I saw your question on gitter as well. Instaparse&apos;s job is to turn strings into meaningful data; any validation you want to do on that data probably should happen after the parse.</span></div><div data-t="aengelberg The only real way to have more sophisticated validation on an input is to use lookahead and negative lookahead."><span class="u" id="1454967191.000007">2016:02:08 21:33:11       aengelberg </span><span>The only real way to have more sophisticated validation on an input is to use lookahead and negative lookahead.</span></div><div data-t="aengelberg Well, those are the only ways to do sophisticated validation within instaparse."><span class="u" id="1454967205.000008">2016:02:08 21:33:25       aengelberg </span><span>Well, those are the only ways to do sophisticated validation within instaparse.</span></div><div data-t="aengelberg In this particular example you could use negative lookahead, e.g.
S = !(&apos;0&apos;*) (N | (N (&apos;+&apos; N)+));"><span class="u" id="1454967257.000009">2016:02:08 21:34:17       aengelberg </span><span>In this particular example you could use negative lookahead, e.g.
S = !(&apos;0&apos;*) (N | (N (&apos;+&apos; N)+));</span></div><div data-t="socksy this works, but it&apos;s ambiguous:
 (def minimum-one-not-zero
  (insta/parser
    &quot;EXP = N | S;
    S = (ZN &apos;+&apos;)* N (&apos;+&apos; ZN)*;
    N =  &apos;1&apos; | &apos;2&apos; | &apos;3&apos; | &apos;4&apos; | &apos;5&apos; | &apos;6&apos; | &apos;7&apos; | &apos;8&apos; | &apos;9&apos;;
    ZN = &apos;0&apos; | N;&quot;))
"><span class="u" id="1454967260.000010">2016:02:08 21:34:20           socksy </span><span>this works, but it&apos;s ambiguous:
</span><pre>(def minimum-one-not-zero
  (insta/parser
    &quot;EXP = N | S;
    S = (ZN &apos;+&apos;)* N (&apos;+&apos; ZN)*;
    N =  &apos;1&apos; | &apos;2&apos; | &apos;3&apos; | &apos;4&apos; | &apos;5&apos; | &apos;6&apos; | &apos;7&apos; | &apos;8&apos; | &apos;9&apos;;
    ZN = &apos;0&apos; | N;&quot;))
</pre></div><div data-t="aengelberg ^ That would work as well"><span class="u" id="1454967275.000011">2016:02:08 21:34:35       aengelberg </span><span>^ That would work as well</span></div><div data-t="socksy (tested)"><span class="u" id="1454967302.000013">2016:02:08 21:35:02           socksy </span><span>(tested)</span></div><div data-t="aengelberg The advantage to writing your own validation after the parse is that when the input is wrong, you can write your own error message to say whatever you want instead of instaparse&apos;s failure message which might not be as readable."><span class="u" id="1454967362.000014">2016:02:08 21:36:02       aengelberg </span><span>The advantage to writing your own validation after the parse is that when the input is wrong, you can write your own error message to say whatever you want instead of instaparse&apos;s failure message which might not be as readable.</span></div><div data-t="socksy ^definitely 
 Parse error at line 1, column 4:
0+0
   ^
Expected:
&quot;+&quot;"><span class="u" id="1454967394.000015">2016:02:08 21:36:34           socksy </span><span>^definitely 
</span><pre>Parse error at line 1, column 4:
0+0
   ^
Expected:
&quot;+&quot;</pre></div><div data-t="aengelberg oops, my negative lookahead approach definitely wouldn&apos;t work because I totally didn&apos;t see the pluses in the input"><span class="u" id="1454967417.000016">2016:02:08 21:36:57       aengelberg </span><span>oops, my negative lookahead approach definitely wouldn&apos;t work because I totally didn&apos;t see the pluses in the input</span></div><div data-t="aengelberg Maybe
 S = &amp;(#&quot;.*[1-9]&quot;) (N | (N (&apos;+&apos; N)+);
"><span class="u" id="1454967487.000017">2016:02:08 21:38:07       aengelberg </span><span>Maybe
</span><pre>S = &amp;(#&quot;.*[1-9]&quot;) (N | (N (&apos;+&apos; N)+);
</pre></div><div data-t="aengelberg e.g. &quot;make sure there&apos;s some nonzero number somewhere, then parse as usual&quot;"><span class="u" id="1454967505.000018">2016:02:08 21:38:25       aengelberg </span><span>e.g. &quot;make sure there&apos;s some nonzero number somewhere, then parse as usual&quot;</span></div><div data-t="aengelberg that&apos;s lookahead not negative lookahead"><span class="u" id="1454967549.000019">2016:02:08 21:39:09       aengelberg </span><span>that&apos;s lookahead not negative lookahead</span></div><div data-t="socksy if errors aren&apos;t important, and the fact you might get the &quot;wrong&quot; evaluation (e.g. &quot;1+0+1&quot; could be  [:EXP [:S [:N &quot;1&quot;] &quot;+&quot; [:ZN &quot;0&quot;] &quot;+&quot; [:ZN [:N &quot;1&quot;]]]]  or  [:EXP [:S [:ZN [:N&quot;1&quot;]] &quot;+&quot; [:ZN 0] &quot;+&quot; [:N 1]]] ) is also unimportant (e.g. you eval N and ZN the same), then you should be fine with the ambiguous grammar"><span class="u" id="1454967653.000020">2016:02:08 21:40:53           socksy </span><span>if errors aren&apos;t important, and the fact you might get the &quot;wrong&quot; evaluation (e.g. &quot;1+0+1&quot; could be </span><code>[:EXP [:S [:N &quot;1&quot;] &quot;+&quot; [:ZN &quot;0&quot;] &quot;+&quot; [:ZN [:N &quot;1&quot;]]]]</code><span> or </span><code>[:EXP [:S [:ZN [:N&quot;1&quot;]] &quot;+&quot; [:ZN 0] &quot;+&quot; [:N 1]]]</code><span>) is also unimportant (e.g. you eval N and ZN the same), then you should be fine with the ambiguous grammar</span></div><div data-t="socksy (instaparse gives you the former)"><span class="u" id="1454967692.000021">2016:02:08 21:41:32           socksy </span><span>(instaparse gives you the former)</span></div><div data-t="aengelberg @socksy how about
 S = N (&apos;+&apos; N)* | (N &apos;+&apos;)* &apos;0&apos; (&apos;+&apos; ZN)*;
"><span class="u" id="1454967904.000022">2016:02:08 21:45:04       aengelberg </span><span>@socksy how about
</span><pre>S = N (&apos;+&apos; N)* | (N &apos;+&apos;)* &apos;0&apos; (&apos;+&apos; ZN)*;
</pre></div><div data-t="aengelberg I&apos;m just writing these off the top of my head, not evaluating them to be sure. I think that would be unambiguous though"><span class="u" id="1454967927.000023">2016:02:08 21:45:27       aengelberg </span><span>I&apos;m just writing these off the top of my head, not evaluating them to be sure. I think that would be unambiguous though</span></div><div data-t="aengelberg hmm, that&apos;s definitely wrong  simple_smile"><span class="u" id="1454968003.000024">2016:02:08 21:46:43       aengelberg </span><span>hmm, that&apos;s definitely wrong </span><b>simple_smile</b></div><div data-t="aengelberg not sure where that came from"><span class="u" id="1454968014.000025">2016:02:08 21:46:54       aengelberg </span><span>not sure where that came from</span></div><div data-t="aengelberg Using lookahead would likely be the easiest path, since the grammar would be unambiguous and easy to understand"><span class="u" id="1454968079.000026">2016:02:08 21:47:59       aengelberg </span><span>Using lookahead would likely be the easiest path, since the grammar would be unambiguous and easy to understand</span></div><div data-t="wongiseng Cool, thanks for the explanations, I&apos;ll play a bit with look ahead, but eventually I guess i&apos;ll validate after the parse"><span class="u" id="1454968674.000027">2016:02:08 21:57:54        wongiseng </span><span>Cool, thanks for the explanations, I&apos;ll play a bit with look ahead, but eventually I guess i&apos;ll validate after the parse</span></div><div data-t="wongiseng The negative lookaheads makes the grammar hard to digest for me"><span class="u" id="1454968720.000028">2016:02:08 21:58:40        wongiseng </span><span>The negative lookaheads makes the grammar hard to digest for me</span></div><div data-t="wongiseng For now I use @socksy&apos;s approach  simple_smile   https://github.com/wibisono/gnip-rule-validator-clj/blob/master/gnip-rule.bnf  thanks a lot!"><span class="u" id="1454973711.000029">2016:02:08 23:21:51        wongiseng </span><span>For now I use @socksy&apos;s approach </span><b>simple_smile</b><span> </span><a href="https://github.com/wibisono/gnip-rule-validator-clj/blob/master/gnip-rule.bnf">https://github.com/wibisono/gnip-rule-validator-clj/blob/master/gnip-rule.bnf</a><span> thanks a lot!</span></div><div data-t="wongiseng My actual problem was OR  to have at least one positive term"><span class="u" id="1454973976.000031">2016:02:08 23:26:16        wongiseng </span><span>My actual problem was OR  to have at least one positive term</span></div><div data-t="conaw hey, anyone know how to match the \ character?"><span class="u" id="1460353865.000005">2016:04:11 05:51:05            conaw </span><span>hey, anyone know how to match the \ character?</span></div><div data-t="conaw I’m trying to match strings within a parsed file, something like this    string = &apos;\&quot;&apos; #&apos;[^(?&lt;!\\\)\&quot;]* &apos;\&quot;&apos;"><span class="u" id="1460353951.000006">2016:04:11 05:52:31            conaw </span><span>I’m trying to match strings within a parsed file, something like this    string = &apos;\&quot;&apos; #&apos;[^(?&lt;!\\\)\&quot;]* &apos;\&quot;&apos;</span></div><div data-t="conaw I keep getting either errors of unmatched parens, or instaparse errors when I’m doing"><span class="u" id="1460353986.000007">2016:04:11 05:53:06            conaw </span><span>I keep getting either errors of unmatched parens, or instaparse errors when I’m doing</span></div><div data-t="conaw \ or \\"><span class="u" id="1460353989.000008">2016:04:11 05:53:09            conaw </span><span>\ or \\</span></div><div data-t="conaw figured it out"><span class="u" id="1460355442.000009">2016:04:11 06:17:22            conaw </span><span>figured it out</span></div><div data-t="conaw If anyone’s interested"><span class="u" id="1460355465.000010">2016:04:11 06:17:45            conaw </span><span>If anyone’s interested</span></div><div data-t="conaw string = &apos;\&quot;&apos; (#&apos;[^\&quot;]&apos; | &apos;\\\\\&quot;&apos;) &apos;\&quot;&apos;"><span class="u" id="1460355472.000011">2016:04:11 06:17:52            conaw </span><span>string = &apos;\&quot;&apos; (#&apos;[^\&quot;]&apos; | &apos;\\\\\&quot;&apos;) &apos;\&quot;&apos;</span></div><div data-t="conaw I’m know there should be a way to do it with lookbehind inside the regex, but at least now I only have one problem"><span class="u" id="1460355552.000012">2016:04:11 06:19:12            conaw </span><span>I’m know there should be a way to do it with lookbehind inside the regex, but at least now I only have one problem</span></div><div data-t="conaw Would be great to have an instaparse wiki for common grammars, if that doesn’t already exist somewhere"><span class="u" id="1460355594.000013">2016:04:11 06:19:54            conaw </span><span>Would be great to have an instaparse wiki for common grammars, if that doesn’t already exist somewhere</span></div><div data-t="conaw also, would be great to know if anyone is using a combination of instaparse and any of the nlp libraries"><span class="u" id="1460355643.000014">2016:04:11 06:20:43            conaw </span><span>also, would be great to know if anyone is using a combination of instaparse and any of the nlp libraries</span></div><div data-t="ska What kind of combination are you thinking about, @conaw ?"><span class="u" id="1460451996.000015">2016:04:12 09:06:36              ska </span><span>What kind of combination are you thinking about, @conaw ?</span></div><div data-t="ska Oh, and regarding your string question, I did something similar with finding regexps in a query language which would be enclosed by slashes and allowed backslash-escaped slashed inside.  The regexp for this was so weird, I completely forgot, how it worked, but here it is:  REGEXP = &lt;&apos;/&apos;&gt; #&apos;(?:.(?!(?&lt;![\\\\])/))+.?&apos; &lt;&apos;/&apos;&gt;   (the grammar is defined in a Clojure string, thus the massive escaping)"><span class="u" id="1460452204.000016">2016:04:12 09:10:04              ska </span><span>Oh, and regarding your string question, I did something similar with finding regexps in a query language which would be enclosed by slashes and allowed backslash-escaped slashed inside.  The regexp for this was so weird, I completely forgot, how it worked, but here it is: </span><pre>REGEXP = &lt;&apos;/&apos;&gt; #&apos;(?:.(?!(?&lt;![\\\\])/))+.?&apos; &lt;&apos;/&apos;&gt;</pre><span>  (the grammar is defined in a Clojure string, thus the massive escaping)</span></div><div data-t="conaw not sure yet to be honest — I’d like to be doing POS tagging, and tokenizing, but really enjoying instaparse and curious if anyone has used it in conjunction with something like opennlp"><span class="u" id="1460452255.000017">2016:04:12 09:10:55            conaw </span><span>not sure yet to be honest — I’d like to be doing POS tagging, and tokenizing, but really enjoying instaparse and curious if anyone has used it in conjunction with something like opennlp</span></div><div data-t="ska I once did a workshop on Clojure with very basic NLP examples (it was at a faculty for computational linguistics), but I did not combine it with any existing NLP libraries.  Here at work, the NLP stuff is mostly self-written as much of it predates the open source libs.  And we do not (yet?) use Clojure in that area."><span class="u" id="1460452380.000018">2016:04:12 09:13:00              ska </span><span>I once did a workshop on Clojure with very basic NLP examples (it was at a faculty for computational linguistics), but I did not combine it with any existing NLP libraries.  Here at work, the NLP stuff is mostly self-written as much of it predates the open source libs.  And we do not (yet?) use Clojure in that area.</span></div><div data-t="ska Hm, looks like I never polished that workshop to put it online somewhere.  Sorry."><span class="u" id="1460452519.000019">2016:04:12 09:15:19              ska </span><span>Hm, looks like I never polished that workshop to put it online somewhere.  Sorry.</span></div><div data-t="ska But you may be interested in the instaparse talk here:  https://github.com/ska2342/clojure-talks/blob/master/instaparse/de.skamphausen.instaparse/src/de/skamphausen/instaparse.clj"><span class="u" id="1460452595.000020">2016:04:12 09:16:35              ska </span><span>But you may be interested in the instaparse talk here: </span><a href="https://github.com/ska2342/clojure-talks/blob/master/instaparse/de.skamphausen.instaparse/src/de/skamphausen/instaparse.clj">https://github.com/ska2342/clojure-talks/blob/master/instaparse/de.skamphausen.instaparse/src/de/skamphausen/instaparse.clj</a></div><div data-t="ska (enough boasting now; please excuse the self-plugging)"><span class="u" id="1460452616.000022">2016:04:12 09:16:56              ska </span><span>(enough boasting now; please excuse the self-plugging)</span></div><div data-t="conaw Not boasting at all, I appreciate the link."><span class="u" id="1460453151.000023">2016:04:12 09:25:51            conaw </span><span>Not boasting at all, I appreciate the link.</span></div><div data-t="conaw Another thing — Is there an idiomatic way to get the matched portion of a string for a given portion of a parse into the final transformed clojure data"><span class="u" id="1460453964.000024">2016:04:12 09:39:24            conaw </span><span>Another thing — Is there an idiomatic way to get the matched portion of a string for a given portion of a parse into the final transformed clojure data</span></div><div data-t="conaw I’m trying to parse the same text multiple times iteratively — passing the result to a different more granular parser based on the first"><span class="u" id="1460453996.000025">2016:04:12 09:39:56            conaw </span><span>I’m trying to parse the same text multiple times iteratively — passing the result to a different more granular parser based on the first</span></div><div data-t="conaw basically I’m trying to split the text up using a parse"><span class="u" id="1460454016.000026">2016:04:12 09:40:16            conaw </span><span>basically I’m trying to split the text up using a parse</span></div><div data-t="conaw spans looks like"><span class="u" id="1460454292.000027">2016:04:12 09:44:52            conaw </span><span>spans looks like</span></div><div data-t="ska There is a :partial option but it only returns the parse tree as far as it could be parsed.  Maybe the total mode would help?  Can&apos;t say.  Sorry."><span class="u" id="1460459642.000028">2016:04:12 11:14:02              ska </span><span>There is a :partial option but it only returns the parse tree as far as it could be parsed.  Maybe the total mode would help?  Can&apos;t say.  Sorry.</span></div><div data-t="ska @conaw, I just found the  span  function which takes a parse tree (result of parsing) and returns start and end index into the string. So, you could first parse partially and then as your input string for the covered substring."><span class="u" id="1460471647.000029">2016:04:12 14:34:07              ska </span><span>@conaw, I just found the </span><code>span</code><span> function which takes a parse tree (result of parsing) and returns start and end index into the string. So, you could first parse partially and then as your input string for the covered substring.</span></div><div data-t="ska Like this: 
 (let [s &quot;abcd&quot;
               g &quot;Q=&apos;a&apos; &apos;b&apos;&quot;
               p (i/parser g)
               t (p s :partial true)]
               (apply subs
                             (into [s] (i/span t))))

"><span class="u" id="1460471858.000030">2016:04:12 14:37:38              ska </span><span>Like this: 
</span><pre>(let [s &quot;abcd&quot;
               g &quot;Q=&apos;a&apos; &apos;b&apos;&quot;
               p (i/parser g)
               t (p s :partial true)]
               (apply subs
                             (into [s] (i/span t))))

</pre></div><div data-t="ska (sorry for the broken indentation)"><span class="u" id="1460471972.000034">2016:04:12 14:39:32              ska </span><span>(sorry for the broken indentation)</span></div><div data-t="conaw @ska yup, that was my last remark, should have used the  code marker to make it more clear.  I did have a little trouble figuring out how to get only the span details for particular tags though — my guess is that I should use  tree-seq for that"><span class="u" id="1460595642.000036">2016:04:14 01:00:42            conaw </span><span>@ska yup, that was my last remark, should have used the </span><code>code marker to make it more clear.  I did have a little trouble figuring out how to get only the span details for particular tags though — my guess is that I should use </code><span>tree-seq for that</span></div><div data-t="conaw and now I know how not to use  the  code marker"><span class="u" id="1460595676.000037">2016:04:14 01:01:16            conaw </span><span>and now I know how not to use  the </span><code>code marker</code></div><div data-t="ska @conaw, ah now I understand your last comment. I misread it for an unfinished sentence and later forgot about it. Then  span  was a surprise to me.  😄"><span class="u" id="1460626078.000038">2016:04:14 09:27:58              ska </span><span>@conaw, ah now I understand your last comment. I misread it for an unfinished sentence and later forgot about it. Then </span><code>span</code><span> was a surprise to me. </span><b>😄</b></div><div data-t="bwstearns Does anyone have any quick guidance on this question at SO:  https://stackoverflow.com/questions/36706854/instaparse-series-of-numbers-or-letters-as-one-leaf"><span class="u" id="1461207648.000003">2016:04:21 03:00:48        bwstearns </span><span>Does anyone have any quick guidance on this question at SO: </span><a href="https://stackoverflow.com/questions/36706854/instaparse-series-of-numbers-or-letters-as-one-leaf">https://stackoverflow.com/questions/36706854/instaparse-series-of-numbers-or-letters-as-one-leaf</a></div><div data-t="bwstearns I think it might be an instance of lacking the right words to google for the answer effectively."><span class="u" id="1461207690.000005">2016:04:21 03:01:30        bwstearns </span><span>I think it might be an instance of lacking the right words to google for the answer effectively.</span></div><div data-t="aengelberg @bwstearns: You could concatenate all the strings as a transform step."><span class="u" id="1461208904.000006">2016:04:21 03:21:44       aengelberg </span><span>@bwstearns: You could concatenate all the strings as a transform step.</span></div><div data-t="aengelberg i.e. unhide the letter and number tags, but add  :letter str, :number str  into your transformer map."><span class="u" id="1461208981.000007">2016:04:21 03:23:01       aengelberg </span><span>i.e. unhide the letter and number tags, but add </span><code>:letter str, :number str</code><span> into your transformer map.</span></div><div data-t="bwstearns @aengelberg: that&apos;s what I&apos;m doing now. Because I&apos;m doing it for a bunch of tags I was wondering if there was something built in for handling that as a common case or not."><span class="u" id="1461209058.000008">2016:04:21 03:24:18        bwstearns </span><span>@aengelberg: that&apos;s what I&apos;m doing now. Because I&apos;m doing it for a bunch of tags I was wondering if there was something built in for handling that as a common case or not.</span></div><div data-t="aengelberg Other than regexes, there&apos;s no way to concatenate strings in a way specified entirely by the instaparse grammar."><span class="u" id="1461209067.000009">2016:04:21 03:24:27       aengelberg </span><span>Other than regexes, there&apos;s no way to concatenate strings in a way specified entirely by the instaparse grammar.</span></div><div data-t="aengelberg The transform approach is the easiest way I could think of out of all the &quot;do something to the tree, fresh out of the parser&quot; possible approaches."><span class="u" id="1461209134.000010">2016:04:21 03:25:34       aengelberg </span><span>The transform approach is the easiest way I could think of out of all the &quot;do something to the tree, fresh out of the parser&quot; possible approaches.</span></div><div data-t="bwstearns That makes sense. I think what I&apos;ll do is put the preprocessor transforms into another hash to keep the more meaninful transform actions less cluttered and then merge them right before usage."><span class="u" id="1461209217.000011">2016:04:21 03:26:57        bwstearns </span><span>That makes sense. I think what I&apos;ll do is put the preprocessor transforms into another hash to keep the more meaninful transform actions less cluttered and then merge them right before usage.</span></div><div data-t="aengelberg That can work. Or just call insta/transform twice, if you don&apos;t mind the performance impact of traversing the tree twice."><span class="u" id="1461209268.000012">2016:04:21 03:27:48       aengelberg </span><span>That can work. Or just call insta/transform twice, if you don&apos;t mind the performance impact of traversing the tree twice.</span></div><div data-t="bwstearns that works too. I don&apos;t think I have any performance issues on the horizon with this project."><span class="u" id="1461209307.000013">2016:04:21 03:28:27        bwstearns </span><span>that works too. I don&apos;t think I have any performance issues on the horizon with this project.</span></div><div data-t="bwstearns @aengelberg: thanks a ton for taking a look. The question got some foot traffic but no feedback. If you&apos;re looking for internet points feel free to drop what you said in there and I&apos;ll accept it. Otherwise I&apos;ll copy it in as an own-answer for the next person."><span class="u" id="1461209558.000014">2016:04:21 03:32:38        bwstearns </span><span>@aengelberg: thanks a ton for taking a look. The question got some foot traffic but no feedback. If you&apos;re looking for internet points feel free to drop what you said in there and I&apos;ll accept it. Otherwise I&apos;ll copy it in as an own-answer for the next person.</span></div><div data-t="aengelberg @bwstearns: Any time! I&apos;ve added an answer to your post"><span class="u" id="1461210641.000015">2016:04:21 03:50:41       aengelberg </span><span>@bwstearns: Any time! I&apos;ve added an answer to your post</span></div><div data-t="bwstearns awesome. thanks. Didn&apos;t think about the performant part, is that primarily due to the extra step of having to transform it or is it because regexes are inherently faster than using parser rules?"><span class="u" id="1461210690.000016">2016:04:21 03:51:30        bwstearns </span><span>awesome. thanks. Didn&apos;t think about the performant part, is that primarily due to the extra step of having to transform it or is it because regexes are inherently faster than using parser rules?</span></div><div data-t="aengelberg #&apos;a+&apos;  is faster than  &apos;a&apos;+ , as letting regexes do the work of searching for all possible &quot;a&quot;s is faster than having instaparse do that work"><span class="u" id="1461211110.000017">2016:04:21 03:58:30       aengelberg </span><code>#&apos;a+&apos;</code><span> is faster than </span><code>&apos;a&apos;+</code><span>, as letting regexes do the work of searching for all possible &quot;a&quot;s is faster than having instaparse do that work</span></div><div data-t="aengelberg @bwstearns: ^"><span class="u" id="1461211392.000019">2016:04:21 04:03:12       aengelberg </span><span>@bwstearns: ^</span></div><div data-t="bwstearns Right, that makes sense because of the greediness. Thanks a ton for taking the time on this."><span class="u" id="1461212213.000020">2016:04:21 04:16:53        bwstearns </span><span>Right, that makes sense because of the greediness. Thanks a ton for taking the time on this.</span></div><div data-t="aengelberg It&apos;s not exactly *because* of the greediness, it&apos;s just speedier when a Java program is doing this task than Clojure  simple_smile"><span class="u" id="1461212403.000021">2016:04:21 04:20:03       aengelberg </span><span>It&apos;s not exactly *because* of the greediness, it&apos;s just speedier when a Java program is doing this task than Clojure </span><b>simple_smile</b></div><div data-t="bwstearns In the wikipedia conventions section on EBNF it suggests that you can have bounded repetitions ( https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form#Conventions ), but the documentation doesn&apos;t say anything about it and I poked around the source and couldn&apos;t find anything in cfg that suggested it was there. Is the best way to get bounded reps to just merge in those rules from combinators?"><span class="u" id="1461447696.000022">2016:04:23 21:41:36        bwstearns </span><span>In the wikipedia conventions section on EBNF it suggests that you can have bounded repetitions (</span><a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form#Conventions">https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form#Conventions</a><span>), but the documentation doesn&apos;t say anything about it and I poked around the source and couldn&apos;t find anything in cfg that suggested it was there. Is the best way to get bounded reps to just merge in those rules from combinators?</span></div><div data-t="aengelberg @bwstearns sorry, didn&apos;t see your question until now. The instaparse ABNF notation (which is explained in  ABNF.md ) supports repetition with any lower and/or upper bound. e.g.  (insta/parser &quot;S = 3*5(&apos;a&apos;)&quot; :input-format :abnf)  matches 3 to 5  a s. The default EBNF notation does not support it, so unless you want to switch to ABNF (a few conventions would have to change) then merging in combinators is the best approach."><span class="u" id="1461739192.000023">2016:04:27 06:39:52       aengelberg </span><span>@bwstearns sorry, didn&apos;t see your question until now. The instaparse ABNF notation (which is explained in </span><code>ABNF.md</code><span>) supports repetition with any lower and/or upper bound. e.g. </span><code>(insta/parser &quot;S = 3*5(&apos;a&apos;)&quot; :input-format :abnf)</code><span> matches 3 to 5 </span><code>a</code><span>s. The default EBNF notation does not support it, so unless you want to switch to ABNF (a few conventions would have to change) then merging in combinators is the best approach.</span></div><div data-t="bwstearns @aengelberg: Sorry, I should have followed up with what I found, which is pretty much what you just said lol. I ended up implementing it by making a rep combinator and merging it into the main grammar, and then after looking at how unreadable it was getting I just threw a #&apos;\d\d&apos; regex at it (or something similar, I forget which part of the thing I was trying to parse). 

Thanks for following up though. Also, I knew I recognized you from something. Really enjoyed the automata presentation (I am of the youtube audience, haven’t had the good fortune to get to a clojure event in person yet)."><span class="u" id="1461765944.000024">2016:04:27 14:05:44        bwstearns </span><span>@aengelberg: Sorry, I should have followed up with what I found, which is pretty much what you just said lol. I ended up implementing it by making a rep combinator and merging it into the main grammar, and then after looking at how unreadable it was getting I just threw a #&apos;\d\d&apos; regex at it (or something similar, I forget which part of the thing I was trying to parse). 

Thanks for following up though. Also, I knew I recognized you from something. Really enjoyed the automata presentation (I am of the youtube audience, haven’t had the good fortune to get to a clojure event in person yet).</span></div><div data-t="aengelberg @bwstearns: Glad you liked the talk!  simple_smile  If you have any more questions just @-mention me or say the word &quot;instaparse&quot; which also notifies me"><span class="u" id="1461915311.000025">2016:04:29 07:35:11       aengelberg </span><span>@bwstearns: Glad you liked the talk! </span><b>simple_smile</b><span> If you have any more questions just @-mention me or say the word &quot;instaparse&quot; which also notifies me</span></div><div data-t="ska Hi.  I am aware that Instaparse collects the offsets to the strings it parses in the metadata of the elements of the parse tree.  I would like to turn the parse tree into XML (using  :output-format :enlive  and  clojure.xml/emit ) and get the offset information somehow into the XML tree.  Any pointers or ideas how to achieve this?"><span class="u" id="1464769955.000028">2016:06:01 08:32:35              ska </span><span>Hi.  I am aware that Instaparse collects the offsets to the strings it parses in the metadata of the elements of the parse tree.  I would like to turn the parse tree into XML (using </span><code>:output-format :enlive</code><span> and </span><code>clojure.xml/emit</code><span>) and get the offset information somehow into the XML tree.  Any pointers or ideas how to achieve this?</span></div><div data-t="ska Does instaparse support special symbols for EOF and/or BOF?"><span class="u" id="1464870095.000032">2016:06:02 12:21:35              ska </span><span>Does instaparse support special symbols for EOF and/or BOF?</span></div><div data-t="ska Hm, first experiments give hint that having  &lt;EOF&gt; = &lt;#&apos;\\Z&apos;&gt;  in my grammar works."><span class="u" id="1464883595.000033">2016:06:02 16:06:35              ska </span><span>Hm, first experiments give hint that having </span><code>&lt;EOF&gt; = &lt;#&apos;\\Z&apos;&gt;</code><span> in my grammar works.</span></div><div data-t="aengelberg You could use the regex symbol for end of string, #&quot;$&quot; I believe"><span class="u" id="1464885459.000034">2016:06:02 16:37:39       aengelberg </span><span>You could use the regex symbol for end of string, #&quot;$&quot; I believe</span></div><div data-t="dave hey everyone! this is a shot in the dark, but is anyone interested in helping me speed up alda&apos;s parser? i have some notes here:  https://github.com/alda-lang/alda/pull/238 

i have to run at the moment, but thought i&apos;d leave this here in case someone is interested in helping me tackle this"><span class="u" id="1464988242.000037">2016:06:03 21:10:42             dave </span><span>hey everyone! this is a shot in the dark, but is anyone interested in helping me speed up alda&apos;s parser? i have some notes here: </span><a href="https://github.com/alda-lang/alda/pull/238">https://github.com/alda-lang/alda/pull/238</a><span>

i have to run at the moment, but thought i&apos;d leave this here in case someone is interested in helping me tackle this</span></div><div data-t="aengelberg @ghaz FYI  https://github.com/aengelberg/cljsee"><span class="u" id="1465885098.000002">2016:06:14 06:18:18       aengelberg </span><span>@ghaz FYI </span><a href="https://github.com/aengelberg/cljsee">https://github.com/aengelberg/cljsee</a></div><div data-t="aengelberg @lucasbradstreet ^"><span class="u" id="1465885108.000004">2016:06:14 06:18:28       aengelberg </span><span>@lucasbradstreet ^</span></div><div data-t="aengelberg I wrote this plugin with Instaparse in mind as a use case. I&apos;m hoping this can help us get instaparse-cljs to (non cljx) portable code and maybe even merge this upstream."><span class="u" id="1465885185.000005">2016:06:14 06:19:45       aengelberg </span><span>I wrote this plugin with Instaparse in mind as a use case. I&apos;m hoping this can help us get instaparse-cljs to (non cljx) portable code and maybe even merge this upstream.</span></div><div data-t="lucasbradstreet Thanks @aengelberg. I retweeted your tweet about it because it&apos;s awesome! Nice work. Unfortunately I have absolutely no time to help with a port right now :(, but the approach sounds like a great way to go "><span class="u" id="1465886795.000006">2016:06:14 06:46:35  lucasbradstreet </span><span>Thanks @aengelberg. I retweeted your tweet about it because it&apos;s awesome! Nice work. Unfortunately I have absolutely no time to help with a port right now :(, but the approach sounds like a great way to go </span></div><div data-t="turbopape What&apos;s the status of cljs support ? "><span class="u" id="1467597226.000012">2016:07:04 01:53:46        turbopape </span><span>What&apos;s the status of cljs support ? </span></div><div data-t="turbopape Is it still living as a fork?"><span class="u" id="1467597289.000013">2016:07:04 01:54:49        turbopape </span><span>Is it still living as a fork?</span></div><div data-t="aengelberg The only cljs support still lives in lbradstreet/instaparse-cljs"><span class="u" id="1467597476.000014">2016:07:04 01:57:56       aengelberg </span><span>The only cljs support still lives in lbradstreet/instaparse-cljs</span></div><div data-t="aengelberg But I&apos;m currently in the process of rewriting instaparse-cljs into a form that we&apos;d be willing to accept back into upstream, now that cljsee exists"><span class="u" id="1467597597.000015">2016:07:04 01:59:57       aengelberg </span><span>But I&apos;m currently in the process of rewriting instaparse-cljs into a form that we&apos;d be willing to accept back into upstream, now that cljsee exists</span></div><div data-t="aengelberg @seylerius: Here&apos;s a grammar that parses exponents like you were you asking:
 boot.user=&gt; (def p (insta/parser &quot;
&lt;S&gt; = ows (exponent ows)+
&lt;exponent&gt; = token &lt;&apos;^&apos;&gt; super
super = token | &lt;&apos;{&apos;&gt; token &lt;&apos;}&apos;&gt;
&lt;token&gt; = #&apos;[^\\s\\^{}]+&apos;
&lt;ows&gt; = &lt;#&apos;\\s*&apos;&gt;
&quot;))
#&apos;boot.user/p
boot.user=&gt; (p &quot;foo^2 x^{x+1}&quot;)
(&quot;foo&quot; [:super &quot;2&quot;] &quot;x&quot; [:super &quot;x+1&quot;])
 
This parser is pretty naive about the range of possible inputs, since I&apos;m not totally sure myself what that range of inputs is in your use case."><span class="u" id="1467618391.000016">2016:07:04 07:46:31       aengelberg </span><span>@seylerius: Here&apos;s a grammar that parses exponents like you were you asking:
</span><pre>boot.user=&gt; (def p (insta/parser &quot;
&lt;S&gt; = ows (exponent ows)+
&lt;exponent&gt; = token &lt;&apos;^&apos;&gt; super
super = token | &lt;&apos;{&apos;&gt; token &lt;&apos;}&apos;&gt;
&lt;token&gt; = #&apos;[^\\s\\^{}]+&apos;
&lt;ows&gt; = &lt;#&apos;\\s*&apos;&gt;
&quot;))
#&apos;boot.user/p
boot.user=&gt; (p &quot;foo^2 x^{x+1}&quot;)
(&quot;foo&quot; [:super &quot;2&quot;] &quot;x&quot; [:super &quot;x+1&quot;])
</pre><span>
This parser is pretty naive about the range of possible inputs, since I&apos;m not totally sure myself what that range of inputs is in your use case.</span></div><div data-t="seylerius Thanks!"><span class="u" id="1467650610.000018">2016:07:04 16:43:30        seylerius </span><span>Thanks!</span></div><div data-t="seylerius Another question:  *   /   +   =  &amp;  ~  can appear in singles without being tokens. How would you represent that? Current parser:  http://sprunge.us/GNDe"><span class="u" id="1467650833.000020">2016:07:04 16:47:13        seylerius </span><span>Another question: </span><code>*</code><span> </span><code>/</code><span> </span><code>+</code><span> </span><code>=</code><span> &amp; </span><code>~</code><span> can appear in singles without being tokens. How would you represent that? Current parser: </span><a href="http://sprunge.us/GNDe">http://sprunge.us/GNDe</a></div><div data-t="seylerius @aengelberg: What I have will do for the moment, but it&apos;s a part of the spec I&apos;d like to meet eventually."><span class="u" id="1467651298.000021">2016:07:04 16:54:58        seylerius </span><span>@aengelberg: What I have will do for the moment, but it&apos;s a part of the spec I&apos;d like to meet eventually.</span></div><div data-t="Andy Hi,
We switched recently for parsing user input using plain regex to instaparse. Code looks way better. However there are two corner cases where I am not sure what would be idiomatic way:
1) parsing of certain domain of inputs should result on noop.  Our current solution is:
 &quot;sentence = define / explain / help / catchall
&lt;&lt;skipped definitions&gt;&gt;
 catchall = #&apos;(.|[\n\r])*&apos;&quot;
 
with an intention to just ignore last part during transformation  : catchall (fn [_] nil) 

Now I wonder if there is another way to catch this case and ignore without using exceptions.

2)`&apos;(.|[\n\r])*&apos;` comes with  |  which on JVM leads on recursion and might result in stack overflow. In fact it happened one to us.  Is there a better way to write  catchall  which would account for anything including  \n  and  \r ."><span class="u" id="1467651806.000022">2016:07:04 17:03:26             Andy </span><span>Hi,
We switched recently for parsing user input using plain regex to instaparse. Code looks way better. However there are two corner cases where I am not sure what would be idiomatic way:
1) parsing of certain domain of inputs should result on noop.  Our current solution is:
</span><pre>&quot;sentence = define / explain / help / catchall
&lt;&lt;skipped definitions&gt;&gt;
 catchall = #&apos;(.|[\n\r])*&apos;&quot;
</pre><span>
with an intention to just ignore last part during transformation </span><code>: catchall (fn [_] nil)</code><span>

Now I wonder if there is another way to catch this case and ignore without using exceptions.

2)`&apos;(.|[\n\r])*&apos;` comes with </span><code>|</code><span> which on JVM leads on recursion and might result in stack overflow. In fact it happened one to us.  Is there a better way to write </span><code>catchall</code><span> which would account for anything including </span><code>\n</code><span> and </span><code>\r</code><span>.</span></div><div data-t="aengelberg @happy.lisper for catchall you could do  #&apos;[\s\S]*&apos;"><span class="u" id="1467652205.000023">2016:07:04 17:10:05       aengelberg </span><span>@happy.lisper for catchall you could do </span><code>#&apos;[\s\S]*&apos;</code></div><div data-t="Andy ty"><span class="u" id="1467652224.000024">2016:07:04 17:10:24             Andy </span><span>ty</span></div><div data-t="aengelberg So your use case is: &quot;Parse the entire string as a  define , an  explain , or a  help , but if that doesn&apos;t work then return nil&quot;?"><span class="u" id="1467652276.000025">2016:07:04 17:11:16       aengelberg </span><span>So your use case is: &quot;Parse the entire string as a </span><code>define</code><span>, an </span><code>explain</code><span>, or a </span><code>help</code><span>, but if that doesn&apos;t work then return nil&quot;?</span></div><div data-t="aengelberg Because you could just run the parse and a transform, then check  (insta/failure? result)"><span class="u" id="1467652303.000026">2016:07:04 17:11:43       aengelberg </span><span>Because you could just run the parse and a transform, then check </span><code>(insta/failure? result)</code></div><div data-t="Andy yes, where  nil  is just a signal to ignore the input."><span class="u" id="1467652312.000027">2016:07:04 17:11:52             Andy </span><span>yes, where </span><code>nil</code><span> is just a signal to ignore the input.</span></div><div data-t="aengelberg (def p (insta/parser ...))
(let [result (p input-string)
      transformed (insta/transform p {...})]
  (when-not (insta/failure? transformed)
    transformed))
"><span class="u" id="1467652434.000028">2016:07:04 17:13:54       aengelberg </span><pre>(def p (insta/parser ...))
(let [result (p input-string)
      transformed (insta/transform p {...})]
  (when-not (insta/failure? transformed)
    transformed))
</pre></div><div data-t="aengelberg Note that  insta/transform  is specifically designed to pass through failures"><span class="u" id="1467652452.000029">2016:07:04 17:14:12       aengelberg </span><span>Note that </span><code>insta/transform</code><span> is specifically designed to pass through failures</span></div><div data-t="Andy Let me consider that  🙂 ."><span class="u" id="1467652513.000030">2016:07:04 17:15:13             Andy </span><span>Let me consider that </span><b>🙂</b><span>.</span></div><div data-t="aengelberg @seylerius: Given an input  ~a ~b , how do you know the  a  and  b  are to be parsed as individual  ~ &apos;s, as opposed to a code string of  &quot;a &quot;  followed by  &quot;b&quot; ?"><span class="u" id="1467652790.000031">2016:07:04 17:19:50       aengelberg </span><span>@seylerius: Given an input </span><code>~a ~b</code><span>, how do you know the </span><code>a</code><span> and </span><code>b</code><span> are to be parsed as individual </span><code>~</code><span>&apos;s, as opposed to a code string of </span><code>&quot;a &quot;</code><span> followed by </span><code>&quot;b&quot;</code><span>?</span></div><div data-t="seylerius @aengelberg: If I&apos;m reading this correctly, the characters touching the inside of the tokens need to be alphanumeric, or at least non-whitespace."><span class="u" id="1467653046.000034">2016:07:04 17:24:06        seylerius </span><span>@aengelberg: If I&apos;m reading this correctly, the characters touching the inside of the tokens need to be alphanumeric, or at least non-whitespace.</span></div><div data-t="aengelberg so  *a b c*  shouldn&apos;t be allowed?"><span class="u" id="1467653263.000035">2016:07:04 17:27:43       aengelberg </span><span>so </span><code>*a b c*</code><span> shouldn&apos;t be allowed?</span></div><div data-t="aengelberg the current grammar that I suggested would allow that. Just trying to get a sense of the range of inputs so I can help design a parser accordingly"><span class="u" id="1467653304.000036">2016:07:04 17:28:24       aengelberg </span><span>the current grammar that I suggested would allow that. Just trying to get a sense of the range of inputs so I can help design a parser accordingly</span></div><div data-t="seylerius *foo* *bar*   ➡   [:b &quot;foo&quot; &quot;bar&quot;]  
 foo* bar*   ➡   &quot;foo* bar*&quot; "><span class="u" id="1467653364.000037">2016:07:04 17:29:24        seylerius </span><code>*foo* *bar*</code><span> </span><b>➡</b><span> </span><code>[:b &quot;foo&quot; &quot;bar&quot;] </code><span>
</span><code>foo* bar*</code><span> </span><b>➡</b><span> </span><code>&quot;foo* bar*&quot; </code></div><div data-t="seylerius @aengelberg: that make sense?"><span class="u" id="1467653616.000038">2016:07:04 17:33:36        seylerius </span><span>@aengelberg: that make sense?</span></div><div data-t="aengelberg for the first example do you mean  [:b &quot;foo&quot;] [:b &quot;bar&quot;] ?"><span class="u" id="1467653690.000039">2016:07:04 17:34:50       aengelberg </span><span>for the first example do you mean </span><code>[:b &quot;foo&quot;] [:b &quot;bar&quot;]</code><span>?</span></div><div data-t="aengelberg is there a guarantee that  *a**b*  won&apos;t happen?"><span class="u" id="1467653836.000040">2016:07:04 17:37:16       aengelberg </span><span>is there a guarantee that </span><code>*a**b*</code><span> won&apos;t happen?</span></div><div data-t="seylerius @aengelberg: Yes. 
And guarantee? No. Ambiguity in the spec we can lock to an interpretation? Yes."><span class="u" id="1467653926.000041">2016:07:04 17:38:46        seylerius </span><span>@aengelberg: Yes. 
And guarantee? No. Ambiguity in the spec we can lock to an interpretation? Yes.</span></div><div data-t="seylerius We basically get to decide if that&apos;s a pair of bold characters or a flat string we&apos;ll leave be."><span class="u" id="1467654317.000042">2016:07:04 17:45:17        seylerius </span><span>We basically get to decide if that&apos;s a pair of bold characters or a flat string we&apos;ll leave be.</span></div><div data-t="seylerius It would only likely happen as a typo."><span class="u" id="1467654328.000043">2016:07:04 17:45:28        seylerius </span><span>It would only likely happen as a typo.</span></div><div data-t="seylerius (Or a stupid user)"><span class="u" id="1467654341.000044">2016:07:04 17:45:41        seylerius </span><span>(Or a stupid user)</span></div><div data-t="seylerius @aengelberg: I&apos;m basically upgrading organum. Sample org file:  http://sprunge.us/KBbL"><span class="u" id="1467654487.000045">2016:07:04 17:48:07        seylerius </span><span>@aengelberg: I&apos;m basically upgrading organum. Sample org file: </span><a href="http://sprunge.us/KBbL">http://sprunge.us/KBbL</a></div><div data-t="aengelberg hmm, thinking through how to enforce alphanumeric chars on the insides of tokens."><span class="u" id="1467654661.000046">2016:07:04 17:51:01       aengelberg </span><span>hmm, thinking through how to enforce alphanumeric chars on the insides of tokens.</span></div><div data-t="aengelberg doing a &quot;lookbehind&quot; on the last  *  is nontrivial."><span class="u" id="1467654742.000047">2016:07:04 17:52:22       aengelberg </span><span>doing a &quot;lookbehind&quot; on the last </span><code>*</code><span> is nontrivial.</span></div><div data-t="seylerius What if I stripped leading and trailing whitespace before parsing, and modified the base  string  rule to start and end alphanumeric? Would that be easier?"><span class="u" id="1467655276.000048">2016:07:04 18:01:16        seylerius </span><span>What if I stripped leading and trailing whitespace before parsing, and modified the base </span><code>string</code><span> rule to start and end alphanumeric? Would that be easier?</span></div><div data-t="seylerius But, no, that wouldn&apos;t quite work."><span class="u" id="1467655537.000049">2016:07:04 18:05:37        seylerius </span><span>But, no, that wouldn&apos;t quite work.</span></div><div data-t="seylerius @aengelberg: Will the parser ignore escaped tokens, like  \* ?"><span class="u" id="1467655889.000050">2016:07:04 18:11:29        seylerius </span><span>@aengelberg: Will the parser ignore escaped tokens, like </span><code>\*</code><span>?</span></div><div data-t="seylerius Ach. Clojure doesn&apos;t like  \*  in a string"><span class="u" id="1467655968.000051">2016:07:04 18:12:48        seylerius </span><span>Ach. Clojure doesn&apos;t like </span><code>\*</code><span> in a string</span></div><div data-t="seylerius @aengelberg: Is here any way to mark tokens to not be parsed?"><span class="u" id="1467657043.000052">2016:07:04 18:30:43        seylerius </span><span>@aengelberg: Is here any way to mark tokens to not be parsed?</span></div><div data-t="Andy would angle brackets  &lt;&gt;  to hide parsed elements work?"><span class="u" id="1467657215.000053">2016:07:04 18:33:35             Andy </span><span>would angle brackets </span><code>&lt;&gt;</code><span> to hide parsed elements work?</span></div><div data-t="aengelberg @seylerius you&apos;d have to do  \\*  if inside a Clojure string"><span class="u" id="1467657329.000054">2016:07:04 18:35:29       aengelberg </span><span>@seylerius you&apos;d have to do </span><code>\\*</code><span> if inside a Clojure string</span></div><div data-t="aengelberg the goal is to avoid parsing  *a *  as  [:b &quot;a &quot;]"><span class="u" id="1467657414.000055">2016:07:04 18:36:54       aengelberg </span><span>the goal is to avoid parsing </span><code>*a *</code><span> as </span><code>[:b &quot;a &quot;]</code></div><div data-t="seylerius @aengelberg: Anything special I have to do to mark that? I just tried parsing  \\*foo\\*  and got  (&quot;\\&quot; [:b &quot;foo\\&quot;]) "><span class="u" id="1467657454.000056">2016:07:04 18:37:34        seylerius </span><span>@aengelberg: Anything special I have to do to mark that? I just tried parsing </span><code>\\*foo\\*</code><span> and got </span><code>(&quot;\\&quot; [:b &quot;foo\\&quot;]) </code></div><div data-t="aengelberg instaparse doesn&apos;t automatically handle backslashes in any special way besides what has been defined in your grammar."><span class="u" id="1467657502.000057">2016:07:04 18:38:22       aengelberg </span><span>instaparse doesn&apos;t automatically handle backslashes in any special way besides what has been defined in your grammar.</span></div><div data-t="seylerius Okay. How do you define a simple backslash replacement in this type of grammar, then?"><span class="u" id="1467657702.000059">2016:07:04 18:41:42        seylerius </span><span>Okay. How do you define a simple backslash replacement in this type of grammar, then?</span></div><div data-t="aengelberg Maybe replace  &lt;string&gt;  with:
 &lt;string&gt; = &apos;\\\\*&apos; | #&apos;[^*/_+=~^_\\\\]+&apos;
 
 user&gt; (inline-markup &quot;a\\* b&quot;)
(&quot;a&quot; &quot;\\*&quot; &quot; b&quot;)
"><span class="u" id="1467657959.000060">2016:07:04 18:45:59       aengelberg </span><span>Maybe replace </span><code>&lt;string&gt;</code><span> with:
</span><pre>&lt;string&gt; = &apos;\\\\*&apos; | #&apos;[^*/_+=~^_\\\\]+&apos;
</pre><span>
</span><pre>user&gt; (inline-markup &quot;a\\* b&quot;)
(&quot;a&quot; &quot;\\*&quot; &quot; b&quot;)
</pre></div><div data-t="aengelberg Pretty messy, I know. (four backslashes  🙄 )"><span class="u" id="1467657977.000061">2016:07:04 18:46:17       aengelberg </span><span>Pretty messy, I know. (four backslashes </span><b>🙄</b><span>)</span></div><div data-t="aengelberg I don&apos;t know if this solves your problem though; you don&apos;t want to escape  * &apos;s in every  ** My Subsection  text, do you?"><span class="u" id="1467658083.000062">2016:07:04 18:48:03       aengelberg </span><span>I don&apos;t know if this solves your problem though; you don&apos;t want to escape </span><code>*</code><span>&apos;s in every </span><code>** My Subsection</code><span> text, do you?</span></div><div data-t="aengelberg sorry if I&apos;m a bit unhelpful; phasing in and out of AFK"><span class="u" id="1467658153.000063">2016:07:04 18:49:13       aengelberg </span><span>sorry if I&apos;m a bit unhelpful; phasing in and out of AFK</span></div><div data-t="seylerius I&apos;m thinking I&apos;m just going to tell users that if they want a plain  *  they have to escape it."><span class="u" id="1467658238.000064">2016:07:04 18:50:38        seylerius </span><span>I&apos;m thinking I&apos;m just going to tell users that if they want a plain </span><code>*</code><span> they have to escape it.</span></div><div data-t="seylerius Headlines are already handled by the time this stage of parsing is invoked, so those won&apos;t be an issue."><span class="u" id="1467658283.000065">2016:07:04 18:51:23        seylerius </span><span>Headlines are already handled by the time this stage of parsing is invoked, so those won&apos;t be an issue.</span></div><div data-t="seylerius And your special case of  *a**b*  is apparently already readily converted to  ([:b &quot;a&quot;] [:b &quot;b&quot;])"><span class="u" id="1467658401.000066">2016:07:04 18:53:21        seylerius </span><span>And your special case of </span><code>*a**b*</code><span> is apparently already readily converted to </span><code>([:b &quot;a&quot;] [:b &quot;b&quot;])</code></div><div data-t="seylerius @aengelberg: Separate (earlier stage) parser: Is it possible (other than by having respective rules for  #&apos;^* &apos; ,  #&apos;^** &apos; ,  #&apos;^*** &apos; , etc) to easily produce  h1 ,  h2 ,  h3 , etc?"><span class="u" id="1467663066.000067">2016:07:04 20:11:06        seylerius </span><span>@aengelberg: Separate (earlier stage) parser: Is it possible (other than by having respective rules for </span><code>#&apos;^* &apos;</code><span>, </span><code>#&apos;^** &apos;</code><span>, </span><code>#&apos;^*** &apos;</code><span>, etc) to easily produce </span><code>h1</code><span>, </span><code>h2</code><span>, </span><code>h3</code><span>, etc?</span></div><div data-t="seylerius Actually, yeah. Just don&apos;t hide the token, and I can put that through a counter after the fact."><span class="u" id="1467663625.000068">2016:07:04 20:20:25        seylerius </span><span>Actually, yeah. Just don&apos;t hide the token, and I can put that through a counter after the fact.</span></div><div data-t="seylerius @aengelberg: I&apos;m trying to make blank lines in one parser flag as  :blank , but they&apos;re staying as empty seqs. 
Parser:  http://sprunge.us/RcOf 
Tester:  http://sprunge.us/GGdK"><span class="u" id="1467678938.000069">2016:07:05 00:35:38        seylerius </span><span>@aengelberg: I&apos;m trying to make blank lines in one parser flag as </span><code>:blank</code><span>, but they&apos;re staying as empty seqs. 
Parser: </span><a href="http://sprunge.us/RcOf">http://sprunge.us/RcOf</a><span>
Tester: </span><a href="http://sprunge.us/GGdK">http://sprunge.us/GGdK</a></div><div data-t="aengelberg currently that parser doesn&apos;t account for any newlines (`\n`) between the lines / blank lines, is that intentional?"><span class="u" id="1467679158.000070">2016:07:05 00:39:18       aengelberg </span><span>currently that parser doesn&apos;t account for any newlines (`\n`) between the lines / blank lines, is that intentional?</span></div><div data-t="seylerius The library I&apos;m modifying reads the file into a line-seq initially, so I&apos;m mostly just going with that."><span class="u" id="1467680082.000071">2016:07:05 00:54:42        seylerius </span><span>The library I&apos;m modifying reads the file into a line-seq initially, so I&apos;m mostly just going with that.</span></div><div data-t="seylerius @aengelberg: Think it would be easier if it was parsing the original, and not a line-seq?"><span class="u" id="1467746797.000072">2016:07:05 19:26:37        seylerius </span><span>@aengelberg: Think it would be easier if it was parsing the original, and not a line-seq?</span></div><div data-t="aengelberg it may be useful to, instead of line-seq, use a different parser on the original input that identifies the sections / subsections but not the inline syntax."><span class="u" id="1467747027.000073">2016:07:05 19:30:27       aengelberg </span><span>it may be useful to, instead of line-seq, use a different parser on the original input that identifies the sections / subsections but not the inline syntax.</span></div><div data-t="seylerius Yeah. I&apos;m already splitting it into multiple instaparsers. I take it insta can handle multi-line input?"><span class="u" id="1467747131.000074">2016:07:05 19:32:11        seylerius </span><span>Yeah. I&apos;m already splitting it into multiple instaparsers. I take it insta can handle multi-line input?</span></div><div data-t="aengelberg yeah, just make sure all your strings / regexes handle them. All characters are equal citizens in instaparse input, it&apos;s up to the grammar to handle what it wants to handle. And make sure the grammar handles CRLFs (`\r\n`) which may appear."><span class="u" id="1467747243.000075">2016:07:05 19:34:03       aengelberg </span><span>yeah, just make sure all your strings / regexes handle them. All characters are equal citizens in instaparse input, it&apos;s up to the grammar to handle what it wants to handle. And make sure the grammar handles CRLFs (`\r\n`) which may appear.</span></div><div data-t="seylerius @aengelberg: So make sure my regexps are multi-line and whatnot?"><span class="u" id="1467757336.000076">2016:07:05 22:22:16        seylerius </span><span>@aengelberg: So make sure my regexps are multi-line and whatnot?</span></div><div data-t="aengelberg yep"><span class="u" id="1467757647.000077">2016:07:05 22:27:27       aengelberg </span><span>yep</span></div><div data-t="aengelberg e.g.  .  inside a regex matches any non-newline character"><span class="u" id="1467757664.000078">2016:07:05 22:27:44       aengelberg </span><span>e.g. </span><code>.</code><span> inside a regex matches any non-newline character</span></div><div data-t="aengelberg also,  \s  inside a regex handles any kind of whitespace (including newlines)"><span class="u" id="1467758152.000079">2016:07:05 22:35:52       aengelberg </span><span>also, </span><code>\s</code><span> inside a regex handles any kind of whitespace (including newlines)</span></div><div data-t="seylerius Good caveats to know, thanks"><span class="u" id="1467758454.000080">2016:07:05 22:40:54        seylerius </span><span>Good caveats to know, thanks</span></div><div data-t="seylerius @aengelberg: Any particular instaparse way to go multi-line, or just specify it in the regexps?"><span class="u" id="1467871526.000081">2016:07:07 06:05:26        seylerius </span><span>@aengelberg: Any particular instaparse way to go multi-line, or just specify it in the regexps?</span></div><div data-t="aengelberg @seylerius not sure what exactly you&apos;re confused about, but here are some examples:
imagine you&apos;re parsing the following input:
 aaaa
bbb
cccccc
 
the grammar could look like
 S = A &apos;\n&apos; B &apos;\n&apos; C
A = &apos;a&apos;+
B = &apos;b&apos;+
C = &apos;c&apos;+
"><span class="u" id="1467911408.000082">2016:07:07 17:10:08       aengelberg </span><span>@seylerius not sure what exactly you&apos;re confused about, but here are some examples:
imagine you&apos;re parsing the following input:
</span><pre>aaaa
bbb
cccccc
</pre><span>
the grammar could look like
</span><pre>S = A &apos;\n&apos; B &apos;\n&apos; C
A = &apos;a&apos;+
B = &apos;b&apos;+
C = &apos;c&apos;+
</pre></div><div data-t="aengelberg or
 S = #&apos;a+\n&apos; #&apos;b+\n&apos; #&apos;c+&apos;
"><span class="u" id="1467911445.000083">2016:07:07 17:10:45       aengelberg </span><span>or
</span><pre>S = #&apos;a+\n&apos; #&apos;b+\n&apos; #&apos;c+&apos;
</pre></div><div data-t="aengelberg either  \n  or  \\n  would work if you are inside a Clojure string."><span class="u" id="1467911505.000084">2016:07:07 17:11:45       aengelberg </span><span>either </span><code>\n</code><span> or </span><code>\\n</code><span> would work if you are inside a Clojure string.</span></div><div data-t="aengelberg S = A ows B ows C
A = &apos;a&apos;+
B = &apos;b&apos;+
C = &apos;c&apos;+
(* optional whitespace *)
&lt;ows&gt; = &lt;#&apos;\s*&apos;&gt;
"><span class="u" id="1467911612.000085">2016:07:07 17:13:32       aengelberg </span><pre>S = A ows B ows C
A = &apos;a&apos;+
B = &apos;b&apos;+
C = &apos;c&apos;+
(* optional whitespace *)
&lt;ows&gt; = &lt;#&apos;\s*&apos;&gt;
</pre></div><div data-t="aengelberg For that example, inside a Clojure string you would need to change  \s  to  \\s ."><span class="u" id="1467911637.000086">2016:07:07 17:13:57       aengelberg </span><span>For that example, inside a Clojure string you would need to change </span><code>\s</code><span> to </span><code>\\s</code><span>.</span></div><div data-t="seylerius @aengelberg: Also, how would you modify what would normally be a  .*  to not eat an optional  :[  that follows it? Or would you just post-process that out after?"><span class="u" id="1467913334.000087">2016:07:07 17:42:14        seylerius </span><span>@aengelberg: Also, how would you modify what would normally be a </span><code>.*</code><span> to not eat an optional </span><code>:[</code><span> that follows it? Or would you just post-process that out after?</span></div><div data-t="aengelberg so you&apos;re trying to parse  #&quot;shown-part hidden-part&quot;  but only return  &quot;shown-part&quot;  in the parse result?"><span class="u" id="1467913476.000088">2016:07:07 17:44:36       aengelberg </span><span>so you&apos;re trying to parse </span><code>#&quot;shown-part hidden-part&quot;</code><span> but only return </span><code>&quot;shown-part&quot;</code><span> in the parse result?</span></div><div data-t="aengelberg you could use the regex lookahead to omit it from the result, but then actually parse it (with instaparse&apos;s  &lt;&gt;  hiding feature) in order to properly advance the parser.
 S = #&apos;shown-part(?=hidden-part)&apos; &lt;#&apos;hidden-part&apos;&gt;
"><span class="u" id="1467913617.000089">2016:07:07 17:46:57       aengelberg </span><span>you could use the regex lookahead to omit it from the result, but then actually parse it (with instaparse&apos;s </span><code>&lt;&gt;</code><span> hiding feature) in order to properly advance the parser.
</span><pre>S = #&apos;shown-part(?=hidden-part)&apos; &lt;#&apos;hidden-part&apos;&gt;
</pre></div><div data-t="aengelberg or unhide the second  #&apos;hidden-part&apos;  if you actually do want it in the parse tree, but separate from  #&apos;shown-part&apos; ."><span class="u" id="1467913829.000090">2016:07:07 17:50:29       aengelberg </span><span>or unhide the second </span><code>#&apos;hidden-part&apos;</code><span> if you actually do want it in the parse tree, but separate from </span><code>#&apos;shown-part&apos;</code><span>.</span></div><div data-t="seylerius @aengelberg: More like org-mode headlines allow tags at the end in that style. Not hidden so much as separate."><span class="u" id="1467916756.000091">2016:07:07 18:39:16        seylerius </span><span>@aengelberg: More like org-mode headlines allow tags at the end in that style. Not hidden so much as separate.</span></div><div data-t="seylerius @aengelberg: Basically, how would you parse an optional non-hidden token that follows a token that may contain things somewhat similar to the optional non-hidden token?"><span class="u" id="1467952087.000092">2016:07:08 04:28:07        seylerius </span><span>@aengelberg: Basically, how would you parse an optional non-hidden token that follows a token that may contain things somewhat similar to the optional non-hidden token?</span></div><div data-t="seylerius Ah, I see what you&apos;re talking about"><span class="u" id="1468261311.000093">2016:07:11 18:21:51        seylerius </span><span>Ah, I see what you&apos;re talking about</span></div><div data-t="uwo Is there anyway to prevent  intsta/parse  from printing to the repl on error?"><span class="u" id="1471480536.000007">2016:08:18 00:35:36              uwo </span><span>Is there anyway to prevent </span><code>intsta/parse</code><span> from printing to the repl on error?</span></div><div data-t="seylerius Hrm. Is there a way to make some tokens higher priority than others? This parser ( http://sprunge.us/hFCU ) eats the entire input file, failing to break out the initial metadata."><span class="u" id="1471574879.000008">2016:08:19 02:47:59        seylerius </span><span>Hrm. Is there a way to make some tokens higher priority than others? This parser (</span><a href="http://sprunge.us/hFCU">http://sprunge.us/hFCU</a><span>) eats the entire input file, failing to break out the initial metadata.</span></div><div data-t="seylerius When I try to make the  content  token reluctant (adding a  ?  to the  * ), it fails to match when the content section begins."><span class="u" id="1471574972.000009">2016:08:19 02:49:32        seylerius </span><span>When I try to make the </span><code>content</code><span> token reluctant (adding a </span><code>?</code><span> to the </span><code>*</code><span>), it fails to match when the content section begins.</span></div><div data-t="dave @seylerius you could use ordered choice  https://github.com/Engelberg/instaparse#ordered-choice"><span class="u" id="1471615915.000010">2016:08:19 14:11:55             dave </span><span>@seylerius you could use ordered choice </span><a href="https://github.com/Engelberg/instaparse#ordered-choice">https://github.com/Engelberg/instaparse#ordered-choice</a></div><div data-t="dave define a rule that could be one or the other, using  /  instead of  | , and put the one you prefer first"><span class="u" id="1471615948.000012">2016:08:19 14:12:28             dave </span><span>define a rule that could be one or the other, using </span><code>/</code><span> instead of </span><code>|</code><span>, and put the one you prefer first</span></div><div data-t="dave although, it looks like your title rule is probably consuming everything"><span class="u" id="1471616012.000013">2016:08:19 14:13:32             dave </span><span>although, it looks like your title rule is probably consuming everything</span></div><div data-t="dave #&apos;.*&apos;"><span class="u" id="1471616025.000014">2016:08:19 14:13:45             dave </span><code>#&apos;.*&apos;</code></div><div data-t="dave that will consume everything"><span class="u" id="1471616030.000015">2016:08:19 14:13:50             dave </span><span>that will consume everything</span></div><div data-t="seylerius Nope, it&apos;s not eating newlines."><span class="u" id="1471616045.000016">2016:08:19 14:14:05        seylerius </span><span>Nope, it&apos;s not eating newlines.</span></div><div data-t="seylerius This looks like it&apos;s going to do it."><span class="u" id="1471616055.000017">2016:08:19 14:14:15        seylerius </span><span>This looks like it&apos;s going to do it.</span></div><div data-t="dave oh, you&apos;re right!"><span class="u" id="1471616058.000018">2016:08:19 14:14:18             dave </span><span>oh, you&apos;re right!</span></div><div data-t="aengelberg @uwo: instaparse doesn&apos;t print anything when a failure occurs. It returns a  instaparse.Failure  object which happens to print in a special way at the REPL"><span class="u" id="1471625134.000019">2016:08:19 16:45:34       aengelberg </span><span>@uwo: instaparse doesn&apos;t print anything when a failure occurs. It returns a </span><code>instaparse.Failure</code><span> object which happens to print in a special way at the REPL</span></div><div data-t="seylerius Okay, I&apos;m producing hiccup-style structures from inataparse. I need help figuring out how to re-parse specific items within the structure."><span class="u" id="1472313305.000020">2016:08:27 15:55:05        seylerius </span><span>Okay, I&apos;m producing hiccup-style structures from inataparse. I need help figuring out how to re-parse specific items within the structure.</span></div><div data-t="seylerius Solo strings (unmatched with a tag) are one of the types I need to re- parse in place"><span class="u" id="1472313399.000021">2016:08:27 15:56:39        seylerius </span><span>Solo strings (unmatched with a tag) are one of the types I need to re- parse in place</span></div><div data-t="seylerius Wait, this would go better in #C03S1KBA2"><span class="u" id="1472313439.000022">2016:08:27 15:57:19        seylerius </span><span>Wait, this would go better in #C03S1KBA2</span></div><div data-t="seylerius Didn&apos;t realize I was still in instaparse"><span class="u" id="1472313549.000023">2016:08:27 15:59:09        seylerius </span><span>Didn&apos;t realize I was still in instaparse</span></div><div data-t="aengelberg @seylerius this is a good place for that."><span class="u" id="1472343669.000024">2016:08:28 00:21:09       aengelberg </span><span>@seylerius this is a good place for that.</span></div><div data-t="aengelberg You could put further &quot;insta/parse&quot;s in the functions inside the &quot;insta/transform&quot; map"><span class="u" id="1472343695.000025">2016:08:28 00:21:35       aengelberg </span><span>You could put further &quot;insta/parse&quot;s in the functions inside the &quot;insta/transform&quot; map</span></div><div data-t="seylerius Wat"><span class="u" id="1472343708.000026">2016:08:28 00:21:48        seylerius </span><span>Wat</span></div><div data-t="seylerius This is awesome."><span class="u" id="1472343713.000027">2016:08:28 00:21:53        seylerius </span><span>This is awesome.</span></div><div data-t="aengelberg (insta/transform {:x (fn [s] (insta/parse otherparser s))} (insta/parse firstparser s)"><span class="u" id="1472343785.000028">2016:08:28 00:23:05       aengelberg </span><code>(insta/transform {:x (fn [s] (insta/parse otherparser s))} (insta/parse firstparser s)</code></div><div data-t="aengelberg Hard to bang out a good example on mobile"><span class="u" id="1472343792.000029">2016:08:28 00:23:12       aengelberg </span><span>Hard to bang out a good example on mobile</span></div><div data-t="seylerius Lolyep."><span class="u" id="1472343818.000030">2016:08:28 00:23:38        seylerius </span><span>Lolyep.</span></div><div data-t="seylerius That looks fascinating."><span class="u" id="1472343826.000032">2016:08:28 00:23:46        seylerius </span><span>That looks fascinating.</span></div><div data-t="aengelberg It would get weird if the nested parser had an error though."><span class="u" id="1472343852.000033">2016:08:28 00:24:12       aengelberg </span><span>It would get weird if the nested parser had an error though.</span></div><div data-t="seylerius Yeah."><span class="u" id="1472343859.000034">2016:08:28 00:24:19        seylerius </span><span>Yeah.</span></div><div data-t="seylerius So how deep does it go looking for  :x ?"><span class="u" id="1472343929.000035">2016:08:28 00:25:29        seylerius </span><span>So how deep does it go looking for </span><code>:x</code><span>?</span></div><div data-t="seylerius And how do you make it check for loose strings?"><span class="u" id="1472343969.000036">2016:08:28 00:26:09        seylerius </span><span>And how do you make it check for loose strings?</span></div><div data-t="aengelberg It does a full traversal of the hiccup / enlive, as long as all structures around the  :x  are valid hiccup / enlive"><span class="u" id="1472344017.000037">2016:08:28 00:26:57       aengelberg </span><span>It does a full traversal of the hiccup / enlive, as long as all structures around the </span><code>:x</code><span> are valid hiccup / enlive</span></div><div data-t="seylerius Nice"><span class="u" id="1472344025.000038">2016:08:28 00:27:05        seylerius </span><span>Nice</span></div><div data-t="seylerius @aengelberg: How do you get solo strings?"><span class="u" id="1472345954.000039">2016:08:28 00:59:14        seylerius </span><span>@aengelberg: How do you get solo strings?</span></div><div data-t="seylerius Gah, what&apos;s wrong with this parser?  doc-metadata  works fine, but running  headlines  on the remaining content just returns flat content.  https://github.com/seylerius/organum"><span class="u" id="1472418079.000002">2016:08:28 21:01:19        seylerius </span><span>Gah, what&apos;s wrong with this parser? </span><code>doc-metadata</code><span> works fine, but running </span><code>headlines</code><span> on the remaining content just returns flat content. </span><a href="https://github.com/seylerius/organum">https://github.com/seylerius/organum</a></div><div data-t="seylerius @aengelberg: Got any clues?"><span class="u" id="1472418156.000004">2016:08:28 21:02:36        seylerius </span><span>@aengelberg: Got any clues?</span></div><div data-t="seylerius Simple reproduction:  (headlines (last (doc-metadata (slurp &quot;&quot;)))) "><span class="u" id="1472418237.000005">2016:08:28 21:03:57        seylerius </span><span>Simple reproduction: </span><code>(headlines (last (doc-metadata (slurp &quot;&quot;)))) </code></div><div data-t="seylerius It&apos;s something in the  h  token, because that&apos;s the last thing I changed before it started failing."><span class="u" id="1472418308.000006">2016:08:28 21:05:08        seylerius </span><span>It&apos;s something in the </span><code>h</code><span> token, because that&apos;s the last thing I changed before it started failing.</span></div><div data-t="ska At a first glance, the  #&apos;.+&apos;  looks suspicious to me.  Is greediness biting you here? (Did not try it out, though)"><span class="u" id="1472418645.000007">2016:08:28 21:10:45              ska </span><span>At a first glance, the </span><code>#&apos;.+&apos;</code><span> looks suspicious to me.  Is greediness biting you here? (Did not try it out, though)</span></div><div data-t="aengelberg @seylerius the regex you put for  :content  is probably not what you want. Due to the  (?s)  flag, seems to match everything including newlines, as long as the first character is not a  * ."><span class="u" id="1472419500.000008">2016:08:28 21:25:00       aengelberg </span><span>@seylerius the regex you put for </span><code>:content</code><span> is probably not what you want. Due to the </span><code>(?s)</code><span> flag, seems to match everything including newlines, as long as the first character is not a </span><code>*</code><span>.</span></div><div data-t="aengelberg I&apos;m not sure what your desired behavior is though."><span class="u" id="1472419506.000009">2016:08:28 21:25:06       aengelberg </span><span>I&apos;m not sure what your desired behavior is though.</span></div><div data-t="aengelberg BTW, both the first  ^  and the  ?  in your regex appear redundant, if I understand it correctly."><span class="u" id="1472419576.000010">2016:08:28 21:26:16       aengelberg </span><span>BTW, both the first </span><code>^</code><span> and the </span><code>?</code><span> in your regex appear redundant, if I understand it correctly.</span></div><div data-t="seylerius The content regexp is fine. It&apos;s after I changed a few things to tidy up  :h  and added tag parsing that it started failing."><span class="u" id="1472419589.000011">2016:08:28 21:26:29        seylerius </span><span>The content regexp is fine. It&apos;s after I changed a few things to tidy up </span><code>:h</code><span> and added tag parsing that it started failing.</span></div><div data-t="seylerius Basically, a headline starts with some number of stars. Everything else isn&apos;t a headline."><span class="u" id="1472419614.000012">2016:08:28 21:26:54        seylerius </span><span>Basically, a headline starts with some number of stars. Everything else isn&apos;t a headline.</span></div><div data-t="aengelberg I cloned your project and am looking at that parser. Is there a different version / branch I missed?"><span class="u" id="1472419616.000013">2016:08:28 21:26:56       aengelberg </span><span>I cloned your project and am looking at that parser. Is there a different version / branch I missed?</span></div><div data-t="seylerius Nope, I pushed the latest version just before I spoke up today."><span class="u" id="1472419658.000014">2016:08:28 21:27:38        seylerius </span><span>Nope, I pushed the latest version just before I spoke up today.</span></div><div data-t="aengelberg Sorry I may have been unclear. When I said  :content  I meant the content inside the headlines parser."><span class="u" id="1472419693.000015">2016:08:28 21:28:13       aengelberg </span><span>Sorry I may have been unclear. When I said </span><code>:content</code><span> I meant the content inside the headlines parser.</span></div><div data-t="aengelberg Not the doc-metadata parser"><span class="u" id="1472419706.000016">2016:08:28 21:28:26       aengelberg </span><span>Not the doc-metadata parser</span></div><div data-t="aengelberg As an experiment I removed all the hide-tags from the headlines parser, since I got that behavior you were talking about (flat content). That exposed the headlines&apos;  :content  rule as being greedy."><span class="u" id="1472419745.000017">2016:08:28 21:29:05       aengelberg </span><span>As an experiment I removed all the hide-tags from the headlines parser, since I got that behavior you were talking about (flat content). That exposed the headlines&apos; </span><code>:content</code><span> rule as being greedy.</span></div><div data-t="aengelberg organum.core&gt; (headlines content)
[:S [:token [:content &quot;This is an attempt...
"><span class="u" id="1472419806.000018">2016:08:28 21:30:06       aengelberg </span><pre>organum.core&gt; (headlines content)
[:S [:token [:content &quot;This is an attempt...
</pre></div><div data-t="seylerius Yep. I&apos;ve got an ordered choice making it prefer to define a section (headline then content) if possible, and just content if not. The defining difference between content and headline is whether it starts with stars."><span class="u" id="1472419820.000019">2016:08:28 21:30:20        seylerius </span><span>Yep. I&apos;ve got an ordered choice making it prefer to define a section (headline then content) if possible, and just content if not. The defining difference between content and headline is whether it starts with stars.</span></div><div data-t="seylerius Although, Hmmm. You&apos;ve got a point about the mode there."><span class="u" id="1472419871.000020">2016:08:28 21:31:11        seylerius </span><span>Although, Hmmm. You&apos;ve got a point about the mode there.</span></div><div data-t="aengelberg I think this is what happened:
- The  section  rule failed at the start of the string
- It then fell back to the  content  rule due to ordered choice
- The  content  rule mistakenly parses the whole string (for the reason I mentioned above)
- Parse is done"><span class="u" id="1472419918.000021">2016:08:28 21:31:58       aengelberg </span><span>I think this is what happened:
- The </span><code>section</code><span> rule failed at the start of the string
- It then fell back to the </span><code>content</code><span> rule due to ordered choice
- The </span><code>content</code><span> rule mistakenly parses the whole string (for the reason I mentioned above)
- Parse is done</span></div><div data-t="seylerius Yeah. You&apos;re right. Making the content rule less accepting (not  (?s) ) fixes that part, and now I&apos;m seeing failures to parse the first headline. Joy."><span class="u" id="1472420062.000023">2016:08:28 21:34:22        seylerius </span><span>Yeah. You&apos;re right. Making the content rule less accepting (not </span><code>(?s)</code><span>) fixes that part, and now I&apos;m seeing failures to parse the first headline. Joy.</span></div><div data-t="seylerius How does inataparse play with non-capturing groups?"><span class="u" id="1472420187.000024">2016:08:28 21:36:27        seylerius </span><span>How does inataparse play with non-capturing groups?</span></div><div data-t="aengelberg Not familiar with that term; are you referring to the groups returned by a Java regex match?"><span class="u" id="1472420289.000025">2016:08:28 21:38:09       aengelberg </span><span>Not familiar with that term; are you referring to the groups returned by a Java regex match?</span></div><div data-t="seylerius Non-capturing groups are for saying, &quot;this should be here, but don&apos;t return it in a group&quot;"><span class="u" id="1472420404.000026">2016:08:28 21:40:04        seylerius </span><span>Non-capturing groups are for saying, &quot;this should be here, but don&apos;t return it in a group&quot;</span></div><div data-t="seylerius Okay, new push. Can&apos;t manage to get tags out separate."><span class="u" id="1472420439.000027">2016:08:28 21:40:39        seylerius </span><span>Okay, new push. Can&apos;t manage to get tags out separate.</span></div><div data-t="aengelberg oh, you mean things like regex lookahead and lookbehind?"><span class="u" id="1472420480.000028">2016:08:28 21:41:20       aengelberg </span><span>oh, you mean things like regex lookahead and lookbehind?</span></div><div data-t="seylerius They work if I make them mandatory, but get eaten by the headline body if they&apos;re optional. Would lookahead allow saying &quot;if there&apos;s whitespace followed by a colon, stop here&quot;?"><span class="u" id="1472420561.000029">2016:08:28 21:42:41        seylerius </span><span>They work if I make them mandatory, but get eaten by the headline body if they&apos;re optional. Would lookahead allow saying &quot;if there&apos;s whitespace followed by a colon, stop here&quot;?</span></div><div data-t="aengelberg This is the instaparse source code that applies regexes, may shed some light on whether certain constructs would work.  https://github.com/Engelberg/instaparse/blob/master/src/instaparse/gll.clj#L670"><span class="u" id="1472420737.000030">2016:08:28 21:45:37       aengelberg </span><span>This is the instaparse source code that applies regexes, may shed some light on whether certain constructs would work. </span><a href="https://github.com/Engelberg/instaparse/blob/master/src/instaparse/gll.clj#L670">https://github.com/Engelberg/instaparse/blob/master/src/instaparse/gll.clj#L670</a></div><div data-t="aengelberg I would expect regex non matching lookaheads to work, but non-matching lookbehinds to NOT work. Instaparse runs a regex match on the substring of the current index onward, so previous characters are invisible. EDIT: I misunderstood the term &quot;non-matching&quot;"><span class="u" id="1472420841.000032">2016:08:28 21:47:21       aengelberg </span><span>I would expect regex non matching lookaheads to work, but non-matching lookbehinds to NOT work. Instaparse runs a regex match on the substring of the current index onward, so previous characters are invisible. EDIT: I misunderstood the term &quot;non-matching&quot;</span></div><div data-t="aengelberg I see you&apos;re using  (?:)  now. I don&apos;t think &quot;non capturing&quot; is what you want"><span class="u" id="1472420951.000033">2016:08:28 21:49:11       aengelberg </span><span>I see you&apos;re using </span><code>(?:)</code><span> now. I don&apos;t think &quot;non capturing&quot; is what you want</span></div><div data-t="seylerius I think you&apos;re right."><span class="u" id="1472420962.000034">2016:08:28 21:49:22        seylerius </span><span>I think you&apos;re right.</span></div><div data-t="aengelberg organum.core&gt; (re-find #&quot;a&quot; &quot;a&quot;)
&quot;a&quot;
organum.core&gt; (re-find #&quot;(?:a)&quot; &quot;a&quot;)
&quot;a&quot;
"><span class="u" id="1472420987.000035">2016:08:28 21:49:47       aengelberg </span><pre>organum.core&gt; (re-find #&quot;a&quot; &quot;a&quot;)
&quot;a&quot;
organum.core&gt; (re-find #&quot;(?:a)&quot; &quot;a&quot;)
&quot;a&quot;
</pre></div><div data-t="seylerius What&apos;s weird is non-greedy options fail entirely."><span class="u" id="1472420996.000036">2016:08:28 21:49:56        seylerius </span><span>What&apos;s weird is non-greedy options fail entirely.</span></div><div data-t="aengelberg (?:)  basically means, if there are any other groups  ()  inside that block, DON&apos;T return them as an additional output."><span class="u" id="1472421018.000037">2016:08:28 21:50:18       aengelberg </span><code>(?:)</code><span> basically means, if there are any other groups </span><code>()</code><span> inside that block, DON&apos;T return them as an additional output.</span></div><div data-t="seylerius Ah, it looks like negative lookahead is the trick."><span class="u" id="1472421064.000038">2016:08:28 21:51:04        seylerius </span><span>Ah, it looks like negative lookahead is the trick.</span></div><div data-t="aengelberg (?!=) ?"><span class="u" id="1472421080.000039">2016:08:28 21:51:20       aengelberg </span><code>(?!=)</code><span>?</span></div><div data-t="aengelberg the  ?:  flag shouldn&apos;t affect Instaparse&apos;s usage of regexes at all. Instaparse throws away match groups"><span class="u" id="1472421103.000040">2016:08:28 21:51:43       aengelberg </span><span>the </span><code>?:</code><span> flag shouldn&apos;t affect Instaparse&apos;s usage of regexes at all. Instaparse throws away match groups</span></div><div data-t="seylerius (?!\\s+:)"><span class="u" id="1472421115.000041">2016:08:28 21:51:55        seylerius </span><code>(?!\\s+:)</code></div><div data-t="aengelberg seems legit"><span class="u" id="1472421141.000042">2016:08:28 21:52:21       aengelberg </span><span>seems legit</span></div><div data-t="seylerius Nope. Pushing. Still eats the tags."><span class="u" id="1472421165.000043">2016:08:28 21:52:45        seylerius </span><span>Nope. Pushing. Still eats the tags.</span></div><div data-t="aengelberg hmm"><span class="u" id="1472421180.000045">2016:08:28 21:53:00       aengelberg </span><span>hmm</span></div><div data-t="seylerius Pushed"><span class="u" id="1472421196.000046">2016:08:28 21:53:16        seylerius </span><span>Pushed</span></div><div data-t="aengelberg need to run now, can probably help more in an hour or so. I&apos;d say the next step is manually parsing the regexes on the strings."><span class="u" id="1472421231.000047">2016:08:28 21:53:51       aengelberg </span><span>need to run now, can probably help more in an hour or so. I&apos;d say the next step is manually parsing the regexes on the strings.</span></div><div data-t="aengelberg and try gradually taking characters away from the regex to see what the problem is"><span class="u" id="1472421258.000048">2016:08:28 21:54:18       aengelberg </span><span>and try gradually taking characters away from the regex to see what the problem is</span></div><div data-t="seylerius Okay, thanks for the help. Talk with ya when you&apos;ve got time."><span class="u" id="1472421263.000049">2016:08:28 21:54:23        seylerius </span><span>Okay, thanks for the help. Talk with ya when you&apos;ve got time.</span></div><div data-t="aengelberg feel free to dump any further findings here"><span class="u" id="1472421276.000050">2016:08:28 21:54:36       aengelberg </span><span>feel free to dump any further findings here</span></div><div data-t="seylerius Will do. Slack has persistence, which is pretty handy"><span class="u" id="1472421297.000051">2016:08:28 21:54:57        seylerius </span><span>Will do. Slack has persistence, which is pretty handy</span></div><div data-t="seylerius Okay, trying reluctance means I only get the first character of the headline, and the rest becomes part of the content."><span class="u" id="1472427283.000052">2016:08:28 23:34:43        seylerius </span><span>Okay, trying reluctance means I only get the first character of the headline, and the rest becomes part of the content.</span></div><div data-t="seylerius Trying lookahead seems to just fail."><span class="u" id="1472427299.000053">2016:08:28 23:34:59        seylerius </span><span>Trying lookahead seems to just fail.</span></div><div data-t="seylerius Okay, tags are mostly fixed, but it&apos;s only grabbing the first one."><span class="u" id="1472427726.000054">2016:08:28 23:42:06        seylerius </span><span>Okay, tags are mostly fixed, but it&apos;s only grabbing the first one.</span></div><div data-t="seylerius Pushed."><span class="u" id="1472427731.000055">2016:08:28 23:42:11        seylerius </span><span>Pushed.</span></div><div data-t="seylerius Would appreciate a look when you have time, @aengelberg"><span class="u" id="1472427749.000056">2016:08:28 23:42:29        seylerius </span><span>Would appreciate a look when you have time, @aengelberg</span></div><div data-t="seylerius Ach. It&apos;s also not getting second headlines. They&apos;re turning into content lines due to newline weirdness."><span class="u" id="1472427810.000057">2016:08:28 23:43:30        seylerius </span><span>Ach. It&apos;s also not getting second headlines. They&apos;re turning into content lines due to newline weirdness.</span></div><div data-t="seylerius Pushed again. Fixed newline weirdness"><span class="u" id="1472428009.000058">2016:08:28 23:46:49        seylerius </span><span>Pushed again. Fixed newline weirdness</span></div><div data-t="seylerius Hah, fixed it. Required post-tag newline/whitespace."><span class="u" id="1472428217.000059">2016:08:28 23:50:17        seylerius </span><span>Hah, fixed it. Required post-tag newline/whitespace.</span></div><div data-t="seylerius Gah. Org is a beautiful format, but it&apos;s a bitch to parse."><span class="u" id="1472428239.000060">2016:08:28 23:50:39        seylerius </span><span>Gah. Org is a beautiful format, but it&apos;s a bitch to parse.</span></div><div data-t="aengelberg The parser breaks if I put into the file
 * The First : Section :foo:bar:
"><span class="u" id="1472428597.000061">2016:08:28 23:56:37       aengelberg </span><span>The parser breaks if I put into the file
</span><pre>* The First : Section :foo:bar:
</pre></div><div data-t="aengelberg Not sure if that&apos;s valid org-mode."><span class="u" id="1472428603.000062">2016:08:28 23:56:43       aengelberg </span><span>Not sure if that&apos;s valid org-mode.</span></div><div data-t="aengelberg @seylerius This approach handles a variety of potential characters before the tags, at the expense of speed, since it parses every single character on the header line to get around regex greediness.
 (def headlines
  (insta/parser
   &quot;&lt;S&gt; = token (ows token)*
    &lt;token&gt; = section / content
    section = h (ows content)*
    h = ows stars &lt;#&apos;\\s+&apos;&gt; (todo &lt;#&apos;\\s+&apos;&gt;)? title
    &lt;title&gt; = (#&apos;.&apos;+ ws-line? tags) / #&apos;.+&apos;
    stars = #&apos;^\\*+&apos;
    todo = #&apos;TODO|DONE&apos;
    tags = &lt;&apos;:&apos;&gt; (tag &lt;&apos;:&apos;&gt;)+ ws
    &lt;tag&gt; = #&apos;["><span class="u" id="1472429149.000063">2016:08:29 00:05:49       aengelberg </span><span>@seylerius This approach handles a variety of potential characters before the tags, at the expense of speed, since it parses every single character on the header line to get around regex greediness.
</span><pre>(def headlines
  (insta/parser
   &quot;&lt;S&gt; = token (ows token)*
    &lt;token&gt; = section / content
    section = h (ows content)*
    h = ows stars &lt;#&apos;\\s+&apos;&gt; (todo &lt;#&apos;\\s+&apos;&gt;)? title
    &lt;title&gt; = (#&apos;.&apos;+ ws-line? tags) / #&apos;.+&apos;
    stars = #&apos;^\\*+&apos;
    todo = #&apos;TODO|DONE&apos;
    tags = &lt;&apos;:&apos;&gt; (tag &lt;&apos;:&apos;&gt;)+ ws
    &lt;tag&gt; = #&apos;[</pre></div><div data-t="seylerius Probably be an uncommon usage, but technically legal, @aengelberg. Probably ought to do something like this. Hmmm."><span class="u" id="1472429327.000064">2016:08:29 00:08:47        seylerius </span><span>Probably be an uncommon usage, but technically legal, @aengelberg. Probably ought to do something like this. Hmmm.</span></div><div data-t="seylerius Yeah, that works. Definitely going to need the follow-up concatenation I was planning on."><span class="u" id="1472429660.000065">2016:08:29 00:14:20        seylerius </span><span>Yeah, that works. Definitely going to need the follow-up concatenation I was planning on.</span></div><div data-t="seylerius Okay, another puzzle for ya, @aengelberg. In this latest push, why isn&apos;t priority getting picked up? I&apos;ve cleaned up some of the names and added an overall  parse  function that takes a string, to simplify testing."><span class="u" id="1472433574.000067">2016:08:29 01:19:34        seylerius </span><span>Okay, another puzzle for ya, @aengelberg. In this latest push, why isn&apos;t priority getting picked up? I&apos;ve cleaned up some of the names and added an overall </span><code>parse</code><span> function that takes a string, to simplify testing.</span></div><div data-t="seylerius (parse (slurp &quot;&quot;))   should work for testing."><span class="u" id="1472433621.000068">2016:08:29 01:20:21        seylerius </span><code>(parse (slurp &quot;&quot;)) </code><span> should work for testing.</span></div><div data-t="seylerius (Thanks a ton for the help, BTW)"><span class="u" id="1472433635.000069">2016:08:29 01:20:35        seylerius </span><span>(Thanks a ton for the help, BTW)</span></div><div data-t="seylerius A priority is defined as a letter preceded by a pound sign, in square brackets.  [#A]  or  [#z] , for example."><span class="u" id="1472433952.000070">2016:08:29 01:25:52        seylerius </span><span>A priority is defined as a letter preceded by a pound sign, in square brackets. </span><code>[#A]</code><span> or </span><code>[#z]</code><span>, for example.</span></div><div data-t="seylerius Lol, whoops. Reversed my pound sign and bracket"><span class="u" id="1472434792.000071">2016:08:29 01:39:52        seylerius </span><span>Lol, whoops. Reversed my pound sign and bracket</span></div><div data-t="seylerius @aengelberg: Can you help me figure out why the parsed sample is not registering as compliant hiccup to  insta/transform ?"><span class="u" id="1472442733.000072">2016:08:29 03:52:13        seylerius </span><span>@aengelberg: Can you help me figure out why the parsed sample is not registering as compliant hiccup to </span><code>insta/transform</code><span>?</span></div><div data-t="seylerius Okay, I see that it&apos;s looking for a root node. Tried to unhide the  document  node, but it&apos;s not showing up."><span class="u" id="1472444949.000073">2016:08:29 04:29:09        seylerius </span><span>Okay, I see that it&apos;s looking for a root node. Tried to unhide the </span><code>document</code><span> node, but it&apos;s not showing up.</span></div><div data-t="aengelberg @seylerius lemme take a look"><span class="u" id="1472444991.000074">2016:08:29 04:29:51       aengelberg </span><span>@seylerius lemme take a look</span></div><div data-t="seylerius Thanks."><span class="u" id="1472445011.000075">2016:08:29 04:30:11        seylerius </span><span>Thanks.</span></div><div data-t="aengelberg @seylerius what&apos;s the repro case?"><span class="u" id="1472445165.000076">2016:08:29 04:32:45       aengelberg </span><span>@seylerius what&apos;s the repro case?</span></div><div data-t="seylerius (parse (slurp &quot;&quot;))   returns a seq, not a vector with a root node."><span class="u" id="1472445221.000077">2016:08:29 04:33:41        seylerius </span><code>(parse (slurp &quot;&quot;)) </code><span> returns a seq, not a vector with a root node.</span></div><div data-t="aengelberg looks like function  reducing  doesn&apos;t exist"><span class="u" id="1472445253.000078">2016:08:29 04:34:13       aengelberg </span><span>looks like function </span><code>reducing</code><span> doesn&apos;t exist</span></div><div data-t="aengelberg CompilerException java.lang.RuntimeException: Unable to resolve symbol: reducing in this context"><span class="u" id="1472445285.000079">2016:08:29 04:34:45       aengelberg </span><code>CompilerException java.lang.RuntimeException: Unable to resolve symbol: reducing in this context</code></div><div data-t="seylerius Cleared that up."><span class="u" id="1472445412.000080">2016:08:29 04:36:52        seylerius </span><span>Cleared that up.</span></div><div data-t="seylerius Thanks"><span class="u" id="1472445417.000081">2016:08:29 04:36:57        seylerius </span><span>Thanks</span></div><div data-t="seylerius Still isn&apos;t giving me a root node, though."><span class="u" id="1472445477.000082">2016:08:29 04:37:57        seylerius </span><span>Still isn&apos;t giving me a root node, though.</span></div><div data-t="seylerius ([:author... , rather than  [:document [:author..."><span class="u" id="1472445542.000083">2016:08:29 04:39:02        seylerius </span><code>([:author...</code><span>, rather than </span><code>[:document [:author...</code></div><div data-t="aengelberg interesting. transforming on a sequence should work. I think you may have found a bug in instaparse."><span class="u" id="1472445664.000084">2016:08:29 04:41:04       aengelberg </span><span>interesting. transforming on a sequence should work. I think you may have found a bug in instaparse.</span></div><div data-t="aengelberg The fact that there&apos;s a string in the uppermost level is what&apos;s throwing it off."><span class="u" id="1472445692.000085">2016:08:29 04:41:32       aengelberg </span><span>The fact that there&apos;s a string in the uppermost level is what&apos;s throwing it off.</span></div><div data-t="seylerius Fascinating"><span class="u" id="1472445803.000086">2016:08:29 04:43:23        seylerius </span><span>Fascinating</span></div><div data-t="seylerius @aengelberg: Maybe make strings pass straight through  transform ?"><span class="u" id="1472445981.000087">2016:08:29 04:46:21        seylerius </span><span>@aengelberg: Maybe make strings pass straight through </span><code>transform</code><span>?</span></div><div data-t="aengelberg I can confirm that&apos;s a bug"><span class="u" id="1472445982.000088">2016:08:29 04:46:22       aengelberg </span><span>I can confirm that&apos;s a bug</span></div><div data-t="aengelberg Yeah, that&apos;s what I&apos;m about to do."><span class="u" id="1472445988.000090">2016:08:29 04:46:28       aengelberg </span><span>Yeah, that&apos;s what I&apos;m about to do.</span></div><div data-t="seylerius Awesome"><span class="u" id="1472445992.000091">2016:08:29 04:46:32        seylerius </span><span>Awesome</span></div><div data-t="aengelberg @seylerius  https://github.com/Engelberg/instaparse/pull/145"><span class="u" id="1472447495.000092">2016:08:29 05:11:35       aengelberg </span><span>@seylerius </span><a href="https://github.com/Engelberg/instaparse/pull/145">https://github.com/Engelberg/instaparse/pull/145</a></div><div data-t="aengelberg oops, didn&apos;t link properly... edited"><span class="u" id="1472447995.000096">2016:08:29 05:19:55       aengelberg </span><span>oops, didn&apos;t link properly... edited</span></div><div data-t="seylerius Downloaded, testing."><span class="u" id="1472448540.000097">2016:08:29 05:29:00        seylerius </span><span>Downloaded, testing.</span></div><div data-t="seylerius It works! Thanks, @aengelberg!"><span class="u" id="1472448548.000098">2016:08:29 05:29:08        seylerius </span><span>It works! Thanks, @aengelberg!</span></div><div data-t="seylerius @aengelberg: Yep, that worked perfectly. What&apos;s the release schedule on that, out of curiosity?"><span class="u" id="1472495406.000099">2016:08:29 18:30:06        seylerius </span><span>@aengelberg: Yep, that worked perfectly. What&apos;s the release schedule on that, out of curiosity?</span></div><div data-t="seylerius In the meantime, I&apos;m moving on to adding additional parsers (drawers, blocks, footnotes, lists, tables, to name a few)."><span class="u" id="1472495587.000100">2016:08:29 18:33:07        seylerius </span><span>In the meantime, I&apos;m moving on to adding additional parsers (drawers, blocks, footnotes, lists, tables, to name a few).</span></div><div data-t="aengelberg @seylerius For instaparse we prefer to merge fixes, bump version numbers / changelogs, and deploy to clojars all at once. And only my dad has the power to do the last part. So whenever he gets around to doing that is when I&apos;d expect to see the latest version. Should be sometime today."><span class="u" id="1472496971.000101">2016:08:29 18:56:11       aengelberg </span><span>@seylerius For instaparse we prefer to merge fixes, bump version numbers / changelogs, and deploy to clojars all at once. And only my dad has the power to do the last part. So whenever he gets around to doing that is when I&apos;d expect to see the latest version. Should be sometime today.</span></div><div data-t="seylerius Shiny. Looking forward to it. Also, shiny that y&apos;all are a father-son team. Be cool if one of my kids coded with me (after I have some)."><span class="u" id="1472497731.000102">2016:08:29 19:08:51        seylerius </span><span>Shiny. Looking forward to it. Also, shiny that y&apos;all are a father-son team. Be cool if one of my kids coded with me (after I have some).</span></div><div data-t="aengelberg Thanks. It&apos;s fun! You may enjoy the Clojure/west 2014 instaparse talk, which provides some backstory on the collaboration"><span class="u" id="1472499094.000103">2016:08:29 19:31:34       aengelberg </span><span>Thanks. It&apos;s fun! You may enjoy the Clojure/west 2014 instaparse talk, which provides some backstory on the collaboration</span></div><div data-t="seylerius Awesome. I&apos;ll check it out"><span class="u" id="1472499737.000104">2016:08:29 19:42:17        seylerius </span><span>Awesome. I&apos;ll check it out</span></div><div data-t="andrei I am trying to write a simple grammar that parses comments:
 /* some text */ , is there a way in instaparse to say any character?
e.g.
 &quot;comment = ‘/*’ .* ‘*/‘&quot;
"><span class="u" id="1472588759.000108">2016:08:30 20:25:59           andrei </span><span>I am trying to write a simple grammar that parses comments:
</span><code>/* some text */</code><span>, is there a way in instaparse to say any character?
e.g.
</span><pre>&quot;comment = ‘/*’ .* ‘*/‘&quot;
</pre></div><div data-t="aengelberg @andrei Instaparse doesn&apos;t have a special character for that, but you can use regular expressions to cover any character"><span class="u" id="1472588844.000109">2016:08:30 20:27:24       aengelberg </span><span>@andrei Instaparse doesn&apos;t have a special character for that, but you can use regular expressions to cover any character</span></div><div data-t="aengelberg e.g.  comment = &apos;/*&apos; #&apos;[\\s\\S]&apos;* &apos;*/&apos;"><span class="u" id="1472588884.000110">2016:08:30 20:28:04       aengelberg </span><span>e.g. </span><code>comment = &apos;/*&apos; #&apos;[\\s\\S]&apos;* &apos;*/&apos;</code></div><div data-t="aengelberg (`#&quot;[\s\S]&quot;` is my personal favorite way to match any character in a regex)"><span class="u" id="1472588947.000111">2016:08:30 20:29:07       aengelberg </span><span>(`#&quot;[\s\S]&quot;` is my personal favorite way to match any character in a regex)</span></div><div data-t="seylerius @andrei: Yeah, you&apos;ll want something like this:
 &quot;comment = &lt;&apos;/*&apos;&gt; #&apos;.*&apos; &lt;&apos;*/&apos;&gt;&quot;
 
My version hides the comment tokens, though @aengelberg&apos;s regexp might be more appropriate."><span class="u" id="1472589004.000112">2016:08:30 20:30:04        seylerius </span><span>@andrei: Yeah, you&apos;ll want something like this:
</span><pre>&quot;comment = &lt;&apos;/*&apos;&gt; #&apos;.*&apos; &lt;&apos;*/&apos;&gt;&quot;
</pre><span>
My version hides the comment tokens, though @aengelberg&apos;s regexp might be more appropriate.</span></div><div data-t="andrei @aengelberg @seylerius thank you for the suggestions. 
I think I got a bit mislead by the source code, 
 https://github.com/Engelberg/instaparse/blob/master/src/instaparse/abnf.clj#L19-L40 
I thought there are some defaults in instaparse"><span class="u" id="1472589043.000113">2016:08:30 20:30:43           andrei </span><span>@aengelberg @seylerius thank you for the suggestions. 
I think I got a bit mislead by the source code, 
</span><a href="https://github.com/Engelberg/instaparse/blob/master/src/instaparse/abnf.clj#L19-L40">https://github.com/Engelberg/instaparse/blob/master/src/instaparse/abnf.clj#L19-L40</a><span>
I thought there are some defaults in instaparse</span></div><div data-t="andrei but now reading through the doc strings, these are only to parse the grammar itself 
 https://github.com/Engelberg/instaparse/blob/master/src/instaparse/abnf.clj#L2"><span class="u" id="1472589083.000115">2016:08:30 20:31:23           andrei </span><span>but now reading through the doc strings, these are only to parse the grammar itself 
</span><a href="https://github.com/Engelberg/instaparse/blob/master/src/instaparse/abnf.clj#L2">https://github.com/Engelberg/instaparse/blob/master/src/instaparse/abnf.clj#L2</a></div><div data-t="aengelberg a couple things I see in @seylerius&apos;s solution:
1)  .  in a regex doesn&apos;t include newlines
2)  .*  will greedily match past the  */  and won&apos;t be able to parse the end of a comment"><span class="u" id="1472589096.000117">2016:08:30 20:31:36       aengelberg </span><span>a couple things I see in @seylerius&apos;s solution:
1) </span><code>.</code><span> in a regex doesn&apos;t include newlines
2) </span><code>.*</code><span> will greedily match past the </span><code>*/</code><span> and won&apos;t be able to parse the end of a comment</span></div><div data-t="aengelberg @andrei Sorry for the misleading code. Those constants are available but only to the ABNF format."><span class="u" id="1472589127.000118">2016:08:30 20:32:07       aengelberg </span><span>@andrei Sorry for the misleading code. Those constants are available but only to the ABNF format.</span></div><div data-t="aengelberg EBNF is the default"><span class="u" id="1472589157.000119">2016:08:30 20:32:37       aengelberg </span><span>EBNF is the default</span></div><div data-t="andrei are there constants for ebnf? looking at the code I think not"><span class="u" id="1472589189.000120">2016:08:30 20:33:09           andrei </span><span>are there constants for ebnf? looking at the code I think not</span></div><div data-t="seylerius @andrei A point to keep in mind with @aengelberg&apos;s solution is that you&apos;ll need to condense the individual characters of the output."><span class="u" id="1472589194.000121">2016:08:30 20:33:14        seylerius </span><span>@andrei A point to keep in mind with @aengelberg&apos;s solution is that you&apos;ll need to condense the individual characters of the output.</span></div><div data-t="andrei @seylerius @aengelberg is there a way for specifying in instaparse to group matches together, s.t. one doesn’t need to condense the  matches?"><span class="u" id="1472589267.000122">2016:08:30 20:34:27           andrei </span><span>@seylerius @aengelberg is there a way for specifying in instaparse to group matches together, s.t. one doesn’t need to condense the  matches?</span></div><div data-t="aengelberg yeah, thanks for clarifying that @seylerius"><span class="u" id="1472589267.000123">2016:08:30 20:34:27       aengelberg </span><span>yeah, thanks for clarifying that @seylerius</span></div><div data-t="seylerius You&apos;ll get output like  [:comment &quot;f&quot; &quot;o&quot; &quot;o&quot; &quot; &quot; &quot;b&quot; &quot;a&quot; &quot;r&quot;]   from input like  /*foo bar*/"><span class="u" id="1472589296.000124">2016:08:30 20:34:56        seylerius </span><span>You&apos;ll get output like </span><code>[:comment &quot;f&quot; &quot;o&quot; &quot;o&quot; &quot; &quot; &quot;b&quot; &quot;a&quot; &quot;r&quot;] </code><span> from input like </span><code>/*foo bar*/</code></div><div data-t="andrei exactly"><span class="u" id="1472589304.000125">2016:08:30 20:35:04           andrei </span><span>exactly</span></div><div data-t="andrei there are ways to use transform and apply str on it"><span class="u" id="1472589323.000126">2016:08:30 20:35:23           andrei </span><span>there are ways to use transform and apply str on it</span></div><div data-t="seylerius Yep."><span class="u" id="1472589329.000127">2016:08:30 20:35:29        seylerius </span><span>Yep.</span></div><div data-t="aengelberg @andrei The official specification for ABNF is more strict and specific than EBNF, and it dictates that those constants are available. EBNF is more of an ambiguous mashup of a variety of standards we were able to find on the internet"><span class="u" id="1472589340.000128">2016:08:30 20:35:40       aengelberg </span><span>@andrei The official specification for ABNF is more strict and specific than EBNF, and it dictates that those constants are available. EBNF is more of an ambiguous mashup of a variety of standards we were able to find on the internet</span></div><div data-t="andrei it just feels that there should be a grammar direct way"><span class="u" id="1472589344.000129">2016:08:30 20:35:44           andrei </span><span>it just feels that there should be a grammar direct way</span></div><div data-t="aengelberg So there are no constants in EBNF, since none of the EBNF resources we found seemed to indicate such"><span class="u" id="1472589366.000130">2016:08:30 20:36:06       aengelberg </span><span>So there are no constants in EBNF, since none of the EBNF resources we found seemed to indicate such</span></div><div data-t="seylerius And remember to wrap your comment tokens in  &lt;&gt;  like I did, so you don&apos;t save the markup itself."><span class="u" id="1472589375.000131">2016:08:30 20:36:15        seylerius </span><span>And remember to wrap your comment tokens in </span><code>&lt;&gt;</code><span> like I did, so you don&apos;t save the markup itself.</span></div><div data-t="aengelberg Sadly there is no grammar direct way to concat the strings"><span class="u" id="1472589391.000132">2016:08:30 20:36:31       aengelberg </span><span>Sadly there is no grammar direct way to concat the strings</span></div><div data-t="seylerius Transform works pretty well, though."><span class="u" id="1472589409.000133">2016:08:30 20:36:49        seylerius </span><span>Transform works pretty well, though.</span></div><div data-t="andrei hmm, or a more elaborated reg exp"><span class="u" id="1472589429.000134">2016:08:30 20:37:09           andrei </span><span>hmm, or a more elaborated reg exp</span></div><div data-t="andrei I am using smth like this for strings
 &lt;string&gt; = dqoute #&apos;([^&quot;\\]|\\.)*&apos; dqoute
   &lt;dqoute&gt; = &lt;&apos;\&quot;&apos;&gt;
"><span class="u" id="1472589475.000135">2016:08:30 20:37:55           andrei </span><span>I am using smth like this for strings
</span><pre>&lt;string&gt; = dqoute #&apos;([^&quot;\\]|\\.)*&apos; dqoute
   &lt;dqoute&gt; = &lt;&apos;\&quot;&apos;&gt;
</pre></div><div data-t="seylerius (insta/transform {:comment (partial apply str)} (comment-parser input-data)) "><span class="u" id="1472589493.000136">2016:08:30 20:38:13        seylerius </span><code>(insta/transform {:comment (partial apply str)} (comment-parser input-data)) </code></div><div data-t="andrei and probably the performance impact is small if one applies transforms"><span class="u" id="1472589545.000137">2016:08:30 20:39:05           andrei </span><span>and probably the performance impact is small if one applies transforms</span></div><div data-t="seylerius Lolyep. Far as I can tell, inataparse does a good job with efficient transforms."><span class="u" id="1472589587.000138">2016:08:30 20:39:47        seylerius </span><span>Lolyep. Far as I can tell, inataparse does a good job with efficient transforms.</span></div><div data-t="aengelberg it depends on the size of the file. Probably actually creating all those individual strings is going to be the bottleneck rather than concatenating them later"><span class="u" id="1472589600.000139">2016:08:30 20:40:00       aengelberg </span><span>it depends on the size of the file. Probably actually creating all those individual strings is going to be the bottleneck rather than concatenating them later</span></div><div data-t="andrei I must admit I was lead astray by regexps vs transforms which is more efficient - although I think its a very premature optimisation"><span class="u" id="1472589606.000140">2016:08:30 20:40:06           andrei </span><span>I must admit I was lead astray by regexps vs transforms which is more efficient - although I think its a very premature optimisation</span></div><div data-t="aengelberg A regex is a sensible solution if you can get it right  🙂"><span class="u" id="1472589627.000141">2016:08:30 20:40:27       aengelberg </span><span>A regex is a sensible solution if you can get it right </span><b>🙂</b></div><div data-t="aengelberg My first thought is to do a negative lookahead for  */  as part of the regex"><span class="u" id="1472589660.000142">2016:08:30 20:41:00       aengelberg </span><span>My first thought is to do a negative lookahead for </span><code>*/</code><span> as part of the regex</span></div><div data-t="seylerius Trouble is, from what I&apos;ve found, that the  */  will get eaten in the  .*"><span class="u" id="1472589778.000143">2016:08:30 20:42:58        seylerius </span><span>Trouble is, from what I&apos;ve found, that the </span><code>*/</code><span> will get eaten in the </span><code>.*</code></div><div data-t="seylerius And the negative lookahead will pass because the end token was already eaten"><span class="u" id="1472589799.000144">2016:08:30 20:43:19        seylerius </span><span>And the negative lookahead will pass because the end token was already eaten</span></div><div data-t="andrei so more reg exp magic for me to look into.
to give a bit more context I am playing around with parsing localizable strings.
 /* This is a comment */

&quot;hello&quot; = &quot;Hello!&quot;;

/* This is another comment */
&quot;click_button&quot; = &quot;Click&quot;;

/* Title bar, prints the number of selected products (The translation should be short due to the limit of 100 characters for the title of the mobile app) */
&quot;bar_print_$_selected_products&quot; = &quot;You Selected %@ Products”;
"><span class="u" id="1472589856.000145">2016:08:30 20:44:16           andrei </span><span>so more reg exp magic for me to look into.
to give a bit more context I am playing around with parsing localizable strings.
</span><pre>/* This is a comment */

&quot;hello&quot; = &quot;Hello!&quot;;

/* This is another comment */
&quot;click_button&quot; = &quot;Click&quot;;

/* Title bar, prints the number of selected products (The translation should be short due to the limit of 100 characters for the title of the mobile app) */
&quot;bar_print_$_selected_products&quot; = &quot;You Selected %@ Products”;
</pre></div><div data-t="andrei just an experiment, nothing production related."><span class="u" id="1472589872.000146">2016:08:30 20:44:32           andrei </span><span>just an experiment, nothing production related.</span></div><div data-t="andrei @aengelberg @seylerius thank you for your help, so far I enjoyed using instaparse.
is cool that I can use some things that I learned in college to do some useful things"><span class="u" id="1472590040.000147">2016:08:30 20:47:20           andrei </span><span>@aengelberg @seylerius thank you for your help, so far I enjoyed using instaparse.
is cool that I can use some things that I learned in college to do some useful things</span></div><div data-t="andrei although I must say that I need to re-learn things about parsers and defining  grammars"><span class="u" id="1472590074.000148">2016:08:30 20:47:54           andrei </span><span>although I must say that I need to re-learn things about parsers and defining  grammars</span></div><div data-t="aengelberg @seylerius I meant a regex negative lookahead, i.e.  #&quot;.*(?!=/\*)&quot;  or something"><span class="u" id="1472590091.000149">2016:08:30 20:48:11       aengelberg </span><span>@seylerius I meant a regex negative lookahead, i.e. </span><code>#&quot;.*(?!=/\*)&quot;</code><span> or something</span></div><div data-t="aengelberg @andrei glad you&apos;re having fun! feel free to ask here if you have any more questions"><span class="u" id="1472590180.000150">2016:08:30 20:49:40       aengelberg </span><span>@andrei glad you&apos;re having fun! feel free to ask here if you have any more questions</span></div><div data-t="seylerius @aengelberg: That&apos;s what I thought. It winds up eating the end-token in the  .*  and passes the negative lookahead anyway. I was fighting that with the headline parser in organum over the weekend."><span class="u" id="1472590199.000151">2016:08:30 20:49:59        seylerius </span><span>@aengelberg: That&apos;s what I thought. It winds up eating the end-token in the </span><code>.*</code><span> and passes the negative lookahead anyway. I was fighting that with the headline parser in organum over the weekend.</span></div><div data-t="seylerius When I was trying to get it to parse tags."><span class="u" id="1472590217.000152">2016:08:30 20:50:17        seylerius </span><span>When I was trying to get it to parse tags.</span></div><div data-t="aengelberg oh, I guess the regex would pass, saying &quot;here&apos;s a sequence of characters (including  /* ), and look, there is not a  /*  *after* these characters!&quot;"><span class="u" id="1472590259.000153">2016:08:30 20:50:59       aengelberg </span><span>oh, I guess the regex would pass, saying &quot;here&apos;s a sequence of characters (including </span><code>/*</code><span>), and look, there is not a </span><code>/*</code><span> *after* these characters!&quot;</span></div><div data-t="seylerius Bingo"><span class="u" id="1472590266.000154">2016:08:30 20:51:06        seylerius </span><span>Bingo</span></div><div data-t="aengelberg so maybe  #&quot;((?!/\*).)*&quot;"><span class="u" id="1472590293.000155">2016:08:30 20:51:33       aengelberg </span><span>so maybe </span><code>#&quot;((?!/\*).)*&quot;</code></div><div data-t="aengelberg that would generate a bunch of match groups though due to the  ()"><span class="u" id="1472590304.000156">2016:08:30 20:51:44       aengelberg </span><span>that would generate a bunch of match groups though due to the </span><code>()</code></div><div data-t="seylerius Gah, lemme see what I did for that in the tags in organum."><span class="u" id="1472590334.000157">2016:08:30 20:52:14        seylerius </span><span>Gah, lemme see what I did for that in the tags in organum.</span></div><div data-t="seylerius https://github.com/seylerius/organum/blob/master/src/organum/core.clj"><span class="u" id="1472590434.000158">2016:08:30 20:53:54        seylerius </span><a href="https://github.com/seylerius/organum/blob/master/src/organum/core.clj">https://github.com/seylerius/organum/blob/master/src/organum/core.clj</a></div><div data-t="seylerius Yeah, ordered choice wound up featuring heavily."><span class="u" id="1472590458.000160">2016:08:30 20:54:18        seylerius </span><span>Yeah, ordered choice wound up featuring heavily.</span></div><div data-t="seylerius Maybe  (&lt;&apos;*/&apos;&gt; / #&apos;.&apos;)+ ?"><span class="u" id="1472590556.000161">2016:08:30 20:55:56        seylerius </span><span>Maybe </span><code>(&lt;&apos;*/&apos;&gt; / #&apos;.&apos;)+</code><span>?</span></div><div data-t="seylerius Always prefer to end a comment if possible, otherwise continue eating characters?"><span class="u" id="1472590581.000162">2016:08:30 20:56:21        seylerius </span><span>Always prefer to end a comment if possible, otherwise continue eating characters?</span></div><div data-t="seylerius Wait, not quite"><span class="u" id="1472590588.000163">2016:08:30 20:56:28        seylerius </span><span>Wait, not quite</span></div><div data-t="seylerius That&apos;ll continue past the end."><span class="u" id="1472590597.000164">2016:08:30 20:56:37        seylerius </span><span>That&apos;ll continue past the end.</span></div><div data-t="seylerius Ach. I need to drive back to the store; I&apos;m done with this client. Check in with y&apos;all in about ten."><span class="u" id="1472590637.000165">2016:08:30 20:57:17        seylerius </span><span>Ach. I need to drive back to the store; I&apos;m done with this client. Check in with y&apos;all in about ten.</span></div><div data-t="andrei I will also catch up with you guys a bit later too or early tomorrow, its getting a bit late here in Berlin."><span class="u" id="1472590987.000166">2016:08:30 21:03:07           andrei </span><span>I will also catch up with you guys a bit later too or early tomorrow, its getting a bit late here in Berlin.</span></div><div data-t="seylerius Have a good one."><span class="u" id="1472592945.000167">2016:08:30 21:35:45        seylerius </span><span>Have a good one.</span></div><div data-t="aengelberg @seylerius the bug you encountered a couple days ago is now pushed to Clojars as Instaparse 1.4.3."><span class="u" id="1472658509.000168">2016:08:31 15:48:29       aengelberg </span><span>@seylerius the bug you encountered a couple days ago is now pushed to Clojars as Instaparse 1.4.3.</span></div><div data-t="aengelberg https://github.com/Engelberg/instaparse/blob/master/CHANGES.md#143"><span class="u" id="1472658526.000169">2016:08:31 15:48:46       aengelberg </span><a href="https://github.com/Engelberg/instaparse/blob/master/CHANGES.md#143">https://github.com/Engelberg/instaparse/blob/master/CHANGES.md#143</a></div><div data-t="seylerius @aengelberg: Shiny! Thanks for the heads up."><span class="u" id="1472658735.000171">2016:08:31 15:52:15        seylerius </span><span>@aengelberg: Shiny! Thanks for the heads up.</span></div><div data-t="aengelberg Or rather, a fix for said bug."><span class="u" id="1472658784.000172">2016:08:31 15:53:04       aengelberg </span><span>Or rather, a fix for said bug.</span></div><div data-t="aengelberg :)"><span class="u" id="1472658787.000173">2016:08:31 15:53:07       aengelberg </span><span>:)</span></div><div data-t="seylerius 😁"><span class="u" id="1472658799.000174">2016:08:31 15:53:19        seylerius </span><b>😁</b></div><div data-t="seylerius So,  (map (partial reparse-string is-table) (nth (parse-file &quot;&quot;) 6))  fails, complaining about a lack of either  #&quot;\r\n&quot;  or  #&quot;[\r\n]&quot; . Essentially, it seems to think a  :br  should start the text line in that section."><span class="u" id="1477559218.000003">2016:10:27 09:06:58        seylerius </span><span>So, </span><code>(map (partial reparse-string is-table) (nth (parse-file &quot;&quot;) 6))</code><span> fails, complaining about a lack of either </span><code>#&quot;\r\n&quot;</code><span> or </span><code>#&quot;[\r\n]&quot;</code><span>. Essentially, it seems to think a </span><code>:br</code><span> should start the text line in that section.</span></div><div data-t="aengelberg @seylerius where is the grammar you&apos;re using to parse? apologies if you posted earlier and I missed it."><span class="u" id="1477585383.000004">2016:10:27 16:23:03       aengelberg </span><span>@seylerius where is the grammar you&apos;re using to parse? apologies if you posted earlier and I missed it.</span></div><div data-t="aengelberg and sample file?"><span class="u" id="1477585392.000005">2016:10:27 16:23:12       aengelberg </span><span>and sample file?</span></div><div data-t="seylerius Ach, forgot to link to the repo.  https://github.com/seylerius/organum"><span class="u" id="1477588802.000006">2016:10:27 17:20:02        seylerius </span><span>Ach, forgot to link to the repo. </span><a href="https://github.com/seylerius/organum">https://github.com/seylerius/organum</a></div><div data-t="be9 Hi, I need to parse strings like  some text with spaces XXX 12345678 98765 43 222 11 . Here are 3 parts: “some text with spaces”, “XXX 12345678”, and &quot;98765 43 222 11”. While the last part is required, the “XXX 12345678” part is optional and will be considered as text by a naive greedy regex. How could I prevent this with Instaparse?"><span class="u" id="1478275091.000009">2016:11:04 15:58:11              be9 </span><span>Hi, I need to parse strings like </span><code>some text with spaces XXX 12345678 98765 43 222 11</code><span>. Here are 3 parts: “some text with spaces”, “XXX 12345678”, and &quot;98765 43 222 11”. While the last part is required, the “XXX 12345678” part is optional and will be considered as text by a naive greedy regex. How could I prevent this with Instaparse?</span></div><div data-t="seylerius @be9 Can you describe the requirements your text needs to meet?"><span class="u" id="1478275187.000010">2016:11:04 15:59:47        seylerius </span><span>@be9 Can you describe the requirements your text needs to meet?</span></div><div data-t="seylerius Or give a few more specific examples?"><span class="u" id="1478275204.000011">2016:11:04 16:00:04        seylerius </span><span>Or give a few more specific examples?</span></div><div data-t="be9 @seylerius Ok, let’s simplify even more. Two examples:  John Doe AGE 50 ,  Dohn Joe . An input string contains a name and might contain this age thing. I want to parse those eventually to  {:name “John Doe” :age 50}  and  {:name “Dohn Joe”} ."><span class="u" id="1478275691.000012">2016:11:04 16:08:11              be9 </span><span>@seylerius Ok, let’s simplify even more. Two examples: </span><code>John Doe AGE 50</code><span>, </span><code>Dohn Joe</code><span>. An input string contains a name and might contain this age thing. I want to parse those eventually to </span><code>{:name “John Doe” :age 50}</code><span> and </span><code>{:name “Dohn Joe”}</code><span>.</span></div><div data-t="be9 First one should not be  {:name “John Doe AGE 50”}   🙂"><span class="u" id="1478275735.000014">2016:11:04 16:08:55              be9 </span><span>First one should not be </span><code>{:name “John Doe AGE 50”}</code><span> </span><b>🙂</b></div><div data-t="seylerius Okay. This is a problem I&apos;ve run into before."><span class="u" id="1478275758.000015">2016:11:04 16:09:18        seylerius </span><span>Okay. This is a problem I&apos;ve run into before.</span></div><div data-t="be9 Names can be long and contain digits too"><span class="u" id="1478275772.000016">2016:11:04 16:09:32              be9 </span><span>Names can be long and contain digits too</span></div><div data-t="be9 John Doe AGE 50 AGE 50  would be preferrably parsed as  {:name “John Doe AGE 50” :age 50}"><span class="u" id="1478275912.000017">2016:11:04 16:11:52              be9 </span><code>John Doe AGE 50 AGE 50</code><span> would be preferrably parsed as </span><code>{:name “John Doe AGE 50” :age 50}</code></div><div data-t="seylerius Basically what you need is to have a name token, token, and then a name+age token. You then parse for this:  &quot;name-age / name&quot;"><span class="u" id="1478275927.000019">2016:11:04 16:12:07        seylerius </span><span>Basically what you need is to have a name token, token, and then a name+age token. You then parse for this: </span><code>&quot;name-age / name&quot;</code></div><div data-t="seylerius The slash allows you to express a preference for one over the other."><span class="u" id="1478275950.000020">2016:11:04 16:12:30        seylerius </span><span>The slash allows you to express a preference for one over the other.</span></div><div data-t="seylerius Basically, you&apos;re saying &quot;if this string can match an age too, do that, otherwise it&apos;s just a name&quot;"><span class="u" id="1478275984.000021">2016:11:04 16:13:04        seylerius </span><span>Basically, you&apos;re saying &quot;if this string can match an age too, do that, otherwise it&apos;s just a name&quot;</span></div><div data-t="seylerius I do this a lot in my rebuild of organum, if you want to take a look at the repo."><span class="u" id="1478276013.000022">2016:11:04 16:13:33        seylerius </span><span>I do this a lot in my rebuild of organum, if you want to take a look at the repo.</span></div><div data-t="be9 oh, the slash. I see, thanks!"><span class="u" id="1478276034.000023">2016:11:04 16:13:54              be9 </span><span>oh, the slash. I see, thanks!</span></div><div data-t="seylerius Yep. The slash is for preferential parsing."><span class="u" id="1478276066.000024">2016:11:04 16:14:26        seylerius </span><span>Yep. The slash is for preferential parsing.</span></div><div data-t="be9 :+1:  @seylerius, I guess that’s it  🙂"><span class="u" id="1478276092.000025">2016:11:04 16:14:52              be9 </span><b>:+1:</b><span> @seylerius, I guess that’s it </span><b>🙂</b></div><div data-t="alpi May I ask questions on clojurescript port here?"><span class="u" id="1478423184.000027">2016:11:06 09:06:24             alpi </span><span>May I ask questions on clojurescript port here?</span></div><div data-t="aengelberg @alpi sure"><span class="u" id="1478543398.000028">2016:11:07 18:29:58       aengelberg </span><span>@alpi sure</span></div><div data-t="gfredericks I don&apos;t imagine there&apos;s a way to unparse something"><span class="u" id="1483025116.000007">2016:12:29 15:25:16      gfredericks </span><span>I don&apos;t imagine there&apos;s a way to unparse something</span></div><div data-t="seylerius In what sense? Reconstruct the input that was parsed?"><span class="u" id="1483039564.000008">2016:12:29 19:26:04        seylerius </span><span>In what sense? Reconstruct the input that was parsed?</span></div><div data-t="seylerius @gfredericks What are you trying to accomplish by &quot;unparsing&quot;, and how much control do you have over the parsing?"><span class="u" id="1483039693.000009">2016:12:29 19:28:13        seylerius </span><span>@gfredericks What are you trying to accomplish by &quot;unparsing&quot;, and how much control do you have over the parsing?</span></div><div data-t="aengelberg @gfredericks: some discussion has happened about this in  https://github.com/Engelberg/instaparse/issues/82"><span class="u" id="1483043170.000010">2016:12:29 20:26:10       aengelberg </span><span>@gfredericks: some discussion has happened about this in </span><a href="https://github.com/Engelberg/instaparse/issues/82">https://github.com/Engelberg/instaparse/issues/82</a></div><div data-t="aengelberg which I just noticed you saw and commented on"><span class="u" id="1483043235.000012">2016:12:29 20:27:15       aengelberg </span><span>which I just noticed you saw and commented on</span></div><div data-t="aengelberg The fact that &quot;hide tag&quot; (`&lt;&gt;`) is a thing makes it a complex problem to provide unparsing as a general solution"><span class="u" id="1483043360.000013">2016:12:29 20:29:20       aengelberg </span><span>The fact that &quot;hide tag&quot; (`&lt;&gt;`) is a thing makes it a complex problem to provide unparsing as a general solution</span></div><div data-t="aengelberg also lookahead / negative lookahead"><span class="u" id="1483043458.000014">2016:12:29 20:30:58       aengelberg </span><span>also lookahead / negative lookahead</span></div><div data-t="gfredericks I want a canonical printer. Potentially pretty printing...which sounds hard"><span class="u" id="1483050188.000015">2016:12:29 22:23:08      gfredericks </span><span>I want a canonical printer. Potentially pretty printing...which sounds hard</span></div><div data-t="gfredericks So no, not reconstructing the original input exactly"><span class="u" id="1483050191.000016">2016:12:29 22:23:11      gfredericks </span><span>So no, not reconstructing the original input exactly</span></div><div data-t="seylerius Hmmm."><span class="u" id="1483055238.000017">2016:12:29 23:47:18        seylerius </span><span>Hmmm.</span></div><div data-t="gfredericks pretty printing is complex enough that I&apos;m convinced it would be crazy to try to mix it into a grammar somehow"><span class="u" id="1483057515.000018">2016:12:30 00:25:15      gfredericks </span><span>pretty printing is complex enough that I&apos;m convinced it would be crazy to try to mix it into a grammar somehow</span></div><div data-t="gfredericks instaparse requires keywords for the names of the whatchamacallits?"><span class="u" id="1483153227.000019">2016:12:31 03:00:27      gfredericks </span><span>instaparse requires keywords for the names of the whatchamacallits?</span></div><div data-t="gfredericks I think I might be using instaparse in a weird enough way for that to be a very mild problem"><span class="u" id="1483153255.000020">2016:12:31 03:00:55      gfredericks </span><span>I think I might be using instaparse in a weird enough way for that to be a very mild problem</span></div><div data-t="gfredericks because I have to gensym the names and so it&apos;s a memory leak"><span class="u" id="1483153273.000021">2016:12:31 03:01:13      gfredericks </span><span>because I have to gensym the names and so it&apos;s a memory leak</span></div><div data-t="seylerius @gfredericks It outputs either hiccup or enlive notation, so yes it probably would want keywords in reverse."><span class="u" id="1483159621.000022">2016:12:31 04:47:01        seylerius </span><span>@gfredericks It outputs either hiccup or enlive notation, so yes it probably would want keywords in reverse.</span></div><div data-t="aengelberg @gfredericks:
 (def all-keywords-ever (map keyword (range)))

;; each time you dynamically create a parser
(let [my-syms ...
kws (zipmap my-syms all-keywords-ever)]
...)
"><span class="u" id="1483177948.000023">2016:12:31 09:52:28       aengelberg </span><span>@gfredericks:
</span><pre>(def all-keywords-ever (map keyword (range)))

;; each time you dynamically create a parser
(let [my-syms ...
kws (zipmap my-syms all-keywords-ever)]
...)
</pre></div><div data-t="aengelberg That might be a way to conserve on keywords"><span class="u" id="1483177960.000024">2016:12:31 09:52:40       aengelberg </span><span>That might be a way to conserve on keywords</span></div><div data-t="aengelberg Or do a string replace in the grammar to substitute non terminals with reusable symbols, then postwalk the resulting tree to convert back"><span class="u" id="1483178121.000025">2016:12:31 09:55:21       aengelberg </span><span>Or do a string replace in the grammar to substitute non terminals with reusable symbols, then postwalk the resulting tree to convert back</span></div><div data-t="gfredericks I&apos;m using the combinators, so it shouldn&apos;t be too hard to do something like that if I decide this matters"><span class="u" id="1483194290.000026">2016:12:31 14:24:50      gfredericks </span><span>I&apos;m using the combinators, so it shouldn&apos;t be too hard to do something like that if I decide this matters</span></div><div data-t="zmaril @gfredericks @aengelberg if we can actually get generating from grammars going I&apos;d still be really stoked"><span class="u" id="1483213299.000027">2016:12:31 19:41:39           zmaril </span><span>@gfredericks @aengelberg if we can actually get generating from grammars going I&apos;d still be really stoked</span></div><div data-t="zmaril I&apos;ve been working on  https://github.com/zmaril/instaparse-c  the past few weeks and am getting within spitting distance of doing some fun stuff."><span class="u" id="1483213356.000028">2016:12:31 19:42:36           zmaril </span><span>I&apos;ve been working on </span><a href="https://github.com/zmaril/instaparse-c">https://github.com/zmaril/instaparse-c</a><span> the past few weeks and am getting within spitting distance of doing some fun stuff.</span></div><div data-t="zmaril It can basically parse C at this point and I&apos;m working on finishing the macro preprocessor now."><span class="u" id="1483213389.000030">2016:12:31 19:43:09           zmaril </span><span>It can basically parse C at this point and I&apos;m working on finishing the macro preprocessor now.</span></div><div data-t="zmaril The goal is to get the output into datascript and queryable. But a side product of this is that if you have something that can generate strings from grammars then we already have something that can produce c programs (sans macros)."><span class="u" id="1483213517.000032">2016:12:31 19:45:17           zmaril </span><span>The goal is to get the output into datascript and queryable. But a side product of this is that if you have something that can generate strings from grammars then we already have something that can produce c programs (sans macros).</span></div><div data-t="gfredericks @zmaril do you or anybody know if all instaparse grammars are implemented using the combinators?"><span class="u" id="1483214310.000033">2016:12:31 19:58:30      gfredericks </span><span>@zmaril do you or anybody know if all instaparse grammars are implemented using the combinators?</span></div><div data-t="gfredericks s/grammars/parser/"><span class="u" id="1483214319.000034">2016:12:31 19:58:39      gfredericks </span><span>s/grammars/parser/</span></div><div data-t="zmaril Yes they should be"><span class="u" id="1483214335.000035">2016:12:31 19:58:55           zmaril </span><span>Yes they should be</span></div><div data-t="zmaril My understanding is that the ebnf notation that everybody uses is actually parsed by a parser expressed in the combinators that transforms the output into combinators"><span class="u" id="1483214377.000036">2016:12:31 19:59:37           zmaril </span><span>My understanding is that the ebnf notation that everybody uses is actually parsed by a parser expressed in the combinators that transforms the output into combinators</span></div><div data-t="gfredericks I just glanced at the combinator list -- I think only the lookaheads are problematic, but that&apos;s probably a big deal for sophisticated parsers"><span class="u" id="1483214411.000038">2016:12:31 20:00:11      gfredericks </span><span>I just glanced at the combinator list -- I think only the lookaheads are problematic, but that&apos;s probably a big deal for sophisticated parsers</span></div><div data-t="zmaril yep"><span class="u" id="1483214424.000039">2016:12:31 20:00:24           zmaril </span><span>yep</span></div><div data-t="gfredericks so...oh well."><span class="u" id="1483214429.000040">2016:12:31 20:00:29      gfredericks </span><span>so...oh well.</span></div><div data-t="zmaril how does one express negation in generators now?"><span class="u" id="1483214456.000041">2016:12:31 20:00:56           zmaril </span><span>how does one express negation in generators now?</span></div><div data-t="gfredericks you could implement them with  gen/such-that  but the generator would fail if the lookahead condition is unlikely to pass by chance"><span class="u" id="1483214469.000042">2016:12:31 20:01:09      gfredericks </span><span>you could implement them with </span><code>gen/such-that</code><span> but the generator would fail if the lookahead condition is unlikely to pass by chance</span></div><div data-t="gfredericks I have no how that would play out IRL"><span class="u" id="1483214497.000043">2016:12:31 20:01:37      gfredericks </span><span>I have no how that would play out IRL</span></div><div data-t="zmaril That should be fine then. For the parsers I write lookahead is typically used to implement reserved keywords."><span class="u" id="1483214503.000044">2016:12:31 20:01:43           zmaril </span><span>That should be fine then. For the parsers I write lookahead is typically used to implement reserved keywords.</span></div><div data-t="zmaril I&apos;ve never used positive lookahead actually now that I think about it"><span class="u" id="1483214523.000045">2016:12:31 20:02:03           zmaril </span><span>I&apos;ve never used positive lookahead actually now that I think about it</span></div><div data-t="gfredericks when I made the regex→string generator I just decided not to support look[ahead|behind] for the same reason"><span class="u" id="1483214538.000046">2016:12:31 20:02:18      gfredericks </span><span>when I made the regex→string generator I just decided not to support look[ahead|behind] for the same reason</span></div><div data-t="zmaril It&apos;s one of those things that is academic to me at this point"><span class="u" id="1483214558.000047">2016:12:31 20:02:38           zmaril </span><span>It&apos;s one of those things that is academic to me at this point</span></div><div data-t="zmaril I&apos;m pretty sure that 99% gen/such-that of the time would be fine"><span class="u" id="1483214585.000048">2016:12:31 20:03:05           zmaril </span><span>I&apos;m pretty sure that 99% gen/such-that of the time would be fine</span></div><div data-t="gfredericks it might not be too hard to throw together a PoC"><span class="u" id="1483214609.000050">2016:12:31 20:03:29      gfredericks </span><span>it might not be too hard to throw together a PoC</span></div><div data-t="gfredericks in fact that would potentially be useful for what I&apos;m working on right now"><span class="u" id="1483214622.000051">2016:12:31 20:03:42      gfredericks </span><span>in fact that would potentially be useful for what I&apos;m working on right now</span></div><div data-t="zmaril yeah, I think that would fit really well and mirror what spec is doing"><span class="u" id="1483214679.000052">2016:12:31 20:04:39           zmaril </span><span>yeah, I think that would fit really well and mirror what spec is doing</span></div><div data-t="zmaril I&apos;ve been using spec/conform the same way I use instaparse and it works really well"><span class="u" id="1483214692.000053">2016:12:31 20:04:52           zmaril </span><span>I&apos;ve been using spec/conform the same way I use instaparse and it works really well</span></div><div data-t="zmaril So I imagine we could use generators the same way spec does and it would work well (fingers crossed)"><span class="u" id="1483214712.000054">2016:12:31 20:05:12           zmaril </span><span>So I imagine we could use generators the same way spec does and it would work well (fingers crossed)</span></div><div data-t="gfredericks 😂  I just realized that it would require using  string-from-regex  from test.chuck to support regexes in the grammars, and  string-from-regex  uses instaparse to parse the regex."><span class="u" id="1483214852.000055">2016:12:31 20:07:32      gfredericks </span><b>😂</b><span> I just realized that it would require using </span><code>string-from-regex</code><span> from test.chuck to support regexes in the grammars, and </span><code>string-from-regex</code><span> uses instaparse to parse the regex.</span></div><div data-t="zmaril turtles"><span class="u" id="1483214869.000056">2016:12:31 20:07:49           zmaril </span><span>turtles</span></div><div data-t="gfredericks indeed"><span class="u" id="1483214880.000057">2016:12:31 20:08:00      gfredericks </span><span>indeed</span></div><div data-t="zmaril that was the thing that was holding me up actually"><span class="u" id="1483214890.000058">2016:12:31 20:08:10           zmaril </span><span>that was the thing that was holding me up actually</span></div><div data-t="zmaril was that I didn&apos;t want to mess with regexs"><span class="u" id="1483214894.000059">2016:12:31 20:08:14           zmaril </span><span>was that I didn&apos;t want to mess with regexs</span></div><div data-t="aengelberg just catching up"><span class="u" id="1483214970.000060">2016:12:31 20:09:30       aengelberg </span><span>just catching up</span></div><div data-t="aengelberg After I wrote &quot;instagenerate&quot; I realized going the generator route (as opposed to core.logic) would probably be easier, despite the lookahead  such-that  problem"><span class="u" id="1483215030.000061">2016:12:31 20:10:30       aengelberg </span><span>After I wrote &quot;instagenerate&quot; I realized going the generator route (as opposed to core.logic) would probably be easier, despite the lookahead </span><code>such-that</code><span> problem</span></div><div data-t="aengelberg But what do you want to do about hide-tags?"><span class="u" id="1483215041.000062">2016:12:31 20:10:41       aengelberg </span><span>But what do you want to do about hide-tags?</span></div><div data-t="zmaril I think I have an idea, h/o"><span class="u" id="1483215070.000063">2016:12:31 20:11:10           zmaril </span><span>I think I have an idea, h/o</span></div><div data-t="zmaril well, hmmm what is the problem you see with hide-tags?"><span class="u" id="1483215104.000064">2016:12:31 20:11:44           zmaril </span><span>well, hmmm what is the problem you see with hide-tags?</span></div><div data-t="aengelberg It depends on what you expect the &quot;input&quot; to the generator to be"><span class="u" id="1483215134.000065">2016:12:31 20:12:14       aengelberg </span><span>It depends on what you expect the &quot;input&quot; to the generator to be</span></div><div data-t="aengelberg a parse tree still?"><span class="u" id="1483215144.000066">2016:12:31 20:12:24       aengelberg </span><span>a parse tree still?</span></div><div data-t="gfredericks it&apos;d be the combinator"><span class="u" id="1483215154.000067">2016:12:31 20:12:34      gfredericks </span><span>it&apos;d be the combinator</span></div><div data-t="gfredericks it would generate totally random parsable things"><span class="u" id="1483215166.000068">2016:12:31 20:12:46      gfredericks </span><span>it would generate totally random parsable things</span></div><div data-t="gfredericks not based on same partial input"><span class="u" id="1483215173.000069">2016:12:31 20:12:53      gfredericks </span><span>not based on same partial input</span></div><div data-t="aengelberg ok, in that case I don&apos;t really have a problem with hide tags despite just waking up"><span class="u" id="1483215204.000070">2016:12:31 20:13:24       aengelberg </span><span>ok, in that case I don&apos;t really have a problem with hide tags despite just waking up</span></div><div data-t="zmaril I think if we got something going that just took a grammar and gave back random strings, that would be a good first step"><span class="u" id="1483215220.000071">2016:12:31 20:13:40           zmaril </span><span>I think if we got something going that just took a grammar and gave back random strings, that would be a good first step</span></div><div data-t="aengelberg part of why I did core.logic in instagenerate is @zmaril&apos;s initial request to go from partial input -&gt; parseable strings, so I felt the need to put in the sophistication of logic programming as a general solver for all cases"><span class="u" id="1483215290.000072">2016:12:31 20:14:50       aengelberg </span><span>part of why I did core.logic in instagenerate is @zmaril&apos;s initial request to go from partial input -&gt; parseable strings, so I felt the need to put in the sophistication of logic programming as a general solver for all cases</span></div><div data-t="zmaril oh, if we want to do partial input, we can provide skeletons with places to start generating from"><span class="u" id="1483215315.000073">2016:12:31 20:15:15           zmaril </span><span>oh, if we want to do partial input, we can provide skeletons with places to start generating from</span></div><div data-t="zmaril then we just walk the skeleton and generate random strings at the indicated places"><span class="u" id="1483215341.000074">2016:12:31 20:15:41           zmaril </span><span>then we just walk the skeleton and generate random strings at the indicated places</span></div><div data-t="zmaril still not fully general but better"><span class="u" id="1483215364.000075">2016:12:31 20:16:04           zmaril </span><span>still not fully general but better</span></div><div data-t="zmaril and then we could restrict the grammar inside the combinator somehow"><span class="u" id="1483215439.000076">2016:12:31 20:17:19           zmaril </span><span>and then we could restrict the grammar inside the combinator somehow</span></div><div data-t="aengelberg (def p (insta/parser &quot;
S = A B A | B A B
&lt;A&gt; (&apos;a&apos; &lt;&apos;c&apos;&gt; &apos;b&apos;)+
&lt;B&gt; (&apos;b&apos; &apos;a&apos;)+
&quot;))

(generate p [:S &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot;])
=&gt; (&quot;acbbaacb&quot;)
"><span class="u" id="1483215708.000078">2016:12:31 20:21:48       aengelberg </span><pre>(def p (insta/parser &quot;
S = A B A | B A B
&lt;A&gt; (&apos;a&apos; &lt;&apos;c&apos;&gt; &apos;b&apos;)+
&lt;B&gt; (&apos;b&apos; &apos;a&apos;)+
&quot;))

(generate p [:S &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot;])
=&gt; (&quot;acbbaacb&quot;)
</pre></div><div data-t="aengelberg seems hard to performantly solve generally"><span class="u" id="1483215815.000079">2016:12:31 20:23:35       aengelberg </span><span>seems hard to performantly solve generally</span></div><div data-t="zmaril who said anything about performance"><span class="u" id="1483215874.000080">2016:12:31 20:24:34           zmaril </span><span>who said anything about performance</span></div><div data-t="aengelberg 🙂  fair enough"><span class="u" id="1483215879.000081">2016:12:31 20:24:39       aengelberg </span><b>🙂</b><span> fair enough</span></div><div data-t="aengelberg but a generator approach using  such-that  may never complete on a large enough grammar"><span class="u" id="1483215900.000082">2016:12:31 20:25:00       aengelberg </span><span>but a generator approach using </span><code>such-that</code><span> may never complete on a large enough grammar</span></div><div data-t="zmaril cross that bridge when we get there"><span class="u" id="1483215931.000083">2016:12:31 20:25:31           zmaril </span><span>cross that bridge when we get there</span></div><div data-t="zmaril computers are like really fast"><span class="u" id="1483215948.000084">2016:12:31 20:25:48           zmaril </span><span>computers are like really fast</span></div><div data-t="zmaril this is more of a what&apos;s possible idea than a production thing"><span class="u" id="1483215980.000085">2016:12:31 20:26:20           zmaril </span><span>this is more of a what&apos;s possible idea than a production thing</span></div><div data-t="aengelberg cool"><span class="u" id="1483216063.000086">2016:12:31 20:27:43       aengelberg </span><span>cool</span></div><div data-t="aengelberg let me know if I can help out in whichever path you decide to try out"><span class="u" id="1483216080.000087">2016:12:31 20:28:00       aengelberg </span><span>let me know if I can help out in whichever path you decide to try out</span></div><div data-t="zmaril for sure!"><span class="u" id="1483216108.000088">2016:12:31 20:28:28           zmaril </span><span>for sure!</span></div><div data-t="gfredericks yeah generators aren&apos;t generally for production stuff"><span class="u" id="1483216731.000089">2016:12:31 20:38:51      gfredericks </span><span>yeah generators aren&apos;t generally for production stuff</span></div><div data-t="gfredericks I want a combinator that doesn&apos;t match anything"><span class="u" id="1483217000.000090">2016:12:31 20:43:20      gfredericks </span><span>I want a combinator that doesn&apos;t match anything</span></div><div data-t="gfredericks I thought maybe  (combo/alt)  but that returns ε"><span class="u" id="1483217021.000091">2016:12:31 20:43:41      gfredericks </span><span>I thought maybe </span><code>(combo/alt)</code><span> but that returns ε</span></div><div data-t="zmaril (gen/such-that (constantly false)) or something?"><span class="u" id="1483217051.000092">2016:12:31 20:44:11           zmaril </span><span>(gen/such-that (constantly false)) or something?</span></div><div data-t="gfredericks a combinator, not a generator"><span class="u" id="1483217058.000093">2016:12:31 20:44:18      gfredericks </span><span>a combinator, not a generator</span></div><div data-t="zmaril oh right sorry"><span class="u" id="1483217062.000094">2016:12:31 20:44:22           zmaril </span><span>oh right sorry</span></div><div data-t="gfredericks I guess I can do negative lookahead with epsilon?"><span class="u" id="1483217078.000095">2016:12:31 20:44:38      gfredericks </span><span>I guess I can do negative lookahead with epsilon?</span></div><div data-t="zmaril or a really unlikely string?"><span class="u" id="1483217092.000096">2016:12:31 20:44:52           zmaril </span><span>or a really unlikely string?</span></div><div data-t="zmaril like (string &quot;THISWILLNEVERBEMATCHEDHOPEFULLY&quot;)"><span class="u" id="1483217127.000097">2016:12:31 20:45:27           zmaril </span><span>like (string &quot;THISWILLNEVERBEMATCHEDHOPEFULLY&quot;)</span></div><div data-t="gfredericks 🙂"><span class="u" id="1483217172.000098">2016:12:31 20:46:12      gfredericks </span><b>🙂</b></div><div data-t="zmaril we&apos;re not fancy here"><span class="u" id="1483217190.000099">2016:12:31 20:46:30           zmaril </span><span>we&apos;re not fancy here</span></div><div data-t="gfredericks (string (str (java.util.UUID/randomUUID)))"><span class="u" id="1483217198.000100">2016:12:31 20:46:38      gfredericks </span><code>(string (str (java.util.UUID/randomUUID)))</code></div><div data-t="zmaril that works!"><span class="u" id="1483217216.000101">2016:12:31 20:46:56           zmaril </span><span>that works!</span></div><div data-t="gfredericks I have an alternate thing in my codebase that could be called a parser, but instaparse also has something by that name so I called it a parsifier instead"><span class="u" id="1483217304.000102">2016:12:31 20:48:24      gfredericks </span><span>I have an alternate thing in my codebase that could be called a parser, but instaparse also has something by that name so I called it a parsifier instead</span></div><div data-t="gfredericks and it&apos;s hard to remember that word because it could also have been parsinator"><span class="u" id="1483217312.000103">2016:12:31 20:48:32      gfredericks </span><span>and it&apos;s hard to remember that word because it could also have been parsinator</span></div><div data-t="zmaril hahaha"><span class="u" id="1483217374.000104">2016:12:31 20:49:34           zmaril </span><span>hahaha</span></div><div data-t="zmaril (defn enlive-output-&gt;datascript-datums [m]
 (if-not (map? m)
    {:type :value :value m}
    (as-&gt; m $
        (assoc $ :meta (meta m))
        (assoc $ :db/id (d/tempid :mcc))
        (transform [:content ALL] enlive-output-&gt;datascript-datums $))))
  This will take enlive output and make it so you can query it from datascript"><span class="u" id="1483217417.000105">2016:12:31 20:50:17           zmaril </span><pre>(defn enlive-output-&gt;datascript-datums [m]
 (if-not (map? m)
    {:type :value :value m}
    (as-&gt; m $
        (assoc $ :meta (meta m))
        (assoc $ :db/id (d/tempid :mcc))
        (transform [:content ALL] enlive-output-&gt;datascript-datums $))))
</pre><span> This will take enlive output and make it so you can query it from datascript</span></div><div data-t="gfredericks does instaparse use its own regex engine?"><span class="u" id="1483217604.000106">2016:12:31 20:53:24      gfredericks </span><span>does instaparse use its own regex engine?</span></div><div data-t="zmaril no"><span class="u" id="1483217617.000107">2016:12:31 20:53:37           zmaril </span><span>no</span></div><div data-t="gfredericks I just got a misparse where the thing matches the regex but instaparse disagrees"><span class="u" id="1483217620.000108">2016:12:31 20:53:40      gfredericks </span><span>I just got a misparse where the thing matches the regex but instaparse disagrees</span></div><div data-t="zmaril depends on java if I recall"><span class="u" id="1483217622.000109">2016:12:31 20:53:42           zmaril </span><span>depends on java if I recall</span></div><div data-t="gfredericks and reordering a disjunction in the regex fixes it"><span class="u" id="1483217632.000110">2016:12:31 20:53:52      gfredericks </span><span>and reordering a disjunction in the regex fixes it</span></div><div data-t="zmaril hmm"><span class="u" id="1483217644.000111">2016:12:31 20:54:04           zmaril </span><span>hmm</span></div><div data-t="gfredericks this is the instparse-cljs thing in particular, but still on the jvm"><span class="u" id="1483217650.000112">2016:12:31 20:54:10      gfredericks </span><span>this is the instparse-cljs thing in particular, but still on the jvm</span></div><div data-t="zmaril check if instaparse passes any flags in"><span class="u" id="1483217656.000113">2016:12:31 20:54:16           zmaril </span><span>check if instaparse passes any flags in</span></div><div data-t="gfredericks here&apos;s the failing version:  https://www.refheap.com/124435"><span class="u" id="1483217753.000114">2016:12:31 20:55:53      gfredericks </span><span>here&apos;s the failing version: </span><a href="https://www.refheap.com/124435">https://www.refheap.com/124435</a></div><div data-t="zmaril hmm"><span class="u" id="1483217891.000115">2016:12:31 20:58:11           zmaril </span><span>hmm</span></div><div data-t="zmaril &quot;0/2&quot;  parses"><span class="u" id="1483217898.000116">2016:12:31 20:58:18           zmaril </span><code>&quot;0/2&quot;</code><span> parses</span></div><div data-t="zmaril can you add in some parens to the second part to clarify your intent"><span class="u" id="1483217924.000119">2016:12:31 20:58:44           zmaril </span><span>can you add in some parens to the second part to clarify your intent</span></div><div data-t="gfredericks &quot;0/2&quot; is not supposed to parse o_O"><span class="u" id="1483217999.000120">2016:12:31 20:59:59      gfredericks </span><span>&quot;0/2&quot; is not supposed to parse o_O</span></div><div data-t="gfredericks I see that&apos;s my fault though"><span class="u" id="1483218034.000121">2016:12:31 21:00:34      gfredericks </span><span>I see that&apos;s my fault though</span></div><div data-t="zmaril ha"><span class="u" id="1483218229.000122">2016:12:31 21:03:49           zmaril </span><span>ha</span></div><div data-t="aengelberg I second  !epsilon  as the &quot;don&apos;t parse&quot;"><span class="u" id="1483221581.000123">2016:12:31 21:59:41       aengelberg </span><span>I second </span><code>!epsilon</code><span> as the &quot;don&apos;t parse&quot;</span></div><div data-t="aengelberg also instaparse fails on infinite loop grammars, so this might work
 never-succeed = never-succeed
 
(then use  never-succeed  wherever)"><span class="u" id="1483221629.000124">2016:12:31 22:00:29       aengelberg </span><span>also instaparse fails on infinite loop grammars, so this might work
</span><pre>never-succeed = never-succeed
</pre><span>
(then use </span><code>never-succeed</code><span> wherever)</span></div><div data-t="gfredericks @aengelberg do you think the current behavior of  (combo/alt)  is bad/weird?"><span class="u" id="1483221718.000125">2016:12:31 22:01:58      gfredericks </span><span>@aengelberg do you think the current behavior of </span><code>(combo/alt)</code><span> is bad/weird?</span></div><div data-t="gfredericks my hunch is that According To Math it should either throw or not match anything"><span class="u" id="1483221764.000126">2016:12:31 22:02:44      gfredericks </span><span>my hunch is that According To Math it should either throw or not match anything</span></div><div data-t="aengelberg yeah I agree with your instinct. Not really sure what the thinking was in that design."><span class="u" id="1483221781.000127">2016:12:31 22:03:01       aengelberg </span><span>yeah I agree with your instinct. Not really sure what the thinking was in that design.</span></div><div data-t="gfredericks my argument is that because  (combo/alt p)  probably does not match ε, neither should  (combo/alt)"><span class="u" id="1483221797.000128">2016:12:31 22:03:17      gfredericks </span><span>my argument is that because </span><code>(combo/alt p)</code><span> probably does not match ε, neither should </span><code>(combo/alt)</code></div><div data-t="aengelberg Maybe since &quot;don&apos;t parse anything&quot; isn&apos;t really a common use case"><span class="u" id="1483221803.000129">2016:12:31 22:03:23       aengelberg </span><span>Maybe since &quot;don&apos;t parse anything&quot; isn&apos;t really a common use case</span></div><div data-t="gfredericks you shouldn&apos;t parse more things by removing an arg from  combo/alt"><span class="u" id="1483221813.000130">2016:12:31 22:03:33      gfredericks </span><span>you shouldn&apos;t parse more things by removing an arg from </span><code>combo/alt</code></div><div data-t="aengelberg agreed"><span class="u" id="1483221826.000131">2016:12:31 22:03:46       aengelberg </span><span>agreed</span></div><div data-t="gfredericks yeah I always end up finding the uncommon use cases"><span class="u" id="1483221843.000132">2016:12:31 22:04:03      gfredericks </span><span>yeah I always end up finding the uncommon use cases</span></div><div data-t="gfredericks for a while every time I tried to use CLJS I ended up creating a jira ticket"><span class="u" id="1483221865.000133">2016:12:31 22:04:25      gfredericks </span><span>for a while every time I tried to use CLJS I ended up creating a jira ticket</span></div><div data-t="aengelberg #gobigorgohome"><span class="u" id="1483221895.000134">2016:12:31 22:04:55       aengelberg </span><span>#gobigorgohome</span></div><div data-t="aengelberg I think I know why your parser is failing"><span class="u" id="1483221969.000135">2016:12:31 22:06:09       aengelberg </span><span>I think I know why your parser is failing</span></div><div data-t="aengelberg The regex for the denominator, when given  &quot;25&quot;  as input, may arbitrarily decide to match either  &quot;2&quot;  or  &quot;25&quot;"><span class="u" id="1483222008.000136">2016:12:31 22:06:48       aengelberg </span><span>The regex for the denominator, when given </span><code>&quot;25&quot;</code><span> as input, may arbitrarily decide to match either </span><code>&quot;2&quot;</code><span> or </span><code>&quot;25&quot;</code></div><div data-t="aengelberg In instaparse, whatever the regex decides is the one and only possible parse"><span class="u" id="1483222024.000137">2016:12:31 22:07:04       aengelberg </span><span>In instaparse, whatever the regex decides is the one and only possible parse</span></div><div data-t="aengelberg user=&gt; (re-matches #&quot;[2-9]|[1-9][0-9]+&quot; &quot;25&quot;)
&quot;25&quot;
user=&gt; (re-seq #&quot;[2-9]|[1-9][0-9]+&quot; &quot;25&quot;)
(&quot;2&quot; &quot;5&quot;)
user=&gt; (re-find #&quot;[2-9]|[1-9][0-9]+&quot; &quot;25&quot;)
&quot;2&quot;
"><span class="u" id="1483222073.000138">2016:12:31 22:07:53       aengelberg </span><pre>user=&gt; (re-matches #&quot;[2-9]|[1-9][0-9]+&quot; &quot;25&quot;)
&quot;25&quot;
user=&gt; (re-seq #&quot;[2-9]|[1-9][0-9]+&quot; &quot;25&quot;)
(&quot;2&quot; &quot;5&quot;)
user=&gt; (re-find #&quot;[2-9]|[1-9][0-9]+&quot; &quot;25&quot;)
&quot;2&quot;
</pre></div><div data-t="gfredericks oh it&apos;s about  re-matches  vs  re-find ?"><span class="u" id="1483222113.000139">2016:12:31 22:08:33      gfredericks </span><span>oh it&apos;s about </span><code>re-matches</code><span> vs </span><code>re-find</code><span>?</span></div><div data-t="aengelberg https://github.com/engelberg/instaparse#regular-expressions-a-word-of-warning"><span class="u" id="1483222119.000140">2016:12:31 22:08:39       aengelberg </span><a href="https://github.com/engelberg/instaparse#regular-expressions-a-word-of-warning">https://github.com/engelberg/instaparse#regular-expressions-a-word-of-warning</a></div><div data-t="gfredericks oh I think I see"><span class="u" id="1483222127.000142">2016:12:31 22:08:47      gfredericks </span><span>oh I think I see</span></div><div data-t="aengelberg you could instead do  #&quot;[2-9]&quot; | #&quot;[1-9][0-9]+&quot;"><span class="u" id="1483222144.000143">2016:12:31 22:09:04       aengelberg </span><span>you could instead do </span><code>#&quot;[2-9]&quot; | #&quot;[1-9][0-9]+&quot;</code></div><div data-t="aengelberg If you move logic from regexes into instaparse, you get flexibility at the cost of speed"><span class="u" id="1483222162.000144">2016:12:31 22:09:22       aengelberg </span><span>If you move logic from regexes into instaparse, you get flexibility at the cost of speed</span></div><div data-t="gfredericks so the fact that I fixed it by rearranging the regex is sort of an implementation detail I guess?"><span class="u" id="1483222270.000146">2016:12:31 22:11:10      gfredericks </span><span>so the fact that I fixed it by rearranging the regex is sort of an implementation detail I guess?</span></div><div data-t="aengelberg Yes, so I would call rearranging the regex an improper solution"><span class="u" id="1483222322.000147">2016:12:31 22:12:02       aengelberg </span><span>Yes, so I would call rearranging the regex an improper solution</span></div><div data-t="aengelberg but  #&quot;[2-9]&quot; | #&quot;[1-9][0-9]+&quot;  is proper"><span class="u" id="1483222345.000148">2016:12:31 22:12:25       aengelberg </span><span>but </span><code>#&quot;[2-9]&quot; | #&quot;[1-9][0-9]+&quot;</code><span> is proper</span></div><div data-t="gfredericks okay fine I&apos;ll switch it  😛"><span class="u" id="1483222510.000149">2016:12:31 22:15:10      gfredericks </span><span>okay fine I&apos;ll switch it </span><b>😛</b></div><div data-t="doddenino Hi! Is there a way to do a step by step debug of a parser?"><span class="u" id="1486976333.000154">2017:02:13 08:58:53        doddenino </span><span>Hi! Is there a way to do a step by step debug of a parser?</span></div><div data-t="dave @doddenino:  https://github.com/Engelberg/instaparse#total-parse-mode  &lt;-- this is maybe not exactly what you want, but it can be helpful for debugging a parse failure"><span class="u" id="1487008255.000155">2017:02:13 17:50:55             dave </span><span>@doddenino: </span><a href="https://github.com/Engelberg/instaparse#total-parse-mode">https://github.com/Engelberg/instaparse#total-parse-mode</a><span> &lt;-- this is maybe not exactly what you want, but it can be helpful for debugging a parse failure</span></div><div data-t="aengelberg @doddenino you&apos;re probably looking for tracing mode.  https://github.com/Engelberg/instaparse/blob/master/docs/Tracing.md"><span class="u" id="1487008288.000157">2017:02:13 17:51:28       aengelberg </span><span>@doddenino you&apos;re probably looking for tracing mode. </span><a href="https://github.com/Engelberg/instaparse/blob/master/docs/Tracing.md">https://github.com/Engelberg/instaparse/blob/master/docs/Tracing.md</a></div><div data-t="doddenino Oh that&apos;s great!  🙂  Thanks! I&apos;m having a lot of problems trying to make my parser work correctly  😞"><span class="u" id="1487008358.000159">2017:02:13 17:52:38        doddenino </span><span>Oh that&apos;s great! </span><b>🙂</b><span> Thanks! I&apos;m having a lot of problems trying to make my parser work correctly </span><b>😞</b></div><div data-t="aengelberg Also, calling  insta/parse  with  :start  overridden can also help debug certain small pieces of your parser."><span class="u" id="1487008417.000160">2017:02:13 17:53:37       aengelberg </span><span>Also, calling </span><code>insta/parse</code><span> with </span><code>:start</code><span> overridden can also help debug certain small pieces of your parser.</span></div><div data-t="doddenino @aengelberg I think trace is perfect"><span class="u" id="1487008618.000161">2017:02:13 17:56:58        doddenino </span><span>@aengelberg I think trace is perfect</span></div><div data-t="doddenino I don&apos;t know how and why, but it&apos;s working correctly now  😅"><span class="u" id="1487009459.000162">2017:02:13 18:10:59        doddenino </span><span>I don&apos;t know how and why, but it&apos;s working correctly now </span><b>😅</b></div><div data-t="doddenino Celebrating too soon  😞"><span class="u" id="1487009571.000163">2017:02:13 18:12:51        doddenino </span><span>Celebrating too soon </span><b>😞</b></div><div data-t="doddenino I&apos;m trying to write a lambda calculus expressions parser, but I&apos;m having a hard time dealing applications being left associative and having higher precedence than abstractions. I can either parse &quot;a b c&quot; or &quot;fn x . x a&quot; correctly, but not both with the same parser  😞"><span class="u" id="1487063633.000164">2017:02:14 09:13:53        doddenino </span><span>I&apos;m trying to write a lambda calculus expressions parser, but I&apos;m having a hard time dealing applications being left associative and having higher precedence than abstractions. I can either parse &quot;a b c&quot; or &quot;fn x . x a&quot; correctly, but not both with the same parser </span><b>😞</b></div><div data-t="aengelberg @doddenino: I&apos;m not familiar with the syntax you&apos;re trying to parse, but have you looked at the ordered choice  /  operator?"><span class="u" id="1487098763.000166">2017:02:14 18:59:23       aengelberg </span><span>@doddenino: I&apos;m not familiar with the syntax you&apos;re trying to parse, but have you looked at the ordered choice </span><code>/</code><span> operator?</span></div><div data-t="doddenino Yes, I was using that already. I managed to solve it by enforcing a stricter syntax, dealing better with a specific edge case and randomly moving stuff around until it worked fine  😄"><span class="u" id="1487153531.000167">2017:02:15 10:12:11        doddenino </span><span>Yes, I was using that already. I managed to solve it by enforcing a stricter syntax, dealing better with a specific edge case and randomly moving stuff around until it worked fine </span><b>😄</b></div><div data-t="frank I&apos;m having trouble creating a parser using the grammar specified here:  https://developers.google.com/protocol-buffers/docs/reference/proto3-spec"><span class="u" id="1487354066.000169">2017:02:17 17:54:26            frank </span><span>I&apos;m having trouble creating a parser using the grammar specified here: </span><a href="https://developers.google.com/protocol-buffers/docs/reference/proto3-spec">https://developers.google.com/protocol-buffers/docs/reference/proto3-spec</a></div><div data-t="frank I&apos;m getting the feeling that there are syntax differences"><span class="u" id="1487354092.000170">2017:02:17 17:54:52            frank </span><span>I&apos;m getting the feeling that there are syntax differences</span></div><div data-t="frank I&apos;m slurping the grammar out of a separate file, but I feel like escaped quotes still aren&apos;t being handled as I intend (e.g.  quote = &quot;&apos;&quot; | &apos;&quot;&apos; )"><span class="u" id="1487354246.000171">2017:02:17 17:57:26            frank </span><span>I&apos;m slurping the grammar out of a separate file, but I feel like escaped quotes still aren&apos;t being handled as I intend (e.g. </span><code>quote = &quot;&apos;&quot; | &apos;&quot;&apos;</code><span>)</span></div><div data-t="frank does anyone know how quotes ought to be escaped in instaparse ebnf strings?"><span class="u" id="1487354629.000172">2017:02:17 18:03:49            frank </span><span>does anyone know how quotes ought to be escaped in instaparse ebnf strings?</span></div><div data-t="gfredericks the way you have it looks likely to work to me"><span class="u" id="1487355201.000173">2017:02:17 18:13:21      gfredericks </span><span>the way you have it looks likely to work to me</span></div><div data-t="frank maybe there&apos;s unmatched quotes somewhere in the grammar that I copied and pasted  😕"><span class="u" id="1487355469.000174">2017:02:17 18:17:49            frank </span><span>maybe there&apos;s unmatched quotes somewhere in the grammar that I copied and pasted </span><b>😕</b></div><div data-t="gfredericks try making a trivial grammar that only matches a quote to make sure it works the way you expect"><span class="u" id="1487355578.000175">2017:02:17 18:19:38      gfredericks </span><span>try making a trivial grammar that only matches a quote to make sure it works the way you expect</span></div><div data-t="seylerius ^ This. So much this. When I&apos;m making grammars, I often make little phrases to match a character I haven&apos;t tested before."><span class="u" id="1487355658.000177">2017:02:17 18:20:58        seylerius </span><span>^ This. So much this. When I&apos;m making grammars, I often make little phrases to match a character I haven&apos;t tested before.</span></div><div data-t="frank I&apos;ll try that, thanks"><span class="u" id="1487355704.000178">2017:02:17 18:21:44            frank </span><span>I&apos;ll try that, thanks</span></div><div data-t="aengelberg &quot;&apos;&quot; | &apos;&quot;&apos;  looks right, but there are sometimes additional layers of escaping you have to deal with."><span class="u" id="1487356160.000180">2017:02:17 18:29:20       aengelberg </span><code>&quot;&apos;&quot; | &apos;&quot;&apos;</code><span> looks right, but there are sometimes additional layers of escaping you have to deal with.</span></div><div data-t="aengelberg e.g. if you wrote your grammar as a string in a Clojure file, it would probably have to look like
 (def parser (insta/parser &quot;quote \&quot;&apos;\&quot; | &apos;\&quot;&apos;&quot;))
"><span class="u" id="1487356193.000181">2017:02:17 18:29:53       aengelberg </span><span>e.g. if you wrote your grammar as a string in a Clojure file, it would probably have to look like
</span><pre>(def parser (insta/parser &quot;quote \&quot;&apos;\&quot; | &apos;\&quot;&apos;&quot;))
</pre></div><div data-t="aengelberg I see this in the protobuf spec
 hexEscape = &apos;\&apos;
 
that will probably throw off instaparse, since it thinks you are escaping the second  &apos;"><span class="u" id="1487356271.000182">2017:02:17 18:31:11       aengelberg </span><span>I see this in the protobuf spec
</span><pre>hexEscape = &apos;\&apos;
</pre><span>
that will probably throw off instaparse, since it thinks you are escaping the second </span><code>&apos;</code></div><div data-t="aengelberg so it should really be
 hexEscape = &apos;\\&apos;
"><span class="u" id="1487356285.000183">2017:02:17 18:31:25       aengelberg </span><span>so it should really be
</span><pre>hexEscape = &apos;\\&apos;
</pre></div><div data-t="aengelberg @frank ^"><span class="u" id="1487356321.000185">2017:02:17 18:32:01       aengelberg </span><span>@frank ^</span></div><div data-t="aengelberg also,  /[^\0\n\\]/  is not valid EBNF in instaparse (should be  #&quot;[^\0\n\\]&quot; )"><span class="u" id="1487356340.000186">2017:02:17 18:32:20       aengelberg </span><span>also, </span><code>/[^\0\n\\]/</code><span> is not valid EBNF in instaparse (should be </span><code>#&quot;[^\0\n\\]&quot;</code><span>)</span></div><div data-t="frank ah, that&apos;s probably it!"><span class="u" id="1487356958.000189">2017:02:17 18:42:38            frank </span><span>ah, that&apos;s probably it!</span></div><div data-t="frank strangely enough,  #&quot;[^\0\n\\]&quot;  isn&apos;t valid clojure regex syntax, so I stole the same regex syntax from  https://github.com/arpagaus/clj-protobuf/blob/master/resources/proto.ebnf"><span class="u" id="1487357021.000190">2017:02:17 18:43:41            frank </span><span>strangely enough, </span><code>#&quot;[^\0\n\\]&quot;</code><span> isn&apos;t valid clojure regex syntax, so I stole the same regex syntax from </span><a href="https://github.com/arpagaus/clj-protobuf/blob/master/resources/proto.ebnf">https://github.com/arpagaus/clj-protobuf/blob/master/resources/proto.ebnf</a></div><div data-t="frank they&apos;ve got a few extra backslashes:  #&quot;[^\\0\\n]&quot;"><span class="u" id="1487357044.000192">2017:02:17 18:44:04            frank </span><span>they&apos;ve got a few extra backslashes: </span><code>#&quot;[^\\0\\n]&quot;</code></div><div data-t="frank @aengelberg what&apos;s the equivalent of the  …  that they&apos;ve got littered all over their grammar?"><span class="u" id="1487357185.000193">2017:02:17 18:46:25            frank </span><span>@aengelberg what&apos;s the equivalent of the </span><code>…</code><span> that they&apos;ve got littered all over their grammar?</span></div><div data-t="aengelberg I think they meant that as a shorthand for alternating between all the digits. Sadly instaparse can&apos;t infer the intermediate values, so you would have to  &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;8&quot; | &quot;9&quot;"><span class="u" id="1487357377.000194">2017:02:17 18:49:37       aengelberg </span><span>I think they meant that as a shorthand for alternating between all the digits. Sadly instaparse can&apos;t infer the intermediate values, so you would have to </span><code>&quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;8&quot; | &quot;9&quot;</code></div><div data-t="frank ah, gotcha"><span class="u" id="1487357415.000195">2017:02:17 18:50:15            frank </span><span>ah, gotcha</span></div><div data-t="frank alternatively, #&quot;[0-9]&quot; should work too, right?"><span class="u" id="1487357757.000196">2017:02:17 18:55:57            frank </span><span>alternatively, #&quot;[0-9]&quot; should work too, right?</span></div><div data-t="aengelberg correct"><span class="u" id="1487357774.000197">2017:02:17 18:56:14       aengelberg </span><span>correct</span></div><div data-t="bherrmann has anyone used instaparse to mottle through oracle sql?"><span class="u" id="1487476875.000200">2017:02:19 04:01:15        bherrmann </span><span>has anyone used instaparse to mottle through oracle sql?</span></div><div data-t="aengelberg I vaguely recall hearing about people using instaparse for SQL, but I unfortunately can&apos;t point to something specific."><span class="u" id="1487497182.000201">2017:02:19 09:39:42       aengelberg </span><span>I vaguely recall hearing about people using instaparse for SQL, but I unfortunately can&apos;t point to something specific.</span></div><div data-t="aengelberg Might be something in the instaparse Google group archives"><span class="u" id="1487497208.000202">2017:02:19 09:40:08       aengelberg </span><span>Might be something in the instaparse Google group archives</span></div><div data-t="anthony.naddeo @aengelberg I have a parser that I&apos;m not sure how else to improve:  https://github.com/naddeoa/elm-clojurescript-hello-parser/blob/master/src/elm_toolkit/parser.cljs"><span class="u" id="1487885189.000205">2017:02:23 21:26:29   anthony.naddeo </span><span>@aengelberg I have a parser that I&apos;m not sure how else to improve: </span><a href="https://github.com/naddeoa/elm-clojurescript-hello-parser/blob/master/src/elm_toolkit/parser.cljs">https://github.com/naddeoa/elm-clojurescript-hello-parser/blob/master/src/elm_toolkit/parser.cljs</a></div><div data-t="anthony.naddeo I&apos;ve eliminated a ton of ambiguity but I&apos;m still seeing that its performance scales poorly with the size of the input, even when there are only 1 or two possible parses"><span class="u" id="1487885222.000207">2017:02:23 21:27:02   anthony.naddeo </span><span>I&apos;ve eliminated a ton of ambiguity but I&apos;m still seeing that its performance scales poorly with the size of the input, even when there are only 1 or two possible parses</span></div><div data-t="anthony.naddeo but that same input when fed chunk by chunk adds up to a much more reasonable parse time"><span class="u" id="1487885243.000208">2017:02:23 21:27:23   anthony.naddeo </span><span>but that same input when fed chunk by chunk adds up to a much more reasonable parse time</span></div><div data-t="anthony.naddeo I was reading about the  :optimize :memory  option, but that seems to make it worse"><span class="u" id="1487885302.000209">2017:02:23 21:28:22   anthony.naddeo </span><span>I was reading about the </span><code>:optimize :memory</code><span> option, but that seems to make it worse</span></div><div data-t="anthony.naddeo I even tried it with Java instead of Node to see if it was just a JS thing and the results were still similar"><span class="u" id="1487885321.000210">2017:02:23 21:28:41   anthony.naddeo </span><span>I even tried it with Java instead of Node to see if it was just a JS thing and the results were still similar</span></div><div data-t="anthony.naddeo My next step was about to be to write a function that breaks the input up into chunks, but to do that I&apos;ll need to know where a chunk starts/stops or impose some sort of convention around the input"><span class="u" id="1487885367.000211">2017:02:23 21:29:27   anthony.naddeo </span><span>My next step was about to be to write a function that breaks the input up into chunks, but to do that I&apos;ll need to know where a chunk starts/stops or impose some sort of convention around the input</span></div><div data-t="hiredman have you seen  https://github.com/Engelberg/instaparse/blob/master/docs/Performance.md ? I feel like I have seen splitting input in to chunks recommended for larger inputs to instaparse"><span class="u" id="1487889477.000212">2017:02:23 22:37:57         hiredman </span><span>have you seen </span><a href="https://github.com/Engelberg/instaparse/blob/master/docs/Performance.md">https://github.com/Engelberg/instaparse/blob/master/docs/Performance.md</a><span>? I feel like I have seen splitting input in to chunks recommended for larger inputs to instaparse</span></div><div data-t="anthony.naddeo Yeah that&apos;s where I got it from"><span class="u" id="1487889630.000214">2017:02:23 22:40:30   anthony.naddeo </span><span>Yeah that&apos;s where I got it from</span></div><div data-t="anthony.naddeo It just seems like something I shouldn&apos;t have to do"><span class="u" id="1487889647.000215">2017:02:23 22:40:47   anthony.naddeo </span><span>It just seems like something I shouldn&apos;t have to do</span></div><div data-t="anthony.naddeo If only because I need my parser to determine when a readable chunk starts/stops"><span class="u" id="1487889663.000216">2017:02:23 22:41:03   anthony.naddeo </span><span>If only because I need my parser to determine when a readable chunk starts/stops</span></div><div data-t="anthony.naddeo it isn&apos;t a line by line thing"><span class="u" id="1487889670.000217">2017:02:23 22:41:10   anthony.naddeo </span><span>it isn&apos;t a line by line thing</span></div><div data-t="hiredman I might try and eliminate regexes in the grammar definition, if I recall correctly those can be (or maybe they were?) inefficient"><span class="u" id="1487889752.000218">2017:02:23 22:42:32         hiredman </span><span>I might try and eliminate regexes in the grammar definition, if I recall correctly those can be (or maybe they were?) inefficient</span></div><div data-t="anthony.naddeo Are there any examples you know of large grammars that scale linearly with the size of the input?"><span class="u" id="1487889959.000219">2017:02:23 22:45:59   anthony.naddeo </span><span>Are there any examples you know of large grammars that scale linearly with the size of the input?</span></div><div data-t="anthony.naddeo Before I go down a rabbit hole I want to make sure I know what to expect"><span class="u" id="1487889970.000220">2017:02:23 22:46:10   anthony.naddeo </span><span>Before I go down a rabbit hole I want to make sure I know what to expect</span></div><div data-t="hiredman no, I don&apos;t"><span class="u" id="1487890139.000221">2017:02:23 22:48:59         hiredman </span><span>no, I don&apos;t</span></div><div data-t="hiredman I don&apos;t know of any large grammars, and I have only used smallish grammars on small inputs"><span class="u" id="1487890184.000222">2017:02:23 22:49:44         hiredman </span><span>I don&apos;t know of any large grammars, and I have only used smallish grammars on small inputs</span></div><div data-t="anthony.naddeo I&apos;m just afraid that the performance actually won&apos;t get better as hard as I may try and I want to cut  my losses if I can."><span class="u" id="1487890248.000223">2017:02:23 22:50:48   anthony.naddeo </span><span>I&apos;m just afraid that the performance actually won&apos;t get better as hard as I may try and I want to cut  my losses if I can.</span></div><div data-t="anthony.naddeo Or just use this for things that only require parsing snippets"><span class="u" id="1487890257.000224">2017:02:23 22:50:57   anthony.naddeo </span><span>Or just use this for things that only require parsing snippets</span></div><div data-t="anthony.naddeo Thanks for the advice though @hiredman"><span class="u" id="1487890267.000225">2017:02:23 22:51:07   anthony.naddeo </span><span>Thanks for the advice though @hiredman</span></div><div data-t="hiredman it would be neat if instaparse could emit warnings and suggest fixes if your grammar is not LL(1)"><span class="u" id="1487890433.000226">2017:02:23 22:53:53         hiredman </span><span>it would be neat if instaparse could emit warnings and suggest fixes if your grammar is not LL(1)</span></div><div data-t="anthony.naddeo At this point, it seems like what I really want is a mode where it parses in chunks itself. My grammar is really just a repetition of 4 possible blocks. It seems like it could just parse the first block independent of the second. That is to say, as soon as it matches just consider it a block and move on."><span class="u" id="1487890626.000227">2017:02:23 22:57:06   anthony.naddeo </span><span>At this point, it seems like what I really want is a mode where it parses in chunks itself. My grammar is really just a repetition of 4 possible blocks. It seems like it could just parse the first block independent of the second. That is to say, as soon as it matches just consider it a block and move on.</span></div><div data-t="anthony.naddeo Given the right level of ambiguity I would be ok with massaging the results"><span class="u" id="1487890645.000228">2017:02:23 22:57:25   anthony.naddeo </span><span>Given the right level of ambiguity I would be ok with massaging the results</span></div><div data-t="aengelberg How large are your problematic inputs?"><span class="u" id="1487890821.000229">2017:02:23 23:00:21       aengelberg </span><span>How large are your problematic inputs?</span></div><div data-t="anthony.naddeo Well, it scales poorly. There isn&apos;t a size in specific. It parses the Elm programming langauge. When testing, I start with a single function, then I just keep duplicating that function and observe the performance"><span class="u" id="1487890950.000230">2017:02:23 23:02:30   anthony.naddeo </span><span>Well, it scales poorly. There isn&apos;t a size in specific. It parses the Elm programming langauge. When testing, I start with a single function, then I just keep duplicating that function and observe the performance</span></div><div data-t="anthony.naddeo each additional function adds more than its fair share of time"><span class="u" id="1487890967.000231">2017:02:23 23:02:47   anthony.naddeo </span><span>each additional function adds more than its fair share of time</span></div><div data-t="anthony.naddeo I&apos;ll paste a snippet of something that takes too long"><span class="u" id="1487890975.000232">2017:02:23 23:02:55   anthony.naddeo </span><span>I&apos;ll paste a snippet of something that takes too long</span></div><div data-t="anthony.naddeo (def input &quot;nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next


nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
  Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
  Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
  Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
  Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
  Source (next a) next

&quot;)
"><span class="u" id="1487891215.000233">2017:02:23 23:06:55   anthony.naddeo </span><pre>(def input &quot;nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next


nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
    Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
  Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
  Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
  Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
  Source (next a) next

nextSource : Source a -&gt; Source a
nextSource (Source a next) =
  Source (next a) next

&quot;)
</pre></div><div data-t="anthony.naddeo That one I actually just had to kill"><span class="u" id="1487891295.000236">2017:02:23 23:08:15   anthony.naddeo </span><span>That one I actually just had to kill</span></div><div data-t="anthony.naddeo but if you cut it in half it only takes about a second or so to parse"><span class="u" id="1487891308.000237">2017:02:23 23:08:28   anthony.naddeo </span><span>but if you cut it in half it only takes about a second or so to parse</span></div><div data-t="anthony.naddeo And its a pretty reasonable size for an Elm source file"><span class="u" id="1487891324.000238">2017:02:23 23:08:44   anthony.naddeo </span><span>And its a pretty reasonable size for an Elm source file</span></div><div data-t="aengelberg Ouch"><span class="u" id="1487891446.000239">2017:02:23 23:10:46       aengelberg </span><span>Ouch</span></div><div data-t="aengelberg I&apos;ll try to take a look soon"><span class="u" id="1487891474.000240">2017:02:23 23:11:14       aengelberg </span><span>I&apos;ll try to take a look soon</span></div><div data-t="anthony.naddeo Cool, thanks a lot"><span class="u" id="1487891932.000241">2017:02:23 23:18:52   anthony.naddeo </span><span>Cool, thanks a lot</span></div><div data-t="anthony.naddeo Also, definitely pretty new to clojure still. If I can make the code more approachable/replable feel free to point that out"><span class="u" id="1487891959.000242">2017:02:23 23:19:19   anthony.naddeo </span><span>Also, definitely pretty new to clojure still. If I can make the code more approachable/replable feel free to point that out</span></div><div data-t="anthony.naddeo I kind of just hacked everything together"><span class="u" id="1487891964.000243">2017:02:23 23:19:24   anthony.naddeo </span><span>I kind of just hacked everything together</span></div><div data-t="aengelberg @anthony.naddeo I fixed it

before:
 start = (&lt;ws&gt;* block &lt;ws&gt;*)+
 

after:
 start = (&lt;ws&gt; block &lt;ws&gt;)+
"><span class="u" id="1487893013.000244">2017:02:23 23:36:53       aengelberg </span><span>@anthony.naddeo I fixed it

before:
</span><pre>start = (&lt;ws&gt;* block &lt;ws&gt;*)+
</pre><span>

after:
</span><pre>start = (&lt;ws&gt; block &lt;ws&gt;)+
</pre></div><div data-t="anthony.naddeo That? Let me try now"><span class="u" id="1487893034.000245">2017:02:23 23:37:14   anthony.naddeo </span><span>That? Let me try now</span></div><div data-t="aengelberg the large input now takes 100ms on my machine"><span class="u" id="1487893054.000246">2017:02:23 23:37:34       aengelberg </span><span>the large input now takes 100ms on my machine</span></div><div data-t="anthony.naddeo 100ms? I just tried it and it is WAY better, but I wish I had those numbers"><span class="u" id="1487893186.000247">2017:02:23 23:39:46   anthony.naddeo </span><span>100ms? I just tried it and it is WAY better, but I wish I had those numbers</span></div><div data-t="anthony.naddeo are you just in a node repl?"><span class="u" id="1487893192.000248">2017:02:23 23:39:52   anthony.naddeo </span><span>are you just in a node repl?</span></div><div data-t="anthony.naddeo I&apos;m down to 900ms now"><span class="u" id="1487893195.000249">2017:02:23 23:39:55   anthony.naddeo </span><span>I&apos;m down to 900ms now</span></div><div data-t="anthony.naddeo which is great"><span class="u" id="1487893198.000250">2017:02:23 23:39:58   anthony.naddeo </span><span>which is great</span></div><div data-t="anthony.naddeo compared to never stopping"><span class="u" id="1487893202.000251">2017:02:23 23:40:02   anthony.naddeo </span><span>compared to never stopping</span></div><div data-t="anthony.naddeo I wouldn&apos;t have thought to do that"><span class="u" id="1487893214.000252">2017:02:23 23:40:14   anthony.naddeo </span><span>I wouldn&apos;t have thought to do that</span></div><div data-t="aengelberg sorry I&apos;m in JVM, not JS"><span class="u" id="1487893226.000253">2017:02:23 23:40:26       aengelberg </span><span>sorry I&apos;m in JVM, not JS</span></div><div data-t="aengelberg 900ms makes sense for node, instaparse in cljs is known to be ~ 10x slower"><span class="u" id="1487893246.000254">2017:02:23 23:40:46       aengelberg </span><span>900ms makes sense for node, instaparse in cljs is known to be ~ 10x slower</span></div><div data-t="anthony.naddeo oh interesting. Did you use my parser.clj file?"><span class="u" id="1487893310.000255">2017:02:23 23:41:50   anthony.naddeo </span><span>oh interesting. Did you use my parser.clj file?</span></div><div data-t="anthony.naddeo yeah this is way better"><span class="u" id="1487893330.000256">2017:02:23 23:42:10   anthony.naddeo </span><span>yeah this is way better</span></div><div data-t="anthony.naddeo Thanks a ton"><span class="u" id="1487893337.000257">2017:02:23 23:42:17   anthony.naddeo </span><span>Thanks a ton</span></div><div data-t="aengelberg I just copied the grammar string from  parser.cljs  into my clojure file since the EBNF syntax is the same on both platforms"><span class="u" id="1487893387.000258">2017:02:23 23:43:07       aengelberg </span><span>I just copied the grammar string from </span><code>parser.cljs</code><span> into my clojure file since the EBNF syntax is the same on both platforms</span></div><div data-t="aengelberg np"><span class="u" id="1487893397.000259">2017:02:23 23:43:17       aengelberg </span><span>np</span></div><div data-t="anthony.naddeo One odd thing though"><span class="u" id="1487893543.000261">2017:02:23 23:45:43   anthony.naddeo </span><span>One odd thing though</span></div><div data-t="anthony.naddeo I would expect that the  *  impacts performance because it adds ambiguity right?"><span class="u" id="1487893558.000262">2017:02:23 23:45:58   anthony.naddeo </span><span>I would expect that the </span><code>*</code><span> impacts performance because it adds ambiguity right?</span></div><div data-t="anthony.naddeo If so, shouldn&apos;t there be more than a single parse for it?  (time (count (insta/parses parser/parser input :unhide :all)))  returned 1 unless I did something wrong"><span class="u" id="1487893589.000263">2017:02:23 23:46:29   anthony.naddeo </span><span>If so, shouldn&apos;t there be more than a single parse for it? </span><code>(time (count (insta/parses parser/parser input :unhide :all)))</code><span> returned 1 unless I did something wrong</span></div><div data-t="hiredman ambiguity can mean multiple results, but it can also mean a single result that required checking lots of different cases to arrive at"><span class="u" id="1487893811.000264">2017:02:23 23:50:11         hiredman </span><span>ambiguity can mean multiple results, but it can also mean a single result that required checking lots of different cases to arrive at</span></div><div data-t="anthony.naddeo What metrics could people use to determine ambiguity if not parse counts?"><span class="u" id="1487893842.000266">2017:02:23 23:50:42   anthony.naddeo </span><span>What metrics could people use to determine ambiguity if not parse counts?</span></div><div data-t="hiredman #6 in that peformance doc suggests looking at rules individually to see if you have rules that in isolation can result in multiple parses"><span class="u" id="1487893942.000267">2017:02:23 23:52:22         hiredman </span><span>#6 in that peformance doc suggests looking at rules individually to see if you have rules that in isolation can result in multiple parses</span></div><div data-t="aengelberg Instaparse de-duplicates results, so some internal ambiguity can lurk around but still impact the perf"><span class="u" id="1487893944.000268">2017:02:23 23:52:24       aengelberg </span><span>Instaparse de-duplicates results, so some internal ambiguity can lurk around but still impact the perf</span></div><div data-t="anthony.naddeo interesting"><span class="u" id="1487893984.000269">2017:02:23 23:53:04   anthony.naddeo </span><span>interesting</span></div><div data-t="anthony.naddeo well, I&apos;m glad that was an easy fix, thanks guys"><span class="u" id="1487893994.000270">2017:02:23 23:53:14   anthony.naddeo </span><span>well, I&apos;m glad that was an easy fix, thanks guys</span></div><div data-t="anthony.naddeo I don&apos;t think I can go back to other parsers. I would have been heart broken"><span class="u" id="1487894004.000271">2017:02:23 23:53:24   anthony.naddeo </span><span>I don&apos;t think I can go back to other parsers. I would have been heart broken</span></div><div data-t="aengelberg btw @anthony.naddeo, I made the following optimization to your  Name  and  name  which halved the time for me:
 Name = #&apos;(?!\\b(if|then|else|in|let|case|of)\\b)[A-Z][a-zA-Z0-9]*&apos;
    name = #&apos;(?!\\b(if|then|else|in|let|case|of|type)\\b)[a-z][a-zA-Z0-9]*&apos;
"><span class="u" id="1487894111.000274">2017:02:23 23:55:11       aengelberg </span><span>btw @anthony.naddeo, I made the following optimization to your </span><code>Name</code><span> and </span><code>name</code><span> which halved the time for me:
</span><pre>Name = #&apos;(?!\\b(if|then|else|in|let|case|of)\\b)[A-Z][a-zA-Z0-9]*&apos;
    name = #&apos;(?!\\b(if|then|else|in|let|case|of|type)\\b)[a-z][a-zA-Z0-9]*&apos;
</pre></div><div data-t="aengelberg Actually the first \b doesn&apos;t really do anything, because the first character of this particular token is the first char in the string from the regex&apos;s perspective"><span class="u" id="1487894199.000275">2017:02:23 23:56:39       aengelberg </span><span>Actually the first \b doesn&apos;t really do anything, because the first character of this particular token is the first char in the string from the regex&apos;s perspective</span></div><div data-t="aengelberg But my optimization was to shift more responsibility into the regex; that is always ideal"><span class="u" id="1487894263.000276">2017:02:23 23:57:43       aengelberg </span><span>But my optimization was to shift more responsibility into the regex; that is always ideal</span></div><div data-t="aengelberg related:
 symbol = #&apos;(?!(-&gt;|=)\\b)[+/*&lt;&gt;:&amp;|=^?%#~!-]+&apos;
"><span class="u" id="1487894999.000277">2017:02:24 00:09:59       aengelberg </span><span>related:
</span><pre>symbol = #&apos;(?!(-&gt;|=)\\b)[+/*&lt;&gt;:&amp;|=^?%#~!-]+&apos;
</pre></div><div data-t="anthony.naddeo oh awesome, let me try that now"><span class="u" id="1487895038.000278">2017:02:24 00:10:38   anthony.naddeo </span><span>oh awesome, let me try that now</span></div><div data-t="anthony.naddeo I had meant to circle back and fix all that stuff on the bottom..."><span class="u" id="1487895050.000279">2017:02:24 00:10:50   anthony.naddeo </span><span>I had meant to circle back and fix all that stuff on the bottom...</span></div><div data-t="anthony.naddeo @aengelberg yeah, that&apos;s pretty awesome. Thanks a ton. I guess I have some work to do"><span class="u" id="1487896351.000280">2017:02:24 00:32:31   anthony.naddeo </span><span>@aengelberg yeah, that&apos;s pretty awesome. Thanks a ton. I guess I have some work to do</span></div><div data-t="anthony.naddeo Its cut nearly in half on JS"><span class="u" id="1487896364.000281">2017:02:24 00:32:44   anthony.naddeo </span><span>Its cut nearly in half on JS</span></div><div data-t="aengelberg just curious, does Elm allow newlines pretty much anywhere there can be whitespace? if so, I would recommend making a universal  ws  and  ows  (optional whitespace) that allows whitespace, newlines, and comments, which you can then spam in your grammar anytime you would use  &lt;break&gt; ."><span class="u" id="1487896460.000282">2017:02:24 00:34:20       aengelberg </span><span>just curious, does Elm allow newlines pretty much anywhere there can be whitespace? if so, I would recommend making a universal </span><code>ws</code><span> and </span><code>ows</code><span> (optional whitespace) that allows whitespace, newlines, and comments, which you can then spam in your grammar anytime you would use </span><code>&lt;break&gt;</code><span>.</span></div><div data-t="aengelberg whitespace and comments are sometimes the trickiest parts of grammar perf"><span class="u" id="1487896499.000283">2017:02:24 00:34:59       aengelberg </span><span>whitespace and comments are sometimes the trickiest parts of grammar perf</span></div><div data-t="anthony.naddeo Its pretty flexible with newlines yeah. It does care about indentation (which I haven&apos;t attempted to model in anyway). Are you saying that  break  performs poorly or that it would be easier to maintain if I just settled on fewer whitespace tokens"><span class="u" id="1487896683.000284">2017:02:24 00:38:03   anthony.naddeo </span><span>Its pretty flexible with newlines yeah. It does care about indentation (which I haven&apos;t attempted to model in anyway). Are you saying that </span><code>break</code><span> performs poorly or that it would be easier to maintain if I just settled on fewer whitespace tokens</span></div><div data-t="aengelberg I don&apos;t think anything&apos;s wrong with  break , but you might run into false negatives i.e. valid Elm code that doesn&apos;t parse properly"><span class="u" id="1487896766.000285">2017:02:24 00:39:26       aengelberg </span><span>I don&apos;t think anything&apos;s wrong with </span><code>break</code><span>, but you might run into false negatives i.e. valid Elm code that doesn&apos;t parse properly</span></div><div data-t="aengelberg and making ws easier to reason about makes you less likely to fall into ambiguity traps like two adjacent ws parsers"><span class="u" id="1487896805.000286">2017:02:24 00:40:05       aengelberg </span><span>and making ws easier to reason about makes you less likely to fall into ambiguity traps like two adjacent ws parsers</span></div><div data-t="anthony.naddeo yeah that&apos;s a good point"><span class="u" id="1487896818.000287">2017:02:24 00:40:18   anthony.naddeo </span><span>yeah that&apos;s a good point</span></div><div data-t="anthony.naddeo break probably can go. It was just the result of trial and error when I first picked up the parser, I shouldn&apos;t feel particularly attached to it if I can just use ws everywhere"><span class="u" id="1487896852.000288">2017:02:24 00:40:52   anthony.naddeo </span><span>break probably can go. It was just the result of trial and error when I first picked up the parser, I shouldn&apos;t feel particularly attached to it if I can just use ws everywhere</span></div><div data-t="anthony.naddeo thanks again. This is far more support than I expected"><span class="u" id="1487896923.000289">2017:02:24 00:42:03   anthony.naddeo </span><span>thanks again. This is far more support than I expected</span></div><div data-t="aengelberg No problem"><span class="u" id="1487897364.000290">2017:02:24 00:49:24       aengelberg </span><span>No problem</span></div><div data-t="anthony.naddeo I think it might also make sense for me to roll comments into a rule similar to that"><span class="u" id="1487897370.000291">2017:02:24 00:49:30   anthony.naddeo </span><span>I think it might also make sense for me to roll comments into a rule similar to that</span></div><div data-t="anthony.naddeo they too can appear anywhere"><span class="u" id="1487897384.000292">2017:02:24 00:49:44   anthony.naddeo </span><span>they too can appear anywhere</span></div><div data-t="aengelberg Agreed. Your usage of single line comments seemed kind of arbitrary though admittedly I&apos;m not familiar with Elm"><span class="u" id="1487897418.000293">2017:02:24 00:50:18       aengelberg </span><span>Agreed. Your usage of single line comments seemed kind of arbitrary though admittedly I&apos;m not familiar with Elm</span></div><div data-t="anthony.naddeo yeah its totally arbitrary. I&apos;ve punted on all inline comments atm"><span class="u" id="1487897441.000294">2017:02:24 00:50:41   anthony.naddeo </span><span>yeah its totally arbitrary. I&apos;ve punted on all inline comments atm</span></div><div data-t="anthony.naddeo the only challenge was modeling them in a meaningful way. I wanted to be able to convert the tree back into code and preserve the comments, or be able to include data about comments in queries against the parse tree"><span class="u" id="1487897497.000295">2017:02:24 00:51:37   anthony.naddeo </span><span>the only challenge was modeling them in a meaningful way. I wanted to be able to convert the tree back into code and preserve the comments, or be able to include data about comments in queries against the parse tree</span></div><div data-t="bherrmann how does instaparse compare to ANTLR"><span class="u" id="1489017485.000296">2017:03:08 23:58:05        bherrmann </span><span>how does instaparse compare to ANTLR</span></div><div data-t="aengelberg @bherrmann: in comparison, instaparse is slow and memory-inefficient, but far easier to use and accepts more types of grammars"><span class="u" id="1489017619.000297">2017:03:09 00:00:19       aengelberg </span><span>@bherrmann: in comparison, instaparse is slow and memory-inefficient, but far easier to use and accepts more types of grammars</span></div><div data-t="aengelberg I&apos;ve never actually used ANTLR so I&apos;m just guessing on both points"><span class="u" id="1489017644.000298">2017:03:09 00:00:44       aengelberg </span><span>I&apos;ve never actually used ANTLR so I&apos;m just guessing on both points</span></div><div data-t="bherrmann Ha!"><span class="u" id="1489017653.000299">2017:03:09 00:00:53        bherrmann </span><span>Ha!</span></div><div data-t="bherrmann We have a large oracle grammar…  in ANTLR  and I’m curious about using instaparse instead"><span class="u" id="1489017702.000300">2017:03:09 00:01:42        bherrmann </span><span>We have a large oracle grammar…  in ANTLR  and I’m curious about using instaparse instead</span></div><div data-t="aengelberg So it&apos;s already working in ANTLR?"><span class="u" id="1489017750.000301">2017:03:09 00:02:30       aengelberg </span><span>So it&apos;s already working in ANTLR?</span></div><div data-t="aengelberg Why would you want to switch?"><span class="u" id="1489017754.000302">2017:03:09 00:02:34       aengelberg </span><span>Why would you want to switch?</span></div><div data-t="aengelberg (genuinely curious)"><span class="u" id="1489017915.000303">2017:03:09 00:05:15       aengelberg </span><span>(genuinely curious)</span></div><div data-t="bherrmann well.   This might be the wrong reason"><span class="u" id="1489018092.000304">2017:03:09 00:08:12        bherrmann </span><span>well.   This might be the wrong reason</span></div><div data-t="bherrmann by when we make changes to the ANTLR grammar, it generates a java file which is too big to be compiled"><span class="u" id="1489018116.000305">2017:03:09 00:08:36        bherrmann </span><span>by when we make changes to the ANTLR grammar, it generates a java file which is too big to be compiled</span></div><div data-t="bherrmann so at the moment, we have to giggle the rules to keep the output small enough to be compiled."><span class="u" id="1489018142.000306">2017:03:09 00:09:02        bherrmann </span><span>so at the moment, we have to giggle the rules to keep the output small enough to be compiled.</span></div><div data-t="bherrmann It is ANTLR V3"><span class="u" id="1489018150.000307">2017:03:09 00:09:10        bherrmann </span><span>It is ANTLR V3</span></div><div data-t="seylerius That sounds... clumsy."><span class="u" id="1489018208.000308">2017:03:09 00:10:08        seylerius </span><span>That sounds... clumsy.</span></div><div data-t="bherrmann well, it that old song of someone understanding how ANTLR v3 works and them leaving the company...."><span class="u" id="1489018293.000310">2017:03:09 00:11:33        bherrmann </span><span>well, it that old song of someone understanding how ANTLR v3 works and them leaving the company....</span></div><div data-t="bherrmann I’m working with a modified version of this  http://www.antlr3.org/grammar/1209225566284/PLSQL3.g"><span class="u" id="1489018616.000311">2017:03:09 00:16:56        bherrmann </span><span>I’m working with a modified version of this </span><a href="http://www.antlr3.org/grammar/1209225566284/PLSQL3.g">http://www.antlr3.org/grammar/1209225566284/PLSQL3.g</a></div><div data-t="bherrmann I should really read this  https://tomassetti.me/antlr-mega-tutorial/"><span class="u" id="1489018654.000312">2017:03:09 00:17:34        bherrmann </span><span>I should really read this </span><a href="https://tomassetti.me/antlr-mega-tutorial/">https://tomassetti.me/antlr-mega-tutorial/</a></div><div data-t="bherrmann although that page is ANTLR V4"><span class="u" id="1489018690.000314">2017:03:09 00:18:10        bherrmann </span><span>although that page is ANTLR V4</span></div><div data-t="bherrmann I’m curious if the PLSQL3.g could easily be consumed by Instaparse"><span class="u" id="1489018724.000315">2017:03:09 00:18:44        bherrmann </span><span>I’m curious if the PLSQL3.g could easily be consumed by Instaparse</span></div><div data-t="aengelberg The  is_sql  thing actually looks like something unique to ANTLR (not standard BNF)"><span class="u" id="1489018845.000316">2017:03:09 00:20:45       aengelberg </span><span>The </span><code>is_sql</code><span> thing actually looks like something unique to ANTLR (not standard BNF)</span></div><div data-t="aengelberg i.e. setting local variables"><span class="u" id="1489018852.000317">2017:03:09 00:20:52       aengelberg </span><span>i.e. setting local variables</span></div><div data-t="bherrmann yea, that is weird"><span class="u" id="1489019030.000318">2017:03:09 00:23:50        bherrmann </span><span>yea, that is weird</span></div><div data-t="bherrmann we dont use the is_sql in our copy."><span class="u" id="1489019064.000319">2017:03:09 00:24:24        bherrmann </span><span>we dont use the is_sql in our copy.</span></div><div data-t="bherrmann so the grammar has about 1600 lines (ours has around 2k)…   They appear otherwise very similar"><span class="u" id="1489019298.000320">2017:03:09 00:28:18        bherrmann </span><span>so the grammar has about 1600 lines (ours has around 2k)…   They appear otherwise very similar</span></div><div data-t="nathansmutz I&apos;m sure this is asked a lot; but I&apos;m not figuring out how to search it. 
Is there a standard way to get instaparse to pick grammar-fitting things out of a mess of other text? 

In text-mining, I&apos;ve used regular expressions to carve out the bits I want to parse; but that&apos;s pretty redundant.  Starting and ending your grammar with an &lt;anything&gt; pattern  is slow; and, I&apos;m sure, makes instaparser grind away on unnecessary work."><span class="u" id="1489531129.935683">2017:03:14 22:38:49      nathansmutz </span><span>I&apos;m sure this is asked a lot; but I&apos;m not figuring out how to search it. 
Is there a standard way to get instaparse to pick grammar-fitting things out of a mess of other text? 

In text-mining, I&apos;ve used regular expressions to carve out the bits I want to parse; but that&apos;s pretty redundant.  Starting and ending your grammar with an &lt;anything&gt; pattern  is slow; and, I&apos;m sure, makes instaparser grind away on unnecessary work.</span></div><div data-t="aengelberg Instaparse only works on &quot;full parses&quot;, so adding  &lt;anything&gt;  is the only way to go."><span class="u" id="1489599139.206363">2017:03:15 17:32:19       aengelberg </span><span>Instaparse only works on &quot;full parses&quot;, so adding </span><code>&lt;anything&gt;</code><span> is the only way to go.</span></div><div data-t="aengelberg @nathansmutz if adding  &lt;#&apos;[\\s\\S]&apos;+&gt;  (anything) is too slow, you could maybe  (str/replace #&quot;things you definitely don&apos;t want to parse&quot; &quot;&quot;)  beforehand"><span class="u" id="1489599240.251176">2017:03:15 17:34:00       aengelberg </span><span>@nathansmutz if adding </span><code>&lt;#&apos;[\\s\\S]&apos;+&gt;</code><span> (anything) is too slow, you could maybe </span><code>(str/replace #&quot;things you definitely don&apos;t want to parse&quot; &quot;&quot;)</code><span> beforehand</span></div><div data-t="aengelberg so instaparse isn&apos;t churning through too much garbage"><span class="u" id="1489599264.262420">2017:03:15 17:34:24       aengelberg </span><span>so instaparse isn&apos;t churning through too much garbage</span></div><div data-t="nathansmutz Thanks @aengelberg. I wonder if my &lt;anything&gt; was more complicated than that when I tried it.  
Hmm,  there may be a useful project in &quot;parsing&quot; instaparse code into regex suitable for grabbing parsable chunks.  I&apos;m pretty sure instaparse is generating regex on the backend; but the capture-groups would need some editing."><span class="u" id="1489768017.014507">2017:03:17 16:26:57      nathansmutz </span><span>Thanks @aengelberg. I wonder if my &lt;anything&gt; was more complicated than that when I tried it.  
Hmm,  there may be a useful project in &quot;parsing&quot; instaparse code into regex suitable for grabbing parsable chunks.  I&apos;m pretty sure instaparse is generating regex on the backend; but the capture-groups would need some editing.</span></div><div data-t="hiredman that is not correct, instaparse parses context free langauges, which regexes cannot do"><span class="u" id="1489768172.077518">2017:03:17 16:29:32         hiredman </span><span>that is not correct, instaparse parses context free langauges, which regexes cannot do</span></div><div data-t="hiredman (regular languages are a subset of context free languages)"><span class="u" id="1489768213.094398">2017:03:17 16:30:13         hiredman </span><span>(regular languages are a subset of context free languages)</span></div><div data-t="nathansmutz @hiredman  I think I see what you mean.  The problems I&apos;ve been solving are probably simple enough that regex could define the same patterns.   I suppose, getting into some real recursive stuff, it&apos;d be less easy to go from instaparse-code to regex that says &quot;grab a block of text that looks like this&quot;."><span class="u" id="1489770671.083726">2017:03:17 17:11:11      nathansmutz </span><span>@hiredman  I think I see what you mean.  The problems I&apos;ve been solving are probably simple enough that regex could define the same patterns.   I suppose, getting into some real recursive stuff, it&apos;d be less easy to go from instaparse-code to regex that says &quot;grab a block of text that looks like this&quot;.</span></div><div data-t="wistb @aengelberg , I am trying instaparse against an IETF abnf ( https://tools.ietf.org/html/rfc7950  ). I am getting the error Parse error at line 92, column 44:
                         &lt; URI in RFC 3986 &gt;"><span class="u" id="1491252554.936237">2017:04:03 20:49:14            wistb </span><span>@aengelberg , I am trying instaparse against an IETF abnf (</span><a href="https://tools.ietf.org/html/rfc7950">https://tools.ietf.org/html/rfc7950</a><span> ). I am getting the error Parse error at line 92, column 44:
                         &lt; URI in RFC 3986 &gt;</span></div><div data-t="wistb and this is what I see at that location"><span class="u" id="1491252596.950845">2017:04:03 20:49:56            wistb </span><span>and this is what I see at that location</span></div><div data-t="wistb uri-str             = &lt; a string that matches the rule &gt;
                         &lt; URI in RFC 3986 &gt;"><span class="u" id="1491252597.951333">2017:04:03 20:49:57            wistb </span><span>uri-str             = &lt; a string that matches the rule &gt;
                         &lt; URI in RFC 3986 &gt;</span></div><div data-t="aengelberg &lt; a string that matches the rule &gt;  isn&apos;t valid BNF. In that spec, it is used for prose that can only be understood by humans."><span class="u" id="1491252637.965820">2017:04:03 20:50:37       aengelberg </span><code>&lt; a string that matches the rule &gt;</code><span> isn&apos;t valid BNF. In that spec, it is used for prose that can only be understood by humans.</span></div><div data-t="aengelberg In Instaparse we use  &lt;abc&gt;  completely differently, used to refer to the &quot;hidden&quot; version of the non-terminal  abc ."><span class="u" id="1491252661.974250">2017:04:03 20:51:01       aengelberg </span><span>In Instaparse we use </span><code>&lt;abc&gt;</code><span> completely differently, used to refer to the &quot;hidden&quot; version of the non-terminal </span><code>abc</code><span>.</span></div><div data-t="wistb thank you @aengelberg . I made a change and the parsing moved forward. Now, I am getting an error (in the last few pages of the grammar file, So, I am hoping the grammar is holding up well so far)"><span class="u" id="1491253201.169101">2017:04:03 21:00:01            wistb </span><span>thank you @aengelberg . I made a change and the parsing moved forward. Now, I am getting an error (in the last few pages of the grammar file, So, I am hoping the grammar is holding up well so far)</span></div><div data-t="wistb CompilerException java.lang.RuntimeException: Error parsing grammar specification:
Parse error at line 915, column 32:
   action-keyword           = %s&quot;action&quot;"><span class="u" id="1491253203.170365">2017:04:03 21:00:03            wistb </span><span>CompilerException java.lang.RuntimeException: Error parsing grammar specification:
Parse error at line 915, column 32:
   action-keyword           = %s&quot;action&quot;</span></div><div data-t="wistb I think the ietf doc wants to use &apos;non case sensitive&apos; form."><span class="u" id="1491253228.180093">2017:04:03 21:00:28            wistb </span><span>I think the ietf doc wants to use &apos;non case sensitive&apos; form.</span></div><div data-t="aengelberg I don&apos;t think  %s  is valid ABNF per the spec, though I see what it&apos;s getting at, and it wouldn&apos;t be too hard to implement."><span class="u" id="1491254693.657771">2017:04:03 21:24:53       aengelberg </span><span>I don&apos;t think </span><code>%s</code><span> is valid ABNF per the spec, though I see what it&apos;s getting at, and it wouldn&apos;t be too hard to implement.</span></div><div data-t="aengelberg If you&apos;re ok with case insensitive, you could just do  &quot;action&quot;"><span class="u" id="1491254794.689382">2017:04:03 21:26:34       aengelberg </span><span>If you&apos;re ok with case insensitive, you could just do </span><code>&quot;action&quot;</code></div><div data-t="wistb @aengelberg for now, I removed %s and moved on. It is getting close to the end of the file, but, I have this error :"><span class="u" id="1491254801.691357">2017:04:03 21:26:41            wistb </span><span>@aengelberg for now, I removed %s and moved on. It is getting close to the end of the file, but, I have this error :</span></div><div data-t="aengelberg If you really want case sensitive, you could translate it to decimal or hex and use  %d  /  %x"><span class="u" id="1491254806.692955">2017:04:03 21:26:46       aengelberg </span><span>If you really want case sensitive, you could translate it to decimal or hex and use </span><code>%d</code><span> / </span><code>%x</code></div><div data-t="aengelberg You&apos;re going to want  :input-format :abnf  if you haven&apos;t set that already btw"><span class="u" id="1491254818.696414">2017:04:03 21:26:58       aengelberg </span><span>You&apos;re going to want </span><code>:input-format :abnf</code><span> if you haven&apos;t set that already btw</span></div><div data-t="wistb CompilerException java.lang.RuntimeException: a occurs on the right-hand side of your grammar, but not on the left,"><span class="u" id="1491254921.727778">2017:04:03 21:28:41            wistb </span><span>CompilerException java.lang.RuntimeException: a occurs on the right-hand side of your grammar, but not on the left,</span></div><div data-t="wistb I am invoking , like so,"><span class="u" id="1491254956.738141">2017:04:03 21:29:16            wistb </span><span>I am invoking , like so,</span></div><div data-t="wistb (def my-parser
  (insta/parser ( http://clojure.java.io/resource  &quot;my.abnf&quot;)
                :input-format :abnf :trace true))"><span class="u" id="1491254957.738418">2017:04:03 21:29:17            wistb </span><span>(def my-parser
  (insta/parser (</span><a href="http://clojure.java.io/resource">http://clojure.java.io/resource</a><span> &quot;my.abnf&quot;)
                :input-format :abnf :trace true))</span></div><div data-t="wistb But, this time, I don&apos;t know which particular text is the culprit."><span class="u" id="1491255021.758481">2017:04:03 21:30:21            wistb </span><span>But, this time, I don&apos;t know which particular text is the culprit.</span></div><div data-t="aengelberg hmm."><span class="u" id="1491255320.849012">2017:04:03 21:35:20       aengelberg </span><span>hmm.</span></div><div data-t="aengelberg Only thing I can think of is there is a loose  a  or  A  somewhere..."><span class="u" id="1491255332.852542">2017:04:03 21:35:32       aengelberg </span><span>Only thing I can think of is there is a loose </span><code>a</code><span> or </span><code>A</code><span> somewhere...</span></div><div data-t="aengelberg Or it&apos;s one of the  &lt; a string that matches the rule &gt; "><span class="u" id="1491255369.862964">2017:04:03 21:36:09       aengelberg </span><span>Or it&apos;s one of the </span><code>&lt; a string that matches the rule &gt; </code></div><div data-t="aengelberg and the  a  is the first of many invalid things in that expression."><span class="u" id="1491255376.865435">2017:04:03 21:36:16       aengelberg </span><span>and the </span><code>a</code><span> is the first of many invalid things in that expression.</span></div><div data-t="wistb Let me see. I removed those kind of usages. May be there is still something lurking .."><span class="u" id="1491255434.882067">2017:04:03 21:37:14            wistb </span><span>Let me see. I removed those kind of usages. May be there is still something lurking ..</span></div><div data-t="wistb @aengelberg .. great . that is the issue. one such usage got left out. I changed it, now, that parsing is completing without error.  Thank you."><span class="u" id="1491255692.956121">2017:04:03 21:41:32            wistb </span><span>@aengelberg .. great . that is the issue. one such usage got left out. I changed it, now, that parsing is completing without error.  Thank you.</span></div><div data-t="aengelberg sweet"><span class="u" id="1491255700.958275">2017:04:03 21:41:40       aengelberg </span><span>sweet</span></div><div data-t="aengelberg np"><span class="u" id="1491255702.958798">2017:04:03 21:41:42       aengelberg </span><span>np</span></div><div data-t="wistb I am not sure about the change I made (I dont know much about grammars), though ..

I changed the text from

yang-version-arg-str = &lt; a string that matches the rule &gt;
                       &lt; yang-version-arg &gt;
to

yang-version-arg-str = yang-version-arg
yang-version-arg    = &quot;1.1&quot;"><span class="u" id="1491255853.000564">2017:04:03 21:44:13            wistb </span><span>I am not sure about the change I made (I dont know much about grammars), though ..

I changed the text from

yang-version-arg-str = &lt; a string that matches the rule &gt;
                       &lt; yang-version-arg &gt;
to

yang-version-arg-str = yang-version-arg
yang-version-arg    = &quot;1.1&quot;</span></div><div data-t="wistb if that is correct, I wonder why the ietf folks did not do the same. As it is , the ietf abnf is not parseable, right."><span class="u" id="1491255905.015379">2017:04:03 21:45:05            wistb </span><span>if that is correct, I wonder why the ietf folks did not do the same. As it is , the ietf abnf is not parseable, right.</span></div><div data-t="aengelberg I think some grammars are written with the intention of helping humans to write programs, rather than to be fed to parser generators like Instaparse."><span class="u" id="1491256143.081736">2017:04:03 21:49:03       aengelberg </span><span>I think some grammars are written with the intention of helping humans to write programs, rather than to be fed to parser generators like Instaparse.</span></div><div data-t="aengelberg So they don&apos;t feel the need to exactly follow the ABNF spec."><span class="u" id="1491256154.084877">2017:04:03 21:49:14       aengelberg </span><span>So they don&apos;t feel the need to exactly follow the ABNF spec.</span></div><div data-t="gmercer Hi - I was trying to use instaparse (clone from github) with lumo (or planck) 
I hit some issues (they are in the lumo channel) 
I am happy to cross-post but I thought it may be polite to not do so initially"><span class="u" id="1492212890.058558">2017:04:14 23:34:50          gmercer </span><span>Hi - I was trying to use instaparse (clone from github) with lumo (or planck) 
I hit some issues (they are in the lumo channel) 
I am happy to cross-post but I thought it may be polite to not do so initially</span></div><div data-t="aengelberg Instaparse is known to be incompatible with bootstrapped cljs so I&apos;m not surprised :("><span class="u" id="1492215289.391363">2017:04:15 00:14:49       aengelberg </span><span>Instaparse is known to be incompatible with bootstrapped cljs so I&apos;m not surprised :(</span></div><div data-t="aengelberg Specifically, the cljs version currently uses clj to do macro-time compile steps"><span class="u" id="1492215314.394451">2017:04:15 00:15:14       aengelberg </span><span>Specifically, the cljs version currently uses clj to do macro-time compile steps</span></div><div data-t="aengelberg In theory, it doesn&apos;t have to do that logic on clj, but I don&apos;t know of an easy way to use reader conditionals, etc to write cross-compatible macros as opposed to functions"><span class="u" id="1492215364.400784">2017:04:15 00:16:04       aengelberg </span><span>In theory, it doesn&apos;t have to do that logic on clj, but I don&apos;t know of an easy way to use reader conditionals, etc to write cross-compatible macros as opposed to functions</span></div><div data-t="gmercer cross compatible macros  - thanks, now I have a focus .. soon instaparse will be bootstrapped cljs compatible  😃"><span class="u" id="1492215725.445022">2017:04:15 00:22:05          gmercer </span><code>cross compatible macros</code><span> - thanks, now I have a focus .. soon instaparse will be bootstrapped cljs compatible </span><b>😃</b></div><div data-t="gmercer although the earlier issue regarding the reader eagerly compiling the regex would add a little bit of hairiness  😞"><span class="u" id="1492216030.481492">2017:04:15 00:27:10          gmercer </span><span>although the earlier issue regarding the reader eagerly compiling the regex would add a little bit of hairiness </span><b>😞</b></div><div data-t="aengelberg Let me know if you need any assistance / explanations for some of the instaparse code"><span class="u" id="1492216108.490994">2017:04:15 00:28:28       aengelberg </span><span>Let me know if you need any assistance / explanations for some of the instaparse code</span></div><div data-t="gmercer cheers"><span class="u" id="1492216118.492342">2017:04:15 00:28:38          gmercer </span><span>cheers</span></div><div data-t="wilkerlucio hello people, I&apos;m stuck with a instaparse rule, maybe someone here can help me out  🙂"><span class="u" id="1496753188.033584">2017:06:06 12:46:28      wilkerlucio </span><span>hello people, I&apos;m stuck with a instaparse rule, maybe someone here can help me out </span><b>🙂</b></div><div data-t="wilkerlucio I&apos;m writing a parser for Javascript regexes"><span class="u" id="1496753196.035452">2017:06:06 12:46:36      wilkerlucio </span><span>I&apos;m writing a parser for Javascript regexes</span></div><div data-t="wilkerlucio this is the current grammar:"><span class="u" id="1496753200.036584">2017:06:06 12:46:40      wilkerlucio </span><span>this is the current grammar:</span></div><div data-t="wilkerlucio Regex = &lt;&apos;/&apos;&gt; Alternation &lt;&apos;/&apos;&gt; MatchFlag*

Alternation = Concatenation (&lt;&apos;|&apos;&gt; Concatenation)*

Concatenation = SuffixedExpr*

SuffixedExpr = SingleExpr Suffix?
SingleExpr = BaseExpr | ParenthesizedExpr
ParenthesizedExpr = &lt;&apos;(&apos;&gt; GroupFlags? Alternation &lt;&apos;)&apos;&gt;
Suffix = (Optional | Positive | NonNegative | CurlyRepetition) Quantifier?
Optional = &lt;&apos;?&apos;&gt;
Positive = &lt;&apos;+&apos;&gt;
NonNegative = &lt;&apos;*&apos;&gt;
CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; (&lt;&apos;,&apos;&gt; #&quot;\d+&quot; ?) ? &lt;&apos;}&apos;&gt;
Quantifier = &apos;?&apos; | &apos;+&apos;
BaseExpr = CharExpr | LiteralChar | Anchor | BackReference

Anchor = &apos;^&apos; | &apos;$&apos; | &apos;\\&apos; #&quot;[bB]&quot;
LiteralChar = PlainChar | EscapedChar

BackReference = &lt;&apos;\\&apos;&gt; #&quot;[1-9][0-9]*&quot;

PlainChar = #&quot;[^.|\\+*$^\[(){?]&quot;
CharExpr = Dot | LiteralChar | BCC
Dot = &apos;.&apos;

BCC = &lt;&apos;[&apos;&gt; BCCUnionLeft? &lt;&apos;]&apos;&gt;

BCCUnionLeft = BCCNegation? BCCElemBase*

BCCNegation = &apos;^&apos;

BCCElemBase = BCCCharNonRange | SpecialCharClass | BCCRange | BCC
BCCRangeRightable = BCCCharEndRange | SpecialCharClass
BCCRange = BCCChar &lt;&apos;-&apos;&gt; BCCCharEndRange
BCCRangeWithBracket = &lt;&apos;]-&apos;&gt; BCCCharEndRange
BCCCharNonRange = BCCChar !(&apos;-&apos; BCCRangeRightable)
BCCChar = BCCPlainChar | EscapedChar
BCCCharEndRange = BCCPlainChar | EscapedChar
BCCPlainChar = #&quot;[^\]\[\\]&quot; | &apos;\\b&apos;

EscapedChar = SpecialCharClass | NormalSlashedCharacters | ControlChar | HexChar | BasicEscapedChar

HexChar = ShortHexChar | MediumHexChar | LongHexChar | VeryLongHexChar
ShortHexChar = &lt;&apos;\\x&apos;&gt; #&apos;[0-9a-fA-F]{2}&apos;
MediumHexChar = &lt;&apos;\\u&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos;
LongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos; &lt;&apos;}&apos;&gt;
VeryLongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{6}&apos; &lt;&apos;}&apos;&gt;
BasicEscapedChar = &lt;&apos;\\&apos;&gt; #&quot;[\s\S]&quot;
SpecialCharClass = &lt;&apos;\\&apos;&gt; #&quot;[dDwWsSv0]&quot;

NormalSlashedCharacters = #&quot;\\[tnrf]&quot;

ControlChar = &lt;&apos;\\c&apos;&gt; #&quot;[A-Z]&quot;

(** FLAGS **)
GroupFlags = NonCapturingMatchFlags
           | PositiveLookAheadFlag
           | NegativeLookAheadFlag

NonCapturingMatchFlags = &lt;&apos;?&apos;&gt; !&apos;)&apos; &lt;&apos;:&apos;&gt;
PositiveLookAheadFlag = &lt;&apos;?=&apos;&gt;
NegativeLookAheadFlag = &lt;&apos;?!&apos;&gt;

MatchFlag = #&quot;[gimuy]&quot;
"><span class="u" id="1496753209.038868">2017:06:06 12:46:49      wilkerlucio </span><pre>Regex = &lt;&apos;/&apos;&gt; Alternation &lt;&apos;/&apos;&gt; MatchFlag*

Alternation = Concatenation (&lt;&apos;|&apos;&gt; Concatenation)*

Concatenation = SuffixedExpr*

SuffixedExpr = SingleExpr Suffix?
SingleExpr = BaseExpr | ParenthesizedExpr
ParenthesizedExpr = &lt;&apos;(&apos;&gt; GroupFlags? Alternation &lt;&apos;)&apos;&gt;
Suffix = (Optional | Positive | NonNegative | CurlyRepetition) Quantifier?
Optional = &lt;&apos;?&apos;&gt;
Positive = &lt;&apos;+&apos;&gt;
NonNegative = &lt;&apos;*&apos;&gt;
CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; (&lt;&apos;,&apos;&gt; #&quot;\d+&quot; ?) ? &lt;&apos;}&apos;&gt;
Quantifier = &apos;?&apos; | &apos;+&apos;
BaseExpr = CharExpr | LiteralChar | Anchor | BackReference

Anchor = &apos;^&apos; | &apos;$&apos; | &apos;\\&apos; #&quot;[bB]&quot;
LiteralChar = PlainChar | EscapedChar

BackReference = &lt;&apos;\\&apos;&gt; #&quot;[1-9][0-9]*&quot;

PlainChar = #&quot;[^.|\\+*$^\[(){?]&quot;
CharExpr = Dot | LiteralChar | BCC
Dot = &apos;.&apos;

BCC = &lt;&apos;[&apos;&gt; BCCUnionLeft? &lt;&apos;]&apos;&gt;

BCCUnionLeft = BCCNegation? BCCElemBase*

BCCNegation = &apos;^&apos;

BCCElemBase = BCCCharNonRange | SpecialCharClass | BCCRange | BCC
BCCRangeRightable = BCCCharEndRange | SpecialCharClass
BCCRange = BCCChar &lt;&apos;-&apos;&gt; BCCCharEndRange
BCCRangeWithBracket = &lt;&apos;]-&apos;&gt; BCCCharEndRange
BCCCharNonRange = BCCChar !(&apos;-&apos; BCCRangeRightable)
BCCChar = BCCPlainChar | EscapedChar
BCCCharEndRange = BCCPlainChar | EscapedChar
BCCPlainChar = #&quot;[^\]\[\\]&quot; | &apos;\\b&apos;

EscapedChar = SpecialCharClass | NormalSlashedCharacters | ControlChar | HexChar | BasicEscapedChar

HexChar = ShortHexChar | MediumHexChar | LongHexChar | VeryLongHexChar
ShortHexChar = &lt;&apos;\\x&apos;&gt; #&apos;[0-9a-fA-F]{2}&apos;
MediumHexChar = &lt;&apos;\\u&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos;
LongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos; &lt;&apos;}&apos;&gt;
VeryLongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{6}&apos; &lt;&apos;}&apos;&gt;
BasicEscapedChar = &lt;&apos;\\&apos;&gt; #&quot;[\s\S]&quot;
SpecialCharClass = &lt;&apos;\\&apos;&gt; #&quot;[dDwWsSv0]&quot;

NormalSlashedCharacters = #&quot;\\[tnrf]&quot;

ControlChar = &lt;&apos;\\c&apos;&gt; #&quot;[A-Z]&quot;

(** FLAGS **)
GroupFlags = NonCapturingMatchFlags
           | PositiveLookAheadFlag
           | NegativeLookAheadFlag

NonCapturingMatchFlags = &lt;&apos;?&apos;&gt; !&apos;)&apos; &lt;&apos;:&apos;&gt;
PositiveLookAheadFlag = &lt;&apos;?=&apos;&gt;
NegativeLookAheadFlag = &lt;&apos;?!&apos;&gt;

MatchFlag = #&quot;[gimuy]&quot;
</pre></div><div data-t="wilkerlucio I would like it to parse  { , as a plain char, currently on the  PlainChar  definition this char is excluded to allow for the  CurlyRepetition"><span class="u" id="1496753319.067072">2017:06:06 12:48:39      wilkerlucio </span><span>I would like it to parse </span><code>{</code><span>, as a plain char, currently on the </span><code>PlainChar</code><span> definition this char is excluded to allow for the </span><code>CurlyRepetition</code></div><div data-t="wilkerlucio I&apos;m probably missing something"><span class="u" id="1496753327.069241">2017:06:06 12:48:47      wilkerlucio </span><span>I&apos;m probably missing something</span></div><div data-t="wilkerlucio but if I allow the  {  at  PlainChar"><span class="u" id="1496753341.072898">2017:06:06 12:49:01      wilkerlucio </span><span>but if I allow the </span><code>{</code><span> at </span><code>PlainChar</code></div><div data-t="wilkerlucio then when I try to do:  a{2}"><span class="u" id="1496753355.076763">2017:06:06 12:49:15      wilkerlucio </span><span>then when I try to do: </span><code>a{2}</code></div><div data-t="wilkerlucio I was expect it to go into  SuffixedExpr  and match a  PlainChar  followed by a  Suffix  that would be a  CurlyRepetition"><span class="u" id="1496753386.084308">2017:06:06 12:49:46      wilkerlucio </span><span>I was expect it to go into </span><code>SuffixedExpr</code><span> and match a </span><code>PlainChar</code><span> followed by a </span><code>Suffix</code><span> that would be a </span><code>CurlyRepetition</code></div><div data-t="wilkerlucio but instead seems like it&apos;s not matching the suffix, and instead matches a series of plain chars"><span class="u" id="1496753411.090777">2017:06:06 12:50:11      wilkerlucio </span><span>but instead seems like it&apos;s not matching the suffix, and instead matches a series of plain chars</span></div><div data-t="wilkerlucio sorry the noise, I got a much simplified version now, by this grammar:"><span class="u" id="1496753731.177168">2017:06:06 12:55:31      wilkerlucio </span><span>sorry the noise, I got a much simplified version now, by this grammar:</span></div><div data-t="wilkerlucio Concatenation = SuffixedExpr*

SuffixedExpr = LiteralChar CurlyRepetition?

CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; &lt;&apos;}&apos;&gt;

LiteralChar = #&quot;.&quot;
"><span class="u" id="1496753734.178031">2017:06:06 12:55:34      wilkerlucio </span><pre>Concatenation = SuffixedExpr*

SuffixedExpr = LiteralChar CurlyRepetition?

CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; &lt;&apos;}&apos;&gt;

LiteralChar = #&quot;.&quot;
</pre></div><div data-t="wilkerlucio I expected it to match  &quot;a{2}&quot;  as a  LiteralChar  followed by a  CurlyRepetition , but instead it matches as  [:Concatenation [:SuffixedExpr [:LiteralChar &quot;a&quot;]] [:SuffixedExpr [:LiteralChar &quot;{&quot;]] [:SuffixedExpr [:LiteralChar &quot;2&quot;]] [:SuffixedExpr [:LiteralChar &quot;}&quot;]]]"><span class="u" id="1496753782.191481">2017:06:06 12:56:22      wilkerlucio </span><span>I expected it to match </span><code>&quot;a{2}&quot;</code><span> as a </span><code>LiteralChar</code><span> followed by a </span><code>CurlyRepetition</code><span>, but instead it matches as </span><code>[:Concatenation [:SuffixedExpr [:LiteralChar &quot;a&quot;]] [:SuffixedExpr [:LiteralChar &quot;{&quot;]] [:SuffixedExpr [:LiteralChar &quot;2&quot;]] [:SuffixedExpr [:LiteralChar &quot;}&quot;]]]</code></div><div data-t="wilkerlucio how can make it try force match the  CurlyRepetition  before stepping a level up and matching more literal chars?"><span class="u" id="1496753822.202234">2017:06:06 12:57:02      wilkerlucio </span><span>how can make it try force match the </span><code>CurlyRepetition</code><span> before stepping a level up and matching more literal chars?</span></div><div data-t="aengelberg @wilkerlucio maybe ordered choice  /  in instaparse might help here?"><span class="u" id="1496764842.435558">2017:06:06 16:00:42       aengelberg </span><span>@wilkerlucio maybe ordered choice </span><code>/</code><span> in instaparse might help here?</span></div><div data-t="aengelberg so you want  a{2  to parse as 3 PlainChars, but  a{2}  to parse as a PlainChar followed by a CurlyRepetition?"><span class="u" id="1496764953.481808">2017:06:06 16:02:33       aengelberg </span><span>so you want </span><code>a{2</code><span> to parse as 3 PlainChars, but </span><code>a{2}</code><span> to parse as a PlainChar followed by a CurlyRepetition?</span></div><div data-t="wilkerlucio @aengelberg yes, with some help I was able to figure it out, here is a way to handle it:"><span class="u" id="1496770461.513188">2017:06:06 17:34:21      wilkerlucio </span><span>@aengelberg yes, with some help I was able to figure it out, here is a way to handle it:</span></div><div data-t="wilkerlucio Concatenation = SuffixedExpr*

SuffixedExpr = LiteralChar CurlyRepetition? / AnyLiteralChar

CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; &lt;&apos;}&apos;&gt;

LiteralChar = #&quot;[^{]&quot;
AnyLiteralChar = #&quot;.&quot;"><span class="u" id="1496770463.513971">2017:06:06 17:34:23      wilkerlucio </span><pre>Concatenation = SuffixedExpr*

SuffixedExpr = LiteralChar CurlyRepetition? / AnyLiteralChar

CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; &lt;&apos;}&apos;&gt;

LiteralChar = #&quot;[^{]&quot;
AnyLiteralChar = #&quot;.&quot;</pre></div><div data-t="wilkerlucio I had to restrict the first one a little and have a second more permissive rule, now it parses the way I was expecting  🙂"><span class="u" id="1496770489.523743">2017:06:06 17:34:49      wilkerlucio </span><span>I had to restrict the first one a little and have a second more permissive rule, now it parses the way I was expecting </span><b>🙂</b></div><div data-t="aengelberg I suggest you take away the  ?  after  CurlyRepetition , to make the grammar unambiguous (improving performance)."><span class="u" id="1496770555.547653">2017:06:06 17:35:55       aengelberg </span><span>I suggest you take away the </span><code>?</code><span> after </span><code>CurlyRepetition</code><span>, to make the grammar unambiguous (improving performance).</span></div><div data-t="wilkerlucio @aengelberg but it is needed there, because the curlyrepetition is optional"><span class="u" id="1496770610.567211">2017:06:06 17:36:50      wilkerlucio </span><span>@aengelberg but it is needed there, because the curlyrepetition is optional</span></div><div data-t="wilkerlucio ah, I think I got you said, it would match anyway"><span class="u" id="1496770636.576619">2017:06:06 17:37:16      wilkerlucio </span><span>ah, I think I got you said, it would match anyway</span></div><div data-t="wilkerlucio in my real case its a bit more complicated"><span class="u" id="1496770644.579828">2017:06:06 17:37:24      wilkerlucio </span><span>in my real case its a bit more complicated</span></div><div data-t="wilkerlucio and the latest AnyLiteral actually just matches the  { , otherwise other complications arise"><span class="u" id="1496770659.584812">2017:06:06 17:37:39      wilkerlucio </span><span>and the latest AnyLiteral actually just matches the </span><code>{</code><span>, otherwise other complications arise</span></div><div data-t="wilkerlucio parsing regex is pretty annoying to be honest -.-"><span class="u" id="1496770677.590912">2017:06:06 17:37:57      wilkerlucio </span><span>parsing regex is pretty annoying to be honest -.-</span></div><div data-t="aengelberg lol yeah"><span class="u" id="1496770684.593433">2017:06:06 17:38:04       aengelberg </span><span>lol yeah</span></div><div data-t="aengelberg also, something to watch out for:  .  does not include the newline character"><span class="u" id="1496770701.599856">2017:06:06 17:38:21       aengelberg </span><span>also, something to watch out for: </span><code>.</code><span> does not include the newline character</span></div><div data-t="aengelberg but  [^{]  does"><span class="u" id="1496770713.604146">2017:06:06 17:38:33       aengelberg </span><span>but </span><code>[^{]</code><span> does</span></div><div data-t="wilkerlucio yeah, when I need everything I like to use something like  [\s\S]"><span class="u" id="1496770734.611626">2017:06:06 17:38:54      wilkerlucio </span><span>yeah, when I need everything I like to use something like </span><code>[\s\S]</code></div><div data-t="wilkerlucio so it matches everything"><span class="u" id="1496770737.612823">2017:06:06 17:38:57      wilkerlucio </span><span>so it matches everything</span></div><div data-t="aengelberg that’s exactly what I was going to suggest"><span class="u" id="1496770748.616498">2017:06:06 17:39:08       aengelberg </span><span>that’s exactly what I was going to suggest</span></div><div data-t="wilkerlucio in case you wonder, this is what my current grammar looks like (for parsing JS RegExp):"><span class="u" id="1496770756.619531">2017:06:06 17:39:16      wilkerlucio </span><span>in case you wonder, this is what my current grammar looks like (for parsing JS RegExp):</span></div><div data-t="wilkerlucio Regex = &lt;&apos;/&apos;&gt; Alternation &lt;&apos;/&apos;&gt; MatchFlag*

Alternation = Concatenation (&lt;&apos;|&apos;&gt; Concatenation)*

Concatenation = SuffixedExpr*

SuffixedExpr = SingleExpr Suffix? / CurlyRepetition / LiteralSpecialChar
SingleExpr = BaseExpr | ParenthesizedExpr
ParenthesizedExpr = &lt;&apos;(&apos;&gt; GroupFlags? Alternation &lt;&apos;)&apos;&gt;
Suffix = (Optional | Positive | NonNegative | CurlyRepetition) Quantifier?
Optional = &lt;&apos;?&apos;&gt;
Positive = &lt;&apos;+&apos;&gt;
NonNegative = &lt;&apos;*&apos;&gt;
CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; (&lt;&apos;,&apos;&gt; #&quot;\d+&quot; ?) ? &lt;&apos;}&apos;&gt;
Quantifier = &apos;?&apos; | &apos;+&apos;
BaseExpr = CharExpr | LiteralChar | Anchor | BackReference

Anchor = &apos;^&apos; | &apos;$&apos; | &apos;\\&apos; #&quot;[bB]&quot;
LiteralChar = PlainChar | EscapedChar
LiteralSpecialChar = &apos;{&apos;

BackReference = &lt;&apos;\\&apos;&gt; #&quot;[1-9][0-9]*&quot;

PlainChar = #&quot;[^.|\\+*$^\[(){?]&quot;
CharExpr = Dot / LiteralChar / BCCEmpty / BCC
Dot = &apos;.&apos;

BCC = &lt;&apos;[&apos;&gt; BCCUnionLeft? &lt;&apos;]&apos;&gt;
BCCEmpty = &apos;[]&apos;

BCCUnionLeft = BCCNegation? BCCElemBase*

BCCNegation = &apos;^&apos;

BCCElemBase = BCCCharNonRange | SpecialCharClass | BCCRange | BCC
BCCRangeRightable = BCCCharEndRange | SpecialCharClass
BCCRange = BCCChar &lt;&apos;-&apos;&gt; BCCCharEndRange
BCCRangeWithBracket = &lt;&apos;]-&apos;&gt; BCCCharEndRange
BCCCharNonRange = BCCChar !(&apos;-&apos; BCCRangeRightable)
BCCChar = BCCPlainChar | EscapedChar
BCCCharEndRange = BCCPlainChar | EscapedChar
BCCPlainChar = #&quot;[^\]\[\\]&quot; | &apos;\\b&apos;

EscapedChar = SpecialCharClass / NormalSlashedCharacters / ControlChar / HexChar / BasicEscapedChar

HexChar = ShortHexChar | MediumHexChar | LongHexChar | VeryLongHexChar
ShortHexChar = &lt;&apos;\\x&apos;&gt; #&apos;[0-9a-fA-F]{2}&apos;
MediumHexChar = &lt;&apos;\\u&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos;
LongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos; &lt;&apos;}&apos;&gt;
VeryLongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{6}&apos; &lt;&apos;}&apos;&gt;
BasicEscapedChar = &lt;&apos;\\&apos;&gt; #&quot;[\s\S]&quot;
SpecialCharClass = &lt;&apos;\\&apos;&gt; #&quot;[dDwWsSv0]&quot;

NormalSlashedCharacters = #&quot;\\[tnrf]&quot;

ControlChar = &lt;&apos;\\c&apos;&gt; #&quot;[A-Z]&quot;

(** FLAGS **)
GroupFlags = NonCapturingMatchFlags
           | PositiveLookAheadFlag
           | NegativeLookAheadFlag

NonCapturingMatchFlags = &lt;&apos;?&apos;&gt; !&apos;)&apos; &lt;&apos;:&apos;&gt;
PositiveLookAheadFlag = &lt;&apos;?=&apos;&gt;
NegativeLookAheadFlag = &lt;&apos;?!&apos;&gt;

MatchFlag = #&quot;[gimuy]&quot;
"><span class="u" id="1496770760.621292">2017:06:06 17:39:20      wilkerlucio </span><pre>Regex = &lt;&apos;/&apos;&gt; Alternation &lt;&apos;/&apos;&gt; MatchFlag*

Alternation = Concatenation (&lt;&apos;|&apos;&gt; Concatenation)*

Concatenation = SuffixedExpr*

SuffixedExpr = SingleExpr Suffix? / CurlyRepetition / LiteralSpecialChar
SingleExpr = BaseExpr | ParenthesizedExpr
ParenthesizedExpr = &lt;&apos;(&apos;&gt; GroupFlags? Alternation &lt;&apos;)&apos;&gt;
Suffix = (Optional | Positive | NonNegative | CurlyRepetition) Quantifier?
Optional = &lt;&apos;?&apos;&gt;
Positive = &lt;&apos;+&apos;&gt;
NonNegative = &lt;&apos;*&apos;&gt;
CurlyRepetition = &lt;&apos;{&apos;&gt; #&quot;\d+&quot; (&lt;&apos;,&apos;&gt; #&quot;\d+&quot; ?) ? &lt;&apos;}&apos;&gt;
Quantifier = &apos;?&apos; | &apos;+&apos;
BaseExpr = CharExpr | LiteralChar | Anchor | BackReference

Anchor = &apos;^&apos; | &apos;$&apos; | &apos;\\&apos; #&quot;[bB]&quot;
LiteralChar = PlainChar | EscapedChar
LiteralSpecialChar = &apos;{&apos;

BackReference = &lt;&apos;\\&apos;&gt; #&quot;[1-9][0-9]*&quot;

PlainChar = #&quot;[^.|\\+*$^\[(){?]&quot;
CharExpr = Dot / LiteralChar / BCCEmpty / BCC
Dot = &apos;.&apos;

BCC = &lt;&apos;[&apos;&gt; BCCUnionLeft? &lt;&apos;]&apos;&gt;
BCCEmpty = &apos;[]&apos;

BCCUnionLeft = BCCNegation? BCCElemBase*

BCCNegation = &apos;^&apos;

BCCElemBase = BCCCharNonRange | SpecialCharClass | BCCRange | BCC
BCCRangeRightable = BCCCharEndRange | SpecialCharClass
BCCRange = BCCChar &lt;&apos;-&apos;&gt; BCCCharEndRange
BCCRangeWithBracket = &lt;&apos;]-&apos;&gt; BCCCharEndRange
BCCCharNonRange = BCCChar !(&apos;-&apos; BCCRangeRightable)
BCCChar = BCCPlainChar | EscapedChar
BCCCharEndRange = BCCPlainChar | EscapedChar
BCCPlainChar = #&quot;[^\]\[\\]&quot; | &apos;\\b&apos;

EscapedChar = SpecialCharClass / NormalSlashedCharacters / ControlChar / HexChar / BasicEscapedChar

HexChar = ShortHexChar | MediumHexChar | LongHexChar | VeryLongHexChar
ShortHexChar = &lt;&apos;\\x&apos;&gt; #&apos;[0-9a-fA-F]{2}&apos;
MediumHexChar = &lt;&apos;\\u&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos;
LongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{4}&apos; &lt;&apos;}&apos;&gt;
VeryLongHexChar = &lt;&apos;\\x{&apos;&gt; #&apos;[0-9a-fA-F]{6}&apos; &lt;&apos;}&apos;&gt;
BasicEscapedChar = &lt;&apos;\\&apos;&gt; #&quot;[\s\S]&quot;
SpecialCharClass = &lt;&apos;\\&apos;&gt; #&quot;[dDwWsSv0]&quot;

NormalSlashedCharacters = #&quot;\\[tnrf]&quot;

ControlChar = &lt;&apos;\\c&apos;&gt; #&quot;[A-Z]&quot;

(** FLAGS **)
GroupFlags = NonCapturingMatchFlags
           | PositiveLookAheadFlag
           | NegativeLookAheadFlag

NonCapturingMatchFlags = &lt;&apos;?&apos;&gt; !&apos;)&apos; &lt;&apos;:&apos;&gt;
PositiveLookAheadFlag = &lt;&apos;?=&apos;&gt;
NegativeLookAheadFlag = &lt;&apos;?!&apos;&gt;

MatchFlag = #&quot;[gimuy]&quot;
</pre></div><div data-t="wilkerlucio it doesn&apos;t need to be perfect, the usage of this is to port the  test.chuck   string-from-regex  to CLJS"><span class="u" id="1496770824.644587">2017:06:06 17:40:24      wilkerlucio </span><span>it doesn&apos;t need to be perfect, the usage of this is to port the </span><code>test.chuck</code><span> </span><code>string-from-regex</code><span> to CLJS</span></div><div data-t="aengelberg gfredericks has already done work in  test.chuck  to parse Java regexes in instaparse, which may be useful:  https://github.com/gfredericks/test.chuck/blob/master/resources/com/gfredericks/test/chuck/regex.bnf"><span class="u" id="1496770840.650305">2017:06:06 17:40:40       aengelberg </span><span>gfredericks has already done work in </span><code>test.chuck</code><span> to parse Java regexes in instaparse, which may be useful: </span><a href="https://github.com/gfredericks/test.chuck/blob/master/resources/com/gfredericks/test/chuck/regex.bnf">https://github.com/gfredericks/test.chuck/blob/master/resources/com/gfredericks/test/chuck/regex.bnf</a></div><div data-t="wilkerlucio yeah, this is actually based of that"><span class="u" id="1496770855.655726">2017:06:06 17:40:55      wilkerlucio </span><span>yeah, this is actually based of that</span></div><div data-t="wilkerlucio I&apos;m trying to port it to CLJS"><span class="u" id="1496770861.657789">2017:06:06 17:41:01      wilkerlucio </span><span>I&apos;m trying to port it to CLJS</span></div><div data-t="aengelberg oh lol, you’re right, I just needed to look closer"><span class="u" id="1496770866.659511">2017:06:06 17:41:06       aengelberg </span><span>oh lol, you’re right, I just needed to look closer</span></div><div data-t="aengelberg you’re porting test.chuck to cljs?"><span class="u" id="1496770875.662835">2017:06:06 17:41:15       aengelberg </span><span>you’re porting test.chuck to cljs?</span></div><div data-t="aengelberg or just the regex generator?"><span class="u" id="1496770880.664624">2017:06:06 17:41:20       aengelberg </span><span>or just the regex generator?</span></div><div data-t="wilkerlucio just the regex generator, the rest is already all  cljc  actually"><span class="u" id="1496770893.669242">2017:06:06 17:41:33      wilkerlucio </span><span>just the regex generator, the rest is already all </span><code>cljc</code><span> actually</span></div><div data-t="aengelberg ok this explains a lot  🙂"><span class="u" id="1496770902.672534">2017:06:06 17:41:42       aengelberg </span><span>ok this explains a lot </span><b>🙂</b></div><div data-t="aengelberg so then how did you get the grammar into a weird state that behaved improperly with curly repetitions, just by removing certain things not part of the EcmaScript regex spec?"><span class="u" id="1496770946.688181">2017:06:06 17:42:26       aengelberg </span><span>so then how did you get the grammar into a weird state that behaved improperly with curly repetitions, just by removing certain things not part of the EcmaScript regex spec?</span></div><div data-t="aengelberg or was it already like that?"><span class="u" id="1496770954.691019">2017:06:06 17:42:34       aengelberg </span><span>or was it already like that?</span></div><div data-t="wilkerlucio the Java Regex have many different features compared to JS one"><span class="u" id="1496770984.701872">2017:06:06 17:43:04      wilkerlucio </span><span>the Java Regex have many different features compared to JS one</span></div><div data-t="aengelberg hmm I was under the impression that Java had a super-set of features to JS"><span class="u" id="1496771002.708350">2017:06:06 17:43:22       aengelberg </span><span>hmm I was under the impression that Java had a super-set of features to JS</span></div><div data-t="aengelberg clearly I was mistaken"><span class="u" id="1496771006.709570">2017:06:06 17:43:26       aengelberg </span><span>clearly I was mistaken</span></div><div data-t="wilkerlucio no, JS is more tolerant in some cases"><span class="u" id="1496771014.712365">2017:06:06 17:43:34      wilkerlucio </span><span>no, JS is more tolerant in some cases</span></div><div data-t="wilkerlucio for example, those are invalid on JVM, but ok on JS:  /a{/   /a{}/   /[]/"><span class="u" id="1496771034.720002">2017:06:06 17:43:54      wilkerlucio </span><span>for example, those are invalid on JVM, but ok on JS: </span><code>/a{/</code><span> </span><code>/a{}/</code><span> </span><code>/[]/</code></div><div data-t="wilkerlucio when JS sees an incomplete curly braces, it threats as literals"><span class="u" id="1496771060.729567">2017:06:06 17:44:20      wilkerlucio </span><span>when JS sees an incomplete curly braces, it threats as literals</span></div><div data-t="wilkerlucio where JVM throws an exception"><span class="u" id="1496771067.731898">2017:06:06 17:44:27      wilkerlucio </span><span>where JVM throws an exception</span></div><div data-t="wilkerlucio but in general the JS is simpler, since it doens&apos;t support character class unions (that feature adds a lot of complexity on the JVM Regex grammar, see:  https://www.regular-expressions.info/charclassintersect.html )"><span class="u" id="1496771116.750124">2017:06:06 17:45:16      wilkerlucio </span><span>but in general the JS is simpler, since it doens&apos;t support character class unions (that feature adds a lot of complexity on the JVM Regex grammar, see: </span><a href="https://www.regular-expressions.info/charclassintersect.html">https://www.regular-expressions.info/charclassintersect.html</a><span>)</span></div><div data-t="wilkerlucio so, this is the kind of feature that has a strong dependency on the platform"><span class="u" id="1496771136.757593">2017:06:06 17:45:36      wilkerlucio </span><span>so, this is the kind of feature that has a strong dependency on the platform</span></div><div data-t="wilkerlucio Gary did a great job making generative testing to check if the custom parser conforms with the platform regex parser, check this test:  https://github.com/gfredericks/test.chuck/blob/master/test/com/gfredericks/test/chuck/regexes_test.clj#L117-L119"><span class="u" id="1496771231.793075">2017:06:06 17:47:11      wilkerlucio </span><span>Gary did a great job making generative testing to check if the custom parser conforms with the platform regex parser, check this test: </span><a href="https://github.com/gfredericks/test.chuck/blob/master/test/com/gfredericks/test/chuck/regexes_test.clj#L117-L119">https://github.com/gfredericks/test.chuck/blob/master/test/com/gfredericks/test/chuck/regexes_test.clj#L117-L119</a></div><div data-t="wilkerlucio it generates random regexs and try to parse it with custom and native regex parsers, and they have to conform (all fail or all pass)"><span class="u" id="1496771258.803432">2017:06:06 17:47:38      wilkerlucio </span><span>it generates random regexs and try to parse it with custom and native regex parsers, and they have to conform (all fail or all pass)</span></div><div data-t="wilkerlucio it&apos;s just very hard to get the grammar to work exactly like the native one, with all quirks dealt with"><span class="u" id="1496771283.812542">2017:06:06 17:48:03      wilkerlucio </span><span>it&apos;s just very hard to get the grammar to work exactly like the native one, with all quirks dealt with</span></div><div data-t="fabrao Hello all, how can I make something like
 (def parser
  (insta/parser &quot;regra = &lt;&apos;filtro&apos;&gt; &lt;ws&gt; elemento+
                elemento = operador &lt;ws&gt; operando
                operador = (&apos;origem&apos;)
                operando = #&apos;[a-zA-Z0-9\\-]([0-9a-zA-Z\\-]*)&apos;
                ws = #&apos;\\s+&apos;&quot;))
(parser &quot;filtro 
        origem 001-ARTICO 
        origem 011-BALDACCI&quot;)

  what´s wrong?"><span class="u" id="1498017749.860414">2017:06:21 04:02:29           fabrao </span><span>Hello all, how can I make something like
</span><pre>(def parser
  (insta/parser &quot;regra = &lt;&apos;filtro&apos;&gt; &lt;ws&gt; elemento+
                elemento = operador &lt;ws&gt; operando
                operador = (&apos;origem&apos;)
                operando = #&apos;[a-zA-Z0-9\\-]([0-9a-zA-Z\\-]*)&apos;
                ws = #&apos;\\s+&apos;&quot;))
(parser &quot;filtro 
        origem 001-ARTICO 
        origem 011-BALDACCI&quot;)

</pre><span> what´s wrong?</span></div><div data-t="gfredericks @fabrao looks like the grammar doesn&apos;t allow whitespace in between  elemento s"><span class="u" id="1498043493.584876">2017:06:21 11:11:33      gfredericks </span><span>@fabrao looks like the grammar doesn&apos;t allow whitespace in between </span><code>elemento</code><span>s</span></div><div data-t="aengelberg ^"><span class="u" id="1498077931.746659">2017:06:21 20:45:31       aengelberg </span><span>^</span></div><div data-t="wistb test"><span class="u" id="1498264911.284184">2017:06:24 00:41:51            wistb </span><span>test</span></div><div data-t="wistb hi, beginner question."><span class="u" id="1498264932.285679">2017:06:24 00:42:12            wistb </span><span>hi, beginner question.</span></div><div data-t="wistb (def abc-parser
  (insta/parser ( http://clojure.java.io/resource  &quot;grammars/abc.abnf&quot;)
                :input-format :abnf
                :trace true
                :output-format :enlive))
                ;;:auto-whitespace whitespace))"><span class="u" id="1498264938.286171">2017:06:24 00:42:18            wistb </span><span>(def abc-parser
  (insta/parser (</span><a href="http://clojure.java.io/resource">http://clojure.java.io/resource</a><span> &quot;grammars/abc.abnf&quot;)
                :input-format :abnf
                :trace true
                :output-format :enlive))
                ;;:auto-whitespace whitespace))</span></div><div data-t="wistb if I enable the whitespace option , I am getting a copile error when I run &apos;lein run&apos;."><span class="u" id="1498264977.288645">2017:06:24 00:42:57            wistb </span><span>if I enable the whitespace option , I am getting a copile error when I run &apos;lein run&apos;.</span></div><div data-t="wistb like this :"><span class="u" id="1498264997.290031">2017:06:24 00:43:17            wistb </span><span>like this :</span></div><div data-t="wistb (def abc-parser
  (insta/parser ( http://clojure.java.io/resource  &quot;grammars/abc.abnf&quot;)
                :input-format :abnf
                :trace true
                :output-format :enlive
                :auto-whitespace whitespace))"><span class="u" id="1498264998.290122">2017:06:24 00:43:18            wistb </span><span>(def abc-parser
  (insta/parser (</span><a href="http://clojure.java.io/resource">http://clojure.java.io/resource</a><span> &quot;grammars/abc.abnf&quot;)
                :input-format :abnf
                :trace true
                :output-format :enlive
                :auto-whitespace whitespace))</span></div><div data-t="wistb same problem if I used :auto-whitespace :standard"><span class="u" id="1498265037.292647">2017:06:24 00:43:57            wistb </span><span>same problem if I used :auto-whitespace :standard</span></div><div data-t="wistb Caused by: java.lang.IllegalArgumentException: No matching clause: :char
	at instaparse.combinators_source$auto_whitespace_parser.invokeStatic(combinators_source.clj:163)
	at instaparse.combinators_source$auto_whitespace_parser.invoke(combinators_source.clj:162)
	at instaparse.combinators_source$auto_whitespace$iter__426__430$fn__431.invoke(combinators_source.clj:184)"><span class="u" id="1498265195.303653">2017:06:24 00:46:35            wistb </span><span>Caused by: java.lang.IllegalArgumentException: No matching clause: :char
	at instaparse.combinators_source$auto_whitespace_parser.invokeStatic(combinators_source.clj:163)
	at instaparse.combinators_source$auto_whitespace_parser.invoke(combinators_source.clj:162)
	at instaparse.combinators_source$auto_whitespace$iter__426__430$fn__431.invoke(combinators_source.clj:184)</span></div><div data-t="matan With instaparse, how do you elegantly match any sequence of characters up until a specific sequence of characters?"><span class="u" id="1499247865.080389">2017:07:05 09:44:25            matan </span><span>With instaparse, how do you elegantly match any sequence of characters up until a specific sequence of characters?</span></div><div data-t="matan Currently I do that in a cumbersome way, given the impedence mismatch between grammars and regular expressions:

 WrappedLabel = UnderscorePair Word UnderscorePair
UnderscorePair = &quot;__&quot;
Word = #&quot;.+(?=__)&quot; (* a valid word is hereby contrained to anything that does not include an UnderScorePair *)
"><span class="u" id="1499248474.292535">2017:07:05 09:54:34            matan </span><span>Currently I do that in a cumbersome way, given the impedence mismatch between grammars and regular expressions:

</span><pre>WrappedLabel = UnderscorePair Word UnderscorePair
UnderscorePair = &quot;__&quot;
Word = #&quot;.+(?=__)&quot; (* a valid word is hereby contrained to anything that does not include an UnderScorePair *)
</pre></div><div data-t="matan __  appears both as a grammar definition (`UnderscorePair`) as well as serving as a stop expression in the regex"><span class="u" id="1499248508.304396">2017:07:05 09:55:08            matan </span><code>__</code><span> appears both as a grammar definition (`UnderscorePair`) as well as serving as a stop expression in the regex</span></div><div data-t="matan 🤔  I am curious in case there&apos;s a solution I&apos;ve not thought of"><span class="u" id="1499248562.323420">2017:07:05 09:56:02            matan </span><b>🤔</b><span> I am curious in case there&apos;s a solution I&apos;ve not thought of</span></div><div data-t="matan The above is supposed to catch and parse anything of the form  __foo__ , so that  foo  can be extracted (as part of a larger parse the details of which are quite plain and uninteresting)"><span class="u" id="1499248626.345877">2017:07:05 09:57:06            matan </span><span>The above is supposed to catch and parse anything of the form </span><code>__foo__</code><span>, so that </span><code>foo</code><span> can be extracted (as part of a larger parse the details of which are quite plain and uninteresting)</span></div><div data-t="aengelberg @matan that&apos;s how I would do it. I&apos;m not aware of a more elegant or efficient solution, besides making the underscore pairs part of the regex."><span class="u" id="1499271211.388843">2017:07:05 16:13:31       aengelberg </span><span>@matan that&apos;s how I would do it. I&apos;m not aware of a more elegant or efficient solution, besides making the underscore pairs part of the regex.</span></div><div data-t="matan @aengelberg many thanks for the confirmation! of course, it stems from the difference between what regular expression language is and what grammars are, not from how instaparse works doesn&apos;t it  🙂  Would you agree to this?"><span class="u" id="1499360473.035226">2017:07:06 17:01:13            matan </span><span>@aengelberg many thanks for the confirmation! of course, it stems from the difference between what regular expression language is and what grammars are, not from how instaparse works doesn&apos;t it </span><b>🙂</b><span> Would you agree to this?</span></div><div data-t="aengelberg You mean regexes’ greediness? I would say that’s an artifact of regexes’ supported use case not matching what Instaparse needs it to do. If regexes had a way to lazily emit multiple parse results of the same string, we could maybe use that to make regex non-terminals behave more intuitively."><span class="u" id="1499360746.181443">2017:07:06 17:05:46       aengelberg </span><span>You mean regexes’ greediness? I would say that’s an artifact of regexes’ supported use case not matching what Instaparse needs it to do. If regexes had a way to lazily emit multiple parse results of the same string, we could maybe use that to make regex non-terminals behave more intuitively.</span></div><div data-t="aengelberg e.g. if I match  #&quot;^a+&quot;  on  &quot;aaa&quot;  I’d like to see  &quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;"><span class="u" id="1499360927.278085">2017:07:06 17:08:47       aengelberg </span><span>e.g. if I match </span><code>#&quot;^a+&quot;</code><span> on </span><code>&quot;aaa&quot;</code><span> I’d like to see </span><code>&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;</code></div><div data-t="matan Yes, well, at a higher level, regular expressions and grammars generate disparate automatons, whereas what you mention is one difference in the detail thereof (the most relevant one). This relates to two area I&apos;m lately looking at ― fuzzy parsing and scannerless parsing"><span class="u" id="1499361015.323480">2017:07:06 17:10:15            matan </span><span>Yes, well, at a higher level, regular expressions and grammars generate disparate automatons, whereas what you mention is one difference in the detail thereof (the most relevant one). This relates to two area I&apos;m lately looking at ― fuzzy parsing and scannerless parsing</span></div><div data-t="matan As to regex, have you ever used something like this?
 https://stackoverflow.com/questions/5616822/python-regex-find-all-overlapping-matches"><span class="u" id="1499361047.340146">2017:07:06 17:10:47            matan </span><span>As to regex, have you ever used something like this?
</span><a href="https://stackoverflow.com/questions/5616822/python-regex-find-all-overlapping-matches">https://stackoverflow.com/questions/5616822/python-regex-find-all-overlapping-matches</a></div><div data-t="matan Oh, not really, ignore that last one"><span class="u" id="1499361104.369659">2017:07:06 17:11:44            matan </span><span>Oh, not really, ignore that last one</span></div><div data-t="aengelberg That’s returning one match for each of a variety of starting indexes, which is not quite what I want"><span class="u" id="1499361137.387099">2017:07:06 17:12:17       aengelberg </span><span>That’s returning one match for each of a variety of starting indexes, which is not quite what I want</span></div><div data-t="matan Yes, again, ignore that"><span class="u" id="1499361156.396673">2017:07:06 17:12:36            matan </span><span>Yes, again, ignore that</span></div><div data-t="aengelberg You could theoretically do  (for [i (range (count s))] (re-match re (subs s 0 i)))"><span class="u" id="1499361188.413012">2017:07:06 17:13:08       aengelberg </span><span>You could theoretically do </span><code>(for [i (range (count s))] (re-match re (subs s 0 i)))</code></div><div data-t="aengelberg but that is super slow and might not actually work depending on the regex"><span class="u" id="1499361203.421224">2017:07:06 17:13:23       aengelberg </span><span>but that is super slow and might not actually work depending on the regex</span></div><div data-t="aengelberg the automaton structure of regexes is simply not designed to (efficiently) reason about the set of all possible matches for one string, using backtracking and laziness"><span class="u" id="1499361322.483776">2017:07:06 17:15:22       aengelberg </span><span>the automaton structure of regexes is simply not designed to (efficiently) reason about the set of all possible matches for one string, using backtracking and laziness</span></div><div data-t="aengelberg actually maybe if you compile a NDFA"><span class="u" id="1499361353.500052">2017:07:06 17:15:53       aengelberg </span><span>actually maybe if you compile a NDFA</span></div><div data-t="aengelberg then run it through one character at a time"><span class="u" id="1499361362.504707">2017:07:06 17:16:02       aengelberg </span><span>then run it through one character at a time</span></div><div data-t="aengelberg and mark every time you are in a success state"><span class="u" id="1499361416.532679">2017:07:06 17:16:56       aengelberg </span><span>and mark every time you are in a success state</span></div><div data-t="matan The interaction of a grammar with the need to account for syntactic categories (a.k.a variables, and/or non-terminals) that translate to non-finite sets of productions is very interesting. Right now, we typically &quot;escape&quot; to regular expressions for that. Of course, this goes beyond the scope of my original question with its particular silly use case."><span class="u" id="1499361903.793104">2017:07:06 17:25:03            matan </span><span>The interaction of a grammar with the need to account for syntactic categories (a.k.a variables, and/or non-terminals) that translate to non-finite sets of productions is very interesting. Right now, we typically &quot;escape&quot; to regular expressions for that. Of course, this goes beyond the scope of my original question with its particular silly use case.</span></div><div data-t="aengelberg In this case, the set of productions is not infinite; for the current index  i , all I really need to know is, the set of indexes  j \in [0,N)  such that  s[i:j]  is a complete parse according to the regex."><span class="u" id="1499362031.863939">2017:07:06 17:27:11       aengelberg </span><span>In this case, the set of productions is not infinite; for the current index </span><code>i</code><span>, all I really need to know is, the set of indexes </span><code>j \in [0,N)</code><span> such that </span><code>s[i:j]</code><span> is a complete parse according to the regex.</span></div><div data-t="matan Right, obviously, when looking at a specific input text (or string)."><span class="u" id="1499362162.938677">2017:07:06 17:29:22            matan </span><span>Right, obviously, when looking at a specific input text (or string).</span></div><div data-t="matan But in the general sense, I also meant to say that we use regular expressions for where we want to stipulate a non-finite set, whereas a plain CFG doesn&apos;t provide (IIRC) that kind of support, which is why we use regex along with it. I have to refresh and brush up more on formal languages though, maybe what I just said is totally incorrect, or just sufficiently inaccurate to be incorrect."><span class="u" id="1499362333.034978">2017:07:06 17:32:13            matan </span><span>But in the general sense, I also meant to say that we use regular expressions for where we want to stipulate a non-finite set, whereas a plain CFG doesn&apos;t provide (IIRC) that kind of support, which is why we use regex along with it. I have to refresh and brush up more on formal languages though, maybe what I just said is totally incorrect, or just sufficiently inaccurate to be incorrect.</span></div><div data-t="mrchance Hi! In Instaparse, how do I specify operator precedence... I tried ordered choice, but it doesn&apos;t do what I want. Simple example:
 (def tp (insta/parser &quot;
s = expression
&lt;expression&gt; = binop / integer
integer = #&apos;[0-9]+&apos;
&lt;binop&gt; = times / plus
times = expression &lt;&apos;*&apos;&gt; expression
plus = expression &lt;&apos;+&apos;&gt; expression&quot;
                      :auto-whitespace whitespace))

parser&gt; (tp &quot;5 + 3 * 7&quot;)
[:s [:times [:plus [:integer &quot;5&quot;] [:integer &quot;3&quot;]] [:integer &quot;7&quot;]]]
 
I have seen solutions that distinguish between add-expression and mul-expression, but that doesn&apos;t scale very well for more operators"><span class="u" id="1499701941.468899">2017:07:10 15:52:21         mrchance </span><span>Hi! In Instaparse, how do I specify operator precedence... I tried ordered choice, but it doesn&apos;t do what I want. Simple example:
</span><pre>(def tp (insta/parser &quot;
s = expression
&lt;expression&gt; = binop / integer
integer = #&apos;[0-9]+&apos;
&lt;binop&gt; = times / plus
times = expression &lt;&apos;*&apos;&gt; expression
plus = expression &lt;&apos;+&apos;&gt; expression&quot;
                      :auto-whitespace whitespace))

parser&gt; (tp &quot;5 + 3 * 7&quot;)
[:s [:times [:plus [:integer &quot;5&quot;] [:integer &quot;3&quot;]] [:integer &quot;7&quot;]]]
</pre><span>
I have seen solutions that distinguish between add-expression and mul-expression, but that doesn&apos;t scale very well for more operators</span></div><div data-t="aengelberg Ordered choice only works when considering parses available at a given position, not when ranking this parse here over another parse over there."><span class="u" id="1499702062.542391">2017:07:10 15:54:22       aengelberg </span><span>Ordered choice only works when considering parses available at a given position, not when ranking this parse here over another parse over there.</span></div><div data-t="aengelberg So in your example, your  binop / integer  was making it try  5 + 3  before  5"><span class="u" id="1499702119.577682">2017:07:10 15:55:19       aengelberg </span><span>So in your example, your </span><code>binop / integer</code><span> was making it try </span><code>5 + 3</code><span> before </span><code>5</code></div><div data-t="mrchance ah, so I can fix it by making expression unordered? Or what&apos;s the best way?"><span class="u" id="1499703994.677508">2017:07:10 16:26:34         mrchance </span><span>ah, so I can fix it by making expression unordered? Or what&apos;s the best way?</span></div><div data-t="aengelberg I don&apos;t think ordered choice is the best tool for &quot;order of operations&quot;... I&apos;ll send you another example in a sec"><span class="u" id="1499704205.794685">2017:07:10 16:30:05       aengelberg </span><span>I don&apos;t think ordered choice is the best tool for &quot;order of operations&quot;... I&apos;ll send you another example in a sec</span></div><div data-t="mrchance Thanks!"><span class="u" id="1499704344.871799">2017:07:10 16:32:24         mrchance </span><span>Thanks!</span></div><div data-t="aengelberg @mrchance check out the arithmetic expr parser in  https://github.com/engelberg/instaparse#transforming-the-tree"><span class="u" id="1499704599.009990">2017:07:10 16:36:39       aengelberg </span><span>@mrchance check out the arithmetic expr parser in </span><a href="https://github.com/engelberg/instaparse#transforming-the-tree">https://github.com/engelberg/instaparse#transforming-the-tree</a></div><div data-t="mrchance Thanks, I&apos;ll check it out"><span class="u" id="1499704623.022937">2017:07:10 16:37:03         mrchance </span><span>Thanks, I&apos;ll check it out</span></div><div data-t="aengelberg notice how no ordered choice is necessary, because the grammar is structured so that the order of operations follows naturally"><span class="u" id="1499704648.036028">2017:07:10 16:37:28       aengelberg </span><span>notice how no ordered choice is necessary, because the grammar is structured so that the order of operations follows naturally</span></div><div data-t="mrchance hm, ok, but my impression is that would get unwieldy when there is more operators. I&apos;ll give it a try though, I don&apos;t have that many  😉"><span class="u" id="1499705696.594399">2017:07:10 16:54:56         mrchance </span><span>hm, ok, but my impression is that would get unwieldy when there is more operators. I&apos;ll give it a try though, I don&apos;t have that many </span><b>😉</b></div><div data-t="aengelberg perhaps. not sure."><span class="u" id="1499705733.614828">2017:07:10 16:55:33       aengelberg </span><span>perhaps. not sure.</span></div><div data-t="aengelberg Here’s a potentially more elegant way of expressing it (not sure if this actually works):
 expr = add-sub
add-sub = mul-div ((&apos;+&apos; | &apos;-&apos;) mul-div)*
mul-div = term ((&apos;*&apos; | &apos;/&apos;) term)*
term = number | &lt;&apos;(&apos;&gt; add-sub &lt;&apos;)&apos;&gt;
"><span class="u" id="1499705875.692308">2017:07:10 16:57:55       aengelberg </span><span>Here’s a potentially more elegant way of expressing it (not sure if this actually works):
</span><pre>expr = add-sub
add-sub = mul-div ((&apos;+&apos; | &apos;-&apos;) mul-div)*
mul-div = term ((&apos;*&apos; | &apos;/&apos;) term)*
term = number | &lt;&apos;(&apos;&gt; add-sub &lt;&apos;)&apos;&gt;
</pre></div><div data-t="mrchance hmm, wouldn&apos;t this disallow top level multiplication terms?"><span class="u" id="1499707964.832246">2017:07:10 17:32:44         mrchance </span><span>hmm, wouldn&apos;t this disallow top level multiplication terms?</span></div><div data-t="mrchance I am already wishing I had given my own language a lisp syntax  😉"><span class="u" id="1499708027.867084">2017:07:10 17:33:47         mrchance </span><span>I am already wishing I had given my own language a lisp syntax </span><b>😉</b></div><div data-t="aengelberg @mrchance no, it would end up as  [:expr [:add-sub [:mul-div &quot;1&quot; &quot;*&quot; &quot;2&quot;]]]"><span class="u" id="1499714556.433864">2017:07:10 19:22:36       aengelberg </span><span>@mrchance no, it would end up as </span><code>[:expr [:add-sub [:mul-div &quot;1&quot; &quot;*&quot; &quot;2&quot;]]]</code></div><div data-t="mrchance right  🙂  It worked, btw. For the Moment it&apos;s still quite manageable too. Thanks for the fast replies!"><span class="u" id="1499728146.226105">2017:07:10 23:09:06         mrchance </span><span>right </span><b>🙂</b><span> It worked, btw. For the Moment it&apos;s still quite manageable too. Thanks for the fast replies!</span></div><div data-t="fabrao Hello all, how to I parse any kind of char in this:  Groups: CN=THIAGO VITOR COSTA,OU=REPRESENTANTES,DC=DOM,DC=COM,DC=BR+OU=REPRESENTANTES,DC=DOM,DC=COM,DC=BR+CN=USUÃ¡RIOS DO DOMÃ­NIO,CN=USERS,DC=DOM,DC=COM,DC=BR+CN=GPO_REPRESENTANTES_CN,OU=GRUPOS,DC=DOM,DC=COM,DC=BR+CN=USUÃ¡RIOS,CN=BUILTIN,DC=DOM,DC=COM,DC=BR+CN=GPO_REPRESENTANTES,OU=GRUPOS,DC=DOM,DC=COM,DC=BR ? The Groups: is reserved and the rest is the capture information"><span class="u" id="1499880387.932298">2017:07:12 17:26:27           fabrao </span><span>Hello all, how to I parse any kind of char in this: </span><code>Groups: CN=THIAGO VITOR COSTA,OU=REPRESENTANTES,DC=DOM,DC=COM,DC=BR+OU=REPRESENTANTES,DC=DOM,DC=COM,DC=BR+CN=USUÃ¡RIOS DO DOMÃ­NIO,CN=USERS,DC=DOM,DC=COM,DC=BR+CN=GPO_REPRESENTANTES_CN,OU=GRUPOS,DC=DOM,DC=COM,DC=BR+CN=USUÃ¡RIOS,CN=BUILTIN,DC=DOM,DC=COM,DC=BR+CN=GPO_REPRESENTANTES,OU=GRUPOS,DC=DOM,DC=COM,DC=BR</code><span>? The Groups: is reserved and the rest is the capture information</span></div><div data-t="bbss I&apos;m trying to parse Google&apos;s protobuf with Instaparse, but I can&apos;t find a recent file with it&apos;s EBNF spec."><span class="u" id="1503031677.000131">2017:08:18 04:47:57             bbss </span><span>I&apos;m trying to parse Google&apos;s protobuf with Instaparse, but I can&apos;t find a recent file with it&apos;s EBNF spec.</span></div><div data-t="bbss https://developers.google.com/protocol-buffers/docs/reference/proto3-spec 
I&apos;ve copied all the bits from this site, but some lines are giving errors when I try to parse them."><span class="u" id="1503031705.000052">2017:08:18 04:48:25             bbss </span><a href="https://developers.google.com/protocol-buffers/docs/reference/proto3-spec">https://developers.google.com/protocol-buffers/docs/reference/proto3-spec</a><span>
I&apos;ve copied all the bits from this site, but some lines are giving errors when I try to parse them.</span></div><div data-t="bbss Is instaparse compatible with what they put in there? For example I see they use  =  where other files often seem to have  :: == ."><span class="u" id="1503031751.000152">2017:08:18 04:49:11             bbss </span><span>Is instaparse compatible with what they put in there? For example I see they use </span><code>=</code><span> where other files often seem to have </span><code>:: ==</code><span>.</span></div><div data-t="bbss Ah, I just noticed the escape sequence part of the readme, let me look into that."><span class="u" id="1503031919.000047">2017:08:18 04:51:59             bbss </span><span>Ah, I just noticed the escape sequence part of the readme, let me look into that.</span></div><div data-t="bbss ah I notice it&apos;s been discussed here before:
 https://clojurians-log.clojureverse.org/instaparse/2017-02-17.html"><span class="u" id="1503038164.000183">2017:08:18 06:36:04             bbss </span><span>ah I notice it&apos;s been discussed here before:
</span><a href="https://clojurians-log.clojureverse.org/instaparse/2017-02-17.html">https://clojurians-log.clojureverse.org/instaparse/2017-02-17.html</a></div><div data-t="bbss @frank did you perhaps end up succeeding parsing that spec? Can&apos;t find any more discussion in further dates on the clojureverse.."><span class="u" id="1503038362.000030">2017:08:18 06:39:22             bbss </span><span>@frank did you perhaps end up succeeding parsing that spec? Can&apos;t find any more discussion in further dates on the clojureverse..</span></div><div data-t="bbss Okay, great I got it to work with the comments there.
For any future visitors: 
 https://gist.github.com/bbss/153e050f44db294cf7af3afc9a2f9a10"><span class="u" id="1503040888.000188">2017:08:18 07:21:28             bbss </span><span>Okay, great I got it to work with the comments there.
For any future visitors: 
</span><a href="https://gist.github.com/bbss/153e050f44db294cf7af3afc9a2f9a10">https://gist.github.com/bbss/153e050f44db294cf7af3afc9a2f9a10</a></div><div data-t="frank sorry just seeing this now - I had to make changes to it"><span class="u" id="1503071123.000279">2017:08:18 15:45:23            frank </span><span>sorry just seeing this now - I had to make changes to it</span></div><div data-t="frank one thing that might need to be done is removing comments before feeding it into the parser (or adjusting the grammar to know about them)"><span class="u" id="1503071193.000121">2017:08:18 15:46:33            frank </span><span>one thing that might need to be done is removing comments before feeding it into the parser (or adjusting the grammar to know about them)</span></div><div data-t="bbss @frank no worries, figured it out. I hadn&apos;t really used context free grammar before, but after meddling with those files for a bit I might actually use them more often. It seems like an indispensable tool for a Lisp programmer really  🙂"><span class="u" id="1503118498.000037">2017:08:19 04:54:58             bbss </span><span>@frank no worries, figured it out. I hadn&apos;t really used context free grammar before, but after meddling with those files for a bit I might actually use them more often. It seems like an indispensable tool for a Lisp programmer really </span><b>🙂</b></div><div data-t="bbss and you&apos;re right, I actually wrote a function to remove the comments."><span class="u" id="1503118519.000024">2017:08:19 04:55:19             bbss </span><span>and you&apos;re right, I actually wrote a function to remove the comments.</span></div><div data-t="hlolli In clojurescript with defparser, Im guessing the regexes are read wrongly, with insta/parser I get in my willingly generated token error
 {:tag :regexp,
 :expecting #&quot;^[0-9]+\.?[0-9]*&quot;}
 
in same error via defparse
 {:tag :regexp,
 :expecting #&quot;^\/^[0-9]+\.?[0-9]*\/&quot;}
 
both originating from
 &lt;digit&gt; = #&apos;[0-9]+\\.?[0-9]*&apos;"><span class="u" id="1504124028.000077">2017:08:30 20:13:48           hlolli </span><span>In clojurescript with defparser, Im guessing the regexes are read wrongly, with insta/parser I get in my willingly generated token error
</span><pre>{:tag :regexp,
 :expecting #&quot;^[0-9]+\.?[0-9]*&quot;}
</pre><span>
in same error via defparse
</span><pre>{:tag :regexp,
 :expecting #&quot;^\/^[0-9]+\.?[0-9]*\/&quot;}
</pre><span>
both originating from
</span><code>&lt;digit&gt; = #&apos;[0-9]+\\.?[0-9]*&apos;</code></div><div data-t="hlolli my first question should be, does some other clojurescript user experience this, as Im running my forked version of Instaparse 1.4.7 running on lumo."><span class="u" id="1504124132.000271">2017:08:30 20:15:32           hlolli </span><span>my first question should be, does some other clojurescript user experience this, as Im running my forked version of Instaparse 1.4.7 running on lumo.</span></div><div data-t="aengelberg Instaparse is known to have some bugs on Lumo"><span class="u" id="1504124188.000137">2017:08:30 20:16:28       aengelberg </span><span>Instaparse is known to have some bugs on Lumo</span></div><div data-t="aengelberg because Lumo behaves weirdly with cljc files"><span class="u" id="1504124201.000073">2017:08:30 20:16:41       aengelberg </span><span>because Lumo behaves weirdly with cljc files</span></div><div data-t="hlolli yes, I know, I&apos;ve fixed those on my fork and it&apos;s effectively working fine, just this one error with regexes, so Im only guessing this is unrelated."><span class="u" id="1504124250.000102">2017:08:30 20:17:30           hlolli </span><span>yes, I know, I&apos;ve fixed those on my fork and it&apos;s effectively working fine, just this one error with regexes, so Im only guessing this is unrelated.</span></div><div data-t="aengelberg since  defparse  is evaluated at macro-time, not runtime, my guess is that Lumo trying to execute code on ClojureScript that was meant to be run on Clojure"><span class="u" id="1504124255.000515">2017:08:30 20:17:35       aengelberg </span><span>since </span><code>defparse</code><span> is evaluated at macro-time, not runtime, my guess is that Lumo trying to execute code on ClojureScript that was meant to be run on Clojure</span></div><div data-t="hlolli or related, then in the way you described  🙂"><span class="u" id="1504124306.000048">2017:08:30 20:18:26           hlolli </span><span>or related, then in the way you described </span><b>🙂</b></div><div data-t="aengelberg The  regexp  combinator in particular has special logic when run on ClojureScript  https://github.com/Engelberg/instaparse/blob/master/src/instaparse/combinators_source.cljc#L93"><span class="u" id="1504124313.000100">2017:08:30 20:18:33       aengelberg </span><span>The </span><code>regexp</code><span> combinator in particular has special logic when run on ClojureScript </span><a href="https://github.com/Engelberg/instaparse/blob/master/src/instaparse/combinators_source.cljc#L93">https://github.com/Engelberg/instaparse/blob/master/src/instaparse/combinators_source.cljc#L93</a></div><div data-t="aengelberg which might be why you&apos;re only running into this now"><span class="u" id="1504124318.000069">2017:08:30 20:18:38       aengelberg </span><span>which might be why you&apos;re only running into this now</span></div><div data-t="hlolli hmm, ok, I try removing this constraint to see what happens..."><span class="u" id="1504124378.000183">2017:08:30 20:19:38           hlolli </span><span>hmm, ok, I try removing this constraint to see what happens...</span></div><div data-t="aengelberg also maybe try not using  defparser  and see if that fixes it"><span class="u" id="1504124394.000273">2017:08:30 20:19:54       aengelberg </span><span>also maybe try not using </span><code>defparser</code><span> and see if that fixes it</span></div><div data-t="hlolli yes, that fixes it, I want to use defparser for the performance it brings, Im using the parser to evaluate musical expressions in realtime music application"><span class="u" id="1504124438.000250">2017:08:30 20:20:38           hlolli </span><span>yes, that fixes it, I want to use defparser for the performance it brings, Im using the parser to evaluate musical expressions in realtime music application</span></div><div data-t="aengelberg makes sense."><span class="u" id="1504124898.000398">2017:08:30 20:28:18       aengelberg </span><span>makes sense.</span></div><div data-t="aengelberg also that sounds cool, is your application similar to  https://github.com/alda-lang/alda  ?"><span class="u" id="1504124915.000515">2017:08:30 20:28:35       aengelberg </span><span>also that sounds cool, is your application similar to </span><a href="https://github.com/alda-lang/alda">https://github.com/alda-lang/alda</a><span> ?</span></div><div data-t="gfredericks The Adlaphone: a musical instrument for programmers"><span class="u" id="1504125495.000146">2017:08:30 20:38:15      gfredericks </span><span>The Adlaphone: a musical instrument for programmers</span></div><div data-t="hlolli only very partially similar to Alda, the use of parser is very limited, and only an extra feature Im implementing atm."><span class="u" id="1504125598.000160">2017:08:30 20:39:58           hlolli </span><span>only very partially similar to Alda, the use of parser is very limited, and only an extra feature Im implementing atm.</span></div><div data-t="hlolli more about native datatypes Im sending to Csound, audio processing language, and make simple repetitive patterns."><span class="u" id="1504125673.000665">2017:08:30 20:41:13           hlolli </span><span>more about native datatypes Im sending to Csound, audio processing language, and make simple repetitive patterns.</span></div><div data-t="hlolli loud thinking, I notice that the function regex gets called twice by defparser but once on parse, the second time the input is  &quot;/^[0-9]+\.?[0-9]*/&quot;  and returnes  #&quot;^\/^[0-9]+\.?[0-9]*\/&quot;"><span class="u" id="1504126474.000055">2017:08:30 20:54:34           hlolli </span><span>loud thinking, I notice that the function regex gets called twice by defparser but once on parse, the second time the input is </span><code>&quot;/^[0-9]+\.?[0-9]*/&quot;</code><span> and returnes </span><code>#&quot;^\/^[0-9]+\.?[0-9]*\/&quot;</code></div><div data-t="hlolli ah fixed it  🙂"><span class="u" id="1504126738.000586">2017:08:30 20:58:58           hlolli </span><span>ah fixed it </span><b>🙂</b></div><div data-t="hlolli in  defparse  macro I commented
 ;; Regexp terminals are handled differently in cljs
 ;; (= :regexp (:tag form))
 ;; `(merge (c/regexp ~(str (:regexp form)))
 ;;         ~(dissoc form :tag :regexp))
 
maybe I should test the standard cljs and see if this is also a problem there."><span class="u" id="1504126805.000018">2017:08:30 21:00:05           hlolli </span><span>in </span><code>defparse</code><span> macro I commented
</span><pre>;; Regexp terminals are handled differently in cljs
 ;; (= :regexp (:tag form))
 ;; `(merge (c/regexp ~(str (:regexp form)))
 ;;         ~(dissoc form :tag :regexp))
</pre><span>
maybe I should test the standard cljs and see if this is also a problem there.</span></div><div data-t="Empperi does someone happen to know if there is a ready tool to convert W3C EBNF declarations to format which instaparse understands?"><span class="u" id="1509542821.000384">2017:11:01 13:27:01          Empperi </span><span>does someone happen to know if there is a ready tool to convert W3C EBNF declarations to format which instaparse understands?</span></div><div data-t="Empperi specifically I’m looking for SPARQL ebnf declarations which I could feed into instaparse"><span class="u" id="1509542841.000008">2017:11:01 13:27:21          Empperi </span><span>specifically I’m looking for SPARQL ebnf declarations which I could feed into instaparse</span></div><div data-t="Empperi I would also accept an ANTLR -&gt; instaparse converter"><span class="u" id="1509543153.000404">2017:11:01 13:32:33          Empperi </span><span>I would also accept an ANTLR -&gt; instaparse converter</span></div><div data-t="novel instaparse understands the SPARQL grammar from w3c. you just have to adapt the production rules for the terminals so that instaparse will detect them as regexes. See for instance  https://github.com/mladvladimir/sparqlom/blob/master/resources/sparql.ebnf"><span class="u" id="1509552429.000222">2017:11:01 16:07:09            novel </span><span>instaparse understands the SPARQL grammar from w3c. you just have to adapt the production rules for the terminals so that instaparse will detect them as regexes. See for instance </span><a href="https://github.com/mladvladimir/sparqlom/blob/master/resources/sparql.ebnf">https://github.com/mladvladimir/sparqlom/blob/master/resources/sparql.ebnf</a></div><div data-t="Empperi yeah, I know it is almost the same. What you just linked looks like actually a ready made file which instaparse should be able to digest"><span class="u" id="1509623299.000118">2017:11:02 11:48:19          Empperi </span><span>yeah, I know it is almost the same. What you just linked looks like actually a ready made file which instaparse should be able to digest</span></div><div data-t="Empperi looks promising, need to test that out, thanks!  👍"><span class="u" id="1509623313.000093">2017:11:02 11:48:33          Empperi </span><span>looks promising, need to test that out, thanks! </span><b>👍</b></div><div data-t="Empperi indeed, instaparse happily consumed that file. My first SPARQL query did not get through the parser though but it is much easier to proceed from here"><span class="u" id="1509623580.000103">2017:11:02 11:53:00          Empperi </span><span>indeed, instaparse happily consumed that file. My first SPARQL query did not get through the parser though but it is much easier to proceed from here</span></div><div data-t="tbrooke I am looking at a project that uses  https://nearley.js.org/  in javascript  which uses Early parsing — I did find an old Clojure repo that mentioned early parsing --- I am somewhat new to parsing and wondered if anyone was up on early parsing or whether I could do the same thing in Clojure with instaparse or another library - I don’t want to use javascript and I would like to rewrite the parser with Clojure Clojurescript"><span class="u" id="1510149424.000317">2017:11:08 13:57:04          tbrooke </span><span>I am looking at a project that uses </span><a href="https://nearley.js.org/">https://nearley.js.org/</a><span> in javascript  which uses Early parsing — I did find an old Clojure repo that mentioned early parsing --- I am somewhat new to parsing and wondered if anyone was up on early parsing or whether I could do the same thing in Clojure with instaparse or another library - I don’t want to use javascript and I would like to rewrite the parser with Clojure Clojurescript</span></div><div data-t="jeremys Hey guys, I am playing with instaparse and I have a problem contructucting a grammar."><span class="u" id="1511456117.000090">2017:11:23 16:55:17          jeremys </span><span>Hey guys, I am playing with instaparse and I have a problem contructucting a grammar.</span></div><div data-t="jeremys Here is what I am going for  (insta/defparser ex7
  &quot;
  doc = (text | tag)*
  text = #&apos;[^@]*&apos;
  tag = &apos;@&apos; #&apos;[a-z]*&apos; inner-text*
  inner-text = &apos;{&apos; #&apos;[^}]*&apos; &apos;}&apos;
  &quot;)

(ex7 &quot;some text @toto{inner text}&quot;)"><span class="u" id="1511456138.000016">2017:11:23 16:55:38          jeremys </span><span>Here is what I am going for </span><pre>(insta/defparser ex7
  &quot;
  doc = (text | tag)*
  text = #&apos;[^@]*&apos;
  tag = &apos;@&apos; #&apos;[a-z]*&apos; inner-text*
  inner-text = &apos;{&apos; #&apos;[^}]*&apos; &apos;}&apos;
  &quot;)

(ex7 &quot;some text @toto{inner text}&quot;)</pre></div><div data-t="jeremys The problem is the parser when parsing a  tag  rule won’t consider the  inner-text  rule giving me the parse  [:doc [:text &quot;some text &quot;] [:tag &quot;@&quot; &quot;toto&quot;] [:text &quot;{inner text}&quot;]]"><span class="u" id="1511456314.000190">2017:11:23 16:58:34          jeremys </span><span>The problem is the parser when parsing a </span><code>tag</code><span> rule won’t consider the </span><code>inner-text</code><span> rule giving me the parse </span><pre>[:doc [:text &quot;some text &quot;] [:tag &quot;@&quot; &quot;toto&quot;] [:text &quot;{inner text}&quot;]]</pre></div><div data-t="jeremys instead of the desired  [:doc [:text &quot;some text &quot;] [:tag &quot;@&quot; &quot;toto&quot; [:inner-text &quot;{&quot; &quot;inner text&quot; &quot;}&quot;]]]"><span class="u" id="1511456355.000407">2017:11:23 16:59:15          jeremys </span><span>instead of the desired </span><pre>[:doc [:text &quot;some text &quot;] [:tag &quot;@&quot; &quot;toto&quot; [:inner-text &quot;{&quot; &quot;inner text&quot; &quot;}&quot;]]]</pre></div><div data-t="jeremys Any Idea how I can modify the grammar to consider the  inner-text rule  before going back to the  text  one ?"><span class="u" id="1511456512.000152">2017:11:23 17:01:52          jeremys </span><span>Any Idea how I can modify the grammar to consider the </span><code>inner-text rule</code><span> before going back to the </span><code>text</code><span> one ?</span></div><div data-t="aengelberg @jeremys Maybe change  inner-text*  to  inner-text* !inner-text , to ensure that it parses as many inner-texts as it can."><span class="u" id="1511474837.000040">2017:11:23 22:07:17       aengelberg </span><span>@jeremys Maybe change </span><code>inner-text*</code><span> to </span><code>inner-text* !inner-text</code><span>, to ensure that it parses as many inner-texts as it can.</span></div><div data-t="jeremys @aengelberg Thx Alex I’ll try to use the lookahead, I haven’t played with that yet."><span class="u" id="1511479153.000098">2017:11:23 23:19:13          jeremys </span><span>@aengelberg Thx Alex I’ll try to use the lookahead, I haven’t played with that yet.</span></div><div data-t="jeremys @aengelberg Thx for the help, the negative lookahead work perfectly. I also started a thread on clojureverse with that question. You can find it here  https://clojureverse.org/t/need-a-bit-of-help-with-an-instaparse-grammar/965/4"><span class="u" id="1511528308.000271">2017:11:24 12:58:28          jeremys </span><span>@aengelberg Thx for the help, the negative lookahead work perfectly. I also started a thread on clojureverse with that question. You can find it here </span><a href="https://clojureverse.org/t/need-a-bit-of-help-with-an-instaparse-grammar/965/4">https://clojureverse.org/t/need-a-bit-of-help-with-an-instaparse-grammar/965/4</a></div><div data-t="mrchance hi, is there a possibility in instaparse to bind parse results? For example, when looking for a matching closing tag?"><span class="u" id="1512066231.000301">2017:11:30 18:23:51         mrchance </span><span>hi, is there a possibility in instaparse to bind parse results? For example, when looking for a matching closing tag?</span></div><div data-t="aengelberg @mrchance sadly no. I&apos;d recommend writing your parser so that it accepts any pair of tags (matching or not), and then separately do some validation to make sure the tag pairs are well formed."><span class="u" id="1512066858.000669">2017:11:30 18:34:18       aengelberg </span><span>@mrchance sadly no. I&apos;d recommend writing your parser so that it accepts any pair of tags (matching or not), and then separately do some validation to make sure the tag pairs are well formed.</span></div><div data-t="mrchance ok, thanks. Should be easy enough to do in the transform step"><span class="u" id="1512067348.000047">2017:11:30 18:42:28         mrchance </span><span>ok, thanks. Should be easy enough to do in the transform step</span></div><div data-t="Empperi hmm, I have a rather large EBNF that I’m using to initialize an instaparse parser in ClojureScript"><span class="u" id="1513158486.000324">2017:12:13 09:48:06          Empperi </span><span>hmm, I have a rather large EBNF that I’m using to initialize an instaparse parser in ClojureScript</span></div><div data-t="Empperi It works just fine but the problem is that the parser creation takes a long time and since it’s ClojureScript that causes the UI to freeze while it is being created"><span class="u" id="1513158518.000291">2017:12:13 09:48:38          Empperi </span><span>It works just fine but the problem is that the parser creation takes a long time and since it’s ClojureScript that causes the UI to freeze while it is being created</span></div><div data-t="Empperi I was wondering if there is any way to do this in a webworker and if anyone has tried to do that before"><span class="u" id="1513158541.000381">2017:12:13 09:49:01          Empperi </span><span>I was wondering if there is any way to do this in a webworker and if anyone has tried to do that before</span></div><div data-t="Empperi my initial feeling is that “no you cannot use webworkers” since they work with message passing and as such only Strings can be passed"><span class="u" id="1513158565.000083">2017:12:13 09:49:25          Empperi </span><span>my initial feeling is that “no you cannot use webworkers” since they work with message passing and as such only Strings can be passed</span></div><div data-t="Empperi ideas?"><span class="u" id="1513158633.000112">2017:12:13 09:50:33          Empperi </span><span>ideas?</span></div><div data-t="hlolli @niklas.collin are you using the defparser macro?"><span class="u" id="1513159528.000125">2017:12:13 10:05:28           hlolli </span><span>@niklas.collin are you using the defparser macro?</span></div><div data-t="Empperi no, I’m using  instaparse.core/parser"><span class="u" id="1513159553.000272">2017:12:13 10:05:53          Empperi </span><span>no, I’m using </span><code>instaparse.core/parser</code></div><div data-t="hlolli I wonder if you&apos;d be faster if you&apos;d be using the macro, then it precompiles a bit."><span class="u" id="1513159584.000252">2017:12:13 10:06:24           hlolli </span><span>I wonder if you&apos;d be faster if you&apos;d be using the macro, then it precompiles a bit.</span></div><div data-t="Empperi dunno, maybe"><span class="u" id="1513159594.000312">2017:12:13 10:06:34          Empperi </span><span>dunno, maybe</span></div><div data-t="Empperi I could try"><span class="u" id="1513159601.000532">2017:12:13 10:06:41          Empperi </span><span>I could try</span></div><div data-t="Empperi well, that’s what the  defparser  documentation in instaparse github page says that it should work better"><span class="u" id="1513159672.000189">2017:12:13 10:07:52          Empperi </span><span>well, that’s what the </span><code>defparser</code><span> documentation in instaparse github page says that it should work better</span></div><div data-t="Empperi thanks, will try that"><span class="u" id="1513159677.000064">2017:12:13 10:07:57          Empperi </span><span>thanks, will try that</span></div><div data-t="Empperi yeah, now performance is pretty much instant"><span class="u" id="1513160901.000320">2017:12:13 10:28:21          Empperi </span><span>yeah, now performance is pretty much instant</span></div><div data-t="Empperi cheers  🙂"><span class="u" id="1513160904.000496">2017:12:13 10:28:24          Empperi </span><span>cheers </span><b>🙂</b></div><div data-t="aengelberg @hlolli yep, that&apos;s exactly what it&apos;s meant for. @niklas.collin I&apos;m glad it served its purpose!"><span class="u" id="1513184675.000169">2017:12:13 17:04:35       aengelberg </span><span>@hlolli yep, that&apos;s exactly what it&apos;s meant for. @niklas.collin I&apos;m glad it served its purpose!</span></div><div data-t="mbjarland I&apos;m playing around with instaparse and for kicks and giggles I wrote a parser to parse some log files I have laying around"><span class="u" id="1513269088.000597">2017:12:14 16:31:28        mbjarland </span><span>I&apos;m playing around with instaparse and for kicks and giggles I wrote a parser to parse some log files I have laying around</span></div><div data-t="mbjarland is there a way to define a fixed width &quot;anything goes&quot; string in instaparse"><span class="u" id="1513269110.000334">2017:12:14 16:31:50        mbjarland </span><span>is there a way to define a fixed width &quot;anything goes&quot; string in instaparse</span></div><div data-t="mbjarland i.e. if I just want to gobble up a few characters into a tree node and don&apos;t care about the content there, is that possible?"><span class="u" id="1513269153.000731">2017:12:14 16:32:33        mbjarland </span><span>i.e. if I just want to gobble up a few characters into a tree node and don&apos;t care about the content there, is that possible?</span></div><div data-t="aengelberg Fixed width? Maybe  #&apos;.{N}&apos; ?"><span class="u" id="1513269156.000605">2017:12:14 16:32:36       aengelberg </span><span>Fixed width? Maybe </span><code>#&apos;.{N}&apos;</code><span>?</span></div><div data-t="mbjarland right, yes regex does the job but is probably not very performant for just &quot;take substring of 10 from where you are&quot;"><span class="u" id="1513269189.000338">2017:12:14 16:33:09        mbjarland </span><span>right, yes regex does the job but is probably not very performant for just &quot;take substring of 10 from where you are&quot;</span></div><div data-t="mbjarland ok, so regex is the way to go for this in instaparse?"><span class="u" id="1513269270.000018">2017:12:14 16:34:30        mbjarland </span><span>ok, so regex is the way to go for this in instaparse?</span></div><div data-t="aengelberg I think regex is the most performant way to grab a not-static set of characters"><span class="u" id="1513269301.000532">2017:12:14 16:35:01       aengelberg </span><span>I think regex is the most performant way to grab a not-static set of characters</span></div><div data-t="mbjarland : ) well I should probably mention that I think instaparse is excellent and by far the best parser lib I&apos;ve run across....so my intent was not to come here and critique it"><span class="u" id="1513269428.000382">2017:12:14 16:37:08        mbjarland </span><span>: ) well I should probably mention that I think instaparse is excellent and by far the best parser lib I&apos;ve run across....so my intent was not to come here and critique it</span></div><div data-t="aengelberg Thanks! And no worries, I was just answering your question from the perspective of what instaparse actually supports"><span class="u" id="1513269480.000011">2017:12:14 16:38:00       aengelberg </span><span>Thanks! And no worries, I was just answering your question from the perspective of what instaparse actually supports</span></div><div data-t="mbjarland that being said...if I parse 2G of log files (without instaparse) and compare the simplest regex match with  (subs line 10 20) , regex performace doesn&apos;t exactly shine"><span class="u" id="1513269503.000194">2017:12:14 16:38:23        mbjarland </span><span>that being said...if I parse 2G of log files (without instaparse) and compare the simplest regex match with </span><code>(subs line 10 20)</code><span>, regex performace doesn&apos;t exactly shine</span></div><div data-t="aengelberg But I see your point that if it theoretically supported a dedicated &quot;substring&quot; combinator, that would be faster"><span class="u" id="1513269512.000419">2017:12:14 16:38:32       aengelberg </span><span>But I see your point that if it theoretically supported a dedicated &quot;substring&quot; combinator, that would be faster</span></div><div data-t="mbjarland anyway, figured I would ask, but regex does indeed do the job and perhaps what I&apos;m doing with this parser is a bit of an edge case"><span class="u" id="1513269599.000897">2017:12:14 16:39:59        mbjarland </span><span>anyway, figured I would ask, but regex does indeed do the job and perhaps what I&apos;m doing with this parser is a bit of an edge case</span></div><div data-t="aengelberg Maybe we should support &quot;custom combinators&quot; so people like you with special use cases can write their own more performant specialized versions"><span class="u" id="1513269625.000280">2017:12:14 16:40:25       aengelberg </span><span>Maybe we should support &quot;custom combinators&quot; so people like you with special use cases can write their own more performant specialized versions</span></div><div data-t="mbjarland that would be awesome"><span class="u" id="1513269642.000280">2017:12:14 16:40:42        mbjarland </span><span>that would be awesome</span></div><div data-t="mbjarland you would have to add some kind of extension point to the instaparse bnf syntax I guess"><span class="u" id="1513269767.000926">2017:12:14 16:42:47        mbjarland </span><span>you would have to add some kind of extension point to the instaparse bnf syntax I guess</span></div><div data-t="aengelberg Maybe, or we don&apos;t allow extensions to the EBNF syntax and just let people make custom combinators for the combinator syntax"><span class="u" id="1513270025.000180">2017:12:14 16:47:05       aengelberg </span><span>Maybe, or we don&apos;t allow extensions to the EBNF syntax and just let people make custom combinators for the combinator syntax</span></div><div data-t="mbjarland ah, ok, hadn&apos;t grokked the combinators syntax until now"><span class="u" id="1513270249.000614">2017:12:14 16:50:49        mbjarland </span><span>ah, ok, hadn&apos;t grokked the combinators syntax until now</span></div><div data-t="mbjarland right now I&apos;m considering writing my own mini language for this log parsing, I could use instaparse to parse that language and then do custom, optimized parsing based on the format specification tree coming out from instaparse...so still useful"><span class="u" id="1513270583.000245">2017:12:14 16:56:23        mbjarland </span><span>right now I&apos;m considering writing my own mini language for this log parsing, I could use instaparse to parse that language and then do custom, optimized parsing based on the format specification tree coming out from instaparse...so still useful</span></div><div data-t="mbjarland hmm, how come I need to double escape the not-inclusive rule in the following grammmar: 
 (def my-p 
  (instaparse.core/parser 
    &quot;spec = (field-spec &lt;&apos; &apos;?&gt;)+
     field-spec = &lt;&apos;[&apos;&gt;name &apos; &apos;* &lt;&apos;:&apos;&gt; &apos; &apos;* (width | not-inclusive | not-exclusive | rest)&lt;&apos;]&apos;&gt;
     name = #&apos;[^:]+&apos;
     width = &lt;&apos;{&apos;&gt; #&apos;\\d+&apos; &lt;&apos;}&apos;&gt;
     not-inclusive = &lt;&apos;\\\\&apos;&gt; #&apos;.&apos;
     not-exclusive = &lt;&apos;/&apos;&gt; #&apos;.&apos;
     rest = &apos;*&apos;    
    &quot;))
"><span class="u" id="1513272095.000419">2017:12:14 17:21:35        mbjarland </span><span>hmm, how come I need to double escape the not-inclusive rule in the following grammmar: 
</span><pre>(def my-p 
  (instaparse.core/parser 
    &quot;spec = (field-spec &lt;&apos; &apos;?&gt;)+
     field-spec = &lt;&apos;[&apos;&gt;name &apos; &apos;* &lt;&apos;:&apos;&gt; &apos; &apos;* (width | not-inclusive | not-exclusive | rest)&lt;&apos;]&apos;&gt;
     name = #&apos;[^:]+&apos;
     width = &lt;&apos;{&apos;&gt; #&apos;\\d+&apos; &lt;&apos;}&apos;&gt;
     not-inclusive = &lt;&apos;\\\\&apos;&gt; #&apos;.&apos;
     not-exclusive = &lt;&apos;/&apos;&gt; #&apos;.&apos;
     rest = &apos;*&apos;    
    &quot;))
</pre></div><div data-t="aengelberg you mean the  &apos;\\\\&apos; ?"><span class="u" id="1513272145.000423">2017:12:14 17:22:25       aengelberg </span><span>you mean the </span><code>&apos;\\\\&apos;</code><span>?</span></div><div data-t="mbjarland yeah"><span class="u" id="1513272147.000648">2017:12:14 17:22:27        mbjarland </span><span>yeah</span></div><div data-t="mbjarland shouldn&apos;t two have been enough?"><span class="u" id="1513272161.000042">2017:12:14 17:22:41        mbjarland </span><span>shouldn&apos;t two have been enough?</span></div><div data-t="aengelberg because
1) you need to tell Clojure that you aren&apos;t escaping a character within a string
2) you need to tell Instaparse that you aren&apos;t escaping a character within a string combinator"><span class="u" id="1513272189.000479">2017:12:14 17:23:09       aengelberg </span><span>because
1) you need to tell Clojure that you aren&apos;t escaping a character within a string
2) you need to tell Instaparse that you aren&apos;t escaping a character within a string combinator</span></div><div data-t="mbjarland ok, missed point 2 there"><span class="u" id="1513272214.000533">2017:12:14 17:23:34        mbjarland </span><span>ok, missed point 2 there</span></div><div data-t="Empperi is there some way in instaparse to ask for all possible grammar elements at certain point of the parse tree?"><span class="u" id="1513329003.000190">2017:12:15 09:10:03          Empperi </span><span>is there some way in instaparse to ask for all possible grammar elements at certain point of the parse tree?</span></div><div data-t="Empperi meaning, I have parse result, I take a specific point in that parse tree and the would get a list of parse elements that could go there"><span class="u" id="1513329037.000187">2017:12:15 09:10:37          Empperi </span><span>meaning, I have parse result, I take a specific point in that parse tree and the would get a list of parse elements that could go there</span></div><div data-t="Empperi I could theoretically write an EBNF analyzer to do just this but don’t feel like it unless I have to"><span class="u" id="1513329059.000451">2017:12:15 09:10:59          Empperi </span><span>I could theoretically write an EBNF analyzer to do just this but don’t feel like it unless I have to</span></div><div data-t="Empperi since I think instaparse already does this somewhere under the hood and has the necessary information"><span class="u" id="1513329072.000215">2017:12:15 09:11:12          Empperi </span><span>since I think instaparse already does this somewhere under the hood and has the necessary information</span></div><div data-t="Empperi hmm, there is  instaparse.cfg/ebnf , need look at it and if it would provide the necessary information"><span class="u" id="1513329594.000105">2017:12:15 09:19:54          Empperi </span><span>hmm, there is </span><code>instaparse.cfg/ebnf</code><span>, need look at it and if it would provide the necessary information</span></div><div data-t="Empperi actually it looks like it just might"><span class="u" id="1513329704.000088">2017:12:15 09:21:44          Empperi </span><span>actually it looks like it just might</span></div><div data-t="aengelberg @niklas.collin not sure what you&apos;re asking. what would be an example of using this functionality?"><span class="u" id="1513357178.000066">2017:12:15 16:59:38       aengelberg </span><span>@niklas.collin not sure what you&apos;re asking. what would be an example of using this functionality?</span></div><div data-t="Empperi Autocomplete suggestions for code editor"><span class="u" id="1513357271.000107">2017:12:15 17:01:11          Empperi </span><span>Autocomplete suggestions for code editor</span></div><div data-t="Empperi And the result from cfg/ebnf looks ok usable"><span class="u" id="1513357314.000298">2017:12:15 17:01:54          Empperi </span><span>And the result from cfg/ebnf looks ok usable</span></div><div data-t="aengelberg There have been a few discussions about generating data for a parser, or listing possible inputs to a parser"><span class="u" id="1513371973.000379">2017:12:15 21:06:13       aengelberg </span><span>There have been a few discussions about generating data for a parser, or listing possible inputs to a parser</span></div><div data-t="aengelberg Not sure the best path to exposing that"><span class="u" id="1513371979.000069">2017:12:15 21:06:19       aengelberg </span><span>Not sure the best path to exposing that</span></div><div data-t="aengelberg are you sure  ebnf  is what you want? That just creates a combinator based on an EBNF spec, it doesn&apos;t generate a list of things that could go there"><span class="u" id="1513372021.000480">2017:12:15 21:07:01       aengelberg </span><span>are you sure </span><code>ebnf</code><span> is what you want? That just creates a combinator based on an EBNF spec, it doesn&apos;t generate a list of things that could go there</span></div><div data-t="borkdude Hello. Why is my InstaParser so slow? 850ms vs 8ms hand-written Clojure:
 https://github.com/borkdude/aoc2017/blob/master/src/day16.clj#L119"><span class="u" id="1513446177.000041">2017:12:16 17:42:57         borkdude </span><span>Hello. Why is my InstaParser so slow? 850ms vs 8ms hand-written Clojure:
</span><a href="https://github.com/borkdude/aoc2017/blob/master/src/day16.clj#L119">https://github.com/borkdude/aoc2017/blob/master/src/day16.clj#L119</a></div><div data-t="borkdude Maybe it’s my grammar, but I don’t see it."><span class="u" id="1513446189.000064">2017:12:16 17:43:09         borkdude </span><span>Maybe it’s my grammar, but I don’t see it.</span></div><div data-t="aengelberg How big is the input?"><span class="u" id="1513446192.000109">2017:12:16 17:43:12       aengelberg </span><span>How big is the input?</span></div><div data-t="borkdude The input is this:  https://github.com/borkdude/aoc2017/blob/master/resources/day16.txt"><span class="u" id="1513446207.000011">2017:12:16 17:43:27         borkdude </span><span>The input is this: </span><a href="https://github.com/borkdude/aoc2017/blob/master/resources/day16.txt">https://github.com/borkdude/aoc2017/blob/master/resources/day16.txt</a></div><div data-t="borkdude Here’s the grammar:  https://github.com/borkdude/aoc2017/blob/master/src/day16.clj#L17"><span class="u" id="1513446275.000004">2017:12:16 17:44:35         borkdude </span><span>Here’s the grammar: </span><a href="https://github.com/borkdude/aoc2017/blob/master/src/day16.clj#L17">https://github.com/borkdude/aoc2017/blob/master/src/day16.clj#L17</a></div><div data-t="aengelberg I mean, you&apos;re basically generating one string per character in a 40kb file. I&apos;m not surprised it&apos;s slow."><span class="u" id="1513446514.000080">2017:12:16 17:48:34       aengelberg </span><span>I mean, you&apos;re basically generating one string per character in a 40kb file. I&apos;m not surprised it&apos;s slow.</span></div><div data-t="aengelberg And wrapping with vectors, etc"><span class="u" id="1513446531.000067">2017:12:16 17:48:51       aengelberg </span><span>And wrapping with vectors, etc</span></div><div data-t="borkdude That’s fair, but even without wrapping the arguments I get a similar time"><span class="u" id="1513446631.000086">2017:12:16 17:50:31         borkdude </span><span>That’s fair, but even without wrapping the arguments I get a similar time</span></div><div data-t="borkdude I had that before, but I wanted to transform the arguments to ints, that’s why I wrapped them later"><span class="u" id="1513446648.000041">2017:12:16 17:50:48         borkdude </span><span>I had that before, but I wanted to transform the arguments to ints, that’s why I wrapped them later</span></div><div data-t="aengelberg Hmm yeah"><span class="u" id="1513446693.000068">2017:12:16 17:51:33       aengelberg </span><span>Hmm yeah</span></div><div data-t="borkdude I mean, it’s not really a problem, but just curious why or if I made a mistake in my grammar"><span class="u" id="1513446801.000093">2017:12:16 17:53:21         borkdude </span><span>I mean, it’s not really a problem, but just curious why or if I made a mistake in my grammar</span></div><div data-t="aengelberg I don&apos;t think you made a mistake like an ambiguity issue or anything"><span class="u" id="1513446835.000100">2017:12:16 17:53:55       aengelberg </span><span>I don&apos;t think you made a mistake like an ambiguity issue or anything</span></div><div data-t="aengelberg It&apos;s just really exercising the parser&apos;s dataflow overhead"><span class="u" id="1513446863.000039">2017:12:16 17:54:23       aengelberg </span><span>It&apos;s just really exercising the parser&apos;s dataflow overhead</span></div><div data-t="aengelberg I saw similar issues when trying to perf-tune @dave&apos;s Alda parser a while ago"><span class="u" id="1513446915.000048">2017:12:16 17:55:15       aengelberg </span><span>I saw similar issues when trying to perf-tune @dave&apos;s Alda parser a while ago</span></div><div data-t="aengelberg Because his rules were like &quot;if you see this single character, parse this other single character&quot;"><span class="u" id="1513446969.000061">2017:12:16 17:56:09       aengelberg </span><span>Because his rules were like &quot;if you see this single character, parse this other single character&quot;</span></div><div data-t="aengelberg Instaparse does a lot of bookkeeping during a parse to make sure it magically works with weirdly recursive grammars, so for super low level parsers like this it doesn&apos;t exactly shine"><span class="u" id="1513447061.000023">2017:12:16 17:57:41       aengelberg </span><span>Instaparse does a lot of bookkeeping during a parse to make sure it magically works with weirdly recursive grammars, so for super low level parsers like this it doesn&apos;t exactly shine</span></div><div data-t="borkdude (def parse2
  (insta/parser
   &quot;&lt;INPUT&gt;       = (INSTRUCTION &lt;&apos;,&apos;&gt;)+ INSTRUCTION 
    &lt;INSTRUCTION&gt; = SPIN | EXCHANGE | PARTNER
    SPIN          = &lt;&apos;s&apos;&gt; POSITION
    EXCHANGE      = &lt;&apos;x&apos;&gt; POSITION &lt;&apos;/&apos;&gt; POSITION
    PARTNER       = &lt;&apos;p&apos;&gt; PROGRAM  &lt;&apos;/&apos;&gt; PROGRAM
    &lt;POSITION&gt;    = #&apos;\\d\\d?&apos;
    &lt;PROGRAM&gt;     = #&apos;[a-p]&apos;&quot;))
 
No nesting of position and program, 800ms"><span class="u" id="1513447077.000037">2017:12:16 17:57:57         borkdude </span><pre>(def parse2
  (insta/parser
   &quot;&lt;INPUT&gt;       = (INSTRUCTION &lt;&apos;,&apos;&gt;)+ INSTRUCTION 
    &lt;INSTRUCTION&gt; = SPIN | EXCHANGE | PARTNER
    SPIN          = &lt;&apos;s&apos;&gt; POSITION
    EXCHANGE      = &lt;&apos;x&apos;&gt; POSITION &lt;&apos;/&apos;&gt; POSITION
    PARTNER       = &lt;&apos;p&apos;&gt; PROGRAM  &lt;&apos;/&apos;&gt; PROGRAM
    &lt;POSITION&gt;    = #&apos;\\d\\d?&apos;
    &lt;PROGRAM&gt;     = #&apos;[a-p]&apos;&quot;))
</pre><span>
No nesting of position and program, 800ms</span></div><div data-t="borkdude ok"><span class="u" id="1513447095.000060">2017:12:16 17:58:15         borkdude </span><span>ok</span></div><div data-t="aengelberg Just curious, does anything improve if you change the first rule to  INSTRUCTION (&lt;&apos;,&apos;&gt; INSTRUCTION)* ?"><span class="u" id="1513447193.000114">2017:12:16 17:59:53       aengelberg </span><span>Just curious, does anything improve if you change the first rule to </span><code>INSTRUCTION (&lt;&apos;,&apos;&gt; INSTRUCTION)*</code><span>?</span></div><div data-t="borkdude I wondered about that rule as well. Quickbenching…"><span class="u" id="1513447485.000106">2017:12:16 18:04:45         borkdude </span><span>I wondered about that rule as well. Quickbenching…</span></div><div data-t="borkdude Yup, 582ms!"><span class="u" id="1513447513.000060">2017:12:16 18:05:13         borkdude </span><span>Yup, 582ms!</span></div><div data-t="borkdude Does the order of rules matter for performance?"><span class="u" id="1513447550.000002">2017:12:16 18:05:50         borkdude </span><span>Does the order of rules matter for performance?</span></div><div data-t="borkdude I mean, when it’s more likely to encounter EXCHANGE, does it help putting that first?"><span class="u" id="1513447581.000007">2017:12:16 18:06:21         borkdude </span><span>I mean, when it’s more likely to encounter EXCHANGE, does it help putting that first?</span></div><div data-t="aengelberg I&apos;m not actually sure why that is faster, just a hunch since I haven&apos;t seen the left-recursive usage a whole lot."><span class="u" id="1513483794.000010">2017:12:17 04:09:54       aengelberg </span><span>I&apos;m not actually sure why that is faster, just a hunch since I haven&apos;t seen the left-recursive usage a whole lot.</span></div><div data-t="Empperi @aengelberg definitely not sure if cfg/ebnf is the correct thing but it looks like it provides the necessary data. Not in the format that would be optimal but I think I can kinda do some kind of functionality based on it. For now, I’m mostly happy if I can find the string literals which can go in and I can ignore regexp literals and other more complex stuff. So, basically I do this recursive algorithm which retrieves elements from the combinatioral tree until it finds  :string"><span class="u" id="1513599873.000247">2017:12:18 12:24:33          Empperi </span><span>@aengelberg definitely not sure if cfg/ebnf is the correct thing but it looks like it provides the necessary data. Not in the format that would be optimal but I think I can kinda do some kind of functionality based on it. For now, I’m mostly happy if I can find the string literals which can go in and I can ignore regexp literals and other more complex stuff. So, basically I do this recursive algorithm which retrieves elements from the combinatioral tree until it finds </span><code>:string</code></div><div data-t="Empperi best I can come up with as it is now"><span class="u" id="1513599884.000285">2017:12:18 12:24:44          Empperi </span><span>best I can come up with as it is now</span></div><div data-t="mbjarland say I have the following grammar: 
 (defn make-layout-parser-internal []
  (insta/parser
    &quot;layout-string = col-delim (col-align col-delim)+
     col-delim    = (col-fill | col-padding)*
     col-fill     = (&apos;F&apos; | &apos;f&apos;)
     col-padding  = #&apos;[^\\[\\]fF]*&apos;
     col-align    = &lt;&apos;[&apos;&gt; (&apos;L&apos; | &apos;l&apos; | &apos;C&apos; | &apos;c&apos; | &apos;R&apos; | &apos;r&apos;) &lt;&apos;]&apos;&gt;&quot;))
 
but I want to make a slight modification to it in a certain context. In essence I have two grammars with just a slight differentce between them and depending on the surrounding (non instaparse related) programming context I would like to parse using either grammar a or grammar b. Would I need to define two distinct grammars as per the above or is there some good way to share most of the grammar and have just a slight modification? In my specific case I would have a difference in the  col-align  value only"><span class="u" id="1513763521.000293">2017:12:20 09:52:01        mbjarland </span><span>say I have the following grammar: 
</span><pre>(defn make-layout-parser-internal []
  (insta/parser
    &quot;layout-string = col-delim (col-align col-delim)+
     col-delim    = (col-fill | col-padding)*
     col-fill     = (&apos;F&apos; | &apos;f&apos;)
     col-padding  = #&apos;[^\\[\\]fF]*&apos;
     col-align    = &lt;&apos;[&apos;&gt; (&apos;L&apos; | &apos;l&apos; | &apos;C&apos; | &apos;c&apos; | &apos;R&apos; | &apos;r&apos;) &lt;&apos;]&apos;&gt;&quot;))
</pre><span>
but I want to make a slight modification to it in a certain context. In essence I have two grammars with just a slight differentce between them and depending on the surrounding (non instaparse related) programming context I would like to parse using either grammar a or grammar b. Would I need to define two distinct grammars as per the above or is there some good way to share most of the grammar and have just a slight modification? In my specific case I would have a difference in the </span><code>col-align</code><span> value only</span></div><div data-t="aengelberg @mbjarland you could use combinators to create separate submaps of common components that get merged together in each use case."><span class="u" id="1514356761.000139">2017:12:27 06:39:21       aengelberg </span><span>@mbjarland you could use combinators to create separate submaps of common components that get merged together in each use case.</span></div><div data-t="mbjarland I have a question about greedy parsing and ambiguous grammars, I have the following grammar: 
 (insta/parser
    &quot;layout   = (align | delim | repeat)+
     repeat   = &lt;&apos;{&apos;&gt; (align | delim)+ &lt;&apos;}&apos;&gt;
     delim    = (fill | padding)+
     fill     = &apos;F&apos;
     padding  = #&apos;[^\\[\\]{}fF]*&apos;
     align    = &lt;&apos;[&apos;&gt; (&apos;L&apos; | &apos;C&apos; | &apos;R&apos; | &apos;V&apos;) &lt;&apos;]&apos;&gt;&quot;
    :string-ci true))
 
where the only relevant pieces are the  layout = (align | delim | repeat)+  and  delim = (fill | padding)+  pieces. Assume we get a ‘fill’ followed by a ‘padding’, the parser can here choose between  [:delim [:fill &quot;F&quot;]] [:delim [:padding &quot;xxx&quot;]]  and  [:delim [:fill &quot;F&quot;] [:padding &quot;xxx&quot;]] . This is not really instaparse specific, but rather to do with bnf’s and disambiguating repeating elements. I would like to force the second interpretation where the  delim = (fill | padding)+  is greedy and collects all contiguous delim elements into a list before proceeding. Any ideas much appreciated"><span class="u" id="1515401503.000113">2018:01:08 08:51:43        mbjarland </span><span>I have a question about greedy parsing and ambiguous grammars, I have the following grammar: 
</span><pre>(insta/parser
    &quot;layout   = (align | delim | repeat)+
     repeat   = &lt;&apos;{&apos;&gt; (align | delim)+ &lt;&apos;}&apos;&gt;
     delim    = (fill | padding)+
     fill     = &apos;F&apos;
     padding  = #&apos;[^\\[\\]{}fF]*&apos;
     align    = &lt;&apos;[&apos;&gt; (&apos;L&apos; | &apos;C&apos; | &apos;R&apos; | &apos;V&apos;) &lt;&apos;]&apos;&gt;&quot;
    :string-ci true))
</pre><span>
where the only relevant pieces are the </span><code>layout = (align | delim | repeat)+</code><span> and </span><code>delim = (fill | padding)+</code><span> pieces. Assume we get a ‘fill’ followed by a ‘padding’, the parser can here choose between </span><code>[:delim [:fill &quot;F&quot;]] [:delim [:padding &quot;xxx&quot;]]</code><span> and </span><code>[:delim [:fill &quot;F&quot;] [:padding &quot;xxx&quot;]]</code><span>. This is not really instaparse specific, but rather to do with bnf’s and disambiguating repeating elements. I would like to force the second interpretation where the </span><code>delim = (fill | padding)+</code><span> is greedy and collects all contiguous delim elements into a list before proceeding. Any ideas much appreciated</span></div><div data-t="aengelberg @mbjarland you could change  (align | delim)+  to  delim? (align delim?)* , that would force the parser to alternate between delim and align, effectively making the delim rule greedy"><span class="u" id="1515402087.000210">2018:01:08 09:01:27       aengelberg </span><span>@mbjarland you could change </span><code>(align | delim)+</code><span> to </span><code>delim? (align delim?)*</code><span>, that would force the parser to alternate between delim and align, effectively making the delim rule greedy</span></div><div data-t="mbjarland and this is why I love the clojure community, thank you for the fast reply! : ) 
are we talking about the first rule  layout = ... ? In that case I would have to cook up a repeating pattern with 3 elements"><span class="u" id="1515402205.000310">2018:01:08 09:03:25        mbjarland </span><span>and this is why I love the clojure community, thank you for the fast reply! : ) 
are we talking about the first rule </span><code>layout = ...</code><span>? In that case I would have to cook up a repeating pattern with 3 elements</span></div><div data-t="mbjarland so what I’m doing here is defining a column layout"><span class="u" id="1515402249.000327">2018:01:08 09:04:09        mbjarland </span><span>so what I’m doing here is defining a column layout</span></div><div data-t="aengelberg Actually I was talking about the repeat rule. But you made a good point that we&apos;d also have to apply a similar solution to the layout rule to get a similar effect"><span class="u" id="1515402268.000326">2018:01:08 09:04:28       aengelberg </span><span>Actually I was talking about the repeat rule. But you made a good point that we&apos;d also have to apply a similar solution to the layout rule to get a similar effect</span></div><div data-t="mbjarland where the repeat says “if the user comes in with more columns than we have defined, use the repeating group to fill out the layout”"><span class="u" id="1515402276.000164">2018:01:08 09:04:36        mbjarland </span><span>where the repeat says “if the user comes in with more columns than we have defined, use the repeating group to fill out the layout”</span></div><div data-t="aengelberg Column layout? Not sure what you mean"><span class="u" id="1515402309.000138">2018:01:08 09:05:09       aengelberg </span><span>Column layout? Not sure what you mean</span></div><div data-t="mbjarland never mind, that is really application related and not related to the grammar"><span class="u" id="1515402327.000109">2018:01:08 09:05:27        mbjarland </span><span>never mind, that is really application related and not related to the grammar</span></div><div data-t="mbjarland thought actually explaining what the thing does might clarify, but I think it just muddles the waters even more : )"><span class="u" id="1515402367.000158">2018:01:08 09:06:07        mbjarland </span><span>thought actually explaining what the thing does might clarify, but I think it just muddles the waters even more : )</span></div><div data-t="mbjarland I also thought about the  /  ordered parsing syntax, but I can not really see how to apply that to these repeating patterns"><span class="u" id="1515402401.000257">2018:01:08 09:06:41        mbjarland </span><span>I also thought about the </span><code>/</code><span> ordered parsing syntax, but I can not really see how to apply that to these repeating patterns</span></div><div data-t="aengelberg layout = delim? ((align | repeat) delim?)*
repeat = &lt;&apos;{&apos;&gt; delim? (align delim?)* &lt;&apos;}&apos;&gt;
"><span class="u" id="1515402467.000169">2018:01:08 09:07:47       aengelberg </span><pre>layout = delim? ((align | repeat) delim?)*
repeat = &lt;&apos;{&apos;&gt; delim? (align delim?)* &lt;&apos;}&apos;&gt;
</pre></div><div data-t="mbjarland : )"><span class="u" id="1515402530.000052">2018:01:08 09:08:50        mbjarland </span><span>: )</span></div><div data-t="aengelberg Since  align  and  repeat  both require nonzero characters to be present in order for the rule to succeed, wedging them in the repeat rule enforces some regularity in the repetition and thus unambiguates the parsing"><span class="u" id="1515402551.000254">2018:01:08 09:09:11       aengelberg </span><span>Since </span><code>align</code><span> and </span><code>repeat</code><span> both require nonzero characters to be present in order for the rule to succeed, wedging them in the repeat rule enforces some regularity in the repetition and thus unambiguates the parsing</span></div><div data-t="mbjarland that works, I tried it with  insta/parses  and my standard examples and it comes out with a single interpretation"><span class="u" id="1515402599.000175">2018:01:08 09:09:59        mbjarland </span><span>that works, I tried it with </span><code>insta/parses</code><span> and my standard examples and it comes out with a single interpretation</span></div><div data-t="mbjarland I will have to meditate on the exact mechanics"><span class="u" id="1515402610.000087">2018:01:08 09:10:10        mbjarland </span><span>I will have to meditate on the exact mechanics</span></div><div data-t="aengelberg Yeah, ordered choice doesn&apos;t really help here unless delim was competing with some other rule and you wanted to establish the priority. But in this case delim is just competing with itself, in a way."><span class="u" id="1515402628.000196">2018:01:08 09:10:28       aengelberg </span><span>Yeah, ordered choice doesn&apos;t really help here unless delim was competing with some other rule and you wanted to establish the priority. But in this case delim is just competing with itself, in a way.</span></div><div data-t="mbjarland exactly, just a question on what level in the bnf the repetition happens"><span class="u" id="1515402658.000032">2018:01:08 09:10:58        mbjarland </span><span>exactly, just a question on what level in the bnf the repetition happens</span></div><div data-t="aengelberg Yeah"><span class="u" id="1515402666.000081">2018:01:08 09:11:06       aengelberg </span><span>Yeah</span></div><div data-t="aengelberg Fortunately that&apos;s easily solved by restructuring the combinators, no fancy PEG combinators necessary"><span class="u" id="1515402687.000211">2018:01:08 09:11:27       aengelberg </span><span>Fortunately that&apos;s easily solved by restructuring the combinators, no fancy PEG combinators necessary</span></div><div data-t="mbjarland this is actually a higher level pattern, I will make sure to grok this properly for the next time I run into an ambiguous repetition"><span class="u" id="1515402693.000048">2018:01:08 09:11:33        mbjarland </span><span>this is actually a higher level pattern, I will make sure to grok this properly for the next time I run into an ambiguous repetition</span></div><div data-t="mbjarland thanks a ton!"><span class="u" id="1515402710.000159">2018:01:08 09:11:50        mbjarland </span><span>thanks a ton!</span></div><div data-t="aengelberg No problem"><span class="u" id="1515402725.000211">2018:01:08 09:12:05       aengelberg </span><span>No problem</span></div><div data-t="aengelberg @mbjarland I just thought of another way you could have solved it: ignore the above changes I proposed and instead change  delim  rule to:

 delim = (fill | padding)+ !delim
"><span class="u" id="1515403088.000172">2018:01:08 09:18:08       aengelberg </span><span>@mbjarland I just thought of another way you could have solved it: ignore the above changes I proposed and instead change </span><code>delim</code><span> rule to:

</span><pre>delim = (fill | padding)+ !delim
</pre></div><div data-t="aengelberg Pretty sure my first solution would be more performant, albeit more complex"><span class="u" id="1515403121.000229">2018:01:08 09:18:41       aengelberg </span><span>Pretty sure my first solution would be more performant, albeit more complex</span></div><div data-t="mbjarland what does the  !delim  do?"><span class="u" id="1515411182.000082">2018:01:08 11:33:02        mbjarland </span><span>what does the </span><code>!delim</code><span> do?</span></div><div data-t="xiongtx Does the order of rules for Instaparse matter? I seem to recall that rule order didn&apos;t for tools like Lex/JLex...but I could be wrong."><span class="u" id="1516591566.000116">2018:01:22 03:26:06          xiongtx </span><span>Does the order of rules for Instaparse matter? I seem to recall that rule order didn&apos;t for tools like Lex/JLex...but I could be wrong.</span></div><div data-t="aengelberg The order of rules in an alternation does not matter, if that&apos;s what you&apos;re asking."><span class="u" id="1516591624.000206">2018:01:22 03:27:04       aengelberg </span><span>The order of rules in an alternation does not matter, if that&apos;s what you&apos;re asking.</span></div><div data-t="xiongtx I meant the statements themselves; but funny you should bring that up, b/c I was just wondering about the order of alternations as well."><span class="u" id="1516592661.000083">2018:01:22 03:44:21          xiongtx </span><span>I meant the statements themselves; but funny you should bring that up, b/c I was just wondering about the order of alternations as well.</span></div><div data-t="xiongtx For

  type = &apos;int&apos; | &apos;boolean&apos; | className

className = identifier

identifier = #&quot;[A-Za-z_]+[A-Za-z0-9_]*&quot;
 

Is there a way to the order of alternations matter, i.e.  (insta/parse parser &quot;int&quot;)  return  {:type &quot;int&quot;]  instead of (from my observation)  [:type [:className [:identifier &quot;int&quot;]]] ?"><span class="u" id="1516592760.000027">2018:01:22 03:46:00          xiongtx </span><span>For

 </span><pre>type = &apos;int&apos; | &apos;boolean&apos; | className

className = identifier

identifier = #&quot;[A-Za-z_]+[A-Za-z0-9_]*&quot;
</pre><span>

Is there a way to the order of alternations matter, i.e. </span><code>(insta/parse parser &quot;int&quot;)</code><span> return </span><code>{:type &quot;int&quot;]</code><span> instead of (from my observation) </span><code>[:type [:className [:identifier &quot;int&quot;]]]</code><span>?</span></div><div data-t="misha greetings! I am having a trouble to match 2 consequent backslashes (clj):
 (insta/parse
  (insta/parser &quot;s = #&apos;\\\\&apos;&quot;)
  &quot;\\\\&quot;)
=&gt; Parse error at line 1, column 1:
\\
^
Expected:
#&quot;\\&quot; (followed by end-of-string)

(insta/parse
  (insta/parser &quot;s = #\&quot;\\\\\&quot;&quot;)
  &quot;\\\\&quot;)
=&gt; Parse error at line 1, column 1:
\\
^
Expected:
#&quot;\\&quot; (followed by end-of-string)
 
at this point I am just brut forcing with no luck"><span class="u" id="1523189051.000005">2018:04:08 12:04:11            misha </span><span>greetings! I am having a trouble to match 2 consequent backslashes (clj):
</span><pre>(insta/parse
  (insta/parser &quot;s = #&apos;\\\\&apos;&quot;)
  &quot;\\\\&quot;)
=&gt; Parse error at line 1, column 1:
\\
^
Expected:
#&quot;\\&quot; (followed by end-of-string)

(insta/parse
  (insta/parser &quot;s = #\&quot;\\\\\&quot;&quot;)
  &quot;\\\\&quot;)
=&gt; Parse error at line 1, column 1:
\\
^
Expected:
#&quot;\\&quot; (followed by end-of-string)
</pre><span>
at this point I am just brut forcing with no luck</span></div><div data-t="aengelberg @misha I think you are just under-escaping. Try
 (insta/parse
  (insta/parser &quot;s = #&apos;\\\\\\\\&apos;&quot;)
  &quot;\\\\&quot;)
"><span class="u" id="1523239471.000026">2018:04:09 02:04:31       aengelberg </span><span>@misha I think you are just under-escaping. Try
</span><pre>(insta/parse
  (insta/parser &quot;s = #&apos;\\\\\\\\&apos;&quot;)
  &quot;\\\\&quot;)
</pre></div><div data-t="aengelberg Since instaparse and Clojure strings both have their own notation of backslash escaping, you unfortunately have to use an obscene amount of backslashes to convey a legitimate backslash character"><span class="u" id="1523239558.000189">2018:04:09 02:05:58       aengelberg </span><span>Since instaparse and Clojure strings both have their own notation of backslash escaping, you unfortunately have to use an obscene amount of backslashes to convey a legitimate backslash character</span></div><div data-t="aengelberg https://github.com/engelberg/instaparse#escape-characters"><span class="u" id="1523239562.000213">2018:04:09 02:06:02       aengelberg </span><a href="https://github.com/engelberg/instaparse#escape-characters">https://github.com/engelberg/instaparse#escape-characters</a></div><div data-t="aengelberg As that section in the readme explains, one way to get more predictable escaping behavior is to store your grammar in a separate resource file, and that removes one of the layers of escaping (Clojure strings)"><span class="u" id="1523239630.000089">2018:04:09 02:07:10       aengelberg </span><span>As that section in the readme explains, one way to get more predictable escaping behavior is to store your grammar in a separate resource file, and that removes one of the layers of escaping (Clojure strings)</span></div><div data-t="misha @aengelberg thank you, that works. I already put grammar and source string into their own files, before asking for help, might have missed something (like ns reload)."><span class="u" id="1523256190.000140">2018:04:09 06:43:10            misha </span><span>@aengelberg thank you, that works. I already put grammar and source string into their own files, before asking for help, might have missed something (like ns reload).</span></div><div data-t="misha how can I distinguish between  \n  within a text, and a line end in multiline text? Can I do it without relying on next line&apos;s grammar/content? For example, here I need to extract &quot;  Simple__ communication example\non several lines&quot; as a single value, w/o including &quot;Alice&quot;. Is there a landmark I can use to stop at &quot;visual&quot; line&apos;s end?:
 title __Simple__ communication example\non several lines
Alice -&gt; Bob: Authentication Request
 
I tried  #&apos;(?m)...$&apos;  regex flag, but I doubt it will receive &quot;visual&quot; line as an input."><span class="u" id="1523257141.000003">2018:04:09 06:59:01            misha </span><span>how can I distinguish between </span><code>\n</code><span> within a text, and a line end in multiline text? Can I do it without relying on next line&apos;s grammar/content? For example, here I need to extract &quot;</span><span>Simple__ communication example\non several lines&quot; as a single value, w/o including &quot;Alice&quot;. Is there a landmark I can use to stop at &quot;visual&quot; line&apos;s end?:
</span><pre>title __Simple__ communication example\non several lines
Alice -&gt; Bob: Authentication Request
</pre><span>
I tried </span><code>#&apos;(?m)...$&apos;</code><span> regex flag, but I doubt it will receive &quot;visual&quot; line as an input.</span></div><div data-t="aengelberg @misha yeah, from the regex&apos;s perspective it&apos;s matching against the entire rest of the string, so  $  means &quot;end of file&quot;, not &quot;end of line&quot;. You could use regex&apos;s lookahead feature to detect and end of line, like  (?=\r?\n)"><span class="u" id="1523287788.000413">2018:04:09 15:29:48       aengelberg </span><span>@misha yeah, from the regex&apos;s perspective it&apos;s matching against the entire rest of the string, so </span><code>$</code><span> means &quot;end of file&quot;, not &quot;end of line&quot;. You could use regex&apos;s lookahead feature to detect and end of line, like </span><code>(?=\r?\n)</code></div><div data-t="gfredericks can instaparse be used to parse significant-whitespace-indentation-things, in the python sense?"><span class="u" id="1524094577.000017">2018:04:18 23:36:17      gfredericks </span><span>can instaparse be used to parse significant-whitespace-indentation-things, in the python sense?</span></div><div data-t="aengelberg not really, primarily because of how the &quot;levels&quot; work in said indentation-heavy languages"><span class="u" id="1524094644.000252">2018:04:18 23:37:24       aengelberg </span><span>not really, primarily because of how the &quot;levels&quot; work in said indentation-heavy languages</span></div><div data-t="gfredericks @aengelberg can you change your username to ængelberg"><span class="u" id="1524094723.000231">2018:04:18 23:38:43      gfredericks </span><span>@aengelberg can you change your username to ængelberg</span></div><div data-t="gfredericks thanks"><span class="u" id="1524094746.000347">2018:04:18 23:39:06      gfredericks </span><span>thanks</span></div><div data-t="aengelberg done"><span class="u" id="1524094747.000148">2018:04:18 23:39:07       aengelberg </span><span>done</span></div><div data-t="gfredericks okay well that&apos;s disappointing because I&apos;m parsing such a thing and I guess I&apos;ll have to do it tediously by hand

have you seen any general tools that can handle it?"><span class="u" id="1524094800.000345">2018:04:18 23:40:00      gfredericks </span><span>okay well that&apos;s disappointing because I&apos;m parsing such a thing and I guess I&apos;ll have to do it tediously by hand

have you seen any general tools that can handle it?</span></div><div data-t="aengelberg if you could somehow pre-tokenize all of the indentation before passing it to instaparse, that might work"><span class="u" id="1524094860.000045">2018:04:18 23:41:00       aengelberg </span><span>if you could somehow pre-tokenize all of the indentation before passing it to instaparse, that might work</span></div><div data-t="aengelberg what I mean is that you&apos;d have to convert
 def f(x):
  if x == 1:
    return 2;
  else:
    return 3;
 
into
 def f(x):
→if x == 1:
→return 2;
←else:
→return 3;
←←
"><span class="u" id="1524094985.000078">2018:04:18 23:43:05       aengelberg </span><span>what I mean is that you&apos;d have to convert
</span><pre>def f(x):
  if x == 1:
    return 2;
  else:
    return 3;
</pre><span>
into
</span><pre>def f(x):
→if x == 1:
→return 2;
←else:
→return 3;
←←
</pre></div><div data-t="aengelberg if that makes sense"><span class="u" id="1524095012.000188">2018:04:18 23:43:32       aengelberg </span><span>if that makes sense</span></div><div data-t="gfredericks and the arrows act like brackets?"><span class="u" id="1524095022.000232">2018:04:18 23:43:42      gfredericks </span><span>and the arrows act like brackets?</span></div><div data-t="aengelberg basically"><span class="u" id="1524095027.000053">2018:04:18 23:43:47       aengelberg </span><span>basically</span></div><div data-t="aengelberg because instaparse can&apos;t keep state of how far to the right you should be at any given point"><span class="u" id="1524095042.000058">2018:04:18 23:44:02       aengelberg </span><span>because instaparse can&apos;t keep state of how far to the right you should be at any given point</span></div><div data-t="aengelberg based on higher-level indentations"><span class="u" id="1524095050.000010">2018:04:18 23:44:10       aengelberg </span><span>based on higher-level indentations</span></div><div data-t="gfredericks I think the combination of writing that code and having to write a grammar is probably more tedious than parsing it manually"><span class="u" id="1524095081.000212">2018:04:18 23:44:41      gfredericks </span><span>I think the combination of writing that code and having to write a grammar is probably more tedious than parsing it manually</span></div><div data-t="aengelberg perhaps"><span class="u" id="1524095097.000215">2018:04:18 23:44:57       aengelberg </span><span>perhaps</span></div><div data-t="aengelberg oh also you could maybe get sneaky with nested parsing"><span class="u" id="1524095218.000129">2018:04:18 23:46:58       aengelberg </span><span>oh also you could maybe get sneaky with nested parsing</span></div><div data-t="aengelberg where, say, the top level parser gives you back
 [:def &quot;f(x)&quot;
 [:nested-block
  &quot;if x == 1:&quot;
  &quot;  return 2;&quot;
  &quot;else:&quot;
  &quot;  return 3;&quot;]]
"><span class="u" id="1524095279.000008">2018:04:18 23:47:59       aengelberg </span><span>where, say, the top level parser gives you back
</span><pre>[:def &quot;f(x)&quot;
 [:nested-block
  &quot;if x == 1:&quot;
  &quot;  return 2;&quot;
  &quot;else:&quot;
  &quot;  return 3;&quot;]]
</pre></div><div data-t="aengelberg and then you have some code that then takes said nested blocks and re-runs the parser on it"><span class="u" id="1524095295.000242">2018:04:18 23:48:15       aengelberg </span><span>and then you have some code that then takes said nested blocks and re-runs the parser on it</span></div><div data-t="aengelberg and so on"><span class="u" id="1524095297.000296">2018:04:18 23:48:17       aengelberg </span><span>and so on</span></div><div data-t="gfredericks oh interesting"><span class="u" id="1524095341.000218">2018:04:18 23:49:01      gfredericks </span><span>oh interesting</span></div><div data-t="gfredericks if you&apos;re not trampolining your parser, why bother getting up in the morning?"><span class="u" id="1524095362.000103">2018:04:18 23:49:22      gfredericks </span><span>if you&apos;re not trampolining your parser, why bother getting up in the morning?</span></div><div data-t="aengelberg you would have to re-append those nested block lines (with newlines in between)"><span class="u" id="1524095621.000048">2018:04:18 23:53:41       aengelberg </span><span>you would have to re-append those nested block lines (with newlines in between)</span></div><div data-t="gfredericks sure"><span class="u" id="1524095643.000295">2018:04:18 23:54:03      gfredericks </span><span>sure</span></div><div data-t="aengelberg the grammar would look like
 S = def | if | ...
def = &lt;&apos;def &apos;&gt; thing-you&apos;re-deffing &lt;&apos;:\n&apos;&gt; nested-block
nested-block = (&apos; &apos; #&quot;.*\n?&quot;)*
"><span class="u" id="1524095809.000321">2018:04:18 23:56:49       aengelberg </span><span>the grammar would look like
</span><pre>S = def | if | ...
def = &lt;&apos;def &apos;&gt; thing-you&apos;re-deffing &lt;&apos;:\n&apos;&gt; nested-block
nested-block = (&apos; &apos; #&quot;.*\n?&quot;)*
</pre></div><div data-t="gfredericks we&apos;re relying on the greediness of  .*  to definitely eat the  \n  even though it`s got a  ?  on it?"><span class="u" id="1524096059.000103">2018:04:19 00:00:59      gfredericks </span><span>we&apos;re relying on the greediness of </span><code>.*</code><span> to definitely eat the </span><code>\n</code><span> even though it`s got a </span><code>?</code><span> on it?</span></div><div data-t="aengelberg well,  .  by default means non-newline chars in regex-land"><span class="u" id="1524096101.000386">2018:04:19 00:01:41       aengelberg </span><span>well, </span><code>.</code><span> by default means non-newline chars in regex-land</span></div><div data-t="gfredericks the  \n?  had me worried that it might parse  [&quot; foo&quot; &quot; bar&quot;]  from  &quot; foo bar&quot;"><span class="u" id="1524096107.000004">2018:04:19 00:01:47      gfredericks </span><span>the </span><code>\n?</code><span> had me worried that it might parse </span><code>[&quot; foo&quot; &quot; bar&quot;]</code><span> from </span><code>&quot; foo bar&quot;</code></div><div data-t="aengelberg but yes we are relying on the greediness"><span class="u" id="1524096117.000110">2018:04:19 00:01:57       aengelberg </span><span>but yes we are relying on the greediness</span></div><div data-t="gfredericks :+1:"><span class="u" id="1524096121.000176">2018:04:19 00:02:01      gfredericks </span><b>:+1:</b></div><div data-t="aengelberg #&quot;.*(\n|$)&quot;  might be safer"><span class="u" id="1524096144.000057">2018:04:19 00:02:24       aengelberg </span><code>#&quot;.*(\n|$)&quot;</code><span> might be safer</span></div><div data-t="aengelberg btw I believe @dave has some prior art on nested parsers for Alda"><span class="u" id="1524096197.000033">2018:04:19 00:03:17       aengelberg </span><span>btw I believe @dave has some prior art on nested parsers for Alda</span></div><div data-t="aengelberg actually just kidding I think he migrated away from instaparse in more recent versions of Alda"><span class="u" id="1524096208.000113">2018:04:19 00:03:28       aengelberg </span><span>actually just kidding I think he migrated away from instaparse in more recent versions of Alda</span></div><div data-t="dave indeed, i ended up rolling my own parser, mostly in the hope that someday we can start to asynchronously process parsed expressions/statements as they are parsed -- meaning that a score could start playing before it&apos;s even done being parsed"><span class="u" id="1524099922.000082">2018:04:19 01:05:22             dave </span><span>indeed, i ended up rolling my own parser, mostly in the hope that someday we can start to asynchronously process parsed expressions/statements as they are parsed -- meaning that a score could start playing before it&apos;s even done being parsed</span></div><div data-t="dave ...although in doing so, performance got significantly better, to the extent that we might never need to do that  😄"><span class="u" id="1524099939.000015">2018:04:19 01:05:39             dave </span><span>...although in doing so, performance got significantly better, to the extent that we might never need to do that </span><b>😄</b></div><div data-t="dave before moving away from instaparse, i was doing some pretty complicated stuff with multiple grammars. it was starting to make my head hurt a little, so that may have had something to do with the decision too"><span class="u" id="1524100148.000226">2018:04:19 01:09:08             dave </span><span>before moving away from instaparse, i was doing some pretty complicated stuff with multiple grammars. it was starting to make my head hurt a little, so that may have had something to do with the decision too</span></div><div data-t="dave the grammars needed to share some rules with each other, so i was defining grammars using bits and pieces strung together"><span class="u" id="1524100193.000182">2018:04:19 01:09:53             dave </span><span>the grammars needed to share some rules with each other, so i was defining grammars using bits and pieces strung together</span></div><div data-t="dave the reason for that was basically to try and get better perf (without being super knowledgeable about how to improve parser performance otherwise), instead of a big master grammar like i had before, i started parsing out large chunks with more specialized grammars, and do the parsing in multiple passes"><span class="u" id="1524100298.000273">2018:04:19 01:11:38             dave </span><span>the reason for that was basically to try and get better perf (without being super knowledgeable about how to improve parser performance otherwise), instead of a big master grammar like i had before, i started parsing out large chunks with more specialized grammars, and do the parsing in multiple passes</span></div><div data-t="aengelberg"><span class="u" id="1527000587.000256">2018:05:22 14:49:47       aengelberg </span></div><div data-t="aengelberg @sova Once your query has been parsed from a string into data (that&apos;s usually the hard part), you can use whatever strategy you want to actually evaluate it.  insta/transform  is meant to be just one tool in your toolbelt to serve the most common case."><span class="u" id="1527000655.000801">2018:05:22 14:50:55       aengelberg </span><span>@sova Once your query has been parsed from a string into data (that&apos;s usually the hard part), you can use whatever strategy you want to actually evaluate it. </span><code>insta/transform</code><span> is meant to be just one tool in your toolbelt to serve the most common case.</span></div><div data-t="aengelberg I think this is the transform example you were referring to:
 =&gt; (-&gt;&gt; (arithmetic &quot;1-2/(3-4)+5*6&quot;)
     (insta/transform
       {:add +, :sub -, :mul *, :div /,
        :number clojure.edn/read-string :expr identity}))
33
"><span class="u" id="1527000775.000211">2018:05:22 14:52:55       aengelberg </span><span>I think this is the transform example you were referring to:
</span><pre>=&gt; (-&gt;&gt; (arithmetic &quot;1-2/(3-4)+5*6&quot;)
     (insta/transform
       {:add +, :sub -, :mul *, :div /,
        :number clojure.edn/read-string :expr identity}))
33
</pre></div><div data-t="aengelberg In this case it isn&apos;t replacing  :add  with  + , it&apos;s actually calling  +  on all of the elements that come after  :add . So as the transformer works its way up the tree, it ends up evaluating the whole expression."><span class="u" id="1527000846.000222">2018:05:22 14:54:06       aengelberg </span><span>In this case it isn&apos;t replacing </span><code>:add</code><span> with </span><code>+</code><span>, it&apos;s actually calling </span><code>+</code><span> on all of the elements that come after </span><code>:add</code><span>. So as the transformer works its way up the tree, it ends up evaluating the whole expression.</span></div><div data-t="aengelberg Does that explanation help?"><span class="u" id="1527000977.000141">2018:05:22 14:56:17       aengelberg </span><span>Does that explanation help?</span></div><div data-t="SoV4 wow!  that is very cool, it&apos;s calling  +  ... this explanation is very helpful, it gives me a really strong starting point,
 but i&apos;m still not sure how i can end up with a thing i can test logicals on.  

since i could replace different nodes with whatever function i see fit, there&apos;s a lot of power there,
but i gotta end up with something that i could pour &quot;lemon juice&quot; through and if the internal 
query expression was (&quot;lemon&quot; | &quot;momo&quot;) &amp; &quot;juice&quot; ... it would work.

do you have any ideas on transforming nodes into logic gates?"><span class="u" id="1527001196.000676">2018:05:22 14:59:56             SoV4 </span><span>wow!  that is very cool, it&apos;s calling </span><code>+</code><span> ... this explanation is very helpful, it gives me a really strong starting point,
 but i&apos;m still not sure how i can end up with a thing i can test logicals on.  

since i could replace different nodes with whatever function i see fit, there&apos;s a lot of power there,
but i gotta end up with something that i could pour &quot;lemon juice&quot; through and if the internal 
query expression was (&quot;lemon&quot; | &quot;momo&quot;) &amp; &quot;juice&quot; ... it would work.

do you have any ideas on transforming nodes into logic gates?</span></div><div data-t="SoV4 okay, you mention that it works its way up the tree so presumably it starts at the leaves...
so if on matching leaves we write down &quot;true&quot; and non matching leaves we write &quot;false&quot; and then eventually do an eval on the whole thing, it&apos;ll be like getting a truth statement back."><span class="u" id="1527001300.000132">2018:05:22 15:01:40             SoV4 </span><span>okay, you mention that it works its way up the tree so presumably it starts at the leaves...
so if on matching leaves we write down &quot;true&quot; and non matching leaves we write &quot;false&quot; and then eventually do an eval on the whole thing, it&apos;ll be like getting a truth statement back.</span></div><div data-t="SoV4 Thanks for taking the time to explain that, by the way."><span class="u" id="1527001378.000598">2018:05:22 15:02:58             SoV4 </span><span>Thanks for taking the time to explain that, by the way.</span></div><div data-t="akiroz Found this channel in #beginners and I just wanna say: @aengelberg thank you for the great library, it saved me multiple times from DSL hell  😊"><span class="u" id="1527023276.000621">2018:05:22 21:07:56           akiroz </span><span>Found this channel in #beginners and I just wanna say: @aengelberg thank you for the great library, it saved me multiple times from DSL hell </span><b>😊</b></div><div data-t="aengelberg thanks @akiroz, glad you are finding it useful"><span class="u" id="1527023365.000166">2018:05:22 21:09:25       aengelberg </span><span>thanks @akiroz, glad you are finding it useful</span></div><div data-t="aengelberg @sova yeah your true/false strategy should work.  insta/transform  is a recursive function, and whenever it&apos;s processing a node it transforms all of the children first, hence the &quot;leaves first&quot; approach."><span class="u" id="1527023544.000225">2018:05:22 21:12:24       aengelberg </span><span>@sova yeah your true/false strategy should work. </span><code>insta/transform</code><span> is a recursive function, and whenever it&apos;s processing a node it transforms all of the children first, hence the &quot;leaves first&quot; approach.</span></div><div data-t="aengelberg you can take a look at the source code of  insta/transform . It has some boilerplate to make sure it works on instaparse&apos;s various output formats, but at its core it&apos;s a fairly simple depth-first iterator."><span class="u" id="1527023592.000445">2018:05:22 21:13:12       aengelberg </span><span>you can take a look at the source code of </span><code>insta/transform</code><span>. It has some boilerplate to make sure it works on instaparse&apos;s various output formats, but at its core it&apos;s a fairly simple depth-first iterator.</span></div><div data-t="aengelberg https://github.com/Engelberg/instaparse/blob/master/src/instaparse/transform.cljc#L33-L46"><span class="u" id="1527023645.000584">2018:05:22 21:14:05       aengelberg </span><a href="https://github.com/Engelberg/instaparse/blob/master/src/instaparse/transform.cljc#L33-L46">https://github.com/Engelberg/instaparse/blob/master/src/instaparse/transform.cljc#L33-L46</a></div><div data-t="aengelberg the super-simplified version of the logic looks like this:
 (defn- hiccup-transform
  [transform-map parse-tree]
  (if (not (empty? parse-tree))
    (let [transform (transform-map (first parse-tree))]
      (apply transform (map (partial hiccup-transform transform-map)
                            (next parse-tree))))
    parse-tree))
"><span class="u" id="1527023898.000028">2018:05:22 21:18:18       aengelberg </span><span>the super-simplified version of the logic looks like this:
</span><pre>(defn- hiccup-transform
  [transform-map parse-tree]
  (if (not (empty? parse-tree))
    (let [transform (transform-map (first parse-tree))]
      (apply transform (map (partial hiccup-transform transform-map)
                            (next parse-tree))))
    parse-tree))
</pre></div><div data-t="SoV4 Cool!  Thanks very much for providing source and also zooming in on the vital part."><span class="u" id="1527024773.000138">2018:05:22 21:32:53             SoV4 </span><span>Cool!  Thanks very much for providing source and also zooming in on the vital part.</span></div><div data-t="SoV4 So the (partial ..) function ... could you tell me more about how that comes into play?"><span class="u" id="1527024879.000561">2018:05:22 21:34:39             SoV4 </span><span>So the (partial ..) function ... could you tell me more about how that comes into play?</span></div><div data-t="aengelberg partial  is a function built-in to Clojure that helps curry arguments in anonymous functions  http://clojuredocs.org/clojure.core/partial"><span class="u" id="1527025532.000616">2018:05:22 21:45:32       aengelberg </span><code>partial</code><span> is a function built-in to Clojure that helps curry arguments in anonymous functions </span><a href="http://clojuredocs.org/clojure.core/partial">http://clojuredocs.org/clojure.core/partial</a></div><div data-t="SoV4 Hello again.  I stumbled onto  http://instaparse-live.matt.is/   and it&apos;s really awesome, I&apos;ve been tinkering with it and with a repl-like feedback loop it&apos;s been pretty painless finding something that can parse logic like i need"><span class="u" id="1527190559.000517">2018:05:24 19:35:59             SoV4 </span><span>Hello again.  I stumbled onto </span><a href="http://instaparse-live.matt.is/">http://instaparse-live.matt.is/</a><span>  and it&apos;s really awesome, I&apos;ve been tinkering with it and with a repl-like feedback loop it&apos;s been pretty painless finding something that can parse logic like i need</span></div><div data-t="SoV4 But one thing I have noticed is that if there are parse variations, there may be multiple result parses"><span class="u" id="1527190578.000278">2018:05:24 19:36:18             SoV4 </span><span>But one thing I have noticed is that if there are parse variations, there may be multiple result parses</span></div><div data-t="SoV4 That pretty much encapsulates the nodes as I want to store them... i wonder if there is a cleaner or clearer representation for just &amp; and  |  logic w/ parens"><span class="u" id="1527190898.000378">2018:05:24 19:41:38             SoV4 </span><span>That pretty much encapsulates the nodes as I want to store them... i wonder if there is a cleaner or clearer representation for just &amp; and  |  logic w/ parens</span></div><div data-t="SoV4 Sometimes, there are multiple valid interpretations, for example: (pardon the zoom level)..."><span class="u" id="1527190998.000610">2018:05:24 19:43:18             SoV4 </span><span>Sometimes, there are multiple valid interpretations, for example: (pardon the zoom level)...</span></div><div data-t="SoV4 It seems as though they are both perfectly valid so, maybe I can just use the first one of the result set"><span class="u" id="1527191176.000437">2018:05:24 19:46:16             SoV4 </span><span>It seems as though they are both perfectly valid so, maybe I can just use the first one of the result set</span></div><div data-t="SoV4 better example.."><span class="u" id="1527191822.000071">2018:05:24 19:57:02             SoV4 </span><span>better example..</span></div><div data-t="dave wow, i haven&apos;t seen this before. so cool!"><span class="u" id="1527192505.000733">2018:05:24 20:08:25             dave </span><span>wow, i haven&apos;t seen this before. so cool!</span></div><div data-t="SoV4 yeah, LISP is insanely cool, instaparse is amazing, and context free grammars absolutely rock.  seeing how easy it actually is to get tokens out of arbitrary syntax i&apos;m really inspired to work on some NLP stuff!"><span class="u" id="1527265957.000550">2018:05:25 16:32:37             SoV4 </span><span>yeah, LISP is insanely cool, instaparse is amazing, and context free grammars absolutely rock.  seeing how easy it actually is to get tokens out of arbitrary syntax i&apos;m really inspired to work on some NLP stuff!</span></div><div data-t="Logan Powell 👋  Hi everyone!"><span class="u" id="1527447050.000111">2018:05:27 18:50:50     Logan Powell </span><b>👋</b><span> Hi everyone!</span></div><div data-t="Logan Powell btw,  http://instaparse-live.matt.is/  is awesome"><span class="u" id="1527447713.000073">2018:05:27 19:01:53     Logan Powell </span><span>btw, </span><a href="http://instaparse-live.matt.is/">http://instaparse-live.matt.is/</a><span> is awesome</span></div><div data-t="akiroz @loganpowell Why not just read the clojure code as data? I mean lisp code IS data, there&apos;s no need to deal with string parsing"><span class="u" id="1527448127.000036">2018:05:27 19:08:47           akiroz </span><span>@loganpowell Why not just read the clojure code as data? I mean lisp code IS data, there&apos;s no need to deal with string parsing</span></div><div data-t="Logan Powell how would I pull out the pieces of the function definitions as strings?"><span class="u" id="1527448171.000006">2018:05:27 19:09:31     Logan Powell </span><span>how would I pull out the pieces of the function definitions as strings?</span></div><div data-t="Logan Powell I&apos;m converting it to markdown"><span class="u" id="1527448191.000097">2018:05:27 19:09:51     Logan Powell </span><span>I&apos;m converting it to markdown</span></div><div data-t="akiroz just print it to string"><span class="u" id="1527448207.000140">2018:05:27 19:10:07           akiroz </span><span>just print it to string</span></div><div data-t="Logan Powell haha, I&apos;m very stupid. That&apos;s a great idea"><span class="u" id="1527448226.000065">2018:05:27 19:10:26     Logan Powell </span><span>haha, I&apos;m very stupid. That&apos;s a great idea</span></div><div data-t="akiroz you might want  pprint  actually, since it&apos;s for docs"><span class="u" id="1527448252.000025">2018:05:27 19:10:52           akiroz </span><span>you might want </span><code>pprint</code><span> actually, since it&apos;s for docs</span></div><div data-t="Logan Powell ok, so I get the string that way, then how do I pull out the specific parts of that string that I need?"><span class="u" id="1527448267.000082">2018:05:27 19:11:07     Logan Powell </span><span>ok, so I get the string that way, then how do I pull out the specific parts of that string that I need?</span></div><div data-t="akiroz well first parse the whole thing into data with the built-in  read  function"><span class="u" id="1527448295.000064">2018:05:27 19:11:35           akiroz </span><span>well first parse the whole thing into data with the built-in </span><code>read</code><span> function</span></div><div data-t="akiroz manipulate the data as much as you want then print it"><span class="u" id="1527448330.000028">2018:05:27 19:12:10           akiroz </span><span>manipulate the data as much as you want then print it</span></div><div data-t="Logan Powell hmm... let me give that a shot!"><span class="u" id="1527448345.000062">2018:05:27 19:12:25     Logan Powell </span><span>hmm... let me give that a shot!</span></div><div data-t="akiroz @loganpowell if you need more advanced code analysis, check out  tools.analyzer"><span class="u" id="1527448407.000099">2018:05:27 19:13:27           akiroz </span><span>@loganpowell if you need more advanced code analysis, check out </span><code>tools.analyzer</code></div><div data-t="akiroz https://github.com/clojure/tools.analyzer"><span class="u" id="1527448418.000001">2018:05:27 19:13:38           akiroz </span><a href="https://github.com/clojure/tools.analyzer">https://github.com/clojure/tools.analyzer</a></div><div data-t="Logan Powell I&apos;m using cljs, works the same?"><span class="u" id="1527448443.000109">2018:05:27 19:14:03     Logan Powell </span><span>I&apos;m using cljs, works the same?</span></div><div data-t="akiroz you mean the  read  part or analyser?"><span class="u" id="1527448474.000084">2018:05:27 19:14:34           akiroz </span><span>you mean the </span><code>read</code><span> part or analyser?</span></div><div data-t="Logan Powell both"><span class="u" id="1527448485.000027">2018:05:27 19:14:45     Logan Powell </span><span>both</span></div><div data-t="akiroz former is called  cljs.reader/read-string  in cljs"><span class="u" id="1527448498.000013">2018:05:27 19:14:58           akiroz </span><span>former is called </span><code>cljs.reader/read-string</code><span> in cljs</span></div><div data-t="akiroz latter I have no idea if it works in cljs (I&apos;m gonna guess no)"><span class="u" id="1527448507.000060">2018:05:27 19:15:07           akiroz </span><span>latter I have no idea if it works in cljs (I&apos;m gonna guess no)</span></div><div data-t="Logan Powell is  reader  a part of core or do I need to add it as a :dependency?"><span class="u" id="1527448592.000006">2018:05:27 19:16:32     Logan Powell </span><span>is </span><code>reader</code><span> a part of core or do I need to add it as a :dependency?</span></div><div data-t="akiroz it&apos;s built-in"><span class="u" id="1527448609.000024">2018:05:27 19:16:49           akiroz </span><span>it&apos;s built-in</span></div><div data-t="Logan Powell cool"><span class="u" id="1527448615.000101">2018:05:27 19:16:55     Logan Powell </span><span>cool</span></div><div data-t="Logan Powell it&apos;s working  🙂  I was getting all excited about instaparse... now I have to calm down my curiosity and get to work  😄"><span class="u" id="1527448687.000055">2018:05:27 19:18:07     Logan Powell </span><span>it&apos;s working </span><b>🙂</b><span> I was getting all excited about instaparse... now I have to calm down my curiosity and get to work </span><b>😄</b></div><div data-t="Logan Powell do I use  core.match  with this?"><span class="u" id="1527448741.000012">2018:05:27 19:19:01     Logan Powell </span><span>do I use </span><code>core.match</code><span> with this?</span></div><div data-t="akiroz Haha, I suppose building a parser yourself would be a great learning exercise too.... but code grammar is a bit complex."><span class="u" id="1527448795.000081">2018:05:27 19:19:55           akiroz </span><span>Haha, I suppose building a parser yourself would be a great learning exercise too.... but code grammar is a bit complex.</span></div><div data-t="Logan Powell it looks as so, you&apos;re right"><span class="u" id="1527448833.000003">2018:05:27 19:20:33     Logan Powell </span><span>it looks as so, you&apos;re right</span></div><div data-t="akiroz You can use whatever tools you want to process the data, it&apos;s just a list"><span class="u" id="1527448833.000041">2018:05:27 19:20:33           akiroz </span><span>You can use whatever tools you want to process the data, it&apos;s just a list</span></div><div data-t="Logan Powell ok, let me give it a go"><span class="u" id="1527448843.000126">2018:05:27 19:20:43     Logan Powell </span><span>ok, let me give it a go</span></div><div data-t="aengelberg yeah, Instaparse only aims to help turn strings into data, so if you already have a way to do that (`read-string`) then instaparse won&apos;t be much help"><span class="u" id="1527453897.000068">2018:05:27 20:44:57       aengelberg </span><span>yeah, Instaparse only aims to help turn strings into data, so if you already have a way to do that (`read-string`) then instaparse won&apos;t be much help</span></div><div data-t="aengelberg the &quot;analysis&quot; of your resulting data is always left as an exercise to the reader anyway  🙂"><span class="u" id="1527453921.000031">2018:05:27 20:45:21       aengelberg </span><span>the &quot;analysis&quot; of your resulting data is always left as an exercise to the reader anyway </span><b>🙂</b></div><div data-t="SoV4 does it make sense to use instaparse on the input to (read-line)  (e.g. getting input from std in?)"><span class="u" id="1527482666.000244">2018:05:28 04:44:26             SoV4 </span><span>does it make sense to use instaparse on the input to (read-line)  (e.g. getting input from std in?)</span></div><div data-t="SoV4 because I want to parse numbers and strings.  integers"><span class="u" id="1527491342.000320">2018:05:28 07:09:02             SoV4 </span><span>because I want to parse numbers and strings.  integers</span></div><div data-t="aengelberg not sure what you mean @sova; instaparse parsers can be run on any string"><span class="u" id="1527548083.000132">2018:05:28 22:54:43       aengelberg </span><span>not sure what you mean @sova; instaparse parsers can be run on any string</span></div><div data-t="SoV4 Yeah, I had a hard time forming my question, i&apos;m getting input from stdin, i have resorted to using edn/read-string which gives a vector of strings,"><span class="u" id="1527552238.000192">2018:05:29 00:03:58             SoV4 </span><span>Yeah, I had a hard time forming my question, i&apos;m getting input from stdin, i have resorted to using edn/read-string which gives a vector of strings,</span></div><div data-t="fabrao Hello all, I´m doing parser for fixed width with instaparse and the code is 
 (-&gt;&gt;
   ((insta/parser
     &quot;VALOR = CODIGO BARRAS
CODIGO = 2DIGIT
BARRAS = 3DIGIT
&quot; :input-format :abnf) &quot;12334&quot;)
   (insta/transform {:DIGIT (comp str)}))  
How do I concat the &quot;DIGITs&quot; and keep CODIGO and BARRAS?"><span class="u" id="1527653207.000021">2018:05:30 04:06:47           fabrao </span><span>Hello all, I´m doing parser for fixed width with instaparse and the code is 
</span><pre>(-&gt;&gt;
   ((insta/parser
     &quot;VALOR = CODIGO BARRAS
CODIGO = 2DIGIT
BARRAS = 3DIGIT
&quot; :input-format :abnf) &quot;12334&quot;)
   (insta/transform {:DIGIT (comp str)}))</pre><span> 
How do I concat the &quot;DIGITs&quot; and keep CODIGO and BARRAS?</span></div><div data-t="aengelberg @fabrao try adding transform entries for  :CODIGO (partial apply str) :BARRAS (partial apply str)"><span class="u" id="1527661282.000018">2018:05:30 06:21:22       aengelberg </span><span>@fabrao try adding transform entries for </span><code>:CODIGO (partial apply str) :BARRAS (partial apply str)</code></div><div data-t="fabrao @aengelberg it did not work, this keep showing  [:VALOR [:DIGIT &quot;1&quot;]:DIGIT2 [:DIGIT &quot;3&quot;][:DIGIT &quot;3&quot;]:DIGIT4]"><span class="u" id="1527683382.000132">2018:05:30 12:29:42           fabrao </span><span>@aengelberg it did not work, this keep showing </span><code>[:VALOR [:DIGIT &quot;1&quot;]:DIGIT2 [:DIGIT &quot;3&quot;][:DIGIT &quot;3&quot;]:DIGIT4]</code></div><div data-t="fabrao I had to change to 
 ((insta/parser
     &quot;VALOR = CODIGO BARRAS
CODIGO = #&apos;.{3}&apos;
BARRAS = #&apos;.{2}&apos;
&quot;) &quot;12334&quot;)"><span class="u" id="1527683473.000203">2018:05:30 12:31:13           fabrao </span><span>I had to change to 
</span><pre>((insta/parser
     &quot;VALOR = CODIGO BARRAS
CODIGO = #&apos;.{3}&apos;
BARRAS = #&apos;.{2}&apos;
&quot;) &quot;12334&quot;)</pre></div><div data-t="SoV4 hey @aengelberg, how does instaparse work?  i was looking at the source and it looks like it makes multiple passes until it&apos;s successfully consumed the whole input string, correct?  and if a parse doesn&apos;t work, an &quot;error node is embedded in the tree&quot; so it knows not to try that parse again?"><span class="u" id="1527781068.000091">2018:05:31 15:37:48             SoV4 </span><span>hey @aengelberg, how does instaparse work?  i was looking at the source and it looks like it makes multiple passes until it&apos;s successfully consumed the whole input string, correct?  and if a parse doesn&apos;t work, an &quot;error node is embedded in the tree&quot; so it knows not to try that parse again?</span></div><div data-t="aengelberg @sova this talk explains the internals pretty well  https://www.youtube.com/watch?v=b2AUW6psVcE"><span class="u" id="1527784069.000811">2018:05:31 16:27:49       aengelberg </span><span>@sova this talk explains the internals pretty well </span><a href="https://www.youtube.com/watch?v=b2AUW6psVcE">https://www.youtube.com/watch?v=b2AUW6psVcE</a></div><div data-t="SoV4 oh nice.  thank you!  i was very curious because it&apos;s very powerful and very fast and i don&apos;t remember things being so fast in compilers class  😄"><span class="u" id="1527784124.000569">2018:05:31 16:28:44             SoV4 </span><span>oh nice.  thank you!  i was very curious because it&apos;s very powerful and very fast and i don&apos;t remember things being so fast in compilers class </span><b>😄</b></div><div data-t="aengelberg glad to hear it&apos;s fast! Although what makes Instaparse really unique is that it works well with left-recursive and ambiguous grammars"><span class="u" id="1527784161.000482">2018:05:31 16:29:21       aengelberg </span><span>glad to hear it&apos;s fast! Although what makes Instaparse really unique is that it works well with left-recursive and ambiguous grammars</span></div><div data-t="aengelberg something like
 S = &apos;a&apos; | S &apos;a&apos;
 
usually doesn&apos;t work in normal parsers"><span class="u" id="1527784192.000086">2018:05:31 16:29:52       aengelberg </span><span>something like
</span><pre>S = &apos;a&apos; | S &apos;a&apos;
</pre><span>
usually doesn&apos;t work in normal parsers</span></div><div data-t="SoV4 leftwards-building strings... I see  that is cool"><span class="u" id="1527784221.000109">2018:05:31 16:30:21             SoV4 </span><span>leftwards-building strings... I see  that is cool</span></div><div data-t="SoV4 I want to do some language processing stuff -- eventually reduce articles people write to synopses and relevant tags.  i feel like that&apos;s very possible but i gotta think a bit more on the approach.  like checking words against a dictionary to try and focus on nouns and verbs"><span class="u" id="1527784480.000694">2018:05:31 16:34:40             SoV4 </span><span>I want to do some language processing stuff -- eventually reduce articles people write to synopses and relevant tags.  i feel like that&apos;s very possible but i gotta think a bit more on the approach.  like checking words against a dictionary to try and focus on nouns and verbs</span></div><div data-t="SoV4 aha, now i know why the file is called .gll  😄"><span class="u" id="1527785749.000542">2018:05:31 16:55:49             SoV4 </span><span>aha, now i know why the file is called .gll </span><b>😄</b></div><div data-t="SoV4 &quot;send me all your old magazine subscriptions before any new ones&quot; is a good way to explain how it works briefly."><span class="u" id="1527787286.000569">2018:05:31 17:21:26             SoV4 </span><span>&quot;send me all your old magazine subscriptions before any new ones&quot; is a good way to explain how it works briefly.</span></div><div data-t="mlimotte Can I get some help with a (hopefully) a simple grammar?  I haven’t done much with CFGs so I could be totally off base.
I want to find variable expressions in a string.  
For example:   hello, {{name}}. 
This is similar to the Mustache variety of interpolation, but I need to pre-parse it to do something slightly different.

I can recognize the pattern above pretty easily.  My problem is having it ignore single brackets.
For example:  hello, {{name}}.  Please choose {Yes, No}. 
The last part is not a double bracket expression and should just be treated like the other uninteresting text.

So, my grammar looks like this (I’ve tried a bunch of other variations, this is the closest I’ve come):

 (def p 
  (insta/parser
    &quot;&lt;S&gt; = (block | TXT)*
     block = &lt;&apos;{{&apos;&gt; TXT &lt;&apos;}}&apos;&gt;
     &lt;TXT&gt; = (OPEN | CLOSE | A | block)*
     &lt;OPEN&gt; = !&apos;{&apos; &apos;{&apos;
     &lt;CLOSE&gt; = !&apos;}&apos; &apos;}&apos;
     &lt;A&gt; = #&apos;[^{}]*&apos;&quot;))
"><span class="u" id="1533233430.000427">2018:08:02 18:10:30         mlimotte </span><span>Can I get some help with a (hopefully) a simple grammar?  I haven’t done much with CFGs so I could be totally off base.
I want to find variable expressions in a string.  
For example:  </span><code>hello, {{name}}.</code><span>
This is similar to the Mustache variety of interpolation, but I need to pre-parse it to do something slightly different.

I can recognize the pattern above pretty easily.  My problem is having it ignore single brackets.
For example: </span><code>hello, {{name}}.  Please choose {Yes, No}.</code><span>
The last part is not a double bracket expression and should just be treated like the other uninteresting text.

So, my grammar looks like this (I’ve tried a bunch of other variations, this is the closest I’ve come):

</span><pre>(def p 
  (insta/parser
    &quot;&lt;S&gt; = (block | TXT)*
     block = &lt;&apos;{{&apos;&gt; TXT &lt;&apos;}}&apos;&gt;
     &lt;TXT&gt; = (OPEN | CLOSE | A | block)*
     &lt;OPEN&gt; = !&apos;{&apos; &apos;{&apos;
     &lt;CLOSE&gt; = !&apos;}&apos; &apos;}&apos;
     &lt;A&gt; = #&apos;[^{}]*&apos;&quot;))
</pre></div><div data-t="mlimotte A call  (p &quot;x{a}&quot;)  yields:
 =&gt; Parse error at line 1, column 2:
x{a}
 ^
Expected one of:
&quot;{{&quot;
&quot;}&quot;
NOT &quot;{&quot;
"><span class="u" id="1533233523.000393">2018:08:02 18:12:03         mlimotte </span><span>A call </span><code>(p &quot;x{a}&quot;)</code><span> yields:
</span><pre>=&gt; Parse error at line 1, column 2:
x{a}
 ^
Expected one of:
&quot;{{&quot;
&quot;}&quot;
NOT &quot;{&quot;
</pre></div><div data-t="mlimotte Seems like the  x  got picked up by &lt;A&gt;.  I would have liked it to match !‘{’, so that the next char could match in &lt;OPEN&gt;"><span class="u" id="1533233574.000338">2018:08:02 18:12:54         mlimotte </span><span>Seems like the </span><code>x</code><span> got picked up by &lt;A&gt;.  I would have liked it to match !‘{’, so that the next char could match in &lt;OPEN&gt;</span></div><div data-t="aengelberg try changing the  OPEN  and  CLOSE  rules to
 &lt;OPEN&gt; = &apos;{&apos; !&apos;{&apos;
&lt;CLOSE&gt; = &apos;}&apos; !&apos;}&apos;
"><span class="u" id="1533233587.000172">2018:08:02 18:13:07       aengelberg </span><span>try changing the </span><code>OPEN</code><span> and </span><code>CLOSE</code><span> rules to
</span><pre>&lt;OPEN&gt; = &apos;{&apos; !&apos;{&apos;
&lt;CLOSE&gt; = &apos;}&apos; !&apos;}&apos;
</pre></div><div data-t="mlimotte 😄"><span class="u" id="1533233674.000506">2018:08:02 18:14:34         mlimotte </span><b>😄</b></div><div data-t="mlimotte That seems to work."><span class="u" id="1533233678.000449">2018:08:02 18:14:38         mlimotte </span><span>That seems to work.</span></div><div data-t="aengelberg The problem in the original grammar was that the negative lookahead was conflicting with the token itself. It was basically saying &quot;If there isn&apos;t an open bracket, please parse an open bracket&quot;"><span class="u" id="1533233710.000293">2018:08:02 18:15:10       aengelberg </span><span>The problem in the original grammar was that the negative lookahead was conflicting with the token itself. It was basically saying &quot;If there isn&apos;t an open bracket, please parse an open bracket&quot;</span></div><div data-t="aengelberg Whereas what you really want is &quot;Please parse an open bracket but only if there isn&apos;t another open bracket right after&quot;"><span class="u" id="1533233726.000439">2018:08:02 18:15:26       aengelberg </span><span>Whereas what you really want is &quot;Please parse an open bracket but only if there isn&apos;t another open bracket right after&quot;</span></div><div data-t="mlimotte hmm..  ok, i think that makes sense to me."><span class="u" id="1533233753.000503">2018:08:02 18:15:53         mlimotte </span><span>hmm..  ok, i think that makes sense to me.</span></div><div data-t="mlimotte Very cool.  Thanks for the quick help!"><span class="u" id="1533233766.000513">2018:08:02 18:16:06         mlimotte </span><span>Very cool.  Thanks for the quick help!</span></div><div data-t="aengelberg no problem"><span class="u" id="1533233772.000082">2018:08:02 18:16:12       aengelberg </span><span>no problem</span></div><div data-t="mlimotte Here’s an edge case that still fails.  But it’s a bit contrived, so if it’s not a trivial fix, I don’t need to worry about it.  
 (p &quot;{{y}&quot;)"><span class="u" id="1533233938.000506">2018:08:02 18:18:58         mlimotte </span><span>Here’s an edge case that still fails.  But it’s a bit contrived, so if it’s not a trivial fix, I don’t need to worry about it.  
</span><code>(p &quot;{{y}&quot;)</code></div><div data-t="aengelberg do you want that to parse as normal text?"><span class="u" id="1533233951.000332">2018:08:02 18:19:11       aengelberg </span><span>do you want that to parse as normal text?</span></div><div data-t="mlimotte yep"><span class="u" id="1533233961.000488">2018:08:02 18:19:21         mlimotte </span><span>yep</span></div><div data-t="mlimotte not a  block"><span class="u" id="1533233983.000336">2018:08:02 18:19:43         mlimotte </span><span>not a </span><code>block</code></div><div data-t="aengelberg maybe something like
 &lt;S&gt; = TXT*
block = &lt;&apos;{{&apos;&gt; TXT &lt;&apos;}}&apos;&gt;
&lt;TXT&gt; = (block / A)*
&lt;A&gt; = #&apos;[^{}]*&apos; | &apos;{&apos; | &apos;}&apos;
"><span class="u" id="1533234098.000386">2018:08:02 18:21:38       aengelberg </span><span>maybe something like
</span><pre>&lt;S&gt; = TXT*
block = &lt;&apos;{{&apos;&gt; TXT &lt;&apos;}}&apos;&gt;
&lt;TXT&gt; = (block / A)*
&lt;A&gt; = #&apos;[^{}]*&apos; | &apos;{&apos; | &apos;}&apos;
</pre></div><div data-t="aengelberg here I&apos;m changing the  A  rule to match any text (including brackets and double brackets) but then using the ordered choice (`/`) to prefer parsing complete blocks when possible."><span class="u" id="1533234147.000444">2018:08:02 18:22:27       aengelberg </span><span>here I&apos;m changing the </span><code>A</code><span> rule to match any text (including brackets and double brackets) but then using the ordered choice (`/`) to prefer parsing complete blocks when possible.</span></div><div data-t="mlimotte oh.. that’s great.  I had tried an approach like that previously, but didn’t know how to prefer one parse over another … that  /  operator is new to me."><span class="u" id="1533234281.000041">2018:08:02 18:24:41         mlimotte </span><span>oh.. that’s great.  I had tried an approach like that previously, but didn’t know how to prefer one parse over another … that </span><code>/</code><span> operator is new to me.</span></div><div data-t="aengelberg :+1:"><span class="u" id="1533234297.000363">2018:08:02 18:24:57       aengelberg </span><b>:+1:</b></div><div data-t="mlimotte thanks for your help, again"><span class="u" id="1533234328.000254">2018:08:02 18:25:28         mlimotte </span><span>thanks for your help, again</span></div><div data-t="aengelberg np"><span class="u" id="1533234333.000177">2018:08:02 18:25:33       aengelberg </span><span>np</span></div><div data-t="aengelberg"><span class="u" id="1535126314.000100">2018:08:24 15:58:34       aengelberg </span></div><div data-t="aengelberg @jeroenvandijk that grammar doesn&apos;t appear to be valid BNF; many of the string tokens are not properly quoted"><span class="u" id="1535126339.000100">2018:08:24 15:58:59       aengelberg </span><span>@jeroenvandijk that grammar doesn&apos;t appear to be valid BNF; many of the string tokens are not properly quoted</span></div><div data-t="aengelberg Also, instaparse has adopted the angle brackets  &lt;&gt;  to mean &quot;hiding tags&quot; (not an EBNF standard) but this AWS grammar uses them in all of the rule names, which might result in weird behavior"><span class="u" id="1535126419.000100">2018:08:24 16:00:19       aengelberg </span><span>Also, instaparse has adopted the angle brackets </span><code>&lt;&gt;</code><span> to mean &quot;hiding tags&quot; (not an EBNF standard) but this AWS grammar uses them in all of the rule names, which might result in weird behavior</span></div><div data-t="aengelberg for example
 &lt;condition_block&gt; = &quot;Condition&quot; : { &lt;condition_map&gt; }
 
should be
 condition_block = &quot;Condition&quot; &quot;:&quot; &quot;{&quot; condition_map &quot;}&quot;
"><span class="u" id="1535126441.000100">2018:08:24 16:00:41       aengelberg </span><span>for example
</span><pre>&lt;condition_block&gt; = &quot;Condition&quot; : { &lt;condition_map&gt; }
</pre><span>
should be
</span><pre>condition_block = &quot;Condition&quot; &quot;:&quot; &quot;{&quot; condition_map &quot;}&quot;
</pre></div><div data-t="hiredman my experience with instaparse, and other parsers for that matter, and external grammars, is pretty much no one provides complete grammars that are machine parseable."><span class="u" id="1535127732.000100">2018:08:24 16:22:12         hiredman </span><span>my experience with instaparse, and other parsers for that matter, and external grammars, is pretty much no one provides complete grammars that are machine parseable.</span></div><div data-t="hiredman it is incredibly frustrating to find out that, for example, the only grammar for the version 3 of the protobuf type description language available is incomplete and only published as fragments in &lt;pre&gt; blocks on the protobuf website"><span class="u" id="1535127896.000100">2018:08:24 16:24:56         hiredman </span><span>it is incredibly frustrating to find out that, for example, the only grammar for the version 3 of the protobuf type description language available is incomplete and only published as fragments in &lt;pre&gt; blocks on the protobuf website</span></div><div data-t="jeroenvandijk @aengelberg @hiredman interesting. I was hoping it to have a parser one copy paste away  🙂"><span class="u" id="1535356272.000100">2018:08:27 07:51:12    jeroenvandijk </span><span>@aengelberg @hiredman interesting. I was hoping it to have a parser one copy paste away </span><b>🙂</b></div><div data-t="jeroenvandijk When I remove the &apos;&lt;&gt;&apos;, instaparse is complaining over the use of  : ,  ...  and it is missing  condition_map . I think I have to do a proper investigation where this parser is being used to understand how it should work"><span class="u" id="1535356351.000200">2018:08:27 07:52:31    jeroenvandijk </span><span>When I remove the &apos;&lt;&gt;&apos;, instaparse is complaining over the use of </span><code>:</code><span>, </span><code>...</code><span> and it is missing </span><code>condition_map</code><span>. I think I have to do a proper investigation where this parser is being used to understand how it should work</span></div><div data-t="jeroenvandijk Thanks for your feedback"><span class="u" id="1535356364.000100">2018:08:27 07:52:44    jeroenvandijk </span><span>Thanks for your feedback</span></div><div data-t="aengelberg no problem"><span class="u" id="1535382432.000100">2018:08:27 15:07:12       aengelberg </span><span>no problem</span></div><div data-t="souenzzo There is some repo with a colaborative collection of useful/example grammars?"><span class="u" id="1536666918.000100">2018:09:11 11:55:18         souenzzo </span><span>There is some repo with a colaborative collection of useful/example grammars?</span></div><div data-t="aengelberg hmm not that I know of"><span class="u" id="1537376729.000100">2018:09:19 17:05:29       aengelberg </span><span>hmm not that I know of</span></div><div data-t="drone anyone know of an instaparse grammar for C? I’m checking out mcc ( https://github.com/zmaril/mcc ), but looks like it may be incomplete and bit-rotted"><span class="u" id="1537471332.000100">2018:09:20 19:22:12            drone </span><span>anyone know of an instaparse grammar for C? I’m checking out mcc (</span><a href="https://github.com/zmaril/mcc">https://github.com/zmaril/mcc</a><span>), but looks like it may be incomplete and bit-rotted</span></div><div data-t="aengelberg not that I&apos;m aware of"><span class="u" id="1537471366.000100">2018:09:20 19:22:46       aengelberg </span><span>not that I&apos;m aware of</span></div><div data-t="drone thanks"><span class="u" id="1537471394.000100">2018:09:20 19:23:14            drone </span><span>thanks</span></div><div data-t="schmee hey folks! I’m trying to write my first parser for a very simple file format. I’ve made it work, but my solution uses negative lookahead. Is there any way to write a grammar that produces the same output without negative lookahead? here a REPL example:"><span class="u" id="1540501436.000100">2018:10:25 21:03:56           schmee </span><span>hey folks! I’m trying to write my first parser for a very simple file format. I’ve made it work, but my solution uses negative lookahead. Is there any way to write a grammar that produces the same output without negative lookahead? here a REPL example:</span></div><div data-t="schmee user=&gt; (def s
   #_=&gt;   &quot;NAME=Thing 1
   #_=&gt; ACTIVE=120201-171231
   #_=&gt;
   #_=&gt; NAME=Thing 2
   #_=&gt; ACTIVE=120201-171231&quot;)
   #_=&gt;
#&apos;user/s

user=&gt; (def grammar
   #_=&gt;   (insta/parser
   #_=&gt;     &quot;top = (block &lt;newline?&gt;)+
   #_=&gt;      block = line+ !line
   #_=&gt;      line = key &lt;&apos;=&apos;&gt; value &lt;newline?&gt;
   #_=&gt;      key = #&apos;[A-Z]+&apos;
   #_=&gt;      value = #&apos;[^\n]*&apos;
   #_=&gt;      newline = &apos;\n&apos;&quot;))
   #_=&gt;
#&apos;user/grammar

user=&gt; (clojure.pprint/pprint (insta/parse grammar s))
[:top
 [:block
  [:line [:key &quot;NAME&quot;] [:value &quot;Thing 1&quot;]]
  [:line [:key &quot;ACTIVE&quot;] [:value &quot;120201-171231&quot;]]]
 [:block
  [:line [:key &quot;NAME&quot;] [:value &quot;Thing 2&quot;]]
  [:line [:key &quot;ACTIVE&quot;] [:value &quot;120201-171231&quot;]]]]
nil
"><span class="u" id="1540501440.000100">2018:10:25 21:04:00           schmee </span><pre>user=&gt; (def s
   #_=&gt;   &quot;NAME=Thing 1
   #_=&gt; ACTIVE=120201-171231
   #_=&gt;
   #_=&gt; NAME=Thing 2
   #_=&gt; ACTIVE=120201-171231&quot;)
   #_=&gt;
#&apos;user/s

user=&gt; (def grammar
   #_=&gt;   (insta/parser
   #_=&gt;     &quot;top = (block &lt;newline?&gt;)+
   #_=&gt;      block = line+ !line
   #_=&gt;      line = key &lt;&apos;=&apos;&gt; value &lt;newline?&gt;
   #_=&gt;      key = #&apos;[A-Z]+&apos;
   #_=&gt;      value = #&apos;[^\n]*&apos;
   #_=&gt;      newline = &apos;\n&apos;&quot;))
   #_=&gt;
#&apos;user/grammar

user=&gt; (clojure.pprint/pprint (insta/parse grammar s))
[:top
 [:block
  [:line [:key &quot;NAME&quot;] [:value &quot;Thing 1&quot;]]
  [:line [:key &quot;ACTIVE&quot;] [:value &quot;120201-171231&quot;]]]
 [:block
  [:line [:key &quot;NAME&quot;] [:value &quot;Thing 2&quot;]]
  [:line [:key &quot;ACTIVE&quot;] [:value &quot;120201-171231&quot;]]]]
nil
</pre></div><div data-t="schmee if there’s any other way to simplify it I’d love to hear about it  🙂"><span class="u" id="1540501699.000100">2018:10:25 21:08:19           schmee </span><span>if there’s any other way to simplify it I’d love to hear about it </span><b>🙂</b></div><div data-t="socksy I don&apos;t have a repl to hand, but couldn&apos;t you use a newline as a character separator rather than a negative look ahead for another line? "><span class="u" id="1541074394.000300">2018:11:01 12:13:14                socksy </span><span>I don&apos;t have a repl to hand, but couldn&apos;t you use a newline as a character separator rather than a negative look ahead for another line? </span></div><div data-t="Vincent Cantin Hello. I am starting to use instaparse, and I am matching the end of a multi-line string using  #&apos;\\Z&apos; . While it seems to work, is it the correct way to match it?"><span class="u" id="1542637203.001900">2018:11:19 14:20:03   Vincent Cantin </span><span>Hello. I am starting to use instaparse, and I am matching the end of a multi-line string using </span><code>#&apos;\\Z&apos;</code><span>. While it seems to work, is it the correct way to match it?</span></div><div data-t="aengelberg @vincent.cantin that seems like a legit approach to me; I&apos;d have to know more about your broader use case to know whether there&apos;s a more elegant overall approach."><span class="u" id="1542646403.003500">2018:11:19 16:53:23       aengelberg </span><span>@vincent.cantin that seems like a legit approach to me; I&apos;d have to know more about your broader use case to know whether there&apos;s a more elegant overall approach.</span></div><div data-t="aengelberg for example, you could use the instaparse negative lookahead feature (`!`) to determine whether there are no more tokens to match"><span class="u" id="1542646833.004100">2018:11:19 17:00:33       aengelberg </span><span>for example, you could use the instaparse negative lookahead feature (`!`) to determine whether there are no more tokens to match</span></div><div data-t="Vincent Cantin @aengelberg The context is: I am parsing a markdown document and I need to detect a line separator as either something based on \n and \r, or either the end of the document."><span class="u" id="1542706229.006000">2018:11:20 09:30:29   Vincent Cantin </span><span>@aengelberg The context is: I am parsing a markdown document and I need to detect a line separator as either something based on \n and \r, or either the end of the document.</span></div><div data-t="Vincent Cantin Thank you for the negative lookahead hint, I will try it."><span class="u" id="1542706310.007400">2018:11:20 09:31:50   Vincent Cantin </span><span>Thank you for the negative lookahead hint, I will try it.</span></div><div data-t="aengelberg @vincent.cantin you could maybe structure the parser as
 S = line (separator line)*
separator = &apos;\n&apos; | &apos;\r&apos;
 
then you don&apos;t have to explicitly check whether it reaches the end of the file."><span class="u" id="1542733918.008300">2018:11:20 17:11:58       aengelberg </span><span>@vincent.cantin you could maybe structure the parser as
</span><pre>S = line (separator line)*
separator = &apos;\n&apos; | &apos;\r&apos;
</pre><span>
then you don&apos;t have to explicitly check whether it reaches the end of the file.</span></div><div data-t="Vincent Cantin That would be doable, but it requires to adapt the full grammar for that."><span class="u" id="1542868881.014700">2018:11:22 06:41:21        Vincent Cantin </span><span>That would be doable, but it requires to adapt the full grammar for that.</span></div><div data-t="Vincent Cantin I am currently reading the CommonMark specification for parsing markdown format. Do you know if anybody already wrote such a parser with instaparse?"><span class="u" id="1542799378.011400">2018:11:21 11:22:58   Vincent Cantin </span><span>I am currently reading the CommonMark specification for parsing markdown format. Do you know if anybody already wrote such a parser with instaparse?</span></div><div data-t="Vincent Cantin I found this project but it is a simple version, not the full spec.  https://github.com/chameco/Hitman/blob/master/src/hitman/core.clj"><span class="u" id="1542799775.011900">2018:11:21 11:29:35   Vincent Cantin </span><span>I found this project but it is a simple version, not the full spec. </span><a href="https://github.com/chameco/Hitman/blob/master/src/hitman/core.clj">https://github.com/chameco/Hitman/blob/master/src/hitman/core.clj</a></div><div data-t="Vincent Cantin The reason I ask is that I am implementing one using instaparse. I just started recently, it’s called hiccdown."><span class="u" id="1542809623.012400">2018:11:21 14:13:43   Vincent Cantin </span><span>The reason I ask is that I am implementing one using instaparse. I just started recently, it’s called hiccdown.</span></div><div data-t="Vincent Cantin I found a strange behavior with  #&apos;\\Z&apos; , I wonder if it is a bug or if it is normal.

 ((insta/parser
   &quot;Paragraph = NonBlankLine+ BlankLine+
    BlankLine = #&apos;[ \\t]&apos;* EOL
    NonBlankLine = #&apos;\\S&apos;+ EOL
    EOL = (#&apos;\\n&apos; | EOF)
    EOF = #&apos;\\Z&apos;&quot;)
 &quot;abc\ndef\n&quot;)

=&gt; 
[:Paragraph
 [:NonBlankLine &quot;a&quot; &quot;b&quot; &quot;c&quot; [:EOL &quot;\n&quot;]]
 [:NonBlankLine &quot;d&quot; &quot;e&quot; &quot;f&quot; [:EOL [:EOF &quot;&quot;]]]
 [:BlankLine [:EOL &quot;\n&quot;]]]
"><span class="u" id="1542868512.013800">2018:11:22 06:35:12   Vincent Cantin </span><span>I found a strange behavior with </span><code>#&apos;\\Z&apos;</code><span>, I wonder if it is a bug or if it is normal.

</span><pre>((insta/parser
   &quot;Paragraph = NonBlankLine+ BlankLine+
    BlankLine = #&apos;[ \\t]&apos;* EOL
    NonBlankLine = #&apos;\\S&apos;+ EOL
    EOL = (#&apos;\\n&apos; | EOF)
    EOF = #&apos;\\Z&apos;&quot;)
 &quot;abc\ndef\n&quot;)

=&gt; 
[:Paragraph
 [:NonBlankLine &quot;a&quot; &quot;b&quot; &quot;c&quot; [:EOL &quot;\n&quot;]]
 [:NonBlankLine &quot;d&quot; &quot;e&quot; &quot;f&quot; [:EOL [:EOF &quot;&quot;]]]
 [:BlankLine [:EOL &quot;\n&quot;]]]
</pre></div><div data-t="Vincent Cantin EOF appears before  &quot;\n&quot;  in the parsed result."><span class="u" id="1542868623.014500">2018:11:22 06:37:03   Vincent Cantin </span><span>EOF appears before </span><code>&quot;\n&quot;</code><span> in the parsed result.</span></div><div data-t="Vincent Cantin This other approach which uses the negative lookahead does put the  &quot;\n&quot;  in the right place in the result, but there is another problem: The  BlankLine  is missing in the result. That may be a bug of instaparse. I am using the version  1.4.9 .

 ((insta/parser
   &quot;Paragraph = NonBlankLine+ BlankLine+
    BlankLine = #&apos;[ \\t]&apos;* EOL
    NonBlankLine = #&apos;\\S&apos;+ EOL
    EOL = (#&apos;\\n&apos; | EOF)
    EOF = !#&apos;.&apos;&quot;)
 &quot;abc\ndef\n&quot;)
=&gt;
[:Paragraph [:NonBlankLine &quot;a&quot; &quot;b&quot; &quot;c&quot; [:EOL &quot;\n&quot;]]
            [:NonBlankLine &quot;d&quot; &quot;e&quot; &quot;f&quot; [:EOL &quot;\n&quot;]]]
"><span class="u" id="1542869183.016600">2018:11:22 06:46:23   Vincent Cantin </span><span>This other approach which uses the negative lookahead does put the </span><code>&quot;\n&quot;</code><span> in the right place in the result, but there is another problem: The </span><code>BlankLine</code><span> is missing in the result. That may be a bug of instaparse. I am using the version </span><code>1.4.9</code><span>.

</span><pre>((insta/parser
   &quot;Paragraph = NonBlankLine+ BlankLine+
    BlankLine = #&apos;[ \\t]&apos;* EOL
    NonBlankLine = #&apos;\\S&apos;+ EOL
    EOL = (#&apos;\\n&apos; | EOF)
    EOF = !#&apos;.&apos;&quot;)
 &quot;abc\ndef\n&quot;)
=&gt;
[:Paragraph [:NonBlankLine &quot;a&quot; &quot;b&quot; &quot;c&quot; [:EOL &quot;\n&quot;]]
            [:NonBlankLine &quot;d&quot; &quot;e&quot; &quot;f&quot; [:EOL &quot;\n&quot;]]]
</pre></div><div data-t="Vincent Cantin I am going to use this workaround for now: append “EOF” at the end of the input and parse it. It works very well  🙂 
 ((insta/parser
   &quot;Paragraph = NonBlankLine+ BlankLine+
    BlankLine = #&apos;[ \\t]&apos;* EOL
    NonBlankLine = #&apos;\\S&apos;+ EOL
    EOL = (#&apos;\\n&apos; | EOF)
    EOF = &apos;EOF&apos; #&apos;\\Z&apos;&quot;) ; works as well with !#&apos;.&apos;
 &quot;abc\ndef\nEOF&quot;)
=&gt;
[:Paragraph
 [:NonBlankLine &quot;a&quot; &quot;b&quot; &quot;c&quot; [:EOL &quot;\n&quot;]]
 [:NonBlankLine &quot;d&quot; &quot;e&quot; &quot;f&quot; [:EOL &quot;\n&quot;]]
 [:BlankLine [:EOL [:EOF &quot;EOF&quot; &quot;&quot;]]]]
"><span class="u" id="1542870534.018300">2018:11:22 07:08:54   Vincent Cantin </span><span>I am going to use this workaround for now: append “EOF” at the end of the input and parse it. It works very well </span><b>🙂</b><span>
</span><pre>((insta/parser
   &quot;Paragraph = NonBlankLine+ BlankLine+
    BlankLine = #&apos;[ \\t]&apos;* EOL
    NonBlankLine = #&apos;\\S&apos;+ EOL
    EOL = (#&apos;\\n&apos; | EOF)
    EOF = &apos;EOF&apos; #&apos;\\Z&apos;&quot;) ; works as well with !#&apos;.&apos;
 &quot;abc\ndef\nEOF&quot;)
=&gt;
[:Paragraph
 [:NonBlankLine &quot;a&quot; &quot;b&quot; &quot;c&quot; [:EOL &quot;\n&quot;]]
 [:NonBlankLine &quot;d&quot; &quot;e&quot; &quot;f&quot; [:EOL &quot;\n&quot;]]
 [:BlankLine [:EOL [:EOF &quot;EOF&quot; &quot;&quot;]]]]
</pre></div><div data-t="SoV4 love instaparse"><span class="u" id="1542899976.018900">2018:11:22 15:19:36             SoV4 </span><span>love instaparse</span></div><div data-t="mattly is there a way to get line/column numbers associated with the tokens generated from instaparse?"><span class="u" id="1549309937.001300">2019:02:04 19:52:17           mattly </span><span>is there a way to get line/column numbers associated with the tokens generated from instaparse?</span></div><div data-t="aengelberg Yeah, check out  instaparse.line-col"><span class="u" id="1549310021.002100">2019:02:04 19:53:41       aengelberg </span><span>Yeah, check out </span><code>instaparse.line-col</code></div><div data-t="mattly yay!"><span class="u" id="1549310169.002300">2019:02:04 19:56:09           mattly </span><span>yay!</span></div><div data-t="mattly thanks"><span class="u" id="1549310171.002500">2019:02:04 19:56:11           mattly </span><span>thanks</span></div><div data-t="souenzzo it&apos;s just DATA"><span class="u" id="1549318658.002800">2019:02:04 22:17:38         souenzzo </span><span>it&apos;s just DATA</span></div><div data-t="aengelberg it&apos;s not code, it&apos;s DATA"><span class="u" id="1549318691.003000">2019:02:04 22:18:11       aengelberg </span><span>it&apos;s not code, it&apos;s DATA</span></div><div data-t="souenzzo is possible to write a grammar for clojure?
including things like  ^metadata  and  ;; comments"><span class="u" id="1558489406.000800">2019:05:22 01:43:26         souenzzo </span><span>is possible to write a grammar for clojure?
including things like </span><code>^metadata</code><span> and </span><code>;; comments</code></div><div data-t="aengelberg It should be possible, yes"><span class="u" id="1558987821.000300">2019:05:27 20:10:21       aengelberg </span><span>It should be possible, yes</span></div><div data-t="aengelberg I&apos;m not aware of any prior art"><span class="u" id="1558987829.000500">2019:05:27 20:10:29       aengelberg </span><span>I&apos;m not aware of any prior art</span></div><div data-t="aengelberg not to my knowledge, unless you count ClojureScript"><span class="u" id="1565990285.001700">2019:08:16 21:18:05       aengelberg </span><span>not to my knowledge, unless you count ClojureScript</span></div><div data-t="aengelberg the underlying engine is actually based on an existing algorithm called GLL, which was originally implemented in Racket  https://github.com/epsil/gll"><span class="u" id="1565990321.002200">2019:08:16 21:18:41       aengelberg </span><span>the underlying engine is actually based on an existing algorithm called GLL, which was originally implemented in Racket </span><a href="https://github.com/epsil/gll">https://github.com/epsil/gll</a></div><div data-t="aengelberg but being able to create parsers based on arbitrary EBNF specifications (rather than a language-specific DSL of combinators) I think is unique to instaparse"><span class="u" id="1565990408.003900">2019:08:16 21:20:08       aengelberg </span><span>but being able to create parsers based on arbitrary EBNF specifications (rather than a language-specific DSL of combinators) I think is unique to instaparse</span></div><div data-t="pepas yeah, I was so surprised when I started getting into parsers and no one seemed to take BNF as input"><span class="u" id="1565990453.004400">2019:08:16 21:20:53            pepas </span><span>yeah, I was so surprised when I started getting into parsers and no one seemed to take BNF as input</span></div><div data-t="pepas Huge kudos to you and your old man!"><span class="u" id="1565990462.004700">2019:08:16 21:21:02            pepas </span><span>Huge kudos to you and your old man!</span></div><div data-t="aengelberg thanks!"><span class="u" id="1565990467.004900">2019:08:16 21:21:07       aengelberg </span><span>thanks!</span></div><div data-t="hiredman is there I recommended way for dealing with C style comments like / ... / instagram parsers? I vaguely recall maybe trying to handle them with a custom whitespace rule, but it has been a long time"><span class="u" id="1566531802.006200">2019:08:23 03:43:22         hiredman </span><span>is there I recommended way for dealing with C style comments like / ... / instagram parsers? I vaguely recall maybe trying to handle them with a custom whitespace rule, but it has been a long time</span></div><div data-t="skelter I have a combination of a parser and a particular data file that causes the parser to consume CPU and memory until out of memory exception."><span class="u" id="1570984898.001200">2019:10:13 16:41:38          skelter </span><span>I have a combination of a parser and a particular data file that causes the parser to consume CPU and memory until out of memory exception.</span></div><div data-t="aengelberg that&apos;s not good"><span class="u" id="1571089622.001400">2019:10:14 21:47:02       aengelberg </span><span>that&apos;s not good</span></div><div data-t="skelter I think I now have it isolated to its own project, if you’d like a captured specimen."><span class="u" id="1571192275.002100">2019:10:16 02:17:55          skelter </span><span>I think I now have it isolated to its own project, if you’d like a captured specimen.</span></div><div data-t="aengelberg that would be great"><span class="u" id="1571192294.002300">2019:10:16 02:18:14       aengelberg </span><span>that would be great</span></div><div data-t="aengelberg github tickets also welcome"><span class="u" id="1571192301.002500">2019:10:16 02:18:21       aengelberg </span><span>github tickets also welcome</span></div><div data-t="skelter Not sure I want this particular specimen in the public pipeline.  Maybe if I can reduce it to something more comfortable."><span class="u" id="1571275889.003500">2019:10:17 01:31:29          skelter </span><span>Not sure I want this particular specimen in the public pipeline.  Maybe if I can reduce it to something more comfortable.</span></div><div data-t="skelter regarding the channel description line, what is a good example of trampolining a parser?"><span class="u" id="1571276492.004100">2019:10:17 01:41:32          skelter </span><span>regarding the channel description line, what is a good example of trampolining a parser?</span></div><div data-t="hiredman I suspect it is tongue in cheek, the internals of instaparse(and many gll parsers) use what you could call a trampoline to drive parsing"><span class="u" id="1571290567.006600">2019:10:17 05:36:07         hiredman </span><span>I suspect it is tongue in cheek, the internals of instaparse(and many gll parsers) use what you could call a trampoline to drive parsing</span></div><div data-t="aengelberg yeah, I think that came from a conversation with @gfredericks in which we discussed parsers generating parsers or some other unusual use case"><span class="u" id="1571295174.007400">2019:10:17 06:52:54       aengelberg </span><span>yeah, I think that came from a conversation with @gfredericks in which we discussed parsers generating parsers or some other unusual use case</span></div><div data-t="gfredericks Slander. I don&apos;t recall any such thing."><span class="u" id="1571438354.011000">2019:10:18 22:39:14      gfredericks </span><span>Slander. I don&apos;t recall any such thing.</span></div><div data-t="Daniel Hines Does there happen to exist a tool for taking an instaparse grammar and generating random strings with it?"><span class="u" id="1572354437.012000">2019:10:29 13:07:17     Daniel Hines </span><span>Does there happen to exist a tool for taking an instaparse grammar and generating random strings with it?</span></div><div data-t="aengelberg @d4hines the idea has been tossed around a couple times, but the only implementation I&apos;m aware of is my experiment  https://github.com/aengelberg/instagenerate  which isn&apos;t super useable in practice."><span class="u" id="1572414114.012900">2019:10:30 05:41:54       aengelberg </span><span>@d4hines the idea has been tossed around a couple times, but the only implementation I&apos;m aware of is my experiment </span><a href="https://github.com/aengelberg/instagenerate">https://github.com/aengelberg/instagenerate</a><span> which isn&apos;t super useable in practice.</span></div><div data-t="aengelberg My usage of core.logic was primarily motivated by a challenge to reverse-engineer output parse trees or fill in partial outputs. But if the main goal is to simply generate random inputs to a grammar (which most people really want), I think the implementation could be a lot cleaner, and leverage test.check."><span class="u" id="1572414386.016200">2019:10:30 05:46:26       aengelberg </span><span>My usage of core.logic was primarily motivated by a challenge to reverse-engineer output parse trees or fill in partial outputs. But if the main goal is to simply generate random inputs to a grammar (which most people really want), I think the implementation could be a lot cleaner, and leverage test.check.</span></div><div data-t="aengelberg The hardest part I think would be coming up with a good solution to lookahead and negative lookahead, while guaranteeing terminable generation..."><span class="u" id="1572414440.016900">2019:10:30 05:47:20       aengelberg </span><span>The hardest part I think would be coming up with a good solution to lookahead and negative lookahead, while guaranteeing terminable generation...</span></div><div data-t="Daniel Hines I&apos;m a noob when it comes to this stuff. Do you need lookahead for an EBNF grammar?"><span class="u" id="1572443134.022400">2019:10:30 13:45:34          Daniel Hines </span><span>I&apos;m a noob when it comes to this stuff. Do you need lookahead for an EBNF grammar?</span></div><div data-t="aengelberg I don’t think so, it’s just a nice feature that sometimes people take advantage of"><span class="u" id="1572622180.024900">2019:11:01 15:29:40            aengelberg </span><span>I don’t think so, it’s just a nice feature that sometimes people take advantage of</span></div><div data-t="Daniel Hines That&apos;s really cool!"><span class="u" id="1572439743.019500">2019:10:30 12:49:03     Daniel Hines </span><span>That&apos;s really cool!</span></div><div data-t="jeroenvandijk Maybe this project is relevant  https://github.com/cs-au-dk/dk.brics.automaton  ? We used it to generate data, also from regexps"><span class="u" id="1572440593.020700">2019:10:30 13:03:13    jeroenvandijk </span><span>Maybe this project is relevant </span><a href="https://github.com/cs-au-dk/dk.brics.automaton">https://github.com/cs-au-dk/dk.brics.automaton</a><span> ? We used it to generate data, also from regexps</span></div><div data-t="gfredericks When I wrote a generator for regexes I intentionally didn&apos;t try to support lookaheadbehinds"><span class="u" id="1572445657.023600">2019:10:30 14:27:37      gfredericks </span><span>When I wrote a generator for regexes I intentionally didn&apos;t try to support lookaheadbehinds</span></div><div data-t="gfredericks But it seems like something you could support with the same caveats as such-that"><span class="u" id="1572445692.024300">2019:10:30 14:28:12      gfredericks </span><span>But it seems like something you could support with the same caveats as such-that</span></div><div data-t="gfredericks (And have it fail the same way, rather than infinite loop)"><span class="u" id="1572445713.024800">2019:10:30 14:28:33      gfredericks </span><span>(And have it fail the same way, rather than infinite loop)</span></div><div data-t="Ahmad Nazir Raja Hi,
This is related to greedy behavior of instaparse. I have the following grammar:


 X := Y* Z*

Y := CHAR
Z := CHAR

CHAR := (&apos;a&apos; | &apos;b&apos; | &apos;c&apos;) 

With input  aaa  I get the output shown below. I expect greedy behavior and that Y should be matched instead of Z. Does anyone have an idea to why this happens or how to enforce greedy behavior?"><span class="u" id="1574769155.027700">2019:11:26 11:52:35 Ahmad Nazir Raja </span><span>Hi,
This is related to greedy behavior of instaparse. I have the following grammar:


</span><pre>X := Y* Z*

Y := CHAR
Z := CHAR

CHAR := (&apos;a&apos; | &apos;b&apos; | &apos;c&apos;)</pre><span>

With input </span><code>aaa</code><span> I get the output shown below. I expect greedy behavior and that Y should be matched instead of Z. Does anyone have an idea to why this happens or how to enforce greedy behavior?</span></div><div data-t="aengelberg @U82LVQ5NX sorry for the late reply, but instaparse doesn’t guarantee greediness or non-greediness; in fact, if you call  insta/parses  you will get every version of the parse including ones where  Y  is parsing some or all of the chars."><span class="u" id="1575398126.029300">2019:12:03 18:35:26            aengelberg </span><span>@U82LVQ5NX sorry for the late reply, but instaparse doesn’t guarantee greediness or non-greediness; in fact, if you call </span><code>insta/parses</code><span> you will get every version of the parse including ones where </span><code>Y</code><span> is parsing some or all of the chars.</span></div><div data-t="Ahmad Nazir Raja Yes, I tried  parses  and I could see all versions. For some reason I thought there would be a way to prefer one version over the other. Anyway, thanks for the response."><span class="u" id="1575398280.029500">2019:12:03 18:38:00      Ahmad Nazir Raja </span><span>Yes, I tried </span><code>parses</code><span> and I could see all versions. For some reason I thought there would be a way to prefer one version over the other. Anyway, thanks for the response.</span></div><div data-t="aengelberg You can achieve greediness by using negative lookahead:
 X := Y* !Y Z*"><span class="u" id="1575398282.029700">2019:12:03 18:38:02            aengelberg </span><span>You can achieve greediness by using negative lookahead:
</span><pre>X := Y* !Y Z*</pre></div><div data-t="aengelberg this ensures that it won’t start parsing Z until it can’t parse Y anymore."><span class="u" id="1575398307.029900">2019:12:03 18:38:27            aengelberg </span><span>this ensures that it won’t start parsing Z until it can’t parse Y anymore.</span></div><div data-t="Daniel Hines How do I read this?"><span class="u" id="1575397996.028300">2019:12:03 18:33:16     Daniel Hines </span><span>How do I read this?</span></div><div data-t="Daniel Hines"><span class="u" id="1575398035.028800">2019:12:03 18:33:55     Daniel Hines </span></div><div data-t="aengelberg I think the instaparse equivalent of this would be:
 remainder_sort_names := &apos;&apos; | &apos;,&apos; sort_name remainder_sorts"><span class="u" id="1575398422.030200">2019:12:03 18:40:22            aengelberg </span><span>I think the instaparse equivalent of this would be:
</span><pre>remainder_sort_names := &apos;&apos; | &apos;,&apos; sort_name remainder_sorts</pre></div><div data-t="Daniel Hines Oh! Duh! Epsilon!"><span class="u" id="1575398446.030400">2019:12:03 18:40:46          Daniel Hines </span><span>Oh! Duh! Epsilon!</span></div><div data-t="aengelberg although instaparse also supports  ε  as an alias for  &apos;&apos;"><span class="u" id="1575398450.030600">2019:12:03 18:40:50            aengelberg </span><span>although instaparse also supports </span><code>ε</code><span> as an alias for </span><code>&apos;&apos;</code></div><div data-t="Daniel Hines Noob fail. Thanks a bunch!"><span class="u" id="1575398480.030800">2019:12:03 18:41:20          Daniel Hines </span><span>Noob fail. Thanks a bunch!</span></div><div data-t="SoV4 Hi!  Why is it called a &quot;Context-Free&quot; Grammar?"><span class="u" id="1578168105.000600">2020:01:04 20:01:45             SoV4 </span><span>Hi!  Why is it called a &quot;Context-Free&quot; Grammar?</span></div><div data-t="SoV4 Isn&apos;t it nothing BUT context?"><span class="u" id="1578168111.000800">2020:01:04 20:01:51             SoV4 </span><span>Isn&apos;t it nothing BUT context?</span></div><div data-t="SoV4 😃"><span class="u" id="1578168138.001000">2020:01:04 20:02:18             SoV4 </span><b>😃</b></div><div data-t="gfredericks wikipedia says rules in a context-sensitive grammar take the form

α_A_β → αγβ"><span class="u" id="1578169011.001300">2020:01:04 20:16:51      gfredericks </span><span>wikipedia says rules in a context-sensitive grammar take the form

α_A_β → αγβ</span></div><div data-t="SoV4 Hmmm I seeeee.  Thank you @gfredericks"><span class="u" id="1578191828.001800">2020:01:05 02:37:08             SoV4 </span><span>Hmmm I seeeee.  Thank you @gfredericks</span></div><div data-t="hiredman I believe the terminology(and concepts) comes out of linguistics first (not cs) and was first used as a way to construct (or produce) all the strings in a language (a constructive definition of all the strings in a language). So context free comes from the fact that when you are using the grammar to construct strings you can apply the production rules anywhere they match without other restrictions"><span class="u" id="1578344123.007100">2020:01:06 20:55:23         hiredman </span><span>I believe the terminology(and concepts) comes out of linguistics first (not cs) and was first used as a way to construct (or produce) all the strings in a language (a constructive definition of all the strings in a language). So context free comes from the fact that when you are using the grammar to construct strings you can apply the production rules anywhere they match without other restrictions</span></div><div data-t="hiredman https://en.m.wikipedia.org/wiki/Generative_grammar"><span class="u" id="1578344311.007200">2020:01:06 20:58:31         hiredman </span><a href="https://en.m.wikipedia.org/wiki/Generative_grammar">https://en.m.wikipedia.org/wiki/Generative_grammar</a></div><div data-t="Adrian Smith https://i.imgur.com/G1xdp1F.png  In this example how do I make it so the identifiers rule matches anything until the next rule along is valid?"><span class="u" id="1579966059.000700">2020:01:25 15:27:39     Adrian Smith </span><a href="https://i.imgur.com/G1xdp1F.png">https://i.imgur.com/G1xdp1F.png</a><span> In this example how do I make it so the identifiers rule matches anything until the next rule along is valid?</span></div><div data-t="Adrian Smith ah I see it kind of explains this in  https://github.com/Engelberg/instaparse#regular-expressions-a-word-of-warning"><span class="u" id="1579966289.001300">2020:01:25 15:31:29     Adrian Smith </span><span>ah I see it kind of explains this in </span><a href="https://github.com/Engelberg/instaparse#regular-expressions-a-word-of-warning">https://github.com/Engelberg/instaparse#regular-expressions-a-word-of-warning</a></div><div data-t="Adrian Smith how would you go about writing a grammer for SQL columns? where commas must appear between elements"><span class="u" id="1580043765.002100">2020:01:26 13:02:45     Adrian Smith </span><span>how would you go about writing a grammer for SQL columns? where commas must appear between elements</span></div><div data-t="mmeix New to Instaparse and wrapping my head around grammars: how would I write a grammar that can do nested tag pairs like in xml:  &quot;&lt;p&gt;&lt;span&gt;text&lt;/span&gt;&lt;/p&gt;&quot; =&gt; [:p [:span text]]  ?"><span class="u" id="1582276769.007900">2020:02:21 09:19:29            mmeix </span><span>New to Instaparse and wrapping my head around grammars: how would I write a grammar that can do nested tag pairs like in xml: </span><code>&quot;&lt;p&gt;&lt;span&gt;text&lt;/span&gt;&lt;/p&gt;&quot; =&gt; [:p [:span text]]</code><span> ?</span></div><div data-t="aengelberg it’s possible to parse XML hierarchies into Clojure data, however I don’t think you can enforce that the tags must be matching."><span class="u" id="1582763876.005000">2020:02:27 00:37:56            aengelberg </span><span>it’s possible to parse XML hierarchies into Clojure data, however I don’t think you can enforce that the tags must be matching.</span></div><div data-t="aengelberg You can enforce that manually with your own custom logic after the fact, just not as part of the parser."><span class="u" id="1582763916.005300">2020:02:27 00:38:36            aengelberg </span><span>You can enforce that manually with your own custom logic after the fact, just not as part of the parser.</span></div><div data-t="mmeix So I would just trust, that tags are properly matched/paired/nested."><span class="u" id="1582822980.014000">2020:02:27 17:03:00                 mmeix </span><span>So I would just trust, that tags are properly matched/paired/nested.</span></div><div data-t="mmeix and take each closing tag as the next needed"><span class="u" id="1582823026.014200">2020:02:27 17:03:46                 mmeix </span><span>and take each closing tag as the next needed</span></div><div data-t="manutter51 caveat: I haven’t had my coffee yet, but the basic idea is that you say something like “a BLOCK element is a P or a DIV or a TABLE (etc), an INLINE element is a SPAN or a B or TEXT (etc),” and then say “a P element is the literal string ‘&lt;P&gt;’ or ‘&lt;p&gt;’ followed by zero or more INLINE elements, followed by the literal string ‘&lt;/P&gt;’ or ‘&lt;/p&gt;’.” And similarly with SPAN."><span class="u" id="1582288244.011400">2020:02:21 12:30:44       manutter51 </span><span>caveat: I haven’t had my coffee yet, but the basic idea is that you say something like “a BLOCK element is a P or a DIV or a TABLE (etc), an INLINE element is a SPAN or a B or TEXT (etc),” and then say “a P element is the literal string ‘&lt;P&gt;’ or ‘&lt;p&gt;’ followed by zero or more INLINE elements, followed by the literal string ‘&lt;/P&gt;’ or ‘&lt;/p&gt;’.” And similarly with SPAN.</span></div><div data-t="mmeix ah! thanks ... that should start it"><span class="u" id="1582290696.012100">2020:02:21 13:11:36            mmeix </span><span>ah! thanks ... that should start it</span></div><div data-t="manutter51 The other caveat is that Instaparse is incredibly fun to work with and may be addictive.  😉"><span class="u" id="1582290832.012700">2020:02:21 13:13:52       manutter51 </span><span>The other caveat is that Instaparse is incredibly fun to work with and may be addictive. </span><b>😉</b></div><div data-t="mmeix Confirmed!  😁"><span class="u" id="1582295549.013100">2020:02:21 14:32:29            mmeix </span><span>Confirmed! </span><b>😁</b></div><div data-t="SoV4 @mmeix it looks to me at first glance that you could make some rules
span = &lt;span&gt; val &lt;/span&gt;
paragraph = &lt;p&gt; val &lt;/p&gt;
val = paragraph* | span* | val
[editS: added stars to p and span in val]"><span class="u" id="1582820543.006500">2020:02:27 16:22:23             SoV4 </span><span>@mmeix it looks to me at first glance that you could make some rules
span = &lt;span&gt; val &lt;/span&gt;
paragraph = &lt;p&gt; val &lt;/p&gt;
val = paragraph* | span* | val
[editS: added stars to p and span in val]</span></div><div data-t="SoV4 the last rule allows recursion, which can infinitely nest spans or p&apos;s"><span class="u" id="1582820559.006900">2020:02:27 16:22:39             SoV4 </span><span>the last rule allows recursion, which can infinitely nest spans or p&apos;s</span></div><div data-t="SoV4 notice how i defined the rigid components of the grammar on the right-hand side, with my variable, and how i use variable names only on the left-hand side."><span class="u" id="1582820579.007400">2020:02:27 16:22:59             SoV4 </span><span>notice how i defined the rigid components of the grammar on the right-hand side, with my variable, and how i use variable names only on the left-hand side.</span></div><div data-t="mmeix That looks like a good recipe. Thanks!"><span class="u" id="1582820850.007700">2020:02:27 16:27:30            mmeix </span><span>That looks like a good recipe. Thanks!</span></div><div data-t="SoV4 @mmeix  http://instaparse-live.matt.is/#/-M16TrdGzPQ0FFLRyCyd/v1"><span class="u" id="1582820991.008400">2020:02:27 16:29:51             SoV4 </span><span>@mmeix </span><a href="http://instaparse-live.matt.is/#/-M16TrdGzPQ0FFLRyCyd/v1">http://instaparse-live.matt.is/#/-M16TrdGzPQ0FFLRyCyd/v1</a></div><div data-t="SoV4 i had to make sure it works before setting you out"><span class="u" id="1582821007.008800">2020:02:27 16:30:07             SoV4 </span><span>i had to make sure it works before setting you out</span></div><div data-t="SoV4 notice how there can be multiple valid parses with the recursion now."><span class="u" id="1582821033.009300">2020:02:27 16:30:33             SoV4 </span><span>notice how there can be multiple valid parses with the recursion now.</span></div><div data-t="SoV4 you&apos;ll probably need to be creative with the output to get rid of tags you don&apos;t need  😃   i forget exactly how we would delete unnecessary strings in the grammar itself, there&apos;s a way with rules i think, it might just be mathematical though lol"><span class="u" id="1582821167.010400">2020:02:27 16:32:47             SoV4 </span><span>you&apos;ll probably need to be creative with the output to get rid of tags you don&apos;t need </span><b>😃</b><span>  i forget exactly how we would delete unnecessary strings in the grammar itself, there&apos;s a way with rules i think, it might just be mathematical though lol</span></div><div data-t="mmeix Getting rid of tags is done by enclosing them with &lt;…&gt;"><span class="u" id="1582822160.011100">2020:02:27 16:49:20            mmeix </span><span>Getting rid of tags is done by enclosing them with &lt;…&gt;</span></div><div data-t="mmeix Thanks for the gist!"><span class="u" id="1582822178.011500">2020:02:27 16:49:38            mmeix </span><span>Thanks for the gist!</span></div><div data-t="mmeix Now I’m thinking, if it would be possible to get a general solution without enumerating all possible tags (span, p , …). It would need to somehow remember the tag name until its closing cousin arrives"><span class="u" id="1582822312.013400">2020:02:27 16:51:52            mmeix </span><span>Now I’m thinking, if it would be possible to get a general solution without enumerating all possible tags (span, p , …). It would need to somehow remember the tag name until its closing cousin arrives</span></div><div data-t="mmeix Didn’t know  http://instaparse-live.matt.is  ! Great tool!"><span class="u" id="1582822396.013800">2020:02:27 16:53:16            mmeix </span><span>Didn’t know </span><a href="http://instaparse-live.matt.is">http://instaparse-live.matt.is</a><span> ! Great tool!</span></div><div data-t="SoV4 @mmeix i think you probably want to parse this into a tree and go over it tree-style if you need opening/closing tag harmony.  using a CFG to do that might be possible but it&apos;s more for orientable sequences.

in reality if you wanted to you could just run over that thing wit a regex and make opening tags [: and closing tags ], throwing away &lt;/span&gt; and &lt;/p&gt; in favor of ]

i would definitely write some sample input, some sample output, and then see what tool is best for the job.  instaparse is indeed powerful, i used it to create an EBNF grammar representation of Japanese.
 https://learn-japanese.org/2020/01/04/japanese-grammar-in-ebnf-notation/"><span class="u" id="1582909209.018900">2020:02:28 17:00:09             SoV4 </span><span>@mmeix i think you probably want to parse this into a tree and go over it tree-style if you need opening/closing tag harmony.  using a CFG to do that might be possible but it&apos;s more for orientable sequences.

in reality if you wanted to you could just run over that thing wit a regex and make opening tags [: and closing tags ], throwing away &lt;/span&gt; and &lt;/p&gt; in favor of ]

i would definitely write some sample input, some sample output, and then see what tool is best for the job.  instaparse is indeed powerful, i used it to create an EBNF grammar representation of Japanese.
</span><a href="https://learn-japanese.org/2020/01/04/japanese-grammar-in-ebnf-notation/">https://learn-japanese.org/2020/01/04/japanese-grammar-in-ebnf-notation/</a></div><div data-t="bmaddy I have a question about how to do something in Instaparse. Imagine a string like this:
 3 1 John 0 2 Jane 2 1 3 3 Bob 0 
The first number is the number of people. Then, for each person, an id, name, number of people they supervise, and list of ids for the people they supervise. So in that example string there are 3 people. Jane (id = 2) supervises John (id = 1) and Bob (id = 3). Can I use Instaparse to parse stuff like that? Specifically, I&apos;m wondering how to read a number n and parse exactly n items after that."><span class="u" id="1583380381.020000">2020:03:05 03:53:01           bmaddy </span><span>I have a question about how to do something in Instaparse. Imagine a string like this:
</span><pre>3 1 John 0 2 Jane 2 1 3 3 Bob 0</pre><span>
The first number is the number of people. Then, for each person, an id, name, number of people they supervise, and list of ids for the people they supervise. So in that example string there are 3 people. Jane (id = 2) supervises John (id = 1) and Bob (id = 3). Can I use Instaparse to parse stuff like that? Specifically, I&apos;m wondering how to read a number n and parse exactly n items after that.</span></div><div data-t="aengelberg sadly Instaparse isn&apos;t well suited for situations where you parse a thing and then use that as an input to some later part of the same parser."><span class="u" id="1583382587.021000">2020:03:05 04:29:47       aengelberg </span><span>sadly Instaparse isn&apos;t well suited for situations where you parse a thing and then use that as an input to some later part of the same parser.</span></div><div data-t="bmaddy Sounds good. Thank you!"><span class="u" id="1583382642.021300">2020:03:05 04:30:42           bmaddy </span><span>Sounds good. Thank you!</span></div><div data-t="zane Out of curiosity, what would be better suited for situations like that?"><span class="u" id="1583429333.021600">2020:03:05 17:28:53             zane </span><span>Out of curiosity, what would be better suited for situations like that?</span></div><div data-t="thom https://github.com/youngnh/parsatron  might be a better fit"><span class="u" id="1583444600.022100">2020:03:05 21:43:20             thom </span><a href="https://github.com/youngnh/parsatron">https://github.com/youngnh/parsatron</a><span> might be a better fit</span></div><div data-t="thom if you have a look at the way  let-&gt;&gt;  can be used in  https://github.com/youngnh/parsatron/blob/master/doc/guide.markdown"><span class="u" id="1583444647.022600">2020:03:05 21:44:07             thom </span><span>if you have a look at the way </span><code>let-&gt;&gt;</code><span> can be used in </span><a href="https://github.com/youngnh/parsatron/blob/master/doc/guide.markdown">https://github.com/youngnh/parsatron/blob/master/doc/guide.markdown</a></div><div data-t="SoV4 does one have to do anything special to use instaparse on the clientside (cljs) ?"><span class="u" id="1586607236.012200">2020:04:11 12:13:56             SoV4 </span><span>does one have to do anything special to use instaparse on the clientside (cljs) ?</span></div><div data-t="gfredericks I used it in  https://gfredericks.com/things/bespoke-primes 

I don&apos;t remember doing anything special but that doesn&apos;t mean very much"><span class="u" id="1586617312.012900">2020:04:11 15:01:52      gfredericks </span><span>I used it in </span><a href="https://gfredericks.com/things/bespoke-primes">https://gfredericks.com/things/bespoke-primes</a><span>

I don&apos;t remember doing anything special but that doesn&apos;t mean very much</span></div><div data-t="SoV4 sweetness.  looks like it should work outta da box!"><span class="u" id="1586644286.013200">2020:04:11 22:31:26             SoV4 </span><span>sweetness.  looks like it should work outta da box!</span></div><div data-t="zane Can confirm, does work outta da box.  :+1: :skin-tone-2:"><span class="u" id="1586826485.014000">2020:04:14 01:08:05             zane </span><span>Can confirm, does work outta da box. </span><b>:+1:</b><b>:skin-tone-2:</b></div><div data-t="zane I&apos;m curious how often folks wind up using records (vs other alternatives) when writing polymorphic transformation functions for their instaparse parse trees."><span class="u" id="1586888373.014900">2020:04:14 18:19:33             zane </span><span>I&apos;m curious how often folks wind up using records (vs other alternatives) when writing polymorphic transformation functions for their instaparse parse trees.</span></div><div data-t="zane Judging from the  README  there doesn&apos;t appear to be a (public) function to get a data representation of an Instaparse grammar, but could someone confirm?"><span class="u" id="1587066989.015100">2020:04:16 19:56:29             zane </span><span>Judging from the </span><code>README</code><span> there doesn&apos;t appear to be a (public) function to get a data representation of an Instaparse grammar, but could someone confirm?</span></div><div data-t="gfredericks I was wanting that recently but I can&apos;t remember if it was for a good reason"><span class="u" id="1587079469.015500">2020:04:16 23:24:29      gfredericks </span><span>I was wanting that recently but I can&apos;t remember if it was for a good reason</span></div><div data-t="zane I&apos;m wanting to generate documentation, but perhaps there&apos;s a better way to go about that."><span class="u" id="1587147502.015800">2020:04:17 18:18:22             zane </span><span>I&apos;m wanting to generate documentation, but perhaps there&apos;s a better way to go about that.</span></div><div data-t="SoV4 Hi everyone, I&apos;m interesting in dynamically defining grammar components.  I have a big list of nouns, I&apos;d like to incorporate them into my grammar without too much crazy.  Is there some way I can add in a dynamic rule with something like nouns = coll?"><span class="u" id="1590602735.017800">2020:05:27 18:05:35             SoV4 </span><span>Hi everyone, I&apos;m interesting in dynamically defining grammar components.  I have a big list of nouns, I&apos;d like to incorporate them into my grammar without too much crazy.  Is there some way I can add in a dynamic rule with something like nouns = coll?</span></div><div data-t="aengelberg You probably want  instaparse.combinators"><span class="u" id="1590602753.018100">2020:05:27 18:05:53       aengelberg </span><span>You probably want </span><code>instaparse.combinators</code></div><div data-t="SoV4 thanks!"><span class="u" id="1590602799.018400">2020:05:27 18:06:39             SoV4 </span><span>thanks!</span></div><div data-t="SoV4 i shall take a gander"><span class="u" id="1590602812.018600">2020:05:27 18:06:52             SoV4 </span><span>i shall take a gander</span></div><div data-t="aengelberg https://github.com/engelberg/instaparse#combinators"><span class="u" id="1590602834.018800">2020:05:27 18:07:14       aengelberg </span><a href="https://github.com/engelberg/instaparse#combinators">https://github.com/engelberg/instaparse#combinators</a></div><div data-t="SoV4 Would it be ok to do something like  (str/join &quot;|&quot; nouns-seq)   in the grammar def"><span class="u" id="1590602864.019300">2020:05:27 18:07:44             SoV4 </span><span>Would it be ok to do something like </span><code>(str/join &quot;|&quot; nouns-seq) </code><span> in the grammar def</span></div><div data-t="aengelberg that might be more error-prone and hard to read, but it wouldn’t be more or less efficient than the combinator version"><span class="u" id="1590602905.019800">2020:05:27 18:08:25       aengelberg </span><span>that might be more error-prone and hard to read, but it wouldn’t be more or less efficient than the combinator version</span></div><div data-t="SoV4 Okay cool"><span class="u" id="1590602942.020600">2020:05:27 18:09:02             SoV4 </span><span>Okay cool</span></div><div data-t="aengelberg How many nouns are we talking? I’d be wary of putting too many into a parser rule"><span class="u" id="1590602966.021300">2020:05:27 18:09:26       aengelberg </span><span>How many nouns are we talking? I’d be wary of putting too many into a parser rule</span></div><div data-t="aengelberg Because to parse text that satisfies the rule, it ultimately has to iterate through every option at every point in your text that could potentially be a noun"><span class="u" id="1590603011.022000">2020:05:27 18:10:11       aengelberg </span><span>Because to parse text that satisfies the rule, it ultimately has to iterate through every option at every point in your text that could potentially be a noun</span></div><div data-t="aengelberg And if you pass a string to the parser that doesn’t successfully parse, the “failure” message will be really long"><span class="u" id="1590603079.022400">2020:05:27 18:11:19       aengelberg </span><span>And if you pass a string to the parser that doesn’t successfully parse, the “failure” message will be really long</span></div><div data-t="SoV4 I&apos;m using about 5-20 nouns"><span class="u" id="1590603132.022900">2020:05:27 18:12:12             SoV4 </span><span>I&apos;m using about 5-20 nouns</span></div><div data-t="aengelberg ah ok, that’s definitely manageable"><span class="u" id="1590603144.023200">2020:05:27 18:12:24       aengelberg </span><span>ah ok, that’s definitely manageable</span></div><div data-t="SoV4 I&apos;m trying to just do string join on the nouns list I have, but they lose their quotes"><span class="u" id="1590603181.023900">2020:05:27 18:13:01             SoV4 </span><span>I&apos;m trying to just do string join on the nouns list I have, but they lose their quotes</span></div><div data-t="aengelberg maybe  (apply str/join &quot;|&quot; (map #(str &quot;&apos;&quot; % &quot;&apos;&quot;) nouns-seq))"><span class="u" id="1590603212.024400">2020:05:27 18:13:32       aengelberg </span><span>maybe </span><code>(apply str/join &quot;|&quot; (map #(str &quot;&apos;&quot; % &quot;&apos;&quot;) nouns-seq))</code></div><div data-t="SoV4 ah beautiful"><span class="u" id="1590603243.024600">2020:05:27 18:14:03             SoV4 </span><span>ah beautiful</span></div><div data-t="SoV4 thank you very much"><span class="u" id="1590603245.024800">2020:05:27 18:14:05             SoV4 </span><span>thank you very much</span></div><div data-t="SoV4 almost perfect, it gives me a (&apos;list&apos; &apos;of&apos; &apos;nouns&apos;) .. not sure how to make it digestible for the parser"><span class="u" id="1590603570.025700">2020:05:27 18:19:30             SoV4 </span><span>almost perfect, it gives me a (&apos;list&apos; &apos;of&apos; &apos;nouns&apos;) .. not sure how to make it digestible for the parser</span></div><div data-t="aengelberg I think that’s where the  apply str/join  comes in"><span class="u" id="1590603587.026000">2020:05:27 18:19:47       aengelberg </span><span>I think that’s where the </span><code>apply str/join</code><span> comes in</span></div><div data-t="aengelberg oops, I was wrong, you don’t need  apply"><span class="u" id="1590603617.026200">2020:05:27 18:20:17       aengelberg </span><span>oops, I was wrong, you don’t need </span><code>apply</code></div><div data-t="aengelberg just  (str/join &quot;|&quot; …)"><span class="u" id="1590603629.026600">2020:05:27 18:20:29       aengelberg </span><span>just </span><code>(str/join &quot;|&quot; …)</code></div><div data-t="SoV4 Excellent!  Thank you."><span class="u" id="1590603733.026800">2020:05:27 18:22:13             SoV4 </span><span>Excellent!  Thank you.</span></div><div data-t="SoV4 I&apos;m looking forward to showing you guys what I&apos;ve come up with, once it&apos;s done!  😃"><span class="u" id="1590603748.027100">2020:05:27 18:22:28             SoV4 </span><span>I&apos;m looking forward to showing you guys what I&apos;ve come up with, once it&apos;s done! </span><b>😃</b></div><div data-t="aengelberg can’t wait to see!"><span class="u" id="1590603757.027400">2020:05:27 18:22:37       aengelberg </span><span>can’t wait to see!</span></div><div data-t="SoV4 it&apos;s a great wonder to have the power of magic at your fingertips!  😄"><span class="u" id="1590603812.028100">2020:05:27 18:23:32             SoV4 </span><span>it&apos;s a great wonder to have the power of magic at your fingertips! </span><b>😄</b></div><div data-t="SoV4 I keep ending up with a vector although I would like to use a map... I don&apos;t know if it&apos;s clojurescript"><span class="u" id="1590606125.028600">2020:05:27 19:02:05             SoV4 </span><span>I keep ending up with a vector although I would like to use a map... I don&apos;t know if it&apos;s clojurescript</span></div><div data-t="aengelberg you mean for the input or the output?"><span class="u" id="1590606151.029000">2020:05:27 19:02:31       aengelberg </span><span>you mean for the input or the output?</span></div><div data-t="SoV4 the output of insta/parse"><span class="u" id="1590606209.029400">2020:05:27 19:03:29             SoV4 </span><span>the output of insta/parse</span></div><div data-t="aengelberg you can set  :output-format :enlive  to get a map out of the parser"><span class="u" id="1590606217.029600">2020:05:27 19:03:37       aengelberg </span><span>you can set </span><code>:output-format :enlive</code><span> to get a map out of the parser</span></div><div data-t="SoV4 wizardry"><span class="u" id="1590606243.029800">2020:05:27 19:04:03             SoV4 </span><span>wizardry</span></div><div data-t="SoV4 Hmm, not bad, but it has :tag and :content, I could do with simply swapping  [] with {}"><span class="u" id="1590606491.030400">2020:05:27 19:08:11             SoV4 </span><span>Hmm, not bad, but it has :tag and :content, I could do with simply swapping  [] with {}</span></div><div data-t="SoV4 Thanks for all the help, I&apos;ll scratch around"><span class="u" id="1590606717.030700">2020:05:27 19:11:57             SoV4 </span><span>Thanks for all the help, I&apos;ll scratch around</span></div><div data-t="SoV4 Can instaparse flatten a recursive structure with a rule?"><span class="u" id="1590621357.031500">2020:05:27 23:15:57             SoV4 </span><span>Can instaparse flatten a recursive structure with a rule?</span></div><div data-t="SoV4 Hi.  I finished what I was working on.  Phase one, anyway."><span class="u" id="1590685025.031800">2020:05:28 16:57:05             SoV4 </span><span>Hi.  I finished what I was working on.  Phase one, anyway.</span></div><div data-t="SoV4 A few months ago we created a tool that lets people input Japanese by clicking on boxes.  Nouns, verbs, particles (grammar words in Japanese that mark grammatical role of a term).
It&apos;s a useful teaching and learning tool.  Students can create a native-Japanese composition with a tool that respects the basic grammar rules.
I thought it might be possible to generate an English translation in real-time of the Japanese a student was generating.  Turns out, it is!  Turns out, Instaparse is super powerful and I was able to use some grammar and EBNF insights from January to work it into a real-time translation tool.
Here&apos;s a brief gif, you can see it in Action."><span class="u" id="1590685194.034300">2020:05:28 16:59:54             SoV4 </span><span>A few months ago we created a tool that lets people input Japanese by clicking on boxes.  Nouns, verbs, particles (grammar words in Japanese that mark grammatical role of a term).
It&apos;s a useful teaching and learning tool.  Students can create a native-Japanese composition with a tool that respects the basic grammar rules.
I thought it might be possible to generate an English translation in real-time of the Japanese a student was generating.  Turns out, it is!  Turns out, Instaparse is super powerful and I was able to use some grammar and EBNF insights from January to work it into a real-time translation tool.
Here&apos;s a brief gif, you can see it in Action.</span></div><div data-t="SoV4 And here are some still shots to help show what&apos;s happening:  A generated Japanese phrase is parsed, smushed, and sequenced into Plain &apos;Ainglish.  This composition was made by a student! =)"><span class="u" id="1590685271.035500">2020:05:28 17:01:11             SoV4 </span><span>And here are some still shots to help show what&apos;s happening:  A generated Japanese phrase is parsed, smushed, and sequenced into Plain &apos;Ainglish.  This composition was made by a student! =)</span></div><div data-t="SoV4 Thanks a lot for Instaparse!  😄  You can do magical things indistinguishable from magic."><span class="u" id="1590685426.036300">2020:05:28 17:03:46             SoV4 </span><span>Thanks a lot for Instaparse! </span><b>😄</b><span> You can do magical things indistinguishable from magic.</span></div><div data-t="mrchance Hi! If instaparse parses a string in Clojure but fails to do the same in cljs with an identical grammar, what&apos;s a good place to start debugging?"><span class="u" id="1594852166.037600">2020:07:15 22:29:26         mrchance </span><span>Hi! If instaparse parses a string in Clojure but fails to do the same in cljs with an identical grammar, what&apos;s a good place to start debugging?</span></div><div data-t="aengelberg instaparse defers to the host language when it comes to regex syntax, so if you have a  #&quot;…&quot;  in your grammar that might be a good place to start"><span class="u" id="1594852223.038600">2020:07:15 22:30:23       aengelberg </span><span>instaparse defers to the host language when it comes to regex syntax, so if you have a </span><code>#&quot;…&quot;</code><span> in your grammar that might be a good place to start</span></div><div data-t="mrchance Aha! I do, will check that, thanks"><span class="u" id="1594852262.039000">2020:07:15 22:31:02         mrchance </span><span>Aha! I do, will check that, thanks</span></div><div data-t="mrchance Got it, it was Javas  [^]+]  vs. JS&apos;  [^\]+]  , thanks again  🙂 
Writing the parser was a breeze btw!"><span class="u" id="1594852920.040100">2020:07:15 22:42:00         mrchance </span><span>Got it, it was Javas </span><code>[^]+]</code><span> vs. JS&apos; </span><code>[^\]+]</code><span> , thanks again </span><b>🙂</b><span>
Writing the parser was a breeze btw!</span></div><div data-t="aengelberg nice! cool to hear that, thx"><span class="u" id="1594852942.040600">2020:07:15 22:42:22       aengelberg </span><span>nice! cool to hear that, thx</span></div><div data-t="scarrucciu Hello all, is there a way to match on a value, but still use that value for a downstream rule? For example have a string that looks like  &quot;ABC*123~EFG*456~HIJ*789&quot;   and I would want to nest down a level when I see ABC and HIJ, but I also want to parse the ABC and HIJ are part of the regular segment structure that is using the ~ as the delim"><span class="u" id="1597373020.003900">2020:08:14 02:43:40       scarrucciu </span><span>Hello all, is there a way to match on a value, but still use that value for a downstream rule? For example have a string that looks like </span><code>&quot;ABC*123~EFG*456~HIJ*789&quot;</code><span>  and I would want to nest down a level when I see ABC and HIJ, but I also want to parse the ABC and HIJ are part of the regular segment structure that is using the ~ as the delim</span></div><div data-t="aengelberg Would the lookahead feature help?"><span class="u" id="1597373091.004300">2020:08:14 02:44:51            aengelberg </span><span>Would the lookahead feature help?</span></div><div data-t="scarrucciu was thinking that, would that allow me to essentially parse prospectively without actually pulling the value? Will try it now"><span class="u" id="1597373143.004500">2020:08:14 02:45:43            scarrucciu </span><span>was thinking that, would that allow me to essentially parse prospectively without actually pulling the value? Will try it now</span></div><div data-t="scarrucciu that worked! and was way to simple. Thanks for the quick reply"><span class="u" id="1597373216.004700">2020:08:14 02:46:56            scarrucciu </span><span>that worked! and was way to simple. Thanks for the quick reply</span></div><div data-t="jeremys Hi, I was wondering, is there a way to force instaparse to throw an error instead of backtracking and exploring another parse solution ?"><span class="u" id="1601558015.001600">2020:10:01 13:13:35          jeremys </span><span>Hi, I was wondering, is there a way to force instaparse to throw an error instead of backtracking and exploring another parse solution ?</span></div><div data-t="hiredman If your grammar can be expressed without alternatives then you don&apos;t need a parsing library"><span class="u" id="1601569390.002600">2020:10:01 16:23:10         hiredman </span><span>If your grammar can be expressed without alternatives then you don&apos;t need a parsing library</span></div><div data-t="jeremys @hiredman Hi, I don&apos;t know what to make of your answer. I could also say that even with a grammar that offer alternatives I could still make the choice not to use a parsing library and write a reader by hand. I am using instaparse because it makes it much easier to build a parser with it than without it. It also makes it easier to evolve the grammar. Maybe the answer to my question is that my grammar can be expressed another way instead of wanting to tell the parser not to backtrack. Still if the functionality existed I&apos;d like to know about it!  Cheers."><span class="u" id="1601645859.014400">2020:10:02 13:37:39          jeremys </span><span>@hiredman Hi, I don&apos;t know what to make of your answer. I could also say that even with a grammar that offer alternatives I could still make the choice not to use a parsing library and write a reader by hand. I am using instaparse because it makes it much easier to build a parser with it than without it. It also makes it easier to evolve the grammar. Maybe the answer to my question is that my grammar can be expressed another way instead of wanting to tell the parser not to backtrack. Still if the functionality existed I&apos;d like to know about it!  Cheers.</span></div><div data-t="manutter51 What was your reason for wanting to error out instead of backtracking? Are you trying to raise an alert about invalid expressions in what you’re parsing, or are you trying to debug your grammar?"><span class="u" id="1601646070.016200">2020:10:02 13:41:10       manutter51 </span><span>What was your reason for wanting to error out instead of backtracking? Are you trying to raise an alert about invalid expressions in what you’re parsing, or are you trying to debug your grammar?</span></div><div data-t="jeremys @manutter51 hi! I want to raise an alert about invalid code. I am working on something like  https://docs.racket-lang.org/pollen/  that allows to write code in the middle of text. My problem arises in particular situations.
For instance, the entry rule of my grammar looks like this:
 doc = (plain-text | embedded)* 
If I write a pollen expression like this:
 plain-text ◊str[&quot;some string&quot;] plain-text 
it is parsed as:
 [:doc 
 &quot;plain-text &quot; 
 [:tag 
  [:tag-name &quot;str&quot;] 
  [:tag-clj-arg &quot;[&quot; &quot; &quot; &quot;\&quot;aaa\&quot;&quot; &quot;]&quot;]] 
 &quot; plain-text&quot;] 
Now if i make a mistake balancing the quotes:
 plain-text ◊str[&quot;some string&quot;&quot;] plain-text 
the way my grammar works I get:
 [:doc 
 &quot;plain-text &quot; 
 [:tag 
  [:tag-name &quot;str&quot;]] 
 &quot;[ \&quot;some string\&quot;\&quot;]  plain-text&quot;] 
From the point of view of the parser there is no error here. The  [&quot;some string&quot;&quot;]   expression, which serves as arguments to the  str  function, couldn&apos;t be parsed as correct clojure code. However the parser can fall back to the  plain-text  grammatical rule and did just that. In this case I&apos;d rather it didn&apos;t."><span class="u" id="1601655410.029400">2020:10:02 16:16:50          jeremys </span><span>@manutter51 hi! I want to raise an alert about invalid code. I am working on something like </span><a href="https://docs.racket-lang.org/pollen/">https://docs.racket-lang.org/pollen/</a><span> that allows to write code in the middle of text. My problem arises in particular situations.
For instance, the entry rule of my grammar looks like this:
</span><pre>doc = (plain-text | embedded)*</pre><span>
If I write a pollen expression like this:
</span><pre>plain-text ◊str[&quot;some string&quot;] plain-text</pre><span>
it is parsed as:
</span><pre>[:doc 
 &quot;plain-text &quot; 
 [:tag 
  [:tag-name &quot;str&quot;] 
  [:tag-clj-arg &quot;[&quot; &quot; &quot; &quot;\&quot;aaa\&quot;&quot; &quot;]&quot;]] 
 &quot; plain-text&quot;]</pre><span>
Now if i make a mistake balancing the quotes:
</span><pre>plain-text ◊str[&quot;some string&quot;&quot;] plain-text</pre><span>
the way my grammar works I get:
</span><pre>[:doc 
 &quot;plain-text &quot; 
 [:tag 
  [:tag-name &quot;str&quot;]] 
 &quot;[ \&quot;some string\&quot;\&quot;]  plain-text&quot;]</pre><span>
From the point of view of the parser there is no error here. The </span><code>[&quot;some string&quot;&quot;]</code><span>  expression, which serves as arguments to the </span><code>str</code><span> function, couldn&apos;t be parsed as correct clojure code. However the parser can fall back to the </span><code>plain-text</code><span> grammatical rule and did just that. In this case I&apos;d rather it didn&apos;t.</span></div><div data-t="manutter51 Perhaps you could define  plain-text  so that it’s not allowed to contain an unescaped  ◊  character?"><span class="u" id="1601656003.030200">2020:10:02 16:26:43       manutter51 </span><span>Perhaps you could define </span><code>plain-text</code><span> so that it’s not allowed to contain an unescaped </span><code>◊</code><span> character?</span></div><div data-t="jeremys It is actually  🙂  That&apos;s how the grammar recognizes that there is a &quot;tag-fn&quot; there (in pollen&apos;s jargon) or embedded code in general. And so we rightly get the  [:tag [:tag-name &quot;str&quot;]]  part. What happens is that the arguments to the function are optional. Thus if the text that follows the function&apos;s name is malformed args, the parser can fall back to plain text. It may be be that the parser can&apos;t be made to throw in that case or that I can&apos;t gerrymander my grammar into doing what I want. It would would be cool if I could though."><span class="u" id="1601656913.036800">2020:10:02 16:41:53          jeremys </span><span>It is actually </span><b>🙂</b><span> That&apos;s how the grammar recognizes that there is a &quot;tag-fn&quot; there (in pollen&apos;s jargon) or embedded code in general. And so we rightly get the </span><code>[:tag [:tag-name &quot;str&quot;]]</code><span> part. What happens is that the arguments to the function are optional. Thus if the text that follows the function&apos;s name is malformed args, the parser can fall back to plain text. It may be be that the parser can&apos;t be made to throw in that case or that I can&apos;t gerrymander my grammar into doing what I want. It would would be cool if I could though.</span></div><div data-t="misha greetings!
is there a way to specify &quot;greedy&quot; matches in the grammar (instead of the tree transforming) other than using inline regex-es?

(insta/parse (insta/parser &quot;S = &apos;a&apos;+&quot;) &quot;aaaa&quot;)
to get
=&gt; [:S &quot;aaaa&quot;]
instead of:
=&gt; [:S &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot;]

my actual use case is: I have a bunch of rules wrapped in &lt;&gt; (for &quot;documentation&quot;), so the tags will not show up in output tree, so I&apos;d line to have a single match string in the output (like &quot;aaaaa&quot;).
I&apos;d like to avoid tree transforming, because grammar is &quot;up for extension&quot; for someone else, and making sure they update transformers as well add a line to grammar - is extra point of potential failure"><span class="u" id="1605533518.042400">2020:11:16 13:31:58            misha </span><span>greetings!
is there a way to specify &quot;greedy&quot; matches in the grammar (instead of the tree transforming) other than using inline regex-es?

(insta/parse (insta/parser &quot;S = &apos;a&apos;+&quot;) &quot;aaaa&quot;)
to get
=&gt; [:S &quot;aaaa&quot;]
instead of:
=&gt; [:S &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot;]

my actual use case is: I have a bunch of rules wrapped in &lt;&gt; (for &quot;documentation&quot;), so the tags will not show up in output tree, so I&apos;d line to have a single match string in the output (like &quot;aaaaa&quot;).
I&apos;d like to avoid tree transforming, because grammar is &quot;up for extension&quot; for someone else, and making sure they update transformers as well add a line to grammar - is extra point of potential failure</span></div><div data-t="misha and inline regexes do not compose  [:attrs nil]  at all:
 &lt;phrase&gt; =    #&apos;\w+(\s+\w+)*&apos;
text     = #&apos;\s*\w+(\s+\w+)*\s*&apos; 
instead of
 &lt;space&gt;  = #&apos;\s+&apos;
&lt;word&gt;   = #&apos;\w+&apos;
&lt;phrase&gt; = word (space word)*
text     = space? phrase space?"><span class="u" id="1605533959.043400">2020:11:16 13:39:19            misha </span><span>and inline regexes do not compose </span><del>well</del><span> at all:
</span><pre>&lt;phrase&gt; =    #&apos;\w+(\s+\w+)*&apos;
text     = #&apos;\s*\w+(\s+\w+)*\s*&apos;</pre><span>
instead of
</span><pre>&lt;space&gt;  = #&apos;\s+&apos;
&lt;word&gt;   = #&apos;\w+&apos;
&lt;phrase&gt; = word (space word)*
text     = space? phrase space?</pre></div></body>