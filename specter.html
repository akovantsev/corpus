<!DOCTYPE html>
<body><style>body {font-family: Monaco, Menlo, Consolas, "Courier New"; font-size: 12px;}</style><style>pre, code {
    font-family: Monaco, Menlo, Consolas, "Courier New", monospace;
    color: #333;
}</style><style>code {line-height: 1.2;
    white-space: normal;
    color: #c25;
    background-color: #f7f7f9;
    border: 1px solid #e1e1e8;}</style><style>pre {
    margin: .5rem 0 .2rem;
    font-size: .75rem;
    line-height: 1.15rem;</style><style>pre {
    background: #fbfaf8;
    padding: .5rem;
    word-break: normal;
    display: block;
    border: 1px solid rgba(0, 0, 0, .15);
    white-space: pre-wrap;
    word-wrap: break-word;
    border-radius: 4px;
}</style><style>span.u {margin-top: 3px;    margin-left: 10px;
    margin-right: 10px;
    background-color: lavender;}</style><style>span {white-space: pre-wrap;}</style><style id="css-filter"></style><h3>specter, last update time: 2020:11:17 17:42:30</h3><h3>up until: <a href="https://clojurians-log.clojureverse.org/specter/2020-10-27">https://clojurians-log.clojureverse.org/specter/2020-10-27</a></h3><input id="filter" onkeyup="debfilter(this.value)" placeholder="filter" style="position: fixed" type="string" /><script>
const filterInput = document.getElementById("filter");
const filterStryle = document.getElementById("css-filter");

function filter(text) {
    var style = '';
    if (text.trim() !== '') {
        text.split(' ').forEach(function (t) {
            if (t !== '') {
                style = style + "div:not([data-t*='" + t + "' i]) {display: none}";
            }
        });
    }
    filterStryle.innerHTML = style;
}

function filterSelection (e) {
    let sel = document.getSelection();
    let txt;
    if (sel.anchorNode.parentElement.nodeName === "CODE") {
        txt = sel.focusNode.textContent.substring(0, sel.focusOffset);
    } else if (sel.focusNode.parentElement.nodeName === "CODE") {
        txt = sel.anchorNode.textContent.substring(sel.anchorOffset, sel.anchorNode.textContent.length);
    } else {
        txt = sel.toString();
    }

    if (txt.length > 0) {
        filterInput.value = (txt || "");
        filter(txt);
    }
}
function debounce1(callback, delay) {
    let timeout;
    return function(arg) {
        clearTimeout(timeout);
        timeout = setTimeout(callback, delay, arg);
    }
}
const debfilter = debounce1(filter, 200);

function keyUp (e) {
    if (e.code === "KeyF" && e.ctrlKey) {
        let txt = document.getSelection().toString();
        if (txt.length > 0) {
            filterInput.value = (txt || "");
            filter(txt);
        }
    }
}

document.ondblclick = filterSelection;
document.onkeyup = keyUp;
filterInput.focus();
</script><div data-t="sveri That logbot follows everywhere I go  😄"><span class="u" id="1449315226.000007">2015:12:05 11:33:46                sveri </span><span>That logbot follows everywhere I go </span><b>😄</b></div><div data-t="exupero Is there a way with specter to transform the first element matching a predicate?"><span class="u" id="1449843506.000012">2015:12:11 14:18:26              exupero </span><span>Is there a way with specter to transform the first element matching a predicate?</span></div><div data-t="sveri @exupero: I had this working for me:"><span class="u" id="1449843777.000013">2015:12:11 14:22:57                sveri </span><span>@exupero: I had this working for me:</span></div><div data-t="sveri  (spec/transform [:new-entity :columns spec/ALL #(= (:id %) id)]
                                      #(assoc % key val)
                                      @state)``"><span class="u" id="1449843791.000014">2015:12:11 14:23:11                sveri </span><code></code><span>(spec/transform [:new-entity :columns spec/ALL #(= (:id %) id)]
                                      #(assoc % key val)
                                      @state)``</span></div><div data-t="sveri I guess if you switch ALL by FIRST it will only transform the first met one"><span class="u" id="1449843815.000015">2015:12:11 14:23:35                sveri </span><span>I guess if you switch ALL by FIRST it will only transform the first met one</span></div><div data-t="exupero Using  FIRST pred  seems to get the first item in the sequence, then filter it on whether it satisfies the predicate."><span class="u" id="1449844200.000016">2015:12:11 14:30:00              exupero </span><span>Using </span><code>FIRST pred</code><span> seems to get the first item in the sequence, then filter it on whether it satisfies the predicate.</span></div><div data-t="exupero Essentially I want  ALL pred FIRST ."><span class="u" id="1449844216.000017">2015:12:11 14:30:16              exupero </span><span>Essentially I want </span><code>ALL pred FIRST</code><span>.</span></div><div data-t="exupero But that gives the error  Vector’s key for assoc must be a number."><span class="u" id="1449844244.000018">2015:12:11 14:30:44              exupero </span><span>But that gives the error </span><code>Vector’s key for assoc must be a number.</code></div><div data-t="onetom Is it just me, or neither the intro article, nor the README on github mentions what namespace specter is using?"><span class="u" id="1451629574.000020">2016:01:01 06:26:14               onetom </span><span>Is it just me, or neither the intro article, nor the README on github mentions what namespace specter is using?</span></div><div data-t="onetom Is it a convention if the namespace is not mentioned, then it&apos;s the same as the group/artifact-id?"><span class="u" id="1451630336.000021">2016:01:01 06:38:56               onetom </span><span>Is it a convention if the namespace is not mentioned, then it&apos;s the same as the group/artifact-id?</span></div><div data-t="escherize That threw me off too."><span class="u" id="1451702307.000022">2016:01:02 02:38:27            escherize </span><span>That threw me off too.</span></div><div data-t="drusellers i just assumed it followed the java conventions."><span class="u" id="1451747138.000024">2016:01:02 15:05:38           drusellers </span><span>i just assumed it followed the java conventions.</span></div><div data-t="drusellers i’m trying to use Spector in CLJS with React and getting an odd error"><span class="u" id="1451747156.000025">2016:01:02 15:05:56           drusellers </span><span>i’m trying to use Spector in CLJS with React and getting an odd error</span></div><div data-t="drusellers No protocol method IReduce.-reduce defined for type om.core/IndexedCursor"><span class="u" id="1451747163.000026">2016:01:02 15:06:03           drusellers </span><code>No protocol method IReduce.-reduce defined for type om.core/IndexedCursor</code></div><div data-t="drusellers when i try to query out a collection."><span class="u" id="1451747169.000027">2016:01:02 15:06:09           drusellers </span><span>when i try to query out a collection.</span></div><div data-t="sveri @drusellers: Looks like you reduce on a different type than specter expects. Maybe try to turn it into a seq or vec before working on it with specter?"><span class="u" id="1451919412.000028">2016:01:04 14:56:52                sveri </span><span>@drusellers: Looks like you reduce on a different type than specter expects. Maybe try to turn it into a seq or vec before working on it with specter?</span></div><div data-t="sveri Basically the message says that om.core/IndexedCursor does not implement the IReduce protocol and therefore cannot reduce on it"><span class="u" id="1451919459.000029">2016:01:04 14:57:39                sveri </span><span>Basically the message says that om.core/IndexedCursor does not implement the IReduce protocol and therefore cannot reduce on it</span></div><div data-t="drusellers @sveri: fyi -  https://github.com/nathanmarz/specter/issues/46"><span class="u" id="1451947782.000030">2016:01:04 22:49:42           drusellers </span><span>@sveri: fyi - </span><a href="https://github.com/nathanmarz/specter/issues/46">https://github.com/nathanmarz/specter/issues/46</a></div><div data-t="meow boo  👻   :specter:"><span class="u" id="1452588284.000034">2016:01:12 08:44:44                 meow </span><span>boo </span><b>👻</b><span> </span><b>:specter:</b></div><div data-t="pdlug Is there a way to provide a default value when doing a  transform ? I have a vector of maps and I’m looking to either modify the map found by a key or insert it if not found"><span class="u" id="1456953344.000005">2016:03:02 21:15:44                pdlug </span><span>Is there a way to provide a default value when doing a </span><code>transform</code><span>? I have a vector of maps and I’m looking to either modify the map found by a key or insert it if not found</span></div><div data-t="hugobessaa Hey, hi!"><span class="u" id="1457375755.000007">2016:03:07 18:35:55           hugobessaa </span><span>Hey, hi!</span></div><div data-t="hugobessaa I&apos;m using specter to filter a nested list"><span class="u" id="1457375771.000009">2016:03:07 18:36:11           hugobessaa </span><span>I&apos;m using specter to filter a nested list</span></div><div data-t="hugobessaa Any way this could be better written?"><span class="u" id="1457375784.000010">2016:03:07 18:36:24           hugobessaa </span><span>Any way this could be better written?</span></div><div data-t="hugobessaa (specter/transform [:profile-edit :navigation specter/ALL :anchors]
                     (partial filter anchor-on-page?)
                     db)
"><span class="u" id="1457375849.000013">2016:03:07 18:37:29           hugobessaa </span><pre>(specter/transform [:profile-edit :navigation specter/ALL :anchors]
                     (partial filter anchor-on-page?)
                     db)
</pre></div><div data-t="wei @hugobessaa: that’s how I would do it"><span class="u" id="1457379378.000014">2016:03:07 19:36:18                  wei </span><span>@hugobessaa: that’s how I would do it</span></div><div data-t="wei there might be a better way but I’m not sure"><span class="u" id="1457379383.000015">2016:03:07 19:36:23                  wei </span><span>there might be a better way but I’m not sure</span></div><div data-t="hugobessaa it would be nice if I could use a transducer with  transform"><span class="u" id="1457380018.000016">2016:03:07 19:46:58           hugobessaa </span><span>it would be nice if I could use a transducer with </span><code>transform</code></div><div data-t="alexisgallagher I have a basic specter question. I think I&apos;m just not understanding its fundamental concepts."><span class="u" id="1458078819.000003">2016:03:15 21:53:39      alexisgallagher </span><span>I have a basic specter question. I think I&apos;m just not understanding its fundamental concepts.</span></div><div data-t="alexisgallagher Say I have a vector  mymaps  like so:"><span class="u" id="1458078824.000004">2016:03:15 21:53:44      alexisgallagher </span><span>Say I have a vector </span><code>mymaps</code><span> like so:</span></div><div data-t="alexisgallagher (def mymaps [{:a 1 :b 2 :c {:d true}}
               {:a 2 :b 2 :c {:d false}}
               {:a 3 :b 2 :c {:d true}}])"><span class="u" id="1458078842.000005">2016:03:15 21:54:02      alexisgallagher </span><pre>(def mymaps [{:a 1 :b 2 :c {:d true}}
               {:a 2 :b 2 :c {:d false}}
               {:a 3 :b 2 :c {:d true}}])</pre></div><div data-t="alexisgallagher And I want to select all the items where the nested map&apos;s :d&apos;s value is true. If I was using  filter  and  get-in , I&apos;d just do it like so:"><span class="u" id="1458078887.000008">2016:03:15 21:54:47      alexisgallagher </span><span>And I want to select all the items where the nested map&apos;s :d&apos;s value is true. If I was using </span><code>filter</code><span> and </span><code>get-in</code><span>, I&apos;d just do it like so:</span></div><div data-t="alexisgallagher (filter #(get-in % [:c :d]) mymaps)"><span class="u" id="1458078898.000009">2016:03:15 21:54:58      alexisgallagher </span><pre>(filter #(get-in % [:c :d]) mymaps)</pre></div><div data-t="alexisgallagher How would I do this with specter?"><span class="u" id="1458078915.000011">2016:03:15 21:55:15      alexisgallagher </span><span>How would I do this with specter?</span></div><div data-t="alexisgallagher I&apos;m supposing I should use the  select  operator, since I don&apos;t want to transform components of the original structure in place. I only want to select certain components within it."><span class="u" id="1458078948.000012">2016:03:15 21:55:48      alexisgallagher </span><span>I&apos;m supposing I should use the </span><code>select</code><span> operator, since I don&apos;t want to transform components of the original structure in place. I only want to select certain components within it.</span></div><div data-t="alexisgallagher So, trivially, I could use select to pull out all the boolean values I want to test, by doing:"><span class="u" id="1458078984.000013">2016:03:15 21:56:24      alexisgallagher </span><span>So, trivially, I could use select to pull out all the boolean values I want to test, by doing:</span></div><div data-t="alexisgallagher (select [ALL :c :d] mymaps)"><span class="u" id="1458078988.000014">2016:03:15 21:56:28      alexisgallagher </span><pre>(select [ALL :c :d] mymaps)</pre></div><div data-t="alexisgallagher But this just gives me an array of booleans."><span class="u" id="1458078996.000015">2016:03:15 21:56:36      alexisgallagher </span><span>But this just gives me an array of booleans.</span></div><div data-t="alexisgallagher If I want to use those values as a predicate to select the maps themselves, then ... ?"><span class="u" id="1458079016.000016">2016:03:15 21:56:56      alexisgallagher </span><span>If I want to use those values as a predicate to select the maps themselves, then ... ?</span></div><div data-t="alexisgallagher Well, I see there&apos;s a talk on specter at the Conj. Maybe I&apos;ll fly to Seattle and figure out how to select with an embedded filtering condition there.  😜"><span class="u" id="1458245594.000017">2016:03:17 20:13:14      alexisgallagher </span><span>Well, I see there&apos;s a talk on specter at the Conj. Maybe I&apos;ll fly to Seattle and figure out how to select with an embedded filtering condition there. </span><b>😜</b></div><div data-t="hugobessaa @alexisgallagher: I tried to do this myself last week. I ended up doing this:"><span class="u" id="1458302432.000018">2016:03:18 12:00:32           hugobessaa </span><span>@alexisgallagher: I tried to do this myself last week. I ended up doing this:</span></div><div data-t="hugobessaa (specter/transform [:profile-edit :navigation specter/ALL :anchors]
                     (partial filter anchor-on-page?)
                     db)
"><span class="u" id="1458302436.000019">2016:03:18 12:00:36           hugobessaa </span><pre>(specter/transform [:profile-edit :navigation specter/ALL :anchors]
                     (partial filter anchor-on-page?)
                     db)
</pre></div><div data-t="hugobessaa anchor-on-page?  is my predicate that test some nested data"><span class="u" id="1458302485.000020">2016:03:18 12:01:25           hugobessaa </span><code>anchor-on-page?</code><span> is my predicate that test some nested data</span></div><div data-t="hugobessaa revisiting the docs, I think I found what you and I were looking for:"><span class="u" id="1458302642.000021">2016:03:18 12:04:02           hugobessaa </span><span>revisiting the docs, I think I found what you and I were looking for:</span></div><div data-t="hugobessaa (transform [ALL (if-path [:a even?] [:c ALL] :d)]
              inc
              [{:a 2 :c [1 2] :d 4} {:a 4 :c [0 10 -1]} {:a -1 :c [1 1 1] :d 1}])
"><span class="u" id="1458302647.000022">2016:03:18 12:04:07           hugobessaa </span><pre>(transform [ALL (if-path [:a even?] [:c ALL] :d)]
              inc
              [{:a 2 :c [1 2] :d 4} {:a 4 :c [0 10 -1]} {:a -1 :c [1 1 1] :d 1}])
</pre></div><div data-t="wei I would stick with  filter /`get-in` in this case."><span class="u" id="1458342544.000023">2016:03:18 23:09:04                  wei </span><span>I would stick with </span><code>filter</code><span>/`get-in` in this case.</span></div><div data-t="alexisgallagher @hugobessaa: Interesting. I see my original question has been archived out of existence alas."><span class="u" id="1458780570.000024">2016:03:24 00:49:30      alexisgallagher </span><span>@hugobessaa: Interesting. I see my original question has been archived out of existence alas.</span></div><div data-t="thomasdeutsch what is the specter equivalent of this?  (map (fn [a b] ...) a-coll b-coll)    (mapping over two seqs)"><span class="u" id="1461447614.000006">2016:04:23 21:40:14        thomasdeutsch </span><span>what is the specter equivalent of this? </span><pre>(map (fn [a b] ...) a-coll b-coll) </pre><span>  (mapping over two seqs)</span></div><div data-t="tcoupland (select [:workflow ALL LAST keyword? #(= :inc %)]
          {:workflow [[:in :inc]
                      [:inc :dbl]
                      [:dbl :div]
                      [:div [enough? :out :inc]]]}) =&gt; [:inc]
"><span class="u" id="1461601114.000008">2016:04:25 16:18:34            tcoupland </span><pre>(select [:workflow ALL LAST keyword? #(= :inc %)]
          {:workflow [[:in :inc]
                      [:inc :dbl]
                      [:dbl :div]
                      [:div [enough? :out :inc]]]}) =&gt; [:inc]
</pre></div><div data-t="tcoupland to my mind i shouldn&apos;t have to wrap the last element in the selector with a function, i should be able to just use &apos;:inc&apos;"><span class="u" id="1461601143.000009">2016:04:25 16:19:03            tcoupland </span><span>to my mind i shouldn&apos;t have to wrap the last element in the selector with a function, i should be able to just use &apos;:inc&apos;</span></div><div data-t="tcoupland but if i do that i just be nil&apos;s"><span class="u" id="1461601162.000011">2016:04:25 16:19:22            tcoupland </span><span>but if i do that i just be nil&apos;s</span></div><div data-t="tcoupland wld be interested to know why!  simple_smile"><span class="u" id="1461601170.000012">2016:04:25 16:19:30            tcoupland </span><span>wld be interested to know why! </span><b>simple_smile</b></div><div data-t="aengelberg @tcoupland: Specter doesn&apos;t know you mean to compare an element with  :inc , it thinks you want to navigate to  (:inc ...)  which is nil for anything that isn&apos;t a map"><span class="u" id="1461707641.000013">2016:04:26 21:54:01           aengelberg </span><span>@tcoupland: Specter doesn&apos;t know you mean to compare an element with </span><code>:inc</code><span>, it thinks you want to navigate to </span><code>(:inc ...)</code><span> which is nil for anything that isn&apos;t a map</span></div><div data-t="aengelberg (select [:a-keyword] ...)  is syntactic sugar for  (select [(keypath :a-keyword)] ...)  in Specter"><span class="u" id="1461707699.000014">2016:04:26 21:54:59           aengelberg </span><code>(select [:a-keyword] ...)</code><span> is syntactic sugar for </span><code>(select [(keypath :a-keyword)] ...)</code><span> in Specter</span></div><div data-t="tcoupland Aye, it feels very map centric sometimes"><span class="u" id="1461707736.000015">2016:04:26 21:55:36            tcoupland </span><span>Aye, it feels very map centric sometimes</span></div><div data-t="tcoupland I made a little value-path path fn that does the trick nicely, works with parametrised comp-path"><span class="u" id="1461707814.000016">2016:04:26 21:56:54            tcoupland </span><span>I made a little value-path path fn that does the trick nicely, works with parametrised comp-path</span></div><div data-t="mac Is it bad form to ask a question here which is a duplicate of an issue submitted to github?"><span class="u" id="1463416589.000022">2016:05:16 16:36:29                  mac </span><span>Is it bad form to ask a question here which is a duplicate of an issue submitted to github?</span></div><div data-t="nathanmarz @mac: just answered it on github"><span class="u" id="1463420703.000023">2016:05:16 17:45:03           nathanmarz </span><span>@mac: just answered it on github</span></div><div data-t="mac @nathanmarz:  Thanks a lot."><span class="u" id="1463421247.000024">2016:05:16 17:54:07                  mac </span><span>@nathanmarz:  Thanks a lot.</span></div><div data-t="mac Took the liberty of posting a followup  🙂"><span class="u" id="1463421269.000025">2016:05:16 17:54:29                  mac </span><span>Took the liberty of posting a followup </span><b>🙂</b></div><div data-t="mac @nathanmarz: I must be slow today - or in general. Why will (walker keyword?) pickup every keyword while (walker :c) only returns the top level map if :c occurs in it, even if the top level map contains children maps with :c as key?"><span class="u" id="1463421933.000026">2016:05:16 18:05:33                  mac </span><span>@nathanmarz: I must be slow today - or in general. Why will (walker keyword?) pickup every keyword while (walker :c) only returns the top level map if :c occurs in it, even if the top level map contains children maps with :c as key?</span></div><div data-t="nathanmarz The argument to walker is a predicate function"><span class="u" id="1463422214.000027">2016:05:16 18:10:14           nathanmarz </span><span>The argument to walker is a predicate function</span></div><div data-t="nathanmarz So since the top-level map returns truthy when &quot;:c&quot; is run on it"><span class="u" id="1463422229.000028">2016:05:16 18:10:29           nathanmarz </span><span>So since the top-level map returns truthy when &quot;:c&quot; is run on it</span></div><div data-t="nathanmarz It stops there"><span class="u" id="1463422231.000029">2016:05:16 18:10:31           nathanmarz </span><span>It stops there</span></div><div data-t="nathanmarz walker walks the entire structure, and stops on any path once its predicate function matches"><span class="u" id="1463422303.000030">2016:05:16 18:11:43           nathanmarz </span><span>walker walks the entire structure, and stops on any path once its predicate function matches</span></div><div data-t="mac @nathanmarz: &gt;Trying to wrap my head around this"><span class="u" id="1463422455.000031">2016:05:16 18:14:15                  mac </span><span>@nathanmarz: &gt;Trying to wrap my head around this</span></div><div data-t="mac @nathanmarz: Got it. Had to mess a bit with some different predicates, but it sunk in now  🙂"><span class="u" id="1463423717.000032">2016:05:16 18:35:17                  mac </span><span>@nathanmarz: Got it. Had to mess a bit with some different predicates, but it sunk in now </span><b>🙂</b></div><div data-t="nathanmarz great"><span class="u" id="1463424760.000033">2016:05:16 18:52:40           nathanmarz </span><span>great</span></div><div data-t="benzap so i&apos;ve been looking at specter, do you think it can also be applied to matrices?"><span class="u" id="1463604863.000036">2016:05:18 20:54:23               benzap </span><span>so i&apos;ve been looking at specter, do you think it can also be applied to matrices?</span></div><div data-t="benzap been trying basic things like accessing elements in a matrix, and i&apos;ve been having a hard time getting it working. Very new to your library, but I love it nonetheless since seeing your talk"><span class="u" id="1463604915.000037">2016:05:18 20:55:15               benzap </span><span>been trying basic things like accessing elements in a matrix, and i&apos;ve been having a hard time getting it working. Very new to your library, but I love it nonetheless since seeing your talk</span></div><div data-t="benzap for example

(use &apos;com.rpl.specter)
(def x [[1 2 3] [4 5 6]])
(select [1 1] x)
;; failed"><span class="u" id="1463605100.000038">2016:05:18 20:58:20               benzap </span><span>for example

(use &apos;com.rpl.specter)
(def x [[1 2 3] [4 5 6]])
(select [1 1] x)
;; failed</span></div><div data-t="benzap (select [FIRST FIRST] x)"><span class="u" id="1463605102.000039">2016:05:18 20:58:22               benzap </span><span>(select [FIRST FIRST] x)</span></div><div data-t="benzap (select [FIRST FIRST] x)"><span class="u" id="1463605108.000040">2016:05:18 20:58:28               benzap </span><span>(select [FIRST FIRST] x)</span></div><div data-t="benzap [1]*"><span class="u" id="1463605112.000041">2016:05:18 20:58:32               benzap </span><span>[1]*</span></div><div data-t="benzap is there a navigator that lets you select a specific value in a matrix"><span class="u" id="1463605144.000042">2016:05:18 20:59:04               benzap </span><span>is there a navigator that lets you select a specific value in a matrix</span></div><div data-t="benzap I should probably do more reading before I ask this question, sorry in advance"><span class="u" id="1463605168.000043">2016:05:18 20:59:28               benzap </span><span>I should probably do more reading before I ask this question, sorry in advance</span></div><div data-t="nathanmarz benzap: You can use keypath"><span class="u" id="1463605867.000044">2016:05:18 21:11:07           nathanmarz </span><span>benzap: You can use keypath</span></div><div data-t="nathanmarz (select [(keypath 1) (keypath 1)] x)"><span class="u" id="1463605885.000045">2016:05:18 21:11:25           nathanmarz </span><code>(select [(keypath 1) (keypath 1)] x)</code></div><div data-t="seantempesta hey everyone.  Just started using specter and I’m clearly missing something.  Why does this return nil?

 (s/select [:groups s/ALL (s/keypath 15)] {:groups {:present {15 &quot;hi&quot;}}})
"><span class="u" id="1463709576.000047">2016:05:20 01:59:36         seantempesta </span><span>hey everyone.  Just started using specter and I’m clearly missing something.  Why does this return nil?

</span><pre>(s/select [:groups s/ALL (s/keypath 15)] {:groups {:present {15 &quot;hi&quot;}}})
</pre></div><div data-t="wei how would you write this in specter- given a range of numbers, increment the even numbers and remove the odd numbers? i.e.  (transform [..] (fn [n] ..) (range 10)) =&gt; (1 3 5 7 9)  this is a contrived example, but basically I’m transforming the value in one case and removing from the list in another case"><span class="u" id="1463727883.000048">2016:05:20 07:04:43                  wei </span><span>how would you write this in specter- given a range of numbers, increment the even numbers and remove the odd numbers? i.e. </span><code>(transform [..] (fn [n] ..) (range 10)) =&gt; (1 3 5 7 9)</code><span> this is a contrived example, but basically I’m transforming the value in one case and removing from the list in another case</span></div><div data-t="tcoupland @seantempesta: s/ALL creates a sequence of everything refered to by :groups, [[:present {15 &quot;hi&quot;}]] here, so you need to decend another level of the structure. Either with :present or s/LAST would do the trick"><span class="u" id="1463740121.000051">2016:05:20 10:28:41            tcoupland </span><span>@seantempesta: s/ALL creates a sequence of everything refered to by :groups, [[:present {15 &quot;hi&quot;}]] here, so you need to decend another level of the structure. Either with :present or s/LAST would do the trick</span></div><div data-t="nathanmarz @wei You can do it with a navigator like this:
 (defpath ALL-ELEM-SEQ []
  (select* [this structure next-fn]
    (mapcat (fn [e] (next-fn [e])) structure)
    )
  (transform* [this structure next-fn]
    (mapcat (fn [e] (next-fn [e])) structure)    
    ))
"><span class="u" id="1463754523.000052">2016:05:20 14:28:43           nathanmarz </span><span>@wei You can do it with a navigator like this:
</span><pre>(defpath ALL-ELEM-SEQ []
  (select* [this structure next-fn]
    (mapcat (fn [e] (next-fn [e])) structure)
    )
  (transform* [this structure next-fn]
    (mapcat (fn [e] (next-fn [e])) structure)    
    ))
</pre></div><div data-t="nathanmarz (transform [... ALL-ELEM-SEQ] (fn [[v]] (if (even? v) [(inc v)])))"><span class="u" id="1463754561.000053">2016:05:20 14:29:21           nathanmarz </span><pre>(transform [... ALL-ELEM-SEQ] (fn [[v]] (if (even? v) [(inc v)])))</pre></div><div data-t="wei thanks @nathanmarz. just curious why you called it  ALL-ELEM-SEQ ?"><span class="u" id="1463790543.000054">2016:05:21 00:29:03                  wei </span><span>thanks @nathanmarz. just curious why you called it </span><code>ALL-ELEM-SEQ</code><span>?</span></div><div data-t="wei is there an idiomatic way to handle group-by operations? e.g. group-by :x,  [{:id 1 :x 1} {:id 2 :x 1} {:id 3 :x 2}] =&gt; [{:x 1 :ids [1 2]} {:x 2 :ids [3]}]  wondering if the implementation is shorter in specter"><span class="u" id="1464194875.000064">2016:05:25 16:47:55                  wei </span><span>is there an idiomatic way to handle group-by operations? e.g. group-by :x, </span><code>[{:id 1 :x 1} {:id 2 :x 1} {:id 3 :x 2}] =&gt; [{:x 1 :ids [1 2]} {:x 2 :ids [3]}]</code><span> wondering if the implementation is shorter in specter</span></div><div data-t="nathanmarz @wei not that I can think of"><span class="u" id="1464239299.000068">2016:05:26 05:08:19           nathanmarz </span><span>@wei not that I can think of</span></div><div data-t="adambros out of curiosity, how was the name (specter) chosen?"><span class="u" id="1464460619.000073">2016:05:28 18:36:59             adambros </span><span>out of curiosity, how was the name (specter) chosen?</span></div><div data-t="nathanmarz inspect, introspect"><span class="u" id="1464460678.000075">2016:05:28 18:37:58           nathanmarz </span><span>inspect, introspect</span></div><div data-t="adambros So at work we use om.next, and I saw under the readme’s future work you mention graphs
I’ve not had the time to fully think this out, but I was wondering if you had spent any brain power on graphs, om.next &amp; specter"><span class="u" id="1464460822.000076">2016:05:28 18:40:22             adambros </span><span>So at work we use om.next, and I saw under the readme’s future work you mention graphs
I’ve not had the time to fully think this out, but I was wondering if you had spent any brain power on graphs, om.next &amp; specter</span></div><div data-t="adambros i can elaborate on what an om.next graph is if you aren’t aware"><span class="u" id="1464460844.000077">2016:05:28 18:40:44             adambros </span><span>i can elaborate on what an om.next graph is if you aren’t aware</span></div><div data-t="nathanmarz well I have my own internal specter graph navigators (on top of loom)"><span class="u" id="1464460874.000078">2016:05:28 18:41:14           nathanmarz </span><span>well I have my own internal specter graph navigators (on top of loom)</span></div><div data-t="nathanmarz trying to get someone from the community to contribute an open-source version"><span class="u" id="1464460896.000079">2016:05:28 18:41:36           nathanmarz </span><span>trying to get someone from the community to contribute an open-source version</span></div><div data-t="nathanmarz there was someone at clojure west who was really interested but I haven&apos;t heard from him since"><span class="u" id="1464460914.000080">2016:05:28 18:41:54           nathanmarz </span><span>there was someone at clojure west who was really interested but I haven&apos;t heard from him since</span></div><div data-t="nathanmarz short summary of om.next graphs?"><span class="u" id="1464460927.000081">2016:05:28 18:42:07           nathanmarz </span><span>short summary of om.next graphs?</span></div><div data-t="nathanmarz i only have a vague familiarity"><span class="u" id="1464460942.000082">2016:05:28 18:42:22           nathanmarz </span><span>i only have a vague familiarity</span></div><div data-t="adambros let me grab a snapshot from my app, probably be easier with some real data"><span class="u" id="1464460974.000083">2016:05:28 18:42:54             adambros </span><span>let me grab a snapshot from my app, probably be easier with some real data</span></div><div data-t="nathanmarz ok"><span class="u" id="1464461025.000084">2016:05:28 18:43:45           nathanmarz </span><span>ok</span></div><div data-t="nathanmarz btw I gave an example of my specter graph stuff during my clojure west talk:  https://youtu.be/VTCy_DkAJGk?t=39m"><span class="u" id="1464461047.000085">2016:05:28 18:44:07           nathanmarz </span><span>btw I gave an example of my specter graph stuff during my clojure west talk: </span><a href="https://youtu.be/VTCy_DkAJGk?t=39m">https://youtu.be/VTCy_DkAJGk?t=39m</a></div><div data-t="adambros {:todos [[:todo/by-id 111] [:todo/by-id 222]]
 :todo/by-id {111 {:db/id 111 :todo/title [:string/by-id 112]}
              222 {:db/id 222 :todo/title [:string/by-id 223]}}
"><span class="u" id="1464461290.000089">2016:05:28 18:48:10             adambros </span><pre>{:todos [[:todo/by-id 111] [:todo/by-id 222]]
 :todo/by-id {111 {:db/id 111 :todo/title [:string/by-id 112]}
              222 {:db/id 222 :todo/title [:string/by-id 223]}}
</pre></div><div data-t="adambros so edges are called idents and take the form  [:table-name id]"><span class="u" id="1464461306.000090">2016:05:28 18:48:26             adambros </span><span>so edges are called idents and take the form </span><code>[:table-name id]</code></div><div data-t="adambros and we usually want to perform operations like adding/removing a todo to both the  :todos  list and to the table  :todo/by-id"><span class="u" id="1464461340.000091">2016:05:28 18:49:00             adambros </span><span>and we usually want to perform operations like adding/removing a todo to both the </span><code>:todos</code><span> list and to the table </span><code>:todo/by-id</code></div><div data-t="adambros and editing them in the table, which could itself be an operation that involves modifying a todo’s title which is an ident"><span class="u" id="1464461363.000092">2016:05:28 18:49:23             adambros </span><span>and editing them in the table, which could itself be an operation that involves modifying a todo’s title which is an ident</span></div><div data-t="adambros anyway i dont know what im looking for as its very new to me, but we end up writing a lot of boilerplate to update this graph"><span class="u" id="1464461434.000094">2016:05:28 18:50:34             adambros </span><span>anyway i dont know what im looking for as its very new to me, but we end up writing a lot of boilerplate to update this graph</span></div><div data-t="nathanmarz yea, well it&apos;s kind of like manipulating a vector if you had to deal with the internal tree structure directly"><span class="u" id="1464461485.000096">2016:05:28 18:51:25           nathanmarz </span><span>yea, well it&apos;s kind of like manipulating a vector if you had to deal with the internal tree structure directly</span></div><div data-t="nathanmarz I think loom internally implements graphs with maps but has a proper graph api that you can use"><span class="u" id="1464461503.000097">2016:05:28 18:51:43           nathanmarz </span><span>I think loom internally implements graphs with maps but has a proper graph api that you can use</span></div><div data-t="adambros so take a look at loom then?"><span class="u" id="1464461516.000098">2016:05:28 18:51:56             adambros </span><span>so take a look at loom then?</span></div><div data-t="nathanmarz I would start there, yea"><span class="u" id="1464461544.000099">2016:05:28 18:52:24           nathanmarz </span><span>I would start there, yea</span></div><div data-t="adambros ok thanks, hadn’t heard of it before"><span class="u" id="1464461555.000100">2016:05:28 18:52:35             adambros </span><span>ok thanks, hadn’t heard of it before</span></div><div data-t="nathanmarz or some sort of API where you do the basic manipulations / queries with a graph-oriented API"><span class="u" id="1464461567.000101">2016:05:28 18:52:47           nathanmarz </span><span>or some sort of API where you do the basic manipulations / queries with a graph-oriented API</span></div><div data-t="adambros be nice to not reinvent the graph"><span class="u" id="1464461569.000102">2016:05:28 18:52:49             adambros </span><span>be nice to not reinvent the graph</span></div><div data-t="nathanmarz get-node, children, parents, etc."><span class="u" id="1464461572.000103">2016:05:28 18:52:52           nathanmarz </span><span>get-node, children, parents, etc.</span></div><div data-t="nathanmarz then when you want to do more sophisticated stuff, you can do something similar like I&apos;ve done with specter graph navigators"><span class="u" id="1464461655.000105">2016:05:28 18:54:15           nathanmarz </span><span>then when you want to do more sophisticated stuff, you can do something similar like I&apos;ve done with specter graph navigators</span></div><div data-t="luxbock how can I select a subset of keys on a map?"><span class="u" id="1464523863.000115">2016:05:29 12:11:03              luxbock </span><span>how can I select a subset of keys on a map?</span></div><div data-t="luxbock I thought I could use sets with the keys I&apos;m interested in as the selector but this didn&apos;t work, eventhough I see that they implement the protocol"><span class="u" id="1464523896.000116">2016:05:29 12:11:36              luxbock </span><span>I thought I could use sets with the keys I&apos;m interested in as the selector but this didn&apos;t work, eventhough I see that they implement the protocol</span></div><div data-t="luxbock i.e.  (select [#{:foo}] {:foo 1 :bar 2})  returns  nil"><span class="u" id="1464524128.000117">2016:05:29 12:15:28              luxbock </span><span>i.e. </span><code>(select [#{:foo}] {:foo 1 :bar 2})</code><span> returns </span><code>nil</code></div><div data-t="luxbock what I&apos;m trying to achieve is  {:foo 1 :bar 2 :baz 3}  =&gt;  {:foo &quot;1&quot; :bar &quot;2&quot; :baz 3}"><span class="u" id="1464525085.000118">2016:05:29 12:31:25              luxbock </span><span>what I&apos;m trying to achieve is </span><code>{:foo 1 :bar 2 :baz 3}</code><span> =&gt; </span><code>{:foo &quot;1&quot; :bar &quot;2&quot; :baz 3}</code></div><div data-t="nathanmarz @luxbock: You can use either  submap  or  multi-path"><span class="u" id="1464525950.000119">2016:05:29 12:45:50           nathanmarz </span><span>@luxbock: You can use either </span><code>submap</code><span> or </span><code>multi-path</code></div><div data-t="nathanmarz (transform (multi-path :foo :bar) str {:foo 1 :bar 2 :baz 3})"><span class="u" id="1464526029.000120">2016:05:29 12:47:09           nathanmarz </span><code>(transform (multi-path :foo :bar) str {:foo 1 :bar 2 :baz 3})</code></div><div data-t="nathanmarz (transform [(submap [:foo :bar]) ALL LAST] str {:foo 1 :bar 2 :baz 3})"><span class="u" id="1464526064.000121">2016:05:29 12:47:44           nathanmarz </span><code>(transform [(submap [:foo :bar]) ALL LAST] str {:foo 1 :bar 2 :baz 3})</code></div><div data-t="luxbock @nathanmarz: cheers"><span class="u" id="1464533407.000122">2016:05:29 14:50:07              luxbock </span><span>@nathanmarz: cheers</span></div><div data-t="luxbock do sets serve some other purpose as selectors?"><span class="u" id="1464533426.000123">2016:05:29 14:50:26              luxbock </span><span>do sets serve some other purpose as selectors?</span></div><div data-t="nathanmarz they act as filter predicates"><span class="u" id="1464536065.000124">2016:05:29 15:34:25           nathanmarz </span><span>they act as filter predicates</span></div><div data-t="nathanmarz (select [ALL #{1 2}] [1 2 3 4 1 7])  -&gt;  [1 2 1]"><span class="u" id="1464536130.000125">2016:05:29 15:35:30           nathanmarz </span><code>(select [ALL #{1 2}] [1 2 3 4 1 7])</code><span> -&gt; </span><code>[1 2 1]</code></div><div data-t="luxbock ah I see, yeah makes sense"><span class="u" id="1464536209.000126">2016:05:29 15:36:49              luxbock </span><span>ah I see, yeah makes sense</span></div><div data-t="diba pardon my noobness, but i’m just starting out w/ specter, and i’m guessing there’s a better way to do the following that achieves better performance, and would love any guidance:"><span class="u" id="1464656714.000129">2016:05:31 01:05:14                 diba </span><span>pardon my noobness, but i’m just starting out w/ specter, and i’m guessing there’s a better way to do the following that achieves better performance, and would love any guidance:</span></div><div data-t="diba actually, here’s a simpler example where i’m still seeing my (likely non-optimal) specter code taking twice as long:"><span class="u" id="1464657321.000131">2016:05:31 01:15:21                 diba </span><span>actually, here’s a simpler example where i’m still seeing my (likely non-optimal) specter code taking twice as long:</span></div><div data-t="diba and &quot;f3 #(reduce-kv (fn [m k v] (assoc m k (dec v))) {} %)” seems to be twice as fast as f1"><span class="u" id="1464658306.000133">2016:05:31 01:31:46                 diba </span><span>and &quot;f3 #(reduce-kv (fn [m k v] (assoc m k (dec v))) {} %)” seems to be twice as fast as f1</span></div><div data-t="luxbock ALL FIRST  and  ALL LAST  seem like really common selectors, @nathanmarz what do you think about including these as  KEYS  and  VALS ?"><span class="u" id="1464671856.000134">2016:05:31 05:17:36              luxbock </span><code>ALL FIRST</code><span> and </span><code>ALL LAST</code><span> seem like really common selectors, @nathanmarz what do you think about including these as </span><code>KEYS</code><span> and </span><code>VALS</code><span>?</span></div><div data-t="luxbock or perhaps you could have another namespace that contains functions named after the ones in  clojure.core  but which work as selectors"><span class="u" id="1464677960.000135">2016:05:31 06:59:20              luxbock </span><span>or perhaps you could have another namespace that contains functions named after the ones in </span><code>clojure.core</code><span> but which work as selectors</span></div><div data-t="nathanmarz @diba @luxbock Yea the slowdown is caused by it just using generic functions to access the map as a sequence"><span class="u" id="1464700420.000136">2016:05:31 13:13:40           nathanmarz </span><span>@diba @luxbock Yea the slowdown is caused by it just using generic functions to access the map as a sequence</span></div><div data-t="nathanmarz and coercing the MapEntry&apos;s to vectors probably wasn&apos;t the right thing to do in retrospect,  KEY  and  VAL  selectors would be faster than coercing and using  FIRST  and  LAST"><span class="u" id="1464700469.000137">2016:05:31 13:14:29           nathanmarz </span><span>and coercing the MapEntry&apos;s to vectors probably wasn&apos;t the right thing to do in retrospect, </span><code>KEY</code><span> and </span><code>VAL</code><span> selectors would be faster than coercing and using </span><code>FIRST</code><span> and </span><code>LAST</code></div><div data-t="nathanmarz I&apos;ll look into using  reduce-kv  for the map case of  ALL , but otherwise you can make specialized navigators to make it faster"><span class="u" id="1464700526.000138">2016:05:31 13:15:26           nathanmarz </span><span>I&apos;ll look into using </span><code>reduce-kv</code><span> for the map case of </span><code>ALL</code><span>, but otherwise you can make specialized navigators to make it faster</span></div><div data-t="nathanmarz as for having KEYS and VALS as common navigators, maybe"><span class="u" id="1464700616.000139">2016:05:31 13:16:56           nathanmarz </span><span>as for having KEYS and VALS as common navigators, maybe</span></div><div data-t="nathanmarz so far I&apos;ve been hesitant to include compound navigators in the core library (since there&apos;s infinite of them possible), but I can see the argument in this case"><span class="u" id="1464700647.000140">2016:05:31 13:17:27           nathanmarz </span><span>so far I&apos;ve been hesitant to include compound navigators in the core library (since there&apos;s infinite of them possible), but I can see the argument in this case</span></div><div data-t="nathanmarz Big release for Specter today with the new inline factoring and caching feature"><span class="u" id="1464706369.000141">2016:05:31 14:52:49           nathanmarz </span><span>Big release for Specter today with the new inline factoring and caching feature</span></div><div data-t="nathanmarz No need to do manual precompilation anymore to get high performance"><span class="u" id="1464706384.000142">2016:05:31 14:53:04           nathanmarz </span><span>No need to do manual precompilation anymore to get high performance</span></div><div data-t="nathanmarz Also wrote up a guide to the internals of how Specter achieves high performance, recommended reading for all users:  https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs"><span class="u" id="1464706415.000143">2016:05:31 14:53:35           nathanmarz </span><span>Also wrote up a guide to the internals of how Specter achieves high performance, recommended reading for all users: </span><a href="https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs">https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs</a></div><div data-t="luxbock awesome"><span class="u" id="1464708820.000145">2016:05:31 15:33:40              luxbock </span><span>awesome</span></div><div data-t="luxbock @nathanmarz:   transform  seems to have disappeared from  com.rpl.specter  in the new version"><span class="u" id="1464709794.000147">2016:05:31 15:49:54              luxbock </span><span>@nathanmarz:  </span><code>transform</code><span> seems to have disappeared from </span><code>com.rpl.specter</code><span> in the new version</span></div><div data-t="luxbock as well as  select"><span class="u" id="1464709806.000148">2016:05:31 15:50:06              luxbock </span><span>as well as </span><code>select</code></div><div data-t="nathanmarz it&apos;s in the macros namespace"><span class="u" id="1464710015.000149">2016:05:31 15:53:35           nathanmarz </span><span>it&apos;s in the macros namespace</span></div><div data-t="luxbock ah I see"><span class="u" id="1464710032.000150">2016:05:31 15:53:52              luxbock </span><span>ah I see</span></div><div data-t="nathanmarz I recommend reading the changelog for the release as there were a few other backwards incompatible changes"><span class="u" id="1464710055.000151">2016:05:31 15:54:15           nathanmarz </span><span>I recommend reading the changelog for the release as there were a few other backwards incompatible changes</span></div><div data-t="tony.kay I&apos;m wanting to walk a recursive data structure composed of maps and vectors. When inside of a map I&apos;d like to remove k-v pairs where the value matches a predicate. Can I do that with specter?

 { :a 1 :b [{:x 4 :y 3}] }  ---remove where v == 4 --&gt; {:a 1 :b [{:y 3}]}"><span class="u" id="1464711785.000153">2016:05:31 16:23:05             tony.kay </span><span>I&apos;m wanting to walk a recursive data structure composed of maps and vectors. When inside of a map I&apos;d like to remove k-v pairs where the value matches a predicate. Can I do that with specter?

</span><code>{ :a 1 :b [{:x 4 :y 3}] }  ---remove where v == 4 --&gt; {:a 1 :b [{:y 3}]}</code></div><div data-t="tony.kay I can easily nullify the value..seems like collect...sort-of: on the k-v pair instead of the value"><span class="u" id="1464711863.000154">2016:05:31 16:24:23             tony.kay </span><span>I can easily nullify the value..seems like collect...sort-of: on the k-v pair instead of the value</span></div><div data-t="nathanmarz @tony.kay: in that example do you mean remove x when x==4?"><span class="u" id="1464711943.000155">2016:05:31 16:25:43           nathanmarz </span><span>@tony.kay: in that example do you mean remove x when x==4?</span></div><div data-t="tony.kay remove the :x 4 key-value pair when the value is 4, independent of the key"><span class="u" id="1464711972.000156">2016:05:31 16:26:12             tony.kay </span><span>remove the :x 4 key-value pair when the value is 4, independent of the key</span></div><div data-t="tony.kay by v I meant the value of a key-value pair"><span class="u" id="1464711995.000157">2016:05:31 16:26:35             tony.kay </span><span>by v I meant the value of a key-value pair</span></div><div data-t="nathanmarz Oh I see remove all key/value pairs where the value matches some predicate"><span class="u" id="1464712014.000158">2016:05:31 16:26:54           nathanmarz </span><span>Oh I see remove all key/value pairs where the value matches some predicate</span></div><div data-t="tony.kay right"><span class="u" id="1464712021.000159">2016:05:31 16:27:01             tony.kay </span><span>right</span></div><div data-t="tony.kay perhaps a walker on  map?"><span class="u" id="1464712118.000160">2016:05:31 16:28:38             tony.kay </span><span>perhaps a walker on </span><code>map?</code></div><div data-t="tony.kay with a nested transform"><span class="u" id="1464712166.000162">2016:05:31 16:29:26             tony.kay </span><span>with a nested transform</span></div><div data-t="nathanmarz there&apos;s a couple ways to do it"><span class="u" id="1464712190.000164">2016:05:31 16:29:50           nathanmarz </span><span>there&apos;s a couple ways to do it</span></div><div data-t="nathanmarz one way is to do something like  (transform [:b (collect ALL (selected? LAST #(= % 4)) FIRST)] (fn [keys m] (apply dissoc m keys)))"><span class="u" id="1464712262.000165">2016:05:31 16:31:02           nathanmarz </span><span>one way is to do something like </span><code>(transform [:b (collect ALL (selected? LAST #(= % 4)) FIRST)] (fn [keys m] (apply dissoc m keys)))</code></div><div data-t="nathanmarz oh you want it to be recursive as well"><span class="u" id="1464712322.000166">2016:05:31 16:32:02           nathanmarz </span><span>oh you want it to be recursive as well</span></div><div data-t="tony.kay yeah"><span class="u" id="1464712326.000167">2016:05:31 16:32:06             tony.kay </span><span>yeah</span></div><div data-t="nathanmarz one sec, I&apos;ll show you"><span class="u" id="1464712429.000168">2016:05:31 16:33:49           nathanmarz </span><span>one sec, I&apos;ll show you</span></div><div data-t="tony.kay thx"><span class="u" id="1464712434.000169">2016:05:31 16:33:54             tony.kay </span><span>thx</span></div><div data-t="nathanmarz (declarepath RecursiveMaps)

(providepath RecursiveMaps
  [(walker map?)
   (continue-then-stay
     ALL
     LAST
     RecursiveMaps
     )])

(transform
  [RecursiveMaps
   (collect ALL (selected? LAST #(= % 4)) FIRST)
   ]
   (fn [keys m] (apply dissoc m keys))
   {:a 4 :z 11 :b [{:x 4 :y 3} {:a 1}]}
  )
;; =&gt; {:z 11, :b [{:y 3} {:a 1}]}
"><span class="u" id="1464712559.000170">2016:05:31 16:35:59           nathanmarz </span><pre>(declarepath RecursiveMaps)

(providepath RecursiveMaps
  [(walker map?)
   (continue-then-stay
     ALL
     LAST
     RecursiveMaps
     )])

(transform
  [RecursiveMaps
   (collect ALL (selected? LAST #(= % 4)) FIRST)
   ]
   (fn [keys m] (apply dissoc m keys))
   {:a 4 :z 11 :b [{:x 4 :y 3} {:a 1}]}
  )
;; =&gt; {:z 11, :b [{:y 3} {:a 1}]}
</pre></div><div data-t="tony.kay oh boy...would not have gotten that  🙂"><span class="u" id="1464712580.000172">2016:05:31 16:36:20             tony.kay </span><span>oh boy...would not have gotten that </span><b>🙂</b></div><div data-t="tony.kay but cool nonetheless!"><span class="u" id="1464712626.000173">2016:05:31 16:37:06             tony.kay </span><span>but cool nonetheless!</span></div><div data-t="nathanmarz this is more advanced Specter usage, for sure"><span class="u" id="1464712701.000174">2016:05:31 16:38:21           nathanmarz </span><span>this is more advanced Specter usage, for sure</span></div><div data-t="nathanmarz but built on the same principles"><span class="u" id="1464712711.000175">2016:05:31 16:38:31           nathanmarz </span><span>but built on the same principles</span></div><div data-t="tony.kay Yeah, I understand it...just not able to write it yet"><span class="u" id="1464712726.000176">2016:05:31 16:38:46             tony.kay </span><span>Yeah, I understand it...just not able to write it yet</span></div><div data-t="nathanmarz yea, my first few recursive navigations took me awhile even though I came up with this technique"><span class="u" id="1464712771.000177">2016:05:31 16:39:31           nathanmarz </span><span>yea, my first few recursive navigations took me awhile even though I came up with this technique</span></div><div data-t="nathanmarz now I don&apos;t even think about it"><span class="u" id="1464712786.000178">2016:05:31 16:39:46           nathanmarz </span><span>now I don&apos;t even think about it</span></div><div data-t="tony.kay I appreciate the help. I&apos;ll read through these functions and maybe play on paper a bit"><span class="u" id="1464712887.000179">2016:05:31 16:41:27             tony.kay </span><span>I appreciate the help. I&apos;ll read through these functions and maybe play on paper a bit</span></div><div data-t="nathanmarz sure thing"><span class="u" id="1464712916.000180">2016:05:31 16:41:56           nathanmarz </span><span>sure thing</span></div><div data-t="tony.kay I see select-first, and it mentions it is not more efficient....is there a way of detecting the presence of a value in a nested data structure without continuing a recursive walk?"><span class="u" id="1464714574.000181">2016:05:31 17:09:34             tony.kay </span><span>I see select-first, and it mentions it is not more efficient....is there a way of detecting the presence of a value in a nested data structure without continuing a recursive walk?</span></div><div data-t="nathanmarz like do a recursive search for a value matching a predicate and stop once it&apos;s reached?"><span class="u" id="1464715049.000182">2016:05:31 17:17:29           nathanmarz </span><span>like do a recursive search for a value matching a predicate and stop once it&apos;s reached?</span></div><div data-t="tony.kay yes"><span class="u" id="1464715396.000183">2016:05:31 17:23:16             tony.kay </span><span>yes</span></div><div data-t="nathanmarz you can do that for a lot of cases with com.rpl.specter.zipper"><span class="u" id="1464715445.000184">2016:05:31 17:24:05           nathanmarz </span><span>you can do that for a lot of cases with com.rpl.specter.zipper</span></div><div data-t="nathanmarz user=&gt; (transform [z/VECTOR-ZIP (z/find-first #(and (number? %) (even? %))) z/NODE] inc [1 3 5 [2 4]])
[1 3 5 [3 4]]
"><span class="u" id="1464715459.000185">2016:05:31 17:24:19           nathanmarz </span><pre>user=&gt; (transform [z/VECTOR-ZIP (z/find-first #(and (number? %) (even? %))) z/NODE] inc [1 3 5 [2 4]])
[1 3 5 [3 4]]
</pre></div><div data-t="nathanmarz the definition of find-first is pretty simple:  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/zipper.cljx#L119"><span class="u" id="1464715509.000186">2016:05:31 17:25:09           nathanmarz </span><span>the definition of find-first is pretty simple: </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/zipper.cljx#L119">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/zipper.cljx#L119</a></div><div data-t="tony.kay and you&apos;re just using  inc  because you need something"><span class="u" id="1464715511.000188">2016:05:31 17:25:11             tony.kay </span><span>and you&apos;re just using </span><code>inc</code><span> because you need something</span></div><div data-t="tony.kay oh...nvm, I see"><span class="u" id="1464715531.000189">2016:05:31 17:25:31             tony.kay </span><span>oh...nvm, I see</span></div><div data-t="nathanmarz oh I was just showing it for the transform case"><span class="u" id="1464715533.000190">2016:05:31 17:25:33           nathanmarz </span><span>oh I was just showing it for the transform case</span></div><div data-t="nathanmarz works as you&apos;d expect for select"><span class="u" id="1464715549.000191">2016:05:31 17:25:49           nathanmarz </span><span>works as you&apos;d expect for select</span></div><div data-t="tony.kay yep, I see"><span class="u" id="1464715556.000192">2016:05:31 17:25:56             tony.kay </span><span>yep, I see</span></div><div data-t="luxbock how would I write the following using Specter:
  `"><span class="u" id="1464842090.000193">2016:06:02 04:34:50              luxbock </span><span>how would I write the following using Specter:
</span><code></code><span>`</span></div><div data-t="luxbock (into {} (for [[k v] fff] [k (mapv :foo v)]))"><span class="u" id="1464842129.000194">2016:06:02 04:35:29              luxbock </span><code>(into {} (for [[k v] fff] [k (mapv :foo v)]))</code></div><div data-t="luxbock where  fff  is  {:x [{:foo &quot;hello&quot; :bar [2 4]} {:foo &quot;there&quot;}] :y [{:foo &quot;moo&quot;   :bar [2 4]} {:foo &quot;world&quot;}]}"><span class="u" id="1464842157.000195">2016:06:02 04:35:57              luxbock </span><span>where </span><code>fff</code><span> is </span><code>{:x [{:foo &quot;hello&quot; :bar [2 4]} {:foo &quot;there&quot;}] :y [{:foo &quot;moo&quot;   :bar [2 4]} {:foo &quot;world&quot;}]}</code></div><div data-t="luxbock and the desired output is  {:x [&quot;hello&quot; &quot;there&quot;], :y [&quot;moo&quot; &quot;world&quot;]}"><span class="u" id="1464842169.000196">2016:06:02 04:36:09              luxbock </span><span>and the desired output is </span><code>{:x [&quot;hello&quot; &quot;there&quot;], :y [&quot;moo&quot; &quot;world&quot;]}</code></div><div data-t="luxbock my problem is that all of my attempts at selecting the key  :foo  throw away the surrounding context of the vector"><span class="u" id="1464842205.000197">2016:06:02 04:36:45              luxbock </span><span>my problem is that all of my attempts at selecting the key </span><code>:foo</code><span> throw away the surrounding context of the vector</span></div><div data-t="nathanmarz @luxbock:  (transform [ALL LAST ALL] :foo fff)"><span class="u" id="1464842566.000198">2016:06:02 04:42:46           nathanmarz </span><span>@luxbock: </span><code>(transform [ALL LAST ALL] :foo fff)</code></div><div data-t="luxbock @nathanmarz: thanks, I finally got it but my way was using  select-one  which I guess I don&apos;t need"><span class="u" id="1464842653.000199">2016:06:02 04:44:13              luxbock </span><span>@nathanmarz: thanks, I finally got it but my way was using </span><code>select-one</code><span> which I guess I don&apos;t need</span></div><div data-t="nathanmarz what did your select-one solution look like?"><span class="u" id="1464842787.000200">2016:06:02 04:46:27           nathanmarz </span><span>what did your select-one solution look like?</span></div><div data-t="luxbock (transform [VALS ALL (collect-one :foo)] (fn [x y] x) fff) , where  VALS  is  ALL LAST"><span class="u" id="1464842841.000202">2016:06:02 04:47:21              luxbock </span><code>(transform [VALS ALL (collect-one :foo)] (fn [x y] x) fff)</code><span>, where </span><code>VALS</code><span> is </span><code>ALL LAST</code></div><div data-t="luxbock oh yeah, I meant to say  collect-one"><span class="u" id="1464842864.000203">2016:06:02 04:47:44              luxbock </span><span>oh yeah, I meant to say </span><code>collect-one</code></div><div data-t="luxbock how about if I want to return  [[&quot;hello&quot; &quot;there&quot;] [&quot;moo&quot; &quot;world&quot;]] ?"><span class="u" id="1464843025.000204">2016:06:02 04:50:25              luxbock </span><span>how about if I want to return </span><code>[[&quot;hello&quot; &quot;there&quot;] [&quot;moo&quot; &quot;world&quot;]]</code><span>?</span></div><div data-t="nathanmarz yea, besides being more concise my version will be much faster"><span class="u" id="1464843028.000205">2016:06:02 04:50:28           nathanmarz </span><span>yea, besides being more concise my version will be much faster</span></div><div data-t="nathanmarz  (select [ALL LAST (subselect ALL :foo)] fff)"><span class="u" id="1464843109.000206">2016:06:02 04:51:49           nathanmarz </span><code> (select [ALL LAST (subselect ALL :foo)] fff)</code></div><div data-t="luxbock ah great, thanks again"><span class="u" id="1464843238.000207">2016:06:02 04:53:58              luxbock </span><span>ah great, thanks again</span></div><div data-t="luxbock yeah  subselect  is mentioned at the very bottom of the README so I didn&apos;t spot it as something I should&apos;ve looked into"><span class="u" id="1464843313.000208">2016:06:02 04:55:13              luxbock </span><span>yeah </span><code>subselect</code><span> is mentioned at the very bottom of the README so I didn&apos;t spot it as something I should&apos;ve looked into</span></div><div data-t="luxbock there are currently no API docs for specter right?"><span class="u" id="1464843329.000209">2016:06:02 04:55:29              luxbock </span><span>there are currently no API docs for specter right?</span></div><div data-t="nathanmarz well the files themselves are documented"><span class="u" id="1464843346.000210">2016:06:02 04:55:46           nathanmarz </span><span>well the files themselves are documented</span></div><div data-t="nathanmarz I suppose I should generate some html"><span class="u" id="1464843355.000211">2016:06:02 04:55:55           nathanmarz </span><span>I suppose I should generate some html</span></div><div data-t="luxbock I also noticed that many of the core functions lack doc strings"><span class="u" id="1464843454.000212">2016:06:02 04:57:34              luxbock </span><span>I also noticed that many of the core functions lack doc strings</span></div><div data-t="nathanmarz specter.cljx mostly has docstrings"><span class="u" id="1464843506.000213">2016:06:02 04:58:26           nathanmarz </span><span>specter.cljx mostly has docstrings</span></div><div data-t="nathanmarz but yea I agree the docs could use substantial work"><span class="u" id="1464843527.000214">2016:06:02 04:58:47           nathanmarz </span><span>but yea I agree the docs could use substantial work</span></div><div data-t="nathanmarz @luxbock: Any suggestions for documentation improvements would be appreciated  https://github.com/nathanmarz/specter/issues/56"><span class="u" id="1464843935.000215">2016:06:02 05:05:35           nathanmarz </span><span>@luxbock: Any suggestions for documentation improvements would be appreciated </span><a href="https://github.com/nathanmarz/specter/issues/56">https://github.com/nathanmarz/specter/issues/56</a></div><div data-t="luxbock sure"><span class="u" id="1464844016.000217">2016:06:02 05:06:56              luxbock </span><span>sure</span></div><div data-t="luxbock it appears that  collect  and  collect-one  are identical"><span class="u" id="1464848551.000222">2016:06:02 06:22:31              luxbock </span><span>it appears that </span><code>collect</code><span> and </span><code>collect-one</code><span> are identical</span></div><div data-t="nathanmarz @luxbock: they&apos;re not"><span class="u" id="1464849580.000223">2016:06:02 06:39:40           nathanmarz </span><span>@luxbock: they&apos;re not</span></div><div data-t="nathanmarz same difference as between  select  and  select-one"><span class="u" id="1464849589.000224">2016:06:02 06:39:49           nathanmarz </span><span>same difference as between </span><code>select</code><span> and </span><code>select-one</code></div><div data-t="luxbock ah, yeah you are right, I misread the source. need more coffee"><span class="u" id="1464850195.000225">2016:06:02 06:49:55              luxbock </span><span>ah, yeah you are right, I misread the source. need more coffee</span></div><div data-t="nathanmarz finally generated api docs  https://nathanmarz.github.io/specter/"><span class="u" id="1464883684.000227">2016:06:02 16:08:04           nathanmarz </span><span>finally generated api docs </span><a href="https://nathanmarz.github.io/specter/">https://nathanmarz.github.io/specter/</a></div><div data-t="darwin hi, is recursive navigation supported under cljs in 0.11, I have troubles calling  extend-protocolpath"><span class="u" id="1464958735.000230">2016:06:03 12:58:55               darwin </span><span>hi, is recursive navigation supported under cljs in 0.11, I have troubles calling </span><code>extend-protocolpath</code></div><div data-t="darwin it complains  Use of undeclared Var com.rpl.specter.impl/extend-protocolpath*"><span class="u" id="1464958759.000231">2016:06:03 12:59:19               darwin </span><span>it complains </span><code>Use of undeclared Var com.rpl.specter.impl/extend-protocolpath*</code></div><div data-t="darwin and indeed it looks there is only #+clj implementation:
 https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L1085"><span class="u" id="1464958808.000232">2016:06:03 13:00:08               darwin </span><span>and indeed it looks there is only #+clj implementation:
</span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L1085">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L1085</a></div><div data-t="nathanmarz protocol paths don&apos;t work in clojurescript version"><span class="u" id="1464958810.000234">2016:06:03 13:00:10           nathanmarz </span><span>protocol paths don&apos;t work in clojurescript version</span></div><div data-t="nathanmarz you can still do recursive navigation without protocol paths"><span class="u" id="1464958819.000235">2016:06:03 13:00:19           nathanmarz </span><span>you can still do recursive navigation without protocol paths</span></div><div data-t="darwin thanks, any pointer to some example? I’m pretty new to specter"><span class="u" id="1464958839.000236">2016:06:03 13:00:39               darwin </span><span>thanks, any pointer to some example? I’m pretty new to specter</span></div><div data-t="nathanmarz the last example on the README"><span class="u" id="1464958846.000237">2016:06:03 13:00:46           nathanmarz </span><span>the last example on the README</span></div><div data-t="nathanmarz (declarepath TreeValues)

(providepath TreeValues
  (if-path vector?
    [ALL TreeValues]
    STAY
    ))
"><span class="u" id="1464958857.000238">2016:06:03 13:00:57           nathanmarz </span><pre>(declarepath TreeValues)

(providepath TreeValues
  (if-path vector?
    [ALL TreeValues]
    STAY
    ))
</pre></div><div data-t="darwin it looks like insanely powerful tool when mastered btw. thanks a bunch!"><span class="u" id="1464958879.000239">2016:06:03 13:01:19               darwin </span><span>it looks like insanely powerful tool when mastered btw. thanks a bunch!</span></div><div data-t="nathanmarz (transform [TreeValues even?] - [[1 2] [[3] 4] [6 [8 9 10]]])
;; =&gt; [[1 -2] [[3] -4] [-6 [-8 9 -10]]]
"><span class="u" id="1464958924.000240">2016:06:03 13:02:04           nathanmarz </span><pre>(transform [TreeValues even?] - [[1 2] [[3] 4] [6 [8 9 10]]])
;; =&gt; [[1 -2] [[3] -4] [-6 [-8 9 -10]]]
</pre></div><div data-t="darwin got it, going to take that route"><span class="u" id="1464958938.000241">2016:06:03 13:02:18               darwin </span><span>got it, going to take that route</span></div><div data-t="nathanmarz also look at  continue-then-stay  and  stay-then-continue  for doing post-order or pre-order traversals"><span class="u" id="1464959012.000242">2016:06:03 13:03:32           nathanmarz </span><span>also look at </span><code>continue-then-stay</code><span> and </span><code>stay-then-continue</code><span> for doing post-order or pre-order traversals</span></div><div data-t="darwin I’m probably missing something, here is my current code, cannot make it work,  want?  predicate is never called according to that log statement, I call filter-rep and then pprint it to string, so possible laziness should NOT prevent those calls,  https://gist.github.com/darwin/9a2673fdb2448132c6d1908195df0932"><span class="u" id="1464960180.000243">2016:06:03 13:23:00               darwin </span><span>I’m probably missing something, here is my current code, cannot make it work, </span><code>want?</code><span> predicate is never called according to that log statement, I call filter-rep and then pprint it to string, so possible laziness should NOT prevent those calls, </span><a href="https://gist.github.com/darwin/9a2673fdb2448132c6d1908195df0932">https://gist.github.com/darwin/9a2673fdb2448132c6d1908195df0932</a></div><div data-t="darwin I’d like to use specter as filter for filtering scraped DOM structure for my tests"><span class="u" id="1464960240.000245">2016:06:03 13:24:00               darwin </span><span>I’d like to use specter as filter for filtering scraped DOM structure for my tests</span></div><div data-t="nathanmarz yea, your path is incorrect"><span class="u" id="1464960360.000246">2016:06:03 13:26:00           nathanmarz </span><span>yea, your path is incorrect</span></div><div data-t="nathanmarz it only navigates you to elements of :children sequences that aren&apos;t maps"><span class="u" id="1464960376.000247">2016:06:03 13:26:16           nathanmarz </span><span>it only navigates you to elements of :children sequences that aren&apos;t maps</span></div><div data-t="nathanmarz try this path:"><span class="u" id="1464960383.000248">2016:06:03 13:26:23           nathanmarz </span><span>try this path:</span></div><div data-t="nathanmarz (declarepath MyWalker)
(providepath MyWalker
  (continue-then-stay
    :children
    ALL
    MyWalker
    ))
"><span class="u" id="1464960428.000250">2016:06:03 13:27:08           nathanmarz </span><pre>(declarepath MyWalker)
(providepath MyWalker
  (continue-then-stay
    :children
    ALL
    MyWalker
    ))
</pre></div><div data-t="nathanmarz that navigates you to every map"><span class="u" id="1464960452.000251">2016:06:03 13:27:32           nathanmarz </span><span>that navigates you to every map</span></div><div data-t="darwin thanks, that works"><span class="u" id="1464960644.000252">2016:06:03 13:30:44               darwin </span><span>thanks, that works</span></div><div data-t="darwin what if I need to traverse down both into  :children  and/or  :children2  if present"><span class="u" id="1464960707.000253">2016:06:03 13:31:47               darwin </span><span>what if I need to traverse down both into </span><code>:children</code><span> and/or </span><code>:children2</code><span> if present</span></div><div data-t="nathanmarz use  multi-path  +  must"><span class="u" id="1464960777.000254">2016:06:03 13:32:57           nathanmarz </span><span>use </span><code>multi-path</code><span> + </span><code>must</code></div><div data-t="nathanmarz (declarepath MyWalker)
(providepath MyWalker
  (continue-then-stay
    (multi-path (must :children) (must :children2))
    ALL
    MyWalker
    ))
"><span class="u" id="1464960788.000255">2016:06:03 13:33:08           nathanmarz </span><pre>(declarepath MyWalker)
(providepath MyWalker
  (continue-then-stay
    (multi-path (must :children) (must :children2))
    ALL
    MyWalker
    ))
</pre></div><div data-t="darwin looks good, thanks a lot"><span class="u" id="1464960803.000258">2016:06:03 13:33:23               darwin </span><span>looks good, thanks a lot</span></div><div data-t="nathanmarz no problem"><span class="u" id="1464960817.000259">2016:06:03 13:33:37           nathanmarz </span><span>no problem</span></div><div data-t="nathanmarz nice!"><span class="u" id="1464961105.000261">2016:06:03 13:38:25           nathanmarz </span><span>nice!</span></div><div data-t="nathanmarz you can make it a little more concise like this:
 (providepath MyWalker
  (continue-then-stay
    (multi-path
      [(must :children) ALL]
      (must :shadowRoot))
    MyWalker))
"><span class="u" id="1464961138.000262">2016:06:03 13:38:58           nathanmarz </span><span>you can make it a little more concise like this:
</span><pre>(providepath MyWalker
  (continue-then-stay
    (multi-path
      [(must :children) ALL]
      (must :shadowRoot))
    MyWalker))
</pre></div><div data-t="darwin cool! I have a feeling this will be a “jquery” on steroids  🙂"><span class="u" id="1464961186.000263">2016:06:03 13:39:46               darwin </span><span>cool! I have a feeling this will be a “jquery” on steroids </span><b>🙂</b></div><div data-t="nathanmarz 🙂"><span class="u" id="1464961208.000264">2016:06:03 13:40:08           nathanmarz </span><b>🙂</b></div><div data-t="darwin getting some warnings when compiling specter’s impl namespace:
 https://gist.github.com/darwin/90bcb9a87d7f1b492cd6d6400bcd103c#file-impl-cljs-L3"><span class="u" id="1464968121.000265">2016:06:03 15:35:21               darwin </span><span>getting some warnings when compiling specter’s impl namespace:
</span><a href="https://gist.github.com/darwin/90bcb9a87d7f1b492cd6d6400bcd103c#file-impl-cljs-L3">https://gist.github.com/darwin/90bcb9a87d7f1b492cd6d6400bcd103c#file-impl-cljs-L3</a></div><div data-t="darwin not sure about bootstrap, but cljs.js should be cljs.core in my case, I’m not in bootstrapped environment"><span class="u" id="1464968190.000268">2016:06:03 15:36:30               darwin </span><span>not sure about bootstrap, but cljs.js should be cljs.core in my case, I’m not in bootstrapped environment</span></div><div data-t="nathanmarz You can ignore the warnings, and they&apos;re fixed for the next version:  https://github.com/nathanmarz/specter/issues/97"><span class="u" id="1464968252.000269">2016:06:03 15:37:32           nathanmarz </span><span>You can ignore the warnings, and they&apos;re fixed for the next version: </span><a href="https://github.com/nathanmarz/specter/issues/97">https://github.com/nathanmarz/specter/issues/97</a></div><div data-t="nathanmarz They have to do with code that&apos;s specifically for bootstrap cljs"><span class="u" id="1464968273.000271">2016:06:03 15:37:53           nathanmarz </span><span>They have to do with code that&apos;s specifically for bootstrap cljs</span></div><div data-t="darwin ok, np, btw. I was searching open issues first and didn’t find anything related"><span class="u" id="1464968317.000272">2016:06:03 15:38:37               darwin </span><span>ok, np, btw. I was searching open issues first and didn’t find anything related</span></div><div data-t="luxbock is there anything in specter that would allow me to do the following without resorting to the core functions I&apos;m currently using:
 (reduce + (map count (select [VALS] {:a [1 2 3] :b [5 6]}))) , or
 (reduce + (vals (transform [VALS] count {:a [1 2 3] :b [5 6]})))  ?"><span class="u" id="1465045318.000017">2016:06:04 13:01:58              luxbock </span><span>is there anything in specter that would allow me to do the following without resorting to the core functions I&apos;m currently using:
</span><code>(reduce + (map count (select [VALS] {:a [1 2 3] :b [5 6]})))</code><span>, or
</span><code>(reduce + (vals (transform [VALS] count {:a [1 2 3] :b [5 6]})))</code><span> ?</span></div><div data-t="nathanmarz is this what you want?  (select-one [(subselect ALL LAST ALL) (view count)] DATA)"><span class="u" id="1465045563.000018">2016:06:04 13:06:03           nathanmarz </span><span>is this what you want? </span><code>(select-one [(subselect ALL LAST ALL) (view count)] DATA)</code></div><div data-t="nathanmarz you could also do  (count (select [ALL LAST ALL] DATA))"><span class="u" id="1465045638.000019">2016:06:04 13:07:18           nathanmarz </span><span>you could also do </span><code>(count (select [ALL LAST ALL] DATA))</code></div><div data-t="luxbock yeah both of those work, thanks"><span class="u" id="1465045757.000020">2016:06:04 13:09:17              luxbock </span><span>yeah both of those work, thanks</span></div><div data-t="luxbock I&apos;m in a phase where I&apos;m trying to figure out where the line between using specter to do things, and having to break out of it to use the core functions is"><span class="u" id="1465045887.000021">2016:06:04 13:11:27              luxbock </span><span>I&apos;m in a phase where I&apos;m trying to figure out where the line between using specter to do things, and having to break out of it to use the core functions is</span></div><div data-t="luxbock that line is probably quite high once you get familiar with all the features packed in  🙂"><span class="u" id="1465045917.000022">2016:06:04 13:11:57              luxbock </span><span>that line is probably quite high once you get familiar with all the features packed in </span><b>🙂</b></div><div data-t="nathanmarz I&apos;m still in that phase  🙂"><span class="u" id="1465045923.000023">2016:06:04 13:12:03           nathanmarz </span><span>I&apos;m still in that phase </span><b>🙂</b></div><div data-t="nathanmarz the line has gotten higher and higher over time as I&apos;ve realized how many things can be expressed elegantly in terms of navigation"><span class="u" id="1465045962.000024">2016:06:04 13:12:42           nathanmarz </span><span>the line has gotten higher and higher over time as I&apos;ve realized how many things can be expressed elegantly in terms of navigation</span></div><div data-t="luxbock it feels a bit like when I first got comfortable with thinking about all Clojure problems as just transforming data back and fourth beetween the core data types and functions, it feels great!"><span class="u" id="1465045976.000025">2016:06:04 13:12:56              luxbock </span><span>it feels a bit like when I first got comfortable with thinking about all Clojure problems as just transforming data back and fourth beetween the core data types and functions, it feels great!</span></div><div data-t="nathanmarz assuming your learning trajectory is similar to what mine was, prepare for a very rewarding ride"><span class="u" id="1465046069.000026">2016:06:04 13:14:29           nathanmarz </span><span>assuming your learning trajectory is similar to what mine was, prepare for a very rewarding ride</span></div><div data-t="nathanmarz a big moment for me was figuring out the &quot;sub{x}&quot; navigators"><span class="u" id="1465046129.000027">2016:06:04 13:15:29           nathanmarz </span><span>a big moment for me was figuring out the &quot;sub{x}&quot; navigators</span></div><div data-t="nathanmarz subset and then subgraph"><span class="u" id="1465046145.000028">2016:06:04 13:15:45           nathanmarz </span><span>subset and then subgraph</span></div><div data-t="benzap If I have a row-major matrix, would this be the best way to retrieve a sub-matrix?

  `"><span class="u" id="1465080901.000059">2016:06:04 22:55:01               benzap </span><span>If I have a row-major matrix, would this be the best way to retrieve a sub-matrix?

</span><code></code><span>`</span></div><div data-t="benzap (defn NAV-SUBMAT [i j rows cols]
  [specter/ALL (specter/srange i (+ i cols)) [(specter/srange j (+ j rows)) specter/ALL]])"><span class="u" id="1465080912.000060">2016:06:04 22:55:12               benzap </span><span>(defn NAV-SUBMAT [i j rows cols]
  [specter/ALL (specter/srange i (+ i cols)) [(specter/srange j (+ j rows)) specter/ALL]])</span></div><div data-t="benzap oh woops, that doesn&apos;t work"><span class="u" id="1465081148.000061">2016:06:04 22:59:08               benzap </span><span>oh woops, that doesn&apos;t work</span></div><div data-t="benzap This is what I was doing before, but I feel like it can be better
`(-&gt;&gt; content
             (specter/select [specter/ALL (specter/srange col-offset (+ cols col-offset))])
             (specter/select [(specter/srange row-offset (+ rows row-offset)) specter/ALL]))`"><span class="u" id="1465081187.000062">2016:06:04 22:59:47               benzap </span><span>This is what I was doing before, but I feel like it can be better
`(-&gt;&gt; content
             (specter/select [specter/ALL (specter/srange col-offset (+ cols col-offset))])
             (specter/select [(specter/srange row-offset (+ rows row-offset)) specter/ALL]))`</span></div><div data-t="benzap it was backwards, this seems to work: 

(defn NAV-SUBMAT [i j rows cols]
  [[(specter/srange j (+ j rows)) specter/ALL] (specter/srange i (+ i cols))])"><span class="u" id="1465081517.000063">2016:06:04 23:05:17               benzap </span><span>it was backwards, this seems to work: 

(defn NAV-SUBMAT [i j rows cols]
  [[(specter/srange j (+ j rows)) specter/ALL] (specter/srange i (+ i cols))])</span></div><div data-t="roberto is there a way to chain transformations?"><span class="u" id="1465185169.000152">2016:06:06 03:52:49              roberto </span><span>is there a way to chain transformations?</span></div><div data-t="roberto nvm"><span class="u" id="1465185296.000153">2016:06:06 03:54:56              roberto </span><span>nvm</span></div><div data-t="rodeorockstar this might be a silly question, but is specter/collect intended to be used in conjunction with specter/select, or is it strictly for transformations?"><span class="u" id="1465305714.000254">2016:06:07 13:21:54        rodeorockstar </span><span>this might be a silly question, but is specter/collect intended to be used in conjunction with specter/select, or is it strictly for transformations?</span></div><div data-t="nathanmarz @rodeorockstar I use it sometimes with  select"><span class="u" id="1465306265.000256">2016:06:07 13:31:05           nathanmarz </span><span>@rodeorockstar I use it sometimes with </span><code>select</code></div><div data-t="nathanmarz It just lets you get more information about the context of each value"><span class="u" id="1465306308.000257">2016:06:07 13:31:48           nathanmarz </span><span>It just lets you get more information about the context of each value</span></div><div data-t="rodeorockstar yeah, definitely useful when i&apos;ve needed it in the past, but i&apos;ve only used it for transformations where the collected data is passed to the transformation function"><span class="u" id="1465306352.000258">2016:06:07 13:32:32        rodeorockstar </span><span>yeah, definitely useful when i&apos;ve needed it in the past, but i&apos;ve only used it for transformations where the collected data is passed to the transformation function</span></div><div data-t="rodeorockstar when used with select are collected keys just merged into the result of the select?"><span class="u" id="1465306383.000259">2016:06:07 13:33:03        rodeorockstar </span><span>when used with select are collected keys just merged into the result of the select?</span></div><div data-t="nathanmarz yea, each result becomes a vector with the final navigated to value as the final element in the vector"><span class="u" id="1465306595.000260">2016:06:07 13:36:35           nathanmarz </span><span>yea, each result becomes a vector with the final navigated to value as the final element in the vector</span></div><div data-t="rodeorockstar ah, that makes a lot more sense now"><span class="u" id="1465306620.000261">2016:06:07 13:37:00        rodeorockstar </span><span>ah, that makes a lot more sense now</span></div><div data-t="nathanmarz (select VAL 1)  -&gt;  [[1 1]]"><span class="u" id="1465306643.000262">2016:06:07 13:37:23           nathanmarz </span><code>(select VAL 1)</code><span> -&gt; </span><code>[[1 1]]</code></div><div data-t="rodeorockstar thanks for the help  🙂"><span class="u" id="1465306860.000263">2016:06:07 13:41:00        rodeorockstar </span><span>thanks for the help </span><b>🙂</b></div><div data-t="nathanmarz no problem"><span class="u" id="1465306927.000264">2016:06:07 13:42:07           nathanmarz </span><span>no problem</span></div><div data-t="quantisan I&apos;m trying to replace my  group-by /`merge-with` logic, any suggestion on how to transform:

 {:1000 {:a {:sends 1}}
 :2000 {:a {:clicks 1 :opens 1 :sends 1}}
 :3000 {:b {:sends 1 :opens 1}}}
 

into

 {:a {:sends 2 :opens 1 :clicks 1}
 :b {:sends 1 :opens 1}}
"><span class="u" id="1465390896.000339">2016:06:08 13:01:36            quantisan </span><span>I&apos;m trying to replace my </span><code>group-by</code><span>/`merge-with` logic, any suggestion on how to transform:

</span><pre>{:1000 {:a {:sends 1}}
 :2000 {:a {:clicks 1 :opens 1 :sends 1}}
 :3000 {:b {:sends 1 :opens 1}}}
</pre><span>

into

</span><pre>{:a {:sends 2 :opens 1 :clicks 1}
 :b {:sends 1 :opens 1}}
</pre></div><div data-t="nathanmarz I don&apos;t see a way to express that in terms of navigation"><span class="u" id="1465391715.000340">2016:06:08 13:15:15           nathanmarz </span><span>I don&apos;t see a way to express that in terms of navigation</span></div><div data-t="quantisan here&apos;s my current ugly solution:

 (-&gt;&gt; {:1000 {:a {:sends 1}}
      :2000 {:a {:clicks 1 :opens 1 :sends 1}}
      :3000 {:b {:sends 1 :opens 1}}}
     (select [ALL LAST])
     (group-by (comp first keys))
     (transform [ALL LAST]
                #(select [ALL LAST LAST] %))
     (transform [ALL LAST]
                (partial apply merge-with +)))
"><span class="u" id="1465391833.000341">2016:06:08 13:17:13            quantisan </span><span>here&apos;s my current ugly solution:

</span><pre>(-&gt;&gt; {:1000 {:a {:sends 1}}
      :2000 {:a {:clicks 1 :opens 1 :sends 1}}
      :3000 {:b {:sends 1 :opens 1}}}
     (select [ALL LAST])
     (group-by (comp first keys))
     (transform [ALL LAST]
                #(select [ALL LAST LAST] %))
     (transform [ALL LAST]
                (partial apply merge-with +)))
</pre></div><div data-t="nathanmarz hmm"><span class="u" id="1465392097.000342">2016:06:08 13:21:37           nathanmarz </span><span>hmm</span></div><div data-t="nathanmarz (defn merge-with* [f maps]
  (apply merge-with f maps)
  )

(merge-with* (fn [&amp; maps] (merge-with* + maps)) (vals data))
"><span class="u" id="1465392112.000343">2016:06:08 13:21:52           nathanmarz </span><pre>(defn merge-with* [f maps]
  (apply merge-with f maps)
  )

(merge-with* (fn [&amp; maps] (merge-with* + maps)) (vals data))
</pre></div><div data-t="nathanmarz maybe you could define a merge-with navigator somehow"><span class="u" id="1465392133.000344">2016:06:08 13:22:13           nathanmarz </span><span>maybe you could define a merge-with navigator somehow</span></div><div data-t="nathanmarz like from a sequence of maps you navigate to a sequence of values for any given key"><span class="u" id="1465392219.000345">2016:06:08 13:23:39           nathanmarz </span><span>like from a sequence of maps you navigate to a sequence of values for any given key</span></div><div data-t="nathanmarz so then you could do  (transform [MERGED-MAPS MERGED-MAPS] sum (vals data))"><span class="u" id="1465392307.000346">2016:06:08 13:25:07           nathanmarz </span><span>so then you could do </span><pre>(transform [MERGED-MAPS MERGED-MAPS] sum (vals data))</pre></div><div data-t="nathanmarz yea it works"><span class="u" id="1465392422.000347">2016:06:08 13:27:02           nathanmarz </span><span>yea it works</span></div><div data-t="nathanmarz (defnav MERGED-MAPS []
  (select* [this structure next-fn]
    ;;TODO: fill this in
    )
  (transform* [this structure next-fn]
    (apply merge-with (fn [&amp; vals] (next-fn vals)) structure)
    ))


(defn sum [vals] (reduce + vals))



(def data
 {:1000 {:a {:sends 1}}
  :2000 {:a {:clicks 1 :opens 1 :sends 1}}
  :3000 {:b {:sends 1 :opens 1}}})

(transform [MERGED-MAPS MERGED-MAPS] sum (vals data))
"><span class="u" id="1465392484.000348">2016:06:08 13:28:04           nathanmarz </span><pre>(defnav MERGED-MAPS []
  (select* [this structure next-fn]
    ;;TODO: fill this in
    )
  (transform* [this structure next-fn]
    (apply merge-with (fn [&amp; vals] (next-fn vals)) structure)
    ))


(defn sum [vals] (reduce + vals))



(def data
 {:1000 {:a {:sends 1}}
  :2000 {:a {:clicks 1 :opens 1 :sends 1}}
  :3000 {:b {:sends 1 :opens 1}}})

(transform [MERGED-MAPS MERGED-MAPS] sum (vals data))
</pre></div><div data-t="quantisan @nathanmarz: magic  😉"><span class="u" id="1465392538.000349">2016:06:08 13:28:58            quantisan </span><span>@nathanmarz: magic </span><b>😉</b></div><div data-t="nathanmarz I do what I can"><span class="u" id="1465392637.000350">2016:06:08 13:30:37           nathanmarz </span><span>I do what I can</span></div><div data-t="nathanmarz oops, had  sum  written incorrectly there"><span class="u" id="1465393168.000353">2016:06:08 13:39:28           nathanmarz </span><span>oops, had </span><code>sum</code><span> written incorrectly there</span></div><div data-t="nathanmarz now it&apos;s fixed"><span class="u" id="1465393175.000354">2016:06:08 13:39:35           nathanmarz </span><span>now it&apos;s fixed</span></div><div data-t="aengelberg @nathanmarz I agree with your point about  OMIT . My main reasoning for proposing it was that it allows you to control which layer of the path you want to pass  NONE  to. For example:
 (transform [ALL (if-path ... STAY OMIT) ALL (if-path ... STAY OMIT) :a (if-path ... STAY OMIT) ...] ...)
 
Is there a more idiomatic way to do this without coupling the navigation and the transformation as tightly?"><span class="u" id="1465413780.000379">2016:06:08 19:23:00           aengelberg </span><span>@nathanmarz I agree with your point about </span><code>OMIT</code><span>. My main reasoning for proposing it was that it allows you to control which layer of the path you want to pass </span><code>NONE</code><span> to. For example:
</span><pre>(transform [ALL (if-path ... STAY OMIT) ALL (if-path ... STAY OMIT) :a (if-path ... STAY OMIT) ...] ...)
</pre><span>
Is there a more idiomatic way to do this without coupling the navigation and the transformation as tightly?</span></div><div data-t="nathanmarz well I think what you want is a single operation that can do multiple transforms"><span class="u" id="1465416708.000384">2016:06:08 20:11:48           nathanmarz </span><span>well I think what you want is a single operation that can do multiple transforms</span></div><div data-t="nathanmarz @aengelberg as it stands now  transform  does a single transform to all navigated elements"><span class="u" id="1465416735.000385">2016:06:08 20:12:15           nathanmarz </span><span>@aengelberg as it stands now </span><code>transform</code><span> does a single transform to all navigated elements</span></div><div data-t="nathanmarz I&apos;ve thought a bit about this, and basically you could imagine a different transform API that does not take in a transform-fn at the top-level"><span class="u" id="1465416771.000386">2016:06:08 20:12:51           nathanmarz </span><span>I&apos;ve thought a bit about this, and basically you could imagine a different transform API that does not take in a transform-fn at the top-level</span></div><div data-t="nathanmarz (multi-transform [ALL (if-path even? (setval-transform 2) (setval-transform NONE))] data)"><span class="u" id="1465416815.000387">2016:06:08 20:13:35           nathanmarz </span><span>(multi-transform [ALL (if-path even? (setval-transform 2) (setval-transform NONE))] data)</span></div><div data-t="aengelberg The question being whether it&apos;s worth an exception being made for the &quot;specter abstracts the path from the transformation&quot; idea"><span class="u" id="1465416917.000388">2016:06:08 20:15:17           aengelberg </span><span>The question being whether it&apos;s worth an exception being made for the &quot;specter abstracts the path from the transformation&quot; idea</span></div><div data-t="nathanmarz yea"><span class="u" id="1465416945.000389">2016:06:08 20:15:45           nathanmarz </span><span>yea</span></div><div data-t="nathanmarz that&apos;s basically why I&apos;ve held off on this"><span class="u" id="1465416956.000390">2016:06:08 20:15:56           nathanmarz </span><span>that&apos;s basically why I&apos;ve held off on this</span></div><div data-t="nathanmarz and also I&apos;ve gotten by just chaining multiple transformations"><span class="u" id="1465416995.000391">2016:06:08 20:16:35           nathanmarz </span><span>and also I&apos;ve gotten by just chaining multiple transformations</span></div><div data-t="nathanmarz (-&gt;&gt; data (transform ...) (transform ...))"><span class="u" id="1465417008.000392">2016:06:08 20:16:48           nathanmarz </span><code>(-&gt;&gt; data (transform ...) (transform ...))</code></div><div data-t="aengelberg But that&apos;s less efficient right?"><span class="u" id="1465417069.000393">2016:06:08 20:17:49           aengelberg </span><span>But that&apos;s less efficient right?</span></div><div data-t="nathanmarz yea, which is why I keep thinking about this  🙂"><span class="u" id="1465417080.000394">2016:06:08 20:18:00           nathanmarz </span><span>yea, which is why I keep thinking about this </span><b>🙂</b></div><div data-t="aengelberg heh"><span class="u" id="1465417096.000395">2016:06:08 20:18:16           aengelberg </span><span>heh</span></div><div data-t="nathanmarz that said, I don&apos;t think places where I do that are bottlenecks for me"><span class="u" id="1465417111.000396">2016:06:08 20:18:31           nathanmarz </span><span>that said, I don&apos;t think places where I do that are bottlenecks for me</span></div><div data-t="aengelberg Btw I&apos;ve been thinking about the new select semantics, there may be an opportunity to introduce transducers"><span class="u" id="1465417121.000397">2016:06:08 20:18:41           aengelberg </span><span>Btw I&apos;ve been thinking about the new select semantics, there may be an opportunity to introduce transducers</span></div><div data-t="aengelberg Since the continuation is basically a &quot;reducer&quot;"><span class="u" id="1465417139.000398">2016:06:08 20:18:59           aengelberg </span><span>Since the continuation is basically a &quot;reducer&quot;</span></div><div data-t="nathanmarz mm"><span class="u" id="1465417195.000399">2016:06:08 20:19:55           nathanmarz </span><span>mm</span></div><div data-t="nathanmarz hmm"><span class="u" id="1465417196.000400">2016:06:08 20:19:56           nathanmarz </span><span>hmm</span></div><div data-t="nathanmarz got an example?"><span class="u" id="1465417199.000401">2016:06:08 20:19:59           nathanmarz </span><span>got an example?</span></div><div data-t="aengelberg (select [ALL] (map inc) [1 2 3])
=&gt;
[2 3 4]
"><span class="u" id="1465417237.000402">2016:06:08 20:20:37           aengelberg </span><pre>(select [ALL] (map inc) [1 2 3])
=&gt;
[2 3 4]
</pre></div><div data-t="aengelberg (select-reduce conj [] [ALL] [1 2 3])
"><span class="u" id="1465417278.000403">2016:06:08 20:21:18           aengelberg </span><pre>(select-reduce conj [] [ALL] [1 2 3])
</pre></div><div data-t="aengelberg just some ideas. the latter would be achieved by storing the reduced value in a cell and repeatedly updating it"><span class="u" id="1465417346.000404">2016:06:08 20:22:26           aengelberg </span><span>just some ideas. the latter would be achieved by storing the reduced value in a cell and repeatedly updating it</span></div><div data-t="nathanmarz that last one would output [1 2 3]?"><span class="u" id="1465417362.000405">2016:06:08 20:22:42           nathanmarz </span><span>that last one would output [1 2 3]?</span></div><div data-t="aengelberg yes"><span class="u" id="1465417368.000406">2016:06:08 20:22:48           aengelberg </span><span>yes</span></div><div data-t="nathanmarz I&apos;m not following"><span class="u" id="1465417382.000407">2016:06:08 20:23:02           nathanmarz </span><span>I&apos;m not following</span></div><div data-t="aengelberg If I understand the new select semantics properly, the continuation (or &quot;final next-fn&quot;) is currently &quot;dump into a vector&quot;. I&apos;m proposing letting the user specify an alternative for that continuation"><span class="u" id="1465417431.000408">2016:06:08 20:23:51           aengelberg </span><span>If I understand the new select semantics properly, the continuation (or &quot;final next-fn&quot;) is currently &quot;dump into a vector&quot;. I&apos;m proposing letting the user specify an alternative for that continuation</span></div><div data-t="nathanmarz oh I see"><span class="u" id="1465417444.000409">2016:06:08 20:24:04           nathanmarz </span><span>oh I see</span></div><div data-t="nathanmarz well there are different continuations for the different selects"><span class="u" id="1465417452.000410">2016:06:08 20:24:12           nathanmarz </span><span>well there are different continuations for the different selects</span></div><div data-t="nathanmarz you basically want &quot;traverse&quot; exposed"><span class="u" id="1465417476.000411">2016:06:08 20:24:36           nathanmarz </span><span>you basically want &quot;traverse&quot; exposed</span></div><div data-t="aengelberg I just looked up  traverse , didn&apos;t realize that was generalizing the continuation internally. Yeah, that&apos;s basically what I&apos;m saying"><span class="u" id="1465417560.000412">2016:06:08 20:26:00           aengelberg </span><span>I just looked up </span><code>traverse</code><span>, didn&apos;t realize that was generalizing the continuation internally. Yeah, that&apos;s basically what I&apos;m saying</span></div><div data-t="nathanmarz I haven&apos;t completely internalized transducers yet"><span class="u" id="1465417729.000413">2016:06:08 20:28:49           nathanmarz </span><span>I haven&apos;t completely internalized transducers yet</span></div><div data-t="aengelberg transducer: reducer -&gt; reducer"><span class="u" id="1465417749.000414">2016:06:08 20:29:09           aengelberg </span><span>transducer: reducer -&gt; reducer</span></div><div data-t="nathanmarz yea"><span class="u" id="1465417756.000415">2016:06:08 20:29:16           nathanmarz </span><span>yea</span></div><div data-t="nathanmarz but basically it&apos;s like an aggregator that looks at its input one value at a time"><span class="u" id="1465417770.000416">2016:06:08 20:29:30           nathanmarz </span><span>but basically it&apos;s like an aggregator that looks at its input one value at a time</span></div><div data-t="nathanmarz and specter traverse looks at values one at a time"><span class="u" id="1465417787.000417">2016:06:08 20:29:47           nathanmarz </span><span>and specter traverse looks at values one at a time</span></div><div data-t="aengelberg exposing  traverse  isn&apos;t necessarily related at all to transducers"><span class="u" id="1465417836.000418">2016:06:08 20:30:36           aengelberg </span><span>exposing </span><code>traverse</code><span> isn&apos;t necessarily related at all to transducers</span></div><div data-t="nathanmarz but you&apos;re saying you could just plug in a transducer for that continuation fn"><span class="u" id="1465417865.000419">2016:06:08 20:31:05           nathanmarz </span><span>but you&apos;re saying you could just plug in a transducer for that continuation fn</span></div><div data-t="aengelberg err, my posting two examples above probably made things confusing."><span class="u" id="1465417888.000420">2016:06:08 20:31:28           aengelberg </span><span>err, my posting two examples above probably made things confusing.</span></div><div data-t="aengelberg My first example (providing  (map inc) ) was supplying a transducer to modify the hardcoded reducer"><span class="u" id="1465417919.000421">2016:06:08 20:31:59           aengelberg </span><span>My first example (providing </span><code>(map inc)</code><span>) was supplying a transducer to modify the hardcoded reducer</span></div><div data-t="aengelberg The second example (providing  conj ) was replacing the reducer"><span class="u" id="1465417925.000422">2016:06:08 20:32:05           aengelberg </span><span>The second example (providing </span><code>conj</code><span>) was replacing the reducer</span></div><div data-t="aengelberg You could potentially combine both"><span class="u" id="1465417935.000423">2016:06:08 20:32:15           aengelberg </span><span>You could potentially combine both</span></div><div data-t="aengelberg Except there isn&apos;t much advantage of providing both since the user can just call  (my-transducer my-reducer)  and get a reducer to pass in"><span class="u" id="1465417963.000425">2016:06:08 20:32:43           aengelberg </span><span>Except there isn&apos;t much advantage of providing both since the user can just call </span><code>(my-transducer my-reducer)</code><span> and get a reducer to pass in</span></div><div data-t="nathanmarz what if specter could just integrate into the normal transducer api?"><span class="u" id="1465418348.000426">2016:06:08 20:39:08           nathanmarz </span><span>what if specter could just integrate into the normal transducer api?</span></div><div data-t="nathanmarz (eduction xf (traverse [ALL :a even?] data))"><span class="u" id="1465418374.000428">2016:06:08 20:39:34           nathanmarz </span><code>(eduction xf (traverse [ALL :a even?] data))</code></div><div data-t="nathanmarz or even  (eduction xf (traverse [ALL :a even?]) data)"><span class="u" id="1465418395.000429">2016:06:08 20:39:55           nathanmarz </span><span>or even </span><code>(eduction xf (traverse [ALL :a even?]) data)</code></div><div data-t="nathanmarz actually the former probably makes more sense"><span class="u" id="1465418418.000430">2016:06:08 20:40:18           nathanmarz </span><span>actually the former probably makes more sense</span></div><div data-t="aengelberg the latter I think would actually be  (sequence (traverse [ALL :a even?]) data)"><span class="u" id="1465418591.000431">2016:06:08 20:43:11           aengelberg </span><span>the latter I think would actually be </span><code>(sequence (traverse [ALL :a even?]) data)</code></div><div data-t="aengelberg or  (sequence (comp xf (traverse [ALL :a even?])) data)"><span class="u" id="1465418622.000433">2016:06:08 20:43:42           aengelberg </span><span>or </span><code>(sequence (comp xf (traverse [ALL :a even?])) data)</code></div><div data-t="aengelberg Would  traverse  apply the transformation to each input form?"><span class="u" id="1465418701.000435">2016:06:08 20:45:01           aengelberg </span><span>Would </span><code>traverse</code><span> apply the transformation to each input form?</span></div><div data-t="aengelberg err select, not transformation"><span class="u" id="1465418720.000436">2016:06:08 20:45:20           aengelberg </span><span>err select, not transformation</span></div><div data-t="nathanmarz here I&apos;m thinking traverse would return an object that can be reduced"><span class="u" id="1465418722.000437">2016:06:08 20:45:22           nathanmarz </span><span>here I&apos;m thinking traverse would return an object that can be reduced</span></div><div data-t="aengelberg that makes more sense"><span class="u" id="1465418735.000438">2016:06:08 20:45:35           aengelberg </span><span>that makes more sense</span></div><div data-t="aengelberg i.e. implements  IReduce"><span class="u" id="1465418743.000439">2016:06:08 20:45:43           aengelberg </span><span>i.e. implements </span><code>IReduce</code></div><div data-t="nathanmarz yea"><span class="u" id="1465418748.000440">2016:06:08 20:45:48           nathanmarz </span><span>yea</span></div><div data-t="aengelberg :+1:"><span class="u" id="1465418750.000441">2016:06:08 20:45:50           aengelberg </span><b>:+1:</b></div><div data-t="aengelberg and we wouldn&apos;t have to worry about clojure 1.6 compatibility I don&apos;t think"><span class="u" id="1465418768.000442">2016:06:08 20:46:08           aengelberg </span><span>and we wouldn&apos;t have to worry about clojure 1.6 compatibility I don&apos;t think</span></div><div data-t="nathanmarz yea"><span class="u" id="1465418786.000443">2016:06:08 20:46:26           nathanmarz </span><span>yea</span></div><div data-t="nathanmarz although I think I might drop that soon anyway"><span class="u" id="1465418796.000444">2016:06:08 20:46:36           nathanmarz </span><span>although I think I might drop that soon anyway</span></div><div data-t="nathanmarz 1.9 is coming out and I&apos;m sick of cljx  😉"><span class="u" id="1465418820.000445">2016:06:08 20:47:00           nathanmarz </span><span>1.9 is coming out and I&apos;m sick of cljx </span><b>😉</b></div><div data-t="aengelberg I was working on a project last year but got stuck on leiningen issues. the idea was a plugin that would take cljc files and output clj / cljs similar to cljx"><span class="u" id="1465418872.000446">2016:06:08 20:47:52           aengelberg </span><span>I was working on a project last year but got stuck on leiningen issues. the idea was a plugin that would take cljc files and output clj / cljs similar to cljx</span></div><div data-t="nathanmarz that would have helped a lot"><span class="u" id="1465418892.000447">2016:06:08 20:48:12           nathanmarz </span><span>that would have helped a lot</span></div><div data-t="aengelberg the main motivation actually was for instaparse; we don&apos;t really want to pull in  instaparse-cljs  until a non-deprecated cross-compile solution exists"><span class="u" id="1465418934.000448">2016:06:08 20:48:54           aengelberg </span><span>the main motivation actually was for instaparse; we don&apos;t really want to pull in </span><code>instaparse-cljs</code><span> until a non-deprecated cross-compile solution exists</span></div><div data-t="aengelberg (that also works with &lt;1.7)"><span class="u" id="1465418993.000449">2016:06:08 20:49:53           aengelberg </span><span>(that also works with &lt;1.7)</span></div><div data-t="aengelberg maybe i&apos;ll pick it back up soon, the main blocking issue was leiningen&apos;s built-in tools.reader was too old (no longer an issue probably)"><span class="u" id="1465419039.000450">2016:06:08 20:50:39           aengelberg </span><span>maybe i&apos;ll pick it back up soon, the main blocking issue was leiningen&apos;s built-in tools.reader was too old (no longer an issue probably)</span></div><div data-t="nathanmarz any idea how many people are still on 1.6?"><span class="u" id="1465419062.000452">2016:06:08 20:51:02           nathanmarz </span><span>any idea how many people are still on 1.6?</span></div><div data-t="nathanmarz or below"><span class="u" id="1465419068.000453">2016:06:08 20:51:08           nathanmarz </span><span>or below</span></div><div data-t="aengelberg my previous job was still on 1.6 well into the lifetime of 1.8"><span class="u" id="1465419175.000454">2016:06:08 20:52:55           aengelberg </span><span>my previous job was still on 1.6 well into the lifetime of 1.8</span></div><div data-t="aengelberg just one data point, not sure how realistic it is to continue support for 1.6 especially with cider now on &gt;1.7"><span class="u" id="1465419220.000456">2016:06:08 20:53:40           aengelberg </span><span>just one data point, not sure how realistic it is to continue support for 1.6 especially with cider now on &gt;1.7</span></div><div data-t="aengelberg @nathanmarz shall I create a github issue for the reducible  traverse  idea?"><span class="u" id="1465431663.000468">2016:06:09 00:21:03           aengelberg </span><span>@nathanmarz shall I create a github issue for the reducible </span><code>traverse</code><span> idea?</span></div><div data-t="nathanmarz @aengelberg yea"><span class="u" id="1465432103.000469">2016:06:09 00:28:23           nathanmarz </span><span>@aengelberg yea</span></div><div data-t="aengelberg done"><span class="u" id="1465432427.000471">2016:06:09 00:33:47           aengelberg </span><span>done</span></div><div data-t="mac Do I have to do something special use specter from cljs? I have [com.rpl/specter &quot;0.11.1&quot;] in my build.boot (set-env! :dependencies), but my :require [com.rpl.specter :refer [select]] fails with  &quot;Referred var com.rpl.specter/select does not exist&quot;"><span class="u" id="1465471886.000507">2016:06:09 11:31:26                  mac </span><span>Do I have to do something special use specter from cljs? I have [com.rpl/specter &quot;0.11.1&quot;] in my build.boot (set-env! :dependencies), but my :require [com.rpl.specter :refer [select]] fails with  &quot;Referred var com.rpl.specter/select does not exist&quot;</span></div><div data-t="nathanmarz @mac the core select/transform/etc. operations are macros now in com.rpl.specter.macros namespace"><span class="u" id="1465471937.000508">2016:06:09 11:32:17           nathanmarz </span><span>@mac the core select/transform/etc. operations are macros now in com.rpl.specter.macros namespace</span></div><div data-t="nathanmarz that was a change in 0.11.0"><span class="u" id="1465471960.000509">2016:06:09 11:32:40           nathanmarz </span><span>that was a change in 0.11.0</span></div><div data-t="mac Ah, got it."><span class="u" id="1465471963.000510">2016:06:09 11:32:43                  mac </span><span>Ah, got it.</span></div><div data-t="mac I get a ton of warnings about &quot;Use of undeclared Var com.rpl.specter.impl/compiled-select*&quot; just from using select."><span class="u" id="1465472723.000514">2016:06:09 11:45:23                  mac </span><span>I get a ton of warnings about &quot;Use of undeclared Var com.rpl.specter.impl/compiled-select*&quot; just from using select.</span></div><div data-t="mac @nathanmarz: I just added (:require-macros
          [com.rpl.specter.macros :as sp]) to my namespace."><span class="u" id="1465472814.000515">2016:06:09 11:46:54                  mac </span><span>@nathanmarz: I just added (:require-macros
          [com.rpl.specter.macros :as sp]) to my namespace.</span></div><div data-t="nathanmarz are you also requiring com.rpl.specter namespace?"><span class="u" id="1465472934.000516">2016:06:09 11:48:54           nathanmarz </span><span>are you also requiring com.rpl.specter namespace?</span></div><div data-t="mac nathanmarz: no, is that the issue?"><span class="u" id="1465473017.000517">2016:06:09 11:50:17                  mac </span><span>nathanmarz: no, is that the issue?</span></div><div data-t="nathanmarz could be"><span class="u" id="1465473026.000518">2016:06:09 11:50:26           nathanmarz </span><span>could be</span></div><div data-t="mac nathanmarz: that fixed it  🙂"><span class="u" id="1465473054.000519">2016:06:09 11:50:54                  mac </span><span>nathanmarz: that fixed it </span><b>🙂</b></div><div data-t="nathanmarz cool"><span class="u" id="1465473058.000520">2016:06:09 11:50:58           nathanmarz </span><span>cool</span></div><div data-t="mac nathanmarz: thanks, specter is a fantastic piece of kit."><span class="u" id="1465473173.000521">2016:06:09 11:52:53                  mac </span><span>nathanmarz: thanks, specter is a fantastic piece of kit.</span></div><div data-t="nathanmarz thanks"><span class="u" id="1465473194.000522">2016:06:09 11:53:14           nathanmarz </span><span>thanks</span></div><div data-t="conaw @nathanmarz: when would you use continue-then-stay, vs stay-then-continue."><span class="u" id="1465487485.000537">2016:06:09 15:51:25                conaw </span><span>@nathanmarz: when would you use continue-then-stay, vs stay-then-continue.</span></div><div data-t="nathanmarz the first is pre-order traversal, the 2nd is post-order"><span class="u" id="1465487527.000538">2016:06:09 15:52:07           nathanmarz </span><span>the first is pre-order traversal, the 2nd is post-order</span></div><div data-t="nathanmarz in that tree example continue-then-stay would visit the leaves first"><span class="u" id="1465487537.000539">2016:06:09 15:52:17           nathanmarz </span><span>in that tree example continue-then-stay would visit the leaves first</span></div><div data-t="conaw I’m just trying to think of an example problem, and how that might affect composition"><span class="u" id="1465487572.000540">2016:06:09 15:52:52                conaw </span><span>I’m just trying to think of an example problem, and how that might affect composition</span></div><div data-t="nathanmarz if you&apos;re changing the structure of the tree itself it can change the result"><span class="u" id="1465487612.000541">2016:06:09 15:53:32           nathanmarz </span><span>if you&apos;re changing the structure of the tree itself it can change the result</span></div><div data-t="nathanmarz post-order that adds children  will not visit the children in the same navigation, pre-order will"><span class="u" id="1465487640.000542">2016:06:09 15:54:00           nathanmarz </span><span>post-order that adds children  will not visit the children in the same navigation, pre-order will</span></div><div data-t="conaw Inside a recursive navigation path that was visiting every element in a tree this is irrelevant though"><span class="u" id="1465488216.000543">2016:06:09 16:03:36                conaw </span><span>Inside a recursive navigation path that was visiting every element in a tree this is irrelevant though</span></div><div data-t="conaw I’m just trying to imagine step by step what specter is returning.  Is it possible with a continue-then-stay to collect-one from all the leaves of a tree"><span class="u" id="1465488292.000544">2016:06:09 16:04:52                conaw </span><span>I’m just trying to imagine step by step what specter is returning.  Is it possible with a continue-then-stay to collect-one from all the leaves of a tree</span></div><div data-t="conaw sort of, get the path from each leaf to the root node?"><span class="u" id="1465488319.000545">2016:06:09 16:05:19                conaw </span><span>sort of, get the path from each leaf to the root node?</span></div><div data-t="conaw got it"><span class="u" id="1465488832.000546">2016:06:09 16:13:52                conaw </span><span>got it</span></div><div data-t="nathanmarz @conaw you figured out how to do it?"><span class="u" id="1465489262.000547">2016:06:09 16:21:02           nathanmarz </span><span>@conaw you figured out how to do it?</span></div><div data-t="conaw well, figured out when I might use pre-order and post-order in a select  I’m not totally sure how to do the transform though"><span class="u" id="1465489315.000548">2016:06:09 16:21:55                conaw </span><span>well, figured out when I might use pre-order and post-order in a select  I’m not totally sure how to do the transform though</span></div><div data-t="conaw Is there a way to use setval and just set the val of a particular submap to the values collected"><span class="u" id="1465489353.000549">2016:06:09 16:22:33                conaw </span><span>Is there a way to use setval and just set the val of a particular submap to the values collected</span></div><div data-t="nathanmarz you need to use transform for that"><span class="u" id="1465489370.000550">2016:06:09 16:22:50           nathanmarz </span><span>you need to use transform for that</span></div><div data-t="nathanmarz setval ignores value collection"><span class="u" id="1465489402.000551">2016:06:09 16:23:22           nathanmarz </span><span>setval ignores value collection</span></div><div data-t="conaw gotcha, is it possible to use VAL or collect-one inside of continue-then-stay"><span class="u" id="1465489560.000552">2016:06:09 16:26:00                conaw </span><span>gotcha, is it possible to use VAL or collect-one inside of continue-then-stay</span></div><div data-t="conaw I keep getting an arity error or nil values"><span class="u" id="1465489673.000553">2016:06:09 16:27:53                conaw </span><span>I keep getting an arity error or nil values</span></div><div data-t="nathanmarz show me the code"><span class="u" id="1465489762.000554">2016:06:09 16:29:22           nathanmarz </span><span>show me the code</span></div><div data-t="conaw (transform [ALL (sp/continue-then-stay :children ALL (collect-one :node)) :parents] 
         (fn [&amp; xs] (vector xs))   samplemap)"><span class="u" id="1465489796.000555">2016:06:09 16:29:56                conaw </span><pre>(transform [ALL (sp/continue-then-stay :children ALL (collect-one :node)) :parents] 
         (fn [&amp; xs] (vector xs))   samplemap)</pre></div><div data-t="conaw multiple arities passed to next-fn"><span class="u" id="1465489810.000556">2016:06:09 16:30:10                conaw </span><span>multiple arities passed to next-fn</span></div><div data-t="conaw or rather, wrong number of args(2) passed"><span class="u" id="1465489856.000557">2016:06:09 16:30:56                conaw </span><span>or rather, wrong number of args(2) passed</span></div><div data-t="nathanmarz oh"><span class="u" id="1465489945.000558">2016:06:09 16:32:25           nathanmarz </span><span>oh</span></div><div data-t="nathanmarz that&apos;s the only known bug in specter"><span class="u" id="1465489951.000559">2016:06:09 16:32:31           nathanmarz </span><span>that&apos;s the only known bug in specter</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/issues/64"><span class="u" id="1465489956.000560">2016:06:09 16:32:36           nathanmarz </span><a href="https://github.com/nathanmarz/specter/issues/64">https://github.com/nathanmarz/specter/issues/64</a></div><div data-t="conaw lol"><span class="u" id="1465489961.000562">2016:06:09 16:32:41                conaw </span><span>lol</span></div><div data-t="conaw continue-then-stay is a wrapper on multi-path then"><span class="u" id="1465489986.000564">2016:06:09 16:33:06                conaw </span><span>continue-then-stay is a wrapper on multi-path then</span></div><div data-t="nathanmarz yea"><span class="u" id="1465490003.000565">2016:06:09 16:33:23           nathanmarz </span><span>yea</span></div><div data-t="nathanmarz same is true for any of the higher order navigators"><span class="u" id="1465490019.000566">2016:06:09 16:33:39           nathanmarz </span><span>same is true for any of the higher order navigators</span></div><div data-t="nathanmarz like if-path"><span class="u" id="1465490021.000567">2016:06:09 16:33:41           nathanmarz </span><span>like if-path</span></div><div data-t="conaw cool"><span class="u" id="1465490054.000568">2016:06:09 16:34:14                conaw </span><span>cool</span></div><div data-t="conaw Also, you mentioned at Clojure/West a few exercises that you thought were good for figuring out how to write navigators or paths well.   I think you said something about nested vectors of maps.  I’m trying to put together a sort of 4clojurey set of challenges for someone learning specter, if you (or anyone else in this room) have any sample problems I’d love them"><span class="u" id="1465490413.000569">2016:06:09 16:40:13                conaw </span><span>Also, you mentioned at Clojure/West a few exercises that you thought were good for figuring out how to write navigators or paths well.   I think you said something about nested vectors of maps.  I’m trying to put together a sort of 4clojurey set of challenges for someone learning specter, if you (or anyone else in this room) have any sample problems I’d love them</span></div><div data-t="aengelberg my favorite exercise (spoiler alert, it can only be elegantly solved with  subselect ) is:
 ;; given a vector of vectors, reverse all numbers without changing the length of any vector
in:  [[1 2 3] [4 5] [6] [7] [8 9 10]]
out: [[10 9 8] [7 6] [5] [4] [3 2 1]]
"><span class="u" id="1465491339.000572">2016:06:09 16:55:39           aengelberg </span><span>my favorite exercise (spoiler alert, it can only be elegantly solved with </span><code>subselect</code><span>) is:
</span><pre>;; given a vector of vectors, reverse all numbers without changing the length of any vector
in:  [[1 2 3] [4 5] [6] [7] [8 9 10]]
out: [[10 9 8] [7 6] [5] [4] [3 2 1]]
</pre></div><div data-t="conaw love it"><span class="u" id="1465491413.000573">2016:06:09 16:56:53                conaw </span><span>love it</span></div><div data-t="conaw hey that is quite elegant"><span class="u" id="1465491599.000574">2016:06:09 16:59:59                conaw </span><span>hey that is quite elegant</span></div><div data-t="aengelberg 🙂"><span class="u" id="1465491603.000575">2016:06:09 17:00:03           aengelberg </span><b>🙂</b></div><div data-t="nathanmarz here&apos;s another one: concatenate all continuous sequences of strings together"><span class="u" id="1465491631.000576">2016:06:09 17:00:31           nathanmarz </span><span>here&apos;s another one: concatenate all continuous sequences of strings together</span></div><div data-t="nathanmarz [&quot;hello&quot; &quot; &quot; &quot;word&quot; 1 2 &quot;a&quot; &quot;b&quot; 3]  -&gt;  [&quot;hello word&quot; 1 2 &quot;ab&quot; 3]"><span class="u" id="1465491646.000577">2016:06:09 17:00:46           nathanmarz </span><code>[&quot;hello&quot; &quot; &quot; &quot;word&quot; 1 2 &quot;a&quot; &quot;b&quot; 3]</code><span> -&gt; </span><code>[&quot;hello word&quot; 1 2 &quot;ab&quot; 3]</code></div><div data-t="conaw srange-dynamic?"><span class="u" id="1465491709.000579">2016:06:09 17:01:49                conaw </span><span>srange-dynamic?</span></div><div data-t="nathanmarz continuous-subseqs"><span class="u" id="1465491727.000580">2016:06:09 17:02:07           nathanmarz </span><span>continuous-subseqs</span></div><div data-t="conaw filterer"><span class="u" id="1465491729.000581">2016:06:09 17:02:09                conaw </span><span>filterer</span></div><div data-t="nathanmarz adding an element to a nested set (or creating the set if it doesn&apos;t exist) without defining any new functions (anonymous or not)"><span class="u" id="1465491815.000582">2016:06:09 17:03:35           nathanmarz </span><span>adding an element to a nested set (or creating the set if it doesn&apos;t exist) without defining any new functions (anonymous or not)</span></div><div data-t="nathanmarz {:a #{1}}  -&gt;  {:a #{1 2}}"><span class="u" id="1465491843.000583">2016:06:09 17:04:03           nathanmarz </span><code>{:a #{1}}</code><span> -&gt; </span><code>{:a #{1 2}}</code></div><div data-t="nathanmarz in a sequence of maps, set the  :b  key to true if the value for  :a  exists and is greater than 10"><span class="u" id="1465491948.000584">2016:06:09 17:05:48           nathanmarz </span><span>in a sequence of maps, set the </span><code>:b</code><span> key to true if the value for </span><code>:a</code><span> exists and is greater than 10</span></div><div data-t="nathanmarz [{:a 1} {:a 11 :c 1} {:d 4}]  -&gt;  [{:a 1} {:a 11 :b true :c 1} {:d 4}]"><span class="u" id="1465492020.000587">2016:06:09 17:07:00           nathanmarz </span><code>[{:a 1} {:a 11 :c 1} {:d 4}]</code><span> -&gt; </span><code>[{:a 1} {:a 11 :b true :c 1} {:d 4}]</code></div><div data-t="conaw gotta admit I’m a little stumped by what I got back from the continuous subsequence stuff"><span class="u" id="1465492654.000588">2016:06:09 17:17:34                conaw </span><span>gotta admit I’m a little stumped by what I got back from the continuous subsequence stuff</span></div><div data-t="conaw its navigating to each character?"><span class="u" id="1465492701.000589">2016:06:09 17:18:21                conaw </span><span>its navigating to each character?</span></div><div data-t="conaw (transform [(sp/continuous-subseqs string?)] str
            [&quot;hello &quot; &quot;a &quot; &quot;w&quot; 1 2 3 &quot;a &quot; &quot;b&quot; ])

[\[ \&quot; \h \e \l \l \o \space \&quot; \space \&quot; \a \space \&quot; \space \&quot; \w \&quot; \] 1 2 3 \[ \&quot; \a \space \&quot; \space \&quot; \b \&quot; \]]"><span class="u" id="1465492735.000590">2016:06:09 17:18:55                conaw </span><span>(transform [(sp/continuous-subseqs string?)] str
            [&quot;hello &quot; &quot;a &quot; &quot;w&quot; 1 2 3 &quot;a &quot; &quot;b&quot; ])

[\[ \&quot; \h \e \l \l \o \space \&quot; \space \&quot; \a \space \&quot; \space \&quot; \w \&quot; \] 1 2 3 \[ \&quot; \a \space \&quot; \space \&quot; \b \&quot; \]]</span></div><div data-t="nathanmarz the transform fn gets sequence in and expects sequence out"><span class="u" id="1465492770.000591">2016:06:09 17:19:30           nathanmarz </span><span>the transform fn gets sequence in and expects sequence out</span></div><div data-t="conaw so the challenge isn’t in the path, but in the fn you pass to transform"><span class="u" id="1465492792.000592">2016:06:09 17:19:52                conaw </span><span>so the challenge isn’t in the path, but in the fn you pass to transform</span></div><div data-t="nathanmarz you&apos;re turning a vector of strings into a big string, which is then spliced back in as a sequence"><span class="u" id="1465492796.000593">2016:06:09 17:19:56           nathanmarz </span><span>you&apos;re turning a vector of strings into a big string, which is then spliced back in as a sequence</span></div><div data-t="nathanmarz yea, it&apos;s just understanding how the navigation works"><span class="u" id="1465492835.000594">2016:06:09 17:20:35           nathanmarz </span><span>yea, it&apos;s just understanding how the navigation works</span></div><div data-t="conaw gotcha, to do this well you’d really have to do something after the transform fn"><span class="u" id="1465492863.000595">2016:06:09 17:21:03                conaw </span><span>gotcha, to do this well you’d really have to do something after the transform fn</span></div><div data-t="nathanmarz your path is right and the rest of it is making a different transform-fn"><span class="u" id="1465492901.000596">2016:06:09 17:21:41           nathanmarz </span><span>your path is right and the rest of it is making a different transform-fn</span></div><div data-t="nathanmarz your transform-fn will be called twice, once with [&quot;hello &quot; &quot;a &quot; &quot;w&quot;] and once with [&quot;a &quot; &quot;b&quot;]"><span class="u" id="1465492971.000597">2016:06:09 17:22:51           nathanmarz </span><span>your transform-fn will be called twice, once with [&quot;hello &quot; &quot;a &quot; &quot;w&quot;] and once with [&quot;a &quot; &quot;b&quot;]</span></div><div data-t="conaw Yeah, this is a good one, because I’m definitely failing to understand something about specter"><span class="u" id="1465494026.000599">2016:06:09 17:40:26                conaw </span><span>Yeah, this is a good one, because I’m definitely failing to understand something about specter</span></div><div data-t="conaw (s/def ::stringvec (s/+ (s/spec (s/+  string?))))



(defn joinup [stringvec]
  (map (partial str/join &quot;&quot;) stringvec))


(s/fdef joinup :args ::stringvec
        :ret string?)

(s/instrument &apos;joinup)

(transform [(sp/continuous-subseqs string?)] joinup
            [&quot;hello &quot; &quot;a &quot; &quot;w&quot; 1 2 3 &quot;a &quot; &quot;b&quot; ])
"><span class="u" id="1465494035.000600">2016:06:09 17:40:35                conaw </span><pre>(s/def ::stringvec (s/+ (s/spec (s/+  string?))))



(defn joinup [stringvec]
  (map (partial str/join &quot;&quot;) stringvec))


(s/fdef joinup :args ::stringvec
        :ret string?)

(s/instrument &apos;joinup)

(transform [(sp/continuous-subseqs string?)] joinup
            [&quot;hello &quot; &quot;a &quot; &quot;w&quot; 1 2 3 &quot;a &quot; &quot;b&quot; ])
</pre></div><div data-t="conaw still getting back this [&quot;hello &quot; &quot;a &quot; &quot;w&quot; 1 2 3 &quot;a &quot; &quot;b&quot;]"><span class="u" id="1465494065.000601">2016:06:09 17:41:05                conaw </span><span>still getting back this [&quot;hello &quot; &quot;a &quot; &quot;w&quot; 1 2 3 &quot;a &quot; &quot;b&quot;]</span></div><div data-t="conaw yet the spec says I’m returning a string"><span class="u" id="1465494086.000602">2016:06:09 17:41:26                conaw </span><span>yet the spec says I’m returning a string</span></div><div data-t="nathanmarz here i&apos;ll show you"><span class="u" id="1465494096.000603">2016:06:09 17:41:36           nathanmarz </span><span>here i&apos;ll show you</span></div><div data-t="nathanmarz (fn [strseq] [(apply str strseq)])"><span class="u" id="1465494112.000604">2016:06:09 17:41:52           nathanmarz </span><code>(fn [strseq] [(apply str strseq)])</code></div><div data-t="conaw so, because I’m not putting it in a vector at the end"><span class="u" id="1465494135.000605">2016:06:09 17:42:15                conaw </span><span>so, because I’m not putting it in a vector at the end</span></div><div data-t="conaw what’s happening"><span class="u" id="1465494138.000606">2016:06:09 17:42:18                conaw </span><span>what’s happening</span></div><div data-t="conaw ?"><span class="u" id="1465494139.000607">2016:06:09 17:42:19                conaw </span><span>?</span></div><div data-t="nathanmarz continuous-subseqs works just like srange"><span class="u" id="1465494156.000608">2016:06:09 17:42:36           nathanmarz </span><span>continuous-subseqs works just like srange</span></div><div data-t="nathanmarz the sequence returned back replaces the subsequence navigated to"><span class="u" id="1465494173.000609">2016:06:09 17:42:53           nathanmarz </span><span>the sequence returned back replaces the subsequence navigated to</span></div><div data-t="nathanmarz so if you just return a string back, that gets interpreted as a sequence and the individual characters get spliced in"><span class="u" id="1465494191.000610">2016:06:09 17:43:11           nathanmarz </span><span>so if you just return a string back, that gets interpreted as a sequence and the individual characters get spliced in</span></div><div data-t="conaw gotchaaa"><span class="u" id="1465494218.000611">2016:06:09 17:43:38                conaw </span><span>gotchaaa</span></div><div data-t="conaw yeah, that’s totally obvious when you think about it"><span class="u" id="1465494231.000612">2016:06:09 17:43:51                conaw </span><span>yeah, that’s totally obvious when you think about it</span></div><div data-t="nathanmarz yea, you just need to visualize it"><span class="u" id="1465494260.000613">2016:06:09 17:44:20           nathanmarz </span><span>yea, you just need to visualize it</span></div><div data-t="conaw truth, any challenges that involve navigating to a non-empty subset"><span class="u" id="1465495073.000616">2016:06:09 17:57:53                conaw </span><span>truth, any challenges that involve navigating to a non-empty subset</span></div><div data-t="nathanmarz I could imagine minecraft style ones"><span class="u" id="1465495438.000617">2016:06:09 18:03:58           nathanmarz </span><span>I could imagine minecraft style ones</span></div><div data-t="nathanmarz for sequence of players, if :inventory contains :flint and :stick, replace with :torch"><span class="u" id="1465495465.000618">2016:06:09 18:04:25           nathanmarz </span><span>for sequence of players, if :inventory contains :flint and :stick, replace with :torch</span></div><div data-t="conaw Alright, here’s another challenge.  Let me know if this is just taking the idea of everything as a navigation too far though.  Given this

 [[1 2] [1 3] [3 4] [4 5] [5 6]]"><span class="u" id="1465563298.000681">2016:06:10 12:54:58                conaw </span><span>Alright, here’s another challenge.  Let me know if this is just taking the idea of everything as a navigation too far though.  Given this

 [[1 2] [1 3] [3 4] [4 5] [5 6]]</span></div><div data-t="conaw Could you express this"><span class="u" id="1465563315.000682">2016:06:10 12:55:15                conaw </span><span>Could you express this</span></div><div data-t="conaw (for [[k v] e]
              {k #{v}})
              (apply merge-with clojure.set/union))"><span class="u" id="1465563317.000683">2016:06:10 12:55:17                conaw </span><span>(for [[k v] e]
              {k #{v}})
              (apply merge-with clojure.set/union))</span></div><div data-t="conaw as a transformation"><span class="u" id="1465563325.000684">2016:06:10 12:55:25                conaw </span><span>as a transformation</span></div><div data-t="conaw or rather as a navigation"><span class="u" id="1465563340.000685">2016:06:10 12:55:40                conaw </span><span>or rather as a navigation</span></div><div data-t="conaw especially if you’re planning on going back to tuples"><span class="u" id="1465563386.000686">2016:06:10 12:56:26                conaw </span><span>especially if you’re planning on going back to tuples</span></div><div data-t="conaw copy paste was off as well"><span class="u" id="1465563393.000687">2016:06:10 12:56:33                conaw </span><span>copy paste was off as well</span></div><div data-t="conaw (-&gt;&gt; (for [[k v] e]
              {k #{v}})
              (apply merge-with clojure.set/union))"><span class="u" id="1465563394.000688">2016:06:10 12:56:34                conaw </span><span>(-&gt;&gt; (for [[k v] e]
              {k #{v}})
              (apply merge-with clojure.set/union))</span></div><div data-t="nathanmarz I mean, you can"><span class="u" id="1465563793.000689">2016:06:10 13:03:13           nathanmarz </span><span>I mean, you can</span></div><div data-t="nathanmarz but it&apos;s not particularly better than the manual code since everything in the structure is used"><span class="u" id="1465563833.000690">2016:06:10 13:03:53           nathanmarz </span><span>but it&apos;s not particularly better than the manual code since everything in the structure is used</span></div><div data-t="nathanmarz (require &apos;[clojure.set :as set])

(defnav MERGED-MAPS []
  (select* [this structure next-fn]
    ;;TODO: fill this in
    )
  (transform* [this structure next-fn]
    (apply merge-with (fn [&amp; vals] (next-fn vals)) structure)
    ))


(transform
  [(parser #(transform ALL (fn [[k v]] {k #{v}}) %) #(vec %))
   MERGED-MAPS]
  #(apply set/union %)
  [[1 2] [1 3] [3 4] [4 5] [5 6]])
"><span class="u" id="1465563995.000691">2016:06:10 13:06:35           nathanmarz </span><pre>(require &apos;[clojure.set :as set])

(defnav MERGED-MAPS []
  (select* [this structure next-fn]
    ;;TODO: fill this in
    )
  (transform* [this structure next-fn]
    (apply merge-with (fn [&amp; vals] (next-fn vals)) structure)
    ))


(transform
  [(parser #(transform ALL (fn [[k v]] {k #{v}}) %) #(vec %))
   MERGED-MAPS]
  #(apply set/union %)
  [[1 2] [1 3] [3 4] [4 5] [5 6]])
</pre></div><div data-t="nathanmarz that outputs  [[1 #{3 2}] [3 #{4}] [4 #{5}] [5 #{6}]]"><span class="u" id="1465564015.000692">2016:06:10 13:06:55           nathanmarz </span><span>that outputs </span><code>[[1 #{3 2}] [3 #{4}] [4 #{5}] [5 #{6}]]</code></div><div data-t="conaw cool, just trying to get a sense of where the edge is"><span class="u" id="1465568227.000696">2016:06:10 14:17:07                conaw </span><span>cool, just trying to get a sense of where the edge is</span></div><div data-t="conaw are there other examples of when you’d use parser?"><span class="u" id="1465568289.000697">2016:06:10 14:18:09                conaw </span><span>are there other examples of when you’d use parser?</span></div><div data-t="conaw didn’t see that mentioned in any doc?"><span class="u" id="1465568298.000698">2016:06:10 14:18:18                conaw </span><span>didn’t see that mentioned in any doc?</span></div><div data-t="nathanmarz @conaw It&apos;s most commonly used for something like this:
 (def LONG-PARSER (parser #(Long/parseLong %) str))

(transform [ALL LONG-PARSER] inc [&quot;10&quot; &quot;1&quot; &quot;0&quot;])
;; =&gt; [&quot;11&quot; &quot;2&quot; &quot;1&quot;]
"><span class="u" id="1465572392.000701">2016:06:10 15:26:32           nathanmarz </span><span>@conaw It&apos;s most commonly used for something like this:
</span><pre>(def LONG-PARSER (parser #(Long/parseLong %) str))

(transform [ALL LONG-PARSER] inc [&quot;10&quot; &quot;1&quot; &quot;0&quot;])
;; =&gt; [&quot;11&quot; &quot;2&quot; &quot;1&quot;]
</pre></div><div data-t="nathanmarz the docs are very incomplete, though most of the public API has docstrings"><span class="u" id="1465572407.000702">2016:06:10 15:26:47           nathanmarz </span><span>the docs are very incomplete, though most of the public API has docstrings</span></div><div data-t="conaw cool"><span class="u" id="1465572445.000703">2016:06:10 15:27:25                conaw </span><span>cool</span></div><div data-t="conaw ok, here’s a question.  Is there a way I could do a transform that would be akin to map-indexed.  
(transform [TOPSORT :position-id (subset #{})] 
(fn [x]  something that gives me an unique value in the range of zero to the number of items I’m doing the select on)
tree)"><span class="u" id="1465572998.000704">2016:06:10 15:36:38                conaw </span><span>ok, here’s a question.  Is there a way I could do a transform that would be akin to map-indexed.  
(transform [TOPSORT :position-id (subset #{})] 
(fn [x]  something that gives me an unique value in the range of zero to the number of items I’m doing the select on)
tree)</span></div><div data-t="conaw the function for transform is only getting access to one selected value at a time right"><span class="u" id="1465573045.000705">2016:06:10 15:37:25                conaw </span><span>the function for transform is only getting access to one selected value at a time right</span></div><div data-t="conaw so you’d have to do something like, pass the whole subsequence of values you want as a sequence, and then put them all back in in the right place"><span class="u" id="1465573101.000706">2016:06:10 15:38:21                conaw </span><span>so you’d have to do something like, pass the whole subsequence of values you want as a sequence, and then put them all back in in the right place</span></div><div data-t="nathanmarz I think you&apos;re looking for subselect"><span class="u" id="1465575138.000709">2016:06:10 16:12:18           nathanmarz </span><span>I think you&apos;re looking for subselect</span></div><div data-t="conaw right"><span class="u" id="1465575186.000710">2016:06:10 16:13:06                conaw </span><span>right</span></div><div data-t="nathanmarz (transform (subselect ALL even?) reverse [1 2 3 4 5 6 7])  -&gt;  [1 6 3 4 5 2 7]"><span class="u" id="1465575197.000711">2016:06:10 16:13:17           nathanmarz </span><code>(transform (subselect ALL even?) reverse [1 2 3 4 5 6 7])</code><span> -&gt; </span><code>[1 6 3 4 5 2 7]</code></div><div data-t="conaw (transform [(sp/subselect ALL map? :position)] 
           (partial map-indexed (fn [i x] i)) 
           [{:a 1  😛  1}[:not :me 1]{:b 2}])"><span class="u" id="1465576215.000712">2016:06:10 16:30:15                conaw </span><span>(transform [(sp/subselect ALL map? :position)] 
           (partial map-indexed (fn [i x] i)) 
           [{:a 1 </span><b>😛</b><span> 1}[:not :me 1]{:b 2}])</span></div><div data-t="conaw (transform [(sp/subselect ALL map? :position)] 
           (partial map-indexed (fn [i x] i)) 
           [{:a 1 :b 1}[:not :me 1]{:b 2}])
"><span class="u" id="1465576221.000713">2016:06:10 16:30:21                conaw </span><pre>(transform [(sp/subselect ALL map? :position)] 
           (partial map-indexed (fn [i x] i)) 
           [{:a 1 :b 1}[:not :me 1]{:b 2}])
</pre></div><div data-t="conaw [{:a 1,  😛  1, :position 0} [:not :me 1] {:b 2, :position 1}]"><span class="u" id="1465576241.000714">2016:06:10 16:30:41                conaw </span><span>[{:a 1, </span><b>😛</b><span> 1, :position 0} [:not :me 1] {:b 2, :position 1}]</span></div><div data-t="conaw returns  [{:a 1, :b 1, :position 0} [:not :me 1] {:b 2, :position 1}]"><span class="u" id="1465576253.000715">2016:06:10 16:30:53                conaw </span><span>returns </span><pre>[{:a 1, :b 1, :position 0} [:not :me 1] {:b 2, :position 1}]</pre></div><div data-t="conaw much appreciated"><span class="u" id="1465576265.000716">2016:06:10 16:31:05                conaw </span><span>much appreciated</span></div><div data-t="conaw this is really beautiful the more I’m exploring it"><span class="u" id="1465576304.000717">2016:06:10 16:31:44                conaw </span><span>this is really beautiful the more I’m exploring it</span></div><div data-t="conaw thanks so much for the help"><span class="u" id="1465576313.000718">2016:06:10 16:31:53                conaw </span><span>thanks so much for the help</span></div><div data-t="nathanmarz no problem"><span class="u" id="1465576511.000719">2016:06:10 16:35:11           nathanmarz </span><span>no problem</span></div><div data-t="nathanmarz I think you can do that last one with this transform-fn:  (fn [aseq] (range (count aseq)))"><span class="u" id="1465576558.000720">2016:06:10 16:35:58           nathanmarz </span><span>I think you can do that last one with this transform-fn: </span><code>(fn [aseq] (range (count aseq)))</code></div><div data-t="nathanmarz a little cleaner in my opinion"><span class="u" id="1465576566.000721">2016:06:10 16:36:06           nathanmarz </span><span>a little cleaner in my opinion</span></div><div data-t="nathanmarz @conaw: or even better:
 (transform [(subselect ALL map? :position) (view count)] 
           range
           [{:a 1 :b 1} [:not :me 1] {:b 2}])
"><span class="u" id="1465576657.000722">2016:06:10 16:37:37           nathanmarz </span><span>@conaw: or even better:
</span><pre>(transform [(subselect ALL map? :position) (view count)] 
           range
           [{:a 1 :b 1} [:not :me 1] {:b 2}])
</pre></div><div data-t="conaw very cool"><span class="u" id="1465576683.000723">2016:06:10 16:38:03                conaw </span><span>very cool</span></div><div data-t="conaw if you’d like, happy to take a stab at writing up some examples for the wiki."><span class="u" id="1465576825.000724">2016:06:10 16:40:25                conaw </span><span>if you’d like, happy to take a stab at writing up some examples for the wiki.</span></div><div data-t="nathanmarz that would be awesome"><span class="u" id="1465576842.000725">2016:06:10 16:40:42           nathanmarz </span><span>that would be awesome</span></div><div data-t="conaw will give it a stab"><span class="u" id="1465577000.000726">2016:06:10 16:43:20                conaw </span><span>will give it a stab</span></div><div data-t="conaw taking the subselect example into recursion"><span class="u" id="1465577018.000727">2016:06:10 16:43:38                conaw </span><span>taking the subselect example into recursion</span></div><div data-t="conaw nevermind, actually works just as expected"><span class="u" id="1465577062.000728">2016:06:10 16:44:22                conaw </span><span>nevermind, actually works just as expected</span></div><div data-t="conaw this is very cool"><span class="u" id="1465577067.000729">2016:06:10 16:44:27                conaw </span><span>this is very cool</span></div><div data-t="nathanmarz yea subselect is pretty magical"><span class="u" id="1465577091.000730">2016:06:10 16:44:51           nathanmarz </span><span>yea subselect is pretty magical</span></div><div data-t="nathanmarz contributed by @aengelberg"><span class="u" id="1465577098.000731">2016:06:10 16:44:58           nathanmarz </span><span>contributed by @aengelberg</span></div><div data-t="aengelberg 👋"><span class="u" id="1465577109.000732">2016:06:10 16:45:09           aengelberg </span><b>👋</b></div><div data-t="aengelberg its end result almost outweighs the mutable hackiness I used to achieve it  🙂"><span class="u" id="1465577147.000733">2016:06:10 16:45:47           aengelberg </span><span>its end result almost outweighs the mutable hackiness I used to achieve it </span><b>🙂</b></div><div data-t="conaw lol, I was trying to figure out how I would even achieve this before @nathanmarz mentioned subselect, only thing I could think of was to create an atom"><span class="u" id="1465577272.000734">2016:06:10 16:47:52                conaw </span><span>lol, I was trying to figure out how I would even achieve this before @nathanmarz mentioned subselect, only thing I could think of was to create an atom</span></div><div data-t="conaw glad you went into the swamp for us!"><span class="u" id="1465577303.000735">2016:06:10 16:48:23                conaw </span><span>glad you went into the swamp for us!</span></div><div data-t="aengelberg I like this quote from  http://clojure.org/transients :
 If a tree falls in the woods, does it make a sound?
If a pure function mutates some local data in order to produce an immutable return value, is that ok?
"><span class="u" id="1465577334.000736">2016:06:10 16:48:54           aengelberg </span><span>I like this quote from </span><a href="http://clojure.org/transients">http://clojure.org/transients</a><span>:
</span><pre>If a tree falls in the woods, does it make a sound?
If a pure function mutates some local data in order to produce an immutable return value, is that ok?
</pre></div><div data-t="conaw so much beauty in this channel"><span class="u" id="1465577361.000737">2016:06:10 16:49:21                conaw </span><span>so much beauty in this channel</span></div><div data-t="nathanmarz that&apos;s a good one"><span class="u" id="1465577414.000738">2016:06:10 16:50:14           nathanmarz </span><span>that&apos;s a good one</span></div><div data-t="nathanmarz been digging into clojure&apos;s transducers and they use a lot of mutability"><span class="u" id="1465577427.000739">2016:06:10 16:50:27           nathanmarz </span><span>been digging into clojure&apos;s transducers and they use a lot of mutability</span></div><div data-t="aengelberg Subselect gets awkward when working with sets:
 (subselect [ALL ALL] reverse [#{1 2 3} [4 5 6]])
=&gt;
[#{6 5 4} [???]]
"><span class="u" id="1465577510.000740">2016:06:10 16:51:50           aengelberg </span><span>Subselect gets awkward when working with sets:
</span><pre>(subselect [ALL ALL] reverse [#{1 2 3} [4 5 6]])
=&gt;
[#{6 5 4} [???]]
</pre></div><div data-t="nathanmarz looks reasonable to me"><span class="u" id="1465577704.000741">2016:06:10 16:55:04           nathanmarz </span><span>looks reasonable to me</span></div><div data-t="aengelberg often I get overly paranoid about confusing beginners"><span class="u" id="1465577792.000742">2016:06:10 16:56:32           aengelberg </span><span>often I get overly paranoid about confusing beginners</span></div><div data-t="nathanmarz I know what you mean"><span class="u" id="1465577873.000743">2016:06:10 16:57:53           nathanmarz </span><span>I know what you mean</span></div><div data-t="nathanmarz but I like the clojure philosophy of keep it simple and well defined"><span class="u" id="1465577894.000744">2016:06:10 16:58:14           nathanmarz </span><span>but I like the clojure philosophy of keep it simple and well defined</span></div><div data-t="nathanmarz even if it requires a learning curve"><span class="u" id="1465577900.000745">2016:06:10 16:58:20           nathanmarz </span><span>even if it requires a learning curve</span></div><div data-t="nathanmarz @aengelberg: curious to hear your thoughts on  https://github.com/nathanmarz/specter/issues/121"><span class="u" id="1465578398.000746">2016:06:10 17:06:38           nathanmarz </span><span>@aengelberg: curious to hear your thoughts on </span><a href="https://github.com/nathanmarz/specter/issues/121">https://github.com/nathanmarz/specter/issues/121</a></div><div data-t="nathanmarz a lot of overlap with transducers"><span class="u" id="1465578413.000748">2016:06:10 17:06:53           nathanmarz </span><span>a lot of overlap with transducers</span></div><div data-t="aengelberg yeah, just saw that. Seems like it could be even more useful if  takenav  could reset at a later level, e.g.  (select [ALL ALL (takenav 3)] [[1 2 3 4 5] [6 7 8 9 10]]) =&gt; [[1 2 3] [6 7 8]]"><span class="u" id="1465578520.000749">2016:06:10 17:08:40           aengelberg </span><span>yeah, just saw that. Seems like it could be even more useful if </span><code>takenav</code><span> could reset at a later level, e.g. </span><code>(select [ALL ALL (takenav 3)] [[1 2 3 4 5] [6 7 8 9 10]]) =&gt; [[1 2 3] [6 7 8]]</code></div><div data-t="aengelberg essentially the volatile would need to get reset in between the two  ALL s"><span class="u" id="1465578545.000750">2016:06:10 17:09:05           aengelberg </span><span>essentially the volatile would need to get reset in between the two </span><code>ALL</code><span>s</span></div><div data-t="nathanmarz i think the result you would expect there is  [1 2 3 6 7 8]"><span class="u" id="1465578576.000751">2016:06:10 17:09:36           nathanmarz </span><span>i think the result you would expect there is </span><code>[1 2 3 6 7 8]</code></div><div data-t="nathanmarz you might want both behaviors"><span class="u" id="1465578587.000752">2016:06:10 17:09:47           nathanmarz </span><span>you might want both behaviors</span></div><div data-t="aengelberg correct, sorry"><span class="u" id="1465578591.000753">2016:06:10 17:09:51           aengelberg </span><span>correct, sorry</span></div><div data-t="aengelberg thus proving that it&apos;s unreasonable to expect that behavior arbitrarily  🙂"><span class="u" id="1465578613.000754">2016:06:10 17:10:13           aengelberg </span><span>thus proving that it&apos;s unreasonable to expect that behavior arbitrarily </span><b>🙂</b></div><div data-t="nathanmarz so resetting would be an explicit choice"><span class="u" id="1465578619.000755">2016:06:10 17:10:19           nathanmarz </span><span>so resetting would be an explicit choice</span></div><div data-t="aengelberg yeah"><span class="u" id="1465578625.000756">2016:06:10 17:10:25           aengelberg </span><span>yeah</span></div><div data-t="aengelberg have you considered simply introducing  (ALL-transduce (take 3))"><span class="u" id="1465578639.000757">2016:06:10 17:10:39           aengelberg </span><span>have you considered simply introducing </span><code>(ALL-transduce (take 3))</code></div><div data-t="nathanmarz that would be one way to do it"><span class="u" id="1465578678.000758">2016:06:10 17:11:18           nathanmarz </span><span>that would be one way to do it</span></div><div data-t="nathanmarz then takenav would be a completely different implementation to that"><span class="u" id="1465578690.000759">2016:06:10 17:11:30           nathanmarz </span><span>then takenav would be a completely different implementation to that</span></div><div data-t="aengelberg yeah"><span class="u" id="1465578695.000760">2016:06:10 17:11:35           aengelberg </span><span>yeah</span></div><div data-t="nathanmarz seems like they should unify more cleanly"><span class="u" id="1465578705.000761">2016:06:10 17:11:45           nathanmarz </span><span>seems like they should unify more cleanly</span></div><div data-t="nathanmarz the degree of overlap is very suspicious"><span class="u" id="1465578717.000762">2016:06:10 17:11:57           nathanmarz </span><span>the degree of overlap is very suspicious</span></div><div data-t="aengelberg or maybe a &quot;take view&quot;"><span class="u" id="1465578837.000763">2016:06:10 17:13:57           aengelberg </span><span>or maybe a &quot;take view&quot;</span></div><div data-t="nathanmarz could be something like  (select [ALL ALL (traversed (takenav 3)] ... )"><span class="u" id="1465578839.000764">2016:06:10 17:13:59           nathanmarz </span><span>could be something like </span><code>(select [ALL ALL (traversed (takenav 3)] ... )</code></div><div data-t="aengelberg (transform [ALL (subselect (taken 3))] [[1 2 3 4 5] [6 7 8 9 10]]) =&gt; [[1 2 3] [6 7 8]]"><span class="u" id="1465578986.000765">2016:06:10 17:16:26           aengelberg </span><code>(transform [ALL (subselect (taken 3))] [[1 2 3 4 5] [6 7 8 9 10]]) =&gt; [[1 2 3] [6 7 8]]</code></div><div data-t="aengelberg uhhhh ignore that"><span class="u" id="1465578994.000766">2016:06:10 17:16:34           aengelberg </span><span>uhhhh ignore that</span></div><div data-t="aengelberg (transform [ALL (subselect (taken 3))] inc [[1 2 3 4 5] [6 7 8 9 10]]) =&gt; [[2 3 4 4 5] [7 8 9 9 10]]"><span class="u" id="1465579016.000767">2016:06:10 17:16:56           aengelberg </span><span>(transform [ALL (subselect (taken 3))] inc [[1 2 3 4 5] [6 7 8 9 10]]) =&gt; [[2 3 4 4 5] [7 8 9 9 10]]</span></div><div data-t="nathanmarz with the idea there that subselect re-parameterizes its path on every invocation?"><span class="u" id="1465579103.000768">2016:06:10 17:18:23           nathanmarz </span><span>with the idea there that subselect re-parameterizes its path on every invocation?</span></div><div data-t="nathanmarz that&apos;s what I was thinking with  traversed"><span class="u" id="1465579111.000769">2016:06:10 17:18:31           nathanmarz </span><span>that&apos;s what I was thinking with </span><code>traversed</code></div><div data-t="nathanmarz either way the semantics are pretty subtle"><span class="u" id="1465579259.000772">2016:06:10 17:20:59           nathanmarz </span><span>either way the semantics are pretty subtle</span></div><div data-t="nathanmarz maybe too subtle"><span class="u" id="1465579264.000773">2016:06:10 17:21:04           nathanmarz </span><span>maybe too subtle</span></div><div data-t="conaw hey @nathanmarz @aengelberg total aside, but don’t suppose either of you guys know of any great lecturers or youtube channels/videos relating to graph theory."><span class="u" id="1465579427.000774">2016:06:10 17:23:47                conaw </span><span>hey @nathanmarz @aengelberg total aside, but don’t suppose either of you guys know of any great lecturers or youtube channels/videos relating to graph theory.</span></div><div data-t="nathanmarz looks like tim roughgarden has a bunch of videos on graph algorithms on youtube"><span class="u" id="1465579518.000775">2016:06:10 17:25:18           nathanmarz </span><span>looks like tim roughgarden has a bunch of videos on graph algorithms on youtube</span></div><div data-t="nathanmarz https://www.youtube.com/results?search_query=tim+roughgarden+graph+algorithms"><span class="u" id="1465579520.000776">2016:06:10 17:25:20           nathanmarz </span><a href="https://www.youtube.com/results?search_query=tim+roughgarden+graph+algorithms">https://www.youtube.com/results?search_query=tim+roughgarden+graph+algorithms</a></div><div data-t="nathanmarz he&apos;s the best teacher I ever had"><span class="u" id="1465579528.000778">2016:06:10 17:25:28           nathanmarz </span><span>he&apos;s the best teacher I ever had</span></div><div data-t="conaw win"><span class="u" id="1465579715.000779">2016:06:10 17:28:35                conaw </span><span>win</span></div><div data-t="aengelberg I was suggesting  taken  would be just a regular (not stateful) navigator that only selects or transforms the first N elements"><span class="u" id="1465581561.000781">2016:06:10 17:59:21           aengelberg </span><span>I was suggesting </span><code>taken</code><span> would be just a regular (not stateful) navigator that only selects or transforms the first N elements</span></div><div data-t="aengelberg less performant though to do a subselect"><span class="u" id="1465581570.000782">2016:06:10 17:59:30           aengelberg </span><span>less performant though to do a subselect</span></div><div data-t="nathanmarz @aengelberg: ah, yea I&apos;m thinking more cases like  [ALL ALL ALL (takenav 3)]"><span class="u" id="1465582802.000783">2016:06:10 18:20:02           nathanmarz </span><span>@aengelberg: ah, yea I&apos;m thinking more cases like </span><code>[ALL ALL ALL (takenav 3)]</code></div><div data-t="aengelberg too many  ALL s  🙂"><span class="u" id="1465582816.000785">2016:06:10 18:20:16           aengelberg </span><span>too many </span><code>ALL</code><span>s </span><b>🙂</b></div><div data-t="nathanmarz (select [ALL (freshpath ALL (take-nav 2)) (take-nav 4)]
  [[1] [2 3 4] [5 6 7]])
;; =&gt; [1 2 3 5]
"><span class="u" id="1465582837.000786">2016:06:10 18:20:37           nathanmarz </span><pre>(select [ALL (freshpath ALL (take-nav 2)) (take-nav 4)]
  [[1] [2 3 4] [5 6 7]])
;; =&gt; [1 2 3 5]
</pre></div><div data-t="nathanmarz &quot;freshpath&quot; would mean to treat that path from scratch"><span class="u" id="1465582851.000787">2016:06:10 18:20:51           nathanmarz </span><span>&quot;freshpath&quot; would mean to treat that path from scratch</span></div><div data-t="nathanmarz the only impact that would have would be to initialize the states and collected vals every time it enters that part of the path"><span class="u" id="1465582886.000788">2016:06:10 18:21:26           nathanmarz </span><span>the only impact that would have would be to initialize the states and collected vals every time it enters that part of the path</span></div><div data-t="luxbock I already forgot how to do this:  https://gist.github.com/luxbock/3403337442fb3782321209edaa7fffc0"><span class="u" id="1465641990.000006">2016:06:11 10:46:30              luxbock </span><span>I already forgot how to do this: </span><a href="https://gist.github.com/luxbock/3403337442fb3782321209edaa7fffc0">https://gist.github.com/luxbock/3403337442fb3782321209edaa7fffc0</a></div><div data-t="luxbock how can I move lift the filter-part from the function into the selector?"><span class="u" id="1465642007.000007">2016:06:11 10:46:47              luxbock </span><span>how can I move lift the filter-part from the function into the selector?</span></div><div data-t="conaw filterer?"><span class="u" id="1465642028.000008">2016:06:11 10:47:08                conaw </span><span>filterer?</span></div><div data-t="luxbock @conaw: I think that counts the  :bar  keys as well"><span class="u" id="1465642086.000009">2016:06:11 10:48:06              luxbock </span><span>@conaw: I think that counts the </span><code>:bar</code><span> keys as well</span></div><div data-t="luxbock the return value I want is  {:a 2, :b 3}"><span class="u" id="1465642212.000014">2016:06:11 10:50:12              luxbock </span><span>the return value I want is </span><code>{:a 2, :b 3}</code></div><div data-t="codonnell @luxbock: not sure if this is optimal, but it works"><span class="u" id="1465644947.000017">2016:06:11 11:35:47            codonnell </span><span>@luxbock: not sure if this is optimal, but it works</span></div><div data-t="codonnell (transform [MAP-VALS (collect-one (filterer (fn [m] (contains? m :foo))))] (fn [ms _] (count ms)) data)"><span class="u" id="1465644951.000018">2016:06:11 11:35:51            codonnell </span><code>(transform [MAP-VALS (collect-one (filterer (fn [m] (contains? m :foo))))] (fn [ms _] (count ms)) data)</code></div><div data-t="nathanmarz @luxbock: I would do it like this:
 (transform [MAP-VALS (collect ALL (pred :foo))]
  (fn [a _] (count a))
  {:a [{:foo 1} {:bar 3} {:foo 4}]
   :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]}
  )
"><span class="u" id="1465645406.000019">2016:06:11 11:43:26           nathanmarz </span><span>@luxbock: I would do it like this:
</span><pre>(transform [MAP-VALS (collect ALL (pred :foo))]
  (fn [a _] (count a))
  {:a [{:foo 1} {:bar 3} {:foo 4}]
   :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]}
  )
</pre></div><div data-t="nathanmarz can also use  must  instead of  pred  for  contains?  semantics"><span class="u" id="1465645449.000020">2016:06:11 11:44:09           nathanmarz </span><span>can also use </span><code>must</code><span> instead of </span><code>pred</code><span> for </span><code>contains?</code><span> semantics</span></div><div data-t="codonnell I&apos;m trying to understand how late binding works for filterer. It seems to work fine if I pass it a late binding navigator, like must or pred. However, if I try to pass a predicate function directly, I get an exception. Is that just how filterer works or am I missing something?"><span class="u" id="1465649078.000022">2016:06:11 12:44:38            codonnell </span><span>I&apos;m trying to understand how late binding works for filterer. It seems to work fine if I pass it a late binding navigator, like must or pred. However, if I try to pass a predicate function directly, I get an exception. Is that just how filterer works or am I missing something?</span></div><div data-t="nathanmarz @codonnell:  filterer  isn&apos;t a navigator"><span class="u" id="1465649152.000023">2016:06:11 12:45:52           nathanmarz </span><span>@codonnell: </span><code>filterer</code><span> isn&apos;t a navigator</span></div><div data-t="nathanmarz it&apos;s a function that returns a navigator"><span class="u" id="1465649160.000024">2016:06:11 12:46:00           nathanmarz </span><span>it&apos;s a function that returns a navigator</span></div><div data-t="nathanmarz so when you use it in  comp-path  it gets interpreted like all functions do – as a filter function"><span class="u" id="1465649188.000025">2016:06:11 12:46:28           nathanmarz </span><span>so when you use it in </span><code>comp-path</code><span> it gets interpreted like all functions do – as a filter function</span></div><div data-t="nathanmarz filterer  can be invoked with a path that requires more parameters to then create a navigator that requires those parameters"><span class="u" id="1465649231.000026">2016:06:11 12:47:11           nathanmarz </span><code>filterer</code><span> can be invoked with a path that requires more parameters to then create a navigator that requires those parameters</span></div><div data-t="nathanmarz btw, it&apos;s very rare that you need to explicitly precompile anymore"><span class="u" id="1465649257.000027">2016:06:11 12:47:37           nathanmarz </span><span>btw, it&apos;s very rare that you need to explicitly precompile anymore</span></div><div data-t="nathanmarz (select-one (filterer even?) (range 10))  in 0.11.2 should be within 2-3% of the precompiled code"><span class="u" id="1465649299.000028">2016:06:11 12:48:19           nathanmarz </span><code>(select-one (filterer even?) (range 10))</code><span> in 0.11.2 should be within 2-3% of the precompiled code</span></div><div data-t="codonnell Alright, that makes sense. Thanks for the response. I&apos;m aware that compiling paths is generally unnecessary in 0.11.2. I&apos;m writing up some notes for myself and got confused about filterer behavior, so I wanted to clarify for my notes."><span class="u" id="1465649452.000029">2016:06:11 12:50:52            codonnell </span><span>Alright, that makes sense. Thanks for the response. I&apos;m aware that compiling paths is generally unnecessary in 0.11.2. I&apos;m writing up some notes for myself and got confused about filterer behavior, so I wanted to clarify for my notes.</span></div><div data-t="nathanmarz cool"><span class="u" id="1465649468.000030">2016:06:11 12:51:08           nathanmarz </span><span>cool</span></div><div data-t="nathanmarz I opened up  https://github.com/nathanmarz/specter/issues/122"><span class="u" id="1465649473.000031">2016:06:11 12:51:13           nathanmarz </span><span>I opened up </span><a href="https://github.com/nathanmarz/specter/issues/122">https://github.com/nathanmarz/specter/issues/122</a></div><div data-t="nathanmarz Specter should detect that mistake and throw an error"><span class="u" id="1465649487.000033">2016:06:11 12:51:27           nathanmarz </span><span>Specter should detect that mistake and throw an error</span></div><div data-t="codonnell I appreciate that. Informative error messages make a huge difference."><span class="u" id="1465649518.000034">2016:06:11 12:51:58            codonnell </span><span>I appreciate that. Informative error messages make a huge difference.</span></div><div data-t="conaw is there a reason why MAP-VALS might not work in cljs"><span class="u" id="1465649650.000035">2016:06:11 12:54:10                conaw </span><span>is there a reason why MAP-VALS might not work in cljs</span></div><div data-t="conaw Use of undeclared Var com.rpl.specter/MAP-VALS at line 1"><span class="u" id="1465649668.000036">2016:06:11 12:54:28                conaw </span><span>Use of undeclared Var com.rpl.specter/MAP-VALS at line 1</span></div><div data-t="conaw easy enough to define oneself, but surprised by that error"><span class="u" id="1465649728.000037">2016:06:11 12:55:28                conaw </span><span>easy enough to define oneself, but surprised by that error</span></div><div data-t="nathanmarz Are you using 0.11.1 or later?"><span class="u" id="1465649810.000038">2016:06:11 12:56:50           nathanmarz </span><span>Are you using 0.11.1 or later?</span></div><div data-t="conaw 11.0"><span class="u" id="1465649835.000039">2016:06:11 12:57:15                conaw </span><span>11.0</span></div><div data-t="nathanmarz you should use the built-in one as its about twice as fast at  [ALL LAST]"><span class="u" id="1465649836.000040">2016:06:11 12:57:16           nathanmarz </span><span>you should use the built-in one as its about twice as fast at </span><code>[ALL LAST]</code></div><div data-t="nathanmarz it was added in 0.11.1"><span class="u" id="1465649845.000041">2016:06:11 12:57:25           nathanmarz </span><span>it was added in 0.11.1</span></div><div data-t="nathanmarz Highly recommend upgrading to 0.11.2"><span class="u" id="1465649858.000042">2016:06:11 12:57:38           nathanmarz </span><span>Highly recommend upgrading to 0.11.2</span></div><div data-t="conaw done"><span class="u" id="1465650135.000043">2016:06:11 13:02:15                conaw </span><span>done</span></div><div data-t="conaw @nathanmarz: regarding @luxbock’s example, when I do 
 (transform [ALL LAST (sp/collect ALL (sp/pred :foo))]
        count
    {:a [{:foo 1} {:bar 3} {:foo 4}]
     :c [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})

;;=&gt;  {:a 2 c: 3}

(transform [MAP-VALS (sp/collect ALL (sp/pred :foo))]
           (fn [e _] (count e))
           {:a [{:foo 1} {:bar 3} {:foo 4}]
            :c [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
;;=&gt; 0"><span class="u" id="1465651057.000044">2016:06:11 13:17:37                conaw </span><span>@nathanmarz: regarding @luxbock’s example, when I do 
</span><pre>(transform [ALL LAST (sp/collect ALL (sp/pred :foo))]
        count
    {:a [{:foo 1} {:bar 3} {:foo 4}]
     :c [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})

;;=&gt;  {:a 2 c: 3}

(transform [MAP-VALS (sp/collect ALL (sp/pred :foo))]
           (fn [e _] (count e))
           {:a [{:foo 1} {:bar 3} {:foo 4}]
            :c [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
;;=&gt; 0</pre></div><div data-t="conaw (transform [MAP-VALS (sp/collect ALL (sp/pred :foo))]
           count
           {:a [{:foo 1} {:bar 3} {:foo 4}]
     :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
;;=&gt; 0"><span class="u" id="1465651167.000046">2016:06:11 13:19:27                conaw </span><pre>(transform [MAP-VALS (sp/collect ALL (sp/pred :foo))]
           count
           {:a [{:foo 1} {:bar 3} {:foo 4}]
     :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
;;=&gt; 0</pre></div><div data-t="codonnell (transform [MAP-VALS (collect ALL (must :foo))] (fn [c _] (count c)) data)
{:a 2, :b 3}"><span class="u" id="1465651356.000047">2016:06:11 13:22:36            codonnell </span><pre>(transform [MAP-VALS (collect ALL (must :foo))] (fn [c _] (count c)) data)
{:a 2, :b 3}</pre></div><div data-t="conaw I’m just pointing out that ALL LAST and MAP-VALS aren’t equivalent in this case"><span class="u" id="1465651393.000048">2016:06:11 13:23:13                conaw </span><span>I’m just pointing out that ALL LAST and MAP-VALS aren’t equivalent in this case</span></div><div data-t="codonnell ah, interesting"><span class="u" id="1465651400.000049">2016:06:11 13:23:20            codonnell </span><span>ah, interesting</span></div><div data-t="conaw pred and must are equivelent"><span class="u" id="1465651427.000050">2016:06:11 13:23:47                conaw </span><span>pred and must are equivelent</span></div><div data-t="conaw (transform [ALL LAST (sp/collect ALL (sp/must :foo))]
        count
    {:a [{:foo 1} {:bar 3} {:foo 4}]
     :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
;;=&gt; {:a 2 :b 3}"><span class="u" id="1465651458.000051">2016:06:11 13:24:18                conaw </span><pre>(transform [ALL LAST (sp/collect ALL (sp/must :foo))]
        count
    {:a [{:foo 1} {:bar 3} {:foo 4}]
     :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
;;=&gt; {:a 2 :b 3}</pre></div><div data-t="conaw in this example at least"><span class="u" id="1465651491.000052">2016:06:11 13:24:51                conaw </span><span>in this example at least</span></div><div data-t="nathanmarz @conaw: not reproducing your [ALL LAST] vs. MAP-VALS"><span class="u" id="1465651671.000053">2016:06:11 13:27:51           nathanmarz </span><span>@conaw: not reproducing your [ALL LAST] vs. MAP-VALS</span></div><div data-t="codonnell I&apos;m not sure how those are working with plain count. Shouldn&apos;t the transforming function get passed two values?"><span class="u" id="1465651702.000054">2016:06:11 13:28:22            codonnell </span><span>I&apos;m not sure how those are working with plain count. Shouldn&apos;t the transforming function get passed two values?</span></div><div data-t="codonnell I get an exception that count is passed two values."><span class="u" id="1465651719.000055">2016:06:11 13:28:39            codonnell </span><span>I get an exception that count is passed two values.</span></div><div data-t="nathanmarz it shouldn&apos;t be working but it looks like clojurescript doesn&apos;t throw an arity exception"><span class="u" id="1465651740.000056">2016:06:11 13:29:00           nathanmarz </span><span>it shouldn&apos;t be working but it looks like clojurescript doesn&apos;t throw an arity exception</span></div><div data-t="nathanmarz it just ignores args beyond the first"><span class="u" id="1465651748.000057">2016:06:11 13:29:08           nathanmarz </span><span>it just ignores args beyond the first</span></div><div data-t="conaw either way, why would I be getting 0 back from the map vals transform"><span class="u" id="1465652144.000060">2016:06:11 13:35:44                conaw </span><span>either way, why would I be getting 0 back from the map vals transform</span></div><div data-t="conaw this is the exact code I’m running  (transform [ALL LAST (collect ALL (must :foo))]
        count
    {:a [{:foo 1} {:bar 3} {:foo 4}]
     :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})


(transform [MAP-VALS (sp/collect ALL (pred :foo))]
           (fn [a _] (count a))
           {:a [{:foo 1} {:bar 3} {:foo 4}]
            :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
"><span class="u" id="1465652162.000061">2016:06:11 13:36:02                conaw </span><span>this is the exact code I’m running </span><pre>(transform [ALL LAST (collect ALL (must :foo))]
        count
    {:a [{:foo 1} {:bar 3} {:foo 4}]
     :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})


(transform [MAP-VALS (sp/collect ALL (pred :foo))]
           (fn [a _] (count a))
           {:a [{:foo 1} {:bar 3} {:foo 4}]
            :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
</pre></div><div data-t="conaw using specter 0.11.2"><span class="u" id="1465652172.000062">2016:06:11 13:36:12                conaw </span><span>using specter 0.11.2</span></div><div data-t="conaw (transform [ALL LAST (collect ALL (must :foo))]
        (fn [a _] (count a))
    {:a [{:foo 1} {:bar 3} {:foo 4}]
     :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
"><span class="u" id="1465652217.000063">2016:06:11 13:36:57                conaw </span><pre>(transform [ALL LAST (collect ALL (must :foo))]
        (fn [a _] (count a))
    {:a [{:foo 1} {:bar 3} {:foo 4}]
     :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
</pre></div><div data-t="conaw this also returns expected value"><span class="u" id="1465652223.000064">2016:06:11 13:37:03                conaw </span><span>this also returns expected value</span></div><div data-t="conaw just MAP-VALS that doesn&apos;t"><span class="u" id="1465652231.000065">2016:06:11 13:37:11                conaw </span><span>just MAP-VALS that doesn&apos;t</span></div><div data-t="nathanmarz cljs.user=&gt; 
(transform [s/MAP-VALS (s/collect s/ALL (s/pred :foo))]
           (fn [a _] (count a))
           {:a [{:foo 1} {:bar 3} {:foo 4}]
            :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
{:a 2, :b 3}
"><span class="u" id="1465652241.000066">2016:06:11 13:37:21           nathanmarz </span><pre>cljs.user=&gt; 
(transform [s/MAP-VALS (s/collect s/ALL (s/pred :foo))]
           (fn [a _] (count a))
           {:a [{:foo 1} {:bar 3} {:foo 4}]
            :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
{:a 2, :b 3}
</pre></div><div data-t="nathanmarz cljs.user=&gt; 
(transform [s/MAP-VALS (s/collect s/ALL (s/must :foo))]
           (fn [a _] (count a))
           {:a [{:foo 1} {:bar 3} {:foo 4}]
            :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
{:a 2, :b 3}
"><span class="u" id="1465652264.000067">2016:06:11 13:37:44           nathanmarz </span><pre>cljs.user=&gt; 
(transform [s/MAP-VALS (s/collect s/ALL (s/must :foo))]
           (fn [a _] (count a))
           {:a [{:foo 1} {:bar 3} {:foo 4}]
            :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
{:a 2, :b 3}
</pre></div><div data-t="conaw yeah, that’s what I’m running"><span class="u" id="1465652307.000068">2016:06:11 13:38:27                conaw </span><span>yeah, that’s what I’m running</span></div><div data-t="conaw getting 0"><span class="u" id="1465652309.000069">2016:06:11 13:38:29                conaw </span><span>getting 0</span></div><div data-t="conaw weird"><span class="u" id="1465652313.000070">2016:06:11 13:38:33                conaw </span><span>weird</span></div><div data-t="nathanmarz are you redefining MAP-VALS?"><span class="u" id="1465652317.000071">2016:06:11 13:38:37           nathanmarz </span><span>are you redefining MAP-VALS?</span></div><div data-t="conaw nope"><span class="u" id="1465652321.000072">2016:06:11 13:38:41                conaw </span><span>nope</span></div><div data-t="nathanmarz are you doing it from a fresh repl?"><span class="u" id="1465652343.000073">2016:06:11 13:39:03           nathanmarz </span><span>are you doing it from a fresh repl?</span></div><div data-t="conaw just did a lein clean"><span class="u" id="1465652350.000074">2016:06:11 13:39:10                conaw </span><span>just did a lein clean</span></div><div data-t="conaw and started repl fresh"><span class="u" id="1465652354.000075">2016:06:11 13:39:14                conaw </span><span>and started repl fresh</span></div><div data-t="nathanmarz (require &apos;[com.rpl.specter :as s])
(require-macros &apos;[com.rpl.specter.macros :refer [select transform]])

(transform [s/MAP-VALS (s/collect s/ALL (s/pred :foo))]
           (fn [a _] (count a))
           {:a [{:foo 1} {:bar 3} {:foo 4}]
            :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
"><span class="u" id="1465652384.000077">2016:06:11 13:39:44           nathanmarz </span><pre>(require &apos;[com.rpl.specter :as s])
(require-macros &apos;[com.rpl.specter.macros :refer [select transform]])

(transform [s/MAP-VALS (s/collect s/ALL (s/pred :foo))]
           (fn [a _] (count a))
           {:a [{:foo 1} {:bar 3} {:foo 4}]
            :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
</pre></div><div data-t="nathanmarz and that exact code returns 0?"><span class="u" id="1465652390.000078">2016:06:11 13:39:50           nathanmarz </span><span>and that exact code returns 0?</span></div><div data-t="conaw indeed"><span class="u" id="1465652400.000080">2016:06:11 13:40:00                conaw </span><span>indeed</span></div><div data-t="nathanmarz doesn&apos;t make any sense"><span class="u" id="1465652456.000081">2016:06:11 13:40:56           nathanmarz </span><span>doesn&apos;t make any sense</span></div><div data-t="nathanmarz you&apos;ll need to put up a repo and instructions to reproduce it"><span class="u" id="1465652469.000082">2016:06:11 13:41:09           nathanmarz </span><span>you&apos;ll need to put up a repo and instructions to reproduce it</span></div><div data-t="nathanmarz oh one more idea"><span class="u" id="1465652506.000083">2016:06:11 13:41:46           nathanmarz </span><span>oh one more idea</span></div><div data-t="nathanmarz what version of cljs?"><span class="u" id="1465652509.000084">2016:06:11 13:41:49           nathanmarz </span><span>what version of cljs?</span></div><div data-t="conaw 1.9.14"><span class="u" id="1465652539.000085">2016:06:11 13:42:19                conaw </span><span>1.9.14</span></div><div data-t="conaw I’ve been using specter and spec together"><span class="u" id="1465652589.000086">2016:06:11 13:43:09                conaw </span><span>I’ve been using specter and spec together</span></div><div data-t="nathanmarz what version of clojure are you pairing that with?"><span class="u" id="1465652644.000087">2016:06:11 13:44:04           nathanmarz </span><span>what version of clojure are you pairing that with?</span></div><div data-t="nathanmarz 1.9.0-alpha4?"><span class="u" id="1465652649.000088">2016:06:11 13:44:09           nathanmarz </span><span>1.9.0-alpha4?</span></div><div data-t="conaw alpha3"><span class="u" id="1465652653.000089">2016:06:11 13:44:13                conaw </span><span>alpha3</span></div><div data-t="conaw are you on more recent?"><span class="u" id="1465652669.000090">2016:06:11 13:44:29                conaw </span><span>are you on more recent?</span></div><div data-t="nathanmarz i just tried on those exact versions and it works fine"><span class="u" id="1465652788.000091">2016:06:11 13:46:28           nathanmarz </span><span>i just tried on those exact versions and it works fine</span></div><div data-t="nathanmarz so yea, need a repo to see what&apos;s going on"><span class="u" id="1465652795.000092">2016:06:11 13:46:35           nathanmarz </span><span>so yea, need a repo to see what&apos;s going on</span></div><div data-t="luxbock thanks @nathanmarz"><span class="u" id="1465653691.000093">2016:06:11 14:01:31              luxbock </span><span>thanks @nathanmarz</span></div><div data-t="conaw @luxbock: map-vals works fine for you right?"><span class="u" id="1465653710.000094">2016:06:11 14:01:50                conaw </span><span>@luxbock: map-vals works fine for you right?</span></div><div data-t="luxbock @conaw, I need to upgrade to check"><span class="u" id="1465653760.000095">2016:06:11 14:02:40              luxbock </span><span>@conaw, I need to upgrade to check</span></div><div data-t="conaw @nathanmarz: must be something on my end, created a new clean project and got it working fine"><span class="u" id="1465654202.000096">2016:06:11 14:10:02                conaw </span><span>@nathanmarz: must be something on my end, created a new clean project and got it working fine</span></div><div data-t="conaw this is what I get back from (transform MAP-VALS inc {:a 1 :b 2})

&quot;{:a 1, :b 2}1”"><span class="u" id="1465655281.000097">2016:06:11 14:28:01                conaw </span><pre>this is what I get back from (transform MAP-VALS inc {:a 1 :b 2})

&quot;{:a 1, :b 2}1”</pre></div><div data-t="conaw I’m getting that in a file where the ONLY thing I’m loading in is specter"><span class="u" id="1465655326.000098">2016:06:11 14:28:46                conaw </span><span>I’m getting that in a file where the ONLY thing I’m loading in is specter</span></div><div data-t="conaw and the only function is that"><span class="u" id="1465655335.000099">2016:06:11 14:28:55                conaw </span><span>and the only function is that</span></div><div data-t="conaw also strange that this is the only part of specter that’s giving me weird results"><span class="u" id="1465655395.000100">2016:06:11 14:29:55                conaw </span><span>also strange that this is the only part of specter that’s giving me weird results</span></div><div data-t="luxbock ah yeah works fine for me"><span class="u" id="1465659723.000101">2016:06:11 15:42:03              luxbock </span><span>ah yeah works fine for me</span></div><div data-t="codonnell Does anyone know how subselect is meant to be used?"><span class="u" id="1465684311.000108">2016:06:11 22:31:51            codonnell </span><span>Does anyone know how subselect is meant to be used?</span></div><div data-t="eraserhd I’ve just published a library that has specter paths for working with formatted EDN and clojure code:  https://github.com/maitria/specter-edn"><span class="u" id="1465684702.000110">2016:06:11 22:38:22             eraserhd </span><span>I’ve just published a library that has specter paths for working with formatted EDN and clojure code: </span><a href="https://github.com/maitria/specter-edn">https://github.com/maitria/specter-edn</a></div><div data-t="eraserhd It navigates to parsed S-expressions, but re-inserts whitespace and comments."><span class="u" id="1465684734.000112">2016:06:11 22:38:54             eraserhd </span><span>It navigates to parsed S-expressions, but re-inserts whitespace and comments.</span></div><div data-t="nathanmarz @codonnell:  subselect  navigates you to the elements in the given path and lets you manipulate them as a sequence, but transformations will be applied back at the original locations"><span class="u" id="1465688822.000113">2016:06:11 23:47:02           nathanmarz </span><span>@codonnell: </span><code>subselect</code><span> navigates you to the elements in the given path and lets you manipulate them as a sequence, but transformations will be applied back at the original locations</span></div><div data-t="nathanmarz (transform (subselect (walker number?) even?)
  reverse
  [1 [[[2]] 3] 5 [6 [7 8]] 10])
;; =&gt; [1 [[[10]] 3] 5 [8 [7 6]] 2]
"><span class="u" id="1465688846.000114">2016:06:11 23:47:26           nathanmarz </span><pre>(transform (subselect (walker number?) even?)
  reverse
  [1 [[[2]] 3] 5 [6 [7 8]] 10])
;; =&gt; [1 [[[10]] 3] 5 [8 [7 6]] 2]
</pre></div><div data-t="nathanmarz @eraserhd: very cool!"><span class="u" id="1465689009.000115">2016:06:11 23:50:09           nathanmarz </span><span>@eraserhd: very cool!</span></div><div data-t="codonnell @nathanmarz: ok, so it&apos;s a more general version of pathed functions like srange and filterer"><span class="u" id="1465689838.000116">2016:06:12 00:03:58            codonnell </span><span>@nathanmarz: ok, so it&apos;s a more general version of pathed functions like srange and filterer</span></div><div data-t="codonnell thanks for the response"><span class="u" id="1465689843.000117">2016:06:12 00:04:03            codonnell </span><span>thanks for the response</span></div><div data-t="codonnell the example was very helpful"><span class="u" id="1465689847.000118">2016:06:12 00:04:07            codonnell </span><span>the example was very helpful</span></div><div data-t="nathanmarz @codonnell: It&apos;s a generalization of filterer but not of srange"><span class="u" id="1465698309.000122">2016:06:12 02:25:09           nathanmarz </span><span>@codonnell: It&apos;s a generalization of filterer but not of srange</span></div><div data-t="nathanmarz filterer is defined as (subselect ALL (selected? path))"><span class="u" id="1465698339.000123">2016:06:12 02:25:39           nathanmarz </span><span>filterer is defined as (subselect ALL (selected? path))</span></div><div data-t="nathanmarz the expected transformed sequence for subselect is expected to remain the same size, with each index referring to a particular location in the original structure"><span class="u" id="1465698385.000124">2016:06:12 02:26:25           nathanmarz </span><span>the expected transformed sequence for subselect is expected to remain the same size, with each index referring to a particular location in the original structure</span></div><div data-t="nathanmarz the transformed sequence for srange can be of any size and will splice back into the original sequence to replace the original subsequence"><span class="u" id="1465698408.000125">2016:06:12 02:26:48           nathanmarz </span><span>the transformed sequence for srange can be of any size and will splice back into the original sequence to replace the original subsequence</span></div><div data-t="codonnell @nathanmarz: that makes sense."><span class="u" id="1465699169.000126">2016:06:12 02:39:29            codonnell </span><span>@nathanmarz: that makes sense.</span></div><div data-t="codonnell @nathanmarz: I put up my notes and examples as a github wiki page at  https://github.com/codonnell/specter/wiki/List-of-Navigators . It could serve as a starting point for navigator reference documentation; you&apos;re welcome to copy any of it that you&apos;d like."><span class="u" id="1465699443.000127">2016:06:12 02:44:03            codonnell </span><span>@nathanmarz: I put up my notes and examples as a github wiki page at </span><a href="https://github.com/codonnell/specter/wiki/List-of-Navigators">https://github.com/codonnell/specter/wiki/List-of-Navigators</a><span>. It could serve as a starting point for navigator reference documentation; you&apos;re welcome to copy any of it that you&apos;d like.</span></div><div data-t="aengelberg I like your wiki page because every navigator has a few examples. I&apos;m hoping Specter&apos;s official docs will be like that eventually."><span class="u" id="1465708892.000129">2016:06:12 05:21:32           aengelberg </span><span>I like your wiki page because every navigator has a few examples. I&apos;m hoping Specter&apos;s official docs will be like that eventually.</span></div><div data-t="nathanmarz @codonnell: That&apos;s great, I&apos;d like to get that merged into the official docs at some point"><span class="u" id="1465737836.000138">2016:06:12 13:23:56           nathanmarz </span><span>@codonnell: That&apos;s great, I&apos;d like to get that merged into the official docs at some point</span></div><div data-t="nathanmarz I made some modifications for things that were implementation details and not promised to have that exact behavior in future versions"><span class="u" id="1465737865.000139">2016:06:12 13:24:25           nathanmarz </span><span>I made some modifications for things that were implementation details and not promised to have that exact behavior in future versions</span></div><div data-t="nathanmarz For example, in many parts it said &quot;returns a lazy sequence when used in a select&quot;, and that behavior is already completely different in 0.12.0"><span class="u" id="1465737903.000140">2016:06:12 13:25:03           nathanmarz </span><span>For example, in many parts it said &quot;returns a lazy sequence when used in a select&quot;, and that behavior is already completely different in 0.12.0</span></div><div data-t="nathanmarz As for  params-reset , that&apos;s used to make a recursive path that requires parameters"><span class="u" id="1465737944.000141">2016:06:12 13:25:44           nathanmarz </span><span>As for </span><code>params-reset</code><span>, that&apos;s used to make a recursive path that requires parameters</span></div><div data-t="nathanmarz by wrapping the recursive call in  params-reset , it tells the recursive navigation to use the same parameters"><span class="u" id="1465737972.000142">2016:06:12 13:26:12           nathanmarz </span><span>by wrapping the recursive call in </span><code>params-reset</code><span>, it tells the recursive navigation to use the same parameters</span></div><div data-t="nathanmarz e.g.
 (declarepath MyWalker [k])
(providepath MyWalker
  (stay-then-continue must (params-reset MyWalker)))

(select (MyWalker :a) {:a {:a {:b 2}}})
;; =&gt; [{:a {:a {:b 2}}} {:a {:b 2}} {:b 2}]
"><span class="u" id="1465738016.000143">2016:06:12 13:26:56           nathanmarz </span><span>e.g.
</span><pre>(declarepath MyWalker [k])
(providepath MyWalker
  (stay-then-continue must (params-reset MyWalker)))

(select (MyWalker :a) {:a {:a {:b 2}}})
;; =&gt; [{:a {:a {:b 2}}} {:a {:b 2}} {:b 2}]
</pre></div><div data-t="nathanmarz I merged it into the Specter wiki:  https://github.com/nathanmarz/specter/wiki/List-of-Navigators"><span class="u" id="1465739272.000147">2016:06:12 13:47:52           nathanmarz </span><span>I merged it into the Specter wiki: </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators">https://github.com/nathanmarz/specter/wiki/List-of-Navigators</a></div><div data-t="luxbock https://github.com/nathanmarz/specter/issues/123"><span class="u" id="1465743032.000150">2016:06:12 14:50:32              luxbock </span><a href="https://github.com/nathanmarz/specter/issues/123">https://github.com/nathanmarz/specter/issues/123</a></div><div data-t="rauh I like it, but PLEASE don&apos;t introduce anymore breaking changes"><span class="u" id="1465743540.000154">2016:06:12 14:59:00                 rauh </span><span>I like it, but PLEASE don&apos;t introduce anymore breaking changes</span></div><div data-t="rauh It&apos;s such a pain, I can&apos;t currently upgrade and I&apos;m stuck with an older version since the breaking macros changes."><span class="u" id="1465743569.000155">2016:06:12 14:59:29                 rauh </span><span>It&apos;s such a pain, I can&apos;t currently upgrade and I&apos;m stuck with an older version since the breaking macros changes.</span></div><div data-t="nathanmarz @rauh breaking changes are only done when they are necessary to enable very significant improvements"><span class="u" id="1465744496.000156">2016:06:12 15:14:56           nathanmarz </span><span>@rauh breaking changes are only done when they are necessary to enable very significant improvements</span></div><div data-t="nathanmarz what&apos;s preventing you from upgrading and making the appropriate updates?"><span class="u" id="1465744547.000157">2016:06:12 15:15:47           nathanmarz </span><span>what&apos;s preventing you from upgrading and making the appropriate updates?</span></div><div data-t="rauh @nathanmarz: I can&apos;t upgrade since midje pulls in an older specter"><span class="u" id="1465745176.000159">2016:06:12 15:26:16                 rauh </span><span>@nathanmarz: I can&apos;t upgrade since midje pulls in an older specter</span></div><div data-t="nathanmarz @rauh yea, that&apos;s unfortunate"><span class="u" id="1465745396.000160">2016:06:12 15:29:56           nathanmarz </span><span>@rauh yea, that&apos;s unfortunate</span></div><div data-t="rauh Not the end of the world, but specter is getting to the point (1100 gh stars, 57k clojar pulls) that it should be careful if the breaking changes are needed."><span class="u" id="1465745448.000161">2016:06:12 15:30:48                 rauh </span><span>Not the end of the world, but specter is getting to the point (1100 gh stars, 57k clojar pulls) that it should be careful if the breaking changes are needed.</span></div><div data-t="nathanmarz like I said, I only make breaking changes when the benefits are very significant"><span class="u" id="1465745484.000163">2016:06:12 15:31:24           nathanmarz </span><span>like I said, I only make breaking changes when the benefits are very significant</span></div><div data-t="rauh I agree that the macros was a change that was worth it."><span class="u" id="1465745485.000164">2016:06:12 15:31:25                 rauh </span><span>I agree that the macros was a change that was worth it.</span></div><div data-t="nathanmarz 0.12.0 will have another breaking change, but it only affects projects that define their own navigators"><span class="u" id="1465745504.000165">2016:06:12 15:31:44           nathanmarz </span><span>0.12.0 will have another breaking change, but it only affects projects that define their own navigators</span></div><div data-t="rauh Well I blame  suchwow  (used by midje) more for that since they use specter twice! (Two simple  transform )"><span class="u" id="1465745562.000166">2016:06:12 15:32:42                 rauh </span><span>Well I blame </span><code>suchwow</code><span> (used by midje) more for that since they use specter twice! (Two simple </span><code>transform</code><span>)</span></div><div data-t="nathanmarz Ah, well the 0.12.0 change only affects the select path"><span class="u" id="1465745598.000167">2016:06:12 15:33:18           nathanmarz </span><span>Ah, well the 0.12.0 change only affects the select path</span></div><div data-t="luxbock is there a better way to write the following:  https://gist.github.com/luxbock/93d61ccd38b340a99dfd3a93682b5f6c"><span class="u" id="1465746189.000170">2016:06:12 15:43:09              luxbock </span><span>is there a better way to write the following: </span><a href="https://gist.github.com/luxbock/93d61ccd38b340a99dfd3a93682b5f6c">https://gist.github.com/luxbock/93d61ccd38b340a99dfd3a93682b5f6c</a></div><div data-t="luxbock my actual use case is slightly more complicated"><span class="u" id="1465746206.000171">2016:06:12 15:43:26              luxbock </span><span>my actual use case is slightly more complicated</span></div><div data-t="nathanmarz (let [foo-map {:foo #{1 2 3} :bar #{5 6}}]
  (transform [ALL
              (collect-one FIRST (view #(get foo-map %)))
              LAST
              ALL
              ]
    (fn [aset v]
      (if (aset v)
        (str v)
        (inc v)
        ))
    {:foo [1 2 4 5]
     :bar [2 3 5 6]}
    ))
"><span class="u" id="1465746560.000172">2016:06:12 15:49:20           nathanmarz </span><pre>(let [foo-map {:foo #{1 2 3} :bar #{5 6}}]
  (transform [ALL
              (collect-one FIRST (view #(get foo-map %)))
              LAST
              ALL
              ]
    (fn [aset v]
      (if (aset v)
        (str v)
        (inc v)
        ))
    {:foo [1 2 4 5]
     :bar [2 3 5 6]}
    ))
</pre></div><div data-t="luxbock @nathanmarz: nice, I&apos;ll have to get familiar with  view `"><span class="u" id="1465746705.000173">2016:06:12 15:51:45              luxbock </span><span>@nathanmarz: nice, I&apos;ll have to get familiar with </span><code>view</code><span>`</span></div><div data-t="codonnell @nathanmarz: I added a description and examples for  params-reset  at  https://github.com/codonnell/specter/wiki/List-of-Navigators#params-reset"><span class="u" id="1465747739.000174">2016:06:12 16:08:59            codonnell </span><span>@nathanmarz: I added a description and examples for </span><code>params-reset</code><span> at </span><a href="https://github.com/codonnell/specter/wiki/List-of-Navigators#params-reset">https://github.com/codonnell/specter/wiki/List-of-Navigators#params-reset</a></div><div data-t="codonnell Thanks for removing the implementation detail."><span class="u" id="1465747784.000176">2016:06:12 16:09:44            codonnell </span><span>Thanks for removing the implementation detail.</span></div><div data-t="codonnell Is there a reason  params-reset  takes a single path argument rather than a varargs like most of the other pathed functions?"><span class="u" id="1465748172.000177">2016:06:12 16:16:12            codonnell </span><span>Is there a reason </span><code>params-reset</code><span> takes a single path argument rather than a varargs like most of the other pathed functions?</span></div><div data-t="nathanmarz @codonnell: It&apos;s only intended for the particular use case of recursive parameterized navigators"><span class="u" id="1465748350.000178">2016:06:12 16:19:10           nathanmarz </span><span>@codonnell: It&apos;s only intended for the particular use case of recursive parameterized navigators</span></div><div data-t="nathanmarz your description for params-reset is a little inaccurate – it actually decrements position in params array by the number of parameters that navigator requires"><span class="u" id="1465748393.000179">2016:06:12 16:19:53           nathanmarz </span><span>your description for params-reset is a little inaccurate – it actually decrements position in params array by the number of parameters that navigator requires</span></div><div data-t="nathanmarz where that&apos;s important is a path like  [must MyWalker]"><span class="u" id="1465748407.000180">2016:06:12 16:20:07           nathanmarz </span><span>where that&apos;s important is a path like </span><code>[must MyWalker]</code></div><div data-t="nathanmarz will merge in and fix description"><span class="u" id="1465748423.000181">2016:06:12 16:20:23           nathanmarz </span><span>will merge in and fix description</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/wiki/List-of-Navigators#params-reset"><span class="u" id="1465748578.000182">2016:06:12 16:22:58           nathanmarz </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#params-reset">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#params-reset</a></div><div data-t="codonnell The new description makes perfect sense."><span class="u" id="1465748794.000184">2016:06:12 16:26:34            codonnell </span><span>The new description makes perfect sense.</span></div><div data-t="nathanmarz By the way, really appreciate the documentation contribution – that&apos;s Specter&apos;s biggest problem at the moment"><span class="u" id="1465748849.000185">2016:06:12 16:27:29           nathanmarz </span><span>By the way, really appreciate the documentation contribution – that&apos;s Specter&apos;s biggest problem at the moment</span></div><div data-t="codonnell You&apos;re most welcome."><span class="u" id="1465748919.000186">2016:06:12 16:28:39            codonnell </span><span>You&apos;re most welcome.</span></div><div data-t="conaw @codonnell:  👏"><span class="u" id="1465749321.000187">2016:06:12 16:35:21                conaw </span><span>@codonnell: </span><b>👏</b></div><div data-t="codonnell @nathanmarz: I just realized every all-caps link and link with a  &gt;  in it was broken. It&apos;s fixed on my wiki. (Oops)"><span class="u" id="1465749518.000188">2016:06:12 16:38:38            codonnell </span><span>@nathanmarz: I just realized every all-caps link and link with a </span><code>&gt;</code><span> in it was broken. It&apos;s fixed on my wiki. (Oops)</span></div><div data-t="conaw Also, discovered the map-vals bug earlier wasn’t a bug, just my own insufficient cleaning of compiled javascript when updating specter versions."><span class="u" id="1465749629.000189">2016:06:12 16:40:29                conaw </span><span>Also, discovered the map-vals bug earlier wasn’t a bug, just my own insufficient cleaning of compiled javascript when updating specter versions.</span></div><div data-t="nathanmarz @codonnell: merged, thanks"><span class="u" id="1465749711.000190">2016:06:12 16:41:51           nathanmarz </span><span>@codonnell: merged, thanks</span></div><div data-t="nathanmarz @conaw: cool, good to know"><span class="u" id="1465749722.000191">2016:06:12 16:42:02           nathanmarz </span><span>@conaw: cool, good to know</span></div><div data-t="nathanmarz @mfikes: do you think it&apos;s possible to redo your  macroexpand&apos;  implementation in terms of  cljs.analyzer/macroexpand-1 ?"><span class="u" id="1465846749.000211">2016:06:13 19:39:09           nathanmarz </span><span>@mfikes: do you think it&apos;s possible to redo your </span><code>macroexpand&apos;</code><span> implementation in terms of </span><code>cljs.analyzer/macroexpand-1</code><span>?</span></div><div data-t="mfikes Sure… I think one just calls the other recursively or somesuch"><span class="u" id="1465846770.000212">2016:06:13 19:39:30               mfikes </span><span>Sure… I think one just calls the other recursively or somesuch</span></div><div data-t="nathanmarz does it still need to do the eval stuff?"><span class="u" id="1465846808.000213">2016:06:13 19:40:08           nathanmarz </span><span>does it still need to do the eval stuff?</span></div><div data-t="nathanmarz basically I need a macroexpand-all implementation for non-bootstrap clojurescript that&apos;s distinct from the clojure version of macroexpand-all, and I want to see if the bootstrap and non-bootstrap impls can be the same"><span class="u" id="1465846880.000214">2016:06:13 19:41:20           nathanmarz </span><span>basically I need a macroexpand-all implementation for non-bootstrap clojurescript that&apos;s distinct from the clojure version of macroexpand-all, and I want to see if the bootstrap and non-bootstrap impls can be the same</span></div><div data-t="mfikes Hmm… I think the need to eval was simply to cope with not having the form being directly passed to macroexpand. (looking at my post  http://blog.fikesfarm.com/posts/2015-09-05-runtime-macroexpand.html )"><span class="u" id="1465846906.000215">2016:06:13 19:41:46               mfikes </span><span>Hmm… I think the need to eval was simply to cope with not having the form being directly passed to macroexpand. (looking at my post </span><a href="http://blog.fikesfarm.com/posts/2015-09-05-runtime-macroexpand.html">http://blog.fikesfarm.com/posts/2015-09-05-runtime-macroexpand.html</a><span>)</span></div><div data-t="mfikes If there is a use case that you’d like it to work for, I wouldn’t mind taking a look perhaps later on tonight to see if it can be made to work in bootstrap."><span class="u" id="1465847036.000216">2016:06:13 19:43:56               mfikes </span><span>If there is a use case that you’d like it to work for, I wouldn’t mind taking a look perhaps later on tonight to see if it can be made to work in bootstrap.</span></div><div data-t="nathanmarz i&apos;ll get it working for non-boostrap cljs, and then I&apos;ll ping you to see if the new impl works for bootstrap"><span class="u" id="1465847102.000217">2016:06:13 19:45:02           nathanmarz </span><span>i&apos;ll get it working for non-boostrap cljs, and then I&apos;ll ping you to see if the new impl works for bootstrap</span></div><div data-t="nathanmarz otherwise specter will just use a different macroexpand-all for each of the 3 cases"><span class="u" id="1465847121.000218">2016:06:13 19:45:21           nathanmarz </span><span>otherwise specter will just use a different macroexpand-all for each of the 3 cases</span></div><div data-t="mfikes OK… yeah, and I just saw the thread in #C03S1L9DN  🙂"><span class="u" id="1465847157.000219">2016:06:13 19:45:57               mfikes </span><span>OK… yeah, and I just saw the thread in #C03S1L9DN </span><b>🙂</b></div><div data-t="mfikes By the way, Specter is the only major lib I’m aware of that is straddling all 3 targets. It feels like it ain’t easy to do, but it can be done.  🙂"><span class="u" id="1465847226.000220">2016:06:13 19:47:06               mfikes </span><span>By the way, Specter is the only major lib I’m aware of that is straddling all 3 targets. It feels like it ain’t easy to do, but it can be done. </span><b>🙂</b></div><div data-t="nathanmarz indeed"><span class="u" id="1465847234.000221">2016:06:13 19:47:14           nathanmarz </span><span>indeed</span></div><div data-t="nathanmarz sometimes I yell out the occasional profanity, but it&apos;s doable"><span class="u" id="1465847286.000222">2016:06:13 19:48:06           nathanmarz </span><span>sometimes I yell out the occasional profanity, but it&apos;s doable</span></div><div data-t="mfikes Hah. As you said, profanity leads to code these days."><span class="u" id="1465847319.000223">2016:06:13 19:48:39               mfikes </span><span>Hah. As you said, profanity leads to code these days.</span></div><div data-t="nathanmarz @mfikes: alright, finally got it working with this commit  https://github.com/nathanmarz/specter/commit/8c128816f58d8e2188a8a19b7d336dc5a128f7d3"><span class="u" id="1465853075.000227">2016:06:13 21:24:35           nathanmarz </span><span>@mfikes: alright, finally got it working with this commit </span><a href="https://github.com/nathanmarz/specter/commit/8c128816f58d8e2188a8a19b7d336dc5a128f7d3">https://github.com/nathanmarz/specter/commit/8c128816f58d8e2188a8a19b7d336dc5a128f7d3</a></div><div data-t="nathanmarz let me know if it&apos;s still bootstrap-compatible"><span class="u" id="1465853083.000229">2016:06:13 21:24:43           nathanmarz </span><span>let me know if it&apos;s still bootstrap-compatible</span></div><div data-t="mfikes @nathanmarz: will do"><span class="u" id="1465854801.000230">2016:06:13 21:53:21               mfikes </span><span>@nathanmarz: will do</span></div><div data-t="mfikes @nathanmarz: Gotta run but was at least able to see a problem with  riddley.walk :
 $ planck -c target/specter-0.12.0-SNAPSHOT.jar:/Users/mfikes/.m2/repository/riddley/riddley/0.1.12/riddley-0.1.12.jar
Planck 1.14
ClojureScript 1.9.14
    Docs: (doc function-name-here)
          (find-doc &quot;part-of-name-here&quot;)
  Source: (source function-name-here)
    Exit: Control+D or :cljs/quit or exit or quit
 Results: Stored in vars *1, *2, *3, an exception in *e

cljs.user=&gt; (require-macros &apos;[com.rpl.specter.macros :refer [transform]])
No such namespace: riddley.walk, could not locate riddley/walk.cljs, riddley/walk.cljc, or Closure namespace &quot;riddley.walk&quot;
nil
"><span class="u" id="1465855969.000231">2016:06:13 22:12:49               mfikes </span><span>@nathanmarz: Gotta run but was at least able to see a problem with </span><code>riddley.walk</code><span>:
</span><pre>$ planck -c target/specter-0.12.0-SNAPSHOT.jar:/Users/mfikes/.m2/repository/riddley/riddley/0.1.12/riddley-0.1.12.jar
Planck 1.14
ClojureScript 1.9.14
    Docs: (doc function-name-here)
          (find-doc &quot;part-of-name-here&quot;)
  Source: (source function-name-here)
    Exit: Control+D or :cljs/quit or exit or quit
 Results: Stored in vars *1, *2, *3, an exception in *e

cljs.user=&gt; (require-macros &apos;[com.rpl.specter.macros :refer [transform]])
No such namespace: riddley.walk, could not locate riddley/walk.cljs, riddley/walk.cljc, or Closure namespace &quot;riddley.walk&quot;
nil
</pre></div><div data-t="nathanmarz @mfikes: ok, changed master so that shouldn&apos;t happen anymore with bootstrap"><span class="u" id="1465861813.000232">2016:06:13 23:50:13           nathanmarz </span><span>@mfikes: ok, changed master so that shouldn&apos;t happen anymore with bootstrap</span></div><div data-t="mfikes @nathanmarz: With master, the  transform  operation I typically try works. But, when loading  com.rpl.specter.macros  it complains about the use of  require  and  eval  on lines 448 and 452. I’m wondering, though, is a  transform  call sufficient to cover the new macroexpand code? (I suspect not, given  require  and  eval  being in the code paths that you probably want tested.)"><span class="u" id="1465866211.000236">2016:06:14 01:03:31               mfikes </span><span>@nathanmarz: With master, the </span><code>transform</code><span> operation I typically try works. But, when loading </span><code>com.rpl.specter.macros</code><span> it complains about the use of </span><code>require</code><span> and </span><code>eval</code><span> on lines 448 and 452. I’m wondering, though, is a </span><code>transform</code><span> call sufficient to cover the new macroexpand code? (I suspect not, given </span><code>require</code><span> and </span><code>eval</code><span> being in the code paths that you probably want tested.)</span></div><div data-t="mfikes @nathanmarz: Ahh… I found a call that will make it fail in bootstrap:
 cljs.user=&gt; (transform [(filterer odd?) LAST]
       #_=&gt;               inc
       #_=&gt;               [2 1 3 6 9 4 8])
             ⬆
undefined is not an object (evaluating &apos;com.rpl.specter.macros$macros.require.call&apos;) at line 1
"><span class="u" id="1465866548.000238">2016:06:14 01:09:08               mfikes </span><span>@nathanmarz: Ahh… I found a call that will make it fail in bootstrap:
</span><pre>cljs.user=&gt; (transform [(filterer odd?) LAST]
       #_=&gt;               inc
       #_=&gt;               [2 1 3 6 9 4 8])
             ⬆
undefined is not an object (evaluating &apos;com.rpl.specter.macros$macros.require.call&apos;) at line 1
</pre></div><div data-t="mfikes (I hear the profanity from here.)"><span class="u" id="1465866593.000239">2016:06:14 01:09:53               mfikes </span><span>(I hear the profanity from here.)</span></div><div data-t="mfikes @nathanmarz: It can be made to work in bootstrap by eliminating the  require  and the eval. Perhaps  macros.clj  would need to be converted to  macros.cljx  or somesuch to pull it off. This bit of code worked:
 (defn cljs-macroexpand [env form]
  #_(require &apos;cljs.analyzer)
  ;; need to get the expansion function like this so that 
  ;; this code compiles in a clojure environment where cljs.analyzer
  ;; namespace does not exist
  (let [expand-fn cljs.analyzer/macroexpand-1
        mform (expand-fn env form)]
    (cond (identical? form mform) mform
          (and (seq? mform) (#{&apos;js*} (first mform))) form
          :else (cljs-macroexpand env mform))))
 
and here it is working with those changes: 
 cljs.user=&gt; (require-macros &apos;[com.rpl.specter.macros :refer [transform]])
nil
cljs.user=&gt; (require &apos;[com.rpl.specter :refer [filterer LAST]])
nil
cljs.user=&gt; (transform [(filterer odd?) LAST]
       #_=&gt;  inc
       #_=&gt;  [2 1 3 6 9 4 8])
[2 1 3 6 10 4 8]
"><span class="u" id="1465867638.000240">2016:06:14 01:27:18               mfikes </span><span>@nathanmarz: It can be made to work in bootstrap by eliminating the </span><code>require</code><span> and the eval. Perhaps </span><code>macros.clj</code><span> would need to be converted to </span><code>macros.cljx</code><span> or somesuch to pull it off. This bit of code worked:
</span><pre>(defn cljs-macroexpand [env form]
  #_(require &apos;cljs.analyzer)
  ;; need to get the expansion function like this so that 
  ;; this code compiles in a clojure environment where cljs.analyzer
  ;; namespace does not exist
  (let [expand-fn cljs.analyzer/macroexpand-1
        mform (expand-fn env form)]
    (cond (identical? form mform) mform
          (and (seq? mform) (#{&apos;js*} (first mform))) form
          :else (cljs-macroexpand env mform))))
</pre><span>
and here it is working with those changes: 
</span><pre>cljs.user=&gt; (require-macros &apos;[com.rpl.specter.macros :refer [transform]])
nil
cljs.user=&gt; (require &apos;[com.rpl.specter :refer [filterer LAST]])
nil
cljs.user=&gt; (transform [(filterer odd?) LAST]
       #_=&gt;  inc
       #_=&gt;  [2 1 3 6 9 4 8])
[2 1 3 6 10 4 8]
</pre></div><div data-t="conaw Challenge 
 For all the keys in a map of maps, return a vector that has the key and all of the values of its value,   
so 
 {:keep0 {:ignore :keep1, :ignore1 :keep2}}
-&gt;
[[:keep0 :keep1 :keep2]]

closest I’ve got is

(select [ALL (sp/collect-one sp/FIRST) LAST (sp/subselect MAP-VALS)] nested-map)

which gives me 

[[:keep0 (:keep1 :keep2)]]
"><span class="u" id="1465900100.000250">2016:06:14 10:28:20                conaw </span><span>Challenge 
</span><pre>For all the keys in a map of maps, return a vector that has the key and all of the values of its value,   
so 
 {:keep0 {:ignore :keep1, :ignore1 :keep2}}
-&gt;
[[:keep0 :keep1 :keep2]]

closest I’ve got is

(select [ALL (sp/collect-one sp/FIRST) LAST (sp/subselect MAP-VALS)] nested-map)

which gives me 

[[:keep0 (:keep1 :keep2)]]
</pre></div><div data-t="nathanmarz @conaw:  (select [ALL (subselect (multi-path FIRST [LAST MAP-VALS]))] {:keep0 {:ignore :keep1, :ignore1 :keep2}})"><span class="u" id="1465907463.000253">2016:06:14 12:31:03           nathanmarz </span><span>@conaw: </span><code>(select [ALL (subselect (multi-path FIRST [LAST MAP-VALS]))] {:keep0 {:ignore :keep1, :ignore1 :keep2}})</code></div><div data-t="nathanmarz @mfikes: with those changes does this code work?
 (require &apos;[com.rpl.specter :as s])
(require-macros &apos;[com.rpl.specter.macros :refer [select transform traverse collected?]])

(select [s/VAL (collected? [v] (= v 1)) s/DISPENSE] 1)
"><span class="u" id="1465907550.000254">2016:06:14 12:32:30           nathanmarz </span><span>@mfikes: with those changes does this code work?
</span><pre>(require &apos;[com.rpl.specter :as s])
(require-macros &apos;[com.rpl.specter.macros :refer [select transform traverse collected?]])

(select [s/VAL (collected? [v] (= v 1)) s/DISPENSE] 1)
</pre></div><div data-t="nathanmarz should return  [1]"><span class="u" id="1465907577.000255">2016:06:14 12:32:57           nathanmarz </span><span>should return </span><code>[1]</code></div><div data-t="mfikes @nathanmarz: Yes, I get  [1]  in Planck, with no warnings with those proposed changes"><span class="u" id="1465907736.000256">2016:06:14 12:35:36               mfikes </span><span>@nathanmarz: Yes, I get </span><code>[1]</code><span> in Planck, with no warnings with those proposed changes</span></div><div data-t="nathanmarz great"><span class="u" id="1465907808.000257">2016:06:14 12:36:48           nathanmarz </span><span>great</span></div><div data-t="nathanmarz should be able to fiddle with the code to get it working on all three platforms"><span class="u" id="1465907821.000258">2016:06:14 12:37:01           nathanmarz </span><span>should be able to fiddle with the code to get it working on all three platforms</span></div><div data-t="nathanmarz @mfikes: ok, made the changes. let me know how it goes"><span class="u" id="1465908329.000265">2016:06:14 12:45:29           nathanmarz </span><span>@mfikes: ok, made the changes. let me know how it goes</span></div><div data-t="mfikes @nathanmarz: Pulled down master of Specter and it’s a go for bootstrap with respect to trying out the  select  above."><span class="u" id="1465908527.000266">2016:06:14 12:48:47               mfikes </span><span>@nathanmarz: Pulled down master of Specter and it’s a go for bootstrap with respect to trying out the </span><code>select</code><span> above.</span></div><div data-t="nathanmarz awesome"><span class="u" id="1465908544.000267">2016:06:14 12:49:04           nathanmarz </span><span>awesome</span></div><div data-t="codonnell @nathanmarz: Continuing my efforts to understand; I wrote up some docs on the  macros  namespace at  https://github.com/codonnell/specter/wiki/List-of-Macros . I don&apos;t have all the macros in there yet and I&apos;m not as confident in the accuracy of my descriptions. Again, it could be a starting point for documentation."><span class="u" id="1465938414.000277">2016:06:14 21:06:54            codonnell </span><span>@nathanmarz: Continuing my efforts to understand; I wrote up some docs on the </span><code>macros</code><span> namespace at </span><a href="https://github.com/codonnell/specter/wiki/List-of-Macros">https://github.com/codonnell/specter/wiki/List-of-Macros</a><span>. I don&apos;t have all the macros in there yet and I&apos;m not as confident in the accuracy of my descriptions. Again, it could be a starting point for documentation.</span></div><div data-t="nathanmarz @codonnell: actually very accurate"><span class="u" id="1465940287.000279">2016:06:14 21:38:07           nathanmarz </span><span>@codonnell: actually very accurate</span></div><div data-t="nathanmarz the only thing I&apos;d change is the example for  defpathedfn"><span class="u" id="1465940296.000280">2016:06:14 21:38:16           nathanmarz </span><span>the only thing I&apos;d change is the example for </span><code>defpathedfn</code></div><div data-t="nathanmarz defpathedfn  is only meant for higher order navigators that take in paths as input"><span class="u" id="1465940318.000281">2016:06:14 21:38:38           nathanmarz </span><code>defpathedfn</code><span> is only meant for higher order navigators that take in paths as input</span></div><div data-t="nathanmarz the  ^:notpath  thing is if they also require a non-path param, for which  transformed  is the only case of that"><span class="u" id="1465940339.000282">2016:06:14 21:38:59           nathanmarz </span><span>the </span><code>^:notpath</code><span> thing is if they also require a non-path param, for which </span><code>transformed</code><span> is the only case of that</span></div><div data-t="nathanmarz making a constructor function for a navigator which converts the constructor params to the navigator params is what  defnavconstructor  is for"><span class="u" id="1465940372.000283">2016:06:14 21:39:32           nathanmarz </span><span>making a constructor function for a navigator which converts the constructor params to the navigator params is what </span><code>defnavconstructor</code><span> is for</span></div><div data-t="nathanmarz I would do that  walk-pred  example like this:
 (defnavconstructor walk-pred
  [p walker]
  [apred]
  (p #(and (integer? %) (apred %))))
"><span class="u" id="1465940534.000284">2016:06:14 21:42:14           nathanmarz </span><span>I would do that </span><code>walk-pred</code><span> example like this:
</span><pre>(defnavconstructor walk-pred
  [p walker]
  [apred]
  (p #(and (integer? %) (apred %))))
</pre></div><div data-t="nathanmarz the difference between this definition and one using defpathedfn is the parameter to navconstructor walk-pred can be completely dynamic, and the path can still be factored/cached"><span class="u" id="1465940592.000285">2016:06:14 21:43:12           nathanmarz </span><span>the difference between this definition and one using defpathedfn is the parameter to navconstructor walk-pred can be completely dynamic, and the path can still be factored/cached</span></div><div data-t="codonnell @nathanmarz: &quot;that itself takes in one or more paths as input&quot; is even in my description (taken from Codox) of  defpathedfn . I&apos;ll remove that example and add your modified version in the to-be written  defnavconstructor . I wasn&apos;t sure of the purpose of  defnavconstructor , but your example makes it clearer."><span class="u" id="1465940933.000286">2016:06:14 21:48:53            codonnell </span><span>@nathanmarz: &quot;that itself takes in one or more paths as input&quot; is even in my description (taken from Codox) of </span><code>defpathedfn</code><span>. I&apos;ll remove that example and add your modified version in the to-be written </span><code>defnavconstructor</code><span>. I wasn&apos;t sure of the purpose of </span><code>defnavconstructor</code><span>, but your example makes it clearer.</span></div><div data-t="codonnell Why is  transformed  not implemented using  defnavconstructor ?"><span class="u" id="1465940945.000287">2016:06:14 21:49:05            codonnell </span><span>Why is </span><code>transformed</code><span> not implemented using </span><code>defnavconstructor</code><span>?</span></div><div data-t="nathanmarz because it takes in a path"><span class="u" id="1465941021.000288">2016:06:14 21:50:21           nathanmarz </span><span>because it takes in a path</span></div><div data-t="nathanmarz navconstructor can only parameterize an existing navigator (either defined via  defnav  or  comp-paths ), it can&apos;t handle threading params into a nested path"><span class="u" id="1465941063.000289">2016:06:14 21:51:03           nathanmarz </span><span>navconstructor can only parameterize an existing navigator (either defined via </span><code>defnav</code><span> or </span><code>comp-paths</code><span>), it can&apos;t handle threading params into a nested path</span></div><div data-t="nathanmarz have you read this post?  https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs"><span class="u" id="1465941258.000290">2016:06:14 21:54:18           nathanmarz </span><span>have you read this post? </span><a href="https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs">https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs</a></div><div data-t="codonnell I did, but I should definitely take a second look now that I have a better understanding of how specter operates."><span class="u" id="1465941404.000292">2016:06:14 21:56:44            codonnell </span><span>I did, but I should definitely take a second look now that I have a better understanding of how specter operates.</span></div><div data-t="nathanmarz yea, understanding the mechanics of factoring is the key to understanding these different macros"><span class="u" id="1465941431.000293">2016:06:14 21:57:11           nathanmarz </span><span>yea, understanding the mechanics of factoring is the key to understanding these different macros</span></div><div data-t="nathanmarz it all comes down to the fact that to precompile something you need a completely static path"><span class="u" id="1465941461.000294">2016:06:14 21:57:41           nathanmarz </span><span>it all comes down to the fact that to precompile something you need a completely static path</span></div><div data-t="nathanmarz specter&apos;s trick of threading parameters later using an array leads to all these different mechanisms for parameterization"><span class="u" id="1465941490.000295">2016:06:14 21:58:10           nathanmarz </span><span>specter&apos;s trick of threading parameters later using an array leads to all these different mechanisms for parameterization</span></div><div data-t="codonnell Thanks for the suggestion. I&apos;ll read through it more carefully before proceeding further with the macro stuff."><span class="u" id="1465941591.000296">2016:06:14 21:59:51            codonnell </span><span>Thanks for the suggestion. I&apos;ll read through it more carefully before proceeding further with the macro stuff.</span></div><div data-t="nathanmarz sure thing, happy to answer more questions as they arise"><span class="u" id="1465941609.000297">2016:06:14 22:00:09           nathanmarz </span><span>sure thing, happy to answer more questions as they arise</span></div><div data-t="codonnell appreciate that"><span class="u" id="1465941648.000298">2016:06:14 22:00:48            codonnell </span><span>appreciate that</span></div><div data-t="nathanmarz the actual code that does the factoring may be helpful as well:  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L1385"><span class="u" id="1465941721.000299">2016:06:14 22:02:01           nathanmarz </span><span>the actual code that does the factoring may be helpful as well: </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L1385">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L1385</a></div><div data-t="codonnell &quot;magic-precompilation&quot; lol"><span class="u" id="1465941785.000301">2016:06:14 22:03:05            codonnell </span><span>&quot;magic-precompilation&quot; lol</span></div><div data-t="codonnell Yeah, this post makes a lot more sense now I&apos;m more familiar."><span class="u" id="1465941986.000302">2016:06:14 22:06:26            codonnell </span><span>Yeah, this post makes a lot more sense now I&apos;m more familiar.</span></div><div data-t="nathanmarz a reflection of my surprise when I first wrote this that this was actually possible  🙂"><span class="u" id="1465941987.000303">2016:06:14 22:06:27           nathanmarz </span><span>a reflection of my surprise when I first wrote this that this was actually possible </span><b>🙂</b></div><div data-t="codonnell @nathanmarz: Just to confirm.  magic-precompilation  returns the pair of precompiled path and function which sets the late-bound params mentioned in your post, right?"><span class="u" id="1465943319.000304">2016:06:14 22:28:39            codonnell </span><span>@nathanmarz: Just to confirm. </span><code>magic-precompilation</code><span> returns the pair of precompiled path and function which sets the late-bound params mentioned in your post, right?</span></div><div data-t="nathanmarz @codonnell: yes, though to be completely precise the function returns an array of late-bound params"><span class="u" id="1465943745.000305">2016:06:14 22:35:45           nathanmarz </span><span>@codonnell: yes, though to be completely precise the function returns an array of late-bound params</span></div><div data-t="mac Is there a way of passing a vector of paths to multi-path?"><span class="u" id="1465947017.000306">2016:06:14 23:30:17                  mac </span><span>Is there a way of passing a vector of paths to multi-path?</span></div><div data-t="mac Or an alternative way of  atomically transforming several paths using transform or setval?"><span class="u" id="1465947213.000307">2016:06:14 23:33:33                  mac </span><span>Or an alternative way of  atomically transforming several paths using transform or setval?</span></div><div data-t="nathanmarz you can call  (apply multi-path my-paths)"><span class="u" id="1465947251.000308">2016:06:14 23:34:11           nathanmarz </span><span>you can call </span><code>(apply multi-path my-paths)</code></div><div data-t="nathanmarz though if you want that to inline factor you should wrap it in this:
 (defpathedfn multi-path* [paths]
  (apply multi-path paths))
"><span class="u" id="1465947268.000309">2016:06:14 23:34:28           nathanmarz </span><span>though if you want that to inline factor you should wrap it in this:
</span><pre>(defpathedfn multi-path* [paths]
  (apply multi-path paths))
</pre></div><div data-t="mac Oh, I thought multi-path was a macro?"><span class="u" id="1465947293.000310">2016:06:14 23:34:53                  mac </span><span>Oh, I thought multi-path was a macro?</span></div><div data-t="nathanmarz actually nvm, it won&apos;t be possible to inline factor that anyway"><span class="u" id="1465947297.000311">2016:06:14 23:34:57           nathanmarz </span><span>actually nvm, it won&apos;t be possible to inline factor that anyway</span></div><div data-t="nathanmarz no it&apos;s a regular function"><span class="u" id="1465947308.000312">2016:06:14 23:35:08           nathanmarz </span><span>no it&apos;s a regular function</span></div><div data-t="nathanmarz hence the  fn  in  defpathedfn"><span class="u" id="1465947326.000313">2016:06:14 23:35:26           nathanmarz </span><span>hence the </span><code>fn</code><span> in </span><code>defpathedfn</code></div><div data-t="mac Ah silly me, it is just defined by a macor"><span class="u" id="1465947341.000314">2016:06:14 23:35:41                  mac </span><span>Ah silly me, it is just defined by a macor</span></div><div data-t="mac macro"><span class="u" id="1465947343.000315">2016:06:14 23:35:43                  mac </span><span>macro</span></div><div data-t="conaw Putting up another puzzle, this one relating to filters or conditionals

 Given a vector of maps
If the values of a key in the map is

a)    A map that has a key of tempid

return just the tempid

if the value of a key is a set, list, or vector  that contains maps with key of tempid
then replace each of those maps with their temp id

example 

[{:a &quot;foo&quot;,
  :b &quot;bar&quot;,
  :c
  [{:this &quot;other thing&quot;,
    :that
    {:nested :map, :deeper #{{:in :we-go, :tempid -1}}, :tempid -2},
    :tempid -3}],
  :tempid -4}
 {:this &quot;other thing&quot;,
  :that {:nested :map, :deeper #{{:in :we-go, :tempid -1}}, :tempid -2},
  :tempid -3}
 {:nested :map, :deeper #{{:in :we-go, :tempid -1}}, :tempid -2}
 {:in :we-go, :tempid -1}]


would become
[{:a “foo” :b “bar” :c [-3] :tempid -4}
  {:this “other thing” :that -2 :tempid -3} 
  {:nested :map :deeper #{-1} :tempid -2}
  {:in :we-go :tempid -1}]
"><span class="u" id="1465956282.000319">2016:06:15 02:04:42                conaw </span><span>Putting up another puzzle, this one relating to filters or conditionals

</span><pre>Given a vector of maps
If the values of a key in the map is

a)    A map that has a key of tempid

return just the tempid

if the value of a key is a set, list, or vector  that contains maps with key of tempid
then replace each of those maps with their temp id

example 

[{:a &quot;foo&quot;,
  :b &quot;bar&quot;,
  :c
  [{:this &quot;other thing&quot;,
    :that
    {:nested :map, :deeper #{{:in :we-go, :tempid -1}}, :tempid -2},
    :tempid -3}],
  :tempid -4}
 {:this &quot;other thing&quot;,
  :that {:nested :map, :deeper #{{:in :we-go, :tempid -1}}, :tempid -2},
  :tempid -3}
 {:nested :map, :deeper #{{:in :we-go, :tempid -1}}, :tempid -2}
 {:in :we-go, :tempid -1}]


would become
[{:a “foo” :b “bar” :c [-3] :tempid -4}
  {:this “other thing” :that -2 :tempid -3} 
  {:nested :map :deeper #{-1} :tempid -2}
  {:in :we-go :tempid -1}]
</pre></div><div data-t="conaw right now I have this, for the simpler case of just nested maps  (transform [ALL MAP-VALS (sp/pred :tempid) (collect-one :tempid)]
          (fn [v _] v)) "><span class="u" id="1465956631.000322">2016:06:15 02:10:31                conaw </span><span>right now I have this, for the simpler case of just nested maps </span><pre>(transform [ALL MAP-VALS (sp/pred :tempid) (collect-one :tempid)]
          (fn [v _] v)) </pre></div><div data-t="nathanmarz what would that transform to?"><span class="u" id="1465956661.000323">2016:06:15 02:11:01           nathanmarz </span><span>what would that transform to?</span></div><div data-t="conaw the transform I have works fine, but doesn’t handle the case when I have a map inside a seq"><span class="u" id="1465956872.000325">2016:06:15 02:14:32                conaw </span><span>the transform I have works fine, but doesn’t handle the case when I have a map inside a seq</span></div><div data-t="conaw basically I want to find a way to conditionally insert and ALL between MAP-VALS and (pred :tempid)"><span class="u" id="1465956946.000326">2016:06:15 02:15:46                conaw </span><span>basically I want to find a way to conditionally insert and ALL between MAP-VALS and (pred :tempid)</span></div><div data-t="nathanmarz i don&apos;t understand"><span class="u" id="1465957394.000328">2016:06:15 02:23:14           nathanmarz </span><span>i don&apos;t understand</span></div><div data-t="nathanmarz you said when a map has a :tempid to replace it with the :tempid value"><span class="u" id="1465957404.000329">2016:06:15 02:23:24           nathanmarz </span><span>you said when a map has a :tempid to replace it with the :tempid value</span></div><div data-t="nathanmarz that would make that example transform to [-4 -3 -2 -1]"><span class="u" id="1465957413.000330">2016:06:15 02:23:33           nathanmarz </span><span>that would make that example transform to [-4 -3 -2 -1]</span></div><div data-t="nathanmarz @conaw: or does that only happen after the first level of maps?"><span class="u" id="1465957524.000331">2016:06:15 02:25:24           nathanmarz </span><span>@conaw: or does that only happen after the first level of maps?</span></div><div data-t="conaw only happens after first level"><span class="u" id="1465957609.000332">2016:06:15 02:26:49                conaw </span><span>only happens after first level</span></div><div data-t="conaw yeah, that’s why its ALL MAP-VALS"><span class="u" id="1465957627.000333">2016:06:15 02:27:07                conaw </span><span>yeah, that’s why its ALL MAP-VALS</span></div><div data-t="nathanmarz ah"><span class="u" id="1465957636.000334">2016:06:15 02:27:16           nathanmarz </span><span>ah</span></div><div data-t="conaw (transform [ALL MAP-VALS]  
           #((if (and (map? %) #(:tempid %)))
             (:tempid %)
             (if (seq %)
               (keep :tempid %)
               %))
           sampmap2)"><span class="u" id="1465957637.000335">2016:06:15 02:27:17                conaw </span><span>(transform [ALL MAP-VALS]  
           #((if (and (map? %) #(:tempid %)))
             (:tempid %)
             (if (seq %)
               (keep :tempid %)
               %))
           sampmap2)</span></div><div data-t="nathanmarz got it"><span class="u" id="1465957639.000336">2016:06:15 02:27:19           nathanmarz </span><span>got it</span></div><div data-t="nathanmarz easy enough"><span class="u" id="1465957660.000337">2016:06:15 02:27:40           nathanmarz </span><span>easy enough</span></div><div data-t="nathanmarz (transform [ALL MAP-VALS ConawWalker (pred :tempid)] :tempid data)"><span class="u" id="1465957665.000338">2016:06:15 02:27:45           nathanmarz </span><code>(transform [ALL MAP-VALS ConawWalker (pred :tempid)] :tempid data)</code></div><div data-t="nathanmarz I&apos;ll let you figure out  ConawWalker"><span class="u" id="1465957675.000339">2016:06:15 02:27:55           nathanmarz </span><span>I&apos;ll let you figure out </span><code>ConawWalker</code></div><div data-t="conaw lol"><span class="u" id="1465957678.000340">2016:06:15 02:27:58                conaw </span><span>lol</span></div><div data-t="conaw love it"><span class="u" id="1465957681.000341">2016:06:15 02:28:01                conaw </span><span>love it</span></div><div data-t="conaw the question is, inside ConawWalker, am I using filterer or just a normal checking"><span class="u" id="1465957719.000342">2016:06:15 02:28:39                conaw </span><span>the question is, inside ConawWalker, am I using filterer or just a normal checking</span></div><div data-t="nathanmarz the solution I have uses  cond-path"><span class="u" id="1465957754.000343">2016:06:15 02:29:14           nathanmarz </span><span>the solution I have uses </span><code>cond-path</code></div><div data-t="nathanmarz and it&apos;s recursive obviously"><span class="u" id="1465957778.000344">2016:06:15 02:29:38           nathanmarz </span><span>and it&apos;s recursive obviously</span></div><div data-t="conaw hm, in this case I don’t actually need recursion"><span class="u" id="1465957791.000345">2016:06:15 02:29:51                conaw </span><span>hm, in this case I don’t actually need recursion</span></div><div data-t="conaw well, maybe I do"><span class="u" id="1465957803.000346">2016:06:15 02:30:03                conaw </span><span>well, maybe I do</span></div><div data-t="nathanmarz yea you do"><span class="u" id="1465957830.000347">2016:06:15 02:30:30           nathanmarz </span><span>yea you do</span></div><div data-t="conaw but I’ve already flattened the tree out so that I only want to do my replacing at one level of depth in"><span class="u" id="1465957831.000348">2016:06:15 02:30:31                conaw </span><span>but I’ve already flattened the tree out so that I only want to do my replacing at one level of depth in</span></div><div data-t="nathanmarz not in that example"><span class="u" id="1465957846.000349">2016:06:15 02:30:46           nathanmarz </span><span>not in that example</span></div><div data-t="nathanmarz :tempid all over the place"><span class="u" id="1465957865.000350">2016:06:15 02:31:05           nathanmarz </span><span>:tempid all over the place</span></div><div data-t="conaw the example came about this way  (def sampmap2
  [{:a &quot;foo&quot;
    :b &quot;bar&quot;
    :c [{:this &quot;other thing&quot;
         :that {:nested :map
                :deeper [{:in :we-go}]}}]}])

(declarepath TOPSORT3)
(providepath TOPSORT3
             (sp/cond-path
              map?
               (stay-then-continue
                [MAP-VALS TOPSORT3])
              vector?
                [ALL TOPSORT3]))


(select TOPSORT3 sampmap2)


(defn nested-&gt;ds [mapvec]
 (-&gt;&gt; mapvec
  (transform [(subselect TOPSORT3 :tempid) (sp/view count)]
           #(range (- %) 0))
  (select TOPSORT3)
  (transform [ALL MAP-VALS (sp/pred :tempid) (collect-one :tempid)]
          (fn [v _] v))))
"><span class="u" id="1465957948.000351">2016:06:15 02:32:28                conaw </span><span>the example came about this way </span><pre>(def sampmap2
  [{:a &quot;foo&quot;
    :b &quot;bar&quot;
    :c [{:this &quot;other thing&quot;
         :that {:nested :map
                :deeper [{:in :we-go}]}}]}])

(declarepath TOPSORT3)
(providepath TOPSORT3
             (sp/cond-path
              map?
               (stay-then-continue
                [MAP-VALS TOPSORT3])
              vector?
                [ALL TOPSORT3]))


(select TOPSORT3 sampmap2)


(defn nested-&gt;ds [mapvec]
 (-&gt;&gt; mapvec
  (transform [(subselect TOPSORT3 :tempid) (sp/view count)]
           #(range (- %) 0))
  (select TOPSORT3)
  (transform [ALL MAP-VALS (sp/pred :tempid) (collect-one :tempid)]
          (fn [v _] v))))
</pre></div><div data-t="conaw so, I’ve got each of my nodes already pulled out and selected using a recursive cond-path"><span class="u" id="1465958012.000352">2016:06:15 02:33:32                conaw </span><span>so, I’ve got each of my nodes already pulled out and selected using a recursive cond-path</span></div><div data-t="conaw nvm, let me think on this, I think I mostly have ConawWalker with TOP-SORT3"><span class="u" id="1465958089.000353">2016:06:15 02:34:49                conaw </span><span>nvm, let me think on this, I think I mostly have ConawWalker with TOP-SORT3</span></div><div data-t="nathanmarz yea it&apos;s close"><span class="u" id="1465958107.000354">2016:06:15 02:35:07           nathanmarz </span><span>yea it&apos;s close</span></div><div data-t="nathanmarz by the way you can write TOPSORT3 more concisely"><span class="u" id="1465958236.000355">2016:06:15 02:37:16           nathanmarz </span><span>by the way you can write TOPSORT3 more concisely</span></div><div data-t="conaw yeah?"><span class="u" id="1465958270.000356">2016:06:15 02:37:50                conaw </span><span>yeah?</span></div><div data-t="nathanmarz this should be equivalent
 (declarepath TOPSORT3)
(providepath TOPSORT3
   [(cond-path
     map? (stay-then-continue MAP-VALS)
     vector? ALL)
    TOPSORT3])
"><span class="u" id="1465958332.000357">2016:06:15 02:38:52           nathanmarz </span><span>this should be equivalent
</span><pre>(declarepath TOPSORT3)
(providepath TOPSORT3
   [(cond-path
     map? (stay-then-continue MAP-VALS)
     vector? ALL)
    TOPSORT3])
</pre></div><div data-t="conaw aha"><span class="u" id="1465958348.000359">2016:06:15 02:39:08                conaw </span><span>aha</span></div><div data-t="nathanmarz oh nvm, those are not equivalent"><span class="u" id="1465958609.000360">2016:06:15 02:43:29           nathanmarz </span><span>oh nvm, those are not equivalent</span></div><div data-t="nathanmarz that would stack overflow"><span class="u" id="1465958640.000361">2016:06:15 02:44:00           nathanmarz </span><span>that would stack overflow</span></div><div data-t="conaw Why is that?"><span class="u" id="1465958708.000362">2016:06:15 02:45:08                conaw </span><span>Why is that?</span></div><div data-t="conaw would cease to be tail recursive?"><span class="u" id="1465958724.000363">2016:06:15 02:45:24                conaw </span><span>would cease to be tail recursive?</span></div><div data-t="nathanmarz when it&apos;s on a map, it will first stay"><span class="u" id="1465958766.000364">2016:06:15 02:46:06           nathanmarz </span><span>when it&apos;s on a map, it will first stay</span></div><div data-t="nathanmarz then execute TOPSORT3 again"><span class="u" id="1465958770.000365">2016:06:15 02:46:10           nathanmarz </span><span>then execute TOPSORT3 again</span></div><div data-t="nathanmarz then stay, then TOPSORT3, etc."><span class="u" id="1465958780.000366">2016:06:15 02:46:20           nathanmarz </span><span>then stay, then TOPSORT3, etc.</span></div><div data-t="nathanmarz with yours it stays, does whatever is after TOPSORT3, then continues recursing on the map vals"><span class="u" id="1465958806.000367">2016:06:15 02:46:46           nathanmarz </span><span>with yours it stays, does whatever is after TOPSORT3, then continues recursing on the map vals</span></div><div data-t="nathanmarz anyway, i gotta run"><span class="u" id="1465958869.000368">2016:06:15 02:47:49           nathanmarz </span><span>anyway, i gotta run</span></div><div data-t="conaw cool, thanks for help"><span class="u" id="1465958882.000369">2016:06:15 02:48:02                conaw </span><span>cool, thanks for help</span></div><div data-t="conaw last q"><span class="u" id="1465958892.000370">2016:06:15 02:48:12                conaw </span><span>last q</span></div><div data-t="conaw #(:a %)"><span class="u" id="1465958902.000371">2016:06:15 02:48:22                conaw </span><span>#(:a %)</span></div><div data-t="nathanmarz here&apos;s a gist with the solution if you can&apos;t figure it out  https://gist.github.com/nathanmarz/16481b3b4578ed446453bd828335eedb"><span class="u" id="1465958904.000372">2016:06:15 02:48:24           nathanmarz </span><span>here&apos;s a gist with the solution if you can&apos;t figure it out </span><a href="https://gist.github.com/nathanmarz/16481b3b4578ed446453bd828335eedb">https://gist.github.com/nathanmarz/16481b3b4578ed446453bd828335eedb</a></div><div data-t="conaw best way to only navigate to maps with key of a without traversing into a?"><span class="u" id="1465958924.000373">2016:06:15 02:48:44                conaw </span><span>best way to only navigate to maps with key of a without traversing into a?</span></div><div data-t="conaw is that"><span class="u" id="1465958930.000374">2016:06:15 02:48:50                conaw </span><span>is that</span></div><div data-t="conaw right?"><span class="u" id="1465958932.000375">2016:06:15 02:48:52                conaw </span><span>right?</span></div><div data-t="conaw and best way of doing all except would be #(not (:a %))"><span class="u" id="1465958961.000376">2016:06:15 02:49:21                conaw </span><span>and best way of doing all except would be #(not (:a %))</span></div><div data-t="nathanmarz that&apos;s the same as saying (pred :a)"><span class="u" id="1465958964.000377">2016:06:15 02:49:24           nathanmarz </span><span>that&apos;s the same as saying (pred :a)</span></div><div data-t="nathanmarz but that doesn&apos;t account for key existing with nil or false value"><span class="u" id="1465958979.000378">2016:06:15 02:49:39           nathanmarz </span><span>but that doesn&apos;t account for key existing with nil or false value</span></div><div data-t="conaw pred does?"><span class="u" id="1465958994.000379">2016:06:15 02:49:54                conaw </span><span>pred does?</span></div><div data-t="nathanmarz if you want to truly do it based on key existing, use  (selected? (must :a))  or  (not-selected? (must :a))"><span class="u" id="1465959006.000380">2016:06:15 02:50:06           nathanmarz </span><span>if you want to truly do it based on key existing, use </span><code>(selected? (must :a))</code><span> or </span><code>(not-selected? (must :a))</code></div><div data-t="conaw great"><span class="u" id="1465959019.000381">2016:06:15 02:50:19                conaw </span><span>great</span></div><div data-t="conaw much appreciated"><span class="u" id="1465959023.000382">2016:06:15 02:50:23                conaw </span><span>much appreciated</span></div><div data-t="nathanmarz #(:a %)  is equivalent to  (pred :a)"><span class="u" id="1465959032.000383">2016:06:15 02:50:32           nathanmarz </span><code>#(:a %)</code><span> is equivalent to </span><code>(pred :a)</code></div><div data-t="conaw cool"><span class="u" id="1465959039.000384">2016:06:15 02:50:39                conaw </span><span>cool</span></div><div data-t="codonnell @nathanmarz: Made a few updates to  https://github.com/codonnell/specter/wiki/List-of-Macros  after rereading your post and looking through  magic-precompilation  and  magic-precompilation* . I&apos;m just missing examples for  path , and I&apos;m not clear yet on the difference between  comp-paths  and  path . Can  path  not return a  ParamsNeededPath ?"><span class="u" id="1465999015.000391">2016:06:15 13:56:55            codonnell </span><span>@nathanmarz: Made a few updates to </span><a href="https://github.com/codonnell/specter/wiki/List-of-Macros">https://github.com/codonnell/specter/wiki/List-of-Macros</a><span> after rereading your post and looking through </span><code>magic-precompilation</code><span> and </span><code>magic-precompilation*</code><span>. I&apos;m just missing examples for </span><code>path</code><span>, and I&apos;m not clear yet on the difference between </span><code>comp-paths</code><span> and </span><code>path</code><span>. Can </span><code>path</code><span> not return a </span><code>ParamsNeededPath</code><span>?</span></div><div data-t="codonnell On a side note, there&apos;s a typo at  https://github.com/nathanmarz/specter/blob/0.11.2/src/clj/com/rpl/specter/impl.cljx#L1150  (s/consructor/constructor)"><span class="u" id="1465999053.000393">2016:06:15 13:57:33            codonnell </span><span>On a side note, there&apos;s a typo at </span><a href="https://github.com/nathanmarz/specter/blob/0.11.2/src/clj/com/rpl/specter/impl.cljx#L1150">https://github.com/nathanmarz/specter/blob/0.11.2/src/clj/com/rpl/specter/impl.cljx#L1150</a><span> (s/consructor/constructor)</span></div><div data-t="nathanmarz @codonnell:  path  is basically  comp-paths  plus inline factoring and caching"><span class="u" id="1466001342.000395">2016:06:15 14:35:42           nathanmarz </span><span>@codonnell: </span><code>path</code><span> is basically </span><code>comp-paths</code><span> plus inline factoring and caching</span></div><div data-t="nathanmarz You could use  path  on its own like this:
 (defn user-path [u]
  (path ALL (selected? :id #(= u %))))
"><span class="u" id="1466001487.000396">2016:06:15 14:38:07           nathanmarz </span><span>You could use </span><code>path</code><span> on its own like this:
</span><pre>(defn user-path [u]
  (path ALL (selected? :id #(= u %))))
</pre></div><div data-t="nathanmarz user-path  will use inline caching + factoring and efficiently return a path to that particular user"><span class="u" id="1466001527.000397">2016:06:15 14:38:47           nathanmarz </span><code>user-path</code><span> will use inline caching + factoring and efficiently return a path to that particular user</span></div><div data-t="nathanmarz select ,  transform , etc. all use  path"><span class="u" id="1466001558.000398">2016:06:15 14:39:18           nathanmarz </span><code>select</code><span>, </span><code>transform</code><span>, etc. all use </span><code>path</code></div><div data-t="nathanmarz @codonnell: merged the new wiki page in"><span class="u" id="1466002400.000402">2016:06:15 14:53:20           nathanmarz </span><span>@codonnell: merged the new wiki page in</span></div><div data-t="nathanmarz fyi, there will be a new core operation in 0.12.0 called  traverse"><span class="u" id="1466002489.000403">2016:06:15 14:54:49           nathanmarz </span><span>fyi, there will be a new core operation in 0.12.0 called </span><code>traverse</code></div><div data-t="aengelberg @nathanmarz re: transducers. I agree that the mapcat behavior is the most useful but the name  traverse  doesn&apos;t seem to imply that behavior."><span class="u" id="1466007438.000404">2016:06:15 16:17:18           aengelberg </span><span>@nathanmarz re: transducers. I agree that the mapcat behavior is the most useful but the name </span><code>traverse</code><span> doesn&apos;t seem to imply that behavior.</span></div><div data-t="aengelberg What&apos;s really happening is you are traversing some path on ALL structures coming on some stream (or collection, etc) then getting all those results. Maybe  traverse-all  is a more appropriate name?"><span class="u" id="1466007528.000405">2016:06:15 16:18:48           aengelberg </span><span>What&apos;s really happening is you are traversing some path on ALL structures coming on some stream (or collection, etc) then getting all those results. Maybe </span><code>traverse-all</code><span> is a more appropriate name?</span></div><div data-t="nathanmarz @aengelberg: yea, that&apos;s a better name"><span class="u" id="1466008756.000406">2016:06:15 16:39:16           nathanmarz </span><span>@aengelberg: yea, that&apos;s a better name</span></div><div data-t="aengelberg or go for the pun and call it  transverse"><span class="u" id="1466008821.000407">2016:06:15 16:40:21           aengelberg </span><span>or go for the pun and call it </span><code>transverse</code></div><div data-t="aengelberg 👏   🎉  i&apos;m here all week"><span class="u" id="1466008845.000408">2016:06:15 16:40:45           aengelberg </span><b>👏</b><span> </span><b>🎉</b><span> i&apos;m here all week</span></div><div data-t="nathanmarz lol"><span class="u" id="1466008871.000409">2016:06:15 16:41:11           nathanmarz </span><span>lol</span></div><div data-t="codonnell @nathanmarz: after creating your  user-path  function above, I get an error while trying to use it:
 (select (user-path &quot;chris&quot;) [{:id &quot;nick&quot;} {:id &quot;foo&quot;} {:id &quot;chris&quot;}])
Failed to cache path: Var user-path must be either a parameterized navigator, a higher order pathed constructor function, or a nav consructor
"><span class="u" id="1466012833.000410">2016:06:15 17:47:13            codonnell </span><span>@nathanmarz: after creating your </span><code>user-path</code><span> function above, I get an error while trying to use it:
</span><pre>(select (user-path &quot;chris&quot;) [{:id &quot;nick&quot;} {:id &quot;foo&quot;} {:id &quot;chris&quot;}])
Failed to cache path: Var user-path must be either a parameterized navigator, a higher order pathed constructor function, or a nav consructor
</pre></div><div data-t="nathanmarz @codonnell: use  compiled-select"><span class="u" id="1466012875.000411">2016:06:15 17:47:55           nathanmarz </span><span>@codonnell: use </span><code>compiled-select</code></div><div data-t="codonnell alright, that works"><span class="u" id="1466012934.000412">2016:06:15 17:48:54            codonnell </span><span>alright, that works</span></div><div data-t="nathanmarz yea, I only gave that as an example of using  path  on its own"><span class="u" id="1466012968.000413">2016:06:15 17:49:28           nathanmarz </span><span>yea, I only gave that as an example of using </span><code>path</code><span> on its own</span></div><div data-t="nathanmarz but in general, to make a parameterized navigator it&apos;s much better to use comp-paths"><span class="u" id="1466012996.000414">2016:06:15 17:49:56           nathanmarz </span><span>but in general, to make a parameterized navigator it&apos;s much better to use comp-paths</span></div><div data-t="codonnell and I should use  compiled-select  with a path I have already compiled with  comp-paths ?"><span class="u" id="1466013053.000415">2016:06:15 17:50:53            codonnell </span><span>and I should use </span><code>compiled-select</code><span> with a path I have already compiled with </span><code>comp-paths</code><span>?</span></div><div data-t="nathanmarz if you know it&apos;s already compiled then that will be the most efficient"><span class="u" id="1466013154.000416">2016:06:15 17:52:34           nathanmarz </span><span>if you know it&apos;s already compiled then that will be the most efficient</span></div><div data-t="codonnell Also, if I&apos;m understanding  path  correctly, it doesn&apos;t take late binding parameters because it needs to cache the code which creates the parameters at compile time. Is that right?"><span class="u" id="1466013188.000417">2016:06:15 17:53:08            codonnell </span><span>Also, if I&apos;m understanding </span><code>path</code><span> correctly, it doesn&apos;t take late binding parameters because it needs to cache the code which creates the parameters at compile time. Is that right?</span></div><div data-t="nathanmarz select* is like compiled-select except it will compile the input path if it&apos;s not already compiled"><span class="u" id="1466013190.000418">2016:06:15 17:53:10           nathanmarz </span><span>select* is like compiled-select except it will compile the input path if it&apos;s not already compiled</span></div><div data-t="nathanmarz yea  path  is meant for a fully parameterized path"><span class="u" id="1466013219.000419">2016:06:15 17:53:39           nathanmarz </span><span>yea </span><code>path</code><span> is meant for a fully parameterized path</span></div><div data-t="codonnell So is there any reason to use  select  over  select* ?"><span class="u" id="1466013269.000420">2016:06:15 17:54:29            codonnell </span><span>So is there any reason to use </span><code>select</code><span> over </span><code>select*</code><span>?</span></div><div data-t="nathanmarz select* doesn&apos;t do inline caching"><span class="u" id="1466013317.000421">2016:06:15 17:55:17           nathanmarz </span><span>select* doesn&apos;t do inline caching</span></div><div data-t="codonnell Right, because it&apos;s a function rather than a macro."><span class="u" id="1466013341.000422">2016:06:15 17:55:41            codonnell </span><span>Right, because it&apos;s a function rather than a macro.</span></div><div data-t="nathanmarz 99.9% of usage should be through the core  select ,  transform , etc. operations"><span class="u" id="1466013356.000423">2016:06:15 17:55:56           nathanmarz </span><span>99.9% of usage should be through the core </span><code>select</code><span>, </span><code>transform</code><span>, etc. operations</span></div><div data-t="codonnell Alright, thanks for answering my questions.  👍"><span class="u" id="1466013419.000424">2016:06:15 17:56:59            codonnell </span><span>Alright, thanks for answering my questions. </span><b>👍</b></div><div data-t="nathanmarz in my own usage I use select/transform/replace-in over 400 times, comp-paths 15 times, and compiled-select/compiled-transform only twice"><span class="u" id="1466013448.000425">2016:06:15 17:57:28           nathanmarz </span><span>in my own usage I use select/transform/replace-in over 400 times, comp-paths 15 times, and compiled-select/compiled-transform only twice</span></div><div data-t="codonnell @nathanmarz: I added some examples and a longer description for the  path  macro, as well as some minor formatting changes and a fix for broken links in the list of navigators. Can you think of a situation where it would be prefer able to use  path  over  comp-paths ?"><span class="u" id="1466016909.000427">2016:06:15 18:55:09            codonnell </span><span>@nathanmarz: I added some examples and a longer description for the </span><code>path</code><span> macro, as well as some minor formatting changes and a fix for broken links in the list of navigators. Can you think of a situation where it would be prefer able to use </span><code>path</code><span> over </span><code>comp-paths</code><span>?</span></div><div data-t="thomasdeutsch Hi everyone. I am stuck with a specter problem i can not get a solution for.     I have a simple tree structure as a map and the leaves can be at any level (they are a map with a :template key).  

 I can use a walker to simply find the leaves, but for every leaf, i need the path to that leaf.   Is there something like collect-one i can use for this?   

 (def mytree {&quot;e1&quot; {&quot;e2&quot; {&quot;e1&quot; {:template 1}
                        &quot;e2&quot; {:template 2}}}})

(select [(walker #(contains? % :template))] mytree)"><span class="u" id="1466017478.000431">2016:06:15 19:04:38        thomasdeutsch </span><span>Hi everyone. I am stuck with a specter problem i can not get a solution for.     I have a simple tree structure as a map and the leaves can be at any level (they are a map with a :template key).  

 I can use a walker to simply find the leaves, but for every leaf, i need the path to that leaf.   Is there something like collect-one i can use for this?   

</span><pre>(def mytree {&quot;e1&quot; {&quot;e2&quot; {&quot;e1&quot; {:template 1}
                        &quot;e2&quot; {:template 2}}}})

(select [(walker #(contains? % :template))] mytree)</pre></div><div data-t="codonnell @thomasdeutsch: what would you like to be returned for that data structure?"><span class="u" id="1466017761.000432">2016:06:15 19:09:21            codonnell </span><span>@thomasdeutsch: what would you like to be returned for that data structure?</span></div><div data-t="thomasdeutsch i would like to return a vector of maps. The maps have templates + a path to that template.  Like     [{:template 1 :path [&quot;e1 &quot;e2&quot; &quot;e1]} {:template 2 :path [&quot;e1&quot; &quot;e2&quot; &quot;e2]}]"><span class="u" id="1466017859.000433">2016:06:15 19:10:59        thomasdeutsch </span><span>i would like to return a vector of maps. The maps have templates + a path to that template.  Like    </span><code>[{:template 1 :path [&quot;e1 &quot;e2&quot; &quot;e1]} {:template 2 :path [&quot;e1&quot; &quot;e2&quot; &quot;e2]}]</code></div><div data-t="thomasdeutsch i think i need a transform with a filterer and a second one that will transform a path into the structure?"><span class="u" id="1466017907.000434">2016:06:15 19:11:47        thomasdeutsch </span><span>i think i need a transform with a filterer and a second one that will transform a path into the structure?</span></div><div data-t="codonnell I think you want a recursive navigator that collects the keys as you go."><span class="u" id="1466018135.000437">2016:06:15 19:15:35            codonnell </span><span>I think you want a recursive navigator that collects the keys as you go.</span></div><div data-t="codonnell @thomasdeutsch: This is close:
 (declarepath KeyAccumWalker [k])
(providepath KeyAccumWalker (if-path must STAY [ALL (collect-one FIRST) LAST (params-reset KeyAccumWalker)]))
(select (KeyAccumWalker :template) mytree)
"><span class="u" id="1466019037.000438">2016:06:15 19:30:37            codonnell </span><span>@thomasdeutsch: This is close:
</span><pre>(declarepath KeyAccumWalker [k])
(providepath KeyAccumWalker (if-path must STAY [ALL (collect-one FIRST) LAST (params-reset KeyAccumWalker)]))
(select (KeyAccumWalker :template) mytree)
</pre></div><div data-t="thomasdeutsch i have to say, i do not understand if-path must STAY ...   but this is a great place to start from...."><span class="u" id="1466019194.000439">2016:06:15 19:33:14        thomasdeutsch </span><span>i have to say, i do not understand if-path must STAY ...   but this is a great place to start from....</span></div><div data-t="thomasdeutsch Thank you"><span class="u" id="1466019205.000440">2016:06:15 19:33:25        thomasdeutsch </span><span>Thank you</span></div><div data-t="codonnell @thomasdeutsch:  must  has an implicit late-bound parameter, which is the key :template"><span class="u" id="1466019226.000441">2016:06:15 19:33:46            codonnell </span><span>@thomasdeutsch: </span><code>must</code><span> has an implicit late-bound parameter, which is the key :template</span></div><div data-t="mfikes @nathanmarz: Do you develop on Linux? (If so, wanted to let you know that we now have an alpha of Planck that runs on Linux. It can successfully load Specter from its JAR and evaluate things. Figure that might help if you ever want to check some behavior related to bootstrap ClojureScript.)"><span class="u" id="1466019234.000442">2016:06:15 19:33:54               mfikes </span><span>@nathanmarz: Do you develop on Linux? (If so, wanted to let you know that we now have an alpha of Planck that runs on Linux. It can successfully load Specter from its JAR and evaluate things. Figure that might help if you ever want to check some behavior related to bootstrap ClojureScript.)</span></div><div data-t="codonnell so what&apos;s really going on there is more like  (if-path (must :template) STAY ...)"><span class="u" id="1466019249.000443">2016:06:15 19:34:09            codonnell </span><span>so what&apos;s really going on there is more like </span><code>(if-path (must :template) STAY ...)</code></div><div data-t="thomasdeutsch aaahhhh, ok! got it."><span class="u" id="1466019271.000444">2016:06:15 19:34:31        thomasdeutsch </span><span>aaahhhh, ok! got it.</span></div><div data-t="codonnell The problem is that as we recursively call  KeyAccumWalker  the collected values are getting nested instead of concatenated."><span class="u" id="1466019311.000445">2016:06:15 19:35:11            codonnell </span><span>The problem is that as we recursively call </span><code>KeyAccumWalker</code><span> the collected values are getting nested instead of concatenated.</span></div><div data-t="nathanmarz @codonnell @thomasdeutsch value collection + recursion doesn&apos;t work so well in specter at the moment"><span class="u" id="1466020123.000446">2016:06:15 19:48:43           nathanmarz </span><span>@codonnell @thomasdeutsch value collection + recursion doesn&apos;t work so well in specter at the moment</span></div><div data-t="nathanmarz also  https://github.com/nathanmarz/specter/issues/64"><span class="u" id="1466020139.000447">2016:06:15 19:48:59           nathanmarz </span><span>also </span><a href="https://github.com/nathanmarz/specter/issues/64">https://github.com/nathanmarz/specter/issues/64</a></div><div data-t="thomasdeutsch thanks for the heads up"><span class="u" id="1466020159.000449">2016:06:15 19:49:19        thomasdeutsch </span><span>thanks for the heads up</span></div><div data-t="nathanmarz @mfikes: I develop on OSX, does it work there as well?"><span class="u" id="1466020430.000450">2016:06:15 19:53:50           nathanmarz </span><span>@mfikes: I develop on OSX, does it work there as well?</span></div><div data-t="mfikes Oh… definitely. Planck has worked on OS X all along :)  brew install planck  and you are good to go"><span class="u" id="1466020456.000451">2016:06:15 19:54:16               mfikes </span><span>Oh… definitely. Planck has worked on OS X all along :) </span><code>brew install planck</code><span> and you are good to go</span></div><div data-t="mfikes @nathanmarz: If you ever want to point Planck at your JAR, here’s how:
 $ planck -qKc target/specter-0.12.0-SNAPSHOT.jar
cljs.user=&gt; (require-macros &apos;[com.rpl.specter.macros :refer [transform]])
nil
cljs.user=&gt; (require &apos;[com.rpl.specter :refer [ALL]])
nil
cljs.user=&gt; (transform [ALL :a even?] inc [{:a 1} {:a 2} {:a 4} {:a 3}])
[{:a 1} {:a 3} {:a 5} {:a 3}]
 
That’s all there is to it.
(Note that  -K  will cause a  .planck_cache  directory to be written for faster subsequent startups. You can also use  -k  to write to a specific path, or just leave it off and live with slower  require  processing.)"><span class="u" id="1466020735.000452">2016:06:15 19:58:55               mfikes </span><span>@nathanmarz: If you ever want to point Planck at your JAR, here’s how:
</span><pre>$ planck -qKc target/specter-0.12.0-SNAPSHOT.jar
cljs.user=&gt; (require-macros &apos;[com.rpl.specter.macros :refer [transform]])
nil
cljs.user=&gt; (require &apos;[com.rpl.specter :refer [ALL]])
nil
cljs.user=&gt; (transform [ALL :a even?] inc [{:a 1} {:a 2} {:a 4} {:a 3}])
[{:a 1} {:a 3} {:a 5} {:a 3}]
</pre><span>
That’s all there is to it.
(Note that </span><code>-K</code><span> will cause a </span><code>.planck_cache</code><span> directory to be written for faster subsequent startups. You can also use </span><code>-k</code><span> to write to a specific path, or just leave it off and live with slower </span><code>require</code><span> processing.)</span></div><div data-t="nathanmarz ok cool, I&apos;ll note this down"><span class="u" id="1466020761.000453">2016:06:15 19:59:21           nathanmarz </span><span>ok cool, I&apos;ll note this down</span></div><div data-t="mfikes Cool. Of course, happy to continue to sort out bootstrap issues if they arise. Just thought you might want to be able to try things yourself if you ever wanted to.  🙂"><span class="u" id="1466020815.000454">2016:06:15 20:00:15               mfikes </span><span>Cool. Of course, happy to continue to sort out bootstrap issues if they arise. Just thought you might want to be able to try things yourself if you ever wanted to. </span><b>🙂</b></div><div data-t="nathanmarz any leiningen plugin available to be able to do something like &quot;lein planck&quot;?"><span class="u" id="1466020834.000455">2016:06:15 20:00:34           nathanmarz </span><span>any leiningen plugin available to be able to do something like &quot;lein planck&quot;?</span></div><div data-t="nathanmarz and get a planck repl with the project code + dependencies available"><span class="u" id="1466020855.000456">2016:06:15 20:00:55           nathanmarz </span><span>and get a planck repl with the project code + dependencies available</span></div><div data-t="mfikes Well, you can essentially do the opposite: 
 planck -c `lein classpath`
"><span class="u" id="1466020887.000457">2016:06:15 20:01:27               mfikes </span><span>Well, you can essentially do the opposite: 
</span><pre>planck -c `lein classpath`
</pre></div><div data-t="nathanmarz ah nice, just as good"><span class="u" id="1466020905.000458">2016:06:15 20:01:45           nathanmarz </span><span>ah nice, just as good</span></div><div data-t="mfikes There’s also fairly decent docs covering this stuff (that’s covered in the Dependencies section).  http://planck-repl.org/guide.html"><span class="u" id="1466020948.000459">2016:06:15 20:02:28               mfikes </span><span>There’s also fairly decent docs covering this stuff (that’s covered in the Dependencies section). </span><a href="http://planck-repl.org/guide.html">http://planck-repl.org/guide.html</a></div><div data-t="nathanmarz @codonnell @thomasdeutsch that bug you guys ran into yesterday is now fixed in master"><span class="u" id="1466085631.000472">2016:06:16 14:00:31           nathanmarz </span><span>@codonnell @thomasdeutsch that bug you guys ran into yesterday is now fixed in master</span></div><div data-t="nathanmarz also deployed 0.12.0-SNAPSHOT to clojars if you want to use it"><span class="u" id="1466085700.000473">2016:06:16 14:01:40           nathanmarz </span><span>also deployed 0.12.0-SNAPSHOT to clojars if you want to use it</span></div><div data-t="aengelberg @nathanmarz I&apos;m curious why  select*  really needs each navigator to return one of its navigated values as the return value. If you really want  select-any , you could traverse with the final continuation being to deliver to a promise (where only the first value matters)."><span class="u" id="1466087207.000474">2016:06:16 14:26:47           aengelberg </span><span>@nathanmarz I&apos;m curious why </span><code>select*</code><span> really needs each navigator to return one of its navigated values as the return value. If you really want </span><code>select-any</code><span>, you could traverse with the final continuation being to deliver to a promise (where only the first value matters).</span></div><div data-t="nathanmarz it&apos;s the most efficient way"><span class="u" id="1466087723.000475">2016:06:16 14:35:23           nathanmarz </span><span>it&apos;s the most efficient way</span></div><div data-t="nathanmarz don&apos;t need to create any anonymous function, don&apos;t need to write anywhere"><span class="u" id="1466087743.000476">2016:06:16 14:35:43           nathanmarz </span><span>don&apos;t need to create any anonymous function, don&apos;t need to write anywhere</span></div><div data-t="nathanmarz an anonymous function that closes over local environment requires object creation and field setting"><span class="u" id="1466087799.000477">2016:06:16 14:36:39           nathanmarz </span><span>an anonymous function that closes over local environment requires object creation and field setting</span></div><div data-t="nathanmarz for cases like  (select-any [:a :b :c] {:a {:b {:c 1}}})  these things make a noticeable difference"><span class="u" id="1466087829.000478">2016:06:16 14:37:09           nathanmarz </span><span>for cases like </span><code>(select-any [:a :b :c] {:a {:b {:c 1}}})</code><span> these things make a noticeable difference</span></div><div data-t="codonnell @nathanmarz:  (reduce afn init (traverse apath structure))  should always return the same thing as  (reduce afn init (select apath structure)) , right? But it is more memory efficient because it only store the reduction value, rather than instantiating the entire seq?"><span class="u" id="1466106634.000482">2016:06:16 19:50:34            codonnell </span><span>@nathanmarz: </span><code>(reduce afn init (traverse apath structure))</code><span> should always return the same thing as </span><code>(reduce afn init (select apath structure))</code><span>, right? But it is more memory efficient because it only store the reduction value, rather than instantiating the entire seq?</span></div><div data-t="nathanmarz @codonnell: that&apos;s exactly right"><span class="u" id="1466106829.000483">2016:06:16 19:53:49           nathanmarz </span><span>@codonnell: that&apos;s exactly right</span></div><div data-t="nathanmarz not just memory efficient but also faster"><span class="u" id="1466106889.000485">2016:06:16 19:54:49           nathanmarz </span><span>not just memory efficient but also faster</span></div><div data-t="nathanmarz also useful if you want something like a set of results back, e.g.  (into #{} (traverse ...))"><span class="u" id="1466107001.000486">2016:06:16 19:56:41           nathanmarz </span><span>also useful if you want something like a set of results back, e.g. </span><code>(into #{} (traverse ...))</code></div><div data-t="codonnell ok great"><span class="u" id="1466107084.000487">2016:06:16 19:58:04            codonnell </span><span>ok great</span></div><div data-t="codonnell Is  collected?  the same as  pred , but it takes the collected values as input rather than the structure?"><span class="u" id="1466107832.000488">2016:06:16 20:10:32            codonnell </span><span>Is </span><code>collected?</code><span> the same as </span><code>pred</code><span>, but it takes the collected values as input rather than the structure?</span></div><div data-t="nathanmarz yes"><span class="u" id="1466107934.000489">2016:06:16 20:12:14           nathanmarz </span><span>yes</span></div><div data-t="codonnell alright, these new operations should be pretty easy to write up"><span class="u" id="1466107975.000490">2016:06:16 20:12:55            codonnell </span><span>alright, these new operations should be pretty easy to write up</span></div><div data-t="codonnell I pushed the 0.12.0 macros and navigators up to  https://github.com/codonnell/specter/wiki/List-of-Macros . Pretty sure they are accurate."><span class="u" id="1466112666.000494">2016:06:16 21:31:06            codonnell </span><span>I pushed the 0.12.0 macros and navigators up to </span><a href="https://github.com/codonnell/specter/wiki/List-of-Macros">https://github.com/codonnell/specter/wiki/List-of-Macros</a><span>. Pretty sure they are accurate.</span></div><div data-t="codonnell perhaps jumping the gun, but it&apos;s there on my wiki if needed"><span class="u" id="1466112957.000496">2016:06:16 21:35:57            codonnell </span><span>perhaps jumping the gun, but it&apos;s there on my wiki if needed</span></div><div data-t="nathanmarz great"><span class="u" id="1466113517.000497">2016:06:16 21:45:17           nathanmarz </span><span>great</span></div><div data-t="nathanmarz added another traverse example and merged in"><span class="u" id="1466113522.000498">2016:06:16 21:45:22           nathanmarz </span><span>added another traverse example and merged in</span></div><div data-t="luxbock how would I implement  REST ? i.e.  (select-one REST [1 2 3])  =&gt;  [2 3] ?"><span class="u" id="1466120035.000499">2016:06:16 23:33:55              luxbock </span><span>how would I implement </span><code>REST</code><span>? i.e. </span><code>(select-one REST [1 2 3])</code><span> =&gt; </span><code>[2 3]</code><span>?</span></div><div data-t="luxbock I can use  srange  but then I need to know the length of the collection in the selector"><span class="u" id="1466120482.000501">2016:06:16 23:41:22              luxbock </span><span>I can use </span><code>srange</code><span> but then I need to know the length of the collection in the selector</span></div><div data-t="luxbock I was trying to figure out how to do it by looking at  ALL  and  FIRST  but the code looks so optimized that I can&apos;t really figure out how to write it"><span class="u" id="1466120516.000502">2016:06:16 23:41:56              luxbock </span><span>I was trying to figure out how to do it by looking at </span><code>ALL</code><span> and </span><code>FIRST</code><span> but the code looks so optimized that I can&apos;t really figure out how to write it</span></div><div data-t="codonnell @luxbock: you should be able to do it with  defnav  (see  https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav  for a similar example)"><span class="u" id="1466120660.000503">2016:06:16 23:44:20            codonnell </span><span>@luxbock: you should be able to do it with </span><code>defnav</code><span> (see </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav">https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav</a><span> for a similar example)</span></div><div data-t="codonnell I&apos;m not sure if there&apos;s a better way to do it"><span class="u" id="1466120680.000505">2016:06:16 23:44:40            codonnell </span><span>I&apos;m not sure if there&apos;s a better way to do it</span></div><div data-t="luxbock @codonnell: thanks"><span class="u" id="1466120749.000506">2016:06:16 23:45:49              luxbock </span><span>@codonnell: thanks</span></div><div data-t="codonnell no problem"><span class="u" id="1466120788.000507">2016:06:16 23:46:28            codonnell </span><span>no problem</span></div><div data-t="codonnell ooh"><span class="u" id="1466121010.000508">2016:06:16 23:50:10            codonnell </span><span>ooh</span></div><div data-t="codonnell @luxbock: (select (transformed STAY rest) (range 10))"><span class="u" id="1466121068.000509">2016:06:16 23:51:08            codonnell </span><span>@luxbock: (select (transformed STAY rest) (range 10))</span></div><div data-t="codonnell no,  (select (view rest) (range 10))"><span class="u" id="1466121085.000510">2016:06:16 23:51:25            codonnell </span><span>no, </span><code>(select (view rest) (range 10))</code></div><div data-t="codonnell pretty sure  (view rest)  is optimal"><span class="u" id="1466121100.000511">2016:06:16 23:51:40            codonnell </span><span>pretty sure </span><code>(view rest)</code><span> is optimal</span></div><div data-t="codonnell Note that if you&apos;re doing a transform, you&apos;ll lose the first element
 (transform [(view rest) ALL] inc (range 5))
(2 3 4 5)
"><span class="u" id="1466121608.000512">2016:06:17 00:00:08            codonnell </span><span>Note that if you&apos;re doing a transform, you&apos;ll lose the first element
</span><pre>(transform [(view rest) ALL] inc (range 5))
(2 3 4 5)
</pre></div><div data-t="luxbock yeah I need the first element to stay intact"><span class="u" id="1466121754.000513">2016:06:17 00:02:34              luxbock </span><span>yeah I need the first element to stay intact</span></div><div data-t="luxbock https://gist.github.com/luxbock/55ea567166081af107fd7a22582bf8c2"><span class="u" id="1466121757.000514">2016:06:17 00:02:37              luxbock </span><a href="https://gist.github.com/luxbock/55ea567166081af107fd7a22582bf8c2">https://gist.github.com/luxbock/55ea567166081af107fd7a22582bf8c2</a></div><div data-t="luxbock that was my first try but it doesn&apos;t quite work"><span class="u" id="1466121763.000515">2016:06:17 00:02:43              luxbock </span><span>that was my first try but it doesn&apos;t quite work</span></div><div data-t="codonnell you don&apos;t need to call  nextfn  twice in your select"><span class="u" id="1466121855.000516">2016:06:17 00:04:15            codonnell </span><span>you don&apos;t need to call </span><code>nextfn</code><span> twice in your select</span></div><div data-t="luxbock ah whops"><span class="u" id="1466121871.000517">2016:06:17 00:04:31              luxbock </span><span>ah whops</span></div><div data-t="codonnell you do need it in your transform*, though"><span class="u" id="1466121882.000518">2016:06:17 00:04:42            codonnell </span><span>you do need it in your transform*, though</span></div><div data-t="luxbock hmm?"><span class="u" id="1466121919.000519">2016:06:17 00:05:19              luxbock </span><span>hmm?</span></div><div data-t="codonnell transform* also needs to perform  nextfn  on the passed in structure, and then reconstruct the original structure, replacing what you navigate to with the results of  nextfn"><span class="u" id="1466121953.000520">2016:06:17 00:05:53            codonnell </span><span>transform* also needs to perform </span><code>nextfn</code><span> on the passed in structure, and then reconstruct the original structure, replacing what you navigate to with the results of </span><code>nextfn</code></div><div data-t="codonnell for example, the wiki example stores the result of  (nextfn (nth structure n))  and then replaces the nth element of  structure  with it"><span class="u" id="1466122000.000521">2016:06:17 00:06:40            codonnell </span><span>for example, the wiki example stores the result of </span><code>(nextfn (nth structure n))</code><span> and then replaces the nth element of </span><code>structure</code><span> with it</span></div><div data-t="luxbock isn&apos;t that what I was doing though?"><span class="u" id="1466122064.000522">2016:06:17 00:07:44              luxbock </span><span>isn&apos;t that what I was doing though?</span></div><div data-t="codonnell oops"><span class="u" id="1466122118.000523">2016:06:17 00:08:38            codonnell </span><span>oops</span></div><div data-t="codonnell yep, you&apos;re right"><span class="u" id="1466122122.000524">2016:06:17 00:08:42            codonnell </span><span>yep, you&apos;re right</span></div><div data-t="luxbock ah, I needed to map  next-fn  over the  (rest coll)"><span class="u" id="1466122138.000525">2016:06:17 00:08:58              luxbock </span><span>ah, I needed to map </span><code>next-fn</code><span> over the </span><code>(rest coll)</code></div><div data-t="luxbock great, now it works"><span class="u" id="1466122157.000526">2016:06:17 00:09:17              luxbock </span><span>great, now it works</span></div><div data-t="codonnell no, that&apos;s not right"><span class="u" id="1466122229.000527">2016:06:17 00:10:29            codonnell </span><span>no, that&apos;s not right</span></div><div data-t="codonnell I mean, you could do that if you want, but that&apos;s like doing  [REST ALL]"><span class="u" id="1466122244.000528">2016:06:17 00:10:44            codonnell </span><span>I mean, you could do that if you want, but that&apos;s like doing </span><code>[REST ALL]</code></div><div data-t="luxbock oh right"><span class="u" id="1466122267.000529">2016:06:17 00:11:07              luxbock </span><span>oh right</span></div><div data-t="luxbock yeah it was correct the firs time, but my own example useage was wrong"><span class="u" id="1466122359.000530">2016:06:17 00:12:39              luxbock </span><span>yeah it was correct the firs time, but my own example useage was wrong</span></div><div data-t="luxbock I updated the gist so that it now works on sets  and maps as well, although obviously you probably wouldn&apos;t want to use it on thsoe"><span class="u" id="1466122635.000531">2016:06:17 00:17:15              luxbock </span><span>I updated the gist so that it now works on sets  and maps as well, although obviously you probably wouldn&apos;t want to use it on thsoe</span></div><div data-t="luxbock I think it&apos;d be nice to have more selectors that mimic the bahavior of  clojure.core  functions (`TAKE`,  DROP  etc.)"><span class="u" id="1466122726.000532">2016:06:17 00:18:46              luxbock </span><span>I think it&apos;d be nice to have more selectors that mimic the bahavior of </span><code>clojure.core</code><span> functions (`TAKE`, </span><code>DROP</code><span> etc.)</span></div><div data-t="codonnell I did not know about  empty"><span class="u" id="1466122834.000534">2016:06:17 00:20:34            codonnell </span><span>I did not know about </span><code>empty</code></div><div data-t="codonnell neat"><span class="u" id="1466122835.000535">2016:06:17 00:20:35            codonnell </span><span>neat</span></div><div data-t="codonnell some of those functions are in the works, I think ( https://github.com/nathanmarz/specter/issues/121 )"><span class="u" id="1466123084.000536">2016:06:17 00:24:44            codonnell </span><span>some of those functions are in the works, I think (</span><a href="https://github.com/nathanmarz/specter/issues/121">https://github.com/nathanmarz/specter/issues/121</a><span>)</span></div><div data-t="luxbock https://gist.github.com/luxbock/4eb81767e6bb1f6169b4fb12ec8b9356"><span class="u" id="1466125285.000541">2016:06:17 01:01:25              luxbock </span><a href="https://gist.github.com/luxbock/4eb81767e6bb1f6169b4fb12ec8b9356">https://gist.github.com/luxbock/4eb81767e6bb1f6169b4fb12ec8b9356</a></div><div data-t="luxbock this returns what I want, but I wonder if there&apos;s a way to write it using just one  transform"><span class="u" id="1466125298.000542">2016:06:17 01:01:38              luxbock </span><span>this returns what I want, but I wonder if there&apos;s a way to write it using just one </span><code>transform</code></div><div data-t="luxbock the task is to read  :foo  and add it to each number of the  REST  of  :bar"><span class="u" id="1466125332.000543">2016:06:17 01:02:12              luxbock </span><span>the task is to read </span><code>:foo</code><span> and add it to each number of the </span><code>REST</code><span> of </span><code>:bar</code></div><div data-t="luxbock and then to lift the modified  :bar  to be the returned value from the outer  transform"><span class="u" id="1466125372.000544">2016:06:17 01:02:52              luxbock </span><span>and then to lift the modified </span><code>:bar</code><span> to be the returned value from the outer </span><code>transform</code></div><div data-t="luxbock I think my vanilla Clojure version might be easier to read"><span class="u" id="1466125855.000545">2016:06:17 01:10:55              luxbock </span><span>I think my vanilla Clojure version might be easier to read</span></div><div data-t="codonnell (transform [ALL (collect-one :foo) :bar REST ALL ALL] + data)"><span class="u" id="1466126077.000546">2016:06:17 01:14:37            codonnell </span><code>(transform [ALL (collect-one :foo) :bar REST ALL ALL] + data)</code></div><div data-t="codonnell @luxbock: ^"><span class="u" id="1466126093.000547">2016:06:17 01:14:53            codonnell </span><span>@luxbock: ^</span></div><div data-t="luxbock @codonnell: yeah that works except for it doesn&apos;t lift  :bar  up"><span class="u" id="1466126181.000548">2016:06:17 01:16:21              luxbock </span><span>@codonnell: yeah that works except for it doesn&apos;t lift </span><code>:bar</code><span> up</span></div><div data-t="luxbock but maybe  (mapv :bar (transform [ALL (collect-one :foo) :bar REST ALL ALL] + data))  is the most readable"><span class="u" id="1466126224.000549">2016:06:17 01:17:04              luxbock </span><span>but maybe </span><code>(mapv :bar (transform [ALL (collect-one :foo) :bar REST ALL ALL] + data))</code><span> is the most readable</span></div><div data-t="codonnell alright, I&apos;ll take a closer look in a bit"><span class="u" id="1466126225.000550">2016:06:17 01:17:05            codonnell </span><span>alright, I&apos;ll take a closer look in a bit</span></div><div data-t="luxbock I think that using  collect-one  with  transform  for the purpose of lifting an inner structure upwards is a bit verbose and doesn&apos;t feel so easily composable"><span class="u" id="1466126381.000551">2016:06:17 01:19:41              luxbock </span><span>I think that using </span><code>collect-one</code><span> with </span><code>transform</code><span> for the purpose of lifting an inner structure upwards is a bit verbose and doesn&apos;t feel so easily composable</span></div><div data-t="codonnell (transform [ALL (collect-one :foo) (view :bar) REST ALL ALL] + data)"><span class="u" id="1466126398.000552">2016:06:17 01:19:58            codonnell </span><code>(transform [ALL (collect-one :foo) (view :bar) REST ALL ALL] + data)</code></div><div data-t="codonnell that does it, I think"><span class="u" id="1466126418.000553">2016:06:17 01:20:18            codonnell </span><span>that does it, I think</span></div><div data-t="codonnell as for which is more readable, I&apos;d say that&apos;s a matter of opinion"><span class="u" id="1466126441.000554">2016:06:17 01:20:41            codonnell </span><span>as for which is more readable, I&apos;d say that&apos;s a matter of opinion</span></div><div data-t="luxbock yep! nice"><span class="u" id="1466126441.000555">2016:06:17 01:20:41              luxbock </span><span>yep! nice</span></div><div data-t="codonnell probably has a lot to do with how familiar the reader is with specter"><span class="u" id="1466126449.000556">2016:06:17 01:20:49            codonnell </span><span>probably has a lot to do with how familiar the reader is with specter</span></div><div data-t="luxbock I did learn about  view  the other day so I should have been able to get that"><span class="u" id="1466126458.000557">2016:06:17 01:20:58              luxbock </span><span>I did learn about </span><code>view</code><span> the other day so I should have been able to get that</span></div><div data-t="codonnell the fact that it&apos;s even possible to accomplish that transformation in one line of code is pretty absurd IMO"><span class="u" id="1466126636.000558">2016:06:17 01:23:56            codonnell </span><span>the fact that it&apos;s even possible to accomplish that transformation in one line of code is pretty absurd IMO</span></div><div data-t="luxbock yeah definitely"><span class="u" id="1466126648.000559">2016:06:17 01:24:08              luxbock </span><span>yeah definitely</span></div><div data-t="luxbock if only I could think at the speed at which I can type that  😛"><span class="u" id="1466126695.000560">2016:06:17 01:24:55              luxbock </span><span>if only I could think at the speed at which I can type that </span><b>😛</b></div><div data-t="luxbock and adding one more level of complexity takes only a small tweak:  https://gist.github.com/luxbock/c499f34ffe07c00404da7b2615295057"><span class="u" id="1466127065.000562">2016:06:17 01:31:05              luxbock </span><span>and adding one more level of complexity takes only a small tweak: </span><a href="https://gist.github.com/luxbock/c499f34ffe07c00404da7b2615295057">https://gist.github.com/luxbock/c499f34ffe07c00404da7b2615295057</a></div><div data-t="codonnell yep, very nice"><span class="u" id="1466127889.000563">2016:06:17 01:44:49            codonnell </span><span>yep, very nice</span></div><div data-t="rauh @severed-infinity: Def. a Cursive problem, not specter"><span class="u" id="1466178413.000578">2016:06:17 15:46:53                 rauh </span><span>@severed-infinity: Def. a Cursive problem, not specter</span></div><div data-t="rauh You can get rid of almost all warning with the latest EAP version though"><span class="u" id="1466178424.000579">2016:06:17 15:47:04                 rauh </span><span>You can get rid of almost all warning with the latest EAP version though</span></div><div data-t="rauh There you can tell Cursive that a macro is like a  def , thus defining the symbols"><span class="u" id="1466178449.000580">2016:06:17 15:47:29                 rauh </span><span>There you can tell Cursive that a macro is like a </span><code>def</code><span>, thus defining the symbols</span></div><div data-t="rauh And voila, you&apos;ll have full autocomplete for specter"><span class="u" id="1466178465.000581">2016:06:17 15:47:45                 rauh </span><span>And voila, you&apos;ll have full autocomplete for specter</span></div><div data-t="rauh Simply go into the specter (and macros) source file, hover over a (eg.  devnav ) usage and choose  Resolve as ... def"><span class="u" id="1466178527.000582">2016:06:17 15:48:47                 rauh </span><span>Simply go into the specter (and macros) source file, hover over a (eg. </span><code>devnav</code><span>) usage and choose </span><code>Resolve as ... def</code></div><div data-t="severed-infinity @rauh Ah I am using the latest EAP but did not know about this"><span class="u" id="1466178549.000583">2016:06:17 15:49:09     severed-infinity </span><span>@rauh Ah I am using the latest EAP but did not know about this</span></div><div data-t="rauh You have to go into the specter source"><span class="u" id="1466179082.000585">2016:06:17 15:58:02                 rauh </span><span>You have to go into the specter source</span></div><div data-t="rauh F12 for me,  goto source  or someting like that"><span class="u" id="1466179090.000586">2016:06:17 15:58:10                 rauh </span><span>F12 for me, </span><code>goto source</code><span> or someting like that</span></div><div data-t="rauh Well, you can&apos;t do that on an unresolved symbol (yet)  🙂"><span class="u" id="1466179115.000587">2016:06:17 15:58:35                 rauh </span><span>Well, you can&apos;t do that on an unresolved symbol (yet) </span><b>🙂</b></div><div data-t="rauh so jump into specter source from maybe your  (:require ...)"><span class="u" id="1466179138.000588">2016:06:17 15:58:58                 rauh </span><span>so jump into specter source from maybe your </span><code>(:require ...)</code></div><div data-t="luxbock how would I write a selector that stops further navigation if the value it points to matches a predicate?"><span class="u" id="1466258449.000604">2016:06:18 14:00:49              luxbock </span><span>how would I write a selector that stops further navigation if the value it points to matches a predicate?</span></div><div data-t="luxbock probably something with  if-path , let&apos;s see"><span class="u" id="1466258624.000605">2016:06:18 14:03:44              luxbock </span><span>probably something with </span><code>if-path</code><span>, let&apos;s see</span></div><div data-t="nathanmarz @luxbock: try  not-selected?"><span class="u" id="1466260340.000609">2016:06:18 14:32:20           nathanmarz </span><span>@luxbock: try </span><code>not-selected?</code></div><div data-t="luxbock @nathanmarz: thanks, yeah I think that would have solved my toy example, but I ended up writing a custom function for what I&apos;m attempting to do"><span class="u" id="1466260826.000610">2016:06:18 14:40:26              luxbock </span><span>@nathanmarz: thanks, yeah I think that would have solved my toy example, but I ended up writing a custom function for what I&apos;m attempting to do</span></div><div data-t="luxbock https://gist.github.com/luxbock/fda8f2ee4e642903d532d1b34db902e5"><span class="u" id="1466260857.000611">2016:06:18 14:40:57              luxbock </span><a href="https://gist.github.com/luxbock/fda8f2ee4e642903d532d1b34db902e5">https://gist.github.com/luxbock/fda8f2ee4e642903d532d1b34db902e5</a></div><div data-t="luxbock maybe it&apos;s possible to do it with specter as well"><span class="u" id="1466260868.000612">2016:06:18 14:41:08              luxbock </span><span>maybe it&apos;s possible to do it with specter as well</span></div><div data-t="thomasdeutsch what would be the specter version of this:    (map #(+ %1 %2) [1 2 3] [2 3 4])  ?"><span class="u" id="1466327031.000627">2016:06:19 09:03:51        thomasdeutsch </span><span>what would be the specter version of this:   </span><code>(map #(+ %1 %2) [1 2 3] [2 3 4])</code><span> ?</span></div><div data-t="nathanmarz @thomasdeutsch there isn&apos;t"><span class="u" id="1466330122.000629">2016:06:19 09:55:22           nathanmarz </span><span>@thomasdeutsch there isn&apos;t</span></div><div data-t="josh.freckleton @nathanmarz: Thanks for inviting me to  specter , I think it&apos;s brilliant to have this sort of DSL for navigation, and I&apos;m excited for this lib to transform my workflow!

In our conversation yesterday (on #C03S1KBA2) I was talking about needing to post-order traverse a tree. I think I can see how I&apos;d piece that together using  specter , but I see talk toward the end of the  readme  about navigating graphs. What is the best practice if I wanted to post-order traverse a tree?"><span class="u" id="1466546028.000674">2016:06:21 21:53:48      josh.freckleton </span><span>@nathanmarz: Thanks for inviting me to </span><code>specter</code><span>, I think it&apos;s brilliant to have this sort of DSL for navigation, and I&apos;m excited for this lib to transform my workflow!

In our conversation yesterday (on #C03S1KBA2) I was talking about needing to post-order traverse a tree. I think I can see how I&apos;d piece that together using </span><code>specter</code><span>, but I see talk toward the end of the </span><code>readme</code><span> about navigating graphs. What is the best practice if I wanted to post-order traverse a tree?</span></div><div data-t="lellis Hello guys! I made a sort using sorted-map-by then i use into these specter:
 (transform (walker (fn [v] (and (keyword? v)))) #(keyword (clojure.string/replace (subs (str %) 1) &quot;/&quot; &quot;_&quot;)) sorted-map) 

But because inner specter use walker and walker says &quot;Note: &quot;walk&quot; supports all Clojure data structures EXCEPT maps
created with sorted-map-by.  There is no (obvious) way to retrieve
the sorting function.&quot; Is there another way to do that with specter?"><span class="u" id="1466546048.000675">2016:06:21 21:54:08               lellis </span><span>Hello guys! I made a sort using sorted-map-by then i use into these specter:
</span><pre>(transform (walker (fn [v] (and (keyword? v)))) #(keyword (clojure.string/replace (subs (str %) 1) &quot;/&quot; &quot;_&quot;)) sorted-map)</pre><span>

But because inner specter use walker and walker says &quot;Note: &quot;walk&quot; supports all Clojure data structures EXCEPT maps
created with sorted-map-by.  There is no (obvious) way to retrieve
the sorting function.&quot; Is there another way to do that with specter?</span></div><div data-t="lellis Or is better  make my sort without sorted-map-by?"><span class="u" id="1466546247.000676">2016:06:21 21:57:27               lellis </span><span>Or is better  make my sort without sorted-map-by?</span></div><div data-t="nathanmarz @josh.freckleton: do you mean best practice if you wanted to post-order traverse a graph?"><span class="u" id="1466546971.000677">2016:06:21 22:09:31           nathanmarz </span><span>@josh.freckleton: do you mean best practice if you wanted to post-order traverse a graph?</span></div><div data-t="josh.freckleton @nathanmarz: yes, that would be awesome! I don&apos;t quite get recursion, or ordering yet in  specter"><span class="u" id="1466547006.000678">2016:06:21 22:10:06      josh.freckleton </span><span>@nathanmarz: yes, that would be awesome! I don&apos;t quite get recursion, or ordering yet in </span><code>specter</code></div><div data-t="nathanmarz so internally I have a bunch of navigators built on top of loom"><span class="u" id="1466547034.000679">2016:06:21 22:10:34           nathanmarz </span><span>so internally I have a bunch of navigators built on top of loom</span></div><div data-t="nathanmarz https://github.com/aysylu/loom"><span class="u" id="1466547045.000680">2016:06:21 22:10:45           nathanmarz </span><a href="https://github.com/aysylu/loom">https://github.com/aysylu/loom</a></div><div data-t="nathanmarz so I can do things like  (transform [REVERSE-TOPSORT ...] ...)"><span class="u" id="1466547109.000682">2016:06:21 22:11:49           nathanmarz </span><span>so I can do things like </span><code>(transform [REVERSE-TOPSORT ...] ...)</code></div><div data-t="nathanmarz where reverse-topsort navigates to pairs of  [graph, node-id]  in reverse topological order"><span class="u" id="1466547125.000683">2016:06:21 22:12:05           nathanmarz </span><span>where reverse-topsort navigates to pairs of </span><code>[graph, node-id]</code><span> in reverse topological order</span></div><div data-t="nathanmarz at the end of my clojure/west talk I showed a complete example of my specter/loom integration"><span class="u" id="1466547169.000684">2016:06:21 22:12:49           nathanmarz </span><span>at the end of my clojure/west talk I showed a complete example of my specter/loom integration</span></div><div data-t="nathanmarz trying to encourage someone from the community to build an open-source version"><span class="u" id="1466547188.000685">2016:06:21 22:13:08           nathanmarz </span><span>trying to encourage someone from the community to build an open-source version</span></div><div data-t="aengelberg That&apos;s odd that  clojure.walk/walk  claims to not work with  sorted-map-by . I just tried it in the REPL and it seems to work fine."><span class="u" id="1466547278.000686">2016:06:21 22:14:38           aengelberg </span><span>That&apos;s odd that </span><code>clojure.walk/walk</code><span> claims to not work with </span><code>sorted-map-by</code><span>. I just tried it in the REPL and it seems to work fine.</span></div><div data-t="nathanmarz hmm, didn&apos;t even know about  sorted-map-by"><span class="u" id="1466547510.000687">2016:06:21 22:18:30           nathanmarz </span><span>hmm, didn&apos;t even know about </span><code>sorted-map-by</code></div><div data-t="nathanmarz looks like  ALL  and  MAP-VALS  are broken with that, but  walker  does seem to work"><span class="u" id="1466547524.000688">2016:06:21 22:18:44           nathanmarz </span><span>looks like </span><code>ALL</code><span> and </span><code>MAP-VALS</code><span> are broken with that, but </span><code>walker</code><span> does seem to work</span></div><div data-t="nathanmarz that bug is fixed for next release  https://github.com/nathanmarz/specter/commit/9ff9ef6650d3faab5421dd6452a716421a81554f"><span class="u" id="1466548712.000689">2016:06:21 22:38:32           nathanmarz </span><span>that bug is fixed for next release </span><a href="https://github.com/nathanmarz/specter/commit/9ff9ef6650d3faab5421dd6452a716421a81554f">https://github.com/nathanmarz/specter/commit/9ff9ef6650d3faab5421dd6452a716421a81554f</a></div><div data-t="josh.freckleton @nathanmarz: ah, it wasn&apos;t clear you were using  loom  at the end of that talk. Fantastic talk though! Would you by chance have a  gist  I could study?"><span class="u" id="1466549207.000690">2016:06:21 22:46:47      josh.freckleton </span><span>@nathanmarz: ah, it wasn&apos;t clear you were using </span><code>loom</code><span> at the end of that talk. Fantastic talk though! Would you by chance have a </span><code>gist</code><span> I could study?</span></div><div data-t="aengelberg Do priority maps work with  ALL ?"><span class="u" id="1466549702.000691">2016:06:21 22:55:02           aengelberg </span><span>Do priority maps work with </span><code>ALL</code><span>?</span></div><div data-t="lellis I make some code for example: 
 (def demo-map {:a &quot;baa&quot; :b &quot;aab&quot;})

(def demo-map-sorted-by-value (into (sorted-map-by (fn [key1 key2]
                                                     (compare
                                                       [(get demo-map key1) key1]
                                                       [(get demo-map key2) key2]))) demo-map))

(def result (transform (walker (fn [v] (and (keyword? v)))) #(keyword (clojure.string/replace (subs (str %) 1) &quot;a&quot; &quot;c&quot;)) demo-map-sorted-by-value))

demo-map =&gt; {:a &quot;baa&quot;, :b &quot;aab&quot;}
demo-map-sorted-by-value =&gt; {:b &quot;aab&quot;, :a &quot;baa&quot;}
result =&gt; {:c &quot;baa&quot;, :b &quot;aab”}

 
The question is: Why i lost my sort by value?"><span class="u" id="1466552228.000692">2016:06:21 23:37:08               lellis </span><span>I make some code for example: 
</span><pre>(def demo-map {:a &quot;baa&quot; :b &quot;aab&quot;})

(def demo-map-sorted-by-value (into (sorted-map-by (fn [key1 key2]
                                                     (compare
                                                       [(get demo-map key1) key1]
                                                       [(get demo-map key2) key2]))) demo-map))

(def result (transform (walker (fn [v] (and (keyword? v)))) #(keyword (clojure.string/replace (subs (str %) 1) &quot;a&quot; &quot;c&quot;)) demo-map-sorted-by-value))

demo-map =&gt; {:a &quot;baa&quot;, :b &quot;aab&quot;}
demo-map-sorted-by-value =&gt; {:b &quot;aab&quot;, :a &quot;baa&quot;}
result =&gt; {:c &quot;baa&quot;, :b &quot;aab”}

</pre><span>
The question is: Why i lost my sort by value?</span></div><div data-t="codonnell @lellis: that should be fixed in master with  https://github.com/nathanmarz/specter/commit/9ff9ef6650d3faab5421dd6452a716421a81554f"><span class="u" id="1466552450.000693">2016:06:21 23:40:50            codonnell </span><span>@lellis: that should be fixed in master with </span><a href="https://github.com/nathanmarz/specter/commit/9ff9ef6650d3faab5421dd6452a716421a81554f">https://github.com/nathanmarz/specter/commit/9ff9ef6650d3faab5421dd6452a716421a81554f</a></div><div data-t="nathanmarz @lellis: Your compare function compares with the values inside  demo-map"><span class="u" id="1466557309.000697">2016:06:22 01:01:49           nathanmarz </span><span>@lellis: Your compare function compares with the values inside </span><code>demo-map</code></div><div data-t="nathanmarz so you&apos;re comparing [nil :c] vs.  [&quot;aab&quot; :b]"><span class="u" id="1466557324.000698">2016:06:22 01:02:04           nathanmarz </span><span>so you&apos;re comparing [nil :c] vs.  [&quot;aab&quot; :b]</span></div><div data-t="nathanmarz the maps themselves have the correct comparison function"><span class="u" id="1466557333.000699">2016:06:22 01:02:13           nathanmarz </span><span>the maps themselves have the correct comparison function</span></div><div data-t="nathanmarz user=&gt; (identical? (.comparator result) (.comparator demo-map-sorted-by-value))
true
"><span class="u" id="1466557352.000700">2016:06:22 01:02:32           nathanmarz </span><pre>user=&gt; (identical? (.comparator result) (.comparator demo-map-sorted-by-value))
true
</pre></div><div data-t="nathanmarz @aengelberg: which priority map?"><span class="u" id="1466557476.000701">2016:06:22 01:04:36           nathanmarz </span><span>@aengelberg: which priority map?</span></div><div data-t="nathanmarz maps other than clojure&apos;s persistent types will run the  Object  case of  all-transform  protocol (which is the former implementation of  ALL )"><span class="u" id="1466557541.000702">2016:06:22 01:05:41           nathanmarz </span><span>maps other than clojure&apos;s persistent types will run the </span><code>Object</code><span> case of </span><code>all-transform</code><span> protocol (which is the former implementation of </span><code>ALL</code><span>)</span></div><div data-t="nathanmarz @josh.freckleton: Nothing besides what I showed in that talk:  https://github.com/nathanmarz/specter-clojure-west/blob/master/src/specter_demo/examples.clj#L466"><span class="u" id="1466557600.000703">2016:06:22 01:06:40           nathanmarz </span><span>@josh.freckleton: Nothing besides what I showed in that talk: </span><a href="https://github.com/nathanmarz/specter-clojure-west/blob/master/src/specter_demo/examples.clj#L466">https://github.com/nathanmarz/specter-clojure-west/blob/master/src/specter_demo/examples.clj#L466</a></div><div data-t="nathanmarz I work with DAGs so my operators are specific to those"><span class="u" id="1466557644.000705">2016:06:22 01:07:24           nathanmarz </span><span>I work with DAGs so my operators are specific to those</span></div><div data-t="aengelberg External library. clojure.data.priority-map"><span class="u" id="1466557675.000706">2016:06:22 01:07:55           aengelberg </span><span>External library. clojure.data.priority-map</span></div><div data-t="nathanmarz PARENTS ,  CHILDREN ,  TOPSORT ,  NODE , and then a bunch of different ways to navigate to &quot;subgraphs&quot;"><span class="u" id="1466557758.000707">2016:06:22 01:09:18           nathanmarz </span><code>PARENTS</code><span>, </span><code>CHILDREN</code><span>, </span><code>TOPSORT</code><span>, </span><code>NODE</code><span>, and then a bunch of different ways to navigate to &quot;subgraphs&quot;</span></div><div data-t="nathanmarz subgraph navigators are similar in concept to  subset  and  submap , and metadata on the transformed subgraph indicates how to re-attach the edges that were formerly to the prior subgraph"><span class="u" id="1466557816.000708">2016:06:22 01:10:16           nathanmarz </span><span>subgraph navigators are similar in concept to </span><code>subset</code><span> and </span><code>submap</code><span>, and metadata on the transformed subgraph indicates how to re-attach the edges that were formerly to the prior subgraph</span></div><div data-t="nathanmarz @aengelberg: if it correctly implements  empty  I imagine it should work"><span class="u" id="1466557830.000709">2016:06:22 01:10:30           nathanmarz </span><span>@aengelberg: if it correctly implements </span><code>empty</code><span> I imagine it should work</span></div><div data-t="nathanmarz and  IKVReduce"><span class="u" id="1466557881.000710">2016:06:22 01:11:21           nathanmarz </span><span>and </span><code>IKVReduce</code></div><div data-t="nathanmarz wouldn&apos;t be as fast as the other ones though since the default handler does a bunch of other checks beforehand"><span class="u" id="1466557900.000711">2016:06:22 01:11:40           nathanmarz </span><span>wouldn&apos;t be as fast as the other ones though since the default handler does a bunch of other checks beforehand</span></div><div data-t="odinodin Is is possible to remove nodes from a tree structure with specter? I can only manage to replace nodes with nil"><span class="u" id="1466592840.000719">2016:06:22 10:54:00             odinodin </span><span>Is is possible to remove nodes from a tree structure with specter? I can only manage to replace nodes with nil</span></div><div data-t="nathanmarz @odinodin: how are you representing your tree?"><span class="u" id="1466594142.000720">2016:06:22 11:15:42           nathanmarz </span><span>@odinodin: how are you representing your tree?</span></div><div data-t="odinodin (def all-pages
  {:pages {:page-id &quot;home&quot;,
           :options &apos;({:page-id &quot;other_inq&quot;}
                      {:page-id &quot;other_inq&quot;,
                       :access #{&quot;employee&quot;}})}})

(defn only-authorized [pages access]
  (-&gt;&gt; pages
       (transform*
         [(walker #(and (map? %) (contains? % :access)))]
         (fn [page] (when (-&gt; page :access (some access)) page)))))
"><span class="u" id="1466594521.000721">2016:06:22 11:22:01             odinodin </span><pre>(def all-pages
  {:pages {:page-id &quot;home&quot;,
           :options &apos;({:page-id &quot;other_inq&quot;}
                      {:page-id &quot;other_inq&quot;,
                       :access #{&quot;employee&quot;}})}})

(defn only-authorized [pages access]
  (-&gt;&gt; pages
       (transform*
         [(walker #(and (map? %) (contains? % :access)))]
         (fn [page] (when (-&gt; page :access (some access)) page)))))
</pre></div><div data-t="odinodin only-authorized returns
  {:pages {:page-id &quot;home&quot;, :options ({:page-id &quot;other_inq&quot;} nil)}} "><span class="u" id="1466594546.000722">2016:06:22 11:22:26             odinodin </span><span>only-authorized returns
 </span><pre>{:pages {:page-id &quot;home&quot;, :options ({:page-id &quot;other_inq&quot;} nil)}} </pre></div><div data-t="odinodin my current fix for removing the nil is : 
 (defn only-authorized [pages access]
  (-&gt;&gt; pages
       (transform*
         [(walker #(and (map? %) (contains? % :access)))]
         (fn [page] (when (-&gt; page :access (some access)) page)))
       (transform*
           [(walker #(and (map? %) (contains? % :options)))]
           (fn [x] (update x :options (partial remove nil?))))))
"><span class="u" id="1466594587.000723">2016:06:22 11:23:07             odinodin </span><span>my current fix for removing the nil is : 
</span><pre>(defn only-authorized [pages access]
  (-&gt;&gt; pages
       (transform*
         [(walker #(and (map? %) (contains? % :access)))]
         (fn [page] (when (-&gt; page :access (some access)) page)))
       (transform*
           [(walker #(and (map? %) (contains? % :options)))]
           (fn [x] (update x :options (partial remove nil?))))))
</pre></div><div data-t="nathanmarz well you definitely can&apos;t do it with  walker"><span class="u" id="1466594729.000724">2016:06:22 11:25:29           nathanmarz </span><span>well you definitely can&apos;t do it with </span><code>walker</code></div><div data-t="nathanmarz if you make your own recursive path there&apos;s a variety of ways of doing it"><span class="u" id="1466594780.000725">2016:06:22 11:26:20           nathanmarz </span><span>if you make your own recursive path there&apos;s a variety of ways of doing it</span></div><div data-t="odinodin I saw the next version of specter has a NONE value, what if I could return NONE instead of nil in the transform-function?"><span class="u" id="1466594949.000726">2016:06:22 11:29:09             odinodin </span><span>I saw the next version of specter has a NONE value, what if I could return NONE instead of nil in the transform-function?</span></div><div data-t="nathanmarz @odinodin: I&apos;ll show you how to do it"><span class="u" id="1466595119.000727">2016:06:22 11:31:59           nathanmarz </span><span>@odinodin: I&apos;ll show you how to do it</span></div><div data-t="nathanmarz @odinodin: not yet decided whether that feature idea will become reality"><span class="u" id="1466595130.000728">2016:06:22 11:32:10           nathanmarz </span><span>@odinodin: not yet decided whether that feature idea will become reality</span></div><div data-t="nathanmarz your data structure also isn&apos;t recursive"><span class="u" id="1466595145.000729">2016:06:22 11:32:25           nathanmarz </span><span>your data structure also isn&apos;t recursive</span></div><div data-t="odinodin it is, just simplified the example"><span class="u" id="1466595162.000730">2016:06:22 11:32:42             odinodin </span><span>it is, just simplified the example</span></div><div data-t="nathanmarz this example isn&apos;t recursive so it&apos;s hard to show you what to do"><span class="u" id="1466595176.000731">2016:06:22 11:32:56           nathanmarz </span><span>this example isn&apos;t recursive so it&apos;s hard to show you what to do</span></div><div data-t="nathanmarz i think if you change :options to :pages its recursive"><span class="u" id="1466595223.000732">2016:06:22 11:33:43           nathanmarz </span><span>i think if you change :options to :pages its recursive</span></div><div data-t="odinodin (def all-pages
  {:pages {:page-id &quot;home&quot;,
           :options &apos;({:page-id &quot;a&quot; :options ({:page-id &quot;c&quot;, :access #{&quot;external&quot;}})}
                       {:page-id &quot;b&quot;, :access #{&quot;employee&quot;}})}})
"><span class="u" id="1466595281.000733">2016:06:22 11:34:41             odinodin </span><pre>(def all-pages
  {:pages {:page-id &quot;home&quot;,
           :options &apos;({:page-id &quot;a&quot; :options ({:page-id &quot;c&quot;, :access #{&quot;external&quot;}})}
                       {:page-id &quot;b&quot;, :access #{&quot;employee&quot;}})}})
</pre></div><div data-t="nathanmarz @odinodin: 
 (def all-pages
  {:page-id &quot;root&quot;
   :pages [{:page-id &quot;other-page&quot;,
            :pages &apos;({:page-id &quot;other_inq&quot;}
                     {:page-id &quot;other_inq&quot;,
                      :access #{&quot;employee&quot;}})}]
          })

(declarepath NODES)

(providepath NODES
  (stay-then-continue
    (must :pages) ALL NODES
    ))


(setval
  [NODES
   (must :pages)
   (continuous-subseqs :access)
   ]
  []
  all-pages
  )
"><span class="u" id="1466595484.000734">2016:06:22 11:38:04           nathanmarz </span><span>@odinodin: 
</span><pre>(def all-pages
  {:page-id &quot;root&quot;
   :pages [{:page-id &quot;other-page&quot;,
            :pages &apos;({:page-id &quot;other_inq&quot;}
                     {:page-id &quot;other_inq&quot;,
                      :access #{&quot;employee&quot;}})}]
          })

(declarepath NODES)

(providepath NODES
  (stay-then-continue
    (must :pages) ALL NODES
    ))


(setval
  [NODES
   (must :pages)
   (continuous-subseqs :access)
   ]
  []
  all-pages
  )
</pre></div><div data-t="nathanmarz that&apos;s one way to do it"><span class="u" id="1466595489.000735">2016:06:22 11:38:09           nathanmarz </span><span>that&apos;s one way to do it</span></div><div data-t="odinodin sweet, thanks  🙂"><span class="u" id="1466595510.000736">2016:06:22 11:38:30             odinodin </span><span>sweet, thanks </span><b>🙂</b></div><div data-t="nathanmarz modified the example data to be recursive in structure"><span class="u" id="1466595522.000737">2016:06:22 11:38:42           nathanmarz </span><span>modified the example data to be recursive in structure</span></div><div data-t="odinodin specter is really awesome, thanks for making it  🙂"><span class="u" id="1466595569.000738">2016:06:22 11:39:29             odinodin </span><span>specter is really awesome, thanks for making it </span><b>🙂</b></div><div data-t="nathanmarz enjoy  🙂"><span class="u" id="1466595711.000739">2016:06:22 11:41:51           nathanmarz </span><span>enjoy </span><b>🙂</b></div><div data-t="luxbock (transform [(collect MAP-VALS) MAP-VALS] (fn [vs n] (/ n (apply + vs))) (frequencies [1 1 2 2 2 3 4 4 4]))"><span class="u" id="1466611438.000744">2016:06:22 16:03:58              luxbock </span><code>(transform [(collect MAP-VALS) MAP-VALS] (fn [vs n] (/ n (apply + vs))) (frequencies [1 1 2 2 2 3 4 4 4]))</code></div><div data-t="luxbock is there any way to avoid calculating the sum of the values for every individual value as I&apos;m doing there?"><span class="u" id="1466611490.000745">2016:06:22 16:04:50              luxbock </span><span>is there any way to avoid calculating the sum of the values for every individual value as I&apos;m doing there?</span></div><div data-t="luxbock a specter way of doing that I mean"><span class="u" id="1466611523.000746">2016:06:22 16:05:23              luxbock </span><span>a specter way of doing that I mean</span></div><div data-t="nathanmarz @luxbock: like this?
 (transform [(collect-one (view count)) (view frequencies) MAP-VALS]
  (fn [s n] (/ n s))
  [1 1 2 2 2 3 4 4 4]
  )
"><span class="u" id="1466611935.000747">2016:06:22 16:12:15           nathanmarz </span><span>@luxbock: like this?
</span><pre>(transform [(collect-one (view count)) (view frequencies) MAP-VALS]
  (fn [s n] (/ n s))
  [1 1 2 2 2 3 4 4 4]
  )
</pre></div><div data-t="luxbock ah very nice"><span class="u" id="1466612089.000748">2016:06:22 16:14:49              luxbock </span><span>ah very nice</span></div><div data-t="luxbock (transform [ALL (view :foo) #(&gt; % 2)]
  str
  [{:foo 1} {:foo 2} {:foo 3} {:foo 4}])
;; =&gt; [1 2 &quot;3&quot; &quot;4&quot;]
"><span class="u" id="1466613458.000749">2016:06:22 16:37:38              luxbock </span><pre>(transform [ALL (view :foo) #(&gt; % 2)]
  str
  [{:foo 1} {:foo 2} {:foo 3} {:foo 4}])
;; =&gt; [1 2 &quot;3&quot; &quot;4&quot;]
</pre></div><div data-t="luxbock how would I do this but only get  [&quot;3&quot; &quot;4&quot;]  back?"><span class="u" id="1466613477.000750">2016:06:22 16:37:57              luxbock </span><span>how would I do this but only get </span><code>[&quot;3&quot; &quot;4&quot;]</code><span> back?</span></div><div data-t="nathanmarz @luxbock:  (select [ALL :foo #(&gt; % 2) (view str)] [{:foo 1} {:foo 2} {:foo 3} {:foo 4}])"><span class="u" id="1466614425.000751">2016:06:22 16:53:45           nathanmarz </span><span>@luxbock: </span><code>(select [ALL :foo #(&gt; % 2) (view str)] [{:foo 1} {:foo 2} {:foo 3} {:foo 4}])</code></div><div data-t="luxbock @nathanmarz:  in my case  :foo  is actually a function that retrieves the value from deeper in the map, which is why I used  view  with it"><span class="u" id="1466614998.000752">2016:06:22 17:03:18              luxbock </span><span>@nathanmarz:  in my case </span><code>:foo</code><span> is actually a function that retrieves the value from deeper in the map, which is why I used </span><code>view</code><span> with it</span></div><div data-t="luxbock ah, but it looks like it actually works if I just wrap it in  view  and then use  select"><span class="u" id="1466615072.000753">2016:06:22 17:04:32              luxbock </span><span>ah, but it looks like it actually works if I just wrap it in </span><code>view</code><span> and then use </span><code>select</code></div><div data-t="luxbock great"><span class="u" id="1466615073.000754">2016:06:22 17:04:33              luxbock </span><span>great</span></div><div data-t="aengelberg @nathanmarz just saw your post about  multi-transform , looks interesting. Have you considered adding a  terminal-val  which sets the value instead of transforms it (like  setval  is to  transform )?"><span class="u" id="1466642141.000764">2016:06:23 00:35:41           aengelberg </span><span>@nathanmarz just saw your post about </span><code>multi-transform</code><span>, looks interesting. Have you considered adding a </span><code>terminal-val</code><span> which sets the value instead of transforms it (like </span><code>setval</code><span> is to </span><code>transform</code><span>)?</span></div><div data-t="nathanmarz @aengelberg: good idea, i&apos;ll add that to the branch"><span class="u" id="1466643224.000765">2016:06:23 00:53:44           nathanmarz </span><span>@aengelberg: good idea, i&apos;ll add that to the branch</span></div><div data-t="nathanmarz @aengelberg:  https://github.com/nathanmarz/specter/commit/50d2aa48f57df75b8395950ac0511f63849da400"><span class="u" id="1466643661.000766">2016:06:23 01:01:01           nathanmarz </span><span>@aengelberg: </span><a href="https://github.com/nathanmarz/specter/commit/50d2aa48f57df75b8395950ac0511f63849da400">https://github.com/nathanmarz/specter/commit/50d2aa48f57df75b8395950ac0511f63849da400</a></div><div data-t="aengelberg just realized that setval does not work with collect... is this a bug?
 boot.user=&gt; (setval [:a (collect STAY)] 2 {:a 1})

clojure.lang.ArityException: Wrong number of args (2) passed to: impl/compiled-setval*/fn--2959
"><span class="u" id="1466643785.000767">2016:06:23 01:03:05           aengelberg </span><span>just realized that setval does not work with collect... is this a bug?
</span><pre>boot.user=&gt; (setval [:a (collect STAY)] 2 {:a 1})

clojure.lang.ArityException: Wrong number of args (2) passed to: impl/compiled-setval*/fn--2959
</pre></div><div data-t="aengelberg I was about to say, why not switch  constantly  to  (fn [_] val)  like setval uses, for efficiency..."><span class="u" id="1466643816.000768">2016:06:23 01:03:36           aengelberg </span><span>I was about to say, why not switch </span><code>constantly</code><span> to </span><code>(fn [_] val)</code><span> like setval uses, for efficiency...</span></div><div data-t="nathanmarz ah, just looked at the implementation of  constantly"><span class="u" id="1466643883.000770">2016:06:23 01:04:43           nathanmarz </span><span>ah, just looked at the implementation of </span><code>constantly</code></div><div data-t="nathanmarz but yea that&apos;s a bug"><span class="u" id="1466643896.000771">2016:06:23 01:04:56           nathanmarz </span><span>but yea that&apos;s a bug</span></div><div data-t="nathanmarz though it&apos;s a weird bug to hit"><span class="u" id="1466643919.000772">2016:06:23 01:05:19           nathanmarz </span><span>though it&apos;s a weird bug to hit</span></div><div data-t="aengelberg user&gt; (let [f (constantly 1)] (dotimes [i 5] (time (dotimes [i 10000000] (f 2)))))
&quot;Elapsed time: 178.060125 msecs&quot;
&quot;Elapsed time: 164.164117 msecs&quot;
&quot;Elapsed time: 170.549443 msecs&quot;
&quot;Elapsed time: 165.947481 msecs&quot;
&quot;Elapsed time: 163.606619 msecs&quot;
nil
user&gt; (let [f (fn [_] 1)] (dotimes [i 5] (time (dotimes [i 10000000] (f 2)))))
&quot;Elapsed time: 55.36876 msecs&quot;
&quot;Elapsed time: 47.140944 msecs&quot;
&quot;Elapsed time: 46.974314 msecs&quot;
&quot;Elapsed time: 46.51298 msecs&quot;
&quot;Elapsed time: 44.286403 msecs&quot;
nil
user&gt; (let [f (fn [_ &amp; _] 1)] (dotimes [i 5] (time (dotimes [i 10000000] (f 2)))))
&quot;Elapsed time: 86.562498 msecs&quot;
&quot;Elapsed time: 89.103274 msecs&quot;
&quot;Elapsed time: 86.074677 msecs&quot;
&quot;Elapsed time: 87.669437 msecs&quot;
&quot;Elapsed time: 89.690679 msecs&quot;
nil
 
(edited with more accurate benchmark)"><span class="u" id="1466644231.000773">2016:06:23 01:10:31           aengelberg </span><pre>user&gt; (let [f (constantly 1)] (dotimes [i 5] (time (dotimes [i 10000000] (f 2)))))
&quot;Elapsed time: 178.060125 msecs&quot;
&quot;Elapsed time: 164.164117 msecs&quot;
&quot;Elapsed time: 170.549443 msecs&quot;
&quot;Elapsed time: 165.947481 msecs&quot;
&quot;Elapsed time: 163.606619 msecs&quot;
nil
user&gt; (let [f (fn [_] 1)] (dotimes [i 5] (time (dotimes [i 10000000] (f 2)))))
&quot;Elapsed time: 55.36876 msecs&quot;
&quot;Elapsed time: 47.140944 msecs&quot;
&quot;Elapsed time: 46.974314 msecs&quot;
&quot;Elapsed time: 46.51298 msecs&quot;
&quot;Elapsed time: 44.286403 msecs&quot;
nil
user&gt; (let [f (fn [_ &amp; _] 1)] (dotimes [i 5] (time (dotimes [i 10000000] (f 2)))))
&quot;Elapsed time: 86.562498 msecs&quot;
&quot;Elapsed time: 89.103274 msecs&quot;
&quot;Elapsed time: 86.074677 msecs&quot;
&quot;Elapsed time: 87.669437 msecs&quot;
&quot;Elapsed time: 89.690679 msecs&quot;
nil
</pre><span>
(edited with more accurate benchmark)</span></div><div data-t="aengelberg There&apos;s a spectrum"><span class="u" id="1466644318.000774">2016:06:23 01:11:58           aengelberg </span><span>There&apos;s a spectrum</span></div><div data-t="nathanmarz hand-rolled a  fast-constantly  and also fixed that bug"><span class="u" id="1466644977.000776">2016:06:23 01:22:57           nathanmarz </span><span>hand-rolled a </span><code>fast-constantly</code><span> and also fixed that bug</span></div><div data-t="luxbock are  (transform [&lt;selector&gt; (view f)] identity coll)  and  (transform &lt;selector&gt; f coll)  interchangeable? is the latter going to be faster?"><span class="u" id="1466670469.000783">2016:06:23 08:27:49              luxbock </span><span>are </span><code>(transform [&lt;selector&gt; (view f)] identity coll)</code><span> and </span><code>(transform &lt;selector&gt; f coll)</code><span> interchangeable? is the latter going to be faster?</span></div><div data-t="luxbock using  specter  feels a bit like concatenative programming to me"><span class="u" id="1466670688.000784">2016:06:23 08:31:28              luxbock </span><span>using </span><code>specter</code><span> feels a bit like concatenative programming to me</span></div><div data-t="luxbock I wonder if there are some ideas there that could be applicable"><span class="u" id="1466670705.000785">2016:06:23 08:31:45              luxbock </span><span>I wonder if there are some ideas there that could be applicable</span></div><div data-t="luxbock you could think of  VAL  as an analog of  dup  and the discussed  OMIT  as being  drop"><span class="u" id="1466670858.000786">2016:06:23 08:34:18              luxbock </span><span>you could think of </span><code>VAL</code><span> as an analog of </span><code>dup</code><span> and the discussed </span><code>OMIT</code><span> as being </span><code>drop</code></div><div data-t="luxbock concatenative languages can be extremely expressive and allow for easy meta-programming"><span class="u" id="1466670934.000787">2016:06:23 08:35:34              luxbock </span><span>concatenative languages can be extremely expressive and allow for easy meta-programming</span></div><div data-t="luxbock I played around with combining this idea with destructuring:  https://gist.github.com/luxbock/f93529b82792ef35db12fcf5e5a78fdb"><span class="u" id="1466673131.000788">2016:06:23 09:12:11              luxbock </span><span>I played around with combining this idea with destructuring: </span><a href="https://gist.github.com/luxbock/f93529b82792ef35db12fcf5e5a78fdb">https://gist.github.com/luxbock/f93529b82792ef35db12fcf5e5a78fdb</a></div><div data-t="nathanmarz @luxbock: they are not interchangeable as  f  in the latter form will receive collected values while  f  in the former will not"><span class="u" id="1466689955.000792">2016:06:23 13:52:35           nathanmarz </span><span>@luxbock: they are not interchangeable as </span><code>f</code><span> in the latter form will receive collected values while </span><code>f</code><span> in the former will not</span></div><div data-t="nathanmarz the latter will also be faster"><span class="u" id="1466689960.000793">2016:06:23 13:52:40           nathanmarz </span><span>the latter will also be faster</span></div><div data-t="nathanmarz @luxbock: interesting ideas, but can&apos;t the starting example be written as this?
 (transform
  [MAP-VALS
   (view frequencies)
   (collect-one (subselect MAP-VALS) (view #(apply max %)))
   MAP-VALS]
  (fn [mx e] (/ e mx))
  {:a [1 1 3 4] :b [1 1 2 2 2 3]})
"><span class="u" id="1466690431.000794">2016:06:23 14:00:31           nathanmarz </span><span>@luxbock: interesting ideas, but can&apos;t the starting example be written as this?
</span><pre>(transform
  [MAP-VALS
   (view frequencies)
   (collect-one (subselect MAP-VALS) (view #(apply max %)))
   MAP-VALS]
  (fn [mx e] (/ e mx))
  {:a [1 1 3 4] :b [1 1 2 2 2 3]})
</pre></div><div data-t="luxbock yes you are correct, my specter-fu is still far from perfect  🙂"><span class="u" id="1466691168.000795">2016:06:23 14:12:48              luxbock </span><span>yes you are correct, my specter-fu is still far from perfect </span><b>🙂</b></div><div data-t="nathanmarz you&apos;ll get there  🙂"><span class="u" id="1466693161.000799">2016:06:23 14:46:01           nathanmarz </span><span>you&apos;ll get there </span><b>🙂</b></div><div data-t="nathanmarz just realized it can be made even more concise:
 (transform
  [MAP-VALS
   (view frequencies)
   (subselect MAP-VALS)
   (collect-one (view #(apply max %)))
   ALL]
  (fn [mx e] (/ e mx))
  {:a [1 1 3 4] :b [1 1 2 2 2 3]})
"><span class="u" id="1466693172.000800">2016:06:23 14:46:12           nathanmarz </span><span>just realized it can be made even more concise:
</span><pre>(transform
  [MAP-VALS
   (view frequencies)
   (subselect MAP-VALS)
   (collect-one (view #(apply max %)))
   ALL]
  (fn [mx e] (/ e mx))
  {:a [1 1 3 4] :b [1 1 2 2 2 3]})
</pre></div><div data-t="luxbock nice"><span class="u" id="1466693206.000801">2016:06:23 14:46:46              luxbock </span><span>nice</span></div><div data-t="luxbock if I wanted to do the same thing, but wanted to  inc  all the numbers before using  frequencies  and the rest of the selectors, can I somehow fit that into the selector?"><span class="u" id="1466694011.000802">2016:06:23 15:00:11              luxbock </span><span>if I wanted to do the same thing, but wanted to </span><code>inc</code><span> all the numbers before using </span><code>frequencies</code><span> and the rest of the selectors, can I somehow fit that into the selector?</span></div><div data-t="luxbock I have this type of situation where I had a nested  transform  like in my example, and I&apos;m now trying to re-write it using your approach"><span class="u" id="1466694043.000803">2016:06:23 15:00:43              luxbock </span><span>I have this type of situation where I had a nested </span><code>transform</code><span> like in my example, and I&apos;m now trying to re-write it using your approach</span></div><div data-t="luxbock but instead of numbers in a vector, I have a collection of maps where I need to fetch a nested value and then round those up before calling  frequencies"><span class="u" id="1466694081.000804">2016:06:23 15:01:21              luxbock </span><span>but instead of numbers in a vector, I have a collection of maps where I need to fetch a nested value and then round those up before calling </span><code>frequencies</code></div><div data-t="luxbock so I need to start with  MAP-VALS ,  ALL ,  (view inc) , but then I&apos;d need to go back up a level in the selection"><span class="u" id="1466694176.000805">2016:06:23 15:02:56              luxbock </span><span>so I need to start with </span><code>MAP-VALS</code><span>, </span><code>ALL</code><span>, </span><code>(view inc)</code><span>, but then I&apos;d need to go back up a level in the selection</span></div><div data-t="nathanmarz @luxbock: is  transformed  what you&apos;re looking for?
 (transform
  [MAP-VALS
   (transformed ALL inc)
   (view frequencies)
   (subselect MAP-VALS)
   (collect-one (view #(apply max %)))
   ALL]
  (fn [mx e] (/ e mx))
  {:a [1 1 3 4] :b [1 1 2 2 2 3]})
"><span class="u" id="1466694810.000806">2016:06:23 15:13:30           nathanmarz </span><span>@luxbock: is </span><code>transformed</code><span> what you&apos;re looking for?
</span><pre>(transform
  [MAP-VALS
   (transformed ALL inc)
   (view frequencies)
   (subselect MAP-VALS)
   (collect-one (view #(apply max %)))
   ALL]
  (fn [mx e] (/ e mx))
  {:a [1 1 3 4] :b [1 1 2 2 2 3]})
</pre></div><div data-t="luxbock @nathanmarz: yeah it works for my toy example, thanks"><span class="u" id="1466695092.000807">2016:06:23 15:18:12              luxbock </span><span>@nathanmarz: yeah it works for my toy example, thanks</span></div><div data-t="luxbock my actual use case is still a bit more complicated so I need to figure out a few more things"><span class="u" id="1466695107.000808">2016:06:23 15:18:27              luxbock </span><span>my actual use case is still a bit more complicated so I need to figure out a few more things</span></div><div data-t="luxbock does  view  only take one argument? it seems to accept many but I&apos;m not sure if they are doing anything"><span class="u" id="1466695188.000809">2016:06:23 15:19:48              luxbock </span><span>does </span><code>view</code><span> only take one argument? it seems to accept many but I&apos;m not sure if they are doing anything</span></div><div data-t="nathanmarz it only takes one argument"><span class="u" id="1466695269.000810">2016:06:23 15:21:09           nathanmarz </span><span>it only takes one argument</span></div><div data-t="nathanmarz that it doesn&apos;t error with zero or more than one is an implementation artifact"><span class="u" id="1466695278.000811">2016:06:23 15:21:18           nathanmarz </span><span>that it doesn&apos;t error with zero or more than one is an implementation artifact</span></div><div data-t="luxbock what do you think if multiple arguments would use an implicit  comp ?"><span class="u" id="1466695363.000812">2016:06:23 15:22:43              luxbock </span><span>what do you think if multiple arguments would use an implicit </span><code>comp</code><span>?</span></div><div data-t="nathanmarz i think it&apos;s better to be explicit about that"><span class="u" id="1466695442.000813">2016:06:23 15:24:02           nathanmarz </span><span>i think it&apos;s better to be explicit about that</span></div><div data-t="nathanmarz comp  and  view  are completely orthogonal to each other"><span class="u" id="1466695473.000814">2016:06:23 15:24:33           nathanmarz </span><code>comp</code><span> and </span><code>view</code><span> are completely orthogonal to each other</span></div><div data-t="luxbock (view f) (view g) (view h)  is the same as  (view (comp f g h))  right? just making sure I understand how it works"><span class="u" id="1466695532.000815">2016:06:23 15:25:32              luxbock </span><code>(view f) (view g) (view h)</code><span> is the same as </span><code>(view (comp f g h))</code><span> right? just making sure I understand how it works</span></div><div data-t="luxbock EDIT"><span class="u" id="1466695537.000816">2016:06:23 15:25:37              luxbock </span><span>EDIT</span></div><div data-t="nathanmarz i think it would be  (comp h g f)"><span class="u" id="1466695570.000819">2016:06:23 15:26:10           nathanmarz </span><span>i think it would be </span><code>(comp h g f)</code></div><div data-t="luxbock ah right"><span class="u" id="1466695576.000820">2016:06:23 15:26:16              luxbock </span><span>ah right</span></div><div data-t="luxbock https://gist.github.com/luxbock/99645147579aee4812ac9870efa9bb4a"><span class="u" id="1466698833.000821">2016:06:23 16:20:33              luxbock </span><a href="https://gist.github.com/luxbock/99645147579aee4812ac9870efa9bb4a">https://gist.github.com/luxbock/99645147579aee4812ac9870efa9bb4a</a></div><div data-t="luxbock are there any noticeable anti-patterns in here?"><span class="u" id="1466698839.000822">2016:06:23 16:20:39              luxbock </span><span>are there any noticeable anti-patterns in here?</span></div><div data-t="codonnell @luxbock: you could use  (.intValue (double 12.543))  instead of the string business if that&apos;s clojure"><span class="u" id="1466700581.000823">2016:06:23 16:49:41            codonnell </span><span>@luxbock: you could use </span><code>(.intValue (double 12.543))</code><span> instead of the string business if that&apos;s clojure</span></div><div data-t="nathanmarz @luxbock: you should make the transform function argument for  transformed  static – otherwise it can&apos;t inline cache"><span class="u" id="1466700670.000824">2016:06:23 16:51:10           nathanmarz </span><span>@luxbock: you should make the transform function argument for </span><code>transformed</code><span> static – otherwise it can&apos;t inline cache</span></div><div data-t="nathanmarz factor it into a  defn"><span class="u" id="1466700687.000825">2016:06:23 16:51:27           nathanmarz </span><span>factor it into a </span><code>defn</code></div><div data-t="luxbock @codonnell: yeah good point"><span class="u" id="1466700719.000826">2016:06:23 16:51:59              luxbock </span><span>@codonnell: yeah good point</span></div><div data-t="nathanmarz that&apos;s the only case in specter where  anonymous functions to a navigator won&apos;t factor automatically"><span class="u" id="1466700740.000827">2016:06:23 16:52:20           nathanmarz </span><span>that&apos;s the only case in specter where  anonymous functions to a navigator won&apos;t factor automatically</span></div><div data-t="luxbock @nathanmarz: ah, why is that?"><span class="u" id="1466700763.000828">2016:06:23 16:52:43              luxbock </span><span>@nathanmarz: ah, why is that?</span></div><div data-t="luxbock that&apos;s a good thing to know"><span class="u" id="1466700788.000829">2016:06:23 16:53:08              luxbock </span><span>that&apos;s a good thing to know</span></div><div data-t="nathanmarz it would be possible to re-engineer transformed to do so, but that will be a lot of work"><span class="u" id="1466700822.000830">2016:06:23 16:53:42           nathanmarz </span><span>it would be possible to re-engineer transformed to do so, but that will be a lot of work</span></div><div data-t="luxbock is it generally true that I want to do as much of the work in the selector as possible?"><span class="u" id="1466700879.000831">2016:06:23 16:54:39              luxbock </span><span>is it generally true that I want to do as much of the work in the selector as possible?</span></div><div data-t="luxbock rather than nesting in another call to  transform"><span class="u" id="1466700897.000832">2016:06:23 16:54:57              luxbock </span><span>rather than nesting in another call to </span><code>transform</code></div><div data-t="nathanmarz I find that&apos;s generally more elegant"><span class="u" id="1466701017.000833">2016:06:23 16:56:57           nathanmarz </span><span>I find that&apos;s generally more elegant</span></div><div data-t="luxbock is there an easier way to do this:
 (transform [(collect-one :a :b :c) (view (comp :d :b :a))] + {:a {:b {:c 1 :d 2}}})  ?"><span class="u" id="1466701162.000834">2016:06:23 16:59:22              luxbock </span><span>is there an easier way to do this:
</span><code>(transform [(collect-one :a :b :c) (view (comp :d :b :a))] + {:a {:b {:c 1 :d 2}}})</code><span> ?</span></div><div data-t="nathanmarz (reduce + (select [:a :b (multi-path :c :d)] {:a {:b {:c 1 :d 2}}})"><span class="u" id="1466701280.000835">2016:06:23 17:01:20           nathanmarz </span><code>(reduce + (select [:a :b (multi-path :c :d)] {:a {:b {:c 1 :d 2}}})</code></div><div data-t="nathanmarz or in 0.12.0  (reduce + (traverse [:a :b (multi-path :c :d)] {:a {:b {:c 1 :d 2}}})"><span class="u" id="1466701306.000836">2016:06:23 17:01:46           nathanmarz </span><span>or in 0.12.0 </span><code>(reduce + (traverse [:a :b (multi-path :c :d)] {:a {:b {:c 1 :d 2}}})</code></div><div data-t="nathanmarz don&apos;t know if that&apos;s easier"><span class="u" id="1466701311.000837">2016:06:23 17:01:51           nathanmarz </span><span>don&apos;t know if that&apos;s easier</span></div><div data-t="codonnell I think it&apos;s clearer"><span class="u" id="1466701319.000838">2016:06:23 17:01:59            codonnell </span><span>I think it&apos;s clearer</span></div><div data-t="codonnell comp feels unnatural for accessing nested maps, because the keys have to be backwards"><span class="u" id="1466701339.000839">2016:06:23 17:02:19            codonnell </span><span>comp feels unnatural for accessing nested maps, because the keys have to be backwards</span></div><div data-t="luxbock yeah I like the  traverse  one"><span class="u" id="1466701535.000840">2016:06:23 17:05:35              luxbock </span><span>yeah I like the </span><code>traverse</code><span> one</span></div><div data-t="luxbock one problem that I run into with these large selectors is that they break the cider debugger"><span class="u" id="1466701570.000841">2016:06:23 17:06:10              luxbock </span><span>one problem that I run into with these large selectors is that they break the cider debugger</span></div><div data-t="luxbock &quot;Method code too large!&quot;"><span class="u" id="1466701581.000842">2016:06:23 17:06:21              luxbock </span><span>&quot;Method code too large!&quot;</span></div><div data-t="luxbock running  macroexpand-all  on the  transform  I can see why"><span class="u" id="1466701629.000843">2016:06:23 17:07:09              luxbock </span><span>running </span><code>macroexpand-all</code><span> on the </span><code>transform</code><span> I can see why</span></div><div data-t="nathanmarz that&apos;s the inline caching implementation you&apos;re seeing"><span class="u" id="1466701753.000844">2016:06:23 17:09:13           nathanmarz </span><span>that&apos;s the inline caching implementation you&apos;re seeing</span></div><div data-t="nathanmarz odd that cider would have a limit like that"><span class="u" id="1466701770.000845">2016:06:23 17:09:30           nathanmarz </span><span>odd that cider would have a limit like that</span></div><div data-t="luxbock I benchmarked my  specter  implementation of a function vs a transducer / vanillla core version of the same function"><span class="u" id="1466705803.000846">2016:06:23 18:16:43              luxbock </span><span>I benchmarked my </span><code>specter</code><span> implementation of a function vs a transducer / vanillla core version of the same function</span></div><div data-t="luxbock https://gist.github.com/luxbock/29092fd7357b3932eddfa7ee0df98d46"><span class="u" id="1466705805.000847">2016:06:23 18:16:45              luxbock </span><a href="https://gist.github.com/luxbock/29092fd7357b3932eddfa7ee0df98d46">https://gist.github.com/luxbock/29092fd7357b3932eddfa7ee0df98d46</a></div><div data-t="luxbock results are quite close speed wise but in this case I think I prefer the core version slightly for I think it&apos;s easier to go and modify to change its behavior"><span class="u" id="1466705881.000848">2016:06:23 18:18:01              luxbock </span><span>results are quite close speed wise but in this case I think I prefer the core version slightly for I think it&apos;s easier to go and modify to change its behavior</span></div><div data-t="luxbock for example I actually prefer to have the  (filter filter-fn)  happen between the two map-steps, and I can&apos;t think off the top of my head how I&apos;d need to modify the selector to accomplish this"><span class="u" id="1466706092.000850">2016:06:23 18:21:32              luxbock </span><span>for example I actually prefer to have the </span><code>(filter filter-fn)</code><span> happen between the two map-steps, and I can&apos;t think off the top of my head how I&apos;d need to modify the selector to accomplish this</span></div><div data-t="nathanmarz you probably want a new pathed navigator"><span class="u" id="1466706443.000851">2016:06:23 18:27:23           nathanmarz </span><span>you probably want a new pathed navigator</span></div><div data-t="nathanmarz selectview"><span class="u" id="1466706446.000852">2016:06:23 18:27:26           nathanmarz </span><code>selectview</code></div><div data-t="nathanmarz then it would look like:
 (defn round-frequencies
  [iso-map find-size round-fn filter-fn]
  (transform [MAP-VALS
              (selectview [ALL (view find-size) (view round-fn) (pred filter-fn)])
              (view frequencies)
              (transformed
                [(subselect MAP-VALS)
                 (collect-one (view #(apply + %)))
                 ALL]
                revdiv)]
    #(into (sorted-map)
       (keep (fn [[k v]]
               (when (&gt; v 1/100)
                 [k (* 100 v)])))
       %)
    iso-map))
"><span class="u" id="1466706460.000853">2016:06:23 18:27:40           nathanmarz </span><span>then it would look like:
</span><pre>(defn round-frequencies
  [iso-map find-size round-fn filter-fn]
  (transform [MAP-VALS
              (selectview [ALL (view find-size) (view round-fn) (pred filter-fn)])
              (view frequencies)
              (transformed
                [(subselect MAP-VALS)
                 (collect-one (view #(apply + %)))
                 ALL]
                revdiv)]
    #(into (sorted-map)
       (keep (fn [[k v]]
               (when (&gt; v 1/100)
                 [k (* 100 v)])))
       %)
    iso-map))
</pre></div><div data-t="luxbock thanks, yeah I hadn&apos;t seen  selectview  before"><span class="u" id="1466706513.000854">2016:06:23 18:28:33              luxbock </span><span>thanks, yeah I hadn&apos;t seen </span><code>selectview</code><span> before</span></div><div data-t="nathanmarz it doesn&apos;t exist"><span class="u" id="1466706518.000855">2016:06:23 18:28:38           nathanmarz </span><span>it doesn&apos;t exist</span></div><div data-t="nathanmarz but it would be easy to make"><span class="u" id="1466706524.000856">2016:06:23 18:28:44           nathanmarz </span><span>but it would be easy to make</span></div><div data-t="luxbock oh"><span class="u" id="1466706533.000857">2016:06:23 18:28:53              luxbock </span><span>oh</span></div><div data-t="luxbock my third version which uses  (transform MAP-VALS ...)  instead of  (into {} ...)  is the fastest of them all"><span class="u" id="1466706712.000858">2016:06:23 18:31:52              luxbock </span><span>my third version which uses </span><code>(transform MAP-VALS ...)</code><span> instead of </span><code>(into {} ...)</code><span> is the fastest of them all</span></div><div data-t="luxbock also I realized I was doing some uneccessary extra work in the vanilla core version"><span class="u" id="1466706727.000859">2016:06:23 18:32:07              luxbock </span><span>also I realized I was doing some uneccessary extra work in the vanilla core version</span></div><div data-t="nathanmarz If #117 was implemented then it could be simplified further"><span class="u" id="1466706931.000860">2016:06:23 18:35:31           nathanmarz </span><span>If #117 was implemented then it could be simplified further</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/issues/117"><span class="u" id="1466706933.000861">2016:06:23 18:35:33           nathanmarz </span><a href="https://github.com/nathanmarz/specter/issues/117">https://github.com/nathanmarz/specter/issues/117</a></div><div data-t="luxbock yeah I think that&apos;d be a really useful feature"><span class="u" id="1466707275.000863">2016:06:23 18:41:15              luxbock </span><span>yeah I think that&apos;d be a really useful feature</span></div><div data-t="codonnell @luxbock: are you using  comp  so your maps and filters are composing as transducers rather than generating intermediate sequences?"><span class="u" id="1466707317.000864">2016:06:23 18:41:57            codonnell </span><span>@luxbock: are you using </span><code>comp</code><span> so your maps and filters are composing as transducers rather than generating intermediate sequences?</span></div><div data-t="codonnell rather than  -&gt;&gt;"><span class="u" id="1466707326.000865">2016:06:23 18:42:06            codonnell </span><span>rather than </span><code>-&gt;&gt;</code></div><div data-t="luxbock @codonnell: yep"><span class="u" id="1466707334.000866">2016:06:23 18:42:14              luxbock </span><span>@codonnell: yep</span></div><div data-t="codonnell have you checked how much of a performance impact that has?"><span class="u" id="1466707376.000867">2016:06:23 18:42:56            codonnell </span><span>have you checked how much of a performance impact that has?</span></div><div data-t="luxbock no, but I imagine it&apos;s a fair amount, as the bulk of the work is done there"><span class="u" id="1466707446.000868">2016:06:23 18:44:06              luxbock </span><span>no, but I imagine it&apos;s a fair amount, as the bulk of the work is done there</span></div><div data-t="luxbock about to head to bed but I&apos;ll run that out of curiosity before I log off"><span class="u" id="1466707463.000869">2016:06:23 18:44:23              luxbock </span><span>about to head to bed but I&apos;ll run that out of curiosity before I log off</span></div><div data-t="codonnell I&apos;d love to hear the results; I&apos;m curious"><span class="u" id="1466707886.000873">2016:06:23 18:51:26            codonnell </span><span>I&apos;d love to hear the results; I&apos;m curious</span></div><div data-t="nathanmarz @codonnell: specter has a benchmark for that"><span class="u" id="1466712681.000874">2016:06:23 20:11:21           nathanmarz </span><span>@codonnell: specter has a benchmark for that</span></div><div data-t="nathanmarz Benchmark: even :a values from sequence of maps (500000 iterations)

Avg(ms)		vs best		Code
93.478 		 1.00 		 (into [] xf data)
113.85 		 1.22 		 (select [ALL :a even?] data)
156.08 		 1.67 		 (into [] (comp (map :a) (filter even?)) data)
253.74 		 2.71 		 (-&gt;&gt; data (mapv :a) (filter even?) doall)
"><span class="u" id="1466712685.000875">2016:06:23 20:11:25           nathanmarz </span><pre>Benchmark: even :a values from sequence of maps (500000 iterations)

Avg(ms)		vs best		Code
93.478 		 1.00 		 (into [] xf data)
113.85 		 1.22 		 (select [ALL :a even?] data)
156.08 		 1.67 		 (into [] (comp (map :a) (filter even?)) data)
253.74 		 2.71 		 (-&gt;&gt; data (mapv :a) (filter even?) doall)
</pre></div><div data-t="nathanmarz note that  comp  with more than two arguments will slow things down a lot"><span class="u" id="1466712860.000876">2016:06:23 20:14:20           nathanmarz </span><span>note that </span><code>comp</code><span> with more than two arguments will slow things down a lot</span></div><div data-t="nathanmarz Benchmark: even :a values from sequence of maps (500000 iterations)

Avg(ms)		vs best		Code
155.98 		 1.00 		 (into [] (comp (map :a) (filter even?)) data)
164.82 		 1.06 		 (into [] xf data)
203.00 		 1.30 		 (select [ALL :a even? even? even?] data)
331.59 		 2.13 		 (into [] (comp (map :a) (filter even?) (filter even?) (filter even?)) data)
525.34 		 3.37 		 (-&gt;&gt; data (mapv :a) (filter even?) (filter even?) (filter even?) doall)
"><span class="u" id="1466712864.000877">2016:06:23 20:14:24           nathanmarz </span><pre>Benchmark: even :a values from sequence of maps (500000 iterations)

Avg(ms)		vs best		Code
155.98 		 1.00 		 (into [] (comp (map :a) (filter even?)) data)
164.82 		 1.06 		 (into [] xf data)
203.00 		 1.30 		 (select [ALL :a even? even? even?] data)
331.59 		 2.13 		 (into [] (comp (map :a) (filter even?) (filter even?) (filter even?)) data)
525.34 		 3.37 		 (-&gt;&gt; data (mapv :a) (filter even?) (filter even?) (filter even?) doall)
</pre></div><div data-t="nathanmarz here  xf  is  (comp (map :a) (filter even?) (filter even?) (filter even?))"><span class="u" id="1466712884.000878">2016:06:23 20:14:44           nathanmarz </span><span>here </span><code>xf</code><span> is </span><code>(comp (map :a) (filter even?) (filter even?) (filter even?))</code></div><div data-t="codonnell wow, that&apos;s a huge slowdown"><span class="u" id="1466713107.000881">2016:06:23 20:18:27            codonnell </span><span>wow, that&apos;s a huge slowdown</span></div><div data-t="nathanmarz https://github.com/clojure/clojure/blob/clojure-1.7.0/src/clj/clojure/core.clj#L2426"><span class="u" id="1466713171.000883">2016:06:23 20:19:31           nathanmarz </span><a href="https://github.com/clojure/clojure/blob/clojure-1.7.0/src/clj/clojure/core.clj#L2426">https://github.com/clojure/clojure/blob/clojure-1.7.0/src/clj/clojure/core.clj#L2426</a></div><div data-t="nathanmarz it slows down because it does a reduce after more than two args"><span class="u" id="1466713211.000887">2016:06:23 20:20:11           nathanmarz </span><span>it slows down because it does a reduce after more than two args</span></div><div data-t="nathanmarz if the implementation of  comp  was unrolled up to 20 arguments it would work much better"><span class="u" id="1466713235.000888">2016:06:23 20:20:35           nathanmarz </span><span>if the implementation of </span><code>comp</code><span> was unrolled up to 20 arguments it would work much better</span></div><div data-t="codonnell interesting"><span class="u" id="1466713673.000889">2016:06:23 20:27:53            codonnell </span><span>interesting</span></div><div data-t="codonnell I wonder why it isn&apos;t unrolled like that; other functions in core certainly are."><span class="u" id="1466713692.000890">2016:06:23 20:28:12            codonnell </span><span>I wonder why it isn&apos;t unrolled like that; other functions in core certainly are.</span></div><div data-t="nathanmarz there&apos;s a bunch that aren&apos;t:  http://dev.clojure.org/jira/browse/CLJ-731"><span class="u" id="1466713727.000891">2016:06:23 20:28:47           nathanmarz </span><span>there&apos;s a bunch that aren&apos;t: </span><a href="http://dev.clojure.org/jira/browse/CLJ-731">http://dev.clojure.org/jira/browse/CLJ-731</a></div><div data-t="codonnell Perhaps they&apos;ve assumed that people aren&apos;t going to be calling  comp  over and over like in the benchmark."><span class="u" id="1466713729.000892">2016:06:23 20:28:49            codonnell </span><span>Perhaps they&apos;ve assumed that people aren&apos;t going to be calling </span><code>comp</code><span> over and over like in the benchmark.</span></div><div data-t="nathanmarz well it seems like with transducers it would be a common pattern to do it inline like that"><span class="u" id="1466713768.000893">2016:06:23 20:29:28           nathanmarz </span><span>well it seems like with transducers it would be a common pattern to do it inline like that</span></div><div data-t="codonnell that&apos;s true, though transducers weren&apos;t in existence when that patch was submitted"><span class="u" id="1466713842.000894">2016:06:23 20:30:42            codonnell </span><span>that&apos;s true, though transducers weren&apos;t in existence when that patch was submitted</span></div><div data-t="aengelberg @nathanmarz It seems like the  multi-transform  functionality of doing a variety of operations in a single transform is still &quot;doable&quot; with  transform , if you collect values along the way and use that to dispatch on some operation in the transform fn."><span class="u" id="1466718152.000895">2016:06:23 21:42:32           aengelberg </span><span>@nathanmarz It seems like the </span><code>multi-transform</code><span> functionality of doing a variety of operations in a single transform is still &quot;doable&quot; with </span><code>transform</code><span>, if you collect values along the way and use that to dispatch on some operation in the transform fn.</span></div><div data-t="aengelberg it&apos;s probably not as performant as multi-transform but might be fun to add to your benchmark."><span class="u" id="1466718162.000896">2016:06:23 21:42:42           aengelberg </span><span>it&apos;s probably not as performant as multi-transform but might be fun to add to your benchmark.</span></div><div data-t="nathanmarz @aengelberg: true but it&apos;s a bit convoluted and definitely would be less performant"><span class="u" id="1466719283.000897">2016:06:23 22:01:23           nathanmarz </span><span>@aengelberg: true but it&apos;s a bit convoluted and definitely would be less performant</span></div><div data-t="nathanmarz the cases I consider for the benchmarks are the fastest impls, the most concise impls, and the most idiomatic impls"><span class="u" id="1466719316.000898">2016:06:23 22:01:56           nathanmarz </span><span>the cases I consider for the benchmarks are the fastest impls, the most concise impls, and the most idiomatic impls</span></div><div data-t="conaw If want to use specter to replace the nth value in deeply nested array, is there a better way to navigate to that value than using (srange x (inc x))"><span class="u" id="1466736296.000902">2016:06:24 02:44:56                conaw </span><span>If want to use specter to replace the nth value in deeply nested array, is there a better way to navigate to that value than using (srange x (inc x))</span></div><div data-t="conaw Ideally I’d like to be able to transform the value there, or put in default if it doesn’t exist"><span class="u" id="1466737638.000904">2016:06:24 03:07:18                conaw </span><span>Ideally I’d like to be able to transform the value there, or put in default if it doesn’t exist</span></div><div data-t="codonnell @conaw: there&apos;s a custom  nth-elt  navigator in the wiki at  https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav"><span class="u" id="1466737749.000905">2016:06:24 03:09:09            codonnell </span><span>@conaw: there&apos;s a custom </span><code>nth-elt</code><span> navigator in the wiki at </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav">https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav</a></div><div data-t="codonnell I don&apos;t know of a better way to do it, personally"><span class="u" id="1466737760.000907">2016:06:24 03:09:20            codonnell </span><span>I don&apos;t know of a better way to do it, personally</span></div><div data-t="conaw awesome"><span class="u" id="1466737787.000908">2016:06:24 03:09:47                conaw </span><span>awesome</span></div><div data-t="codonnell under the hood it does basically what you said"><span class="u" id="1466737804.000909">2016:06:24 03:10:04            codonnell </span><span>under the hood it does basically what you said</span></div><div data-t="codonnell if you want default element behavior, you could modify it to do that"><span class="u" id="1466737832.000910">2016:06:24 03:10:32            codonnell </span><span>if you want default element behavior, you could modify it to do that</span></div><div data-t="aengelberg @conaw by array do you mean vector? if so, I believe  (keypath 3)  works"><span class="u" id="1466739363.000911">2016:06:24 03:36:03           aengelberg </span><span>@conaw by array do you mean vector? if so, I believe </span><code>(keypath 3)</code><span> works</span></div><div data-t="conaw yeah, I’m actually working with a matrix, so words slipped"><span class="u" id="1466739399.000912">2016:06:24 03:36:39                conaw </span><span>yeah, I’m actually working with a matrix, so words slipped</span></div><div data-t="conaw thanks a bunch"><span class="u" id="1466739429.000913">2016:06:24 03:37:09                conaw </span><span>thanks a bunch</span></div><div data-t="aengelberg np"><span class="u" id="1466739438.000914">2016:06:24 03:37:18           aengelberg </span><span>np</span></div><div data-t="conaw So I can reasonably do a (if-path (keypath 4) LAST) right?"><span class="u" id="1466739582.000915">2016:06:24 03:39:42                conaw </span><span>So I can reasonably do a (if-path (keypath 4) LAST) right?</span></div><div data-t="conaw or I would do (if-path (keypath 4) (keypath 4) LAST)"><span class="u" id="1466739640.000916">2016:06:24 03:40:40                conaw </span><span>or I would do (if-path (keypath 4) (keypath 4) LAST)</span></div><div data-t="conaw or rather END"><span class="u" id="1466739693.000917">2016:06:24 03:41:33                conaw </span><span>or rather END</span></div><div data-t="conaw nvm (if-path (must 3) (keypath 3) END)"><span class="u" id="1466739854.000918">2016:06:24 03:44:14                conaw </span><span>nvm (if-path (must 3) (keypath 3) END)</span></div><div data-t="conaw ok, here’s a question, it seems that I can substitute a value into a vector using setval , but if I want to use sp/END i have to have it wrapped in a seqable, so couldn’t insert it in in a flat way, is there a way I might get around that
 (setval [(sp/if-path (sp/must 3) (sp/keypath 3) sp/END)] :newd  [:a :b :c :dd])

=&gt;  [:a :b :c :newd]

"><span class="u" id="1466740877.000919">2016:06:24 04:01:17                conaw </span><span>ok, here’s a question, it seems that I can substitute a value into a vector using setval , but if I want to use sp/END i have to have it wrapped in a seqable, so couldn’t insert it in in a flat way, is there a way I might get around that
</span><pre>(setval [(sp/if-path (sp/must 3) (sp/keypath 3) sp/END)] :newd  [:a :b :c :dd])

=&gt;  [:a :b :c :newd]

</pre></div><div data-t="conaw (setval [(sp/if-path (sp/must 3) (sp/keypath 3) sp/END)] [:newd]  [:a :b :c])
=&gt; [:a :b :c :newd]"><span class="u" id="1466740910.000920">2016:06:24 04:01:50                conaw </span><pre>(setval [(sp/if-path (sp/must 3) (sp/keypath 3) sp/END)] [:newd]  [:a :b :c])
=&gt; [:a :b :c :newd]</pre></div><div data-t="conaw basically, in assoc, if I assoc to the size of a vector, I conj onto the end, I’m looking for a similar behavior here"><span class="u" id="1466741162.000921">2016:06:24 04:06:02                conaw </span><span>basically, in assoc, if I assoc to the size of a vector, I conj onto the end, I’m looking for a similar behavior here</span></div><div data-t="nathanmarz @conaw: I think you can do  [END (keypath 0)]"><span class="u" id="1466742796.000922">2016:06:24 04:33:16           nathanmarz </span><span>@conaw: I think you can do </span><code>[END (keypath 0)]</code></div><div data-t="luxbock @codonnell: sorry for disappearing last night, I ran the benchmark with  (sequence (comp ...) %)  substituted for  (-&gt;&gt; % ...)   and it actually came out faster, 97ms vs 110 ms"><span class="u" id="1466754875.000926">2016:06:24 07:54:35              luxbock </span><span>@codonnell: sorry for disappearing last night, I ran the benchmark with </span><code>(sequence (comp ...) %)</code><span> substituted for </span><code>(-&gt;&gt; % ...)</code><span>  and it actually came out faster, 97ms vs 110 ms</span></div><div data-t="luxbock that&apos;s really surprising to me"><span class="u" id="1466754895.000927">2016:06:24 07:54:55              luxbock </span><span>that&apos;s really surprising to me</span></div><div data-t="aengelberg Does  (comp ...)  take some time to initially build up the transducer?"><span class="u" id="1466787726.000934">2016:06:24 17:02:06           aengelberg </span><span>Does </span><code>(comp ...)</code><span> take some time to initially build up the transducer?</span></div><div data-t="nathanmarz @aengelberg: yes, most noticeable when operating on relatively little data"><span class="u" id="1466791304.000936">2016:06:24 18:01:44           nathanmarz </span><span>@aengelberg: yes, most noticeable when operating on relatively little data</span></div><div data-t="nathanmarz @aengelberg: the benchmarks I pasted before show a large performance difference between &quot;precompiling&quot; the transducer and doing it inline"><span class="u" id="1466791382.000937">2016:06:24 18:03:02           nathanmarz </span><span>@aengelberg: the benchmarks I pasted before show a large performance difference between &quot;precompiling&quot; the transducer and doing it inline</span></div><div data-t="luxbock I have a nested data-structure and I&apos;d like to collect all lists from it, and then return a map with the original data-structure as one value and a vector of all of the lists as another"><span class="u" id="1466868126.000954">2016:06:25 15:22:06              luxbock </span><span>I have a nested data-structure and I&apos;d like to collect all lists from it, and then return a map with the original data-structure as one value and a vector of all of the lists as another</span></div><div data-t="luxbock am I right in assuming I can&apos;t use  walker  for this? since it just edits the matched values in-place"><span class="u" id="1466868145.000955">2016:06:25 15:22:25              luxbock </span><span>am I right in assuming I can&apos;t use </span><code>walker</code><span> for this? since it just edits the matched values in-place</span></div><div data-t="nathanmarz @luxbock:  walker  will not traverse into matched elements, so as long as you don&apos;t need that it sounds like it should work"><span class="u" id="1466869277.000956">2016:06:25 15:41:17           nathanmarz </span><span>@luxbock: </span><code>walker</code><span> will not traverse into matched elements, so as long as you don&apos;t need that it sounds like it should work</span></div><div data-t="luxbock @nathanmarz: yeah thanks, I got it working"><span class="u" id="1466875428.000957">2016:06:25 17:23:48              luxbock </span><span>@nathanmarz: yeah thanks, I got it working</span></div><div data-t="conaw Lets say I have a tree, and I want to select all of the nodes n levels away from the root following a particular path, is there a smart way to define a navigator that would repeat n times?"><span class="u" id="1466996625.000984">2016:06:27 03:03:45                conaw </span><span>Lets say I have a tree, and I want to select all of the nodes n levels away from the root following a particular path, is there a smart way to define a navigator that would repeat n times?</span></div><div data-t="conaw (select [(repeat-path [:children ALL] 4)] tree)"><span class="u" id="1466996731.000985">2016:06:27 03:05:31                conaw </span><pre>(select [(repeat-path [:children ALL] 4)] tree)</pre></div><div data-t="conaw I’ve noticed some talk of stateful navigators in here but wasn’t paying close attention, is this a case for that?"><span class="u" id="1466996862.000986">2016:06:27 03:07:42                conaw </span><span>I’ve noticed some talk of stateful navigators in here but wasn’t paying close attention, is this a case for that?</span></div><div data-t="conaw https://github.com/nathanmarz/specter/wiki/List-of-Macros#variable-pathed-nav"><span class="u" id="1466997001.000987">2016:06:27 03:10:01                conaw </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#variable-pathed-nav">https://github.com/nathanmarz/specter/wiki/List-of-Macros#variable-pathed-nav</a></div><div data-t="conaw ?"><span class="u" id="1466997002.000989">2016:06:27 03:10:02                conaw </span><span>?</span></div><div data-t="conaw (declarepath deeper [i])

(defpathedfn deeper [i]
  (if (= 0 i)
    (keypath i)
    (deeper (dec i))))


(select [(deeper 1)] [0 1 2 3])
"><span class="u" id="1466998450.000990">2016:06:27 03:34:10                conaw </span><pre>(declarepath deeper [i])

(defpathedfn deeper [i]
  (if (= 0 i)
    (keypath i)
    (deeper (dec i))))


(select [(deeper 1)] [0 1 2 3])
</pre></div><div data-t="conaw ok, found an answer  (declarepath repeat-path [walk-path end-path i])

(defpathedfn repeat-path [walk-path end-path i]
  (if (= 0 i)
    end-path
    [walk-path (repeat-path walk-path end-path (dec i))]))


(select [(repeat-path [:node/_children ALL] :db/id 3)] ptest)
"><span class="u" id="1466999247.000991">2016:06:27 03:47:27                conaw </span><span>ok, found an answer </span><pre>(declarepath repeat-path [walk-path end-path i])

(defpathedfn repeat-path [walk-path end-path i]
  (if (= 0 i)
    end-path
    [walk-path (repeat-path walk-path end-path (dec i))]))


(select [(repeat-path [:node/_children ALL] :db/id 3)] ptest)
</pre></div><div data-t="conaw other question, Figwheel doesn’t seem to like that I am declaring a path and then redefining it this way,  Figwheel: Compile Warning - repeat-path at line 105 is being replaced at line 107   anything to be done about this?"><span class="u" id="1467001801.000992">2016:06:27 04:30:01                conaw </span><span>other question, Figwheel doesn’t seem to like that I am declaring a path and then redefining it this way, </span><pre>Figwheel: Compile Warning - repeat-path at line 105 is being replaced at line 107 </pre><span> anything to be done about this?</span></div><div data-t="nathanmarz @conaw: don&apos;t call  declarepath  there, that&apos;s only for usage with  providepath"><span class="u" id="1467021388.000999">2016:06:27 09:56:28           nathanmarz </span><span>@conaw: don&apos;t call </span><code>declarepath</code><span> there, that&apos;s only for usage with </span><code>providepath</code></div><div data-t="nathanmarz @conaw: the  defpathedfn  call works fine without it"><span class="u" id="1467021399.001000">2016:06:27 09:56:39           nathanmarz </span><span>@conaw: the </span><code>defpathedfn</code><span> call works fine without it</span></div><div data-t="conaw yup, discovered that, my bad not updating"><span class="u" id="1467021426.001001">2016:06:27 09:57:06                conaw </span><span>yup, discovered that, my bad not updating</span></div><div data-t="conaw This has made my life so much easier by the way.  Today was an absolute joy because of it.  Thank you."><span class="u" id="1467021501.001002">2016:06:27 09:58:21                conaw </span><span>This has made my life so much easier by the way.  Today was an absolute joy because of it.  Thank you.</span></div><div data-t="nathanmarz good to hear"><span class="u" id="1467021518.001003">2016:06:27 09:58:38           nathanmarz </span><span>good to hear</span></div><div data-t="jjcomer Has anyone had any issues using specter in an AOT’d uberjar? I’m using it to pull data out of my immutant request. It works fine when running with lein run, but when I run the uberjar, it errors when using the request with: java.lang.IllegalArgumentException: No implementation of method: :get_cell of protocol: #&apos;com.rpl.specter.impl/PMutableCell found for class: clojure.lang.Var$Unbound"><span class="u" id="1467046674.001008">2016:06:27 16:57:54              jjcomer </span><span>Has anyone had any issues using specter in an AOT’d uberjar? I’m using it to pull data out of my immutant request. It works fine when running with lein run, but when I run the uberjar, it errors when using the request with: java.lang.IllegalArgumentException: No implementation of method: :get_cell of protocol: #&apos;com.rpl.specter.impl/PMutableCell found for class: clojure.lang.Var$Unbound</span></div><div data-t="nathanmarz a few people have reported similar issues, I haven&apos;t looked into it"><span class="u" id="1467047077.001009">2016:06:27 17:04:37           nathanmarz </span><span>a few people have reported similar issues, I haven&apos;t looked into it</span></div><div data-t="jjcomer Immutant uses a immutant.web.internal.ring.LazyMap for its requests"><span class="u" id="1467047337.001010">2016:06:27 17:08:57              jjcomer </span><span>Immutant uses a immutant.web.internal.ring.LazyMap for its requests</span></div><div data-t="nathanmarz I&apos;m not seeing the relevance of that"><span class="u" id="1467047576.001011">2016:06:27 17:12:56           nathanmarz </span><span>I&apos;m not seeing the relevance of that</span></div><div data-t="jjcomer Nor I  🙂"><span class="u" id="1467048206.001012">2016:06:27 17:23:26              jjcomer </span><span>Nor I </span><b>🙂</b></div><div data-t="adambros i can confirm that error, although it came up from something other than immutant"><span class="u" id="1467060361.001017">2016:06:27 20:46:01             adambros </span><span>i can confirm that error, although it came up from something other than immutant</span></div><div data-t="nathanmarz @adambros @jjcomer with what versions of clojure/specter did you see those errors?"><span class="u" id="1467060946.001019">2016:06:27 20:55:46           nathanmarz </span><span>@adambros @jjcomer with what versions of clojure/specter did you see those errors?</span></div><div data-t="adambros iirc clj 1.8 and specter 0.11.0"><span class="u" id="1467060987.001020">2016:06:27 20:56:27             adambros </span><span>iirc clj 1.8 and specter 0.11.0</span></div><div data-t="adambros correction: specter 0.11.2"><span class="u" id="1467061022.001021">2016:06:27 20:57:02             adambros </span><span>correction: specter 0.11.2</span></div><div data-t="nathanmarz cool, thanks"><span class="u" id="1467061047.001022">2016:06:27 20:57:27           nathanmarz </span><span>cool, thanks</span></div><div data-t="adambros im pretty sure i didnt want unbound vars in my data, but it would fail on that if i typo’d a symbol"><span class="u" id="1467061114.001023">2016:06:27 20:58:34             adambros </span><span>im pretty sure i didnt want unbound vars in my data, but it would fail on that if i typo’d a symbol</span></div><div data-t="nathanmarz oh I think I know what the problem might be"><span class="u" id="1467061378.001024">2016:06:27 21:02:58           nathanmarz </span><span>oh I think I know what the problem might be</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/issues/132"><span class="u" id="1467061676.001025">2016:06:27 21:07:56           nathanmarz </span><a href="https://github.com/nathanmarz/specter/issues/132">https://github.com/nathanmarz/specter/issues/132</a></div><div data-t="nathanmarz @jjcomer @adambros do you get the error with specter 0.10.0?"><span class="u" id="1467061708.001027">2016:06:27 21:08:28           nathanmarz </span><span>@jjcomer @adambros do you get the error with specter 0.10.0?</span></div><div data-t="adambros i dont, which is why i havent upgraded yet"><span class="u" id="1467061726.001028">2016:06:27 21:08:46             adambros </span><span>i dont, which is why i havent upgraded yet</span></div><div data-t="nathanmarz ok, that supports my hypothesis"><span class="u" id="1467061757.001029">2016:06:27 21:09:17           nathanmarz </span><span>ok, that supports my hypothesis</span></div><div data-t="nathanmarz @adambros @jjcomer I was able to reproduce it and fix it, give 0.12.0-SNAPSHOT a shot and let me know if it fixes it"><span class="u" id="1467063207.001030">2016:06:27 21:33:27           nathanmarz </span><span>@adambros @jjcomer I was able to reproduce it and fix it, give 0.12.0-SNAPSHOT a shot and let me know if it fixes it</span></div><div data-t="nathanmarz just deployed 0.12.0-SNAPSHOT to clojars"><span class="u" id="1467063222.001031">2016:06:27 21:33:42           nathanmarz </span><span>just deployed 0.12.0-SNAPSHOT to clojars</span></div><div data-t="angusiguess @nathanmarz: I built a small repro and just tried with 0.12.0-SNAPSHOT and it worked."><span class="u" id="1467065383.001032">2016:06:27 22:09:43          angusiguess </span><span>@nathanmarz: I built a small repro and just tried with 0.12.0-SNAPSHOT and it worked.</span></div><div data-t="jjcomer @nathanmarz: awesome thanks!"><span class="u" id="1467069865.001036">2016:06:27 23:24:25              jjcomer </span><span>@nathanmarz: awesome thanks!</span></div><div data-t="thomasdeutsch is there a way in specter to delete nil keys from a map?    {nil 1, :b 2}  -&gt;  {:b 2}"><span class="u" id="1467098958.001043">2016:06:28 07:29:18        thomasdeutsch </span><span>is there a way in specter to delete nil keys from a map?   </span><code>{nil 1, :b 2}</code><span> -&gt; </span><code>{:b 2}</code></div><div data-t="codonnell (transform ALL (fn [[k v]] (if (nil? k) nil [k v])) data)  I think. Can&apos;t check as I&apos;m on my phone. "><span class="u" id="1467114445.001049">2016:06:28 11:47:25            codonnell </span><code>(transform ALL (fn [[k v]] (if (nil? k) nil [k v])) data)</code><span> I think. Can&apos;t check as I&apos;m on my phone. </span></div><div data-t="codonnell @thomasdeutsch: ^"><span class="u" id="1467114475.001050">2016:06:28 11:47:55            codonnell </span><span>@thomasdeutsch: ^</span></div><div data-t="codonnell But why not just do  (dissoc m nil) ? "><span class="u" id="1467118946.001051">2016:06:28 13:02:26            codonnell </span><span>But why not just do </span><code>(dissoc m nil)</code><span>? </span></div><div data-t="vikeri Hi, I want to select from a vector using srange. It works well until the index is out of bounds. Can I somehow prevent getting an error and instead return only the elements found? Or is this bad coding practice of some reason? As an example, if I have a vector with three elements and does (srange 0 4) it will throw an error, but instead I would like to get the only three elements found."><span class="u" id="1467122151.001053">2016:06:28 13:55:51               vikeri </span><span>Hi, I want to select from a vector using srange. It works well until the index is out of bounds. Can I somehow prevent getting an error and instead return only the elements found? Or is this bad coding practice of some reason? As an example, if I have a vector with three elements and does (srange 0 4) it will throw an error, but instead I would like to get the only three elements found.</span></div><div data-t="nathanmarz @vikeri: you can use srange-dynamic for that"><span class="u" id="1467123430.001054">2016:06:28 14:17:10           nathanmarz </span><span>@vikeri: you can use srange-dynamic for that</span></div><div data-t="nathanmarz @vikeri
 (defnavconstructor bounded-srange
  [p srange-dynamic]
  [s e]
  (p (fn [aseq]
      (if (&lt; s 0) 0 s))
     (fn [aseq]
      (let [c (count aseq)]
        (if (&gt;= e c) c e)
        ))))
"><span class="u" id="1467123656.001055">2016:06:28 14:20:56           nathanmarz </span><span>@vikeri
</span><pre>(defnavconstructor bounded-srange
  [p srange-dynamic]
  [s e]
  (p (fn [aseq]
      (if (&lt; s 0) 0 s))
     (fn [aseq]
      (let [c (count aseq)]
        (if (&gt;= e c) c e)
        ))))
</pre></div><div data-t="vikeri @nathanmarz: Great! Looks a little like black magic to me since I started looking at specter today. But it worked so I’m happy  🙂"><span class="u" id="1467125020.001056">2016:06:28 14:43:40               vikeri </span><span>@nathanmarz: Great! Looks a little like black magic to me since I started looking at specter today. But it worked so I’m happy </span><b>🙂</b></div><div data-t="vikeri Had to change it to this to fully accomodate my needs:
 (defnavconstructor bounded-srange
                   [p srange-dynamic]
                   [s e]
                   (p (fn [aseq]
                        (let [c (count aseq)]
                          (cond
                            (&lt; s 0) 0
                            (&gt;= s c) c
                            :else s)))
                      (fn [aseq]
                        (let [c (count aseq)]
                          (if (&gt;= e c) c e)
                          ))))
"><span class="u" id="1467125535.001057">2016:06:28 14:52:15               vikeri </span><span>Had to change it to this to fully accomodate my needs:
</span><pre>(defnavconstructor bounded-srange
                   [p srange-dynamic]
                   [s e]
                   (p (fn [aseq]
                        (let [c (count aseq)]
                          (cond
                            (&lt; s 0) 0
                            (&gt;= s c) c
                            :else s)))
                      (fn [aseq]
                        (let [c (count aseq)]
                          (if (&gt;= e c) c e)
                          ))))
</pre></div><div data-t="nathanmarz @vikeri:  defnavconstructor  works like a normal function but also integrates with Specter&apos;s inline caching"><span class="u" id="1467128238.001058">2016:06:28 15:37:18           nathanmarz </span><span>@vikeri: </span><code>defnavconstructor</code><span> works like a normal function but also integrates with Specter&apos;s inline caching</span></div><div data-t="vikeri Alright, I&apos;m sure it makes more sense if I read the docs  😛  . But it seems to be a nifty library, quite useful with a powerful query language for nested data structures."><span class="u" id="1467129676.001062">2016:06:28 16:01:16               vikeri </span><span>Alright, I&apos;m sure it makes more sense if I read the docs </span><b>😛</b><span> . But it seems to be a nifty library, quite useful with a powerful query language for nested data structures.</span></div><div data-t="richiardiandrea Started using specter as well ;)"><span class="u" id="1467987951.001251">2016:07:08 14:25:51      richiardiandrea </span><span>Started using specter as well ;)</span></div><div data-t="nathanmarz cool"><span class="u" id="1467990114.001252">2016:07:08 15:01:54           nathanmarz </span><span>cool</span></div><div data-t="richiardiandrea so first question  😄  let&apos;s say I have a map indexed by a long, but i don&apos;t care about that, I want to navigate to the value"><span class="u" id="1467996215.001254">2016:07:08 16:43:35      richiardiandrea </span><span>so first question </span><b>😄</b><span> let&apos;s say I have a map indexed by a long, but i don&apos;t care about that, I want to navigate to the value</span></div><div data-t="richiardiandrea the  [sp/ALL sp/MAP-VALS ]  path navigates all the keys first, then values"><span class="u" id="1467996256.001255">2016:07:08 16:44:16      richiardiandrea </span><span>the </span><code>[sp/ALL sp/MAP-VALS ]</code><span> path navigates all the keys first, then values</span></div><div data-t="richiardiandrea I&apos;d like to skip keys if possible..."><span class="u" id="1467996278.001256">2016:07:08 16:44:38      richiardiandrea </span><span>I&apos;d like to skip keys if possible...</span></div><div data-t="nathanmarz easier to understand if you show the input/output you&apos;re looking for"><span class="u" id="1467996292.001257">2016:07:08 16:44:52           nathanmarz </span><span>easier to understand if you show the input/output you&apos;re looking for</span></div><div data-t="richiardiandrea {:handles {&quot;booma&quot; {:business {:id 3, :name &quot;&quot;, :twitter-handle &quot;booma&quot;}, :sente-uids [&quot;e8a6a187-1e6b-41d1-aa93-d0912a290f49&quot; &quot;arsassa-1e6b-41d1-aa93-d0912a290f49&quot;]}
           &quot;my-handle&quot; {:business {:id 5, :name &quot;Business&quot;, :twitter-handle &quot;my-handle&quot;}, :sente-uids [&quot;artart27-1e6b-41d1-aa93-d091arsasr49&quot;]}}}
"><span class="u" id="1467996340.001258">2016:07:08 16:45:40      richiardiandrea </span><pre>{:handles {&quot;booma&quot; {:business {:id 3, :name &quot;&quot;, :twitter-handle &quot;booma&quot;}, :sente-uids [&quot;e8a6a187-1e6b-41d1-aa93-d0912a290f49&quot; &quot;arsassa-1e6b-41d1-aa93-d0912a290f49&quot;]}
           &quot;my-handle&quot; {:business {:id 5, :name &quot;Business&quot;, :twitter-handle &quot;my-handle&quot;}, :sente-uids [&quot;artart27-1e6b-41d1-aa93-d091arsasr49&quot;]}}}
</pre></div><div data-t="richiardiandrea I&apos;d like to fetch the inner maps, skipping the string key"><span class="u" id="1467996380.001262">2016:07:08 16:46:20      richiardiandrea </span><span>I&apos;d like to fetch the inner maps, skipping the string key</span></div><div data-t="nathanmarz there&apos;s a lot of inner maps"><span class="u" id="1467996404.001263">2016:07:08 16:46:44           nathanmarz </span><span>there&apos;s a lot of inner maps</span></div><div data-t="nathanmarz so you want the maps that have :business key?"><span class="u" id="1467996424.001264">2016:07:08 16:47:04           nathanmarz </span><span>so you want the maps that have :business key?</span></div><div data-t="richiardiandrea you are right, skip to  {:business .....}"><span class="u" id="1467996431.001265">2016:07:08 16:47:11      richiardiandrea </span><span>you are right, skip to </span><code>{:business .....}</code></div><div data-t="richiardiandrea yes"><span class="u" id="1467996444.001266">2016:07:08 16:47:24      richiardiandrea </span><span>yes</span></div><div data-t="nathanmarz (select [:handles MAP-VALS] data)"><span class="u" id="1467996470.001267">2016:07:08 16:47:50           nathanmarz </span><code>(select [:handles MAP-VALS] data)</code></div><div data-t="nathanmarz can also do  (select [:handles ALL LAST] data)  but the former is more efficient"><span class="u" id="1467996497.001268">2016:07:08 16:48:17           nathanmarz </span><span>can also do </span><code>(select [:handles ALL LAST] data)</code><span> but the former is more efficient</span></div><div data-t="richiardiandrea oh cool, yes it works, so I needed no  ALL  in my code above..."><span class="u" id="1467996535.001269">2016:07:08 16:48:55      richiardiandrea </span><span>oh cool, yes it works, so I needed no </span><code>ALL</code><span> in my code above...</span></div><div data-t="richiardiandrea I so like the fact that you can transform in one go all the things you need to...thanks a lot for the help and the lib"><span class="u" id="1467996602.001274">2016:07:08 16:50:02      richiardiandrea </span><span>I so like the fact that you can transform in one go all the things you need to...thanks a lot for the help and the lib</span></div><div data-t="nathanmarz sure thing"><span class="u" id="1467996611.001275">2016:07:08 16:50:11           nathanmarz </span><span>sure thing</span></div><div data-t="richiardiandrea don&apos;t want to take too much of your time as I can check the samples, but I saw that you can collect data while you descend the data structure, in my case it would be really handy to carry the  {&quot;booma&quot; {...} &quot;my-handle&quot; {...}}  map in the  transform ...is it feasible with  collect ?"><span class="u" id="1467996919.001276">2016:07:08 16:55:19      richiardiandrea </span><span>don&apos;t want to take too much of your time as I can check the samples, but I saw that you can collect data while you descend the data structure, in my case it would be really handy to carry the </span><code>{&quot;booma&quot; {...} &quot;my-handle&quot; {...}}</code><span> map in the </span><code>transform</code><span>...is it feasible with </span><code>collect</code><span>?</span></div><div data-t="nathanmarz yes"><span class="u" id="1467996981.001277">2016:07:08 16:56:21           nathanmarz </span><span>yes</span></div><div data-t="richiardiandrea tnx"><span class="u" id="1467996991.001278">2016:07:08 16:56:31      richiardiandrea </span><span>tnx</span></div><div data-t="nathanmarz (transform [:handles VAL MAP-VALS ] ..."><span class="u" id="1467997000.001279">2016:07:08 16:56:40           nathanmarz </span><code>(transform [:handles VAL MAP-VALS ] ...</code></div><div data-t="richiardiandrea oh cool awesome"><span class="u" id="1467997010.001280">2016:07:08 16:56:50      richiardiandrea </span><span>oh cool awesome</span></div><div data-t="nathanmarz VAL  is same as  (collect-one STAY)"><span class="u" id="1467997014.001281">2016:07:08 16:56:54           nathanmarz </span><code>VAL</code><span> is same as </span><code>(collect-one STAY)</code></div><div data-t="richiardiandrea perfect that is exactly what I need  😉"><span class="u" id="1467997034.001282">2016:07:08 16:57:14      richiardiandrea </span><span>perfect that is exactly what I need </span><b>😉</b></div><div data-t="richiardiandrea my first specter transformation  🙂 
 (defn deregister-uid [state uid]
  (-&gt;&gt; state
       (spm/transform (sp/multi-path :uids
                                     [:handles sp/MAP-VALS :sente-uids]
                                     [:businesses sp/MAP-VALS :sente-uids])
                      #(cond
                         (map? %) (dissoc % uid)
                         (vector? %) (vec (remove #{uid} %))
                         :else %))))
"><span class="u" id="1467998455.001283">2016:07:08 17:20:55      richiardiandrea </span><span>my first specter transformation </span><b>🙂</b><span>
</span><pre>(defn deregister-uid [state uid]
  (-&gt;&gt; state
       (spm/transform (sp/multi-path :uids
                                     [:handles sp/MAP-VALS :sente-uids]
                                     [:businesses sp/MAP-VALS :sente-uids])
                      #(cond
                         (map? %) (dissoc % uid)
                         (vector? %) (vec (remove #{uid} %))
                         :else %))))
</pre></div><div data-t="peeja How would I select every other element in a vector (that is, every element whose index is even)?"><span class="u" id="1468510566.001389">2016:07:14 15:36:06                peeja </span><span>How would I select every other element in a vector (that is, every element whose index is even)?</span></div><div data-t="nathanmarz I believe you would need to define a new navigator for that"><span class="u" id="1468510912.001390">2016:07:14 15:41:52           nathanmarz </span><span>I believe you would need to define a new navigator for that</span></div><div data-t="nathanmarz one idea would be something like this:  (select [(all-partitioned 2) LAST] data)"><span class="u" id="1468510957.001391">2016:07:14 15:42:37           nathanmarz </span><span>one idea would be something like this: </span><code>(select [(all-partitioned 2) LAST] data)</code></div><div data-t="nathanmarz where  all-partitioned  works like  partition  and navigates you to each pair"><span class="u" id="1468511000.001392">2016:07:14 15:43:20           nathanmarz </span><span>where </span><code>all-partitioned</code><span> works like </span><code>partition</code><span> and navigates you to each pair</span></div><div data-t="nathanmarz or you could have an even more specific navigator called something like  every-nth"><span class="u" id="1468511075.001393">2016:07:14 15:44:35           nathanmarz </span><span>or you could have an even more specific navigator called something like </span><code>every-nth</code></div><div data-t="peeja Cheers!"><span class="u" id="1468511156.001394">2016:07:14 15:45:56                peeja </span><span>Cheers!</span></div><div data-t="spieden i’m getting a lot of mileage out of specter — thanks for releasing it  😃"><span class="u" id="1468536137.001401">2016:07:14 22:42:17              spieden </span><span>i’m getting a lot of mileage out of specter — thanks for releasing it </span><b>😃</b></div><div data-t="nathanmarz @spieden: you&apos;re welcome"><span class="u" id="1468537724.001402">2016:07:14 23:08:44           nathanmarz </span><span>@spieden: you&apos;re welcome</span></div><div data-t="rui.yang Hi, wonder if specter could do the following:"><span class="u" id="1468585252.001413">2016:07:15 12:20:52             rui.yang </span><span>Hi, wonder if specter could do the following:</span></div><div data-t="rui.yang combine the element in the following list based on item_id:  [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;} {:id -2, :item_id &quot;1&quot;, :quantity &quot;2”} {:id -3, :item_id “1”, :quantity “3&quot;]"><span class="u" id="1468585295.001414">2016:07:15 12:21:35             rui.yang </span><span>combine the element in the following list based on item_id:  [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;} {:id -2, :item_id &quot;1&quot;, :quantity &quot;2”} {:id -3, :item_id “1”, :quantity “3&quot;]</span></div><div data-t="rui.yang it will be transform to [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;} {:id -2, :item_id &quot;1&quot;, :quantity “5”}]"><span class="u" id="1468585318.001415">2016:07:15 12:21:58             rui.yang </span><span>it will be transform to [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;} {:id -2, :item_id &quot;1&quot;, :quantity “5”}]</span></div><div data-t="rui.yang or what is the best way of doing it in clojure?"><span class="u" id="1468585344.001416">2016:07:15 12:22:24             rui.yang </span><span>or what is the best way of doing it in clojure?</span></div><div data-t="codonnell @rui.yang: I don&apos;t think this is something that you particularly need specter for. You should be able to accumulate your result using reduce."><span class="u" id="1468586249.001417">2016:07:15 12:37:29            codonnell </span><span>@rui.yang: I don&apos;t think this is something that you particularly need specter for. You should be able to accumulate your result using reduce.</span></div><div data-t="rui.yang @codonnell: thanks for the tips"><span class="u" id="1468586549.001419">2016:07:15 12:42:29             rui.yang </span><span>@codonnell: thanks for the tips</span></div><div data-t="rui.yang seems a good usage for reduce, I didn’t think of it  🙂"><span class="u" id="1468586599.001420">2016:07:15 12:43:19             rui.yang </span><span>seems a good usage for reduce, I didn’t think of it </span><b>🙂</b></div><div data-t="codonnell If you want, you could omit the  vals  and leave the result as a map of items, keyed by  item_id"><span class="u" id="1468586635.001421">2016:07:15 12:43:55            codonnell </span><span>If you want, you could omit the </span><code>vals</code><span> and leave the result as a map of items, keyed by </span><code>item_id</code></div><div data-t="codonnell This is a more natural way to store items, in my opinion."><span class="u" id="1468586654.001422">2016:07:15 12:44:14            codonnell </span><span>This is a more natural way to store items, in my opinion.</span></div><div data-t="rui.yang yes, but I am using that to map to a list of in UI"><span class="u" id="1468586924.001424">2016:07:15 12:48:44             rui.yang </span><span>yes, but I am using that to map to a list of in UI</span></div><div data-t="rui.yang the id of every row in UI is actually :id key"><span class="u" id="1468586944.001425">2016:07:15 12:49:04             rui.yang </span><span>the id of every row in UI is actually :id key</span></div><div data-t="codonnell ah, I see"><span class="u" id="1468586959.001426">2016:07:15 12:49:19            codonnell </span><span>ah, I see</span></div><div data-t="rui.yang (def items [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;} {:id -2, :item_id &quot;1&quot;, :quantity &quot;2”} {:id -3, :item_id “1”, :quantity “3&quot;}])"><span class="u" id="1468587020.001427">2016:07:15 12:50:20             rui.yang </span><span>(def items [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;} {:id -2, :item_id &quot;1&quot;, :quantity &quot;2”} {:id -3, :item_id “1”, :quantity “3&quot;}])</span></div><div data-t="rui.yang (reduce (fn [m {:keys [item_id quantity] :as item}]
				(if (contains? m item_id)
					(update-in m [item_id :quantity] #(+ % quantity))
					(assoc m item_id item)))
			{}
			items)"><span class="u" id="1468587046.001428">2016:07:15 12:50:46             rui.yang </span><span>(reduce (fn [m {:keys [item_id quantity] :as item}]
				(if (contains? m item_id)
					(update-in m [item_id :quantity] #(+ % quantity))
					(assoc m item_id item)))
			{}
			items)</span></div><div data-t="rui.yang gives"><span class="u" id="1468587049.001429">2016:07:15 12:50:49             rui.yang </span><span>gives</span></div><div data-t="rui.yang {&quot;2&quot; {:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;}, &quot;1&quot; {:id -2, :item_id &quot;1&quot;, :quantity &quot;2”} {:id -3, :item_id “1”, :quantity “3&quot;}}"><span class="u" id="1468587089.001430">2016:07:15 12:51:29             rui.yang </span><span>{&quot;2&quot; {:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;}, &quot;1&quot; {:id -2, :item_id &quot;1&quot;, :quantity &quot;2”} {:id -3, :item_id “1”, :quantity “3&quot;}}</span></div><div data-t="codonnell You need to parse the  :quantity  values to integers."><span class="u" id="1468587090.001431">2016:07:15 12:51:30            codonnell </span><span>You need to parse the </span><code>:quantity</code><span> values to integers.</span></div><div data-t="rui.yang yes, I need to do that"><span class="u" id="1468587109.001432">2016:07:15 12:51:49             rui.yang </span><span>yes, I need to do that</span></div><div data-t="rui.yang but look at that map"><span class="u" id="1468587113.001433">2016:07:15 12:51:53             rui.yang </span><span>but look at that map</span></div><div data-t="codonnell yeah, I see"><span class="u" id="1468587117.001434">2016:07:15 12:51:57            codonnell </span><span>yeah, I see</span></div><div data-t="codonnell that&apos;s odd"><span class="u" id="1468587119.001435">2016:07:15 12:51:59            codonnell </span><span>that&apos;s odd</span></div><div data-t="rui.yang the value of “1” is odd"><span class="u" id="1468587125.001436">2016:07:15 12:52:05             rui.yang </span><span>the value of “1” is odd</span></div><div data-t="rui.yang I tried in both clojure and clojurescript, same result"><span class="u" id="1468587166.001437">2016:07:15 12:52:46             rui.yang </span><span>I tried in both clojure and clojurescript, same result</span></div><div data-t="codonnell You&apos;re using nonstandard quote characters around the quantity key in your second item, which is causing the problem, I think."><span class="u" id="1468587235.001438">2016:07:15 12:53:55            codonnell </span><span>You&apos;re using nonstandard quote characters around the quantity key in your second item, which is causing the problem, I think.</span></div><div data-t="codonnell =&gt; (count items)
2"><span class="u" id="1468587277.001439">2016:07:15 12:54:37            codonnell </span><pre>=&gt; (count items)
2</pre></div><div data-t="codonnell it thinks the value for  :quantity  in the second item is just a long string"><span class="u" id="1468587301.001441">2016:07:15 12:55:01            codonnell </span><span>it thinks the value for </span><code>:quantity</code><span> in the second item is just a long string</span></div><div data-t="rui.yang aha"><span class="u" id="1468587331.001442">2016:07:15 12:55:31             rui.yang </span><span>aha</span></div><div data-t="madstap Yeah, copy pasting into my emacs shows the problem in the syntax hinghlighter"><span class="u" id="1468587334.001443">2016:07:15 12:55:34              madstap </span><span>Yeah, copy pasting into my emacs shows the problem in the syntax hinghlighter</span></div><div data-t="rui.yang yes, hard to spot"><span class="u" id="1468587347.001444">2016:07:15 12:55:47             rui.yang </span><span>yes, hard to spot</span></div><div data-t="madstap If you fix it you&apos;ll get a class cast exception"><span class="u" id="1468587362.001445">2016:07:15 12:56:02              madstap </span><span>If you fix it you&apos;ll get a class cast exception</span></div><div data-t="rui.yang a special quote character"><span class="u" id="1468587370.001446">2016:07:15 12:56:10             rui.yang </span><span>a special quote character</span></div><div data-t="rui.yang thank you all, save me tons of pain @madstap @codonnell"><span class="u" id="1468587500.001447">2016:07:15 12:58:20             rui.yang </span><span>thank you all, save me tons of pain @madstap @codonnell</span></div><div data-t="madstap I fixed it like this:
 (def items [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;}
            {:id -2, :item_id &quot;1&quot;, :quantity &quot;2&quot;}
            {:id -3, :item_id &quot;1&quot;, :quantity &quot;3&quot;}])

(defn str-&gt;int [s]
  (Integer/parseInt s))

(reduce (fn [m {:keys [item_id quantity] :as item}]
                (if (contains? m item_id)
                  (update-in m [item_id :quantity] #(+ % quantity))
                  (assoc m item_id item)))
            {}
            (map #(update % :quantity str-&gt;int) items))
"><span class="u" id="1468587564.001448">2016:07:15 12:59:24              madstap </span><span>I fixed it like this:
</span><pre>(def items [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;}
            {:id -2, :item_id &quot;1&quot;, :quantity &quot;2&quot;}
            {:id -3, :item_id &quot;1&quot;, :quantity &quot;3&quot;}])

(defn str-&gt;int [s]
  (Integer/parseInt s))

(reduce (fn [m {:keys [item_id quantity] :as item}]
                (if (contains? m item_id)
                  (update-in m [item_id :quantity] #(+ % quantity))
                  (assoc m item_id item)))
            {}
            (map #(update % :quantity str-&gt;int) items))
</pre></div><div data-t="rui.yang it shouldn’t be string, it should be integer. but when UI form update values, somehow it is setting String. I think I should fix it there instead of fixing it in the transformation of map."><span class="u" id="1468587659.001449">2016:07:15 13:00:59             rui.yang </span><span>it shouldn’t be string, it should be integer. but when UI form update values, somehow it is setting String. I think I should fix it there instead of fixing it in the transformation of map.</span></div><div data-t="codonnell @rui.yang: On a side note, you could use specter to parse those  :quantity  keys into integers, though it&apos;s pretty easy to do in core, as well.
 =&gt; (transform [ALL :quantity] #(Integer. %) items)
[{:id -1, :item_id &quot;2&quot;, :quantity 3} {:id -2, :item_id &quot;1&quot;, :quantity 2} {:id -3, :item_id &quot;1&quot;, :quantity 3}]
"><span class="u" id="1468587669.001450">2016:07:15 13:01:09            codonnell </span><span>@rui.yang: On a side note, you could use specter to parse those </span><code>:quantity</code><span> keys into integers, though it&apos;s pretty easy to do in core, as well.
</span><pre>=&gt; (transform [ALL :quantity] #(Integer. %) items)
[{:id -1, :item_id &quot;2&quot;, :quantity 3} {:id -2, :item_id &quot;1&quot;, :quantity 2} {:id -3, :item_id &quot;1&quot;, :quantity 3}]
</pre></div><div data-t="rui.yang @codonnell: thanks for the tip"><span class="u" id="1468587730.001451">2016:07:15 13:02:10             rui.yang </span><span>@codonnell: thanks for the tip</span></div><div data-t="codonnell no problem"><span class="u" id="1468587749.001452">2016:07:15 13:02:29            codonnell </span><span>no problem</span></div><div data-t="richiardiandrea Hello specter folks, I get a weird error in prod and I don&apos;t know what I&apos;d causing it:
 Omar:
No implementation of method: :get_cell of protocol: #&apos;com.rpl.specter.impl/PMutableCell found for class: clojure.lang.Var$Unbound
 

"><span class="u" id="1468804652.000035">2016:07:18 01:17:32      richiardiandrea </span><span>Hello specter folks, I get a weird error in prod and I don&apos;t know what I&apos;d causing it:
</span><pre>Omar:
No implementation of method: :get_cell of protocol: #&apos;com.rpl.specter.impl/PMutableCell found for class: clojure.lang.Var$Unbound
</pre><span>

</span></div><div data-t="richiardiandrea What can be the cause?"><span class="u" id="1468804659.000036">2016:07:18 01:17:39      richiardiandrea </span><span>What can be the cause?</span></div><div data-t="codonnell @richiardiandrea: are you using 0.12.0? (see  https://github.com/nathanmarz/specter/issues/132 )"><span class="u" id="1468804768.000037">2016:07:18 01:19:28            codonnell </span><span>@richiardiandrea: are you using 0.12.0? (see </span><a href="https://github.com/nathanmarz/specter/issues/132">https://github.com/nathanmarz/specter/issues/132</a><span>)</span></div><div data-t="richiardiandrea Oh, it looks like my problem exactly ;)"><span class="u" id="1468804842.000039">2016:07:18 01:20:42      richiardiandrea </span><span>Oh, it looks like my problem exactly ;)</span></div><div data-t="richiardiandrea I confirm that  0.12  fixed it, thanks @codonnell "><span class="u" id="1468805749.000040">2016:07:18 01:35:49      richiardiandrea </span><span>I confirm that </span><code>0.12</code><span> fixed it, thanks @codonnell </span></div><div data-t="codonnell You&apos;re welcome."><span class="u" id="1468805774.000041">2016:07:18 01:36:14            codonnell </span><span>You&apos;re welcome.</span></div><div data-t="arvind Hello"><span class="u" id="1468950772.000075">2016:07:19 17:52:52               arvind </span><span>Hello</span></div><div data-t="arvind I cloned the specter repo from github"><span class="u" id="1468950780.000076">2016:07:19 17:53:00               arvind </span><span>I cloned the specter repo from github</span></div><div data-t="arvind and ran &quot;lein repl&quot;"><span class="u" id="1468950788.000077">2016:07:19 17:53:08               arvind </span><span>and ran &quot;lein repl&quot;</span></div><div data-t="arvind I downloaded a lot stuff"><span class="u" id="1468950819.000078">2016:07:19 17:53:39               arvind </span><span>I downloaded a lot stuff</span></div><div data-t="arvind Can anyone explain what is happening? I am new to Clojure and Java."><span class="u" id="1468950879.000080">2016:07:19 17:54:39               arvind </span><span>Can anyone explain what is happening? I am new to Clojure and Java.</span></div><div data-t="arvind Does specter have so many dependecies?"><span class="u" id="1468950891.000081">2016:07:19 17:54:51               arvind </span><span>Does specter have so many dependecies?</span></div><div data-t="nathanmarz @arvind: those are all build/test dependencies"><span class="u" id="1468951283.000082">2016:07:19 18:01:23           nathanmarz </span><span>@arvind: those are all build/test dependencies</span></div><div data-t="nathanmarz except for riddley, which is actually used by specter&apos;s implementation"><span class="u" id="1468951308.000083">2016:07:19 18:01:48           nathanmarz </span><span>except for riddley, which is actually used by specter&apos;s implementation</span></div><div data-t="nathanmarz and riddley has no dependencies of its own"><span class="u" id="1468951388.000084">2016:07:19 18:03:08           nathanmarz </span><span>and riddley has no dependencies of its own</span></div><div data-t="nathanmarz so basically specter is very lean with respect to dependencies"><span class="u" id="1468951404.000085">2016:07:19 18:03:24           nathanmarz </span><span>so basically specter is very lean with respect to dependencies</span></div><div data-t="arvind @nathanmarz thanks"><span class="u" id="1468953303.000087">2016:07:19 18:35:03               arvind </span><span>@nathanmarz thanks</span></div><div data-t="arvind another question"><span class="u" id="1468953310.000088">2016:07:19 18:35:10               arvind </span><span>another question</span></div><div data-t="arvind When I run &quot;lein repl&quot; inside the specter directory and type
(require &apos;com.repl.specter)"><span class="u" id="1468953392.000091">2016:07:19 18:36:32               arvind </span><span>When I run &quot;lein repl&quot; inside the specter directory and type
(require &apos;com.repl.specter)</span></div><div data-t="arvind It says the file was not found on classpath"><span class="u" id="1468953415.000092">2016:07:19 18:36:55               arvind </span><span>It says the file was not found on classpath</span></div><div data-t="arvind but running &quot;lein classpath&quot; shows that the src directory is in the classpath."><span class="u" id="1468953434.000093">2016:07:19 18:37:14               arvind </span><span>but running &quot;lein classpath&quot; shows that the src directory is in the classpath.</span></div><div data-t="arvind I want to require &apos;com.repl.specter to play with the transform and select macros"><span class="u" id="1468953471.000094">2016:07:19 18:37:51               arvind </span><span>I want to require &apos;com.repl.specter to play with the transform and select macros</span></div><div data-t="codonnell @arvind: try  (require &apos;[com.rpl.specter]) . Also, the select and transform macros are in  com.rpl.specter.macros ."><span class="u" id="1468953870.000095">2016:07:19 18:44:30            codonnell </span><span>@arvind: try </span><code>(require &apos;[com.rpl.specter])</code><span>. Also, the select and transform macros are in </span><code>com.rpl.specter.macros</code><span>.</span></div><div data-t="codonnell actually, it should work not in a list"><span class="u" id="1468953891.000096">2016:07:19 18:44:51            codonnell </span><span>actually, it should work not in a list</span></div><div data-t="codonnell oh, you added an extra e"><span class="u" id="1468953926.000097">2016:07:19 18:45:26            codonnell </span><span>oh, you added an extra e</span></div><div data-t="codonnell com.rpl.specter , not  com.repl.specter"><span class="u" id="1468953936.000098">2016:07:19 18:45:36            codonnell </span><code>com.rpl.specter</code><span>, not </span><code>com.repl.specter</code></div><div data-t="arvind @codonnell: Please refer below:"><span class="u" id="1468954065.000099">2016:07:19 18:47:45               arvind </span><span>@codonnell: Please refer below:</span></div><div data-t="arvind user=&gt; (require &apos;com.rpl.specter)

FileNotFoundException Could not locate com/rpl/specter__init.class or com/rpl/specter.clj on classpath.  clojure.lang.RT.load (RT.java:449)"><span class="u" id="1468954068.000100">2016:07:19 18:47:48               arvind </span><span>user=&gt; (require &apos;com.rpl.specter)

FileNotFoundException Could not locate com/rpl/specter__init.class or com/rpl/specter.clj on classpath.  clojure.lang.RT.load (RT.java:449)</span></div><div data-t="arvind Also when I run  (all-ns)  in the repl I don&apos;t see com.rpl.specter in the list of namespaces"><span class="u" id="1468954212.000101">2016:07:19 18:50:12               arvind </span><span>Also when I run </span><code>(all-ns)</code><span> in the repl I don&apos;t see com.rpl.specter in the list of namespaces</span></div><div data-t="codonnell @arvind: if you&apos;ve cloned specter off github, you need to run  lein cljx  to compile the classes."><span class="u" id="1468954409.000103">2016:07:19 18:53:29            codonnell </span><span>@arvind: if you&apos;ve cloned specter off github, you need to run </span><code>lein cljx</code><span> to compile the classes.</span></div><div data-t="arvind @codonnell: I just ran  lein cljx"><span class="u" id="1468954498.000104">2016:07:19 18:54:58               arvind </span><span>@codonnell: I just ran </span><code>lein cljx</code></div><div data-t="arvind and then  lein repl"><span class="u" id="1468954512.000105">2016:07:19 18:55:12               arvind </span><span>and then </span><code>lein repl</code></div><div data-t="arvind and  (require &apos;com.rpl.specter.macros)  returned  nil"><span class="u" id="1468954541.000106">2016:07:19 18:55:41               arvind </span><span>and </span><code>(require &apos;com.rpl.specter.macros)</code><span> returned </span><code>nil</code></div><div data-t="arvind and I tried  (transform)  that gave the following error:
CompilerException java.lang.RuntimeException: Unable to resolve symbol: transform in this context, compiling:(/tmp/form-init2526821032412369112.clj:1:1)"><span class="u" id="1468954571.000107">2016:07:19 18:56:11               arvind </span><span>and I tried </span><code>(transform)</code><span> that gave the following error:
CompilerException java.lang.RuntimeException: Unable to resolve symbol: transform in this context, compiling:(/tmp/form-init2526821032412369112.clj:1:1)</span></div><div data-t="codonnell If you just do  (require &apos;com.rpl.specter.macros) , then  transform  is named  com.rpl.specter.macros.transform"><span class="u" id="1468954624.000108">2016:07:19 18:57:04            codonnell </span><span>If you just do </span><code>(require &apos;com.rpl.specter.macros)</code><span>, then </span><code>transform</code><span> is named </span><code>com.rpl.specter.macros.transform</code></div><div data-t="arvind ah"><span class="u" id="1468954639.000109">2016:07:19 18:57:19               arvind </span><span>ah</span></div><div data-t="codonnell If you want to just type  transform , you need to do  (require &apos;[com.rpl.specter.macros :refer [transform]])"><span class="u" id="1468954642.000110">2016:07:19 18:57:22            codonnell </span><span>If you want to just type </span><code>transform</code><span>, you need to do </span><code>(require &apos;[com.rpl.specter.macros :refer [transform]])</code></div><div data-t="codonnell there&apos;s a nice piece about namespaces at  http://www.braveclojure.com/organization/"><span class="u" id="1468954743.000112">2016:07:19 18:59:03            codonnell </span><span>there&apos;s a nice piece about namespaces at </span><a href="http://www.braveclojure.com/organization/">http://www.braveclojure.com/organization/</a></div><div data-t="arvind Yeah that worked. Thanks."><span class="u" id="1468954752.000113">2016:07:19 18:59:12               arvind </span><span>Yeah that worked. Thanks.</span></div><div data-t="codonnell If you&apos;re new to clojure, that&apos;s a great book to work through."><span class="u" id="1468954772.000114">2016:07:19 18:59:32            codonnell </span><span>If you&apos;re new to clojure, that&apos;s a great book to work through.</span></div><div data-t="arvind @codonnell: I bought that book recently. Have to read through it."><span class="u" id="1468954826.000115">2016:07:19 19:00:26               arvind </span><span>@codonnell: I bought that book recently. Have to read through it.</span></div><div data-t="hueyp this might be a question of me not understanding spectre … but say I’ve got a nested map that I want to transform multiple times … is it possible to save the lookup?  e.g. write a generic path, but for this exact instance of the map, its a very narrow this key, the next key, run the transform, etc?"><span class="u" id="1468954908.000116">2016:07:19 19:01:48                hueyp </span><span>this might be a question of me not understanding spectre … but say I’ve got a nested map that I want to transform multiple times … is it possible to save the lookup?  e.g. write a generic path, but for this exact instance of the map, its a very narrow this key, the next key, run the transform, etc?</span></div><div data-t="codonnell @hueyp: could you give an example of what you mean?"><span class="u" id="1468954961.000117">2016:07:19 19:02:41            codonnell </span><span>@hueyp: could you give an example of what you mean?</span></div><div data-t="hueyp sure …  {:foo {:a 1 :b 2 :c 3} :bar {:x 1 :y 2 :z 3}  … something like …  ALL LAST ALL LAST even?  (I might have that syntax wrong …) … it would transform  [:foo :b]  and  [:bar :y]  … like if I want to double those, or subtract 1, etc … that paths are the same, so I’d like to kind of save that knowledge"><span class="u" id="1468955099.000118">2016:07:19 19:04:59                hueyp </span><span>sure … </span><code>{:foo {:a 1 :b 2 :c 3} :bar {:x 1 :y 2 :z 3}</code><span> … something like … </span><code>ALL LAST ALL LAST even?</code><span> (I might have that syntax wrong …) … it would transform </span><code>[:foo :b]</code><span> and </span><code>[:bar :y]</code><span> … like if I want to double those, or subtract 1, etc … that paths are the same, so I’d like to kind of save that knowledge</span></div><div data-t="hueyp again … might be not something that actually matters re how spectre works  🙂"><span class="u" id="1468955110.000119">2016:07:19 19:05:10                hueyp </span><span>again … might be not something that actually matters re how spectre works </span><b>🙂</b></div><div data-t="codonnell Sure. If you know the whole path in advance (no parameters), you could save it with  (def my-map-path (comp-paths MAP-VALS MAP-VALS even?))"><span class="u" id="1468955251.000120">2016:07:19 19:07:31            codonnell </span><span>Sure. If you know the whole path in advance (no parameters), you could save it with </span><code>(def my-map-path (comp-paths MAP-VALS MAP-VALS even?))</code></div><div data-t="codonnell (`MAP-VALS` is the same as  [ALL LAST] , but more efficient"><span class="u" id="1468955273.000121">2016:07:19 19:07:53            codonnell </span><span>(`MAP-VALS` is the same as </span><code>[ALL LAST]</code><span>, but more efficient</span></div><div data-t="hueyp that would still require a full traversal of the map though to determine what matches?"><span class="u" id="1468955288.000122">2016:07:19 19:08:08                hueyp </span><span>that would still require a full traversal of the map though to determine what matches?</span></div><div data-t="hueyp basically I’d like to do that traversal one, and save more specific paths?"><span class="u" id="1468955303.000123">2016:07:19 19:08:23                hueyp </span><span>basically I’d like to do that traversal one, and save more specific paths?</span></div><div data-t="codonnell it would do a traversal each time, that&apos;s right"><span class="u" id="1468955353.000124">2016:07:19 19:09:13            codonnell </span><span>it would do a traversal each time, that&apos;s right</span></div><div data-t="hueyp this is more of a curiosity … the cost of traversing the maps I have is small … just curious if I could say turn  (comp-paths MAP-VALS MAP-VALS even?)  + an exact instance of a map into a more specific path"><span class="u" id="1468955354.000125">2016:07:19 19:09:14                hueyp </span><span>this is more of a curiosity … the cost of traversing the maps I have is small … just curious if I could say turn </span><code>(comp-paths MAP-VALS MAP-VALS even?)</code><span> + an exact instance of a map into a more specific path</span></div><div data-t="hueyp and then re-use that with multiple transforms"><span class="u" id="1468955386.000126">2016:07:19 19:09:46                hueyp </span><span>and then re-use that with multiple transforms</span></div><div data-t="hueyp all on the same starting map  😜"><span class="u" id="1468955395.000127">2016:07:19 19:09:55                hueyp </span><span>all on the same starting map </span><b>😜</b></div><div data-t="codonnell @hueyp: you could use  traverse  from 0.12.0, which returns an instance of  IReduceable  (or something like that; basically it&apos;s only useful when being called with  reduce  or  into )"><span class="u" id="1468955478.000128">2016:07:19 19:11:18            codonnell </span><span>@hueyp: you could use </span><code>traverse</code><span> from 0.12.0, which returns an instance of </span><code>IReduceable</code><span> (or something like that; basically it&apos;s only useful when being called with </span><code>reduce</code><span> or </span><code>into</code><span>)</span></div><div data-t="codonnell that will only do the traversal once, and you could call  reduce  on it multiple times over the same initial structure"><span class="u" id="1468955512.000129">2016:07:19 19:11:52            codonnell </span><span>that will only do the traversal once, and you could call </span><code>reduce</code><span> on it multiple times over the same initial structure</span></div><div data-t="hueyp @codonnell: interesting, I’ll take a look, thanks~"><span class="u" id="1468955557.000130">2016:07:19 19:12:37                hueyp </span><span>@codonnell: interesting, I’ll take a look, thanks~</span></div><div data-t="codonnell https://github.com/nathanmarz/specter/wiki/List-of-Macros#traverse"><span class="u" id="1468955570.000131">2016:07:19 19:12:50            codonnell </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#traverse">https://github.com/nathanmarz/specter/wiki/List-of-Macros#traverse</a></div><div data-t="hueyp oh wow, wiki!"><span class="u" id="1468955611.000133">2016:07:19 19:13:31                hueyp </span><span>oh wow, wiki!</span></div><div data-t="nathanmarz @hueyp: I think you might be looking for a  locate  feature  https://github.com/nathanmarz/specter/issues/49"><span class="u" id="1468955652.000134">2016:07:19 19:14:12           nathanmarz </span><span>@hueyp: I think you might be looking for a </span><code>locate</code><span> feature </span><a href="https://github.com/nathanmarz/specter/issues/49">https://github.com/nathanmarz/specter/issues/49</a></div><div data-t="hueyp wow, yup!"><span class="u" id="1468955787.000136">2016:07:19 19:16:27                hueyp </span><span>wow, yup!</span></div><div data-t="ghadi just had a thought… specter is vim navigation commands for datastructures"><span class="u" id="1469063239.000156">2016:07:21 01:07:19                ghadi </span><span>just had a thought… specter is vim navigation commands for datastructures</span></div><div data-t="nathanmarz @ghadi: don&apos;t know vim, care to elaborate?"><span class="u" id="1469110138.000172">2016:07:21 14:08:58           nathanmarz </span><span>@ghadi: don&apos;t know vim, care to elaborate?</span></div><div data-t="ghadi sure, mutation commands for text are usually preceded by giving a direction. ex:"><span class="u" id="1469110196.000173">2016:07:21 14:09:56                ghadi </span><span>sure, mutation commands for text are usually preceded by giving a direction. ex:</span></div><div data-t="ghadi or succeeded in this case:
 d$   means delete from current position to the end of the line
 dfi  means delete from current position to the first  i  character to the right
 d4k   means delete 4 lines upwards"><span class="u" id="1469110317.000174">2016:07:21 14:11:57                ghadi </span><span>or succeeded in this case:
</span><code>d$</code><span>  means delete from current position to the end of the line
</span><code>dfi</code><span> means delete from current position to the first </span><code>i</code><span> character to the right
</span><code>d4k</code><span>  means delete 4 lines upwards</span></div><div data-t="ghadi and then you have fancy stuff like this, which reminds me of transform ALL:"><span class="u" id="1469110334.000175">2016:07:21 14:12:14                ghadi </span><span>and then you have fancy stuff like this, which reminds me of transform ALL:</span></div><div data-t="ghadi http://vimgifs.com/"><span class="u" id="1469110348.000176">2016:07:21 14:12:28                ghadi </span><a href="http://vimgifs.com/">http://vimgifs.com/</a></div><div data-t="ghadi basically a functor"><span class="u" id="1469110376.000177">2016:07:21 14:12:56                ghadi </span><span>basically a functor</span></div><div data-t="nathanmarz oh wow, cool"><span class="u" id="1469110427.000178">2016:07:21 14:13:47           nathanmarz </span><span>oh wow, cool</span></div><div data-t="ghadi in text your navigation commands are 2D. in datastructures, your navigation is structural"><span class="u" id="1469110435.000179">2016:07:21 14:13:55                ghadi </span><span>in text your navigation commands are 2D. in datastructures, your navigation is structural</span></div><div data-t="ghadi there’s a parallel for sure"><span class="u" id="1469110492.000180">2016:07:21 14:14:52                ghadi </span><span>there’s a parallel for sure</span></div><div data-t="nathanmarz definitely"><span class="u" id="1469110534.000181">2016:07:21 14:15:34           nathanmarz </span><span>definitely</span></div><div data-t="nathanmarz the more tangible metaphors to explain specter the better  🙂"><span class="u" id="1469110567.000182">2016:07:21 14:16:07           nathanmarz </span><span>the more tangible metaphors to explain specter the better </span><b>🙂</b></div><div data-t="arvind I want to learn about specter implementation."><span class="u" id="1469211928.000208">2016:07:22 18:25:28               arvind </span><span>I want to learn about specter implementation.</span></div><div data-t="arvind One approach"><span class="u" id="1469211939.000209">2016:07:22 18:25:39               arvind </span><span>One approach</span></div><div data-t="arvind is to build my own specter by studying its API"><span class="u" id="1469211970.000210">2016:07:22 18:26:10               arvind </span><span>is to build my own specter by studying its API</span></div><div data-t="arvind For this I created a new lein app like  lein new app build-specter"><span class="u" id="1469212011.000211">2016:07:22 18:26:51               arvind </span><span>For this I created a new lein app like </span><code>lein new app build-specter</code></div><div data-t="arvind then created a  checkouts  directory within  build-specter  and created a link  specter  within checkouts directory like below:"><span class="u" id="1469212073.000212">2016:07:22 18:27:53               arvind </span><span>then created a </span><code>checkouts</code><span> directory within </span><code>build-specter</code><span> and created a link </span><code>specter</code><span> within checkouts directory like below:</span></div><div data-t="arvind ln -s /home/user/clojure/specter specter"><span class="u" id="1469212108.000213">2016:07:22 18:28:28               arvind </span><code>ln -s /home/user/clojure/specter specter</code></div><div data-t="arvind Then I ran  lein repl  from build-specter directory"><span class="u" id="1469212144.000214">2016:07:22 18:29:04               arvind </span><span>Then I ran </span><code>lein repl</code><span> from build-specter directory</span></div><div data-t="arvind Then attempted to require specter:
 build-specter.core=&gt; (require &apos;com.rpl.specter)"><span class="u" id="1469212180.000215">2016:07:22 18:29:40               arvind </span><span>Then attempted to require specter:
</span><code>build-specter.core=&gt; (require &apos;com.rpl.specter)</code></div><div data-t="arvind But this gave the below error:
CompilerException java.io.FileNotFoundException: Could not locate riddley/walk__init.class or riddley/walk.clj on classpath., compiling:(com/rpl/specter/impl.clj:1:1)"><span class="u" id="1469212195.000216">2016:07:22 18:29:55               arvind </span><span>But this gave the below error:
CompilerException java.io.FileNotFoundException: Could not locate riddley/walk__init.class or riddley/walk.clj on classpath., compiling:(com/rpl/specter/impl.clj:1:1)</span></div><div data-t="arvind How do I include the checkouts dependencies"><span class="u" id="1469212222.000218">2016:07:22 18:30:22               arvind </span><span>How do I include the checkouts dependencies</span></div><div data-t="arvind Because specter depends on riddley"><span class="u" id="1469212728.000219">2016:07:22 18:38:48               arvind </span><span>Because specter depends on riddley</span></div><div data-t="arvind I figured it out. Ran  lein install  in the specter directory and added specter as a dependency in build-specter&apos;s project.clj"><span class="u" id="1469214191.000220">2016:07:22 19:03:11               arvind </span><span>I figured it out. Ran </span><code>lein install</code><span> in the specter directory and added specter as a dependency in build-specter&apos;s project.clj</span></div><div data-t="rui.yang hi, still new to specter, wonder if specter could do the following"><span class="u" id="1469324268.000242">2016:07:24 01:37:48             rui.yang </span><span>hi, still new to specter, wonder if specter could do the following</span></div><div data-t="rui.yang the map"><span class="u" id="1469324271.000243">2016:07:24 01:37:51             rui.yang </span><span>the map</span></div><div data-t="rui.yang {:model
 {:validaton
  {:name
   {:msg &quot;too long&quot;}}
  {:age
   {:msg &quot;too young&quot;}}}}"><span class="u" id="1469324273.000244">2016:07:24 01:37:53             rui.yang </span><span>{:model
 {:validaton
  {:name
   {:msg &quot;too long&quot;}}
  {:age
   {:msg &quot;too young&quot;}}}}</span></div><div data-t="rui.yang How could reset all :msg to nil? (elegantly with specter)"><span class="u" id="1469324315.000245">2016:07:24 01:38:35             rui.yang </span><span>How could reset all :msg to nil? (elegantly with specter)</span></div><div data-t="rui.yang 🙂"><span class="u" id="1469324336.000246">2016:07:24 01:38:56             rui.yang </span><b>🙂</b></div><div data-t="jjunior130 and I renamed  :validaton  to  :validation"><span class="u" id="1469326867.000248">2016:07:24 02:21:07           jjunior130 </span><span>and I renamed </span><code>:validaton</code><span> to </span><code>:validation</code></div><div data-t="jjunior130 I don&apos;t know about elegance but I tried"><span class="u" id="1469326888.000249">2016:07:24 02:21:28           jjunior130 </span><span>I don&apos;t know about elegance but I tried</span></div><div data-t="jjunior130 and I didn&apos;t evaluate it. So idk if it&apos;s good."><span class="u" id="1469326966.000250">2016:07:24 02:22:46           jjunior130 </span><span>and I didn&apos;t evaluate it. So idk if it&apos;s good.</span></div><div data-t="rui.yang @jjunior130: thanks for pointing me to MAP-VALS. I used (setval [:model :validation specter/MAP-VALS :msg] nil db) to set all :msg key based on old structure. and it worked. Thanks again  🙂"><span class="u" id="1469333880.000251">2016:07:24 04:18:00             rui.yang </span><span>@jjunior130: thanks for pointing me to MAP-VALS. I used (setval [:model :validation specter/MAP-VALS :msg] nil db) to set all :msg key based on old structure. and it worked. Thanks again </span><b>🙂</b></div><div data-t="jjunior130 @rui.yang: glad I was of help. 
Format your text for easy reading.  https://get.slack.help/hc/en-us/articles/202288908-Formatting-your-messages"><span class="u" id="1469337879.000252">2016:07:24 05:24:39           jjunior130 </span><span>@rui.yang: glad I was of help. 
Format your text for easy reading. </span><a href="https://get.slack.help/hc/en-us/articles/202288908-Formatting-your-messages">https://get.slack.help/hc/en-us/articles/202288908-Formatting-your-messages</a></div><div data-t="shader how do you do a recursive traversal? I want to create a transform for all of the handlers in a bidi routing structure. This requires getting all of the &apos;leaves&apos; of a nested table/vector structure, where &apos;leaf&apos; is basically a map-val that is a keyword"><span class="u" id="1469711939.000330">2016:07:28 13:18:59               shader </span><span>how do you do a recursive traversal? I want to create a transform for all of the handlers in a bidi routing structure. This requires getting all of the &apos;leaves&apos; of a nested table/vector structure, where &apos;leaf&apos; is basically a map-val that is a keyword</span></div><div data-t="shader the problem is that the leaves are at variable and unbounded depths in the tree"><span class="u" id="1469711974.000331">2016:07:28 13:19:34               shader </span><span>the problem is that the leaves are at variable and unbounded depths in the tree</span></div><div data-t="codonnell @shader: The easiest way is to use  walker , though sometimes you need to define a custom navigator."><span class="u" id="1469712577.000332">2016:07:28 13:29:37            codonnell </span><span>@shader: The easiest way is to use </span><code>walker</code><span>, though sometimes you need to define a custom navigator.</span></div><div data-t="codonnell Another option would be to use the zipper navigators, though I haven&apos;t played with those personally."><span class="u" id="1469712670.000333">2016:07:28 13:31:10            codonnell </span><span>Another option would be to use the zipper navigators, though I haven&apos;t played with those personally.</span></div><div data-t="shader I&apos;ve tried walker, but I don&apos;t really know how to use it I guess"><span class="u" id="1469712735.000334">2016:07:28 13:32:15               shader </span><span>I&apos;ve tried walker, but I don&apos;t really know how to use it I guess</span></div><div data-t="shader I don&apos;t know how to select for &quot;only keywords that are values of maps&quot;"><span class="u" id="1469712750.000335">2016:07:28 13:32:30               shader </span><span>I don&apos;t know how to select for &quot;only keywords that are values of maps&quot;</span></div><div data-t="codonnell Could you give an example of what you&apos;re trying to do? I&apos;m not familiar with bidi routing structures."><span class="u" id="1469712795.000336">2016:07:28 13:33:15            codonnell </span><span>Could you give an example of what you&apos;re trying to do? I&apos;m not familiar with bidi routing structures.</span></div><div data-t="shader I&apos;d like to get all all of :trials-list, :trial-details, etc., without getting the :id keywords in the vectors (those define url parameters, not handlers)"><span class="u" id="1469712934.000338">2016:07:28 13:35:34               shader </span><span>I&apos;d like to get all all of :trials-list, :trial-details, etc., without getting the :id keywords in the vectors (those define url parameters, not handlers)</span></div><div data-t="codonnell So if you were traversing that data structure, you&apos;d want to get a vector  [:trials-list :trial-details :records-list :record-details :authorized-trials :revoke :messages :delete-message] ?"><span class="u" id="1469713036.000339">2016:07:28 13:37:16            codonnell </span><span>So if you were traversing that data structure, you&apos;d want to get a vector </span><code>[:trials-list :trial-details :records-list :record-details :authorized-trials :revoke :messages :delete-message]</code><span>?</span></div><div data-t="shader yes"><span class="u" id="1469713100.000340">2016:07:28 13:38:20               shader </span><span>yes</span></div><div data-t="shader well, specifically a view I can pass to transform to replace them with an actual handler function"><span class="u" id="1469713129.000341">2016:07:28 13:38:49               shader </span><span>well, specifically a view I can pass to transform to replace them with an actual handler function</span></div><div data-t="codonnell should be able to do it with  declarepath  and  providepath"><span class="u" id="1469713866.000342">2016:07:28 13:51:06            codonnell </span><span>should be able to do it with </span><code>declarepath</code><span> and </span><code>providepath</code></div><div data-t="codonnell there we go"><span class="u" id="1469713998.000343">2016:07:28 13:53:18            codonnell </span><span>there we go</span></div><div data-t="codonnell =&gt; (declarepath DEEP-MAP-VALS)
=&gt; (providepath DEEP-MAP-VALS (sp/if-path map? [sp/MAP-VALS DEEP-MAP-VALS] sp/STAY))
=&gt; (select DEEP-MAP-VALS {:a {:b 2} :c {:d 3 :e {:f 4}} :g 5})
[2 3 4 5]
=&gt; (transform DEEP-MAP-VALS inc {:a {:b 2} :c {:d 3 :e {:f 4}} :g 5})
{:a {:b 3}, :c {:d 4, :e {:f 5}}, :g 6}
"><span class="u" id="1469714060.000344">2016:07:28 13:54:20            codonnell </span><pre>=&gt; (declarepath DEEP-MAP-VALS)
=&gt; (providepath DEEP-MAP-VALS (sp/if-path map? [sp/MAP-VALS DEEP-MAP-VALS] sp/STAY))
=&gt; (select DEEP-MAP-VALS {:a {:b 2} :c {:d 3 :e {:f 4}} :g 5})
[2 3 4 5]
=&gt; (transform DEEP-MAP-VALS inc {:a {:b 2} :c {:d 3 :e {:f 4}} :g 5})
{:a {:b 3}, :c {:d 4, :e {:f 5}}, :g 6}
</pre></div><div data-t="shader interesting"><span class="u" id="1469714086.000345">2016:07:28 13:54:46               shader </span><span>interesting</span></div><div data-t="codonnell dammit, keep hitting enter instead of ctrl + enter"><span class="u" id="1469714108.000347">2016:07:28 13:55:08            codonnell </span><span>dammit, keep hitting enter instead of ctrl + enter</span></div><div data-t="codonnell there"><span class="u" id="1469714126.000349">2016:07:28 13:55:26            codonnell </span><span>there</span></div><div data-t="shader @codonnell: thanks, that helped a lot. My final implementation is:
 (providepath DEEP-MAP-VALS (cond-path map? [MAP-VALS DEEP-MAP-VALS] vector? [LAST DEEP-MAP-VALS] :default STAY))"><span class="u" id="1469714576.000350">2016:07:28 14:02:56               shader </span><span>@codonnell: thanks, that helped a lot. My final implementation is:
</span><pre>(providepath DEEP-MAP-VALS (cond-path map? [MAP-VALS DEEP-MAP-VALS] vector? [LAST DEEP-MAP-VALS] :default STAY))</pre></div><div data-t="codonnell nice"><span class="u" id="1469714598.000351">2016:07:28 14:03:18            codonnell </span><span>nice</span></div><div data-t="codonnell @nathanmarz: I added  DEEP-MAP-VALS  as an example to my copy of the wiki, since people ask about recursive navigators pretty often."><span class="u" id="1469715258.000352">2016:07:28 14:14:18            codonnell </span><span>@nathanmarz: I added </span><code>DEEP-MAP-VALS</code><span> as an example to my copy of the wiki, since people ask about recursive navigators pretty often.</span></div><div data-t="nathanmarz @codonnell: good idea, merged it in"><span class="u" id="1469732539.000356">2016:07:28 19:02:19           nathanmarz </span><span>@codonnell: good idea, merged it in</span></div><div data-t="kenny I&apos;m not sure I fully understand how to do a recursive transform. I want to change the value of the key  :changeme  to negative its current value. This should be done for every nested map inside the structure, including all maps inside a sequential collection. It seems like this would be super simple to do in specter but I am guessing I don&apos;t fully understand the way recursion works in specter. Here is what I wrote: 
 (rsm/declarepath MapWalker)
(rsm/providepath MapWalker
                 (rs/cond-path
                   vector?
                   [rs/ALL MapWalker]
                   map?
                   [rs/MAP-VALS coll? MapWalker]))

(rsm/transform [MapWalker :changeme]
               #(- %)
               {:changeme    1
                :ignore-this &quot;&quot;
                :foo2        {:changeme 2
                              :bar2     &quot;something&quot;}
                :foo3        [{:changeme 3}
                              {:changeme    3
                               :ignore-this &quot;&quot;}]})
 
Expected output:
 {:changeme    -1
 :ignore-this &quot;&quot;
 :foo2        {:changeme -2
               :bar2     &quot;something&quot;}
 :foo3        [{:changeme -3}
               {:changeme    -3
                :ignore-this &quot;&quot;}]}
 
Any help?"><span class="u" id="1469735158.000357">2016:07:28 19:45:58                kenny </span><span>I&apos;m not sure I fully understand how to do a recursive transform. I want to change the value of the key </span><code>:changeme</code><span> to negative its current value. This should be done for every nested map inside the structure, including all maps inside a sequential collection. It seems like this would be super simple to do in specter but I am guessing I don&apos;t fully understand the way recursion works in specter. Here is what I wrote: 
</span><pre>(rsm/declarepath MapWalker)
(rsm/providepath MapWalker
                 (rs/cond-path
                   vector?
                   [rs/ALL MapWalker]
                   map?
                   [rs/MAP-VALS coll? MapWalker]))

(rsm/transform [MapWalker :changeme]
               #(- %)
               {:changeme    1
                :ignore-this &quot;&quot;
                :foo2        {:changeme 2
                              :bar2     &quot;something&quot;}
                :foo3        [{:changeme 3}
                              {:changeme    3
                               :ignore-this &quot;&quot;}]})
</pre><span>
Expected output:
</span><pre>{:changeme    -1
 :ignore-this &quot;&quot;
 :foo2        {:changeme -2
               :bar2     &quot;something&quot;}
 :foo3        [{:changeme -3}
               {:changeme    -3
                :ignore-this &quot;&quot;}]}
</pre><span>
Any help?</span></div><div data-t="nathanmarz @kenny: easiest is to use  walker"><span class="u" id="1469736129.000358">2016:07:28 20:02:09           nathanmarz </span><span>@kenny: easiest is to use </span><code>walker</code></div><div data-t="nathanmarz (declarepath MapWalker)
(providepath MapWalker
  (stay-then-continue
    MAP-VALS
    (walker map?)
    MapWalker
    ))
"><span class="u" id="1469736134.000359">2016:07:28 20:02:14           nathanmarz </span><pre>(declarepath MapWalker)
(providepath MapWalker
  (stay-then-continue
    MAP-VALS
    (walker map?)
    MapWalker
    ))
</pre></div><div data-t="kenny That works. Why does the code I sent not work? It reads like it should work  😛"><span class="u" id="1469736352.000360">2016:07:28 20:05:52                kenny </span><span>That works. Why does the code I sent not work? It reads like it should work </span><b>😛</b></div><div data-t="nathanmarz @kenny: you can modify it like this to make it work"><span class="u" id="1469736413.000361">2016:07:28 20:06:53           nathanmarz </span><span>@kenny: you can modify it like this to make it work</span></div><div data-t="nathanmarz (declarepath MapWalker)
(providepath MapWalker
   (cond-path
     vector?
     [ALL MapWalker]
     map?
     (stay-then-continue MAP-VALS MapWalker)))
"><span class="u" id="1469736416.000362">2016:07:28 20:06:56           nathanmarz </span><pre>(declarepath MapWalker)
(providepath MapWalker
   (cond-path
     vector?
     [ALL MapWalker]
     map?
     (stay-then-continue MAP-VALS MapWalker)))
</pre></div><div data-t="codonnell @kenny: I think the problem is you&apos;re not actually navigating to anything. You navigate deeper when you encounter a vector or a map, but you stop navigation when you encounter anything else, rather than staying there."><span class="u" id="1469736473.000363">2016:07:28 20:07:53            codonnell </span><span>@kenny: I think the problem is you&apos;re not actually navigating to anything. You navigate deeper when you encounter a vector or a map, but you stop navigation when you encounter anything else, rather than staying there.</span></div><div data-t="kenny Ah, and  stay-then-continue  solves that problem"><span class="u" id="1469736508.000364">2016:07:28 20:08:28                kenny </span><span>Ah, and </span><code>stay-then-continue</code><span> solves that problem</span></div><div data-t="codonnell Indeed"><span class="u" id="1469736517.000365">2016:07:28 20:08:37            codonnell </span><span>Indeed</span></div><div data-t="codonnell Though as @nathanmarz neatly solved for your use case, you want to stay at each map, since you want to grab its value for  :changeme"><span class="u" id="1469736564.000366">2016:07:28 20:09:24            codonnell </span><span>Though as @nathanmarz neatly solved for your use case, you want to stay at each map, since you want to grab its value for </span><code>:changeme</code></div><div data-t="kenny Agreed, I definitely like @nathanmarz solution much better."><span class="u" id="1469736621.000367">2016:07:28 20:10:21                kenny </span><span>Agreed, I definitely like @nathanmarz solution much better.</span></div><div data-t="kenny In this case I guess the equivalent Clojure code wouldn&apos;t be all that bad to maintain anyways as I could have just used clojure.walk."><span class="u" id="1469736822.000368">2016:07:28 20:13:42                kenny </span><span>In this case I guess the equivalent Clojure code wouldn&apos;t be all that bad to maintain anyways as I could have just used clojure.walk.</span></div><div data-t="nathanmarz another thing to note is the second solution is significantly faster than using  walker  or clojure.walk manually"><span class="u" id="1469737013.000369">2016:07:28 20:16:53           nathanmarz </span><span>another thing to note is the second solution is significantly faster than using </span><code>walker</code><span> or clojure.walk manually</span></div><div data-t="kenny Good to know  🙂"><span class="u" id="1469737210.000370">2016:07:28 20:20:10                kenny </span><span>Good to know </span><b>🙂</b></div><div data-t="kenny It is interesting that each approach you take in Clojure has an &quot;equivalent&quot; approach in specter -- clojure.walk is to walker as manually writing a recursive function is to cond-path."><span class="u" id="1469737314.000371">2016:07:28 20:21:54                kenny </span><span>It is interesting that each approach you take in Clojure has an &quot;equivalent&quot; approach in specter -- clojure.walk is to walker as manually writing a recursive function is to cond-path.</span></div><div data-t="nathanmarz the nature of abstraction I think"><span class="u" id="1469737382.000372">2016:07:28 20:23:02           nathanmarz </span><span>the nature of abstraction I think</span></div><div data-t="nathanmarz like how every clojure function could be written manually in bytecode"><span class="u" id="1469737395.000373">2016:07:28 20:23:15           nathanmarz </span><span>like how every clojure function could be written manually in bytecode</span></div><div data-t="kenny Or rather.. 
&gt; the nature of a good abstraction"><span class="u" id="1469737640.000374">2016:07:28 20:27:20                kenny </span><span>Or rather.. 
&gt; the nature of a good abstraction</span></div><div data-t="richiardiandrea Oh I think this declarepath feature is what I was looking for as well for recursive navigation...I notice that in case of unexpected nil sometimes on the path I am navigating, an exception is thrown...still need to investigate so I will come up with a better test case to submit here"><span class="u" id="1469739238.000379">2016:07:28 20:53:58      richiardiandrea </span><span>Oh I think this declarepath feature is what I was looking for as well for recursive navigation...I notice that in case of unexpected nil sometimes on the path I am navigating, an exception is thrown...still need to investigate so I will come up with a better test case to submit here</span></div><div data-t="wei trying to walk a nested structure and add a sequential index to all the maps. would this be a good use case for specter? e.g.  [[{} {}] [{} {} [{}]]] =&gt; [[{:id 1} {:id 2}] [{:id 3} {:id 4} [{:id 5}]]]  (x-posted from #C03S1KBA2)"><span class="u" id="1469834891.000399">2016:07:29 23:28:11                  wei </span><span>trying to walk a nested structure and add a sequential index to all the maps. would this be a good use case for specter? e.g. </span><code>[[{} {}] [{} {} [{}]]] =&gt; [[{:id 1} {:id 2}] [{:id 3} {:id 4} [{:id 5}]]]</code><span> (x-posted from #C03S1KBA2)</span></div><div data-t="wei I came up with this:
 (defn walk-with-index [m f]
  (let [counter (atom -1)]
    (com.rpl.specter.macros/transform [(com.rpl.specter/walker map?)]
                                      #(f (swap! counter inc) %) m)))"><span class="u" id="1469845298.000404">2016:07:30 02:21:38                  wei </span><span>I came up with this:
</span><pre>(defn walk-with-index [m f]
  (let [counter (atom -1)]
    (com.rpl.specter.macros/transform [(com.rpl.specter/walker map?)]
                                      #(f (swap! counter inc) %) m)))</pre></div><div data-t="wei there’s definitely a better way to do it, looking forward to any feedback  🙂"><span class="u" id="1469845331.000405">2016:07:30 02:22:11                  wei </span><span>there’s definitely a better way to do it, looking forward to any feedback </span><b>🙂</b></div><div data-t="codonnell @wei: here&apos;s a stateless solution:
 (transform (subselect (walker map?)) (partial map #(assoc %2 :id %1) (range)) [[{} {}] {} {}])
[[{:id 0} {:id 1}] {:id 2} {:id 3}]"><span class="u" id="1469847731.000407">2016:07:30 03:02:11            codonnell </span><span>@wei: here&apos;s a stateless solution:
</span><pre>(transform (subselect (walker map?)) (partial map #(assoc %2 :id %1) (range)) [[{} {}] {} {}])
[[{:id 0} {:id 1}] {:id 2} {:id 3}]</pre></div><div data-t="codonnell no idea how that compares to your atom solution in terms of efficiency, though"><span class="u" id="1469847814.000408">2016:07:30 03:03:34            codonnell </span><span>no idea how that compares to your atom solution in terms of efficiency, though</span></div><div data-t="wei @codonnell: looks better though, thanks!"><span class="u" id="1469848133.000409">2016:07:30 03:08:53                  wei </span><span>@codonnell: looks better though, thanks!</span></div><div data-t="codonnell no problem"><span class="u" id="1469848170.000410">2016:07:30 03:09:30            codonnell </span><span>no problem</span></div><div data-t="nathanmarz @wei @codonnell: this solution is even more concise:
 (setval (subselect (walker map?) :id)
  (range)
  [[{} {}] [{} {} [{}]]])
;; =&gt; [[{:id 0} {:id 1}] [{:id 2} {:id 3} [{:id 4}]]]
"><span class="u" id="1469858969.000414">2016:07:30 06:09:29           nathanmarz </span><span>@wei @codonnell: this solution is even more concise:
</span><pre>(setval (subselect (walker map?) :id)
  (range)
  [[{} {}] [{} {} [{}]]])
;; =&gt; [[{:id 0} {:id 1}] [{:id 2} {:id 3} [{:id 4}]]]
</pre></div><div data-t="codonnell very nice"><span class="u" id="1469885875.000418">2016:07:30 13:37:55            codonnell </span><span>very nice</span></div><div data-t="codonnell @nathanmarz: Just checked out multi-transform, terminal, and terminal-val and added them to the wiki."><span class="u" id="1469890516.000422">2016:07:30 14:55:16            codonnell </span><span>@nathanmarz: Just checked out multi-transform, terminal, and terminal-val and added them to the wiki.</span></div><div data-t="luxbock I&apos;d like to use  MAP-VALS  but ignore one specific key in the passed in map"><span class="u" id="1469972895.000439">2016:07:31 13:48:15              luxbock </span><span>I&apos;d like to use </span><code>MAP-VALS</code><span> but ignore one specific key in the passed in map</span></div><div data-t="luxbock how would I do this?"><span class="u" id="1469972900.000440">2016:07:31 13:48:20              luxbock </span><span>how would I do this?</span></div><div data-t="codonnell @luxbock: If you don&apos;t need to rebuild, you could do  (view #(dissoc % :key))"><span class="u" id="1469973948.000441">2016:07:31 14:05:48            codonnell </span><span>@luxbock: If you don&apos;t need to rebuild, you could do </span><code>(view #(dissoc % :key))</code></div><div data-t="codonnell You could also define your own navigator to do it, which shouldn&apos;t be too hard"><span class="u" id="1469973982.000442">2016:07:31 14:06:22            codonnell </span><span>You could also define your own navigator to do it, which shouldn&apos;t be too hard</span></div><div data-t="luxbock I do need the key present in the returned result "><span class="u" id="1469973999.000443">2016:07:31 14:06:39              luxbock </span><span>I do need the key present in the returned result </span></div><div data-t="luxbock Yeah I was wondering if there had been an easy way to do it with the builtins "><span class="u" id="1469974024.000444">2016:07:31 14:07:04              luxbock </span><span>Yeah I was wondering if there had been an easy way to do it with the builtins </span></div><div data-t="luxbock I think rather than building a navigator for this specific use case I would rather just wrap the whole thing with dissoc and assoc "><span class="u" id="1469974067.000445">2016:07:31 14:07:47              luxbock </span><span>I think rather than building a navigator for this specific use case I would rather just wrap the whole thing with dissoc and assoc </span></div><div data-t="codonnell (transform [ALL #(not= :a (first %)) LAST] inc {:a 0 :b 1 :c 2})"><span class="u" id="1469974289.000446">2016:07:31 14:11:29            codonnell </span><code>(transform [ALL #(not= :a (first %)) LAST] inc {:a 0 :b 1 :c 2})</code></div><div data-t="codonnell @luxbock: definitely not as efficient as using  assoc  and  dissoc , but it does work"><span class="u" id="1469974316.000447">2016:07:31 14:11:56            codonnell </span><span>@luxbock: definitely not as efficient as using </span><code>assoc</code><span> and </span><code>dissoc</code><span>, but it does work</span></div><div data-t="luxbock Yeah, thanks, I think I&apos;ll end up doing it manually because this function gets called a ton "><span class="u" id="1469978145.000448">2016:07:31 15:15:45              luxbock </span><span>Yeah, thanks, I think I&apos;ll end up doing it manually because this function gets called a ton </span></div><div data-t="borkdude Does anyone has an example of how I should require specter from clojurescript?"><span class="u" id="1470150774.000489">2016:08:02 15:12:54             borkdude </span><span>Does anyone has an example of how I should require specter from clojurescript?</span></div><div data-t="borkdude It&apos;s missing in the intro page (that uses  use )"><span class="u" id="1470150780.000490">2016:08:02 15:13:00             borkdude </span><span>It&apos;s missing in the intro page (that uses </span><code>use</code><span>)</span></div><div data-t="nathanmarz @borkdude
 (require &apos;[com.rpl.specter :as s])
(require-macros &apos;[com.rpl.specter.macros :refer [select transform]])
"><span class="u" id="1470150884.000492">2016:08:02 15:14:44           nathanmarz </span><span>@borkdude
</span><pre>(require &apos;[com.rpl.specter :as s])
(require-macros &apos;[com.rpl.specter.macros :refer [select transform]])
</pre></div><div data-t="borkdude @nathanmarz: cool, I was trying something with :refer :all, but that isn&apos;t going to work probably"><span class="u" id="1470150912.000493">2016:08:02 15:15:12             borkdude </span><span>@nathanmarz: cool, I was trying something with :refer :all, but that isn&apos;t going to work probably</span></div><div data-t="nathanmarz macros namespace also has declarepath, providepath, and other operations for defining navigators"><span class="u" id="1470150914.000494">2016:08:02 15:15:14           nathanmarz </span><span>macros namespace also has declarepath, providepath, and other operations for defining navigators</span></div><div data-t="nathanmarz yea I think you need to require macros individually"><span class="u" id="1470150958.000495">2016:08:02 15:15:58           nathanmarz </span><span>yea I think you need to require macros individually</span></div><div data-t="nathanmarz not sure, don&apos;t really use cljs"><span class="u" id="1470151023.000496">2016:08:02 15:17:03           nathanmarz </span><span>not sure, don&apos;t really use cljs</span></div><div data-t="borkdude where should I require  walker  from, is it a function or macro?"><span class="u" id="1470151094.000497">2016:08:02 15:18:14             borkdude </span><span>where should I require </span><code>walker</code><span> from, is it a function or macro?</span></div><div data-t="borkdude I&apos;m trying to get Specter going with Planck, but failing so far:  https://gist.github.com/borkdude/a7706bf096e1280b3d8a3fd0b33ec95e"><span class="u" id="1470151314.000498">2016:08:02 15:21:54             borkdude </span><span>I&apos;m trying to get Specter going with Planck, but failing so far: </span><a href="https://gist.github.com/borkdude/a7706bf096e1280b3d8a3fd0b33ec95e">https://gist.github.com/borkdude/a7706bf096e1280b3d8a3fd0b33ec95e</a></div><div data-t="nathanmarz can you get a stack trace for that?"><span class="u" id="1470151451.000500">2016:08:02 15:24:11           nathanmarz </span><span>can you get a stack trace for that?</span></div><div data-t="borkdude @nathanmarz: for transform?"><span class="u" id="1470151953.000502">2016:08:02 15:32:33             borkdude </span><span>@nathanmarz: for transform?</span></div><div data-t="borkdude Don&apos;t know if this is helpful?  https://gist.github.com/borkdude/9287a872db1038160fd0444ec1cac443"><span class="u" id="1470152155.000503">2016:08:02 15:35:55             borkdude </span><span>Don&apos;t know if this is helpful? </span><a href="https://gist.github.com/borkdude/9287a872db1038160fd0444ec1cac443">https://gist.github.com/borkdude/9287a872db1038160fd0444ec1cac443</a></div><div data-t="mfikes FWIW, I quickly tried that expression with older versions of specter, back to 0.9.3 and it fails in Planck in the same way. So not a regression at least. Perhaps just a problematic expression."><span class="u" id="1470153109.000505">2016:08:02 15:51:49               mfikes </span><span>FWIW, I quickly tried that expression with older versions of specter, back to 0.9.3 and it fails in Planck in the same way. So not a regression at least. Perhaps just a problematic expression.</span></div><div data-t="nathanmarz @borkdude: can you open an issue on github for this?"><span class="u" id="1470153330.000506">2016:08:02 15:55:30           nathanmarz </span><span>@borkdude: can you open an issue on github for this?</span></div><div data-t="borkdude of course! I&apos;m cooking right now, but will do so after dinner"><span class="u" id="1470153349.000507">2016:08:02 15:55:49             borkdude </span><span>of course! I&apos;m cooking right now, but will do so after dinner</span></div><div data-t="nathanmarz @mfikes: master branch is on clojure 1.7.0 now, does that mean we should be able to integrate automated tests for specter+bootstrap ?"><span class="u" id="1470153508.000508">2016:08:02 15:58:28           nathanmarz </span><span>@mfikes: master branch is on clojure 1.7.0 now, does that mean we should be able to integrate automated tests for specter+bootstrap ?</span></div><div data-t="borkdude https://github.com/nathanmarz/specter/issues/136"><span class="u" id="1470153993.000509">2016:08:02 16:06:33             borkdude </span><a href="https://github.com/nathanmarz/specter/issues/136">https://github.com/nathanmarz/specter/issues/136</a></div><div data-t="mfikes @nathanmarz: still need  http://dev.clojure.org/jira/browse/TCHECK-105"><span class="u" id="1470154356.000511">2016:08:02 16:12:36               mfikes </span><span>@nathanmarz: still need </span><a href="http://dev.clojure.org/jira/browse/TCHECK-105">http://dev.clojure.org/jira/browse/TCHECK-105</a></div><div data-t="nathanmarz @mfikes: hmmm, timestamps there aren&apos;t so encouraging"><span class="u" id="1470154773.000512">2016:08:02 16:19:33           nathanmarz </span><span>@mfikes: hmmm, timestamps there aren&apos;t so encouraging</span></div><div data-t="nathanmarz would it be possible to fork test.check in the meantime with the appropriate changes? I&apos;d be perfectly happy using that"><span class="u" id="1470154803.000513">2016:08:02 16:20:03           nathanmarz </span><span>would it be possible to fork test.check in the meantime with the appropriate changes? I&apos;d be perfectly happy using that</span></div><div data-t="mattsfrey few questions.. how would I make select* analogous to get-in, currently (select* [:bleh :blah] {:bleh {:blah 1}}) returns [1] instead of just 1"><span class="u" id="1470156086.000515">2016:08:02 16:41:26            mattsfrey </span><span>few questions.. how would I make select* analogous to get-in, currently (select* [:bleh :blah] {:bleh {:blah 1}}) returns [1] instead of just 1</span></div><div data-t="mattsfrey and why do the examples on the github use just &apos;select&apos; when the function is select* ?"><span class="u" id="1470156104.000516">2016:08:02 16:41:44            mattsfrey </span><span>and why do the examples on the github use just &apos;select&apos; when the function is select* ?</span></div><div data-t="mfikes @nathanmarz: Yeah… let me check. There’s an issue related to Transit that might be holding it up, and if that’s the case perhaps I can address it. I agree, if no progress, I’ll pursue an interim fork."><span class="u" id="1470157498.000520">2016:08:02 17:04:58               mfikes </span><span>@nathanmarz: Yeah… let me check. There’s an issue related to Transit that might be holding it up, and if that’s the case perhaps I can address it. I agree, if no progress, I’ll pursue an interim fork.</span></div><div data-t="codonnell @mattsfrey: There is a  select*  function, but it&apos;s preferred to use the  select  macro, as in the docs"><span class="u" id="1470158238.000521">2016:08:02 17:17:18            codonnell </span><span>@mattsfrey: There is a </span><code>select*</code><span> function, but it&apos;s preferred to use the </span><code>select</code><span> macro, as in the docs</span></div><div data-t="codonnell and if you know you&apos;ll only be selecting one thing, you can use  select-one  or  select-any"><span class="u" id="1470158263.000522">2016:08:02 17:17:43            codonnell </span><span>and if you know you&apos;ll only be selecting one thing, you can use </span><code>select-one</code><span> or </span><code>select-any</code></div><div data-t="codonnell (`select` is in the  com.rpl.specter.macros  namespace)"><span class="u" id="1470158291.000523">2016:08:02 17:18:11            codonnell </span><span>(`select` is in the </span><code>com.rpl.specter.macros</code><span> namespace)</span></div><div data-t="nathanmarz @mfikes: sounds good"><span class="u" id="1470158487.000524">2016:08:02 17:21:27           nathanmarz </span><span>@mfikes: sounds good</span></div><div data-t="nathanmarz @codonnell @mattsfrey  select*  is the navigator implementation function, which is distinct from  select"><span class="u" id="1470158569.000525">2016:08:02 17:22:49           nathanmarz </span><span>@codonnell @mattsfrey </span><code>select*</code><span> is the navigator implementation function, which is distinct from </span><code>select</code></div><div data-t="nathanmarz select-any  (introduced in 0.12.0) is the most efficient way to get one result back"><span class="u" id="1470158591.000526">2016:08:02 17:23:11           nathanmarz </span><code>select-any</code><span> (introduced in 0.12.0) is the most efficient way to get one result back</span></div><div data-t="nathanmarz @codonnell @mattsfrey nevermind, just realized you were referring to the functional version of  select  macro"><span class="u" id="1470158647.000527">2016:08:02 17:24:07           nathanmarz </span><span>@codonnell @mattsfrey nevermind, just realized you were referring to the functional version of </span><code>select</code><span> macro</span></div><div data-t="nathanmarz the reason to use the macro is because it does inline caching of the navigation path, so is very efficient"><span class="u" id="1470158688.000528">2016:08:02 17:24:48           nathanmarz </span><span>the reason to use the macro is because it does inline caching of the navigation path, so is very efficient</span></div><div data-t="nathanmarz see  https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs  for details on that"><span class="u" id="1470158715.000529">2016:08:02 17:25:15           nathanmarz </span><span>see </span><a href="https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs">https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs</a><span> for details on that</span></div><div data-t="hueyp noob question … how do I combine clauses? ;p  (spec/comp-paths THINGS spec/ALL (and (spec/selected? :category #{&quot;A&quot;})
                                      (spec/not-selected? :id #{1 2})))"><span class="u" id="1470164572.000533">2016:08:02 19:02:52                hueyp </span><span>noob question … how do I combine clauses? ;p </span><pre>(spec/comp-paths THINGS spec/ALL (and (spec/selected? :category #{&quot;A&quot;})
                                      (spec/not-selected? :id #{1 2})))</pre></div><div data-t="nathanmarz @hueyp: just get rid of the  and"><span class="u" id="1470165001.000534">2016:08:02 19:10:01           nathanmarz </span><span>@hueyp: just get rid of the </span><code>and</code></div><div data-t="hueyp heh"><span class="u" id="1470165009.000535">2016:08:02 19:10:09                hueyp </span><span>heh</span></div><div data-t="nathanmarz (spec/comp-paths THINGS spec/ALL (spec/selected? :category #{&quot;A&quot;}) (spec/not-selected? :id #{1 2}))"><span class="u" id="1470165026.000536">2016:08:02 19:10:26           nathanmarz </span><code>(spec/comp-paths THINGS spec/ALL (spec/selected? :category #{&quot;A&quot;}) (spec/not-selected? :id #{1 2}))</code></div><div data-t="hueyp perfect thanks  🙂"><span class="u" id="1470165077.000537">2016:08:02 19:11:17                hueyp </span><span>perfect thanks </span><b>🙂</b></div><div data-t="puzzler If you know you are selecting one element, what are the pros and cons of choosing select-one or select-any vs select-first?"><span class="u" id="1470166597.000540">2016:08:02 19:36:37              puzzler </span><span>If you know you are selecting one element, what are the pros and cons of choosing select-one or select-any vs select-first?</span></div><div data-t="mattsfrey @nathanmarz: ahh, ok it&apos;s a macro"><span class="u" id="1470166612.000541">2016:08:02 19:36:52            mattsfrey </span><span>@nathanmarz: ahh, ok it&apos;s a macro</span></div><div data-t="nathanmarz @puzzler:  select-any  is the fastest"><span class="u" id="1470166654.000542">2016:08:02 19:37:34           nathanmarz </span><span>@puzzler: </span><code>select-any</code><span> is the fastest</span></div><div data-t="nathanmarz not really any perf difference between  select-one  and  select-first  (for now), they just have different semantics in terms of what happens if there&apos;s multiple elements to select"><span class="u" id="1470166688.000543">2016:08:02 19:38:08           nathanmarz </span><span>not really any perf difference between </span><code>select-one</code><span> and </span><code>select-first</code><span> (for now), they just have different semantics in terms of what happens if there&apos;s multiple elements to select</span></div><div data-t="codonnell @puzzler: Also,  select-one  will throw an exception if more than one result is found, while  select-first  and  select-any  will not (as you may infer from their names)"><span class="u" id="1470166851.000545">2016:08:02 19:40:51            codonnell </span><span>@puzzler: Also, </span><code>select-one</code><span> will throw an exception if more than one result is found, while </span><code>select-first</code><span> and </span><code>select-any</code><span> will not (as you may infer from their names)</span></div><div data-t="puzzler Is select-any in the latest stable version 0.11.2?  For some reason, although I&apos;m &quot;use&quot;ing the macros namespace, I&apos;m not seeing it."><span class="u" id="1470166979.000546">2016:08:02 19:42:59              puzzler </span><span>Is select-any in the latest stable version 0.11.2?  For some reason, although I&apos;m &quot;use&quot;ing the macros namespace, I&apos;m not seeing it.</span></div><div data-t="nathanmarz it&apos;s in 0.12.0"><span class="u" id="1470167024.000547">2016:08:02 19:43:44           nathanmarz </span><span>it&apos;s in 0.12.0</span></div><div data-t="nathanmarz should probably get around to releasing it"><span class="u" id="1470167042.000548">2016:08:02 19:44:02           nathanmarz </span><span>should probably get around to releasing it</span></div><div data-t="puzzler ah, ok."><span class="u" id="1470167044.000549">2016:08:02 19:44:04              puzzler </span><span>ah, ok.</span></div><div data-t="mattsfrey this question will probably sound dumb, but I can&apos;t for the the life of me figure out how to include the macros"><span class="u" id="1470167611.000550">2016:08:02 19:53:31            mattsfrey </span><span>this question will probably sound dumb, but I can&apos;t for the the life of me figure out how to include the macros</span></div><div data-t="mattsfrey (:require-macros [com.rpl.specter.macros])"><span class="u" id="1470167802.000552">2016:08:02 19:56:42            mattsfrey </span><span>(:require-macros [com.rpl.specter.macros])</span></div><div data-t="mattsfrey results in.."><span class="u" id="1470167804.000553">2016:08:02 19:56:44            mattsfrey </span><span>results in..</span></div><div data-t="mattsfrey #object[TypeError TypeError: undefined is not an object (evaluating &apos;bocl.account.data_test.select.call&apos;)]"><span class="u" id="1470167833.000554">2016:08:02 19:57:13            mattsfrey </span><span>#object[TypeError TypeError: undefined is not an object (evaluating &apos;bocl.account.data_test.select.call&apos;)]</span></div><div data-t="codonnell @mattsfrey: are you using clojure or clojurescript?"><span class="u" id="1470167837.000555">2016:08:02 19:57:17            codonnell </span><span>@mattsfrey: are you using clojure or clojurescript?</span></div><div data-t="mattsfrey clojurescript"><span class="u" id="1470167842.000556">2016:08:02 19:57:22            mattsfrey </span><span>clojurescript</span></div><div data-t="codonnell I haven&apos;t done much clojurescript; you have the correct namespace. Did you do a lein clean?"><span class="u" id="1470167937.000557">2016:08:02 19:58:57            codonnell </span><span>I haven&apos;t done much clojurescript; you have the correct namespace. Did you do a lein clean?</span></div><div data-t="mattsfrey yeah"><span class="u" id="1470167966.000558">2016:08:02 19:59:26            mattsfrey </span><span>yeah</span></div><div data-t="mattsfrey i can pull in the normal lib, but not the macros"><span class="u" id="1470167975.000559">2016:08:02 19:59:35            mattsfrey </span><span>i can pull in the normal lib, but not the macros</span></div><div data-t="mattsfrey &apos;select&apos; is always undefined"><span class="u" id="1470167983.000560">2016:08:02 19:59:43            mattsfrey </span><span>&apos;select&apos; is always undefined</span></div><div data-t="codonnell maybe you need it to be  (:require-macros [com.rpl.specter.macros :refer [select transform]]) ?"><span class="u" id="1470168075.000561">2016:08:02 20:01:15            codonnell </span><span>maybe you need it to be </span><code>(:require-macros [com.rpl.specter.macros :refer [select transform]])</code><span>?</span></div><div data-t="mattsfrey tried pretty much every permutation of :refer :all, :include-macros, etc etc and they all end up in error other than just (:require-macros [com.rpl.specter]), but that isn&apos;t actually incuding any macros"><span class="u" id="1470168081.000562">2016:08:02 20:01:21            mattsfrey </span><span>tried pretty much every permutation of :refer :all, :include-macros, etc etc and they all end up in error other than just (:require-macros [com.rpl.specter]), but that isn&apos;t actually incuding any macros</span></div><div data-t="codonnell hmm"><span class="u" id="1470168097.000563">2016:08:02 20:01:37            codonnell </span><span>hmm</span></div><div data-t="mattsfrey lol"><span class="u" id="1470168120.000564">2016:08:02 20:02:00            mattsfrey </span><span>lol</span></div><div data-t="mattsfrey including transform made it work"><span class="u" id="1470168128.000565">2016:08:02 20:02:08            mattsfrey </span><span>including transform made it work</span></div><div data-t="mattsfrey actually nvm"><span class="u" id="1470168183.000566">2016:08:02 20:03:03            mattsfrey </span><span>actually nvm</span></div><div data-t="mattsfrey (:require-macros [com.rpl.specter.macros :refer [select]])"><span class="u" id="1470168184.000567">2016:08:02 20:03:04            mattsfrey </span><span>(:require-macros [com.rpl.specter.macros :refer [select]])</span></div><div data-t="mattsfrey does work"><span class="u" id="1470168188.000568">2016:08:02 20:03:08            mattsfrey </span><span>does work</span></div><div data-t="codonnell ok, good"><span class="u" id="1470168294.000569">2016:08:02 20:04:54            codonnell </span><span>ok, good</span></div><div data-t="mattsfrey definitely have to refer whichever ones you need though"><span class="u" id="1470168310.000570">2016:08:02 20:05:10            mattsfrey </span><span>definitely have to refer whichever ones you need though</span></div><div data-t="mattsfrey :refer :all and :refer-all causes build errors"><span class="u" id="1470168324.000571">2016:08:02 20:05:24            mattsfrey </span><span>:refer :all and :refer-all causes build errors</span></div><div data-t="codonnell that&apos;s good to know"><span class="u" id="1470168373.000572">2016:08:02 20:06:13            codonnell </span><span>that&apos;s good to know</span></div><div data-t="mattsfrey anyone know how to get the ALL keyword?"><span class="u" id="1470170104.000574">2016:08:02 20:35:04            mattsfrey </span><span>anyone know how to get the ALL keyword?</span></div><div data-t="mattsfrey doesn&apos;t seem to be part of macros or the core"><span class="u" id="1470170113.000575">2016:08:02 20:35:13            mattsfrey </span><span>doesn&apos;t seem to be part of macros or the core</span></div><div data-t="codonnell it should be in  com.rpl.specter"><span class="u" id="1470170226.000576">2016:08:02 20:37:06            codonnell </span><span>it should be in </span><code>com.rpl.specter</code></div><div data-t="nathanmarz @mattsfrey:  https://nathanmarz.github.io/specter/"><span class="u" id="1470170285.000577">2016:08:02 20:38:05           nathanmarz </span><span>@mattsfrey: </span><a href="https://nathanmarz.github.io/specter/">https://nathanmarz.github.io/specter/</a></div><div data-t="hueyp is there clojure sugar around importing both ns&apos;s as the same alias? e.g.  (s/select [s/ALL] things)"><span class="u" id="1470170584.000578">2016:08:02 20:43:04                hueyp </span><span>is there clojure sugar around importing both ns&apos;s as the same alias? e.g. </span><code>(s/select [s/ALL] things)</code></div><div data-t="nathanmarz @hueyp: not that I know of"><span class="u" id="1470171083.000579">2016:08:02 20:51:23           nathanmarz </span><span>@hueyp: not that I know of</span></div><div data-t="nathanmarz @hueyp: I use  https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj  to get everything into the same namespace"><span class="u" id="1470171115.000580">2016:08:02 20:51:55           nathanmarz </span><span>@hueyp: I use </span><a href="https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj">https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj</a><span> to get everything into the same namespace</span></div><div data-t="hueyp thanks~  upgrading 10 -&gt; 11 so was wondering if any tricks  🙂"><span class="u" id="1470171445.000583">2016:08:02 20:57:25                hueyp </span><span>thanks~  upgrading 10 -&gt; 11 so was wondering if any tricks </span><b>🙂</b></div><div data-t="puzzler It appears that transform [ALL] on a lazy sequence does not produce a lazy sequence.  Is there a way to make it operate in a lazy fashion?"><span class="u" id="1470172301.000587">2016:08:02 21:11:41              puzzler </span><span>It appears that transform [ALL] on a lazy sequence does not produce a lazy sequence.  Is there a way to make it operate in a lazy fashion?</span></div><div data-t="nathanmarz @puzzler: you would need to make a new navigator for that"><span class="u" id="1470172519.000588">2016:08:02 21:15:19           nathanmarz </span><span>@puzzler: you would need to make a new navigator for that</span></div><div data-t="nathanmarz ALL  could have been implemented to work differently for lazy sequences, but I think it&apos;s better for lazy behavior to be explicit"><span class="u" id="1470172598.000589">2016:08:02 21:16:38           nathanmarz </span><code>ALL</code><span> could have been implemented to work differently for lazy sequences, but I think it&apos;s better for lazy behavior to be explicit</span></div><div data-t="hueyp not sure which construct in specter I’d want to use … I have this:  (defn Foo
  [foo-id]
  [(spec/selected? :type #{&quot;foo&quot;}) (spec/selected? :id #{foo-id})])

(select [THINGS (Foo &quot;bar&quot;)]
        things)
  … which works, but I feel is wrong  🙂 .  I can move it to  declarepath  /  providepath  but wondering if it should use something else"><span class="u" id="1470179703.000594">2016:08:02 23:15:03                hueyp </span><span>not sure which construct in specter I’d want to use … I have this: </span><pre>(defn Foo
  [foo-id]
  [(spec/selected? :type #{&quot;foo&quot;}) (spec/selected? :id #{foo-id})])

(select [THINGS (Foo &quot;bar&quot;)]
        things)
</pre><span> … which works, but I feel is wrong </span><b>🙂</b><span>.  I can move it to </span><code>declarepath</code><span> / </span><code>providepath</code><span> but wondering if it should use something else</span></div><div data-t="hueyp this example could also just be a predicate fn, but other examples include navigation~"><span class="u" id="1470179839.000595">2016:08:02 23:17:19                hueyp </span><span>this example could also just be a predicate fn, but other examples include navigation~</span></div><div data-t="hueyp attempt at  declarepath  /  provide  path is  (declarepath Foo [foo-id])
(providepath Foo
             [(spec/selected? :type #{&quot;foo&quot;})
              (spec/selected? :id (paramsfn [foo-id] [id] (= foo-id id)))])
"><span class="u" id="1470179858.000596">2016:08:02 23:17:38                hueyp </span><span>attempt at </span><code>declarepath</code><span> / </span><code>provide</code><span> path is </span><pre>(declarepath Foo [foo-id])
(providepath Foo
             [(spec/selected? :type #{&quot;foo&quot;})
              (spec/selected? :id (paramsfn [foo-id] [id] (= foo-id id)))])
</pre></div><div data-t="hueyp first time using  paramsfn  … I think it works?  😜"><span class="u" id="1470179890.000597">2016:08:02 23:18:10                hueyp </span><span>first time using </span><code>paramsfn</code><span> … I think it works? </span><b>😜</b></div><div data-t="nathanmarz @hueyp: use  comp-paths"><span class="u" id="1470179919.000598">2016:08:02 23:18:39           nathanmarz </span><span>@hueyp: use </span><code>comp-paths</code></div><div data-t="nathanmarz (def Foo
  (comp-paths
    (spec/selected? :type #{&quot;foo&quot;})
    (spec/selected? :id (paramsfn [foo-id] [id] (= foo-id id)))))
"><span class="u" id="1470179923.000599">2016:08:02 23:18:43           nathanmarz </span><pre>(def Foo
  (comp-paths
    (spec/selected? :type #{&quot;foo&quot;})
    (spec/selected? :id (paramsfn [foo-id] [id] (= foo-id id)))))
</pre></div><div data-t="hueyp ah yes"><span class="u" id="1470179938.000600">2016:08:02 23:18:58                hueyp </span><span>ah yes</span></div><div data-t="nathanmarz declarepath /`providepath` is for defining recursive navigators"><span class="u" id="1470179944.000601">2016:08:02 23:19:04           nathanmarz </span><code>declarepath</code><span>/`providepath` is for defining recursive navigators</span></div><div data-t="hueyp I saw the example with  comp-paths  in tests but it didn’t click"><span class="u" id="1470179965.000602">2016:08:02 23:19:25                hueyp </span><span>I saw the example with </span><code>comp-paths</code><span> in tests but it didn’t click</span></div><div data-t="hueyp yah, I felt like those were wrong"><span class="u" id="1470179973.000603">2016:08:02 23:19:33                hueyp </span><span>yah, I felt like those were wrong</span></div><div data-t="hueyp the declare stuff"><span class="u" id="1470179976.000604">2016:08:02 23:19:36                hueyp </span><span>the declare stuff</span></div><div data-t="nathanmarz comp-paths  result will be high performance and can be further composed with other navigators without its params"><span class="u" id="1470180008.000605">2016:08:02 23:20:08           nathanmarz </span><code>comp-paths</code><span> result will be high performance and can be further composed with other navigators without its params</span></div><div data-t="hueyp thanks much  🙂"><span class="u" id="1470180022.000606">2016:08:02 23:20:22                hueyp </span><span>thanks much </span><b>🙂</b></div><div data-t="nathanmarz no problem"><span class="u" id="1470180037.000607">2016:08:02 23:20:37           nathanmarz </span><span>no problem</span></div><div data-t="borkdude is it possible to transform the keys in a map on just one level with specter?"><span class="u" id="1470210181.000631">2016:08:03 07:43:01             borkdude </span><span>is it possible to transform the keys in a map on just one level with specter?</span></div><div data-t="borkdude for example  {:a 1, :b {:c 2}} =&gt; {:aa 1, :bb {:c 2}}"><span class="u" id="1470210202.000632">2016:08:03 07:43:22             borkdude </span><span>for example </span><code>{:a 1, :b {:c 2}} =&gt; {:aa 1, :bb {:c 2}}</code></div><div data-t="borkdude so, this example:  https://clojurians.slack.com/archives/clojure/p1470213401002703"><span class="u" id="1470221632.000645">2016:08:03 10:53:52             borkdude </span><span>so, this example: </span><a href="https://clojurians.slack.com/archives/clojure/p1470213401002703">https://clojurians.slack.com/archives/clojure/p1470213401002703</a></div><div data-t="borkdude (defnav KW-NS []
  (select* [this kw next-fn]
    (next-fn (namespace kw)))
  (transform* [this kw next-fn]
    (let [kw-name (name kw)
          new-ns (next-fn (namespace kw))]
      (keyword new-ns kw-name)
      )))

(setval [ALL FIRST KW-NS] &quot;user&quot; {:a 1 :b 2 :c 3})
;; =&gt; {:user/a 1, :user/b 2, :user/c 3}
"><span class="u" id="1470221647.000647">2016:08:03 10:54:07             borkdude </span><pre>(defnav KW-NS []
  (select* [this kw next-fn]
    (next-fn (namespace kw)))
  (transform* [this kw next-fn]
    (let [kw-name (name kw)
          new-ns (next-fn (namespace kw))]
      (keyword new-ns kw-name)
      )))

(setval [ALL FIRST KW-NS] &quot;user&quot; {:a 1 :b 2 :c 3})
;; =&gt; {:user/a 1, :user/b 2, :user/c 3}
</pre></div><div data-t="borkdude how does it work?"><span class="u" id="1470221653.000648">2016:08:03 10:54:13             borkdude </span><span>how does it work?</span></div><div data-t="nathanmarz so KW-NS navigates to the namespace portion of a keyword"><span class="u" id="1470221671.000649">2016:08:03 10:54:31           nathanmarz </span><span>so KW-NS navigates to the namespace portion of a keyword</span></div><div data-t="nathanmarz is it the defnav portion that you&apos;re asking about in particular?"><span class="u" id="1470221695.000650">2016:08:03 10:54:55           nathanmarz </span><span>is it the defnav portion that you&apos;re asking about in particular?</span></div><div data-t="borkdude yes"><span class="u" id="1470221700.000651">2016:08:03 10:55:00             borkdude </span><span>yes</span></div><div data-t="nathanmarz there&apos;s two code paths, one for select and one for transform"><span class="u" id="1470221716.000652">2016:08:03 10:55:16           nathanmarz </span><span>there&apos;s two code paths, one for select and one for transform</span></div><div data-t="nathanmarz select must call next-fn on the &quot;navigated to value(s)&quot;"><span class="u" id="1470221727.000653">2016:08:03 10:55:27           nathanmarz </span><span>select must call next-fn on the &quot;navigated to value(s)&quot;</span></div><div data-t="nathanmarz in this case, it&apos;s just  (next-fn (namespace kw))"><span class="u" id="1470221742.000654">2016:08:03 10:55:42           nathanmarz </span><span>in this case, it&apos;s just </span><code>(next-fn (namespace kw))</code></div><div data-t="borkdude @nathanmarz: what is next-fn in the example with setval?"><span class="u" id="1470221752.000655">2016:08:03 10:55:52             borkdude </span><span>@nathanmarz: what is next-fn in the example with setval?</span></div><div data-t="nathanmarz it&apos;s the rest of the navigation + final transformation"><span class="u" id="1470221771.000656">2016:08:03 10:56:11           nathanmarz </span><span>it&apos;s the rest of the navigation + final transformation</span></div><div data-t="nathanmarz so in this case next-fn will be (fn [v] &quot;user&quot;)"><span class="u" id="1470221785.000657">2016:08:03 10:56:25           nathanmarz </span><span>so in this case next-fn will be (fn [v] &quot;user&quot;)</span></div><div data-t="nathanmarz if there was more navigation after KW-NS, it would be the transform* code paths for the subsequent navigators"><span class="u" id="1470221807.000658">2016:08:03 10:56:47           nathanmarz </span><span>if there was more navigation after KW-NS, it would be the transform* code paths for the subsequent navigators</span></div><div data-t="borkdude @nathanmarz: specter takes constants and interprets it as a function?"><span class="u" id="1470221814.000659">2016:08:03 10:56:54             borkdude </span><span>@nathanmarz: specter takes constants and interprets it as a function?</span></div><div data-t="nathanmarz setval is a thin wrapper around transform"><span class="u" id="1470221825.000660">2016:08:03 10:57:05           nathanmarz </span><span>setval is a thin wrapper around transform</span></div><div data-t="nathanmarz (setval [ALL FIRST KW-NS] &quot;user&quot; {:a 1 :b 2 :c 3})  ==  (transform [ALL FIRST KW-NS] (fn [_] &quot;user&quot;) {:a 1 :b 2 :c 3})"><span class="u" id="1470221863.000661">2016:08:03 10:57:43           nathanmarz </span><code>(setval [ALL FIRST KW-NS] &quot;user&quot; {:a 1 :b 2 :c 3})</code><span> == </span><code>(transform [ALL FIRST KW-NS] (fn [_] &quot;user&quot;) {:a 1 :b 2 :c 3})</code></div><div data-t="borkdude ok understood that part"><span class="u" id="1470221876.000662">2016:08:03 10:57:56             borkdude </span><span>ok understood that part</span></div><div data-t="borkdude I think I&apos;ll just have to read up on the defnav docs"><span class="u" id="1470221903.000663">2016:08:03 10:58:23             borkdude </span><span>I think I&apos;ll just have to read up on the defnav docs</span></div><div data-t="nathanmarz here&apos;s how two navigators get composed into one navigator:  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L345"><span class="u" id="1470221974.000664">2016:08:03 10:59:34           nathanmarz </span><span>here&apos;s how two navigators get composed into one navigator: </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L345">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L345</a></div><div data-t="nathanmarz that&apos;s the core of how specter works"><span class="u" id="1470221996.000666">2016:08:03 10:59:56           nathanmarz </span><span>that&apos;s the core of how specter works</span></div><div data-t="nathanmarz your linear path of navigators becomes a single nested function"><span class="u" id="1470222020.000667">2016:08:03 11:00:20           nathanmarz </span><span>your linear path of navigators becomes a single nested function</span></div><div data-t="borkdude I think I&apos;m getting it, but you could also have written:  (transform [ALL FIRST] (fn [kw] (keyword &quot;user&quot; (name kw))))  right? but your example is more abstract"><span class="u" id="1470222040.000668">2016:08:03 11:00:40             borkdude </span><span>I think I&apos;m getting it, but you could also have written: </span><code>(transform [ALL FIRST] (fn [kw] (keyword &quot;user&quot; (name kw))))</code><span> right? but your example is more abstract</span></div><div data-t="nathanmarz correct"><span class="u" id="1470222055.000669">2016:08:03 11:00:55           nathanmarz </span><span>correct</span></div><div data-t="nathanmarz much more reusable and composable"><span class="u" id="1470222068.000670">2016:08:03 11:01:08           nathanmarz </span><span>much more reusable and composable</span></div><div data-t="borkdude cool stuff  🙂"><span class="u" id="1470222078.000671">2016:08:03 11:01:18             borkdude </span><span>cool stuff </span><b>🙂</b></div><div data-t="borkdude any reason specter is still using cljx? compatibility with previous clj versions?"><span class="u" id="1470222163.000672">2016:08:03 11:02:43             borkdude </span><span>any reason specter is still using cljx? compatibility with previous clj versions?</span></div><div data-t="nathanmarz yea"><span class="u" id="1470222213.000673">2016:08:03 11:03:33           nathanmarz </span><span>yea</span></div><div data-t="nathanmarz though finally dropping support for 1.6 as of specter 0.12.0"><span class="u" id="1470222249.000674">2016:08:03 11:04:09           nathanmarz </span><span>though finally dropping support for 1.6 as of specter 0.12.0</span></div><div data-t="nathanmarz just need to do the work now of porting to cljc"><span class="u" id="1470222260.000675">2016:08:03 11:04:20           nathanmarz </span><span>just need to do the work now of porting to cljc</span></div><div data-t="jjcomer @nathanmarz: Any chance you could release 0.12.0 in the near future? We are looking to cut a release of our service pretty soon and require the fixes in 0.12.0"><span class="u" id="1470337817.000772">2016:08:04 19:10:17              jjcomer </span><span>@nathanmarz: Any chance you could release 0.12.0 in the near future? We are looking to cut a release of our service pretty soon and require the fixes in 0.12.0</span></div><div data-t="hueyp master builds fine for us if you clone / build locally (we needed aot fix)"><span class="u" id="1470344697.000779">2016:08:04 21:04:57                hueyp </span><span>master builds fine for us if you clone / build locally (we needed aot fix)</span></div><div data-t="esirola hi, is it possible to implement something similar to a &quot;group-by&quot; operation with specter?"><span class="u" id="1470378630.000808">2016:08:05 06:30:30              esirola </span><span>hi, is it possible to implement something similar to a &quot;group-by&quot; operation with specter?</span></div><div data-t="esirola i&apos;d like to do something like  [{:a 1, :b 1} {:a 1, :b 2} {:a 2, :b 2}] -&gt; [{:a 1, :b [1 2]} {:a 2, :b [2]}]"><span class="u" id="1470378751.000809">2016:08:05 06:32:31              esirola </span><span>i&apos;d like to do something like </span><pre>[{:a 1, :b 1} {:a 1, :b 2} {:a 2, :b 2}] -&gt; [{:a 1, :b [1 2]} {:a 2, :b [2]}]</pre></div><div data-t="esirola ... and I&apos;m a bit puzzled"><span class="u" id="1470378822.000811">2016:08:05 06:33:42              esirola </span><span>... and I&apos;m a bit puzzled</span></div><div data-t="esirola you need to accumulate things while you traverse the collection somewhere, but I can&apos;t figure out how (if possible)"><span class="u" id="1470378960.000812">2016:08:05 06:36:00              esirola </span><span>you need to accumulate things while you traverse the collection somewhere, but I can&apos;t figure out how (if possible)</span></div><div data-t="nathanmarz @jjcomer: will do once clojars comes back up"><span class="u" id="1470390713.000819">2016:08:05 09:51:53           nathanmarz </span><span>@jjcomer: will do once clojars comes back up</span></div><div data-t="nathanmarz @esirola: I&apos;m not sure how to express that with navigation"><span class="u" id="1470390831.000821">2016:08:05 09:53:51           nathanmarz </span><span>@esirola: I&apos;m not sure how to express that with navigation</span></div><div data-t="nathanmarz released 0.12.0:  https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><span class="u" id="1470391964.000824">2016:08:05 10:12:44           nathanmarz </span><span>released 0.12.0: </span><a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></div><div data-t="esirola @nathanmarz: ok thanks a lot"><span class="u" id="1470392801.000826">2016:08:05 10:26:41              esirola </span><span>@nathanmarz: ok thanks a lot</span></div><div data-t="borkdude @esirola: I just implemented it as an exercise, not with Specter: 
 (let [data [{:a 1, :b 1} {:a 1, :b 2} {:a 2, :b 2}]]
       #_=&gt;   (reduce (fn [acc [k v]] (conj acc {:a k :b (mapv :b v)})) [] (group-by :a data)))
"><span class="u" id="1470393140.000828">2016:08:05 10:32:20             borkdude </span><span>@esirola: I just implemented it as an exercise, not with Specter: 
</span><pre>(let [data [{:a 1, :b 1} {:a 1, :b 2} {:a 2, :b 2}]]
       #_=&gt;   (reduce (fn [acc [k v]] (conj acc {:a k :b (mapv :b v)})) [] (group-by :a data)))
</pre></div><div data-t="jjcomer @nathanmarz: Thanks!"><span class="u" id="1470399708.000838">2016:08:05 12:21:48              jjcomer </span><span>@nathanmarz: Thanks!</span></div><div data-t="borkdude What is the reason one path is called FIRST and another MAP-VALS, why not FIRST and SECOND?"><span class="u" id="1470410082.000849">2016:08:05 15:14:42             borkdude </span><span>What is the reason one path is called FIRST and another MAP-VALS, why not FIRST and SECOND?</span></div><div data-t="nathanmarz @borkdude: MAP-VALS navigates to each value of a map, has nothing to do with  second"><span class="u" id="1470411242.000850">2016:08:05 15:34:02           nathanmarz </span><span>@borkdude: MAP-VALS navigates to each value of a map, has nothing to do with </span><code>second</code></div><div data-t="borkdude @nathanmarz: ah, I mean [ALL FIRST] vs [MAP-VALS] - why is there no MAP-KEYS?"><span class="u" id="1470411656.000851">2016:08:05 15:40:56             borkdude </span><span>@nathanmarz: ah, I mean [ALL FIRST] vs [MAP-VALS] - why is there no MAP-KEYS?</span></div><div data-t="borkdude because this case is rare, probably"><span class="u" id="1470411819.000852">2016:08:05 15:43:39             borkdude </span><span>because this case is rare, probably</span></div><div data-t="nathanmarz yea"><span class="u" id="1470411827.000853">2016:08:05 15:43:47           nathanmarz </span><span>yea</span></div><div data-t="nathanmarz there could be a MAP-KEYS that&apos;s more efficient than ALL FIRST but I&apos;ve never needed that"><span class="u" id="1470411846.000854">2016:08:05 15:44:06           nathanmarz </span><span>there could be a MAP-KEYS that&apos;s more efficient than ALL FIRST but I&apos;ve never needed that</span></div><div data-t="nathanmarz whereas MAP-VALS comes up all the time, so having an optimized version provides a lot of value"><span class="u" id="1470411859.000855">2016:08:05 15:44:19           nathanmarz </span><span>whereas MAP-VALS comes up all the time, so having an optimized version provides a lot of value</span></div><div data-t="nathanmarz you can do  (def MAP-KEYS (comp-paths ALL FIRST))  if you want something reusable"><span class="u" id="1470411892.000856">2016:08:05 15:44:52           nathanmarz </span><span>you can do </span><code>(def MAP-KEYS (comp-paths ALL FIRST))</code><span> if you want something reusable</span></div><div data-t="borkdude I was just wondering, didn&apos;t really need it"><span class="u" id="1470411942.000857">2016:08:05 15:45:42             borkdude </span><span>I was just wondering, didn&apos;t really need it</span></div><div data-t="nathanmarz pretty much everything in Specter grew out of real use cases"><span class="u" id="1470411995.000859">2016:08:05 15:46:35           nathanmarz </span><span>pretty much everything in Specter grew out of real use cases</span></div><div data-t="borkdude I needed it when I wanted to solve a stackoverflow question though, I had to transform the keys"><span class="u" id="1470412010.000860">2016:08:05 15:46:50             borkdude </span><span>I needed it when I wanted to solve a stackoverflow question though, I had to transform the keys</span></div><div data-t="jjunior130 I require both  com.rpl.specter  &amp;  com.rpl.specter.macros  namespaces in ClojureScript"><span class="u" id="1470629610.001023">2016:08:08 04:13:30           jjunior130 </span><span>I require both </span><code>com.rpl.specter</code><span> &amp; </span><code>com.rpl.specter.macros</code><span> namespaces in ClojureScript</span></div><div data-t="jjunior130 all symbols from  com.rpl.specter  work but not  com.rpl.specter.macros"><span class="u" id="1470629718.001025">2016:08:08 04:15:18           jjunior130 </span><span>all symbols from </span><code>com.rpl.specter</code><span> work but not </span><code>com.rpl.specter.macros</code></div><div data-t="jjunior130 when I try a symbol from  com.rpl.specter.macros  such as  transform  I get this error message:
 Uncaught TypeError: Cannot read property &apos;cljs$core$IFn$_invoke$arity$1&apos; of undefined
core.js [32556]	anonymous
core.js [19022]	anonymous
core.js [19023]	anonymous
core.js [19038]	cljs.core.PersistentVector.cljs$core$IReduce$_reduce$arity$3
core.js [7719]	cljs.core.reduce.cljs$core$IFn$_invoke$arity$3
core.js [32555]	cljs$core$group_by
views.js?zx=ibkddq5mtrqz [72]	anonymous
specter.js [975]	$rpl$specter$protocols$Navigator$transform_STAR_$arity$3
protocols.js [46]	com$rpl$specter$protocols$transform_STAR_
impl.js [2175]	com.rpl.specter.impl.structure_path_impl
impl.js [2202]	anonymous
impl.js [2371]	anonymous
core.js [16854]	anonymous
core.js [16855]	cljs.core.map.cljs$core$IFn$_invoke$arity$2
core.js [10895]	cljs.core.LazySeq.sval
core.js [11046]	cljs.core.LazySeq.cljs$core$ISeqable$_seq$arity$1
core.js [4117]	cljs$core$seq
core.js [30313]	cljs.core.dorun.cljs$core$IFn$_invoke$arity$1
core.js [30381]	cljs.core.doall.cljs$core$IFn$_invoke$arity$1
core.js [30367]	cljs$core$doall
impl.js [3239]	com.rpl.specter.impl.all_transform._
impl.js [3177]	com$rpl$specter$impl$all_transform
impl.js [3280]	$rpl$specter$protocols$Navigator$transform_STAR_$arity$3
protocols.js [46]	com$rpl$specter$protocols$transform_STAR_
impl.js [2175]	com.rpl.specter.impl.structure_path_impl
impl.js [2202]	anonymous
impl.js [2369]	com.rpl.specter.impl.combine_same_types.combiner
impl.js [284]	anonymous
impl.js [3112]	com$rpl$specter$impl$compiled_transform_STAR_
views.js?zx=ibkddq5mtrqz [54]	anonymous
"><span class="u" id="1470629783.001026">2016:08:08 04:16:23           jjunior130 </span><span>when I try a symbol from </span><code>com.rpl.specter.macros</code><span> such as </span><code>transform</code><span> I get this error message:
</span><pre>Uncaught TypeError: Cannot read property &apos;cljs$core$IFn$_invoke$arity$1&apos; of undefined
core.js [32556]	anonymous
core.js [19022]	anonymous
core.js [19023]	anonymous
core.js [19038]	cljs.core.PersistentVector.cljs$core$IReduce$_reduce$arity$3
core.js [7719]	cljs.core.reduce.cljs$core$IFn$_invoke$arity$3
core.js [32555]	cljs$core$group_by
views.js?zx=ibkddq5mtrqz [72]	anonymous
specter.js [975]	$rpl$specter$protocols$Navigator$transform_STAR_$arity$3
protocols.js [46]	com$rpl$specter$protocols$transform_STAR_
impl.js [2175]	com.rpl.specter.impl.structure_path_impl
impl.js [2202]	anonymous
impl.js [2371]	anonymous
core.js [16854]	anonymous
core.js [16855]	cljs.core.map.cljs$core$IFn$_invoke$arity$2
core.js [10895]	cljs.core.LazySeq.sval
core.js [11046]	cljs.core.LazySeq.cljs$core$ISeqable$_seq$arity$1
core.js [4117]	cljs$core$seq
core.js [30313]	cljs.core.dorun.cljs$core$IFn$_invoke$arity$1
core.js [30381]	cljs.core.doall.cljs$core$IFn$_invoke$arity$1
core.js [30367]	cljs$core$doall
impl.js [3239]	com.rpl.specter.impl.all_transform._
impl.js [3177]	com$rpl$specter$impl$all_transform
impl.js [3280]	$rpl$specter$protocols$Navigator$transform_STAR_$arity$3
protocols.js [46]	com$rpl$specter$protocols$transform_STAR_
impl.js [2175]	com.rpl.specter.impl.structure_path_impl
impl.js [2202]	anonymous
impl.js [2369]	com.rpl.specter.impl.combine_same_types.combiner
impl.js [284]	anonymous
impl.js [3112]	com$rpl$specter$impl$compiled_transform_STAR_
views.js?zx=ibkddq5mtrqz [54]	anonymous
</pre></div><div data-t="jjunior130 I have ran  lein clean  and  lein cljsbuild once"><span class="u" id="1470630030.001030">2016:08:08 04:20:30           jjunior130 </span><span>I have ran </span><code>lein clean</code><span> and </span><code>lein cljsbuild once</code></div><div data-t="esirola @borkdude: yes, I guess one can &quot;select&quot; with specter producing something like the maps you worked on and then use something like the code you posted to perform the aggregations"><span class="u" id="1470640878.001040">2016:08:08 07:21:18              esirola </span><span>@borkdude: yes, I guess one can &quot;select&quot; with specter producing something like the maps you worked on and then use something like the code you posted to perform the aggregations</span></div><div data-t="yonatanel I want to get a deeply nested map value from a parsed SOAP response, so the value of key :contents when the :tag value is :second or any other I choose. I used walker but I wonder if there&apos;s a more elegant way:
 (select-one [(walker #(= :second (:tag %))) :content FIRST] parsed-soap)
=&gt;
&quot;123&quot; 

parsed-soap is
 {:tag :soap:Envelope,
 :attrs {:xmlns:xsi &quot;&quot;,
         :xmlns:xsd &quot;&quot;,
         :xmlns:soap &quot;&quot;},
 :content [{:tag :soap:Body,
            :attrs nil,
            :content [{:tag :aResponse
                       :attrs {:xmlns:a &quot;&quot;},
                       :content [{:tag :a:aResult,
                                  :attrs nil,
                                  :content [{:tag :first
                                             :attrs {:xsi:nil &quot;true&quot;, :xmlns &quot;&quot;},
                                             :content nil}
                                            {:tag :second
                                             :attrs {:xmlns &quot;&quot;},
                                             :content [&quot;123&quot;]}
                                            {:tag :third,
                                             :attrs {:xsi:nil &quot;true&quot;, :xmlns &quot;&quot;},
                                             :content nil}]}]}]}]}"><span class="u" id="1470649109.001046">2016:08:08 09:38:29            yonatanel </span><span>I want to get a deeply nested map value from a parsed SOAP response, so the value of key :contents when the :tag value is :second or any other I choose. I used walker but I wonder if there&apos;s a more elegant way:
</span><pre>(select-one [(walker #(= :second (:tag %))) :content FIRST] parsed-soap)
=&gt;
&quot;123&quot;</pre><span>

parsed-soap is
</span><pre>{:tag :soap:Envelope,
 :attrs {:xmlns:xsi &quot;&quot;,
         :xmlns:xsd &quot;&quot;,
         :xmlns:soap &quot;&quot;},
 :content [{:tag :soap:Body,
            :attrs nil,
            :content [{:tag :aResponse
                       :attrs {:xmlns:a &quot;&quot;},
                       :content [{:tag :a:aResult,
                                  :attrs nil,
                                  :content [{:tag :first
                                             :attrs {:xsi:nil &quot;true&quot;, :xmlns &quot;&quot;},
                                             :content nil}
                                            {:tag :second
                                             :attrs {:xmlns &quot;&quot;},
                                             :content [&quot;123&quot;]}
                                            {:tag :third,
                                             :attrs {:xsi:nil &quot;true&quot;, :xmlns &quot;&quot;},
                                             :content nil}]}]}]}]}</pre></div><div data-t="nathanmarz @jjunior130: what version and what&apos;s the exact code you&apos;re running?"><span class="u" id="1470650357.001049">2016:08:08 09:59:17           nathanmarz </span><span>@jjunior130: what version and what&apos;s the exact code you&apos;re running?</span></div><div data-t="nathanmarz @yonatanel: my only issue with that code is it relies on a strange property of clojure which is that you can do map lookups on non-map values without error"><span class="u" id="1470650594.001050">2016:08:08 10:03:14           nathanmarz </span><span>@yonatanel: my only issue with that code is it relies on a strange property of clojure which is that you can do map lookups on non-map values without error</span></div><div data-t="nathanmarz since walker will run that function on everything it finds"><span class="u" id="1470650611.001051">2016:08:08 10:03:31           nathanmarz </span><span>since walker will run that function on everything it finds</span></div><div data-t="nathanmarz that also makes that particular path less performant than ideal"><span class="u" id="1470650628.001052">2016:08:08 10:03:48           nathanmarz </span><span>that also makes that particular path less performant than ideal</span></div><div data-t="nathanmarz the alternative is to explicitly make a recursive navigator that understands the particular structure of this data"><span class="u" id="1470650650.001053">2016:08:08 10:04:10           nathanmarz </span><span>the alternative is to explicitly make a recursive navigator that understands the particular structure of this data</span></div><div data-t="nathanmarz @yonatanel: 
 (declarepath SoapPath)
(providepath SoapPath
  (continue-then-stay
    :content
    ALL
    SoapPath
    ))

(select-one [SoapPath #(= :second (:tag %)) :content FIRST] parsed-soap)
"><span class="u" id="1470651001.001054">2016:08:08 10:10:01           nathanmarz </span><span>@yonatanel: 
</span><pre>(declarepath SoapPath)
(providepath SoapPath
  (continue-then-stay
    :content
    ALL
    SoapPath
    ))

(select-one [SoapPath #(= :second (:tag %)) :content FIRST] parsed-soap)
</pre></div><div data-t="yonatanel @nathanmarz: can one be compiled by running an example first? Could be nice to tell it to walk the structure and learn for next time."><span class="u" id="1470651045.001055">2016:08:08 10:10:45            yonatanel </span><span>@nathanmarz: can one be compiled by running an example first? Could be nice to tell it to walk the structure and learn for next time.</span></div><div data-t="nathanmarz you mean use  walker  and then have it &quot;learn&quot; the path that I wrote?"><span class="u" id="1470651092.001056">2016:08:08 10:11:32           nathanmarz </span><span>you mean use </span><code>walker</code><span> and then have it &quot;learn&quot; the path that I wrote?</span></div><div data-t="yonatanel yes, assuming it works. I don&apos;t entirely understand it yet."><span class="u" id="1470651231.001057">2016:08:08 10:13:51            yonatanel </span><span>yes, assuming it works. I don&apos;t entirely understand it yet.</span></div><div data-t="nathanmarz it&apos;s an interesting idea but seems like it would be full of minefields"><span class="u" id="1470651380.001058">2016:08:08 10:16:20           nathanmarz </span><span>it&apos;s an interesting idea but seems like it would be full of minefields</span></div><div data-t="nathanmarz there&apos;s no way for walker to know that the data structure is recursive, for one"><span class="u" id="1470651395.001059">2016:08:08 10:16:35           nathanmarz </span><span>there&apos;s no way for walker to know that the data structure is recursive, for one</span></div><div data-t="shader any chance we could get anonymous recursive navigation? so you don&apos;t have to separately declare/provide the navigator? It seems to be a very common pattern"><span class="u" id="1470663494.001070">2016:08:08 13:38:14               shader </span><span>any chance we could get anonymous recursive navigation? so you don&apos;t have to separately declare/provide the navigator? It seems to be a very common pattern</span></div><div data-t="nathanmarz @shader: you can open up an issue for it"><span class="u" id="1470664800.001075">2016:08:08 14:00:00           nathanmarz </span><span>@shader: you can open up an issue for it</span></div><div data-t="jjunior130 @nathanmarz: nvm, it&apos;s working now. After I  lein clean  &amp;  lein cljsbuild once  yesterday, all I did between then and now was reboot my computer. Probably I didn&apos;t restart the repl I was in yesterday (I thought I did). I&apos;m good now. Namespace  com.rpl.specter.macros  is working now."><span class="u" id="1470691126.001096">2016:08:08 21:18:46           jjunior130 </span><span>@nathanmarz: nvm, it&apos;s working now. After I </span><code>lein clean</code><span> &amp; </span><code>lein cljsbuild once</code><span> yesterday, all I did between then and now was reboot my computer. Probably I didn&apos;t restart the repl I was in yesterday (I thought I did). I&apos;m good now. Namespace </span><code>com.rpl.specter.macros</code><span> is working now.</span></div><div data-t="nathanmarz @jjunior130: good to hear"><span class="u" id="1470691185.001097">2016:08:08 21:19:45           nathanmarz </span><span>@jjunior130: good to hear</span></div><div data-t="yonatanel Any plans for a lookahead navigator, for example to select a map value if a sibling descendant matches a predicate?"><span class="u" id="1470727373.001125">2016:08:09 07:22:53            yonatanel </span><span>Any plans for a lookahead navigator, for example to select a map value if a sibling descendant matches a predicate?</span></div><div data-t="codonnell @yonatanel: you could do something like that with  selected?"><span class="u" id="1470727491.001126">2016:08:09 07:24:51            codonnell </span><span>@yonatanel: you could do something like that with </span><code>selected?</code></div><div data-t="yonatanel very nice. thanks"><span class="u" id="1470727861.001128">2016:08:09 07:31:01            yonatanel </span><span>very nice. thanks</span></div><div data-t="codonnell you&apos;re welcome"><span class="u" id="1470728030.001129">2016:08:09 07:33:50            codonnell </span><span>you&apos;re welcome</span></div><div data-t="achesnais @nathanmarz: I wonder, any best practices on aliasing specter? I find that having the split between  specter  and  specter.macros  prevents from efficiently aliasing everything under one ‘specter’ alias. I really like using ns aliases for any non-core library I use, to improve readability/non-ambiguity in my code. Is this split due to the treatment of macros in Clojurescript?"><span class="u" id="1470832621.001179">2016:08:10 12:37:01            achesnais </span><span>@nathanmarz: I wonder, any best practices on aliasing specter? I find that having the split between </span><code>specter</code><span> and </span><code>specter.macros</code><span> prevents from efficiently aliasing everything under one ‘specter’ alias. I really like using ns aliases for any non-core library I use, to improve readability/non-ambiguity in my code. Is this split due to the treatment of macros in Clojurescript?</span></div><div data-t="nathanmarz @achesnais: yes, it was done for cljs"><span class="u" id="1470833781.001181">2016:08:10 12:56:21           nathanmarz </span><span>@achesnais: yes, it was done for cljs</span></div><div data-t="nathanmarz @achesnais: I use  https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj  to get everything into a single namespace"><span class="u" id="1470833807.001182">2016:08:10 12:56:47           nathanmarz </span><span>@achesnais: I use </span><a href="https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj">https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj</a><span> to get everything into a single namespace</span></div><div data-t="sebastianpoeplau is there a way to do something like &quot;insert or update&quot; on a vector? let&apos;s say I have a vector  [{:name &quot;Test&quot;} {:name &quot;Whatever&quot;}]  and I would like to run f on the element that satisfies  #(= &quot;Something&quot; (:name %))  (or create it, as in this case it doesn&apos;t exist)"><span class="u" id="1470842219.001186">2016:08:10 15:16:59     sebastianpoeplau </span><span>is there a way to do something like &quot;insert or update&quot; on a vector? let&apos;s say I have a vector </span><code>[{:name &quot;Test&quot;} {:name &quot;Whatever&quot;}]</code><span> and I would like to run f on the element that satisfies </span><code>#(= &quot;Something&quot; (:name %))</code><span> (or create it, as in this case it doesn&apos;t exist)</span></div><div data-t="sebastianpoeplau I&apos;ve been playing with  nil-&gt;val  but when my predicate doesn&apos;t match on any element of the vector I get an empty vector and not  nil"><span class="u" id="1470842274.001187">2016:08:10 15:17:54     sebastianpoeplau </span><span>I&apos;ve been playing with </span><code>nil-&gt;val</code><span> but when my predicate doesn&apos;t match on any element of the vector I get an empty vector and not </span><code>nil</code></div><div data-t="achesnais @nathanmarz: thanks  🙂"><span class="u" id="1470845270.001189">2016:08:10 16:07:50            achesnais </span><span>@nathanmarz: thanks </span><b>🙂</b></div><div data-t="mattsfrey hello, wondering if anyone knows how to replicate  (update-in db [:contacts :show-modal?] assoc true)  using transform"><span class="u" id="1470853564.001199">2016:08:10 18:26:04            mattsfrey </span><span>hello, wondering if anyone knows how to replicate </span><pre>(update-in db [:contacts :show-modal?] assoc true)</pre><span> using transform</span></div><div data-t="mattsfrey I tried  (transform [:contacts] #(assoc % :show-modal? true) db)  and it seems to be doing transformations to much of the db for some reason"><span class="u" id="1470853615.001200">2016:08:10 18:26:55            mattsfrey </span><span>I tried </span><pre>(transform [:contacts] #(assoc % :show-modal? true) db)</pre><span> and it seems to be doing transformations to much of the db for some reason</span></div><div data-t="mattsfrey nvm it is working, was another issue"><span class="u" id="1470854413.001201">2016:08:10 18:40:13            mattsfrey </span><span>nvm it is working, was another issue</span></div><div data-t="mattsfrey but in the same vein, is there a more efficient or elegant way to  write that^^ ?"><span class="u" id="1470854443.001202">2016:08:10 18:40:43            mattsfrey </span><span>but in the same vein, is there a more efficient or elegant way to  write that^^ ?</span></div><div data-t="nathanmarz @sebastianpoeplau: can you show an example of the input/output you&apos;re looking for?"><span class="u" id="1470854780.001204">2016:08:10 18:46:20           nathanmarz </span><span>@sebastianpoeplau: can you show an example of the input/output you&apos;re looking for?</span></div><div data-t="nathanmarz @mattsfrey:  (setval [:contacts :show-modal?] true db)"><span class="u" id="1470854873.001205">2016:08:10 18:47:53           nathanmarz </span><span>@mattsfrey: </span><code>(setval [:contacts :show-modal?] true db)</code></div><div data-t="mattsfrey ah that is nice, does it get the 6x performance of transform etc though?"><span class="u" id="1470855783.001206">2016:08:10 19:03:03            mattsfrey </span><span>ah that is nice, does it get the 6x performance of transform etc though?</span></div><div data-t="mattsfrey or is that not a good example for comparison"><span class="u" id="1470855794.001207">2016:08:10 19:03:14            mattsfrey </span><span>or is that not a good example for comparison</span></div><div data-t="nathanmarz @mattsfrey: yes, that will be much faster than update-in"><span class="u" id="1470856758.001208">2016:08:10 19:19:18           nathanmarz </span><span>@mattsfrey: yes, that will be much faster than update-in</span></div><div data-t="nathanmarz the new update-in in 1.9 is much better but specter still outperforms it"><span class="u" id="1470856805.001209">2016:08:10 19:20:05           nathanmarz </span><span>the new update-in in 1.9 is much better but specter still outperforms it</span></div><div data-t="mattsfrey oic, good to know, thanks!"><span class="u" id="1470856819.001210">2016:08:10 19:20:19            mattsfrey </span><span>oic, good to know, thanks!</span></div><div data-t="sebastianpoeplau @nathanmarz: of course - say I have  (defn f [person] (assoc person :some &quot;value&quot;)) , then I would like the transformation to return  [{:name &quot;Test&quot; :some &quot;value&quot;} {:name &quot;Whatever&quot;}]  when called on input  [{:name &quot;Test&quot;} {:name &quot;Whatever&quot;}] , and it should return the same value when used on input  [{:name &quot;Whatever&quot;}] . that is, it should update the entry that has  :name &quot;Test&quot;  or insert it if it&apos;s not in the vector"><span class="u" id="1470864717.001213">2016:08:10 21:31:57     sebastianpoeplau </span><span>@nathanmarz: of course - say I have </span><code>(defn f [person] (assoc person :some &quot;value&quot;))</code><span>, then I would like the transformation to return </span><code>[{:name &quot;Test&quot; :some &quot;value&quot;} {:name &quot;Whatever&quot;}]</code><span> when called on input </span><code>[{:name &quot;Test&quot;} {:name &quot;Whatever&quot;}]</code><span>, and it should return the same value when used on input </span><code>[{:name &quot;Whatever&quot;}]</code><span>. that is, it should update the entry that has </span><code>:name &quot;Test&quot;</code><span> or insert it if it&apos;s not in the vector</span></div><div data-t="sebastianpoeplau my best guess so far is the following:
 (setval [(not-selected? ALL #(= &quot;Test&quot; (:name %))) END] [{:name &quot;Test&quot;}]) ; insert if necessary
(transform [ALL #(= &quot;Test&quot; (:name %))] f my-vector) ; apply my function
"><span class="u" id="1470864924.001214">2016:08:10 21:35:24     sebastianpoeplau </span><span>my best guess so far is the following:
</span><pre>(setval [(not-selected? ALL #(= &quot;Test&quot; (:name %))) END] [{:name &quot;Test&quot;}]) ; insert if necessary
(transform [ALL #(= &quot;Test&quot; (:name %))] f my-vector) ; apply my function
</pre></div><div data-t="sebastianpoeplau I&apos;m just realizing that I could change the lambda  #(= &quot;Test&quot; (:name %))  to  :name #(= &quot;Test&quot; %) , but the question is still whether I can accomplish both steps, insertion and transformation, in one go"><span class="u" id="1470865215.001215">2016:08:10 21:40:15     sebastianpoeplau </span><span>I&apos;m just realizing that I could change the lambda </span><code>#(= &quot;Test&quot; (:name %))</code><span> to </span><code>:name #(= &quot;Test&quot; %)</code><span>, but the question is still whether I can accomplish both steps, insertion and transformation, in one go</span></div><div data-t="nathanmarz @sebastianpoeplau: I think doing it the way you&apos;re doing it is the cleanest approach"><span class="u" id="1470866219.001216">2016:08:10 21:56:59           nathanmarz </span><span>@sebastianpoeplau: I think doing it the way you&apos;re doing it is the cleanest approach</span></div><div data-t="nathanmarz I would recommend factoring out [ALL #(= &quot;Test&quot; (:name %)))] into a composite navigator and re-using it in each call"><span class="u" id="1470866283.001217">2016:08:10 21:58:03           nathanmarz </span><span>I would recommend factoring out [ALL #(= &quot;Test&quot; (:name %)))] into a composite navigator and re-using it in each call</span></div><div data-t="nathanmarz @sebastianpoeplau: 
 (def person-nav (comp-paths ALL (paramsfn [id] [p] (= id (:name p)))))

(setval [(not-selected? (person-nav &quot;Test&quot;)) END] [{:name &quot;Test&quot;}] my-vector)
(transform (person-nav &quot;Test&quot;) #(assoc % :some &quot;hi&quot;) my-vector)
"><span class="u" id="1470866498.001218">2016:08:10 22:01:38           nathanmarz </span><span>@sebastianpoeplau: 
</span><pre>(def person-nav (comp-paths ALL (paramsfn [id] [p] (= id (:name p)))))

(setval [(not-selected? (person-nav &quot;Test&quot;)) END] [{:name &quot;Test&quot;}] my-vector)
(transform (person-nav &quot;Test&quot;) #(assoc % :some &quot;hi&quot;) my-vector)
</pre></div><div data-t="sebastianpoeplau @nathanmarz: cool, thank you!"><span class="u" id="1470900869.001238">2016:08:11 07:34:29     sebastianpoeplau </span><span>@nathanmarz: cool, thank you!</span></div><div data-t="borkdude nice challenge for specter:  https://stackoverflow.com/questions/38893968/how-to-select-keys-in-nested-maps-in-clojure"><span class="u" id="1470912153.001245">2016:08:11 10:42:33             borkdude </span><span>nice challenge for specter: </span><a href="https://stackoverflow.com/questions/38893968/how-to-select-keys-in-nested-maps-in-clojure">https://stackoverflow.com/questions/38893968/how-to-select-keys-in-nested-maps-in-clojure</a></div><div data-t="borkdude It brings me to the question how you prune a map in specter"><span class="u" id="1470912658.001247">2016:08:11 10:50:58             borkdude </span><span>It brings me to the question how you prune a map in specter</span></div><div data-t="borkdude like  {:a 1, :b 2, :c 3}  =&gt;  {:a 1} , it must be possible, but I haven&apos;t used this yet"><span class="u" id="1470912700.001248">2016:08:11 10:51:40             borkdude </span><span>like </span><code>{:a 1, :b 2, :c 3}</code><span> =&gt; </span><code>{:a 1}</code><span>, it must be possible, but I haven&apos;t used this yet</span></div><div data-t="borkdude I was thinking something with  multi-path  and  filterer ?"><span class="u" id="1470912716.001249">2016:08:11 10:51:56             borkdude </span><span>I was thinking something with </span><code>multi-path</code><span> and </span><code>filterer</code><span>?</span></div><div data-t="borkdude Ah, the question is even different than I understood it. I thought he wanted  {:a 1, :b 2, :c {:d 3}}  leaving the structure intact"><span class="u" id="1470919917.001251">2016:08:11 12:51:57             borkdude </span><span>Ah, the question is even different than I understood it. I thought he wanted </span><code>{:a 1, :b 2, :c {:d 3}}</code><span> leaving the structure intact</span></div><div data-t="nathanmarz @borkdude:  submap  is the specter analogue to  select-keys"><span class="u" id="1470920554.001252">2016:08:11 13:02:34           nathanmarz </span><span>@borkdude: </span><code>submap</code><span> is the specter analogue to </span><code>select-keys</code></div><div data-t="borkdude going to try it"><span class="u" id="1470920568.001253">2016:08:11 13:02:48             borkdude </span><span>going to try it</span></div><div data-t="nathanmarz (into {} (traverse (multi-path (submap [:a :b]) [:c (submap [:d])]) {:a 1 :b 2 :c {:d 3}}))"><span class="u" id="1470920579.001254">2016:08:11 13:02:59           nathanmarz </span><code>(into {} (traverse (multi-path (submap [:a :b]) [:c (submap [:d])]) {:a 1 :b 2 :c {:d 3}}))</code></div><div data-t="nathanmarz could make a function that converts  [:a :b [:c :d]]   to that path"><span class="u" id="1470920687.001255">2016:08:11 13:04:47           nathanmarz </span><span>could make a function that converts </span><code>[:a :b [:c :d]] </code><span> to that path</span></div><div data-t="borkdude (prune m [:a :b [:c :d]])
"><span class="u" id="1470920723.001256">2016:08:11 13:05:23             borkdude </span><pre>(prune m [:a :b [:c :d]])
</pre></div><div data-t="borkdude very clean"><span class="u" id="1470920755.001259">2016:08:11 13:05:55             borkdude </span><span>very clean</span></div><div data-t="nathanmarz a better way is to capture the idea of &quot;nested submaps&quot; as a navigator"><span class="u" id="1470920813.001262">2016:08:11 13:06:53           nathanmarz </span><span>a better way is to capture the idea of &quot;nested submaps&quot; as a navigator</span></div><div data-t="nathanmarz (into {} (traverse (nested-submaps :a :b [:c :d]) m))"><span class="u" id="1470920839.001263">2016:08:11 13:07:19           nathanmarz </span><code>(into {} (traverse (nested-submaps :a :b [:c :d]) m))</code></div><div data-t="yonatanel In the bank account example, is it possible to collect money from several accounts until a certain sum is reached or no more money is available? Is it then possible to get all the collections made (account+amount pairs) for event sourcing?"><span class="u" id="1471245949.001379">2016:08:15 07:25:49            yonatanel </span><span>In the bank account example, is it possible to collect money from several accounts until a certain sum is reached or no more money is available? Is it then possible to get all the collections made (account+amount pairs) for event sourcing?</span></div><div data-t="nathanmarz @yonatanel: you could do a subselect of all the accounts and then do an srange-dynamic to choose the first N accounts that sum up to what you&apos;re looking for"><span class="u" id="1471253506.001380">2016:08:15 09:31:46           nathanmarz </span><span>@yonatanel: you could do a subselect of all the accounts and then do an srange-dynamic to choose the first N accounts that sum up to what you&apos;re looking for</span></div><div data-t="yonatanel Thanks. I&apos;ll check it out."><span class="u" id="1471256451.001387">2016:08:15 10:20:51            yonatanel </span><span>Thanks. I&apos;ll check it out.</span></div><div data-t="cdine @nathanmarz:  Just stopping by, to say thanks for this wonderful library. Great showcase of what simple and powerful abstractions can do.."><span class="u" id="1471276251.001393">2016:08:15 15:50:51                cdine </span><span>@nathanmarz:  Just stopping by, to say thanks for this wonderful library. Great showcase of what simple and powerful abstractions can do..</span></div><div data-t="nathanmarz @cdine: thanks, glad you&apos;re enjoying it"><span class="u" id="1471276348.001394">2016:08:15 15:52:28           nathanmarz </span><span>@cdine: thanks, glad you&apos;re enjoying it</span></div><div data-t="conaw What’s the easiest way to dissoc-in, or to transform a value to not being there?"><span class="u" id="1471329269.001412">2016:08:16 06:34:29                conaw </span><span>What’s the easiest way to dissoc-in, or to transform a value to not being there?</span></div><div data-t="conaw ideally, I’d like to be able to navigate to a value using walker, and then just setval to nothing, not nil, but nothing, is that possible?"><span class="u" id="1471329332.001413">2016:08:16 06:35:32                conaw </span><span>ideally, I’d like to be able to navigate to a value using walker, and then just setval to nothing, not nil, but nothing, is that possible?</span></div><div data-t="yonatanel @conaw: Perhaps navigate one step behind using  selected?  and then transform with dissoc. Still not elegant though"><span class="u" id="1471330686.001414">2016:08:16 06:58:06            yonatanel </span><span>@conaw: Perhaps navigate one step behind using </span><code>selected?</code><span> and then transform with dissoc. Still not elegant though</span></div><div data-t="conaw looks like this is the closest we’ve got right now to what I’m looking for"><span class="u" id="1471330978.001417">2016:08:16 07:02:58                conaw </span><span>looks like this is the closest we’ve got right now to what I’m looking for</span></div><div data-t="conaw based on this  https://github.com/nathanmarz/specter/issues/83"><span class="u" id="1471330993.001418">2016:08:16 07:03:13                conaw </span><span>based on this </span><a href="https://github.com/nathanmarz/specter/issues/83">https://github.com/nathanmarz/specter/issues/83</a></div><div data-t="conaw so, heres where I’m stuck. right now I’m able to filter out a given value from a vector that is nested one level deep, I’m trying to figure out how to do this recursively though so I could go as deep as needed.  

the following works

 (defpathedfn remove-x [x]
  (filterer #(not= x %)))


(defn t3 [v a]
  (select [
           (remove-x a)
           ALL
           (if-path vector?
                    (remove-x a)
                    STAY)] v))

(deftest test1
  (testing &quot;removal&quot;
    (is
     (= [1 2 3 [4]]
        (t3 [1 2 3 [4 5] 5] 5)))))
 

what I want is 
(= [1 2 3 [4 [6]]]
     (t3 [1 2 3 [4 [5 6] 5] 5] 5))"><span class="u" id="1471335996.001424">2016:08:16 08:26:36                conaw </span><span>so, heres where I’m stuck. right now I’m able to filter out a given value from a vector that is nested one level deep, I’m trying to figure out how to do this recursively though so I could go as deep as needed.  

the following works

</span><pre>(defpathedfn remove-x [x]
  (filterer #(not= x %)))


(defn t3 [v a]
  (select [
           (remove-x a)
           ALL
           (if-path vector?
                    (remove-x a)
                    STAY)] v))

(deftest test1
  (testing &quot;removal&quot;
    (is
     (= [1 2 3 [4]]
        (t3 [1 2 3 [4 5] 5] 5)))))
</pre><span>

what I want is 
(= [1 2 3 [4 [6]]]
     (t3 [1 2 3 [4 [5 6] 5] 5] 5))</span></div><div data-t="nathanmarz @conaw: here&apos;s one way to do it"><span class="u" id="1471346960.001431">2016:08:16 11:29:20           nathanmarz </span><span>@conaw: here&apos;s one way to do it</span></div><div data-t="nathanmarz (defn remove-x [x]
  (fn [v]
    (filterv #(not= x %) v)))

(declarepath AllVectors)
(providepath AllVectors
  (if-path vector?
    (stay-then-continue
      ALL
      AllVectors)))

(transform AllVectors (remove-x 5) [1 2 3 [4 [5 6] 5] 5])
"><span class="u" id="1471346971.001432">2016:08:16 11:29:31           nathanmarz </span><pre>(defn remove-x [x]
  (fn [v]
    (filterv #(not= x %) v)))

(declarepath AllVectors)
(providepath AllVectors
  (if-path vector?
    (stay-then-continue
      ALL
      AllVectors)))

(transform AllVectors (remove-x 5) [1 2 3 [4 [5 6] 5] 5])
</pre></div><div data-t="nathanmarz you could also use  ALL-ELEM-SEQ  from that linked github issue in conjunction with  AllVectors"><span class="u" id="1471347033.001433">2016:08:16 11:30:33           nathanmarz </span><span>you could also use </span><code>ALL-ELEM-SEQ</code><span> from that linked github issue in conjunction with </span><code>AllVectors</code></div><div data-t="nathanmarz which would look like:  (setval [AllVectors ALL-ELEM-SEQ #(= 5 (first %))] nil [1 2 3 [4 [5 6] 5] 5])"><span class="u" id="1471347074.001434">2016:08:16 11:31:14           nathanmarz </span><span>which would look like: </span><code>(setval [AllVectors ALL-ELEM-SEQ #(= 5 (first %))] nil [1 2 3 [4 [5 6] 5] 5])</code></div><div data-t="joshkh I&apos;m attempting to &quot;shake&quot; a map of all top level keys where where a deeply nested key in each branch matches a predicate. Is that something I would tackle with transform? Or would I use select in combination with filterer?"><span class="u" id="1471349546.001436">2016:08:16 12:12:26               joshkh </span><span>I&apos;m attempting to &quot;shake&quot; a map of all top level keys where where a deeply nested key in each branch matches a predicate. Is that something I would tackle with transform? Or would I use select in combination with filterer?</span></div><div data-t="nathanmarz what&apos;s an example of the input/output you&apos;re looking for?"><span class="u" id="1471349608.001437">2016:08:16 12:13:28           nathanmarz </span><span>what&apos;s an example of the input/output you&apos;re looking for?</span></div><div data-t="joshkh In this map, I only want to keep top level branches where at least one of the maps in :where have an :op value of &quot;=&quot;

 {:k1 {:where [{:op    &quot;=&quot;
               :value &quot;A&quot;}
              {:op    &quot;ignore&quot;
               :value &quot;X&quot;}]}
 :k2 {:where [{:op    &quot;&lt;&quot;
               :value &quot;A&quot;}
              {:op    &quot;lookup&quot;
               :value &quot;C&quot;}]}
 :k3 {:where [{:op    &quot;=&quot;
               :value &quot;A&quot;}
              {:op    &quot;lookup&quot;
               :value &quot;E&quot;}]}}

; result

{:k1 {:where [{:op    &quot;=&quot;
               :value &quot;A&quot;}
              {:op    &quot;ignore&quot;
               :value &quot;X&quot;}]}
 :k3 {:where [{:op    &quot;=&quot;
               :value &quot;A&quot;}
              {:op    &quot;lookup&quot;
               :value &quot;E&quot;}]}}
"><span class="u" id="1471349894.001438">2016:08:16 12:18:14               joshkh </span><span>In this map, I only want to keep top level branches where at least one of the maps in :where have an :op value of &quot;=&quot;

</span><pre>{:k1 {:where [{:op    &quot;=&quot;
               :value &quot;A&quot;}
              {:op    &quot;ignore&quot;
               :value &quot;X&quot;}]}
 :k2 {:where [{:op    &quot;&lt;&quot;
               :value &quot;A&quot;}
              {:op    &quot;lookup&quot;
               :value &quot;C&quot;}]}
 :k3 {:where [{:op    &quot;=&quot;
               :value &quot;A&quot;}
              {:op    &quot;lookup&quot;
               :value &quot;E&quot;}]}}

; result

{:k1 {:where [{:op    &quot;=&quot;
               :value &quot;A&quot;}
              {:op    &quot;ignore&quot;
               :value &quot;X&quot;}]}
 :k3 {:where [{:op    &quot;=&quot;
               :value &quot;A&quot;}
              {:op    &quot;lookup&quot;
               :value &quot;E&quot;}]}}
</pre></div><div data-t="joshkh (k2 doesn&apos;t make the cut)"><span class="u" id="1471349935.001439">2016:08:16 12:18:55               joshkh </span><span>(k2 doesn&apos;t make the cut)</span></div><div data-t="joshkh I can build a path to :op no problem, but I lose all parent values when using  select .  I considered using  collect-one  at the root of the path while applying  filterer  at the :op level, but I got the impression I was misunderstanding something fundamental.  🙂"><span class="u" id="1471350218.001440">2016:08:16 12:23:38               joshkh </span><span>I can build a path to :op no problem, but I lose all parent values when using </span><code>select</code><span>.  I considered using </span><code>collect-one</code><span> at the root of the path while applying </span><code>filterer</code><span> at the :op level, but I got the impression I was misunderstanding something fundamental. </span><b>🙂</b></div><div data-t="nathanmarz (into {} (traverse [ALL (selected? LAST :where ALL :op #(= &quot;=&quot; %))] data))"><span class="u" id="1471350248.001441">2016:08:16 12:24:08           nathanmarz </span><code>(into {} (traverse [ALL (selected? LAST :where ALL :op #(= &quot;=&quot; %))] data))</code></div><div data-t="nathanmarz you can do it with  select  too but  traverse  is more efficient"><span class="u" id="1471350318.001442">2016:08:16 12:25:18           nathanmarz </span><span>you can do it with </span><code>select</code><span> too but </span><code>traverse</code><span> is more efficient</span></div><div data-t="nathanmarz (doesn&apos;t create any intermediate sequence)"><span class="u" id="1471350345.001443">2016:08:16 12:25:45           nathanmarz </span><span>(doesn&apos;t create any intermediate sequence)</span></div><div data-t="joshkh Ah, okay"><span class="u" id="1471350351.001444">2016:08:16 12:25:51               joshkh </span><span>Ah, okay</span></div><div data-t="joshkh I think I overlooked  selected?  as well."><span class="u" id="1471350391.001445">2016:08:16 12:26:31               joshkh </span><span>I think I overlooked </span><code>selected?</code><span> as well.</span></div><div data-t="joshkh In your code response, what&apos;s the difference between 1) using  filterer  , or 2) passing an anonymous function to the selection path, as you did?"><span class="u" id="1471350509.001446">2016:08:16 12:28:29               joshkh </span><span>In your code response, what&apos;s the difference between 1) using </span><code>filterer</code><span> , or 2) passing an anonymous function to the selection path, as you did?</span></div><div data-t="nathanmarz filterer navigates you to a new sequence"><span class="u" id="1471350541.001447">2016:08:16 12:29:01           nathanmarz </span><span>filterer navigates you to a new sequence</span></div><div data-t="nathanmarz a function acts as a predicate and stops navigation at that point if the predicate is false"><span class="u" id="1471350553.001448">2016:08:16 12:29:13           nathanmarz </span><span>a function acts as a predicate and stops navigation at that point if the predicate is false</span></div><div data-t="nathanmarz for  selected? , it acts as a predicate where  &quot;true&quot; is when anything is selected"><span class="u" id="1471350572.001449">2016:08:16 12:29:32           nathanmarz </span><span>for </span><code>selected?</code><span>, it acts as a predicate where  &quot;true&quot; is when anything is selected</span></div><div data-t="nathanmarz since filterer doesn&apos;t stop navigation, that wouldn&apos;t be relevant in this case"><span class="u" id="1471350591.001450">2016:08:16 12:29:51           nathanmarz </span><span>since filterer doesn&apos;t stop navigation, that wouldn&apos;t be relevant in this case</span></div><div data-t="joshkh Okay, that helps a lot. Thanks for the explanation and for solving my use case."><span class="u" id="1471350661.001451">2016:08:16 12:31:01               joshkh </span><span>Okay, that helps a lot. Thanks for the explanation and for solving my use case.</span></div><div data-t="nathanmarz no problem"><span class="u" id="1471350677.001452">2016:08:16 12:31:17           nathanmarz </span><span>no problem</span></div><div data-t="nathanmarz this is worth reading through if you haven&apos;t already:  https://github.com/nathanmarz/specter/wiki/List-of-Navigators"><span class="u" id="1471350745.001453">2016:08:16 12:32:25           nathanmarz </span><span>this is worth reading through if you haven&apos;t already: </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators">https://github.com/nathanmarz/specter/wiki/List-of-Navigators</a></div><div data-t="joshkh Great!"><span class="u" id="1471351112.001455">2016:08:16 12:38:32               joshkh </span><span>Great!</span></div><div data-t="darwin any hints how to rewrite this code to be specter 0.12 compatible?
 https://github.com/binaryage/dirac/blob/417b81c3959e9b156f148f9448f2935f33631658/src/implant/dirac/implant/automation/reps.cljs#L43-L52"><span class="u" id="1471356421.001466">2016:08:16 14:07:01               darwin </span><span>any hints how to rewrite this code to be specter 0.12 compatible?
</span><a href="https://github.com/binaryage/dirac/blob/417b81c3959e9b156f148f9448f2935f33631658/src/implant/dirac/implant/automation/reps.cljs#L43-L52">https://github.com/binaryage/dirac/blob/417b81c3959e9b156f148f9448f2935f33631658/src/implant/dirac/implant/automation/reps.cljs#L43-L52</a></div><div data-t="darwin I’m getting &quot;Cannot read property &apos;0&apos; of null” somewhere deep in specter and I wasn’t able to figure out what is going wrong  😞"><span class="u" id="1471356451.001468">2016:08:16 14:07:31               darwin </span><span>I’m getting &quot;Cannot read property &apos;0&apos; of null” somewhere deep in specter and I wasn’t able to figure out what is going wrong </span><b>😞</b></div><div data-t="darwin the RepWalker is used in this function:
 https://github.com/binaryage/dirac/blob/417b81c3959e9b156f148f9448f2935f33631658/src/implant/dirac/implant/automation/reps.cljs#L62-L63"><span class="u" id="1471356500.001469">2016:08:16 14:08:20               darwin </span><span>the RepWalker is used in this function:
</span><a href="https://github.com/binaryage/dirac/blob/417b81c3959e9b156f148f9448f2935f33631658/src/implant/dirac/implant/automation/reps.cljs#L62-L63">https://github.com/binaryage/dirac/blob/417b81c3959e9b156f148f9448f2935f33631658/src/implant/dirac/implant/automation/reps.cljs#L62-L63</a></div><div data-t="nathanmarz @darwin: need a reproducible test case"><span class="u" id="1471356887.001471">2016:08:16 14:14:47           nathanmarz </span><span>@darwin: need a reproducible test case</span></div><div data-t="joshkh Is it okay to nest  selected?  functions? Going back to your  (into {} (traverse [ALL (selected? LAST :where ALL :op #(= &quot;=&quot; %))] data))  response, what if I wanted to also restrict the selection to the :where vec having a count greater than one?"><span class="u" id="1471358829.001472">2016:08:16 14:47:09               joshkh </span><span>Is it okay to nest </span><code>selected?</code><span> functions? Going back to your </span><code>(into {} (traverse [ALL (selected? LAST :where ALL :op #(= &quot;=&quot; %))] data))</code><span> response, what if I wanted to also restrict the selection to the :where vec having a count greater than one?</span></div><div data-t="joshkh Oh wait, I&apos;d just use a function there as well."><span class="u" id="1471358905.001473">2016:08:16 14:48:25               joshkh </span><span>Oh wait, I&apos;d just use a function there as well.</span></div><div data-t="joshkh Oh, double wait, I&apos;m not sure what I just said made sense."><span class="u" id="1471358957.001474">2016:08:16 14:49:17               joshkh </span><span>Oh, double wait, I&apos;m not sure what I just said made sense.</span></div><div data-t="joshkh Okay, I think I got it? Two separate  selected?  expressions:
 (traverse [s/ALL
           (s/selected? s/LAST :where #(&lt; 1 (count %)))
           (s/selected? s/LAST :where s/ALL :op #(= &quot;=&quot; %))] data)
"><span class="u" id="1471359506.001475">2016:08:16 14:58:26               joshkh </span><span>Okay, I think I got it? Two separate </span><code>selected?</code><span> expressions:
</span><pre>(traverse [s/ALL
           (s/selected? s/LAST :where #(&lt; 1 (count %)))
           (s/selected? s/LAST :where s/ALL :op #(= &quot;=&quot; %))] data)
</pre></div><div data-t="codonnell @joshkh: I think you could do it with  (traverse [ALL (selected? LAST :where #(&lt; 1 (count %)) ALL :op #(= &quot;=&quot; %))] data)"><span class="u" id="1471359594.001477">2016:08:16 14:59:54            codonnell </span><span>@joshkh: I think you could do it with </span><code>(traverse [ALL (selected? LAST :where #(&lt; 1 (count %)) ALL :op #(= &quot;=&quot; %))] data)</code></div><div data-t="codonnell also, if you&apos;re traversing a map, you could use  MAP-VALS  instead of  LAST"><span class="u" id="1471359657.001478">2016:08:16 15:00:57            codonnell </span><span>also, if you&apos;re traversing a map, you could use </span><code>MAP-VALS</code><span> instead of </span><code>LAST</code></div><div data-t="joshkh Ah, that&apos;s what how I was thinking about it originally, but I wasn&apos;t sure how ALL fit into the path after the function. I guess the obvious answer is that it fits in just fine.  🙂"><span class="u" id="1471359723.001479">2016:08:16 15:02:03               joshkh </span><span>Ah, that&apos;s what how I was thinking about it originally, but I wasn&apos;t sure how ALL fit into the path after the function. I guess the obvious answer is that it fits in just fine. </span><b>🙂</b></div><div data-t="joshkh And thanks for the advice about MAP-VALS. It&apos;ll be easier to remember the data structure when I come back to this in the future."><span class="u" id="1471359766.001480">2016:08:16 15:02:46               joshkh </span><span>And thanks for the advice about MAP-VALS. It&apos;ll be easier to remember the data structure when I come back to this in the future.</span></div><div data-t="codonnell for sure, and it should be a little more efficient, too!"><span class="u" id="1471359787.001481">2016:08:16 15:03:07            codonnell </span><span>for sure, and it should be a little more efficient, too!</span></div><div data-t="nathanmarz ALL  is needed in this case since traverse must emit key/value pairs"><span class="u" id="1471360148.001482">2016:08:16 15:09:08           nathanmarz </span><code>ALL</code><span> is needed in this case since traverse must emit key/value pairs</span></div><div data-t="codonnell good point @nathanmarz. I&apos;m not thinking very clearly today. @joshkh, you can&apos;t use  MAP-VALS , since  MAP-VALS  acts the same as  [ALL LAST] , but you need the  ALL  outside of  selected?  and  LAST  inside it."><span class="u" id="1471360861.001483">2016:08:16 15:21:01            codonnell </span><span>good point @nathanmarz. I&apos;m not thinking very clearly today. @joshkh, you can&apos;t use </span><code>MAP-VALS</code><span>, since </span><code>MAP-VALS</code><span> acts the same as </span><code>[ALL LAST]</code><span>, but you need the </span><code>ALL</code><span> outside of </span><code>selected?</code><span> and </span><code>LAST</code><span> inside it.</span></div><div data-t="joshkh Got it!"><span class="u" id="1471360913.001484">2016:08:16 15:21:53               joshkh </span><span>Got it!</span></div><div data-t="conaw @nathanmarz: much obliged"><span class="u" id="1471367848.001490">2016:08:16 17:17:28                conaw </span><span>@nathanmarz: much obliged</span></div><div data-t="richiardiandrea I was having working at a big reduce today and I thought, maybe specter will be able to help me. Basically the atomic input is:

 [{:timestamp 14424
  :chat-id 2
  :payload &quot;bla&quot;}
 {:timestamp 14421
  :chat-id 1
  :payload &quot;asd&quot;}
  {:timestamp 14400
  :chat-id 1
  :payload &quot;test&quot;}]
 

I have a list of those that I want to convert to a map indexed by  chat-id  but keeping the oldest timestamp in the value, as:

 {1 {:timestamp 14000 :messages [the list]}
  2 {:timestamp 14424 :messages [the list]}}
 

Can you folks give me a hint (without full solution is fine) from where to start exploring a solution with specter?"><span class="u" id="1471391075.001491">2016:08:16 23:44:35      richiardiandrea </span><span>I was having working at a big reduce today and I thought, maybe specter will be able to help me. Basically the atomic input is:

</span><pre>[{:timestamp 14424
  :chat-id 2
  :payload &quot;bla&quot;}
 {:timestamp 14421
  :chat-id 1
  :payload &quot;asd&quot;}
  {:timestamp 14400
  :chat-id 1
  :payload &quot;test&quot;}]
</pre><span>

I have a list of those that I want to convert to a map indexed by </span><code>chat-id</code><span> but keeping the oldest timestamp in the value, as:

</span><pre>{1 {:timestamp 14000 :messages [the list]}
  2 {:timestamp 14424 :messages [the list]}}
</pre><span>

Can you folks give me a hint (without full solution is fine) from where to start exploring a solution with specter?</span></div><div data-t="codonnell @richiardiandrea: could you give a small example of input/output?"><span class="u" id="1471391589.001494">2016:08:16 23:53:09            codonnell </span><span>@richiardiandrea: could you give a small example of input/output?</span></div><div data-t="richiardiandrea @codonnell: thanks for answering, yes of course, is the above not enough? I am worried it can take too much space"><span class="u" id="1471391698.001495">2016:08:16 23:54:58      richiardiandrea </span><span>@codonnell: thanks for answering, yes of course, is the above not enough? I am worried it can take too much space</span></div><div data-t="codonnell @richiardiandrea: Thanks, that clarifies it."><span class="u" id="1471391862.001502">2016:08:16 23:57:42            codonnell </span><span>@richiardiandrea: Thanks, that clarifies it.</span></div><div data-t="richiardiandrea 😄"><span class="u" id="1471391868.001503">2016:08:16 23:57:48      richiardiandrea </span><b>😄</b></div><div data-t="codonnell Would you list just be a list of the payloads for all messages with the given chat-id?"><span class="u" id="1471391887.001504">2016:08:16 23:58:07            codonnell </span><span>Would you list just be a list of the payloads for all messages with the given chat-id?</span></div><div data-t="richiardiandrea so I need to carry with me the  :timestamp"><span class="u" id="1471391893.001505">2016:08:16 23:58:13      richiardiandrea </span><span>so I need to carry with me the </span><code>:timestamp</code></div><div data-t="richiardiandrea yes"><span class="u" id="1471391895.001506">2016:08:16 23:58:15      richiardiandrea </span><span>yes</span></div><div data-t="richiardiandrea the calculation on the timestamp is a bit mysterious to me at the moment"><span class="u" id="1471391928.001507">2016:08:16 23:58:48      richiardiandrea </span><span>the calculation on the timestamp is a bit mysterious to me at the moment</span></div><div data-t="codonnell Does the list of messages need to be in order of timestamp?"><span class="u" id="1471391949.001508">2016:08:16 23:59:09            codonnell </span><span>Does the list of messages need to be in order of timestamp?</span></div><div data-t="richiardiandrea (specter newbie)"><span class="u" id="1471391952.001509">2016:08:16 23:59:12      richiardiandrea </span><span>(specter newbie)</span></div><div data-t="richiardiandrea yes preferably yes"><span class="u" id="1471391959.001510">2016:08:16 23:59:19      richiardiandrea </span><span>yes preferably yes</span></div><div data-t="codonnell In my opinion, the best solution just uses  reduce . Your accumulator would be a map keyed by chat-id with values being a  sorted-map  storing messages, keyed by timestamp."><span class="u" id="1471392126.001511">2016:08:17 00:02:06            codonnell </span><span>In my opinion, the best solution just uses </span><code>reduce</code><span>. Your accumulator would be a map keyed by chat-id with values being a </span><code>sorted-map</code><span> storing messages, keyed by timestamp.</span></div><div data-t="richiardiandrea Ok yes that is what I am doing as well :)"><span class="u" id="1471392171.001512">2016:08:17 00:02:51      richiardiandrea </span><span>Ok yes that is what I am doing as well :)</span></div><div data-t="richiardiandrea It was just out of curiosity, is it because of the oldest timestamp? In general, just for learning, can I carry a counter while I navigate the data with specter?"><span class="u" id="1471392318.001513">2016:08:17 00:05:18      richiardiandrea </span><span>It was just out of curiosity, is it because of the oldest timestamp? In general, just for learning, can I carry a counter while I navigate the data with specter?</span></div><div data-t="codonnell I can&apos;t think of a great way to do it using specter. I think specter is better for selecting from or transforming pieces of a nested data structure individually, while your task is aggregating all of your structure into something new. Maybe @nathanmarz  has more insight."><span class="u" id="1471392618.001515">2016:08:17 00:10:18            codonnell </span><span>I can&apos;t think of a great way to do it using specter. I think specter is better for selecting from or transforming pieces of a nested data structure individually, while your task is aggregating all of your structure into something new. Maybe @nathanmarz  has more insight.</span></div><div data-t="richiardiandrea @codonnell: ok thanks a lot "><span class="u" id="1471392757.001516">2016:08:17 00:12:37      richiardiandrea </span><span>@codonnell: ok thanks a lot </span></div><div data-t="codonnell you&apos;re welcome"><span class="u" id="1471392851.001517">2016:08:17 00:14:11            codonnell </span><span>you&apos;re welcome</span></div><div data-t="darwin @nathanmarz: FYI this was needed for fixing my earlier issue (after upgrading to 0.12):
 https://github.com/binaryage/dirac/commit/45db785491751cd9e23440139f9b2554094c1759"><span class="u" id="1471473407.001645">2016:08:17 22:36:47               darwin </span><span>@nathanmarz: FYI this was needed for fixing my earlier issue (after upgrading to 0.12):
</span><a href="https://github.com/binaryage/dirac/commit/45db785491751cd9e23440139f9b2554094c1759">https://github.com/binaryage/dirac/commit/45db785491751cd9e23440139f9b2554094c1759</a></div><div data-t="nathanmarz @darwin hmm, ok"><span class="u" id="1471474634.001650">2016:08:17 22:57:14           nathanmarz </span><span>@darwin hmm, ok</span></div><div data-t="nathanmarz @darwin do you have a full stack trace from when the error was happening?"><span class="u" id="1471474648.001651">2016:08:17 22:57:28           nathanmarz </span><span>@darwin do you have a full stack trace from when the error was happening?</span></div><div data-t="darwin @nathanmarz: unfortunately I was unable to make source-mapping work for some strange reason, so I can see only trace with compiled files"><span class="u" id="1471509671.001662">2016:08:18 08:41:11               darwin </span><span>@nathanmarz: unfortunately I was unable to make source-mapping work for some strange reason, so I can see only trace with compiled files</span></div><div data-t="darwin the problem is somewhere in com.rpl.specter.must"><span class="u" id="1471509688.001663">2016:08:18 08:41:28               darwin </span><span>the problem is somewhere in com.rpl.specter.must</span></div><div data-t="darwin https://dl.dropboxusercontent.com/u/559047/specter-dirac-issue.png"><span class="u" id="1471509772.001664">2016:08:18 08:42:52               darwin </span><a href="https://dl.dropboxusercontent.com/u/559047/specter-dirac-issue.png">https://dl.dropboxusercontent.com/u/559047/specter-dirac-issue.png</a></div><div data-t="nathanmarz @darwin ok thanks, that&apos;s helpful"><span class="u" id="1471524422.001671">2016:08:18 12:47:02           nathanmarz </span><span>@darwin ok thanks, that&apos;s helpful</span></div><div data-t="rodeorockstar I have another newbie question regarding Specter. Is this something that I can easily do? I have nested vectors of strings representing a tree. If a vector directly follows a string then it is a subtree. I&apos;d like to update the tree in a similar fashion to update-in when dealing with maps. In this non working example I&apos;d want to append &quot;SUB-A-2-2-2&quot; to the &quot;SUB-A-2-2&quot; &quot;node.&quot;:

 (let [t [&quot;A&quot;
             [&quot;SUB-A-1&quot;
              &quot;SUB-A-2&quot;
              [&quot;SUB-A-2-1&quot;
               &quot;SUB-A-2-2&quot;
               [&quot;SUB-A-2-2-1&quot;]]]]]

      (s/transform [&quot;A&quot; &quot;SUB-A-2&quot; &quot;SUB-A-2-2&quot;]
                   (fn [node] (conj node &quot;SUB-A-2-2-2&quot;))
                   t)
      #_[&quot;A&quot;
         [&quot;SUB-A-1&quot;
          &quot;SUB-A-2&quot;
          [&quot;SUB-A-2-1&quot;
           &quot;SUB-A-2-2&quot;
           [&quot;SUB-A-2-2-1&quot;
            ; New:
            &quot;SUB-A-2-2-2&quot;]]]])"><span class="u" id="1471596019.001693">2016:08:19 08:40:19        rodeorockstar </span><span>I have another newbie question regarding Specter. Is this something that I can easily do? I have nested vectors of strings representing a tree. If a vector directly follows a string then it is a subtree. I&apos;d like to update the tree in a similar fashion to update-in when dealing with maps. In this non working example I&apos;d want to append &quot;SUB-A-2-2-2&quot; to the &quot;SUB-A-2-2&quot; &quot;node.&quot;:

</span><pre>(let [t [&quot;A&quot;
             [&quot;SUB-A-1&quot;
              &quot;SUB-A-2&quot;
              [&quot;SUB-A-2-1&quot;
               &quot;SUB-A-2-2&quot;
               [&quot;SUB-A-2-2-1&quot;]]]]]

      (s/transform [&quot;A&quot; &quot;SUB-A-2&quot; &quot;SUB-A-2-2&quot;]
                   (fn [node] (conj node &quot;SUB-A-2-2-2&quot;))
                   t)
      #_[&quot;A&quot;
         [&quot;SUB-A-1&quot;
          &quot;SUB-A-2&quot;
          [&quot;SUB-A-2-1&quot;
           &quot;SUB-A-2-2&quot;
           [&quot;SUB-A-2-2-1&quot;
            ; New:
            &quot;SUB-A-2-2-2&quot;]]]])</pre></div><div data-t="rodeorockstar I can&apos;t quite figure out how to work something like  #(.indexOf nested-vec %)  into the selection path, presumably recursively. Which makes me think I need a walker?"><span class="u" id="1471596318.001695">2016:08:19 08:45:18        rodeorockstar </span><span>I can&apos;t quite figure out how to work something like </span><code>#(.indexOf nested-vec %)</code><span> into the selection path, presumably recursively. Which makes me think I need a walker?</span></div><div data-t="nathanmarz @rodeorockstar: cleanest way is to define a new navigator that determines which index to navigate to dynamically"><span class="u" id="1471609766.001702">2016:08:19 12:29:26           nathanmarz </span><span>@rodeorockstar: cleanest way is to define a new navigator that determines which index to navigate to dynamically</span></div><div data-t="nathanmarz (defnav dynamic-nth [afn]
  (select* [this structure next-fn]
    (next-fn (nth structure (afn structure))))
  (transform* [this structure next-fn]
    (let [i (afn structure)]
      (assoc structure i (next-fn (nth structure i))))))

(defnavconstructor subtree
  [p dynamic-nth]
  [v]
  (p (fn [avec] (inc (.indexOf avec v)))))
"><span class="u" id="1471609781.001703">2016:08:19 12:29:41           nathanmarz </span><pre>(defnav dynamic-nth [afn]
  (select* [this structure next-fn]
    (next-fn (nth structure (afn structure))))
  (transform* [this structure next-fn]
    (let [i (afn structure)]
      (assoc structure i (next-fn (nth structure i))))))

(defnavconstructor subtree
  [p dynamic-nth]
  [v]
  (p (fn [avec] (inc (.indexOf avec v)))))
</pre></div><div data-t="nathanmarz example:
 (transform
  [(subtree &quot;A&quot;)
   (subtree &quot;SUB-A-2&quot;)
   (subtree &quot;SUB-A-2-2&quot;)
   ALL]
   #(str % &quot;!&quot;)
   data)

;; =&gt; [&quot;A&quot; [&quot;SUB-A-1&quot; &quot;SUB-A-2&quot; [&quot;SUB-A-2-1&quot; &quot;SUB-A-2-2&quot; [&quot;SUB-A-2-2-1!&quot;]]]]
"><span class="u" id="1471609845.001704">2016:08:19 12:30:45           nathanmarz </span><span>example:
</span><pre>(transform
  [(subtree &quot;A&quot;)
   (subtree &quot;SUB-A-2&quot;)
   (subtree &quot;SUB-A-2-2&quot;)
   ALL]
   #(str % &quot;!&quot;)
   data)

;; =&gt; [&quot;A&quot; [&quot;SUB-A-1&quot; &quot;SUB-A-2&quot; [&quot;SUB-A-2-1&quot; &quot;SUB-A-2-2&quot; [&quot;SUB-A-2-2-1!&quot;]]]]
</pre></div><div data-t="nathanmarz @rodeorockstar: that said, I would recommend storing your tree in a different format, as right now you&apos;re basically required to parse it as you traverse it"><span class="u" id="1471610045.001705">2016:08:19 12:34:05           nathanmarz </span><span>@rodeorockstar: that said, I would recommend storing your tree in a different format, as right now you&apos;re basically required to parse it as you traverse it</span></div><div data-t="nathanmarz your particular example can be done like this:
 (setval [(subtree &quot;A&quot;) (subtree &quot;SUB-A-2&quot;) (subtree &quot;SUB-A-2-2&quot;) END]
  [&quot;SUB-A-2-2-2&quot;]
  data)
"><span class="u" id="1471610181.001706">2016:08:19 12:36:21           nathanmarz </span><span>your particular example can be done like this:
</span><pre>(setval [(subtree &quot;A&quot;) (subtree &quot;SUB-A-2&quot;) (subtree &quot;SUB-A-2-2&quot;) END]
  [&quot;SUB-A-2-2-2&quot;]
  data)
</pre></div><div data-t="joshkh That is so cool... Thanks for the example, @nathanmarz . I&apos;ll comb over the  devnav   devnavconstructor  macros until they settle in my head. Agreed, the tree structure isn&apos;t ideal, and I changed it since asking the question. But I was still curious if something like that could be done with specter so it remained a useful exercise to me. I hadn&apos;t thought to use  defnav ."><span class="u" id="1471610417.001707">2016:08:19 12:40:17               joshkh </span><span>That is so cool... Thanks for the example, @nathanmarz . I&apos;ll comb over the </span><code>devnav</code><span> </span><code>devnavconstructor</code><span> macros until they settle in my head. Agreed, the tree structure isn&apos;t ideal, and I changed it since asking the question. But I was still curious if something like that could be done with specter so it remained a useful exercise to me. I hadn&apos;t thought to use </span><code>defnav</code><span>.</span></div><div data-t="joshkh Thanks again for the continued help!"><span class="u" id="1471610434.001708">2016:08:19 12:40:34               joshkh </span><span>Thanks again for the continued help!</span></div><div data-t="nathanmarz yea, the real power of specter is in being able to define your own navigators and then benefit from the combinatorial ways in which everything can be combined"><span class="u" id="1471610504.001709">2016:08:19 12:41:44           nathanmarz </span><span>yea, the real power of specter is in being able to define your own navigators and then benefit from the combinatorial ways in which everything can be combined</span></div><div data-t="nathanmarz no problem, happy to help"><span class="u" id="1471610511.001710">2016:08:19 12:41:51           nathanmarz </span><span>no problem, happy to help</span></div><div data-t="lellis Hi guys, reading codewalker documentation i found “When afn returns a truthy value, codewalker stops searching that branch of the tree and continues its search of the rest of the data structure” So how can i dont stop when afn return true? I just wanna collect when its true and searching that branch of the tree for more patterns to collect. Sorry if the questions isn&apos;t clear."><span class="u" id="1471634843.001721">2016:08:19 19:27:23               lellis </span><span>Hi guys, reading codewalker documentation i found “When afn returns a truthy value, codewalker stops searching that branch of the tree and continues its search of the rest of the data structure” So how can i dont stop when afn return true? I just wanna collect when its true and searching that branch of the tree for more patterns to collect. Sorry if the questions isn&apos;t clear.</span></div><div data-t="nathanmarz @lellis you probably want something like this:
 (declarepath MyCodewalker)
(providepath MyCodewalker
 [(codewalker map?)
  (continue-then-stay
    MAP-VALS
    MyCodewalker)])
"><span class="u" id="1471635968.001722">2016:08:19 19:46:08           nathanmarz </span><span>@lellis you probably want something like this:
</span><pre>(declarepath MyCodewalker)
(providepath MyCodewalker
 [(codewalker map?)
  (continue-then-stay
    MAP-VALS
    MyCodewalker)])
</pre></div><div data-t="mattsfrey wondering if anyone knows offhand the best way to transform a map where I want to select keys of a certain set and map their children into a final map of  {:keyname child}"><span class="u" id="1471639610.001723">2016:08:19 20:46:50            mattsfrey </span><span>wondering if anyone knows offhand the best way to transform a map where I want to select keys of a certain set and map their children into a final map of  {:keyname child}</span></div><div data-t="nathanmarz @mattsfrey what&apos;s an example of input/output?"><span class="u" id="1471639890.001724">2016:08:19 20:51:30           nathanmarz </span><span>@mattsfrey what&apos;s an example of input/output?</span></div><div data-t="lellis ty! @nathanmarz  Done!!"><span class="u" id="1471640133.001725">2016:08:19 20:55:33               lellis </span><span>ty! @nathanmarz  Done!!</span></div><div data-t="mattsfrey I actually had to re-think it but let me get an example"><span class="u" id="1471641291.001726">2016:08:19 21:14:51            mattsfrey </span><span>I actually had to re-think it but let me get an example</span></div><div data-t="mattsfrey so this is what I&apos;m trying to achieve:"><span class="u" id="1471641878.001727">2016:08:19 21:24:38            mattsfrey </span><span>so this is what I&apos;m trying to achieve:</span></div><div data-t="mattsfrey https://pastebin.com/u3SNhevj"><span class="u" id="1471641879.001728">2016:08:19 21:24:39            mattsfrey </span><a href="https://pastebin.com/u3SNhevj">https://pastebin.com/u3SNhevj</a></div><div data-t="mattsfrey Basically will have a map of &quot;info types&quot; that are an array of sub maps, I want to pull out the child sub maps and put them into a flat structure as such"><span class="u" id="1471641943.001731">2016:08:19 21:25:43            mattsfrey </span><span>Basically will have a map of &quot;info types&quot; that are an array of sub maps, I want to pull out the child sub maps and put them into a flat structure as such</span></div><div data-t="mattsfrey (and disregard top level map values that aren&apos;t inside a certain set, i.e :bleh)"><span class="u" id="1471642134.001733">2016:08:19 21:28:54            mattsfrey </span><span>(and disregard top level map values that aren&apos;t inside a certain set, i.e :bleh)</span></div><div data-t="nathanmarz here&apos;s how I would do it:
 (def data {:phone-numbers [{:type &quot;work&quot; :value &quot;720-1234&quot;}
                           {:type &quot;home&quot; :value &quot;720-1235&quot;}]
           :organizations [{:name &quot;Google&quot; :title &quot;Software Engineer&quot;}]
           :bleh &quot;blah...&quot;})

(-&gt;&gt; data
     (traverse [ALL
                (not-selected? FIRST #{:bleh})
                (collect-one FIRST)
                LAST
                ALL])
     (reduce (fn [v [type val]] (conj v {:type type :value val}))
             []))
"><span class="u" id="1471642672.001735">2016:08:19 21:37:52           nathanmarz </span><span>here&apos;s how I would do it:
</span><pre>(def data {:phone-numbers [{:type &quot;work&quot; :value &quot;720-1234&quot;}
                           {:type &quot;home&quot; :value &quot;720-1235&quot;}]
           :organizations [{:name &quot;Google&quot; :title &quot;Software Engineer&quot;}]
           :bleh &quot;blah...&quot;})

(-&gt;&gt; data
     (traverse [ALL
                (not-selected? FIRST #{:bleh})
                (collect-one FIRST)
                LAST
                ALL])
     (reduce (fn [v [type val]] (conj v {:type type :value val}))
             []))
</pre></div><div data-t="mattsfrey that seems to be explicitly ignoring bleh whereas I&apos;d rather explicitly include elements of a set and ignore everything else"><span class="u" id="1471643124.001737">2016:08:19 21:45:24            mattsfrey </span><span>that seems to be explicitly ignoring bleh whereas I&apos;d rather explicitly include elements of a set and ignore everything else</span></div><div data-t="mattsfrey i.e. if in [:organizations :phone-numbers :addresses]"><span class="u" id="1471643177.001739">2016:08:19 21:46:17            mattsfrey </span><span>i.e. if in [:organizations :phone-numbers :addresses]</span></div><div data-t="nathanmarz just change that line to   (selected? FIRST #{:organizations :phone-numbers :addresses})"><span class="u" id="1471643889.001740">2016:08:19 21:58:09           nathanmarz </span><span>just change that line to  </span><code>(selected? FIRST #{:organizations :phone-numbers :addresses})</code></div><div data-t="amacdougall I&apos;m working with a multidimensional array, and couldn&apos;t quite figure out how to drill into a single grid cell by index without an awkward  (srange n (inc n)) . I ended up using  (update-in y x &lt;cell-specific keys...&gt; &lt;fn&gt;) , but if I want to do anything more complex, that will break down. Am I missing an easy way to select something out of a vector by index?"><span class="u" id="1471792381.001798">2016:08:21 15:13:01          amacdougall </span><span>I&apos;m working with a multidimensional array, and couldn&apos;t quite figure out how to drill into a single grid cell by index without an awkward </span><code>(srange n (inc n))</code><span>. I ended up using </span><code>(update-in y x &lt;cell-specific keys...&gt; &lt;fn&gt;)</code><span>, but if I want to do anything more complex, that will break down. Am I missing an easy way to select something out of a vector by index?</span></div><div data-t="nathanmarz @amacdougall use  keypath"><span class="u" id="1471792443.001799">2016:08:21 15:14:03           nathanmarz </span><span>@amacdougall use </span><code>keypath</code></div><div data-t="nathanmarz (transform [(keypath 2) (keypath 4)] ...)"><span class="u" id="1471792459.001800">2016:08:21 15:14:19           nathanmarz </span><code>(transform [(keypath 2) (keypath 4)] ...)</code></div><div data-t="amacdougall ...oh, that makes perfect sense. I saw &quot;key&quot; and my brain jumped to &quot;keyword&quot;."><span class="u" id="1471792522.001801">2016:08:21 15:15:22          amacdougall </span><span>...oh, that makes perfect sense. I saw &quot;key&quot; and my brain jumped to &quot;keyword&quot;.</span></div><div data-t="amacdougall Worked like a charm!"><span class="u" id="1471792639.001802">2016:08:21 15:17:19          amacdougall </span><span>Worked like a charm!</span></div><div data-t="yonatanel @nathanmarz: do you have any posts on what makes specter faster than drilling with built in functions, or should I just read the code?"><span class="u" id="1471847167.001823">2016:08:22 06:26:07            yonatanel </span><span>@nathanmarz: do you have any posts on what makes specter faster than drilling with built in functions, or should I just read the code?</span></div><div data-t="aengelberg @yonatanel it may help to look at the source code of  get-in  /  update-in , or macroexpanding a call to  select  or  transform"><span class="u" id="1471848859.001824">2016:08:22 06:54:19           aengelberg </span><span>@yonatanel it may help to look at the source code of </span><code>get-in</code><span> / </span><code>update-in</code><span>, or macroexpanding a call to </span><code>select</code><span> or </span><code>transform</code></div><div data-t="yonatanel Thanks, I will"><span class="u" id="1471849284.001825">2016:08:22 07:01:24            yonatanel </span><span>Thanks, I will</span></div><div data-t="nathanmarz @yonatanel take a look at this as well  https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs"><span class="u" id="1471863343.001832">2016:08:22 10:55:43           nathanmarz </span><span>@yonatanel take a look at this as well </span><a href="https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs">https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs</a></div><div data-t="mattsfrey @nathanmarz my one major complaint dealing with specter so far is it is very difficult to know where functions / macros are coming from, which are which etc. Reading an example I have to guess and check to figure out which is which. I still can&apos;t even find that function &quot;traverse&quot; in either macros or the main com.rpl.specter"><span class="u" id="1471880892.001844">2016:08:22 15:48:12            mattsfrey </span><span>@nathanmarz my one major complaint dealing with specter so far is it is very difficult to know where functions / macros are coming from, which are which etc. Reading an example I have to guess and check to figure out which is which. I still can&apos;t even find that function &quot;traverse&quot; in either macros or the main com.rpl.specter</span></div><div data-t="mattsfrey Is there any definitive require statement(s) to just import everything specter related?"><span class="u" id="1471880916.001845">2016:08:22 15:48:36            mattsfrey </span><span>Is there any definitive require statement(s) to just import everything specter related?</span></div><div data-t="nathanmarz @mattsfrey traverse is in specter 0.12.0"><span class="u" id="1471880961.001846">2016:08:22 15:49:21           nathanmarz </span><span>@mattsfrey traverse is in specter 0.12.0</span></div><div data-t="nathanmarz I use this to get everything into a single namespace in my projects  https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj"><span class="u" id="1471880983.001847">2016:08:22 15:49:43           nathanmarz </span><span>I use this to get everything into a single namespace in my projects </span><a href="https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj">https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj</a></div><div data-t="mattsfrey oh no kidding so thats hot off the press then"><span class="u" id="1471880998.001849">2016:08:22 15:49:58            mattsfrey </span><span>oh no kidding so thats hot off the press then</span></div><div data-t="nathanmarz there&apos;s also  https://github.com/nathanmarz/specter/wiki/List-of-Macros  and  https://github.com/nathanmarz/specter/wiki/List-of-Navigators"><span class="u" id="1471881045.001850">2016:08:22 15:50:45           nathanmarz </span><span>there&apos;s also </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros">https://github.com/nathanmarz/specter/wiki/List-of-Macros</a><span> and </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators">https://github.com/nathanmarz/specter/wiki/List-of-Navigators</a></div><div data-t="mattsfrey the lists definitely help, thanks"><span class="u" id="1471881854.001852">2016:08:22 16:04:14            mattsfrey </span><span>the lists definitely help, thanks</span></div><div data-t="mattsfrey also that code from yesterday (now that i have traverse!) works splendidly"><span class="u" id="1471881870.001853">2016:08:22 16:04:30            mattsfrey </span><span>also that code from yesterday (now that i have traverse!) works splendidly</span></div><div data-t="mattsfrey thanks!"><span class="u" id="1471881872.001854">2016:08:22 16:04:32            mattsfrey </span><span>thanks!</span></div><div data-t="nathanmarz @mattsfrey fyi, that code would work the same with  select , just less efficiently"><span class="u" id="1471885401.001855">2016:08:22 17:03:21           nathanmarz </span><span>@mattsfrey fyi, that code would work the same with </span><code>select</code><span>, just less efficiently</span></div><div data-t="zane Is there a more comprehensive guide to writing navigators? I feel like I&apos;m not getting the full picture from the API documentation."><span class="u" id="1471967666.001882">2016:08:23 15:54:26                 zane </span><span>Is there a more comprehensive guide to writing navigators? I feel like I&apos;m not getting the full picture from the API documentation.</span></div><div data-t="zane Also, it feels like there&apos;s significant overlap between  declarepath  /  providepath  recursive paths and navigators?"><span class="u" id="1471967736.001883">2016:08:23 15:55:36                 zane </span><span>Also, it feels like there&apos;s significant overlap between </span><code>declarepath</code><span> / </span><code>providepath</code><span> recursive paths and navigators?</span></div><div data-t="zane Am I reading this correctly?"><span class="u" id="1471967743.001884">2016:08:23 15:55:43                 zane </span><span>Am I reading this correctly?</span></div><div data-t="nathanmarz @zane there&apos;s also  https://github.com/nathanmarz/specter/wiki/List-of-Macros"><span class="u" id="1471968921.001885">2016:08:23 16:15:21           nathanmarz </span><span>@zane there&apos;s also </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros">https://github.com/nathanmarz/specter/wiki/List-of-Macros</a></div><div data-t="nathanmarz not sure what you mean by overlap,  declarepath  /  providepath  is the main way to make a recursive navigator"><span class="u" id="1471968973.001887">2016:08:23 16:16:13           nathanmarz </span><span>not sure what you mean by overlap, </span><code>declarepath</code><span> / </span><code>providepath</code><span> is the main way to make a recursive navigator</span></div><div data-t="zane I saw that! Definitely helps."><span class="u" id="1471968978.001888">2016:08:23 16:16:18                 zane </span><span>I saw that! Definitely helps.</span></div><div data-t="nathanmarz I do agree the docs need work"><span class="u" id="1471968993.001889">2016:08:23 16:16:33           nathanmarz </span><span>I do agree the docs need work</span></div><div data-t="zane Ah, there&apos;s probably a hole in my understanding around the intended uses of navigators and paths."><span class="u" id="1471969015.001890">2016:08:23 16:16:55                 zane </span><span>Ah, there&apos;s probably a hole in my understanding around the intended uses of navigators and paths.</span></div><div data-t="nathanmarz studying the implementations of the core navigators will probably help"><span class="u" id="1471969059.001891">2016:08:23 16:17:39           nathanmarz </span><span>studying the implementations of the core navigators will probably help</span></div><div data-t="zane Ah, that&apos;s a good suggestion."><span class="u" id="1471969073.001892">2016:08:23 16:17:53                 zane </span><span>Ah, that&apos;s a good suggestion.</span></div><div data-t="zane Specter is awesome, by the way! Even with my flawed understanding of it it&apos;s already paying dividends."><span class="u" id="1471969116.001893">2016:08:23 16:18:36                 zane </span><span>Specter is awesome, by the way! Even with my flawed understanding of it it&apos;s already paying dividends.</span></div><div data-t="nathanmarz thanks"><span class="u" id="1471969138.001894">2016:08:23 16:18:58           nathanmarz </span><span>thanks</span></div><div data-t="nathanmarz though I will say the real power is unlocked when you understand how to write your own navigators"><span class="u" id="1471969164.001895">2016:08:23 16:19:24           nathanmarz </span><span>though I will say the real power is unlocked when you understand how to write your own navigators</span></div><div data-t="zane I&apos;m getting that sense!"><span class="u" id="1471970039.001896">2016:08:23 16:33:59                 zane </span><span>I&apos;m getting that sense!</span></div><div data-t="zane &gt; though I will say the real power is unlocked when you understand how to write your own navigators
I&apos;d love to hear more about this: What kind of custom navigators do you feel deliver the most value?"><span class="u" id="1471980093.001902">2016:08:23 19:21:33                 zane </span><span>&gt; though I will say the real power is unlocked when you understand how to write your own navigators
I&apos;d love to hear more about this: What kind of custom navigators do you feel deliver the most value?</span></div><div data-t="nathanmarz @zane I have a whole suite of navigators for DAGs that I use privately"><span class="u" id="1471980405.001903">2016:08:23 19:26:45           nathanmarz </span><span>@zane I have a whole suite of navigators for DAGs that I use privately</span></div><div data-t="nathanmarz as an example"><span class="u" id="1471980432.001904">2016:08:23 19:27:12           nathanmarz </span><span>as an example</span></div><div data-t="nathanmarz I can do very sophisticated recursive DAG transformations with almost no effort at all, and it runs with near optimal performance"><span class="u" id="1471980458.001905">2016:08:23 19:27:38           nathanmarz </span><span>I can do very sophisticated recursive DAG transformations with almost no effort at all, and it runs with near optimal performance</span></div><div data-t="zane Ah, I think I remember you mentioning that in a video or blog post somewhere."><span class="u" id="1471980469.001906">2016:08:23 19:27:49                 zane </span><span>Ah, I think I remember you mentioning that in a video or blog post somewhere.</span></div><div data-t="nathanmarz the key is since that everything composes, you have a combinatoric explosion of ways in which you can apply Specter"><span class="u" id="1471980495.001907">2016:08:23 19:28:15           nathanmarz </span><span>the key is since that everything composes, you have a combinatoric explosion of ways in which you can apply Specter</span></div><div data-t="zane Right!"><span class="u" id="1471980504.001908">2016:08:23 19:28:24                 zane </span><span>Right!</span></div><div data-t="zane For simple recursive descent through EDN I shouldn&apos;t have to reach for custom navigators though, right?"><span class="u" id="1471980510.001909">2016:08:23 19:28:30                 zane </span><span>For simple recursive descent through EDN I shouldn&apos;t have to reach for custom navigators though, right?</span></div><div data-t="zane It should just be a matter of defining paths?"><span class="u" id="1471980519.001910">2016:08:23 19:28:39                 zane </span><span>It should just be a matter of defining paths?</span></div><div data-t="nathanmarz most likely"><span class="u" id="1471980533.001912">2016:08:23 19:28:53           nathanmarz </span><span>most likely</span></div><div data-t="zane Okay, cool. That was my intuition."><span class="u" id="1471980540.001913">2016:08:23 19:29:00                 zane </span><span>Okay, cool. That was my intuition.</span></div><div data-t="nathanmarz you&apos;ll start off using Specter for getting in and out of nested data structures, and later you&apos;ll see how much more the concept of navigation generalizes"><span class="u" id="1471980562.001914">2016:08:23 19:29:22           nathanmarz </span><span>you&apos;ll start off using Specter for getting in and out of nested data structures, and later you&apos;ll see how much more the concept of navigation generalizes</span></div><div data-t="nathanmarz a big moment for me was realizing that adding to a set could be expressed as a navigator"><span class="u" id="1471980610.001915">2016:08:23 19:30:10           nathanmarz </span><span>a big moment for me was realizing that adding to a set could be expressed as a navigator</span></div><div data-t="nathanmarz (setval [:a (subset #{})] #{:new-elem} data)"><span class="u" id="1471980632.001916">2016:08:23 19:30:32           nathanmarz </span><code>(setval [:a (subset #{})] #{:new-elem} data)</code></div><div data-t="zane Ah."><span class="u" id="1471980777.001918">2016:08:23 19:32:57                 zane </span><span>Ah.</span></div><div data-t="zane Yes."><span class="u" id="1471980778.001919">2016:08:23 19:32:58                 zane </span><span>Yes.</span></div><div data-t="zane Very monadic?"><span class="u" id="1471980786.001920">2016:08:23 19:33:06                 zane </span><span>Very monadic?</span></div><div data-t="zane Atom feels similar."><span class="u" id="1471980795.001921">2016:08:23 19:33:15                 zane </span><span>Atom feels similar.</span></div><div data-t="zane This was making me think about navigators that descended into  datomic  connections somehow, but that might be  🍌 s."><span class="u" id="1471980838.001922">2016:08:23 19:33:58                 zane </span><span>This was making me think about navigators that descended into </span><b>datomic</b><span> connections somehow, but that might be </span><b>🍌</b><span>s.</span></div><div data-t="nathanmarz select is semantically identical to the list monad, though specter&apos;s implementation is far more efficient"><span class="u" id="1471980842.001923">2016:08:23 19:34:02           nathanmarz </span><span>select is semantically identical to the list monad, though specter&apos;s implementation is far more efficient</span></div><div data-t="erichmond #shotsfired"><span class="u" id="1471980855.001924">2016:08:23 19:34:15            erichmond </span><span>#shotsfired</span></div><div data-t="nathanmarz I looked at how transform might be done as a monad some time ago but it wasn&apos;t obvious, and it wasn&apos;t really important to figure out"><span class="u" id="1471980870.001925">2016:08:23 19:34:30           nathanmarz </span><span>I looked at how transform might be done as a monad some time ago but it wasn&apos;t obvious, and it wasn&apos;t really important to figure out</span></div><div data-t="zane Are these available somewhere?"><span class="u" id="1471984290.001926">2016:08:23 20:31:30                 zane </span><span>Are these available somewhere?</span></div><div data-t="zane Hmm. So  view  is a bit weird in that it doesn&apos;t allow for transformations inside the view. (Which I guess makes sense.)"><span class="u" id="1471985408.001927">2016:08:23 20:50:08                 zane </span><span>Hmm. So </span><code>view</code><span> is a bit weird in that it doesn&apos;t allow for transformations inside the view. (Which I guess makes sense.)</span></div><div data-t="zane I wonder if transforms should even be allowed on paths that have  view s in them…"><span class="u" id="1471985936.001928">2016:08:23 20:58:56                 zane </span><span>I wonder if transforms should even be allowed on paths that have </span><code>view</code><span>s in them…</span></div><div data-t="nathanmarz view  works just fine in  transform"><span class="u" id="1471986163.001929">2016:08:23 21:02:43           nathanmarz </span><code>view</code><span> works just fine in </span><code>transform</code></div><div data-t="nathanmarz transformed  is similar to  view  except done with a path and transform function"><span class="u" id="1471986208.001930">2016:08:23 21:03:28           nathanmarz </span><code>transformed</code><span> is similar to </span><code>view</code><span> except done with a path and transform function</span></div><div data-t="nathanmarz @zane no, those navigators are not publicly available"><span class="u" id="1471986399.001931">2016:08:23 21:06:39           nathanmarz </span><span>@zane no, those navigators are not publicly available</span></div><div data-t="zane I guess what I mean is, this is not what I was expecting:
 (setval [(view namespace)]
        &quot;woo&quot;
        :hey/there)
"><span class="u" id="1471987480.001932">2016:08:23 21:24:40                 zane </span><span>I guess what I mean is, this is not what I was expecting:
</span><pre>(setval [(view namespace)]
        &quot;woo&quot;
        :hey/there)
</pre></div><div data-t="zane &quot;woo&quot;
"><span class="u" id="1471987491.001933">2016:08:23 21:24:51                 zane </span><pre>&quot;woo&quot;
</pre></div><div data-t="zane So now I&apos;m trying to write  NAMESPACE :
 (defnav NAMESPACE
  []
  (select* [this structure next-fn]
           (next-fn (namespace structure)))
  (transform* [this structure next-fn]
              (keyword (next-fn (namespace structure))
                       (name structure))))
"><span class="u" id="1471987512.001934">2016:08:23 21:25:12                 zane </span><span>So now I&apos;m trying to write </span><code>NAMESPACE</code><span>:
</span><pre>(defnav NAMESPACE
  []
  (select* [this structure next-fn]
           (next-fn (namespace structure)))
  (transform* [this structure next-fn]
              (keyword (next-fn (namespace structure))
                       (name structure))))
</pre></div><div data-t="zane Holy crap, it works."><span class="u" id="1471987694.001941">2016:08:23 21:28:14                 zane </span><span>Holy crap, it works.</span></div><div data-t="zane Magic!"><span class="u" id="1471987695.001942">2016:08:23 21:28:15                 zane </span><span>Magic!</span></div><div data-t="nathanmarz nice one, I have a similar navigator"><span class="u" id="1471988796.001943">2016:08:23 21:46:36           nathanmarz </span><span>nice one, I have a similar navigator</span></div><div data-t="nathanmarz you want to handle the no-namespace case as well (when  (next-fn (namespace structure))  returns nil)"><span class="u" id="1471988850.001944">2016:08:23 21:47:30           nathanmarz </span><span>you want to handle the no-namespace case as well (when </span><code>(next-fn (namespace structure))</code><span> returns nil)</span></div><div data-t="branch14 Hi, I&apos;m struggling to use specter (0.12.0) in cljs. I probably haven&apos;t set the ns up properly.
 =&gt; (select [:a :b] {:a {:b 42}})
#object[TypeError TypeError: Cannot read property &apos;specter&apos; of undefined]
 
My ns looks like this:
 (ns dummy
  (:require [com.rpl.specter :as s])
  (:require-macros [com.rpl.specter.macros :refer [select]]))
"><span class="u" id="1472041595.001962">2016:08:24 12:26:35             branch14 </span><span>Hi, I&apos;m struggling to use specter (0.12.0) in cljs. I probably haven&apos;t set the ns up properly.
</span><pre>=&gt; (select [:a :b] {:a {:b 42}})
#object[TypeError TypeError: Cannot read property &apos;specter&apos; of undefined]
</pre><span>
My ns looks like this:
</span><pre>(ns dummy
  (:require [com.rpl.specter :as s])
  (:require-macros [com.rpl.specter.macros :refer [select]]))
</pre></div><div data-t="nathanmarz @branch14 works fine for me, don&apos;t know what&apos;s causing that"><span class="u" id="1472042108.001963">2016:08:24 12:35:08           nathanmarz </span><span>@branch14 works fine for me, don&apos;t know what&apos;s causing that</span></div><div data-t="branch14 @nathanmarz Ha, it kind of works in the browser, but it doesn&apos;t on the REPL that figwheel gives me."><span class="u" id="1472042506.001964">2016:08:24 12:41:46             branch14 </span><span>@nathanmarz Ha, it kind of works in the browser, but it doesn&apos;t on the REPL that figwheel gives me.</span></div><div data-t="branch14 Ok, it works perfectly in the browser, but the REPL only yields the error above."><span class="u" id="1472042701.001965">2016:08:24 12:45:01             branch14 </span><span>Ok, it works perfectly in the browser, but the REPL only yields the error above.</span></div><div data-t="sashton I’m trying to write a navigator that drops  n  items. Here’s what I’ve got:
 (spm/defnav nav-drop [n]
  (select* [this structure next-fn]
           (let [ret (next-fn (drop n structure))
                 empt (empty structure)]
             (if (= ret sp/NONE)
               ret
               (into empt ret))))
  (transform* [this structure next-fn]
              (let [ret (next-fn (drop n structure))]
                (-&gt;&gt; (concat (take n structure) ret)
                     (into (empty structure))))))
 

I found I had to check the return value of  next-fn  to check for  NONE . Is that the right approach? My original attempt was done assuming I’d just get back an empty list, but that didn’t work."><span class="u" id="1472240150.002053">2016:08:26 19:35:50              sashton </span><span>I’m trying to write a navigator that drops </span><code>n</code><span> items. Here’s what I’ve got:
</span><pre>(spm/defnav nav-drop [n]
  (select* [this structure next-fn]
           (let [ret (next-fn (drop n structure))
                 empt (empty structure)]
             (if (= ret sp/NONE)
               ret
               (into empt ret))))
  (transform* [this structure next-fn]
              (let [ret (next-fn (drop n structure))]
                (-&gt;&gt; (concat (take n structure) ret)
                     (into (empty structure))))))
</pre><span>

I found I had to check the return value of </span><code>next-fn</code><span> to check for </span><code>NONE</code><span>. Is that the right approach? My original attempt was done assuming I’d just get back an empty list, but that didn’t work.</span></div><div data-t="nathanmarz @sashton the select* implementation should just be   (next-fn (drop n structure))"><span class="u" id="1472244101.002055">2016:08:26 20:41:41           nathanmarz </span><span>@sashton the select* implementation should just be </span><code> (next-fn (drop n structure))</code></div><div data-t="nathanmarz you&apos;re on 0.12.0, right?"><span class="u" id="1472244157.002056">2016:08:26 20:42:37           nathanmarz </span><span>you&apos;re on 0.12.0, right?</span></div><div data-t="sashton yes"><span class="u" id="1472244167.002057">2016:08:26 20:42:47              sashton </span><span>yes</span></div><div data-t="sashton that changes the data type to a list, though, right?"><span class="u" id="1472244180.002058">2016:08:26 20:43:00              sashton </span><span>that changes the data type to a list, though, right?</span></div><div data-t="sashton even if my input is a vector?"><span class="u" id="1472244193.002059">2016:08:26 20:43:13              sashton </span><span>even if my input is a vector?</span></div><div data-t="sashton i was trying to preserve the collection type"><span class="u" id="1472244208.002060">2016:08:26 20:43:28              sashton </span><span>i was trying to preserve the collection type</span></div><div data-t="nathanmarz the requirement of select* is to call next-fn on whatever subvalue should be passed to the next navigator"><span class="u" id="1472244238.002061">2016:08:26 20:43:58           nathanmarz </span><span>the requirement of select* is to call next-fn on whatever subvalue should be passed to the next navigator</span></div><div data-t="nathanmarz so you should put the logic to maintain type before you call next-fn"><span class="u" id="1472244260.002062">2016:08:26 20:44:20           nathanmarz </span><span>so you should put the logic to maintain type before you call next-fn</span></div><div data-t="nathanmarz probably  (next-fn (into (empty structure) (drop n structure)))"><span class="u" id="1472244281.002063">2016:08:26 20:44:41           nathanmarz </span><span>probably </span><code>(next-fn (into (empty structure) (drop n structure)))</code></div><div data-t="sashton ah, i’ll give that a try"><span class="u" id="1472244290.002064">2016:08:26 20:44:50              sashton </span><span>ah, i’ll give that a try</span></div><div data-t="nathanmarz you only need to deal with  NONE  when a navigator navigates to an indeterminate number of subvalues"><span class="u" id="1472244337.002065">2016:08:26 20:45:37           nathanmarz </span><span>you only need to deal with </span><code>NONE</code><span> when a navigator navigates to an indeterminate number of subvalues</span></div><div data-t="amacdougall Still playing with my maze thing—to implement the first algorithm in the book, I realized that I needed to consider each cell in turn, but during each iteration, I might need to operate on the entire grid. For instance, upon deciding that cell 0,0 should be linked east to cell 1,0, I need to get a grid with both cells changed.

I solved it by applying the Feynmann Algorithm, and used  traverse :
 (reduce
  (fn [grid cell]
    (let [open-directions (filter (partial move grid cell) [::s ::e])]
      (if (empty? open-directions)
        grid
        (link grid cell (rand-nth open-directions)))))
  g
  (sm/traverse [s/ALL s/ALL] g))
 
This totally works! Just curious if I&apos;m missing a simpler way to do the same thing.

(The book is in Ruby, so it has an easier time just navigating around the data structure and changing whatever it wants at any point in the loop.)"><span class="u" id="1472405488.000017">2016:08:28 17:31:28          amacdougall </span><span>Still playing with my maze thing—to implement the first algorithm in the book, I realized that I needed to consider each cell in turn, but during each iteration, I might need to operate on the entire grid. For instance, upon deciding that cell 0,0 should be linked east to cell 1,0, I need to get a grid with both cells changed.

I solved it by applying the Feynmann Algorithm, and used </span><code>traverse</code><span>:
</span><pre>(reduce
  (fn [grid cell]
    (let [open-directions (filter (partial move grid cell) [::s ::e])]
      (if (empty? open-directions)
        grid
        (link grid cell (rand-nth open-directions)))))
  g
  (sm/traverse [s/ALL s/ALL] g))
</pre><span>
This totally works! Just curious if I&apos;m missing a simpler way to do the same thing.

(The book is in Ruby, so it has an easier time just navigating around the data structure and changing whatever it wants at any point in the loop.)</span></div><div data-t="amacdougall ...looking at the docs and my code a bit harder, I realize that  traverse  is just there to have a more efficient implementation than  select  when used as a  reduce  argument. And the problem of &quot;make changes to a larger resultset while iterating over individual elements&quot; is exactly what  reduce  is for. So I guess that kind of answers my question.  :duck:"><span class="u" id="1472405695.000018">2016:08:28 17:34:55          amacdougall </span><span>...looking at the docs and my code a bit harder, I realize that </span><code>traverse</code><span> is just there to have a more efficient implementation than </span><code>select</code><span> when used as a </span><code>reduce</code><span> argument. And the problem of &quot;make changes to a larger resultset while iterating over individual elements&quot; is exactly what </span><code>reduce</code><span> is for. So I guess that kind of answers my question. </span><b>:duck:</b></div><div data-t="bill I can  (dissoc {:id 1} :id) .

Is there an idomatic way to dissoc in specter, or should I nav to the map of interest and call my own function that calls  dissoc ?"><span class="u" id="1472482918.000046">2016:08:29 15:01:58                 bill </span><span>I can </span><code>(dissoc {:id 1} :id)</code><span>.

Is there an idomatic way to dissoc in specter, or should I nav to the map of interest and call my own function that calls </span><code>dissoc</code><span>?</span></div><div data-t="bill (and yes, I searched the docs, bugs and source for “dissoc” first)"><span class="u" id="1472482989.000047">2016:08:29 15:03:09                 bill </span><span>(and yes, I searched the docs, bugs and source for “dissoc” first)</span></div><div data-t="codonnell @bill: you could do  (view #(dissoc % :k)) , but if you use that with  transform , the key will not be added back during reconstruction"><span class="u" id="1472483754.000049">2016:08:29 15:15:54            codonnell </span><span>@bill: you could do </span><code>(view #(dissoc % :k))</code><span>, but if you use that with </span><code>transform</code><span>, the key will not be added back during reconstruction</span></div><div data-t="codonnell you could also write your own navigator, which would be straightforward"><span class="u" id="1472483779.000050">2016:08:29 15:16:19            codonnell </span><span>you could also write your own navigator, which would be straightforward</span></div><div data-t="bill thanks @codonnell. I don’t understand your caveat “the key will not be added back during reconstruction”.

maybe I’m not being clear: I want the key (and value) removed from the hash."><span class="u" id="1472485132.000051">2016:08:29 15:38:52                 bill </span><span>thanks @codonnell. I don’t understand your caveat “the key will not be added back during reconstruction”.

maybe I’m not being clear: I want the key (and value) removed from the hash.</span></div><div data-t="codonnell @bill: For example,  (transform [(view #(dissoc % :a)) MAP-VALS] inc {:a 0 :b 0 :c 0})  gives  {:b 1, :c 1} , not  {:a 0, :b 1, :c 1}"><span class="u" id="1472485335.000052">2016:08:29 15:42:15            codonnell </span><span>@bill: For example, </span><code>(transform [(view #(dissoc % :a)) MAP-VALS] inc {:a 0 :b 0 :c 0})</code><span> gives </span><code>{:b 1, :c 1}</code><span>, not </span><code>{:a 0, :b 1, :c 1}</code></div><div data-t="codonnell If you wrote your own navigator, you could make it have the latter behavior."><span class="u" id="1472485376.000053">2016:08:29 15:42:56            codonnell </span><span>If you wrote your own navigator, you could make it have the latter behavior.</span></div><div data-t="bill ah I get 60% of that which is enough—I think that’ll work for me. thanks!"><span class="u" id="1472485449.000054">2016:08:29 15:44:09                 bill </span><span>ah I get 60% of that which is enough—I think that’ll work for me. thanks!</span></div><div data-t="codonnell @bill: There are lots of examples on the wiki, including an example of a custom navigator at  https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav"><span class="u" id="1472485568.000056">2016:08:29 15:46:08            codonnell </span><span>@bill: There are lots of examples on the wiki, including an example of a custom navigator at </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav">https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav</a></div><div data-t="codonnell good luck!"><span class="u" id="1472485605.000058">2016:08:29 15:46:45            codonnell </span><span>good luck!</span></div><div data-t="bill thanks!"><span class="u" id="1472485619.000059">2016:08:29 15:46:59                 bill </span><span>thanks!</span></div><div data-t="bill so I here is me, removing the  :id s:

 (transform [:results ALL (view #(dissoc % :id)) MAP-VALS] identity {:foo 3 :results [{:id 0 :b 0 :c 0}]})
=&gt; {:foo 3, :results [{:b 0, :c 0}]}
 

It works, but it seems like calling  identity  is a sign of wrongness here."><span class="u" id="1472485914.000060">2016:08:29 15:51:54                 bill </span><span>so I here is me, removing the </span><code>:id</code><span>s:

</span><pre>(transform [:results ALL (view #(dissoc % :id)) MAP-VALS] identity {:foo 3 :results [{:id 0 :b 0 :c 0}]})
=&gt; {:foo 3, :results [{:b 0, :c 0}]}
</pre><span>

It works, but it seems like calling </span><code>identity</code><span> is a sign of wrongness here.</span></div><div data-t="codonnell @bill: I&apos;m not at a repl, but I think you could do  (transform [:results ALL] #(dissoc % :id) data)"><span class="u" id="1472486105.000065">2016:08:29 15:55:05            codonnell </span><span>@bill: I&apos;m not at a repl, but I think you could do </span><code>(transform [:results ALL] #(dissoc % :id) data)</code></div><div data-t="bill perfecto! (works)"><span class="u" id="1472486227.000066">2016:08:29 15:57:07                 bill </span><span>perfecto! (works)</span></div><div data-t="nathanmarz @bill I&apos;ve used a function like this in the past:
 (defn dissocer [k]
  (fn [m]
    (dissoc m k)))
"><span class="u" id="1472486594.000067">2016:08:29 16:03:14           nathanmarz </span><span>@bill I&apos;ve used a function like this in the past:
</span><pre>(defn dissocer [k]
  (fn [m]
    (dissoc m k)))
</pre></div><div data-t="nathanmarz then you can do  (transform [:results ALL] (dissocer :a) data)"><span class="u" id="1472486612.000068">2016:08:29 16:03:32           nathanmarz </span><span>then you can do </span><code>(transform [:results ALL] (dissocer :a) data)</code></div><div data-t="bill nice ‘un @nathanmarz"><span class="u" id="1472486656.000069">2016:08:29 16:04:16                 bill </span><span>nice ‘un @nathanmarz</span></div><div data-t="caio as we’re talking about  dissoc ing, I have a doubt as well  😆  
I need to dissoc a key from every map that has it in a nested structure, so if I want to dissoc  :a ,  {:a “le”, :c {:a “lu”, :b “la”}}  should become  {:c {:b “la”}} . I tried doing  (transform (walker coll?) #(dissoc % :a) ds) , but the walker stops on the first level and the transform returns  {:c {:a “lu”, :b “la”}} . is there an easy way to do this?"><span class="u" id="1472775315.000177">2016:09:02 00:15:15                 caio </span><span>as we’re talking about </span><code>dissoc</code><span>ing, I have a doubt as well </span><b>😆</b><span> 
I need to dissoc a key from every map that has it in a nested structure, so if I want to dissoc </span><code>:a</code><span>, </span><code>{:a “le”, :c {:a “lu”, :b “la”}}</code><span> should become </span><code>{:c {:b “la”}}</code><span>. I tried doing </span><code>(transform (walker coll?) #(dissoc % :a) ds)</code><span>, but the walker stops on the first level and the transform returns </span><code>{:c {:a “lu”, :b “la”}}</code><span>. is there an easy way to do this?</span></div><div data-t="caio oh, nvm. just saw  params-reset  for declaring recursive navigators"><span class="u" id="1472775820.000179">2016:09:02 00:23:40                 caio </span><span>oh, nvm. just saw </span><code>params-reset</code><span> for declaring recursive navigators</span></div><div data-t="codonnell @caio: I don&apos;t think you need  params-reset . Here&apos;s what I came up with, though I&apos;m trying to think of a better way.
  =&gt; (declarepath MapWalker)
=&gt; (providepath MapWalker (if-path map? (continue-then-stay MAP-VALS MapWalker)))
=&gt; (transform MapWalker #(dissoc % :a) {:a 0 :b {:a 1 :b 2}})
{:b {:b 2}}"><span class="u" id="1472776081.000180">2016:09:02 00:28:01            codonnell </span><span>@caio: I don&apos;t think you need </span><code>params-reset</code><span>. Here&apos;s what I came up with, though I&apos;m trying to think of a better way.
 </span><pre>=&gt; (declarepath MapWalker)
=&gt; (providepath MapWalker (if-path map? (continue-then-stay MAP-VALS MapWalker)))
=&gt; (transform MapWalker #(dissoc % :a) {:a 0 :b {:a 1 :b 2}})
{:b {:b 2}}</pre></div><div data-t="codonnell Yeah, here&apos;s a shorter implementation:  (providepath MapWalker (continue-then-stay MAP-VALS map? MapWalker))"><span class="u" id="1472776229.000182">2016:09:02 00:30:29            codonnell </span><span>Yeah, here&apos;s a shorter implementation: </span><code>(providepath MapWalker (continue-then-stay MAP-VALS map? MapWalker))</code></div><div data-t="caio Oh, nice. Didn&apos;t knew this  continue-then-stay . Thanks!"><span class="u" id="1472777387.000183">2016:09:02 00:49:47                 caio </span><span>Oh, nice. Didn&apos;t knew this </span><code>continue-then-stay</code><span>. Thanks!</span></div><div data-t="nathanmarz for those interested, I rewrote almost all of Specter&apos;s core  https://github.com/nathanmarz/specter/blob/rewrite/CHANGES.md"><span class="u" id="1472832875.000199">2016:09:02 16:14:35           nathanmarz </span><span>for those interested, I rewrote almost all of Specter&apos;s core </span><a href="https://github.com/nathanmarz/specter/blob/rewrite/CHANGES.md">https://github.com/nathanmarz/specter/blob/rewrite/CHANGES.md</a></div><div data-t="nathanmarz 25% smaller codebase, better performance, and no more restrictions on what can be inline compiled/cached (locals, special forms, and dynamic vars in nav positions can now be inline compiled/cached)"><span class="u" id="1472832947.000201">2016:09:02 16:15:47           nathanmarz </span><span>25% smaller codebase, better performance, and no more restrictions on what can be inline compiled/cached (locals, special forms, and dynamic vars in nav positions can now be inline compiled/cached)</span></div><div data-t="caio @codonnell the code you sent me actually breaks when there are other nested structures other than maps (vectors for instance). for instance:
 =&gt; (transform MapWalker #(dissoc % :a) {:a 0 :b [{:a 1 :b 2}]})
{:b [{:a 1 :b 2}]}
 

. after some time, this is what I got:
 (declarepath map-walker)
(providepath map-walker [(walker map?)
                         (continue-then-stay MAP-VALS map-walker)])
 

now it’s working fine  🙂"><span class="u" id="1472835185.000207">2016:09:02 16:53:05                 caio </span><span>@codonnell the code you sent me actually breaks when there are other nested structures other than maps (vectors for instance). for instance:
</span><pre>=&gt; (transform MapWalker #(dissoc % :a) {:a 0 :b [{:a 1 :b 2}]})
{:b [{:a 1 :b 2}]}
</pre><span>

. after some time, this is what I got:
</span><pre>(declarepath map-walker)
(providepath map-walker [(walker map?)
                         (continue-then-stay MAP-VALS map-walker)])
</pre><span>

now it’s working fine </span><b>🙂</b></div><div data-t="codonnell @caio: nice!"><span class="u" id="1472835255.000209">2016:09:02 16:54:15            codonnell </span><span>@caio: nice!</span></div><div data-t="escherize Hello I&apos;m new to specter, and I&apos;m trying to move a keyword from one path to another. so far I have this working but I can&apos;t tell if it is the specter way, and I have a feeling i&apos;m doing it wrong:

 (defn remover [&amp; n]
  (fn [coll] (into (empty coll)
                   (remove (set n) coll))))

(-&gt;&gt; {:a [1 2 3] :b [4]}
     (transform [:a] (remover 2))
     (setval [:b BEGINNING] [2]))
"><span class="u" id="1472835300.000210">2016:09:02 16:55:00            escherize </span><span>Hello I&apos;m new to specter, and I&apos;m trying to move a keyword from one path to another. so far I have this working but I can&apos;t tell if it is the specter way, and I have a feeling i&apos;m doing it wrong:

</span><pre>(defn remover [&amp; n]
  (fn [coll] (into (empty coll)
                   (remove (set n) coll))))

(-&gt;&gt; {:a [1 2 3] :b [4]}
     (transform [:a] (remover 2))
     (setval [:b BEGINNING] [2]))
</pre></div><div data-t="escherize I&apos;d like to be able to reference the  2  in this example from inside the paths themselves.  is that a thing? I&apos;ve been reading the docs and having trouble finding something that addresses this"><span class="u" id="1472835467.000211">2016:09:02 16:57:47            escherize </span><span>I&apos;d like to be able to reference the </span><code>2</code><span> in this example from inside the paths themselves.  is that a thing? I&apos;ve been reading the docs and having trouble finding something that addresses this</span></div><div data-t="codonnell @escherize: To add onto the beginning of a sequence with specter, it&apos;s more idiomatic to do  (setval [:b BEGINNING] [0] [1 2 3])"><span class="u" id="1472835576.000212">2016:09:02 16:59:36            codonnell </span><span>@escherize: To add onto the beginning of a sequence with specter, it&apos;s more idiomatic to do </span><code>(setval [:b BEGINNING] [0] [1 2 3])</code></div><div data-t="escherize thanks, I thought conjer was a bit much. I&apos;ll update the example"><span class="u" id="1472835614.000213">2016:09:02 17:00:14            escherize </span><span>thanks, I thought conjer was a bit much. I&apos;ll update the example</span></div><div data-t="codonnell Other than that, your approach looks fine to me."><span class="u" id="1472835667.000214">2016:09:02 17:01:07            codonnell </span><span>Other than that, your approach looks fine to me.</span></div><div data-t="escherize That&apos;s good to hear, thanks @codonnell"><span class="u" id="1472835765.000216">2016:09:02 17:02:45            escherize </span><span>That&apos;s good to hear, thanks @codonnell</span></div><div data-t="escherize but is there a way to bake the  2  into the path itself?"><span class="u" id="1472836064.000217">2016:09:02 17:07:44            escherize </span><span>but is there a way to bake the </span><code>2</code><span> into the path itself?</span></div><div data-t="zane Oh wow."><span class="u" id="1472836139.000218">2016:09:02 17:08:59                 zane </span><span>Oh wow.</span></div><div data-t="codonnell Yes @escherize. Transform functions receive as their initial arguments any collected values."><span class="u" id="1472836260.000219">2016:09:02 17:11:00            codonnell </span><span>Yes @escherize. Transform functions receive as their initial arguments any collected values.</span></div><div data-t="codonnell =&gt; (transform [(putval #{2 3 5}) :a] remove {:a (range 10)})
{:a (0 1 4 6 7 8 9)}"><span class="u" id="1472836411.000221">2016:09:02 17:13:31            codonnell </span><pre>=&gt; (transform [(putval #{2 3 5}) :a] remove {:a (range 10)})
{:a (0 1 4 6 7 8 9)}</pre></div><div data-t="escherize ohhh. I see! that&apos;s fantasic, thanks @codonnell !"><span class="u" id="1472836515.000222">2016:09:02 17:15:15            escherize </span><span>ohhh. I see! that&apos;s fantasic, thanks @codonnell !</span></div><div data-t="codonnell @nathanmarz are you planning on a blog post/wiki page about the 0.13.0 changes similar to the post about 0.11.0&apos;s optimizations?"><span class="u" id="1472842799.000223">2016:09:02 18:59:59            codonnell </span><span>@nathanmarz are you planning on a blog post/wiki page about the 0.13.0 changes similar to the post about 0.11.0&apos;s optimizations?</span></div><div data-t="nathanmarz @codonnell if I have time"><span class="u" id="1472845080.000224">2016:09:02 19:38:00           nathanmarz </span><span>@codonnell if I have time</span></div><div data-t="nathanmarz @codonnell the inline caching implementation is completely different now"><span class="u" id="1472845097.000225">2016:09:02 19:38:17           nathanmarz </span><span>@codonnell the inline caching implementation is completely different now</span></div><div data-t="nathanmarz @codonnell I need  to get the new design working for cljs first"><span class="u" id="1472845137.000226">2016:09:02 19:38:57           nathanmarz </span><span>@codonnell I need  to get the new design working for cljs first</span></div><div data-t="codonnell :+1:"><span class="u" id="1472845337.000227">2016:09:02 19:42:17            codonnell </span><b>:+1:</b></div><div data-t="markaddleman i&apos;m pretty new to specter.  i have a map with some nils in the values.  how would i create a submap of all non-nil values?  eg {:a  😛 , :c :d, :nil nil} =&gt; {:a  😛 , :c :d}"><span class="u" id="1472988049.000038">2016:09:04 11:20:49         markaddleman </span><span>i&apos;m pretty new to specter.  i have a map with some nils in the values.  how would i create a submap of all non-nil values?  eg {:a </span><b>😛</b><span>, :c :d, :nil nil} =&gt; {:a </span><b>😛</b><span>, :c :d}</span></div><div data-t="nathanmarz @markaddleman at the moment with built-in navs:  (into {} (traverse [ALL (selected? LAST some?)] data))"><span class="u" id="1472993906.000039">2016:09:04 12:58:26           nathanmarz </span><span>@markaddleman at the moment with built-in navs: </span><code>(into {} (traverse [ALL (selected? LAST some?)] data))</code></div><div data-t="nathanmarz though there&apos;s consideration over extending the built-in navs to support removal as well  https://github.com/nathanmarz/specter/issues/117"><span class="u" id="1472993960.000040">2016:09:04 12:59:20           nathanmarz </span><span>though there&apos;s consideration over extending the built-in navs to support removal as well </span><a href="https://github.com/nathanmarz/specter/issues/117">https://github.com/nathanmarz/specter/issues/117</a></div><div data-t="nathanmarz in which case your use case would be  (setval [MAP-VALS nil?] NONE data)"><span class="u" id="1472993985.000042">2016:09:04 12:59:45           nathanmarz </span><span>in which case your use case would be </span><code>(setval [MAP-VALS nil?] NONE data)</code></div><div data-t="markaddleman Thanks"><span class="u" id="1472996868.000048">2016:09:04 13:47:48         markaddleman </span><span>Thanks</span></div><div data-t="escherize Anyone here have much experience with using re-frame + specter before?"><span class="u" id="1473146376.000099">2016:09:06 07:19:36            escherize </span><span>Anyone here have much experience with using re-frame + specter before?</span></div><div data-t="escherize There is a little bit of overlap (the re-frame path interceptor for example)."><span class="u" id="1473146392.000100">2016:09:06 07:19:52            escherize </span><span>There is a little bit of overlap (the re-frame path interceptor for example).</span></div><div data-t="escherize but I&apos;d be curious to here."><span class="u" id="1473146401.000101">2016:09:06 07:20:01            escherize </span><span>but I&apos;d be curious to here.</span></div><div data-t="nathanmarz Released Specter 0.13.0  https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><span class="u" id="1473171369.000108">2016:09:06 14:16:09           nathanmarz </span><span>Released Specter 0.13.0 </span><a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></div><div data-t="nathanmarz Here&apos;s a post about the new inline caching implementation  https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation"><span class="u" id="1473171390.000110">2016:09:06 14:16:30           nathanmarz </span><span>Here&apos;s a post about the new inline caching implementation </span><a href="https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation">https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation</a></div><div data-t="nathanmarz And a benchmark  https://gist.github.com/nathanmarz/b7c612b417647db80b9eaab618ff8d83"><span class="u" id="1473171409.000112">2016:09:06 14:16:49           nathanmarz </span><span>And a benchmark </span><a href="https://gist.github.com/nathanmarz/b7c612b417647db80b9eaab618ff8d83">https://gist.github.com/nathanmarz/b7c612b417647db80b9eaab618ff8d83</a></div><div data-t="martinklepsch @nathanmarz in changelog  with defnav or defnav"><span class="u" id="1473171523.000114">2016:09:06 14:18:43        martinklepsch </span><span>@nathanmarz in changelog </span><code>with defnav or defnav</code></div><div data-t="martinklepsch think that&apos;s a typo?"><span class="u" id="1473171533.000115">2016:09:06 14:18:53        martinklepsch </span><span>think that&apos;s a typo?</span></div><div data-t="nathanmarz @martinklepsch just poorly written, updated it to be clearer"><span class="u" id="1473171674.000117">2016:09:06 14:21:14           nathanmarz </span><span>@martinklepsch just poorly written, updated it to be clearer</span></div><div data-t="martinklepsch ahh, I get it now  😛  I thought there was an asterisk or something like that missing from the second  defnav , congrats on the release as well  :+1:"><span class="u" id="1473171743.000118">2016:09:06 14:22:23        martinklepsch </span><span>ahh, I get it now </span><b>😛</b><span> I thought there was an asterisk or something like that missing from the second </span><code>defnav</code><span>, congrats on the release as well </span><b>:+1:</b></div><div data-t="nathanmarz thanks!"><span class="u" id="1473171758.000119">2016:09:06 14:22:38           nathanmarz </span><span>thanks!</span></div><div data-t="caio I’m not being able to run the benchmark  😞   Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: com.rpl.specter.Util, compiling:(com/rpl/specter/impl.cljc:1:1)"><span class="u" id="1473172879.000125">2016:09:06 14:41:19                 caio </span><span>I’m not being able to run the benchmark </span><b>😞</b><span> </span><code>Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: com.rpl.specter.Util, compiling:(com/rpl/specter/impl.cljc:1:1)</code></div><div data-t="nathanmarz how are you running it?"><span class="u" id="1473172914.000126">2016:09:06 14:41:54           nathanmarz </span><span>how are you running it?</span></div><div data-t="caio scripts/run-benchmarks"><span class="u" id="1473172943.000127">2016:09:06 14:42:23                 caio </span><code>scripts/run-benchmarks</code></div><div data-t="nathanmarz ah, do  lein javac  first"><span class="u" id="1473172963.000128">2016:09:06 14:42:43           nathanmarz </span><span>ah, do </span><code>lein javac</code><span> first</span></div><div data-t="nathanmarz ah just realized the benchmark script needs a quick update"><span class="u" id="1473173033.000129">2016:09:06 14:43:53           nathanmarz </span><span>ah just realized the benchmark script needs a quick update</span></div><div data-t="nathanmarz one sec"><span class="u" id="1473173034.000130">2016:09:06 14:43:54           nathanmarz </span><span>one sec</span></div><div data-t="nathanmarz ok, just pushed a fix"><span class="u" id="1473173094.000131">2016:09:06 14:44:54           nathanmarz </span><span>ok, just pushed a fix</span></div><div data-t="nathanmarz it wasn&apos;t updated to the namespace change"><span class="u" id="1473173110.000132">2016:09:06 14:45:10           nathanmarz </span><span>it wasn&apos;t updated to the namespace change</span></div><div data-t="caio now it worked. thanks"><span class="u" id="1473173278.000133">2016:09:06 14:47:58                 caio </span><span>now it worked. thanks</span></div><div data-t="amacdougall I&apos;m still getting up to speed on selectors. I&apos;m creating Hiccup-formatted SVG, and in this case, I&apos;m trying to get the attributes map of the first  rect  in a  g  (SVG&apos;s &quot;group&quot; tag). This works for me, but I suspect I&apos;m missing a better way:
 (sm/select-any
  [s/ALL vector? #(= :rect (first %)) s/ALL map?]
  [:g
   [:line {:x1 0 :y1 0 :x2 100 :y2 100}]
   [:rect {:x 1 :y 2 :width 100 :height 200}]])
"><span class="u" id="1473211749.000145">2016:09:07 01:29:09          amacdougall </span><span>I&apos;m still getting up to speed on selectors. I&apos;m creating Hiccup-formatted SVG, and in this case, I&apos;m trying to get the attributes map of the first </span><code>rect</code><span> in a </span><code>g</code><span> (SVG&apos;s &quot;group&quot; tag). This works for me, but I suspect I&apos;m missing a better way:
</span><pre>(sm/select-any
  [s/ALL vector? #(= :rect (first %)) s/ALL map?]
  [:g
   [:line {:x1 0 :y1 0 :x2 100 :y2 100}]
   [:rect {:x 1 :y 2 :width 100 :height 200}]])
</pre></div><div data-t="nathanmarz @amacdougall if the attributes map is always the last element of the vector you can end with  LAST  instead of  [ALL map?]"><span class="u" id="1473211967.000146">2016:09:07 01:32:47           nathanmarz </span><span>@amacdougall if the attributes map is always the last element of the vector you can end with </span><code>LAST</code><span> instead of </span><code>[ALL map?]</code></div><div data-t="amacdougall Ah, good point! In this case, I think it will be, because the rects are leaf nodes in the SVG tree. For other constructs, this may not hold true, but that&apos;s another story."><span class="u" id="1473212003.000147">2016:09:07 01:33:23          amacdougall </span><span>Ah, good point! In this case, I think it will be, because the rects are leaf nodes in the SVG tree. For other constructs, this may not hold true, but that&apos;s another story.</span></div><div data-t="amacdougall Thanks!"><span class="u" id="1473212008.000148">2016:09:07 01:33:28          amacdougall </span><span>Thanks!</span></div><div data-t="nathanmarz you can also use  keypath  to navigate by index into a vector"><span class="u" id="1473212031.000149">2016:09:07 01:33:51           nathanmarz </span><span>you can also use </span><code>keypath</code><span> to navigate by index into a vector</span></div><div data-t="amacdougall I suppose in this case, it&apos;s okay to assume a lot about the structure of the target. But one of my favorite things about Specter is that paths can be quite flexible. Just trying to develop good habits."><span class="u" id="1473212180.000150">2016:09:07 01:36:20          amacdougall </span><span>I suppose in this case, it&apos;s okay to assume a lot about the structure of the target. But one of my favorite things about Specter is that paths can be quite flexible. Just trying to develop good habits.</span></div><div data-t="nathanmarz yea just takes practice"><span class="u" id="1473212253.000152">2016:09:07 01:37:33           nathanmarz </span><span>yea just takes practice</span></div><div data-t="levitanong I’m getting  ERROR: contains? not supported on type: clojure.lang.PersistentList  when requiring specter. Am I doing anything wrong? The following is my require clause in  ns :  (:require [com.rpl.specter :refer [ALL FIRST]])"><span class="u" id="1473234267.000164">2016:09:07 07:44:27           levitanong </span><span>I’m getting </span><code>ERROR: contains? not supported on type: clojure.lang.PersistentList</code><span> when requiring specter. Am I doing anything wrong? The following is my require clause in </span><code>ns</code><span>: </span><code>(:require [com.rpl.specter :refer [ALL FIRST]])</code></div><div data-t="levitanong this is on specter 0.13.0. Specter 0.12.0 works just fine"><span class="u" id="1473235090.000167">2016:09:07 07:58:10           levitanong </span><span>this is on specter 0.13.0. Specter 0.12.0 works just fine</span></div><div data-t="nathanmarz @levitanong is this Clojure or ClojureScript? do you have a full stack trace?"><span class="u" id="1473246545.000173">2016:09:07 11:09:05           nathanmarz </span><span>@levitanong is this Clojure or ClojureScript? do you have a full stack trace?</span></div><div data-t="levitanong clojurescript"><span class="u" id="1473248613.000174">2016:09:07 11:43:33           levitanong </span><span>clojurescript</span></div><div data-t="levitanong hang on, will come up with the full stack trace"><span class="u" id="1473248626.000175">2016:09:07 11:43:46           levitanong </span><span>hang on, will come up with the full stack trace</span></div><div data-t="nathanmarz @levitanong what version of cljs?"><span class="u" id="1473249157.000177">2016:09:07 11:52:37           nathanmarz </span><span>@levitanong what version of cljs?</span></div><div data-t="levitanong 1.9.225"><span class="u" id="1473249173.000178">2016:09:07 11:52:53           levitanong </span><span>1.9.225</span></div><div data-t="nathanmarz I just pushed a build that renames that function, might fix it"><span class="u" id="1473249327.000179">2016:09:07 11:55:27           nathanmarz </span><span>I just pushed a build that renames that function, might fix it</span></div><div data-t="nathanmarz try 0.13.1-SNAPSHOT"><span class="u" id="1473249331.000180">2016:09:07 11:55:31           nathanmarz </span><span>try 0.13.1-SNAPSHOT</span></div><div data-t="levitanong @nathanmarz Works perfectly, thanks  🙂"><span class="u" id="1473271545.000196">2016:09:07 18:05:45           levitanong </span><span>@nathanmarz Works perfectly, thanks </span><b>🙂</b></div><div data-t="darwin just upgraded to 0.13.0, started getting  TypeError: this.$late1$.$select_STAR_$ is not a function , looks like I didn’t include something?"><span class="u" id="1473285564.000203">2016:09:07 21:59:24               darwin </span><span>just upgraded to 0.13.0, started getting </span><code>TypeError: this.$late1$.$select_STAR_$ is not a function</code><span>, looks like I didn’t include something?</span></div><div data-t="darwin relevant call-site:
 https://github.com/binaryage/dirac/blob/a95e9c3f42ca9cd202240509ecbc7196c3a19753/src/implant/dirac/implant/automation/reps.cljs#L63"><span class="u" id="1473285701.000207">2016:09:07 22:01:41               darwin </span><span>relevant call-site:
</span><a href="https://github.com/binaryage/dirac/blob/a95e9c3f42ca9cd202240509ecbc7196c3a19753/src/implant/dirac/implant/automation/reps.cljs#L63">https://github.com/binaryage/dirac/blob/a95e9c3f42ca9cd202240509ecbc7196c3a19753/src/implant/dirac/implant/automation/reps.cljs#L63</a></div><div data-t="darwin investigating it more, this looks like advanced-mode optimization problem"><span class="u" id="1473285973.000211">2016:09:07 22:06:13               darwin </span><span>investigating it more, this looks like advanced-mode optimization problem</span></div><div data-t="darwin I’m compiling my cljs code under :advanced with :pseudo-names true (running my tests against advanced mode build)"><span class="u" id="1473285988.000212">2016:09:07 22:06:28               darwin </span><span>I’m compiling my cljs code under :advanced with :pseudo-names true (running my tests against advanced mode build)</span></div><div data-t="nathanmarz @darwin so you don&apos;t get the error under a different optimization mode?"><span class="u" id="1473286451.000215">2016:09:07 22:14:11           nathanmarz </span><span>@darwin so you don&apos;t get the error under a different optimization mode?</span></div><div data-t="darwin trying to test that, but my project is pretty complex and I bumped into another issue with :none mode"><span class="u" id="1473286511.000216">2016:09:07 22:15:11               darwin </span><span>trying to test that, but my project is pretty complex and I bumped into another issue with :none mode</span></div><div data-t="darwin will get back to you ASAP"><span class="u" id="1473286517.000217">2016:09:07 22:15:17               darwin </span><span>will get back to you ASAP</span></div><div data-t="nathanmarz ok"><span class="u" id="1473286520.000218">2016:09:07 22:15:20           nathanmarz </span><span>ok</span></div><div data-t="nathanmarz also, you should try 0.13.1-SNAPSHOT"><span class="u" id="1473286526.000219">2016:09:07 22:15:26           nathanmarz </span><span>also, you should try 0.13.1-SNAPSHOT</span></div><div data-t="darwin ok, going to do that first"><span class="u" id="1473286541.000220">2016:09:07 22:15:41               darwin </span><span>ok, going to do that first</span></div><div data-t="nathanmarz what version of cljs are you using?"><span class="u" id="1473286549.000221">2016:09:07 22:15:49           nathanmarz </span><span>what version of cljs are you using?</span></div><div data-t="darwin 229"><span class="u" id="1473286596.000222">2016:09:07 22:16:36               darwin </span><span>229</span></div><div data-t="darwin so 0.13.1-SNAPSHOT behaves the same way for me under :advanced, now I’m going to make that :none mode work"><span class="u" id="1473287123.000223">2016:09:07 22:25:23               darwin </span><span>so 0.13.1-SNAPSHOT behaves the same way for me under :advanced, now I’m going to make that :none mode work</span></div><div data-t="darwin just need to mess with goog/base.js require which is missing for some reason"><span class="u" id="1473287142.000224">2016:09:07 22:25:42               darwin </span><span>just need to mess with goog/base.js require which is missing for some reason</span></div><div data-t="darwin this is fun, I’m depending on parinfer package from cljsjs and it has missing semicolon in a wrong place, advanced mode optimizer seems to “fix” it and in  [:attrs nil]  :simple / :whitespace mode browser throws, this will be hard to fix quickly..."><span class="u" id="1473288567.000225">2016:09:07 22:49:27               darwin </span><span>this is fun, I’m depending on parinfer package from cljsjs and it has missing semicolon in a wrong place, advanced mode optimizer seems to “fix” it and in </span><del>:none</del><span> :simple / :whitespace mode browser throws, this will be hard to fix quickly...</span></div><div data-t="darwin maybe I will just try to isolate my specter usage into a standalone project and demonstrate the issue there (if exists)"><span class="u" id="1473288592.000226">2016:09:07 22:49:52               darwin </span><span>maybe I will just try to isolate my specter usage into a standalone project and demonstrate the issue there (if exists)</span></div><div data-t="gphilipp Hi, I’m trying to solve using Specter the clojure brave and true example of chapter 3 (the one with the hobbit symmetrical body, search &apos;Pulling It All Together&apos; on  http://www.braveclojure.com/do-things/ ), but I can’t find a way to do it. Can anybody enlighten me ?"><span class="u" id="1473370867.000276">2016:09:08 21:41:07             gphilipp </span><span>Hi, I’m trying to solve using Specter the clojure brave and true example of chapter 3 (the one with the hobbit symmetrical body, search &apos;Pulling It All Together&apos; on </span><a href="http://www.braveclojure.com/do-things/">http://www.braveclojure.com/do-things/</a><span>), but I can’t find a way to do it. Can anybody enlighten me ?</span></div><div data-t="gphilipp My best shot is to transform existing parts, but I didn’t add them to the whole collection :  (transform [ALL needs-matching-part?]
           make-matching-part
           asym-hobbit-body-parts)"><span class="u" id="1473370936.000277">2016:09:08 21:42:16             gphilipp </span><span>My best shot is to transform existing parts, but I didn’t add them to the whole collection : </span><pre>(transform [ALL needs-matching-part?]
           make-matching-part
           asym-hobbit-body-parts)</pre></div><div data-t="loganmhb @gphilipp one way to do that is with multi-transform, I think:
 (multi-transform [ALL needs-matching-part? (multi-path (terminal identity)
                                                       (terminal make-matching-part))]
                 asym-hobbit-body-parts)
"><span class="u" id="1473372421.000281">2016:09:08 22:07:01             loganmhb </span><span>@gphilipp one way to do that is with multi-transform, I think:
</span><pre>(multi-transform [ALL needs-matching-part? (multi-path (terminal identity)
                                                       (terminal make-matching-part))]
                 asym-hobbit-body-parts)
</pre></div><div data-t="loganmhb dunno if there’s a way to avoid the explicit  identity"><span class="u" id="1473372514.000282">2016:09:08 22:08:34             loganmhb </span><span>dunno if there’s a way to avoid the explicit </span><code>identity</code></div><div data-t="aengelberg I don&apos;t think that would work, it would overwrite the value with the second transformation in  multi-path"><span class="u" id="1473372564.000283">2016:09:08 22:09:24           aengelberg </span><span>I don&apos;t think that would work, it would overwrite the value with the second transformation in </span><code>multi-path</code></div><div data-t="loganmhb ah, I think you’re right"><span class="u" id="1473372645.000284">2016:09:08 22:10:45             loganmhb </span><span>ah, I think you’re right</span></div><div data-t="loganmhb was testing with  range  and misinterpreted the output  🙂"><span class="u" id="1473372664.000285">2016:09:08 22:11:04             loganmhb </span><span>was testing with </span><code>range</code><span> and misinterpreted the output </span><b>🙂</b></div><div data-t="aengelberg there might be a way with  com.rpl.specter.zipper"><span class="u" id="1473372712.000286">2016:09:08 22:11:52           aengelberg </span><span>there might be a way with </span><code>com.rpl.specter.zipper</code></div><div data-t="loganmhb here’s something:
 (select [ALL keyword? (continue-then-stay (transformed STAY str))] [:a :b :c])
[&quot;:a&quot; :a &quot;:b&quot; :b &quot;:c&quot; :c]
"><span class="u" id="1473372771.000287">2016:09:08 22:12:51             loganmhb </span><span>here’s something:
</span><pre>(select [ALL keyword? (continue-then-stay (transformed STAY str))] [:a :b :c])
[&quot;:a&quot; :a &quot;:b&quot; :b &quot;:c&quot; :c]
</pre></div><div data-t="gphilipp That looks ok. Not very readable though :-/"><span class="u" id="1473372885.000288">2016:09:08 22:14:45             gphilipp </span><span>That looks ok. Not very readable though :-/</span></div><div data-t="gphilipp Thanks anyway !"><span class="u" id="1473372929.000289">2016:09:08 22:15:29             gphilipp </span><span>Thanks anyway !</span></div><div data-t="aengelberg (transform [VECTOR-ZIP LEFTMOST (stay-then-continue RIGHT) NODE-SEQ (view set) (collect-one FIRST) (subset #{})] (fn [body-part _] #{(make-matching-part body-part)}) asym-hobbit-body-parts)
"><span class="u" id="1473373167.000290">2016:09:08 22:19:27           aengelberg </span><pre>(transform [VECTOR-ZIP LEFTMOST (stay-then-continue RIGHT) NODE-SEQ (view set) (collect-one FIRST) (subset #{})] (fn [body-part _] #{(make-matching-part body-part)}) asym-hobbit-body-parts)
</pre></div><div data-t="aengelberg #nailedit"><span class="u" id="1473373212.000292">2016:09:08 22:20:12           aengelberg </span><span>#nailedit</span></div><div data-t="caio so, I have this small path that I’m using in several places:  [map? ALL (sp/if-path #(-&gt; % first ks) LAST)] 
it’s basically a  select-key  (didn’t use  (view #(select-key …))  cause it doesn’t work on transforms :(). is this the right way of doing it? if it is, how can I transform it into a nav? my goal is to call  (key-selector ks)  inside a path"><span class="u" id="1473373680.000293">2016:09:08 22:28:00                 caio </span><span>so, I have this small path that I’m using in several places: </span><code>[map? ALL (sp/if-path #(-&gt; % first ks) LAST)]</code><span>
it’s basically a </span><code>select-key</code><span> (didn’t use </span><code>(view #(select-key …))</code><span> cause it doesn’t work on transforms :(). is this the right way of doing it? if it is, how can I transform it into a nav? my goal is to call </span><code>(key-selector ks)</code><span> inside a path</span></div><div data-t="caio I looked into  defnav , but couldn’t understand how to do it"><span class="u" id="1473373739.000295">2016:09:08 22:28:59                 caio </span><span>I looked into </span><code>defnav</code><span>, but couldn’t understand how to do it</span></div><div data-t="codonnell There might be a way to do it with  multi-path . "><span class="u" id="1473374239.000298">2016:09:08 22:37:19            codonnell </span><span>There might be a way to do it with </span><code>multi-path</code><span>. </span></div><div data-t="codonnell Or submap"><span class="u" id="1473374314.000299">2016:09:08 22:38:34            codonnell </span><span>Or submap</span></div><div data-t="codonnell @caio yeah that&apos;s exactly  submap  ( https://github.com/nathanmarz/specter/wiki/List-of-Navigators#submap )"><span class="u" id="1473374655.000300">2016:09:08 22:44:15            codonnell </span><span>@caio yeah that&apos;s exactly </span><code>submap</code><span> (</span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#submap">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#submap</a><span>)</span></div><div data-t="caio well, that was easy. thanks again @codonnell"><span class="u" id="1473374710.000302">2016:09:08 22:45:10                 caio </span><span>well, that was easy. thanks again @codonnell</span></div><div data-t="codonnell @caio if you were confused about how to implement it using  defnav  you could check out the source code for  submap  at  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L703"><span class="u" id="1473382643.000316">2016:09:09 00:57:23            codonnell </span><span>@caio if you were confused about how to implement it using </span><code>defnav</code><span> you could check out the source code for </span><code>submap</code><span> at </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L703">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L703</a></div><div data-t="zane Is it possible to attach docstrings via  defnav ?"><span class="u" id="1473779120.000553">2016:09:13 15:05:20                 zane </span><span>Is it possible to attach docstrings via </span><code>defnav</code><span>?</span></div><div data-t="codonnell @zane IIRC the semantics are the same as  clojure.core/defn"><span class="u" id="1473779235.000554">2016:09:13 15:07:15            codonnell </span><span>@zane IIRC the semantics are the same as </span><code>clojure.core/defn</code></div><div data-t="zane @codonnell: Don&apos;t think so. This doesn&apos;t compile, for example:
 (defnav EXAMPLE
  &quot;Docs!&quot;
  []
  (select* [this structure next-fn])
  (transform* [this structure next-fn])
 
Whereas, this does:
 (defn example
  &quot;Docs!&quot;
  []
  :ok)
"><span class="u" id="1473779453.000555">2016:09:13 15:10:53                 zane </span><span>@codonnell: Don&apos;t think so. This doesn&apos;t compile, for example:
</span><pre>(defnav EXAMPLE
  &quot;Docs!&quot;
  []
  (select* [this structure next-fn])
  (transform* [this structure next-fn])
</pre><span>
Whereas, this does:
</span><pre>(defn example
  &quot;Docs!&quot;
  []
  :ok)
</pre></div><div data-t="codonnell @zane which specter version are you using?"><span class="u" id="1473779584.000556">2016:09:13 15:13:04            codonnell </span><span>@zane which specter version are you using?</span></div><div data-t="zane [com.rpl/specter &quot;0.12.0&quot;]"><span class="u" id="1473779616.000557">2016:09:13 15:13:36                 zane </span><code>[com.rpl/specter &quot;0.12.0&quot;]</code></div><div data-t="codonnell @zane just took a look at the source; nope, no docstrings"><span class="u" id="1473779806.000559">2016:09:13 15:16:46            codonnell </span><span>@zane just took a look at the source; nope, no docstrings</span></div><div data-t="zane Yeah. I looked at it too but wanted to confirm. Sad panda."><span class="u" id="1473779819.000560">2016:09:13 15:16:59                 zane </span><span>Yeah. I looked at it too but wanted to confirm. Sad panda.</span></div><div data-t="nathanmarz @zane you can use  ^{:doc ...}  syntax in front of the symbol, e.g.  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L593"><span class="u" id="1473784031.000562">2016:09:13 16:27:11           nathanmarz </span><span>@zane you can use </span><code>^{:doc ...}</code><span> syntax in front of the symbol, e.g. </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L593">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L593</a></div><div data-t="zane Thanks, Nathan!"><span class="u" id="1473784126.000564">2016:09:13 16:28:46                 zane </span><span>Thanks, Nathan!</span></div><div data-t="mac This might be obvious and/or silly, but wouldn&apos;t specter be very well suited to query/update those application state atoms that all the web-frameworks use these days?"><span class="u" id="1473801175.000575">2016:09:13 21:12:55                  mac </span><span>This might be obvious and/or silly, but wouldn&apos;t specter be very well suited to query/update those application state atoms that all the web-frameworks use these days?</span></div><div data-t="nathanmarz @mac I think Specter is extremely useful for web programming in general, as a DOM is just a big nested data structure"><span class="u" id="1473803326.000578">2016:09:13 21:48:46           nathanmarz </span><span>@mac I think Specter is extremely useful for web programming in general, as a DOM is just a big nested data structure</span></div><div data-t="cjmurphy @mac Something that goes against that idea somewhat is to have the atom have its own internal organisation and way of querying updating, which is what Om Next does with its Idents. (Having said that I imagine Om Next would still benefit from using Specter)."><span class="u" id="1473806409.000580">2016:09:13 22:40:09             cjmurphy </span><span>@mac Something that goes against that idea somewhat is to have the atom have its own internal organisation and way of querying updating, which is what Om Next does with its Idents. (Having said that I imagine Om Next would still benefit from using Specter).</span></div><div data-t="levitanong Is there any way to  transform  keys of hashmaps to booleans without filtering out  false s?"><span class="u" id="1473857591.000615">2016:09:14 12:53:11           levitanong </span><span>Is there any way to </span><code>transform</code><span> keys of hashmaps to booleans without filtering out </span><code>false</code><span>s?</span></div><div data-t="codonnell @levitanong Not sure exactly what behavior you want. Could you give an example?"><span class="u" id="1473859093.000616">2016:09:14 13:18:13            codonnell </span><span>@levitanong Not sure exactly what behavior you want. Could you give an example?</span></div><div data-t="levitanong @codonnell given the following dataset:
 (def data {1 {“false” 11 “true” 12} 2 {“false” 21 “true” 22}})
 

I want to turn the strings to proper booleans.
 (transform [ALL LAST ALL FIRST]
  boolean
  data)
 

However, instead of

 (def data {1 {false 11 true 12} 2 {false 21 true 22}})
 
I get
 (def data {1 {true 12} 2 {true 22}})
 
So I’m assuming  transform  automatically removes falsy values or keys."><span class="u" id="1473869059.000629">2016:09:14 16:04:19           levitanong </span><span>@codonnell given the following dataset:
</span><pre>(def data {1 {“false” 11 “true” 12} 2 {“false” 21 “true” 22}})
</pre><span>

I want to turn the strings to proper booleans.
</span><pre>(transform [ALL LAST ALL FIRST]
  boolean
  data)
</pre><span>

However, instead of

</span><pre>(def data {1 {false 11 true 12} 2 {false 21 true 22}})
</pre><span>
I get
</span><pre>(def data {1 {true 12} 2 {true 22}})
</pre><span>
So I’m assuming </span><code>transform</code><span> automatically removes falsy values or keys.</span></div><div data-t="nathanmarz @levitanong  (boolean &quot;false&quot;)  returns  true"><span class="u" id="1473869268.000630">2016:09:14 16:07:48           nathanmarz </span><span>@levitanong </span><code>(boolean &quot;false&quot;)</code><span> returns </span><code>true</code></div><div data-t="levitanong derp"><span class="u" id="1473869278.000631">2016:09:14 16:07:58           levitanong </span><span>derp</span></div><div data-t="nathanmarz I think you want to make a  parse-boolean-string  function"><span class="u" id="1473869280.000632">2016:09:14 16:08:00           nathanmarz </span><span>I think you want to make a </span><code>parse-boolean-string</code><span> function</span></div><div data-t="levitanong My bad! Thanks @nathanmarz"><span class="u" id="1473869312.000633">2016:09:14 16:08:32           levitanong </span><span>My bad! Thanks @nathanmarz</span></div><div data-t="karan hey guys, is there an idiomatic way to select a slice of a nested map given a predicate for some level? for example, using  even? ,  {:a {:b 1, :c 2}, :d {:e 3, :f 4}, :g {:h 5}}  -&gt;  {:a {:c 2} :d {:f 4}}"><span class="u" id="1474147604.000753">2016:09:17 21:26:44                karan </span><span>hey guys, is there an idiomatic way to select a slice of a nested map given a predicate for some level? for example, using </span><code>even?</code><span>, </span><code>{:a {:b 1, :c 2}, :d {:e 3, :f 4}, :g {:h 5}}</code><span> -&gt; </span><code>{:a {:c 2} :d {:f 4}}</code></div><div data-t="karan so far I have something like this, which is pretty close: 
 (transform [MAP-VALS]
    #(into {} 
               (select-one (filterer LAST even?) %))
      ex)
"><span class="u" id="1474147627.000754">2016:09:17 21:27:07                karan </span><span>so far I have something like this, which is pretty close: 
</span><pre>(transform [MAP-VALS]
    #(into {} 
               (select-one (filterer LAST even?) %))
      ex)
</pre></div><div data-t="karan with  (def ex {:a {:b 1, :c 2}, :d {:e 3, :f 4}, :g {:h 5}})"><span class="u" id="1474147720.000757">2016:09:17 21:28:40                karan </span><span>with </span><code>(def ex {:a {:b 1, :c 2}, :d {:e 3, :f 4}, :g {:h 5}})</code></div><div data-t="karan the  (into {} … )  doesn’t seem like the best solution. maybe if there were a type-aware  select ? seems to be an issue from a while back here:  https://github.com/nathanmarz/specter/issues/127"><span class="u" id="1474148078.000760">2016:09:17 21:34:38                karan </span><span>the </span><code>(into {} … )</code><span> doesn’t seem like the best solution. maybe if there were a type-aware </span><code>select</code><span>? seems to be an issue from a while back here: </span><a href="https://github.com/nathanmarz/specter/issues/127">https://github.com/nathanmarz/specter/issues/127</a></div><div data-t="nathanmarz @karan sounds like that would be a variant on  submap  that takes in a path to evaluate the vals, e.g.  (filtered-submap even?)  or  (filtered-submap (filterer even?) (view count) #(&gt;= % 2))"><span class="u" id="1474148430.000762">2016:09:17 21:40:30           nathanmarz </span><span>@karan sounds like that would be a variant on </span><code>submap</code><span> that takes in a path to evaluate the vals, e.g. </span><code>(filtered-submap even?)</code><span> or </span><code>(filtered-submap (filterer even?) (view count) #(&gt;= % 2))</code></div><div data-t="nathanmarz see  selected?  implementation for an example of a navigator which uses a path"><span class="u" id="1474148557.000763">2016:09:17 21:42:37           nathanmarz </span><span>see </span><code>selected?</code><span> implementation for an example of a navigator which uses a path</span></div><div data-t="karan @nathanmarz thanks, I’ll try that!"><span class="u" id="1474148739.000764">2016:09:17 21:45:39                karan </span><span>@nathanmarz thanks, I’ll try that!</span></div><div data-t="fasiha I&apos;m super-hesitant to ask this—I feel I ought to go thru the wikis listing the navigators and macros and other examples a couple more times (and as I just did). Can I navigate to &quot;the space between the first and second element of a vec&quot; and  setval  it, so that  [:a :b :c]  becomes  [:a :NEW-VAL :b :c] ?"><span class="u" id="1474173167.000778">2016:09:18 04:32:47               fasiha </span><span>I&apos;m super-hesitant to ask this—I feel I ought to go thru the wikis listing the navigators and macros and other examples a couple more times (and as I just did). Can I navigate to &quot;the space between the first and second element of a vec&quot; and </span><code>setval</code><span> it, so that </span><code>[:a :b :c]</code><span> becomes </span><code>[:a :NEW-VAL :b :c]</code><span>?</span></div><div data-t="karan try this: 
 (def my-nav (n/PosNavigator (fn [v] (nth v 1)) (fn [v afn]
                                                                 (let [val (nth v 1)]
                                                                   (assoc v 1 (afn val))))))
"><span class="u" id="1474173764.000779">2016:09:18 04:42:44                karan </span><span>try this: 
</span><pre>(def my-nav (n/PosNavigator (fn [v] (nth v 1)) (fn [v afn]
                                                                 (let [val (nth v 1)]
                                                                   (assoc v 1 (afn val))))))
</pre></div><div data-t="karan that will need to polymorphic on the second function (the transformer), but it’s the idea"><span class="u" id="1474173795.000780">2016:09:18 04:43:15                karan </span><span>that will need to polymorphic on the second function (the transformer), but it’s the idea</span></div><div data-t="karan @fasiha"><span class="u" id="1474173833.000781">2016:09:18 04:43:53                karan </span><span>@fasiha</span></div><div data-t="karan oh never mind, that’s not what you asked  🙂 . sorry!"><span class="u" id="1474174021.000782">2016:09:18 04:47:01                karan </span><span>oh never mind, that’s not what you asked </span><b>🙂</b><span>. sorry!</span></div><div data-t="karan (defnav POSONE []
                   (select* [this structure next-fn]
                            (next-fn []))
                   (transform* [this structure next-fn]
                               (let [new-val (next-fn [])]
                                 (vec (cons (first structure)
                                            (cons new-val (rest structure)))))))
  
@fasiha take two. similar caveats, but I think that’s the right direction."><span class="u" id="1474174442.000783">2016:09:18 04:54:02                karan </span><pre>(defnav POSONE []
                   (select* [this structure next-fn]
                            (next-fn []))
                   (transform* [this structure next-fn]
                               (let [new-val (next-fn [])]
                                 (vec (cons (first structure)
                                            (cons new-val (rest structure)))))))
</pre><span> 
@fasiha take two. similar caveats, but I think that’s the right direction.</span></div><div data-t="nathanmarz @fasiha  (setval (srange 1 1) [:NEW-VAL] [:a :b :c])"><span class="u" id="1474197686.000790">2016:09:18 11:21:26           nathanmarz </span><span>@fasiha </span><code>(setval (srange 1 1) [:NEW-VAL] [:a :b :c])</code></div><div data-t="aaelony what is the idiomatic way in Specter to do the following:  (mapv (fn [x] {:name x}) (-&gt;&gt; [[:a :b][:b :c][:c :d][:c :e]] flatten set vec ))
=&gt; [{:name :e} {:name :c} {:name :b} {:name :d} {:name :a}]"><span class="u" id="1474260286.000815">2016:09:19 04:44:46              aaelony </span><span>what is the idiomatic way in Specter to do the following: </span><pre>(mapv (fn [x] {:name x}) (-&gt;&gt; [[:a :b][:b :c][:c :d][:c :e]] flatten set vec ))
=&gt; [{:name :e} {:name :c} {:name :b} {:name :d} {:name :a}]</pre></div><div data-t="aaelony taking a vector and constructing a map with new keys and vals?"><span class="u" id="1474260351.000816">2016:09:19 04:45:51              aaelony </span><span>taking a vector and constructing a map with new keys and vals?</span></div><div data-t="dev-hartmann i am trying to add to a list inside a map of maps if the if the id matches. my code looks like that: (def same-id?
 (specter/comp-paths (specter/paramsfn [id-key id] [item] (= id (get item id-key)))))"><span class="u" id="1474280605.000830">2016:09:19 10:23:25         dev-hartmann </span><span>i am trying to add to a list inside a map of maps if the if the id matches. my code looks like that: (def same-id?
 (specter/comp-paths (specter/paramsfn [id-key id] [item] (= id (get item id-key)))))</span></div><div data-t="dev-hartmann (specter/select [specter/ALL same-id? (:entity-id entity) (:entity-val entity)] db)"><span class="u" id="1474280620.000831">2016:09:19 10:23:40         dev-hartmann </span><span>(specter/select [specter/ALL same-id? (:entity-id entity) (:entity-val entity)] db)</span></div><div data-t="dev-hartmann i know the actual transform is missing, but i have a feeling i missunderstood how to use specter"><span class="u" id="1474280670.000832">2016:09:19 10:24:30         dev-hartmann </span><span>i know the actual transform is missing, but i have a feeling i missunderstood how to use specter</span></div><div data-t="nathanmarz can you give an example of input/output?"><span class="u" id="1474280786.000833">2016:09:19 10:26:26           nathanmarz </span><span>can you give an example of input/output?</span></div><div data-t="nathanmarz @aaelony that&apos;s an aggregation producing a brand new data structure construction, so Specter won&apos;t be any better than transducers for that case"><span class="u" id="1474280868.000834">2016:09:19 10:27:48           nathanmarz </span><span>@aaelony that&apos;s an aggregation producing a brand new data structure construction, so Specter won&apos;t be any better than transducers for that case</span></div><div data-t="nathanmarz @aaelony but this is an efficient way to do it:
 (-&gt;&gt; [[:a :b][:b :c][:c :d][:c :e]]
     (traverse [ALL ALL])
     (into #{})
     (into [] (map (fn [k] {:name k}))))
"><span class="u" id="1474281033.000835">2016:09:19 10:30:33           nathanmarz </span><span>@aaelony but this is an efficient way to do it:
</span><pre>(-&gt;&gt; [[:a :b][:b :c][:c :d][:c :e]]
     (traverse [ALL ALL])
     (into #{})
     (into [] (map (fn [k] {:name k}))))
</pre></div><div data-t="dev-hartmann entity = {:entity-id :advisory-id :entity-val :&quot;2016-1425&quot;}
db = {:advisories {:list {:advisory-id &quot;2016-1623&quot; :cvss {:c 1 :d 2 :e 3} :tags ({:tag-key &quot;test-tag&quot; :tag-value nil} {:tag-key &quot;test-tag-2&quot; :tag-value 12})}}}"><span class="u" id="1474282300.000836">2016:09:19 10:51:40         dev-hartmann </span><span>entity = {:entity-id :advisory-id :entity-val :&quot;2016-1425&quot;}
db = {:advisories {:list {:advisory-id &quot;2016-1623&quot; :cvss {:c 1 :d 2 :e 3} :tags ({:tag-key &quot;test-tag&quot; :tag-value nil} {:tag-key &quot;test-tag-2&quot; :tag-value 12})}}}</span></div><div data-t="dev-hartmann at the moment i don&apos;t get any output because i cannot locate paramsfn"><span class="u" id="1474282331.000837">2016:09:19 10:52:11         dev-hartmann </span><span>at the moment i don&apos;t get any output because i cannot locate paramsfn</span></div><div data-t="dev-hartmann what i want to do is, append a tag to tags inside advisory inside the advisories list if the id matches"><span class="u" id="1474282421.000838">2016:09:19 10:53:41         dev-hartmann </span><span>what i want to do is, append a tag to tags inside advisory inside the advisories list if the id matches</span></div><div data-t="dev-hartmann entity id"><span class="u" id="1474282424.000839">2016:09:19 10:53:44         dev-hartmann </span><span>entity id</span></div><div data-t="nathanmarz @dev-hartmann looking for expected input/output"><span class="u" id="1474282898.000840">2016:09:19 11:01:38           nathanmarz </span><span>@dev-hartmann looking for expected input/output</span></div><div data-t="nathanmarz paramsfn  was removed in 0.13.0 because it&apos;s no longer necessary"><span class="u" id="1474282929.000841">2016:09:19 11:02:09           nathanmarz </span><code>paramsfn</code><span> was removed in 0.13.0 because it&apos;s no longer necessary</span></div><div data-t="dev-hartmann expected output is the updated db map"><span class="u" id="1474283018.000842">2016:09:19 11:03:38         dev-hartmann </span><span>expected output is the updated db map</span></div><div data-t="dev-hartmann input is entity map like above and a tag {:tag-key &quot;something&quot; :tag-value &quot;optional&quot;}"><span class="u" id="1474283071.000843">2016:09:19 11:04:31         dev-hartmann </span><span>input is entity map like above and a tag {:tag-key &quot;something&quot; :tag-value &quot;optional&quot;}</span></div><div data-t="nathanmarz I don&apos;t know what you mean, so I need a specific minimal example of input/output in order to help you"><span class="u" id="1474283277.000844">2016:09:19 11:07:57           nathanmarz </span><span>I don&apos;t know what you mean, so I need a specific minimal example of input/output in order to help you</span></div><div data-t="dev-hartmann (transform [(filterer #( = (:entity-val entity) (:entity-id %))) ALL] #(conj (:tags %) tag) db)]"><span class="u" id="1474283694.000845">2016:09:19 11:14:54         dev-hartmann </span><span>(transform [(filterer #( = (:entity-val entity) (:entity-id %))) ALL] #(conj (:tags %) tag) db)]</span></div><div data-t="dev-hartmann that&apos;s what i am trying at the moment, with the data from above"><span class="u" id="1474283710.000846">2016:09:19 11:15:10         dev-hartmann </span><span>that&apos;s what i am trying at the moment, with the data from above</span></div><div data-t="dev-hartmann as a result i get the unchanged map"><span class="u" id="1474284064.000847">2016:09:19 11:21:04         dev-hartmann </span><span>as a result i get the unchanged map</span></div><div data-t="nathanmarz @dev-hartmann a specific minimal example is something like  [1 2 3]  =&gt;  [2 3 4]"><span class="u" id="1474284238.000848">2016:09:19 11:23:58           nathanmarz </span><span>@dev-hartmann a specific minimal example is something like </span><code>[1 2 3]</code><span> =&gt; </span><code>[2 3 4]</code></div><div data-t="dev-hartmann ah ok, sry, did not understand -.-"><span class="u" id="1474284300.000849">2016:09:19 11:25:00         dev-hartmann </span><span>ah ok, sry, did not understand -.-</span></div><div data-t="dev-hartmann {:entity-id :item-id :entity-val 1}    {:tag-key &quot;test2&quot; :tag-value &quot;2&quot;}   {:items {:item-id 1 :sub-items ({:tag-key :tag &quot;value&quot;} {:tag-key &quot;tag2&quot; &quot;value2&quot;} {:tag-key &quot;tag3&quot; &quot;value1&quot;})}
        {:item-id 2 :sub-items ({:tag-key &quot;tag1&quot; &quot;value&quot;})}}   -&gt;  {:items {:item-id 1 :sub-items ({:tag-key :tag &quot;value&quot;} {:tag-key :tag2 &quot;value2&quot;} {:tag-key :tag3 &quot;value1&quot;})}
        {:item-id 2 :sub-items ({:tag-key &quot;tag-test&quot; &quot;value&quot;} {:tag-key &quot;test2&quot; :tag-value &quot;2&quot;})}} "><span class="u" id="1474284731.000850">2016:09:19 11:32:11         dev-hartmann </span><pre>{:entity-id :item-id :entity-val 1} </pre><span> </span><pre>{:tag-key &quot;test2&quot; :tag-value &quot;2&quot;}</pre><span> </span><pre>{:items {:item-id 1 :sub-items ({:tag-key :tag &quot;value&quot;} {:tag-key &quot;tag2&quot; &quot;value2&quot;} {:tag-key &quot;tag3&quot; &quot;value1&quot;})}
        {:item-id 2 :sub-items ({:tag-key &quot;tag1&quot; &quot;value&quot;})}} </pre><span> -&gt; </span><pre>{:items {:item-id 1 :sub-items ({:tag-key :tag &quot;value&quot;} {:tag-key :tag2 &quot;value2&quot;} {:tag-key :tag3 &quot;value1&quot;})}
        {:item-id 2 :sub-items ({:tag-key &quot;tag-test&quot; &quot;value&quot;} {:tag-key &quot;test2&quot; :tag-value &quot;2&quot;})}} </pre></div><div data-t="dev-hartmann like that?"><span class="u" id="1474284739.000851">2016:09:19 11:32:19         dev-hartmann </span><span>like that?</span></div><div data-t="nathanmarz yes"><span class="u" id="1474284838.000853">2016:09:19 11:33:58           nathanmarz </span><span>yes</span></div><div data-t="nathanmarz do you mean for value of :items to be in a list of some sort?"><span class="u" id="1474284850.000854">2016:09:19 11:34:10           nathanmarz </span><span>do you mean for value of :items to be in a list of some sort?</span></div><div data-t="dev-hartmann oh yes, sry"><span class="u" id="1474284878.000855">2016:09:19 11:34:38         dev-hartmann </span><span>oh yes, sry</span></div><div data-t="dev-hartmann it&apos;s a list"><span class="u" id="1474284884.000856">2016:09:19 11:34:44         dev-hartmann </span><span>it&apos;s a list</span></div><div data-t="nathanmarz and here you have the append going to subitems of item id 2, but your input says entity-val 1"><span class="u" id="1474284906.000857">2016:09:19 11:35:06           nathanmarz </span><span>and here you have the append going to subitems of item id 2, but your input says entity-val 1</span></div><div data-t="dev-hartmann my brain is full on monday, sry again, entity-val should be 2"><span class="u" id="1474284945.000858">2016:09:19 11:35:45         dev-hartmann </span><span>my brain is full on monday, sry again, entity-val should be 2</span></div><div data-t="nathanmarz one way to do it:  (setval [:items ALL #(= (get % (:entity-id entity)) (:entity-val entity)) :sub-items END] [tag] db)"><span class="u" id="1474285054.000859">2016:09:19 11:37:34           nathanmarz </span><span>one way to do it: </span><code>(setval [:items ALL #(= (get % (:entity-id entity)) (:entity-val entity)) :sub-items END] [tag] db)</code></div><div data-t="dev-hartmann thank you very much, seeing your answer explains how i got the way the path is created all wrong. thanks again"><span class="u" id="1474285179.000860">2016:09:19 11:39:39         dev-hartmann </span><span>thank you very much, seeing your answer explains how i got the way the path is created all wrong. thanks again</span></div><div data-t="nathanmarz I would also suggest using vectors instead of lists for sub-items, as appending to a vector is much more efficient"><span class="u" id="1474285231.000861">2016:09:19 11:40:31           nathanmarz </span><span>I would also suggest using vectors instead of lists for sub-items, as appending to a vector is much more efficient</span></div><div data-t="dev-hartmann that makes sense, thanks for the advice"><span class="u" id="1474285647.000862">2016:09:19 11:47:27         dev-hartmann </span><span>that makes sense, thanks for the advice</span></div><div data-t="aaelony thanks, @nathanmarz"><span class="u" id="1474301180.000869">2016:09:19 16:06:20              aaelony </span><span>thanks, @nathanmarz</span></div><div data-t="puzzler Which is more idiomatic to conj something into a set inside some other stuff :  (setval [path1 path2 (subset #{})] #{:a} data)   or  (transform [path1 path2] #(conj % :a) data) ?"><span class="u" id="1474405444.000922">2016:09:20 21:04:04              puzzler </span><span>Which is more idiomatic to conj something into a set inside some other stuff : </span><code>(setval [path1 path2 (subset #{})] #{:a} data)</code><span>  or </span><code>(transform [path1 path2] #(conj % :a) data)</code><span>?</span></div><div data-t="puzzler And is there a meaningful perf difference between the two?"><span class="u" id="1474405476.000923">2016:09:20 21:04:36              puzzler </span><span>And is there a meaningful perf difference between the two?</span></div><div data-t="nathanmarz @puzzler the latter will be faster but the former works better with nil"><span class="u" id="1474405823.000924">2016:09:20 21:10:23           nathanmarz </span><span>@puzzler the latter will be faster but the former works better with nil</span></div><div data-t="nathanmarz I&apos;ve considered making navigators that go to &quot;void&quot; elements of specific type, like VOID-SET-ELEM"><span class="u" id="1474405912.000925">2016:09:20 21:11:52           nathanmarz </span><span>I&apos;ve considered making navigators that go to &quot;void&quot; elements of specific type, like VOID-SET-ELEM</span></div><div data-t="nathanmarz if the transform results in  NONE , it wouldn&apos;t conj, otherwise it would conj"><span class="u" id="1474405931.000926">2016:09:20 21:12:11           nathanmarz </span><span>if the transform results in </span><code>NONE</code><span>, it wouldn&apos;t conj, otherwise it would conj</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/issues/131"><span class="u" id="1474405983.000927">2016:09:20 21:13:03           nathanmarz </span><a href="https://github.com/nathanmarz/specter/issues/131">https://github.com/nathanmarz/specter/issues/131</a></div><div data-t="puzzler @nathanmarz I can see the value, but as far as I can tell this wouldn&apos;t help with the precisely symmetric scenario of wanting to disj a single item from a set nested in a data structure ."><span class="u" id="1474422153.000935">2016:09:21 01:42:33              puzzler </span><span>@nathanmarz I can see the value, but as far as I can tell this wouldn&apos;t help with the precisely symmetric scenario of wanting to disj a single item from a set nested in a data structure .</span></div><div data-t="puzzler @nathanmarz In general, I&apos;ve been thinking about how assoc-in and setval automatically add levels to your data structure if needed, but I am not aware of a convenient way to make the path down to a leaf go away when the leaf becomes empty."><span class="u" id="1474422253.000936">2016:09:21 01:44:13              puzzler </span><span>@nathanmarz In general, I&apos;ve been thinking about how assoc-in and setval automatically add levels to your data structure if needed, but I am not aware of a convenient way to make the path down to a leaf go away when the leaf becomes empty.</span></div><div data-t="puzzler I&apos;m having trouble building up a good mental model of how the complex navigators work.  For example, I don&apos;t understand why these two navigators behave so differently with setval:"><span class="u" id="1474425584.000941">2016:09:21 02:39:44              puzzler </span><span>I&apos;m having trouble building up a good mental model of how the complex navigators work.  For example, I don&apos;t understand why these two navigators behave so differently with setval:</span></div><div data-t="puzzler Sorry, that wasn&apos;t quite the right example"><span class="u" id="1474425647.000943">2016:09:21 02:40:47              puzzler </span><span>Sorry, that wasn&apos;t quite the right example</span></div><div data-t="puzzler =&gt; (setval [(filterer number?)] [:a :b :c] [:x 2 :y 4 :z 6])
[:x :a :y :b :z :c]
=&gt; (setval [(walker number?)] [:a :b :c] [:x 2 :y 4 :z 6])
[:x [:a :b :c] :y [:a :b :c] :z [:a :b :c]]"><span class="u" id="1474425655.000945">2016:09:21 02:40:55              puzzler </span><pre>=&gt; (setval [(filterer number?)] [:a :b :c] [:x 2 :y 4 :z 6])
[:x :a :y :b :z :c]
=&gt; (setval [(walker number?)] [:a :b :c] [:x 2 :y 4 :z 6])
[:x [:a :b :c] :y [:a :b :c] :z [:a :b :c]]</pre></div><div data-t="puzzler There we go."><span class="u" id="1474425660.000946">2016:09:21 02:41:00              puzzler </span><span>There we go.</span></div><div data-t="nathanmarz @puzzler I think things like removing from a sequence or a map are fairly easy with variants on  ALL  or  keypath   https://github.com/nathanmarz/specter/issues/117"><span class="u" id="1474425686.000949">2016:09:21 02:41:26           nathanmarz </span><span>@puzzler I think things like removing from a sequence or a map are fairly easy with variants on </span><code>ALL</code><span> or </span><code>keypath</code><span> </span><a href="https://github.com/nathanmarz/specter/issues/117">https://github.com/nathanmarz/specter/issues/117</a></div><div data-t="nathanmarz the trickier case is removing an entire path, such as specifying to remove a nested map when it becomes empty"><span class="u" id="1474425718.000951">2016:09:21 02:41:58           nathanmarz </span><span>the trickier case is removing an entire path, such as specifying to remove a nested map when it becomes empty</span></div><div data-t="nathanmarz I&apos;ve done things like making navigators such as  non-empty-keypath , but I&apos;m not sure having so many variants is the right approach"><span class="u" id="1474425750.000952">2016:09:21 02:42:30           nathanmarz </span><span>I&apos;ve done things like making navigators such as </span><code>non-empty-keypath</code><span>, but I&apos;m not sure having so many variants is the right approach</span></div><div data-t="nathanmarz filterer  navigates to a single value, while  walker  navigates to many values"><span class="u" id="1474425783.000953">2016:09:21 02:43:03           nathanmarz </span><code>filterer</code><span> navigates to a single value, while </span><code>walker</code><span> navigates to many values</span></div><div data-t="nathanmarz think of  filterer  as working just like  filter , sequence -&gt; single sequence, except it also propagates changes back"><span class="u" id="1474425820.000954">2016:09:21 02:43:40           nathanmarz </span><span>think of </span><code>filterer</code><span> as working just like </span><code>filter</code><span>, sequence -&gt; single sequence, except it also propagates changes back</span></div><div data-t="nathanmarz whereas  walker  is like  ALL"><span class="u" id="1474425833.000955">2016:09:21 02:43:53           nathanmarz </span><span>whereas </span><code>walker</code><span> is like </span><code>ALL</code></div><div data-t="puzzler Is there a way to predict this single value vs. multi value behavior from the info on the doc page?"><span class="u" id="1474425891.000956">2016:09:21 02:44:51              puzzler </span><span>Is there a way to predict this single value vs. multi value behavior from the info on the doc page?</span></div><div data-t="nathanmarz (setval (subselect (walker number?)) [:a :b :c] [:x 2 :y 4 :z 6]) 
;; =&gt;  [:x :a :y :b :z :c]"><span class="u" id="1474425918.000957">2016:09:21 02:45:18           nathanmarz </span><code>(setval (subselect (walker number?)) [:a :b :c] [:x 2 :y 4 :z 6])</code><span>
;; =&gt; </span><code>[:x :a :y :b :z :c]</code></div><div data-t="puzzler Similarly, I was confused the first time I encountered that setval on END expected a sequence, not a single value."><span class="u" id="1474425931.000958">2016:09:21 02:45:31              puzzler </span><span>Similarly, I was confused the first time I encountered that setval on END expected a sequence, not a single value.</span></div><div data-t="nathanmarz filterer  uses  subselect  and  ALL"><span class="u" id="1474425935.000959">2016:09:21 02:45:35           nathanmarz </span><code>filterer</code><span> uses </span><code>subselect</code><span> and </span><code>ALL</code></div><div data-t="nathanmarz the doc for  filterer  could be clearer, but I think the doc for  END  is pretty clear"><span class="u" id="1474426013.000960">2016:09:21 02:46:53           nathanmarz </span><span>the doc for </span><code>filterer</code><span> could be clearer, but I think the doc for </span><code>END</code><span> is pretty clear</span></div><div data-t="nathanmarz &quot;Navigate to the empty subsequence after the last element of the collection.&quot;"><span class="u" id="1474426028.000961">2016:09:21 02:47:08           nathanmarz </span><span>&quot;Navigate to the empty subsequence after the last element of the collection.&quot;</span></div><div data-t="puzzler Yes, END was clear once I looked it up.  Just didn&apos;t match my intuition, I guess.  If these things are just something you have to learn over time, I guess that&apos;s the nature of complex libs, but I&apos;m trying to figure out if there&apos;s some big-picture way of thinking about it that makes it clear without looking these details up.  Sort of like how, in Clojure, once you realize that &quot;sequence functions&quot; put the sequence as the last input, and &quot;collection functions&quot; put the collection as the first input, it&apos;s a lot easier to remember."><span class="u" id="1474426113.000962">2016:09:21 02:48:33              puzzler </span><span>Yes, END was clear once I looked it up.  Just didn&apos;t match my intuition, I guess.  If these things are just something you have to learn over time, I guess that&apos;s the nature of complex libs, but I&apos;m trying to figure out if there&apos;s some big-picture way of thinking about it that makes it clear without looking these details up.  Sort of like how, in Clojure, once you realize that &quot;sequence functions&quot; put the sequence as the last input, and &quot;collection functions&quot; put the collection as the first input, it&apos;s a lot easier to remember.</span></div><div data-t="nathanmarz the only way to do that would be with a naming convention, but that could get unwieldy"><span class="u" id="1474426244.000963">2016:09:21 02:50:44           nathanmarz </span><span>the only way to do that would be with a naming convention, but that could get unwieldy</span></div><div data-t="nathanmarz like you might want to include in the name whether it navigates to many values or a single value, to a substructure, subvalue, or view, etc"><span class="u" id="1474426299.000964">2016:09:21 02:51:39           nathanmarz </span><span>like you might want to include in the name whether it navigates to many values or a single value, to a substructure, subvalue, or view, etc</span></div><div data-t="puzzler So that list you just typed is very interesting to me, because I realize I don&apos;t have a clear mental model of what kinds of things you can navigate to, when you talk about substructure, subvalue, view, etc. and what the different behavior of setval, transform, and select would be under those scenarios."><span class="u" id="1474426504.000965">2016:09:21 02:55:04              puzzler </span><span>So that list you just typed is very interesting to me, because I realize I don&apos;t have a clear mental model of what kinds of things you can navigate to, when you talk about substructure, subvalue, view, etc. and what the different behavior of setval, transform, and select would be under those scenarios.</span></div><div data-t="nathanmarz substructure is something like srange or subset, where it&apos;s the same structure as the parent but with a subset of the values"><span class="u" id="1474426553.000966">2016:09:21 02:55:53           nathanmarz </span><span>substructure is something like srange or subset, where it&apos;s the same structure as the parent but with a subset of the values</span></div><div data-t="nathanmarz transforms on substructures transform the parent"><span class="u" id="1474426560.000967">2016:09:21 02:56:00           nathanmarz </span><span>transforms on substructures transform the parent</span></div><div data-t="nathanmarz subvalues are the common case where you literally navigate to that value inside the structure"><span class="u" id="1474426583.000968">2016:09:21 02:56:23           nathanmarz </span><span>subvalues are the common case where you literally navigate to that value inside the structure</span></div><div data-t="nathanmarz and views navigate you to something with no structural relation to the input"><span class="u" id="1474426617.000969">2016:09:21 02:56:57           nathanmarz </span><span>and views navigate you to something with no structural relation to the input</span></div><div data-t="nathanmarz something like  view  totally replaces it&apos;s input"><span class="u" id="1474426650.000970">2016:09:21 02:57:30           nathanmarz </span><span>something like </span><code>view</code><span> totally replaces it&apos;s input</span></div><div data-t="nathanmarz on transform"><span class="u" id="1474426652.000971">2016:09:21 02:57:32           nathanmarz </span><span>on transform</span></div><div data-t="nathanmarz I don&apos;t think these are hard boundaries between navigators,  subselect  is like a combination of substructure and view"><span class="u" id="1474426719.000972">2016:09:21 02:58:39           nathanmarz </span><span>I don&apos;t think these are hard boundaries between navigators, </span><code>subselect</code><span> is like a combination of substructure and view</span></div><div data-t="puzzler Interesting.  That&apos;s helpful to know. Thanks."><span class="u" id="1474426776.000973">2016:09:21 02:59:36              puzzler </span><span>Interesting.  That&apos;s helpful to know. Thanks.</span></div><div data-t="nathanmarz learning to think in terms of substructure is probably one of the major milestones in using specter to its potential"><span class="u" id="1474426863.000974">2016:09:21 03:01:03           nathanmarz </span><span>learning to think in terms of substructure is probably one of the major milestones in using specter to its potential</span></div><div data-t="puzzler So the other topic I mentioned is something I encounter a fair amount in my programming.  Let&apos;s say I want to keep a map that bins words by first letter.  So I start out with  {} .  Now, I add the word apple  {\a #{&quot;apple&quot;}}  and then banana and ape  {\a #{&quot;apple&quot; &quot;ape&quot;} \b #{&quot;banana&quot;}} .  Now I remove apple.   {\a #{&quot;ape&quot;} \b #{&quot;banana&quot;}}  Now I remove ape and I want it to go to  {\b #{&quot;banana&quot;}} .  A similar scenario is a map of numeric counters.  If a counter doesn&apos;t yet exist in the map, I create it at 0 and increment it to 1 on demand.  When it decrements back to 0, I&apos;d like the counter to disappear from the map."><span class="u" id="1474427220.000975">2016:09:21 03:07:00              puzzler </span><span>So the other topic I mentioned is something I encounter a fair amount in my programming.  Let&apos;s say I want to keep a map that bins words by first letter.  So I start out with </span><code>{}</code><span>.  Now, I add the word apple </span><code>{\a #{&quot;apple&quot;}}</code><span> and then banana and ape </span><code>{\a #{&quot;apple&quot; &quot;ape&quot;} \b #{&quot;banana&quot;}}</code><span>.  Now I remove apple.  </span><code>{\a #{&quot;ape&quot;} \b #{&quot;banana&quot;}}</code><span> Now I remove ape and I want it to go to </span><code>{\b #{&quot;banana&quot;}}</code><span>.  A similar scenario is a map of numeric counters.  If a counter doesn&apos;t yet exist in the map, I create it at 0 and increment it to 1 on demand.  When it decrements back to 0, I&apos;d like the counter to disappear from the map.</span></div><div data-t="nathanmarz I&apos;ve thought about that a bit, and I think ideally this kind of information would be encoded and handled within the data structure implementation"><span class="u" id="1474427656.000976">2016:09:21 03:14:16           nathanmarz </span><span>I&apos;ve thought about that a bit, and I think ideally this kind of information would be encoded and handled within the data structure implementation</span></div><div data-t="nathanmarz you could do it with navigators like this:  (setval [(non-nil-keypath \a) (nil&lt;-&gt;val #{}) (subset #{&quot;apple&quot;})] #{} data) , but I think it would work better at the data structure impl level"><span class="u" id="1474427706.000977">2016:09:21 03:15:06           nathanmarz </span><span>you could do it with navigators like this: </span><code>(setval [(non-nil-keypath \a) (nil&lt;-&gt;val #{}) (subset #{&quot;apple&quot;})] #{} data)</code><span>, but I think it would work better at the data structure impl level</span></div><div data-t="nathanmarz so for example a map would understand what &quot;empty&quot; values look like, and would automatically remove them if they become empty"><span class="u" id="1474427731.000978">2016:09:21 03:15:31           nathanmarz </span><span>so for example a map would understand what &quot;empty&quot; values look like, and would automatically remove them if they become empty</span></div><div data-t="nathanmarz and it would know how to initialize a non-existent key to the empty value"><span class="u" id="1474427751.000979">2016:09:21 03:15:51           nathanmarz </span><span>and it would know how to initialize a non-existent key to the empty value</span></div><div data-t="nathanmarz then you could do with specter:  (setval [(keypath \a) (subset #{&quot;apple&quot;})] #{} data)  and everything would work in a nice and elegant manner"><span class="u" id="1474427811.000980">2016:09:21 03:16:51           nathanmarz </span><span>then you could do with specter: </span><code>(setval [(keypath \a) (subset #{&quot;apple&quot;})] #{} data)</code><span> and everything would work in a nice and elegant manner</span></div><div data-t="nathanmarz and it composes nicely to arbitrarily complex data structure combinations"><span class="u" id="1474427828.000981">2016:09:21 03:17:08           nathanmarz </span><span>and it composes nicely to arbitrarily complex data structure combinations</span></div><div data-t="nathanmarz constructing a data structure like that would be something like  (def my-map ((hash-map (hash-map (hash-set empty-nil))))"><span class="u" id="1474427987.000982">2016:09:21 03:19:47           nathanmarz </span><span>constructing a data structure like that would be something like </span><code>(def my-map ((hash-map (hash-map (hash-set empty-nil))))</code></div><div data-t="puzzler Are non-nil-keypath and nil&lt;-&gt;val new?  I don&apos;t see them in latest stable or in the github repo."><span class="u" id="1474435427.000988">2016:09:21 05:23:47              puzzler </span><span>Are non-nil-keypath and nil&lt;-&gt;val new?  I don&apos;t see them in latest stable or in the github repo.</span></div><div data-t="puzzler A bit of a testimonial:  Prior to now, I&apos;ve been aware of specter, but figured I&apos;d reach for it only if I really needed it -- get-in and update-in are usually sufficient for me.  Today, I decided to use specter for the &quot;trivial&quot; things I could do with get-in and update-in; once I had it at my disposal, within a few hours I started seeing several non-trivial uses for it as well which made my implementation a lot cleaner."><span class="u" id="1474435681.000989">2016:09:21 05:28:01              puzzler </span><span>A bit of a testimonial:  Prior to now, I&apos;ve been aware of specter, but figured I&apos;d reach for it only if I really needed it -- get-in and update-in are usually sufficient for me.  Today, I decided to use specter for the &quot;trivial&quot; things I could do with get-in and update-in; once I had it at my disposal, within a few hours I started seeing several non-trivial uses for it as well which made my implementation a lot cleaner.</span></div><div data-t="puzzler Was everything in specter motivated by actual use-cases?  There are several things I can&apos;t figure out what the utility would be, and I&apos;m wondering whether some of the things are there just because they were an experiment to see if something was doable, or whether each one actually solves some particular problem that comes up in practice."><span class="u" id="1474435988.000990">2016:09:21 05:33:08              puzzler </span><span>Was everything in specter motivated by actual use-cases?  There are several things I can&apos;t figure out what the utility would be, and I&apos;m wondering whether some of the things are there just because they were an experiment to see if something was doable, or whether each one actually solves some particular problem that comes up in practice.</span></div><div data-t="nathanmarz @puzzler no those are hypothetical navigators... non-nil-keypath would remove the value if it becomes nil and nil&lt;-&gt;val would navigate to  val  if it&apos;s nil and transform to  nil  if it&apos;s  val . They would be trivial to implement"><span class="u" id="1474456048.001001">2016:09:21 11:07:28           nathanmarz </span><span>@puzzler no those are hypothetical navigators... non-nil-keypath would remove the value if it becomes nil and nil&lt;-&gt;val would navigate to </span><code>val</code><span> if it&apos;s nil and transform to </span><code>nil</code><span> if it&apos;s </span><code>val</code><span>. They would be trivial to implement</span></div><div data-t="nathanmarz @puzzler yes, I use most of what comes with Specter, plus I have a whole lot of private navigators for dealing with DAGs"><span class="u" id="1474456091.001002">2016:09:21 11:08:11           nathanmarz </span><span>@puzzler yes, I use most of what comes with Specter, plus I have a whole lot of private navigators for dealing with DAGs</span></div><div data-t="nathanmarz I think the only ones I don&apos;t use are  ATOM  and the zipper navigators"><span class="u" id="1474456207.001003">2016:09:21 11:10:07           nathanmarz </span><span>I think the only ones I don&apos;t use are </span><code>ATOM</code><span> and the zipper navigators</span></div><div data-t="nathanmarz for which ones do you have trouble seeing the utility?"><span class="u" id="1474456265.001004">2016:09:21 11:11:05           nathanmarz </span><span>for which ones do you have trouble seeing the utility?</span></div><div data-t="jvuillermet Is this how I&apos;m supposed to require specter macros ?"><span class="u" id="1474490862.001022">2016:09:21 20:47:42          jvuillermet </span><span>Is this how I&apos;m supposed to require specter macros ?</span></div><div data-t="jvuillermet (:require-macros [com.rpl.specter.macros :refer [transform]]"><span class="u" id="1474490866.001023">2016:09:21 20:47:46          jvuillermet </span><span>(:require-macros [com.rpl.specter.macros :refer [transform]]</span></div><div data-t="jvuillermet from clojurescript"><span class="u" id="1474490870.001024">2016:09:21 20:47:50          jvuillermet </span><span>from clojurescript</span></div><div data-t="jvuillermet Ok just saw the changelog, no more macros namespace"><span class="u" id="1474491058.001025">2016:09:21 20:50:58          jvuillermet </span><span>Ok just saw the changelog, no more macros namespace</span></div><div data-t="puzzler Haven&apos;t imagined a use yet for anything relating to value collection (DISPENSE, collect, collect-one, terminal, terminal-val).  Also don&apos;t see the point of the &quot;view functions&quot;, i.e., transformed and view.  I&apos;m also not sure whether STAY and STOP have any direct utility, or if they are only useful in building other navigators.  If you&apos;re using all these things, then there must be a whole level to specter that I haven&apos;t grokked yet, because I couldn&apos;t extrapolate from the toy examples on the wiki page to a real-world use case."><span class="u" id="1474500896.001029">2016:09:21 23:34:56              puzzler </span><span>Haven&apos;t imagined a use yet for anything relating to value collection (DISPENSE, collect, collect-one, terminal, terminal-val).  Also don&apos;t see the point of the &quot;view functions&quot;, i.e., transformed and view.  I&apos;m also not sure whether STAY and STOP have any direct utility, or if they are only useful in building other navigators.  If you&apos;re using all these things, then there must be a whole level to specter that I haven&apos;t grokked yet, because I couldn&apos;t extrapolate from the toy examples on the wiki page to a real-world use case.</span></div><div data-t="nathanmarz @puzzler  STAY  is common with recursive navigators, the README has one for navigating a tree represented by nested vectors. Also  continue-then-stay  and  stay-then-continue  use it  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1061"><span class="u" id="1474502549.001033">2016:09:22 00:02:29           nathanmarz </span><span>@puzzler </span><code>STAY</code><span> is common with recursive navigators, the README has one for navigating a tree represented by nested vectors. Also </span><code>continue-then-stay</code><span> and </span><code>stay-then-continue</code><span> use it </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1061">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1061</a></div><div data-t="nathanmarz as for value collection, it&apos;s something I use constantly, especially for more sophisticated transformations"><span class="u" id="1474502712.001035">2016:09:22 00:05:12           nathanmarz </span><span>as for value collection, it&apos;s something I use constantly, especially for more sophisticated transformations</span></div><div data-t="nathanmarz this is pretty representative of the kinds of things I use it for:  https://github.com/nathanmarz/specter-clojure-west/blob/master/src/specter_demo/examples.clj#L489"><span class="u" id="1474502774.001036">2016:09:22 00:06:14           nathanmarz </span><span>this is pretty representative of the kinds of things I use it for: </span><a href="https://github.com/nathanmarz/specter-clojure-west/blob/master/src/specter_demo/examples.clj#L489">https://github.com/nathanmarz/specter-clojure-west/blob/master/src/specter_demo/examples.clj#L489</a></div><div data-t="nathanmarz those graph navigators aren&apos;t public, but that takes an ancestry graph and adds a field to each node for the &quot;royal name&quot; which is &quot;{name} of {parent1}, {parent2}...&quot;"><span class="u" id="1474502818.001038">2016:09:22 00:06:58           nathanmarz </span><span>those graph navigators aren&apos;t public, but that takes an ancestry graph and adds a field to each node for the &quot;royal name&quot; which is &quot;{name} of {parent1}, {parent2}...&quot;</span></div><div data-t="nathanmarz it navigates to each :royal-name field to create and along the way collects what it needs to compute that value – the parent names and the name for this node"><span class="u" id="1474502855.001039">2016:09:22 00:07:35           nathanmarz </span><span>it navigates to each :royal-name field to create and along the way collects what it needs to compute that value – the parent names and the name for this node</span></div><div data-t="nathanmarz the only places I use  STOP  are in conjunction with protocol paths, essentially saying there&apos;s nothing to navigate to for that type"><span class="u" id="1474503056.001040">2016:09:22 00:10:56           nathanmarz </span><span>the only places I use </span><code>STOP</code><span> are in conjunction with protocol paths, essentially saying there&apos;s nothing to navigate to for that type</span></div><div data-t="puzzler Is there a way to splice things into lists with specter?  For example, I want to find all the [:c :d] pairs and splice them like so:  [:a :b [:c :d] :e [:c :d]]  should yield  [:a :b :c :d :e :c :d] ."><span class="u" id="1474588073.001080">2016:09:22 23:47:53              puzzler </span><span>Is there a way to splice things into lists with specter?  For example, I want to find all the [:c :d] pairs and splice them like so: </span><code>[:a :b [:c :d] :e [:c :d]]</code><span> should yield </span><code>[:a :b :c :d :e :c :d]</code><span>.</span></div><div data-t="puzzler NM. I figured out a way to do it using continuous-subseqs."><span class="u" id="1474588558.001082">2016:09:22 23:55:58              puzzler </span><span>NM. I figured out a way to do it using continuous-subseqs.</span></div><div data-t="caio @puzzler  (select (pred (complement seq?)) m) ? "><span class="u" id="1474688625.001123">2016:09:24 03:43:45                 caio </span><span>@puzzler </span><code>(select (pred (complement seq?)) m)</code><span>? </span></div><div data-t="puzzler `=&gt; (select (pred (complement seq?)) [:a :b [:c :d] :e [:c :d]])
[[:a :b [:c :d] :e [:c :d]]]`"><span class="u" id="1474690056.001126">2016:09:24 04:07:36              puzzler </span><span>`=&gt; (select (pred (complement seq?)) [:a :b [:c :d] :e [:c :d]])
[[:a :b [:c :d] :e [:c :d]]]`</span></div><div data-t="puzzler I did something like this:"><span class="u" id="1474690225.001127">2016:09:24 04:10:25              puzzler </span><span>I did something like this:</span></div><div data-t="puzzler =&gt; (transform [(continuous-subseqs vector?)] #(first %) [:a :b [:c :d] :e [:c :d]])
[:a :b :c :d :e :c :d]"><span class="u" id="1474690230.001128">2016:09:24 04:10:30              puzzler </span><pre>=&gt; (transform [(continuous-subseqs vector?)] #(first %) [:a :b [:c :d] :e [:c :d]])
[:a :b :c :d :e :c :d]</pre></div><div data-t="puzzler It feels a little hacky to me, but I don&apos;t see another way to do it."><span class="u" id="1474690256.001129">2016:09:24 04:10:56              puzzler </span><span>It feels a little hacky to me, but I don&apos;t see another way to do it.</span></div><div data-t="puzzler Actually, that won&apos;t work if they are adjacent."><span class="u" id="1474694864.001130">2016:09:24 05:27:44              puzzler </span><span>Actually, that won&apos;t work if they are adjacent.</span></div><div data-t="puzzler Hmmmm."><span class="u" id="1474694872.001131">2016:09:24 05:27:52              puzzler </span><span>Hmmmm.</span></div><div data-t="puzzler Any other ideas?"><span class="u" id="1474694982.001132">2016:09:24 05:29:42              puzzler </span><span>Any other ideas?</span></div><div data-t="puzzler =&gt; (transform [(continuous-subseqs vector?)] #(first %) [:a :b [:c :d] [:c :d]])
[:a :b :c :d]"><span class="u" id="1474695007.001133">2016:09:24 05:30:07              puzzler </span><pre>=&gt; (transform [(continuous-subseqs vector?)] #(first %) [:a :b [:c :d] [:c :d]])
[:a :b :c :d]</pre></div><div data-t="puzzler @caio I don&apos;t see how yours would work, but mine doesn&apos;t work either."><span class="u" id="1474695036.001134">2016:09:24 05:30:36              puzzler </span><span>@caio I don&apos;t see how yours would work, but mine doesn&apos;t work either.</span></div><div data-t="puzzler This works:"><span class="u" id="1474695128.001135">2016:09:24 05:32:08              puzzler </span><span>This works:</span></div><div data-t="puzzler =&gt; (transform [(continuous-subseqs vector?)] #(apply concat %) [:a :b [:c :d] [:c :d]])
[:a :b :c :d :c :d]"><span class="u" id="1474695138.001137">2016:09:24 05:32:18              puzzler </span><pre>=&gt; (transform [(continuous-subseqs vector?)] #(apply concat %) [:a :b [:c :d] [:c :d]])
[:a :b :c :d :c :d]</pre></div><div data-t="puzzler It&apos;s still hacky"><span class="u" id="1474695867.001139">2016:09:24 05:44:27              puzzler </span><span>It&apos;s still hacky</span></div><div data-t="nathanmarz @puzzler you could make a new navigator which navigates to each element as a 1 element subsequence"><span class="u" id="1474718844.001150">2016:09:24 12:07:24           nathanmarz </span><span>@puzzler you could make a new navigator which navigates to each element as a 1 element subsequence</span></div><div data-t="nathanmarz or a new version of  ALL  which does splicing if the transformed element has metadata indicating to do so"><span class="u" id="1474718907.001151">2016:09:24 12:08:27           nathanmarz </span><span>or a new version of </span><code>ALL</code><span> which does splicing if the transformed element has metadata indicating to do so</span></div><div data-t="nathanmarz e.g.  (transform [MY-ALL vector?] (fn [v] (with-meta v {:all-splice true})) data)"><span class="u" id="1474719010.001152">2016:09:24 12:10:10           nathanmarz </span><span>e.g. </span><code>(transform [MY-ALL vector?] (fn [v] (with-meta v {:all-splice true})) data)</code></div><div data-t="nathanmarz can also do this:
 (def SPLICED (comp-paths (continuous-subseqs vector?) (view #(apply concat %))))
(transform SPLICED identity [:a :b [:c :d] :e [:c :d]])
[:a :b :c :d :e :c :d]
"><span class="u" id="1474719460.001153">2016:09:24 12:17:40           nathanmarz </span><span>can also do this:
</span><pre>(def SPLICED (comp-paths (continuous-subseqs vector?) (view #(apply concat %))))
(transform SPLICED identity [:a :b [:c :d] :e [:c :d]])
[:a :b :c :d :e :c :d]
</pre></div><div data-t="puzzler Nifty!"><span class="u" id="1474788929.001184">2016:09:25 07:35:29              puzzler </span><span>Nifty!</span></div><div data-t="puzzler BTW, I&apos;m really enjoying the convenience of pulling in a single namespace.  Thanks for addressing that in the latest version."><span class="u" id="1474788965.001185">2016:09:25 07:36:05              puzzler </span><span>BTW, I&apos;m really enjoying the convenience of pulling in a single namespace.  Thanks for addressing that in the latest version.</span></div><div data-t="rnandan273 Trying to use specter with the following configuration [org.clojure/clojurescript &quot;1.9.225&quot; :scope &quot;provided&quot;]
                 [org.clojure/clojure &quot;1.8.0&quot;]"><span class="u" id="1474961361.001258">2016:09:27 07:29:21           rnandan273 </span><span>Trying to use specter with the following configuration [org.clojure/clojurescript &quot;1.9.225&quot; :scope &quot;provided&quot;]
                 [org.clojure/clojure &quot;1.8.0&quot;]</span></div><div data-t="rnandan273 [com.rpl/specter &quot;0.13.0&quot;], but am getting errors such as any? already refers to: cljs.core/any? being replaced by: com.rpl.specter.impl/any?"><span class="u" id="1474961391.001259">2016:09:27 07:29:51           rnandan273 </span><span>[com.rpl/specter &quot;0.13.0&quot;], but am getting errors such as any? already refers to: cljs.core/any? being replaced by: com.rpl.specter.impl/any?</span></div><div data-t="rnandan273 Any ideas on the resolution of this?"><span class="u" id="1474961401.001260">2016:09:27 07:30:01           rnandan273 </span><span>Any ideas on the resolution of this?</span></div><div data-t="rnandan273 Used this option also [com.rpl/specter &quot;0.13.0&quot; :exclusions [org.clojure/clojure org.clojure/clojurescript]] but no luck"><span class="u" id="1474961746.001261">2016:09:27 07:35:46           rnandan273 </span><span>Used this option also [com.rpl/specter &quot;0.13.0&quot; :exclusions [org.clojure/clojure org.clojure/clojurescript]] but no luck</span></div><div data-t="rnandan273 this configuration worked"><span class="u" id="1474962191.001262">2016:09:27 07:43:11           rnandan273 </span><span>this configuration worked</span></div><div data-t="rnandan273 [com.rpl/specter &quot;0.11.2&quot; :exclusions [org.clojure/clojure org.clojure/clojurescript]]"><span class="u" id="1474962192.001263">2016:09:27 07:43:12           rnandan273 </span><span>[com.rpl/specter &quot;0.11.2&quot; :exclusions [org.clojure/clojure org.clojure/clojurescript]]</span></div><div data-t="nathanmarz @rnandan273 try 0.13.1-SNAPSHOT"><span class="u" id="1474978593.001271">2016:09:27 12:16:33           nathanmarz </span><span>@rnandan273 try 0.13.1-SNAPSHOT</span></div><div data-t="rnandan273 @nathanmarz  Could not compile with this version , the error is &quot;  Invalid :refer, macro com.rpl.specter.macros/select does not exist&quot;"><span class="u" id="1474978995.001272">2016:09:27 12:23:15           rnandan273 </span><span>@nathanmarz  Could not compile with this version , the error is &quot;  Invalid :refer, macro com.rpl.specter.macros/select does not exist&quot;</span></div><div data-t="nathanmarz @rnandan273 0.13.0 moved all macros to com.rpl.specter namespace"><span class="u" id="1474980390.001273">2016:09:27 12:46:30           nathanmarz </span><span>@rnandan273 0.13.0 moved all macros to com.rpl.specter namespace</span></div><div data-t="rnandan273 @nathanmarz  Removing the namespace worked, i should have checked about the changes before asking the question. thanks a lot for your timely response"><span class="u" id="1474982959.001280">2016:09:27 13:29:19           rnandan273 </span><span>@nathanmarz  Removing the namespace worked, i should have checked about the changes before asking the question. thanks a lot for your timely response</span></div><div data-t="vikeri What am I doing wrong here, I expect:
 (select [MAP-VALS (filterer [:id #(= 1 %)])] {:h {:id 1 :ad 2} :ho {:id 2 :ad 3}})
 
To return  [{:id 1 :ad 2}]  but instead it returns  [[] []]"><span class="u" id="1475073734.001323">2016:09:28 14:42:14               vikeri </span><span>What am I doing wrong here, I expect:
</span><pre>(select [MAP-VALS (filterer [:id #(= 1 %)])] {:h {:id 1 :ad 2} :ho {:id 2 :ad 3}})
</pre><span>
To return </span><code>[{:id 1 :ad 2}]</code><span> but instead it returns </span><code>[[] []]</code></div><div data-t="nathanmarz @vikeri  filterer  treats input as a sequence"><span class="u" id="1475073901.001324">2016:09:28 14:45:01           nathanmarz </span><span>@vikeri </span><code>filterer</code><span> treats input as a sequence</span></div><div data-t="nathanmarz if you change  filterer  to  selected?  it should work"><span class="u" id="1475073911.001325">2016:09:28 14:45:11           nathanmarz </span><span>if you change </span><code>filterer</code><span> to </span><code>selected?</code><span> it should work</span></div><div data-t="nathanmarz and you don&apos;t need to wrap the subpath in  []"><span class="u" id="1475073929.001326">2016:09:28 14:45:29           nathanmarz </span><span>and you don&apos;t need to wrap the subpath in </span><code>[]</code></div><div data-t="vikeri @nathanmarz Great! Thanks! Maybe worth collecting these simple examples somewhere?"><span class="u" id="1475074020.001327">2016:09:28 14:47:00               vikeri </span><span>@nathanmarz Great! Thanks! Maybe worth collecting these simple examples somewhere?</span></div><div data-t="nathanmarz there&apos;s examples on the wiki and the readme"><span class="u" id="1475074771.001328">2016:09:28 14:59:31           nathanmarz </span><span>there&apos;s examples on the wiki and the readme</span></div><div data-t="nathanmarz though I agree that the current docs are pretty sparse and disorganized"><span class="u" id="1475074787.001329">2016:09:28 14:59:47           nathanmarz </span><span>though I agree that the current docs are pretty sparse and disorganized</span></div><div data-t="nathanmarz ideally there would be something like 4clojure but for specter, unfortunately I don&apos;t have the time to put that together"><span class="u" id="1475074867.001330">2016:09:28 15:01:07           nathanmarz </span><span>ideally there would be something like 4clojure but for specter, unfortunately I don&apos;t have the time to put that together</span></div><div data-t="vikeri Yeah I skimmed through the ones on the readme and the wiki but couldn’t find my use case. Since it’s quite a powerful abstraction I think some people might need some more examples to grok it."><span class="u" id="1475076320.001331">2016:09:28 15:25:20               vikeri </span><span>Yeah I skimmed through the ones on the readme and the wiki but couldn’t find my use case. Since it’s quite a powerful abstraction I think some people might need some more examples to grok it.</span></div><div data-t="rodeorockstar I&apos;m pretty sure I&apos;ve asked this before but I can&apos;t seem to find the answer. Is  subselect  the right way to match conditions &quot;deeper&quot; into a tree yet transform higher up?"><span class="u" id="1475252348.001405">2016:09:30 16:19:08        rodeorockstar </span><span>I&apos;m pretty sure I&apos;ve asked this before but I can&apos;t seem to find the answer. Is </span><code>subselect</code><span> the right way to match conditions &quot;deeper&quot; into a tree yet transform higher up?</span></div><div data-t="rodeorockstar I realize there&apos;s no matching function in this subselect, but still I would have expected  found  to be farther up the tree. Instead it&apos;s the just the :id which is the last part of the subselect
 (s/transform [:data s/ALL #(= &quot;interactor&quot; (:object %)) (s/subselect [:identifier :id])]
                 (fn [found] (println &quot;FOUND&quot; found))
                 (:data db))
"><span class="u" id="1475252465.001406">2016:09:30 16:21:05        rodeorockstar </span><span>I realize there&apos;s no matching function in this subselect, but still I would have expected </span><code>found</code><span> to be farther up the tree. Instead it&apos;s the just the :id which is the last part of the subselect
</span><pre>(s/transform [:data s/ALL #(= &quot;interactor&quot; (:object %)) (s/subselect [:identifier :id])]
                 (fn [found] (println &quot;FOUND&quot; found))
                 (:data db))
</pre></div><div data-t="nathanmarz @rodeorockstar it sounds like you&apos;re looking for  selected?"><span class="u" id="1475256260.001407">2016:09:30 17:24:20           nathanmarz </span><span>@rodeorockstar it sounds like you&apos;re looking for </span><code>selected?</code></div><div data-t="nathanmarz but  [:identifier :id]  will always match something, maybe you wanted to use  [(must :identifier) (must :id)] ?"><span class="u" id="1475256319.001408">2016:09:30 17:25:19           nathanmarz </span><span>but </span><code>[:identifier :id]</code><span> will always match something, maybe you wanted to use </span><code>[(must :identifier) (must :id)]</code><span>?</span></div><div data-t="puzzler It seems like  pred  would also work in the last couple examples where you&apos;ve recommended  selected? .  What are some instances where they would behave differently?"><span class="u" id="1475280898.001421">2016:10:01 00:14:58              puzzler </span><span>It seems like </span><code>pred</code><span> would also work in the last couple examples where you&apos;ve recommended </span><code>selected?</code><span>.  What are some instances where they would behave differently?</span></div><div data-t="nathanmarz well, for  pred  to work like  (selected? (must :a) (must :b))  you would have to write  #(and (contains? % :a) (contains? (:a %) :b))"><span class="u" id="1475329031.001440">2016:10:01 13:37:11           nathanmarz </span><span>well, for </span><code>pred</code><span> to work like </span><code>(selected? (must :a) (must :b))</code><span> you would have to write </span><code>#(and (contains? % :a) (contains? (:a %) :b))</code></div><div data-t="nathanmarz @puzzler  selected?  is particularly good for things like  (selected? (filterer even?) (view count) #(&gt;= % 2)) , which stays navigated at current position if the sequence contains at least 2 even numbers"><span class="u" id="1475329122.001441">2016:10:01 13:38:42           nathanmarz </span><span>@puzzler </span><code>selected?</code><span> is particularly good for things like </span><code>(selected? (filterer even?) (view count) #(&gt;= % 2))</code><span>, which stays navigated at current position if the sequence contains at least 2 even numbers</span></div><div data-t="nathanmarz or something like  (selected? ALL even?)  which stays navigated if at least one even number"><span class="u" id="1475329161.001442">2016:10:01 13:39:21           nathanmarz </span><span>or something like </span><code>(selected? ALL even?)</code><span> which stays navigated if at least one even number</span></div><div data-t="puzzler It sounds like, basically, pred takes a Clojure predicate function and selected? takes a navigator path."><span class="u" id="1475329246.001443">2016:10:01 13:40:46              puzzler </span><span>It sounds like, basically, pred takes a Clojure predicate function and selected? takes a navigator path.</span></div><div data-t="nathanmarz @puzzler yes, that&apos;s correct"><span class="u" id="1475333998.001444">2016:10:01 14:59:58           nathanmarz </span><span>@puzzler yes, that&apos;s correct</span></div><div data-t="novakboskov If I have lazy seq made of vector I can do this  (transform ALL inc (lazy-seq [1 2])) , then how to do this  (transform MAP-VALS inc (lazy-seq {:a 1 :b 2})) ?"><span class="u" id="1475514146.001518">2016:10:03 17:02:26          novakboskov </span><span>If I have lazy seq made of vector I can do this </span><code>(transform ALL inc (lazy-seq [1 2]))</code><span>, then how to do this </span><code>(transform MAP-VALS inc (lazy-seq {:a 1 :b 2}))</code><span>?</span></div><div data-t="nathanmarz a seq isn&apos;t a map, so you can&apos;t use  MAP-VALS  with it"><span class="u" id="1475518515.001519">2016:10:03 18:15:15           nathanmarz </span><span>a seq isn&apos;t a map, so you can&apos;t use </span><code>MAP-VALS</code><span> with it</span></div><div data-t="nathanmarz you could use  [ALL LAST]  instead"><span class="u" id="1475518538.001520">2016:10:03 18:15:38           nathanmarz </span><span>you could use </span><code>[ALL LAST]</code><span> instead</span></div><div data-t="novakboskov @nathanmarz It makes sense. Thank you for your work!  🙂"><span class="u" id="1475524107.001521">2016:10:03 19:48:27          novakboskov </span><span>@nathanmarz It makes sense. Thank you for your work! </span><b>🙂</b></div><div data-t="nlessa In 0.13.0 version the macro namespace was deprecated, right? Must we require only com.rpl.specter and use select*, transform*? Bit confused with these last API changes..."><span class="u" id="1475697114.001588">2016:10:05 19:51:54               nlessa </span><span>In 0.13.0 version the macro namespace was deprecated, right? Must we require only com.rpl.specter and use select*, transform*? Bit confused with these last API changes...</span></div><div data-t="nathanmarz @nlessa use  select ,  transform , etc. as usual except get them from com.rpl.specter now"><span class="u" id="1475697266.001589">2016:10:05 19:54:26           nathanmarz </span><span>@nlessa use </span><code>select</code><span>, </span><code>transform</code><span>, etc. as usual except get them from com.rpl.specter now</span></div><div data-t="nlessa Is there any known problem with midje (&quot;1.9.0-alpha5)  and 0.13.0? After upgrade to 0.13.0 I am running with a No such var: sm/transform..."><span class="u" id="1475699233.001590">2016:10:05 20:27:13               nlessa </span><span>Is there any known problem with midje (&quot;1.9.0-alpha5)  and 0.13.0? After upgrade to 0.13.0 I am running with a No such var: sm/transform...</span></div><div data-t="nathanmarz @nlessa it&apos;s probably not updated to the namespace changes"><span class="u" id="1475702007.001591">2016:10:05 21:13:27           nathanmarz </span><span>@nlessa it&apos;s probably not updated to the namespace changes</span></div><div data-t="yonatanel Is it possible to transform a map according to a transformation that already happened in a nested map?
I have nested objects that need to be marked if they have a certain ID, and if they contain a marked object they should also be marked. For example:
 [{:a 1 :bs [{:b 2} {:b 3}]}
 {:a 4 :bs [{:b 5} {:b 6}]}]

;; 1, 2 and 6 need to be marked, and also those that contain them:
[{:a 1 :mark true :bs [{:b 2 :mark true} {:b 3}]}
 {:a 4 :mark true :bs [{:b 5} {:b 6 :mark true}]}]
"><span class="u" id="1475737607.001610">2016:10:06 07:06:47            yonatanel </span><span>Is it possible to transform a map according to a transformation that already happened in a nested map?
I have nested objects that need to be marked if they have a certain ID, and if they contain a marked object they should also be marked. For example:
</span><pre>[{:a 1 :bs [{:b 2} {:b 3}]}
 {:a 4 :bs [{:b 5} {:b 6}]}]

;; 1, 2 and 6 need to be marked, and also those that contain them:
[{:a 1 :mark true :bs [{:b 2 :mark true} {:b 3}]}
 {:a 4 :mark true :bs [{:b 5} {:b 6 :mark true}]}]
</pre></div><div data-t="nathanmarz @yonatanel I don&apos;t understand your example"><span class="u" id="1475757550.001619">2016:10:06 12:39:10           nathanmarz </span><span>@yonatanel I don&apos;t understand your example</span></div><div data-t="nathanmarz the ids are sometimes under  :a  and sometimes under  :b ?"><span class="u" id="1475757568.001620">2016:10:06 12:39:28           nathanmarz </span><span>the ids are sometimes under </span><code>:a</code><span> and sometimes under </span><code>:b</code><span>?</span></div><div data-t="nathanmarz is this recursive or just 2 levels? why is the map with :a 4 getting marked in the example?"><span class="u" id="1475757594.001621">2016:10:06 12:39:54           nathanmarz </span><span>is this recursive or just 2 levels? why is the map with :a 4 getting marked in the example?</span></div><div data-t="nathanmarz oh i see, you want to mark the parent if the child gets marked, still don&apos;t understand when to look at  :a  vs  :b"><span class="u" id="1475757828.001623">2016:10:06 12:43:48           nathanmarz </span><span>oh i see, you want to mark the parent if the child gets marked, still don&apos;t understand when to look at </span><code>:a</code><span> vs </span><code>:b</code></div><div data-t="yonatanel @nathanmarz The ids can have different keys. Only their value matters in this example."><span class="u" id="1475757841.001624">2016:10:06 12:44:01            yonatanel </span><span>@nathanmarz The ids can have different keys. Only their value matters in this example.</span></div><div data-t="yonatanel Frankly it&apos;s not recursive, just up to 2 levels deeps, but a few hours ago I thought I might need it recursive. It might be only 1 level though."><span class="u" id="1475757875.001625">2016:10:06 12:44:35            yonatanel </span><span>Frankly it&apos;s not recursive, just up to 2 levels deeps, but a few hours ago I thought I might need it recursive. It might be only 1 level though.</span></div><div data-t="nathanmarz I would just do it as two separate transformations"><span class="u" id="1475758100.001627">2016:10:06 12:48:20           nathanmarz </span><span>I would just do it as two separate transformations</span></div><div data-t="nathanmarz (def data
  [{:a 1 :bs [{:b 2} {:b 3}]}
   {:a 4 :bs [{:b 5} {:b 6}]}])
   
(-&gt;&gt; data
     (setval [ALL
              :bs
              ALL
              (selected? :b #{1 2 6})
              :mark]
       true)
     (setval [ALL
              (selected? :bs ALL (must :mark))
              :mark]
      true))
"><span class="u" id="1475758104.001628">2016:10:06 12:48:24           nathanmarz </span><pre>(def data
  [{:a 1 :bs [{:b 2} {:b 3}]}
   {:a 4 :bs [{:b 5} {:b 6}]}])
   
(-&gt;&gt; data
     (setval [ALL
              :bs
              ALL
              (selected? :b #{1 2 6})
              :mark]
       true)
     (setval [ALL
              (selected? :bs ALL (must :mark))
              :mark]
      true))
</pre></div><div data-t="yonatanel OK, nice!"><span class="u" id="1475758643.001630">2016:10:06 12:57:23            yonatanel </span><span>OK, nice!</span></div><div data-t="yonatanel It wouldn&apos;t work if I wanted to only mark id 4, but I&apos;ll figure it out."><span class="u" id="1475758869.001631">2016:10:06 13:01:09            yonatanel </span><span>It wouldn&apos;t work if I wanted to only mark id 4, but I&apos;ll figure it out.</span></div><div data-t="nathanmarz couldn&apos;t tell from your example whether the id matching was just on nested maps or on the parent maps as well"><span class="u" id="1475759152.001632">2016:10:06 13:05:52           nathanmarz </span><span>couldn&apos;t tell from your example whether the id matching was just on nested maps or on the parent maps as well</span></div><div data-t="nathanmarz not hard to modify to check both"><span class="u" id="1475759159.001633">2016:10:06 13:05:59           nathanmarz </span><span>not hard to modify to check both</span></div><div data-t="nlessa Hi! Using 0.12.0 version what would be the elegant way to get in a hierarchical map like
 {:a 1 :b: 1  :c {:a 2 :b 2 :c {:a 3 :b 3 :c …}…} 
- undetermined levels of c - the most profound value of :a ?"><span class="u" id="1475789811.001656">2016:10:06 21:36:51               nlessa </span><span>Hi! Using 0.12.0 version what would be the elegant way to get in a hierarchical map like
</span><pre>{:a 1 :b: 1  :c {:a 2 :b 2 :c {:a 3 :b 3 :c …}…}</pre><span>
- undetermined levels of c - the most profound value of :a ?</span></div><div data-t="nathanmarz @nlessa what do you mean by &quot;most profound&quot;?"><span class="u" id="1475800992.001657">2016:10:07 00:43:12           nathanmarz </span><span>@nlessa what do you mean by &quot;most profound&quot;?</span></div><div data-t="nlessa hi @nathanmarz. 
I mean: navigating continuously in the hierarchy by the :c key, get the last :c you navigated and the get the value of :a

3 examples:
 {:a 1 :b: 1 :c {:a 2 :d 2 :c {:a 3 :b 3 :c  {:a 4 :h 4}}}} =&gt;   4

   {:a 1 :b 1 :c: {:a 2 :d 2 :f {:a 3 :b 3 :c  {:a 4 :h 4} }}}} =&gt;  2

   {:a 1 :b: 1 :j {:a 2 :d 2 :c {:a 3 :b 3 :c  {:a 4 :h 4}}}} =&gt;  1 

Is it clear?"><span class="u" id="1475849553.001682">2016:10:07 14:12:33               nlessa </span><span>hi @nathanmarz. 
I mean: navigating continuously in the hierarchy by the :c key, get the last :c you navigated and the get the value of :a

3 examples:
</span><pre>{:a 1 :b: 1 :c {:a 2 :d 2 :c {:a 3 :b 3 :c  {:a 4 :h 4}}}} =&gt;   4

   {:a 1 :b 1 :c: {:a 2 :d 2 :f {:a 3 :b 3 :c  {:a 4 :h 4} }}}} =&gt;  2

   {:a 1 :b: 1 :j {:a 2 :d 2 :c {:a 3 :b 3 :c  {:a 4 :h 4}}}} =&gt;  1</pre><span>

Is it clear?</span></div><div data-t="nathanmarz @nlessa you can do something like this with 0.12.0
 (declarepath LastCMap)
(providepath LastCMap
  (if-path (must :c)
    [:c LastCMap]
    STAY
    ))

(select-any [LastCMap :a] data)
"><span class="u" id="1475850226.001683">2016:10:07 14:23:46           nathanmarz </span><span>@nlessa you can do something like this with 0.12.0
</span><pre>(declarepath LastCMap)
(providepath LastCMap
  (if-path (must :c)
    [:c LastCMap]
    STAY
    ))

(select-any [LastCMap :a] data)
</pre></div><div data-t="nathanmarz though I really recommend using 0.13.0, which is much better at things like this"><span class="u" id="1475850240.001684">2016:10:07 14:24:00           nathanmarz </span><span>though I really recommend using 0.13.0, which is much better at things like this</span></div><div data-t="nathanmarz in 0.13.0 you can do it like this:
 (def LastMap
  (recursive-path [k] p
    (if-path (must k)
      [(keypath k) p]
      STAY)))

(select-any [(LastMap :c) :a] data)
"><span class="u" id="1475850271.001685">2016:10:07 14:24:31           nathanmarz </span><span>in 0.13.0 you can do it like this:
</span><pre>(def LastMap
  (recursive-path [k] p
    (if-path (must k)
      [(keypath k) p]
      STAY)))

(select-any [(LastMap :c) :a] data)
</pre></div><div data-t="nlessa Thank you very much, @nathanmarz. Specter is really great, very elegant! When we see the solution it seems obvious.  🙂  I am yet struggling to dominate all the navigators logic  and solve some problems in the specter-way."><span class="u" id="1475854750.001686">2016:10:07 15:39:10               nlessa </span><span>Thank you very much, @nathanmarz. Specter is really great, very elegant! When we see the solution it seems obvious. </span><b>🙂</b><span> I am yet struggling to dominate all the navigators logic  and solve some problems in the specter-way.</span></div><div data-t="nathanmarz you&apos;ll get there, it just takes practice"><span class="u" id="1475854982.001687">2016:10:07 15:43:02           nathanmarz </span><span>you&apos;ll get there, it just takes practice</span></div><div data-t="nathanmarz and a certain amount of retraining on how you think about data structures"><span class="u" id="1475854996.001688">2016:10:07 15:43:16           nathanmarz </span><span>and a certain amount of retraining on how you think about data structures</span></div><div data-t="aaelony is a transformation from  [[:a :b] [:a :c] [:b :d] [:c :d]]  to  {:a [:b :c], :b [:d], :c [:d]}  something that Specter is designed for?  Not sure if that should be a  transform  or a  setval  or something else..."><span class="u" id="1475864978.001695">2016:10:07 18:29:38              aaelony </span><span>is a transformation from </span><code>[[:a :b] [:a :c] [:b :d] [:c :d]]</code><span> to </span><code>{:a [:b :c], :b [:d], :c [:d]}</code><span> something that Specter is designed for?  Not sure if that should be a </span><code>transform</code><span> or a </span><code>setval</code><span> or something else...</span></div><div data-t="nathanmarz @aaelony the target object doesn&apos;t really share any structure with the source, so I would just do that with regular clojure functions"><span class="u" id="1475865121.001696">2016:10:07 18:32:01           nathanmarz </span><span>@aaelony the target object doesn&apos;t really share any structure with the source, so I would just do that with regular clojure functions</span></div><div data-t="aaelony perfect, thanks @nathanmarz"><span class="u" id="1475865165.001697">2016:10:07 18:32:45              aaelony </span><span>perfect, thanks @nathanmarz</span></div><div data-t="richiardiandrea Hello folks! A newbie question, if I have a vec of vecs and want to conj to only the first vec, how should I go about? Sample:
 [[1 2] [4 6] [42]] -&gt; [[1 2 3] [4 6] [42]]"><span class="u" id="1475982721.001740">2016:10:09 03:12:01      richiardiandrea </span><span>Hello folks! A newbie question, if I have a vec of vecs and want to conj to only the first vec, how should I go about? Sample:
</span><code>[[1 2] [4 6] [42]] -&gt; [[1 2 3] [4 6] [42]]</code></div><div data-t="richiardiandrea I tried FIRST but it navigates to the first element in each vector I believe (but I am trying again)"><span class="u" id="1475982766.001742">2016:10:09 03:12:46      richiardiandrea </span><span>I tried FIRST but it navigates to the first element in each vector I believe (but I am trying again)</span></div><div data-t="richiardiandrea I could stop here and do the conj in the transform function only to the first, but there might be a better way  😄"><span class="u" id="1475982855.001743">2016:10:09 03:14:15      richiardiandrea </span><span>I could stop here and do the conj in the transform function only to the first, but there might be a better way </span><b>😄</b></div><div data-t="richiardiandrea oh, found...it is  specter/VAL  what I am looking for"><span class="u" id="1475982972.001745">2016:10:09 03:16:12      richiardiandrea </span><span>oh, found...it is </span><code>specter/VAL</code><span> what I am looking for</span></div><div data-t="richiardiandrea uhm..no probably my original idea to do it in the transform function is good for now, but I am open for suggestions"><span class="u" id="1475983127.001746">2016:10:09 03:18:47      richiardiandrea </span><span>uhm..no probably my original idea to do it in the transform function is good for now, but I am open for suggestions</span></div><div data-t="nathanmarz @richiardiandrea  (setval [FIRST END] [3] [[1 2] [4 6] [42]] )"><span class="u" id="1476010069.001757">2016:10:09 10:47:49           nathanmarz </span><span>@richiardiandrea </span><code>(setval [FIRST END] [3] [[1 2] [4 6] [42]] )</code></div><div data-t="richiardiandrea oh ok tnx !"><span class="u" id="1476031139.001770">2016:10:09 16:38:59      richiardiandrea </span><span>oh ok tnx !</span></div><div data-t="spieden some specter golf for you all: how to select triples from a nested map where values are nil? e.g. {:foo {:bar nil :bom 1}} -&gt; [:foo :bar]"><span class="u" id="1476221502.001871">2016:10:11 21:31:42              spieden </span><span>some specter golf for you all: how to select triples from a nested map where values are nil? e.g. {:foo {:bar nil :bom 1}} -&gt; [:foo :bar]</span></div><div data-t="spieden hmm maybe selected? + some subselects"><span class="u" id="1476221861.001872">2016:10:11 21:37:41              spieden </span><span>hmm maybe selected? + some subselects</span></div><div data-t="nathanmarz @spieden use value collection"><span class="u" id="1476223246.001873">2016:10:11 22:00:46           nathanmarz </span><span>@spieden use value collection</span></div><div data-t="spieden trying something with multi-path right now but not panning out"><span class="u" id="1476223267.001874">2016:10:11 22:01:07              spieden </span><span>trying something with multi-path right now but not panning out</span></div><div data-t="nathanmarz (select [ALL (collect-one FIRST) LAST ALL (selected? LAST nil?) FIRST] data)"><span class="u" id="1476223288.001875">2016:10:11 22:01:28           nathanmarz </span><code>(select [ALL (collect-one FIRST) LAST ALL (selected? LAST nil?) FIRST] data)</code></div><div data-t="spieden perfect, thanks!"><span class="u" id="1476223375.001876">2016:10:11 22:02:55              spieden </span><span>perfect, thanks!</span></div><div data-t="spieden (works and now i’ll try to understand it)"><span class="u" id="1476223382.001877">2016:10:11 22:03:02              spieden </span><span>(works and now i’ll try to understand it)</span></div><div data-t="nathanmarz can make it recursive too if you want to handle arbitrarily nested maps"><span class="u" id="1476223420.001878">2016:10:11 22:03:40           nathanmarz </span><span>can make it recursive too if you want to handle arbitrarily nested maps</span></div><div data-t="spieden i think i understand it — didn’t realize that selected? would propagate back like that"><span class="u" id="1476223544.001879">2016:10:11 22:05:44              spieden </span><span>i think i understand it — didn’t realize that selected? would propagate back like that</span></div><div data-t="spieden is this what distinguishes it from filterer?"><span class="u" id="1476223556.001880">2016:10:11 22:05:56              spieden </span><span>is this what distinguishes it from filterer?</span></div><div data-t="nathanmarz selected?  expresses a filter predicate in terms of a path"><span class="u" id="1476223569.001881">2016:10:11 22:06:09           nathanmarz </span><code>selected?</code><span> expresses a filter predicate in terms of a path</span></div><div data-t="spieden also was trying to use collect instead of collect-one"><span class="u" id="1476223573.001882">2016:10:11 22:06:13              spieden </span><span>also was trying to use collect instead of collect-one</span></div><div data-t="nathanmarz filterer  navigates to result of running  filter  using the path as a filter predicate"><span class="u" id="1476223623.001883">2016:10:11 22:07:03           nathanmarz </span><code>filterer</code><span> navigates to result of running </span><code>filter</code><span> using the path as a filter predicate</span></div><div data-t="nathanmarz (`filterer` uses  selected?  in its implementation)"><span class="u" id="1476223635.001884">2016:10:11 22:07:15           nathanmarz </span><span>(`filterer` uses </span><code>selected?</code><span> in its implementation)</span></div><div data-t="spieden ah ok"><span class="u" id="1476223679.001885">2016:10:11 22:07:59              spieden </span><span>ah ok</span></div><div data-t="nathanmarz (defdynamicnav filterer
  [&amp; path]
  (subselect ALL (selected? path)))
"><span class="u" id="1476223679.001886">2016:10:11 22:07:59           nathanmarz </span><pre>(defdynamicnav filterer
  [&amp; path]
  (subselect ALL (selected? path)))
</pre></div><div data-t="nathanmarz (transform (filterer odd?) reverse [1 2 3 4 5 6 7])  =&gt;  [7 2 5 4 3 6 1]"><span class="u" id="1476223764.001887">2016:10:11 22:09:24           nathanmarz </span><code>(transform (filterer odd?) reverse [1 2 3 4 5 6 7])</code><span> =&gt; </span><code>[7 2 5 4 3 6 1]</code></div><div data-t="spieden wow  💡"><span class="u" id="1476223870.001889">2016:10:11 22:11:10              spieden </span><span>wow </span><b>💡</b></div><div data-t="kenny Is there some sort of problem with specter + Datomic tempids? I get this very strange error: 
 (rs/declarepath MapWalker)
(rs/providepath MapWalker
                (rs/stay-then-continue
                  rs/MAP-VALS
                  (rs/walker map?)
                  MapWalker))

(rs/transform [MapWalker :db/id]
              (fn [id]
                (d/tempid :db.part/user))
              {:db/id 1
               :foo [{:db/id 2}]})
=&gt; java.lang.UnsupportedOperationException: Can&apos;t create empty: datomic.db.DbId
 
I suspect the error is a red herring.."><span class="u" id="1476320467.001921">2016:10:13 01:01:07                kenny </span><span>Is there some sort of problem with specter + Datomic tempids? I get this very strange error: 
</span><pre>(rs/declarepath MapWalker)
(rs/providepath MapWalker
                (rs/stay-then-continue
                  rs/MAP-VALS
                  (rs/walker map?)
                  MapWalker))

(rs/transform [MapWalker :db/id]
              (fn [id]
                (d/tempid :db.part/user))
              {:db/id 1
               :foo [{:db/id 2}]})
=&gt; java.lang.UnsupportedOperationException: Can&apos;t create empty: datomic.db.DbId
</pre><span>
I suspect the error is a red herring..</span></div><div data-t="kenny I can do this without an error: 
 (rs/transform [MapWalker :db/id]
              (fn [id]
                (d/tempid :db.part/user)
                id)
              {:db/id 1
               :foo [{:db/id 2}]})
=&gt; {:db/id 1, :foo [#:db{:id 2}]}
"><span class="u" id="1476320654.001922">2016:10:13 01:04:14                kenny </span><span>I can do this without an error: 
</span><pre>(rs/transform [MapWalker :db/id]
              (fn [id]
                (d/tempid :db.part/user)
                id)
              {:db/id 1
               :foo [{:db/id 2}]})
=&gt; {:db/id 1, :foo [#:db{:id 2}]}
</pre></div><div data-t="kenny It&apos;s just if the transform-fn returns a tempid that I get the error"><span class="u" id="1476320680.001923">2016:10:13 01:04:40                kenny </span><span>It&apos;s just if the transform-fn returns a tempid that I get the error</span></div><div data-t="kenny I am using specter v0.13.0"><span class="u" id="1476320763.001924">2016:10:13 01:06:03                kenny </span><span>I am using specter v0.13.0</span></div><div data-t="nathanmarz @kenny it probably has something to do with clojure.walk interacting with that datomic type"><span class="u" id="1476320997.001925">2016:10:13 01:09:57           nathanmarz </span><span>@kenny it probably has something to do with clojure.walk interacting with that datomic type</span></div><div data-t="nathanmarz i think you can avoid that situation by doing  continue-then-stay  instead of  stay-then-continue"><span class="u" id="1476321038.001926">2016:10:13 01:10:38           nathanmarz </span><span>i think you can avoid that situation by doing </span><code>continue-then-stay</code><span> instead of </span><code>stay-then-continue</code></div><div data-t="kenny yes that did it"><span class="u" id="1476321105.001927">2016:10:13 01:11:45                kenny </span><span>yes that did it</span></div><div data-t="kenny Why did that make it work?"><span class="u" id="1476321128.001928">2016:10:13 01:12:08                kenny </span><span>Why did that make it work?</span></div><div data-t="nathanmarz when you do  stay-then-continue , it first updates :db/id on the top-level map. then it does the rest of the path (`MAP-VALS (walker ...) MapWalker`)"><span class="u" id="1476321187.001929">2016:10:13 01:13:07           nathanmarz </span><span>when you do </span><code>stay-then-continue</code><span>, it first updates :db/id on the top-level map. then it does the rest of the path (`MAP-VALS (walker ...) MapWalker`)</span></div><div data-t="nathanmarz when you do  continue-then-stay , it does the walk of the submaps first, so at no point does the walk ever go over the datomic types that you produced"><span class="u" id="1476321223.001930">2016:10:13 01:13:43           nathanmarz </span><span>when you do </span><code>continue-then-stay</code><span>, it does the walk of the submaps first, so at no point does the walk ever go over the datomic types that you produced</span></div><div data-t="kenny Ah I see. Thank you for your explanation  🙂"><span class="u" id="1476321265.001931">2016:10:13 01:14:25                kenny </span><span>Ah I see. Thank you for your explanation </span><b>🙂</b></div><div data-t="nathanmarz no problem!"><span class="u" id="1476321503.001932">2016:10:13 01:18:23           nathanmarz </span><span>no problem!</span></div><div data-t="jlutteringer noob question here: How do I select the values that come before elements that satisfy a given predicate. For example if I had  [1 &quot;a&quot; 22 3 5 2 &quot;b&quot; 10]  and wanted to select values that occur before strings to get  [1 2] . Is this something that is possible?"><span class="u" id="1476386771.001957">2016:10:13 19:26:11         jlutteringer </span><span>noob question here: How do I select the values that come before elements that satisfy a given predicate. For example if I had </span><code>[1 &quot;a&quot; 22 3 5 2 &quot;b&quot; 10]</code><span> and wanted to select values that occur before strings to get </span><code>[1 2]</code><span>. Is this something that is possible?</span></div><div data-t="darwin gave 0.13 another shot, and still having the same issue like 5 weeks ago:
 https://gist.github.com/darwin/10e6748467e0a13a8f7573c1ae99e4a6 
it is calling this function, compiled under  :advanced  mode with  :pseudo-names  true
 https://github.com/binaryage/dirac/blob/6c0c2bc8348eb296174cc72331c031e096af1bda/src/implant/dirac/implant/automation/reps.cljs#L62"><span class="u" id="1476387151.001958">2016:10:13 19:32:31               darwin </span><span>gave 0.13 another shot, and still having the same issue like 5 weeks ago:
</span><a href="https://gist.github.com/darwin/10e6748467e0a13a8f7573c1ae99e4a6">https://gist.github.com/darwin/10e6748467e0a13a8f7573c1ae99e4a6</a><span>
it is calling this function, compiled under </span><code>:advanced</code><span> mode with </span><code>:pseudo-names</code><span> true
</span><a href="https://github.com/binaryage/dirac/blob/6c0c2bc8348eb296174cc72331c031e096af1bda/src/implant/dirac/implant/automation/reps.cljs#L62">https://github.com/binaryage/dirac/blob/6c0c2bc8348eb296174cc72331c031e096af1bda/src/implant/dirac/implant/automation/reps.cljs#L62</a></div><div data-t="darwin looking into it further, I’m going to solve this today, just posting FYI"><span class="u" id="1476387173.001961">2016:10:13 19:32:53               darwin </span><span>looking into it further, I’m going to solve this today, just posting FYI</span></div><div data-t="darwin this.$late1$ seems to be ok, but it does not contain $select_STAR_$"><span class="u" id="1476387451.001962">2016:10:13 19:37:31               darwin </span><span>this.$late1$ seems to be ok, but it does not contain $select_STAR_$</span></div><div data-t="nathanmarz @jlutteringer you could do  [(continuous-subseqs (complement string?)) FIRST]"><span class="u" id="1476388752.001963">2016:10:13 19:59:12           nathanmarz </span><span>@jlutteringer you could do </span><code>[(continuous-subseqs (complement string?)) FIRST]</code></div><div data-t="nathanmarz @darwin can you remind me what was causing the issue before?"><span class="u" id="1476388791.001964">2016:10:13 19:59:51           nathanmarz </span><span>@darwin can you remind me what was causing the issue before?</span></div><div data-t="nathanmarz also, does it still fail under 0.13.1-SNAPSHOT?"><span class="u" id="1476388817.001965">2016:10:13 20:00:17           nathanmarz </span><span>also, does it still fail under 0.13.1-SNAPSHOT?</span></div><div data-t="darwin we didn’t go deeper into it, I decided to wait if anyone else hits similar issue, downgraded to 0.12 again"><span class="u" id="1476388853.001966">2016:10:13 20:00:53               darwin </span><span>we didn’t go deeper into it, I decided to wait if anyone else hits similar issue, downgraded to 0.12 again</span></div><div data-t="darwin I’m going to try the snapshot"><span class="u" id="1476388862.001967">2016:10:13 20:01:02               darwin </span><span>I’m going to try the snapshot</span></div><div data-t="nathanmarz does it work under non-advanced compilation?"><span class="u" id="1476388872.001968">2016:10:13 20:01:12           nathanmarz </span><span>does it work under non-advanced compilation?</span></div><div data-t="darwin that is next thing I want to test"><span class="u" id="1476388925.001969">2016:10:13 20:02:05               darwin </span><span>that is next thing I want to test</span></div><div data-t="nathanmarz can you also wrap that line in  (with-inline-debug ...) ?"><span class="u" id="1476389127.001970">2016:10:13 20:05:27           nathanmarz </span><span>can you also wrap that line in </span><code>(with-inline-debug ...)</code><span>?</span></div><div data-t="nathanmarz that will print some debugging info that might be useful"><span class="u" id="1476389149.001971">2016:10:13 20:05:49           nathanmarz </span><span>that will print some debugging info that might be useful</span></div><div data-t="darwin 0.13.1-SNAPSHOT is broken for me as well, trying to compile it under :whitespace mode and with-inline-debug, unfortunately switching to :none mode would be much more work due to chrome extension packaging restrictions"><span class="u" id="1476389673.001972">2016:10:13 20:14:33               darwin </span><span>0.13.1-SNAPSHOT is broken for me as well, trying to compile it under :whitespace mode and with-inline-debug, unfortunately switching to :none mode would be much more work due to chrome extension packaging restrictions</span></div><div data-t="darwin ah, I’m going in the same footsteps, :whitespace mode is broken due to this parinfer issue:
 https://github.com/shaunlebron/parinfer/issues/120 
and I cannot upgrade because it wasn’t yet published on cljsjs"><span class="u" id="1476390217.001973">2016:10:13 20:23:37               darwin </span><span>ah, I’m going in the same footsteps, :whitespace mode is broken due to this parinfer issue:
</span><a href="https://github.com/shaunlebron/parinfer/issues/120">https://github.com/shaunlebron/parinfer/issues/120</a><span>
and I cannot upgrade because it wasn’t yet published on cljsjs</span></div><div data-t="darwin now I recall, that is why I gave up few weeks ago"><span class="u" id="1476390247.001975">2016:10:13 20:24:07               darwin </span><span>now I recall, that is why I gave up few weeks ago</span></div><div data-t="nathanmarz ok"><span class="u" id="1476390357.001976">2016:10:13 20:25:57           nathanmarz </span><span>ok</span></div><div data-t="darwin I’m going to use parinfer directly as foreign-lib, but it will take me some time until I figure it out"><span class="u" id="1476390391.001977">2016:10:13 20:26:31               darwin </span><span>I’m going to use parinfer directly as foreign-lib, but it will take me some time until I figure it out</span></div><div data-t="nathanmarz looking at the error more closely, the issue is happening inside of multi-path, so wrapping the providepath in with-inline-debug would be helpful as well"><span class="u" id="1476390401.001978">2016:10:13 20:26:41           nathanmarz </span><span>looking at the error more closely, the issue is happening inside of multi-path, so wrapping the providepath in with-inline-debug would be helpful as well</span></div><div data-t="darwin also that “undefined” thing in generated identifier names is suspicious"><span class="u" id="1476390759.001979">2016:10:13 20:32:39               darwin </span><span>also that “undefined” thing in generated identifier names is suspicious</span></div><div data-t="nathanmarz @jlutteringer just realized you asked something completely different, for that use case I would recommend using zipper navigators or making a custom navigator"><span class="u" id="1476390822.001980">2016:10:13 20:33:42           nathanmarz </span><span>@jlutteringer just realized you asked something completely different, for that use case I would recommend using zipper navigators or making a custom navigator</span></div><div data-t="nathanmarz @darwin agree"><span class="u" id="1476390859.001981">2016:10:13 20:34:19           nathanmarz </span><span>@darwin agree</span></div><div data-t="jlutteringer I was able to get very close tweaking your example  (specter/select [(specter/continuous-subseqs (complement string?)) specter/LAST] [1 &quot;a&quot; 22 3 5 2 &quot;b&quot; 10])  gives me  [1 2 10]  now I just need to figure out how to drop the last element"><span class="u" id="1476390914.001982">2016:10:13 20:35:14         jlutteringer </span><span>I was able to get very close tweaking your example </span><code>(specter/select [(specter/continuous-subseqs (complement string?)) specter/LAST] [1 &quot;a&quot; 22 3 5 2 &quot;b&quot; 10])</code><span> gives me </span><code>[1 2 10]</code><span> now I just need to figure out how to drop the last element</span></div><div data-t="nathanmarz well, if the last element of sequence is a string you wouldn&apos;t want to drop it"><span class="u" id="1476391202.001983">2016:10:13 20:40:02           nathanmarz </span><span>well, if the last element of sequence is a string you wouldn&apos;t want to drop it</span></div><div data-t="jlutteringer ah, right"><span class="u" id="1476391326.001984">2016:10:13 20:42:06         jlutteringer </span><span>ah, right</span></div><div data-t="jlutteringer kk, I’ll give zippers a shot, thanks so much for the help!"><span class="u" id="1476391357.001985">2016:10:13 20:42:37         jlutteringer </span><span>kk, I’ll give zippers a shot, thanks so much for the help!</span></div><div data-t="nathanmarz specter integrates zippers in specter/zipper.cljc"><span class="u" id="1476391395.001986">2016:10:13 20:43:15           nathanmarz </span><span>specter integrates zippers in specter/zipper.cljc</span></div><div data-t="nathanmarz https://nathanmarz.github.io/specter/com.rpl.specter.zipper.html"><span class="u" id="1476391439.001987">2016:10:13 20:43:59           nathanmarz </span><a href="https://nathanmarz.github.io/specter/com.rpl.specter.zipper.html">https://nathanmarz.github.io/specter/com.rpl.specter.zipper.html</a></div><div data-t="nathanmarz @jlutteringer
 (select
        [z/VECTOR-ZIP
         z/DOWN
         z/NEXT-WALK
         (selected? z/NODE string?)
         z/LEFT
         z/NODE]
        [1 2 &quot;a&quot; 3 &quot;b&quot; 4])
;; =&gt; [2 3]
"><span class="u" id="1476391651.001988">2016:10:13 20:47:31           nathanmarz </span><span>@jlutteringer
</span><pre>(select
        [z/VECTOR-ZIP
         z/DOWN
         z/NEXT-WALK
         (selected? z/NODE string?)
         z/LEFT
         z/NODE]
        [1 2 &quot;a&quot; 3 &quot;b&quot; 4])
;; =&gt; [2 3]
</pre></div><div data-t="jlutteringer you’re the man, thank you so much"><span class="u" id="1476391743.001989">2016:10:13 20:49:03         jlutteringer </span><span>you’re the man, thank you so much</span></div><div data-t="darwin getting close to get :whitespace working, now hitting
 http://dev.clojure.org/jira/browse/CLJS-1547"><span class="u" id="1476393514.001990">2016:10:13 21:18:34               darwin </span><span>getting close to get :whitespace working, now hitting
</span><a href="http://dev.clojure.org/jira/browse/CLJS-1547">http://dev.clojure.org/jira/browse/CLJS-1547</a></div><div data-t="darwin @nathanmarz finally got a screenshot for you:
 https://dl.dropboxusercontent.com/u/559047/specter-dirac-whitespace.png"><span class="u" id="1476399668.001997">2016:10:13 23:01:08               darwin </span><span>@nathanmarz finally got a screenshot for you:
</span><a href="https://dl.dropboxusercontent.com/u/559047/specter-dirac-whitespace.png">https://dl.dropboxusercontent.com/u/559047/specter-dirac-whitespace.png</a></div><div data-t="darwin https://dl.dropboxusercontent.com/u/559047/specter-dirac-whitespace2.png"><span class="u" id="1476399784.001999">2016:10:13 23:03:04               darwin </span><a href="https://dl.dropboxusercontent.com/u/559047/specter-dirac-whitespace2.png">https://dl.dropboxusercontent.com/u/559047/specter-dirac-whitespace2.png</a></div><div data-t="darwin this is output I got from the inline-debug:  https://gist.github.com/darwin/1b2d5f75a9348ba2b9dcad241c1e2fb6"><span class="u" id="1476401773.002001">2016:10:13 23:36:13               darwin </span><span>this is output I got from the inline-debug: </span><a href="https://gist.github.com/darwin/1b2d5f75a9348ba2b9dcad241c1e2fb6">https://gist.github.com/darwin/1b2d5f75a9348ba2b9dcad241c1e2fb6</a></div><div data-t="darwin I was able to isolate the issue:  https://github.com/darwin/pesky-select-star"><span class="u" id="1476406387.002004">2016:10:14 00:53:07               darwin </span><span>I was able to isolate the issue: </span><a href="https://github.com/darwin/pesky-select-star">https://github.com/darwin/pesky-select-star</a></div><div data-t="darwin it is failing even on code from specter’s own tests, I was playing with deps and downgrading clojurescript to 1.7.122 fixed it
 https://github.com/darwin/pesky-select-star/blob/master/project.clj#L9 

so does specter support newer clojurescript versions?"><span class="u" id="1476406457.002006">2016:10:14 00:54:17               darwin </span><span>it is failing even on code from specter’s own tests, I was playing with deps and downgrading clojurescript to 1.7.122 fixed it
</span><a href="https://github.com/darwin/pesky-select-star/blob/master/project.clj#L9">https://github.com/darwin/pesky-select-star/blob/master/project.clj#L9</a><span>

so does specter support newer clojurescript versions?</span></div><div data-t="darwin that 1.7.122 I took from specter’s repo and I don’t see there any other clojurescript version"><span class="u" id="1476406540.002008">2016:10:14 00:55:40               darwin </span><span>that 1.7.122 I took from specter’s repo and I don’t see there any other clojurescript version</span></div><div data-t="nathanmarz @darwin Thanks, this is all really helpful"><span class="u" id="1476428374.002026">2016:10:14 06:59:34           nathanmarz </span><span>@darwin Thanks, this is all really helpful</span></div><div data-t="nathanmarz @darwin I opened an issue to track it  https://github.com/nathanmarz/specter/issues/152"><span class="u" id="1476428537.002027">2016:10:14 07:02:17           nathanmarz </span><span>@darwin I opened an issue to track it </span><a href="https://github.com/nathanmarz/specter/issues/152">https://github.com/nathanmarz/specter/issues/152</a></div><div data-t="darwin thanks @nathanmarz, will downgrade to 0.12 and track the issue and do next attempt when you fix it, not a priority, good luck!"><span class="u" id="1476443745.002043">2016:10:14 11:15:45               darwin </span><span>thanks @nathanmarz, will downgrade to 0.12 and track the issue and do next attempt when you fix it, not a priority, good luck!</span></div><div data-t="nathanmarz @darwin ok give the latest 0.13.1-SNAPSHOT a shot"><span class="u" id="1476453331.002056">2016:10:14 13:55:31           nathanmarz </span><span>@darwin ok give the latest 0.13.1-SNAPSHOT a shot</span></div><div data-t="nathanmarz should be fixed"><span class="u" id="1476453334.002057">2016:10:14 13:55:34           nathanmarz </span><span>should be fixed</span></div><div data-t="darwin @nathanmarz thanks a lot! going to test it now"><span class="u" id="1476453423.002058">2016:10:14 13:57:03               darwin </span><span>@nathanmarz thanks a lot! going to test it now</span></div><div data-t="darwin @nathanmarz works for me, thanks for the quick fix!
 https://github.com/nathanmarz/specter/issues/152#issuecomment-253822990"><span class="u" id="1476456802.002061">2016:10:14 14:53:22               darwin </span><span>@nathanmarz works for me, thanks for the quick fix!
</span><a href="https://github.com/nathanmarz/specter/issues/152#issuecomment-253822990">https://github.com/nathanmarz/specter/issues/152#issuecomment-253822990</a></div><div data-t="nathanmarz @darwin awesome, thanks for tracking it down"><span class="u" id="1476457016.002063">2016:10:14 14:56:56           nathanmarz </span><span>@darwin awesome, thanks for tracking it down</span></div><div data-t="nahuel is possible to use specter to dissoc? ej, transform  {:a {:b 1 :c 2}} to {:a {:c 2}} ?"><span class="u" id="1476738760.002311">2016:10:17 21:12:40               nahuel </span><span>is possible to use specter to dissoc? ej, transform  {:a {:b 1 :c 2}} to {:a {:c 2}} ?</span></div><div data-t="nathanmarz @nahuel You can just do  (transform :a #(dissoc % :b) data)"><span class="u" id="1476739349.002312">2016:10:17 21:22:29           nathanmarz </span><span>@nahuel You can just do </span><code>(transform :a #(dissoc % :b) data)</code></div><div data-t="nathanmarz I have a utility function to help with it:  (defn dissocer [k] (fn [m] (dissoc m k)))"><span class="u" id="1476739372.002313">2016:10:17 21:22:52           nathanmarz </span><span>I have a utility function to help with it: </span><code>(defn dissocer [k] (fn [m] (dissoc m k)))</code></div><div data-t="nathanmarz so you can do  (transform :a (dissocer :b) data)"><span class="u" id="1476739386.002314">2016:10:17 21:23:06           nathanmarz </span><span>so you can do </span><code>(transform :a (dissocer :b) data)</code></div><div data-t="nathanmarz there&apos;s also some thought about extending  ALL  and  keypath  to be able to remove elements on this issue  https://github.com/nathanmarz/specter/issues/117"><span class="u" id="1476739429.002315">2016:10:17 21:23:49           nathanmarz </span><span>there&apos;s also some thought about extending </span><code>ALL</code><span> and </span><code>keypath</code><span> to be able to remove elements on this issue </span><a href="https://github.com/nathanmarz/specter/issues/117">https://github.com/nathanmarz/specter/issues/117</a></div><div data-t="nathanmarz but you could always just make your own navigator with that functionality"><span class="u" id="1476739450.002317">2016:10:17 21:24:10           nathanmarz </span><span>but you could always just make your own navigator with that functionality</span></div><div data-t="nahuel nathanmarz: thanks"><span class="u" id="1476740138.002318">2016:10:17 21:35:38               nahuel </span><span>nathanmarz: thanks</span></div><div data-t="nahuel why this doesnt work? (setval [:a #{1 2} ] :y {:a {1 :z 2 :z 3 :z }})  .. I expected {:a {1 :y, 2 :y, 3 :z}} but the map is unchanged (I&apos;m trying to use the set as a predicate)"><span class="u" id="1476740501.002320">2016:10:17 21:41:41               nahuel </span><span>why this doesnt work? (setval [:a #{1 2} ] :y {:a {1 :z 2 :z 3 :z }})  .. I expected {:a {1 :y, 2 :y, 3 :z}} but the map is unchanged (I&apos;m trying to use the set as a predicate)</span></div><div data-t="nathanmarz sets are interpreted as filter predicates"><span class="u" id="1476740694.002321">2016:10:17 21:44:54           nathanmarz </span><span>sets are interpreted as filter predicates</span></div><div data-t="nathanmarz (#{1 2} {1 :z 2 :z 3 :z })  is false, so it stops navigation at that point"><span class="u" id="1476740716.002322">2016:10:17 21:45:16           nathanmarz </span><code>(#{1 2} {1 :z 2 :z 3 :z })</code><span> is false, so it stops navigation at that point</span></div><div data-t="nathanmarz @nahuel you should do this:  (setval [:a (multi-path (keypath 1) (keypath 2))] :y {:a {1 :z 2 :z 3 :z }}) "><span class="u" id="1476740747.002323">2016:10:17 21:45:47           nathanmarz </span><span>@nahuel you should do this: </span><code>(setval [:a (multi-path (keypath 1) (keypath 2))] :y {:a {1 :z 2 :z 3 :z }}) </code></div><div data-t="nahuel but what if the keys are stored in a set? (it can be variable)"><span class="u" id="1476740894.002324">2016:10:17 21:48:14               nahuel </span><span>but what if the keys are stored in a set? (it can be variable)</span></div><div data-t="nathanmarz probably the easiest is to do  (setval [:a (apply multi-path #{1 2})] ...)"><span class="u" id="1476742093.002326">2016:10:17 22:08:13           nathanmarz </span><span>probably the easiest is to do </span><code>(setval [:a (apply multi-path #{1 2})] ...)</code></div><div data-t="nahuel mm, my set can be very big, I think there is some limitation for apply on the number of arguments"><span class="u" id="1476742210.002327">2016:10:17 22:10:10               nahuel </span><span>mm, my set can be very big, I think there is some limitation for apply on the number of arguments</span></div><div data-t="nathanmarz there&apos;s not"><span class="u" id="1476742562.002332">2016:10:17 22:16:02           nathanmarz </span><span>there&apos;s not</span></div><div data-t="nathanmarz (apply + (range 100000))  =&gt; 4999950000"><span class="u" id="1476742580.002333">2016:10:17 22:16:20           nathanmarz </span><code>(apply + (range 100000))</code><span> =&gt; 4999950000</span></div><div data-t="nathanmarz actually the code I gave you isn&apos;t quite right, it should be  (setval [:a (apply multi-path (map keypath #{1 2}))] ...)"><span class="u" id="1476742633.002334">2016:10:17 22:17:13           nathanmarz </span><span>actually the code I gave you isn&apos;t quite right, it should be </span><code>(setval [:a (apply multi-path (map keypath #{1 2}))] ...)</code></div><div data-t="nahuel oh, thanks"><span class="u" id="1476742651.002335">2016:10:17 22:17:31               nahuel </span><span>oh, thanks</span></div><div data-t="madstap You can actually apply a function to an infinite list"><span class="u" id="1476785466.002368">2016:10:18 10:11:06              madstap </span><span>You can actually apply a function to an infinite list</span></div><div data-t="joshkh howdy! just curious about a behaviour in the following example:
 (s/select [:a s/ALL (juxt :start :end)]
                  {:a [{:start 1 :middle 9 :end 2} {:start 3 :middle 9 :end 4}]})
 
yields  [{:start 1, :middle 9, :end 2} {:start 3, :middle 9, :end 4}] 
when i would have expected just :start and :end keys in the resulting maps."><span class="u" id="1476976517.002541">2016:10:20 15:15:17               joshkh </span><span>howdy! just curious about a behaviour in the following example:
</span><pre>(s/select [:a s/ALL (juxt :start :end)]
                  {:a [{:start 1 :middle 9 :end 2} {:start 3 :middle 9 :end 4}]})
</pre><span>
yields </span><code>[{:start 1, :middle 9, :end 2} {:start 3, :middle 9, :end 4}]</code><span>
when i would have expected just :start and :end keys in the resulting maps.</span></div><div data-t="joshkh i thought multipath might allow me to collect the two values but this throws an exception in cljs:
 (s/select [:a s/ALL (s/multi-path :start :end)]
                  {:a [{:start 1 :middle 9 :end 2} {:start 3 :middle 9 :end 4}]})
"><span class="u" id="1476976615.002542">2016:10:20 15:16:55               joshkh </span><span>i thought multipath might allow me to collect the two values but this throws an exception in cljs:
</span><pre>(s/select [:a s/ALL (s/multi-path :start :end)]
                  {:a [{:start 1 :middle 9 :end 2} {:start 3 :middle 9 :end 4}]})
</pre></div><div data-t="joshkh when i really just wanted  [[1 2] [3 4]"><span class="u" id="1476976663.002543">2016:10:20 15:17:43               joshkh </span><span>when i really just wanted </span><code>[[1 2] [3 4]</code></div><div data-t="joshkh i could just throw an anonymous function in there, something like (vals (select-keys..."><span class="u" id="1476976811.002544">2016:10:20 15:20:11               joshkh </span><span>i could just throw an anonymous function in there, something like (vals (select-keys...</span></div><div data-t="exupero In the  juxt  example, I’m guessing the function is treated as a predicate, so it returns anything for which that predicate returns a truthy result, not the truthy result itself."><span class="u" id="1476976830.002545">2016:10:20 15:20:30              exupero </span><span>In the </span><code>juxt</code><span> example, I’m guessing the function is treated as a predicate, so it returns anything for which that predicate returns a truthy result, not the truthy result itself.</span></div><div data-t="joshkh ah, that makes sense"><span class="u" id="1476976856.002546">2016:10:20 15:20:56               joshkh </span><span>ah, that makes sense</span></div><div data-t="joshkh (and i lied about the anonymous function - like you said it&apos;s treated as a predicate)"><span class="u" id="1476976898.002547">2016:10:20 15:21:38               joshkh </span><span>(and i lied about the anonymous function - like you said it&apos;s treated as a predicate)</span></div><div data-t="nathanmarz @joshkh what exception are you getting? that works fine for me in a cljs repl"><span class="u" id="1476977239.002548">2016:10:20 15:27:19           nathanmarz </span><span>@joshkh what exception are you getting? that works fine for me in a cljs repl</span></div><div data-t="joshkh specter.cljc?rel=1476963781628:1049 Uncaught TypeError: G__36053.select_STAR_ is not a function"><span class="u" id="1476977377.002549">2016:10:20 15:29:37               joshkh </span><code>specter.cljc?rel=1476963781628:1049 Uncaught TypeError: G__36053.select_STAR_ is not a function</code></div><div data-t="joshkh using  [com.rpl/specter &quot;0.13.0&quot;]"><span class="u" id="1476977419.002550">2016:10:20 15:30:19               joshkh </span><span>using </span><code>[com.rpl/specter &quot;0.13.0&quot;]</code></div><div data-t="nathanmarz oh"><span class="u" id="1476977441.002551">2016:10:20 15:30:41           nathanmarz </span><span>oh</span></div><div data-t="nathanmarz yea that bug is fixed in master"><span class="u" id="1476977453.002552">2016:10:20 15:30:53           nathanmarz </span><span>yea that bug is fixed in master</span></div><div data-t="nathanmarz try 0.13.1-SNAPSHOT"><span class="u" id="1476977457.002553">2016:10:20 15:30:57           nathanmarz </span><span>try 0.13.1-SNAPSHOT</span></div><div data-t="joshkh it worked! thanks  🙂"><span class="u" id="1476977556.002554">2016:10:20 15:32:36               joshkh </span><span>it worked! thanks </span><b>🙂</b></div><div data-t="nathanmarz also if you want to get  [[1 2] [3 4]]  as the result do this:
  (select [:a s/ALL (s/collect-one :start) :end]
        {:a [{:start 1 :middle 9 :end 2} {:start 3 :middle 9 :end 4}]})
"><span class="u" id="1476977558.002555">2016:10:20 15:32:38           nathanmarz </span><span>also if you want to get </span><code>[[1 2] [3 4]]</code><span> as the result do this:
 </span><pre>(select [:a s/ALL (s/collect-one :start) :end]
        {:a [{:start 1 :middle 9 :end 2} {:start 3 :middle 9 :end 4}]})
</pre></div><div data-t="joshkh oh right. i had tried calling  collect-one  for each respective key but couldn&apos;t figure out how to &quot;drop&quot; the rest from the selection resulting in  [1 3 {entire-node}]"><span class="u" id="1476977696.002557">2016:10:20 15:34:56               joshkh </span><span>oh right. i had tried calling </span><code>collect-one</code><span> for each respective key but couldn&apos;t figure out how to &quot;drop&quot; the rest from the selection resulting in </span><code>[1 3 {entire-node}]</code></div><div data-t="joshkh as always, thanks for the help"><span class="u" id="1476977699.002558">2016:10:20 15:34:59               joshkh </span><span>as always, thanks for the help</span></div><div data-t="nathanmarz no problem, glad I was helpful"><span class="u" id="1476977722.002559">2016:10:20 15:35:22           nathanmarz </span><span>no problem, glad I was helpful</span></div><div data-t="nlessa Hi,
How could I solve in specter this problem? Given a key (eg: :e) located in an undetermined nested level of a map return the map with only the keys that compose the path to reach it. 
 For example: 
{:a 1 :b {:c 2 :d {:e 3 :f 4} :g {:e 5 :h 8}}}

 --&gt; {:b {:d {:e 3} :g {:e 5}}}"><span class="u" id="1477417588.002768">2016:10:25 17:46:28               nlessa </span><span>Hi,
How could I solve in specter this problem? Given a key (eg: :e) located in an undetermined nested level of a map return the map with only the keys that compose the path to reach it. 
</span><pre>For example: 
{:a 1 :b {:c 2 :d {:e 3 :f 4} :g {:e 5 :h 8}}}

 --&gt; {:b {:d {:e 3} :g {:e 5}}}</pre></div><div data-t="nathanmarz @nlessa two ways to go about it"><span class="u" id="1477427296.002789">2016:10:25 20:28:16           nathanmarz </span><span>@nlessa two ways to go about it</span></div><div data-t="nathanmarz first is to use  select  with a recursive path + value collection to get the sequence of paths to your desired key/values. Then construct the nested map manually"><span class="u" id="1477427326.002790">2016:10:25 20:28:46           nathanmarz </span><span>first is to use </span><code>select</code><span> with a recursive path + value collection to get the sequence of paths to your desired key/values. Then construct the nested map manually</span></div><div data-t="nathanmarz second is to make a new navigator like  ALL  that removes values when  NONE  is returned on transformation"><span class="u" id="1477427413.002791">2016:10:25 20:30:13           nathanmarz </span><span>second is to make a new navigator like </span><code>ALL</code><span> that removes values when </span><code>NONE</code><span> is returned on transformation</span></div><div data-t="nathanmarz with that you could solve your use case with a single  transform  call"><span class="u" id="1477427427.002792">2016:10:25 20:30:27           nathanmarz </span><span>with that you could solve your use case with a single </span><code>transform</code><span> call</span></div><div data-t="achesnais @nathanmarz don’t know if this is a silly question or not, but is there any remote chance or plan to have specter become part of clojure.core?"><span class="u" id="1477648268.002891">2016:10:28 09:51:08            achesnais </span><span>@nathanmarz don’t know if this is a silly question or not, but is there any remote chance or plan to have specter become part of clojure.core?</span></div><div data-t="achesnais And if not I’d be interested to know if there’s a specific reason why in terms of design philosophy etc."><span class="u" id="1477648298.002892">2016:10:28 09:51:38            achesnais </span><span>And if not I’d be interested to know if there’s a specific reason why in terms of design philosophy etc.</span></div><div data-t="achesnais 🙂"><span class="u" id="1477648300.002893">2016:10:28 09:51:40            achesnais </span><b>🙂</b></div><div data-t="darwin I’m afraid it works the other way around, there may be no specific reasons why something is not in core. To get something into the core there must be very compelling reasons for it. I mean really compelling. Being a popular/useful/well-maintained/general library is not enough of itself. One such compelling reason I could imagine with specter would be the core library using specter internally, so it would make sense to expose it as well. Similar to clojure.spec. Or another reason could be when specter could not be implemented as a library and would have to be implemented as part of core for some reason… just my $0.02 thoughts"><span class="u" id="1477651823.002897">2016:10:28 10:50:23               darwin </span><span>I’m afraid it works the other way around, there may be no specific reasons why something is not in core. To get something into the core there must be very compelling reasons for it. I mean really compelling. Being a popular/useful/well-maintained/general library is not enough of itself. One such compelling reason I could imagine with specter would be the core library using specter internally, so it would make sense to expose it as well. Similar to clojure.spec. Or another reason could be when specter could not be implemented as a library and would have to be implemented as part of core for some reason… just my $0.02 thoughts</span></div><div data-t="nathanmarz @achesnais @darwin I get that question a lot and I understand why"><span class="u" id="1477659628.002901">2016:10:28 13:00:28           nathanmarz </span><span>@achesnais @darwin I get that question a lot and I understand why</span></div><div data-t="nathanmarz Specter solves such a fundamental, universal problem that I do believe it makes Clojure much stronger, so in that sense it would make sense to be distributed with the language"><span class="u" id="1477659687.002902">2016:10:28 13:01:27           nathanmarz </span><span>Specter solves such a fundamental, universal problem that I do believe it makes Clojure much stronger, so in that sense it would make sense to be distributed with the language</span></div><div data-t="nathanmarz ultimately though it&apos;s not up to me what goes into core"><span class="u" id="1477659910.002903">2016:10:28 13:05:10           nathanmarz </span><span>ultimately though it&apos;s not up to me what goes into core</span></div><div data-t="kzeidler Specter looks really cool, but I can&apos;t figure out how to import it. How do I actually use the library in a namespace?"><span class="u" id="1477895149.002999">2016:10:31 06:25:49             kzeidler </span><span>Specter looks really cool, but I can&apos;t figure out how to import it. How do I actually use the library in a namespace?</span></div><div data-t="kzeidler Preferably without the prefix, as demonstrated in the examples"><span class="u" id="1477895176.003000">2016:10:31 06:26:16             kzeidler </span><span>Preferably without the prefix, as demonstrated in the examples</span></div><div data-t="aengelberg @kzeidler:  (use &apos;com.rpl.specter) ?"><span class="u" id="1477895335.003001">2016:10:31 06:28:55           aengelberg </span><span>@kzeidler: </span><code>(use &apos;com.rpl.specter)</code><span>?</span></div><div data-t="kzeidler I get: `Only :refer-clojure, :require, :require-macros, :use, :use-macros, and :import libspecs supported at line 1 src/succulent/core.cljs"><span class="u" id="1477895474.003002">2016:10:31 06:31:14             kzeidler </span><span>I get: `Only :refer-clojure, :require, :require-macros, :use, :use-macros, and :import libspecs supported at line 1 src/succulent/core.cljs</span></div><div data-t="kzeidler aha, taking it out of the (ns ...) s-expr does work though"><span class="u" id="1477895560.003003">2016:10:31 06:32:40             kzeidler </span><span>aha, taking it out of the (ns ...) s-expr does work though</span></div><div data-t="kzeidler What&apos;s the idiomatic way to put this in my code? Just place it after the ns definition?"><span class="u" id="1477895613.003004">2016:10:31 06:33:33             kzeidler </span><span>What&apos;s the idiomatic way to put this in my code? Just place it after the ns definition?</span></div><div data-t="kzeidler Spoke too soon. It compiled with your suggestion, but isn&apos;t able to find a definition for any of its functions"><span class="u" id="1477895907.003005">2016:10:31 06:38:27             kzeidler </span><span>Spoke too soon. It compiled with your suggestion, but isn&apos;t able to find a definition for any of its functions</span></div><div data-t="kzeidler And in the repl: (use &apos;com.rpl.specter)
clojure.lang.ExceptionInfo: Only [lib.ns :only (names)] and optionally  :rename {from to}  specs supported in :use / :use-macros; offending spec: [com.rpl.specter] at line 1 &lt;cljs repl&gt; {:file &quot;&lt;cljs repl&gt;&quot;, :line 1, :column 1, :root-source-info {:source-type :fragment, :source-form (ns succulent.core (:use [com.rpl.specter]))}, :tag :cljs/analysis-error}"><span class="u" id="1477895921.003006">2016:10:31 06:38:41             kzeidler </span><span>And in the repl: (use &apos;com.rpl.specter)
clojure.lang.ExceptionInfo: Only [lib.ns :only (names)] and optionally </span><code>:rename {from to}</code><span> specs supported in :use / :use-macros; offending spec: [com.rpl.specter] at line 1 &lt;cljs repl&gt; {:file &quot;&lt;cljs repl&gt;&quot;, :line 1, :column 1, :root-source-info {:source-type :fragment, :source-form (ns succulent.core (:use [com.rpl.specter]))}, :tag :cljs/analysis-error}</span></div><div data-t="nathanmarz @kzeidler in clojurescript you can&apos;t do  use , you have to do  require"><span class="u" id="1477914399.003019">2016:10:31 11:46:39           nathanmarz </span><span>@kzeidler in clojurescript you can&apos;t do </span><code>use</code><span>, you have to do </span><code>require</code></div><div data-t="nathanmarz if you don&apos;t want the prefix in cljs you have to enumerate every symbol you want to import, e.g.  (require &apos;[com.rpl.specter :refer [ALL srange keypath]])"><span class="u" id="1477914505.003020">2016:10:31 11:48:25           nathanmarz </span><span>if you don&apos;t want the prefix in cljs you have to enumerate every symbol you want to import, e.g. </span><code>(require &apos;[com.rpl.specter :refer [ALL srange keypath]])</code></div><div data-t="joshkh i noticed that adding specter to my clojurescript project increased the compiled file size from 550kb to 830kb after google closure advanced optimization. that&apos;s quite an increase, and i&apos;m only referencing  [select ALL] . does that seem normal?"><span class="u" id="1478016055.003066">2016:11:01 16:00:55               joshkh </span><span>i noticed that adding specter to my clojurescript project increased the compiled file size from 550kb to 830kb after google closure advanced optimization. that&apos;s quite an increase, and i&apos;m only referencing </span><code>[select ALL]</code><span>. does that seem normal?</span></div><div data-t="nathanmarz @joshkh I&apos;m not familiar enough with cljs to understand those details"><span class="u" id="1478017108.003067">2016:11:01 16:18:28           nathanmarz </span><span>@joshkh I&apos;m not familiar enough with cljs to understand those details</span></div><div data-t="nathanmarz any idea what the increase is? the compiled js for specter?"><span class="u" id="1478017129.003068">2016:11:01 16:18:49           nathanmarz </span><span>any idea what the increase is? the compiled js for specter?</span></div><div data-t="joshkh i&apos;ll investigate. it&apos;s a bit hard to tell at first glance because advanced optimization munges everything into one garbled file."><span class="u" id="1478017277.003069">2016:11:01 16:21:17               joshkh </span><span>i&apos;ll investigate. it&apos;s a bit hard to tell at first glance because advanced optimization munges everything into one garbled file.</span></div><div data-t="joshkh i&apos;ll try the same with simple optimization and see where it gets me  🙂"><span class="u" id="1478017299.003070">2016:11:01 16:21:39               joshkh </span><span>i&apos;ll try the same with simple optimization and see where it gets me </span><b>🙂</b></div><div data-t="nathanmarz ok, thanks"><span class="u" id="1478017305.003071">2016:11:01 16:21:45           nathanmarz </span><span>ok, thanks</span></div><div data-t="nathanmarz might be a good idea to open an issue on this to track it"><span class="u" id="1478017313.003072">2016:11:01 16:21:53           nathanmarz </span><span>might be a good idea to open an issue on this to track it</span></div><div data-t="joshkh gotcha, will do"><span class="u" id="1478017379.003073">2016:11:01 16:22:59               joshkh </span><span>gotcha, will do</span></div><div data-t="shooodooken Having some issues transforming map:
I expected the output to be  {:parent {:grandchild {}}} 

 (require &apos;[com.rpl.specter.macros :as spm])
(require &apos;[com.rpl.specter :as sp])

(spm/transform [:parent sp/ALL] #(get-in % [:child]) {:parent {:child {:grandchild {}}}})
=&gt; {:parent {nil nil}} 

Running this will get me close to the desired output:

 (spm/transform [:parent sp/ALL] #(get-in % [:child]) {:parent [{:child {:grandchild {}}}]})
=&gt; {:parent [{:grandchild {}}]}"><span class="u" id="1478018239.003074">2016:11:01 16:37:19          shooodooken </span><span>Having some issues transforming map:
I expected the output to be </span><code>{:parent {:grandchild {}}}</code><span>

</span><pre>(require &apos;[com.rpl.specter.macros :as spm])
(require &apos;[com.rpl.specter :as sp])

(spm/transform [:parent sp/ALL] #(get-in % [:child]) {:parent {:child {:grandchild {}}}})
=&gt; {:parent {nil nil}}</pre><span>

Running this will get me close to the desired output:

</span><pre>(spm/transform [:parent sp/ALL] #(get-in % [:child]) {:parent [{:child {:grandchild {}}}]})
=&gt; {:parent [{:grandchild {}}]}</pre></div><div data-t="shooodooken how can i achieve the desired result without changing the datastructure?"><span class="u" id="1478018270.003075">2016:11:01 16:37:50          shooodooken </span><span>how can i achieve the desired result without changing the datastructure?</span></div><div data-t="shooodooken reading the docs for ALL ({:doc &quot;Navigate to every element of the collection. For maps navigates to
          a vector of  [key value] .&quot;}) tells me I&apos;ll have to deconstruct &amp; reconstruct data structure manually."><span class="u" id="1478021099.003077">2016:11:01 17:24:59          shooodooken </span><span>reading the docs for ALL ({:doc &quot;Navigate to every element of the collection. For maps navigates to
          a vector of </span><code>[key value]</code><span>.&quot;}) tells me I&apos;ll have to deconstruct &amp; reconstruct data structure manually.</span></div><div data-t="nathanmarz @shooodooken is this what you want?
 (transform :parent :child  {:parent {:child {:grandchild {}}}})
"><span class="u" id="1478025552.003081">2016:11:01 18:39:12           nathanmarz </span><span>@shooodooken is this what you want?
</span><pre>(transform :parent :child  {:parent {:child {:grandchild {}}}})
</pre></div><div data-t="shooodooken yes sir, thank you. (the real code was bit more tricky but dropping the ALL was ultimately what I needed)"><span class="u" id="1478036029.003088">2016:11:01 21:33:49          shooodooken </span><span>yes sir, thank you. (the real code was bit more tricky but dropping the ALL was ultimately what I needed)</span></div><div data-t="tianshu Hi, I&apos;m new to specter, I&apos;m very exciting about specter. 
And I&apos;m trying to use it, does specter ship some features like threading macros? 
I want to use specter to do something following:
 (-&gt;&gt; {&quot;20161106020&quot; {:3010 {}
                       :3006 {:3 &quot;3.10&quot;
                              :1 &quot;3.55&quot;
                              :0 &quot;18.00&quot;}}
        &quot;20161106021&quot; {:3010 {:3 &quot;3.00&quot;}
                       :3006 {:3 &quot;2.00&quot;}}}

       (map (fn [kv]
              (-&gt;&gt; (peek kv)
                   (map (fn [kv1]
                         (count (peek kv1))))
                   (reduce +))))
       (reduce *))
 
what I want is simplify this piece of code with specter. wonder if someone could give me an example.
appreciate for any help, thanks!"><span class="u" id="1478506573.003277">2016:11:07 08:16:13              tianshu </span><span>Hi, I&apos;m new to specter, I&apos;m very exciting about specter. 
And I&apos;m trying to use it, does specter ship some features like threading macros? 
I want to use specter to do something following:
</span><pre>(-&gt;&gt; {&quot;20161106020&quot; {:3010 {}
                       :3006 {:3 &quot;3.10&quot;
                              :1 &quot;3.55&quot;
                              :0 &quot;18.00&quot;}}
        &quot;20161106021&quot; {:3010 {:3 &quot;3.00&quot;}
                       :3006 {:3 &quot;2.00&quot;}}}

       (map (fn [kv]
              (-&gt;&gt; (peek kv)
                   (map (fn [kv1]
                         (count (peek kv1))))
                   (reduce +))))
       (reduce *))
</pre><span>
what I want is simplify this piece of code with specter. wonder if someone could give me an example.
appreciate for any help, thanks!</span></div><div data-t="nathanmarz @doglooksgood here&apos;s one way to do it with specter:
 (defn sum [args] (reduce + args))
(reduce * (traverse [MAP-VALS (subselect MAP-VALS (view count)) (view sum)] data))
"><span class="u" id="1478522421.003285">2016:11:07 12:40:21           nathanmarz </span><span>@doglooksgood here&apos;s one way to do it with specter:
</span><pre>(defn sum [args] (reduce + args))
(reduce * (traverse [MAP-VALS (subselect MAP-VALS (view count)) (view sum)] data))
</pre></div><div data-t="nathanmarz if there were a  traversed  navigator builder along the lines of  transformed , you could do it like this:
 (reduce * (traverse [MAP-VALS (traversed [MAP-VALS (view count)] +)] data))
"><span class="u" id="1478522460.003286">2016:11:07 12:41:00           nathanmarz </span><span>if there were a </span><code>traversed</code><span> navigator builder along the lines of </span><code>transformed</code><span>, you could do it like this:
</span><pre>(reduce * (traverse [MAP-VALS (traversed [MAP-VALS (view count)] +)] data))
</pre></div><div data-t="nathanmarz the former (which currently works) does materialize some intermediate subsequences, while the latter would not, so the latter would be close to optimal efficiency"><span class="u" id="1478522507.003287">2016:11:07 12:41:47           nathanmarz </span><span>the former (which currently works) does materialize some intermediate subsequences, while the latter would not, so the latter would be close to optimal efficiency</span></div><div data-t="nathanmarz (defdynamicnav traversed
  &quot;Navigates to a view of the current value by transforming with a reduction over
   the specified traversal.&quot;
  [path reduce-fn]
  (late-bound-nav [late (late-path path)
                   late-fn reduce-fn]
    (select* [this structure next-fn]
      (next-fn (reduce late-fn (compiled-traverse late structure))))
    (transform* [this structure next-fn]
      (next-fn (reduce late-fn (compiled-traverse late structure)))
      )))
"><span class="u" id="1478522775.003288">2016:11:07 12:46:15           nathanmarz </span><pre>(defdynamicnav traversed
  &quot;Navigates to a view of the current value by transforming with a reduction over
   the specified traversal.&quot;
  [path reduce-fn]
  (late-bound-nav [late (late-path path)
                   late-fn reduce-fn]
    (select* [this structure next-fn]
      (next-fn (reduce late-fn (compiled-traverse late structure))))
    (transform* [this structure next-fn]
      (next-fn (reduce late-fn (compiled-traverse late structure)))
      )))
</pre></div><div data-t="nathanmarz I&apos;ll add that to the next version"><span class="u" id="1478522782.003289">2016:11:07 12:46:22           nathanmarz </span><span>I&apos;ll add that to the next version</span></div><div data-t="nathanmarz Released 0.13.1  https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><span class="u" id="1478536097.003297">2016:11:07 16:28:17           nathanmarz </span><span>Released 0.13.1 </span><a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></div><div data-t="danielcompton @nathanmarz is this you?  http://rpl.com/"><span class="u" id="1478546683.003300">2016:11:07 19:24:43        danielcompton </span><span>@nathanmarz is this you? </span><a href="http://rpl.com/">http://rpl.com/</a></div><div data-t="nathanmarz @danielcompton no lol"><span class="u" id="1478547117.003301">2016:11:07 19:31:57           nathanmarz </span><span>@danielcompton no lol</span></div><div data-t="nathanmarz I haven&apos;t put up a website yet"><span class="u" id="1478547125.003302">2016:11:07 19:32:05           nathanmarz </span><span>I haven&apos;t put up a website yet</span></div><div data-t="levitanong It would suck for renaissance partners, ltd. if they decided to make a clojure library, and found out they couldn’t use the  com.rpl  namespace  😛"><span class="u" id="1478591782.003321">2016:11:08 07:56:22           levitanong </span><span>It would suck for renaissance partners, ltd. if they decided to make a clojure library, and found out they couldn’t use the </span><code>com.rpl</code><span> namespace </span><b>😛</b></div><div data-t="zane Can anyone think of what the root cause for intermittent  java.lang.ClassCastException: clojure.lang.Var$Unbound cannot be cast to com.rpl.specter.MutableCell  would be?"><span class="u" id="1478622908.003334">2016:11:08 16:35:08                 zane </span><span>Can anyone think of what the root cause for intermittent </span><code>java.lang.ClassCastException: clojure.lang.Var$Unbound cannot be cast to com.rpl.specter.MutableCell</code><span> would be?</span></div><div data-t="nathanmarz @zane what version of Specter?"><span class="u" id="1478623720.003335">2016:11:08 16:48:40           nathanmarz </span><span>@zane what version of Specter?</span></div><div data-t="nathanmarz and what&apos;s the full stack trace?"><span class="u" id="1478623730.003336">2016:11:08 16:48:50           nathanmarz </span><span>and what&apos;s the full stack trace?</span></div><div data-t="zane @nathanmarz:  [com.rpl/specter &quot;0.12.0&quot;]"><span class="u" id="1478625000.003337">2016:11:08 17:10:00                 zane </span><span>@nathanmarz: </span><code>[com.rpl/specter &quot;0.12.0&quot;]</code></div><div data-t="zane I&apos;ll get you the stack trace. One moment."><span class="u" id="1478625010.003338">2016:11:08 17:10:10                 zane </span><span>I&apos;ll get you the stack trace. One moment.</span></div><div data-t="zane @nathanmarz, the Specter part of the stack trace is just:
 com.rpl.specter.impl/get-cell                 impl.clj:  469
java.lang.ClassCastException: clojure.lang.Var$Unbound cannot be cast to com.rpl.specter.MutableCell
"><span class="u" id="1478625725.003339">2016:11:08 17:22:05                 zane </span><span>@nathanmarz, the Specter part of the stack trace is just:
</span><pre>com.rpl.specter.impl/get-cell                 impl.clj:  469
java.lang.ClassCastException: clojure.lang.Var$Unbound cannot be cast to com.rpl.specter.MutableCell
</pre></div><div data-t="bfabry we get those all the time as well using specter in a distributed env. I suspect it&apos;s got something to do with caching paths"><span class="u" id="1478629677.003347">2016:11:08 18:27:57               bfabry </span><span>we get those all the time as well using specter in a distributed env. I suspect it&apos;s got something to do with caching paths</span></div><div data-t="nathanmarz there was a bug in 0.11.2 with that exception related to aot compilation that was fixed in 0.12.0"><span class="u" id="1478632902.003348">2016:11:08 19:21:42           nathanmarz </span><span>there was a bug in 0.11.2 with that exception related to aot compilation that was fixed in 0.12.0</span></div><div data-t="nathanmarz @zane @bfabry I&apos;ll need a reproducible test case"><span class="u" id="1478632916.003349">2016:11:08 19:21:56           nathanmarz </span><span>@zane @bfabry I&apos;ll need a reproducible test case</span></div><div data-t="bfabry you won&apos;t be getting one from me  😛"><span class="u" id="1478632950.003350">2016:11:08 19:22:30               bfabry </span><span>you won&apos;t be getting one from me </span><b>😛</b></div><div data-t="bfabry haha"><span class="u" id="1478632958.003351">2016:11:08 19:22:38               bfabry </span><span>haha</span></div><div data-t="zane Yeah, I wish. It&apos;s very intermittent. I haven&apos;t found a way to reproduce it reliably yet."><span class="u" id="1478633019.003352">2016:11:08 19:23:39                 zane </span><span>Yeah, I wish. It&apos;s very intermittent. I haven&apos;t found a way to reproduce it reliably yet.</span></div><div data-t="bfabry the error happens for us in an environment that&apos;s serializing classes and sending them over the wire, deserializing and executing. it&apos;s way through the looking glass as far as me actually expecting anyone to support it goes. fortunately by virtue of it being distributed it also retries, and then it starts working. so it&apos;s way down on my list of things to care about"><span class="u" id="1478633049.003353">2016:11:08 19:24:09               bfabry </span><span>the error happens for us in an environment that&apos;s serializing classes and sending them over the wire, deserializing and executing. it&apos;s way through the looking glass as far as me actually expecting anyone to support it goes. fortunately by virtue of it being distributed it also retries, and then it starts working. so it&apos;s way down on my list of things to care about</span></div><div data-t="nathanmarz The section of the code where it was coming from in the old bug is here:  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L233"><span class="u" id="1478633066.003354">2016:11:08 19:24:26           nathanmarz </span><span>The section of the code where it was coming from in the old bug is here: </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L233">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L233</a></div><div data-t="nathanmarz as you can see, it now catches ClassCastException there"><span class="u" id="1478633082.003356">2016:11:08 19:24:42           nathanmarz </span><span>as you can see, it now catches ClassCastException there</span></div><div data-t="nathanmarz only possibility is  bound?  is returning true for  clojure.lang.Var$Unbound"><span class="u" id="1478633150.003357">2016:11:08 19:25:50           nathanmarz </span><span>only possibility is </span><code>bound?</code><span> is returning true for </span><code>clojure.lang.Var$Unbound</code></div><div data-t="nathanmarz @zane is the context of these exceptions also a distributed env?"><span class="u" id="1478633167.003358">2016:11:08 19:26:07           nathanmarz </span><span>@zane is the context of these exceptions also a distributed env?</span></div><div data-t="zane I might needs some help understanding what you mean by a &quot;distributed env&quot;. It&apos;s a web server with multiple threads?"><span class="u" id="1478633383.003359">2016:11:08 19:29:43                 zane </span><span>I might needs some help understanding what you mean by a &quot;distributed env&quot;. It&apos;s a web server with multiple threads?</span></div><div data-t="nathanmarz ok, that&apos;s good to know"><span class="u" id="1478633878.003362">2016:11:08 19:37:58           nathanmarz </span><span>ok, that&apos;s good to know</span></div><div data-t="nathanmarz by distributed env I mean something like Hadoop where you serialize/deserialize objects"><span class="u" id="1478633902.003363">2016:11:08 19:38:22           nathanmarz </span><span>by distributed env I mean something like Hadoop where you serialize/deserialize objects</span></div><div data-t="zane Oh, no."><span class="u" id="1478634029.003364">2016:11:08 19:40:29                 zane </span><span>Oh, no.</span></div><div data-t="zane Nothing like that."><span class="u" id="1478634030.003365">2016:11:08 19:40:30                 zane </span><span>Nothing like that.</span></div><div data-t="nathanmarz @zane @bfabry found a race condition in that code that could cause the exception you were seeing, it&apos;s fixed in master"><span class="u" id="1478700247.003391">2016:11:09 14:04:07           nathanmarz </span><span>@zane @bfabry found a race condition in that code that could cause the exception you were seeing, it&apos;s fixed in master</span></div><div data-t="zane Oh wow. Thanks, Nathan!"><span class="u" id="1478704685.003392">2016:11:09 15:18:05                 zane </span><span>Oh wow. Thanks, Nathan!</span></div><div data-t="tianshu @nathanmarz Thanks for the help. It&apos;s very useful!"><span class="u" id="1478742077.003415">2016:11:10 01:41:17              tianshu </span><span>@nathanmarz Thanks for the help. It&apos;s very useful!</span></div><div data-t="fredokun Hi there. Lately, I pretty much enjoy writing specter one-liners, neat!"><span class="u" id="1478771459.003423">2016:11:10 09:50:59             fredokun </span><span>Hi there. Lately, I pretty much enjoy writing specter one-liners, neat!</span></div><div data-t="fredokun I have a probably numb question but is it possible in  (transform PATH f val)  to make 
the transformation somewhat depend on the application of val.

I give an example (on which I stumbled multiple times)...
Consider a map like this:

  `"><span class="u" id="1478771622.003430">2016:11:10 09:53:42             fredokun </span><span>I have a probably numb question but is it possible in </span><code>(transform PATH f val)</code><span> to make 
the transformation somewhat depend on the application of val.

I give an example (on which I stumbled multiple times)...
Consider a map like this:

</span><code></code><span>`</span></div><div data-t="fredokun { :a 2 :b 1 :c 3}
 
And I would like to e.g. decrement all VALS and, at the same time, 
remove all the pairs whose value gets to 0, i.e. :

  `"><span class="u" id="1478771745.003431">2016:11:10 09:55:45             fredokun </span><pre>{ :a 2 :b 1 :c 3}
</pre><span>
And I would like to e.g. decrement all VALS and, at the same time, 
remove all the pairs whose value gets to 0, i.e. :

</span><code></code><span>`</span></div><div data-t="fredokun "><span class="u" id="1478771751.003432">2016:11:10 09:55:51             fredokun </span><pre></pre></div><div data-t="fredokun (sorry for the very bad slack edits, I&apos;m new here ;-)...

So I would like to obtain :

 { :a 1 :c 3}    and  :b  is no more ...

Thanks in advance (and sorry again for the awfully bad typing above)."><span class="u" id="1478771855.003433">2016:11:10 09:57:35             fredokun </span><span>(sorry for the very bad slack edits, I&apos;m new here ;-)...

So I would like to obtain :

</span><code>{ :a 1 :c 3}</code><span>   and </span><code>:b</code><span> is no more ...

Thanks in advance (and sorry again for the awfully bad typing above).</span></div><div data-t="fredokun (plus I see that it&apos;s the middle of the night in the U.S. and no one&apos;s here ;-).  See you later then !"><span class="u" id="1478771915.003434">2016:11:10 09:58:35             fredokun </span><span>(plus I see that it&apos;s the middle of the night in the U.S. and no one&apos;s here ;-).  See you later then !</span></div><div data-t="fredokun (oops)
To rephrase myself: is it possible in  (transform PATH f val)  to make
the transformation somewhat depend on the application of  f  ?"><span class="u" id="1478780612.003435">2016:11:10 12:23:32             fredokun </span><span>(oops)
To rephrase myself: is it possible in </span><code>(transform PATH f val)</code><span> to make
the transformation somewhat depend on the application of </span><code>f</code><span> ?</span></div><div data-t="nathanmarz @fredokun there&apos;s discussion of a feature for that here:  https://github.com/nathanmarz/specter/issues/117"><span class="u" id="1478781321.003436">2016:11:10 12:35:21           nathanmarz </span><span>@fredokun there&apos;s discussion of a feature for that here: </span><a href="https://github.com/nathanmarz/specter/issues/117">https://github.com/nathanmarz/specter/issues/117</a></div><div data-t="nathanmarz you could always make that navigator yourself"><span class="u" id="1478781328.003438">2016:11:10 12:35:28           nathanmarz </span><span>you could always make that navigator yourself</span></div><div data-t="nathanmarz keypath ,  MAP-VALS , and  ALL  could have that functionality"><span class="u" id="1478781360.003439">2016:11:10 12:36:00           nathanmarz </span><code>keypath</code><span>, </span><code>MAP-VALS</code><span>, and </span><code>ALL</code><span> could have that functionality</span></div><div data-t="fredokun thanks for the reply I will look at the issue and try to do something !"><span class="u" id="1478798160.003446">2016:11:10 17:16:00             fredokun </span><span>thanks for the reply I will look at the issue and try to do something !</span></div><div data-t="zane I wish specs were … Specter-aware, if that makes sense."><span class="u" id="1478801779.003453">2016:11:10 18:16:19                 zane </span><span>I wish specs were … Specter-aware, if that makes sense.</span></div><div data-t="zane Haven&apos;t completely thought this through."><span class="u" id="1478801813.003454">2016:11:10 18:16:53                 zane </span><span>Haven&apos;t completely thought this through.</span></div><div data-t="zane But it would be nice to be able to use Specter selectors in specs rather than traditional keypaths."><span class="u" id="1478801829.003455">2016:11:10 18:17:09                 zane </span><span>But it would be nice to be able to use Specter selectors in specs rather than traditional keypaths.</span></div><div data-t="nathanmarz @zane I haven&apos;t dug that much into Spec yet, care to show an example of what you mean?"><span class="u" id="1478865307.003480">2016:11:11 11:55:07           nathanmarz </span><span>@zane I haven&apos;t dug that much into Spec yet, care to show an example of what you mean?</span></div><div data-t="imre hi all"><span class="u" id="1478871436.003482">2016:11:11 13:37:16                 imre </span><span>hi all</span></div><div data-t="imre I would be grateful if someone could give me advice on building paths dynamically using a navigator in 0.13.1"><span class="u" id="1478871489.003483">2016:11:11 13:38:09                 imre </span><span>I would be grateful if someone could give me advice on building paths dynamically using a navigator in 0.13.1</span></div><div data-t="imre my navigator is like this"><span class="u" id="1478871507.003484">2016:11:11 13:38:27                 imre </span><span>my navigator is like this</span></div><div data-t="imre (sp/defnav
  EID
  [eid]
  (select* [{:keys [eid]} structure next-fn] (eid-nav-select* eid structure next-fn))
  (transform* [{:keys [eid]} structure next-fn] (eid-nav-transform* eid structure next-fn)))"><span class="u" id="1478871511.003485">2016:11:11 13:38:31                 imre </span><pre>(sp/defnav
  EID
  [eid]
  (select* [{:keys [eid]} structure next-fn] (eid-nav-select* eid structure next-fn))
  (transform* [{:keys [eid]} structure next-fn] (eid-nav-transform* eid structure next-fn)))</pre></div><div data-t="imre and this is how I try to build a path from a list of keys"><span class="u" id="1478871580.003486">2016:11:11 13:39:40                 imre </span><span>and this is how I try to build a path from a list of keys</span></div><div data-t="imre (defn- specter-path [ks]
  (map #(if (u/uuid? %)
          (EID %)
          %)
       ks))"><span class="u" id="1478871583.003487">2016:11:11 13:39:43                 imre </span><pre>(defn- specter-path [ks]
  (map #(if (u/uuid? %)
          (EID %)
          %)
       ks))</pre></div><div data-t="imre and getting a  Cannot statically combine sequential when not in nav pos  error when invoking specter-path"><span class="u" id="1478871668.003488">2016:11:11 13:41:08                 imre </span><span>and getting a </span><code>Cannot statically combine sequential when not in nav pos</code><span> error when invoking specter-path</span></div><div data-t="imre well actually the error comes when I try to use the path in a call to  setval"><span class="u" id="1478872140.003489">2016:11:11 13:49:00                 imre </span><span>well actually the error comes when I try to use the path in a call to </span><code>setval</code></div><div data-t="imre well, I managed to fix it however I don&apos;t exactly know why it failed."><span class="u" id="1478872927.003490">2016:11:11 14:02:07                 imre </span><span>well, I managed to fix it however I don&apos;t exactly know why it failed.</span></div><div data-t="imre so the calling code looked like this:"><span class="u" id="1478872936.003491">2016:11:11 14:02:16                 imre </span><span>so the calling code looked like this:</span></div><div data-t="imre (-&gt; (concat [:_entity] ks)
          specter-path
          (sp/setval value stored-entity))
"><span class="u" id="1478872956.003492">2016:11:11 14:02:36                 imre </span><pre>(-&gt; (concat [:_entity] ks)
          specter-path
          (sp/setval value stored-entity))
</pre></div><div data-t="imre but when I defined this function
 (defn- setval [apath aval structure]
  (sp/setval apath aval structure))
 
and replaced  sp/setval  with  setval  inside the threading macro, it worked"><span class="u" id="1478873038.003495">2016:11:11 14:03:58                 imre </span><span>but when I defined this function
</span><pre>(defn- setval [apath aval structure]
  (sp/setval apath aval structure))
</pre><span>
and replaced </span><code>sp/setval</code><span> with </span><code>setval</code><span> inside the threading macro, it worked</span></div><div data-t="nathanmarz @imre that looks like a bug"><span class="u" id="1478873538.003496">2016:11:11 14:12:18           nathanmarz </span><span>@imre that looks like a bug</span></div><div data-t="nathanmarz can you open an issue on github for it?"><span class="u" id="1478873550.003497">2016:11:11 14:12:30           nathanmarz </span><span>can you open an issue on github for it?</span></div><div data-t="nathanmarz you can workaround it by doing  (let [p (specter-path ...)] (setval p ...))"><span class="u" id="1478873575.003498">2016:11:11 14:12:55           nathanmarz </span><span>you can workaround it by doing </span><code>(let [p (specter-path ...)] (setval p ...))</code></div><div data-t="imre thanks @nathanmarz I&apos;ll open one - is it okay if I just put this chatlog in there?"><span class="u" id="1478873629.003499">2016:11:11 14:13:49                 imre </span><span>thanks @nathanmarz I&apos;ll open one - is it okay if I just put this chatlog in there?</span></div><div data-t="nathanmarz sure"><span class="u" id="1478873745.003500">2016:11:11 14:15:45           nathanmarz </span><span>sure</span></div><div data-t="imre https://github.com/nathanmarz/specter/issues/157  added, thanks again!"><span class="u" id="1478873864.003501">2016:11:11 14:17:44                 imre </span><a href="https://github.com/nathanmarz/specter/issues/157">https://github.com/nathanmarz/specter/issues/157</a><span> added, thanks again!</span></div><div data-t="imre and btw specter absolutely rocks"><span class="u" id="1478873876.003503">2016:11:11 14:17:56                 imre </span><span>and btw specter absolutely rocks</span></div><div data-t="nathanmarz thanks"><span class="u" id="1478875141.003504">2016:11:11 14:39:01           nathanmarz </span><span>thanks</span></div><div data-t="nathanmarz in a transform,  view  replaces whatever is at that point with the result of the view function before continuing the transform"><span class="u" id="1479220428.003650">2016:11:15 14:33:48           nathanmarz </span><span>in a transform, </span><code>view</code><span> replaces whatever is at that point with the result of the view function before continuing the transform</span></div><div data-t="achesnais I got that – but here, shouldn’t  :value  and  (view :value)  be equivalent?"><span class="u" id="1479220618.003651">2016:11:15 14:36:58            achesnais </span><span>I got that – but here, shouldn’t </span><code>:value</code><span> and </span><code>(view :value)</code><span> be equivalent?</span></div><div data-t="achesnais (your lib is so great by the way)"><span class="u" id="1479220654.003652">2016:11:15 14:37:34            achesnais </span><span>(your lib is so great by the way)</span></div><div data-t="nathanmarz no,  :value  on its own navigates to the subvalue and continues the transform from there"><span class="u" id="1479221174.003653">2016:11:15 14:46:14           nathanmarz </span><span>no, </span><code>:value</code><span> on its own navigates to the subvalue and continues the transform from there</span></div><div data-t="nathanmarz (transform :a afn data)  is the same as  (update data :a afn)"><span class="u" id="1479221221.003654">2016:11:15 14:47:01           nathanmarz </span><code>(transform :a afn data)</code><span> is the same as </span><code>(update data :a afn)</code></div><div data-t="achesnais Ohhh"><span class="u" id="1479228956.003661">2016:11:15 16:55:56            achesnais </span><span>Ohhh</span></div><div data-t="achesnais okay"><span class="u" id="1479228957.003662">2016:11:15 16:55:57            achesnais </span><span>okay</span></div><div data-t="achesnais I think I got it"><span class="u" id="1479228960.003663">2016:11:15 16:56:00            achesnais </span><span>I think I got it</span></div><div data-t="achesnais Thank you!"><span class="u" id="1479228966.003664">2016:11:15 16:56:06            achesnais </span><span>Thank you!</span></div><div data-t="wei is there a way to get the next/previous element of an collection in a transformation?  [1 2 3]  =&gt;  [[1 0] [2 1] [3 2]]"><span class="u" id="1479341629.003707">2016:11:17 00:13:49                  wei </span><span>is there a way to get the next/previous element of an collection in a transformation? </span><code>[1 2 3]</code><span> =&gt; </span><code>[[1 0] [2 1] [3 2]]</code></div><div data-t="wei use case + hacky solution:  ((fn [xs]
   (concat [(first xs)]
           (-&gt;&gt; (partition 2 1 xs)
                (map (fn [[prev cur]] (assoc cur :prev prev))))))
 [{:id 1} {:id 2} {:id 3} {:id 4}])
=&gt; ({:id 1} {:id 2, :prev {:id 1}} {:id 3, :prev {:id 2}} {:id 4, :prev {:id 3}})
"><span class="u" id="1479342778.003708">2016:11:17 00:32:58                  wei </span><span>use case + hacky solution: </span><pre>((fn [xs]
   (concat [(first xs)]
           (-&gt;&gt; (partition 2 1 xs)
                (map (fn [[prev cur]] (assoc cur :prev prev))))))
 [{:id 1} {:id 2} {:id 3} {:id 4}])
=&gt; ({:id 1} {:id 2, :prev {:id 1}} {:id 3, :prev {:id 2}} {:id 4, :prev {:id 3}})
</pre></div><div data-t="nathanmarz @wei you can use com.rpl.specter.zipper for that"><span class="u" id="1479498105.003777">2016:11:18 19:41:45           nathanmarz </span><span>@wei you can use com.rpl.specter.zipper for that</span></div><div data-t="caio failing on the following  providepath :
 (sp/declarepath map-walker)
(sp/providepath map-walker
                 [(sp/walker map?)
                  (sp/continue-then-stay sp/MAP-VALS map-walker)])
"><span class="u" id="1479933356.003944">2016:11:23 20:35:56                 caio </span><span>failing on the following </span><code>providepath</code><span>:
</span><pre>(sp/declarepath map-walker)
(sp/providepath map-walker
                 [(sp/walker map?)
                  (sp/continue-then-stay sp/MAP-VALS map-walker)])
</pre></div><div data-t="nathanmarz @caio what version of specter?"><span class="u" id="1479934907.003952">2016:11:23 21:01:47           nathanmarz </span><span>@caio what version of specter?</span></div><div data-t="nathanmarz are you doing aot compilation?"><span class="u" id="1479934919.003953">2016:11:23 21:01:59           nathanmarz </span><span>are you doing aot compilation?</span></div><div data-t="caio [com.rpl/specter “0 .13.1”]`"><span class="u" id="1479936670.003954">2016:11:23 21:31:10                 caio </span><code>[com.rpl/specter “0</code><span>.13.1”]`</span></div><div data-t="caio yep, I’m doing aot compilation"><span class="u" id="1479936699.003955">2016:11:23 21:31:39                 caio </span><span>yep, I’m doing aot compilation</span></div><div data-t="nathanmarz @caio ok"><span class="u" id="1479937900.003956">2016:11:23 21:51:40           nathanmarz </span><span>@caio ok</span></div><div data-t="nathanmarz could you open an issue for this? don&apos;t have time to look at it now"><span class="u" id="1479937908.003957">2016:11:23 21:51:48           nathanmarz </span><span>could you open an issue for this? don&apos;t have time to look at it now</span></div><div data-t="bfabry slightly gross:
 (sp/transform [:parent sp/ALL #(= :children (first %)) sp/LAST] identity {:parent {:something {}}})
=&gt; {:parent {:something {}}}
(sp/transform [:parent sp/ALL #(= :children (first %)) sp/LAST] identity {:parent {:something {} :children 1}})
=&gt; {:parent {:something {}, :children 1}}
"><span class="u" id="1479941807.003959">2016:11:23 22:56:47               bfabry </span><span>slightly gross:
</span><pre>(sp/transform [:parent sp/ALL #(= :children (first %)) sp/LAST] identity {:parent {:something {}}})
=&gt; {:parent {:something {}}}
(sp/transform [:parent sp/ALL #(= :children (first %)) sp/LAST] identity {:parent {:something {} :children 1}})
=&gt; {:parent {:something {}, :children 1}}
</pre></div><div data-t="shooodooken :+1:   gives me the correct result so not too gross. looks like i can drop the sp/LAST aswell.
 (sp/transform [:parent sp/ALL #(= :children (first %))] identity {:parent {:something {}}})
=&gt; {:parent {:something {}}}
(sp/transform [:parent sp/ALL #(= :children (first %))] identity {:parent {:something {} :children 1}})
=&gt; {:parent {:something {}, :children 1}}"><span class="u" id="1479942167.003960">2016:11:23 23:02:47          shooodooken </span><b>:+1:</b><span>  gives me the correct result so not too gross. looks like i can drop the sp/LAST aswell.
</span><pre>(sp/transform [:parent sp/ALL #(= :children (first %))] identity {:parent {:something {}}})
=&gt; {:parent {:something {}}}
(sp/transform [:parent sp/ALL #(= :children (first %))] identity {:parent {:something {} :children 1}})
=&gt; {:parent {:something {}, :children 1}}</pre></div><div data-t="shooodooken i&apos;m still thinking there must be a cleaner way out there"><span class="u" id="1479942191.003961">2016:11:23 23:03:11          shooodooken </span><span>i&apos;m still thinking there must be a cleaner way out there</span></div><div data-t="bfabry yeah"><span class="u" id="1479942195.003962">2016:11:23 23:03:15               bfabry </span><span>yeah</span></div><div data-t="shooodooken must be a common enough scenario"><span class="u" id="1479942204.003963">2016:11:23 23:03:24          shooodooken </span><span>must be a common enough scenario</span></div><div data-t="bfabry I guess it defaults to this way because that&apos;s what update-in does"><span class="u" id="1479942217.003964">2016:11:23 23:03:37               bfabry </span><span>I guess it defaults to this way because that&apos;s what update-in does</span></div><div data-t="shooodooken i could have sworn i already unsuccessfully tried what i&apos;m about to post..
 (sp/transform [:parent sp/ALL (sp/selected? :children)] identity {:parent {:something {} }})
=&gt; {:parent {:something {}}}
(sp/transform [:parent sp/ALL (sp/selected? :children)] identity {:parent {:something {},:children 1 }})
=&gt; {:parent {:something {}, :children 1}}"><span class="u" id="1479942432.003965">2016:11:23 23:07:12          shooodooken </span><span>i could have sworn i already unsuccessfully tried what i&apos;m about to post..
</span><pre>(sp/transform [:parent sp/ALL (sp/selected? :children)] identity {:parent {:something {} }})
=&gt; {:parent {:something {}}}
(sp/transform [:parent sp/ALL (sp/selected? :children)] identity {:parent {:something {},:children 1 }})
=&gt; {:parent {:something {}, :children 1}}</pre></div><div data-t="shooodooken but it works!"><span class="u" id="1479942463.003966">2016:11:23 23:07:43          shooodooken </span><span>but it works!</span></div><div data-t="bfabry I think the difference is the sp/ALL bit"><span class="u" id="1479942508.003967">2016:11:23 23:08:28               bfabry </span><span>I think the difference is the sp/ALL bit</span></div><div data-t="shooodooken hmm."><span class="u" id="1479942587.003968">2016:11:23 23:09:47          shooodooken </span><span>hmm.</span></div><div data-t="shooodooken i&apos;m looking at transform now and thinking maybe i should be wrapping everything in sp/selected?

 (sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent {:something {},:children 1 }})
=&gt; {:parent {:something {}, :children 1}}"><span class="u" id="1479942612.003969">2016:11:23 23:10:12          shooodooken </span><span>i&apos;m looking at transform now and thinking maybe i should be wrapping everything in sp/selected?

</span><pre>(sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent {:something {},:children 1 }})
=&gt; {:parent {:something {}, :children 1}}</pre></div><div data-t="shooodooken so if it doesn&apos;t exist, it&apos;s not created. not sure if that&apos;s sane or not?!"><span class="u" id="1479942649.003970">2016:11:23 23:10:49          shooodooken </span><span>so if it doesn&apos;t exist, it&apos;s not created. not sure if that&apos;s sane or not?!</span></div><div data-t="shooodooken (sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {})
=&gt; {}"><span class="u" id="1479942672.003971">2016:11:23 23:11:12          shooodooken </span><pre>(sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {})
=&gt; {}</pre></div><div data-t="bfabry not sure it&apos;s doing what you expect
 (sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {})
=&gt; {}
(sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent nil})
=&gt; {:parent nil}
(sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent {:something nil}})
=&gt; {:parent {:something nil}}
(sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent {:something nil :children nil}})
=&gt; {:parent {:something nil, :children nil}}
(sp/transform [(sp/selected? :parent) (sp/selected? :children)] (constantly &apos;foo) {:parent {:something nil :children nil}})
=&gt; foo
"><span class="u" id="1479942786.003973">2016:11:23 23:13:06               bfabry </span><span>not sure it&apos;s doing what you expect
</span><pre>(sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {})
=&gt; {}
(sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent nil})
=&gt; {:parent nil}
(sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent {:something nil}})
=&gt; {:parent {:something nil}}
(sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent {:something nil :children nil}})
=&gt; {:parent {:something nil, :children nil}}
(sp/transform [(sp/selected? :parent) (sp/selected? :children)] (constantly &apos;foo) {:parent {:something nil :children nil}})
=&gt; foo
</pre></div><div data-t="shooodooken you are correct...damn.!"><span class="u" id="1479942903.003974">2016:11:23 23:15:03          shooodooken </span><span>you are correct...damn.!</span></div><div data-t="bfabry found it"><span class="u" id="1479943680.003975">2016:11:23 23:28:00               bfabry </span><span>found it</span></div><div data-t="bfabry undocumented function, sp/must"><span class="u" id="1479943685.003976">2016:11:23 23:28:05               bfabry </span><span>undocumented function, sp/must</span></div><div data-t="bfabry (sp/transform [(sp/must :parent)] (constantly &apos;foo) {})
=&gt; {}
(sp/transform [(sp/must :parent)] (constantly &apos;foo) {:parent {}})
=&gt; {:parent foo}
(sp/transform [(sp/must :parent)] (constantly &apos;foo) {:parent {:children {}}})
=&gt; {:parent foo}
(sp/transform [(sp/must :parent)] (constantly &apos;foo) {:parent {:children {} :foo nil
                                                              }})
=&gt; {:parent foo}
(sp/transform [(sp/must :parent) (sp/must :children)] (constantly &apos;foo) {:parent {:children {} :foo nil}})
=&gt; {:parent {:children foo, :foo nil}}
(sp/transform [(sp/must :parent) (sp/must :children)] (constantly &apos;foo) {:parent { :foo nil}})
=&gt; {:parent {:foo nil}}
"><span class="u" id="1479943699.003977">2016:11:23 23:28:19               bfabry </span><pre>(sp/transform [(sp/must :parent)] (constantly &apos;foo) {})
=&gt; {}
(sp/transform [(sp/must :parent)] (constantly &apos;foo) {:parent {}})
=&gt; {:parent foo}
(sp/transform [(sp/must :parent)] (constantly &apos;foo) {:parent {:children {}}})
=&gt; {:parent foo}
(sp/transform [(sp/must :parent)] (constantly &apos;foo) {:parent {:children {} :foo nil
                                                              }})
=&gt; {:parent foo}
(sp/transform [(sp/must :parent) (sp/must :children)] (constantly &apos;foo) {:parent {:children {} :foo nil}})
=&gt; {:parent {:children foo, :foo nil}}
(sp/transform [(sp/must :parent) (sp/must :children)] (constantly &apos;foo) {:parent { :foo nil}})
=&gt; {:parent {:foo nil}}
</pre></div><div data-t="bfabry actually that&apos;s not true, it has a docstring, just not visible from core"><span class="u" id="1479943768.003978">2016:11:23 23:29:28               bfabry </span><span>actually that&apos;s not true, it has a docstring, just not visible from core</span></div><div data-t="bfabry https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L421"><span class="u" id="1479943775.003979">2016:11:23 23:29:35               bfabry </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L421">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L421</a></div><div data-t="shooodooken super. that&apos;s the one."><span class="u" id="1479943914.003981">2016:11:23 23:31:54          shooodooken </span><span>super. that&apos;s the one.</span></div><div data-t="shooodooken thanks a lot"><span class="u" id="1479943918.003982">2016:11:23 23:31:58          shooodooken </span><span>thanks a lot</span></div><div data-t="bfabry np"><span class="u" id="1479943965.003983">2016:11:23 23:32:45               bfabry </span><span>np</span></div><div data-t="caio @nathanmarz sorry for the delay. I’ve created the issue here, with a repo that reproduces the bug:  https://github.com/nathanmarz/specter/issues/160"><span class="u" id="1480008060.004008">2016:11:24 17:21:00                 caio </span><span>@nathanmarz sorry for the delay. I’ve created the issue here, with a repo that reproduces the bug: </span><a href="https://github.com/nathanmarz/specter/issues/160">https://github.com/nathanmarz/specter/issues/160</a></div><div data-t="nathanmarz @caio thanks"><span class="u" id="1480047095.004022">2016:11:25 04:11:35           nathanmarz </span><span>@caio thanks</span></div><div data-t="zane Out of curiosity, why is there no  MAP-KEYS ?"><span class="u" id="1480435132.004176">2016:11:29 15:58:52                 zane </span><span>Out of curiosity, why is there no </span><code>MAP-KEYS</code><span>?</span></div><div data-t="nathanmarz @zane never had a need for it"><span class="u" id="1480435196.004177">2016:11:29 15:59:56           nathanmarz </span><span>@zane never had a need for it</span></div><div data-t="nathanmarz you can make an inefficient one like this:  (def MAP-KEYS (comp-paths ALL FIRST))"><span class="u" id="1480435215.004178">2016:11:29 16:00:15           nathanmarz </span><span>you can make an inefficient one like this: </span><code>(def MAP-KEYS (comp-paths ALL FIRST))</code></div><div data-t="zane Huh. I might be misunderstanding what&apos;s happening here, but  ALL  seems to behave strangely on records."><span class="u" id="1480440964.004185">2016:11:29 17:36:04                 zane </span><span>Huh. I might be misunderstanding what&apos;s happening here, but </span><code>ALL</code><span> seems to behave strangely on records.</span></div><div data-t="zane Is this user error?
 (defrecord Test [])
(transform [specter/ALL] identity (-&gt;Test))
;; =&gt; UnsupportedOperationException Can&apos;t create empty: test-ns.Test 
"><span class="u" id="1480451243.004186">2016:11:29 20:27:23                 zane </span><span>Is this user error?
</span><pre>(defrecord Test [])
(transform [specter/ALL] identity (-&gt;Test))
;; =&gt; UnsupportedOperationException Can&apos;t create empty: test-ns.Test 
</pre></div><div data-t="nathanmarz @zane yes"><span class="u" id="1480451472.004187">2016:11:29 20:31:12           nathanmarz </span><span>@zane yes</span></div><div data-t="nathanmarz ALL  works on vectors, maps, lists, queues"><span class="u" id="1480451512.004188">2016:11:29 20:31:52           nathanmarz </span><code>ALL</code><span> works on vectors, maps, lists, queues</span></div><div data-t="zane Okay. Thanks, Nathan."><span class="u" id="1480454989.004201">2016:11:29 21:29:49                 zane </span><span>Okay. Thanks, Nathan.</span></div><div data-t="mac @nathanmarz Offtopic: When is you start-up coming out of stealth? There must be a good story related to specter there  🙂"><span class="u" id="1480488545.004239">2016:11:30 06:49:05                  mac </span><span>@nathanmarz Offtopic: When is you start-up coming out of stealth? There must be a good story related to specter there </span><b>🙂</b></div><div data-t="nathanmarz @mac not anytime soon"><span class="u" id="1480512139.004246">2016:11:30 13:22:19           nathanmarz </span><span>@mac not anytime soon</span></div><div data-t="nathanmarz but yes, I use Specter extremely heavily"><span class="u" id="1480512201.004247">2016:11:30 13:23:21           nathanmarz </span><span>but yes, I use Specter extremely heavily</span></div><div data-t="nathanmarz in my clojure/west talk I talked a little bit about my usage of it, which involves a lot of graph manipulation"><span class="u" id="1480512254.004248">2016:11:30 13:24:14           nathanmarz </span><span>in my clojure/west talk I talked a little bit about my usage of it, which involves a lot of graph manipulation</span></div><div data-t="mac @nathanmarz Ok, funny you mention that because I think I might try to use it for something similar in the near future. Have you seen it used for AST manipulation?"><span class="u" id="1480512375.004249">2016:11:30 13:26:15                  mac </span><span>@nathanmarz Ok, funny you mention that because I think I might try to use it for something similar in the near future. Have you seen it used for AST manipulation?</span></div><div data-t="nathanmarz that would be really straightforward with the graph navigators I talked about"><span class="u" id="1480513891.004250">2016:11:30 13:51:31           nathanmarz </span><span>that would be really straightforward with the graph navigators I talked about</span></div><div data-t="nathanmarz if you&apos;re interested in making an open source version of those navigators I&apos;m happy to talk you through it"><span class="u" id="1480513917.004251">2016:11:30 13:51:57           nathanmarz </span><span>if you&apos;re interested in making an open source version of those navigators I&apos;m happy to talk you through it</span></div><div data-t="mac @nathanmarz Sounds interesting. Will get to it in a couple of weeks probably."><span class="u" id="1480525592.004258">2016:11:30 17:06:32                  mac </span><span>@nathanmarz Sounds interesting. Will get to it in a couple of weeks probably.</span></div><div data-t="nathanmarz @josh.freckleton it&apos;s possible, but I don&apos;t know if it&apos;s a good idea"><span class="u" id="1480546910.004266">2016:11:30 23:01:50           nathanmarz </span><span>@josh.freckleton it&apos;s possible, but I don&apos;t know if it&apos;s a good idea</span></div><div data-t="nathanmarz doesn&apos;t feel like navigation to me"><span class="u" id="1480546923.004267">2016:11:30 23:02:03           nathanmarz </span><span>doesn&apos;t feel like navigation to me</span></div><div data-t="nathanmarz you could make a custom navigator that does that though"><span class="u" id="1480546939.004268">2016:11:30 23:02:19           nathanmarz </span><span>you could make a custom navigator that does that though</span></div><div data-t="bfabry (apply merge-with into (sp/transform sp/MAP-VALS vector [...])) is pretty terse anyway"><span class="u" id="1480547105.004269">2016:11:30 23:05:05               bfabry </span><span>(apply merge-with into (sp/transform sp/MAP-VALS vector [...])) is pretty terse anyway</span></div><div data-t="josh.freckleton @nathanmarz @bfabry thanks!"><span class="u" id="1480565640.004282">2016:12:01 04:14:00      josh.freckleton </span><span>@nathanmarz @bfabry thanks!</span></div><div data-t="caio @nathanmarz I tracked the issue 160 to this line:  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L263"><span class="u" id="1480631446.004308">2016:12:01 22:30:46                 caio </span><span>@nathanmarz I tracked the issue 160 to this line: </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L263">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L263</a></div><div data-t="caio removing the type hint solves it. I have no idea what that means ¯\(ツ)/¯"><span class="u" id="1480631449.004310">2016:12:01 22:30:49                 caio </span><span>removing the type hint solves it. I have no idea what that means ¯\(ツ)/¯</span></div><div data-t="caio and when I print the result of the sexp, I get this:  #com.rpl.specter.impl.CachedPathInfo{:dynamic? false, :precompiled #object[com.rpl.specter.impl$combine_two_navs$reify__446 0x468dda3e  , so it is a cachedpathinfo"><span class="u" id="1480631927.004312">2016:12:01 22:38:47                 caio </span><span>and when I print the result of the sexp, I get this: </span><code>#com.rpl.specter.impl.CachedPathInfo{:dynamic? false, :precompiled #object[com.rpl.specter.impl$combine_two_navs$reify__446 0x468dda3e </code><span>, so it is a cachedpathinfo</span></div><div data-t="caio related:  http://grokbase.com/t/gg/clojure/14c6sjq7hx/debugging-myclass-cannot-be-cast-to-myclass-exceptions  wtf..."><span class="u" id="1480633476.004313">2016:12:01 23:04:36                 caio </span><span>related: </span><a href="http://grokbase.com/t/gg/clojure/14c6sjq7hx/debugging-myclass-cannot-be-cast-to-myclass-exceptions">http://grokbase.com/t/gg/clojure/14c6sjq7hx/debugging-myclass-cannot-be-cast-to-myclass-exceptions</a><span> wtf...</span></div><div data-t="caio also, is there a benchmark test so I can test the options? I opened a PR without the typehint, but I’m trying to explore it a little bit"><span class="u" id="1480633697.004315">2016:12:01 23:08:17                 caio </span><span>also, is there a benchmark test so I can test the options? I opened a PR without the typehint, but I’m trying to explore it a little bit</span></div><div data-t="nathanmarz @caio I&apos;d really like to understand the underlying issue rather than try to work around it"><span class="u" id="1480683168.004334">2016:12:02 12:52:48           nathanmarz </span><span>@caio I&apos;d really like to understand the underlying issue rather than try to work around it</span></div><div data-t="nathanmarz that type hint should be working fine"><span class="u" id="1480683183.004335">2016:12:02 12:53:03           nathanmarz </span><span>that type hint should be working fine</span></div><div data-t="nathanmarz only want to resort to workaround if there&apos;s no other option"><span class="u" id="1480683216.004336">2016:12:02 12:53:36           nathanmarz </span><span>only want to resort to workaround if there&apos;s no other option</span></div><div data-t="caio @nathanmarz I understand that, but I don’t know if it’s worth it. It’s an obscure bug (all I found was one discussion) and you’re only using a record there because it’s faster to get the resulting instance’s attributes using interop. If you’re going to choose a data structure with the sole purpose of optimizing code, why not choose one that solves it and doesn’t touch a nasty trick involving clojure’s compilation and class generation?  🙂"><span class="u" id="1480695179.004350">2016:12:02 16:12:59                 caio </span><span>@nathanmarz I understand that, but I don’t know if it’s worth it. It’s an obscure bug (all I found was one discussion) and you’re only using a record there because it’s faster to get the resulting instance’s attributes using interop. If you’re going to choose a data structure with the sole purpose of optimizing code, why not choose one that solves it and doesn’t touch a nasty trick involving clojure’s compilation and class generation? </span><b>🙂</b></div><div data-t="caio I think keeping this bug on the latest specter version is horrible (even worse than the lack of clarity introduced by my PR, IMHO). afaik, this is breaking at least one other open source library (xsc/invariant) and breaks a really common and simple use case for specter: recursive paths on projects that must be AOT compiled."><span class="u" id="1480695319.004351">2016:12:02 16:15:19                 caio </span><span>I think keeping this bug on the latest specter version is horrible (even worse than the lack of clarity introduced by my PR, IMHO). afaik, this is breaking at least one other open source library (xsc/invariant) and breaks a really common and simple use case for specter: recursive paths on projects that must be AOT compiled.</span></div><div data-t="caio I am curious about what one would do to solve this bug without removing the record, but I also think there’re more important things to do other than trying to fix something without removing an optimisation “workaround”."><span class="u" id="1480695388.004352">2016:12:02 16:16:28                 caio </span><span>I am curious about what one would do to solve this bug without removing the record, but I also think there’re more important things to do other than trying to fix something without removing an optimisation “workaround”.</span></div><div data-t="caio about the bug: it looks like the compilation generates two identical classes with names  com.rpl.specter.impl.CachedPathInfo$reify__XX  (they have different suffixes). it looks like what’s being said here is true:  http://grokbase.com/t/gg/clojure/14c6sjq7hx/debugging-myclass-cannot-be-cast-to-myclass-exceptions#20141210sl7tnec6xz46p5zfwwnn47er2a 
I have no idea how to tell clojure compiler to not recompile that class/ns."><span class="u" id="1480696883.004353">2016:12:02 16:41:23                 caio </span><span>about the bug: it looks like the compilation generates two identical classes with names </span><code>com.rpl.specter.impl.CachedPathInfo$reify__XX</code><span> (they have different suffixes). it looks like what’s being said here is true: </span><a href="http://grokbase.com/t/gg/clojure/14c6sjq7hx/debugging-myclass-cannot-be-cast-to-myclass-exceptions#20141210sl7tnec6xz46p5zfwwnn47er2a">http://grokbase.com/t/gg/clojure/14c6sjq7hx/debugging-myclass-cannot-be-cast-to-myclass-exceptions#20141210sl7tnec6xz46p5zfwwnn47er2a</a><span>
I have no idea how to tell clojure compiler to not recompile that class/ns.</span></div><div data-t="caio @nathanmarz my last attempt on doing this: I implemented a native class for CachedPathInfo so it improves the benchmarks. I doesn’t make it less readable and works both in java/javascript (it uses a record impl on JS). if you don’t want to use simpler DS as a workaround for solving this issue, then maybe a DS that actually (slightly) improves specter’s performance may convince you to forget about this bug  😄 

the patch:  https://github.com/nathanmarz/specter/compare/master …caioaao:native-impl?expand=1
benchmark logs:  https://gist.github.com/caioaao/7f9c44db050aed9a5326cfd28f9efca0 
you can compare it with the benchmark I did using the master branch on my pc:  https://gist.github.com/caioaao/95a0cd834a08a777a184f5edf6c9bf00"><span class="u" id="1480699714.004355">2016:12:02 17:28:34                 caio </span><span>@nathanmarz my last attempt on doing this: I implemented a native class for CachedPathInfo so it improves the benchmarks. I doesn’t make it less readable and works both in java/javascript (it uses a record impl on JS). if you don’t want to use simpler DS as a workaround for solving this issue, then maybe a DS that actually (slightly) improves specter’s performance may convince you to forget about this bug </span><b>😄</b><span>

the patch: </span><a href="https://github.com/nathanmarz/specter/compare/master">https://github.com/nathanmarz/specter/compare/master</a><span>…caioaao:native-impl?expand=1
benchmark logs: </span><a href="https://gist.github.com/caioaao/7f9c44db050aed9a5326cfd28f9efca0">https://gist.github.com/caioaao/7f9c44db050aed9a5326cfd28f9efca0</a><span>
you can compare it with the benchmark I did using the master branch on my pc: </span><a href="https://gist.github.com/caioaao/95a0cd834a08a777a184f5edf6c9bf00">https://gist.github.com/caioaao/95a0cd834a08a777a184f5edf6c9bf00</a></div><div data-t="nathanmarz @caio thanks for the help figuring this out, I committed a fix to master"><span class="u" id="1480781145.000014">2016:12:03 16:05:45           nathanmarz </span><span>@caio thanks for the help figuring this out, I committed a fix to master</span></div><div data-t="caio @nathanmarz no problem, I&apos;m glad this is solved  🙂  about the patch I posted before: is it still useful for optimization purposes? if not, I&apos;ll delete the branch"><span class="u" id="1480796052.000015">2016:12:03 20:14:12                 caio </span><span>@nathanmarz no problem, I&apos;m glad this is solved </span><b>🙂</b><span> about the patch I posted before: is it still useful for optimization purposes? if not, I&apos;ll delete the branch</span></div><div data-t="caio adds some complexity and is really ugly for a marginal gain  so idk if it&apos;s worth it"><span class="u" id="1480796771.000022">2016:12:03 20:26:11                 caio </span><span>adds some complexity and is really ugly for a marginal gain  so idk if it&apos;s worth it</span></div><div data-t="nathanmarz @caio no it&apos;s not, the bytecode won&apos;t be any different"><span class="u" id="1480798009.000023">2016:12:03 20:46:49           nathanmarz </span><span>@caio no it&apos;s not, the bytecode won&apos;t be any different</span></div><div data-t="mpenet is there a (recommended) way to compose transforms ? I mean other than just (-&gt;&gt; x (transform ...) (transform ...)) etc"><span class="u" id="1481271002.000211">2016:12:09 08:10:02               mpenet </span><span>is there a (recommended) way to compose transforms ? I mean other than just (-&gt;&gt; x (transform ...) (transform ...)) etc</span></div><div data-t="mpenet I suspect there might be something to do that to allow a single pass over data applying all transforms in a smart way (or not)"><span class="u" id="1481271066.000213">2016:12:09 08:11:06               mpenet </span><span>I suspect there might be something to do that to allow a single pass over data applying all transforms in a smart way (or not)</span></div><div data-t="mpenet Oh I see  multi-transform  and  compiled-multi-transform  could be it"><span class="u" id="1481273422.000214">2016:12:09 08:50:22               mpenet </span><span>Oh I see </span><code>multi-transform</code><span> and </span><code>compiled-multi-transform</code><span> could be it</span></div><div data-t="bfabry I reckon the dot point at the bottom of the readme under &quot;Future work&quot; &quot;any connection to transducers?&quot; might be the final end game there  😉"><span class="u" id="1481273490.000215">2016:12:09 08:51:30               bfabry </span><span>I reckon the dot point at the bottom of the readme under &quot;Future work&quot; &quot;any connection to transducers?&quot; might be the final end game there </span><b>😉</b></div><div data-t="bfabry but I don&apos;t see anything atm"><span class="u" id="1481273535.000216">2016:12:09 08:52:15               bfabry </span><span>but I don&apos;t see anything atm</span></div><div data-t="mpenet yeah, hard to map to transducers maybe. I was more thinking of some kind of navigation/transformation planner depending on some composition of both"><span class="u" id="1481273622.000217">2016:12:09 08:53:42               mpenet </span><span>yeah, hard to map to transducers maybe. I was more thinking of some kind of navigation/transformation planner depending on some composition of both</span></div><div data-t="mpenet but yeah, not an easy task"><span class="u" id="1481273683.000218">2016:12:09 08:54:43               mpenet </span><span>but yeah, not an easy task</span></div><div data-t="mpenet fun tho"><span class="u" id="1481273687.000219">2016:12:09 08:54:47               mpenet </span><span>fun tho</span></div><div data-t="nathanmarz @mpenet yea you want to use multi-transform"><span class="u" id="1481287978.000226">2016:12:09 12:52:58           nathanmarz </span><span>@mpenet yea you want to use multi-transform</span></div><div data-t="bfabry are there performance benefits to using multi-transform over intermediate collections?"><span class="u" id="1481306982.000233">2016:12:09 18:09:42               bfabry </span><span>are there performance benefits to using multi-transform over intermediate collections?</span></div><div data-t="nathanmarz @bfabry yes"><span class="u" id="1481309306.000234">2016:12:09 18:48:26           nathanmarz </span><span>@bfabry yes</span></div><div data-t="nathanmarz if you want to do two transforms in a row and they share part of the path, it will be more performant to do it as a multi-transform"><span class="u" id="1481309350.000235">2016:12:09 18:49:10           nathanmarz </span><span>if you want to do two transforms in a row and they share part of the path, it will be more performant to do it as a multi-transform</span></div><div data-t="nathanmarz there&apos;s some benchmarks for that:  https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L307"><span class="u" id="1481309398.000236">2016:12:09 18:49:58           nathanmarz </span><span>there&apos;s some benchmarks for that: </span><a href="https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L307">https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L307</a></div><div data-t="mpenet That s what I ended up using, thanks ;)"><span class="u" id="1481310332.000238">2016:12:09 19:05:32               mpenet </span><span>That s what I ended up using, thanks ;)</span></div><div data-t="bcarrell Is there a better way of doing this?  I&apos;m a novice (to Specter) trying to figure out if it simplifies my use case: querying a nested data structure which might be in two slightly different shapes for the presence of a value.  Here&apos;s a gist which hopefully outlines it with a working solution:  https://gist.github.com/bcarrell/f9081a7a7a1c5834a09da576a463c9fb"><span class="u" id="1481655907.000385">2016:12:13 19:05:07             bcarrell </span><span>Is there a better way of doing this?  I&apos;m a novice (to Specter) trying to figure out if it simplifies my use case: querying a nested data structure which might be in two slightly different shapes for the presence of a value.  Here&apos;s a gist which hopefully outlines it with a working solution: </span><a href="https://gist.github.com/bcarrell/f9081a7a7a1c5834a09da576a463c9fb">https://gist.github.com/bcarrell/f9081a7a7a1c5834a09da576a463c9fb</a></div><div data-t="nathanmarz @bcarrell looks pretty good to me"><span class="u" id="1481657525.000387">2016:12:13 19:32:05           nathanmarz </span><span>@bcarrell looks pretty good to me</span></div><div data-t="nathanmarz you could factor it into two paths if you want to make it more &quot;readable&quot;"><span class="u" id="1481657562.000388">2016:12:13 19:32:42           nathanmarz </span><span>you could factor it into two paths if you want to make it more &quot;readable&quot;</span></div><div data-t="nathanmarz one to navigate to the  :foos  value you care about (distinguishing between the two &quot;types&quot;), and another using that to search for your target element"><span class="u" id="1481657613.000389">2016:12:13 19:33:33           nathanmarz </span><span>one to navigate to the </span><code>:foos</code><span> value you care about (distinguishing between the two &quot;types&quot;), and another using that to search for your target element</span></div><div data-t="bcarrell Cool, thanks!  I wanted to make sure it was approaching correctness"><span class="u" id="1481657651.000390">2016:12:13 19:34:11             bcarrell </span><span>Cool, thanks!  I wanted to make sure it was approaching correctness</span></div><div data-t="nathanmarz you can also change the condition of your  if-path  to  [:foo #(= :bar %)]"><span class="u" id="1481657686.000391">2016:12:13 19:34:46           nathanmarz </span><span>you can also change the condition of your </span><code>if-path</code><span> to </span><code>[:foo #(= :bar %)]</code></div><div data-t="souenzzo Hi,
 https://github.com/nathanmarz/specter/issues/117 
 (setval [ALL even?] NONE [1 2 3 4])
;; =&gt; [1 3]
 
Is there any way to do this in 0.12?"><span class="u" id="1482157303.000611">2016:12:19 14:21:43             souenzzo </span><span>Hi,
</span><a href="https://github.com/nathanmarz/specter/issues/117">https://github.com/nathanmarz/specter/issues/117</a><span>
</span><pre>(setval [ALL even?] NONE [1 2 3 4])
;; =&gt; [1 3]
</pre><span>
Is there any way to do this in 0.12?</span></div><div data-t="nathanmarz @souenzzo no, that issue isn&apos;t implemented"><span class="u" id="1482157685.000614">2016:12:19 14:28:05           nathanmarz </span><span>@souenzzo no, that issue isn&apos;t implemented</span></div><div data-t="nathanmarz you could always make your own version of ALL that has that functionality"><span class="u" id="1482157701.000615">2016:12:19 14:28:21           nathanmarz </span><span>you could always make your own version of ALL that has that functionality</span></div><div data-t="nathanmarz Specter 0.13.2 released (bug fixes)  https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><span class="u" id="1482347486.000697">2016:12:21 19:11:26           nathanmarz </span><span>Specter 0.13.2 released (bug fixes) </span><a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></div><div data-t="nathanmarz next release will probably be 1.0"><span class="u" id="1482347495.000699">2016:12:21 19:11:35           nathanmarz </span><span>next release will probably be 1.0</span></div><div data-t="stephenmhopper I&apos;m brand new to Specter, but I have a very simple task that I need to perform that I believe will be easy with Specter. I&apos;m just not sure how to do it. I have a Clojure map and a function. I want to apply that function to the value at a given key any time that key appears in the map or any of the child maps. Does that make sense? How would I do that?"><span class="u" id="1482865023.000896">2016:12:27 18:57:03       stephenmhopper </span><span>I&apos;m brand new to Specter, but I have a very simple task that I need to perform that I believe will be easy with Specter. I&apos;m just not sure how to do it. I have a Clojure map and a function. I want to apply that function to the value at a given key any time that key appears in the map or any of the child maps. Does that make sense? How would I do that?</span></div><div data-t="nathanmarz @stephenmhopper it&apos;s a recursive map?"><span class="u" id="1482865076.000897">2016:12:27 18:57:56           nathanmarz </span><span>@stephenmhopper it&apos;s a recursive map?</span></div><div data-t="stephenmhopper yep"><span class="u" id="1482865085.000898">2016:12:27 18:58:05       stephenmhopper </span><span>yep</span></div><div data-t="nathanmarz @stephenmhopper here&apos;s an example
 (let [all-maps (recursive-path [] p (continue-then-stay MAP-VALS map? p))]
  (transform [all-maps (must &quot;mykey&quot;)] inc {&quot;mykey&quot; 1 :b {:a 2 :c {&quot;mykey&quot; 2}}})
  )
"><span class="u" id="1482865349.000899">2016:12:27 19:02:29           nathanmarz </span><span>@stephenmhopper here&apos;s an example
</span><pre>(let [all-maps (recursive-path [] p (continue-then-stay MAP-VALS map? p))]
  (transform [all-maps (must &quot;mykey&quot;)] inc {&quot;mykey&quot; 1 :b {:a 2 :c {&quot;mykey&quot; 2}}})
  )
</pre></div><div data-t="stephenmhopper Cool. That works. Thank you! Now I&apos;m going to go read the docs (again) and I&apos;ll be back with questions"><span class="u" id="1482865507.000900">2016:12:27 19:05:07       stephenmhopper </span><span>Cool. That works. Thank you! Now I&apos;m going to go read the docs (again) and I&apos;ll be back with questions</span></div><div data-t="stephenmhopper Okay, I think I understand this.  (recursive-path [] p (continue-then-stay MAP-VALS map? p))  generates a navigator which steps through the parameter data structure, keeping only the values which are maps. It does this recursively and because order isn&apos;t really important here, we could use  stay-then-continue  interchangeably with  continue-then-stay .

This navigator is then combined with  (must &quot;mykey&quot;)  to (1) filter out maps which don&apos;t contain &quot;mykey&quot; and (2) expose the values associated with &quot;mykey&quot;.  inc  is then mapped across these values and the rest is easy.

Is that accurate?"><span class="u" id="1482868236.000902">2016:12:27 19:50:36       stephenmhopper </span><span>Okay, I think I understand this. </span><code>(recursive-path [] p (continue-then-stay MAP-VALS map? p))</code><span> generates a navigator which steps through the parameter data structure, keeping only the values which are maps. It does this recursively and because order isn&apos;t really important here, we could use </span><code>stay-then-continue</code><span> interchangeably with </span><code>continue-then-stay</code><span>.

This navigator is then combined with </span><code>(must &quot;mykey&quot;)</code><span> to (1) filter out maps which don&apos;t contain &quot;mykey&quot; and (2) expose the values associated with &quot;mykey&quot;. </span><code>inc</code><span> is then mapped across these values and the rest is easy.

Is that accurate?</span></div><div data-t="stephenmhopper @nathanmarz Stage 2: How do I update the previous example to also handle maps which are nested inside of sequences?"><span class="u" id="1482871742.000903">2016:12:27 20:49:02       stephenmhopper </span><span>@nathanmarz Stage 2: How do I update the previous example to also handle maps which are nested inside of sequences?</span></div><div data-t="stephenmhopper nvmd on Stage 2. I figured it out"><span class="u" id="1482873366.000904">2016:12:27 21:16:06       stephenmhopper </span><span>nvmd on Stage 2. I figured it out</span></div><div data-t="nathanmarz @stephenmhopper yes, in this case  continue-then-stay  can be used interchangeably with  stay-then-continue"><span class="u" id="1482873607.000905">2016:12:27 21:20:07           nathanmarz </span><span>@stephenmhopper yes, in this case </span><code>continue-then-stay</code><span> can be used interchangeably with </span><code>stay-then-continue</code></div><div data-t="narkisr Hey, looking for a way of selecting items from a Vector using Specter (like srange but for any index), couldn&apos;t find a way of doing: (select [ALL &lt;?&gt;]  [[1 2 3 4 5] [1 2 3  6 7]]) -&gt; [[2 5] [2 7]]"><span class="u" id="1482976318.000931">2016:12:29 01:51:58              narkisr </span><span>Hey, looking for a way of selecting items from a Vector using Specter (like srange but for any index), couldn&apos;t find a way of doing: (select [ALL &lt;?&gt;]  [[1 2 3 4 5] [1 2 3  6 7]]) -&gt; [[2 5] [2 7]]</span></div><div data-t="narkisr There is multi-path"><span class="u" id="1482976322.000932">2016:12:29 01:52:02              narkisr </span><span>There is multi-path</span></div><div data-t="narkisr (select [ALL (multi-path (keypath 1) (keypath 4)) ] rs)"><span class="u" id="1482976332.000933">2016:12:29 01:52:12              narkisr </span><span>(select [ALL (multi-path (keypath 1) (keypath 4)) ] rs)</span></div><div data-t="narkisr but it flattens out the result"><span class="u" id="1482976340.000934">2016:12:29 01:52:20              narkisr </span><span>but it flattens out the result</span></div><div data-t="narkisr [2 5 2 7]

["><span class="u" id="1482976347.000935">2016:12:29 01:52:27              narkisr </span><span>[2 5 2 7]

[</span></div><div data-t="narkisr A possible solution might be to use: (transform [ALL (s/collect-one (keypath 0) ) (s/collect-one (keypath 1) )] (fn [a b c] [a b]) rs) which feels a bit akward (I would like to have the ability so select neste sub vectors)"><span class="u" id="1482976354.000936">2016:12:29 01:52:34              narkisr </span><span>A possible solution might be to use: (transform [ALL (s/collect-one (keypath 0) ) (s/collect-one (keypath 1) )] (fn [a b c] [a b]) rs) which feels a bit akward (I would like to have the ability so select neste sub vectors)</span></div><div data-t="nathanmarz @narkisr you can use  subselect"><span class="u" id="1482976551.000937">2016:12:29 01:55:51           nathanmarz </span><span>@narkisr you can use </span><code>subselect</code></div><div data-t="nathanmarz subselect  +  multi-path  should get you the behavior you want"><span class="u" id="1482976594.000938">2016:12:29 01:56:34           nathanmarz </span><code>subselect</code><span> + </span><code>multi-path</code><span> should get you the behavior you want</span></div><div data-t="narkisr Ok, thanks! ill try to use them"><span class="u" id="1482976612.000939">2016:12:29 01:56:52              narkisr </span><span>Ok, thanks! ill try to use them</span></div><div data-t="nathanmarz (select [ALL (subselect (multi-path (keypath 1) (keypath 4)))] [[1 2 3 4 5] [1 2 3 6 7]])"><span class="u" id="1482976703.000940">2016:12:29 01:58:23           nathanmarz </span><code>(select [ALL (subselect (multi-path (keypath 1) (keypath 4)))] [[1 2 3 4 5] [1 2 3 6 7]])</code></div><div data-t="narkisr Got it"><span class="u" id="1482976714.000941">2016:12:29 01:58:34              narkisr </span><span>Got it</span></div><div data-t="narkisr BTW is there any reason why indices are not treated like map keys? (since both access assosciative DS)"><span class="u" id="1482976838.000942">2016:12:29 02:00:38              narkisr </span><span>BTW is there any reason why indices are not treated like map keys? (since both access assosciative DS)</span></div><div data-t="narkisr You need to wrap them using keypath"><span class="u" id="1482976852.000943">2016:12:29 02:00:52              narkisr </span><span>You need to wrap them using keypath</span></div><div data-t="nathanmarz I just stuck with implementing implicit behavior that&apos;s analogous to what clojure already treats as functions"><span class="u" id="1483021923.000956">2016:12:29 14:32:03           nathanmarz </span><span>I just stuck with implementing implicit behavior that&apos;s analogous to what clojure already treats as functions</span></div><div data-t="nathanmarz @narkisr namely keywords and sets"><span class="u" id="1483021931.000957">2016:12:29 14:32:11           nathanmarz </span><span>@narkisr namely keywords and sets</span></div><div data-t="nathanmarz you could always implement that yourself if you want it, see  ImplicitNav"><span class="u" id="1483021951.000958">2016:12:29 14:32:31           nathanmarz </span><span>you could always implement that yourself if you want it, see </span><code>ImplicitNav</code></div><div data-t="narkisr Got it, thanks"><span class="u" id="1483027903.000966">2016:12:29 16:11:43              narkisr </span><span>Got it, thanks</span></div><div data-t="zmaril Hello! Happy New Year&apos;s! I have some instaparse output in enlive format (will paste example shortly). I&apos;m trying to walk the tree and transform all the maps to include their metadata explicitly. I&apos;ve tried a few things without success and am currently experimenting with recursive-path."><span class="u" id="1483213143.001005">2016:12:31 19:39:03               zmaril </span><span>Hello! Happy New Year&apos;s! I have some instaparse output in enlive format (will paste example shortly). I&apos;m trying to walk the tree and transform all the maps to include their metadata explicitly. I&apos;ve tried a few things without success and am currently experimenting with recursive-path.</span></div><div data-t="nathanmarz @zmaril if you have some examples can help you through it"><span class="u" id="1483217076.001012">2016:12:31 20:44:36           nathanmarz </span><span>@zmaril if you have some examples can help you through it</span></div><div data-t="nathanmarz @zmaril cool, seems pretty straightforward"><span class="u" id="1483219093.001014">2016:12:31 21:18:13           nathanmarz </span><span>@zmaril cool, seems pretty straightforward</span></div><div data-t="zmaril yeah I guess I thought something like recursive-path or the TreeWalker stuff would come in handy"><span class="u" id="1483219138.001015">2016:12:31 21:18:58               zmaril </span><span>yeah I guess I thought something like recursive-path or the TreeWalker stuff would come in handy</span></div><div data-t="nathanmarz @zmaril you could reframe it with recursive navigation"><span class="u" id="1483221923.001016">2016:12:31 22:05:23           nathanmarz </span><span>@zmaril you could reframe it with recursive navigation</span></div><div data-t="nathanmarz probably in conjunction with  multi-transform  since you&apos;re doing a few different changes throughout the tree"><span class="u" id="1483221947.001017">2016:12:31 22:05:47           nathanmarz </span><span>probably in conjunction with </span><code>multi-transform</code><span> since you&apos;re doing a few different changes throughout the tree</span></div><div data-t="zmaril Yeah I don&apos;t understand navigation quite yet, still eludes me. "><span class="u" id="1483223236.001018">2016:12:31 22:27:16               zmaril </span><span>Yeah I don&apos;t understand navigation quite yet, still eludes me. </span></div><div data-t="gdeer81 when you have a bunch of maps and you want to make all of the maps agree on a unit of measure you have to convert the value for one key to another and remove the old key like,  [{:place &quot;here&quot; :degrees-celsius 32} {:place &quot;there&quot; :degrees-faren 100}]  you have to do something like  (dissoc (assoc mymap  :degrees-celsius (f-&gt;c (:degrees-faren mymap)) :degrees-faren))  you could split that out into a general function that takes a key and a conversion function and my implementation probably isn&apos;t very idiomatic, but I&apos;m sure there is a way to do this in specter I just can&apos;t seem to quite get it"><span class="u" id="1483545745.001108">2017:01:04 16:02:25              gdeer81 </span><span>when you have a bunch of maps and you want to make all of the maps agree on a unit of measure you have to convert the value for one key to another and remove the old key like, </span><code>[{:place &quot;here&quot; :degrees-celsius 32} {:place &quot;there&quot; :degrees-faren 100}]</code><span> you have to do something like </span><code>(dissoc (assoc mymap  :degrees-celsius (f-&gt;c (:degrees-faren mymap)) :degrees-faren))</code><span> you could split that out into a general function that takes a key and a conversion function and my implementation probably isn&apos;t very idiomatic, but I&apos;m sure there is a way to do this in specter I just can&apos;t seem to quite get it</span></div><div data-t="gdeer81 it&apos;s such a common thing I&apos;m sure someone has a recipe for this kind of transform"><span class="u" id="1483545893.001109">2017:01:04 16:04:53              gdeer81 </span><span>it&apos;s such a common thing I&apos;m sure someone has a recipe for this kind of transform</span></div><div data-t="schmee hello! I’m trying to figure out how to annotate the depth of a tree with specter"><span class="u" id="1483549461.001111">2017:01:04 17:04:21               schmee </span><span>hello! I’m trying to figure out how to annotate the depth of a tree with specter</span></div><div data-t="schmee so something like
 (= (depth-counter [:a [:b [:d] [:e]] [:c [:f]]])
   [{:val :a :depth 0}
    [{:val :b :depth 1}
      [{:val :d :depth 2}]
      [{:val :e :depth 2}]]
    [{:val :c :depth 1}
      [{:val :c :depth 2}]]])
"><span class="u" id="1483549479.001112">2017:01:04 17:04:39               schmee </span><span>so something like
</span><pre>(= (depth-counter [:a [:b [:d] [:e]] [:c [:f]]])
   [{:val :a :depth 0}
    [{:val :b :depth 1}
      [{:val :d :depth 2}]
      [{:val :e :depth 2}]]
    [{:val :c :depth 1}
      [{:val :c :depth 2}]]])
</pre></div><div data-t="schmee looking at the readme I don’t see any immediate way to carry state when navigating, but I’m sure I just haven’t figured out how yet  🙂"><span class="u" id="1483549528.001113">2017:01:04 17:05:28               schmee </span><span>looking at the readme I don’t see any immediate way to carry state when navigating, but I’m sure I just haven’t figured out how yet </span><b>🙂</b></div><div data-t="schmee or wait,  collect  seems like something..."><span class="u" id="1483549628.001114">2017:01:04 17:07:08               schmee </span><span>or wait, </span><code>collect</code><span> seems like something...</span></div><div data-t="nathanmarz @gdeer81 you could make a navigator that navigates to the k/v pair and replaces it with a new k/v pair"><span class="u" id="1483549639.001115">2017:01:04 17:07:19           nathanmarz </span><span>@gdeer81 you could make a navigator that navigates to the k/v pair and replaces it with a new k/v pair</span></div><div data-t="nathanmarz so something like  (transform (kvpair :degrees-faren) (fn [[_ v]] [:degrees-celsius (k-&gt;c v)]))"><span class="u" id="1483549724.001116">2017:01:04 17:08:44           nathanmarz </span><span>so something like </span><code>(transform (kvpair :degrees-faren) (fn [[_ v]] [:degrees-celsius (k-&gt;c v)]))</code></div><div data-t="nathanmarz @schmee yea you should be able to just collect nodes as you go, and then use the count of the collected values list to annotate the depth"><span class="u" id="1483549782.001117">2017:01:04 17:09:42           nathanmarz </span><span>@schmee yea you should be able to just collect nodes as you go, and then use the count of the collected values list to annotate the depth</span></div><div data-t="nathanmarz @schmee 
 (def data [:a [:b [:d] [:e]] [:c [:f]]])

(def TreeWalker
  (recursive-path [] p
    (stay-then-continue
      VAL
      (if-path vector?
        [ALL p]))))
        
(transform [TreeWalker (complement vector?)]
  (fn [&amp; vals]
    {:depth (- (count vals) 2)
     :val (last vals)})
  data)
"><span class="u" id="1483550126.001118">2017:01:04 17:15:26           nathanmarz </span><span>@schmee 
</span><pre>(def data [:a [:b [:d] [:e]] [:c [:f]]])

(def TreeWalker
  (recursive-path [] p
    (stay-then-continue
      VAL
      (if-path vector?
        [ALL p]))))
        
(transform [TreeWalker (complement vector?)]
  (fn [&amp; vals]
    {:depth (- (count vals) 2)
     :val (last vals)})
  data)
</pre></div><div data-t="gdeer81 so the naming convention is unparameterized navigators are in all caps else it follows regular function naming conventions?"><span class="u" id="1483550574.001119">2017:01:04 17:22:54              gdeer81 </span><span>so the naming convention is unparameterized navigators are in all caps else it follows regular function naming conventions?</span></div><div data-t="nathanmarz yea"><span class="u" id="1483550759.001120">2017:01:04 17:25:59           nathanmarz </span><span>yea</span></div><div data-t="schmee nathanmarz thank you so much for that example!"><span class="u" id="1483551009.001121">2017:01:04 17:30:09               schmee </span><span>nathanmarz thank you so much for that example!</span></div><div data-t="schmee I’m just trying out Specter for the first time and this stuff is blowing my mind already!"><span class="u" id="1483551025.001122">2017:01:04 17:30:25               schmee </span><span>I’m just trying out Specter for the first time and this stuff is blowing my mind already!</span></div><div data-t="schmee such a breath of fresh air after dealing with zippers  😛"><span class="u" id="1483551045.001123">2017:01:04 17:30:45               schmee </span><span>such a breath of fresh air after dealing with zippers </span><b>😛</b></div><div data-t="nathanmarz thanks"><span class="u" id="1483551315.001124">2017:01:04 17:35:15           nathanmarz </span><span>thanks</span></div><div data-t="nathanmarz zippers are still useful but not for the majority of use cases"><span class="u" id="1483551349.001125">2017:01:04 17:35:49           nathanmarz </span><span>zippers are still useful but not for the majority of use cases</span></div><div data-t="nathanmarz (zippers are integrated with specter in com.rpl.specter.zipper)"><span class="u" id="1483551359.001126">2017:01:04 17:35:59           nathanmarz </span><span>(zippers are integrated with specter in com.rpl.specter.zipper)</span></div><div data-t="schmee am I correct in thinking that  recursive-path  is just a shorthand for declarepath + providepath?"><span class="u" id="1483551482.001127">2017:01:04 17:38:02               schmee </span><span>am I correct in thinking that </span><code>recursive-path</code><span> is just a shorthand for declarepath + providepath?</span></div><div data-t="schmee (there are no docs for that macro)"><span class="u" id="1483551489.001128">2017:01:04 17:38:09               schmee </span><span>(there are no docs for that macro)</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L80"><span class="u" id="1483551532.001129">2017:01:04 17:38:52           nathanmarz </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L80">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L80</a></div><div data-t="nathanmarz local-declarepath  +  providepath"><span class="u" id="1483551541.001131">2017:01:04 17:39:01           nathanmarz </span><code>local-declarepath</code><span> + </span><code>providepath</code></div><div data-t="schmee :+1:"><span class="u" id="1483551700.001132">2017:01:04 17:41:40               schmee </span><b>:+1:</b></div><div data-t="gdeer81 @nathanmarz if I write this kvpair navigator do you think it would be useful to add to specter or is it too specific to this one use case? I remember you saying in your talk that most of the functionality that is in specter is from your specific needs so"><span class="u" id="1483553714.001133">2017:01:04 18:15:14              gdeer81 </span><span>@nathanmarz if I write this kvpair navigator do you think it would be useful to add to specter or is it too specific to this one use case? I remember you saying in your talk that most of the functionality that is in specter is from your specific needs so</span></div><div data-t="nathanmarz @gdeer81 doesn&apos;t seem common enough to add to the core"><span class="u" id="1483553746.001134">2017:01:04 18:15:46           nathanmarz </span><span>@gdeer81 doesn&apos;t seem common enough to add to the core</span></div><div data-t="gdeer81 okay then I guess it will just end up in a gist and if someone needs it, it will show up in their google results  😆"><span class="u" id="1483553876.001135">2017:01:04 18:17:56              gdeer81 </span><span>okay then I guess it will just end up in a gist and if someone needs it, it will show up in their google results </span><b>😆</b></div><div data-t="gdeer81 Okay, so specter is good for ETL, but what about analytics? like  {:usa-census [{:state &quot;Texas&quot; :population 20000000} {:state &quot;California&quot; :population 40000000} ...}] :mexico-census  [{:state &quot;Coahuila&quot; :population 200000} {:state &quot;Mexico City&quot; :population 20000000} ...]}  transformed into  {:us-total-pop 3241118787 :mexico-total-pop 128632004 ...}"><span class="u" id="1483555036.001136">2017:01:04 18:37:16              gdeer81 </span><span>Okay, so specter is good for ETL, but what about analytics? like </span><code>{:usa-census [{:state &quot;Texas&quot; :population 20000000} {:state &quot;California&quot; :population 40000000} ...}] :mexico-census  [{:state &quot;Coahuila&quot; :population 200000} {:state &quot;Mexico City&quot; :population 20000000} ...]}</code><span> transformed into </span><code>{:us-total-pop 3241118787 :mexico-total-pop 128632004 ...}</code></div><div data-t="gdeer81 basically a collection of maps and you aggregate on one of the keys"><span class="u" id="1483555083.001138">2017:01:04 18:38:03              gdeer81 </span><span>basically a collection of maps and you aggregate on one of the keys</span></div><div data-t="gdeer81 The Clojure that I have for this looks really gnarly"><span class="u" id="1483555113.001139">2017:01:04 18:38:33              gdeer81 </span><span>The Clojure that I have for this looks really gnarly</span></div><div data-t="nathanmarz that&apos;s outside the scope of specter"><span class="u" id="1483555213.001140">2017:01:04 18:40:13           nathanmarz </span><span>that&apos;s outside the scope of specter</span></div><div data-t="gdeer81 I guess I could write a function that uses specter to collect the values for each key I&apos;m aggregating"><span class="u" id="1483555543.001141">2017:01:04 18:45:43              gdeer81 </span><span>I guess I could write a function that uses specter to collect the values for each key I&apos;m aggregating</span></div><div data-t="schmee how can I transform every nth element of a collection?"><span class="u" id="1483600336.001148">2017:01:05 07:12:16               schmee </span><span>how can I transform every nth element of a collection?</span></div><div data-t="schmee I’ve tried various combinations of  map-indexed  but then I’m back to the ‘reconstruct the right type’ problem"><span class="u" id="1483600399.001149">2017:01:05 07:13:19               schmee </span><span>I’ve tried various combinations of </span><code>map-indexed</code><span> but then I’m back to the ‘reconstruct the right type’ problem</span></div><div data-t="schmee if I had a version of  collected?  that also gave you the current element, I guess something like this would work:
 (sr/transform [(sr/collect sr/ALL) sr/ALL (sr/collected-with-current? [collected current] (= 0 (mod (.indexOf collected current) n)))] f (range 10))"><span class="u" id="1483600672.001150">2017:01:05 07:17:52               schmee </span><span>if I had a version of </span><code>collected?</code><span> that also gave you the current element, I guess something like this would work:
</span><pre>(sr/transform [(sr/collect sr/ALL) sr/ALL (sr/collected-with-current? [collected current] (= 0 (mod (.indexOf collected current) n)))] f (range 10))</pre></div><div data-t="nathanmarz @schmee you would either need zippers for that or a custom navigator"><span class="u" id="1483602926.001151">2017:01:05 07:55:26           nathanmarz </span><span>@schmee you would either need zippers for that or a custom navigator</span></div><div data-t="nathanmarz zippers are integrated with specter in com.rpl.specter.zipper"><span class="u" id="1483602936.001152">2017:01:05 07:55:36           nathanmarz </span><span>zippers are integrated with specter in com.rpl.specter.zipper</span></div><div data-t="nathanmarz something like  ALL-INDEXED  which navigates to pair of  [index value]  should do the trick"><span class="u" id="1483603004.001153">2017:01:05 07:56:44           nathanmarz </span><span>something like </span><code>ALL-INDEXED</code><span> which navigates to pair of </span><code>[index value]</code><span> should do the trick</span></div><div data-t="schmee I’ll give the custom navigator a shot later today, thanks!"><span class="u" id="1483606324.001160">2017:01:05 08:52:04               schmee </span><span>I’ll give the custom navigator a shot later today, thanks!</span></div><div data-t="wei I’m confused with the result of  (sp/walker sequential?)   (sm/select (sp/walker sequential?) {:b [1 2 nil 3]}) =&gt; [[:b [1 2 nil 3]]]  I would have expected  [1 2 nil 3]"><span class="u" id="1483750819.001186">2017:01:07 01:00:19                  wei </span><span>I’m confused with the result of </span><code>(sp/walker sequential?)</code><span> </span><pre>(sm/select (sp/walker sequential?) {:b [1 2 nil 3]}) =&gt; [[:b [1 2 nil 3]]]</pre><span> I would have expected </span><code>[1 2 nil 3]</code></div><div data-t="wei as a followup question, what would be the specter-y way to remove nils from sequences?"><span class="u" id="1483750884.001187">2017:01:07 01:01:24                  wei </span><span>as a followup question, what would be the specter-y way to remove nils from sequences?</span></div><div data-t="nathanmarz @wei looks like clojure.walk navigates to the key/value pairs of maps, which it considers sequences"><span class="u" id="1483753871.001188">2017:01:07 01:51:11           nathanmarz </span><span>@wei looks like clojure.walk navigates to the key/value pairs of maps, which it considers sequences</span></div><div data-t="nathanmarz for removing nils, use com.rpl.specter.zipper"><span class="u" id="1483753888.001189">2017:01:07 01:51:28           nathanmarz </span><span>for removing nils, use com.rpl.specter.zipper</span></div><div data-t="nathanmarz or navigate to the sequence and use  filter"><span class="u" id="1483753908.001190">2017:01:07 01:51:48           nathanmarz </span><span>or navigate to the sequence and use </span><code>filter</code></div><div data-t="nathanmarz if  https://github.com/nathanmarz/specter/issues/117  is implemented will be able to do  (setval [ALL nil?] NONE data)"><span class="u" id="1483753951.001191">2017:01:07 01:52:31           nathanmarz </span><span>if </span><a href="https://github.com/nathanmarz/specter/issues/117">https://github.com/nathanmarz/specter/issues/117</a><span> is implemented will be able to do </span><code>(setval [ALL nil?] NONE data)</code></div><div data-t="wei @nathanmarz thanks for the tips. can zipper remove all nils an a nested structure? having some trouble putting it together"><span class="u" id="1483825022.001215">2017:01:07 21:37:02                  wei </span><span>@nathanmarz thanks for the tips. can zipper remove all nils an a nested structure? having some trouble putting it together</span></div><div data-t="nathanmarz @wei like this:  (setval [z/VECTOR-ZIP z/DOWN z/RIGHT z/NODE-SEQ] [] [1 2 3 4])"><span class="u" id="1483825775.001216">2017:01:07 21:49:35           nathanmarz </span><span>@wei like this: </span><code>(setval [z/VECTOR-ZIP z/DOWN z/RIGHT z/NODE-SEQ] [] [1 2 3 4])</code></div><div data-t="nathanmarz @wei removing nils:  (setval [z/VECTOR-ZIP z/DOWN z/NEXT-WALK (selected? z/NODE nil?) z/NODE-SEQ] [] [1 2 nil 3 nil])"><span class="u" id="1483825924.001217">2017:01:07 21:52:04           nathanmarz </span><span>@wei removing nils: </span><code>(setval [z/VECTOR-ZIP z/DOWN z/NEXT-WALK (selected? z/NODE nil?) z/NODE-SEQ] [] [1 2 nil 3 nil])</code></div><div data-t="nathanmarz obviously the approach in #117 would be more elegant as well as more performant"><span class="u" id="1483825984.001218">2017:01:07 21:53:04           nathanmarz </span><span>obviously the approach in #117 would be more elegant as well as more performant</span></div><div data-t="nathanmarz added ability to remove values in 0.13.3-SNAPSHOT (on clojars)"><span class="u" id="1483926306.001237">2017:01:09 01:45:06           nathanmarz </span><span>added ability to remove values in 0.13.3-SNAPSHOT (on clojars)</span></div><div data-t="nathanmarz e.g.  (setval [ALL nil?] NONE [1 2 nil 3 nil])  =&gt;  [1 2 3]"><span class="u" id="1483926328.001238">2017:01:09 01:45:28           nathanmarz </span><span>e.g. </span><code>(setval [ALL nil?] NONE [1 2 nil 3 nil])</code><span> =&gt; </span><code>[1 2 3]</code></div><div data-t="nathanmarz and  (setval [:a :b] NONE {:a {:b 1 :c 2}})  =&gt;  {:a {:c 2}}"><span class="u" id="1483926369.001239">2017:01:09 01:46:09           nathanmarz </span><span>and </span><code>(setval [:a :b] NONE {:a {:b 1 :c 2}})</code><span> =&gt; </span><code>{:a {:c 2}}</code></div><div data-t="richiardiandrea maybe FAQ  🙂  is there a way in specter to stop to the first  MAP-VALS , without further going deep in a map for instance?"><span class="u" id="1484007433.001258">2017:01:10 00:17:13      richiardiandrea </span><span>maybe FAQ </span><b>🙂</b><span> is there a way in specter to stop to the first </span><code>MAP-VALS</code><span>, without further going deep in a map for instance?</span></div><div data-t="qqq is there a way to avoid the all caps? On a kinesis advantage pro keyboard, typing all caps is quite annoying"><span class="u" id="1484007620.001260">2017:01:10 00:20:20                  qqq </span><span>is there a way to avoid the all caps? On a kinesis advantage pro keyboard, typing all caps is quite annoying</span></div><div data-t="nathanmarz @qqq you can do  (def my-all ALL)  if you want"><span class="u" id="1484008314.001261">2017:01:10 00:31:54           nathanmarz </span><span>@qqq you can do </span><code>(def my-all ALL)</code><span> if you want</span></div><div data-t="qqq yeah, I my have to"><span class="u" id="1484008335.001262">2017:01:10 00:32:15                  qqq </span><span>yeah, I my have to</span></div><div data-t="qqq MAP_VALS is really awkward on the kinesis"><span class="u" id="1484008342.001263">2017:01:10 00:32:22                  qqq </span><span>MAP_VALS is really awkward on the kinesis</span></div><div data-t="nathanmarz @richiardiandrea no, not at the moment"><span class="u" id="1484008355.001264">2017:01:10 00:32:35           nathanmarz </span><span>@richiardiandrea no, not at the moment</span></div><div data-t="qqq I guess you can&apos;t use :all or :map-vals since you&apos;re using kws for kw selector functions"><span class="u" id="1484008366.001265">2017:01:10 00:32:46                  qqq </span><span>I guess you can&apos;t use :all or :map-vals since you&apos;re using kws for kw selector functions</span></div><div data-t="nathanmarz keywords extend  ImplicitNav  in order to wrap themselves in  keypath"><span class="u" id="1484008416.001266">2017:01:10 00:33:36           nathanmarz </span><span>keywords extend </span><code>ImplicitNav</code><span> in order to wrap themselves in </span><code>keypath</code></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L896"><span class="u" id="1484008432.001267">2017:01:10 00:33:52           nathanmarz </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L896">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L896</a></div><div data-t="nathanmarz @richiardiandrea fyi, there are some ideas about supporting that in the future though:  https://github.com/nathanmarz/specter/issues/125"><span class="u" id="1484008862.001269">2017:01:10 00:41:02           nathanmarz </span><span>@richiardiandrea fyi, there are some ideas about supporting that in the future though: </span><a href="https://github.com/nathanmarz/specter/issues/125">https://github.com/nathanmarz/specter/issues/125</a></div><div data-t="richiardiandrea oh cool, for a moment I though I could use  STOP  for it"><span class="u" id="1484008915.001271">2017:01:10 00:41:55      richiardiandrea </span><span>oh cool, for a moment I though I could use </span><code>STOP</code><span> for it</span></div><div data-t="richiardiandrea btw I tried  0.13.3-SNAPSHOT  and the  NONE  syntax works here, but because it navigates deeply in the data, it is still something different from what I was thinking"><span class="u" id="1484008963.001272">2017:01:10 00:42:43      richiardiandrea </span><span>btw I tried </span><code>0.13.3-SNAPSHOT</code><span> and the </span><code>NONE</code><span> syntax works here, but because it navigates deeply in the data, it is still something different from what I was thinking</span></div><div data-t="nathanmarz what do you mean?"><span class="u" id="1484008990.001273">2017:01:10 00:43:10           nathanmarz </span><span>what do you mean?</span></div><div data-t="nathanmarz example?"><span class="u" id="1484008996.001274">2017:01:10 00:43:16           nathanmarz </span><span>example?</span></div><div data-t="richiardiandrea uhm...no ok I lost it, I tried another example but it works fine, give a couple of minutes  😄"><span class="u" id="1484009202.001275">2017:01:10 00:46:42      richiardiandrea </span><span>uhm...no ok I lost it, I tried another example but it works fine, give a couple of minutes </span><b>😄</b></div><div data-t="richiardiandrea uhm (2), I tried again what I had in mind and it works fine..."><span class="u" id="1484009276.001276">2017:01:10 00:47:56      richiardiandrea </span><span>uhm (2), I tried again what I had in mind and it works fine...</span></div><div data-t="richiardiandrea It was  (sp/setval [sp/MAP-VALS #(map? %)] sp/NONE {:a 3 :b 5 :c {:d 5}})"><span class="u" id="1484009289.001277">2017:01:10 00:48:09      richiardiandrea </span><span>It was </span><code>(sp/setval [sp/MAP-VALS #(map? %)] sp/NONE {:a 3 :b 5 :c {:d 5}})</code></div><div data-t="richiardiandrea very convenient btw  :+1:"><span class="u" id="1484009353.001278">2017:01:10 00:49:13      richiardiandrea </span><span>very convenient btw </span><b>:+1:</b></div><div data-t="richiardiandrea @nathanmarz every time I turn to Specter for data manipulation, I surprise myself with the simplicity of the result, thanks:
 (sp/transform [(sp/collect-one [:family (sp/submap [:name :description])])
                                             :family
                                             (sp/submap [:resource :relationship])
                                             sp/MAP-VALS
                                             sp/ALL]
                                            (fn [family m]
                                              (assoc m :family family)) 
                                 (first families))
"><span class="u" id="1484010320.001279">2017:01:10 01:05:20      richiardiandrea </span><span>@nathanmarz every time I turn to Specter for data manipulation, I surprise myself with the simplicity of the result, thanks:
</span><pre>(sp/transform [(sp/collect-one [:family (sp/submap [:name :description])])
                                             :family
                                             (sp/submap [:resource :relationship])
                                             sp/MAP-VALS
                                             sp/ALL]
                                            (fn [family m]
                                              (assoc m :family family)) 
                                 (first families))
</pre></div><div data-t="richiardiandrea the collect feature is super neat"><span class="u" id="1484010335.001280">2017:01:10 01:05:35      richiardiandrea </span><span>the collect feature is super neat</span></div><div data-t="nathanmarz yea I use that feature quite a bit"><span class="u" id="1484010519.001282">2017:01:10 01:08:39           nathanmarz </span><span>yea I use that feature quite a bit</span></div><div data-t="richiardiandrea I wanted basically to avoid using a  submap  with keys there"><span class="u" id="1484010558.001283">2017:01:10 01:09:18      richiardiandrea </span><span>I wanted basically to avoid using a </span><code>submap</code><span> with keys there</span></div><div data-t="richiardiandrea so that I can assoc to all the key-values where the value is a map"><span class="u" id="1484010593.001284">2017:01:10 01:09:53      richiardiandrea </span><span>so that I can assoc to all the key-values where the value is a map</span></div><div data-t="richiardiandrea oh ok wow done  😉"><span class="u" id="1484010912.001285">2017:01:10 01:15:12      richiardiandrea </span><span>oh ok wow done </span><b>😉</b></div><div data-t="richiardiandrea (defn propagate-family
  [family]
  (sp/transform [(sp/collect-one [:family (sp/submap [:name :description])])
                 :family
                 sp/MAP-VALS
                 #(vector? %)
                 sp/ALL]
                (fn [family m]
                  (assoc m :family family))
                family))
"><span class="u" id="1484010970.001286">2017:01:10 01:16:10      richiardiandrea </span><pre>(defn propagate-family
  [family]
  (sp/transform [(sp/collect-one [:family (sp/submap [:name :description])])
                 :family
                 sp/MAP-VALS
                 #(vector? %)
                 sp/ALL]
                (fn [family m]
                  (assoc m :family family))
                family))
</pre></div><div data-t="bfabry omg people use like my only oss contribution ever, goosebumps  😄"><span class="u" id="1484017209.001287">2017:01:10 03:00:09               bfabry </span><span>omg people use like my only oss contribution ever, goosebumps </span><b>😄</b></div><div data-t="qqq https://stackoverflow.com/questions/39123457/how-to-use-specter-in-clojurescript  &lt;-- is using specter in cljs in figwheel still a problem? (I&apos;m having problems using specter in cljs, but not in clj, and I can&apos;t figure out why)"><span class="u" id="1484018838.001288">2017:01:10 03:27:18                  qqq </span><a href="https://stackoverflow.com/questions/39123457/how-to-use-specter-in-clojurescript">https://stackoverflow.com/questions/39123457/how-to-use-specter-in-clojurescript</a><span> &lt;-- is using specter in cljs in figwheel still a problem? (I&apos;m having problems using specter in cljs, but not in clj, and I can&apos;t figure out why)</span></div><div data-t="nathanmarz @qqq I&apos;ve only used it in Node myself"><span class="u" id="1484019288.001290">2017:01:10 03:34:48           nathanmarz </span><span>@qqq I&apos;ve only used it in Node myself</span></div><div data-t="nathanmarz what specific problem are you having?"><span class="u" id="1484019333.001291">2017:01:10 03:35:33           nathanmarz </span><span>what specific problem are you having?</span></div><div data-t="nathanmarz @richiardiandrea fyi you can write that in a simpler way like this:
 (defn propagate-family
  [family]
  (sp/transform [:family
                 (sp/collect-one (sp/submap [:name :description]))
                 sp/MAP-VALS
                 vector?
                 sp/ALL
                 :family]
                (fn [family _] family)
                family))
"><span class="u" id="1484019483.001292">2017:01:10 03:38:03           nathanmarz </span><span>@richiardiandrea fyi you can write that in a simpler way like this:
</span><pre>(defn propagate-family
  [family]
  (sp/transform [:family
                 (sp/collect-one (sp/submap [:name :description]))
                 sp/MAP-VALS
                 vector?
                 sp/ALL
                 :family]
                (fn [family _] family)
                family))
</pre></div><div data-t="richiardiandrea Thanks @nathanmarz, is  transform  acting like  update  then?"><span class="u" id="1484020819.001293">2017:01:10 04:00:19      richiardiandrea </span><span>Thanks @nathanmarz, is </span><code>transform</code><span> acting like </span><code>update</code><span> then?</span></div><div data-t="richiardiandrea Did not know that, even better  😄  "><span class="u" id="1484020856.001295">2017:01:10 04:00:56      richiardiandrea </span><span>Did not know that, even better </span><b>😄</b><span> </span></div><div data-t="qqq @nathanmarz: let me create a minimal failure care"><span class="u" id="1484021087.001296">2017:01:10 04:04:47                  qqq </span><span>@nathanmarz: let me create a minimal failure care</span></div><div data-t="qqq false alarm, I was requiring com.rpl/specter instead of com.rpl/specter"><span class="u" id="1484021320.001297">2017:01:10 04:08:40                  qqq </span><span>false alarm, I was requiring com.rpl/specter instead of com.rpl/specter</span></div><div data-t="nathanmarz @richiardiandrea yea it&apos;s like  update  on steroids"><span class="u" id="1484022014.001304">2017:01:10 04:20:14           nathanmarz </span><span>@richiardiandrea yea it&apos;s like </span><code>update</code><span> on steroids</span></div><div data-t="qqq @nathanmarz : from a newcomer perspective, it might help if at the very top of the README.md, there was a line to the effect of 

transform takes two functions, one to select items, one to update, and leaves everything else the samespe"><span class="u" id="1484022173.001305">2017:01:10 04:22:53                  qqq </span><span>@nathanmarz : from a newcomer perspective, it might help if at the very top of the README.md, there was a line to the effect of 

transform takes two functions, one to select items, one to update, and leaves everything else the samespe</span></div><div data-t="richiardiandrea Super!"><span class="u" id="1484022176.001306">2017:01:10 04:22:56      richiardiandrea </span><span>Super!</span></div><div data-t="nathanmarz yea the documentation could be a lot better"><span class="u" id="1484022251.001307">2017:01:10 04:24:11           nathanmarz </span><span>yea the documentation could be a lot better</span></div><div data-t="nathanmarz a good beginner tutorial would be great, but I don&apos;t have time for that now"><span class="u" id="1484022286.001308">2017:01:10 04:24:46           nathanmarz </span><span>a good beginner tutorial would be great, but I don&apos;t have time for that now</span></div><div data-t="nathanmarz would love documentation contributions"><span class="u" id="1484022295.001309">2017:01:10 04:24:55           nathanmarz </span><span>would love documentation contributions</span></div><div data-t="qqq lol"><span class="u" id="1484022303.001310">2017:01:10 04:25:03                  qqq </span><span>lol</span></div><div data-t="richiardiandrea @nathanmarz is there a more elegant way to do this:
 (defn normalize-family
  [family]
  (merge
   (sp/setval [sp/MAP-VALS string?] sp/NONE (:family family))
   (sp/transform [(sp/collect-one [:family (sp/submap [:name :description])])
                  :family]
                 (fn [family _] family)
                 family)))
"><span class="u" id="1484078939.001317">2017:01:10 20:08:59      richiardiandrea </span><span>@nathanmarz is there a more elegant way to do this:
</span><pre>(defn normalize-family
  [family]
  (merge
   (sp/setval [sp/MAP-VALS string?] sp/NONE (:family family))
   (sp/transform [(sp/collect-one [:family (sp/submap [:name :description])])
                  :family]
                 (fn [family _] family)
                 family)))
</pre></div><div data-t="richiardiandrea the initial shape is  {:family {:name &quot;art&quot; :desc &quot;sda&quot; :complex-map {....}}"><span class="u" id="1484078995.001318">2017:01:10 20:09:55      richiardiandrea </span><span>the initial shape is </span><code>{:family {:name &quot;art&quot; :desc &quot;sda&quot; :complex-map {....}}</code></div><div data-t="richiardiandrea and I basically want to transform it into  {:family {:name &quot;art&quot; :desc &quot;sda&quot;} :complex-map {....}}"><span class="u" id="1484079025.001319">2017:01:10 20:10:25      richiardiandrea </span><span>and I basically want to transform it into </span><code>{:family {:name &quot;art&quot; :desc &quot;sda&quot;} :complex-map {....}}</code></div><div data-t="nathanmarz you just want to move :complex-map keypair into parent map?"><span class="u" id="1484079279.001327">2017:01:10 20:14:39           nathanmarz </span><span>you just want to move :complex-map keypair into parent map?</span></div><div data-t="richiardiandrea ah yes that&apos;s another way to see it  😄"><span class="u" id="1484079295.001328">2017:01:10 20:14:55      richiardiandrea </span><span>ah yes that&apos;s another way to see it </span><b>😄</b></div><div data-t="richiardiandrea but all the  :complex-map s, so everything that has not a  string?  value should go up"><span class="u" id="1484079330.001329">2017:01:10 20:15:30      richiardiandrea </span><span>but all the </span><code>:complex-map</code><span>s, so everything that has not a </span><code>string?</code><span> value should go up</span></div><div data-t="nathanmarz I think the way you&apos;re doing it is fine"><span class="u" id="1484079619.001330">2017:01:10 20:20:19           nathanmarz </span><span>I think the way you&apos;re doing it is fine</span></div><div data-t="richiardiandrea @nathanmarz cool then thanks!"><span class="u" id="1484080045.001331">2017:01:10 20:27:25      richiardiandrea </span><span>@nathanmarz cool then thanks!</span></div><div data-t="qqq in specter, is it possible for a update function to depend not only on the value, but also on the &quot;path&quot; down to the node ?"><span class="u" id="1484080943.001333">2017:01:10 20:42:23                  qqq </span><span>in specter, is it possible for a update function to depend not only on the value, but also on the &quot;path&quot; down to the node ?</span></div><div data-t="richiardiandrea @qqq I think there is a  https://github.com/nathanmarz/specter/wiki/List-of-Navigators#if-path  but I guess depends a lot on what you have in mind"><span class="u" id="1484081269.001334">2017:01:10 20:47:49      richiardiandrea </span><span>@qqq I think there is a </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#if-path">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#if-path</a><span> but I guess depends a lot on what you have in mind</span></div><div data-t="bfabry @qqq have you got a pseudo example?"><span class="u" id="1484081731.001337">2017:01:10 20:55:31               bfabry </span><span>@qqq have you got a pseudo example?</span></div><div data-t="richiardiandrea @qqq also  https://github.com/nathanmarz/specter/wiki/List-of-Macros#multi-transform"><span class="u" id="1484081769.001338">2017:01:10 20:56:09      richiardiandrea </span><span>@qqq also </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#multi-transform">https://github.com/nathanmarz/specter/wiki/List-of-Macros#multi-transform</a></div><div data-t="qqq {:a {:b [:apple :orange :pear]
     :c [:juice]}
 :e [:cat :dog]}

to

{:a {:b [[[:a :b 0] :apple]
         [[:a :b 1] :orange]
         [[:a :b 2] :pear]]
     :c [[[:a :c 0] :juice]]}
 :e [[[:e 0] :cat]
     [[:e 1] :dog]
     ]}
 
^^ can specter do the above transform ? I want to map over the leafs, and for each leaf, also store into it its &apos;path&apos;"><span class="u" id="1484081888.001340">2017:01:10 20:58:08                  qqq </span><pre>{:a {:b [:apple :orange :pear]
     :c [:juice]}
 :e [:cat :dog]}

to

{:a {:b [[[:a :b 0] :apple]
         [[:a :b 1] :orange]
         [[:a :b 2] :pear]]
     :c [[[:a :c 0] :juice]]}
 :e [[[:e 0] :cat]
     [[:e 1] :dog]
     ]}
</pre><span>
^^ can specter do the above transform ? I want to map over the leafs, and for each leaf, also store into it its &apos;path&apos;</span></div><div data-t="qqq @bfabry : ^^^"><span class="u" id="1484081894.001341">2017:01:10 20:58:14                  qqq </span><span>@bfabry : ^^^</span></div><div data-t="bfabry that&apos;s an interesting thought. what would you want to receive if it went through a navigator like a predicate? #(.startsWith % &quot;:or&quot;) or similar?"><span class="u" id="1484081998.001342">2017:01:10 20:59:58               bfabry </span><span>that&apos;s an interesting thought. what would you want to receive if it went through a navigator like a predicate? #(.startsWith % &quot;:or&quot;) or similar?</span></div><div data-t="qqq I never considered that case."><span class="u" id="1484082019.001343">2017:01:10 21:00:19                  qqq </span><span>I never considered that case.</span></div><div data-t="qqq Maybe this is not a right fit with specter, since specter is &quot;does more than indexing&quot;"><span class="u" id="1484082037.001344">2017:01:10 21:00:37                  qqq </span><span>Maybe this is not a right fit with specter, since specter is &quot;does more than indexing&quot;</span></div><div data-t="qqq In haskell, this is trivial with a &quot;reader monad&quot;"><span class="u" id="1484082048.001345">2017:01:10 21:00:48                  qqq </span><span>In haskell, this is trivial with a &quot;reader monad&quot;</span></div><div data-t="qqq not sure the right clojure solution"><span class="u" id="1484082055.001346">2017:01:10 21:00:55                  qqq </span><span>not sure the right clojure solution</span></div><div data-t="bfabry maybe zippers if your data is representable as a tree (which that is)"><span class="u" id="1484082278.001347">2017:01:10 21:04:38               bfabry </span><span>maybe zippers if your data is representable as a tree (which that is)</span></div><div data-t="nathanmarz @qqq you can collect values as you go"><span class="u" id="1484083633.001348">2017:01:10 21:27:13           nathanmarz </span><span>@qqq you can collect values as you go</span></div><div data-t="qqq nathanmarz: does this involve (1) making the &apos;update&apos; function impure&apos;, or (2) does specter support the reader monad?"><span class="u" id="1484083730.001349">2017:01:10 21:28:50                  qqq </span><span>nathanmarz: does this involve (1) making the &apos;update&apos; function impure&apos;, or (2) does specter support the reader monad?</span></div><div data-t="nathanmarz @qqq like this:
 (defnav ALL-INDEXED []
  (select* [this structure next-fn]
    ;; fill this in
    )
  (transform* [this structure next-fn]
    (map-indexed
      (fn [i v]
        (second (next-fn [i v])))
      structure
      )))


(def MyPath
  (recursive-path [] p
    (cond-path map? [ALL (collect-one FIRST) LAST p]
               vector? [ALL-INDEXED (collect-one FIRST) LAST p]
               STAY STAY)))

(transform MyPath
  (fn [&amp; vals] vals)
  {:a {:b [:apple :orange :pear]
   :c [:juice]}
   :e [:cat :dog]})
"><span class="u" id="1484084386.001350">2017:01:10 21:39:46           nathanmarz </span><span>@qqq like this:
</span><pre>(defnav ALL-INDEXED []
  (select* [this structure next-fn]
    ;; fill this in
    )
  (transform* [this structure next-fn]
    (map-indexed
      (fn [i v]
        (second (next-fn [i v])))
      structure
      )))


(def MyPath
  (recursive-path [] p
    (cond-path map? [ALL (collect-one FIRST) LAST p]
               vector? [ALL-INDEXED (collect-one FIRST) LAST p]
               STAY STAY)))

(transform MyPath
  (fn [&amp; vals] vals)
  {:a {:b [:apple :orange :pear]
   :c [:juice]}
   :e [:cat :dog]})
</pre></div><div data-t="nathanmarz it&apos;s pure"><span class="u" id="1484084399.001351">2017:01:10 21:39:59           nathanmarz </span><span>it&apos;s pure</span></div><div data-t="nathanmarz more work is needed on  ALL-INDEXED  to make it preserve type (ala  ALL ), but that&apos;s the gist of it"><span class="u" id="1484084415.001352">2017:01:10 21:40:15           nathanmarz </span><span>more work is needed on </span><code>ALL-INDEXED</code><span> to make it preserve type (ala </span><code>ALL</code><span>), but that&apos;s the gist of it</span></div><div data-t="schmee (removed redudant answer cause slack was out of sync)"><span class="u" id="1484085145.001353">2017:01:10 21:52:25               schmee </span><span>(removed redudant answer cause slack was out of sync)</span></div><div data-t="schmee if I have a path like this, will it get cached automatically?"><span class="u" id="1484087121.001356">2017:01:10 22:25:21               schmee </span><span>if I have a path like this, will it get cached automatically?</span></div><div data-t="schmee (defn every-nth [n] [ALL-INDEXED (collect-one FIRST) (fn [[i _]] (= 0 (mod i n))) LAST])"><span class="u" id="1484087124.001357">2017:01:10 22:25:24               schmee </span><code>(defn every-nth [n] [ALL-INDEXED (collect-one FIRST) (fn [[i _]] (= 0 (mod i n))) LAST])</code></div><div data-t="schmee using your implementation of  ALL-INDEXED  above"><span class="u" id="1484087139.001358">2017:01:10 22:25:39               schmee </span><span>using your implementation of </span><code>ALL-INDEXED</code><span> above</span></div><div data-t="nathanmarz no"><span class="u" id="1484087234.001359">2017:01:10 22:27:14           nathanmarz </span><span>no</span></div><div data-t="nathanmarz just do this:
 (defn every-nth [n] (path ALL-INDEXED (collect-one FIRST) (fn [[i _]] (= 0 (mod i n))) LAST))
"><span class="u" id="1484087272.001360">2017:01:10 22:27:52           nathanmarz </span><span>just do this:
</span><pre>(defn every-nth [n] (path ALL-INDEXED (collect-one FIRST) (fn [[i _]] (= 0 (mod i n))) LAST))
</pre></div><div data-t="schmee ahh, gotcha"><span class="u" id="1484087299.001361">2017:01:10 22:28:19               schmee </span><span>ahh, gotcha</span></div><div data-t="nathanmarz path  implements all the inline caching stuff"><span class="u" id="1484087312.001362">2017:01:10 22:28:32           nathanmarz </span><code>path</code><span> implements all the inline caching stuff</span></div><div data-t="schmee also, the macros wiki page mentioned a  must-cache-paths!  fn, but it seems like that function is gone?"><span class="u" id="1484087357.001363">2017:01:10 22:29:17               schmee </span><span>also, the macros wiki page mentioned a </span><code>must-cache-paths!</code><span> fn, but it seems like that function is gone?</span></div><div data-t="nathanmarz yea that&apos;s gone as of 0.13.0"><span class="u" id="1484087378.001364">2017:01:10 22:29:38           nathanmarz </span><span>yea that&apos;s gone as of 0.13.0</span></div><div data-t="nathanmarz every path can be inline cached now"><span class="u" id="1484087399.001365">2017:01:10 22:29:59           nathanmarz </span><span>every path can be inline cached now</span></div><div data-t="schmee sweet  :+1:"><span class="u" id="1484087442.001366">2017:01:10 22:30:42               schmee </span><span>sweet </span><b>:+1:</b></div><div data-t="schmee it’s really a whole new paradigm to use Specter, I feel kinda lost just like I did when I went from imperative to functional programming"><span class="u" id="1484087500.001367">2017:01:10 22:31:40               schmee </span><span>it’s really a whole new paradigm to use Specter, I feel kinda lost just like I did when I went from imperative to functional programming</span></div><div data-t="schmee but I guess it will reveal itself in due time  🙂"><span class="u" id="1484087509.001368">2017:01:10 22:31:49               schmee </span><span>but I guess it will reveal itself in due time </span><b>🙂</b></div><div data-t="nathanmarz you&apos;ll get there"><span class="u" id="1484087552.001369">2017:01:10 22:32:32           nathanmarz </span><span>you&apos;ll get there</span></div><div data-t="nathanmarz eventually you&apos;ll wonder how you ever programmed without it"><span class="u" id="1484087559.001370">2017:01:10 22:32:39           nathanmarz </span><span>eventually you&apos;ll wonder how you ever programmed without it</span></div><div data-t="qqq what&apos;s a good letter to bind com.rpl.specter to , given that I already have s -&gt; clojure.spec ?"><span class="u" id="1484096646.001371">2017:01:11 01:04:06                  qqq </span><span>what&apos;s a good letter to bind com.rpl.specter to , given that I already have s -&gt; clojure.spec ?</span></div><div data-t="bfabry @qqq our convention is sp and I believe i&apos;ve seen it in other places"><span class="u" id="1484096925.001372">2017:01:11 01:08:45               bfabry </span><span>@qqq our convention is sp and I believe i&apos;ve seen it in other places</span></div><div data-t="qqq @bfabry : I was going to use &quot;dt&quot; for &quot;data&quot;, but &quot;sp&quot; makes more sense"><span class="u" id="1484097005.001373">2017:01:11 01:10:05                  qqq </span><span>@bfabry : I was going to use &quot;dt&quot; for &quot;data&quot;, but &quot;sp&quot; makes more sense</span></div><div data-t="bfabry quicker to type than dt on a qwerty keyboard  😛"><span class="u" id="1484097061.001374">2017:01:11 01:11:01               bfabry </span><span>quicker to type than dt on a qwerty keyboard </span><b>😛</b></div><div data-t="qqq it&apos;s unfortunate that spec / specter share such a long prefix"><span class="u" id="1484097105.001375">2017:01:11 01:11:45                  qqq </span><span>it&apos;s unfortunate that spec / specter share such a long prefix</span></div><div data-t="bfabry I guess yeah, though spec is in core so I think it&apos;s fair to just assume it will always get the bare &apos;s&apos;"><span class="u" id="1484097153.001376">2017:01:11 01:12:33               bfabry </span><span>I guess yeah, though spec is in core so I think it&apos;s fair to just assume it will always get the bare &apos;s&apos;</span></div><div data-t="richiardiandrea I second  sp  :)"><span class="u" id="1484100098.001377">2017:01:11 02:01:38      richiardiandrea </span><span>I second </span><code>sp</code><span> :)</span></div><div data-t="qqq @nathanmarz : between cascalog, elephantdb, and specter; you have the tools for &quot;manipulating large scale datasets&quot; -- any plans on a database of some sort down the line?"><span class="u" id="1484105651.001378">2017:01:11 03:34:11                  qqq </span><span>@nathanmarz : between cascalog, elephantdb, and specter; you have the tools for &quot;manipulating large scale datasets&quot; -- any plans on a database of some sort down the line?</span></div><div data-t="qqq https://github.com/nathanmarz/specter/search?utf8=%E2%9C%93&amp;amp;q=setval  &lt;-- where is setval defined?"><span class="u" id="1484106183.001379">2017:01:11 03:43:03                  qqq </span><a href="https://github.com/nathanmarz/specter/search?utf8=%E2%9C%93&amp;amp;q=setval">https://github.com/nathanmarz/specter/search?utf8=%E2%9C%93&amp;amp;q=setval</a><span> &lt;-- where is setval defined?</span></div><div data-t="qqq (m/pp (com.rpl.specter/setval [:a com.rpl.specter/ALL nil?] com.rpl.specter/NONE {:a [1 2 nil 3 nil]}))
is outputting:
{:a [1 2 :com.rpl.specter.impl/NONE 3 :com.rpl.specter.impl/NONE]}
 
what am I doing wrong?"><span class="u" id="1484106285.001382">2017:01:11 03:44:45                  qqq </span><pre>(m/pp (com.rpl.specter/setval [:a com.rpl.specter/ALL nil?] com.rpl.specter/NONE {:a [1 2 nil 3 nil]}))
is outputting:
{:a [1 2 :com.rpl.specter.impl/NONE 3 :com.rpl.specter.impl/NONE]}
</pre><span>
what am I doing wrong?</span></div><div data-t="qqq issue resolved -- I was on 0.12 instead of 0.13.3-snapshot"><span class="u" id="1484108948.001383">2017:01:11 04:29:08                  qqq </span><span>issue resolved -- I was on 0.12 instead of 0.13.3-snapshot</span></div><div data-t="nathanmarz @qqq no comment ;)"><span class="u" id="1484109409.001384">2017:01:11 04:36:49           nathanmarz </span><span>@qqq no comment ;)</span></div><div data-t="qqq @nathanmarz : what, if any, is the theoretical under pinning of specter?
in numpy, we can do something like:
a :: mxn float
b :: mxn bool
a [b] = ... 
// assigns to the portion of a where b is true
specter seems to be doing this on a &quot;multi level&quot; way, but I&apos;m wondering if there is some deeper theoretical underpinning"><span class="u" id="1484111060.001385">2017:01:11 05:04:20                  qqq </span><span>@nathanmarz : what, if any, is the theoretical under pinning of specter?
in numpy, we can do something like:
a :: mxn float
b :: mxn bool
a [b] = ... 
// assigns to the portion of a where b is true
specter seems to be doing this on a &quot;multi level&quot; way, but I&apos;m wondering if there is some deeper theoretical underpinning</span></div><div data-t="qqq does (setval BEGINNING) always treat both args as seqs and output a seq?"><span class="u" id="1484117374.001386">2017:01:11 06:49:34                  qqq </span><span>does (setval BEGINNING) always treat both args as seqs and output a seq?</span></div><div data-t="qqq Keeps the element only if it matches the supplied predicate. This is the late-bound parameterized version of using a function directly in a path.

^^ -- I don&apos; get it. Why do I need pred instead of just using the function?"><span class="u" id="1484125320.001393">2017:01:11 09:02:00                  qqq </span><span>Keeps the element only if it matches the supplied predicate. This is the late-bound parameterized version of using a function directly in a path.

^^ -- I don&apos; get it. Why do I need pred instead of just using the function?</span></div><div data-t="qqq ;; not-selected?: stops navigation if something is found
(sp/select [sp/all (sp/not-selected? even?)] (range 10))
(sp/select [sp/all (sp/not-selected? [(sp/must :a) even?])] [{:a 0} {:a 1} {:a 2} {:a 3}])
(sp/select-one (sp/not-selected? [sp/all (sp/must :a) even?]) [{:a 0} {:a 1} {:a 2} {:a 3}])

;; not-selected?: stops navigation if fails to find path
(sp/select [sp/all (sp/selected? even?)] (range 10))
(sp/select [sp/all (sp/selected? [(sp/must :a) even?])] [{:a 0} {:a 1} {:a 2} {:a 3}])
(sp/select (sp/selected? [sp/all (sp/must :a) even?]) [{:a 0} {:a 1} {:a 2} {:a 3}])
 
selected? / not-selected? -- these examples I am not understanding"><span class="u" id="1484125786.001394">2017:01:11 09:09:46                  qqq </span><pre>;; not-selected?: stops navigation if something is found
(sp/select [sp/all (sp/not-selected? even?)] (range 10))
(sp/select [sp/all (sp/not-selected? [(sp/must :a) even?])] [{:a 0} {:a 1} {:a 2} {:a 3}])
(sp/select-one (sp/not-selected? [sp/all (sp/must :a) even?]) [{:a 0} {:a 1} {:a 2} {:a 3}])

;; not-selected?: stops navigation if fails to find path
(sp/select [sp/all (sp/selected? even?)] (range 10))
(sp/select [sp/all (sp/selected? [(sp/must :a) even?])] [{:a 0} {:a 1} {:a 2} {:a 3}])
(sp/select (sp/selected? [sp/all (sp/must :a) even?]) [{:a 0} {:a 1} {:a 2} {:a 3}])
</pre><span>
selected? / not-selected? -- these examples I am not understanding</span></div><div data-t="nathanmarz @qqq  pred  is the navigator that functions implicitly use"><span class="u" id="1484141099.001395">2017:01:11 13:24:59           nathanmarz </span><span>@qqq </span><code>pred</code><span> is the navigator that functions implicitly use</span></div><div data-t="nathanmarz You would use it in a situation like this:
 (defn foo [afn data]
  (select [ALL (pred afn)] data))
"><span class="u" id="1484141143.001396">2017:01:11 13:25:43           nathanmarz </span><span>You would use it in a situation like this:
</span><pre>(defn foo [afn data]
  (select [ALL (pred afn)] data))
</pre></div><div data-t="nathanmarz if you were just to do  (select [ALL afn] data)  there&apos;s no way to know what the type of that local will be (or whether it will change on every invocation, so specter would have to figure that out on every single invocation"><span class="u" id="1484141184.001397">2017:01:11 13:26:24           nathanmarz </span><span>if you were just to do </span><code>(select [ALL afn] data)</code><span> there&apos;s no way to know what the type of that local will be (or whether it will change on every invocation, so specter would have to figure that out on every single invocation</span></div><div data-t="nathanmarz which would hurt performance"><span class="u" id="1484141191.001398">2017:01:11 13:26:31           nathanmarz </span><span>which would hurt performance</span></div><div data-t="nathanmarz by explicitly saying it&apos;s  pred , the inline compiler can bake it into the path and avoid that coercion at runtime"><span class="u" id="1484141225.001399">2017:01:11 13:27:05           nathanmarz </span><span>by explicitly saying it&apos;s </span><code>pred</code><span>, the inline compiler can bake it into the path and avoid that coercion at runtime</span></div><div data-t="nathanmarz a common use case of  selected?  is finding all values in a map where the key matches some criteria"><span class="u" id="1484141268.001400">2017:01:11 13:27:48           nathanmarz </span><span>a common use case of </span><code>selected?</code><span> is finding all values in a map where the key matches some criteria</span></div><div data-t="nathanmarz e.g.  (select [ALL (selected? FIRST some-predicate?) LAST] amap)"><span class="u" id="1484141291.001401">2017:01:11 13:28:11           nathanmarz </span><span>e.g. </span><code>(select [ALL (selected? FIRST some-predicate?) LAST] amap)</code></div><div data-t="nathanmarz lot of other use cases of course"><span class="u" id="1484141302.001402">2017:01:11 13:28:22           nathanmarz </span><span>lot of other use cases of course</span></div><div data-t="nathanmarz as for theoretical underpinnings... no"><span class="u" id="1484141323.001403">2017:01:11 13:28:43           nathanmarz </span><span>as for theoretical underpinnings... no</span></div><div data-t="nathanmarz the specter API is the result of me unifying a ton of data manipulation use cases into the simplest possible abstractions"><span class="u" id="1484141359.001404">2017:01:11 13:29:19           nathanmarz </span><span>the specter API is the result of me unifying a ton of data manipulation use cases into the simplest possible abstractions</span></div><div data-t="nathanmarz there&apos;s similarities to haskell lenses but also some key differences"><span class="u" id="1484141403.001405">2017:01:11 13:30:03           nathanmarz </span><span>there&apos;s similarities to haskell lenses but also some key differences</span></div><div data-t="gdeer81 I&apos;m starting over and playing with examples to see if I can stub my toe and document beginner gotchas. here&apos;s an interesting example :  (setval [:peeps END] [:name &quot;Moe&quot;] {:peeps [{:name &quot;Larry&quot; } {:name &quot;Curly&quot;}]}) 
 (setval [:peeps END] {:name &quot;Moe&quot;} {:peeps [{:name &quot;Larry&quot; } {:name &quot;Curly&quot;}]}) 
 (setval [:peeps END] [{:name &quot;Moe&quot;}] {:peeps [{:name &quot;Larry&quot; } {:name &quot;Curly&quot;}]})"><span class="u" id="1484153812.001412">2017:01:11 16:56:52              gdeer81 </span><span>I&apos;m starting over and playing with examples to see if I can stub my toe and document beginner gotchas. here&apos;s an interesting example : </span><code>(setval [:peeps END] [:name &quot;Moe&quot;] {:peeps [{:name &quot;Larry&quot; } {:name &quot;Curly&quot;}]})</code><span>
</span><code>(setval [:peeps END] {:name &quot;Moe&quot;} {:peeps [{:name &quot;Larry&quot; } {:name &quot;Curly&quot;}]})</code><span>
</span><code>(setval [:peeps END] [{:name &quot;Moe&quot;}] {:peeps [{:name &quot;Larry&quot; } {:name &quot;Curly&quot;}]})</code></div><div data-t="gdeer81 the first one adds the key and string to the vector, the second adds a vector with the keyword and string to the vector and the last does what I was looking for and adds the map for Moe to the vector of maps"><span class="u" id="1484154079.001414">2017:01:11 17:01:19              gdeer81 </span><span>the first one adds the key and string to the vector, the second adds a vector with the keyword and string to the vector and the last does what I was looking for and adds the map for Moe to the vector of maps</span></div><div data-t="gdeer81 Early access to Specter Koans:  https://github.com/gdeer81/specter-koans  currently only covers select and navigation and only takes about 10 minutes to complete but I&apos;m going to constantly be adding more"><span class="u" id="1484198580.001428">2017:01:12 05:23:00              gdeer81 </span><span>Early access to Specter Koans: </span><a href="https://github.com/gdeer81/specter-koans">https://github.com/gdeer81/specter-koans</a><span> currently only covers select and navigation and only takes about 10 minutes to complete but I&apos;m going to constantly be adding more</span></div><div data-t="schmee nice, I’ll check em out later today!"><span class="u" id="1484211495.001430">2017:01:12 08:58:15               schmee </span><span>nice, I’ll check em out later today!</span></div><div data-t="james @gdeer81 Great initiative!"><span class="u" id="1484215514.001431">2017:01:12 10:05:14                james </span><span>@gdeer81 Great initiative!</span></div><div data-t="james Is there a bug here?
 &quot;FIRST is obvious on collections except for on a map&quot;
 (= true (= [[0 :a]] (select FIRST (sorted-map 0 :a 1 :b))))

 &quot;You will also run into the same thing with LAST on a map&quot;
 (= false (= [1 :b] (select LAST (sorted-map 0 :a 1 :b))))
 
As you can’t guarantee order in a map, you can&apos;t know in advance if the result will be true or false. I guess this might be confusing for some people."><span class="u" id="1484215707.001432">2017:01:12 10:08:27                james </span><span>Is there a bug here?
</span><pre>&quot;FIRST is obvious on collections except for on a map&quot;
 (= true (= [[0 :a]] (select FIRST (sorted-map 0 :a 1 :b))))

 &quot;You will also run into the same thing with LAST on a map&quot;
 (= false (= [1 :b] (select LAST (sorted-map 0 :a 1 :b))))
</pre><span>
As you can’t guarantee order in a map, you can&apos;t know in advance if the result will be true or false. I guess this might be confusing for some people.</span></div><div data-t="bfabry I think you&apos;re just missing a wrapping set of [] for the second assertion"><span class="u" id="1484215997.001433">2017:01:12 10:13:17               bfabry </span><span>I think you&apos;re just missing a wrapping set of [] for the second assertion</span></div><div data-t="bfabry because (though this could just be lucky)
 (first (sorted-map 0 :a 1 :b))
=&gt; [0 :a]
(last (sorted-map 0 :a 1 :b))
=&gt; [1 :b]
(sp/select sp/FIRST (sorted-map 0 :a 1 :b))
=&gt; [[0 :a]]
(sp/select sp/LAST (sorted-map 0 :a 1 :b))
=&gt; [[1 :b]]
"><span class="u" id="1484216072.001434">2017:01:12 10:14:32               bfabry </span><span>because (though this could just be lucky)
</span><pre>(first (sorted-map 0 :a 1 :b))
=&gt; [0 :a]
(last (sorted-map 0 :a 1 :b))
=&gt; [1 :b]
(sp/select sp/FIRST (sorted-map 0 :a 1 :b))
=&gt; [[0 :a]]
(sp/select sp/LAST (sorted-map 0 :a 1 :b))
=&gt; [[1 :b]]
</pre></div><div data-t="gdeer81 @james that one was actually pulled from the example  https://github.com/nathanmarz/specter/wiki/List-of-Navigators#first  but it looks like I used select instead of select-one"><span class="u" id="1484236612.001441">2017:01:12 15:56:52              gdeer81 </span><span>@james that one was actually pulled from the example </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#first">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#first</a><span> but it looks like I used select instead of select-one</span></div><div data-t="gdeer81 @bfabry yeah this koan has taught me to pay attention to which select function I&apos;m using lol"><span class="u" id="1484239515.001443">2017:01:12 16:45:15              gdeer81 </span><span>@bfabry yeah this koan has taught me to pay attention to which select function I&apos;m using lol</span></div><div data-t="devth checking out specter, looks great so far. one thing i&apos;m trying to figure out is, given a nested data structure and a leaf node (e.g.  :foo ), can specter compute the path to that node for me?"><span class="u" id="1484240489.001445">2017:01:12 17:01:29                devth </span><span>checking out specter, looks great so far. one thing i&apos;m trying to figure out is, given a nested data structure and a leaf node (e.g. </span><code>:foo</code><span>), can specter compute the path to that node for me?</span></div><div data-t="nathanmarz @devth you&apos;re looking for this:  https://github.com/nathanmarz/specter/issues/49"><span class="u" id="1484240573.001446">2017:01:12 17:02:53           nathanmarz </span><span>@devth you&apos;re looking for this: </span><a href="https://github.com/nathanmarz/specter/issues/49">https://github.com/nathanmarz/specter/issues/49</a></div><div data-t="nathanmarz not implemented"><span class="u" id="1484240575.001448">2017:01:12 17:02:55           nathanmarz </span><span>not implemented</span></div><div data-t="nathanmarz you can do it manually for some cases using value collection (`collect` and  collect-one )"><span class="u" id="1484240598.001449">2017:01:12 17:03:18           nathanmarz </span><span>you can do it manually for some cases using value collection (`collect` and </span><code>collect-one</code><span>)</span></div><div data-t="devth thanks. i&apos;ll play with it"><span class="u" id="1484240670.001450">2017:01:12 17:04:30                devth </span><span>thanks. i&apos;ll play with it</span></div><div data-t="devth doesn&apos;t  collect  require that you know the path ahead of time? e.g. searching for  :qux  in a given structure –  [:foo/bar {:baz/a [:qux]}]  as an example"><span class="u" id="1484242359.001451">2017:01:12 17:32:39                devth </span><span>doesn&apos;t </span><code>collect</code><span> require that you know the path ahead of time? e.g. searching for </span><code>:qux</code><span> in a given structure – </span><code>[:foo/bar {:baz/a [:qux]}]</code><span> as an example</span></div><div data-t="nathanmarz @devth there&apos;s an example above of what I mean"><span class="u" id="1484246078.001452">2017:01:12 18:34:38           nathanmarz </span><span>@devth there&apos;s an example above of what I mean</span></div><div data-t="nathanmarz here:
 (defnav ALL-INDEXED []
  (select* [this structure next-fn]
    ;; fill this in
    )
  (transform* [this structure next-fn]
    (map-indexed
      (fn [i v]
        (second (next-fn [i v])))
      structure
      )))


(def MyPath
  (recursive-path [] p
    (cond-path map? [ALL (collect-one FIRST) LAST p]
               vector? [ALL-INDEXED (collect-one FIRST) LAST p]
               STAY STAY)))

(transform MyPath
  (fn [&amp; vals] vals)
  {:a {:b [:apple :orange :pear]
   :c [:juice]}
   :e [:cat :dog]})
"><span class="u" id="1484246086.001453">2017:01:12 18:34:46           nathanmarz </span><span>here:
</span><pre>(defnav ALL-INDEXED []
  (select* [this structure next-fn]
    ;; fill this in
    )
  (transform* [this structure next-fn]
    (map-indexed
      (fn [i v]
        (second (next-fn [i v])))
      structure
      )))


(def MyPath
  (recursive-path [] p
    (cond-path map? [ALL (collect-one FIRST) LAST p]
               vector? [ALL-INDEXED (collect-one FIRST) LAST p]
               STAY STAY)))

(transform MyPath
  (fn [&amp; vals] vals)
  {:a {:b [:apple :orange :pear]
   :c [:juice]}
   :e [:cat :dog]})
</pre></div><div data-t="devth @nathanmarz awesome, thanks!"><span class="u" id="1484246103.001454">2017:01:12 18:35:03                devth </span><span>@nathanmarz awesome, thanks!</span></div><div data-t="nathanmarz if you filled in  select*  for  ALL-INDEXED   then you could do  (select MyPath data)  to retrieve the paths to each leaf element"><span class="u" id="1484246211.001455">2017:01:12 18:36:51           nathanmarz </span><span>if you filled in </span><code>select*</code><span> for </span><code>ALL-INDEXED</code><span>  then you could do </span><code>(select MyPath data)</code><span> to retrieve the paths to each leaf element</span></div><div data-t="qqq I&apos;m looking for &quot;closest to leaf&quot; nodes that:
(1) have a :node filed, (2) have an empty :children field
how do I do this?"><span class="u" id="1484283177.001462">2017:01:13 04:52:57                  qqq </span><span>I&apos;m looking for &quot;closest to leaf&quot; nodes that:
(1) have a :node filed, (2) have an empty :children field
how do I do this?</span></div><div data-t="qqq I think it&apos;s something dealing with walk, but I don&apos;t knowhow to &quot;force to the leafs&quot;"><span class="u" id="1484283190.001463">2017:01:13 04:53:10                  qqq </span><span>I think it&apos;s something dealing with walk, but I don&apos;t knowhow to &quot;force to the leafs&quot;</span></div><div data-t="qqq {:node {:name &quot;tex&quot; :key :tex}
   :children
   [{:node {:name &quot;glyph&quot; :key :glpyh}}
    {:node {:name &quot;resize&quot; :key :resize}}
    {:node {:name &quot;frac&quot; :key :frac}}]}
 
^^ something like this, but it&apos;s a deep . / big tree, and I want the &apos;glph/resize/frac nodes"><span class="u" id="1484283231.001464">2017:01:13 04:53:51                  qqq </span><pre>{:node {:name &quot;tex&quot; :key :tex}
   :children
   [{:node {:name &quot;glyph&quot; :key :glpyh}}
    {:node {:name &quot;resize&quot; :key :resize}}
    {:node {:name &quot;frac&quot; :key :frac}}]}
</pre><span>
^^ something like this, but it&apos;s a deep . / big tree, and I want the &apos;glph/resize/frac nodes</span></div><div data-t="qqq does specter allow &apos;recursive selectors&apos; without using walk?"><span class="u" id="1484284588.001465">2017:01:13 05:16:28                  qqq </span><span>does specter allow &apos;recursive selectors&apos; without using walk?</span></div><div data-t="qqq I want something that says :stay -- and then process :children ALL, recursively"><span class="u" id="1484284599.001466">2017:01:13 05:16:39                  qqq </span><span>I want something that says :stay -- and then process :children ALL, recursively</span></div><div data-t="qqq specter&apos;s ALL is only &quot;process one level&quot;; is there a recursive-all which processes all subtrees?"><span class="u" id="1484286933.001473">2017:01:13 05:55:33                  qqq </span><span>specter&apos;s ALL is only &quot;process one level&quot;; is there a recursive-all which processes all subtrees?</span></div><div data-t="qqq @nathanmarz : is there any version of specter that runs on java 7? I need to deploy on GAE and spcter appears to reqauire some jav a8 feature"><span class="u" id="1484305243.001474">2017:01:13 11:00:43                  qqq </span><span>@nathanmarz : is there any version of specter that runs on java 7? I need to deploy on GAE and spcter appears to reqauire some jav a8 feature</span></div><div data-t="nathanmarz @qqq that&apos;s easy with  recursive-path"><span class="u" id="1484316913.001475">2017:01:13 14:15:13           nathanmarz </span><span>@qqq that&apos;s easy with </span><code>recursive-path</code></div><div data-t="nathanmarz specter should work fine on java 7, are you running into an issue?"><span class="u" id="1484316928.001476">2017:01:13 14:15:28           nathanmarz </span><span>specter should work fine on java 7, are you running into an issue?</span></div><div data-t="schmee qqq this seems to work:  (def DeepKeys
  (recursive-path [] p
    (if-path (must :children)
      [:children ALL p]
      [:node :key])))
"><span class="u" id="1484442253.001513">2017:01:15 01:04:13               schmee </span><span>qqq this seems to work: </span><pre>(def DeepKeys
  (recursive-path [] p
    (if-path (must :children)
      [:children ALL p]
      [:node :key])))
</pre></div><div data-t="qqq is it possible to go a step further and say &quot;:children&quot; is not empty?"><span class="u" id="1484476783.001527">2017:01:15 10:39:43                  qqq </span><span>is it possible to go a step further and say &quot;:children&quot; is not empty?</span></div><div data-t="qqq I wnat (must :children -- this part is not empty)"><span class="u" id="1484476792.001528">2017:01:15 10:39:52                  qqq </span><span>I wnat (must :children -- this part is not empty)</span></div><div data-t="nathanmarz @qqq you can replace  (must :children)  with  [:children FIRST]"><span class="u" id="1484478753.001529">2017:01:15 11:12:33           nathanmarz </span><span>@qqq you can replace </span><code>(must :children)</code><span> with </span><code>[:children FIRST]</code></div><div data-t="qqq @nathanmarz : I found that #(not-empty (:children %)) also worked"><span class="u" id="1484478799.001530">2017:01:15 11:13:19                  qqq </span><span>@nathanmarz : I found that #(not-empty (:children %)) also worked</span></div><div data-t="qqq is the main disaadvantage t omy appraoch lack of optimizability since the funciton is &apos;opaque&apos; ?"><span class="u" id="1484478818.001531">2017:01:15 11:13:38                  qqq </span><span>is the main disaadvantage t omy appraoch lack of optimizability since the funciton is &apos;opaque&apos; ?</span></div><div data-t="nathanmarz no"><span class="u" id="1484478952.001532">2017:01:15 11:15:52           nathanmarz </span><span>no</span></div><div data-t="nathanmarz the function approach might be a little faster"><span class="u" id="1484478966.001533">2017:01:15 11:16:06           nathanmarz </span><span>the function approach might be a little faster</span></div><div data-t="nathanmarz you&apos;d have to profile it"><span class="u" id="1484478979.001534">2017:01:15 11:16:19           nathanmarz </span><span>you&apos;d have to profile it</span></div><div data-t="richiardiandrea the recursive approach is very neat"><span class="u" id="1484505364.001542">2017:01:15 18:36:04      richiardiandrea </span><span>the recursive approach is very neat</span></div><div data-t="richiardiandrea so if i do something like:
 (sp/transform [:family
                 :relationship
                 sp/ALL]
                #(dadada)
                family)
 
The  :relationship  key is created even when it is missing. Is there a way to avoid it? Meaning I don&apos;t want to create it at all if it was not there in the first place?"><span class="u" id="1484530920.001543">2017:01:16 01:42:00      richiardiandrea </span><span>so if i do something like:
</span><pre>(sp/transform [:family
                 :relationship
                 sp/ALL]
                #(dadada)
                family)
</pre><span>
The </span><code>:relationship</code><span> key is created even when it is missing. Is there a way to avoid it? Meaning I don&apos;t want to create it at all if it was not there in the first place?</span></div><div data-t="schmee richiardiandrea use  (must :relationship)"><span class="u" id="1484553878.001550">2017:01:16 08:04:38               schmee </span><span>richiardiandrea use </span><code>(must :relationship)</code></div><div data-t="schmee https://github.com/nathanmarz/specter/wiki/List-of-Navigators#must"><span class="u" id="1484557528.001557">2017:01:16 09:05:28               schmee </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#must">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#must</a></div><div data-t="schmee keypath  might also be of interest"><span class="u" id="1484557536.001559">2017:01:16 09:05:36               schmee </span><code>keypath</code><span> might also be of interest</span></div><div data-t="richiardiandrea @schmee thanks! Will try soon"><span class="u" id="1484580645.001566">2017:01:16 15:30:45      richiardiandrea </span><span>@schmee thanks! Will try soon</span></div><div data-t="zane Has anyone successfully used  core.match  inside of a recursive path definition?"><span class="u" id="1484777797.001604">2017:01:18 22:16:37                 zane </span><span>Has anyone successfully used </span><code>core.match</code><span> inside of a recursive path definition?</span></div><div data-t="zane @nathanmarz,  recursive-path  is fantastic. Thanks!"><span class="u" id="1484856116.001627">2017:01:19 20:01:56                 zane </span><span>@nathanmarz, </span><code>recursive-path</code><span> is fantastic. Thanks!</span></div><div data-t="narkisr Hey, I&apos;m looking for a way to replace a single nested value {:one #{:two}} with a splattered list of values {:one #{1 2 3 4}} using transform"><span class="u" id="1485221381.001693">2017:01:24 01:29:41              narkisr </span><span>Hey, I&apos;m looking for a way to replace a single nested value {:one #{:two}} with a splattered list of values {:one #{1 2 3 4}} using transform</span></div><div data-t="narkisr Not sure if thats possible"><span class="u" id="1485221405.001694">2017:01:24 01:30:05              narkisr </span><span>Not sure if thats possible</span></div><div data-t="james @narkisr How about  setval ?"><span class="u" id="1485244018.001702">2017:01:24 07:46:58                james </span><span>@narkisr How about </span><code>setval</code><span>?</span></div><div data-t="james (setval [:one] #{1 2 3 4} {:one #{:two}})
&gt; {:one #{1 4 3 2}}"><span class="u" id="1485244034.001703">2017:01:24 07:47:14                james </span><pre>(setval [:one] #{1 2 3 4} {:one #{:two}})
&gt; {:one #{1 4 3 2}}</pre></div><div data-t="narkisr Hey James, I need the to be a result of a function call (transformation) and not a static value like in setval"><span class="u" id="1485248141.001704">2017:01:24 08:55:41              narkisr </span><span>Hey James, I need the to be a result of a function call (transformation) and not a static value like in setval</span></div><div data-t="narkisr the value"><span class="u" id="1485248155.001705">2017:01:24 08:55:55              narkisr </span><span>the value</span></div><div data-t="james @narkisr  (transform [:one] (constantly #{1 2 3 4}) {:one #{:two}})"><span class="u" id="1485251869.001707">2017:01:24 09:57:49                james </span><span>@narkisr </span><pre>(transform [:one] (constantly #{1 2 3 4}) {:one #{:two}})</pre></div><div data-t="james Does that help?"><span class="u" id="1485251872.001708">2017:01:24 09:57:52                james </span><span>Does that help?</span></div><div data-t="narkisr So In my case I&apos;m transforming the keys into a list of vectors for example (tranform [:one :two] (fn [_] [[1 2] [3 4]]) {:one #{:two}}) I would like to get {:one #{[1 2] [3 4]}}"><span class="u" id="1485262373.001715">2017:01:24 12:52:53              narkisr </span><span>So In my case I&apos;m transforming the keys into a list of vectors for example (tranform [:one :two] (fn [_] [[1 2] [3 4]]) {:one #{:two}}) I would like to get {:one #{[1 2] [3 4]}}</span></div><div data-t="narkisr And not  {:one #{[[1 2] [3 4]]}}"><span class="u" id="1485262393.001716">2017:01:24 12:53:13              narkisr </span><span>And not  {:one #{[[1 2] [3 4]]}}</span></div><div data-t="narkisr Its looks like partial flatten but I didn&apos;t manage to come without any working example"><span class="u" id="1485262468.001717">2017:01:24 12:54:28              narkisr </span><span>Its looks like partial flatten but I didn&apos;t manage to come without any working example</span></div><div data-t="nathanmarz @narkisr I think you&apos;re looking for this:  (transform [:one (subset #{:two})] (fn [_] #{[1 2] [3 4]}) {:one #{two}})"><span class="u" id="1485264420.001718">2017:01:24 13:27:00           nathanmarz </span><span>@narkisr I think you&apos;re looking for this: </span><code>(transform [:one (subset #{:two})] (fn [_] #{[1 2] [3 4]}) {:one #{two}})</code></div><div data-t="james @narkisr Do you actually want the inner data structure to be a set? Because you’re trying to access it like a hashmap (with a keyword), and talking about “transforming keys&quot;."><span class="u" id="1485264447.001719">2017:01:24 13:27:27                james </span><span>@narkisr Do you actually want the inner data structure to be a set? Because you’re trying to access it like a hashmap (with a keyword), and talking about “transforming keys&quot;.</span></div><div data-t="narkisr The actual code contains a hash which values are days like :sunday which I want so substitute for all the Sundays within a month (so you get multiple values out from a single value)"><span class="u" id="1485267503.001720">2017:01:24 14:18:23              narkisr </span><span>The actual code contains a hash which values are days like :sunday which I want so substitute for all the Sundays within a month (so you get multiple values out from a single value)</span></div><div data-t="narkisr A set matches this use since the values are always unique"><span class="u" id="1485267544.001721">2017:01:24 14:19:04              narkisr </span><span>A set matches this use since the values are always unique</span></div><div data-t="narkisr Thanks Natan ill give it a go"><span class="u" id="1485267601.001722">2017:01:24 14:20:01              narkisr </span><span>Thanks Natan ill give it a go</span></div><div data-t="narkisr for example {:foo #{:sunday}} =&gt; {:foo #{[1 1] [8 1] [15 1] [22 1]  [29 1]}"><span class="u" id="1485267724.001723">2017:01:24 14:22:04              narkisr </span><span>for example {:foo #{:sunday}} =&gt; {:foo #{[1 1] [8 1] [15 1] [22 1]  [29 1]}</span></div><div data-t="narkisr all the Sundays in Jan 2017"><span class="u" id="1485267745.001724">2017:01:24 14:22:25              narkisr </span><span>all the Sundays in Jan 2017</span></div><div data-t="narkisr Hey Natan its seems that subset does not fit the bill in my case because the values that I&apos;m replace are based on a pred"><span class="u" id="1485304198.001732">2017:01:25 00:29:58              narkisr </span><span>Hey Natan its seems that subset does not fit the bill in my case because the values that I&apos;m replace are based on a pred</span></div><div data-t="narkisr (tranform [:one (pred keyword?)] (fn [_] [[1 2] [3 4]]) {:one #{:two}})"><span class="u" id="1485304291.001733">2017:01:25 00:31:31              narkisr </span><span>(tranform [:one (pred keyword?)] (fn [_] [[1 2] [3 4]]) {:one #{:two}})</span></div><div data-t="narkisr Ok managed to solve it"><span class="u" id="1485305441.001734">2017:01:25 00:50:41              narkisr </span><span>Ok managed to solve it</span></div><div data-t="narkisr Since my kewords are days its closed set (so subset works) but id be curious on how you can use pred to substitute values"><span class="u" id="1485305505.001735">2017:01:25 00:51:45              narkisr </span><span>Since my kewords are days its closed set (so subset works) but id be curious on how you can use pred to substitute values</span></div><div data-t="nathanmarz @narkisr you would need to iterate over all the values and check the predicate against each value"><span class="u" id="1485316384.001736">2017:01:25 03:53:04           nathanmarz </span><span>@narkisr you would need to iterate over all the values and check the predicate against each value</span></div><div data-t="nathanmarz ALL  isn&apos;t currently implemented for sets though"><span class="u" id="1485316441.001737">2017:01:25 03:54:01           nathanmarz </span><code>ALL</code><span> isn&apos;t currently implemented for sets though</span></div><div data-t="nathanmarz you could either use a vector there instead of a set or make an  ALL-SET-ELEMS  navigator"><span class="u" id="1485316466.001738">2017:01:25 03:54:26           nathanmarz </span><span>you could either use a vector there instead of a set or make an </span><code>ALL-SET-ELEMS</code><span> navigator</span></div><div data-t="nathanmarz (or open a pull request to extend  ALL  to sets)"><span class="u" id="1485316474.001739">2017:01:25 03:54:34           nathanmarz </span><span>(or open a pull request to extend </span><code>ALL</code><span> to sets)</span></div><div data-t="narkisr Thank you Natan, ill take a look on what it takes to add support for that"><span class="u" id="1485348602.001747">2017:01:25 12:50:02              narkisr </span><span>Thank you Natan, ill take a look on what it takes to add support for that</span></div><div data-t="narkisr Nathan*"><span class="u" id="1485349212.001748">2017:01:25 13:00:12              narkisr </span><span>Nathan*</span></div><div data-t="nathanmarz @narkisr need to extend  AllTransformProtocol  to  PersistentHashSet"><span class="u" id="1485352469.001749">2017:01:25 13:54:29           nathanmarz </span><span>@narkisr need to extend </span><code>AllTransformProtocol</code><span> to </span><code>PersistentHashSet</code></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L87"><span class="u" id="1485352482.001750">2017:01:25 13:54:42           nathanmarz </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L87">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L87</a></div><div data-t="nathanmarz @narkisr actually just realized that  ALL  already handles sets via the default case, it&apos;s just not optimized like the other data structures"><span class="u" id="1485352596.001752">2017:01:25 13:56:36           nathanmarz </span><span>@narkisr actually just realized that </span><code>ALL</code><span> already handles sets via the default case, it&apos;s just not optimized like the other data structures</span></div><div data-t="rauh I&apos;m guessing  setval  is faster than  assoc-in ? Can&apos;t find  setval  at all in the performance gist."><span class="u" id="1485530350.001804">2017:01:27 15:19:10                 rauh </span><span>I&apos;m guessing </span><code>setval</code><span> is faster than </span><code>assoc-in</code><span>? Can&apos;t find </span><code>setval</code><span> at all in the performance gist.</span></div><div data-t="nathanmarz @rauh  setval  is just a thin wrapper over transform"><span class="u" id="1485531332.001805">2017:01:27 15:35:32           nathanmarz </span><span>@rauh </span><code>setval</code><span> is just a thin wrapper over transform</span></div><div data-t="nathanmarz haven&apos;t benchmarked  assoc-in  but I&apos;d guess  setval  is faster"><span class="u" id="1485531360.001806">2017:01:27 15:36:00           nathanmarz </span><span>haven&apos;t benchmarked </span><code>assoc-in</code><span> but I&apos;d guess </span><code>setval</code><span> is faster</span></div><div data-t="rauh I see, did a non-scientific  time  and it looks like it&apos;s slightly faster.  setval , that is"><span class="u" id="1485531362.001807">2017:01:27 15:36:02                 rauh </span><span>I see, did a non-scientific </span><code>time</code><span> and it looks like it&apos;s slightly faster. </span><code>setval</code><span>, that is</span></div><div data-t="nathanmarz it&apos;s over 3x faster"><span class="u" id="1485531542.001810">2017:01:27 15:39:02           nathanmarz </span><span>it&apos;s over 3x faster</span></div><div data-t="nathanmarz ********************************

Benchmark: set value in nested map (2500000 iterations)

Avg(ms)		vs best		Code
370.15 		 1.00 		 (setval [:a :b :c] 1 data)
1240.9 		 3.35 		 (assoc-in data [:a :b :c] 1)
"><span class="u" id="1485531546.001811">2017:01:27 15:39:06           nathanmarz </span><pre>********************************

Benchmark: set value in nested map (2500000 iterations)

Avg(ms)		vs best		Code
370.15 		 1.00 		 (setval [:a :b :c] 1 data)
1240.9 		 3.35 		 (assoc-in data [:a :b :c] 1)
</pre></div><div data-t="nha Is specter suited to transform clojure map keys?
 {:a {:b {:c 123}} :d 456}
{:a_b_c 123 :d 456}
 
Something like that, back and forth."><span class="u" id="1486138371.001943">2017:02:03 16:12:51                  nha </span><span>Is specter suited to transform clojure map keys?
</span><pre>{:a {:b {:c 123}} :d 456}
{:a_b_c 123 :d 456}
</pre><span>
Something like that, back and forth.</span></div><div data-t="nathanmarz @nha you can do something like this:
 user=&gt; (def PATH-MAP-WALKER
  #_=&gt;   (recursive-path [] p
  #_=&gt;     (if-path map?
  #_=&gt;       [ALL (collect-one FIRST) LAST p]
  #_=&gt;       STAY
  #_=&gt;       )))
#&apos;user/PATH-MAP-WALKER
user=&gt; 

user=&gt; 

user=&gt; (reduce
  #_=&gt;   (fn [m path]
  #_=&gt;     (assoc m (apply str (butlast path)) (last path)))
  #_=&gt;   {}
  #_=&gt;   (traverse PATH-MAP-WALKER {:a {:b {:c 1}} :d 2}))
{&quot;:a:b:c&quot; 1, &quot;:d&quot; 2}
"><span class="u" id="1486138709.001945">2017:02:03 16:18:29           nathanmarz </span><span>@nha you can do something like this:
</span><pre>user=&gt; (def PATH-MAP-WALKER
  #_=&gt;   (recursive-path [] p
  #_=&gt;     (if-path map?
  #_=&gt;       [ALL (collect-one FIRST) LAST p]
  #_=&gt;       STAY
  #_=&gt;       )))
#&apos;user/PATH-MAP-WALKER
user=&gt; 

user=&gt; 

user=&gt; (reduce
  #_=&gt;   (fn [m path]
  #_=&gt;     (assoc m (apply str (butlast path)) (last path)))
  #_=&gt;   {}
  #_=&gt;   (traverse PATH-MAP-WALKER {:a {:b {:c 1}} :d 2}))
{&quot;:a:b:c&quot; 1, &quot;:d&quot; 2}
</pre></div><div data-t="nha Nice  🙂  I don’t really understand the traverse part: it returns a function? Can I view it as a collection?
(I am trying to make the reverse function now - but I am also just starting out with specter)"><span class="u" id="1486140096.001946">2017:02:03 16:41:36                  nha </span><span>Nice </span><b>🙂</b><span> I don’t really understand the traverse part: it returns a function? Can I view it as a collection?
(I am trying to make the reverse function now - but I am also just starting out with specter)</span></div><div data-t="nha Ah, get it  reducible object ."><span class="u" id="1486140152.001947">2017:02:03 16:42:32                  nha </span><span>Ah, get it </span><code>reducible object</code><span>.</span></div><div data-t="nathanmarz @nha  traverse  is very efficient, there&apos;s no materialization of intermediate data structures (similar to transducers)"><span class="u" id="1486140886.001948">2017:02:03 16:54:46           nathanmarz </span><span>@nha </span><code>traverse</code><span> is very efficient, there&apos;s no materialization of intermediate data structures (similar to transducers)</span></div><div data-t="nha Yes, starting to understand that  🙂 
Seems easy enough to modify even without understanding every fn in there. Thanks!"><span class="u" id="1486140938.001949">2017:02:03 16:55:38                  nha </span><span>Yes, starting to understand that </span><b>🙂</b><span>
Seems easy enough to modify even without understanding every fn in there. Thanks!</span></div><div data-t="bradford Hi all! I&apos;m trying to get better at Specter. I&apos;m doing a lot of parsing HAR files for metadata. I&apos;m able to do what I want, but it feels...inefficient. like this:  (select [ALL #(or 
                   (re-find #&quot;css&quot; (get-in % [:response :content :mimeType]))
                   (and (re-find #&quot;html&quot; (get-in % [:response :content :mimeType]))
                        (re-find #&quot;tff|woff&quot; (get-in % [:request :url]))
                        )
                   (re-find #&quot;font&quot; (get-in % [:response :content :mimeType]))
                   (and (re-find #&quot;javascript&quot; (get-in % [:response :content :mimeType]))
                        (re-find #&quot;js&quot; (get-in % [:request :url]))
                        )
                   (and (re-find #&quot;image&quot; (get-in % [:response :content :mimeType]))
                        (re-find #&quot;jpg|png|gif|bmp|ico&quot; (get-in % [:request :url]))
                        )

                   )
         [:request :url]] f)"><span class="u" id="1486763442.002078">2017:02:10 21:50:42             bradford </span><span>Hi all! I&apos;m trying to get better at Specter. I&apos;m doing a lot of parsing HAR files for metadata. I&apos;m able to do what I want, but it feels...inefficient. like this: </span><pre>(select [ALL #(or 
                   (re-find #&quot;css&quot; (get-in % [:response :content :mimeType]))
                   (and (re-find #&quot;html&quot; (get-in % [:response :content :mimeType]))
                        (re-find #&quot;tff|woff&quot; (get-in % [:request :url]))
                        )
                   (re-find #&quot;font&quot; (get-in % [:response :content :mimeType]))
                   (and (re-find #&quot;javascript&quot; (get-in % [:response :content :mimeType]))
                        (re-find #&quot;js&quot; (get-in % [:request :url]))
                        )
                   (and (re-find #&quot;image&quot; (get-in % [:response :content :mimeType]))
                        (re-find #&quot;jpg|png|gif|bmp|ico&quot; (get-in % [:request :url]))
                        )

                   )
         [:request :url]] f)</pre></div><div data-t="bradford Is there a cleaner way to do this?"><span class="u" id="1486763450.002079">2017:02:10 21:50:50             bradford </span><span>Is there a cleaner way to do this?</span></div><div data-t="bradford (I&apos;m trying to extract URLs that match certain mimeTypes)"><span class="u" id="1486763480.002080">2017:02:10 21:51:20             bradford </span><span>(I&apos;m trying to extract URLs that match certain mimeTypes)</span></div><div data-t="nathanmarz @bradford I think this is cleaner and it should be much more efficient as well:
 (defn ^:direct-nav my-matcher [exp1 exp2]
  (collected? [part1 part2]
    (and (or (not exp1)
             (re-find exp1 part1))
         (or (not exp2)
             (re-find exp2 part2)))
    ))

(select [ALL 
         (selected?
          (collect-one :response :content :mimeType)
          (collect-one :request :url)
          (multi-path
            (my-matcher #&quot;css&quot; nil)
            (my-matcher #&quot;font&quot; nil)
            (my-matcher #&quot;html&quot; #&quot;tff|woff&quot;)
            (my-matcher #&quot;javascript&quot; #&quot;js&quot;)
            (my-matcher #&quot;image&quot; #&quot;jpg|png|gif|bmp|ico&quot;)
            ))
         :request
         :url]
        f)
"><span class="u" id="1486765270.002081">2017:02:10 22:21:10           nathanmarz </span><span>@bradford I think this is cleaner and it should be much more efficient as well:
</span><pre>(defn ^:direct-nav my-matcher [exp1 exp2]
  (collected? [part1 part2]
    (and (or (not exp1)
             (re-find exp1 part1))
         (or (not exp2)
             (re-find exp2 part2)))
    ))

(select [ALL 
         (selected?
          (collect-one :response :content :mimeType)
          (collect-one :request :url)
          (multi-path
            (my-matcher #&quot;css&quot; nil)
            (my-matcher #&quot;font&quot; nil)
            (my-matcher #&quot;html&quot; #&quot;tff|woff&quot;)
            (my-matcher #&quot;javascript&quot; #&quot;js&quot;)
            (my-matcher #&quot;image&quot; #&quot;jpg|png|gif|bmp|ico&quot;)
            ))
         :request
         :url]
        f)
</pre></div><div data-t="zane ^:direct-nav ?"><span class="u" id="1486765611.002082">2017:02:10 22:26:51                 zane </span><code>^:direct-nav</code><span>?</span></div><div data-t="nathanmarz minor optimization, not necessary"><span class="u" id="1486765634.002083">2017:02:10 22:27:14           nathanmarz </span><span>minor optimization, not necessary</span></div><div data-t="zane Hmm."><span class="u" id="1486765645.002084">2017:02:10 22:27:25                 zane </span><span>Hmm.</span></div><div data-t="nathanmarz explained in  https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation"><span class="u" id="1486765659.002085">2017:02:10 22:27:39           nathanmarz </span><span>explained in </span><a href="https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation">https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation</a></div><div data-t="zane Is it idiomatic to use  collect-one  in that way if you&apos;re trying to, uh, introduce a variable that will be used by a downstream navigator?"><span class="u" id="1486765665.002087">2017:02:10 22:27:45                 zane </span><span>Is it idiomatic to use </span><code>collect-one</code><span> in that way if you&apos;re trying to, uh, introduce a variable that will be used by a downstream navigator?</span></div><div data-t="zane Let me see if I can rephrase that question to make it clearer…  🤔"><span class="u" id="1486765712.002088">2017:02:10 22:28:32                 zane </span><span>Let me see if I can rephrase that question to make it clearer… </span><b>🤔</b></div><div data-t="zane I wand to use  cond-path , but each of the  cond-path  tests begins with the same  (view …) ."><span class="u" id="1486765840.002089">2017:02:10 22:30:40                 zane </span><span>I wand to use </span><code>cond-path</code><span>, but each of the </span><code>cond-path</code><span> tests begins with the same </span><code>(view …)</code><span>.</span></div><div data-t="zane What is the right way to reuse the  (view …)  results?"><span class="u" id="1486765873.002090">2017:02:10 22:31:13                 zane </span><span>What is the right way to reuse the </span><code>(view …)</code><span> results?</span></div><div data-t="nathanmarz yea  collect-one  +  collected?  should do what you need"><span class="u" id="1486765898.002091">2017:02:10 22:31:38           nathanmarz </span><span>yea </span><code>collect-one</code><span> + </span><code>collected?</code><span> should do what you need</span></div><div data-t="nathanmarz you can use  DISPENSE  to drop collected values later in path (so they don&apos;t reach your transform-fn, for instance)"><span class="u" id="1486765928.002092">2017:02:10 22:32:08           nathanmarz </span><span>you can use </span><code>DISPENSE</code><span> to drop collected values later in path (so they don&apos;t reach your transform-fn, for instance)</span></div><div data-t="zane Interesting. Let me give this a shot."><span class="u" id="1486766014.002093">2017:02:10 22:33:34                 zane </span><span>Interesting. Let me give this a shot.</span></div><div data-t="nathanmarz you can also use  defrichnav  to do more custom manipulation of collected values"><span class="u" id="1486766040.002094">2017:02:10 22:34:00           nathanmarz </span><span>you can also use </span><code>defrichnav</code><span> to do more custom manipulation of collected values</span></div><div data-t="nathanmarz look at definition of  DISPENSE  for an example"><span class="u" id="1486766056.002095">2017:02:10 22:34:16           nathanmarz </span><span>look at definition of </span><code>DISPENSE</code><span> for an example</span></div><div data-t="zane ok"><span class="u" id="1486766063.002096">2017:02:10 22:34:23                 zane </span><span>ok</span></div><div data-t="bradford @nathanmarz oh... very cool. very."><span class="u" id="1486766352.002097">2017:02:10 22:39:12             bradford </span><span>@nathanmarz oh... very cool. very.</span></div><div data-t="zane Hmm."><span class="u" id="1486766442.002098">2017:02:10 22:40:42                 zane </span><span>Hmm.</span></div><div data-t="zane Should I be thinking of the collected values as … a stack?"><span class="u" id="1486766448.002099">2017:02:10 22:40:48                 zane </span><span>Should I be thinking of the collected values as … a stack?</span></div><div data-t="zane Like, what happens if some upstream navigator before me also collected a few things?"><span class="u" id="1486766462.002100">2017:02:10 22:41:02                 zane </span><span>Like, what happens if some upstream navigator before me also collected a few things?</span></div><div data-t="nathanmarz @zane they&apos;re a vector"><span class="u" id="1486766588.002101">2017:02:10 22:43:08           nathanmarz </span><span>@zane they&apos;re a vector</span></div><div data-t="nathanmarz new collected values are conj&apos;d to the end"><span class="u" id="1486766596.002102">2017:02:10 22:43:16           nathanmarz </span><span>new collected values are conj&apos;d to the end</span></div><div data-t="nathanmarz I&apos;m sure there&apos;s room for all sorts of new navigators to help with those sorts of issues"><span class="u" id="1486766665.002103">2017:02:10 22:44:25           nathanmarz </span><span>I&apos;m sure there&apos;s room for all sorts of new navigators to help with those sorts of issues</span></div><div data-t="zane I see, okay."><span class="u" id="1486766710.002104">2017:02:10 22:45:10                 zane </span><span>I see, okay.</span></div><div data-t="nathanmarz something like  (with-fresh-collected  (cond-path ...))"><span class="u" id="1486766713.002105">2017:02:10 22:45:13           nathanmarz </span><span>something like </span><code>(with-fresh-collected  (cond-path ...))</code></div><div data-t="zane Yeah."><span class="u" id="1486766718.002106">2017:02:10 22:45:18                 zane </span><span>Yeah.</span></div><div data-t="zane That&apos;s what I&apos;m itching for."><span class="u" id="1486766722.002107">2017:02:10 22:45:22                 zane </span><span>That&apos;s what I&apos;m itching for.</span></div><div data-t="zane But this&apos;ll work."><span class="u" id="1486766725.002108">2017:02:10 22:45:25                 zane </span><span>But this&apos;ll work.</span></div><div data-t="nathanmarz should be easy to do using  richnav  and  defdynamicnav"><span class="u" id="1486766747.002109">2017:02:10 22:45:47           nathanmarz </span><span>should be easy to do using </span><code>richnav</code><span> and </span><code>defdynamicnav</code></div><div data-t="zane I haven&apos;t yet wrapped my mind around those, I think."><span class="u" id="1486766764.002110">2017:02:10 22:46:04                 zane </span><span>I haven&apos;t yet wrapped my mind around those, I think.</span></div><div data-t="zane Baby steps."><span class="u" id="1486766767.002111">2017:02:10 22:46:07                 zane </span><span>Baby steps.</span></div><div data-t="nathanmarz I opened an issue for it since it&apos;s actually a pretty good idea  https://github.com/nathanmarz/specter/issues/175"><span class="u" id="1486766889.002112">2017:02:10 22:48:09           nathanmarz </span><span>I opened an issue for it since it&apos;s actually a pretty good idea </span><a href="https://github.com/nathanmarz/specter/issues/175">https://github.com/nathanmarz/specter/issues/175</a></div><div data-t="zane There&apos;s no  DISPENSE-ONE ?"><span class="u" id="1486766937.002114">2017:02:10 22:48:57                 zane </span><span>There&apos;s no </span><code>DISPENSE-ONE</code><span>?</span></div><div data-t="nathanmarz no"><span class="u" id="1486766949.002115">2017:02:10 22:49:09           nathanmarz </span><span>no</span></div><div data-t="nathanmarz I have a feeling the use cases for that would be better served by  with-fresh-collected"><span class="u" id="1486767007.002116">2017:02:10 22:50:07           nathanmarz </span><span>I have a feeling the use cases for that would be better served by </span><code>with-fresh-collected</code></div><div data-t="nathanmarz not sure, this part of the design space is fairly unexplored"><span class="u" id="1486767025.002117">2017:02:10 22:50:25           nathanmarz </span><span>not sure, this part of the design space is fairly unexplored</span></div><div data-t="nathanmarz would need to see more use cases"><span class="u" id="1486767031.002118">2017:02:10 22:50:31           nathanmarz </span><span>would need to see more use cases</span></div><div data-t="zane defrichnav  isn&apos;t documented yet?"><span class="u" id="1486767289.002119">2017:02:10 22:54:49                 zane </span><code>defrichnav</code><span> isn&apos;t documented yet?</span></div><div data-t="zane The only way it differs is that it takes  vals , which is the collected vals?"><span class="u" id="1486767335.002120">2017:02:10 22:55:35                 zane </span><span>The only way it differs is that it takes </span><code>vals</code><span>, which is the collected vals?</span></div><div data-t="nathanmarz yea, that and  next-fn  expects to be passed in the new vals + the next value to navigate to"><span class="u" id="1486767393.002121">2017:02:10 22:56:33           nathanmarz </span><span>yea, that and </span><code>next-fn</code><span> expects to be passed in the new vals + the next value to navigate to</span></div><div data-t="zane Got it."><span class="u" id="1486767413.002122">2017:02:10 22:56:53                 zane </span><span>Got it.</span></div><div data-t="zane Cool!"><span class="u" id="1486767415.002123">2017:02:10 22:56:55                 zane </span><span>Cool!</span></div><div data-t="nathanmarz defnav  is a thin wrapper around  defrichnav"><span class="u" id="1486767431.002124">2017:02:10 22:57:11           nathanmarz </span><code>defnav</code><span> is a thin wrapper around </span><code>defrichnav</code></div><div data-t="zane Is  defnav  mainly there for backwards compat at this point?"><span class="u" id="1486767563.002125">2017:02:10 22:59:23                 zane </span><span>Is </span><code>defnav</code><span> mainly there for backwards compat at this point?</span></div><div data-t="zane I&apos;m not going to need  late-bound-nav  here?"><span class="u" id="1486767993.002126">2017:02:10 23:06:33                 zane </span><span>I&apos;m not going to need </span><code>late-bound-nav</code><span> here?</span></div><div data-t="zane Rather than  richnav ?"><span class="u" id="1486768004.002127">2017:02:10 23:06:44                 zane </span><span>Rather than </span><code>richnav</code><span>?</span></div><div data-t="nathanmarz @zane oh yea, you&apos;ll need  late-bound-richnav"><span class="u" id="1486768936.002128">2017:02:10 23:22:16           nathanmarz </span><span>@zane oh yea, you&apos;ll need </span><code>late-bound-richnav</code></div><div data-t="zane Maybe I should re-read the caching implementation doc."><span class="u" id="1486769439.002131">2017:02:10 23:30:39                 zane </span><span>Maybe I should re-read the caching implementation doc.</span></div><div data-t="nathanmarz @zane I assume you&apos;re talking about  with-fresh-collected ?"><span class="u" id="1486776180.002132">2017:02:11 01:23:00           nathanmarz </span><span>@zane I assume you&apos;re talking about </span><code>with-fresh-collected</code><span>?</span></div><div data-t="nathanmarz it takes in a path as a parameter, which itself needs to be compiled"><span class="u" id="1486776200.002133">2017:02:11 01:23:20           nathanmarz </span><span>it takes in a path as a parameter, which itself needs to be compiled</span></div><div data-t="nathanmarz you make sure the subpath is only compiled once by using  defdynamicnav , which is like a macro to Specter&apos;s inline compiler, and  late-bound-richnav  which lets you mark the subpath parameter using  late-path  to ensure it&apos;s compiled once and re-used for every invocation of the callsite"><span class="u" id="1486776271.002134">2017:02:11 01:24:31           nathanmarz </span><span>you make sure the subpath is only compiled once by using </span><code>defdynamicnav</code><span>, which is like a macro to Specter&apos;s inline compiler, and </span><code>late-bound-richnav</code><span> which lets you mark the subpath parameter using </span><code>late-path</code><span> to ensure it&apos;s compiled once and re-used for every invocation of the callsite</span></div><div data-t="nathanmarz that wiki page I referenced explains the mechanics of what happens at each callsite which will help you understand what these things do"><span class="u" id="1486776388.002135">2017:02:11 01:26:28           nathanmarz </span><span>that wiki page I referenced explains the mechanics of what happens at each callsite which will help you understand what these things do</span></div><div data-t="zane Awesome. I&apos;ll have a look. Thanks!"><span class="u" id="1486776543.002136">2017:02:11 01:29:03                 zane </span><span>Awesome. I&apos;ll have a look. Thanks!</span></div><div data-t="zane Beat me to it."><span class="u" id="1486829359.002137">2017:02:11 16:09:19                 zane </span><span>Beat me to it.</span></div><div data-t="bradford Hi fam. How do I remove a value from a vector using  setval ? I&apos;ve got the path correct, but when I set the value to NONE, I get com.rpl.specter/NONE in the vector. Which does make sense, but that&apos;s not what I want  😉   (defn remove-luminati-refs-and-save [f]
  (setval [ALL :response :headers [ALL #(re-find #&quot;luminati|hola&quot; (:name %) )]] NONE f)

  )
"><span class="u" id="1486851168.002138">2017:02:11 22:12:48             bradford </span><span>Hi fam. How do I remove a value from a vector using </span><code>setval</code><span>? I&apos;ve got the path correct, but when I set the value to NONE, I get com.rpl.specter/NONE in the vector. Which does make sense, but that&apos;s not what I want </span><b>😉</b><span> </span><pre>(defn remove-luminati-refs-and-save [f]
  (setval [ALL :response :headers [ALL #(re-find #&quot;luminati|hola&quot; (:name %) )]] NONE f)

  )
</pre></div><div data-t="bradford also specter is super magic and cool"><span class="u" id="1486851176.002139">2017:02:11 22:12:56             bradford </span><span>also specter is super magic and cool</span></div><div data-t="nathanmarz @bradford setting a value to  NONE  to remove it is implemented in master but not released yet"><span class="u" id="1486852714.002140">2017:02:11 22:38:34           nathanmarz </span><span>@bradford setting a value to </span><code>NONE</code><span> to remove it is implemented in master but not released yet</span></div><div data-t="bradford Ah, rad. thanks!"><span class="u" id="1486852732.002141">2017:02:11 22:38:52             bradford </span><span>Ah, rad. thanks!</span></div><div data-t="nathanmarz I think 0.13.3-SNAPSHOT on clojars has it though"><span class="u" id="1486852744.002142">2017:02:11 22:39:04           nathanmarz </span><span>I think 0.13.3-SNAPSHOT on clojars has it though</span></div><div data-t="richiardiandrea Confirm I am using that feature successfully, very useful one ;)"><span class="u" id="1486862881.002143">2017:02:12 01:28:01      richiardiandrea </span><span>Confirm I am using that feature successfully, very useful one ;)</span></div><div data-t="zane @nathanmarz: Does this look like valid usage?
 (specter/select
 (specter/with-fresh-collected
   (specter/collect-one (specter/keypath 0))
   (specter/cond-path
    (specter/collected? [x] (even? x))
    (specter/keypath 1)
    (specter/collected? [n] (odd? n))
    (specter/keypath 2)))
 [1 &quot;even&quot; &quot;odd&quot;])
"><span class="u" id="1487007526.002176">2017:02:13 17:38:46                 zane </span><span>@nathanmarz: Does this look like valid usage?
</span><pre>(specter/select
 (specter/with-fresh-collected
   (specter/collect-one (specter/keypath 0))
   (specter/cond-path
    (specter/collected? [x] (even? x))
    (specter/keypath 1)
    (specter/collected? [n] (odd? n))
    (specter/keypath 2)))
 [1 &quot;even&quot; &quot;odd&quot;])
</pre></div><div data-t="zane I&apos;m finding that  x  in the  collected?  call is  nil ."><span class="u" id="1487007578.002179">2017:02:13 17:39:38                 zane </span><span>I&apos;m finding that </span><code>x</code><span> in the </span><code>collected?</code><span> call is </span><code>nil</code><span>.</span></div><div data-t="zane Hmm. I must be misunderstanding how collections work:"><span class="u" id="1487008361.002180">2017:02:13 17:52:41                 zane </span><span>Hmm. I must be misunderstanding how collections work:</span></div><div data-t="zane (specter/select
 (specter/comp-paths (specter/collect-one :type)
                     (specter/collected? [type]
                                         (clojure.tools.trace/trace &quot;type&quot; type)
                                         true)
                     (specter/if-path
                      (specter/collected? [type]
                                          (clojure.tools.trace/trace &quot;type&quot; type)
                                          (= :a type))
                      :a
                      :b))
 {:type :a
  :a &quot;a&quot;
  :b &quot;b&quot;})
"><span class="u" id="1487008364.002181">2017:02:13 17:52:44                 zane </span><pre>(specter/select
 (specter/comp-paths (specter/collect-one :type)
                     (specter/collected? [type]
                                         (clojure.tools.trace/trace &quot;type&quot; type)
                                         true)
                     (specter/if-path
                      (specter/collected? [type]
                                          (clojure.tools.trace/trace &quot;type&quot; type)
                                          (= :a type))
                      :a
                      :b))
 {:type :a
  :a &quot;a&quot;
  :b &quot;b&quot;})
</pre></div><div data-t="nathanmarz @zane yea looks like a bug"><span class="u" id="1487008380.002182">2017:02:13 17:53:00           nathanmarz </span><span>@zane yea looks like a bug</span></div><div data-t="zane TRACE type: :a
TRACE type: nil
[[:a &quot;b&quot;]]
"><span class="u" id="1487008387.002183">2017:02:13 17:53:07                 zane </span><pre>TRACE type: :a
TRACE type: nil
[[:a &quot;b&quot;]]
</pre></div><div data-t="zane Ah, okay."><span class="u" id="1487008396.002184">2017:02:13 17:53:16                 zane </span><span>Ah, okay.</span></div><div data-t="zane Phew. I&apos;m not crazy."><span class="u" id="1487008399.002185">2017:02:13 17:53:19                 zane </span><span>Phew. I&apos;m not crazy.</span></div><div data-t="nathanmarz vals aren&apos;t being passed to condition paths for  if-path /`cond-path`"><span class="u" id="1487008411.002186">2017:02:13 17:53:31           nathanmarz </span><span>vals aren&apos;t being passed to condition paths for </span><code>if-path</code><span>/`cond-path`</span></div><div data-t="zane Want me to file an issue or something?"><span class="u" id="1487008415.002187">2017:02:13 17:53:35                 zane </span><span>Want me to file an issue or something?</span></div><div data-t="nathanmarz yes, thanks"><span class="u" id="1487008440.002188">2017:02:13 17:54:00           nathanmarz </span><span>yes, thanks</span></div><div data-t="zane https://github.com/nathanmarz/specter/issues/176"><span class="u" id="1487009037.002190">2017:02:13 18:03:57                 zane </span><a href="https://github.com/nathanmarz/specter/issues/176">https://github.com/nathanmarz/specter/issues/176</a></div><div data-t="nathanmarz @zane btw you can handle your previous use case with:
 (if-path [(keypath 0) even?] (keypath 1) (keypath 2))
"><span class="u" id="1487018789.002198">2017:02:13 20:46:29           nathanmarz </span><span>@zane btw you can handle your previous use case with:
</span><pre>(if-path [(keypath 0) even?] (keypath 1) (keypath 2))
</pre></div><div data-t="zane Yeah, my actual use case has more than two branches, @nathanmarz.  😞  "><span class="u" id="1487021904.002199">2017:02:13 21:38:24                 zane </span><span>Yeah, my actual use case has more than two branches, @nathanmarz. </span><b>😞</b><span> </span></div><div data-t="zane I could repeat the computation of the dispatch value but that feels gross. "><span class="u" id="1487021949.002200">2017:02:13 21:39:09                 zane </span><span>I could repeat the computation of the dispatch value but that feels gross. </span></div><div data-t="shader I&apos;m getting an error &quot;com.rpl.specter.impl.CachedPathInfo cannot be cast to com.rpl.specter.impl.CachedPathInfo&quot;"><span class="u" id="1487025722.002201">2017:02:13 22:42:02               shader </span><span>I&apos;m getting an error &quot;com.rpl.specter.impl.CachedPathInfo cannot be cast to com.rpl.specter.impl.CachedPathInfo&quot;</span></div><div data-t="shader I presume this has been seen before; any ideas?"><span class="u" id="1487025730.002202">2017:02:13 22:42:10               shader </span><span>I presume this has been seen before; any ideas?</span></div><div data-t="shader it may just be that I need to update to the latest version..."><span class="u" id="1487025750.002203">2017:02:13 22:42:30               shader </span><span>it may just be that I need to update to the latest version...</span></div><div data-t="shader hmm... updating changed the error to &quot;No implementation of method: :get_cell of protocol: #&apos;com.rpl.specter.impl/PMutableCell found for class: clojure.lang.Var$Unbound&quot;, which means the api has probably changed"><span class="u" id="1487025860.002204">2017:02:13 22:44:20               shader </span><span>hmm... updating changed the error to &quot;No implementation of method: :get_cell of protocol: #&apos;com.rpl.specter.impl/PMutableCell found for class: clojure.lang.Var$Unbound&quot;, which means the api has probably changed</span></div><div data-t="nathanmarz @shader that first error was fixed in 0.13.2, as for second issue would need to see the code producing the error to help"><span class="u" id="1487037605.002214">2017:02:14 02:00:05           nathanmarz </span><span>@shader that first error was fixed in 0.13.2, as for second issue would need to see the code producing the error to help</span></div><div data-t="zane @nathanmarz, I&apos;m finding  with-fresh-collected  to be incredibly useful."><span class="u" id="1487098973.002234">2017:02:14 19:02:53                 zane </span><span>@nathanmarz, I&apos;m finding </span><code>with-fresh-collected</code><span> to be incredibly useful.</span></div><div data-t="zane Here are two navigators I&apos;ve used it for:"><span class="u" id="1487098982.002235">2017:02:14 19:03:02                 zane </span><span>Here are two navigators I&apos;ve used it for:</span></div><div data-t="zane (s/def ::or-spec-path-args
  (s/cat :spec qualified-keyword?
         :branches (s/+ (s/alt :branch (s/cat :key simple-keyword? :body any?)
                               :invalid (s/cat :key #{:spec/invalid} :body any?)))))

(defmacro or-spec-path
  &quot;Navigates to one of several subpaths depending on which branch of a
  `clojure.spec/or` the structure conforms to.&quot;
  [&amp; args]
  (let [{:keys [spec branches] :as conformed} (s/conform ::or-spec-path-args args)
        spec-obj (s/get-spec spec)
        invalid (or (select-first (fn [[tag _]] (= :invalid tag))
                                  branches)
                    `(fn [val#] (throw (ex-info (s/explain-str ~spec val#)
                                                (s/explain-data ~spec val#)))))]
    (if-not spec-obj
      (throw (ex-info (str &quot;Spec not found: &quot; spec)
                      {:spec spec
                       :conformed conformed}))
      `(with-fresh-collected
         (collect-one (view (partial s/conform ~spec)))
         (cond-path
          (collected? [conformed#]
            (= ::s/invalid conformed#))
          ~invalid
          "><span class="u" id="1487098996.002236">2017:02:14 19:03:16                 zane </span><pre>(s/def ::or-spec-path-args
  (s/cat :spec qualified-keyword?
         :branches (s/+ (s/alt :branch (s/cat :key simple-keyword? :body any?)
                               :invalid (s/cat :key #{:spec/invalid} :body any?)))))

(defmacro or-spec-path
  &quot;Navigates to one of several subpaths depending on which branch of a
  `clojure.spec/or` the structure conforms to.&quot;
  [&amp; args]
  (let [{:keys [spec branches] :as conformed} (s/conform ::or-spec-path-args args)
        spec-obj (s/get-spec spec)
        invalid (or (select-first (fn [[tag _]] (= :invalid tag))
                                  branches)
                    `(fn [val#] (throw (ex-info (s/explain-str ~spec val#)
                                                (s/explain-data ~spec val#)))))]
    (if-not spec-obj
      (throw (ex-info (str &quot;Spec not found: &quot; spec)
                      {:spec spec
                       :conformed conformed}))
      `(with-fresh-collected
         (collect-one (view (partial s/conform ~spec)))
         (cond-path
          (collected? [conformed#]
            (= ::s/invalid conformed#))
          ~invalid
          </pre></div><div data-t="zane (s/def ::case-path-args
  (s/cat :path any?
         :branches (s/+ (s/cat :value any? :body any?))
         :default (s/? any?)))

(defmacro case-path
  &quot;Navigates to one of several subpaths depending on the value selected by a the
  provided path.&quot;
  [&amp; args]
  (let [{:keys [path branches default] :as conformed} (s/conform ::case-path-args args)]
    `(with-fresh-collected
       (collect-one ~path)
       (cond-path
        "><span class="u" id="1487099009.002237">2017:02:14 19:03:29                 zane </span><pre>(s/def ::case-path-args
  (s/cat :path any?
         :branches (s/+ (s/cat :value any? :body any?))
         :default (s/? any?)))

(defmacro case-path
  &quot;Navigates to one of several subpaths depending on the value selected by a the
  provided path.&quot;
  [&amp; args]
  (let [{:keys [path branches default] :as conformed} (s/conform ::case-path-args args)]
    `(with-fresh-collected
       (collect-one ~path)
       (cond-path
        </pre></div><div data-t="nathanmarz @zane cool, you should be able to do those as dynamic navs though"><span class="u" id="1487099716.002238">2017:02:14 19:15:16           nathanmarz </span><span>@zane cool, you should be able to do those as dynamic navs though</span></div><div data-t="zane Hmm. Could I do the spec one as a dynamic nav? I want to have compile-time error reporting for that one."><span class="u" id="1487208958.002265">2017:02:16 01:35:58                      zane </span><span>Hmm. Could I do the spec one as a dynamic nav? I want to have compile-time error reporting for that one.</span></div><div data-t="nathanmarz I haven&apos;t dug into spec yet, so I don&apos;t understand every detail of your code. But if you did it as a dynamic nav it would throw the error the first time that callsite is run (when Specter&apos;s inline compiler expands dynamic navs)."><span class="u" id="1487218801.002267">2017:02:16 04:20:01                nathanmarz </span><span>I haven&apos;t dug into spec yet, so I don&apos;t understand every detail of your code. But if you did it as a dynamic nav it would throw the error the first time that callsite is run (when Specter&apos;s inline compiler expands dynamic navs).</span></div><div data-t="nathanmarz Another approach you could take is have a macro that does your validation and expands to a dynamic nav invocation which does the rest of the work."><span class="u" id="1487218851.002269">2017:02:16 04:20:51                nathanmarz </span><span>Another approach you could take is have a macro that does your validation and expands to a dynamic nav invocation which does the rest of the work.</span></div><div data-t="zane That last suggestion seems like the way to go. Thanks for the feedback!"><span class="u" id="1487265511.002284">2017:02:16 17:18:31                      zane </span><span>That last suggestion seems like the way to go. Thanks for the feedback!</span></div><div data-t="nathanmarz opened a thread on the mailing list about whether Specter should be part of Clojure core or not  https://groups.google.com/forum/#!topic/clojure/qN1UPMVQmaM"><span class="u" id="1487106311.002239">2017:02:14 21:05:11           nathanmarz </span><span>opened a thread on the mailing list about whether Specter should be part of Clojure core or not </span><a href="https://groups.google.com/forum/#!topic/clojure/qN1UPMVQmaM">https://groups.google.com/forum/#!topic/clojure/qN1UPMVQmaM</a></div><div data-t="schmee I think it is better to have it as a lib since that way we can add and fix stuff faster and easier"><span class="u" id="1487106977.002240">2017:02:14 21:16:17               schmee </span><span>I think it is better to have it as a lib since that way we can add and fix stuff faster and easier</span></div><div data-t="dm3 it should probably be on a list of “blessed” libs, if one existed for Clojure"><span class="u" id="1487110032.002241">2017:02:14 22:07:12                  dm3 </span><span>it should probably be on a list of “blessed” libs, if one existed for Clojure</span></div><div data-t="dm3 I think it’s in the same category as “core.async” - indispensable when you have a good problem for it"><span class="u" id="1487110251.002242">2017:02:14 22:10:51                  dm3 </span><span>I think it’s in the same category as “core.async” - indispensable when you have a good problem for it</span></div><div data-t="nathanmarz @schmee new navigators can easily be provided in external libraries"><span class="u" id="1487132491.002249">2017:02:15 04:21:31           nathanmarz </span><span>@schmee new navigators can easily be provided in external libraries</span></div><div data-t="nathanmarz I don&apos;t see the core of Specter (navigator composition and inline compilation/caching) changing since the performance is near-optimal"><span class="u" id="1487132564.002250">2017:02:15 04:22:44           nathanmarz </span><span>I don&apos;t see the core of Specter (navigator composition and inline compilation/caching) changing since the performance is near-optimal</span></div><div data-t="richiardiandrea Imho with some small retouch it could be transparently integrated in core, for instance  update-in  could accept a navigator. "><span class="u" id="1487193033.002257">2017:02:15 21:10:33      richiardiandrea </span><span>Imho with some small retouch it could be transparently integrated in core, for instance </span><code>update-in</code><span> could accept a navigator. </span></div><div data-t="souenzzo Hi!
There is some docs to  recursive-path ?
I&apos;m trying to do:  [:a {:b [:c]}]  -&gt;  [:a {:b [:c :x]} :x]  (position of  x  don&apos;t matter)
(append  x  to all  vector?  level&apos;s)"><span class="u" id="1487625566.002309">2017:02:20 21:19:26             souenzzo </span><span>Hi!
There is some docs to </span><code>recursive-path</code><span>?
I&apos;m trying to do: </span><code>[:a {:b [:c]}]</code><span> -&gt; </span><code>[:a {:b [:c :x]} :x]</code><span> (position of </span><code>x</code><span> don&apos;t matter)
(append </span><code>x</code><span> to all </span><code>vector?</code><span> level&apos;s)</span></div><div data-t="nathanmarz @souenzzo it&apos;s just  (recursive-path [] p ...)"><span class="u" id="1487625782.002311">2017:02:20 21:23:02           nathanmarz </span><span>@souenzzo it&apos;s just </span><code>(recursive-path [] p ...)</code></div><div data-t="nathanmarz where  p  refers to itself"><span class="u" id="1487625790.002312">2017:02:20 21:23:10           nathanmarz </span><span>where </span><code>p</code><span> refers to itself</span></div><div data-t="nathanmarz navigating to all levels of the vector can be done:  (recursive-path [] p (if-path vector? (continue-then-stay ALL p)))"><span class="u" id="1487625894.002313">2017:02:20 21:24:54           nathanmarz </span><span>navigating to all levels of the vector can be done: </span><code>(recursive-path [] p (if-path vector? (continue-then-stay ALL p)))</code></div><div data-t="nathanmarz with 0.13.3-SNAPSHOT can do:
 user=&gt; (def p (recursive-path [] p (if-path vector? (continue-then-stay ALL p))))
#&apos;user/p
user=&gt; (setval [p AFTER-ELEM] :x [1 [2 3] [[4]]])
[1 [2 3 :x] [[4 :x] :x] :x]
"><span class="u" id="1487625924.002314">2017:02:20 21:25:24           nathanmarz </span><span>with 0.13.3-SNAPSHOT can do:
</span><pre>user=&gt; (def p (recursive-path [] p (if-path vector? (continue-then-stay ALL p))))
#&apos;user/p
user=&gt; (setval [p AFTER-ELEM] :x [1 [2 3] [[4]]])
[1 [2 3 :x] [[4 :x] :x] :x]
</pre></div><div data-t="richiardiandrea Woah nice ^"><span class="u" id="1487643065.002315">2017:02:21 02:11:05      richiardiandrea </span><span>Woah nice ^</span></div><div data-t="richiardiandrea We should take the history of this channel and apply a transformation  that generates wiki pages with these kind of examples. Every time I peek in here there is something nice and  🆒"><span class="u" id="1487643140.002316">2017:02:21 02:12:20      richiardiandrea </span><span>We should take the history of this channel and apply a transformation  that generates wiki pages with these kind of examples. Every time I peek in here there is something nice and </span><b>🆒</b></div><div data-t="dm3 we need something like  https://regexr.com/ , but for Specter"><span class="u" id="1487663437.002318">2017:02:21 07:50:37                  dm3 </span><span>we need something like </span><a href="https://regexr.com/">https://regexr.com/</a><span>, but for Specter</span></div><div data-t="nathanmarz @dm3 various people have said they would do something like that for specter (more along the lines of 4clojure), but no one has done it yet"><span class="u" id="1487682756.002323">2017:02:21 13:12:36           nathanmarz </span><span>@dm3 various people have said they would do something like that for specter (more along the lines of 4clojure), but no one has done it yet</span></div><div data-t="dm3 not going to say I’ll do that  🙂"><span class="u" id="1487682805.002324">2017:02:21 13:13:25                  dm3 </span><span>not going to say I’ll do that </span><b>🙂</b></div><div data-t="dm3 but this type of incremental visual path construction would be awesome"><span class="u" id="1487682872.002325">2017:02:21 13:14:32                  dm3 </span><span>but this type of incremental visual path construction would be awesome</span></div><div data-t="dm3 instead of Text pane you have a tree editor with sequences, maps and primitives as building blocks"><span class="u" id="1487682951.002327">2017:02:21 13:15:51                  dm3 </span><span>instead of Text pane you have a tree editor with sequences, maps and primitives as building blocks</span></div><div data-t="dm3 instead of Expression - an executable editor panel, because you might want to write new navigators. Or maybe a separate panel for the context NS and a separate path expression editor"><span class="u" id="1487683055.002328">2017:02:21 13:17:35                  dm3 </span><span>instead of Expression - an executable editor panel, because you might want to write new navigators. Or maybe a separate panel for the context NS and a separate path expression editor</span></div><div data-t="dm3 does Specter work in bootstrapped cljs?"><span class="u" id="1487683119.002329">2017:02:21 13:18:39                  dm3 </span><span>does Specter work in bootstrapped cljs?</span></div><div data-t="nathanmarz @dm3 not at the moment  https://github.com/nathanmarz/specter/issues/72"><span class="u" id="1487684752.002330">2017:02:21 13:45:52           nathanmarz </span><span>@dm3 not at the moment </span><a href="https://github.com/nathanmarz/specter/issues/72">https://github.com/nathanmarz/specter/issues/72</a></div><div data-t="nathanmarz shouldn&apos;t be too much work to get it working again, but the main task that needs to be done to ensure support moving forward is getting the tests running under bootstrap cljs"><span class="u" id="1487684785.002332">2017:02:21 13:46:25           nathanmarz </span><span>shouldn&apos;t be too much work to get it working again, but the main task that needs to be done to ensure support moving forward is getting the tests running under bootstrap cljs</span></div><div data-t="chromalchemy I am trying to tranform some &quot;Hiccup-y&quot; style data that will be compiled by Garden into CSS. Ex:  [:h1 :h2 {:font-weight &quot;none&quot;}] [:body {:font-size &quot;16px&quot;}] 
But it seem like the Specter functions expect maps. How can I get these vectors into something that Specter can see better?"><span class="u" id="1487780815.002335">2017:02:22 16:26:55         chromalchemy </span><span>I am trying to tranform some &quot;Hiccup-y&quot; style data that will be compiled by Garden into CSS. Ex: </span><code>[:h1 :h2 {:font-weight &quot;none&quot;}] [:body {:font-size &quot;16px&quot;}]</code><span>
But it seem like the Specter functions expect maps. How can I get these vectors into something that Specter can see better?</span></div><div data-t="chromalchemy ps. Thank you for Specter. I&apos;m coming from front end and dont know much about typical database interactions, But Specter + nested EDN just seems to make sense  😅  I&apos;m trying to use it in cljs client with persistance to Firebase JSON tree."><span class="u" id="1487780947.002336">2017:02:22 16:29:07         chromalchemy </span><span>ps. Thank you for Specter. I&apos;m coming from front end and dont know much about typical database interactions, But Specter + nested EDN just seems to make sense </span><b>😅</b><span> I&apos;m trying to use it in cljs client with persistance to Firebase JSON tree.</span></div><div data-t="nathanmarz @chromalchemy specter works on all data structures"><span class="u" id="1487782046.002339">2017:02:22 16:47:26           nathanmarz </span><span>@chromalchemy specter works on all data structures</span></div><div data-t="nathanmarz what are you trying to do?"><span class="u" id="1487782120.002340">2017:02:22 16:48:40           nathanmarz </span><span>what are you trying to do?</span></div><div data-t="chromalchemy It might be a lark, but since CSS uses a form of navigators, and Garden follows suit to compile Hiccup style clojure data into CSS, I could take a super-structure of ready-to-compile Garden data, and transform or filter it as needed with Specter for more specific application of the style data. Kind of like querying a style database dynamically, instead of declaring static css rules/paths directly."><span class="u" id="1487782702.002341">2017:02:22 16:58:22         chromalchemy </span><span>It might be a lark, but since CSS uses a form of navigators, and Garden follows suit to compile Hiccup style clojure data into CSS, I could take a super-structure of ready-to-compile Garden data, and transform or filter it as needed with Specter for more specific application of the style data. Kind of like querying a style database dynamically, instead of declaring static css rules/paths directly.</span></div><div data-t="chromalchemy Im not sure how to navigate the Garden vectors though. They arent exactly maps (though there are nested maps) I cant even get the first key-val out of a vector."><span class="u" id="1487782800.002342">2017:02:22 17:00:00         chromalchemy </span><span>Im not sure how to navigate the Garden vectors though. They arent exactly maps (though there are nested maps) I cant even get the first key-val out of a vector.</span></div><div data-t="tolitius @chromalchemy 
 =&gt; (def html [[:h1 :h2 {:font-weight &quot;none&quot;}] [:body {:font-size &quot;16px&quot;}]])

=&gt; (transform [(walker :font-size) :font-size] #(s/replace %  #&quot;px&quot; &quot;em&quot;) html)

[[:h1 :h2 {:font-weight &quot;none&quot;}] [:body {:font-size &quot;16em&quot;}]]
 
your examples are just data structures: i.e. maps, vectors, sets, etc.. or not?"><span class="u" id="1487782857.002343">2017:02:22 17:00:57             tolitius </span><span>@chromalchemy 
</span><pre>=&gt; (def html [[:h1 :h2 {:font-weight &quot;none&quot;}] [:body {:font-size &quot;16px&quot;}]])

=&gt; (transform [(walker :font-size) :font-size] #(s/replace %  #&quot;px&quot; &quot;em&quot;) html)

[[:h1 :h2 {:font-weight &quot;none&quot;}] [:body {:font-size &quot;16em&quot;}]]
</pre><span>
your examples are just data structures: i.e. maps, vectors, sets, etc.. or not?</span></div><div data-t="tolitius would probably be better if you provided an example of a data structure (Garden, ..) + what you need to do with it"><span class="u" id="1487783026.002344">2017:02:22 17:03:46             tolitius </span><span>would probably be better if you provided an example of a data structure (Garden, ..) + what you need to do with it</span></div><div data-t="chromalchemy Yes, just data. Primarily a list of vectors, each vector is a css rule.    I will try out walker. Not familiar with that one yet."><span class="u" id="1487783076.002345">2017:02:22 17:04:36         chromalchemy </span><span>Yes, just data. Primarily a list of vectors, each vector is a css rule.    I will try out walker. Not familiar with that one yet.</span></div><div data-t="chromalchemy [:myclass {:color &quot;red}]
How can I get the map from the :myclass key?"><span class="u" id="1487783171.002346">2017:02:22 17:06:11         chromalchemy </span><span>[:myclass {:color &quot;red}]
How can I get the map from the :myclass key?</span></div><div data-t="nathanmarz you mean the element to the right of  :myclass  in the vector?"><span class="u" id="1487783251.002347">2017:02:22 17:07:31           nathanmarz </span><span>you mean the element to the right of </span><code>:myclass</code><span> in the vector?</span></div><div data-t="chromalchemy Yes"><span class="u" id="1487783309.002348">2017:02:22 17:08:29         chromalchemy </span><span>Yes</span></div><div data-t="nathanmarz you can do it with com.rpl.specter.zipper"><span class="u" id="1487783362.002349">2017:02:22 17:09:22           nathanmarz </span><span>you can do it with com.rpl.specter.zipper</span></div><div data-t="nathanmarz navigate to the position of  :myclass , and then do  z/RIGHT"><span class="u" id="1487783386.002350">2017:02:22 17:09:46           nathanmarz </span><span>navigate to the position of </span><code>:myclass</code><span>, and then do </span><code>z/RIGHT</code></div><div data-t="nathanmarz I would really question why you store data like that instead of just using a map"><span class="u" id="1487783405.002351">2017:02:22 17:10:05           nathanmarz </span><span>I would really question why you store data like that instead of just using a map</span></div><div data-t="chromalchemy Ok, How do I navigate to position of :myclass?"><span class="u" id="1487783498.002352">2017:02:22 17:11:38         chromalchemy </span><span>Ok, How do I navigate to position of :myclass?</span></div><div data-t="nathanmarz user=&gt; (setval [z/VECTOR-ZIP (z/find-first #(= :myclass %)) z/RIGHT z/NODE :color] &quot;blue&quot; [:myclass {:color &quot;red&quot;}])
[:myclass {:color &quot;blue&quot;}]
"><span class="u" id="1487783598.002353">2017:02:22 17:13:18           nathanmarz </span><pre>user=&gt; (setval [z/VECTOR-ZIP (z/find-first #(= :myclass %)) z/RIGHT z/NODE :color] &quot;blue&quot; [:myclass {:color &quot;red&quot;}])
[:myclass {:color &quot;blue&quot;}]
</pre></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/zipper.cljc#L120"><span class="u" id="1487783671.002354">2017:02:22 17:14:31           nathanmarz </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/zipper.cljc#L120">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/zipper.cljc#L120</a></div><div data-t="chromalchemy Your probably right. The style data super-structure should probably just be maps. I was trying to keep it in the format that Garden wants so I dont have to do more syntax-oriented transformations to be able to compile the results to css"><span class="u" id="1487783675.002356">2017:02:22 17:14:35         chromalchemy </span><span>Your probably right. The style data super-structure should probably just be maps. I was trying to keep it in the format that Garden wants so I dont have to do more syntax-oriented transformations to be able to compile the results to css</span></div><div data-t="chromalchemy Thanks for that!"><span class="u" id="1487783716.002357">2017:02:22 17:15:16         chromalchemy </span><span>Thanks for that!</span></div><div data-t="chromalchemy [[:class1 {foo}] [:class2 {bar}]]
I assume I can use something similar to get to bar by filtering on :class2"><span class="u" id="1487783791.002358">2017:02:22 17:16:31         chromalchemy </span><span>[[:class1 {foo}] [:class2 {bar}]]
I assume I can use something similar to get to bar by filtering on :class2</span></div><div data-t="nathanmarz find-first  will descend into nested vectors, so the code is pretty much exactly the same"><span class="u" id="1487783872.002359">2017:02:22 17:17:52           nathanmarz </span><code>find-first</code><span> will descend into nested vectors, so the code is pretty much exactly the same</span></div><div data-t="chromalchemy or in [:class1 :class2 {foo}], getting from class1 to class2 to foo?"><span class="u" id="1487783887.002360">2017:02:22 17:18:07         chromalchemy </span><span>or in [:class1 :class2 {foo}], getting from class1 to class2 to foo?</span></div><div data-t="chromalchemy Ok cool. I came to Specter after hearing about the challenges of using zippers. But glad that it&apos;s all included :)"><span class="u" id="1487783997.002361">2017:02:22 17:19:57         chromalchemy </span><span>Ok cool. I came to Specter after hearing about the challenges of using zippers. But glad that it&apos;s all included :)</span></div><div data-t="nathanmarz zippers are just an advanced form of navigation"><span class="u" id="1487784090.002362">2017:02:22 17:21:30           nathanmarz </span><span>zippers are just an advanced form of navigation</span></div><div data-t="nathanmarz this happens to be a case where it fits"><span class="u" id="1487784102.002363">2017:02:22 17:21:42           nathanmarz </span><span>this happens to be a case where it fits</span></div><div data-t="chromalchemy Thanks for the help"><span class="u" id="1487784237.002365">2017:02:22 17:23:57         chromalchemy </span><span>Thanks for the help</span></div><div data-t="chromalchemy On a side note, do you have any best practices on size of nested data in a cljs client. Like could i serialize a one-tree to-do datastructure, and transact on it in the client with atoms. Is this reasonable or am i asking for trouble? especially if there are thousands of items &amp; notes &amp; metadata (i have a lot to do lol) "><span class="u" id="1487784626.002366">2017:02:22 17:30:26         chromalchemy </span><span>On a side note, do you have any best practices on size of nested data in a cljs client. Like could i serialize a one-tree to-do datastructure, and transact on it in the client with atoms. Is this reasonable or am i asking for trouble? especially if there are thousands of items &amp; notes &amp; metadata (i have a lot to do lol) </span></div><div data-t="nathanmarz no idea, I don&apos;t do much clojurescript"><span class="u" id="1487784791.002368">2017:02:22 17:33:11           nathanmarz </span><span>no idea, I don&apos;t do much clojurescript</span></div><div data-t="nathanmarz better to ask in #clojurescript channel"><span class="u" id="1487784800.002369">2017:02:22 17:33:20           nathanmarz </span><span>better to ask in #clojurescript channel</span></div><div data-t="mccraigmccraig @chromalchemy i have a largish cljs (re-frame) app with a single atom for all client state - there are commonly many thousands of items in the tree and it&apos;s fine"><span class="u" id="1487787478.002370">2017:02:22 18:17:58       mccraigmccraig </span><span>@chromalchemy i have a largish cljs (re-frame) app with a single atom for all client state - there are commonly many thousands of items in the tree and it&apos;s fine</span></div><div data-t="chromalchemy Cool. good to know. Tree soup it is."><span class="u" id="1487788296.002371">2017:02:22 18:31:36         chromalchemy </span><span>Cool. good to know. Tree soup it is.</span></div><div data-t="alexyakushev Hello folks! Can anyone help me implement a deep filter? I&apos;m looking for the following transformation:
 ;; Drop all maps from the vector in :stuff where :c key is present
{:fluff 42, :stuff [{:a 1, :b 2} {:a 1, :c 3} {:b 2, :c 3} {:b 2, :d 4}]}
=&gt;
{:fluff 42, :stuff [{:a 1, :b 2} {:b 2, :d 4}]}
"><span class="u" id="1487791836.002373">2017:02:22 19:30:36         alexyakushev </span><span>Hello folks! Can anyone help me implement a deep filter? I&apos;m looking for the following transformation:
</span><pre>;; Drop all maps from the vector in :stuff where :c key is present
{:fluff 42, :stuff [{:a 1, :b 2} {:a 1, :c 3} {:b 2, :c 3} {:b 2, :d 4}]}
=&gt;
{:fluff 42, :stuff [{:a 1, :b 2} {:b 2, :d 4}]}
</pre></div><div data-t="alexyakushev I also discovered  NONE , but the example from Github doesn&apos;t work correctly for me (see the impl/NONE):
 (setval [:a ALL nil?] NONE {:a [1 2 nil 3 nil]})
=&gt;
{:a [1 2 :com.rpl.specter.impl/NONE 3 :com.rpl.specter.impl/NONE]}
"><span class="u" id="1487792207.002375">2017:02:22 19:36:47         alexyakushev </span><span>I also discovered </span><code>NONE</code><span>, but the example from Github doesn&apos;t work correctly for me (see the impl/NONE):
</span><pre>(setval [:a ALL nil?] NONE {:a [1 2 nil 3 nil]})
=&gt;
{:a [1 2 :com.rpl.specter.impl/NONE 3 :com.rpl.specter.impl/NONE]}
</pre></div><div data-t="alexyakushev Worked with  0.13.0-SNAPSHOT :
 (setval [:stuff ALL (pred :c)] NONE {:fluff 42, :stuff [{:a 1, :b 2} {:a 1, :c 3} {:b 2, :c 3} {:b 2, :d 4}]})
=&gt;
{:fluff 42, :stuff [{:a 1, :b 2} {:b 2, :d 4}]}
 
Thanks for help!  😄"><span class="u" id="1487792619.002377">2017:02:22 19:43:39         alexyakushev </span><span>Worked with </span><code>0.13.0-SNAPSHOT</code><span>:
</span><pre>(setval [:stuff ALL (pred :c)] NONE {:fluff 42, :stuff [{:a 1, :b 2} {:a 1, :c 3} {:b 2, :c 3} {:b 2, :d 4}]})
=&gt;
{:fluff 42, :stuff [{:a 1, :b 2} {:b 2, :d 4}]}
</pre><span>
Thanks for help! </span><b>😄</b></div><div data-t="nathanmarz @alexyakushev more precise to do  (selected? (must :c))  rather than  (pred :c)"><span class="u" id="1487793040.002378">2017:02:22 19:50:40           nathanmarz </span><span>@alexyakushev more precise to do </span><code>(selected? (must :c))</code><span> rather than </span><code>(pred :c)</code></div><div data-t="alexyakushev Thanks! What is the case when they will work differently?"><span class="u" id="1487793104.002379">2017:02:22 19:51:44         alexyakushev </span><span>Thanks! What is the case when they will work differently?</span></div><div data-t="nathanmarz (pred :c)  will filter out maps with  :c  being false or nil"><span class="u" id="1487793105.002380">2017:02:22 19:51:45           nathanmarz </span><code>(pred :c)</code><span> will filter out maps with </span><code>:c</code><span> being false or nil</span></div><div data-t="alexyakushev Oh, I see.  must  is like  contains? . I get it now, thanks!"><span class="u" id="1487793130.002381">2017:02:22 19:52:10         alexyakushev </span><span>Oh, I see. </span><code>must</code><span> is like </span><code>contains?</code><span>. I get it now, thanks!</span></div><div data-t="nathanmarz must  is  keypath  that navigates only if the key is present"><span class="u" id="1487793205.002382">2017:02:22 19:53:25           nathanmarz </span><code>must</code><span> is </span><code>keypath</code><span> that navigates only if the key is present</span></div><div data-t="souenzzo There is something like  transform-one! ?
 (transform-one! (walker :a) f m) 
with:
Return  nil  if dosen&apos;t apply  f  in any element
Throws or don&apos;t apply  f  if find more then one &quot;match&quot;
Return transformed  m  case find only one &quot;match&quot;"><span class="u" id="1487875491.002383">2017:02:23 18:44:51             souenzzo </span><span>There is something like </span><code>transform-one!</code><span>?
</span><code>(transform-one! (walker :a) f m)</code><span>
with:
Return </span><code>nil</code><span> if dosen&apos;t apply </span><code>f</code><span> in any element
Throws or don&apos;t apply </span><code>f</code><span> if find more then one &quot;match&quot;
Return transformed </span><code>m</code><span> case find only one &quot;match&quot;</span></div><div data-t="nathanmarz @souenzzo no, nothing like that"><span class="u" id="1487878228.002384">2017:02:23 19:30:28           nathanmarz </span><span>@souenzzo no, nothing like that</span></div><div data-t="nathanmarz easy to implement yourself by wrapping the transform fn"><span class="u" id="1487878242.002385">2017:02:23 19:30:42           nathanmarz </span><span>easy to implement yourself by wrapping the transform fn</span></div><div data-t="souenzzo I implemented with  select-one  before transform.
For now, that&apos;s enough.  😉"><span class="u" id="1487878756.002386">2017:02:23 19:39:16             souenzzo </span><span>I implemented with </span><code>select-one</code><span> before transform.
For now, that&apos;s enough. </span><b>😉</b></div><div data-t="qqq Is there a simple way to rewrite the following without specter? (need to eliminate the dependency)
 (fn [x]
  (s/select (s/walker keyword?) x)
 
I want to rewrite the above using just clojure core"><span class="u" id="1487970354.002388">2017:02:24 21:05:54                  qqq </span><span>Is there a simple way to rewrite the following without specter? (need to eliminate the dependency)
</span><pre>(fn [x]
  (s/select (s/walker keyword?) x)
</pre><span>
I want to rewrite the above using just clojure core</span></div><div data-t="nathanmarz @qqq you can use clojure.walk, which is what  walker  uses underneath the hood"><span class="u" id="1487972899.002390">2017:02:24 21:48:19           nathanmarz </span><span>@qqq you can use clojure.walk, which is what </span><code>walker</code><span> uses underneath the hood</span></div><div data-t="mpenet @nathanmarz Could you make a release or are they pending things in master?"><span class="u" id="1488211948.002393">2017:02:27 16:12:28               mpenet </span><span>@nathanmarz Could you make a release or are they pending things in master?</span></div><div data-t="mpenet (I want to get rid of the reflection warnings from my logs :p)"><span class="u" id="1488211979.002394">2017:02:27 16:12:59               mpenet </span><span>(I want to get rid of the reflection warnings from my logs :p)</span></div><div data-t="nathanmarz @mpenet next release will be 1.0 and there&apos;s a few pending things"><span class="u" id="1488212434.002395">2017:02:27 16:20:34           nathanmarz </span><span>@mpenet next release will be 1.0 and there&apos;s a few pending things</span></div><div data-t="nathanmarz 0.13.3-SNAPSHOT is current with master though"><span class="u" id="1488212446.002396">2017:02:27 16:20:46           nathanmarz </span><span>0.13.3-SNAPSHOT is current with master though</span></div><div data-t="mpenet ok, thanks"><span class="u" id="1488212685.002397">2017:02:27 16:24:45               mpenet </span><span>ok, thanks</span></div><div data-t="ghadi is there a simple way to transform all values in a nested map recursively?"><span class="u" id="1488313995.002401">2017:02:28 20:33:15                ghadi </span><span>is there a simple way to transform all values in a nested map recursively?</span></div><div data-t="ghadi I&apos;m trying to make a nicer printout of ElasticSearch mappings... here&apos;s a sample"><span class="u" id="1488314017.002402">2017:02:28 20:33:37                ghadi </span><span>I&apos;m trying to make a nicer printout of ElasticSearch mappings... here&apos;s a sample</span></div><div data-t="ghadi {:properties {:foo {:type &quot;blah&quot; :properties {....}}"><span class="u" id="1488314055.002403">2017:02:28 20:34:15                ghadi </span><code>{:properties {:foo {:type &quot;blah&quot; :properties {....}}</code></div><div data-t="ghadi I&apos;d like to collect all names along all paths... so that I end up with a list of [&quot;blah&quot; &quot;foo&quot;] [&quot;blah&quot; &quot;bar&quot;]"><span class="u" id="1488314087.002404">2017:02:28 20:34:47                ghadi </span><span>I&apos;d like to collect all names along all paths... so that I end up with a list of [&quot;blah&quot; &quot;foo&quot;] [&quot;blah&quot; &quot;bar&quot;]</span></div><div data-t="nathanmarz @ghadi you can use value collection for that"><span class="u" id="1488315948.002405">2017:02:28 21:05:48           nathanmarz </span><span>@ghadi you can use value collection for that</span></div><div data-t="nathanmarz (def data
  {:foo {:type &quot;blah&quot;
         :properties {:foo {:type &quot;bar&quot;}
   :foo2 {:type &quot;foo&quot;}}}})

(def MY-WALKER
  (recursive-path [] p
    (continue-then-stay
      MAP-VALS
      (collect-one :type)
      :properties
      p
      )))

(select MY-WALKER data)
;; =&gt; [[&quot;blah&quot; &quot;bar&quot; nil] [&quot;blah&quot; &quot;foo&quot; nil] [&quot;blah&quot; {:foo {:type &quot;bar&quot;}, :foo2 {:type &quot;foo&quot;}}] {:foo {:type &quot;blah&quot;, :properties {:foo {:type &quot;bar&quot;}, :foo2 {:type &quot;foo&quot;}}}}]
"><span class="u" id="1488315954.002406">2017:02:28 21:05:54           nathanmarz </span><pre>(def data
  {:foo {:type &quot;blah&quot;
         :properties {:foo {:type &quot;bar&quot;}
   :foo2 {:type &quot;foo&quot;}}}})

(def MY-WALKER
  (recursive-path [] p
    (continue-then-stay
      MAP-VALS
      (collect-one :type)
      :properties
      p
      )))

(select MY-WALKER data)
;; =&gt; [[&quot;blah&quot; &quot;bar&quot; nil] [&quot;blah&quot; &quot;foo&quot; nil] [&quot;blah&quot; {:foo {:type &quot;bar&quot;}, :foo2 {:type &quot;foo&quot;}}] {:foo {:type &quot;blah&quot;, :properties {:foo {:type &quot;bar&quot;}, :foo2 {:type &quot;foo&quot;}}}}]
</pre></div><div data-t="nathanmarz for selection it returns each collected  :type  followed by the node value at that point"><span class="u" id="1488315994.002407">2017:02:28 21:06:34           nathanmarz </span><span>for selection it returns each collected </span><code>:type</code><span> followed by the node value at that point</span></div><div data-t="ghadi interesting... what does that return?"><span class="u" id="1488316023.002408">2017:02:28 21:07:03                ghadi </span><span>interesting... what does that return?</span></div><div data-t="nathanmarz for transformation, your transform-fn will receive same thing but as arguments"><span class="u" id="1488316028.002409">2017:02:28 21:07:08           nathanmarz </span><span>for transformation, your transform-fn will receive same thing but as arguments</span></div><div data-t="nathanmarz edited it"><span class="u" id="1488316054.002411">2017:02:28 21:07:34           nathanmarz </span><span>edited it</span></div><div data-t="ghadi thanks! I&apos;m going to try to read the docs to understand that"><span class="u" id="1488316109.002412">2017:02:28 21:08:29                ghadi </span><span>thanks! I&apos;m going to try to read the docs to understand that</span></div><div data-t="nathanmarz Released Specter 1.0 and wrote a post about why I consider it Clojure&apos;s missing piece  http://nathanmarz.com/blog/clojures-missing-piece.html"><span class="u" id="1488390491.002414">2017:03:01 17:48:11           nathanmarz </span><span>Released Specter 1.0 and wrote a post about why I consider it Clojure&apos;s missing piece </span><a href="http://nathanmarz.com/blog/clojures-missing-piece.html">http://nathanmarz.com/blog/clojures-missing-piece.html</a></div><div data-t="wei any tips simplifying this path?
 sp/ALL
(sp/collect-one sp/FIRST)
sp/LAST"><span class="u" id="1488405814.002417">2017:03:01 22:03:34                  wei </span><span>any tips simplifying this path?
</span><pre>sp/ALL
(sp/collect-one sp/FIRST)
sp/LAST</pre></div><div data-t="wei basically MAP-VAL but capturing the key"><span class="u" id="1488405828.002418">2017:03:01 22:03:48                  wei </span><span>basically MAP-VAL but capturing the key</span></div><div data-t="nathanmarz @wei you can factor it as  (def MY-MAP-VALS (comp-paths ALL (collect-one FIRST) LAST))"><span class="u" id="1488406679.002419">2017:03:01 22:17:59           nathanmarz </span><span>@wei you can factor it as </span><code>(def MY-MAP-VALS (comp-paths ALL (collect-one FIRST) LAST))</code></div><div data-t="wei aha, thanks @nathanmarz"><span class="u" id="1488407918.002421">2017:03:01 22:38:38                  wei </span><span>aha, thanks @nathanmarz</span></div><div data-t="wei also, if I wanted to run some formatting function on the captured value, how would I express that?"><span class="u" id="1488407961.002422">2017:03:01 22:39:21                  wei </span><span>also, if I wanted to run some formatting function on the captured value, how would I express that?</span></div><div data-t="wei this doesn’t give me what I want:  sp/ALL
(sp/collect-one sp/FIRST some-format-fn)
sp/LAST"><span class="u" id="1488407979.002423">2017:03:01 22:39:39                  wei </span><span>this doesn’t give me what I want: </span><pre>sp/ALL
(sp/collect-one sp/FIRST some-format-fn)
sp/LAST</pre></div><div data-t="nathanmarz @wei do  (view some-format-fn)"><span class="u" id="1488408494.002425">2017:03:01 22:48:14           nathanmarz </span><span>@wei do </span><code>(view some-format-fn)</code></div><div data-t="richiardiandrea By the way great blog post"><span class="u" id="1488414942.002429">2017:03:02 00:35:42      richiardiandrea </span><span>By the way great blog post</span></div><div data-t="nathanmarz thanks"><span class="u" id="1488423500.002430">2017:03:02 02:58:20           nathanmarz </span><span>thanks</span></div><div data-t="miikka Regarding Haskell lenses and Lens/Traversal distinction: if I recall correctly, for Lens you&apos;re guaranteed that you can read a single value. This is handy with Haskell&apos;s type system, but in a dynamic language like Clojure, it does not really matter or make sense."><span class="u" id="1488441204.002434">2017:03:02 07:53:24               miikka </span><span>Regarding Haskell lenses and Lens/Traversal distinction: if I recall correctly, for Lens you&apos;re guaranteed that you can read a single value. This is handy with Haskell&apos;s type system, but in a dynamic language like Clojure, it does not really matter or make sense.</span></div><div data-t="miikka In general, if you try to port Haskell lenses directly to dynamic languages (like people sometimes do), you&apos;ll end up with a bunch of things that just do not do anything useful without the type system."><span class="u" id="1488441338.002435">2017:03:02 07:55:38               miikka </span><span>In general, if you try to port Haskell lenses directly to dynamic languages (like people sometimes do), you&apos;ll end up with a bunch of things that just do not do anything useful without the type system.</span></div><div data-t="nathanmarz @miikka Thanks, interesting point. Makes sense that the distinction would have something to do with the type system."><span class="u" id="1488459483.002438">2017:03:02 12:58:03           nathanmarz </span><span>@miikka Thanks, interesting point. Makes sense that the distinction would have something to do with the type system.</span></div><div data-t="mmer (NEWBIE QUESTION) - I have been using specter to work with a structure that was originally yaml. The basic selectors I have some grasp of.  What I need to do is find a set of map entries where the values are maps and that have a particular key - eg:"><span class="u" id="1488463760.002440">2017:03:02 14:09:20                 mmer </span><span>(NEWBIE QUESTION) - I have been using specter to work with a structure that was originally yaml. The basic selectors I have some grasp of.  What I need to do is find a set of map entries where the values are maps and that have a particular key - eg:</span></div><div data-t="mmer I want to be able to return :field1 and its contents by finding it because it has the :require true set."><span class="u" id="1488463867.002442">2017:03:02 14:11:07                 mmer </span><span>I want to be able to return :field1 and its contents by finding it because it has the :require true set.</span></div><div data-t="nathanmarz @mmer I think you&apos;re looking for  (select [MAP-VALS map? (pred :required)] data)"><span class="u" id="1488464960.002443">2017:03:02 14:29:20           nathanmarz </span><span>@mmer I think you&apos;re looking for </span><code>(select [MAP-VALS map? (pred :required)] data)</code></div><div data-t="mmer Thanks Nathan,  how do I also get the key of the top level map returned i.e. :field1?"><span class="u" id="1488466104.002444">2017:03:02 14:48:24                 mmer </span><span>Thanks Nathan,  how do I also get the key of the top level map returned i.e. :field1?</span></div><div data-t="nathanmarz @mmer you can do  (select [ALL (collect-one FIRST) LAST map? (pred :required)] data)"><span class="u" id="1488466282.002445">2017:03:02 14:51:22           nathanmarz </span><span>@mmer you can do </span><code>(select [ALL (collect-one FIRST) LAST map? (pred :required)] data)</code></div><div data-t="mmer Thanks Nathan.  I guess I am struggling to understand how this ends up working - for example the (collect-one FIRST) Is it FIRST because you treat the map as a list?  The map? after the LAST is applied to what is returned by the LAST which is the end of the list created from the map?"><span class="u" id="1488467345.002446">2017:03:02 15:09:05                 mmer </span><span>Thanks Nathan.  I guess I am struggling to understand how this ends up working - for example the (collect-one FIRST) Is it FIRST because you treat the map as a list?  The map? after the LAST is applied to what is returned by the LAST which is the end of the list created from the map?</span></div><div data-t="tolitius would this work:
 =&gt; (select [ALL (pred (comp :required val))] m)
[[:field1 {:type &quot;string&quot;, :required true}]] ?"><span class="u" id="1488467874.002447">2017:03:02 15:17:54             tolitius </span><span>would this work:
</span><pre>=&gt; (select [ALL (pred (comp :required val))] m)
[[:field1 {:type &quot;string&quot;, :required true}]]</pre><span>?</span></div><div data-t="nathanmarz @mmer  ALL  on a map navigates you to each key/value pair as a 2-element vector"><span class="u" id="1488468584.002448">2017:03:02 15:29:44           nathanmarz </span><span>@mmer </span><code>ALL</code><span> on a map navigates you to each key/value pair as a 2-element vector</span></div><div data-t="mmer Ok that really helps my understanding."><span class="u" id="1488468625.002449">2017:03:02 15:30:25                 mmer </span><span>Ok that really helps my understanding.</span></div><div data-t="nathanmarz @tolitius yea, that works too"><span class="u" id="1488468642.002450">2017:03:02 15:30:42           nathanmarz </span><span>@tolitius yea, that works too</span></div><div data-t="tolitius thanks, I am learning specter, just wanted to make sure I did not miss an edge case"><span class="u" id="1488468715.002451">2017:03:02 15:31:55             tolitius </span><span>thanks, I am learning specter, just wanted to make sure I did not miss an edge case</span></div><div data-t="james @nathanmarz Congratulations on the 1.0 release! Specter is an amazing feat of software engineering, and an essential part of my Clojure toolbox. Thank you so much for turning my least favourite part of Clojure (manipulating nested data structures) from a frustrating slog into joyful productivity!"><span class="u" id="1488527196.002456">2017:03:03 07:46:36                james </span><span>@nathanmarz Congratulations on the 1.0 release! Specter is an amazing feat of software engineering, and an essential part of my Clojure toolbox. Thank you so much for turning my least favourite part of Clojure (manipulating nested data structures) from a frustrating slog into joyful productivity!</span></div><div data-t="bill_tozier I’ve been able to replicate all the examples involving trees, of course. The bigger picture for me, though, is to be able to select a random item from a tree and transform that. Working it out with a  zipper  is simple enough, but I was hoping to produce a clearer and more readable function that uses Specter.

I’m working through from the given examples “change every X in a tree to Y”, and I’ve got a working version in which one of the filters is a random function. So I can now change a random subset of the nodes in a tree to new values. But selecting only one of those is turning out to be problematic for me.

Maybe if I could find the source for the  FIRST  and  LAST  navigators? ¯\(ツ)/¯"><span class="u" id="1488547648.002460">2017:03:03 13:27:28          bill_tozier </span><span>I’ve been able to replicate all the examples involving trees, of course. The bigger picture for me, though, is to be able to select a random item from a tree and transform that. Working it out with a </span><code>zipper</code><span> is simple enough, but I was hoping to produce a clearer and more readable function that uses Specter.

I’m working through from the given examples “change every X in a tree to Y”, and I’ve got a working version in which one of the filters is a random function. So I can now change a random subset of the nodes in a tree to new values. But selecting only one of those is turning out to be problematic for me.

Maybe if I could find the source for the </span><code>FIRST</code><span> and </span><code>LAST</code><span> navigators? ¯\(ツ)/¯</span></div><div data-t="nathanmarz @bill_tozier  FIRST /`LAST` navigate you to the first or last element of a sequence"><span class="u" id="1488548755.002462">2017:03:03 13:45:55           nathanmarz </span><span>@bill_tozier </span><code>FIRST</code><span>/`LAST` navigate you to the first or last element of a sequence</span></div><div data-t="bill_tozier That was my guess, yes."><span class="u" id="1488548796.002463">2017:03:03 13:46:36          bill_tozier </span><span>That was my guess, yes.</span></div><div data-t="nathanmarz if you want to change a random element, you&apos;ll first need:
 (def TREE-VALUES
  (recursive-path [] p
    (if-path vector?
      [ALL p]
      STAY)))
"><span class="u" id="1488548808.002464">2017:03:03 13:46:48           nathanmarz </span><span>if you want to change a random element, you&apos;ll first need:
</span><pre>(def TREE-VALUES
  (recursive-path [] p
    (if-path vector?
      [ALL p]
      STAY)))
</pre></div><div data-t="nathanmarz Then do  (transform (subselect TREE-VALUES) (fn [all-vals] ...) tree)"><span class="u" id="1488548868.002465">2017:03:03 13:47:48           nathanmarz </span><span>Then do </span><code>(transform (subselect TREE-VALUES) (fn [all-vals] ...) tree)</code></div><div data-t="nathanmarz and inside your custom function change a random element of that sequence"><span class="u" id="1488548893.002467">2017:03:03 13:48:13           nathanmarz </span><span>and inside your custom function change a random element of that sequence</span></div><div data-t="nathanmarz you could also use define a custom navigator for it though it&apos;s tricky since it&apos;s better if navigators are deterministic (so they work with  subselect , for instance)"><span class="u" id="1488548997.002468">2017:03:03 13:49:57           nathanmarz </span><span>you could also use define a custom navigator for it though it&apos;s tricky since it&apos;s better if navigators are deterministic (so they work with </span><code>subselect</code><span>, for instance)</span></div><div data-t="nathanmarz your custom navigator would need to generate a random seed, and then always use that seed to navigate to the same random element"><span class="u" id="1488549027.002469">2017:03:03 13:50:27           nathanmarz </span><span>your custom navigator would need to generate a random seed, and then always use that seed to navigate to the same random element</span></div><div data-t="nathanmarz so usage would probably be something like:  (setval [(subselect TREE-VALUES) (random-elem)] 1111 tree)"><span class="u" id="1488549066.002470">2017:03:03 13:51:06           nathanmarz </span><span>so usage would probably be something like: </span><code>(setval [(subselect TREE-VALUES) (random-elem)] 1111 tree)</code></div><div data-t="bill_tozier nathanmarz: Thanks! I had made the mistake of thinking a navigator accumulated a collection of paths to items. I realize that’s the un-lazy inefficient way, which is how I got sidetracked."><span class="u" id="1488551994.002492">2017:03:03 14:39:54               bill_tozier </span><span>nathanmarz: Thanks! I had made the mistake of thinking a navigator accumulated a collection of paths to items. I realize that’s the un-lazy inefficient way, which is how I got sidetracked.</span></div><div data-t="nathanmarz @james Thanks!"><span class="u" id="1488549148.002471">2017:03:03 13:52:28           nathanmarz </span><span>@james Thanks!</span></div><div data-t="val_waeselynck I seem unable to use  setval NONE  to dissoc fro a map, any idea why ?"><span class="u" id="1488549344.002473">2017:03:03 13:55:44       val_waeselynck </span><span>I seem unable to use </span><code>setval NONE</code><span> to dissoc fro a map, any idea why ?</span></div><div data-t="val_waeselynck (setval [:a :b :c] NONE {:a {:b {:c 1}}})
=&gt; {:a {:b {:c :com.rpl.specter.impl/NONE}}}
"><span class="u" id="1488549346.002474">2017:03:03 13:55:46       val_waeselynck </span><pre>(setval [:a :b :c] NONE {:a {:b {:c 1}}})
=&gt; {:a {:b {:c :com.rpl.specter.impl/NONE}}}
</pre></div><div data-t="val_waeselynck This is weird as I&apos;m using specter 1.0.0"><span class="u" id="1488549444.002477">2017:03:03 13:57:24       val_waeselynck </span><span>This is weird as I&apos;m using specter 1.0.0</span></div><div data-t="schmee val_waeselynck are you sure?"><span class="u" id="1488549858.002478">2017:03:03 14:04:18               schmee </span><span>val_waeselynck are you sure?</span></div><div data-t="schmee I get this:  user=&gt; (setval [:a :b :c] NONE {:a {:b {:c 1}}})
{:a {:b {}}}"><span class="u" id="1488549874.002479">2017:03:03 14:04:34               schmee </span><span>I get this: </span><pre>user=&gt; (setval [:a :b :c] NONE {:a {:b {:c 1}}})
{:a {:b {}}}</pre></div><div data-t="schmee in 1.0.0"><span class="u" id="1488549879.002480">2017:03:03 14:04:39               schmee </span><span>in 1.0.0</span></div><div data-t="val_waeselynck maybe I have some classpath issue I don&apos;t understand, but I don&apos;t know how to find out..."><span class="u" id="1488549903.002481">2017:03:03 14:05:03       val_waeselynck </span><span>maybe I have some classpath issue I don&apos;t understand, but I don&apos;t know how to find out...</span></div><div data-t="val_waeselynck $ lein deps :tree | grep specter  yields"><span class="u" id="1488549915.002482">2017:03:03 14:05:15       val_waeselynck </span><code>$ lein deps :tree | grep specter</code><span> yields</span></div><div data-t="val_waeselynck  [com.rpl/specter &quot;1.0.0&quot;]"><span class="u" id="1488549919.002483">2017:03:03 14:05:19       val_waeselynck </span><code> [com.rpl/specter &quot;1.0.0&quot;]</code></div><div data-t="schmee 🤔"><span class="u" id="1488549941.002484">2017:03:03 14:05:41               schmee </span><b>🤔</b></div><div data-t="schmee have you tried restarting the repl?"><span class="u" id="1488549964.002485">2017:03:03 14:06:04               schmee </span><span>have you tried restarting the repl?</span></div><div data-t="schmee the catch-all solution  😛"><span class="u" id="1488549974.002486">2017:03:03 14:06:14               schmee </span><span>the catch-all solution </span><b>😛</b></div><div data-t="val_waeselynck yup"><span class="u" id="1488550004.002487">2017:03:03 14:06:44       val_waeselynck </span><span>yup</span></div><div data-t="val_waeselynck trying again after a  lein clean  ..."><span class="u" id="1488550019.002488">2017:03:03 14:06:59       val_waeselynck </span><span>trying again after a </span><code>lein clean</code><span> ...</span></div><div data-t="val_waeselynck see you in 2 minutes ^^"><span class="u" id="1488550028.002489">2017:03:03 14:07:08       val_waeselynck </span><span>see you in 2 minutes ^^</span></div><div data-t="val_waeselynck OK, it does work, awesome"><span class="u" id="1488550082.002490">2017:03:03 14:08:02       val_waeselynck </span><span>OK, it does work, awesome</span></div><div data-t="oskarkv Hi! New to specter. Is there any particular reason why the data is the last argument to, for example, transform, instead of the first like in update-in?"><span class="u" id="1488653327.002498">2017:03:04 18:48:47              oskarkv </span><span>Hi! New to specter. Is there any particular reason why the data is the last argument to, for example, transform, instead of the first like in update-in?</span></div><div data-t="schmee I would guess that it is to match  map ,  filter ,  remove  et. al"><span class="u" id="1488653967.002499">2017:03:04 18:59:27               schmee </span><span>I would guess that it is to match </span><code>map</code><span>, </span><code>filter</code><span>, </span><code>remove</code><span> et. al</span></div><div data-t="oskarkv Yeah, it matters mostly for -&gt; et al, I guess the question was not that important  🙂"><span class="u" id="1488654258.002500">2017:03:04 19:04:18              oskarkv </span><span>Yeah, it matters mostly for -&gt; et al, I guess the question was not that important </span><b>🙂</b></div><div data-t="schmee -&gt;&gt;  should do the trick then  🙂"><span class="u" id="1488654367.002501">2017:03:04 19:06:07               schmee </span><code>-&gt;&gt;</code><span> should do the trick then </span><b>🙂</b></div><div data-t="oskarkv yeah but i mean when you have several functions in a -&gt; or -&gt;&gt;  😛"><span class="u" id="1488654562.002502">2017:03:04 19:09:22              oskarkv </span><span>yeah but i mean when you have several functions in a -&gt; or -&gt;&gt; </span><b>😛</b></div><div data-t="schmee then you want  as-&gt;   🙂"><span class="u" id="1488654615.002503">2017:03:04 19:10:15               schmee </span><span>then you want </span><code>as-&gt;</code><span> </span><b>🙂</b></div><div data-t="oskarkv I started reading about specter like 30 min ago. It&apos;s amazing  🙂"><span class="u" id="1488656215.002504">2017:03:04 19:36:55              oskarkv </span><span>I started reading about specter like 30 min ago. It&apos;s amazing </span><b>🙂</b></div><div data-t="oskarkv I saw that there is a function,  select* , that seems to do the same thing as the macro  select . What&apos;s the  difference?"><span class="u" id="1488666688.002505">2017:03:04 22:31:28              oskarkv </span><span>I saw that there is a function, </span><code>select*</code><span>, that seems to do the same thing as the macro </span><code>select</code><span>. What&apos;s the  difference?</span></div><div data-t="oskarkv Oh, you need the precompiled path"><span class="u" id="1488666749.002507">2017:03:04 22:32:29              oskarkv </span><span>Oh, you need the precompiled path</span></div><div data-t="oskarkv Or, now I&apos;m not sure anymore, looks like the  select*  function calls compile on the path."><span class="u" id="1488667276.002508">2017:03:04 22:41:16              oskarkv </span><span>Or, now I&apos;m not sure anymore, looks like the </span><code>select*</code><span> function calls compile on the path.</span></div><div data-t="puzzler @oskarkv Use the macro  select  whenever possible -- it does more optimization magic, I believe.   select*  may be useful in a situation where you absolutely need a function (for example, as an input to a higher-order function like  map ).    For the most part, it&apos;s best to think of  select*  as an underlying implementation function, not really an important part of the end-user API.  [I&apos;m jumping in because you haven&apos;t gotten a response yet, but if anyone provides a more definitive answer, feel free to ignore mine]."><span class="u" id="1488698896.002510">2017:03:05 07:28:16              puzzler </span><span>@oskarkv Use the macro </span><code>select</code><span> whenever possible -- it does more optimization magic, I believe.  </span><code>select*</code><span> may be useful in a situation where you absolutely need a function (for example, as an input to a higher-order function like </span><code>map</code><span>).    For the most part, it&apos;s best to think of </span><code>select*</code><span> as an underlying implementation function, not really an important part of the end-user API.  [I&apos;m jumping in because you haven&apos;t gotten a response yet, but if anyone provides a more definitive answer, feel free to ignore mine].</span></div><div data-t="nathanmarz gave a bit more detail answering the question on github  https://github.com/nathanmarz/specter/issues/186"><span class="u" id="1488722204.002511">2017:03:05 13:56:44           nathanmarz </span><span>gave a bit more detail answering the question on github </span><a href="https://github.com/nathanmarz/specter/issues/186">https://github.com/nathanmarz/specter/issues/186</a></div><div data-t="vikeri Is there a simple way to get all the keys of a nested map?"><span class="u" id="1488836274.002513">2017:03:06 21:37:54               vikeri </span><span>Is there a simple way to get all the keys of a nested map?</span></div><div data-t="vikeri I suspect  walker  might be useful?"><span class="u" id="1488836292.002514">2017:03:06 21:38:12               vikeri </span><span>I suspect </span><code>walker</code><span> might be useful?</span></div><div data-t="tolitius @vikeri  http://gitpod.com/talks/config-plus-love/#33"><span class="u" id="1488836389.002515">2017:03:06 21:39:49             tolitius </span><span>@vikeri </span><a href="http://gitpod.com/talks/config-plus-love/#33">http://gitpod.com/talks/config-plus-love/#33</a></div><div data-t="vikeri @tolitius I actually just want the keywords
 (spfun {:hello {:hi “Hello” :kew :not-included} :included 123})
=&gt; (:hello :hi :kew :included)
"><span class="u" id="1488836585.002516">2017:03:06 21:43:05               vikeri </span><span>@tolitius I actually just want the keywords
</span><pre>(spfun {:hello {:hi “Hello” :kew :not-included} :included 123})
=&gt; (:hello :hi :kew :included)
</pre></div><div data-t="nathanmarz @vikeri
 (defn spfun [m]
  (let [p (recursive-path [] p
            (if-path map?
              (continue-then-stay MAP-VALS p)))]
    (select [p MAP-KEYS] m)
    ))
"><span class="u" id="1488838817.002518">2017:03:06 22:20:17           nathanmarz </span><span>@vikeri
</span><pre>(defn spfun [m]
  (let [p (recursive-path [] p
            (if-path map?
              (continue-then-stay MAP-VALS p)))]
    (select [p MAP-KEYS] m)
    ))
</pre></div><div data-t="ag do I need to do anything special to be able to use Specter in Clojurescript? 

when I try to require it like this: (require &apos;[com.rpl.specter :as sp])
I’m seeing bunch of errors"><span class="u" id="1488838912.002519">2017:03:06 22:21:52                   ag </span><span>do I need to do anything special to be able to use Specter in Clojurescript? 

when I try to require it like this: (require &apos;[com.rpl.specter :as sp])
I’m seeing bunch of errors</span></div><div data-t="nathanmarz it should work fine"><span class="u" id="1488838935.002520">2017:03:06 22:22:15           nathanmarz </span><span>it should work fine</span></div><div data-t="nathanmarz what errors are you seeing?"><span class="u" id="1488838938.002521">2017:03:06 22:22:18           nathanmarz </span><span>what errors are you seeing?</span></div><div data-t="ag :optimizations    :none"><span class="u" id="1488838990.002523">2017:03:06 22:23:10                   ag </span><code>:optimizations    :none</code></div><div data-t="nathanmarz is that a stack trace?"><span class="u" id="1488839090.002526">2017:03:06 22:24:50           nathanmarz </span><span>is that a stack trace?</span></div><div data-t="ag that’s what I’m seeing in browser window (dev tools)"><span class="u" id="1488839125.002527">2017:03:06 22:25:25                   ag </span><span>that’s what I’m seeing in browser window (dev tools)</span></div><div data-t="ag when I try to require specter"><span class="u" id="1488839140.002528">2017:03:06 22:25:40                   ag </span><span>when I try to require specter</span></div><div data-t="nathanmarz hmm, it doesn&apos;t say an error type or exception type?"><span class="u" id="1488839146.002529">2017:03:06 22:25:46           nathanmarz </span><span>hmm, it doesn&apos;t say an error type or exception type?</span></div><div data-t="nathanmarz oh is this being run with bootstrap?"><span class="u" id="1488839183.002530">2017:03:06 22:26:23           nathanmarz </span><span>oh is this being run with bootstrap?</span></div><div data-t="ag no, it’s a boot-clj project. 
I’m using [org.clojure/clojurescript   “1.9.293”]"><span class="u" id="1488839218.002531">2017:03:06 22:26:58                   ag </span><span>no, it’s a boot-clj project. 
I’m using [org.clojure/clojurescript   “1.9.293”]</span></div><div data-t="nathanmarz i&apos;m not sure how boot works"><span class="u" id="1488839270.002532">2017:03:06 22:27:50           nathanmarz </span><span>i&apos;m not sure how boot works</span></div><div data-t="nathanmarz this may be relevant:  https://github.com/nathanmarz/specter/issues/136"><span class="u" id="1488839273.002533">2017:03:06 22:27:53           nathanmarz </span><span>this may be relevant: </span><a href="https://github.com/nathanmarz/specter/issues/136">https://github.com/nathanmarz/specter/issues/136</a></div><div data-t="ag I’m gonna try to update to “1.9.494” of CLJS"><span class="u" id="1488839294.002534">2017:03:06 22:28:14                   ag </span><span>I’m gonna try to update to “1.9.494” of CLJS</span></div><div data-t="nathanmarz planck/bootstrap implement macros differently than normal clojurescript, and specter currently doesn&apos;t handle this"><span class="u" id="1488839382.002536">2017:03:06 22:29:42           nathanmarz </span><span>planck/bootstrap implement macros differently than normal clojurescript, and specter currently doesn&apos;t handle this</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/issues/72"><span class="u" id="1488839418.002537">2017:03:06 22:30:18           nathanmarz </span><a href="https://github.com/nathanmarz/specter/issues/72">https://github.com/nathanmarz/specter/issues/72</a></div><div data-t="ag bumping clojurescript version didn’t help. still saying same error  😞"><span class="u" id="1488839625.002538">2017:03:06 22:33:45                   ag </span><span>bumping clojurescript version didn’t help. still saying same error </span><b>😞</b></div><div data-t="ag I’m gonna try to repro in a smaller repo and will report"><span class="u" id="1488839650.002539">2017:03:06 22:34:10                   ag </span><span>I’m gonna try to repro in a smaller repo and will report</span></div><div data-t="ag Ha, interesting - actually when required in a file it works."><span class="u" id="1488839850.002540">2017:03:06 22:37:30                   ag </span><span>Ha, interesting - actually when required in a file it works.</span></div><div data-t="ag but when required in a repl - doesn&apos;t"><span class="u" id="1488839861.002541">2017:03:06 22:37:41                   ag </span><span>but when required in a repl - doesn&apos;t</span></div><div data-t="ag ¯\(ツ)/¯"><span class="u" id="1488839865.002542">2017:03:06 22:37:45                   ag </span><span>¯\(ツ)/¯</span></div><div data-t="nathanmarz @ag thanks, just open an issue on github"><span class="u" id="1488840701.002543">2017:03:06 22:51:41           nathanmarz </span><span>@ag thanks, just open an issue on github</span></div><div data-t="schmee how do I remove all keys where the value is  ”_&quot;  from a hash like this?  {:dim1 &quot;slice1&quot;, :dim2 &quot;slice2&quot;, :dim3 “_”}"><span class="u" id="1489007971.002551">2017:03:08 21:19:31               schmee </span><span>how do I remove all keys where the value is </span><code>”_&quot;</code><span> from a hash like this? </span><pre>{:dim1 &quot;slice1&quot;, :dim2 &quot;slice2&quot;, :dim3 “_”}</pre></div><div data-t="schmee I’ve tried various incantations of  selected? ,  subselect  and  filterer , and I can’t figure out what goes where"><span class="u" id="1489008039.002552">2017:03:08 21:20:39               schmee </span><span>I’ve tried various incantations of </span><code>selected?</code><span>, </span><code>subselect</code><span> and </span><code>filterer</code><span>, and I can’t figure out what goes where</span></div><div data-t="schmee or if that is even the right approach"><span class="u" id="1489008047.002553">2017:03:08 21:20:47               schmee </span><span>or if that is even the right approach</span></div><div data-t="tolitius @schmee:  boot.user=&gt; (setval [MAP-VALS #(= % &quot;_&quot;)] NONE data)
{:dim1 &quot;slice1&quot;, :dim2 &quot;slice2&quot;}"><span class="u" id="1489008175.002554">2017:03:08 21:22:55             tolitius </span><span>@schmee: </span><pre>boot.user=&gt; (setval [MAP-VALS #(= % &quot;_&quot;)] NONE data)
{:dim1 &quot;slice1&quot;, :dim2 &quot;slice2&quot;}</pre></div><div data-t="schmee neat, thanks!"><span class="u" id="1489008248.002555">2017:03:08 21:24:08               schmee </span><span>neat, thanks!</span></div><div data-t="schmee feel like cheating to use setval, I’m so used to immutability that anything involving “set” makes me nervous  😄"><span class="u" id="1489008288.002556">2017:03:08 21:24:48               schmee </span><span>feel like cheating to use setval, I’m so used to immutability that anything involving “set” makes me nervous </span><b>😄</b></div><div data-t="schmee is there a way to do it with  select  though?"><span class="u" id="1489008412.002557">2017:03:08 21:26:52               schmee </span><span>is there a way to do it with </span><code>select</code><span> though?</span></div><div data-t="schmee to reformulate, “select all keys that are not  ”_” &quot;"><span class="u" id="1489008467.002558">2017:03:08 21:27:47               schmee </span><span>to reformulate, “select all keys that are not </span><code>”_”</code><span>&quot;</span></div><div data-t="tolitius boot.user=&gt; (select [ALL #(-&gt; % val (not= &quot;_&quot;))] data)
[[:dim1 &quot;slice1&quot;] [:dim2 &quot;slice2&quot;]] 
but this is not the right solution, since it does not return you a map + this would likely be better solved with creating a separate navigator.. which I did not wrap my head around yet"><span class="u" id="1489008944.002559">2017:03:08 21:35:44             tolitius </span><pre>boot.user=&gt; (select [ALL #(-&gt; % val (not= &quot;_&quot;))] data)
[[:dim1 &quot;slice1&quot;] [:dim2 &quot;slice2&quot;]]</pre><span>
but this is not the right solution, since it does not return you a map + this would likely be better solved with creating a separate navigator.. which I did not wrap my head around yet</span></div><div data-t="schmee yeah, this is where I ended up as well"><span class="u" id="1489008987.002560">2017:03:08 21:36:27               schmee </span><span>yeah, this is where I ended up as well</span></div><div data-t="schmee it seems there is no way to keep the hash when using  select"><span class="u" id="1489009005.002562">2017:03:08 21:36:45               schmee </span><span>it seems there is no way to keep the hash when using </span><code>select</code></div><div data-t="tolitius I don&apos;t think  setval  is wrong though"><span class="u" id="1489009080.002564">2017:03:08 21:38:00             tolitius </span><span>I don&apos;t think </span><code>setval</code><span> is wrong though</span></div><div data-t="tolitius since you are removing / filtering the map entries"><span class="u" id="1489009108.002565">2017:03:08 21:38:28             tolitius </span><span>since you are removing / filtering the map entries</span></div><div data-t="schmee indeed, but sometimes you want  filter  and sometimes you want  remove , so I hope there is something equivalent in Specter  🙂"><span class="u" id="1489009161.002566">2017:03:08 21:39:21               schmee </span><span>indeed, but sometimes you want </span><code>filter</code><span> and sometimes you want </span><code>remove</code><span>, so I hope there is something equivalent in Specter </span><b>🙂</b></div><div data-t="tolitius do  (source remove) , it is filter underneath"><span class="u" id="1489009205.002568">2017:03:08 21:40:05             tolitius </span><span>do </span><code>(source remove)</code><span>, it is filter underneath</span></div><div data-t="tolitius i.e.  (filter (complement pred))"><span class="u" id="1489009231.002569">2017:03:08 21:40:31             tolitius </span><span>i.e. </span><code>(filter (complement pred))</code></div><div data-t="tolitius i.e.  setval  does not mutate the original data structure"><span class="u" id="1489009272.002570">2017:03:08 21:41:12             tolitius </span><span>i.e. </span><code>setval</code><span> does not mutate the original data structure</span></div><div data-t="schmee I know, and the  setval  approach works just fine, but aesthetically having both  filter  and  remove  can make the code read nicer"><span class="u" id="1489009586.002571">2017:03:08 21:46:26               schmee </span><span>I know, and the </span><code>setval</code><span> approach works just fine, but aesthetically having both </span><code>filter</code><span> and </span><code>remove</code><span> can make the code read nicer</span></div><div data-t="schmee which is why I want to use specter at all in this case, otherwise I’d just do  (into {} (remove #(= &quot;_&quot; (val %)) data))"><span class="u" id="1489009629.002572">2017:03:08 21:47:09               schmee </span><span>which is why I want to use specter at all in this case, otherwise I’d just do </span><code>(into {} (remove #(= &quot;_&quot; (val %)) data))</code></div><div data-t="schmee I’m hunting for use-cases in my own code where Specter makes sense, that’s why I’m trying to shoehorn it a bit in this case"><span class="u" id="1489009711.002574">2017:03:08 21:48:31               schmee </span><span>I’m hunting for use-cases in my own code where Specter makes sense, that’s why I’m trying to shoehorn it a bit in this case</span></div><div data-t="tolitius makes sense. I think  select  will always return you a sequence though"><span class="u" id="1489009751.002575">2017:03:08 21:49:11             tolitius </span><span>makes sense. I think </span><code>select</code><span> will always return you a sequence though</span></div><div data-t="nathanmarz @schmee keep in mind that the  setval  approach will maintain the type of map and also be significantly faster than the  (into {} ...)  approach"><span class="u" id="1489010706.002577">2017:03:08 22:05:06           nathanmarz </span><span>@schmee keep in mind that the </span><code>setval</code><span> approach will maintain the type of map and also be significantly faster than the </span><code>(into {} ...)</code><span> approach</span></div><div data-t="chromalchemy I am trying to filter a map, but return a map, not just the filtered values. I can use setval, but how do I go one level deep?

 {:id1 {:a false} :id2 {:a true}}  -&gt; {:id2 {:a true}}  using something like  (setval [MAP-VALS :a true?] ....)"><span class="u" id="1489100888.651624">2017:03:09 23:08:08         chromalchemy </span><span>I am trying to filter a map, but return a map, not just the filtered values. I can use setval, but how do I go one level deep?

</span><code>{:id1 {:a false} :id2 {:a true}}  -&gt; {:id2 {:a true}}</code><span> using something like </span><code>(setval [MAP-VALS :a true?] ....)</code></div><div data-t="nathanmarz @chromalchemy I think you&apos;re looking for:
 (setval [MAP-VALS (selected? :a (complement identity))] NONE data)
"><span class="u" id="1489101067.678140">2017:03:09 23:11:07           nathanmarz </span><span>@chromalchemy I think you&apos;re looking for:
</span><pre>(setval [MAP-VALS (selected? :a (complement identity))] NONE data)
</pre></div><div data-t="chromalchemy Perfect Thanks!!! Trying to understand  (selected?) . What is the difference between  [ALL even?]  and  [ALL (selected? even?)] ?"><span class="u" id="1489102011.808765">2017:03:09 23:26:51         chromalchemy </span><span>Perfect Thanks!!! Trying to understand </span><code>(selected?)</code><span>. What is the difference between </span><code>[ALL even?]</code><span> and </span><code>[ALL (selected? even?)]</code><span>?</span></div><div data-t="nathanmarz those particular examples are equivalent"><span class="u" id="1489102059.814831">2017:03:09 23:27:39           nathanmarz </span><span>those particular examples are equivalent</span></div><div data-t="nathanmarz selected?  in general is a filter on whether the path selects anything"><span class="u" id="1489102076.817127">2017:03:09 23:27:56           nathanmarz </span><code>selected?</code><span> in general is a filter on whether the path selects anything</span></div><div data-t="nathanmarz if you only give it functions it&apos;s the same as just using those functions directly in the path"><span class="u" id="1489102099.819906">2017:03:09 23:28:19           nathanmarz </span><span>if you only give it functions it&apos;s the same as just using those functions directly in the path</span></div><div data-t="chromalchemy Ok so if the path does not &quot;select&quot; a thing, then it is effectively filtered out of the result."><span class="u" id="1489102191.831970">2017:03:09 23:29:51         chromalchemy </span><span>Ok so if the path does not &quot;select&quot; a thing, then it is effectively filtered out of the result.</span></div><div data-t="chromalchemy Thank you again for Specter and the recent push to 1.0!!! I was surprised to read the consternated feedback on reddit. As a relative noob, it is for me much more obvious and empowering than than the walls I regularly run into when trying to juggle basic clojure functions to screen and transform data for UI stuff in cljs."><span class="u" id="1489102439.866079">2017:03:09 23:33:59         chromalchemy </span><span>Thank you again for Specter and the recent push to 1.0!!! I was surprised to read the consternated feedback on reddit. As a relative noob, it is for me much more obvious and empowering than than the walls I regularly run into when trying to juggle basic clojure functions to screen and transform data for UI stuff in cljs.</span></div><div data-t="chromalchemy Still a bit confused why  (setval
      [MAP-VALS (selected? :a true?)]
      NONE
      {:id1 {:a false} :id2 {:a true}})  returns  {:id1 {:a false}} 
But i&apos;m up an running nonetheless  simple_smile"><span class="u" id="1489103242.971040">2017:03:09 23:47:22         chromalchemy </span><span>Still a bit confused why </span><pre>(setval
      [MAP-VALS (selected? :a true?)]
      NONE
      {:id1 {:a false} :id2 {:a true}})</pre><span> returns </span><code>{:id1 {:a false}}</code><span>
But i&apos;m up an running nonetheless </span><b>simple_smile</b></div><div data-t="chromalchemy I guess  NONE  gets rid of the maps that pass the  true?  test."><span class="u" id="1489103331.981706">2017:03:09 23:48:51         chromalchemy </span><span>I guess </span><code>NONE</code><span> gets rid of the maps that pass the </span><code>true?</code><span> test.</span></div><div data-t="nathanmarz @chromalchemy yes, that&apos;s right"><span class="u" id="1489103367.985681">2017:03:09 23:49:27           nathanmarz </span><span>@chromalchemy yes, that&apos;s right</span></div><div data-t="nathanmarz that code is selecting which values to remove (as opposed to which values to keep)"><span class="u" id="1489103396.988932">2017:03:09 23:49:56           nathanmarz </span><span>that code is selecting which values to remove (as opposed to which values to keep)</span></div><div data-t="chromalchemy Ok , got it. Thx for the clarification."><span class="u" id="1489103462.997182">2017:03:09 23:51:02         chromalchemy </span><span>Ok , got it. Thx for the clarification.</span></div><div data-t="tolitius @nathanmarz  (setval [MAP-VALS (comp not :a)] NONE data)  would also work, what would be the difference in it vs.  (setval [MAP-VALS (selected? :a (complement identity))] NONE data)"><span class="u" id="1489114241.091777">2017:03:10 02:50:41             tolitius </span><span>@nathanmarz </span><pre>(setval [MAP-VALS (comp not :a)] NONE data)</pre><span> would also work, what would be the difference in it vs. </span><pre>(setval [MAP-VALS (selected? :a (complement identity))] NONE data)</pre></div><div data-t="nathanmarz @tolitius same thing"><span class="u" id="1489114372.102721">2017:03:10 02:52:52           nathanmarz </span><span>@tolitius same thing</span></div><div data-t="tolitius would  selected?  be more performant?"><span class="u" id="1489114389.104098">2017:03:10 02:53:09             tolitius </span><span>would </span><code>selected?</code><span> be more performant?</span></div><div data-t="nathanmarz definitely not"><span class="u" id="1489114398.104853">2017:03:10 02:53:18           nathanmarz </span><span>definitely not</span></div><div data-t="nathanmarz the comp approach might be slightly more performant"><span class="u" id="1489114408.105624">2017:03:10 02:53:28           nathanmarz </span><span>the comp approach might be slightly more performant</span></div><div data-t="nathanmarz pretty minor though"><span class="u" id="1489114433.107726">2017:03:10 02:53:53           nathanmarz </span><span>pretty minor though</span></div><div data-t="tolitius thanks. trying to reason when to use an  fn  vs. a navigator"><span class="u" id="1489114525.116298">2017:03:10 02:55:25             tolitius </span><span>thanks. trying to reason when to use an </span><code>fn</code><span> vs. a navigator</span></div><div data-t="nathanmarz in this case it doesn&apos;t really matter"><span class="u" id="1489116182.251730">2017:03:10 03:23:02           nathanmarz </span><span>in this case it doesn&apos;t really matter</span></div><div data-t="firesofmay Hi,
I am interested in contributing to specter. Just for fun/learning. But I am not sure which issue I should pick. I don&apos;t know where to begin with the issues already opened. Can someone point me to a good starting bug?
Thanks"><span class="u" id="1489260650.712785">2017:03:11 19:30:50           firesofmay </span><span>Hi,
I am interested in contributing to specter. Just for fun/learning. But I am not sure which issue I should pick. I don&apos;t know where to begin with the issues already opened. Can someone point me to a good starting bug?
Thanks</span></div><div data-t="nathanmarz @firesofmay thanks for the contribution you already made"><span class="u" id="1489260700.716022">2017:03:11 19:31:40           nathanmarz </span><span>@firesofmay thanks for the contribution you already made</span></div><div data-t="firesofmay @nathanmarz thanks for your contributions to so many projects  🙂"><span class="u" id="1489260747.719467">2017:03:11 19:32:27           firesofmay </span><span>@nathanmarz thanks for your contributions to so many projects </span><b>🙂</b></div><div data-t="nathanmarz there&apos;s not too much to be added to specter at the moment, I took care of most of the open issues for 1.0"><span class="u" id="1489260755.719977">2017:03:11 19:32:35           nathanmarz </span><span>there&apos;s not too much to be added to specter at the moment, I took care of most of the open issues for 1.0</span></div><div data-t="nathanmarz this is probably the most self-contained issue:  https://github.com/nathanmarz/specter/issues/183"><span class="u" id="1489260764.720480">2017:03:11 19:32:44           nathanmarz </span><span>this is probably the most self-contained issue: </span><a href="https://github.com/nathanmarz/specter/issues/183">https://github.com/nathanmarz/specter/issues/183</a></div><div data-t="nathanmarz the most important improvement I&apos;m targeting for next version is  https://github.com/nathanmarz/specter/issues/72"><span class="u" id="1489260804.723113">2017:03:11 19:33:24           nathanmarz </span><span>the most important improvement I&apos;m targeting for next version is </span><a href="https://github.com/nathanmarz/specter/issues/72">https://github.com/nathanmarz/specter/issues/72</a></div><div data-t="nathanmarz but that one is pretty difficult due to needing to have some understanding of what&apos;s going on in the inline compiler"><span class="u" id="1489260842.725525">2017:03:11 19:34:02           nathanmarz </span><span>but that one is pretty difficult due to needing to have some understanding of what&apos;s going on in the inline compiler</span></div><div data-t="firesofmay Hmm"><span class="u" id="1489260852.726157">2017:03:11 19:34:12           firesofmay </span><span>Hmm</span></div><div data-t="nathanmarz plus the complexity of targeting three platforms simultaneously"><span class="u" id="1489260859.726740">2017:03:11 19:34:19           nathanmarz </span><span>plus the complexity of targeting three platforms simultaneously</span></div><div data-t="nathanmarz this one would be nice too:  https://github.com/nathanmarz/specter/issues/149"><span class="u" id="1489260890.728804">2017:03:11 19:34:50           nathanmarz </span><span>this one would be nice too: </span><a href="https://github.com/nathanmarz/specter/issues/149">https://github.com/nathanmarz/specter/issues/149</a></div><div data-t="nathanmarz probably won&apos;t be very much code, but will require understanding some of the inline compiler"><span class="u" id="1489260904.729705">2017:03:11 19:35:04           nathanmarz </span><span>probably won&apos;t be very much code, but will require understanding some of the inline compiler</span></div><div data-t="nathanmarz oh, and this one:  https://github.com/nathanmarz/specter/issues/39"><span class="u" id="1489260935.731558">2017:03:11 19:35:35           nathanmarz </span><span>oh, and this one: </span><a href="https://github.com/nathanmarz/specter/issues/39">https://github.com/nathanmarz/specter/issues/39</a></div><div data-t="nathanmarz that one is much easier than the ones that deal with the inline compiler"><span class="u" id="1489260949.732567">2017:03:11 19:35:49           nathanmarz </span><span>that one is much easier than the ones that deal with the inline compiler</span></div><div data-t="nathanmarz just need to re-implement protocol paths in terms of primitives shared between cljs and clj"><span class="u" id="1489260961.733342">2017:03:11 19:36:01           nathanmarz </span><span>just need to re-implement protocol paths in terms of primitives shared between cljs and clj</span></div><div data-t="firesofmay I haven&apos;t tried protocol for cljs. Any reference doc?"><span class="u" id="1489260989.735020">2017:03:11 19:36:29           firesofmay </span><span>I haven&apos;t tried protocol for cljs. Any reference doc?</span></div><div data-t="nathanmarz https://github.com/clojure/clojurescript/wiki/Differences-from-Clojure"><span class="u" id="1489261026.737271">2017:03:11 19:37:06           nathanmarz </span><a href="https://github.com/clojure/clojurescript/wiki/Differences-from-Clojure">https://github.com/clojure/clojurescript/wiki/Differences-from-Clojure</a></div><div data-t="nathanmarz that lists the differences"><span class="u" id="1489261031.737506">2017:03:11 19:37:11           nathanmarz </span><span>that lists the differences</span></div><div data-t="firesofmay Also in  Regex navigator  Can you share input output examples?"><span class="u" id="1489261033.737651">2017:03:11 19:37:13           firesofmay </span><span>Also in </span><code>Regex navigator</code><span> Can you share input output examples?</span></div><div data-t="nathanmarz the main difference is lack of  extend  function, which is what Specter currently uses for protocol paths"><span class="u" id="1489261048.738679">2017:03:11 19:37:28           nathanmarz </span><span>the main difference is lack of </span><code>extend</code><span> function, which is what Specter currently uses for protocol paths</span></div><div data-t="nathanmarz (setval (regex-all #&quot;aa*&quot;) &quot;Q&quot; &quot;aaabcaad&quot;) ;; =&gt; &quot;QbcQd&quot;"><span class="u" id="1489261170.746636">2017:03:11 19:39:30           nathanmarz </span><code>(setval (regex-all #&quot;aa*&quot;) &quot;Q&quot; &quot;aaabcaad&quot;) ;; =&gt; &quot;QbcQd&quot;</code></div><div data-t="nathanmarz and this too:  (setval (regex-first #&quot;aa*&quot;) &quot;Q&quot; &quot;aaabcaad&quot;) ;; =&gt; &quot;Qbcaad&quot;"><span class="u" id="1489261212.749164">2017:03:11 19:40:12           nathanmarz </span><span>and this too: </span><code>(setval (regex-first #&quot;aa*&quot;) &quot;Q&quot; &quot;aaabcaad&quot;) ;; =&gt; &quot;Qbcaad&quot;</code></div><div data-t="firesofmay This looks interesting. And a bit more easy to do I guess. So to implement this functionality where should I start looking at?  setval  fn?"><span class="u" id="1489261297.754544">2017:03:11 19:41:37           firesofmay </span><span>This looks interesting. And a bit more easy to do I guess. So to implement this functionality where should I start looking at? </span><code>setval</code><span> fn?</span></div><div data-t="nathanmarz it would just be a new navigator"><span class="u" id="1489261337.756953">2017:03:11 19:42:17           nathanmarz </span><span>it would just be a new navigator</span></div><div data-t="nathanmarz using  defnav"><span class="u" id="1489261342.757288">2017:03:11 19:42:22           nathanmarz </span><span>using </span><code>defnav</code></div><div data-t="nathanmarz look at the implementation of existing navigators to see how it works"><span class="u" id="1489261353.758002">2017:03:11 19:42:33           nathanmarz </span><span>look at the implementation of existing navigators to see how it works</span></div><div data-t="firesofmay Great. I&apos;ll check it out  🙂"><span class="u" id="1489261370.759017">2017:03:11 19:42:50           firesofmay </span><span>Great. I&apos;ll check it out </span><b>🙂</b></div><div data-t="nathanmarz awesome"><span class="u" id="1489261381.759768">2017:03:11 19:43:01           nathanmarz </span><span>awesome</span></div><div data-t="firesofmay @nathanmarz Btw I had a question. I noticed in your  project.clj  file you have  (def VERSION (.trim (slurp &quot;VERSION&quot;)))  and  (defproject com.rpl/specter VERSION 
What benefit does this provide?"><span class="u" id="1489261787.784902">2017:03:11 19:49:47           firesofmay </span><span>@nathanmarz Btw I had a question. I noticed in your </span><code>project.clj</code><span> file you have </span><code>(def VERSION (.trim (slurp &quot;VERSION&quot;)))</code><span> and </span><code>(defproject com.rpl/specter VERSION</code><span>
What benefit does this provide?</span></div><div data-t="nathanmarz @firesofmay if I have submodules in the project, that makes it easy to have them all share the same version"><span class="u" id="1489262313.817435">2017:03:11 19:58:33           nathanmarz </span><span>@firesofmay if I have submodules in the project, that makes it easy to have them all share the same version</span></div><div data-t="nathanmarz like if there were a  specter-graph  module with navigators for working with graphs"><span class="u" id="1489262330.818463">2017:03:11 19:58:50           nathanmarz </span><span>like if there were a </span><code>specter-graph</code><span> module with navigators for working with graphs</span></div><div data-t="firesofmay @nathanmarz Ah they all just point to the same file and you just have to bump one single file. Make sense"><span class="u" id="1489262364.820698">2017:03:11 19:59:24           firesofmay </span><span>@nathanmarz Ah they all just point to the same file and you just have to bump one single file. Make sense</span></div><div data-t="nathanmarz yea"><span class="u" id="1489262372.821248">2017:03:11 19:59:32           nathanmarz </span><span>yea</span></div><div data-t="oskarkv How is (keypath :a) different from just :a in paths?"><span class="u" id="1489502070.870543">2017:03:14 14:34:30              oskarkv </span><span>How is (keypath :a) different from just :a in paths?</span></div><div data-t="nathanmarz @oskarkv it&apos;s the same thing"><span class="u" id="1489502408.015653">2017:03:14 14:40:08           nathanmarz </span><span>@oskarkv it&apos;s the same thing</span></div><div data-t="nathanmarz keywords implicitly convert themselves to that  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L984"><span class="u" id="1489502432.025990">2017:03:14 14:40:32           nathanmarz </span><span>keywords implicitly convert themselves to that </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L984">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L984</a></div><div data-t="nathanmarz likewise, functions implicitly convert themselves to  pred   https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L988"><span class="u" id="1489502469.041907">2017:03:14 14:41:09           nathanmarz </span><span>likewise, functions implicitly convert themselves to </span><code>pred</code><span> </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L988">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L988</a></div><div data-t="oskarkv ok, thanks"><span class="u" id="1489502537.071584">2017:03:14 14:42:17              oskarkv </span><span>ok, thanks</span></div><div data-t="mars0i I&apos;m confused about how  continue-then-stay  works, for example in  (continue-then-stay MAP-VALS p)  from a recent example in this channeel."><span class="u" id="1489547289.428704">2017:03:15 03:08:09               mars0i </span><span>I&apos;m confused about how </span><code>continue-then-stay</code><span> works, for example in </span><code>(continue-then-stay MAP-VALS p)</code><span> from a recent example in this channeel.</span></div><div data-t="mars0i I&apos;m also a bit confused about  recursive-path , although I&apos;ve used it successfully by modifying an example in the &quot;missing piece&quot; blog post.  In  (recursive-path []  p (if-path vector? [ALL p] STAY)) , what is  p  bound to when it finds a vector, and why is  p  put after  ALL ?  (Also, what&apos;s the meaning of second argument  [] ?)   recursive-path  seems very useful, but I gather it&apos;s new since it doesn&apos;t have a docstring or other documentation yet that I&apos;ve found."><span class="u" id="1489548384.544617">2017:03:15 03:26:24               mars0i </span><span>I&apos;m also a bit confused about </span><code>recursive-path</code><span>, although I&apos;ve used it successfully by modifying an example in the &quot;missing piece&quot; blog post.  In </span><code>(recursive-path []  p (if-path vector? [ALL p] STAY))</code><span>, what is </span><code>p</code><span> bound to when it finds a vector, and why is </span><code>p</code><span> put after </span><code>ALL</code><span>?  (Also, what&apos;s the meaning of second argument </span><code>[]</code><span>?)  </span><code>recursive-path</code><span> seems very useful, but I gather it&apos;s new since it doesn&apos;t have a docstring or other documentation yet that I&apos;ve found.</span></div><div data-t="oskarkv Apparently I don&apos;t understand how  not-selected?  works.  (select [:a (not-selected? :c)] {:a 1 :b {:a 1 :b 2}})  I expected to return something since :c does not exist. &quot;Stops navigation if the path navigator finds a result. Otherwise continues with the current structure.&quot; It couldn&apos;t have found :c, so the current structure is 1, because that&apos;s what just :a gives?"><span class="u" id="1489574111.372605">2017:03:15 10:35:11              oskarkv </span><span>Apparently I don&apos;t understand how </span><code>not-selected?</code><span> works. </span><code>(select [:a (not-selected? :c)] {:a 1 :b {:a 1 :b 2}})</code><span> I expected to return something since :c does not exist. &quot;Stops navigation if the path navigator finds a result. Otherwise continues with the current structure.&quot; It couldn&apos;t have found :c, so the current structure is 1, because that&apos;s what just :a gives?</span></div><div data-t="nathanmarz @oskarkv but  :c  always navigates to something"><span class="u" id="1489574815.530260">2017:03:15 10:46:55           nathanmarz </span><span>@oskarkv but </span><code>:c</code><span> always navigates to something</span></div><div data-t="nathanmarz in this case to  nil"><span class="u" id="1489574819.531123">2017:03:15 10:46:59           nathanmarz </span><span>in this case to </span><code>nil</code></div><div data-t="nathanmarz if you do  (must :c) , that only navigates if  :c  exists in the map"><span class="u" id="1489574835.534330">2017:03:15 10:47:15           nathanmarz </span><span>if you do </span><code>(must :c)</code><span>, that only navigates if </span><code>:c</code><span> exists in the map</span></div><div data-t="nathanmarz @mars0i  continue-then-stay  does literally what it says"><span class="u" id="1489574924.554264">2017:03:15 10:48:44           nathanmarz </span><span>@mars0i </span><code>continue-then-stay</code><span> does literally what it says</span></div><div data-t="nathanmarz first it navigates to the given path"><span class="u" id="1489574930.555655">2017:03:15 10:48:50           nathanmarz </span><span>first it navigates to the given path</span></div><div data-t="nathanmarz then it navigates to itself"><span class="u" id="1489574937.557252">2017:03:15 10:48:57           nathanmarz </span><span>then it navigates to itself</span></div><div data-t="nathanmarz (transform (continue-then-stay STAY) inc 1)  will return  3 , because it navigates to itself, then navigates to itself again"><span class="u" id="1489574996.570439">2017:03:15 10:49:56           nathanmarz </span><code>(transform (continue-then-stay STAY) inc 1)</code><span> will return </span><code>3</code><span>, because it navigates to itself, then navigates to itself again</span></div><div data-t="nathanmarz p  in that example is bound to itself (aka the entire path definition given )"><span class="u" id="1489575048.582391">2017:03:15 10:50:48           nathanmarz </span><code>p</code><span> in that example is bound to itself (aka the entire path definition given )</span></div><div data-t="nathanmarz so for  TREE-VALUES , what it&apos;s saying is: if navigated at a vector, navigate to each element of the vector and recurse"><span class="u" id="1489575084.590294">2017:03:15 10:51:24           nathanmarz </span><span>so for </span><code>TREE-VALUES</code><span>, what it&apos;s saying is: if navigated at a vector, navigate to each element of the vector and recurse</span></div><div data-t="nathanmarz otherwise (meaning not at a vector), just stay navigated at that point (finish recursing)"><span class="u" id="1489575109.595940">2017:03:15 10:51:49           nathanmarz </span><span>otherwise (meaning not at a vector), just stay navigated at that point (finish recursing)</span></div><div data-t="nathanmarz the  []  argument i used to specify arguments to the resulting path"><span class="u" id="1489575204.617313">2017:03:15 10:53:24           nathanmarz </span><span>the </span><code>[]</code><span> argument i used to specify arguments to the resulting path</span></div><div data-t="nathanmarz basically the result of  recursive-path  will be a function if any arguments are provided"><span class="u" id="1489575217.620004">2017:03:15 10:53:37           nathanmarz </span><span>basically the result of </span><code>recursive-path</code><span> will be a function if any arguments are provided</span></div><div data-t="oskarkv Oh, OK. Thanks!"><span class="u" id="1489575355.651071">2017:03:15 10:55:55              oskarkv </span><span>Oh, OK. Thanks!</span></div><div data-t="nathanmarz @oskarkv oh just noticed you were navigating to  :a  first, don&apos;t think that path is what you want"><span class="u" id="1489578889.383153">2017:03:15 11:54:49           nathanmarz </span><span>@oskarkv oh just noticed you were navigating to </span><code>:a</code><span> first, don&apos;t think that path is what you want</span></div><div data-t="oskarkv I was just playing around to learn  😛"><span class="u" id="1489580131.653229">2017:03:15 12:15:31              oskarkv </span><span>I was just playing around to learn </span><b>😛</b></div><div data-t="mars0i Thanks @nathanmarz.  That&apos;s very helpful.  I&apos;m still trying to get my head wrapped around some things that aren&apos;t intuitive for me yet. I still don&apos;t understand what  p  is doing in  if-path  branches in  recursive-path .  Here&apos;s an example I&apos;ve been using:"><span class="u" id="1489588991.506191">2017:03:15 14:43:11               mars0i </span><span>Thanks @nathanmarz.  That&apos;s very helpful.  I&apos;m still trying to get my head wrapped around some things that aren&apos;t intuitive for me yet. I still don&apos;t understand what </span><code>p</code><span> is doing in </span><code>if-path</code><span> branches in </span><code>recursive-path</code><span>.  Here&apos;s an example I&apos;ve been using:</span></div><div data-t="mars0i (def a {:a1 {:b1 {:c1 1, :c2 2}, :b2 {:c1 3, :c2 4}},
 :a2 {:b1 {:c1 5, :c2 6}, :b2 {:c1 7, :c2 8}}})"><span class="u" id="1489589034.524259">2017:03:15 14:43:54               mars0i </span><pre>(def a {:a1 {:b1 {:c1 1, :c2 2}, :b2 {:c1 3, :c2 4}},
 :a2 {:b1 {:c1 5, :c2 6}, :b2 {:c1 7, :c2 8}}})</pre></div><div data-t="mars0i (select [(recursive-path [] p (if-path map? [MAP-VALS p] [STAY]))] a)  produces  [1 2 3 4 5 6 7 8] , i.e. the leaf node values.  Why do I follow  MAP-VALS  with  p ?  Leaving out  p   just produces the original map wrapped in a vector, so I know I need  p , to get the leaf nodes, but I don&apos;t understand why.  Normally, if I have a path operator like  MAP-VALS  in a vector, it&apos;s the first navigation operation, and then the next one is applied, and so on.  Here it feels as if  p  is an argument that&apos;s passed to  MAP-VALS , maybe.  Is that correct?  So that  [MAP-VALS p]  within  recursive-path   (or  if-path ?) is semantically different from, a sequence of navigators immediately after  select  or  transform ?"><span class="u" id="1489589311.640429">2017:03:15 14:48:31               mars0i </span><code>(select [(recursive-path [] p (if-path map? [MAP-VALS p] [STAY]))] a)</code><span> produces </span><code>[1 2 3 4 5 6 7 8]</code><span>, i.e. the leaf node values.  Why do I follow </span><code>MAP-VALS</code><span> with </span><code>p</code><span>?  Leaving out </span><code>p</code><span>  just produces the original map wrapped in a vector, so I know I need </span><code>p</code><span>, to get the leaf nodes, but I don&apos;t understand why.  Normally, if I have a path operator like </span><code>MAP-VALS</code><span> in a vector, it&apos;s the first navigation operation, and then the next one is applied, and so on.  Here it feels as if </span><code>p</code><span> is an argument that&apos;s passed to </span><code>MAP-VALS</code><span>, maybe.  Is that correct?  So that </span><code>[MAP-VALS p]</code><span> within </span><code>recursive-path</code><span>  (or </span><code>if-path</code><span>?) is semantically different from, a sequence of navigators immediately after </span><code>select</code><span> or </span><code>transform</code><span>?</span></div><div data-t="nathanmarz no,  p  is just the next navigation to do after  MAP-VALS"><span class="u" id="1489589340.652575">2017:03:15 14:49:00           nathanmarz </span><span>no, </span><code>p</code><span> is just the next navigation to do after </span><code>MAP-VALS</code></div><div data-t="nathanmarz think of it just like regular recursion"><span class="u" id="1489589358.660248">2017:03:15 14:49:18           nathanmarz </span><span>think of it just like regular recursion</span></div><div data-t="nathanmarz (defn foo [i]
  (if (= 0 i)
    1
    (* 2 (foo (dec i)))))
"><span class="u" id="1489589361.661270">2017:03:15 14:49:21           nathanmarz </span><pre>(defn foo [i]
  (if (= 0 i)
    1
    (* 2 (foo (dec i)))))
</pre></div><div data-t="mars0i What is the value of  p ?"><span class="u" id="1489589363.662081">2017:03:15 14:49:23               mars0i </span><span>What is the value of </span><code>p</code><span>?</span></div><div data-t="nathanmarz foo  refers to itself there, just like how  p  refers to the overall path"><span class="u" id="1489589377.668331">2017:03:15 14:49:37           nathanmarz </span><code>foo</code><span> refers to itself there, just like how </span><code>p</code><span> refers to the overall path</span></div><div data-t="nathanmarz p  is  (if-path map? [MAP-VALS p] [STAY]))"><span class="u" id="1489589388.672869">2017:03:15 14:49:48           nathanmarz </span><code>p</code><span> is </span><code>(if-path map? [MAP-VALS p] [STAY]))</code></div><div data-t="nathanmarz the effect of using  p  there is to continue going to all map vals until a non-map is encountered"><span class="u" id="1489589418.685041">2017:03:15 14:50:18           nathanmarz </span><span>the effect of using </span><code>p</code><span> there is to continue going to all map vals until a non-map is encountered</span></div><div data-t="mars0i I know I might seem dense.  I&apos;m just not in the mindset yet, but want to be."><span class="u" id="1489589435.692564">2017:03:15 14:50:35               mars0i </span><span>I know I might seem dense.  I&apos;m just not in the mindset yet, but want to be.</span></div><div data-t="nathanmarz (btw you don&apos;t need the  []  if it&apos;s just a single navigator)"><span class="u" id="1489589447.697702">2017:03:15 14:50:47           nathanmarz </span><span>(btw you don&apos;t need the </span><code>[]</code><span> if it&apos;s just a single navigator)</span></div><div data-t="nathanmarz the second branch of  if-path  can just be  STAY"><span class="u" id="1489589456.701725">2017:03:15 14:50:56           nathanmarz </span><span>the second branch of </span><code>if-path</code><span> can just be </span><code>STAY</code></div><div data-t="nathanmarz are you comfortable with recursion with functions?"><span class="u" id="1489589504.722370">2017:03:15 14:51:44           nathanmarz </span><span>are you comfortable with recursion with functions?</span></div><div data-t="mars0i Ah, maybe I see.  So  recursive-path  doesn&apos;t in itself cause recursion to occur.  It just sets up a context in which it can occur.  The recursion is implemented by using the  p  that it binds, in  if-path ."><span class="u" id="1489589532.733929">2017:03:15 14:52:12               mars0i </span><span>Ah, maybe I see.  So </span><code>recursive-path</code><span> doesn&apos;t in itself cause recursion to occur.  It just sets up a context in which it can occur.  The recursion is implemented by using the </span><code>p</code><span> that it binds, in </span><code>if-path</code><span>.</span></div><div data-t="nathanmarz that&apos;s right"><span class="u" id="1489589539.737227">2017:03:15 14:52:19           nathanmarz </span><span>that&apos;s right</span></div><div data-t="mars0i Yes, no problem with recursion.  It&apos;s a reasonable question to ask."><span class="u" id="1489589548.741184">2017:03:15 14:52:28               mars0i </span><span>Yes, no problem with recursion.  It&apos;s a reasonable question to ask.</span></div><div data-t="nathanmarz I see where you were confused now"><span class="u" id="1489589557.744989">2017:03:15 14:52:37           nathanmarz </span><span>I see where you were confused now</span></div><div data-t="mars0i The Little Lisper set me straight decades ago."><span class="u" id="1489589561.746530">2017:03:15 14:52:41               mars0i </span><span>The Little Lisper set me straight decades ago.</span></div><div data-t="nathanmarz recursive-path  does absolutely nothing except provide you with an object that references itself"><span class="u" id="1489589590.759052">2017:03:15 14:53:10           nathanmarz </span><code>recursive-path</code><span> does absolutely nothing except provide you with an object that references itself</span></div><div data-t="nathanmarz (recursive-path [] p [ALL even?])  is the same as  [ALL even?]"><span class="u" id="1489589611.768295">2017:03:15 14:53:31           nathanmarz </span><code>(recursive-path [] p [ALL even?])</code><span> is the same as </span><code>[ALL even?]</code></div><div data-t="mars0i OK.  That helps a lot.  Thanks.  It&apos;s just like a special kind of  let ."><span class="u" id="1489589679.797948">2017:03:15 14:54:39               mars0i </span><span>OK.  That helps a lot.  Thanks.  It&apos;s just like a special kind of </span><code>let</code><span>.</span></div><div data-t="nathanmarz sort of"><span class="u" id="1489589691.803400">2017:03:15 14:54:51           nathanmarz </span><span>sort of</span></div><div data-t="nathanmarz if you&apos;re curious, it&apos;s actually a wrapper around the lower level  local-declarepath  and  providepath"><span class="u" id="1489589708.810822">2017:03:15 14:55:08           nathanmarz </span><span>if you&apos;re curious, it&apos;s actually a wrapper around the lower level </span><code>local-declarepath</code><span> and </span><code>providepath</code></div><div data-t="nathanmarz those two can be used to make mutually recursive paths"><span class="u" id="1489589717.814238">2017:03:15 14:55:17           nathanmarz </span><span>those two can be used to make mutually recursive paths</span></div><div data-t="mars0i &quot;sort of&quot; yeah that&apos;s why I wrote &quot;like&quot; and &quot;kind of&quot;  🙂   .  OK, I&apos;ll look at those at some point."><span class="u" id="1489589763.834915">2017:03:15 14:56:03               mars0i </span><span>&quot;sort of&quot; yeah that&apos;s why I wrote &quot;like&quot; and &quot;kind of&quot; </span><b>🙂</b><span>  .  OK, I&apos;ll look at those at some point.</span></div><div data-t="mars0i I&apos;m not sure I understand  continue-then-stay  followed by  p  within  recursive-path , but I think I should think and experiment a bit and see if I can figure it out before asking further questions.  Thanks very mush."><span class="u" id="1489589938.912341">2017:03:15 14:58:58               mars0i </span><span>I&apos;m not sure I understand </span><code>continue-then-stay</code><span> followed by </span><code>p</code><span> within </span><code>recursive-path</code><span>, but I think I should think and experiment a bit and see if I can figure it out before asking further questions.  Thanks very mush.</span></div><div data-t="nathanmarz no problem, happy to help"><span class="u" id="1489589974.928019">2017:03:15 14:59:34           nathanmarz </span><span>no problem, happy to help</span></div><div data-t="mars0i much.  now that I understand  recursive-path  better."><span class="u" id="1489589976.929120">2017:03:15 14:59:36               mars0i </span><span>much.  now that I understand </span><code>recursive-path</code><span> better.</span></div><div data-t="mars0i Based on an answer to vikeri a week ago:  b ;=&gt; {:b1 {:c1 1, :c2 2}, :b2 {:c1 3, :c2 4}}

(select [(recursive-path [] p
           (if-path map?
	         (continue-then-stay MAP-VALS p)))
         MAP-KEYS]
	b)
;=&gt; [:c1 :c2 :c1 :c2 :b1 :b2]
"><span class="u" id="1489598019.450179">2017:03:15 17:13:39               mars0i </span><span>Based on an answer to vikeri a week ago: </span><pre>b ;=&gt; {:b1 {:c1 1, :c2 2}, :b2 {:c1 3, :c2 4}}

(select [(recursive-path [] p
           (if-path map?
	         (continue-then-stay MAP-VALS p)))
         MAP-KEYS]
	b)
;=&gt; [:c1 :c2 :c1 :c2 :b1 :b2]
</pre></div><div data-t="mars0i Just want to check my understanding of how this works."><span class="u" id="1489598042.459533">2017:03:15 17:14:02               mars0i </span><span>Just want to check my understanding of how this works.</span></div><div data-t="mars0i If the current element is a map, then get its vals and continue with the path, p, but also, return the current element and pass it to MAP-KEYS.  So what keeps coming out of all that are the keys, and they are what are wrapped in vector.  Something like that?"><span class="u" id="1489598167.511589">2017:03:15 17:16:07               mars0i </span><span>If the current element is a map, then get its vals and continue with the path, p, but also, return the current element and pass it to MAP-KEYS.  So what keeps coming out of all that are the keys, and they are what are wrapped in vector.  Something like that?</span></div><div data-t="mars0i Or rather  MAP-VALS p  causes  p  into which we recurse to be bound to the outputs of  MAP-VALS .  But also the entire map element at that point is passed to  MAP-KEYS ."><span class="u" id="1489598339.582763">2017:03:15 17:18:59               mars0i </span><span>Or rather </span><code>MAP-VALS p</code><span> causes </span><code>p</code><span> into which we recurse to be bound to the outputs of </span><code>MAP-VALS</code><span>.  But also the entire map element at that point is passed to </span><code>MAP-KEYS</code><span>.</span></div><div data-t="nathanmarz better to think of it one step at a time"><span class="u" id="1489598481.640999">2017:03:15 17:21:21           nathanmarz </span><span>better to think of it one step at a time</span></div><div data-t="nathanmarz @mars0i the  recursive-path  part navigates to all maps reachable via navigations to map vals"><span class="u" id="1489598505.650851">2017:03:15 17:21:45           nathanmarz </span><span>@mars0i the </span><code>recursive-path</code><span> part navigates to all maps reachable via navigations to map vals</span></div><div data-t="nathanmarz then for each map navigated to, it navigates to the keys"><span class="u" id="1489598517.655850">2017:03:15 17:21:57           nathanmarz </span><span>then for each map navigated to, it navigates to the keys</span></div><div data-t="nathanmarz because of the  continue-then-stay , transformations happen first on more descendant maps"><span class="u" id="1489598551.669888">2017:03:15 17:22:31           nathanmarz </span><span>because of the </span><code>continue-then-stay</code><span>, transformations happen first on more descendant maps</span></div><div data-t="nathanmarz whereas with  stay-then-continue  the opposite would be true"><span class="u" id="1489598563.674862">2017:03:15 17:22:43           nathanmarz </span><span>whereas with </span><code>stay-then-continue</code><span> the opposite would be true</span></div><div data-t="mars0i Ah, cool about  stay-then-continue .  I didn&apos;t want the keys in reverse order."><span class="u" id="1489598619.697929">2017:03:15 17:23:39               mars0i </span><span>Ah, cool about </span><code>stay-then-continue</code><span>.  I didn&apos;t want the keys in reverse order.</span></div><div data-t="mars0i Maybe what I wrote applies better to it."><span class="u" id="1489598651.710835">2017:03:15 17:24:11               mars0i </span><span>Maybe what I wrote applies better to it.</span></div><div data-t="mars0i Thanks again."><span class="u" id="1489598680.723356">2017:03:15 17:24:40               mars0i </span><span>Thanks again.</span></div><div data-t="nathanmarz worth looking at their implementations  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1204"><span class="u" id="1489598682.724303">2017:03:15 17:24:42           nathanmarz </span><span>worth looking at their implementations </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1204">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1204</a></div><div data-t="nathanmarz thin wrappers around  multi-path"><span class="u" id="1489598688.726679">2017:03:15 17:24:48           nathanmarz </span><span>thin wrappers around </span><code>multi-path</code></div><div data-t="mars0i OK, I see.   This is also helping me understand  multi-path ."><span class="u" id="1489598851.795831">2017:03:15 17:27:31               mars0i </span><span>OK, I see.   This is also helping me understand </span><code>multi-path</code><span>.</span></div><div data-t="narkisr Hey, looking for a way to dissoc all items that are not matched by a select"><span class="u" id="1489649462.239092">2017:03:16 07:31:02              narkisr </span><span>Hey, looking for a way to dissoc all items that are not matched by a select</span></div><div data-t="rauh @narkisr Like this?  (sp/setval [sp/ALL (sp/not-selected? sp/LAST odd?)] sp/NONE {:a 0 :b 1})"><span class="u" id="1489649888.298204">2017:03:16 07:38:08                 rauh </span><span>@narkisr Like this? </span><code>(sp/setval [sp/ALL (sp/not-selected? sp/LAST odd?)] sp/NONE {:a 0 :b 1})</code></div><div data-t="narkisr I think so but my path is based on srange (I want to remove all items except last n)"><span class="u" id="1489649936.304753">2017:03:16 07:38:56              narkisr </span><span>I think so but my path is based on srange (I want to remove all items except last n)</span></div><div data-t="narkisr Ill give it a go and report back"><span class="u" id="1489650056.321594">2017:03:16 07:40:56              narkisr </span><span>Ill give it a go and report back</span></div><div data-t="narkisr thanks!"><span class="u" id="1489650058.321763">2017:03:16 07:40:58              narkisr </span><span>thanks!</span></div><div data-t="nathanmarz @rauh you can do that more concisely and efficiently with:  (setval [MAP-VALS even?] NONE {:a 0 :b 1})"><span class="u" id="1489663626.203383">2017:03:16 11:27:06           nathanmarz </span><span>@rauh you can do that more concisely and efficiently with: </span><code>(setval [MAP-VALS even?] NONE {:a 0 :b 1})</code></div><div data-t="nathanmarz @narkisr you can do that by transforming the srange to be a smaller sequence only containing the last n elements"><span class="u" id="1489663679.214347">2017:03:16 11:27:59           nathanmarz </span><span>@narkisr you can do that by transforming the srange to be a smaller sequence only containing the last n elements</span></div><div data-t="nathanmarz e.g.  (transform (srange 1 5) #(subvec % 2 4) [1 2 3 4 5 6 7 8]) =&gt; [1 4 5 6 7 8]"><span class="u" id="1489663759.230815">2017:03:16 11:29:19           nathanmarz </span><span>e.g. </span><code>(transform (srange 1 5) #(subvec % 2 4) [1 2 3 4 5 6 7 8]) =&gt; [1 4 5 6 7 8]</code></div><div data-t="narkisr Hey Natan,  (transform [MAP-VALS (srange 1 4)] NONE  (into (sorted-map) {1 2 3 4 5 6 7 8 9 10})))"><span class="u" id="1489667570.049163">2017:03:16 12:32:50              narkisr </span><span>Hey Natan,  (transform [MAP-VALS (srange 1 4)] NONE  (into (sorted-map) {1 2 3 4 5 6 7 8 9 10})))</span></div><div data-t="narkisr Seems to not keep the sorting order"><span class="u" id="1489667580.051661">2017:03:16 12:33:00              narkisr </span><span>Seems to not keep the sorting order</span></div><div data-t="narkisr ([1 2] [9 10])"><span class="u" id="1489667593.054428">2017:03:16 12:33:13              narkisr </span><span>([1 2] [9 10])</span></div><div data-t="narkisr Never mind"><span class="u" id="1489667634.063842">2017:03:16 12:33:54              narkisr </span><span>Never mind</span></div><div data-t="narkisr my bad"><span class="u" id="1489667635.064134">2017:03:16 12:33:55              narkisr </span><span>my bad</span></div><div data-t="narkisr Just realized iv should have used (srange 0 3)"><span class="u" id="1489667681.074712">2017:03:16 12:34:41              narkisr </span><span>Just realized iv should have used (srange 0 3)</span></div><div data-t="narkisr Also not sure how many you get feedback but specter is awesome, I can&apos;t imagine writing Clojure without it"><span class="u" id="1489667736.087385">2017:03:16 12:35:36              narkisr </span><span>Also not sure how many you get feedback but specter is awesome, I can&apos;t imagine writing Clojure without it</span></div><div data-t="narkisr So big thank you"><span class="u" id="1489667747.089877">2017:03:16 12:35:47              narkisr </span><span>So big thank you</span></div><div data-t="nathanmarz @narkisr thanks, glad to hear it"><span class="u" id="1489669268.473473">2017:03:16 13:01:08           nathanmarz </span><span>@narkisr thanks, glad to hear it</span></div><div data-t="oskarkv What is  this  in  (defnav a [x] (select* [this structure next-fn] ...))  I tried to use it but &quot;Unable to resolve symbol this&quot;."><span class="u" id="1489761059.781490">2017:03:17 14:30:59              oskarkv </span><span>What is </span><code>this</code><span> in </span><code>(defnav a [x] (select* [this structure next-fn] ...))</code><span> I tried to use it but &quot;Unable to resolve symbol this&quot;.</span></div><div data-t="mars0i Looks like it&apos;s being used inside a  proxy  def @oskarkv "><span class="u" id="1489763206.639415">2017:03:17 15:06:46               mars0i </span><span>Looks like it&apos;s being used inside a </span><code>proxy</code><span> def @oskarkv </span></div><div data-t="mars0i ie is that where that code originated?"><span class="u" id="1489763340.692129">2017:03:17 15:09:00               mars0i </span><span>ie is that where that code originated?</span></div><div data-t="nathanmarz @oskarkv that&apos;s currently ignored"><span class="u" id="1489764043.972582">2017:03:17 15:20:43           nathanmarz </span><span>@oskarkv that&apos;s currently ignored</span></div><div data-t="nathanmarz just there for consistency with how method definition works in clojure"><span class="u" id="1489764119.002674">2017:03:17 15:21:59           nathanmarz </span><span>just there for consistency with how method definition works in clojure</span></div><div data-t="nathanmarz if you use  defrichnav , then  this  refers to the navigator object"><span class="u" id="1489764171.023516">2017:03:17 15:22:51           nathanmarz </span><span>if you use </span><code>defrichnav</code><span>, then </span><code>this</code><span> refers to the navigator object</span></div><div data-t="levitanong hi would  transformed  be able to receive a value from above its scope? Like:
 (transform
  [VAL
   (transformed
     [some-path]
     (fn [value-from-VAL path-from-transformed]
       (do-something)))]
  (fn [value-from-VAL value-from-transformed]
    (do-another-thing)))
"><span class="u" id="1489770875.605169">2017:03:17 17:14:35           levitanong </span><span>hi would </span><code>transformed</code><span> be able to receive a value from above its scope? Like:
</span><pre>(transform
  [VAL
   (transformed
     [some-path]
     (fn [value-from-VAL path-from-transformed]
       (do-something)))]
  (fn [value-from-VAL value-from-transformed]
    (do-another-thing)))
</pre></div><div data-t="nathanmarz @levitanong no, I opted to design it so the values for  transformed  are reset"><span class="u" id="1489770996.649263">2017:03:17 17:16:36           nathanmarz </span><span>@levitanong no, I opted to design it so the values for </span><code>transformed</code><span> are reset</span></div><div data-t="levitanong @nathanmarz So if within a  transform  I use a  transformed  followed by some navigator, the “cursor” that navigator will operate on will be the original shape of the data passed to  transform ?"><span class="u" id="1489771051.669590">2017:03:17 17:17:31           levitanong </span><span>@nathanmarz So if within a </span><code>transform</code><span> I use a </span><code>transformed</code><span> followed by some navigator, the “cursor” that navigator will operate on will be the original shape of the data passed to </span><code>transform</code><span>?</span></div><div data-t="levitanong i.e. as if i had used a collector"><span class="u" id="1489771065.674619">2017:03:17 17:17:45           levitanong </span><span>i.e. as if i had used a collector</span></div><div data-t="levitanong without any collecting going on"><span class="u" id="1489771071.676568">2017:03:17 17:17:51           levitanong </span><span>without any collecting going on</span></div><div data-t="nathanmarz no, it just ignores collected values"><span class="u" id="1489771073.677374">2017:03:17 17:17:53           nathanmarz </span><span>no, it just ignores collected values</span></div><div data-t="nathanmarz (transform [ALL (transformed STAY inc)] inc [1 2 3 4])  will emit  [3 4 5 6]"><span class="u" id="1489771149.704859">2017:03:17 17:19:09           nathanmarz </span><code>(transform [ALL (transformed STAY inc)] inc [1 2 3 4])</code><span> will emit </span><code>[3 4 5 6]</code></div><div data-t="levitanong hmmm."><span class="u" id="1489771726.918961">2017:03:17 17:28:46           levitanong </span><span>hmmm.</span></div><div data-t="levitanong I think i have to parse this. lol"><span class="u" id="1489771732.920801">2017:03:17 17:28:52           levitanong </span><span>I think i have to parse this. lol</span></div><div data-t="levitanong thanks for the replies, @nathanmarz"><span class="u" id="1489771738.923105">2017:03:17 17:28:58           levitanong </span><span>thanks for the replies, @nathanmarz</span></div><div data-t="levitanong (transform [(transformed [VAL :key ALL] (fn [a b] (inc b)) VAL even?] 
  (fn [a b] (println a))
  {:key [1 2 3 4]})
 
In this above example, I expect a to be  [2 3 4 5] , but I seem to be getting  {:key [2 3 4 5]} 

At least, this is a simplified version of what I’m trying to do. Is this expected behavior?"><span class="u" id="1489772094.056821">2017:03:17 17:34:54           levitanong </span><pre>(transform [(transformed [VAL :key ALL] (fn [a b] (inc b)) VAL even?] 
  (fn [a b] (println a))
  {:key [1 2 3 4]})
</pre><span>
In this above example, I expect a to be </span><code>[2 3 4 5]</code><span>, but I seem to be getting </span><code>{:key [2 3 4 5]}</code><span>

At least, this is a simplified version of what I’m trying to do. Is this expected behavior?</span></div><div data-t="nathanmarz @levitanong that code produces an error"><span class="u" id="1489774189.820537">2017:03:17 18:09:49           nathanmarz </span><span>@levitanong that code produces an error</span></div><div data-t="nathanmarz since it&apos;s trying to incrementing a vector in the  transformed  clause"><span class="u" id="1489774206.826545">2017:03:17 18:10:06           nathanmarz </span><span>since it&apos;s trying to incrementing a vector in the </span><code>transformed</code><span> clause</span></div><div data-t="levitanong @nathanmarz woops, fixed"><span class="u" id="1489775858.398575">2017:03:17 18:37:38           levitanong </span><span>@nathanmarz woops, fixed</span></div><div data-t="nathanmarz @levitanong still erroring"><span class="u" id="1489776527.623620">2017:03:17 18:48:47           nathanmarz </span><span>@levitanong still erroring</span></div><div data-t="nathanmarz now because it&apos;s calling  even?  on the map"><span class="u" id="1489776535.626276">2017:03:17 18:48:55           nathanmarz </span><span>now because it&apos;s calling </span><code>even?</code><span> on the map</span></div><div data-t="nathanmarz but anyway, the navigator after the  transformed  clause will get  {:key [2 3 4 5]}  as input"><span class="u" id="1489776598.648059">2017:03:17 18:49:58           nathanmarz </span><span>but anyway, the navigator after the </span><code>transformed</code><span> clause will get </span><code>{:key [2 3 4 5]}</code><span> as input</span></div><div data-t="levitanong @nathanmarz so it doesn’t actually navigate to the transformed values"><span class="u" id="1489776745.698097">2017:03:17 18:52:25           levitanong </span><span>@nathanmarz so it doesn’t actually navigate to the transformed values</span></div><div data-t="nathanmarz correct"><span class="u" id="1489776759.702791">2017:03:17 18:52:39           nathanmarz </span><span>correct</span></div><div data-t="nathanmarz it works just like  view"><span class="u" id="1489776762.703739">2017:03:17 18:52:42           nathanmarz </span><span>it works just like </span><code>view</code></div><div data-t="levitanong oh, must’ve misread the docs on transformed"><span class="u" id="1489776802.717488">2017:03:17 18:53:22           levitanong </span><span>oh, must’ve misread the docs on transformed</span></div><div data-t="levitanong i was almost certain it said “navigates to the transformed values” or somesuch."><span class="u" id="1489776825.725305">2017:03:17 18:53:45           levitanong </span><span>i was almost certain it said “navigates to the transformed values” or somesuch.</span></div><div data-t="levitanong Anyway, thanks! I am no longer confused  😄"><span class="u" id="1489776837.729125">2017:03:17 18:53:57           levitanong </span><span>Anyway, thanks! I am no longer confused </span><b>😄</b></div><div data-t="mars0i I&apos;ve been trying to use Specter to return paths of keys from embedded maps.  e.g. amalloy&apos;s answer at  https://stackoverflow.com/questions/21768802/how-can-i-get-the-nested-keys-of-a-map-in-clojure  :"><span class="u" id="1489779215.484550">2017:03:17 19:33:35               mars0i </span><span>I&apos;ve been trying to use Specter to return paths of keys from embedded maps.  e.g. amalloy&apos;s answer at </span><a href="https://stackoverflow.com/questions/21768802/how-can-i-get-the-nested-keys-of-a-map-in-clojure">https://stackoverflow.com/questions/21768802/how-can-i-get-the-nested-keys-of-a-map-in-clojure</a><span> :</span></div><div data-t="mars0i (defn keys-in [m]
  (if (or (not (map? m))
          (empty? m))
    &apos;(())
    (for [[k v] m
          subkey (keys-in v)]
      (cons k subkey))))"><span class="u" id="1489779260.498338">2017:03:17 19:34:20               mars0i </span><pre>(defn keys-in [m]
  (if (or (not (map? m))
          (empty? m))
    &apos;(())
    (for [[k v] m
          subkey (keys-in v)]
      (cons k subkey))))</pre></div><div data-t="mars0i (keys-in {:a1 {:b1 {:c1 1, :c2 2}, :b2 {:c2 3}}, :a2 {:b2 {:c1 4, :c2 5}}})"><span class="u" id="1489779387.536950">2017:03:17 19:36:27               mars0i </span><code>(keys-in {:a1 {:b1 {:c1 1, :c2 2}, :b2 {:c2 3}}, :a2 {:b2 {:c1 4, :c2 5}}})</code></div><div data-t="mars0i ;=&gt; ((:a1 :b1 :c1) (:a1 :b1 :c2) (:a1 :b2 :c2) (:a2 :b2 :c1) (:a2 :b2 :c2))"><span class="u" id="1489779401.540976">2017:03:17 19:36:41               mars0i </span><code>;=&gt; ((:a1 :b1 :c1) (:a1 :b1 :c2) (:a1 :b2 :c2) (:a2 :b2 :c1) (:a2 :b2 :c2))</code></div><div data-t="mars0i I have been trying everything, turning myself inside-out.  Probably used combinations of half of the items on the navigators page."><span class="u" id="1489779448.554559">2017:03:17 19:37:28               mars0i </span><span>I have been trying everything, turning myself inside-out.  Probably used combinations of half of the items on the navigators page.</span></div><div data-t="mars0i Found out about  transformed  from above discussion, thought that was the key.  Argh."><span class="u" id="1489779474.562416">2017:03:17 19:37:54               mars0i </span><span>Found out about </span><code>transformed</code><span> from above discussion, thought that was the key.  Argh.</span></div><div data-t="mars0i Is this possible in Specter?  Undoubtedly yes.  Is it possible more simply than without it, though?  I suspect so, but I don&apos;t yet have the insight to see how."><span class="u" id="1489779517.575203">2017:03:17 19:38:37               mars0i </span><span>Is this possible in Specter?  Undoubtedly yes.  Is it possible more simply than without it, though?  I suspect so, but I don&apos;t yet have the insight to see how.</span></div><div data-t="mars0i Actually I don&apos;t need amalloy&apos;s  empty?  test.  Just testing for  map?  is enough."><span class="u" id="1489779611.603099">2017:03:17 19:40:11               mars0i </span><span>Actually I don&apos;t need amalloy&apos;s </span><code>empty?</code><span> test.  Just testing for </span><code>map?</code><span> is enough.</span></div><div data-t="nathanmarz @mars0i you can do that with value collection"><span class="u" id="1489780202.778715">2017:03:17 19:50:02           nathanmarz </span><span>@mars0i you can do that with value collection</span></div><div data-t="nathanmarz one sec"><span class="u" id="1489780203.779202">2017:03:17 19:50:03           nathanmarz </span><span>one sec</span></div><div data-t="mars0i I have experimented with  VAL ,  collect ,  collect-one , but haven&apos;t figured out the magic configuration."><span class="u" id="1489780330.817414">2017:03:17 19:52:10               mars0i </span><span>I have experimented with </span><code>VAL</code><span>, </span><code>collect</code><span>, </span><code>collect-one</code><span>, but haven&apos;t figured out the magic configuration.</span></div><div data-t="nathanmarz (defn keys-in [m]
  (let [p (recursive-path [] p
            (if-path map?
              [ALL (collect-one FIRST) LAST p]
              STAY
              ))]
    (map butlast (select p m))
    ))
"><span class="u" id="1489780349.823488">2017:03:17 19:52:29           nathanmarz </span><pre>(defn keys-in [m]
  (let [p (recursive-path [] p
            (if-path map?
              [ALL (collect-one FIRST) LAST p]
              STAY
              ))]
    (map butlast (select p m))
    ))
</pre></div><div data-t="nathanmarz that&apos;s one way"><span class="u" id="1489780353.824688">2017:03:17 19:52:33           nathanmarz </span><span>that&apos;s one way</span></div><div data-t="mars0i Beautiful.  Thanks.  I&apos;ll digest that now."><span class="u" id="1489780422.844968">2017:03:17 19:53:42               mars0i </span><span>Beautiful.  Thanks.  I&apos;ll digest that now.</span></div><div data-t="nathanmarz here&apos;s another way:
 (defn keys-in [m]
  (let [p (recursive-path [] p
            (if-path map?
              [ALL
               (if-path [LAST map?]
                [(collect-one FIRST) LAST p]
                FIRST
                )]))]
    (select p m)
    ))
"><span class="u" id="1489780484.864023">2017:03:17 19:54:44           nathanmarz </span><span>here&apos;s another way:
</span><pre>(defn keys-in [m]
  (let [p (recursive-path [] p
            (if-path map?
              [ALL
               (if-path [LAST map?]
                [(collect-one FIRST) LAST p]
                FIRST
                )]))]
    (select p m)
    ))
</pre></div><div data-t="nathanmarz more efficient"><span class="u" id="1489780489.865737">2017:03:17 19:54:49           nathanmarz </span><span>more efficient</span></div><div data-t="mars0i I&apos;d like to have this added to that StackOverflow question.  I&apos;ll do it and credit you, if you want, but if you play SO and have time, you could get the points."><span class="u" id="1489780493.866843">2017:03:17 19:54:53               mars0i </span><span>I&apos;d like to have this added to that StackOverflow question.  I&apos;ll do it and credit you, if you want, but if you play SO and have time, you could get the points.</span></div><div data-t="nathanmarz go for it"><span class="u" id="1489780559.887043">2017:03:17 19:55:59           nathanmarz </span><span>go for it</span></div><div data-t="mars0i Great.   more to digest ..."><span class="u" id="1489780560.887431">2017:03:17 19:56:00               mars0i </span><span>Great.   more to digest ...</span></div><div data-t="mars0i OK, thanks much.  I think there ought to be a Specter solution there.  I&apos;ll add both.  I saw a discussion elsewhere someone trying to do this with Specter and gave up."><span class="u" id="1489780605.901296">2017:03:17 19:56:45               mars0i </span><span>OK, thanks much.  I think there ought to be a Specter solution there.  I&apos;ll add both.  I saw a discussion elsewhere someone trying to do this with Specter and gave up.</span></div><div data-t="nathanmarz once your brain adapts to thinking in terms of navigation this is easy stuff"><span class="u" id="1489780944.009889">2017:03:17 20:02:24           nathanmarz </span><span>once your brain adapts to thinking in terms of navigation this is easy stuff</span></div><div data-t="mars0i I believe that.  Still getting there."><span class="u" id="1489781012.030901">2017:03:17 20:03:32               mars0i </span><span>I believe that.  Still getting there.</span></div><div data-t="mars0i i.e. the discussion elsewhere someone else gave up.  So it&apos;s not just me who thought of using Specter for this kind of thing."><span class="u" id="1489781505.178620">2017:03:17 20:11:45               mars0i </span><span>i.e. the discussion elsewhere someone else gave up.  So it&apos;s not just me who thought of using Specter for this kind of thing.</span></div><div data-t="nathanmarz @mars0i also worth noting that the specter solution should be significantly more efficient than all the solutions on that page"><span class="u" id="1489782533.485482">2017:03:17 20:28:53           nathanmarz </span><span>@mars0i also worth noting that the specter solution should be significantly more efficient than all the solutions on that page</span></div><div data-t="nathanmarz except for the amalloy one which is probably comparable"><span class="u" id="1489782598.504899">2017:03:17 20:29:58           nathanmarz </span><span>except for the amalloy one which is probably comparable</span></div><div data-t="mars0i I was wondering about that.  I&apos;ll run the specter defs through Criterium later.  I&apos;m using very small structures, so differences might not show up."><span class="u" id="1489786466.537053">2017:03:17 21:34:26               mars0i </span><span>I was wondering about that.  I&apos;ll run the specter defs through Criterium later.  I&apos;m using very small structures, so differences might not show up.</span></div><div data-t="mars0i At some point I might randomly generate some large embedded maps just to see how the algorithms perform, but I don&apos;t have a need for large ones."><span class="u" id="1489786524.549621">2017:03:17 21:35:24               mars0i </span><span>At some point I might randomly generate some large embedded maps just to see how the algorithms perform, but I don&apos;t have a need for large ones.</span></div><div data-t="nathanmarz @mars0i you should see a substantial difference"><span class="u" id="1489787882.835681">2017:03:17 21:58:02           nathanmarz </span><span>@mars0i you should see a substantial difference</span></div><div data-t="mars0i nathanmarz or anyone else, I&apos;d like check my understanding of those keys-in functions from earlier if someone is willing.  Here are very informal explanations of the functions&apos; operations as I understand them.  This would help me understand some basic ideas of specter.  Specter&apos;s already been useful for me, but once I went beyond very simple things I was getting confused.  No need if you&apos;re not interested, too busy, etc."><span class="u" id="1489807229.698504">2017:03:18 03:20:29               mars0i </span><span>nathanmarz or anyone else, I&apos;d like check my understanding of those keys-in functions from earlier if someone is willing.  Here are very informal explanations of the functions&apos; operations as I understand them.  This would help me understand some basic ideas of specter.  Specter&apos;s already been useful for me, but once I went beyond very simple things I was getting confused.  No need if you&apos;re not interested, too busy, etc.</span></div><div data-t="mars0i (defn simple-keybranches [m]
  (let [p (recursive-path [] p
            (if-path map?
              [ALL (collect-one FIRST) LAST p]
              STAY))]
    (map butlast (select p m))))
;; Explanation:
;; I&apos;m given a map of maps of ... and 
;; (A) since it&apos;s a map
;; it&apos;s passed to the first collection of navigators, which begins with ALL, so
;; for each MapEntry in the map
;; add its first element (key) to:
;; passing its last element (val) to ... now recurse (which is what p does),
;; i.e. for each of those map vals continue at (A)
;; 
;; On each of these branches, we eventually get to a non-map;
;; return it and stop processing on that branch (STAY).
;;
;; However, this last thing returned is not one of the keys, it&apos;s
;; the terminal val.  So we end up with the leaf vals in each
;; sequence.  To strip them out, map butlast over the entire result.
"><span class="u" id="1489807256.699829">2017:03:18 03:20:56               mars0i </span><pre>(defn simple-keybranches [m]
  (let [p (recursive-path [] p
            (if-path map?
              [ALL (collect-one FIRST) LAST p]
              STAY))]
    (map butlast (select p m))))
;; Explanation:
;; I&apos;m given a map of maps of ... and 
;; (A) since it&apos;s a map
;; it&apos;s passed to the first collection of navigators, which begins with ALL, so
;; for each MapEntry in the map
;; add its first element (key) to:
;; passing its last element (val) to ... now recurse (which is what p does),
;; i.e. for each of those map vals continue at (A)
;; 
;; On each of these branches, we eventually get to a non-map;
;; return it and stop processing on that branch (STAY).
;;
;; However, this last thing returned is not one of the keys, it&apos;s
;; the terminal val.  So we end up with the leaf vals in each
;; sequence.  To strip them out, map butlast over the entire result.
</pre></div><div data-t="mars0i (defn faster-keybranches [m]
  (let [p (recursive-path [] p
            (if-path map?
              [ALL
               (if-path [LAST map?]
                [(collect-one FIRST) LAST p]
                FIRST)]))]
    (select p m)))
;; Explanation:
;; I&apos;m given a map of maps of ... and 
;; (A) since it&apos;s a map
;; it&apos;s passed to ALL, i.e.
;; for each MapEntry e in the map,
;;   if e&apos;s val is also a map
;;     add its first element (key) to:
;;     passing its last element (val) to ... now recurse (which is what p does),
;;     i.e. for each of those map vals continue at (A)
;;   or if e&apos;s val is not a map, then
;;     get its first element, i.e. its key
;; On each of these branches, we eventually get to a non-map,
;; in which case stop processing on that branch and return nothing."><span class="u" id="1489807281.701134">2017:03:18 03:21:21               mars0i </span><pre>(defn faster-keybranches [m]
  (let [p (recursive-path [] p
            (if-path map?
              [ALL
               (if-path [LAST map?]
                [(collect-one FIRST) LAST p]
                FIRST)]))]
    (select p m)))
;; Explanation:
;; I&apos;m given a map of maps of ... and 
;; (A) since it&apos;s a map
;; it&apos;s passed to ALL, i.e.
;; for each MapEntry e in the map,
;;   if e&apos;s val is also a map
;;     add its first element (key) to:
;;     passing its last element (val) to ... now recurse (which is what p does),
;;     i.e. for each of those map vals continue at (A)
;;   or if e&apos;s val is not a map, then
;;     get its first element, i.e. its key
;; On each of these branches, we eventually get to a non-map,
;; in which case stop processing on that branch and return nothing.</pre></div><div data-t="mars0i A question: Is the main reason that the first one should be faster is because the  butlast  is required to strip off the leaf elements?"><span class="u" id="1489807386.706026">2017:03:18 03:23:06               mars0i </span><span>A question: Is the main reason that the first one should be faster is because the </span><code>butlast</code><span> is required to strip off the leaf elements?</span></div><div data-t="mars0i I actually want those!  I was trying to figure out how to get the key paths, and then figured it would be easy to add the leaf elements, but that seemed like an additional step, so I didn&apos;t mention it.  So I can just leave out the  butlast  for my application."><span class="u" id="1489807466.710016">2017:03:18 03:24:26               mars0i </span><span>I actually want those!  I was trying to figure out how to get the key paths, and then figured it would be easy to add the leaf elements, but that seemed like an additional step, so I didn&apos;t mention it.  So I can just leave out the </span><code>butlast</code><span> for my application.</span></div><div data-t="mars0i So far it looks like there&apos;s no speed difference between the two specter definitions and the others for my small embedded maps, but that&apos;s not surprising.   I&apos;m curious to try it with a larger structure, though."><span class="u" id="1489807553.714386">2017:03:18 03:25:53               mars0i </span><span>So far it looks like there&apos;s no speed difference between the two specter definitions and the others for my small embedded maps, but that&apos;s not surprising.   I&apos;m curious to try it with a larger structure, though.</span></div><div data-t="nathanmarz correct, that&apos;s why the  butlast  is there"><span class="u" id="1489840816.090783">2017:03:18 12:40:16           nathanmarz </span><span>correct, that&apos;s why the </span><code>butlast</code><span> is there</span></div><div data-t="nathanmarz I&apos;ve had issues profiling with criterium before, I did Specter&apos;s benchmarks manually:  https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj"><span class="u" id="1489840860.092911">2017:03:18 12:41:00           nathanmarz </span><span>I&apos;ve had issues profiling with criterium before, I did Specter&apos;s benchmarks manually: </span><a href="https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj">https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj</a></div><div data-t="nathanmarz the first run through the specter code it&apos;s doing inline compilation/caching, so unless you look at the aggregate of many runs that will skew the results"><span class="u" id="1489840915.095473">2017:03:18 12:41:55           nathanmarz </span><span>the first run through the specter code it&apos;s doing inline compilation/caching, so unless you look at the aggregate of many runs that will skew the results</span></div><div data-t="nathanmarz not sure if criterium handles that"><span class="u" id="1489840930.096131">2017:03:18 12:42:10           nathanmarz </span><span>not sure if criterium handles that</span></div><div data-t="mars0i Yes, that&apos;s the point of Criterium--to do that for you.  It&apos;s supposed to run the code a bunch of times before starting timing, and then it reports average times from many runs.  It&apos;s also supposed to put garbage collection in a fresh state beforehand.  However, something&apos;s wrong with my testing.  All of the functions are just as fast with huge embedded maps as with small ones.  One has to worry about setting up tests in such a way that Java or Clojure optimizes them away.  It looks like what worked to avoid that in the past isn&apos;t working for me.  I have to investigate."><span class="u" id="1489854476.937886">2017:03:18 16:27:56               mars0i </span><span>Yes, that&apos;s the point of Criterium--to do that for you.  It&apos;s supposed to run the code a bunch of times before starting timing, and then it reports average times from many runs.  It&apos;s also supposed to put garbage collection in a fresh state beforehand.  However, something&apos;s wrong with my testing.  All of the functions are just as fast with huge embedded maps as with small ones.  One has to worry about setting up tests in such a way that Java or Clojure optimizes them away.  It looks like what worked to avoid that in the past isn&apos;t working for me.  I have to investigate.</span></div><div data-t="mars0i Halfway systematic testing by hand suggests that both specter keybranch functions are much faster on a large embedded map (800K paths) than all of the other definitions, except for miner49r&apos;s  reduce-kv  version, which has comparable speed."><span class="u" id="1489856006.048011">2017:03:18 16:53:26               mars0i </span><span>Halfway systematic testing by hand suggests that both specter keybranch functions are much faster on a large embedded map (800K paths) than all of the other definitions, except for miner49r&apos;s </span><code>reduce-kv</code><span> version, which has comparable speed.</span></div><div data-t="mars0i amalloy&apos;s definition might be fastest on small maps, but my testing so far isn&apos;t rigorous enough to be sure."><span class="u" id="1489856487.083790">2017:03:18 17:01:27               mars0i </span><span>amalloy&apos;s definition might be fastest on small maps, but my testing so far isn&apos;t rigorous enough to be sure.</span></div><div data-t="nathanmarz ah yea, the  reduce-kv  version should be very fast"><span class="u" id="1489858559.225856">2017:03:18 17:35:59           nathanmarz </span><span>ah yea, the </span><code>reduce-kv</code><span> version should be very fast</span></div><div data-t="nathanmarz the amalloy one uses  for  on the map which adds a lot of overhead"><span class="u" id="1489858588.227812">2017:03:18 17:36:28           nathanmarz </span><span>the amalloy one uses </span><code>for</code><span> on the map which adds a lot of overhead</span></div><div data-t="nathanmarz for the first specter version you should wrap the  (map butlast ...)  in a  doall  so that the laziness doesn&apos;t avoid measurement"><span class="u" id="1489858678.233665">2017:03:18 17:37:58           nathanmarz </span><span>for the first specter version you should wrap the </span><code>(map butlast ...)</code><span> in a </span><code>doall</code><span> so that the laziness doesn&apos;t avoid measurement</span></div><div data-t="mars0i I&apos;m putting all of the results through  doall .  As far as I can tell, none of them produce lazy sequences for the internal sequences."><span class="u" id="1489863065.528985">2017:03:18 18:51:05               mars0i </span><span>I&apos;m putting all of the results through </span><code>doall</code><span>.  As far as I can tell, none of them produce lazy sequences for the internal sequences.</span></div><div data-t="mars0i Problem with Criterium was not optimization.  Foolish mistake I was quoting the code passed to Criterium&apos;s macro.  It&apos;s not supposed to be quoted."><span class="u" id="1489864191.601325">2017:03:18 19:09:51               mars0i </span><span>Problem with Criterium was not optimization.  Foolish mistake I was quoting the code passed to Criterium&apos;s macro.  It&apos;s not supposed to be quoted.</span></div><div data-t="mars0i I tested seven functions that extract all paths through on 3-level, 3 keys per level and 6-level, 6 keys per level embedded map structures.  The second Specter version above and miner49r&apos;s  reduce-kv  version are about the same speed, 2X (for the 3x3 map) and 3.5X (for the 6x6 map)  faster than any other  version.  Another illustration of Specter producing code that&apos;s as fast or faster than handwritten code.   It&apos;s very impressive.  (The first Specter version is about the same speed if I take out  map butlast .)  Full details about my tests are available here:  https://github.com/mars0i/key-path-tests"><span class="u" id="1489900417.316379">2017:03:19 05:13:37               mars0i </span><span>I tested seven functions that extract all paths through on 3-level, 3 keys per level and 6-level, 6 keys per level embedded map structures.  The second Specter version above and miner49r&apos;s </span><code>reduce-kv</code><span> version are about the same speed, 2X (for the 3x3 map) and 3.5X (for the 6x6 map)  faster than any other  version.  Another illustration of Specter producing code that&apos;s as fast or faster than handwritten code.   It&apos;s very impressive.  (The first Specter version is about the same speed if I take out </span><code>map butlast</code><span>.)  Full details about my tests are available here: </span><a href="https://github.com/mars0i/key-path-tests">https://github.com/mars0i/key-path-tests</a></div><div data-t="nathanmarz @mars0i nice work, thanks for investigating it"><span class="u" id="1489929905.430313">2017:03:19 13:25:05           nathanmarz </span><span>@mars0i nice work, thanks for investigating it</span></div><div data-t="mars0i Follow up question about generating paths of keys from embedded maps.  My leaf values are sequences of numbers.  If I use the first solution you gave, and don&apos;t strip out the values using  butlast , I almost get what I want:"><span class="u" id="1489970550.034623">2017:03:20 00:42:30               mars0i </span><span>Follow up question about generating paths of keys from embedded maps.  My leaf values are sequences of numbers.  If I use the first solution you gave, and don&apos;t strip out the values using </span><code>butlast</code><span>, I almost get what I want:</span></div><div data-t="mars0i (select (recursive-path [] p
           (if-path map?
             [ALL (collect-one FIRST) LAST p]
             STAY))
        {:a1 {:b1 [1 2 3]
              :b2 [3 4 5]}
         :a2 {:b2 [6 7 8]}})
;=&gt; [[:a1 :b1 [1 2 3]] [:a1 :b2 [3 4 5]] [:a2 :b2 [6 7 8]]]"><span class="u" id="1489970585.037139">2017:03:20 00:43:05               mars0i </span><pre>(select (recursive-path [] p
           (if-path map?
             [ALL (collect-one FIRST) LAST p]
             STAY))
        {:a1 {:b1 [1 2 3]
              :b2 [3 4 5]}
         :a2 {:b2 [6 7 8]}})
;=&gt; [[:a1 :b1 [1 2 3]] [:a1 :b2 [3 4 5]] [:a2 :b2 [6 7 8]]]</pre></div><div data-t="mars0i What I want is  [[:a1 :b1 1 2 3] [:a1 :b2 3 4 5] [:a2 :b2 6 7 8]] .  I&apos;ve been trying to figure out how to do this in specter.  Of course it&apos;s easy to fix in core Clojure afterwards.  If I replace  STAY  with  ALL , I get a separate path vector for each of the numbers in the leaf vectors.  Other things I&apos;ve tried either produce one of these two results, or error.  Thanks again for any help."><span class="u" id="1489970729.047584">2017:03:20 00:45:29               mars0i </span><span>What I want is </span><code>[[:a1 :b1 1 2 3] [:a1 :b2 3 4 5] [:a2 :b2 6 7 8]]</code><span>.  I&apos;ve been trying to figure out how to do this in specter.  Of course it&apos;s easy to fix in core Clojure afterwards.  If I replace </span><code>STAY</code><span> with </span><code>ALL</code><span>, I get a separate path vector for each of the numbers in the leaf vectors.  Other things I&apos;ve tried either produce one of these two results, or error.  Thanks again for any help.</span></div><div data-t="nathanmarz @mars0i for that it&apos;s best to just fix it after the selection, with regular clojure or a  transform  call"><span class="u" id="1489975942.446220">2017:03:20 02:12:22           nathanmarz </span><span>@mars0i for that it&apos;s best to just fix it after the selection, with regular clojure or a </span><code>transform</code><span> call</span></div><div data-t="nathanmarz it&apos;s possible to do it in one path with specter&apos;s zipper integration, but it won&apos;t be particularly elegant"><span class="u" id="1489976003.451129">2017:03:20 02:13:23           nathanmarz </span><span>it&apos;s possible to do it in one path with specter&apos;s zipper integration, but it won&apos;t be particularly elegant</span></div><div data-t="mars0i OK, thanks very much.    Yeah, I&apos;d rather avoid zippers if I can."><span class="u" id="1489982225.953802">2017:03:20 03:57:05               mars0i </span><span>OK, thanks very much.    Yeah, I&apos;d rather avoid zippers if I can.</span></div><div data-t="spieden thought i’d share a satisfying solution i was just able to rattle off for extracting some information using specter  (spr/select [:Resources spr/ALL (spr/collect spr/FIRST) spr/LAST :Properties :ContainerDefinitions spr/ALL :Environment spr/ALL (spr/selected? :Name #(= % &quot;REFERENCE_DATASET&quot;)) :Value] t)  (i’m on an old version still)"><span class="u" id="1490048133.196018">2017:03:20 22:15:33              spieden </span><span>thought i’d share a satisfying solution i was just able to rattle off for extracting some information using specter </span><code>(spr/select [:Resources spr/ALL (spr/collect spr/FIRST) spr/LAST :Properties :ContainerDefinitions spr/ALL :Environment spr/ALL (spr/selected? :Name #(= % &quot;REFERENCE_DATASET&quot;)) :Value] t)</code><span> (i’m on an old version still)</span></div><div data-t="luxbock what&apos;s wrong with my implementation of a  take-nth  navigator:  https://gist.github.com/luxbock/a6a1323497a02e36b09dec624c57b3ab  ?"><span class="u" id="1490105797.325289">2017:03:21 14:16:37              luxbock </span><span>what&apos;s wrong with my implementation of a </span><code>take-nth</code><span> navigator: </span><a href="https://gist.github.com/luxbock/a6a1323497a02e36b09dec624c57b3ab">https://gist.github.com/luxbock/a6a1323497a02e36b09dec624c57b3ab</a><span> ?</span></div><div data-t="luxbock I am using  (:refer-clojure :exclude [take-nth])  so it&apos;s not colliding with the  clojure.core  version"><span class="u" id="1490105842.342799">2017:03:21 14:17:22              luxbock </span><span>I am using </span><code>(:refer-clojure :exclude [take-nth])</code><span> so it&apos;s not colliding with the </span><code>clojure.core</code><span> version</span></div><div data-t="luxbock using  transform  works fine"><span class="u" id="1490105862.350982">2017:03:21 14:17:42              luxbock </span><span>using </span><code>transform</code><span> works fine</span></div><div data-t="luxbock argh, I&apos;m an idiot, of course I&apos;m calling  take-nth  inside my  select*"><span class="u" id="1490106431.585123">2017:03:21 14:27:11              luxbock </span><span>argh, I&apos;m an idiot, of course I&apos;m calling </span><code>take-nth</code><span> inside my </span><code>select*</code></div><div data-t="luxbock if I want my navigators to respect  NONE  do I need to implement that for every navigator?"><span class="u" id="1490112189.142917">2017:03:21 16:03:09              luxbock </span><span>if I want my navigators to respect </span><code>NONE</code><span> do I need to implement that for every navigator?</span></div><div data-t="nathanmarz @luxbock yes"><span class="u" id="1490112272.180172">2017:03:21 16:04:32           nathanmarz </span><span>@luxbock yes</span></div><div data-t="luxbock is that something that could be done automatically for me, or am I missing something obvious?"><span class="u" id="1490112311.197265">2017:03:21 16:05:11              luxbock </span><span>is that something that could be done automatically for me, or am I missing something obvious?</span></div><div data-t="nathanmarz how to handle transformations to  NONE  is completely navigator specific"><span class="u" id="1490112334.207557">2017:03:21 16:05:34           nathanmarz </span><span>how to handle transformations to </span><code>NONE</code><span> is completely navigator specific</span></div><div data-t="nathanmarz for  keypath  it does a  dissoc , for  ALL  it filters it from reconstruction, for  nthpath  it removes from the sequence, etc."><span class="u" id="1490112367.221718">2017:03:21 16:06:07           nathanmarz </span><span>for </span><code>keypath</code><span> it does a </span><code>dissoc</code><span>, for </span><code>ALL</code><span> it filters it from reconstruction, for </span><code>nthpath</code><span> it removes from the sequence, etc.</span></div><div data-t="luxbock right, makes sense"><span class="u" id="1490112402.237202">2017:03:21 16:06:42              luxbock </span><span>right, makes sense</span></div><div data-t="nathanmarz looking at how those navigators implement it would be instructive I think"><span class="u" id="1490112499.278543">2017:03:21 16:08:19           nathanmarz </span><span>looking at how those navigators implement it would be instructive I think</span></div><div data-t="luxbock what is the extra argument  vals  that  defrichnav  uses for select and transform?"><span class="u" id="1490112588.315781">2017:03:21 16:09:48              luxbock </span><span>what is the extra argument </span><code>vals</code><span> that </span><code>defrichnav</code><span> uses for select and transform?</span></div><div data-t="nathanmarz those are the collected values"><span class="u" id="1490112610.325148">2017:03:21 16:10:10           nathanmarz </span><span>those are the collected values</span></div><div data-t="nathanmarz like from  collect ,  collect-one"><span class="u" id="1490112626.330738">2017:03:21 16:10:26           nathanmarz </span><span>like from </span><code>collect</code><span>, </span><code>collect-one</code></div><div data-t="luxbock ah I see, thanks"><span class="u" id="1490112677.352987">2017:03:21 16:11:17              luxbock </span><span>ah I see, thanks</span></div><div data-t="nathanmarz navigators that need to be defined using  defrichnav  are special cases"><span class="u" id="1490112736.377545">2017:03:21 16:12:16           nathanmarz </span><span>navigators that need to be defined using </span><code>defrichnav</code><span> are special cases</span></div><div data-t="nathanmarz keypath  does it as an optimization since Clojure/JVM aren&apos;t smart enough to inline this particular case"><span class="u" id="1490112771.393066">2017:03:21 16:12:51           nathanmarz </span><code>keypath</code><span> does it as an optimization since Clojure/JVM aren&apos;t smart enough to inline this particular case</span></div><div data-t="luxbock I&apos;m trying to figure out how I could implement  every-nth  that respects  NONE  but it feels very difficult:  https://gist.github.com/luxbock/69b766830144e4bdb767923ba7fb2f9c"><span class="u" id="1490113099.530171">2017:03:21 16:18:19              luxbock </span><span>I&apos;m trying to figure out how I could implement </span><code>every-nth</code><span> that respects </span><code>NONE</code><span> but it feels very difficult: </span><a href="https://gist.github.com/luxbock/69b766830144e4bdb767923ba7fb2f9c">https://gist.github.com/luxbock/69b766830144e4bdb767923ba7fb2f9c</a></div><div data-t="nathanmarz you&apos;ll need a totally different approach"><span class="u" id="1490113193.569947">2017:03:21 16:19:53           nathanmarz </span><span>you&apos;ll need a totally different approach</span></div><div data-t="nathanmarz better to construct a new vector from scratch"><span class="u" id="1490113201.573123">2017:03:21 16:20:01           nathanmarz </span><span>better to construct a new vector from scratch</span></div><div data-t="nathanmarz elements that aren&apos;t at the nth indices go in unchanged, and for the others you apply next-fn and filter out ones that transform to  NONE"><span class="u" id="1490113227.584963">2017:03:21 16:20:27           nathanmarz </span><span>elements that aren&apos;t at the nth indices go in unchanged, and for the others you apply next-fn and filter out ones that transform to </span><code>NONE</code></div><div data-t="nathanmarz something similar for lists"><span class="u" id="1490113235.588499">2017:03:21 16:20:35           nathanmarz </span><span>something similar for lists</span></div><div data-t="nathanmarz that&apos;s basically how  ALL  works"><span class="u" id="1490113244.592385">2017:03:21 16:20:44           nathanmarz </span><span>that&apos;s basically how </span><code>ALL</code><span> works</span></div><div data-t="luxbock yeah, I&apos;m trying to learn from the specter native navigators but they are so heavily optimized that it&apos;s taking some time  🙂"><span class="u" id="1490113280.607715">2017:03:21 16:21:20              luxbock </span><span>yeah, I&apos;m trying to learn from the specter native navigators but they are so heavily optimized that it&apos;s taking some time </span><b>🙂</b></div><div data-t="nathanmarz ALL  on vectors is pretty simple  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L94"><span class="u" id="1490113319.623907">2017:03:21 16:21:59           nathanmarz </span><code>ALL</code><span> on vectors is pretty simple </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L94">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L94</a></div><div data-t="nathanmarz you should be able to do something very similar"><span class="u" id="1490113347.635498">2017:03:21 16:22:27           nathanmarz </span><span>you should be able to do something very similar</span></div><div data-t="luxbock yeah, I&apos;ll keep trying, seems like an appropriately challenging example for me to level up on"><span class="u" id="1490113390.653274">2017:03:21 16:23:10              luxbock </span><span>yeah, I&apos;ll keep trying, seems like an appropriately challenging example for me to level up on</span></div><div data-t="nathanmarz lists are a little trickier due to needing to maintain order  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L71"><span class="u" id="1490113413.663268">2017:03:21 16:23:33           nathanmarz </span><span>lists are a little trickier due to needing to maintain order </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L71">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L71</a></div><div data-t="nathanmarz looks like you&apos;re understanding how navs work pretty well"><span class="u" id="1490113450.678613">2017:03:21 16:24:10           nathanmarz </span><span>looks like you&apos;re understanding how navs work pretty well</span></div><div data-t="luxbock do you see specter still adding more navigators (such as these) or would you rather people see publish them as utility libraries?"><span class="u" id="1490113503.700994">2017:03:21 16:25:03              luxbock </span><span>do you see specter still adding more navigators (such as these) or would you rather people see publish them as utility libraries?</span></div><div data-t="luxbock I think it&apos;s easy enough to write navigators that are very naive, but making them highly performant, versatile (in support for all possible datastructures) and respecting  NONE  is a lot of work, so I would definitely be happy to share the workload with others"><span class="u" id="1490113633.755552">2017:03:21 16:27:13              luxbock </span><span>I think it&apos;s easy enough to write navigators that are very naive, but making them highly performant, versatile (in support for all possible datastructures) and respecting </span><code>NONE</code><span> is a lot of work, so I would definitely be happy to share the workload with others</span></div><div data-t="luxbock I remember a while back you mentioned that transducers that use  comp  are in some cases slower than just writing the same tranformation sequentially, because of the overhead of  comp , and you could improve the performance by pre-compiling the composed transducer"><span class="u" id="1490114090.946690">2017:03:21 16:34:50              luxbock </span><span>I remember a while back you mentioned that transducers that use </span><code>comp</code><span> are in some cases slower than just writing the same tranformation sequentially, because of the overhead of </span><code>comp</code><span>, and you could improve the performance by pre-compiling the composed transducer</span></div><div data-t="luxbock how would one compile a transducer, if I already know what it should do and don&apos;t need to compose it further using other transducers?"><span class="u" id="1490114153.972689">2017:03:21 16:35:53              luxbock </span><span>how would one compile a transducer, if I already know what it should do and don&apos;t need to compose it further using other transducers?</span></div><div data-t="luxbock this seems to work and looks a lot better:  https://gist.github.com/luxbock/33fecd25fce1ea91412ff86fb4df1e83"><span class="u" id="1490114394.070371">2017:03:21 16:39:54              luxbock </span><span>this seems to work and looks a lot better: </span><a href="https://gist.github.com/luxbock/33fecd25fce1ea91412ff86fb4df1e83">https://gist.github.com/luxbock/33fecd25fce1ea91412ff86fb4df1e83</a></div><div data-t="nathanmarz @luxbock these don&apos;t seem core enough to me to go into specter core"><span class="u" id="1490114631.166509">2017:03:21 16:43:51           nathanmarz </span><span>@luxbock these don&apos;t seem core enough to me to go into specter core</span></div><div data-t="nathanmarz also some of these may be superseded by stateful navigators if that&apos;s ever implemented  https://github.com/nathanmarz/specter/issues/121"><span class="u" id="1490114669.181813">2017:03:21 16:44:29           nathanmarz </span><span>also some of these may be superseded by stateful navigators if that&apos;s ever implemented </span><a href="https://github.com/nathanmarz/specter/issues/121">https://github.com/nathanmarz/specter/issues/121</a></div><div data-t="nathanmarz not sure I understand your question about transducers"><span class="u" id="1490114707.197297">2017:03:21 16:45:07           nathanmarz </span><span>not sure I understand your question about transducers</span></div><div data-t="nathanmarz you precompile by calling  comp  in a central spot"><span class="u" id="1490114721.202958">2017:03:21 16:45:21           nathanmarz </span><span>you precompile by calling </span><code>comp</code><span> in a central spot</span></div><div data-t="nathanmarz the problem is you can&apos;t precompile anything that requires the dynamic context (like local variables)"><span class="u" id="1490114751.215555">2017:03:21 16:45:51           nathanmarz </span><span>the problem is you can&apos;t precompile anything that requires the dynamic context (like local variables)</span></div><div data-t="nathanmarz e.g.  (comp (map some-local-arg) (filter even?))"><span class="u" id="1490114771.223823">2017:03:21 16:46:11           nathanmarz </span><span>e.g. </span><code>(comp (map some-local-arg) (filter even?))</code></div><div data-t="nathanmarz the best you can do is precompile sequences of static transducers for reuse"><span class="u" id="1490114836.250299">2017:03:21 16:47:16           nathanmarz </span><span>the best you can do is precompile sequences of static transducers for reuse</span></div><div data-t="nathanmarz in theory, transducers could use a similar inline compilation/caching strategy as specter to make this automatic"><span class="u" id="1490114866.262780">2017:03:21 16:47:46           nathanmarz </span><span>in theory, transducers could use a similar inline compilation/caching strategy as specter to make this automatic</span></div><div data-t="luxbock I see, yeah stateful navigators look very interesting"><span class="u" id="1490114981.309988">2017:03:21 16:49:41              luxbock </span><span>I see, yeah stateful navigators look very interesting</span></div><div data-t="conaw just had an idea that might be useful for some folks here… the new CSS Grid Module that just shipped in browsers has a feature called “grid-template-areas” which lets you build up an ascii-art style layout and then apply items to that layout according to names"><span class="u" id="1490205241.353381">2017:03:22 17:54:01                conaw </span><span>just had an idea that might be useful for some folks here… the new CSS Grid Module that just shipped in browsers has a feature called “grid-template-areas” which lets you build up an ascii-art style layout and then apply items to that layout according to names</span></div><div data-t="conaw so you’d have 
 ” ‘header header header’ 
‘sidebar content ads&apos;
&apos;footer footer footer’&quot;
"><span class="u" id="1490205304.379129">2017:03:22 17:55:04                conaw </span><span>so you’d have 
</span><pre>” ‘header header header’ 
‘sidebar content ads&apos;
&apos;footer footer footer’&quot;
</pre></div><div data-t="conaw I’ve been thinking about how I might dynamically generate certain named layouts based on content and user actions, realized specter could be used for doing things like inserting columns"><span class="u" id="1490205364.404396">2017:03:22 17:56:04                conaw </span><span>I’ve been thinking about how I might dynamically generate certain named layouts based on content and user actions, realized specter could be used for doing things like inserting columns</span></div><div data-t="conaw http://gridbyexample.com/video/grid-template-areas/"><span class="u" id="1490207184.135470">2017:03:22 18:26:24                conaw </span><a href="http://gridbyexample.com/video/grid-template-areas/">http://gridbyexample.com/video/grid-template-areas/</a></div><div data-t="conaw (def a (for [x (range 6)]
         (for [y (range 6)]
           y
           )
         ))

(sp/setval [(sp/srange 0 3) ALL
            (sp/srange 4 5) ALL] :a
a
          )
"><span class="u" id="1490207204.144013">2017:03:22 18:26:44                conaw </span><pre>(def a (for [x (range 6)]
         (for [y (range 6)]
           y
           )
         ))

(sp/setval [(sp/srange 0 3) ALL
            (sp/srange 4 5) ALL] :a
a
          )
</pre></div><div data-t="mmer Hi I have an question about adding a entry to a map based on the existence of a string within a value of a particular entry in the map:"><span class="u" id="1490302980.008297">2017:03:23 21:03:00                 mmer </span><span>Hi I have an question about adding a entry to a map based on the existence of a string within a value of a particular entry in the map:</span></div><div data-t="mmer I want to do a transform that removes the (read-only) from the desc fields
  and adds a map entry read-only: true to the map that contains the desc.
  
  I tried using the walker and predicate to find the entries with the (read-only) string
  the problem I have is that I can&apos;t find a way to create a transform that adds the entry.
  
  Removing the string is a bonus and I would be happy just to do the add."><span class="u" id="1490303262.103774">2017:03:23 21:07:42                 mmer </span><span>I want to do a transform that removes the (read-only) from the desc fields
  and adds a map entry read-only: true to the map that contains the desc.
  
  I tried using the walker and predicate to find the entries with the (read-only) string
  the problem I have is that I can&apos;t find a way to create a transform that adds the entry.
  
  Removing the string is a bonus and I would be happy just to do the add.</span></div><div data-t="nathanmarz @mmer not understanding your input"><span class="u" id="1490304630.537752">2017:03:23 21:30:30           nathanmarz </span><span>@mmer not understanding your input</span></div><div data-t="nathanmarz it&apos;s not a map, did you mean to have a vector of maps?"><span class="u" id="1490304640.540612">2017:03:23 21:30:40           nathanmarz </span><span>it&apos;s not a map, did you mean to have a vector of maps?</span></div><div data-t="nathanmarz what&apos;s &quot;type&quot; and &quot;desc&quot;? strings?"><span class="u" id="1490304651.544159">2017:03:23 21:30:51           nathanmarz </span><span>what&apos;s &quot;type&quot; and &quot;desc&quot;? strings?</span></div><div data-t="nathanmarz same with their values"><span class="u" id="1490304655.545219">2017:03:23 21:30:55           nathanmarz </span><span>same with their values</span></div><div data-t="nathanmarz you want to convert maps containing a description containing  &quot;(read-only)&quot;  to one with key/value pair of  :read-only true  and with the  (&quot;read-only&quot;)  removed?"><span class="u" id="1490304736.570240">2017:03:23 21:32:16           nathanmarz </span><span>you want to convert maps containing a description containing </span><code>&quot;(read-only)&quot;</code><span> to one with key/value pair of </span><code>:read-only true</code><span> and with the </span><code>(&quot;read-only&quot;)</code><span> removed?</span></div><div data-t="mmer Sorry I missed the key in the outside map  now edited as it is"><span class="u" id="1490307520.292845">2017:03:23 22:18:40                 mmer </span><span>Sorry I missed the key in the outside map  now edited as it is</span></div><div data-t="mmer target:"><span class="u" id="1490307617.314133">2017:03:23 22:20:17                 mmer </span><span>target:</span></div><div data-t="nathanmarz ok, I&apos;ll just assume the keys are keywords and the value for properties is a sequence"><span class="u" id="1490307734.340329">2017:03:23 22:22:14           nathanmarz </span><span>ok, I&apos;ll just assume the keys are keywords and the value for properties is a sequence</span></div><div data-t="nathanmarz it would look something like:
 (multi-transform [:properties 
                  ALL
                  (selected? :desc #(.contains % &quot;(read-only&quot;)))
                  (multi-path [:desc (terminal remove-read-only-str)]
                              [:read-only (terminal-val true)])] 
         data)
"><span class="u" id="1490307861.368801">2017:03:23 22:24:21           nathanmarz </span><span>it would look something like:
</span><pre>(multi-transform [:properties 
                  ALL
                  (selected? :desc #(.contains % &quot;(read-only&quot;)))
                  (multi-path [:desc (terminal remove-read-only-str)]
                              [:read-only (terminal-val true)])] 
         data)
</pre></div><div data-t="nathanmarz with  https://github.com/nathanmarz/specter/issues/183  you could do this without any custom or anonymous functions"><span class="u" id="1490308039.408074">2017:03:23 22:27:19           nathanmarz </span><span>with </span><a href="https://github.com/nathanmarz/specter/issues/183">https://github.com/nathanmarz/specter/issues/183</a><span> you could do this without any custom or anonymous functions</span></div><div data-t="nathanmarz by replacing the anonymous function with  (regex-all #&quot;(read-only)&quot;)  and replacing  remove-read-only-str  custom function with  (regex-all #&quot;(read-only)&quot;) (terminal-val &quot;&quot;)"><span class="u" id="1490308092.419352">2017:03:23 22:28:12           nathanmarz </span><span>by replacing the anonymous function with </span><code>(regex-all #&quot;(read-only)&quot;)</code><span> and replacing </span><code>remove-read-only-str</code><span> custom function with </span><code>(regex-all #&quot;(read-only)&quot;) (terminal-val &quot;&quot;)</code></div><div data-t="mmer Thanks once again"><span class="u" id="1490308439.494741">2017:03:23 22:33:59                 mmer </span><span>Thanks once again</span></div><div data-t="mmer I am rather puzzled by the #anglican?  I presume that is slack getting in the way?"><span class="u" id="1490308539.515696">2017:03:23 22:35:39                 mmer </span><span>I am rather puzzled by the #anglican?  I presume that is slack getting in the way?</span></div><div data-t="nathanmarz hmm not sure why it did that"><span class="u" id="1490309014.614706">2017:03:23 22:43:34           nathanmarz </span><span>hmm not sure why it did that</span></div><div data-t="nathanmarz fixed it"><span class="u" id="1490309016.614979">2017:03:23 22:43:36           nathanmarz </span><span>fixed it</span></div><div data-t="mmer Thanks I do have a followup question - if you change :properties with ALL I get a NullPointerException - in fact any changes to the :properties ALL seems to result in the same exception"><span class="u" id="1490312668.279557">2017:03:23 23:44:28                 mmer </span><span>Thanks I do have a followup question - if you change :properties with ALL I get a NullPointerException - in fact any changes to the :properties ALL seems to result in the same exception</span></div><div data-t="nathanmarz well,  ALL  on a map navigates you to a vector of  [key value]"><span class="u" id="1490312744.291951">2017:03:23 23:45:44           nathanmarz </span><span>well, </span><code>ALL</code><span> on a map navigates you to a vector of </span><code>[key value]</code></div><div data-t="nathanmarz the next  ALL  navigates you to each  key  and  value"><span class="u" id="1490312759.294255">2017:03:23 23:45:59           nathanmarz </span><span>the next </span><code>ALL</code><span> navigates you to each </span><code>key</code><span> and </span><code>value</code></div><div data-t="nathanmarz then the  selected?  line navigates to  :desc  for each of those values, which in some cases is nil"><span class="u" id="1490312781.297755">2017:03:23 23:46:21           nathanmarz </span><span>then the </span><code>selected?</code><span> line navigates to </span><code>:desc</code><span> for each of those values, which in some cases is nil</span></div><div data-t="nathanmarz so doing  .contains  on nil will be a  NullPointedException"><span class="u" id="1490312793.299675">2017:03:23 23:46:33           nathanmarz </span><span>so doing </span><code>.contains</code><span> on nil will be a </span><code>NullPointedException</code></div><div data-t="nathanmarz you probably wanted to replace  :properties  with  MAP-VALS , but I&apos;m not sure since your input data still isn&apos;t clear"><span class="u" id="1490312918.319716">2017:03:23 23:48:38           nathanmarz </span><span>you probably wanted to replace </span><code>:properties</code><span> with </span><code>MAP-VALS</code><span>, but I&apos;m not sure since your input data still isn&apos;t clear</span></div><div data-t="snacks hi:  If i have a nested map like this map1   {:a [{:b 1 c:3} {:b 2  c:0}] :b 0 }    I need to update  :b   key based on the  :c   from one of these nested maps under  :a  and I have a filter function fn1 to select it based on  :c  value . is this the right way to do it?
 (transform [(collect :a ALL (selected? [:c ?fn1]) :b) :b] (fn [new old] new) map1)"><span class="u" id="1490324291.804096">2017:03:24 02:58:11               snacks </span><span>hi:  If i have a nested map like this map1 </span><code> {:a [{:b 1 c:3} {:b 2  c:0}] :b 0 } </code><span>  I need to update </span><code>:b</code><span>  key based on the </span><code>:c</code><span>  from one of these nested maps under </span><code>:a</code><span> and I have a filter function fn1 to select it based on </span><code>:c</code><span> value . is this the right way to do it?
</span><pre>(transform [(collect :a ALL (selected? [:c ?fn1]) :b) :b] (fn [new old] new) map1)</pre></div><div data-t="nathanmarz the code isn&apos;t matching up with your description"><span class="u" id="1490324433.822261">2017:03:24 03:00:33           nathanmarz </span><span>the code isn&apos;t matching up with your description</span></div><div data-t="nathanmarz the code is collecting  :b  values, not  :c  values"><span class="u" id="1490324458.825580">2017:03:24 03:00:58           nathanmarz </span><span>the code is collecting </span><code>:b</code><span> values, not </span><code>:c</code><span> values</span></div><div data-t="nathanmarz you&apos;re also collecting a sequence of values, not &quot;one of&quot; the values"><span class="u" id="1490324519.832815">2017:03:24 03:01:59           nathanmarz </span><span>you&apos;re also collecting a sequence of values, not &quot;one of&quot; the values</span></div><div data-t="snacks yes it is collecting  :b  value, but using   :c  values to select which map to collect  :b  values from. so if fn1 is  ??even  it will return [1] while  ?odd  will return [2]."><span class="u" id="1490324771.861180">2017:03:24 03:06:11               snacks </span><span>yes it is collecting </span><code>:b</code><span> value, but using  </span><code>:c</code><span> values to select which map to collect </span><code>:b</code><span> values from. so if fn1 is </span><code>??even</code><span> it will return [1] while </span><code>?odd</code><span> will return [2].</span></div><div data-t="nathanmarz I think you have that reversed"><span class="u" id="1490324918.877378">2017:03:24 03:08:38           nathanmarz </span><span>I think you have that reversed</span></div><div data-t="nathanmarz if fn1 is  odd?  it will collect  [1]"><span class="u" id="1490324932.878823">2017:03:24 03:08:52           nathanmarz </span><span>if fn1 is </span><code>odd?</code><span> it will collect </span><code>[1]</code></div><div data-t="nathanmarz but yea, the code looks correct as long as you&apos;re looking to set  :b  in the top-level map to a sequence"><span class="u" id="1490324970.882835">2017:03:24 03:09:30           nathanmarz </span><span>but yea, the code looks correct as long as you&apos;re looking to set </span><code>:b</code><span> in the top-level map to a sequence</span></div><div data-t="nathanmarz also you don&apos;t need the  [...]  in  selected?"><span class="u" id="1490324986.884491">2017:03:24 03:09:46           nathanmarz </span><span>also you don&apos;t need the </span><code>[...]</code><span> in </span><code>selected?</code></div><div data-t="nathanmarz (selected? :c fn1)"><span class="u" id="1490324996.885730">2017:03:24 03:09:56           nathanmarz </span><code>(selected? :c fn1)</code></div><div data-t="snacks ok thanks"><span class="u" id="1490325001.886304">2017:03:24 03:10:01               snacks </span><span>ok thanks</span></div><div data-t="snacks you can use setval with collect?"><span class="u" id="1490325011.887492">2017:03:24 03:10:11               snacks </span><span>you can use setval with collect?</span></div><div data-t="nathanmarz no"><span class="u" id="1490325018.888381">2017:03:24 03:10:18           nathanmarz </span><span>no</span></div><div data-t="snacks ok"><span class="u" id="1490325023.888929">2017:03:24 03:10:23               snacks </span><span>ok</span></div><div data-t="nathanmarz I mean, it will execute but collected values will be ignored"><span class="u" id="1490325054.892287">2017:03:24 03:10:54           nathanmarz </span><span>I mean, it will execute but collected values will be ignored</span></div><div data-t="borkdude How do I prune a map in specter? select only selects the values, but I want something like a recursive  select-keys . I can’t find a good example of this on the wiki"><span class="u" id="1490360861.736252">2017:03:24 13:07:41             borkdude </span><span>How do I prune a map in specter? select only selects the values, but I want something like a recursive </span><code>select-keys</code><span>. I can’t find a good example of this on the wiki</span></div><div data-t="nathanmarz @borkdude you can do something like this:
 (def data {:a {:a 1 :b 2 :c 3} :b {:a 1 :b 2 :c 3 :d 4} :c {:a 1}})

(def ALL-MAPS
  (recursive-path [] p
    (if-path map?
      (stay-then-continue
        MAP-VALS p)
      )))

(transform ALL-MAPS #(select-keys % [:a :b]) data)
;; =&gt; {:a {:a 1, :b 2}, :b {:a 1, :b 2}}
"><span class="u" id="1490361558.936220">2017:03:24 13:19:18           nathanmarz </span><span>@borkdude you can do something like this:
</span><pre>(def data {:a {:a 1 :b 2 :c 3} :b {:a 1 :b 2 :c 3 :d 4} :c {:a 1}})

(def ALL-MAPS
  (recursive-path [] p
    (if-path map?
      (stay-then-continue
        MAP-VALS p)
      )))

(transform ALL-MAPS #(select-keys % [:a :b]) data)
;; =&gt; {:a {:a 1, :b 2}, :b {:a 1, :b 2}}
</pre></div><div data-t="borkdude Thanks"><span class="u" id="1490361757.995330">2017:03:24 13:22:37             borkdude </span><span>Thanks</span></div><div data-t="tothda Hi All, I&apos;m using specter 1.0.0 and trying this example from the readme: 
 (setval [:a ALL nil?] NONE {:a [1 2 nil 3 nil]})  
what I get is this: 
 {:a [1 2 :com.rpl.specter.impl/NONE 3 :com.rpl.specter.impl/NONE]}  
instead of
 {:a [1 2 3]} 
Clojure version: 1.9.0-alpha14."><span class="u" id="1491236723.755634">2017:04:03 16:25:23               tothda </span><span>Hi All, I&apos;m using specter 1.0.0 and trying this example from the readme: 
</span><code>(setval [:a ALL nil?] NONE {:a [1 2 nil 3 nil]})</code><span> 
what I get is this: 
</span><code>{:a [1 2 :com.rpl.specter.impl/NONE 3 :com.rpl.specter.impl/NONE]}</code><span> 
instead of
</span><code>{:a [1 2 3]}</code><span>
Clojure version: 1.9.0-alpha14.</span></div><div data-t="nathanmarz @tothda that definitely works with 1.0.0"><span class="u" id="1491237833.161084">2017:04:03 16:43:53           nathanmarz </span><span>@tothda that definitely works with 1.0.0</span></div><div data-t="nathanmarz if you&apos;re using lein what&apos;s the output of  lein deps :tree ?"><span class="u" id="1491237842.164414">2017:04:03 16:44:02           nathanmarz </span><span>if you&apos;re using lein what&apos;s the output of </span><code>lein deps :tree</code><span>?</span></div><div data-t="tothda Ohh, I&apos;m sorry, it works. I started the REPL on a branch where specter version was 0.13.2 and then switched to an other branch with specter 1.0.0"><span class="u" id="1491239270.691495">2017:04:03 17:07:50               tothda </span><span>Ohh, I&apos;m sorry, it works. I started the REPL on a branch where specter version was 0.13.2 and then switched to an other branch with specter 1.0.0</span></div><div data-t="tothda After restarting the REPL with 1.0.0 it works obviously  😳"><span class="u" id="1491239343.717910">2017:04:03 17:09:03               tothda </span><span>After restarting the REPL with 1.0.0 it works obviously </span><b>😳</b></div><div data-t="nathanmarz cool"><span class="u" id="1491240959.306423">2017:04:03 17:35:59           nathanmarz </span><span>cool</span></div><div data-t="souenzzo recursive-path  shoud be used directly on &quot;path&quot;?
ex:  (transform [(walker ,,,) (recursive-path ,,,,) ,,,,] foo bar)"><span class="u" id="1491586121.414782">2017:04:07 17:28:41             souenzzo </span><code>recursive-path</code><span> shoud be used directly on &quot;path&quot;?
ex: </span><code>(transform [(walker ,,,) (recursive-path ,,,,) ,,,,] foo bar)</code></div><div data-t="nathanmarz @souenzzo yes that should work fine"><span class="u" id="1491589939.774424">2017:04:07 18:32:19           nathanmarz </span><span>@souenzzo yes that should work fine</span></div><div data-t="nathanmarz or you can use it to declare a top-level path or bind a symbol in  let"><span class="u" id="1491589960.781812">2017:04:07 18:32:40           nathanmarz </span><span>or you can use it to declare a top-level path or bind a symbol in </span><code>let</code></div><div data-t="souenzzo I usually declare at top-level. but in this case it contains a lot of parameters and (probably) will not be reuse.
I was unsure whether using in-line would lose optimization"><span class="u" id="1491590235.878834">2017:04:07 18:37:15             souenzzo </span><span>I usually declare at top-level. but in this case it contains a lot of parameters and (probably) will not be reuse.
I was unsure whether using in-line would lose optimization</span></div><div data-t="nathanmarz nope"><span class="u" id="1491590431.946855">2017:04:07 18:40:31           nathanmarz </span><span>nope</span></div><div data-t="nathanmarz you can see the produced code by wrapping it in  with-inline-debug  the first time the callsite is executed"><span class="u" id="1491590449.953006">2017:04:07 18:40:49           nathanmarz </span><span>you can see the produced code by wrapping it in </span><code>with-inline-debug</code><span> the first time the callsite is executed</span></div><div data-t="deplect I have a question, supose I want to delete all keys-values pairs in the :exposure map with spectre. How would I go about?"><span class="u" id="1491838032.655058">2017:04:10 15:27:12              deplect </span><span>I have a question, supose I want to delete all keys-values pairs in the :exposure map with spectre. How would I go about?</span></div><div data-t="deplect {:mdc-artificial/random {5 {:exposure {1000 {[1.0 2.0] 200.0}}}
                                   10 {:exposure {2000 {[1.0 2.0] 400.0}}}}}"><span class="u" id="1491838034.656090">2017:04:10 15:27:14              deplect </span><span>{:mdc-artificial/random {5 {:exposure {1000 {[1.0 2.0] 200.0}}}
                                   10 {:exposure {2000 {[1.0 2.0] 400.0}}}}}</span></div><div data-t="deplect where all key-values i want to delete must be smaller than 1500  🙂"><span class="u" id="1491838085.677360">2017:04:10 15:28:05              deplect </span><span>where all key-values i want to delete must be smaller than 1500 </span><b>🙂</b></div><div data-t="nathanmarz @deplect you mean empty all exposure maps where the sum of the numbers within is &lt; 1500?"><span class="u" id="1491841833.158836">2017:04:10 16:30:33           nathanmarz </span><span>@deplect you mean empty all exposure maps where the sum of the numbers within is &lt; 1500?</span></div><div data-t="nathanmarz that would just be:
 (transform [:mdc-artificial/random MAP-VALS
            :exposure
            (selected? (traversed (walker number?) +) #(&lt; % 1500))]
  empty
  data)
"><span class="u" id="1491841840.161318">2017:04:10 16:30:40           nathanmarz </span><span>that would just be:
</span><pre>(transform [:mdc-artificial/random MAP-VALS
            :exposure
            (selected? (traversed (walker number?) +) #(&lt; % 1500))]
  empty
  data)
</pre></div><div data-t="deplect hai Nathan, no I already figured it out …"><span class="u" id="1491841862.169651">2017:04:10 16:31:02              deplect </span><span>hai Nathan, no I already figured it out …</span></div><div data-t="deplect i want exactly the 1000 key in the exposure map to be gone."><span class="u" id="1491841885.178240">2017:04:10 16:31:25              deplect </span><span>i want exactly the 1000 key in the exposure map to be gone.</span></div><div data-t="deplect came down to: (sp/transform [MAP-VALS MAP-VALS MAP-VALS] #(remove-keys (partial &gt; expire-time) %) registry)"><span class="u" id="1491841913.188741">2017:04:10 16:31:53              deplect </span><span>came down to: (sp/transform [MAP-VALS MAP-VALS MAP-VALS] #(remove-keys (partial &gt; expire-time) %) registry)</span></div><div data-t="nathanmarz in that case I think you want something more along the lines of:
 (setval [:mdc-artificial/random
            MAP-VALS
            :exposure
            MAP-KEYS
            #(&lt; % 1500)]
  NONE
  data)
"><span class="u" id="1491842313.334174">2017:04:10 16:38:33           nathanmarz </span><span>in that case I think you want something more along the lines of:
</span><pre>(setval [:mdc-artificial/random
            MAP-VALS
            :exposure
            MAP-KEYS
            #(&lt; % 1500)]
  NONE
  data)
</pre></div><div data-t="deplect yes buy :mdc-artificial/random can be any value. :exposure will always be called exporsure"><span class="u" id="1491842371.354458">2017:04:10 16:39:31              deplect </span><span>yes buy :mdc-artificial/random can be any value. :exposure will always be called exporsure</span></div><div data-t="nathanmarz ah"><span class="u" id="1491842405.366737">2017:04:10 16:40:05           nathanmarz </span><span>ah</span></div><div data-t="nathanmarz easy to modify to handle that"><span class="u" id="1491842408.368003">2017:04:10 16:40:08           nathanmarz </span><span>easy to modify to handle that</span></div><div data-t="deplect yes works like a charm, the transform version fails under certain circumstances, thx!"><span class="u" id="1491842584.430801">2017:04:10 16:43:04              deplect </span><span>yes works like a charm, the transform version fails under certain circumstances, thx!</span></div><div data-t="snacks hi Nathan i have a question"><span class="u" id="1492007252.129993">2017:04:12 14:27:32               snacks </span><span>hi Nathan i have a question</span></div><div data-t="snacks Is there anyway I can use selected? with a selector takes multiple values. for example  def data [{:a 1 :b 1 :c 1} {:a 2 :b 1 :c 1}]"><span class="u" id="1492007260.132961">2017:04:12 14:27:40               snacks </span><span>Is there anyway I can use selected? with a selector takes multiple values. for example </span><code>def data [{:a 1 :b 1 :c 1} {:a 2 :b 1 :c 1}]</code></div><div data-t="snacks I only want to select sub maps where  :a  =  :b"><span class="u" id="1492007275.139182">2017:04:12 14:27:55               snacks </span><span>I only want to select sub maps where </span><code>:a</code><span> = </span><code>:b</code></div><div data-t="nathanmarz @snacks for that I would just use an anonymous function"><span class="u" id="1492007585.269079">2017:04:12 14:33:05           nathanmarz </span><span>@snacks for that I would just use an anonymous function</span></div><div data-t="nathanmarz #(= (:a %) (:b %))"><span class="u" id="1492007593.272251">2017:04:12 14:33:13           nathanmarz </span><code>#(= (:a %) (:b %))</code></div><div data-t="nathanmarz (def data [{:a 1 :b 1 :c &quot;biubiu&quot;} {:a 1 :b 2 :c 3}])
(select [ALL #(= (:a %) (:b %)) :c] data)
;; =&gt; [&quot;biubiu&quot;]
"><span class="u" id="1492007762.341844">2017:04:12 14:36:02           nathanmarz </span><pre>(def data [{:a 1 :b 1 :c &quot;biubiu&quot;} {:a 1 :b 2 :c 3}])
(select [ALL #(= (:a %) (:b %)) :c] data)
;; =&gt; [&quot;biubiu&quot;]
</pre></div><div data-t="snacks thanks!"><span class="u" id="1492008035.454112">2017:04:12 14:40:35               snacks </span><span>thanks!</span></div><div data-t="snacks why is it called specter?"><span class="u" id="1492027501.922868">2017:04:12 20:05:01               snacks </span><span>why is it called specter?</span></div><div data-t="nathanmarz @snacks from &quot;introspect&quot;"><span class="u" id="1492028139.139897">2017:04:12 20:15:39           nathanmarz </span><span>@snacks from &quot;introspect&quot;</span></div><div data-t="nathanmarz it was also released before clojure.spec was a thing, would choose a different name if I made it today"><span class="u" id="1492028199.160245">2017:04:12 20:16:39           nathanmarz </span><span>it was also released before clojure.spec was a thing, would choose a different name if I made it today</span></div><div data-t="souenzzo And  com.rpl.specter  was related with   ?"><span class="u" id="1492037543.757552">2017:04:12 22:52:23             souenzzo </span><span>And </span><code>com.rpl.specter</code><span> was related with </span><code></code><span>?</span></div><div data-t="nathanmarz @souenzzo no, my company is called Red Planet Labs"><span class="u" id="1492040807.325884">2017:04:12 23:46:47           nathanmarz </span><span>@souenzzo no, my company is called Red Planet Labs</span></div><div data-t="nathanmarz no website yet"><span class="u" id="1492040820.327784">2017:04:12 23:47:00           nathanmarz </span><span>no website yet</span></div><div data-t="tankthinks anyone around?"><span class="u" id="1492091561.967154">2017:04:13 13:52:41           tankthinks </span><span>anyone around?</span></div><div data-t="nathanmarz @tankthinks yes"><span class="u" id="1492092357.272229">2017:04:13 14:05:57           nathanmarz </span><span>@tankthinks yes</span></div><div data-t="tankthinks hey @nathanmarz!"><span class="u" id="1492092367.275584">2017:04:13 14:06:07           tankthinks </span><span>hey @nathanmarz!</span></div><div data-t="tankthinks first and foremost … specter is awesome"><span class="u" id="1492092377.279224">2017:04:13 14:06:17           tankthinks </span><span>first and foremost … specter is awesome</span></div><div data-t="tankthinks now that I have that out of the way"><span class="u" id="1492092386.283108">2017:04:13 14:06:26           tankthinks </span><span>now that I have that out of the way</span></div><div data-t="nathanmarz thanks"><span class="u" id="1492092423.296969">2017:04:13 14:07:03           nathanmarz </span><span>thanks</span></div><div data-t="tankthinks I need to transform this data structure (I’ve elided unnecessary bits for now):
 (def plans
  {:plans &apos;({:planId &quot;1&quot;
             :disbursements ({:history ({:amount &quot;1&quot; :disbursementDate &quot;2017-01-01&quot;}
                                        {:amount &quot;1&quot; :disbursementDate &quot;2017-01-01&quot;}
                                        {:amount &quot;2&quot; :disbursementDate &quot;2017-02-01&quot;}
                                        {:amount &quot;3&quot; :disbursementDate &quot;2017-03-01&quot;})})})})
"><span class="u" id="1492092430.299602">2017:04:13 14:07:10           tankthinks </span><span>I need to transform this data structure (I’ve elided unnecessary bits for now):
</span><pre>(def plans
  {:plans &apos;({:planId &quot;1&quot;
             :disbursements ({:history ({:amount &quot;1&quot; :disbursementDate &quot;2017-01-01&quot;}
                                        {:amount &quot;1&quot; :disbursementDate &quot;2017-01-01&quot;}
                                        {:amount &quot;2&quot; :disbursementDate &quot;2017-02-01&quot;}
                                        {:amount &quot;3&quot; :disbursementDate &quot;2017-03-01&quot;})})})})
</pre></div><div data-t="tankthinks by removing duplicate entries from the  :history  list"><span class="u" id="1492092459.310447">2017:04:13 14:07:39           tankthinks </span><span>by removing duplicate entries from the </span><code>:history</code><span> list</span></div><div data-t="tankthinks this basically does what I want:
 (transform [:plans ALL #(= &quot;1&quot; (:planId %)) :disbursements ALL :history]
  dedupe
  plans)
"><span class="u" id="1492092472.315366">2017:04:13 14:07:52           tankthinks </span><span>this basically does what I want:
</span><pre>(transform [:plans ALL #(= &quot;1&quot; (:planId %)) :disbursements ALL :history]
  dedupe
  plans)
</pre></div><div data-t="tankthinks but what if I want a predicate to ensure that I’m only  dedupe ing entries from January, i.e. “2017-01-01”"><span class="u" id="1492092510.329928">2017:04:13 14:08:30           tankthinks </span><span>but what if I want a predicate to ensure that I’m only </span><code>dedupe</code><span>ing entries from January, i.e. “2017-01-01”</span></div><div data-t="nathanmarz hmm"><span class="u" id="1492092552.345470">2017:04:13 14:09:12           nathanmarz </span><span>hmm</span></div><div data-t="nathanmarz gonna have to do it manually for now in your transform fn"><span class="u" id="1492092566.350918">2017:04:13 14:09:26           nathanmarz </span><span>gonna have to do it manually for now in your transform fn</span></div><div data-t="nathanmarz it&apos;s possible  subselect  could be extended to support that"><span class="u" id="1492092586.358240">2017:04:13 14:09:46           nathanmarz </span><span>it&apos;s possible </span><code>subselect</code><span> could be extended to support that</span></div><div data-t="nathanmarz so you could do:
 (transform [:plans ALL #(= &quot;1&quot; (:planId %)) :disbursements ALL :history (filterer :disbursementDate #(= % “2017-01-01”))]
  dedupe
  plans)
"><span class="u" id="1492092628.375039">2017:04:13 14:10:28           nathanmarz </span><span>so you could do:
</span><pre>(transform [:plans ALL #(= &quot;1&quot; (:planId %)) :disbursements ALL :history (filterer :disbursementDate #(= % “2017-01-01”))]
  dedupe
  plans)
</pre></div><div data-t="nathanmarz right now  subselect /`filterer` require the output sequence to be the same size as the input"><span class="u" id="1492092652.384326">2017:04:13 14:10:52           nathanmarz </span><span>right now </span><code>subselect</code><span>/`filterer` require the output sequence to be the same size as the input</span></div><div data-t="nathanmarz the logic change would be to fill in removed entires with  NONE  to trigger removal"><span class="u" id="1492092701.402637">2017:04:13 14:11:41           nathanmarz </span><span>the logic change would be to fill in removed entires with </span><code>NONE</code><span> to trigger removal</span></div><div data-t="nathanmarz that would be a good issue to open on github"><span class="u" id="1492092726.411802">2017:04:13 14:12:06           nathanmarz </span><span>that would be a good issue to open on github</span></div><div data-t="tankthinks ah … cool"><span class="u" id="1492092914.483094">2017:04:13 14:15:14           tankthinks </span><span>ah … cool</span></div><div data-t="tankthinks Thank you for the quick response … I’ll play around a bit to make sure I completely understand, then I’ll submit an issue"><span class="u" id="1492092981.509123">2017:04:13 14:16:21           tankthinks </span><span>Thank you for the quick response … I’ll play around a bit to make sure I completely understand, then I’ll submit an issue</span></div><div data-t="nathanmarz actually it&apos;s fine"><span class="u" id="1492092989.512359">2017:04:13 14:16:29           nathanmarz </span><span>actually it&apos;s fine</span></div><div data-t="nathanmarz I was curious so I just implemented it"><span class="u" id="1492092993.513971">2017:04:13 14:16:33           nathanmarz </span><span>I was curious so I just implemented it</span></div><div data-t="tankthinks haha"><span class="u" id="1492093001.517146">2017:04:13 14:16:41           tankthinks </span><span>haha</span></div><div data-t="nathanmarz @tankthinks  https://github.com/nathanmarz/specter/commit/be30e46960c879d6177d8ab8c2d3f4450bab0095"><span class="u" id="1492093245.610841">2017:04:13 14:20:45           nathanmarz </span><span>@tankthinks </span><a href="https://github.com/nathanmarz/specter/commit/be30e46960c879d6177d8ab8c2d3f4450bab0095">https://github.com/nathanmarz/specter/commit/be30e46960c879d6177d8ab8c2d3f4450bab0095</a></div><div data-t="nathanmarz quite elegant I think"><span class="u" id="1492093317.638324">2017:04:13 14:21:57           nathanmarz </span><span>quite elegant I think</span></div><div data-t="tankthinks so … uh … you’re welcome?"><span class="u" id="1492093333.644268">2017:04:13 14:22:13           tankthinks </span><span>so … uh … you’re welcome?</span></div><div data-t="tankthinks 😃"><span class="u" id="1492093349.651078">2017:04:13 14:22:29           tankthinks </span><b>😃</b></div><div data-t="nathanmarz 😉"><span class="u" id="1492093350.651627">2017:04:13 14:22:30           nathanmarz </span><b>😉</b></div><div data-t="tankthinks thanks again @nathanmarz, not sure how I would have done that without specter … cheers!"><span class="u" id="1492094781.213928">2017:04:13 14:46:21           tankthinks </span><span>thanks again @nathanmarz, not sure how I would have done that without specter … cheers!</span></div><div data-t="nathanmarz Released Specter 1.0.1 (bug fixes and minor enhancements)  https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><span class="u" id="1492460622.626018">2017:04:17 20:23:42           nathanmarz </span><span>Released Specter 1.0.1 (bug fixes and minor enhancements) </span><a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></div><div data-t="mbjarland Hi Nathan. I&apos;m new to specter but this seems indeed like the bees knees"><span class="u" id="1492533510.759161">2017:04:18 16:38:30            mbjarland </span><span>Hi Nathan. I&apos;m new to specter but this seems indeed like the bees knees</span></div><div data-t="mbjarland I have a question, a while back I posted the following s.o. question: 
 https://stackoverflow.com/questions/42551765/idiomatic-and-concise-way-of-working-with-nested-map-vector-structures-in-clojur 
and I have been playing for the past few hours with using spectre for this nested traversal problem. In essense I have some json data (maps and vectors) and I need to traverse to a certain depth, do a few operations, remember context, traverse a few more levels down, do a few operations etc"><span class="u" id="1492533572.785139">2017:04:18 16:39:32            mbjarland </span><span>I have a question, a while back I posted the following s.o. question: 
</span><a href="https://stackoverflow.com/questions/42551765/idiomatic-and-concise-way-of-working-with-nested-map-vector-structures-in-clojur">https://stackoverflow.com/questions/42551765/idiomatic-and-concise-way-of-working-with-nested-map-vector-structures-in-clojur</a><span>
and I have been playing for the past few hours with using spectre for this nested traversal problem. In essense I have some json data (maps and vectors) and I need to traverse to a certain depth, do a few operations, remember context, traverse a few more levels down, do a few operations etc</span></div><div data-t="mbjarland I am not really interested in changing the traverse structure. I assume I should be using collectors then?"><span class="u" id="1492533728.849717">2017:04:18 16:42:08            mbjarland </span><span>I am not really interested in changing the traverse structure. I assume I should be using collectors then?</span></div><div data-t="nathanmarz @mbjarland so to clarify, you&apos;re not transforming the nested structure, you just want to perform some operations using values inside?"><span class="u" id="1492533841.897628">2017:04:18 16:44:01           nathanmarz </span><span>@mbjarland so to clarify, you&apos;re not transforming the nested structure, you just want to perform some operations using values inside?</span></div><div data-t="mbjarland this is the groovy equivalent of what I want to do: 
 json.issues.each { issue -&gt;
  issue.changelog.histories.each { history -&gt;
    def date = DateTime.parse(history.created)
    if (date &lt; fromDate || date &gt; toDate) return

    def timeItems = history.items.findAll { it.field == &apos;timespent&apos; }
    if (!timeItems) return

    def consultant = history.author.displayName
    timeItems.each { item -&gt;
      def from = (item.from ?: 0) as Integer
      def to   = (   ?: 0) as Integer

      timesheets[consultant].entries &lt;&lt; new TimeEntry(date: date, issueKey: issue.key, secondsSpent: to - from)
    }
  }
}
"><span class="u" id="1492533863.907075">2017:04:18 16:44:23            mbjarland </span><span>this is the groovy equivalent of what I want to do: 
</span><pre>json.issues.each { issue -&gt;
  issue.changelog.histories.each { history -&gt;
    def date = DateTime.parse(history.created)
    if (date &lt; fromDate || date &gt; toDate) return

    def timeItems = history.items.findAll { it.field == &apos;timespent&apos; }
    if (!timeItems) return

    def consultant = history.author.displayName
    timeItems.each { item -&gt;
      def from = (item.from ?: 0) as Integer
      def to   = (   ?: 0) as Integer

      timesheets[consultant].entries &lt;&lt; new TimeEntry(date: date, issueKey: issue.key, secondsSpent: to - from)
    }
  }
}
</pre></div><div data-t="mbjarland and generate some resulting data  structure (map)"><span class="u" id="1492533893.919111">2017:04:18 16:44:53            mbjarland </span><span>and generate some resulting data  structure (map)</span></div><div data-t="mbjarland it seems that the path traversals above  json.issues.each ,  issue.changelog.histories.each , etc are a perfect match for specter"><span class="u" id="1492533925.933166">2017:04:18 16:45:25            mbjarland </span><span>it seems that the path traversals above </span><code>json.issues.each</code><span>, </span><code>issue.changelog.histories.each</code><span>, etc are a perfect match for specter</span></div><div data-t="nathanmarz it sounds like you want to do a  traverse  to get to the values you care about in the order you want"><span class="u" id="1492533929.934936">2017:04:18 16:45:29           nathanmarz </span><span>it sounds like you want to do a </span><code>traverse</code><span> to get to the values you care about in the order you want</span></div><div data-t="nathanmarz and then  reduce  over that to generate your result"><span class="u" id="1492533942.940216">2017:04:18 16:45:42           nathanmarz </span><span>and then </span><code>reduce</code><span> over that to generate your result</span></div><div data-t="mbjarland and multiple nested traverses to get hold of the different levels (issue, history, item) above?"><span class="u" id="1492534020.973985">2017:04:18 16:47:00            mbjarland </span><span>and multiple nested traverses to get hold of the different levels (issue, history, item) above?</span></div><div data-t="nathanmarz use  collect  /  collect-one"><span class="u" id="1492534115.013602">2017:04:18 16:48:35           nathanmarz </span><span>use </span><code>collect</code><span> / </span><code>collect-one</code></div><div data-t="nathanmarz a simplified example:
 (reduce conj [] (traverse [ALL (collect-one :name) :age] [{:name &quot;Bob&quot; :age 21} {:name &quot;Alice&quot; :age 20}]))
"><span class="u" id="1492534218.054837">2017:04:18 16:50:18           nathanmarz </span><span>a simplified example:
</span><pre>(reduce conj [] (traverse [ALL (collect-one :name) :age] [{:name &quot;Bob&quot; :age 21} {:name &quot;Alice&quot; :age 20}]))
</pre></div><div data-t="mbjarland ok, that&apos;s probably enough to nudge me in the right direction"><span class="u" id="1492534343.105868">2017:04:18 16:52:23            mbjarland </span><span>ok, that&apos;s probably enough to nudge me in the right direction</span></div><div data-t="mbjarland thank you! ...and clojure still makes me feel like an idiot at least once a day"><span class="u" id="1492534390.124314">2017:04:18 16:53:10            mbjarland </span><span>thank you! ...and clojure still makes me feel like an idiot at least once a day</span></div><div data-t="mbjarland I&apos;ve been trying various methods of getting the groovy code above expressive and terse in clojure, I think specter might be the answer"><span class="u" id="1492534449.148379">2017:04:18 16:54:09            mbjarland </span><span>I&apos;ve been trying various methods of getting the groovy code above expressive and terse in clojure, I think specter might be the answer</span></div><div data-t="nathanmarz your path would look something like:  [:issues ALL :changelog :histories ALL (selected? :date #(&gt; % fromDate) #(&lt; % toDate)) (collect-one :author :displayName) :items ALL #(= (:field %) &quot;timespent&quot;) (collect-one :from (nil-&gt;val 0)) :to (nil-&gt;val 0)]"><span class="u" id="1492534515.175238">2017:04:18 16:55:15           nathanmarz </span><span>your path would look something like: </span><code>[:issues ALL :changelog :histories ALL (selected? :date #(&gt; % fromDate) #(&lt; % toDate)) (collect-one :author :displayName) :items ALL #(= (:field %) &quot;timespent&quot;) (collect-one :from (nil-&gt;val 0)) :to (nil-&gt;val 0)]</code></div><div data-t="mbjarland : )"><span class="u" id="1492534549.189821">2017:04:18 16:55:49            mbjarland </span><span>: )</span></div><div data-t="nathanmarz or something like that"><span class="u" id="1492534565.196173">2017:04:18 16:56:05           nathanmarz </span><span>or something like that</span></div><div data-t="mbjarland this is by the way the json returned from a jira instance and we use the results for invoicing so it is an actual real world example"><span class="u" id="1492534626.221390">2017:04:18 16:57:06            mbjarland </span><span>this is by the way the json returned from a jira instance and we use the results for invoicing so it is an actual real world example</span></div><div data-t="mbjarland thank you, that helps a ton"><span class="u" id="1492534641.227631">2017:04:18 16:57:21            mbjarland </span><span>thank you, that helps a ton</span></div><div data-t="nathanmarz cool"><span class="u" id="1492534652.232297">2017:04:18 16:57:32           nathanmarz </span><span>cool</span></div><div data-t="nathanmarz no problem"><span class="u" id="1492534653.232878">2017:04:18 16:57:33           nathanmarz </span><span>no problem</span></div><div data-t="mbjarland one more question, in your path the date comparison assumes the date is parsed"><span class="u" id="1492534707.254662">2017:04:18 16:58:27            mbjarland </span><span>one more question, in your path the date comparison assumes the date is parsed</span></div><div data-t="mbjarland what if I need to do some computation at an intermediate level like parsing the date ?"><span class="u" id="1492534723.261340">2017:04:18 16:58:43            mbjarland </span><span>what if I need to do some computation at an intermediate level like parsing the date ?</span></div><div data-t="mbjarland just an inline function in the path expression?"><span class="u" id="1492534749.271723">2017:04:18 16:59:09            mbjarland </span><span>just an inline function in the path expression?</span></div><div data-t="mbjarland a privilege to be able to get answers directly from the author and I have to say I&apos;m impressed with the clojure community experience so far. Thanks again!"><span class="u" id="1492534951.358972">2017:04:18 17:02:31            mbjarland </span><span>a privilege to be able to get answers directly from the author and I have to say I&apos;m impressed with the clojure community experience so far. Thanks again!</span></div><div data-t="mbjarland : ) and the more I look at the above path expression....this is beautiful!"><span class="u" id="1492535347.520290">2017:04:18 17:09:07            mbjarland </span><span>: ) and the more I look at the above path expression....this is beautiful!</span></div><div data-t="nathanmarz @mbjarland you can insert  (view parse-date)  to parse before comparing"><span class="u" id="1492536856.200604">2017:04:18 17:34:16           nathanmarz </span><span>@mbjarland you can insert </span><code>(view parse-date)</code><span> to parse before comparing</span></div><div data-t="nathanmarz a function directly in a path is interpreted as a filter"><span class="u" id="1492536897.222113">2017:04:18 17:34:57           nathanmarz </span><span>a function directly in a path is interpreted as a filter</span></div><div data-t="mbjarland ok got a last one, for context I have the following function: 
 (defn disect-json [json from-date to-date]
  (let [path [:issues ALL
              (collect-one :key)
              :changelog :histories ALL
              #(history-in-date-range? % from-date to-date)
              (selected? [:items ALL #(= (:field %) &quot;timespent&quot;)])
              (collect-one (view #(parse-history-date %)))
              (collect-one [:author :displayName])
              :items ALL
              (collect-one :from (nil-&gt;val &quot;0&quot;) (view #(read-string %)))
              (collect-one :to (nil-&gt;val &quot;0&quot;) (view #(read-string %)))]]
        (group-by #(nth % 2)
          (reduce conj [] (traverse path json)))))
 
looking at the path expression, how do I terminate the path without selecting the currently navigated node and only keeping the  collect-one  values?"><span class="u" id="1492549435.013281">2017:04:18 21:03:55            mbjarland </span><span>ok got a last one, for context I have the following function: 
</span><pre>(defn disect-json [json from-date to-date]
  (let [path [:issues ALL
              (collect-one :key)
              :changelog :histories ALL
              #(history-in-date-range? % from-date to-date)
              (selected? [:items ALL #(= (:field %) &quot;timespent&quot;)])
              (collect-one (view #(parse-history-date %)))
              (collect-one [:author :displayName])
              :items ALL
              (collect-one :from (nil-&gt;val &quot;0&quot;) (view #(read-string %)))
              (collect-one :to (nil-&gt;val &quot;0&quot;) (view #(read-string %)))]]
        (group-by #(nth % 2)
          (reduce conj [] (traverse path json)))))
</pre><span>
looking at the path expression, how do I terminate the path without selecting the currently navigated node and only keeping the </span><code>collect-one</code><span> values?</span></div><div data-t="mbjarland oh and the above works, so I’m happy as a clam after looking for months for a clean solution for this in clojure."><span class="u" id="1492549689.097514">2017:04:18 21:08:09            mbjarland </span><span>oh and the above works, so I’m happy as a clam after looking for months for a clean solution for this in clojure.</span></div><div data-t="nathanmarz @mbjarland instead of collecting the last element, just navigate to it"><span class="u" id="1492551414.618478">2017:04:18 21:36:54           nathanmarz </span><span>@mbjarland instead of collecting the last element, just navigate to it</span></div><div data-t="nathanmarz terminate the path with  :to (nil-&gt;val &quot;0&quot;) (view #(read-string %)))  and drop the  collect-one"><span class="u" id="1492551435.623945">2017:04:18 21:37:15           nathanmarz </span><span>terminate the path with </span><code>:to (nil-&gt;val &quot;0&quot;) (view #(read-string %)))</code><span> and drop the </span><code>collect-one</code></div><div data-t="nathanmarz also you can do  (view parse-history-date)  to make it cleaner, same with usage of  read-string"><span class="u" id="1492551491.639696">2017:04:18 21:38:11           nathanmarz </span><span>also you can do </span><code>(view parse-history-date)</code><span> to make it cleaner, same with usage of </span><code>read-string</code></div><div data-t="nathanmarz also if you just want a vector of results back, just do  select  instead of  (reduce ... (traverse ...))"><span class="u" id="1492551541.653532">2017:04:18 21:39:01           nathanmarz </span><span>also if you just want a vector of results back, just do </span><code>select</code><span> instead of </span><code>(reduce ... (traverse ...))</code></div><div data-t="nathanmarz finally, you should specify the path inline with the  select  call so it can be properly optimized"><span class="u" id="1492551567.660827">2017:04:18 21:39:27           nathanmarz </span><span>finally, you should specify the path inline with the </span><code>select</code><span> call so it can be properly optimized</span></div><div data-t="nathanmarz or define the  path  local using specter&apos;s  path  macro"><span class="u" id="1492551610.672130">2017:04:18 21:40:10           nathanmarz </span><span>or define the </span><code>path</code><span> local using specter&apos;s </span><code>path</code><span> macro</span></div><div data-t="nathanmarz (let [json-path (path :issues ALL ...) ..."><span class="u" id="1492551625.676414">2017:04:18 21:40:25           nathanmarz </span><code>(let [json-path (path :issues ALL ...) ...</code></div><div data-t="albaker is there a way to walk any arbitrary map/vector/map nested structure?"><span class="u" id="1492562911.806583">2017:04:19 00:48:31              albaker </span><span>is there a way to walk any arbitrary map/vector/map nested structure?</span></div><div data-t="albaker trying to get success generations of something like  {:a &quot;blah&quot; :b :undefined}  -&gt;  {:a blah :b [{:a &quot;blah :b :undefined}] }"><span class="u" id="1492563184.843982">2017:04:19 00:53:04              albaker </span><span>trying to get success generations of something like </span><code>{:a &quot;blah&quot; :b :undefined}</code><span> -&gt; </span><code>{:a blah :b [{:a &quot;blah :b :undefined}] }</code></div><div data-t="nathanmarz @albaker yes, walker does that"><span class="u" id="1492570463.794720">2017:04:19 02:54:23           nathanmarz </span><span>@albaker yes, walker does that</span></div><div data-t="nathanmarz or you can define a more precise navigator using  recursive-path"><span class="u" id="1492570488.797653">2017:04:19 02:54:48           nathanmarz </span><span>or you can define a more precise navigator using </span><code>recursive-path</code></div><div data-t="nathanmarz not sure what you&apos;re going for with that transformation, need more examples or explanation"><span class="u" id="1492570508.799849">2017:04:19 02:55:08           nathanmarz </span><span>not sure what you&apos;re going for with that transformation, need more examples or explanation</span></div><div data-t="mbjarland @nathanmarz thank you. Got the select part right while tinkering last night, should have seen the view function pattern, guidance much appreciated."><span class="u" id="1492576828.475620">2017:04:19 04:40:28            mbjarland </span><span>@nathanmarz thank you. Got the select part right while tinkering last night, should have seen the view function pattern, guidance much appreciated.</span></div><div data-t="mbjarland @nathanmarz is there any way to refer back to a  collect-one :ed value in a filter expression later in the path?"><span class="u" id="1492593148.291113">2017:04:19 09:12:28            mbjarland </span><span>@nathanmarz is there any way to refer back to a </span><code>collect-one</code><span>:ed value in a filter expression later in the path?</span></div><div data-t="nathanmarz @mbjarland yes, use  collected?"><span class="u" id="1492599873.815863">2017:04:19 11:04:33           nathanmarz </span><span>@mbjarland yes, use </span><code>collected?</code></div><div data-t="nathanmarz also see  DISPENSE  and  with-fresh-collected"><span class="u" id="1492599898.820433">2017:04:19 11:04:58           nathanmarz </span><span>also see </span><code>DISPENSE</code><span> and </span><code>with-fresh-collected</code></div><div data-t="mbjarland @nathanmarz fresh out the oven? these don&apos;t seem to be part of the online docs, will fire up a repl and take a look"><span class="u" id="1492601128.066464">2017:04:19 11:25:28            mbjarland </span><span>@nathanmarz fresh out the oven? these don&apos;t seem to be part of the online docs, will fire up a repl and take a look</span></div><div data-t="nathanmarz @mbjarland not on the wiki but in the API docs  https://nathanmarz.github.io/specter/"><span class="u" id="1492602587.365970">2017:04:19 11:49:47           nathanmarz </span><span>@mbjarland not on the wiki but in the API docs </span><a href="https://nathanmarz.github.io/specter/">https://nathanmarz.github.io/specter/</a></div><div data-t="albaker @nathanmarz basically want to run something like  (transform walker expander-function)  that I can repeatedly call until some notion of completion"><span class="u" id="1492610322.685976">2017:04:19 13:58:42              albaker </span><span>@nathanmarz basically want to run something like </span><code>(transform walker expander-function)</code><span> that I can repeatedly call until some notion of completion</span></div><div data-t="albaker where each transform has that  {:a &quot;blah&quot; :b :undefined}  -&gt;  {:a blah :b [{:a &quot;blah :b :undefined}] }  style replace a key in the map, or maybe nested map/vectors"><span class="u" id="1492610360.701683">2017:04:19 13:59:20              albaker </span><span>where each transform has that </span><code>{:a &quot;blah&quot; :b :undefined}</code><span> -&gt; </span><code>{:a blah :b [{:a &quot;blah :b :undefined}] }</code><span> style replace a key in the map, or maybe nested map/vectors</span></div><div data-t="nathanmarz @albaker you can use  stay-then-continue  to transform something and then continue recursing into the transformed value"><span class="u" id="1492610414.725342">2017:04:19 14:00:14           nathanmarz </span><span>@albaker you can use </span><code>stay-then-continue</code><span> to transform something and then continue recursing into the transformed value</span></div><div data-t="nathanmarz e.g.  (recursive-path [] p [(walker vector?) (stay-then-continue ALL p)])"><span class="u" id="1492610464.747918">2017:04:19 14:01:04           nathanmarz </span><span>e.g. </span><code>(recursive-path [] p [(walker vector?) (stay-then-continue ALL p)])</code></div><div data-t="albaker but that&apos;ll walk vectors or also maps/vectors of maps, with vectors of maps, etc"><span class="u" id="1492610502.764405">2017:04:19 14:01:42              albaker </span><span>but that&apos;ll walk vectors or also maps/vectors of maps, with vectors of maps, etc</span></div><div data-t="nathanmarz that will walk all clojure data structures until it reaches a vector, then it will do the transformation and continue walking"><span class="u" id="1492610526.774943">2017:04:19 14:02:06           nathanmarz </span><span>that will walk all clojure data structures until it reaches a vector, then it will do the transformation and continue walking</span></div><div data-t="nathanmarz if you want different behavior then you can encode that into your recursive path definition"><span class="u" id="1492610541.781317">2017:04:19 14:02:21           nathanmarz </span><span>if you want different behavior then you can encode that into your recursive path definition</span></div><div data-t="albaker so walker wants a predicate function that returns truthy for something you want to process"><span class="u" id="1492610588.800027">2017:04:19 14:03:08              albaker </span><span>so walker wants a predicate function that returns truthy for something you want to process</span></div><div data-t="nathanmarz yea"><span class="u" id="1492610594.802587">2017:04:19 14:03:14           nathanmarz </span><span>yea</span></div><div data-t="albaker ok cool, I&apos;ll give that a whirl"><span class="u" id="1492610600.805506">2017:04:19 14:03:20              albaker </span><span>ok cool, I&apos;ll give that a whirl</span></div><div data-t="mbjarland @nathanmarz if I am on a node which is a map and want to do a calculation on the values for two keys on that map, i.e.
 (view #(- (read-string (:to %)) (read-string (:from %))))
 
it seems that  %  does not evaluate to the current node in the above expression?"><span class="u" id="1492611189.048848">2017:04:19 14:13:09            mbjarland </span><span>@nathanmarz if I am on a node which is a map and want to do a calculation on the values for two keys on that map, i.e.
</span><pre>(view #(- (read-string (:to %)) (read-string (:from %))))
</pre><span>
it seems that </span><code>%</code><span> does not evaluate to the current node in the above expression?</span></div><div data-t="mbjarland take that back, figured it out, my bad"><span class="u" id="1492612826.747588">2017:04:19 14:40:26            mbjarland </span><span>take that back, figured it out, my bad</span></div><div data-t="albaker @nathanmarz so that works so well, I&apos;m stack overflowing as the descent into the tree (or madness?) goes..  in this case, making a graph query to find more children until no more children can be had.  Are there any gotchas (other then don&apos;t do that) to avoid in the transform?"><span class="u" id="1492615790.053275">2017:04:19 15:29:50              albaker </span><span>@nathanmarz so that works so well, I&apos;m stack overflowing as the descent into the tree (or madness?) goes..  in this case, making a graph query to find more children until no more children can be had.  Are there any gotchas (other then don&apos;t do that) to avoid in the transform?</span></div><div data-t="albaker I guess I could move the query into a core.async channel, so transform is just pulling from channels"><span class="u" id="1492615862.085911">2017:04:19 15:31:02              albaker </span><span>I guess I could move the query into a core.async channel, so transform is just pulling from channels</span></div><div data-t="nathanmarz @albaker specter doesn&apos;t use any more stack than you would expect"><span class="u" id="1492616089.187228">2017:04:19 15:34:49           nathanmarz </span><span>@albaker specter doesn&apos;t use any more stack than you would expect</span></div><div data-t="nathanmarz each level in data structure you go down during the transform will be another stack frame"><span class="u" id="1492616110.195915">2017:04:19 15:35:10           nathanmarz </span><span>each level in data structure you go down during the transform will be another stack frame</span></div><div data-t="albaker yeah I suspect it&apos;s in the db client somewhere"><span class="u" id="1492616136.207648">2017:04:19 15:35:36              albaker </span><span>yeah I suspect it&apos;s in the db client somewhere</span></div><div data-t="nathanmarz don&apos;t know enough about your use case to give any guidance beyond that"><span class="u" id="1492616162.218969">2017:04:19 15:36:02           nathanmarz </span><span>don&apos;t know enough about your use case to give any guidance beyond that</span></div><div data-t="albaker I&apos;ll move the db client behind a core.async queue and leaves the transforming function only doing a quick put a thing on, get a thing back transaction and lets the db query run separately"><span class="u" id="1492616285.271078">2017:04:19 15:38:05              albaker </span><span>I&apos;ll move the db client behind a core.async queue and leaves the transforming function only doing a quick put a thing on, get a thing back transaction and lets the db query run separately</span></div><div data-t="albaker don&apos;t feel like playing the &quot;why I hate Apache HTTP commons today&quot; game on why it&apos;s stack overflowing  😄"><span class="u" id="1492616315.283546">2017:04:19 15:38:35              albaker </span><span>don&apos;t feel like playing the &quot;why I hate Apache HTTP commons today&quot; game on why it&apos;s stack overflowing </span><b>😄</b></div><div data-t="lvh Does anyone have any suggestions for a faster clojure.data/diff? I don’t know if anyone’s e.g. tried specter for this (or if it’d even help). I imagine zippers might, at least. I currently have two mostly-similar nested trees (flattened about 2E5 entries) and clojure.data/diff just takes a very long time"><span class="u" id="1492639684.778183">2017:04:19 22:08:04                  lvh </span><span>Does anyone have any suggestions for a faster clojure.data/diff? I don’t know if anyone’s e.g. tried specter for this (or if it’d even help). I imagine zippers might, at least. I currently have two mostly-similar nested trees (flattened about 2E5 entries) and clojure.data/diff just takes a very long time</span></div><div data-t="lvh I dunno if it matters, but the two data structures are very similar, deeply nested, and form a deep (as opposed to broad) tree"><span class="u" id="1492639726.787825">2017:04:19 22:08:46                  lvh </span><span>I dunno if it matters, but the two data structures are very similar, deeply nested, and form a deep (as opposed to broad) tree</span></div><div data-t="nathanmarz @lvh I don&apos;t think specter will be very useful for that"><span class="u" id="1492647657.250528">2017:04:20 00:20:57           nathanmarz </span><span>@lvh I don&apos;t think specter will be very useful for that</span></div><div data-t="albaker @nathanmarz is there a recursive-path that will not recurse into the transformed value?   i.e.  (recursive-path [] p [(walker vector?) (stay-then-continue ALL p)])  will go for a while, but I&apos;m still finding something will stackoverflow... core.async, futures, apache client. I&apos;m thinking I need to just run transforms again and again, until it no longer transforms rather than in one big recursive blitz"><span class="u" id="1492711140.358053">2017:04:20 17:59:00              albaker </span><span>@nathanmarz is there a recursive-path that will not recurse into the transformed value?   i.e. </span><code>(recursive-path [] p [(walker vector?) (stay-then-continue ALL p)])</code><span> will go for a while, but I&apos;m still finding something will stackoverflow... core.async, futures, apache client. I&apos;m thinking I need to just run transforms again and again, until it no longer transforms rather than in one big recursive blitz</span></div><div data-t="albaker in the stack overflow error, there&apos;s lots of repeating versions of this:"><span class="u" id="1492711276.413393">2017:04:20 18:01:16              albaker </span><span>in the stack overflow error, there&apos;s lots of repeating versions of this:</span></div><div data-t="nathanmarz @albaker that path is defined so it will continue recursing"><span class="u" id="1492711378.453984">2017:04:20 18:02:58           nathanmarz </span><span>@albaker that path is defined so it will continue recursing</span></div><div data-t="nathanmarz recursive-path  itself doesn&apos;t do anything besides provide you the programmer the ability to have the path refer to itself"><span class="u" id="1492711399.462355">2017:04:20 18:03:19           nathanmarz </span><code>recursive-path</code><span> itself doesn&apos;t do anything besides provide you the programmer the ability to have the path refer to itself</span></div><div data-t="nathanmarz if it&apos;s stack overflowing, then you&apos;re doing something wrong in your program"><span class="u" id="1492711416.469506">2017:04:20 18:03:36           nathanmarz </span><span>if it&apos;s stack overflowing, then you&apos;re doing something wrong in your program</span></div><div data-t="albaker I&apos;m okay recursing, just not into the results, so I recurse down to the last known genration, apply and end"><span class="u" id="1492711427.473736">2017:04:20 18:03:47              albaker </span><span>I&apos;m okay recursing, just not into the results, so I recurse down to the last known genration, apply and end</span></div><div data-t="nathanmarz I don&apos;t know what that means"><span class="u" id="1492711443.480099">2017:04:20 18:04:03           nathanmarz </span><span>I don&apos;t know what that means</span></div><div data-t="nathanmarz whatever logic you want will need to be encoded in the path"><span class="u" id="1492711461.487056">2017:04:20 18:04:21           nathanmarz </span><span>whatever logic you want will need to be encoded in the path</span></div><div data-t="nathanmarz you can use value collection to keep track of how many levels you&apos;ve recursed"><span class="u" id="1492711484.496220">2017:04:20 18:04:44           nathanmarz </span><span>you can use value collection to keep track of how many levels you&apos;ve recursed</span></div><div data-t="nathanmarz and then check that using  collected?  to have the path decide whether or not to recurse"><span class="u" id="1492711515.507978">2017:04:20 18:05:15           nathanmarz </span><span>and then check that using </span><code>collected?</code><span> to have the path decide whether or not to recurse</span></div><div data-t="nathanmarz or you can encode in your data itself information to allow the path to decide whether to recurse"><span class="u" id="1492711541.518355">2017:04:20 18:05:41           nathanmarz </span><span>or you can encode in your data itself information to allow the path to decide whether to recurse</span></div><div data-t="nathanmarz e.g. using metadata"><span class="u" id="1492711543.519437">2017:04:20 18:05:43           nathanmarz </span><span>e.g. using metadata</span></div><div data-t="albaker yeah, something like that - right now I&apos;m keeping a counter ref going"><span class="u" id="1492711560.525733">2017:04:20 18:06:00              albaker </span><span>yeah, something like that - right now I&apos;m keeping a counter ref going</span></div><div data-t="nathanmarz yea, that would work too"><span class="u" id="1492711620.549579">2017:04:20 18:07:00           nathanmarz </span><span>yea, that would work too</span></div><div data-t="nathanmarz lots of options available to control termination"><span class="u" id="1492711641.557895">2017:04:20 18:07:21           nathanmarz </span><span>lots of options available to control termination</span></div><div data-t="albaker there is a potential for a loop, and I thought I had caught it - but perhaps not"><span class="u" id="1492711673.569842">2017:04:20 18:07:53              albaker </span><span>there is a potential for a loop, and I thought I had caught it - but perhaps not</span></div><div data-t="albaker there a way to force the transform with recursive path to bail out?"><span class="u" id="1492711687.575155">2017:04:20 18:08:07              albaker </span><span>there a way to force the transform with recursive path to bail out?</span></div><div data-t="nathanmarz you mean with an exception or something?"><span class="u" id="1492711709.583537">2017:04:20 18:08:29           nathanmarz </span><span>you mean with an exception or something?</span></div><div data-t="albaker yeah, I guess just a regular exception and wrap the transform in a try/catch"><span class="u" id="1492711786.613601">2017:04:20 18:09:46              albaker </span><span>yeah, I guess just a regular exception and wrap the transform in a try/catch</span></div><div data-t="nathanmarz I guess you could make a navigator which does that"><span class="u" id="1492711815.624612">2017:04:20 18:10:15           nathanmarz </span><span>I guess you could make a navigator which does that</span></div><div data-t="nathanmarz try catch over invoking next-fn, and when your special exception is thrown it returns the structure unchanged"><span class="u" id="1492711833.631852">2017:04:20 18:10:33           nathanmarz </span><span>try catch over invoking next-fn, and when your special exception is thrown it returns the structure unchanged</span></div><div data-t="albaker ok, I&apos;ll take a look at that - thanks!"><span class="u" id="1492711867.645140">2017:04:20 18:11:07              albaker </span><span>ok, I&apos;ll take a look at that - thanks!</span></div><div data-t="nathanmarz imo that&apos;s a dirty way to solve this and you&apos;re better off more precisely specifying when you want recursion to stop"><span class="u" id="1492711909.661234">2017:04:20 18:11:49           nathanmarz </span><span>imo that&apos;s a dirty way to solve this and you&apos;re better off more precisely specifying when you want recursion to stop</span></div><div data-t="nathanmarz it&apos;s using exceptions for flow control"><span class="u" id="1492711920.665269">2017:04:20 18:12:00           nathanmarz </span><span>it&apos;s using exceptions for flow control</span></div><div data-t="albaker yeah"><span class="u" id="1492711942.673820">2017:04:20 18:12:22              albaker </span><span>yeah</span></div><div data-t="albaker ah sweet, found the bug, took the exception out, and now have a near general purpose specter+stardog graph walker for recursively expanding graph data"><span class="u" id="1492712236.786746">2017:04:20 18:17:16              albaker </span><span>ah sweet, found the bug, took the exception out, and now have a near general purpose specter+stardog graph walker for recursively expanding graph data</span></div><div data-t="albaker @nathanmarz thanks for all the help - this is really nice, with like 6 lines of specter, and a few lines of SPARQL, this thing walks and queries and walks again.  I&apos;ll give a shot out in the blog that&apos;ll fall out from this"><span class="u" id="1492712561.911666">2017:04:20 18:22:41              albaker </span><span>@nathanmarz thanks for all the help - this is really nice, with like 6 lines of specter, and a few lines of SPARQL, this thing walks and queries and walks again.  I&apos;ll give a shot out in the blog that&apos;ll fall out from this</span></div><div data-t="nathanmarz @albaker no problem, happy to help"><span class="u" id="1492712620.933934">2017:04:20 18:23:40           nathanmarz </span><span>@albaker no problem, happy to help</span></div><div data-t="jeremyraines I have a (maybe similar?) question.  Happy to post on StackOverflow if I can formulate it correctly.  I think the imaginary code I want may explain best:
 (def TreeValues
  (s/recursive-path [] p
    (s/if-path #(not (empty? (:children %)))
      (s/submap [:id :name {{ set :children to [:children s/ALL p] }}  ])
      (s/submap [:id :name :children]))))
"><span class="u" id="1492712818.011433">2017:04:20 18:26:58         jeremyraines </span><span>I have a (maybe similar?) question.  Happy to post on StackOverflow if I can formulate it correctly.  I think the imaginary code I want may explain best:
</span><pre>(def TreeValues
  (s/recursive-path [] p
    (s/if-path #(not (empty? (:children %)))
      (s/submap [:id :name {{ set :children to [:children s/ALL p] }}  ])
      (s/submap [:id :name :children]))))
</pre></div><div data-t="jeremyraines is this possible without an inner  transform ?  Maybe with some use of  collect  that I haven’t hit on yet?"><span class="u" id="1492712898.042226">2017:04:20 18:28:18         jeremyraines </span><span>is this possible without an inner </span><code>transform</code><span>?  Maybe with some use of </span><code>collect</code><span> that I haven’t hit on yet?</span></div><div data-t="jeremyraines essentially it’s operating on a vector of maps, where each map has a  :children  key with a vec of the same type of map"><span class="u" id="1492713006.086134">2017:04:20 18:30:06         jeremyraines </span><span>essentially it’s operating on a vector of maps, where each map has a </span><code>:children</code><span> key with a vec of the same type of map</span></div><div data-t="jeremyraines I’m just trying to prune each level to the keys I want"><span class="u" id="1492713015.089691">2017:04:20 18:30:15         jeremyraines </span><span>I’m just trying to prune each level to the keys I want</span></div><div data-t="nathanmarz submap isn&apos;t going to prune keys"><span class="u" id="1492713048.103032">2017:04:20 18:30:48           nathanmarz </span><span>submap isn&apos;t going to prune keys</span></div><div data-t="nathanmarz it lets you operate on a portion of the map with the result being merged back into the original map"><span class="u" id="1492713078.114827">2017:04:20 18:31:18           nathanmarz </span><span>it lets you operate on a portion of the map with the result being merged back into the original map</span></div><div data-t="nathanmarz I think you want to use  continue-then-stay"><span class="u" id="1492713122.132193">2017:04:20 18:32:02           nathanmarz </span><span>I think you want to use </span><code>continue-then-stay</code></div><div data-t="jeremyraines hmm, OK thanks.  I got the notion of pruning because this is the closet I got, but it only returns the leaves"><span class="u" id="1492713149.142879">2017:04:20 18:32:29         jeremyraines </span><span>hmm, OK thanks.  I got the notion of pruning because this is the closet I got, but it only returns the leaves</span></div><div data-t="nathanmarz (recursive-path [] p (continue-then-stay :children ALL p))"><span class="u" id="1492713155.145367">2017:04:20 18:32:35           nathanmarz </span><code>(recursive-path [] p (continue-then-stay :children ALL p))</code></div><div data-t="jeremyraines (def TreeValues
  (s/recursive-path [] p
    (s/if-path #(not (empty? (:children %)))
      [:children s/ALL p]
      (s/submap [:id :name :children]))))
"><span class="u" id="1492713182.155817">2017:04:20 18:33:02         jeremyraines </span><pre>(def TreeValues
  (s/recursive-path [] p
    (s/if-path #(not (empty? (:children %)))
      [:children s/ALL p]
      (s/submap [:id :name :children]))))
</pre></div><div data-t="nathanmarz then you could do:  (transform TreeNodes #(select-keys % [:id :name :children]) data)"><span class="u" id="1492713197.161830">2017:04:20 18:33:17           nathanmarz </span><span>then you could do: </span><code>(transform TreeNodes #(select-keys % [:id :name :children]) data)</code></div><div data-t="jeremyraines ok, thanks - reading up on  continue-then-stay  and trying it out"><span class="u" id="1492713222.171645">2017:04:20 18:33:42         jeremyraines </span><span>ok, thanks - reading up on </span><code>continue-then-stay</code><span> and trying it out</span></div><div data-t="jeremyraines that works, thanks!"><span class="u" id="1492714119.515691">2017:04:20 18:48:39         jeremyraines </span><span>that works, thanks!</span></div><div data-t="jeremyraines I’m lacking some intuition though . . . I don’t understand why this works:
 (transform [ALL TreeNodes] #(select-keys % [:id :name :children]) data) 
but not this:
 (transform [FIRST TreeNodes] #(select-keys % [:id :name :children]) data)"><span class="u" id="1492715023.863028">2017:04:20 19:03:43         jeremyraines </span><span>I’m lacking some intuition though . . . I don’t understand why this works:
</span><pre>(transform [ALL TreeNodes] #(select-keys % [:id :name :children]) data)</pre><span>
but not this:
</span><pre>(transform [FIRST TreeNodes] #(select-keys % [:id :name :children]) data)</pre></div><div data-t="nathanmarz what&apos;s not working?"><span class="u" id="1492715083.884421">2017:04:20 19:04:43           nathanmarz </span><span>what&apos;s not working?</span></div><div data-t="jeremyraines the latter does something, I’m not sure what, on the whole data vec.  I thought it would be equivalent to:"><span class="u" id="1492715163.913810">2017:04:20 19:06:03         jeremyraines </span><span>the latter does something, I’m not sure what, on the whole data vec.  I thought it would be equivalent to:</span></div><div data-t="jeremyraines (transform [ALL TreeNodes] #(select-keys % [:id :name :children]) (take 1 data))"><span class="u" id="1492715190.923775">2017:04:20 19:06:30         jeremyraines </span><code>(transform [ALL TreeNodes] #(select-keys % [:id :name :children]) (take 1 data))</code></div><div data-t="nathanmarz no, it will just do the transformation on the first element of the vector"><span class="u" id="1492715219.934313">2017:04:20 19:06:59           nathanmarz </span><span>no, it will just do the transformation on the first element of the vector</span></div><div data-t="nathanmarz you&apos;ll still get the whole vector back, but everything beyond the first element will be untouched"><span class="u" id="1492715231.938269">2017:04:20 19:07:11           nathanmarz </span><span>you&apos;ll still get the whole vector back, but everything beyond the first element will be untouched</span></div><div data-t="jeremyraines oh, got it"><span class="u" id="1492715242.942362">2017:04:20 19:07:22         jeremyraines </span><span>oh, got it</span></div><div data-t="nathanmarz transform always operates on a select portion of the data structure, with the path specifying how to navigate to what needs to be operated on"><span class="u" id="1492715286.957585">2017:04:20 19:08:06           nathanmarz </span><span>transform always operates on a select portion of the data structure, with the path specifying how to navigate to what needs to be operated on</span></div><div data-t="jeremyraines makes sense, I think I understood that but just dropped the context of the basics when struggling with this problem.  Thanks"><span class="u" id="1492715407.000498">2017:04:20 19:10:07         jeremyraines </span><span>makes sense, I think I understood that but just dropped the context of the basics when struggling with this problem.  Thanks</span></div><div data-t="jeremyraines anyone have a way to get the ancestors of a node in a tree, with or without specter.zipper?"><span class="u" id="1492896459.452066">2017:04:22 21:27:39         jeremyraines </span><span>anyone have a way to get the ancestors of a node in a tree, with or without specter.zipper?</span></div><div data-t="jeremyraines closest I can get is collecting the path with
 clojure
(def NodeAndParents
  (s/recursive-path [id] p
    (s/if-path #(= (:id %) id)
      s/STAY
      (s/if-path #(empty? (:children %))
        [s/DISPENSE s/STOP]
        [(s/collect-one :id) :children s/ALL p]))))
 
then using the collected ids to go through the tree again, selecting the nodes whose id is in that set"><span class="u" id="1492896642.462358">2017:04:22 21:30:42         jeremyraines </span><span>closest I can get is collecting the path with
</span><pre>clojure
(def NodeAndParents
  (s/recursive-path [id] p
    (s/if-path #(= (:id %) id)
      s/STAY
      (s/if-path #(empty? (:children %))
        [s/DISPENSE s/STOP]
        [(s/collect-one :id) :children s/ALL p]))))
</pre><span>
then using the collected ids to go through the tree again, selecting the nodes whose id is in that set</span></div><div data-t="nathanmarz @jeremyraines yea that&apos;s pretty much how you do it with specter"><span class="u" id="1492896704.465847">2017:04:22 21:31:44           nathanmarz </span><span>@jeremyraines yea that&apos;s pretty much how you do it with specter</span></div><div data-t="jeremyraines ah ok, cool, thanks"><span class="u" id="1492896729.467146">2017:04:22 21:32:09         jeremyraines </span><span>ah ok, cool, thanks</span></div><div data-t="nathanmarz you can change the last part to  (if-path [:children ALL] [(collect-one :id) :children ALL p])"><span class="u" id="1492896762.469147">2017:04:22 21:32:42           nathanmarz </span><span>you can change the last part to </span><code>(if-path [:children ALL] [(collect-one :id) :children ALL p])</code></div><div data-t="jeremyraines nice"><span class="u" id="1492896776.469902">2017:04:22 21:32:56         jeremyraines </span><span>nice</span></div><div data-t="nathanmarz calling  DISPENSE  before  STOP  doesn&apos;t do anything"><span class="u" id="1492896777.469916">2017:04:22 21:32:57           nathanmarz </span><span>calling </span><code>DISPENSE</code><span> before </span><code>STOP</code><span> doesn&apos;t do anything</span></div><div data-t="nathanmarz and  if-path  has default &quot;else&quot; branch of  STOP"><span class="u" id="1492896812.471803">2017:04:22 21:33:32           nathanmarz </span><span>and </span><code>if-path</code><span> has default &quot;else&quot; branch of </span><code>STOP</code></div><div data-t="sophiago @nathanmarz after seeing your excellent presentation this past week at the NYC Clojure meetup, I think specter could likely greatly help me in working with the output of a library I have that produces deeply nested maps of vectors. Mainly my issue is that built-in functions don&apos;t seem to go deep-enough into the nesting and rolling my own with walking has proven two difficult with all the filtering necessary. I&apos;m using integer keys, which means I should probably switch to the int-map library for efficiency, but that doesn&apos;t seem like it would solve any of my major problems."><span class="u" id="1492932623.926661">2017:04:23 07:30:23             sophiago </span><span>@nathanmarz after seeing your excellent presentation this past week at the NYC Clojure meetup, I think specter could likely greatly help me in working with the output of a library I have that produces deeply nested maps of vectors. Mainly my issue is that built-in functions don&apos;t seem to go deep-enough into the nesting and rolling my own with walking has proven two difficult with all the filtering necessary. I&apos;m using integer keys, which means I should probably switch to the int-map library for efficiency, but that doesn&apos;t seem like it would solve any of my major problems.</span></div><div data-t="sophiago I&apos;m currently mainly concerned with the following: 1. I&apos;d like to stick with generating the data into an unsorted map for speed, but when I use  (into (sorted-map) ...)  after the fact it oddly doesn&apos;t sort the deepest level of nesting. 2. Searching for values within the maps using  some  similarly always returns nil as it doesn&apos;t seem to be searching deep enough. 3. Same when it comes to using  filter  to eliminate empty vectors. 4. Same when trying to use  vals  to eliminate keys entirely."><span class="u" id="1492932657.927912">2017:04:23 07:30:57             sophiago </span><span>I&apos;m currently mainly concerned with the following: 1. I&apos;d like to stick with generating the data into an unsorted map for speed, but when I use </span><code>(into (sorted-map) ...)</code><span> after the fact it oddly doesn&apos;t sort the deepest level of nesting. 2. Searching for values within the maps using </span><code>some</code><span> similarly always returns nil as it doesn&apos;t seem to be searching deep enough. 3. Same when it comes to using </span><code>filter</code><span> to eliminate empty vectors. 4. Same when trying to use </span><code>vals</code><span> to eliminate keys entirely.</span></div><div data-t="sophiago Although I can see how navigators like  MAP-VALS  and  NIL-&gt;VECTOR  would help with this, I&apos;m having trouble figuring out from the API docs how to compose them to achieve these results. I know this is quite a bit, but any pointers on which functions/macros to look at would be greatly appreciated. Thanks!"><span class="u" id="1492932729.930513">2017:04:23 07:32:09             sophiago </span><span>Although I can see how navigators like </span><code>MAP-VALS</code><span> and </span><code>NIL-&gt;VECTOR</code><span> would help with this, I&apos;m having trouble figuring out from the API docs how to compose them to achieve these results. I know this is quite a bit, but any pointers on which functions/macros to look at would be greatly appreciated. Thanks!</span></div><div data-t="nathanmarz @sophiago going to be easiest to help you by working through some specific examples"><span class="u" id="1492950681.670186">2017:04:23 12:31:21           nathanmarz </span><span>@sophiago going to be easiest to help you by working through some specific examples</span></div><div data-t="nathanmarz which navigators you need to compose for a use case depends entirely on the use case, a huge portion of specter&apos;s core navigators could be relevant for what you&apos;ve described so far"><span class="u" id="1492950791.675355">2017:04:23 12:33:11           nathanmarz </span><span>which navigators you need to compose for a use case depends entirely on the use case, a huge portion of specter&apos;s core navigators could be relevant for what you&apos;ve described so far</span></div><div data-t="sophiago @nathanmarz thanks for getting back to me so fast! This is the library I&apos;m working with:  https://github.com/Sophia-Gold/Madhava-v2 . It&apos;s still pretty rough in terms of functionality I need to build out, but the core of it is computing a large number of partial derivatives all at once and storing them in an atomic hash-map. Since the number of partials grows exponentially by order and are stored with keys that match them to the corresponding variables at each order this means the maps end up heavily nested. The Github README describes how to use it, but I&apos;ll paste a snippet of the function that creates the map (which is quite small) below and describe some operations on it I&apos;m having trouble getting done with core functions."><span class="u" id="1492993410.316344">2017:04:24 00:23:30             sophiago </span><span>@nathanmarz thanks for getting back to me so fast! This is the library I&apos;m working with: </span><a href="https://github.com/Sophia-Gold/Madhava-v2">https://github.com/Sophia-Gold/Madhava-v2</a><span>. It&apos;s still pretty rough in terms of functionality I need to build out, but the core of it is computing a large number of partial derivatives all at once and storing them in an atomic hash-map. Since the number of partials grows exponentially by order and are stored with keys that match them to the corresponding variables at each order this means the maps end up heavily nested. The Github README describes how to use it, but I&apos;ll paste a snippet of the function that creates the map (which is quite small) below and describe some operations on it I&apos;m having trouble getting done with core functions.</span></div><div data-t="sophiago I should also mention I did try using  data.int-map  last night and the increase in speed was barely noticeable, presumably because when generating the map I&apos;m only  assoc ing data into it and not calling  update . Let me know if you think  int-map  makes more sense with some of the operations on it I&apos;m thinking of."><span class="u" id="1492993595.329467">2017:04:24 00:26:35             sophiago </span><span>I should also mention I did try using </span><code>data.int-map</code><span> last night and the increase in speed was barely noticeable, presumably because when generating the map I&apos;m only </span><code>assoc</code><span>ing data into it and not calling </span><code>update</code><span>. Let me know if you think </span><code>int-map</code><span> makes more sense with some of the operations on it I&apos;m thinking of.</span></div><div data-t="sophiago So for starters, the reason why I thought of this project with regards to specter is because I initially tried to implement some functions that would combine two maps by applying a given binary operation to all the values with matching keys (meaning all their keys matching down to the deepest level of nesting) and then either throw out the disjoint key-value pairs or merge them as is. I tried implementing that with  postwalk , but found it too messy to match for just the values (all vectors) since it returns everything in the map."><span class="u" id="1492993934.354053">2017:04:24 00:32:14             sophiago </span><span>So for starters, the reason why I thought of this project with regards to specter is because I initially tried to implement some functions that would combine two maps by applying a given binary operation to all the values with matching keys (meaning all their keys matching down to the deepest level of nesting) and then either throw out the disjoint key-value pairs or merge them as is. I tried implementing that with </span><code>postwalk</code><span>, but found it too messy to match for just the values (all vectors) since it returns everything in the map.</span></div><div data-t="sophiago More realistically for calculating gradients I&apos;d need to use my  linear-transform  function in this library as the binary function yet instead of between two different maps, to values store in adjacent keys with some type of weighting scheme. I don&apos;t have that fully specified yet, so can set it aside, but I think specter could greatly help. I&apos;m thinking something like a zipper except instead of starting from the head, which would be ridiculously slow, I&apos;d want to go straight to the relevant key and then create the zipper right there."><span class="u" id="1492994142.369170">2017:04:24 00:35:42             sophiago </span><span>More realistically for calculating gradients I&apos;d need to use my </span><code>linear-transform</code><span> function in this library as the binary function yet instead of between two different maps, to values store in adjacent keys with some type of weighting scheme. I don&apos;t have that fully specified yet, so can set it aside, but I think specter could greatly help. I&apos;m thinking something like a zipper except instead of starting from the head, which would be ridiculously slow, I&apos;d want to go straight to the relevant key and then create the zipper right there.</span></div><div data-t="sophiago That&apos;s a bit abstract, but a simpler example are the operations I referred to last night. I was trying to see if I could use partial differentiation to encode laws for cellular automata so started playing around with extremely large maps (often verging on too large to print) generated from one very high-dimensional term and going up to many orders like so:  (diff [[0 0 0 1 0 0 1 1 0 1 1 1 1 1]] diff-map 7) . That&apos;s the map I was trying to search inside of using  some  (to see if the initial term was repeated) and realized it failed searching for any values due to the level of nesting. Similarly, when using  (into (sorted-map) ...)  how it would sort to everything but the final level of nesting,  filter  to eliminate &gt;50% of it that consisted of empty vectors, and  vals  to try and visualize the entire thing with the keys stripped out entirely."><span class="u" id="1492994447.390816">2017:04:24 00:40:47             sophiago </span><span>That&apos;s a bit abstract, but a simpler example are the operations I referred to last night. I was trying to see if I could use partial differentiation to encode laws for cellular automata so started playing around with extremely large maps (often verging on too large to print) generated from one very high-dimensional term and going up to many orders like so: </span><code>(diff [[0 0 0 1 0 0 1 1 0 1 1 1 1 1]] diff-map 7)</code><span>. That&apos;s the map I was trying to search inside of using </span><code>some</code><span> (to see if the initial term was repeated) and realized it failed searching for any values due to the level of nesting. Similarly, when using </span><code>(into (sorted-map) ...)</code><span> how it would sort to everything but the final level of nesting, </span><code>filter</code><span> to eliminate &gt;50% of it that consisted of empty vectors, and </span><code>vals</code><span> to try and visualize the entire thing with the keys stripped out entirely.</span></div><div data-t="sophiago So that gives me five operations on nested hash-maps I couldn&apos;t achieve with core. I&apos;m not sure how involved they&apos;d be to do with specter, but seems like they could be a very good place to start as far as learning the library."><span class="u" id="1492994526.396676">2017:04:24 00:42:06             sophiago </span><span>So that gives me five operations on nested hash-maps I couldn&apos;t achieve with core. I&apos;m not sure how involved they&apos;d be to do with specter, but seems like they could be a very good place to start as far as learning the library.</span></div><div data-t="nathanmarz @sophiago partial-diff can be written with specter like:
 (let [pidx (peek idx)]
  (select [ALL
           (selected? (keypath pidx) #(-&gt; % zero? not))
           (view
            (fn [expr]
              (-&gt; expr
                  (update 0 * (get expr pidx))
                  (update pidx dec))))]
    p
    ))
"><span class="u" id="1493007693.585077">2017:04:24 04:21:33           nathanmarz </span><span>@sophiago partial-diff can be written with specter like:
</span><pre>(let [pidx (peek idx)]
  (select [ALL
           (selected? (keypath pidx) #(-&gt; % zero? not))
           (view
            (fn [expr]
              (-&gt; expr
                  (update 0 * (get expr pidx))
                  (update pidx dec))))]
    p
    ))
</pre></div><div data-t="nathanmarz maybe a little bit of an improvement"><span class="u" id="1493007735.588266">2017:04:24 04:22:15           nathanmarz </span><span>maybe a little bit of an improvement</span></div><div data-t="nathanmarz this is a lot of code for me to parse, I can&apos;t really help with what are the optimal data structures / algorithms for this purpose"><span class="u" id="1493007797.593202">2017:04:24 04:23:17           nathanmarz </span><span>this is a lot of code for me to parse, I can&apos;t really help with what are the optimal data structures / algorithms for this purpose</span></div><div data-t="nathanmarz if you show me subproblems you&apos;re dealing with, with inputs you have and outputs you want, I can show you how to use specter for it"><span class="u" id="1493007835.596607">2017:04:24 04:23:55           nathanmarz </span><span>if you show me subproblems you&apos;re dealing with, with inputs you have and outputs you want, I can show you how to use specter for it</span></div><div data-t="sophiago Interesting. I&apos;m not sure how much of performance I can wring out of that tiny function, but it helps me to understand specter."><span class="u" id="1493007840.596960">2017:04:24 04:24:00             sophiago </span><span>Interesting. I&apos;m not sure how much of performance I can wring out of that tiny function, but it helps me to understand specter.</span></div><div data-t="nathanmarz specter&apos;s most useful when you want to change part of a data structure"><span class="u" id="1493007871.599648">2017:04:24 04:24:31           nathanmarz </span><span>specter&apos;s most useful when you want to change part of a data structure</span></div><div data-t="nathanmarz (and leave the rest unchanged)"><span class="u" id="1493007876.600079">2017:04:24 04:24:36           nathanmarz </span><span>(and leave the rest unchanged)</span></div><div data-t="nathanmarz when you want to combine everything into a new data structure, that&apos;s not what specter is for"><span class="u" id="1493007897.601614">2017:04:24 04:24:57           nathanmarz </span><span>when you want to combine everything into a new data structure, that&apos;s not what specter is for</span></div><div data-t="nathanmarz though it can be helpful for pieces of it"><span class="u" id="1493007909.602642">2017:04:24 04:25:09           nathanmarz </span><span>though it can be helpful for pieces of it</span></div><div data-t="nathanmarz (`traverse` is useful when you want to combine only parts of a data structure)"><span class="u" id="1493007928.604192">2017:04:24 04:25:28           nathanmarz </span><span>(`traverse` is useful when you want to combine only parts of a data structure)</span></div><div data-t="sophiago Well, I mentioned a few tasks so I&apos;m trying to think where&apos;s the best to start. I did have trouble figuring out how to combine two nested maps by applying a function to all values with the same key signature, but you&apos;re saying specter isn&apos;t ideal for something like that?"><span class="u" id="1493007980.608824">2017:04:24 04:26:20             sophiago </span><span>Well, I mentioned a few tasks so I&apos;m trying to think where&apos;s the best to start. I did have trouble figuring out how to combine two nested maps by applying a function to all values with the same key signature, but you&apos;re saying specter isn&apos;t ideal for something like that?</span></div><div data-t="nathanmarz it really depends on the problem"><span class="u" id="1493008011.611578">2017:04:24 04:26:51           nathanmarz </span><span>it really depends on the problem</span></div><div data-t="sophiago So far everything I&apos;ve mentioned is an operation on an entire map, either like above, or scrubbing the data in some way or other."><span class="u" id="1493008031.613271">2017:04:24 04:27:11             sophiago </span><span>So far everything I&apos;ve mentioned is an operation on an entire map, either like above, or scrubbing the data in some way or other.</span></div><div data-t="nathanmarz if you just had two random maps that you wanted to combine, probably not"><span class="u" id="1493008038.613886">2017:04:24 04:27:18           nathanmarz </span><span>if you just had two random maps that you wanted to combine, probably not</span></div><div data-t="nathanmarz but if you wanted to do something like merge a map in one location in a data structure with another map at some other location, specter will be useful"><span class="u" id="1493008058.615486">2017:04:24 04:27:38           nathanmarz </span><span>but if you wanted to do something like merge a map in one location in a data structure with another map at some other location, specter will be useful</span></div><div data-t="sophiago As mentioned, even just sorting and filtering deeply nested maps is not quite working out with core. How would you go about that?"><span class="u" id="1493008110.619501">2017:04:24 04:28:30             sophiago </span><span>As mentioned, even just sorting and filtering deeply nested maps is not quite working out with core. How would you go about that?</span></div><div data-t="nathanmarz well"><span class="u" id="1493008125.620621">2017:04:24 04:28:45           nathanmarz </span><span>well</span></div><div data-t="sophiago Or searching for a value inside one?"><span class="u" id="1493008126.620734">2017:04:24 04:28:46             sophiago </span><span>Or searching for a value inside one?</span></div><div data-t="nathanmarz what&apos;s a specific example of what you want to do?"><span class="u" id="1493008133.621192">2017:04:24 04:28:53           nathanmarz </span><span>what&apos;s a specific example of what you want to do?</span></div><div data-t="nathanmarz input and output"><span class="u" id="1493008135.621371">2017:04:24 04:28:55           nathanmarz </span><span>input and output</span></div><div data-t="sophiago one second"><span class="u" id="1493008168.624049">2017:04:24 04:29:28             sophiago </span><span>one second</span></div><div data-t="sophiago So, as one example,  (some #(= % [[120 3 3 0]]) @diff-map)  returns  nil  even though that value is in the map."><span class="u" id="1493008488.652750">2017:04:24 04:34:48             sophiago </span><span>So, as one example, </span><code>(some #(= % [[120 3 3 0]]) @diff-map)</code><span> returns </span><code>nil</code><span> even though that value is in the map.</span></div><div data-t="nathanmarz ah"><span class="u" id="1493008533.656603">2017:04:24 04:35:33           nathanmarz </span><span>ah</span></div><div data-t="nathanmarz ok, for this specter can be very helpful"><span class="u" id="1493008545.657669">2017:04:24 04:35:45           nathanmarz </span><span>ok, for this specter can be very helpful</span></div><div data-t="nathanmarz you can define a recursive navigator to the &quot;leaves&quot; of the structure (values which are vectors)"><span class="u" id="1493008575.660790">2017:04:24 04:36:15           nathanmarz </span><span>you can define a recursive navigator to the &quot;leaves&quot; of the structure (values which are vectors)</span></div><div data-t="nathanmarz one sec"><span class="u" id="1493008577.661032">2017:04:24 04:36:17           nathanmarz </span><span>one sec</span></div><div data-t="nathanmarz (def LEAVES
  (recursive-path [] p
    (if-path map?
      [MAP-VALS p]
      STAY
      )))
"><span class="u" id="1493008630.666214">2017:04:24 04:37:10           nathanmarz </span><pre>(def LEAVES
  (recursive-path [] p
    (if-path map?
      [MAP-VALS p]
      STAY
      )))
</pre></div><div data-t="nathanmarz then you can do  (select-first [LEAVES #(= % [[120 3 3 0]])] @diff-map)"><span class="u" id="1493008668.670378">2017:04:24 04:37:48           nathanmarz </span><span>then you can do </span><code>(select-first [LEAVES #(= % [[120 3 3 0]])] @diff-map)</code></div><div data-t="nathanmarz that will return either [[120 3 3 0]] or nil"><span class="u" id="1493008684.672139">2017:04:24 04:38:04           nathanmarz </span><span>that will return either [[120 3 3 0]] or nil</span></div><div data-t="sophiago Oh wow, great."><span class="u" id="1493008693.672986">2017:04:24 04:38:13             sophiago </span><span>Oh wow, great.</span></div><div data-t="nathanmarz if you do  select , then you&apos;ll get a sequence of every match"><span class="u" id="1493008698.673639">2017:04:24 04:38:18           nathanmarz </span><span>if you do </span><code>select</code><span>, then you&apos;ll get a sequence of every match</span></div><div data-t="nathanmarz that&apos;s very performant too"><span class="u" id="1493008717.675791">2017:04:24 04:38:37           nathanmarz </span><span>that&apos;s very performant too</span></div><div data-t="nathanmarz you can continue navigation at each leaf as well"><span class="u" id="1493008747.678950">2017:04:24 04:39:07           nathanmarz </span><span>you can continue navigation at each leaf as well</span></div><div data-t="nathanmarz (select [LEAVES ALL ALL odd?] @diff-map)  gets you call the odd numbers in those vectors"><span class="u" id="1493008767.681047">2017:04:24 04:39:27           nathanmarz </span><code>(select [LEAVES ALL ALL odd?] @diff-map)</code><span> gets you call the odd numbers in those vectors</span></div><div data-t="sophiago So I can also use  select  like how I want  vals  to work on a structure like this? To strip out keys?"><span class="u" id="1493008808.685622">2017:04:24 04:40:08             sophiago </span><span>So I can also use </span><code>select</code><span> like how I want </span><code>vals</code><span> to work on a structure like this? To strip out keys?</span></div><div data-t="nathanmarz don&apos;t think of it as &quot;stripping&quot;"><span class="u" id="1493008825.687174">2017:04:24 04:40:25           nathanmarz </span><span>don&apos;t think of it as &quot;stripping&quot;</span></div><div data-t="sophiago (select [LEAVES ALL] @diff-map) ?"><span class="u" id="1493008834.688334">2017:04:24 04:40:34             sophiago </span><code>(select [LEAVES ALL] @diff-map)</code><span>?</span></div><div data-t="nathanmarz it&apos;s just querying the data structure for a sequence of matches"><span class="u" id="1493008835.688416">2017:04:24 04:40:35           nathanmarz </span><span>it&apos;s just querying the data structure for a sequence of matches</span></div><div data-t="nathanmarz but yea, that will get you all the vectors of numbers as a single sequence"><span class="u" id="1493008863.691266">2017:04:24 04:41:03           nathanmarz </span><span>but yea, that will get you all the vectors of numbers as a single sequence</span></div><div data-t="sophiago Oh, as a sequence? I thought a big feature was returning the same kind of data structure. What if I want to perform operations on all the values and return a map with the same nesting? For example filtering?"><span class="u" id="1493008911.696199">2017:04:24 04:41:51             sophiago </span><span>Oh, as a sequence? I thought a big feature was returning the same kind of data structure. What if I want to perform operations on all the values and return a map with the same nesting? For example filtering?</span></div><div data-t="nathanmarz use  transform  for that"><span class="u" id="1493008923.697236">2017:04:24 04:42:03           nathanmarz </span><span>use </span><code>transform</code><span> for that</span></div><div data-t="nathanmarz (transform [LEAVES ALL ALL even?] inc @diff-map)"><span class="u" id="1493008955.700181">2017:04:24 04:42:35           nathanmarz </span><code>(transform [LEAVES ALL ALL even?] inc @diff-map)</code></div><div data-t="nathanmarz that gives you a new map with all the even numbers incremented"><span class="u" id="1493008967.701054">2017:04:24 04:42:47           nathanmarz </span><span>that gives you a new map with all the even numbers incremented</span></div><div data-t="sophiago Ah, this is quite easy once you wrote that LEAVES navigator  🙂"><span class="u" id="1493008983.702378">2017:04:24 04:43:03             sophiago </span><span>Ah, this is quite easy once you wrote that LEAVES navigator </span><b>🙂</b></div><div data-t="nathanmarz (setval [LEAVES ALL AFTER-ELEM] 10)  appends the value 10 to each vector of numbers"><span class="u" id="1493008995.703280">2017:04:24 04:43:15           nathanmarz </span><code>(setval [LEAVES ALL AFTER-ELEM] 10)</code><span> appends the value 10 to each vector of numbers</span></div><div data-t="sophiago For just filtering would you recommend calling  transform  with  identity  as the function?"><span class="u" id="1493009113.713264">2017:04:24 04:45:13             sophiago </span><span>For just filtering would you recommend calling </span><code>transform</code><span> with </span><code>identity</code><span> as the function?</span></div><div data-t="nathanmarz what&apos;s an example of what you want to filter?"><span class="u" id="1493009133.715144">2017:04:24 04:45:33           nathanmarz </span><span>what&apos;s an example of what you want to filter?</span></div><div data-t="nathanmarz most likely it will be something along the lines of  (setval [...] NONE @diff-map)"><span class="u" id="1493009151.716723">2017:04:24 04:45:51           nathanmarz </span><span>most likely it will be something along the lines of </span><code>(setval [...] NONE @diff-map)</code></div><div data-t="nathanmarz (setval [LEAVES ALL (selected? ALL even?)] NONE @diff-map)  will remove any vector of nums that has an even number within"><span class="u" id="1493009183.719382">2017:04:24 04:46:23           nathanmarz </span><code>(setval [LEAVES ALL (selected? ALL even?)] NONE @diff-map)</code><span> will remove any vector of nums that has an even number within</span></div><div data-t="sophiago I was thinking something like  (transform [LEAVES ALL ALL #(not= [])] identity @diff-map)"><span class="u" id="1493009188.719788">2017:04:24 04:46:28             sophiago </span><span>I was thinking something like </span><code>(transform [LEAVES ALL ALL #(not= [])] identity @diff-map)</code></div><div data-t="sophiago err wait...one less ALL"><span class="u" id="1493009197.720578">2017:04:24 04:46:37             sophiago </span><span>err wait...one less ALL</span></div><div data-t="sophiago I think?"><span class="u" id="1493009200.720786">2017:04:24 04:46:40             sophiago </span><span>I think?</span></div><div data-t="nathanmarz what you wrote will be a no-op"><span class="u" id="1493009208.721556">2017:04:24 04:46:48           nathanmarz </span><span>what you wrote will be a no-op</span></div><div data-t="sophiago Ah ok"><span class="u" id="1493009212.721885">2017:04:24 04:46:52             sophiago </span><span>Ah ok</span></div><div data-t="nathanmarz you want to remove empty vectors?"><span class="u" id="1493009220.722519">2017:04:24 04:47:00           nathanmarz </span><span>you want to remove empty vectors?</span></div><div data-t="sophiago Yes. I&apos;m more interested in working with the vectors as a whole than values inside of them. So that&apos;s one example. I can see wanting to apply a function to a whole vector like you did about with  inc  as well, though."><span class="u" id="1493009285.727894">2017:04:24 04:48:05             sophiago </span><span>Yes. I&apos;m more interested in working with the vectors as a whole than values inside of them. So that&apos;s one example. I can see wanting to apply a function to a whole vector like you did about with </span><code>inc</code><span> as well, though.</span></div><div data-t="nathanmarz (setval [LEAVES ALL #(= [] %)] NONE @diff-map)  will remove empty vectors"><span class="u" id="1493009295.728751">2017:04:24 04:48:15           nathanmarz </span><code>(setval [LEAVES ALL #(= [] %)] NONE @diff-map)</code><span> will remove empty vectors</span></div><div data-t="nathanmarz (transform [LEAVES ALL] some-custom-fn @diff-map)  runs an arbitrary function on each vec of nums"><span class="u" id="1493009324.731469">2017:04:24 04:48:44           nathanmarz </span><code>(transform [LEAVES ALL] some-custom-fn @diff-map)</code><span> runs an arbitrary function on each vec of nums</span></div><div data-t="nathanmarz the path in transform says what you want to change in the data structure, meaning anything else will remain unchanged"><span class="u" id="1493009377.736041">2017:04:24 04:49:37           nathanmarz </span><span>the path in transform says what you want to change in the data structure, meaning anything else will remain unchanged</span></div><div data-t="nathanmarz so what you wrote says to transform each non empty vector with  identity"><span class="u" id="1493009395.737622">2017:04:24 04:49:55           nathanmarz </span><span>so what you wrote says to transform each non empty vector with </span><code>identity</code></div><div data-t="sophiago This is really great! I don&apos;t quite understand how you defined the LEAVES navigator to begin with, but from there everything is incredibly simple."><span class="u" id="1493009399.737961">2017:04:24 04:49:59             sophiago </span><span>This is really great! I don&apos;t quite understand how you defined the LEAVES navigator to begin with, but from there everything is incredibly simple.</span></div><div data-t="nathanmarz it&apos;s pretty simple"><span class="u" id="1493009413.739168">2017:04:24 04:50:13           nathanmarz </span><span>it&apos;s pretty simple</span></div><div data-t="nathanmarz it&apos;s just saying how to get to the vec of vecs"><span class="u" id="1493009426.740449">2017:04:24 04:50:26           nathanmarz </span><span>it&apos;s just saying how to get to the vec of vecs</span></div><div data-t="nathanmarz recursive-path  lets you have the path refer to itself (using  p  in this case)"><span class="u" id="1493009451.742824">2017:04:24 04:50:51           nathanmarz </span><code>recursive-path</code><span> lets you have the path refer to itself (using </span><code>p</code><span> in this case)</span></div><div data-t="nathanmarz it&apos;s saying &quot;if currently at a map, recurse at all the map vals, otherwise already at the target so stay navigated&quot;"><span class="u" id="1493009492.746382">2017:04:24 04:51:32           nathanmarz </span><span>it&apos;s saying &quot;if currently at a map, recurse at all the map vals, otherwise already at the target so stay navigated&quot;</span></div><div data-t="sophiago Right. I get it now."><span class="u" id="1493009508.747729">2017:04:24 04:51:48             sophiago </span><span>Right. I get it now.</span></div><div data-t="sophiago What about merging two maps with a transformation function?"><span class="u" id="1493009542.750587">2017:04:24 04:52:22             sophiago </span><span>What about merging two maps with a transformation function?</span></div><div data-t="nathanmarz example?"><span class="u" id="1493009566.752614">2017:04:24 04:52:46           nathanmarz </span><span>example?</span></div><div data-t="sophiago Let&apos;s say I have two of that map above, so the keys are equal, and I want a new map with the same structure and the values the result of a binary function applied to the old one?"><span class="u" id="1493009666.761407">2017:04:24 04:54:26             sophiago </span><span>Let&apos;s say I have two of that map above, so the keys are equal, and I want a new map with the same structure and the values the result of a binary function applied to the old one?</span></div><div data-t="sophiago I don&apos;t want to make it more complicated by adding a long function to multiply or divide two vectors, but you get the idea. I would also ideally like to be able to choose what to do with key signatures that don&apos;t match, but that seems more complicated."><span class="u" id="1493009755.769385">2017:04:24 04:55:55             sophiago </span><span>I don&apos;t want to make it more complicated by adding a long function to multiply or divide two vectors, but you get the idea. I would also ideally like to be able to choose what to do with key signatures that don&apos;t match, but that seems more complicated.</span></div><div data-t="nathanmarz ah, yea specter won&apos;t help with that"><span class="u" id="1493009768.770538">2017:04:24 04:56:08           nathanmarz </span><span>ah, yea specter won&apos;t help with that</span></div><div data-t="nathanmarz that sounds like a somewhat complicated  merge-with"><span class="u" id="1493009778.771378">2017:04:24 04:56:18           nathanmarz </span><span>that sounds like a somewhat complicated </span><code>merge-with</code></div><div data-t="sophiago I can&apos;t quite remember, but that must have been the first thing I tried for that before  postwalk . It works with nesting?"><span class="u" id="1493009812.774377">2017:04:24 04:56:52             sophiago </span><span>I can&apos;t quite remember, but that must have been the first thing I tried for that before </span><code>postwalk</code><span>. It works with nesting?</span></div><div data-t="nathanmarz well"><span class="u" id="1493009823.775253">2017:04:24 04:57:03           nathanmarz </span><span>well</span></div><div data-t="nathanmarz your call to  merge-with  will have to be recursive"><span class="u" id="1493009843.777025">2017:04:24 04:57:23           nathanmarz </span><span>your call to </span><code>merge-with</code><span> will have to be recursive</span></div><div data-t="sophiago Right. I think what happened was I gave up on writing a recursive  merge-with   😛"><span class="u" id="1493009868.779220">2017:04:24 04:57:48             sophiago </span><span>Right. I think what happened was I gave up on writing a recursive </span><code>merge-with</code><span> </span><b>😛</b></div><div data-t="nathanmarz i&apos;ve thought a bit about extending specter to walk multiple structures at once, but I haven&apos;t personally had many use cases for it"><span class="u" id="1493009931.784660">2017:04:24 04:58:51           nathanmarz </span><span>i&apos;ve thought a bit about extending specter to walk multiple structures at once, but I haven&apos;t personally had many use cases for it</span></div><div data-t="nathanmarz it would likely be a massive change to how specter works and I&apos;m not sure it can be done while maintaining near-optimal efficiency"><span class="u" id="1493009965.787872">2017:04:24 04:59:25           nathanmarz </span><span>it would likely be a massive change to how specter works and I&apos;m not sure it can be done while maintaining near-optimal efficiency</span></div><div data-t="sophiago It seems like it would help with that as is... I&apos;d have to think about it a bit."><span class="u" id="1493009966.787928">2017:04:24 04:59:26             sophiago </span><span>It seems like it would help with that as is... I&apos;d have to think about it a bit.</span></div><div data-t="sophiago Yeah, I&apos;m not taking into account efficiency of using specter for something like that."><span class="u" id="1493009987.789716">2017:04:24 04:59:47             sophiago </span><span>Yeah, I&apos;m not taking into account efficiency of using specter for something like that.</span></div><div data-t="nathanmarz those transformations I was showing before will be near-optimal efficiency"><span class="u" id="1493010012.792543">2017:04:24 05:00:12           nathanmarz </span><span>those transformations I was showing before will be near-optimal efficiency</span></div><div data-t="sophiago I do think being able to precisely define a path and apply  transform  to that will really help me with this library."><span class="u" id="1493010022.793603">2017:04:24 05:00:22             sophiago </span><span>I do think being able to precisely define a path and apply </span><code>transform</code><span> to that will really help me with this library.</span></div><div data-t="nathanmarz will blow away the performance of postwalk"><span class="u" id="1493010034.794882">2017:04:24 05:00:34           nathanmarz </span><span>will blow away the performance of postwalk</span></div><div data-t="nathanmarz yea, I think this should be a good start for you"><span class="u" id="1493010043.795746">2017:04:24 05:00:43           nathanmarz </span><span>yea, I think this should be a good start for you</span></div><div data-t="sophiago postwalk  just is really difficult to work with due to everything it returns"><span class="u" id="1493010064.797755">2017:04:24 05:01:04             sophiago </span><code>postwalk</code><span> just is really difficult to work with due to everything it returns</span></div><div data-t="sophiago I guess the only other thing I was going to ask about was sorting and why  (into (sorted-map) @diff-map)  wasn&apos;t changing anything. This one came out perfectly sorted, but when they get really gigantic and hairy, they&apos;re not on the deepest level. I designed it that way in case I wanted to use something similar to  pmap ."><span class="u" id="1493010159.807197">2017:04:24 05:02:39             sophiago </span><span>I guess the only other thing I was going to ask about was sorting and why </span><code>(into (sorted-map) @diff-map)</code><span> wasn&apos;t changing anything. This one came out perfectly sorted, but when they get really gigantic and hairy, they&apos;re not on the deepest level. I designed it that way in case I wanted to use something similar to </span><code>pmap</code><span>.</span></div><div data-t="nathanmarz that will only sort the first level"><span class="u" id="1493010204.811278">2017:04:24 05:03:24           nathanmarz </span><span>that will only sort the first level</span></div><div data-t="sophiago Ah ok. Then that&apos;s the expected behavior."><span class="u" id="1493010216.812439">2017:04:24 05:03:36             sophiago </span><span>Ah ok. Then that&apos;s the expected behavior.</span></div><div data-t="nathanmarz you can define a navigator to every map and then do  (transform MAP-NODES #(into (sorted-map) %) @diff-map)"><span class="u" id="1493010252.815755">2017:04:24 05:04:12           nathanmarz </span><span>you can define a navigator to every map and then do </span><code>(transform MAP-NODES #(into (sorted-map) %) @diff-map)</code></div><div data-t="nathanmarz (def MAP-NODES
  (recursive-path [] p
    (if-path map?
      (continue-then-stay MAP-VALS p))
    ))
"><span class="u" id="1493010289.819056">2017:04:24 05:04:49           nathanmarz </span><pre>(def MAP-NODES
  (recursive-path [] p
    (if-path map?
      (continue-then-stay MAP-VALS p))
    ))
</pre></div><div data-t="sophiago Yes, I was just going to say. It helps to see the navigator for that as well."><span class="u" id="1493010311.821173">2017:04:24 05:05:11             sophiago </span><span>Yes, I was just going to say. It helps to see the navigator for that as well.</span></div><div data-t="nathanmarz anyway, it&apos;s bedtime for me, I&apos;ll be back online tomorrow if you have more questions"><span class="u" id="1493010371.827035">2017:04:24 05:06:11           nathanmarz </span><span>anyway, it&apos;s bedtime for me, I&apos;ll be back online tomorrow if you have more questions</span></div><div data-t="sophiago Thanks so much! This will definitely get me started. I was also just going to ask whether you find much of a speed increase using  int-map  with these kind of functions?"><span class="u" id="1493010418.831459">2017:04:24 05:06:58             sophiago </span><span>Thanks so much! This will definitely get me started. I was also just going to ask whether you find much of a speed increase using </span><code>int-map</code><span> with these kind of functions?</span></div><div data-t="nathanmarz I&apos;ve never used  int-map  so I&apos;m not familiar with which operations it achieves speedups"><span class="u" id="1493010488.837594">2017:04:24 05:08:08           nathanmarz </span><span>I&apos;ve never used </span><code>int-map</code><span> so I&apos;m not familiar with which operations it achieves speedups</span></div><div data-t="nathanmarz I&apos;m guessing it&apos;s faster for get and assoc, which these transformations we&apos;ve been doing aren&apos;t using"><span class="u" id="1493010525.840956">2017:04:24 05:08:45           nathanmarz </span><span>I&apos;m guessing it&apos;s faster for get and assoc, which these transformations we&apos;ve been doing aren&apos;t using</span></div><div data-t="sophiago I actually found very little increase for  assoc . I think the main benefit is when you&apos;re calling  update  frequently since it provides its own version of that."><span class="u" id="1493010595.847436">2017:04:24 05:09:55             sophiago </span><span>I actually found very little increase for </span><code>assoc</code><span>. I think the main benefit is when you&apos;re calling </span><code>update</code><span> frequently since it provides its own version of that.</span></div><div data-t="sophiago @nathanmarz thanks again for all the help again the other day! I just wanted to clarify one thing, this function you gave me for filtering out empty lists isn&apos;t working:  (setval [LEAVES ALL #(= [] %)] NONE *map*) . It seems like it should so I&apos;m a bit confused."><span class="u" id="1493213724.105238">2017:04:26 13:35:24             sophiago </span><span>@nathanmarz thanks again for all the help again the other day! I just wanted to clarify one thing, this function you gave me for filtering out empty lists isn&apos;t working: </span><code>(setval [LEAVES ALL #(= [] %)] NONE *map*)</code><span>. It seems like it should so I&apos;m a bit confused.</span></div><div data-t="nathanmarz seems to be working fine
 user=&gt; (def LEAVES
  #_=&gt;   (recursive-path [] p
  #_=&gt;     (if-path map?
  #_=&gt;       [MAP-VALS p]
  #_=&gt;       STAY
  #_=&gt;       )))
#&apos;user/LEAVES
user=&gt; (def m {0 {1 [[1 2 3] [] [4]]} 2 [[] [] [5 6]]}) 
#&apos;user/m
user=&gt; (setval [LEAVES ALL #(= [] %)] NONE m)
{0 {1 [[1 2 3] [4]]}, 2 [[5 6]]}
"><span class="u" id="1493213880.164392">2017:04:26 13:38:00           nathanmarz </span><span>seems to be working fine
</span><pre>user=&gt; (def LEAVES
  #_=&gt;   (recursive-path [] p
  #_=&gt;     (if-path map?
  #_=&gt;       [MAP-VALS p]
  #_=&gt;       STAY
  #_=&gt;       )))
#&apos;user/LEAVES
user=&gt; (def m {0 {1 [[1 2 3] [] [4]]} 2 [[] [] [5 6]]}) 
#&apos;user/m
user=&gt; (setval [LEAVES ALL #(= [] %)] NONE m)
{0 {1 [[1 2 3] [4]]}, 2 [[5 6]]}
</pre></div><div data-t="sophiago Oh wait. You&apos;re filtering empty vectors inside the values. I was thinking that would filter values that were empty vectors."><span class="u" id="1493214116.252213">2017:04:26 13:41:56             sophiago </span><span>Oh wait. You&apos;re filtering empty vectors inside the values. I was thinking that would filter values that were empty vectors.</span></div><div data-t="nathanmarz if you want to filter the direct values of the maps then just remove the  ALL"><span class="u" id="1493214190.280136">2017:04:26 13:43:10           nathanmarz </span><span>if you want to filter the direct values of the maps then just remove the </span><code>ALL</code></div><div data-t="nathanmarz you can also do   (setval [LEAVES (continue-then-stay ALL) #(= [] %)] NONE m)  to remove empty vectors from inside the map values and then remove key/value pairs where the value is  []"><span class="u" id="1493214228.295478">2017:04:26 13:43:48           nathanmarz </span><span>you can also do </span><code> (setval [LEAVES (continue-then-stay ALL) #(= [] %)] NONE m)</code><span> to remove empty vectors from inside the map values and then remove key/value pairs where the value is </span><code>[]</code></div><div data-t="sophiago Ah, I see. I just looked back at the docs. Since I&apos;m already selecting for leaves of the maps that means ALL would go inside any collections present in the values. I assumed it meant &quot;apply this to all leaves.&quot;"><span class="u" id="1493214344.339919">2017:04:26 13:45:44             sophiago </span><span>Ah, I see. I just looked back at the docs. Since I&apos;m already selecting for leaves of the maps that means ALL would go inside any collections present in the values. I assumed it meant &quot;apply this to all leaves.&quot;</span></div><div data-t="sophiago Yup, looks good now. Thanks!"><span class="u" id="1493214399.361272">2017:04:26 13:46:39             sophiago </span><span>Yup, looks good now. Thanks!</span></div><div data-t="nathanmarz no problem"><span class="u" id="1493214405.363737">2017:04:26 13:46:45           nathanmarz </span><span>no problem</span></div><div data-t="nathanmarz @teng  srange  navigates you to a sequence, so navigating to a keyword from there doesn&apos;t make sense"><span class="u" id="1493219398.519999">2017:04:26 15:09:58           nathanmarz </span><span>@teng </span><code>srange</code><span> navigates you to a sequence, so navigating to a keyword from there doesn&apos;t make sense</span></div><div data-t="nathanmarz I think you want:  (setval [:educations (nthpath 1) :major-name] &quot;C&quot; data)"><span class="u" id="1493219421.530173">2017:04:26 15:10:21           nathanmarz </span><span>I think you want: </span><code>(setval [:educations (nthpath 1) :major-name] &quot;C&quot; data)</code></div><div data-t="teng @nathanmarz That worked, thanks!  🙂"><span class="u" id="1493219505.566308">2017:04:26 15:11:45                 teng </span><span>@nathanmarz That worked, thanks! </span><b>🙂</b></div><div data-t="albaker @nathanmarz so in the crazy nested structure of  {:id &quot;blah :children [{:id &quot;blah2 :children [ .. ]]}  it looks like a  (select-first (recursive-path [] p [(walker (fn [x] ... match an id ...) STAY]) tree)  will grab any intermediate node in that structure (and halt with the STAY) is that right?"><span class="u" id="1493248080.848902">2017:04:26 23:08:00              albaker </span><span>@nathanmarz so in the crazy nested structure of </span><code>{:id &quot;blah :children [{:id &quot;blah2 :children [ .. ]]}</code><span> it looks like a </span><code>(select-first (recursive-path [] p [(walker (fn [x] ... match an id ...) STAY]) tree)</code><span> will grab any intermediate node in that structure (and halt with the STAY) is that right?</span></div><div data-t="nathanmarz @albaker it&apos;ll grab the first node it encounters"><span class="u" id="1493248980.011973">2017:04:26 23:23:00           nathanmarz </span><span>@albaker it&apos;ll grab the first node it encounters</span></div><div data-t="nathanmarz fyi that path isn&apos;t recursive so no reason to use  recursive-path"><span class="u" id="1493249009.017255">2017:04:26 23:23:29           nathanmarz </span><span>fyi that path isn&apos;t recursive so no reason to use </span><code>recursive-path</code></div><div data-t="nathanmarz and no reason to have the  STAY  after  walker"><span class="u" id="1493249023.019576">2017:04:26 23:23:43           nathanmarz </span><span>and no reason to have the </span><code>STAY</code><span> after </span><code>walker</code></div><div data-t="albaker ah, so the walker will depth first down through w/o a recursive path, and select-first makes STAY redundant?   I&apos;m still wrapping my head around paths"><span class="u" id="1493249286.065855">2017:04:26 23:28:06              albaker </span><span>ah, so the walker will depth first down through w/o a recursive path, and select-first makes STAY redundant?   I&apos;m still wrapping my head around paths</span></div><div data-t="nathanmarz @albaker  recursive-path  is only needed when your path definition needs to refer to itself"><span class="u" id="1493282718.142263">2017:04:27 08:45:18           nathanmarz </span><span>@albaker </span><code>recursive-path</code><span> is only needed when your path definition needs to refer to itself</span></div><div data-t="nathanmarz the  STAY  is redundant regardless of the operation"><span class="u" id="1493282745.149463">2017:04:27 08:45:45           nathanmarz </span><span>the </span><code>STAY</code><span> is redundant regardless of the operation</span></div><div data-t="nathanmarz walker  navigates you to all values matching that predicate"><span class="u" id="1493282769.155786">2017:04:27 08:46:09           nathanmarz </span><code>walker</code><span> navigates you to all values matching that predicate</span></div><div data-t="nathanmarz navigating from those values using  STAY  does nothing"><span class="u" id="1493282789.160893">2017:04:27 08:46:29           nathanmarz </span><span>navigating from those values using </span><code>STAY</code><span> does nothing</span></div><div data-t="albaker makes sense, thanks!"><span class="u" id="1493304541.340227">2017:04:27 14:49:01              albaker </span><span>makes sense, thanks!</span></div><div data-t="nijssels Why do the following statements work..."><span class="u" id="1493661808.117826">2017:05:01 18:03:28             nijssels </span><span>Why do the following statements work...</span></div><div data-t="nijssels But the combination doesnt..."><span class="u" id="1493661829.125720">2017:05:01 18:03:49             nijssels </span><span>But the combination doesnt...</span></div><div data-t="nijssels This works... It must be the workings of select-one..."><span class="u" id="1493662219.258116">2017:05:01 18:10:19             nijssels </span><span>This works... It must be the workings of select-one...</span></div><div data-t="levitanong @nathanmarz I can’t seem to find documentation on  traverse-all . Tried using it as if it were a transducer version of  traverse  but it doesn’t seem to work exactly like that."><span class="u" id="1493664453.019290">2017:05:01 18:47:33           levitanong </span><span>@nathanmarz I can’t seem to find documentation on </span><code>traverse-all</code><span>. Tried using it as if it were a transducer version of </span><code>traverse</code><span> but it doesn’t seem to work exactly like that.</span></div><div data-t="nathanmarz @nijssels  MAP-VALS  navigates you to each value individually, which means you&apos;re calling  FIRST  on a number"><span class="u" id="1493664487.031434">2017:05:01 18:48:07           nathanmarz </span><span>@nijssels </span><code>MAP-VALS</code><span> navigates you to each value individually, which means you&apos;re calling </span><code>FIRST</code><span> on a number</span></div><div data-t="nathanmarz you can do  (select-first MAP-VALS {:a 1 :b 2 :c 3})"><span class="u" id="1493664516.041063">2017:05:01 18:48:36           nathanmarz </span><span>you can do </span><code>(select-first MAP-VALS {:a 1 :b 2 :c 3})</code></div><div data-t="nathanmarz @levitanong examples of usage:  https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L1370"><span class="u" id="1493664548.052258">2017:05:01 18:49:08           nathanmarz </span><span>@levitanong examples of usage: </span><a href="https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L1370">https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L1370</a></div><div data-t="levitanong ok that makes sense. thanks!"><span class="u" id="1493664619.076864">2017:05:01 18:50:19           levitanong </span><span>ok that makes sense. thanks!</span></div><div data-t="nijssels Of course. Thanks @nathanmarz!"><span class="u" id="1493664631.080957">2017:05:01 18:50:31             nijssels </span><span>Of course. Thanks @nathanmarz!</span></div><div data-t="urbank I probably should have figured this out, but how do recursively navigate this kind of data-structure"><span class="u" id="1493673909.982765">2017:05:01 21:25:09               urbank </span><span>I probably should have figured this out, but how do recursively navigate this kind of data-structure</span></div><div data-t="urbank I want to get to all the maps that have a :children key"><span class="u" id="1493674095.033038">2017:05:01 21:28:15               urbank </span><span>I want to get to all the maps that have a :children key</span></div><div data-t="nathanmarz @urbank
 (def data
  {:data 10
   :children [{:data [1 2 3]
               :children []}
              {:data [4 5 6]
               :children []}]})


(def NODES
  (recursive-path [] p
    (continue-then-stay :children ALL p)
    ))

(select [NODES :data] data)
;; =&gt; [[1 2 3] [4 5 6] 10]
"><span class="u" id="1493676323.594463">2017:05:01 22:05:23           nathanmarz </span><span>@urbank
</span><pre>(def data
  {:data 10
   :children [{:data [1 2 3]
               :children []}
              {:data [4 5 6]
               :children []}]})


(def NODES
  (recursive-path [] p
    (continue-then-stay :children ALL p)
    ))

(select [NODES :data] data)
;; =&gt; [[1 2 3] [4 5 6] 10]
</pre></div><div data-t="urbank @nathanmarz Oh cool, thanks! For some reason I thought there needed to be a terminating clause in a recursive path, but I suppose it just stops when it runs out of results"><span class="u" id="1493677202.781596">2017:05:01 22:20:02               urbank </span><span>@nathanmarz Oh cool, thanks! For some reason I thought there needed to be a terminating clause in a recursive path, but I suppose it just stops when it runs out of results</span></div><div data-t="urbank Still don&apos;t quite understand what  Navigates to the provided path and then to the current element  means. Stay as opposed to what?"><span class="u" id="1493677363.814144">2017:05:01 22:22:43               urbank </span><span>Still don&apos;t quite understand what </span><code>Navigates to the provided path and then to the current element</code><span> means. Stay as opposed to what?</span></div><div data-t="nathanmarz @urbank as opposed to only navigating to the provided subpath"><span class="u" id="1493677763.893694">2017:05:01 22:29:23           nathanmarz </span><span>@urbank as opposed to only navigating to the provided subpath</span></div><div data-t="nathanmarz (select (continue-then-stay :a) {:a 1}) ; =&gt; [1 {:a 1}]"><span class="u" id="1493677814.904544">2017:05:01 22:30:14           nathanmarz </span><code>(select (continue-then-stay :a) {:a 1}) ; =&gt; [1 {:a 1}]</code></div><div data-t="nathanmarz it navigates to :a, then navigates to itself"><span class="u" id="1493677834.908669">2017:05:01 22:30:34           nathanmarz </span><span>it navigates to :a, then navigates to itself</span></div><div data-t="luxbock is there some built-in higher order selector that allows me to write the following:  (transform (??? FIRST LAST) (fn [[a b]] (if (&gt; a b) [(str a) b] [a (str b)]) [1 2 3])  =&gt; [1 2 &quot;3&quot;]?"><span class="u" id="1493693440.130540">2017:05:02 02:50:40              luxbock </span><span>is there some built-in higher order selector that allows me to write the following: </span><code>(transform (??? FIRST LAST) (fn [[a b]] (if (&gt; a b) [(str a) b] [a (str b)]) [1 2 3])</code><span> =&gt; [1 2 &quot;3&quot;]?</span></div><div data-t="narkisr Hey, looking for a way to transform a single value from set into multiple values using a predicate (subset won&apos;t help in that case becuase its not a static set of items)"><span class="u" id="1493705906.422993">2017:05:02 06:18:26              narkisr </span><span>Hey, looking for a way to transform a single value from set into multiple values using a predicate (subset won&apos;t help in that case becuase its not a static set of items)</span></div><div data-t="narkisr iv tried to use transform with pred but that can replace only a single value and not expand a value into multiple ones"><span class="u" id="1493705936.426582">2017:05:02 06:18:56              narkisr </span><span>iv tried to use transform with pred but that can replace only a single value and not expand a value into multiple ones</span></div><div data-t="narkisr I managed to so by using a reduce in the transform function but that not really using specter"><span class="u" id="1493707855.681492">2017:05:02 06:50:55              narkisr </span><span>I managed to so by using a reduce in the transform function but that not really using specter</span></div><div data-t="nathanmarz @narkisr you would need a new navigator for that"><span class="u" id="1493719110.979508">2017:05:02 09:58:30           nathanmarz </span><span>@narkisr you would need a new navigator for that</span></div><div data-t="nathanmarz something like  (dynamic-subset even?)  that navigates to the subset of all even values"><span class="u" id="1493719151.988868">2017:05:02 09:59:11           nathanmarz </span><span>something like </span><code>(dynamic-subset even?)</code><span> that navigates to the subset of all even values</span></div><div data-t="nathanmarz the definition of  subset  should be a good starting point  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L794"><span class="u" id="1493719187.996681">2017:05:02 09:59:47           nathanmarz </span><span>the definition of </span><code>subset</code><span> should be a good starting point </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L794">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L794</a></div><div data-t="mac Has anybody looked at odin  https://github.com/halgari/odin  Any thoughts on how it compares to specter?"><span class="u" id="1493719463.057339">2017:05:02 10:04:23                  mac </span><span>Has anybody looked at odin </span><a href="https://github.com/halgari/odin">https://github.com/halgari/odin</a><span> Any thoughts on how it compares to specter?</span></div><div data-t="nathanmarz @mac from glancing at the readme every example deals with nested maps, so I would want to know if it can handle other data structures / be extensible to user data types"><span class="u" id="1493735404.222044">2017:05:02 14:30:04           nathanmarz </span><span>@mac from glancing at the readme every example deals with nested maps, so I would want to know if it can handle other data structures / be extensible to user data types</span></div><div data-t="nathanmarz I&apos;m also skeptical of the performance and the expressive power"><span class="u" id="1493735537.279134">2017:05:02 14:32:17           nathanmarz </span><span>I&apos;m also skeptical of the performance and the expressive power</span></div><div data-t="nathanmarz especially specter&apos;s &quot;substructure&quot; navigators, like &quot;srange&quot;, &quot;filterer&quot;, etc."><span class="u" id="1493735557.287758">2017:05:02 14:32:37           nathanmarz </span><span>especially specter&apos;s &quot;substructure&quot; navigators, like &quot;srange&quot;, &quot;filterer&quot;, etc.</span></div><div data-t="nathanmarz a good test use case is incrementing the last odd number in a vector of numbers"><span class="u" id="1493735591.302103">2017:05:02 14:33:11           nathanmarz </span><span>a good test use case is incrementing the last odd number in a vector of numbers</span></div><div data-t="mac @nathanmarz If get the time I will see if I can make that work."><span class="u" id="1493735627.317037">2017:05:02 14:33:47                  mac </span><span>@nathanmarz If get the time I will see if I can make that work.</span></div><div data-t="mac Unrelated I am having trouble with understanding DISPENSE."><span class="u" id="1493735659.330862">2017:05:02 14:34:19                  mac </span><span>Unrelated I am having trouble with understanding DISPENSE.</span></div><div data-t="nathanmarz cool, please post whatever you find"><span class="u" id="1493735667.333802">2017:05:02 14:34:27           nathanmarz </span><span>cool, please post whatever you find</span></div><div data-t="mac I would have expected  (s/select [s/ALL (s/collect-one :a) :b s/DISPENSE #(= % 1)] [{:a &quot;A&quot; :b 1} {:a &quot;AA&quot; :b 1}])"><span class="u" id="1493735692.344370">2017:05:02 14:34:52                  mac </span><span>I would have expected </span><pre>(s/select [s/ALL (s/collect-one :a) :b s/DISPENSE #(= % 1)] [{:a &quot;A&quot; :b 1} {:a &quot;AA&quot; :b 1}])</pre></div><div data-t="mac to return  [&quot;A&quot; &quot;AA&quot;]"><span class="u" id="1493735715.354259">2017:05:02 14:35:15                  mac </span><span>to return </span><pre>[&quot;A&quot; &quot;AA&quot;]</pre></div><div data-t="mac but I get  [1 1]"><span class="u" id="1493735741.364839">2017:05:02 14:35:41                  mac </span><span>but I get </span><pre>[1 1]</pre></div><div data-t="mac Isn&apos;t DISPENSE suppose to drop whatever navigations comes after it?"><span class="u" id="1493735774.378625">2017:05:02 14:36:14                  mac </span><span>Isn&apos;t DISPENSE suppose to drop whatever navigations comes after it?</span></div><div data-t="nathanmarz it&apos;s producing the right result"><span class="u" id="1493735786.383625">2017:05:02 14:36:26           nathanmarz </span><span>it&apos;s producing the right result</span></div><div data-t="nathanmarz DISPENSE  drops collected values"><span class="u" id="1493735795.387140">2017:05:02 14:36:35           nathanmarz </span><code>DISPENSE</code><span> drops collected values</span></div><div data-t="nathanmarz that path is equivalent to  [ALL :b #(= % 1)]"><span class="u" id="1493735811.393783">2017:05:02 14:36:51           nathanmarz </span><span>that path is equivalent to </span><code>[ALL :b #(= % 1)]</code></div><div data-t="mac Ok, then I find the docs slightly confusing."><span class="u" id="1493735820.397643">2017:05:02 14:37:00                  mac </span><span>Ok, then I find the docs slightly confusing.</span></div><div data-t="nathanmarz what about it?"><span class="u" id="1493735863.415746">2017:05:02 14:37:43           nathanmarz </span><span>what about it?</span></div><div data-t="mac Ref &quot;Drops all collected values for subsequent navigation&quot; - I understood this to mean values for subsequent navigations to be droped."><span class="u" id="1493735900.430783">2017:05:02 14:38:20                  mac </span><span>Ref &quot;Drops all collected values for subsequent navigation&quot; - I understood this to mean values for subsequent navigations to be droped.</span></div><div data-t="nathanmarz &quot;collected values&quot; always refers to values collected via  collect ,  collect-one , and  VAL"><span class="u" id="1493735937.446464">2017:05:02 14:38:57           nathanmarz </span><span>&quot;collected values&quot; always refers to values collected via </span><code>collect</code><span>, </span><code>collect-one</code><span>, and </span><code>VAL</code></div><div data-t="nathanmarz user=&gt; (doc DISPENSE)
-------------------------
com.rpl.specter/DISPENSE
  Drops all collected values for subsequent navigation.
nil
user=&gt; (doc collect-one)
-------------------------
com.rpl.specter/collect-one
  Adds the result of running select-one with the given path on the
          current value to the collected vals.
nil
user=&gt; (doc collect)
-------------------------
com.rpl.specter/collect
  Adds the result of running select with the given path on the
          current value to the collected vals.
nil
user=&gt; (doc with-fresh-collected)
-------------------------
com.rpl.specter/with-fresh-collected
  Continues navigating on the given path with the collected vals reset to []. Once
     navigation leaves the scope of with-fresh-collected, the collected vals revert
     to what they were before.
nil
"><span class="u" id="1493735998.471241">2017:05:02 14:39:58           nathanmarz </span><pre>user=&gt; (doc DISPENSE)
-------------------------
com.rpl.specter/DISPENSE
  Drops all collected values for subsequent navigation.
nil
user=&gt; (doc collect-one)
-------------------------
com.rpl.specter/collect-one
  Adds the result of running select-one with the given path on the
          current value to the collected vals.
nil
user=&gt; (doc collect)
-------------------------
com.rpl.specter/collect
  Adds the result of running select with the given path on the
          current value to the collected vals.
nil
user=&gt; (doc with-fresh-collected)
-------------------------
com.rpl.specter/with-fresh-collected
  Continues navigating on the given path with the collected vals reset to []. Once
     navigation leaves the scope of with-fresh-collected, the collected vals revert
     to what they were before.
nil
</pre></div><div data-t="nathanmarz terminology is consistent"><span class="u" id="1493736008.475500">2017:05:02 14:40:08           nathanmarz </span><span>terminology is consistent</span></div><div data-t="mac Ok. Is there a way to achieve what I expected."><span class="u" id="1493736060.497081">2017:05:02 14:41:00                  mac </span><span>Ok. Is there a way to achieve what I expected.</span></div><div data-t="nathanmarz I think you&apos;re looking for  (select [ALL #(= 1 (:b %)) :a] data)"><span class="u" id="1493736109.517314">2017:05:02 14:41:49           nathanmarz </span><span>I think you&apos;re looking for </span><code>(select [ALL #(= 1 (:b %)) :a] data)</code></div><div data-t="nathanmarz or  (select [ALL (selected? :b #(= 1 %)) :a] data)"><span class="u" id="1493736137.528975">2017:05:02 14:42:17           nathanmarz </span><span>or </span><code>(select [ALL (selected? :b #(= 1 %)) :a] data)</code></div><div data-t="mac Thanks. I take it then there is no &quot;do not return any values navigated to after this point just use it for selecting&quot; navigator."><span class="u" id="1493736247.576094">2017:05:02 14:44:07                  mac </span><span>Thanks. I take it then there is no &quot;do not return any values navigated to after this point just use it for selecting&quot; navigator.</span></div><div data-t="nathanmarz correct"><span class="u" id="1493736265.583599">2017:05:02 14:44:25           nathanmarz </span><span>correct</span></div><div data-t="mac @nathanmarz Gave halgari anouthe look. No obvious way of solving the use case you mentioned."><span class="u" id="1493758594.245568">2017:05:02 20:56:34                  mac </span><span>@nathanmarz Gave halgari anouthe look. No obvious way of solving the use case you mentioned.</span></div><div data-t="mac I am faced with a design dilemma. I have data structure consisting of deeply nested records which reflect the domain I am working in. Querying this is very straight fwd using specter. But some of these records contain &quot;behaviour&quot; (ie. anonymous functions as values) in the form of validation functions, transformation functions (for how to transform themselves or other records in the structure), dispatch functions(that decides when to dispatch certain messages), conditions etc. I am debating (with myself) two different approaches: Either use multimethods to walk/query the datastructure/trigger behaviour OR use specter for the same task. My primary (perhaps very unfounded) concern with specter is that my structure contains &quot;behaviour&quot;.  My concern with the multimethod approach is that it will be messy and hard to maintain. Hope my question is even remotely clear, otherwise happy to clarify and context."><span class="u" id="1493819364.081489">2017:05:03 13:49:24                  mac </span><span>I am faced with a design dilemma. I have data structure consisting of deeply nested records which reflect the domain I am working in. Querying this is very straight fwd using specter. But some of these records contain &quot;behaviour&quot; (ie. anonymous functions as values) in the form of validation functions, transformation functions (for how to transform themselves or other records in the structure), dispatch functions(that decides when to dispatch certain messages), conditions etc. I am debating (with myself) two different approaches: Either use multimethods to walk/query the datastructure/trigger behaviour OR use specter for the same task. My primary (perhaps very unfounded) concern with specter is that my structure contains &quot;behaviour&quot;.  My concern with the multimethod approach is that it will be messy and hard to maintain. Hope my question is even remotely clear, otherwise happy to clarify and context.</span></div><div data-t="nathanmarz @mac I think using specter is fine for that task"><span class="u" id="1493819836.267681">2017:05:03 13:57:16           nathanmarz </span><span>@mac I think using specter is fine for that task</span></div><div data-t="nathanmarz you probably want to use  traverse  with  reduce  to trigger the nested functions"><span class="u" id="1493819864.279182">2017:05:03 13:57:44           nathanmarz </span><span>you probably want to use </span><code>traverse</code><span> with </span><code>reduce</code><span> to trigger the nested functions</span></div><div data-t="mac Thanks, had not noticed traverse, looks very useful."><span class="u" id="1493820237.437472">2017:05:03 14:03:57                  mac </span><span>Thanks, had not noticed traverse, looks very useful.</span></div><div data-t="nathanmarz @luxbock just noticed your question"><span class="u" id="1493868950.461695">2017:05:04 03:35:50           nathanmarz </span><span>@luxbock just noticed your question</span></div><div data-t="nathanmarz yes there is, it&apos;s this:
 (transform (subselect (multi-path FIRST LAST))
  (fn [[a b]] (if (&gt; a b) [(str a) b] [a (str b)]))
  [1 2 3])
;; =&gt; [1 2 &quot;3&quot;]
"><span class="u" id="1493868986.465128">2017:05:04 03:36:26           nathanmarz </span><span>yes there is, it&apos;s this:
</span><pre>(transform (subselect (multi-path FIRST LAST))
  (fn [[a b]] (if (&gt; a b) [(str a) b] [a (str b)]))
  [1 2 3])
;; =&gt; [1 2 &quot;3&quot;]
</pre></div><div data-t="luxbock Ah that&apos;s great, I will try to see if it works for my original use case "><span class="u" id="1493869214.486417">2017:05:04 03:40:14              luxbock </span><span>Ah that&apos;s great, I will try to see if it works for my original use case </span></div><div data-t="nha Could this selector be rewritten to avoid  sp/range  or  sp/LAST ?

 (def data
  [[:foo {:component &quot;aaa&quot;}]
   [:bar {:component &quot;bbb&quot;}]
   [:qux {:component &quot;ccc&quot;}]])

(= (sp/select [sp/ALL
               (sp/srange 1 2)
               sp/ALL
               :component
               ] data)

   (sp/select [sp/ALL
               sp/LAST
               :component
               ] data)) ;; =&gt; true
 

Is there something analog to  sp/SECOND  or  sp/NTH  ?"><span class="u" id="1494175703.045093">2017:05:07 16:48:23                  nha </span><span>Could this selector be rewritten to avoid </span><code>sp/range</code><span> or </span><code>sp/LAST</code><span>?

</span><pre>(def data
  [[:foo {:component &quot;aaa&quot;}]
   [:bar {:component &quot;bbb&quot;}]
   [:qux {:component &quot;ccc&quot;}]])

(= (sp/select [sp/ALL
               (sp/srange 1 2)
               sp/ALL
               :component
               ] data)

   (sp/select [sp/ALL
               sp/LAST
               :component
               ] data)) ;; =&gt; true
</pre><span>

Is there something analog to </span><code>sp/SECOND</code><span> or </span><code>sp/NTH</code><span> ?</span></div><div data-t="nathanmarz @nha use nthpath"><span class="u" id="1494182725.487165">2017:05:07 18:45:25           nathanmarz </span><span>@nha use nthpath</span></div><div data-t="nathanmarz (nthpath 1)"><span class="u" id="1494182738.488033">2017:05:07 18:45:38           nathanmarz </span><code>(nthpath 1)</code></div><div data-t="nha Perfect, I missed this one  🙂  Thanks nathanmarz, always helpful!"><span class="u" id="1494186742.747072">2017:05:07 19:52:22                  nha </span><span>Perfect, I missed this one </span><b>🙂</b><span> Thanks nathanmarz, always helpful!</span></div><div data-t="mac @nathanmarz I looked at traverse and not sure it does what I need. I have a tree structure of deeply nested records which I would like to walk/transform. Some of these are condition records that should stop navigation of the subtree underneath if the condition (a vector of predicate functions) does not return true. Does that make sense?  I have tried to illustrate the structure below. Navigation should not get to the action records of type :three and :three-and-a-half but allow me to select/transform the other records based on some criteria."><span class="u" id="1494278985.768208">2017:05:08 21:29:45                  mac </span><span>@nathanmarz I looked at traverse and not sure it does what I need. I have a tree structure of deeply nested records which I would like to walk/transform. Some of these are condition records that should stop navigation of the subtree underneath if the condition (a vector of predicate functions) does not return true. Does that make sense?  I have tried to illustrate the structure below. Navigation should not get to the action records of type :three and :three-and-a-half but allow me to select/transform the other records based on some criteria.</span></div><div data-t="nathanmarz @mac what do you run the predicate function on?"><span class="u" id="1494280963.301139">2017:05:08 22:02:43           nathanmarz </span><span>@mac what do you run the predicate function on?</span></div><div data-t="nathanmarz what is  #(= % 3)  supposed to receive as input?"><span class="u" id="1494280979.305360">2017:05:08 22:02:59           nathanmarz </span><span>what is </span><code>#(= % 3)</code><span> supposed to receive as input?</span></div><div data-t="mac @nathanmarz I will pass it the children it is guarding and probably an environment of some sort (a map most likely)."><span class="u" id="1494281112.338636">2017:05:08 22:05:12                  mac </span><span>@nathanmarz I will pass it the children it is guarding and probably an environment of some sort (a map most likely).</span></div><div data-t="nathanmarz from your prior description it sounded like you needed to get some functions out of a nested structure and run them"><span class="u" id="1494282123.568392">2017:05:08 22:22:03           nathanmarz </span><span>from your prior description it sounded like you needed to get some functions out of a nested structure and run them</span></div><div data-t="nathanmarz to do this, once you get to a condition, just use a function to filter it"><span class="u" id="1494282149.574012">2017:05:08 22:22:29           nathanmarz </span><span>to do this, once you get to a condition, just use a function to filter it</span></div><div data-t="nathanmarz (defn cond-filter [cond]
  ;; return true if every condition function returns true)
"><span class="u" id="1494282205.586100">2017:05:08 22:23:25           nathanmarz </span><pre>(defn cond-filter [cond]
  ;; return true if every condition function returns true)
</pre></div><div data-t="nathanmarz then your path would contain  [... cond-filter :actions ALL ...]"><span class="u" id="1494282233.592113">2017:05:08 22:23:53           nathanmarz </span><span>then your path would contain </span><code>[... cond-filter :actions ALL ...]</code></div><div data-t="mac @nathanmarz Sorry for the confusion. I only need to run the functions to determine if the subtree they are guarding should be walked or skipped."><span class="u" id="1494282563.661792">2017:05:08 22:29:23                  mac </span><span>@nathanmarz Sorry for the confusion. I only need to run the functions to determine if the subtree they are guarding should be walked or skipped.</span></div><div data-t="nathanmarz @mac does making a function that runs the condition functions solve your problem?"><span class="u" id="1494283206.793734">2017:05:08 22:40:06           nathanmarz </span><span>@mac does making a function that runs the condition functions solve your problem?</span></div><div data-t="mac @nathanmarz I don&apos;t think so. Only if I the result could control if the children of the Condition record are walked or not - the problem is I don&apos;t know how to do that. Been looking at zippers too, but last time I dealt with them it was painful  🙂"><span class="u" id="1494284202.987049">2017:05:08 22:56:42                  mac </span><span>@nathanmarz I don&apos;t think so. Only if I the result could control if the children of the Condition record are walked or not - the problem is I don&apos;t know how to do that. Been looking at zippers too, but last time I dealt with them it was painful </span><b>🙂</b></div><div data-t="nathanmarz it does control that"><span class="u" id="1494284922.123735">2017:05:08 23:08:42           nathanmarz </span><span>it does control that</span></div><div data-t="nathanmarz that&apos;s exactly what it does"><span class="u" id="1494284935.125905">2017:05:08 23:08:55           nathanmarz </span><span>that&apos;s exactly what it does</span></div><div data-t="nathanmarz your path should navigate to condition, then run a filter function there to do all the logic of testing the predicates against the guarded children"><span class="u" id="1494284983.134059">2017:05:08 23:09:43           nathanmarz </span><span>your path should navigate to condition, then run a filter function there to do all the logic of testing the predicates against the guarded children</span></div><div data-t="nathanmarz if that returns true, then it can continue walking the actions"><span class="u" id="1494284991.135665">2017:05:08 23:09:51           nathanmarz </span><span>if that returns true, then it can continue walking the actions</span></div><div data-t="nathanmarz if it returns false, then the actions will not be walked"><span class="u" id="1494284997.136690">2017:05:08 23:09:57           nathanmarz </span><span>if it returns false, then the actions will not be walked</span></div><div data-t="mac And the remainder of the structure will still be walked?"><span class="u" id="1494285372.204747">2017:05:08 23:16:12                  mac </span><span>And the remainder of the structure will still be walked?</span></div><div data-t="mac @nathanmarz I might be missing something here, but I don&apos;t have a path at all, only a walker."><span class="u" id="1494285566.238426">2017:05:08 23:19:26                  mac </span><span>@nathanmarz I might be missing something here, but I don&apos;t have a path at all, only a walker.</span></div><div data-t="nathanmarz you mean you&apos;re using the  walker  navigator?"><span class="u" id="1494285600.244148">2017:05:08 23:20:00           nathanmarz </span><span>you mean you&apos;re using the </span><code>walker</code><span> navigator?</span></div><div data-t="mac Yes"><span class="u" id="1494285608.245680">2017:05:08 23:20:08                  mac </span><span>Yes</span></div><div data-t="nathanmarz wrap it in a  recursive-path"><span class="u" id="1494285627.249294">2017:05:08 23:20:27           nathanmarz </span><span>wrap it in a </span><code>recursive-path</code></div><div data-t="nathanmarz what are you walking to?"><span class="u" id="1494285673.257360">2017:05:08 23:21:13           nathanmarz </span><span>what are you walking to?</span></div><div data-t="nathanmarz Action  or  Condition ?"><span class="u" id="1494285679.258614">2017:05:08 23:21:19           nathanmarz </span><code>Action</code><span> or </span><code>Condition</code><span>?</span></div><div data-t="nathanmarz actually, is your goal to just retrieve all actions that are properly guarded?"><span class="u" id="1494285715.264932">2017:05:08 23:21:55           nathanmarz </span><span>actually, is your goal to just retrieve all actions that are properly guarded?</span></div><div data-t="mac Yes, and potentially transform them."><span class="u" id="1494285738.268858">2017:05:08 23:22:18                  mac </span><span>Yes, and potentially transform them.</span></div><div data-t="nathanmarz (def SATISFACTORY-ACTION-NODES
  (recursive-path [] p
    (if-path #(instance? Condition %)
      [cond-filter :children ALL p]
      (continue-then-stay
        :children
        ALL
        p
        ))))
"><span class="u" id="1494285831.285211">2017:05:08 23:23:51           nathanmarz </span><pre>(def SATISFACTORY-ACTION-NODES
  (recursive-path [] p
    (if-path #(instance? Condition %)
      [cond-filter :children ALL p]
      (continue-then-stay
        :children
        ALL
        p
        ))))
</pre></div><div data-t="nathanmarz you want something like that"><span class="u" id="1494285835.285921">2017:05:08 23:23:55           nathanmarz </span><span>you want something like that</span></div><div data-t="nathanmarz I don&apos;t think you want to use walker"><span class="u" id="1494285854.289108">2017:05:08 23:24:14           nathanmarz </span><span>I don&apos;t think you want to use walker</span></div><div data-t="nathanmarz it&apos;s always better to encode the precise structure of your data rather than brute force it with  walker"><span class="u" id="1494285883.293774">2017:05:08 23:24:43           nathanmarz </span><span>it&apos;s always better to encode the precise structure of your data rather than brute force it with </span><code>walker</code></div><div data-t="nathanmarz an alternative way to solve this is with protocol paths (if you&apos;re using clojure)"><span class="u" id="1494285994.313619">2017:05:08 23:26:34           nathanmarz </span><span>an alternative way to solve this is with protocol paths (if you&apos;re using clojure)</span></div><div data-t="nathanmarz protocol path solution would be extensible to other types of nodes beyond Action and Condition"><span class="u" id="1494286023.318716">2017:05:08 23:27:03           nathanmarz </span><span>protocol path solution would be extensible to other types of nodes beyond Action and Condition</span></div><div data-t="mac That might be even better, since I have several other record types."><span class="u" id="1494286079.328702">2017:05:08 23:27:59                  mac </span><span>That might be even better, since I have several other record types.</span></div><div data-t="nathanmarz there&apos;s examples of those on the README"><span class="u" id="1494286107.333694">2017:05:08 23:28:27           nathanmarz </span><span>there&apos;s examples of those on the README</span></div><div data-t="mac Yeah, looked at those but it wasn&apos;t clear to me how to achieve my goal. Will look at them again."><span class="u" id="1494286149.341125">2017:05:08 23:29:09                  mac </span><span>Yeah, looked at those but it wasn&apos;t clear to me how to achieve my goal. Will look at them again.</span></div><div data-t="nathanmarz (defprotocolpath SatisfactoryActionNodes)

(extend-protocolpath SatisfactoryActionNodes
  Action (continue-then-stay :children ALL SatisfactoryActionNodes)
  Condition [cond-filter :children ALL SatisfactoryActionNodes])
"><span class="u" id="1494286264.361802">2017:05:08 23:31:04           nathanmarz </span><pre>(defprotocolpath SatisfactoryActionNodes)

(extend-protocolpath SatisfactoryActionNodes
  Action (continue-then-stay :children ALL SatisfactoryActionNodes)
  Condition [cond-filter :children ALL SatisfactoryActionNodes])
</pre></div><div data-t="mac @nathanmarz That it is very elegant."><span class="u" id="1494286478.398918">2017:05:08 23:34:38                  mac </span><span>@nathanmarz That it is very elegant.</span></div><div data-t="wilkerlucio hello, I&apos;m trying to figure if I can use specter for a situation I have here"><span class="u" id="1494512056.464755">2017:05:11 14:14:16          wilkerlucio </span><span>hello, I&apos;m trying to figure if I can use specter for a situation I have here</span></div><div data-t="wilkerlucio I have a map, and I would like to filter the map by some criteria on the values"><span class="u" id="1494512081.475117">2017:05:11 14:14:41          wilkerlucio </span><span>I have a map, and I would like to filter the map by some criteria on the values</span></div><div data-t="wilkerlucio today my Clojure code is:"><span class="u" id="1494512104.484753">2017:05:11 14:15:04          wilkerlucio </span><span>today my Clojure code is:</span></div><div data-t="wilkerlucio (-&gt;&gt; some-map
     (filter (fn [[k v]]
               (&gt; v 10)))
     (into {}))"><span class="u" id="1494512137.499106">2017:05:11 14:15:37          wilkerlucio </span><pre>(-&gt;&gt; some-map
     (filter (fn [[k v]]
               (&gt; v 10)))
     (into {}))</pre></div><div data-t="wilkerlucio is there a way to replace this with specter  select  and avoid having to convert the data types?"><span class="u" id="1494512154.506091">2017:05:11 14:15:54          wilkerlucio </span><span>is there a way to replace this with specter </span><code>select</code><span> and avoid having to convert the data types?</span></div><div data-t="nathanmarz @wilkerlucio  (transform [MAP-VALS #(&gt; % 10)] some-map)"><span class="u" id="1494514839.698820">2017:05:11 15:00:39           nathanmarz </span><span>@wilkerlucio </span><code>(transform [MAP-VALS #(&gt; % 10)] some-map)</code></div><div data-t="nathanmarz that will maintain the type of the map and also run about 10x faster"><span class="u" id="1494514884.720657">2017:05:11 15:01:24           nathanmarz </span><span>that will maintain the type of the map and also run about 10x faster</span></div><div data-t="wilkerlucio @nathanmarz thanks, didn&apos;t even occur to me to use transform to filter, but seeing it makes total sense  🙂"><span class="u" id="1494515209.870008">2017:05:11 15:06:49          wilkerlucio </span><span>@nathanmarz thanks, didn&apos;t even occur to me to use transform to filter, but seeing it makes total sense </span><b>🙂</b></div><div data-t="wilkerlucio I think would be nice to have some  filter  example like this on README"><span class="u" id="1494515242.886020">2017:05:11 15:07:22          wilkerlucio </span><span>I think would be nice to have some </span><code>filter</code><span> example like this on README</span></div><div data-t="nathanmarz err"><span class="u" id="1494515286.905466">2017:05:11 15:08:06           nathanmarz </span><span>err</span></div><div data-t="nathanmarz sorry, meant to write this:  (setval [MAP-VALS #(&lt;= % 10)] NONE some-map)"><span class="u" id="1494515308.915489">2017:05:11 15:08:28           nathanmarz </span><span>sorry, meant to write this: </span><code>(setval [MAP-VALS #(&lt;= % 10)] NONE some-map)</code></div><div data-t="nathanmarz sleepy today"><span class="u" id="1494515318.919247">2017:05:11 15:08:38           nathanmarz </span><span>sleepy today</span></div><div data-t="wilkerlucio haha, I was just coming back to ask, thanks for the speedy catch  🙂"><span class="u" id="1494515417.963705">2017:05:11 15:10:17          wilkerlucio </span><span>haha, I was just coming back to ask, thanks for the speedy catch </span><b>🙂</b></div><div data-t="wilkerlucio @nathanmarz why we need to invert the predicate?"><span class="u" id="1494515472.988506">2017:05:11 15:11:12          wilkerlucio </span><span>@nathanmarz why we need to invert the predicate?</span></div><div data-t="wilkerlucio ah, gotcha, it&apos;s not about filtering ther,e it&apos;s about removing"><span class="u" id="1494515494.998061">2017:05:11 15:11:34          wilkerlucio </span><span>ah, gotcha, it&apos;s not about filtering ther,e it&apos;s about removing</span></div><div data-t="nathanmarz yea, that&apos;s right"><span class="u" id="1494515714.095345">2017:05:11 15:15:14           nathanmarz </span><span>yea, that&apos;s right</span></div><div data-t="ksmithbaylor Hey everyone! I&apos;ve got a nested map (It&apos;s a deserialization of a flat file JSON &quot;database&quot; for a budgeting app I&apos;m extending) that looks similar to this (stripped down somewhat):

 {:categories [{:name &quot;Monthly bills&quot;
               :subcategories [{:name &quot;Electric&quot;}
                               {:name &quot;Cable&quot; :inactive true}
                               {:name &quot;Mortgage&quot;}
                               {:name &quot;Natural Gas&quot;}]}
              {:name &quot;Food&quot;
               :subcategories [{:name &quot;Eating Out&quot;}
                               {:name &quot;Groceries&quot;}]}
              {:name &quot;Stuff&quot;
               :inactive true
               :subcategories [{:name &quot;Things&quot; :inactive true}
                               {:name &quot;Whatever&quot;}]}]
 :accounts [{:name &quot;Checking&quot;
             :balance 100}
            {:name &quot;Old account&quot;
             :balance 0
             :inactive true}
            {:name &quot;Savings&quot;
             :balance 500}]}
 

I&apos;m fairly new to specter, and am still learning about what&apos;s possible. How would I recursively remove all maps at all levels that have an  :inactive true  flag? The result I would get from the above would be:

 {:categories [{:name &quot;Monthly bills&quot;
               :subcategories [{:name &quot;Electric&quot;}
                               {:name &quot;Mortgage&quot;}
                               {:name &quot;Natural Gas&quot;}]}
              {:name &quot;Food&quot;
               :subcategories [{:name &quot;Eating Out&quot;}
                               {:name &quot;Groceries&quot;}]}]
 :accounts [{:name &quot;Checking&quot;
             :balance 100}
            {:name &quot;Savings&quot;
             :balance 500}]}
"><span class="u" id="1494628511.095955">2017:05:12 22:35:11         ksmithbaylor </span><span>Hey everyone! I&apos;ve got a nested map (It&apos;s a deserialization of a flat file JSON &quot;database&quot; for a budgeting app I&apos;m extending) that looks similar to this (stripped down somewhat):

</span><pre>{:categories [{:name &quot;Monthly bills&quot;
               :subcategories [{:name &quot;Electric&quot;}
                               {:name &quot;Cable&quot; :inactive true}
                               {:name &quot;Mortgage&quot;}
                               {:name &quot;Natural Gas&quot;}]}
              {:name &quot;Food&quot;
               :subcategories [{:name &quot;Eating Out&quot;}
                               {:name &quot;Groceries&quot;}]}
              {:name &quot;Stuff&quot;
               :inactive true
               :subcategories [{:name &quot;Things&quot; :inactive true}
                               {:name &quot;Whatever&quot;}]}]
 :accounts [{:name &quot;Checking&quot;
             :balance 100}
            {:name &quot;Old account&quot;
             :balance 0
             :inactive true}
            {:name &quot;Savings&quot;
             :balance 500}]}
</pre><span>

I&apos;m fairly new to specter, and am still learning about what&apos;s possible. How would I recursively remove all maps at all levels that have an </span><code>:inactive true</code><span> flag? The result I would get from the above would be:

</span><pre>{:categories [{:name &quot;Monthly bills&quot;
               :subcategories [{:name &quot;Electric&quot;}
                               {:name &quot;Mortgage&quot;}
                               {:name &quot;Natural Gas&quot;}]}
              {:name &quot;Food&quot;
               :subcategories [{:name &quot;Eating Out&quot;}
                               {:name &quot;Groceries&quot;}]}]
 :accounts [{:name &quot;Checking&quot;
             :balance 100}
            {:name &quot;Savings&quot;
             :balance 500}]}
</pre></div><div data-t="nathanmarz @ksmithbaylor it would be something like:
 (def NODES
  (recursive-path [] p
    (continue-then-stay
      (must :subcategories) ALL p
      )))

(setval [(multi-path :categories :accounts)
         ALL
         NODES
         (pred :inactive)]
  NONE
  data)
"><span class="u" id="1494630195.357018">2017:05:12 23:03:15           nathanmarz </span><span>@ksmithbaylor it would be something like:
</span><pre>(def NODES
  (recursive-path [] p
    (continue-then-stay
      (must :subcategories) ALL p
      )))

(setval [(multi-path :categories :accounts)
         ALL
         NODES
         (pred :inactive)]
  NONE
  data)
</pre></div><div data-t="ksmithbaylor This is doing almost what I want:  (setval [(walker #(and (map? %) (:inactive %)))] nil data)"><span class="u" id="1494631265.505435">2017:05:12 23:21:05         ksmithbaylor </span><span>This is doing almost what I want: </span><code>(setval [(walker #(and (map? %) (:inactive %)))] nil data)</code></div><div data-t="ksmithbaylor but now I need to recursively remove the  nil s"><span class="u" id="1494631289.508530">2017:05:12 23:21:29         ksmithbaylor </span><span>but now I need to recursively remove the </span><code>nil</code><span>s</span></div><div data-t="ksmithbaylor I&apos;d like to keep it generic so I don&apos;t need to know/care what keys are in each level"><span class="u" id="1494631330.513756">2017:05:12 23:22:10         ksmithbaylor </span><span>I&apos;d like to keep it generic so I don&apos;t need to know/care what keys are in each level</span></div><div data-t="nathanmarz it&apos;s generally better to be more precise about the structure of your data"><span class="u" id="1494632876.696979">2017:05:12 23:47:56           nathanmarz </span><span>it&apos;s generally better to be more precise about the structure of your data</span></div><div data-t="nathanmarz walker  doesn&apos;t perform well and has some pitfalls"><span class="u" id="1494632887.698275">2017:05:12 23:48:07           nathanmarz </span><code>walker</code><span> doesn&apos;t perform well and has some pitfalls</span></div><div data-t="nathanmarz you can just replace  nil  with  NONE  there to get the maps removed"><span class="u" id="1494632903.700138">2017:05:12 23:48:23           nathanmarz </span><span>you can just replace </span><code>nil</code><span> with </span><code>NONE</code><span> there to get the maps removed</span></div><div data-t="nathanmarz actually nevermind,  walker  doesn&apos;t implement  NONE  removal"><span class="u" id="1494632980.708680">2017:05:12 23:49:40           nathanmarz </span><span>actually nevermind, </span><code>walker</code><span> doesn&apos;t implement </span><code>NONE</code><span> removal</span></div><div data-t="ksmithbaylor Is there a way to implement NONE removal for walker? There are a lot of types of entities in the db and they all use the same flag for signifying something as inactive."><span class="u" id="1494636942.069460">2017:05:13 00:55:42         ksmithbaylor </span><span>Is there a way to implement NONE removal for walker? There are a lot of types of entities in the db and they all use the same flag for signifying something as inactive.</span></div><div data-t="ksmithbaylor Also, the inactive entities always appear in vectors. Would it make sense to wrap the setval above in a transform that would filter each vector to remove NONE?"><span class="u" id="1494636999.073660">2017:05:13 00:56:39         ksmithbaylor </span><span>Also, the inactive entities always appear in vectors. Would it make sense to wrap the setval above in a transform that would filter each vector to remove NONE?</span></div><div data-t="nathanmarz @ksmithbaylor i don&apos;t think it would be too hard to re-implement walker in terms of  recursive-path ,  ALL , etc."><span class="u" id="1494637756.128319">2017:05:13 01:09:16           nathanmarz </span><span>@ksmithbaylor i don&apos;t think it would be too hard to re-implement walker in terms of </span><code>recursive-path</code><span>, </span><code>ALL</code><span>, etc.</span></div><div data-t="nathanmarz you could also use  [(walker vector?) ALL (pred :inactive)]  as your path, and  NONE  removal will work"><span class="u" id="1494637800.131184">2017:05:13 01:10:00           nathanmarz </span><span>you could also use </span><code>[(walker vector?) ALL (pred :inactive)]</code><span> as your path, and </span><code>NONE</code><span> removal will work</span></div><div data-t="nathanmarz actually that would need to be wrapped in  recursive-path  so it reaches vectors nested inside maps inside vectors"><span class="u" id="1494637977.143103">2017:05:13 01:12:57           nathanmarz </span><span>actually that would need to be wrapped in </span><code>recursive-path</code><span> so it reaches vectors nested inside maps inside vectors</span></div><div data-t="ksmithbaylor Since I&apos;m fairly new to Clojure, I&apos;m not quite clear on the usage of  recursive-path . Here&apos;s what I have so far, but it seems to have no effect on the data:
 (setval (recursive-path [] p [(walker vector?) ALL (pred :inactive) p]) NONE data)
"><span class="u" id="1494711014.225895">2017:05:13 21:30:14         ksmithbaylor </span><span>Since I&apos;m fairly new to Clojure, I&apos;m not quite clear on the usage of </span><code>recursive-path</code><span>. Here&apos;s what I have so far, but it seems to have no effect on the data:
</span><pre>(setval (recursive-path [] p [(walker vector?) ALL (pred :inactive) p]) NONE data)
</pre></div><div data-t="nathanmarz @ksmithbaylor that path as defined never finishes navigation anywhere"><span class="u" id="1494818130.033618">2017:05:15 03:15:30           nathanmarz </span><span>@ksmithbaylor that path as defined never finishes navigation anywhere</span></div><div data-t="nathanmarz you&apos;ll want something like
 (let [all-maps
        (recursive-path [] p
           [(walker vector?)
             ALL
             (continue-then-stay p)])]
(setval [all-maps (pred :inactive)] NONE data))
"><span class="u" id="1494818401.059092">2017:05:15 03:20:01           nathanmarz </span><span>you&apos;ll want something like
</span><pre>(let [all-maps
        (recursive-path [] p
           [(walker vector?)
             ALL
             (continue-then-stay p)])]
(setval [all-maps (pred :inactive)] NONE data))
</pre></div><div data-t="dottedmag Is Specter a good tool for the following task? I have a representation of file tree  {:dirs {&quot;name&quot; &lt;...&gt; &quot;name2&quot; &lt;..&gt;} :files {&quot;fname&quot; &lt;...&gt; &quot;fname2&quot; &lt;...&gt;}} , where values in map under  :dirs  are of the same structure. And I also have a file path &quot;name/subname/subname/filename&quot;. I need to return a new file tree with this path added, potentially creating any missing intermediate directories."><span class="u" id="1495485919.492971">2017:05:22 20:45:19            dottedmag </span><span>Is Specter a good tool for the following task? I have a representation of file tree </span><code>{:dirs {&quot;name&quot; &lt;...&gt; &quot;name2&quot; &lt;..&gt;} :files {&quot;fname&quot; &lt;...&gt; &quot;fname2&quot; &lt;...&gt;}}</code><span>, where values in map under </span><code>:dirs</code><span> are of the same structure. And I also have a file path &quot;name/subname/subname/filename&quot;. I need to return a new file tree with this path added, potentially creating any missing intermediate directories.</span></div><div data-t="nathanmarz @dottedmag it&apos;ll help but won&apos;t be as compelling as it is for a lot of other use cases"><span class="u" id="1495495145.677911">2017:05:22 23:19:05           nathanmarz </span><span>@dottedmag it&apos;ll help but won&apos;t be as compelling as it is for a lot of other use cases</span></div><div data-t="nathanmarz for this I would dynamically create a path using reduce, comp-paths, and keypath"><span class="u" id="1495495201.687191">2017:05:22 23:20:01           nathanmarz </span><span>for this I would dynamically create a path using reduce, comp-paths, and keypath</span></div><div data-t="dottedmag @nathanmarz Yep, I&apos;ve got the same impression. Looks like a zipper is a better fit for this particular problem."><span class="u" id="1495497495.054440">2017:05:22 23:58:15            dottedmag </span><span>@nathanmarz Yep, I&apos;ve got the same impression. Looks like a zipper is a better fit for this particular problem.</span></div><div data-t="madstap @dottedmag I would just use core functions:
 (defn assoc-file [dir-map path content]
  (let [xs (str/split path #&quot;/&quot;)
        dirs (butlast xs)
        file-name (last xs)
        path-vec (-&gt; (interleave (repeat :dirs) dirs)
                     vec
                     (conj :files file-name))]
    (assoc-in dir-map path-vec content)))

(assoc-file {} &quot;foo/bar/baz.sh&quot; &quot;#!/bin/bash\n\necho foobar&quot;)
 
Edit:  (mapcat vector foo bar)  is just  (interleave foo bar)"><span class="u" id="1495501668.640520">2017:05:23 01:07:48              madstap </span><span>@dottedmag I would just use core functions:
</span><pre>(defn assoc-file [dir-map path content]
  (let [xs (str/split path #&quot;/&quot;)
        dirs (butlast xs)
        file-name (last xs)
        path-vec (-&gt; (interleave (repeat :dirs) dirs)
                     vec
                     (conj :files file-name))]
    (assoc-in dir-map path-vec content)))

(assoc-file {} &quot;foo/bar/baz.sh&quot; &quot;#!/bin/bash\n\necho foobar&quot;)
</pre><span>
Edit: </span><code>(mapcat vector foo bar)</code><span> is just </span><code>(interleave foo bar)</code></div><div data-t="dottedmag @madstap Thanks. I&apos;ve got other operations on the same structure, so I went slightly crazy and created  https://github.com/dottedmag/azip"><span class="u" id="1495565835.299779">2017:05:23 18:57:15            dottedmag </span><span>@madstap Thanks. I&apos;ve got other operations on the same structure, so I went slightly crazy and created </span><a href="https://github.com/dottedmag/azip">https://github.com/dottedmag/azip</a></div><div data-t="madstap dottedmag: Nice. I&apos;ve never used zippers before. Out of curiosity, how would my assoc-file function look using azip?"><span class="u" id="1495566284.478220">2017:05:23 19:04:44                   madstap </span><span>dottedmag: Nice. I&apos;ve never used zippers before. Out of curiosity, how would my assoc-file function look using azip?</span></div><div data-t="oskarkv outer-map looks like this:
 {[1.0 1.0] {:vertices [[0 0] [1.5 0.0] [1.5 1.5] [0.0 1.5]]}
 ...}
 

Can I do this conveniently with specter? I.e. take the vertices, make a polygon out of them, and put it next to the vertices.

 (into {} (map (fn [[site m]] (assoc m :polygon
                                    (pair-cycle (:vertices m)))
                outer-map)))
"><span class="u" id="1496084984.226772">2017:05:29 19:09:44              oskarkv </span><span>outer-map looks like this:
</span><pre>{[1.0 1.0] {:vertices [[0 0] [1.5 0.0] [1.5 1.5] [0.0 1.5]]}
 ...}
</pre><span>

Can I do this conveniently with specter? I.e. take the vertices, make a polygon out of them, and put it next to the vertices.

</span><pre>(into {} (map (fn [[site m]] (assoc m :polygon
                                    (pair-cycle (:vertices m)))
                outer-map)))
</pre></div><div data-t="oskarkv (s/transform [s/MAP-VALS (s/collect-one :vertices) :polygon]
                   (fn [vs _] (pair-cycle vs))
                   m)
"><span class="u" id="1496091745.966596">2017:05:29 21:02:25              oskarkv </span><pre>(s/transform [s/MAP-VALS (s/collect-one :vertices) :polygon]
                   (fn [vs _] (pair-cycle vs))
                   m)
</pre></div><div data-t="oskarkv That&apos;s what I came up with."><span class="u" id="1496091773.969338">2017:05:29 21:02:53              oskarkv </span><span>That&apos;s what I came up with.</span></div><div data-t="nathanmarz @oskarkv that code looks good to me"><span class="u" id="1496098014.495972">2017:05:29 22:46:54           nathanmarz </span><span>@oskarkv that code looks good to me</span></div><div data-t="mping hia"><span class="u" id="1496174451.441630">2017:05:30 20:00:51                mping </span><span>hia</span></div><div data-t="mping is there a way to traverse a map of maps and return a val for a given predicate?"><span class="u" id="1496174545.474581">2017:05:30 20:02:25                mping </span><span>is there a way to traverse a map of maps and return a val for a given predicate?</span></div><div data-t="mping I&apos;m still wrapping my head around specter"><span class="u" id="1496174554.477759">2017:05:30 20:02:34                mping </span><span>I&apos;m still wrapping my head around specter</span></div><div data-t="mping something like a recursive tree walk"><span class="u" id="1496174620.500750">2017:05:30 20:03:40                mping </span><span>something like a recursive tree walk</span></div><div data-t="nathanmarz @mping yes, that&apos;s pretty easy"><span class="u" id="1496182387.800539">2017:05:30 22:13:07           nathanmarz </span><span>@mping yes, that&apos;s pretty easy</span></div><div data-t="nathanmarz have a particular example?"><span class="u" id="1496182391.801409">2017:05:30 22:13:11           nathanmarz </span><span>have a particular example?</span></div><div data-t="danboykis If I have the following:

 (def person
  [{:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag :a}
   {:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag :b}
   {:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag :c}])
 

I want to transform that to

 {:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag #{:c :b :a}}
 

In plain clojure I can  do it with

 (into {} (map (fn [[k v]] (assoc k :tag v)))
      (reduce (fn [accum e]
          (let [sm (select-keys e [:name :id :job])]
            (if-let [exists (get accum sm)]
              (assoc accum sm (conj exists (:tag e)))
              (assoc accum sm #{(:tag e)}))))
        {}
        person))
 

I am hoping there&apos;s a nicer way to do the same in specter"><span class="u" id="1496191376.309652">2017:05:31 00:42:56            danboykis </span><span>If I have the following:

</span><pre>(def person
  [{:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag :a}
   {:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag :b}
   {:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag :c}])
</pre><span>

I want to transform that to

</span><pre>{:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag #{:c :b :a}}
</pre><span>

In plain clojure I can  do it with

</span><pre>(into {} (map (fn [[k v]] (assoc k :tag v)))
      (reduce (fn [accum e]
          (let [sm (select-keys e [:name :id :job])]
            (if-let [exists (get accum sm)]
              (assoc accum sm (conj exists (:tag e)))
              (assoc accum sm #{(:tag e)}))))
        {}
        person))
</pre><span>

I am hoping there&apos;s a nicer way to do the same in specter</span></div><div data-t="nathanmarz @danboykis that&apos;s computing an entirely new value, whereas specter is about changing part of a data structure"><span class="u" id="1496197141.057865">2017:05:31 02:19:01           nathanmarz </span><span>@danboykis that&apos;s computing an entirely new value, whereas specter is about changing part of a data structure</span></div><div data-t="nathanmarz there are pieces of it you can make nicer with specter, like replacing the  if-let  clause with  (setval [(keypath sm) NONE-ELEM] (:tag e) accum)"><span class="u" id="1496197239.069598">2017:05:31 02:20:39           nathanmarz </span><span>there are pieces of it you can make nicer with specter, like replacing the </span><code>if-let</code><span> clause with </span><code>(setval [(keypath sm) NONE-ELEM] (:tag e) accum)</code></div><div data-t="danboykis @nathanmarz thanks for the explanation, I am new to specter and don&apos;t have a good feel for the its use cases yet"><span class="u" id="1496199982.391841">2017:05:31 03:06:22            danboykis </span><span>@nathanmarz thanks for the explanation, I am new to specter and don&apos;t have a good feel for the its use cases yet</span></div><div data-t="mping @nathanmarz figured it out:  (specter/select (specter/walker is-pdf-attachment?) user/msg)"><span class="u" id="1496211126.637006">2017:05:31 06:12:06                mping </span><span>@nathanmarz figured it out: </span><code>(specter/select (specter/walker is-pdf-attachment?) user/msg)</code></div><div data-t="mping tks"><span class="u" id="1496211129.637367">2017:05:31 06:12:09                mping </span><span>tks</span></div><div data-t="wilkerlucio hello, I would like to use specter to apply a function to all map keys (recursively) on a map, can someone please give me an example on doing that?"><span class="u" id="1496409793.577510">2017:06:02 13:23:13          wilkerlucio </span><span>hello, I would like to use specter to apply a function to all map keys (recursively) on a map, can someone please give me an example on doing that?</span></div><div data-t="nathanmarz @wilkerlucio can you show a specific example of a transformation?"><span class="u" id="1496411498.150800">2017:06:02 13:51:38           nathanmarz </span><span>@wilkerlucio can you show a specific example of a transformation?</span></div><div data-t="nathanmarz that should be pretty easy"><span class="u" id="1496411507.153703">2017:06:02 13:51:47           nathanmarz </span><span>that should be pretty easy</span></div><div data-t="wilkerlucio @nathanmarz sure, something like this:

 {:person/name &quot;Bla&quot;
 :person/child {:child/something &quot;other&quot;
                :child/bla {:subchild/entry &quot;blabla&quot;}}}
 

to this:

 {:name &quot;Bla&quot;
 :child {:something &quot;other&quot;
                :bla {:entry &quot;blabla&quot;}}}
"><span class="u" id="1496411644.202871">2017:06:02 13:54:04          wilkerlucio </span><span>@nathanmarz sure, something like this:

</span><pre>{:person/name &quot;Bla&quot;
 :person/child {:child/something &quot;other&quot;
                :child/bla {:subchild/entry &quot;blabla&quot;}}}
</pre><span>

to this:

</span><pre>{:name &quot;Bla&quot;
 :child {:something &quot;other&quot;
                :bla {:entry &quot;blabla&quot;}}}
</pre></div><div data-t="wilkerlucio considering it can  have N nesting fields"><span class="u" id="1496411657.207327">2017:06:02 13:54:17          wilkerlucio </span><span>considering it can  have N nesting fields</span></div><div data-t="nathanmarz @wilkerlucio looks like this:
 (def data
  {:person/name &quot;Bla&quot;
   :person/child {:child/something &quot;other&quot;
                  :child/bla {:subchild/entry &quot;blabla&quot;}}})

(def MapWalker
  (recursive-path [] p
    (if-path map?
      (continue-then-stay MAP-VALS p))
    ))

(setval [MapWalker MAP-KEYS NAMESPACE] nil data)
"><span class="u" id="1496412327.457893">2017:06:02 14:05:27           nathanmarz </span><span>@wilkerlucio looks like this:
</span><pre>(def data
  {:person/name &quot;Bla&quot;
   :person/child {:child/something &quot;other&quot;
                  :child/bla {:subchild/entry &quot;blabla&quot;}}})

(def MapWalker
  (recursive-path [] p
    (if-path map?
      (continue-then-stay MAP-VALS p))
    ))

(setval [MapWalker MAP-KEYS NAMESPACE] nil data)
</pre></div><div data-t="wilkerlucio @nathanmarz thanks  🙂"><span class="u" id="1496416649.119002">2017:06:02 15:17:29          wilkerlucio </span><span>@nathanmarz thanks </span><b>🙂</b></div><div data-t="souenzzo (def ALL-MAPS
  &quot;All maps of an entity&quot;
  (recursive-path [] p
                  [(walker map?) (stay-then-continue MAP-VALS p)]))

 
@wilkerlucio those dont work with  {:a [{:b :c}]} ..."><span class="u" id="1496419564.233137">2017:06:02 16:06:04             souenzzo </span><pre>(def ALL-MAPS
  &quot;All maps of an entity&quot;
  (recursive-path [] p
                  [(walker map?) (stay-then-continue MAP-VALS p)]))

</pre><span>
@wilkerlucio those dont work with </span><code>{:a [{:b :c}]}</code><span>...</span></div><div data-t="nathanmarz it&apos;s generally better not to use walker"><span class="u" id="1496422776.367437">2017:06:02 16:59:36           nathanmarz </span><span>it&apos;s generally better not to use walker</span></div><div data-t="nathanmarz but rather make a path that precisely encodes the structure of the data you&apos;re working with"><span class="u" id="1496422801.375719">2017:06:02 17:00:01           nathanmarz </span><span>but rather make a path that precisely encodes the structure of the data you&apos;re working with</span></div><div data-t="nathanmarz walker is brute force which makes it less performant and often causes surprising bugs (e.g. by descending into things you didn&apos;t want, like records)"><span class="u" id="1496422826.386111">2017:06:02 17:00:26           nathanmarz </span><span>walker is brute force which makes it less performant and often causes surprising bugs (e.g. by descending into things you didn&apos;t want, like records)</span></div><div data-t="souenzzo There is some other way to define  ALL-MAPS  (w/o walker)?"><span class="u" id="1496422925.420869">2017:06:02 17:02:05             souenzzo </span><span>There is some other way to define </span><code>ALL-MAPS</code><span> (w/o walker)?</span></div><div data-t="nathanmarz @souenzzo  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1284"><span class="u" id="1496422975.438388">2017:06:02 17:02:55           nathanmarz </span><span>@souenzzo </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1284">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1284</a></div><div data-t="nathanmarz that&apos;s the new definition of  walker  I recently committed"><span class="u" id="1496422990.443338">2017:06:02 17:03:10           nathanmarz </span><span>that&apos;s the new definition of </span><code>walker</code><span> I recently committed</span></div><div data-t="nathanmarz can define your  ALL-MAPS  similarly by handling the different data structure cases in a  cond-path"><span class="u" id="1496423039.459771">2017:06:02 17:03:59           nathanmarz </span><span>can define your </span><code>ALL-MAPS</code><span> similarly by handling the different data structure cases in a </span><code>cond-path</code></div><div data-t="souenzzo (def ALL-MAPS-2
  (recursive-path
    [] p
    (cond-path map? (continue-then-stay MAP-VALS p)
               coll? [ALL p])))
 
I will try to swap in my code."><span class="u" id="1496423616.653577">2017:06:02 17:13:36             souenzzo </span><pre>(def ALL-MAPS-2
  (recursive-path
    [] p
    (cond-path map? (continue-then-stay MAP-VALS p)
               coll? [ALL p])))
</pre><span>
I will try to swap in my code.</span></div><div data-t="wilkerlucio @souenzzo nice catch"><span class="u" id="1496429113.531132">2017:06:02 18:45:13          wilkerlucio </span><span>@souenzzo nice catch</span></div><div data-t="souenzzo (-&gt;&gt; x
(transform [:foo :bar MY-TRANSFORM] inc)
(transform [:foo2 :bar2 MY-TRANSFORM] inc))
 
There is some how to do this with one transoform?"><span class="u" id="1496505690.695364">2017:06:03 16:01:30             souenzzo </span><pre>(-&gt;&gt; x
(transform [:foo :bar MY-TRANSFORM] inc)
(transform [:foo2 :bar2 MY-TRANSFORM] inc))
</pre><span>
There is some how to do this with one transoform?</span></div><div data-t="urbank Try multi-path"><span class="u" id="1496509481.966515">2017:06:03 17:04:41               urbank </span><span>Try multi-path</span></div><div data-t="nathanmarz if you want different transformation functions applied at each path, use  multi-transform  +  terminal /`terminal-val`"><span class="u" id="1496518312.483102">2017:06:03 19:31:52           nathanmarz </span><span>if you want different transformation functions applied at each path, use </span><code>multi-transform</code><span> + </span><code>terminal</code><span>/`terminal-val`</span></div><div data-t="nathanmarz in this case just  multi-path  is fine"><span class="u" id="1496518321.483562">2017:06:03 19:32:01           nathanmarz </span><span>in this case just </span><code>multi-path</code><span> is fine</span></div><div data-t="michaelwfogleman Hm, playing around with specter and really loving it so far. I notice that sometimes I want to get a single value but specter wraps the return in a vector - so I call first on the result - is there a more idiomatic way to do this?"><span class="u" id="1496539840.486261">2017:06:04 01:30:40     michaelwfogleman </span><span>Hm, playing around with specter and really loving it so far. I notice that sometimes I want to get a single value but specter wraps the return in a vector - so I call first on the result - is there a more idiomatic way to do this?</span></div><div data-t="nathanmarz @michaelwfogleman  select-any"><span class="u" id="1496544888.680385">2017:06:04 02:54:48           nathanmarz </span><span>@michaelwfogleman </span><code>select-any</code></div><div data-t="nathanmarz or  select-first"><span class="u" id="1496544897.680681">2017:06:04 02:54:57           nathanmarz </span><span>or </span><code>select-first</code></div><div data-t="nathanmarz those are also much more efficient than  (first (select ...))"><span class="u" id="1496544961.683285">2017:06:04 02:56:01           nathanmarz </span><span>those are also much more efficient than </span><code>(first (select ...))</code></div><div data-t="frankmoyer I’ve really enjoyed working with specter over the past couple of days; its code concision in dealing with nested sequences is beautiful. I’ve run into an issue that has gotten me stuck.

I have a  defnav my-nav  that is returning  [[] [] [[&quot;a&quot; {:x &quot;y&quot;}]]] . I cannot figure out a way to remove the empty sequences from the  defnav  before returning it. I’ve read through recent posts on using  (setval [ALL nil?] NONE m) , however that only works when used outside the  defnav . Also, when I place  FIRST  in a path after  my-nav  like  (select [my-nav FIRST] m) , it removes the empty vectors. However, when I place that  FIRST  at the last part of the navigator within  my-nav , it does not remove them. Any ideas on why specter behaves this way and any way around it?"><span class="u" id="1496849945.246223">2017:06:07 15:39:05           frankmoyer </span><span>I’ve really enjoyed working with specter over the past couple of days; its code concision in dealing with nested sequences is beautiful. I’ve run into an issue that has gotten me stuck.

I have a </span><code>defnav my-nav</code><span> that is returning </span><code>[[] [] [[&quot;a&quot; {:x &quot;y&quot;}]]]</code><span>. I cannot figure out a way to remove the empty sequences from the </span><code>defnav</code><span> before returning it. I’ve read through recent posts on using </span><code>(setval [ALL nil?] NONE m)</code><span>, however that only works when used outside the </span><code>defnav</code><span>. Also, when I place </span><code>FIRST</code><span> in a path after </span><code>my-nav</code><span> like </span><code>(select [my-nav FIRST] m)</code><span>, it removes the empty vectors. However, when I place that </span><code>FIRST</code><span> at the last part of the navigator within </span><code>my-nav</code><span>, it does not remove them. Any ideas on why specter behaves this way and any way around it?</span></div><div data-t="nathanmarz @frankmoyer what is the definition of  my-nav ?"><span class="u" id="1496850445.456643">2017:06:07 15:47:25           nathanmarz </span><span>@frankmoyer what is the definition of </span><code>my-nav</code><span>?</span></div><div data-t="frankmoyer @nathanmarz 

 (sp/defnav previously-assigned-not-finished
  [user get-time completion-time-limit]
  (select* [this structure next-fn]
    (next-fn
      (sp/select
        (sp/selected? ;; return the matching keys-value pairs from this point
          [sp/LAST ;; pick the map value (now in vector form)
           :assignments ;; select :assignments entry
           (sp/must annotator) ;; only the ones assigned to this user
           (sp/selected? ;; pass through the assignments to both next
             [(sp/must :assigned) ;; get the assigned entry
             ;; check that the time limit has not passed
             #(&gt; completion-time-limit (- (get-time) %))])
             (sp/not-selected? ;; exclude when finished
               (sp/multi-path
                 (sp/must :complete)
                 (sp/must :flagged-for-review)
                 (sp/must :incomplete)))])
      structure)))
  (transform* [this structure next-fn]
        (next-fn [structure annotator])))
 

Any other advice is appreciated; I just started working with Specter yesterday."><span class="u" id="1496850612.527342">2017:06:07 15:50:12           frankmoyer </span><span>@nathanmarz 

</span><pre>(sp/defnav previously-assigned-not-finished
  [user get-time completion-time-limit]
  (select* [this structure next-fn]
    (next-fn
      (sp/select
        (sp/selected? ;; return the matching keys-value pairs from this point
          [sp/LAST ;; pick the map value (now in vector form)
           :assignments ;; select :assignments entry
           (sp/must annotator) ;; only the ones assigned to this user
           (sp/selected? ;; pass through the assignments to both next
             [(sp/must :assigned) ;; get the assigned entry
             ;; check that the time limit has not passed
             #(&gt; completion-time-limit (- (get-time) %))])
             (sp/not-selected? ;; exclude when finished
               (sp/multi-path
                 (sp/must :complete)
                 (sp/must :flagged-for-review)
                 (sp/must :incomplete)))])
      structure)))
  (transform* [this structure next-fn]
        (next-fn [structure annotator])))
</pre><span>

Any other advice is appreciated; I just started working with Specter yesterday.</span></div><div data-t="nathanmarz ok, I suspect you don&apos;t want to be using  defnav"><span class="u" id="1496850660.548184">2017:06:07 15:51:00           nathanmarz </span><span>ok, I suspect you don&apos;t want to be using </span><code>defnav</code></div><div data-t="nathanmarz what are you trying to accomplish with that?"><span class="u" id="1496850666.551048">2017:06:07 15:51:06           nathanmarz </span><span>what are you trying to accomplish with that?</span></div><div data-t="nathanmarz there seems to be no relation between the  select*  and  transform*  codepaths"><span class="u" id="1496850680.557010">2017:06:07 15:51:20           nathanmarz </span><span>there seems to be no relation between the </span><code>select*</code><span> and </span><code>transform*</code><span> codepaths</span></div><div data-t="frankmoyer I was hoping not to implement  transform* , as all I really need is a parameterized navigator."><span class="u" id="1496850893.646167">2017:06:07 15:54:53           frankmoyer </span><span>I was hoping not to implement </span><code>transform*</code><span>, as all I really need is a parameterized navigator.</span></div><div data-t="nathanmarz for your select* code, you can just accomplish that with a regular  defn :
 (defn previously-assigned-not-finished-path [user get-time completion-time-limit]
  (path ...)
  )
"><span class="u" id="1496850917.656546">2017:06:07 15:55:17           nathanmarz </span><span>for your select* code, you can just accomplish that with a regular </span><code>defn</code><span>:
</span><pre>(defn previously-assigned-not-finished-path [user get-time completion-time-limit]
  (path ...)
  )
</pre></div><div data-t="nathanmarz and then use it in any  select  or  transform"><span class="u" id="1496850947.669607">2017:06:07 15:55:47           nathanmarz </span><span>and then use it in any </span><code>select</code><span> or </span><code>transform</code></div><div data-t="frankmoyer :+1:"><span class="u" id="1496850955.672658">2017:06:07 15:55:55           frankmoyer </span><b>:+1:</b></div><div data-t="nathanmarz the path itself isn&apos;t navigating anywhere"><span class="u" id="1496850975.681521">2017:06:07 15:56:15           nathanmarz </span><span>the path itself isn&apos;t navigating anywhere</span></div><div data-t="nathanmarz is that what you want?"><span class="u" id="1496850978.682739">2017:06:07 15:56:18           nathanmarz </span><span>is that what you want?</span></div><div data-t="nathanmarz it&apos;s just a filter"><span class="u" id="1496850981.683924">2017:06:07 15:56:21           nathanmarz </span><span>it&apos;s just a filter</span></div><div data-t="nathanmarz selected?  stays navigated if the provided path selects at least one value"><span class="u" id="1496851067.720990">2017:06:07 15:57:47           nathanmarz </span><code>selected?</code><span> stays navigated if the provided path selects at least one value</span></div><div data-t="frankmoyer Yes, it is. I was trying to get more advanced with defining navigators and testing them individually, chaining them together for different filters. Given it is my second day, I think I need to spend a few more cycles with Specter."><span class="u" id="1496851080.726727">2017:06:07 15:58:00           frankmoyer </span><span>Yes, it is. I was trying to get more advanced with defining navigators and testing them individually, chaining them together for different filters. Given it is my second day, I think I need to spend a few more cycles with Specter.</span></div><div data-t="frankmoyer I have been using  selected?  a lot because in a map I want to also return the key."><span class="u" id="1496851129.747592">2017:06:07 15:58:49           frankmoyer </span><span>I have been using </span><code>selected?</code><span> a lot because in a map I want to also return the key.</span></div><div data-t="nathanmarz selected?  has nothing to do with that"><span class="u" id="1496851151.756828">2017:06:07 15:59:11           nathanmarz </span><code>selected?</code><span> has nothing to do with that</span></div><div data-t="nathanmarz if you can simplify your example it will be easier to show you the best way to handle it"><span class="u" id="1496851180.769967">2017:06:07 15:59:40           nathanmarz </span><span>if you can simplify your example it will be easier to show you the best way to handle it</span></div><div data-t="frankmoyer How would you get the full filtered value from the incoming structure?"><span class="u" id="1496851182.770726">2017:06:07 15:59:42           frankmoyer </span><span>How would you get the full filtered value from the incoming structure?</span></div><div data-t="nathanmarz that question is too generic to answer"><span class="u" id="1496851207.783156">2017:06:07 16:00:07           nathanmarz </span><span>that question is too generic to answer</span></div><div data-t="nathanmarz try to come up with a simple representative example of your use case"><span class="u" id="1496851222.790673">2017:06:07 16:00:22           nathanmarz </span><span>try to come up with a simple representative example of your use case</span></div><div data-t="frankmoyer will do. thanks!"><span class="u" id="1496851232.795444">2017:06:07 16:00:32           frankmoyer </span><span>will do. thanks!</span></div><div data-t="souenzzo @nathanmarz It&apos;s missing on docs that on clojurescript you may need to  :require  with  :refer-macros :all"><span class="u" id="1496955435.826835">2017:06:08 20:57:15             souenzzo </span><span>@nathanmarz It&apos;s missing on docs that on clojurescript you may need to </span><code>:require</code><span> with </span><code>:refer-macros :all</code></div><div data-t="nathanmarz @souenzzo please add to  https://github.com/nathanmarz/specter/issues/56"><span class="u" id="1496956804.261667">2017:06:08 21:20:04           nathanmarz </span><span>@souenzzo please add to </span><a href="https://github.com/nathanmarz/specter/issues/56">https://github.com/nathanmarz/specter/issues/56</a></div><div data-t="michaelwfogleman Apparently reagent implements its own form of atom. Does anyone have any experience getting specter to work with reagent atoms?"><span class="u" id="1497027628.292252">2017:06:09 17:00:28     michaelwfogleman </span><span>Apparently reagent implements its own form of atom. Does anyone have any experience getting specter to work with reagent atoms?</span></div><div data-t="nathanmarz @michaelwfogleman i&apos;m unfamiliar with reagent, but it sounds like you could make a navigator for it similar to  ATOM"><span class="u" id="1497029571.955576">2017:06:09 17:32:51           nathanmarz </span><span>@michaelwfogleman i&apos;m unfamiliar with reagent, but it sounds like you could make a navigator for it similar to </span><code>ATOM</code></div><div data-t="nathanmarz Released Specter 1.0.2  https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><span class="u" id="1497285070.261833">2017:06:12 16:31:10           nathanmarz </span><span>Released Specter 1.0.2 </span><a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></div><div data-t="souenzzo For ALL transforms on maps, interpret transformed key/value pair of size &lt; 2 as removal  REAL AWESOME."><span class="u" id="1497290964.433145">2017:06:12 18:09:24             souenzzo </span><code>For ALL transforms on maps, interpret transformed key/value pair of size &lt; 2 as removal</code><span> REAL AWESOME.</span></div><div data-t="tcoupland looking for a &apos;stateful collector&apos;, for merging a sequence of values with a value within a nested structure"><span class="u" id="1497432694.585917">2017:06:14 09:31:34            tcoupland </span><span>looking for a &apos;stateful collector&apos;, for merging a sequence of values with a value within a nested structure</span></div><div data-t="tcoupland something like this:
 (use &apos;com.rpl.specter)

(def o {:a {:x 1}
        :b {:x 1}
        :c {:x 1}})

(def i (range 1 10))

(defcollector putseqval
  [a]
  (collect-val 
   [this structure]
   (let [v (first @a)]
     (swap! a rest)
     v)))

(transform
 [MAP-VALS MAP-VALS (putseqval (atom i))] 
 +
 o);; =&gt; {:a {:x 2}, :b {:x 3}, :c {:x 4}}
"><span class="u" id="1497432704.588332">2017:06:14 09:31:44            tcoupland </span><span>something like this:
</span><pre>(use &apos;com.rpl.specter)

(def o {:a {:x 1}
        :b {:x 1}
        :c {:x 1}})

(def i (range 1 10))

(defcollector putseqval
  [a]
  (collect-val 
   [this structure]
   (let [v (first @a)]
     (swap! a rest)
     v)))

(transform
 [MAP-VALS MAP-VALS (putseqval (atom i))] 
 +
 o);; =&gt; {:a {:x 2}, :b {:x 3}, :c {:x 4}}
</pre></div><div data-t="tcoupland anybody have any better ideas?  🙂"><span class="u" id="1497432726.593983">2017:06:14 09:32:06            tcoupland </span><span>anybody have any better ideas? </span><b>🙂</b></div><div data-t="nathanmarz @tcoupland use  subselect"><span class="u" id="1497450329.409260">2017:06:14 14:25:29           nathanmarz </span><span>@tcoupland use </span><code>subselect</code></div><div data-t="nathanmarz (setval (subselect MAP-VALS MAP-VALS) [2 3 4] o)"><span class="u" id="1497450351.418602">2017:06:14 14:25:51           nathanmarz </span><code>(setval (subselect MAP-VALS MAP-VALS) [2 3 4] o)</code></div><div data-t="tcoupland can i work that into the transform?"><span class="u" id="1497450538.497714">2017:06:14 14:28:58            tcoupland </span><span>can i work that into the transform?</span></div><div data-t="nathanmarz @tcoupland what do you mean?"><span class="u" id="1497450936.668682">2017:06:14 14:35:36           nathanmarz </span><span>@tcoupland what do you mean?</span></div><div data-t="tcoupland i want to execute a function (+) on the value in the datastructure (o) and values from the sequence (i)"><span class="u" id="1497451017.702124">2017:06:14 14:36:57            tcoupland </span><span>i want to execute a function (+) on the value in the datastructure (o) and values from the sequence (i)</span></div><div data-t="nathanmarz transform  on the subselect will be on the sequence of values"><span class="u" id="1497451065.722478">2017:06:14 14:37:45           nathanmarz </span><code>transform</code><span> on the subselect will be on the sequence of values</span></div><div data-t="nathanmarz so you can combine the two sequences easily"><span class="u" id="1497451071.724858">2017:06:14 14:37:51           nathanmarz </span><span>so you can combine the two sequences easily</span></div><div data-t="nathanmarz (transform (subselect MAP-VALS MAP-VALS) (fn [s] (map + s [2 3 4])) o)"><span class="u" id="1497451126.747639">2017:06:14 14:38:46           nathanmarz </span><code>(transform (subselect MAP-VALS MAP-VALS) (fn [s] (map + s [2 3 4])) o)</code></div><div data-t="tcoupland clearly i do not grok subselect  🙂"><span class="u" id="1497451366.847354">2017:06:14 14:42:46            tcoupland </span><span>clearly i do not grok subselect </span><b>🙂</b></div><div data-t="tcoupland thank you nathan  🙇"><span class="u" id="1497451373.850405">2017:06:14 14:42:53            tcoupland </span><span>thank you nathan </span><b>🙇</b></div><div data-t="nathanmarz i recommend toying around with the size of transformed sequence to fully understand its behavior"><span class="u" id="1497451498.902048">2017:06:14 14:44:58           nathanmarz </span><span>i recommend toying around with the size of transformed sequence to fully understand its behavior</span></div><div data-t="tcoupland do collect and subselect play nicely together?"><span class="u" id="1497455665.687236">2017:06:14 15:54:25            tcoupland </span><span>do collect and subselect play nicely together?</span></div><div data-t="tcoupland getting an arity exception in terminal*"><span class="u" id="1497455679.693445">2017:06:14 15:54:39            tcoupland </span><span>getting an arity exception in terminal*</span></div><div data-t="tcoupland for my function i also need the map keys, trying to collect them on the way"><span class="u" id="1497455712.708174">2017:06:14 15:55:12            tcoupland </span><span>for my function i also need the map keys, trying to collect them on the way</span></div><div data-t="tcoupland (transform [(subselect MAP-VALS (collect FIRST FIRST) MAP-VALS)]
           (fn [fnd] (prn (map (fn [[k v] r] (str k v r)) fnd  i))) 
           o)
"><span class="u" id="1497455777.736114">2017:06:14 15:56:17            tcoupland </span><pre>(transform [(subselect MAP-VALS (collect FIRST FIRST) MAP-VALS)]
           (fn [fnd] (prn (map (fn [[k v] r] (str k v r)) fnd  i))) 
           o)
</pre></div><div data-t="tcoupland Wrong number of args (2) passed to:
   specter/fn--38572/fn/reify--38574/fn--38579

                  AFn.java:  429  clojure.lang.AFn/throwArity
                  AFn.java:   36  clojure.lang.AFn/invoke
                  AFn.java:  156  clojure.lang.AFn/applyToHelper
                  AFn.java:  144  clojure.lang.AFn/applyTo
                  core.clj:  657  clojure.core/apply
                  core.clj:  652  clojure.core/apply
                 impl.cljc:  406  com.rpl.specter.impl$terminal_STAR_/invokeStatic
                 impl.cljc:  403  com.rpl.specter.impl$terminal_STAR_/invoke
                 impl.cljc:  413  com.rpl.specter.impl$compiled_transform_STAR_$fn__36780/invoke
              specter.cljc:  673  com.rpl.specter$reify__38443$next_fn__38449/invoke
"><span class="u" id="1497455794.743516">2017:06:14 15:56:34            tcoupland </span><pre>Wrong number of args (2) passed to:
   specter/fn--38572/fn/reify--38574/fn--38579

                  AFn.java:  429  clojure.lang.AFn/throwArity
                  AFn.java:   36  clojure.lang.AFn/invoke
                  AFn.java:  156  clojure.lang.AFn/applyToHelper
                  AFn.java:  144  clojure.lang.AFn/applyTo
                  core.clj:  657  clojure.core/apply
                  core.clj:  652  clojure.core/apply
                 impl.cljc:  406  com.rpl.specter.impl$terminal_STAR_/invokeStatic
                 impl.cljc:  403  com.rpl.specter.impl$terminal_STAR_/invoke
                 impl.cljc:  413  com.rpl.specter.impl$compiled_transform_STAR_$fn__36780/invoke
              specter.cljc:  673  com.rpl.specter$reify__38443$next_fn__38449/invoke
</pre></div><div data-t="tcoupland the prn in the transform function get&apos;s fired and looks right, but then the exception happens"><span class="u" id="1497455821.755205">2017:06:14 15:57:01            tcoupland </span><span>the prn in the transform function get&apos;s fired and looks right, but then the exception happens</span></div><div data-t="tcoupland hm, works in a select, but not in the transform"><span class="u" id="1497456084.873999">2017:06:14 16:01:24            tcoupland </span><span>hm, works in a select, but not in the transform</span></div><div data-t="nathanmarz @tcoupland don&apos;t use value collection in  subselect"><span class="u" id="1497456578.097535">2017:06:14 16:09:38           nathanmarz </span><span>@tcoupland don&apos;t use value collection in </span><code>subselect</code></div><div data-t="nathanmarz i&apos;ll put a note about that in its documentation"><span class="u" id="1497456615.115179">2017:06:14 16:10:15           nathanmarz </span><span>i&apos;ll put a note about that in its documentation</span></div><div data-t="timgilbert Hey, I&apos;ve got a newbie question. I have a big arbitrarily-nested ball of data (vectors, maps, etc). I want to traverse it looking for maps that pass a certain predicate, and then assoc a new key into those maps."><span class="u" id="1497561929.438384">2017:06:15 21:25:29           timgilbert </span><span>Hey, I&apos;ve got a newbie question. I have a big arbitrarily-nested ball of data (vectors, maps, etc). I want to traverse it looking for maps that pass a certain predicate, and then assoc a new key into those maps.</span></div><div data-t="timgilbert Here&apos;s what my current implementation looks like:
 (defn decorate
  &quot;walk/postwalk version of above that adds get urls in-place&quot;
  [data]
  (walk/postwalk
   (fn [item]
     (if-not (right-thing? item)
       item
       (my-transform item)))
   data))
"><span class="u" id="1497561953.444976">2017:06:15 21:25:53           timgilbert </span><span>Here&apos;s what my current implementation looks like:
</span><pre>(defn decorate
  &quot;walk/postwalk version of above that adds get urls in-place&quot;
  [data]
  (walk/postwalk
   (fn [item]
     (if-not (right-thing? item)
       item
       (my-transform item)))
   data))
</pre></div><div data-t="timgilbert Can someone advise me on what the equivalent specter calls would be?"><span class="u" id="1497561983.453185">2017:06:15 21:26:23           timgilbert </span><span>Can someone advise me on what the equivalent specter calls would be?</span></div><div data-t="nathanmarz @timgilbert it would look something like  (setval [(walker right-thing?) :my-new-key] my-new-val data)"><span class="u" id="1497562638.634926">2017:06:15 21:37:18           nathanmarz </span><span>@timgilbert it would look something like </span><code>(setval [(walker right-thing?) :my-new-key] my-new-val data)</code></div><div data-t="nathanmarz or to match your code exactly  (transform (walker right-thing?) my-transform data)"><span class="u" id="1497562827.684895">2017:06:15 21:40:27           nathanmarz </span><span>or to match your code exactly </span><code>(transform (walker right-thing?) my-transform data)</code></div><div data-t="nathanmarz depending on what  my-transform  is you may be able to express it within the path"><span class="u" id="1497562851.691245">2017:06:15 21:40:51           nathanmarz </span><span>depending on what </span><code>my-transform</code><span> is you may be able to express it within the path</span></div><div data-t="timgilbert It&apos;s basically just  (assoc my-map :my/key (other-fn my-map))"><span class="u" id="1497562890.701587">2017:06:15 21:41:30           timgilbert </span><span>It&apos;s basically just </span><code>(assoc my-map :my/key (other-fn my-map))</code></div><div data-t="nathanmarz you can do  (transform [(walker right-thing?) (collect-one (view other-fn)) :my/key] (fn [m _] m) data)"><span class="u" id="1497562980.725292">2017:06:15 21:43:00           nathanmarz </span><span>you can do </span><code>(transform [(walker right-thing?) (collect-one (view other-fn)) :my/key] (fn [m _] m) data)</code></div><div data-t="timgilbert Cool. Thanks for the help, I&apos;ll play around with it some. I&apos;m benchmarking a few different approaches"><span class="u" id="1497563017.734835">2017:06:15 21:43:37           timgilbert </span><span>Cool. Thanks for the help, I&apos;ll play around with it some. I&apos;m benchmarking a few different approaches</span></div><div data-t="nathanmarz the  walker  in latest specter release is a lot faster than clojure.walk and has same functionality"><span class="u" id="1497563064.746826">2017:06:15 21:44:24           nathanmarz </span><span>the </span><code>walker</code><span> in latest specter release is a lot faster than clojure.walk and has same functionality</span></div><div data-t="nathanmarz i benchmarked 70% improvement"><span class="u" id="1497563080.751054">2017:06:15 21:44:40           nathanmarz </span><span>i benchmarked 70% improvement</span></div><div data-t="timgilbert Cool. I&apos;ll let you know how it turns out"><span class="u" id="1497563116.760357">2017:06:15 21:45:16           timgilbert </span><span>Cool. I&apos;ll let you know how it turns out</span></div><div data-t="timgilbert FWIW, I&apos;m seeing about the same speeds on my test data set, which has a lot of stuff I don&apos;t care (about 750K of EDN) about and 0-90 target maps"><span class="u" id="1497564068.000042">2017:06:15 22:01:08           timgilbert </span><span>FWIW, I&apos;m seeing about the same speeds on my test data set, which has a lot of stuff I don&apos;t care (about 750K of EDN) about and 0-90 target maps</span></div><div data-t="nathanmarz care to share your benchmark code?"><span class="u" id="1497564097.006964">2017:06:15 22:01:37           nathanmarz </span><span>care to share your benchmark code?</span></div><div data-t="timgilbert It would take me some time to clean it up and put it into a gist, but I&apos;ll try to do it tomorrow afternoon sometime"><span class="u" id="1497564156.020927">2017:06:15 22:02:36           timgilbert </span><span>It would take me some time to clean it up and put it into a gist, but I&apos;ll try to do it tomorrow afternoon sometime</span></div><div data-t="timgilbert But it&apos;s basically running criterium against a bunch of random data from an EDN file plus a bunch of generated data from specs"><span class="u" id="1497564197.030792">2017:06:15 22:03:17           timgilbert </span><span>But it&apos;s basically running criterium against a bunch of random data from an EDN file plus a bunch of generated data from specs</span></div><div data-t="timgilbert The context is I need to go through a potentially large API response and decorate some data with derived values, and I&apos;m trying to see how much of a perf hit I&apos;m setting myself up for"><span class="u" id="1497564297.054144">2017:06:15 22:04:57           timgilbert </span><span>The context is I need to go through a potentially large API response and decorate some data with derived values, and I&apos;m trying to see how much of a perf hit I&apos;m setting myself up for</span></div><div data-t="nathanmarz i&apos;d be curious to see benchmark of  (transform (walker right-thing?) my-transform data)  approach as well (without using  collect-one )"><span class="u" id="1497564333.063216">2017:06:15 22:05:33           nathanmarz </span><span>i&apos;d be curious to see benchmark of </span><code>(transform (walker right-thing?) my-transform data)</code><span> approach as well (without using </span><code>collect-one</code><span>)</span></div><div data-t="timgilbert Looks like about the same. In my benchmarks I&apos;ve got 0.2927 for the collect-one version, 0.2994 for the transform one and 0.2962 for the postwalk version"><span class="u" id="1497564681.141992">2017:06:15 22:11:21           timgilbert </span><span>Looks like about the same. In my benchmarks I&apos;ve got 0.2927 for the collect-one version, 0.2994 for the transform one and 0.2962 for the postwalk version</span></div><div data-t="timgilbert (I&apos;m not going absolutely crazy with the methodology here, I should note, just looking for back-of-the-envelope stuff)"><span class="u" id="1497564729.152535">2017:06:15 22:12:09           timgilbert </span><span>(I&apos;m not going absolutely crazy with the methodology here, I should note, just looking for back-of-the-envelope stuff)</span></div><div data-t="nathanmarz if your target maps are never within another map&apos;s keys, you can gain big performance improvement by using a custom recursive path"><span class="u" id="1497564781.163782">2017:06:15 22:13:01           nathanmarz </span><span>if your target maps are never within another map&apos;s keys, you can gain big performance improvement by using a custom recursive path</span></div><div data-t="timgilbert Sadly, they are deeply and somewhat arbitrarily nested"><span class="u" id="1497564812.170861">2017:06:15 22:13:32           timgilbert </span><span>Sadly, they are deeply and somewhat arbitrarily nested</span></div><div data-t="timgilbert (Which is something I&apos;m looking to fix but that&apos;s another story)"><span class="u" id="1497564827.174274">2017:06:15 22:13:47           timgilbert </span><span>(Which is something I&apos;m looking to fix but that&apos;s another story)</span></div><div data-t="nathanmarz (def optimized-walker
  (recursive-path [afn] p
    (cond-path (pred afn) STAY
               map? [MAP-VALS p]
               coll? [ALL p]
               )))
"><span class="u" id="1497564828.174570">2017:06:15 22:13:48           nathanmarz </span><pre>(def optimized-walker
  (recursive-path [afn] p
    (cond-path (pred afn) STAY
               map? [MAP-VALS p]
               coll? [ALL p]
               )))
</pre></div><div data-t="nathanmarz the data has maps within map keys?"><span class="u" id="1497564844.178087">2017:06:15 22:14:04           nathanmarz </span><span>the data has maps within map keys?</span></div><div data-t="nathanmarz e.g.  {[{:a 1}] 2}"><span class="u" id="1497564863.182269">2017:06:15 22:14:23           nathanmarz </span><span>e.g. </span><code>{[{:a 1}] 2}</code></div><div data-t="timgilbert Yeah, so it could be like  {:company &quot;foo&quot; :people [{:person &quot;bob&quot; :avatar {:type :thumbnail :image-path &quot;/dir/file.png&quot;}}]}"><span class="u" id="1497564943.199702">2017:06:15 22:15:43           timgilbert </span><span>Yeah, so it could be like </span><code>{:company &quot;foo&quot; :people [{:person &quot;bob&quot; :avatar {:type :thumbnail :image-path &quot;/dir/file.png&quot;}}]}</code></div><div data-t="timgilbert I&apos;m looking for  :image-path"><span class="u" id="1497564955.202342">2017:06:15 22:15:55           timgilbert </span><span>I&apos;m looking for </span><code>:image-path</code></div><div data-t="timgilbert But it could also be  {:product &quot;foo&quot; :images [{:type :product-img :image-path &quot;foo-bar&quot;}]}"><span class="u" id="1497565004.212707">2017:06:15 22:16:44           timgilbert </span><span>But it could also be </span><code>{:product &quot;foo&quot; :images [{:type :product-img :image-path &quot;foo-bar&quot;}]}</code></div><div data-t="nathanmarz yea, use  optimized-walker"><span class="u" id="1497565012.214365">2017:06:15 22:16:52           nathanmarz </span><span>yea, use </span><code>optimized-walker</code></div><div data-t="timgilbert ...and those things can all nest in various ways"><span class="u" id="1497565015.215001">2017:06:15 22:16:55           timgilbert </span><span>...and those things can all nest in various ways</span></div><div data-t="nathanmarz avoiding traversing over key/value pairs and keys should be very significant"><span class="u" id="1497565039.220274">2017:06:15 22:17:19           nathanmarz </span><span>avoiding traversing over key/value pairs and keys should be very significant</span></div><div data-t="timgilbert Cool. Thanks again for the help. I&apos;ll play around with it more tomorrow and let you know if I kick up anything interesting"><span class="u" id="1497565074.227744">2017:06:15 22:17:54           timgilbert </span><span>Cool. Thanks again for the help. I&apos;ll play around with it more tomorrow and let you know if I kick up anything interesting</span></div><div data-t="nathanmarz sure thing"><span class="u" id="1497565102.233628">2017:06:15 22:18:22           nathanmarz </span><span>sure thing</span></div><div data-t="enn Hello … I’m wondering if I’m missing an obvious way to do sorting and/or selecting minimum/maximum values with Specter? I think I could do it with  view  or  transformed  and a function that takes  the whole array and just does the min/max in Clojure, but is there a more Specter-y (spectral?) way?"><span class="u" id="1498751608.236636">2017:06:29 15:53:28                  enn </span><span>Hello … I’m wondering if I’m missing an obvious way to do sorting and/or selecting minimum/maximum values with Specter? I think I could do it with </span><code>view</code><span> or </span><code>transformed</code><span> and a function that takes  the whole array and just does the min/max in Clojure, but is there a more Specter-y (spectral?) way?</span></div><div data-t="enn Hmm, it looks like  view  or  transformed  will not do what I want because the provided functions get applied to each value matching my  ALL  selector, rather than the sequence of matching values."><span class="u" id="1498752237.514462">2017:06:29 16:03:57                  enn </span><span>Hmm, it looks like </span><code>view</code><span> or </span><code>transformed</code><span> will not do what I want because the provided functions get applied to each value matching my </span><code>ALL</code><span> selector, rather than the sequence of matching values.</span></div><div data-t="nathanmarz @enn if it&apos;s not already sorted in your data structure, you would need to do  (view sort)"><span class="u" id="1498752442.607871">2017:06:29 16:07:22           nathanmarz </span><span>@enn if it&apos;s not already sorted in your data structure, you would need to do </span><code>(view sort)</code></div><div data-t="nathanmarz if the values are spread throughout your data structure (not together in a sequence), you can first do  (subselect &lt;path&gt;)   to manipulate them as a single sequence"><span class="u" id="1498752493.631028">2017:06:29 16:08:13           nathanmarz </span><span>if the values are spread throughout your data structure (not together in a sequence), you can first do </span><code>(subselect &lt;path&gt;)</code><span>  to manipulate them as a single sequence</span></div><div data-t="enn @nathanmarz aha, thank you, I will look at  subselect"><span class="u" id="1498752629.698004">2017:06:29 16:10:29                  enn </span><span>@nathanmarz aha, thank you, I will look at </span><code>subselect</code></div><div data-t="sophiago Not expecting an answer today, but figured I&apos;d put this out there since I couldn&apos;t figure it out from the wiki this weekend: is there a way to just call  select  on a sequence of keys? I would expect to at least be able to do something like this unless there&apos;s a simpler way, but it returns all kv pairs:  (select [ALL (fn [[k v]] (map #(= k %) [2 3]))] {1 :a, 2 :b, 3, :c, 4 :d})"><span class="u" id="1499206934.862154">2017:07:04 22:22:14             sophiago </span><span>Not expecting an answer today, but figured I&apos;d put this out there since I couldn&apos;t figure it out from the wiki this weekend: is there a way to just call </span><code>select</code><span> on a sequence of keys? I would expect to at least be able to do something like this unless there&apos;s a simpler way, but it returns all kv pairs: </span><code>(select [ALL (fn [[k v]] (map #(= k %) [2 3]))] {1 :a, 2 :b, 3, :c, 4 :d})</code></div><div data-t="sophiago I&apos;m also wondering if, after selecting based on keys, Specter has a faster way to return just the values than  val  from clojure.core?"><span class="u" id="1499207007.869736">2017:07:04 22:23:27             sophiago </span><span>I&apos;m also wondering if, after selecting based on keys, Specter has a faster way to return just the values than </span><code>val</code><span> from clojure.core?</span></div><div data-t="nathanmarz @sophiago I think you&apos;re looking for  (select [(submap [2 3]) MAP-VALS] {1 :a 2 :b 3 :c 4 :d})"><span class="u" id="1499208998.072716">2017:07:04 22:56:38           nathanmarz </span><span>@sophiago I think you&apos;re looking for </span><code>(select [(submap [2 3]) MAP-VALS] {1 :a 2 :b 3 :c 4 :d})</code></div><div data-t="nathanmarz or possibly  (select (multi-path (keypath 2) (keypath 3)) {1 :a 2 :b 3 :c 4 :d})"><span class="u" id="1499209030.076122">2017:07:04 22:57:10           nathanmarz </span><span>or possibly </span><code>(select (multi-path (keypath 2) (keypath 3)) {1 :a 2 :b 3 :c 4 :d})</code></div><div data-t="sophiago Thanks for responding, Nathan! Probably the first one, unless there&apos;s a performance difference?"><span class="u" id="1499209064.079652">2017:07:04 22:57:44             sophiago </span><span>Thanks for responding, Nathan! Probably the first one, unless there&apos;s a performance difference?</span></div><div data-t="nathanmarz the latter should be faster"><span class="u" id="1499209081.081360">2017:07:04 22:58:01           nathanmarz </span><span>the latter should be faster</span></div><div data-t="nathanmarz but the former works with a dynamic sequence of keys"><span class="u" id="1499209093.082511">2017:07:04 22:58:13           nathanmarz </span><span>but the former works with a dynamic sequence of keys</span></div><div data-t="sophiago Can&apos;t I just map keypath over a sequence of keys?"><span class="u" id="1499209120.085146">2017:07:04 22:58:40             sophiago </span><span>Can&apos;t I just map keypath over a sequence of keys?</span></div><div data-t="nathanmarz yes, but that won&apos;t perform optimally at the moment"><span class="u" id="1499209157.088794">2017:07:04 22:59:17           nathanmarz </span><span>yes, but that won&apos;t perform optimally at the moment</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/issues/200"><span class="u" id="1499209158.088871">2017:07:04 22:59:18           nathanmarz </span><a href="https://github.com/nathanmarz/specter/issues/200">https://github.com/nathanmarz/specter/issues/200</a></div><div data-t="nathanmarz both  keypath  and  multi-path  are dynamic navs"><span class="u" id="1499209170.090117">2017:07:04 22:59:30           nathanmarz </span><span>both </span><code>keypath</code><span> and </span><code>multi-path</code><span> are dynamic navs</span></div><div data-t="sophiago I see. So the fastest way is with  submap  until that issue is closed?"><span class="u" id="1499209224.096844">2017:07:04 23:00:24             sophiago </span><span>I see. So the fastest way is with </span><code>submap</code><span> until that issue is closed?</span></div><div data-t="nathanmarz you&apos;d have to benchmark to be sure, but that would be my guess"><span class="u" id="1499209252.100184">2017:07:04 23:00:52           nathanmarz </span><span>you&apos;d have to benchmark to be sure, but that would be my guess</span></div><div data-t="sophiago Great. Thanks!"><span class="u" id="1499209266.101706">2017:07:04 23:01:06             sophiago </span><span>Great. Thanks!</span></div><div data-t="nathanmarz actually"><span class="u" id="1499209275.102780">2017:07:04 23:01:15           nathanmarz </span><span>actually</span></div><div data-t="nathanmarz you can do this:  (map #(select-any (keypath %) data) key-seq)"><span class="u" id="1499209312.106725">2017:07:04 23:01:52           nathanmarz </span><span>you can do this: </span><code>(map #(select-any (keypath %) data) key-seq)</code></div><div data-t="nathanmarz nevermind"><span class="u" id="1499209340.109642">2017:07:04 23:02:20           nathanmarz </span><span>nevermind</span></div><div data-t="nathanmarz if performance is critical just do  (map #(get data %) key-seq)"><span class="u" id="1499209360.111543">2017:07:04 23:02:40           nathanmarz </span><span>if performance is critical just do </span><code>(map #(get data %) key-seq)</code></div><div data-t="sophiago Ok, got it. I&apos;ll run some microbenchmarks to be sure as well."><span class="u" id="1499209514.128642">2017:07:04 23:05:14             sophiago </span><span>Ok, got it. I&apos;ll run some microbenchmarks to be sure as well.</span></div><div data-t="mbjarland lets say I have the following data structure: 
 {:2010-12-31 [{:name &quot;New Year&apos;s Eve&quot;, :date &quot;2010-12-31&quot;, :observed &quot;2010-12-31&quot;, :public true}],
 :2010-12-25 [{:name &quot;Christmas Day&quot;, :date &quot;2010-12-25&quot;, :observed &quot;2010-12-24&quot;, :public true}],
 :2010-05-31 [{:name &quot;Memorial Day&quot;, :date &quot;2010-05-31&quot;, :observed &quot;2010-05-31&quot;, :public true}],
 :2010-11-25 [{:name &quot;Thanksgiving Day&quot;, :date &quot;2010-11-25&quot;, :observed &quot;2010-11-25&quot;, :public true}],
 :2010-09-06 [{:name &quot;Labor Day&quot;, :date &quot;2010-09-06&quot;, :observed &quot;2010-09-06&quot;, :public true}],
 :2010-01-01 [{:name &quot;New Year&apos;s Day&quot;, :date &quot;2010-01-01&quot;, :observed &quot;2010-01-01&quot;, :public true}],
 :2010-07-04 [{:name &quot;Independence Day&quot;, :date &quot;2010-07-04&quot;, :observed &quot;2010-07-05&quot;, :public true}],
 :2010-11-11 [{:name &quot;Veterans Day&quot;, :date &quot;2010-11-11&quot;, :observed &quot;2010-11-11&quot;, :public true}],
 :2010-02-15 [{:name &quot;George Washington&apos;s Birthday&quot;, :date &quot;2010-02-15&quot;, :observed &quot;2010-02-15&quot;, :public true}],
 :2010-01-18 [{:name &quot;Martin Luther King, Jr. Day&quot;, :date &quot;2010-01-18&quot;, :observed &quot;2010-01-18&quot;, :public true}],
 :2010-10-11 [{:name &quot;Columbus Day&quot;, :date &quot;2010-10-11&quot;, :observed &quot;2010-10-11&quot;, :public true}]}
 
and I would like to apply a function to all the dates (root level key and  :date  and  :observed  in the inner map). I got as far as using  multi-transform  on the root level keys but I&apos;m failing at writing the rest of the path expression. I can do the first level with: 
 (multi-transform [MAP-KEYS (terminal my-tranform-fn)] data)
 
how would I go about transforming the other two dates in the data?"><span class="u" id="1499780585.060676">2017:07:11 13:43:05            mbjarland </span><span>lets say I have the following data structure: 
</span><pre>{:2010-12-31 [{:name &quot;New Year&apos;s Eve&quot;, :date &quot;2010-12-31&quot;, :observed &quot;2010-12-31&quot;, :public true}],
 :2010-12-25 [{:name &quot;Christmas Day&quot;, :date &quot;2010-12-25&quot;, :observed &quot;2010-12-24&quot;, :public true}],
 :2010-05-31 [{:name &quot;Memorial Day&quot;, :date &quot;2010-05-31&quot;, :observed &quot;2010-05-31&quot;, :public true}],
 :2010-11-25 [{:name &quot;Thanksgiving Day&quot;, :date &quot;2010-11-25&quot;, :observed &quot;2010-11-25&quot;, :public true}],
 :2010-09-06 [{:name &quot;Labor Day&quot;, :date &quot;2010-09-06&quot;, :observed &quot;2010-09-06&quot;, :public true}],
 :2010-01-01 [{:name &quot;New Year&apos;s Day&quot;, :date &quot;2010-01-01&quot;, :observed &quot;2010-01-01&quot;, :public true}],
 :2010-07-04 [{:name &quot;Independence Day&quot;, :date &quot;2010-07-04&quot;, :observed &quot;2010-07-05&quot;, :public true}],
 :2010-11-11 [{:name &quot;Veterans Day&quot;, :date &quot;2010-11-11&quot;, :observed &quot;2010-11-11&quot;, :public true}],
 :2010-02-15 [{:name &quot;George Washington&apos;s Birthday&quot;, :date &quot;2010-02-15&quot;, :observed &quot;2010-02-15&quot;, :public true}],
 :2010-01-18 [{:name &quot;Martin Luther King, Jr. Day&quot;, :date &quot;2010-01-18&quot;, :observed &quot;2010-01-18&quot;, :public true}],
 :2010-10-11 [{:name &quot;Columbus Day&quot;, :date &quot;2010-10-11&quot;, :observed &quot;2010-10-11&quot;, :public true}]}
</pre><span>
and I would like to apply a function to all the dates (root level key and </span><code>:date</code><span> and </span><code>:observed</code><span> in the inner map). I got as far as using </span><code>multi-transform</code><span> on the root level keys but I&apos;m failing at writing the rest of the path expression. I can do the first level with: 
</span><pre>(multi-transform [MAP-KEYS (terminal my-tranform-fn)] data)
</pre><span>
how would I go about transforming the other two dates in the data?</span></div><div data-t="mbjarland ok I think I got it, somebody please tell me if there is a better way: 
 (multi-transform [(multi-path [MAP-VALS ALL (multi-path [:date (terminal my-transform-fn)]
                                                        [:observed (terminal my-transform-fn)])]
                              [MAP-KEYS (terminal my-transform-fn)])] data)
"><span class="u" id="1499781202.422762">2017:07:11 13:53:22            mbjarland </span><span>ok I think I got it, somebody please tell me if there is a better way: 
</span><pre>(multi-transform [(multi-path [MAP-VALS ALL (multi-path [:date (terminal my-transform-fn)]
                                                        [:observed (terminal my-transform-fn)])]
                              [MAP-KEYS (terminal my-transform-fn)])] data)
</pre></div><div data-t="nathanmarz @mbjarland this is better:  (transform (multi-path MAP-KEYS [MAP-VALS ALL (multi-path :date :observed)]) my-transform-fn data)"><span class="u" id="1499782376.147268">2017:07:11 14:12:56           nathanmarz </span><span>@mbjarland this is better: </span><code>(transform (multi-path MAP-KEYS [MAP-VALS ALL (multi-path :date :observed)]) my-transform-fn data)</code></div><div data-t="nathanmarz multi-transform  is more for when you have distinct transformations you want to run on the same structure"><span class="u" id="1499782522.237855">2017:07:11 14:15:22           nathanmarz </span><code>multi-transform</code><span> is more for when you have distinct transformations you want to run on the same structure</span></div><div data-t="mbjarland : ) figured there would be a better way...so just  transform ....when would I use  multi-transform ?"><span class="u" id="1499782627.303720">2017:07:11 14:17:07            mbjarland </span><span>: ) figured there would be a better way...so just </span><code>transform</code><span>....when would I use </span><code>multi-transform</code><span>?</span></div><div data-t="nathanmarz e.g.  (multi-transform [ALL (multi-path [:a (terminal inc)] [:b (terminal dec)])] data)"><span class="u" id="1499782684.340005">2017:07:11 14:18:04           nathanmarz </span><span>e.g. </span><code>(multi-transform [ALL (multi-path [:a (terminal inc)] [:b (terminal dec)])] data)</code></div><div data-t="nathanmarz another good example:  https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L342"><span class="u" id="1499782715.359112">2017:07:11 14:18:35           nathanmarz </span><span>another good example: </span><a href="https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L342">https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L342</a></div><div data-t="nathanmarz if the transformation functions are distinct and there&apos;s any shared navigation,  multi-transform  will be more efficient"><span class="u" id="1499782741.375506">2017:07:11 14:19:01           nathanmarz </span><span>if the transformation functions are distinct and there&apos;s any shared navigation, </span><code>multi-transform</code><span> will be more efficient</span></div><div data-t="mbjarland ah so forking paths which shared ancestry are a good candidate"><span class="u" id="1499782805.415646">2017:07:11 14:20:05            mbjarland </span><span>ah so forking paths which shared ancestry are a good candidate</span></div><div data-t="nathanmarz in your case each date location is transformed the same way, so cleaner to navigate to each date as a single path"><span class="u" id="1499782805.415945">2017:07:11 14:20:05           nathanmarz </span><span>in your case each date location is transformed the same way, so cleaner to navigate to each date as a single path</span></div><div data-t="nathanmarz yes, that&apos;s right"><span class="u" id="1499782814.420888">2017:07:11 14:20:14           nathanmarz </span><span>yes, that&apos;s right</span></div><div data-t="mbjarland ok, got it...it seems to me every time I find an excuse to use specter a couple of things happen 1. half my code goes away 2. the end result is beautiful 3. I realize that at least for me, most of the hurdle in specter is to grok paths. Thanks for the pointers"><span class="u" id="1499782899.474660">2017:07:11 14:21:39            mbjarland </span><span>ok, got it...it seems to me every time I find an excuse to use specter a couple of things happen 1. half my code goes away 2. the end result is beautiful 3. I realize that at least for me, most of the hurdle in specter is to grok paths. Thanks for the pointers</span></div><div data-t="nathanmarz 🙂"><span class="u" id="1499782923.489434">2017:07:11 14:22:03           nathanmarz </span><b>🙂</b></div><div data-t="schmee I’m sure this has been asked a million times, but can I use Specter to go from  [{:a 1 :b 2} {:a 3 :b 4}]  to  {:a [1 3] :b [2 4]} ?"><span class="u" id="1499784418.464753">2017:07:11 14:46:58               schmee </span><span>I’m sure this has been asked a million times, but can I use Specter to go from </span><code>[{:a 1 :b 2} {:a 3 :b 4}]</code><span> to </span><code>{:a [1 3] :b [2 4]}</code><span>?</span></div><div data-t="nathanmarz @schmee that&apos;s a complete transformation, so should do that with  reduce"><span class="u" id="1499791569.989869">2017:07:11 16:46:09           nathanmarz </span><span>@schmee that&apos;s a complete transformation, so should do that with </span><code>reduce</code></div><div data-t="madstap @schmee I remember seeing a one liner for that that was something like:  (defn f [ms] (apply merge-with into (for [m ms, [k v] m] {k [v]})))"><span class="u" id="1499791796.120699">2017:07:11 16:49:56              madstap </span><span>@schmee I remember seeing a one liner for that that was something like: </span><code>(defn f [ms] (apply merge-with into (for [m ms, [k v] m] {k [v]})))</code></div><div data-t="schmee roger, thanks for the input  :+1:"><span class="u" id="1499794152.474465">2017:07:11 17:29:12               schmee </span><span>roger, thanks for the input </span><b>:+1:</b></div><div data-t="schmee is there a know issue with  transform  and transients?"><span class="u" id="1499816144.833981">2017:07:11 23:35:44               schmee </span><span>is there a know issue with </span><code>transform</code><span> and transients?</span></div><div data-t="schmee I’m getting 
 java.lang.IllegalAccessError: Transient used after persistent! call
	at clojure.lang.PersistentVector$TransientVector.ensureEditable(PersistentVector.java:548)
	at clojure.lang.PersistentVector$TransientVector.persistent(PersistentVector.java:559)
	at clojure.lang.PersistentVector$TransientVector.persistent(PersistentVector.java:518)
	at clojure.core$persistent_BANG_.invokeStatic(core.clj:3336)
	at clojure.core$persistent_BANG_.invoke(core.clj:3329)
	at com.rpl.specter.impl$terminal_STAR_.invokeStatic(impl.cljc:402)
	at com.rpl.specter.impl$terminal_STAR_.invoke(impl.cljc:400)
	at com.rpl.specter.impl$compiled_transform_STAR_$fn__16689.invoke(impl.cljc:410)
	at com.rpl.specter$reify__18110$next_fn__18116.invoke(specter.cljc:642)
	at com.rpl.specter.navs$eval17464$fn__17465.invoke(navs.cljc:261)
	at com.rpl.specter.navs$eval17420$fn__17421$G__17409__17428.invoke(navs.cljc:213)
	at com.rpl.specter$reify__18110.transform_STAR_(specter.cljc:651)
	at com.rpl.specter.impl$compiled_transform_STAR_.invokeStatic(impl.cljc:408)
	at com.rpl.specter.impl$compiled_transform_STAR_.invoke(impl.cljc:407)
 
when using  (s/transform s/MAP-VALS persistent! stuff)"><span class="u" id="1499816192.845352">2017:07:11 23:36:32               schmee </span><span>I’m getting 
</span><pre>java.lang.IllegalAccessError: Transient used after persistent! call
	at clojure.lang.PersistentVector$TransientVector.ensureEditable(PersistentVector.java:548)
	at clojure.lang.PersistentVector$TransientVector.persistent(PersistentVector.java:559)
	at clojure.lang.PersistentVector$TransientVector.persistent(PersistentVector.java:518)
	at clojure.core$persistent_BANG_.invokeStatic(core.clj:3336)
	at clojure.core$persistent_BANG_.invoke(core.clj:3329)
	at com.rpl.specter.impl$terminal_STAR_.invokeStatic(impl.cljc:402)
	at com.rpl.specter.impl$terminal_STAR_.invoke(impl.cljc:400)
	at com.rpl.specter.impl$compiled_transform_STAR_$fn__16689.invoke(impl.cljc:410)
	at com.rpl.specter$reify__18110$next_fn__18116.invoke(specter.cljc:642)
	at com.rpl.specter.navs$eval17464$fn__17465.invoke(navs.cljc:261)
	at com.rpl.specter.navs$eval17420$fn__17421$G__17409__17428.invoke(navs.cljc:213)
	at com.rpl.specter$reify__18110.transform_STAR_(specter.cljc:651)
	at com.rpl.specter.impl$compiled_transform_STAR_.invokeStatic(impl.cljc:408)
	at com.rpl.specter.impl$compiled_transform_STAR_.invoke(impl.cljc:407)
</pre><span>
when using </span><code>(s/transform s/MAP-VALS persistent! stuff)</code></div><div data-t="schmee where  stuff  is a map of keyword to transient vectors"><span class="u" id="1499816222.852531">2017:07:11 23:37:02               schmee </span><span>where </span><code>stuff</code><span> is a map of keyword to transient vectors</span></div><div data-t="nathanmarz @schmee looks fine to me:
 (transform MAP-VALS persistent! {1 (transient []) 2 (transient [1 2 3])})
;; =&gt; {1 [], 2 [1 2 3]}
"><span class="u" id="1499822419.205707">2017:07:12 01:20:19           nathanmarz </span><span>@schmee looks fine to me:
</span><pre>(transform MAP-VALS persistent! {1 (transient []) 2 (transient [1 2 3])})
;; =&gt; {1 [], 2 [1 2 3]}
</pre></div><div data-t="nathanmarz there must be another issue with your code"><span class="u" id="1499822457.213155">2017:07:12 01:20:57           nathanmarz </span><span>there must be another issue with your code</span></div><div data-t="schmee hmm… weird, I’ll see if I can find a minimal case"><span class="u" id="1499843643.142526">2017:07:12 07:14:03               schmee </span><span>hmm… weird, I’ll see if I can find a minimal case</span></div><div data-t="schmee Two questions:
1. is it possible to return a “subpath” of a path from  transform ? e.g.  transform [(submap [:a :c]) MAP-VALS] inc {:a 1 :b 2 :c 3}  returns  {:a 2 :b 2 :c 4} , can you modify the path somehow to make it return  {:a 2 :c 4} ?
2. can you “invert” a path? e.g. to make  (some-invert-fn (submap [:a :c]))  navigate to the map without  :a  and  :c"><span class="u" id="1499848400.707454">2017:07:12 08:33:20               schmee </span><span>Two questions:
1. is it possible to return a “subpath” of a path from </span><code>transform</code><span>? e.g. </span><code>transform [(submap [:a :c]) MAP-VALS] inc {:a 1 :b 2 :c 3}</code><span> returns </span><code>{:a 2 :b 2 :c 4}</code><span>, can you modify the path somehow to make it return </span><code>{:a 2 :c 4}</code><span>?
2. can you “invert” a path? e.g. to make </span><code>(some-invert-fn (submap [:a :c]))</code><span> navigate to the map without </span><code>:a</code><span> and </span><code>:c</code></div><div data-t="souenzzo @schmee take a look on &quot;select&quot; and on &quot;if-path&quot;"><span class="u" id="1499861586.213223">2017:07:12 12:13:06             souenzzo </span><span>@schmee take a look on &quot;select&quot; and on &quot;if-path&quot;</span></div><div data-t="schmee could you give a more concrete example on how those would help me?"><span class="u" id="1499861654.237513">2017:07:12 12:14:14               schmee </span><span>could you give a more concrete example on how those would help me?</span></div><div data-t="souenzzo I&apos;m on mobile. When I arrive I&apos;ll do one"><span class="u" id="1499861745.270294">2017:07:12 12:15:45                  souenzzo </span><span>I&apos;m on mobile. When I arrive I&apos;ll do one</span></div><div data-t="schmee cheers  :+1:"><span class="u" id="1499861765.277387">2017:07:12 12:16:05                    schmee </span><span>cheers </span><b>:+1:</b></div><div data-t="schmee AFAIK  select  always returns a sequence and doesn’t modify the original structure"><span class="u" id="1499861680.246831">2017:07:12 12:14:40               schmee </span><span>AFAIK </span><code>select</code><span> always returns a sequence and doesn’t modify the original structure</span></div><div data-t="nathanmarz @schmee you can do  (view #(select-keys % [:a :c]))"><span class="u" id="1499866258.306742">2017:07:12 13:30:58           nathanmarz </span><span>@schmee you can do </span><code>(view #(select-keys % [:a :c]))</code></div><div data-t="nathanmarz for #2, that would need to be another navigator"><span class="u" id="1499866384.376747">2017:07:12 13:33:04           nathanmarz </span><span>for #2, that would need to be another navigator</span></div><div data-t="schmee ahh,  view  is the one!"><span class="u" id="1499866454.414860">2017:07:12 13:34:14               schmee </span><span>ahh, </span><code>view</code><span> is the one!</span></div><div data-t="schmee is there a version of  view  that takes a path?"><span class="u" id="1499866461.418813">2017:07:12 13:34:21               schmee </span><span>is there a version of </span><code>view</code><span> that takes a path?</span></div><div data-t="nathanmarz no, it just takes a function"><span class="u" id="1499866476.427269">2017:07:12 13:34:36           nathanmarz </span><span>no, it just takes a function</span></div><div data-t="schmee my intuition was that  transformed  was the path equivalent"><span class="u" id="1499866493.436643">2017:07:12 13:34:53               schmee </span><span>my intuition was that </span><code>transformed</code><span> was the path equivalent</span></div><div data-t="nathanmarz yes, that&apos;s right"><span class="u" id="1499866501.441223">2017:07:12 13:35:01           nathanmarz </span><span>yes, that&apos;s right</span></div><div data-t="nathanmarz forgot about that"><span class="u" id="1499866515.448906">2017:07:12 13:35:15           nathanmarz </span><span>forgot about that</span></div><div data-t="schmee user=&gt; (s/transform [(s/transformed (s/submap [:a :c]) identity) s/MAP-VALS] inc {:a 1 :b 2 :c 3})
{:a 2 :b 3 :c 4}
"><span class="u" id="1499866526.455120">2017:07:12 13:35:26               schmee </span><pre>user=&gt; (s/transform [(s/transformed (s/submap [:a :c]) identity) s/MAP-VALS] inc {:a 1 :b 2 :c 3})
{:a 2 :b 3 :c 4}
</pre></div><div data-t="schmee seems like that would be equivalent to the  view  version?"><span class="u" id="1499866609.501908">2017:07:12 13:36:49               schmee </span><span>seems like that would be equivalent to the </span><code>view</code><span> version?</span></div><div data-t="nathanmarz no, that doesn&apos;t remove :b"><span class="u" id="1499866837.629933">2017:07:12 13:40:37           nathanmarz </span><span>no, that doesn&apos;t remove :b</span></div><div data-t="nathanmarz (transformed (submap [:a :c]) identity)  is a no-op"><span class="u" id="1499866854.639999">2017:07:12 13:40:54           nathanmarz </span><code>(transformed (submap [:a :c]) identity)</code><span> is a no-op</span></div><div data-t="nathanmarz (transformed (submap [:a :c]) (fn [_] nil))  would remove :a and :c"><span class="u" id="1499866889.659494">2017:07:12 13:41:29           nathanmarz </span><code>(transformed (submap [:a :c]) (fn [_] nil))</code><span> would remove :a and :c</span></div><div data-t="schmee ahh, right!"><span class="u" id="1499866905.668776">2017:07:12 13:41:45               schmee </span><span>ahh, right!</span></div><div data-t="schmee thank you for your patience in answering all these question, I appreciate it!"><span class="u" id="1499866924.679778">2017:07:12 13:42:04               schmee </span><span>thank you for your patience in answering all these question, I appreciate it!</span></div><div data-t="nathanmarz no problem, happy to help"><span class="u" id="1499866956.697456">2017:07:12 13:42:36           nathanmarz </span><span>no problem, happy to help</span></div><div data-t="drowsy While toying around I stumbled over something strange. When using select a MapEntry is handled as MapEntry while when using transform is a Vector. So  (select [ALL (pred key)] {:a 1})  =&gt;  [[:a 1]]  while  (transform [ALL (pred key)] identity {:a 1})  throws a ClassCastException"><span class="u" id="1499879358.530022">2017:07:12 17:09:18               drowsy </span><span>While toying around I stumbled over something strange. When using select a MapEntry is handled as MapEntry while when using transform is a Vector. So </span><code>(select [ALL (pred key)] {:a 1})</code><span> =&gt; </span><code>[[:a 1]]</code><span> while </span><code>(transform [ALL (pred key)] identity {:a 1})</code><span> throws a ClassCastException</span></div><div data-t="drowsy I know this path is not useful, but I&apos;m just curious if this is &quot;working as intended&quot; as select and transform differs"><span class="u" id="1499879658.700574">2017:07:12 17:14:18               drowsy </span><span>I know this path is not useful, but I&apos;m just curious if this is &quot;working as intended&quot; as select and transform differs</span></div><div data-t="nathanmarz @drowsy that&apos;s a good observation"><span class="u" id="1499882048.090202">2017:07:12 17:54:08           nathanmarz </span><span>@drowsy that&apos;s a good observation</span></div><div data-t="nathanmarz it&apos;s because  select  does a  reduce  over the map, while  transform  accesses the keys/vals using direct means"><span class="u" id="1499882120.133436">2017:07:12 17:55:20           nathanmarz </span><span>it&apos;s because </span><code>select</code><span> does a </span><code>reduce</code><span> over the map, while </span><code>transform</code><span> accesses the keys/vals using direct means</span></div><div data-t="nathanmarz while it would be nice to be consistent, it&apos;s not really important"><span class="u" id="1499882300.241228">2017:07:12 17:58:20           nathanmarz </span><span>while it would be nice to be consistent, it&apos;s not really important</span></div><div data-t="nathanmarz (since there would be a slight performance penalty to do a conversion somewhere)"><span class="u" id="1499882346.269041">2017:07:12 17:59:06           nathanmarz </span><span>(since there would be a slight performance penalty to do a conversion somewhere)</span></div><div data-t="drowsy @nathanmarz thanks for the explanation, I agree, it&apos;s not important. Are there more things where select and transform differs? maybe those can be documented somewhere?"><span class="u" id="1499882432.323622">2017:07:12 18:00:32               drowsy </span><span>@nathanmarz thanks for the explanation, I agree, it&apos;s not important. Are there more things where select and transform differs? maybe those can be documented somewhere?</span></div><div data-t="nathanmarz not that i can think of"><span class="u" id="1499882553.398581">2017:07:12 18:02:33           nathanmarz </span><span>not that i can think of</span></div><div data-t="nathanmarz ALL on maps is a weird case"><span class="u" id="1499882560.403373">2017:07:12 18:02:40           nathanmarz </span><span>ALL on maps is a weird case</span></div><div data-t="nathanmarz a good thing to add to  https://github.com/nathanmarz/specter/issues/56"><span class="u" id="1499882576.412996">2017:07:12 18:02:56           nathanmarz </span><span>a good thing to add to </span><a href="https://github.com/nathanmarz/specter/issues/56">https://github.com/nathanmarz/specter/issues/56</a></div><div data-t="drowsy i will have a look. btw. I really like specter  🙂  so thank you!"><span class="u" id="1499882736.507998">2017:07:12 18:05:36               drowsy </span><span>i will have a look. btw. I really like specter </span><b>🙂</b><span> so thank you!</span></div><div data-t="nathanmarz 🙂"><span class="u" id="1499882751.517165">2017:07:12 18:05:51           nathanmarz </span><b>🙂</b></div><div data-t="frankmoyer I’m using specter in Clojurescript. I have a form that uses specter to remove a row from a deeply nested map. When I call the form from the repl, it works fine. When I run it from the browser,  core.cljs?rel=1495975558928:89 Error: No protocol method IAssociative.-assoc defined for type cljs.core/LazySeq:..... 

I’d really like to get Specter working in Clojurescript, as it will make my code much more manageable.

Here is the form:

 (defn delete-row
  [db row-nbr]
  (-&gt;&gt; db
       (sp/transform [:db (:active (:db db)) :blocks
                      (sp/if-path #(&lt; 1 (count %)) (sp/keypath row-nbr))]
                     sp/NONE)
       (sp/setval    [:db (:active (:db db)) :blocks nil?]
                     sp/NONE)))
"><span class="u" id="1500069850.166828">2017:07:14 22:04:10           frankmoyer </span><span>I’m using specter in Clojurescript. I have a form that uses specter to remove a row from a deeply nested map. When I call the form from the repl, it works fine. When I run it from the browser, </span><code>core.cljs?rel=1495975558928:89 Error: No protocol method IAssociative.-assoc defined for type cljs.core/LazySeq:.....</code><span>

I’d really like to get Specter working in Clojurescript, as it will make my code much more manageable.

Here is the form:

</span><pre>(defn delete-row
  [db row-nbr]
  (-&gt;&gt; db
       (sp/transform [:db (:active (:db db)) :blocks
                      (sp/if-path #(&lt; 1 (count %)) (sp/keypath row-nbr))]
                     sp/NONE)
       (sp/setval    [:db (:active (:db db)) :blocks nil?]
                     sp/NONE)))
</pre></div><div data-t="nathanmarz @frankmoyer which line is failing, the transform or the setval?"><span class="u" id="1500070582.367268">2017:07:14 22:16:22           nathanmarz </span><span>@frankmoyer which line is failing, the transform or the setval?</span></div><div data-t="nathanmarz also, what is  (:active (:db db)) ?"><span class="u" id="1500070664.388486">2017:07:14 22:17:44           nathanmarz </span><span>also, what is </span><code>(:active (:db db))</code><span>?</span></div><div data-t="nathanmarz that returns a navigator?"><span class="u" id="1500070678.391834">2017:07:14 22:17:58           nathanmarz </span><span>that returns a navigator?</span></div><div data-t="frankmoyer @nathanmarz Here is a test map input.

 {:db
  {:active                         :left,
   :left
   {:southern                      false,
    :blocks
    [{:tame                        &quot;first row&quot;
      :nont                        false}]}}
 :event                            [:last-char-deleted 0]}
 

It looks like it is happening in the  keypath  part of the  transform . Here is some more of the stacktrace:

 core.cljs?rel=1495975558928:89 Error: No protocol method IAssociative.-assoc defined for type cljs.core/LazySeq: ({:tame &quot;&quot;,  :nont false} {:tame &quot;This&quot;, :nont false})
    at Object.cljs$core$missing_protocol [as missing_protocol] (core.cljs:270)
    at Object.cljs$core$_assoc [as _assoc] (core.cljs:529)
    at Function.cljs.core.assoc.cljs$core$IFn$_invoke$arity$3 (core.cljs:1860)
    at cljs$core$assoc (core.cljs:1853)
    at com$rpl$specter$navs$do_keypath_transform (navs.cljc?rel=1495975557245:615)
    at com.rpl.specter.navs.keypath_STAR_.com.rpl.specter.impl.direct_nav_obj.call.com.rpl.specter.navs.t_com$rpl$specter$$rpl$specter$protocols$RichNavigator$transform_STAR_$arity$4 (navs.cljc?rel=1495975557245:625)
    at com$rpl$specter$protocols$transform_STAR_ (protocols.cljc?rel=1495975553225:15)
    at com$rpl$specter$navs$if_transform (navs.cljc?rel=1495975557245:402)
"><span class="u" id="1500077523.732020">2017:07:15 00:12:03           frankmoyer </span><span>@nathanmarz Here is a test map input.

</span><pre>{:db
  {:active                         :left,
   :left
   {:southern                      false,
    :blocks
    [{:tame                        &quot;first row&quot;
      :nont                        false}]}}
 :event                            [:last-char-deleted 0]}
</pre><span>

It looks like it is happening in the </span><code>keypath</code><span> part of the </span><code>transform</code><span>. Here is some more of the stacktrace:

</span><pre>core.cljs?rel=1495975558928:89 Error: No protocol method IAssociative.-assoc defined for type cljs.core/LazySeq: ({:tame &quot;&quot;,  :nont false} {:tame &quot;This&quot;, :nont false})
    at Object.cljs$core$missing_protocol [as missing_protocol] (core.cljs:270)
    at Object.cljs$core$_assoc [as _assoc] (core.cljs:529)
    at Function.cljs.core.assoc.cljs$core$IFn$_invoke$arity$3 (core.cljs:1860)
    at cljs$core$assoc (core.cljs:1853)
    at com$rpl$specter$navs$do_keypath_transform (navs.cljc?rel=1495975557245:615)
    at com.rpl.specter.navs.keypath_STAR_.com.rpl.specter.impl.direct_nav_obj.call.com.rpl.specter.navs.t_com$rpl$specter$$rpl$specter$protocols$RichNavigator$transform_STAR_$arity$4 (navs.cljc?rel=1495975557245:625)
    at com$rpl$specter$protocols$transform_STAR_ (protocols.cljc?rel=1495975553225:15)
    at com$rpl$specter$navs$if_transform (navs.cljc?rel=1495975557245:402)
</pre></div><div data-t="nathanmarz @frankmoyer oh, that  transform  should be a  setval"><span class="u" id="1500081725.183262">2017:07:15 01:22:05           nathanmarz </span><span>@frankmoyer oh, that </span><code>transform</code><span> should be a </span><code>setval</code></div><div data-t="nathanmarz also you should wrap  (:active (:db db))  with  keypath"><span class="u" id="1500081805.190151">2017:07:15 01:23:25           nathanmarz </span><span>also you should wrap </span><code>(:active (:db db))</code><span> with </span><code>keypath</code></div><div data-t="nathanmarz no semantic difference but will perform better"><span class="u" id="1500081825.191784">2017:07:15 01:23:45           nathanmarz </span><span>no semantic difference but will perform better</span></div><div data-t="nathanmarz since it doesn&apos;t have to convert keyword -&gt; navigator at runtime"><span class="u" id="1500081844.193433">2017:07:15 01:24:04           nathanmarz </span><span>since it doesn&apos;t have to convert keyword -&gt; navigator at runtime</span></div><div data-t="frankmoyer Perfect! That worked. I really appreciate it. I was just bragging to my wife about how great Specter is and how responsive you are. It makes working with Specter so much less daunting to know you are there for support!"><span class="u" id="1500081946.202726">2017:07:15 01:25:46           frankmoyer </span><span>Perfect! That worked. I really appreciate it. I was just bragging to my wife about how great Specter is and how responsive you are. It makes working with Specter so much less daunting to know you are there for support!</span></div><div data-t="nathanmarz you can also combine the two calls using  (multi-path (if-path ...) nil?)"><span class="u" id="1500081974.205250">2017:07:15 01:26:14           nathanmarz </span><span>you can also combine the two calls using </span><code>(multi-path (if-path ...) nil?)</code></div><div data-t="nathanmarz awesome, glad to help"><span class="u" id="1500081996.207221">2017:07:15 01:26:36           nathanmarz </span><span>awesome, glad to help</span></div><div data-t="frankmoyer I’m not sure I need the second call anymore now that the first call has been changed to a  setval ."><span class="u" id="1500082029.210326">2017:07:15 01:27:09           frankmoyer </span><span>I’m not sure I need the second call anymore now that the first call has been changed to a </span><code>setval</code><span>.</span></div><div data-t="slpssm Hi, I’m new to specter and have a select I keep trying to do but I’m not quite sure how. I have data like this:  {:foo [{:data &quot;text&quot; :required true}]
 :bar [{:data &quot;text&quot;}]
 :baz [{:data &quot;text&quot; :required true}]}  and I’d like the list of keys whose value has :required in the inner map. This seems to do it:  (map first (s/select [s/ALL (fn[[k,v]] (:required (first v)))] data))  and return the expected  (:foo :baz)  Is there a better way? There have been a few places where I’d like the outer key depending on some value lower in the data structure."><span class="u" id="1500476561.178830">2017:07:19 15:02:41               slpssm </span><span>Hi, I’m new to specter and have a select I keep trying to do but I’m not quite sure how. I have data like this: </span><pre>{:foo [{:data &quot;text&quot; :required true}]
 :bar [{:data &quot;text&quot;}]
 :baz [{:data &quot;text&quot; :required true}]}</pre><span> and I’d like the list of keys whose value has :required in the inner map. This seems to do it: </span><pre>(map first (s/select [s/ALL (fn[[k,v]] (:required (first v)))] data))</pre><span> and return the expected </span><pre>(:foo :baz)</pre><span> Is there a better way? There have been a few places where I’d like the outer key depending on some value lower in the data structure.</span></div><div data-t="nathanmarz @slpssm can those inner vectors have multiple elements?"><span class="u" id="1500477338.688104">2017:07:19 15:15:38           nathanmarz </span><span>@slpssm can those inner vectors have multiple elements?</span></div><div data-t="nathanmarz if so then it&apos;s  (select [ALL (selected? LAST ALL (must :required)) FIRST] data)"><span class="u" id="1500477364.704907">2017:07:19 15:16:04           nathanmarz </span><span>if so then it&apos;s </span><code>(select [ALL (selected? LAST ALL (must :required)) FIRST] data)</code></div><div data-t="nathanmarz otherwise it&apos;s  (select [ALL (selected? LAST FIRST (must :required)) FIRST] data)  to match your code"><span class="u" id="1500477415.738833">2017:07:19 15:16:55           nathanmarz </span><span>otherwise it&apos;s </span><code>(select [ALL (selected? LAST FIRST (must :required)) FIRST] data)</code><span> to match your code</span></div><div data-t="nathanmarz this code just checks for existence of a :required key, if you need to match only when :required is truthy replace  (must :required)  with  :required identity"><span class="u" id="1500477617.871870">2017:07:19 15:20:17           nathanmarz </span><span>this code just checks for existence of a :required key, if you need to match only when :required is truthy replace </span><code>(must :required)</code><span> with </span><code>:required identity</code></div><div data-t="slpssm I think it can have more than one item, but I’ve never seen one so I’m going with the first version.  🙂  With a note on the second version just in case. Now I just need to parse this so I know how it works."><span class="u" id="1500477741.952512">2017:07:19 15:22:21               slpssm </span><span>I think it can have more than one item, but I’ve never seen one so I’m going with the first version. </span><b>🙂</b><span> With a note on the second version just in case. Now I just need to parse this so I know how it works.</span></div><div data-t="nathanmarz selected?  is a filter based on whether the subpath selects at least a single value"><span class="u" id="1500477776.975543">2017:07:19 15:22:56           nathanmarz </span><code>selected?</code><span> is a filter based on whether the subpath selects at least a single value</span></div><div data-t="slpssm LAST  gets you into the array, the next  ALL  looks at key/values,  (must :required)  does the  :required  check and the last  FIRST  is the outer key. About right?"><span class="u" id="1500478047.153902">2017:07:19 15:27:27               slpssm </span><code>LAST</code><span> gets you into the array, the next </span><code>ALL</code><span> looks at key/values, </span><code>(must :required)</code><span> does the </span><code>:required</code><span> check and the last </span><code>FIRST</code><span> is the outer key. About right?</span></div><div data-t="nathanmarz the initial  LAST  goes to the value for that key/value pair, the subsequent  ALL  looks at all maps inside that vector"><span class="u" id="1500478214.265519">2017:07:19 15:30:14           nathanmarz </span><span>the initial </span><code>LAST</code><span> goes to the value for that key/value pair, the subsequent </span><code>ALL</code><span> looks at all maps inside that vector</span></div><div data-t="slpssm Ah, OK. Yes.  FIRST  would be the key,  LAST  is the value."><span class="u" id="1500478946.752288">2017:07:19 15:42:26               slpssm </span><span>Ah, OK. Yes. </span><code>FIRST</code><span> would be the key, </span><code>LAST</code><span> is the value.</span></div><div data-t="alexyakushev Hello everyone. I want to do the following transformation:
 [[:a :b :c] [:d] [:e :f] [:g]] =&gt; [[0 1 2] [3] [4 5] [6]]
 
In other words, I want to enumerate elements in two-levels-deep nested structure. I managed to achieve this with  subselect :
 (setval (subselect ALL ALL) (iterate inc 0) [[:a :a :a] [:b] [:c :c] [:d]])
 
Is there a better way than using  subselect  here? I was looking for something like  FLATMAP  navigator that is like  ALL  but splices each sequence into top-level view."><span class="u" id="1500552976.379170">2017:07:20 12:16:16         alexyakushev </span><span>Hello everyone. I want to do the following transformation:
</span><pre>[[:a :b :c] [:d] [:e :f] [:g]] =&gt; [[0 1 2] [3] [4 5] [6]]
</pre><span>
In other words, I want to enumerate elements in two-levels-deep nested structure. I managed to achieve this with </span><code>subselect</code><span>:
</span><pre>(setval (subselect ALL ALL) (iterate inc 0) [[:a :a :a] [:b] [:c :c] [:d]])
</pre><span>
Is there a better way than using </span><code>subselect</code><span> here? I was looking for something like </span><code>FLATMAP</code><span> navigator that is like </span><code>ALL</code><span> but splices each sequence into top-level view.</span></div><div data-t="nathanmarz @alexyakushev that&apos;s a perfect solution"><span class="u" id="1500553913.720505">2017:07:20 12:31:53           nathanmarz </span><span>@alexyakushev that&apos;s a perfect solution</span></div><div data-t="nathanmarz you could define  FLATMAP  with something like:
 (def FLATMAP
  (recursive-path [] p
    (if-path sequential?
      [ALL p]
      STAY
      )))
"><span class="u" id="1500554086.788021">2017:07:20 12:34:46           nathanmarz </span><span>you could define </span><code>FLATMAP</code><span> with something like:
</span><pre>(def FLATMAP
  (recursive-path [] p
    (if-path sequential?
      [ALL p]
      STAY
      )))
</pre></div><div data-t="alexyakushev Thanks, Nathan! A quick follow-up question. Is there a way to transform a vector so that the transform-fn receives an index of the element? Like  map-indexed . All I could Google was  https://github.com/nathanmarz/specter/issues/169 , but in that case the iterable element was a map, where keys are more easily obtained."><span class="u" id="1500554098.792460">2017:07:20 12:34:58         alexyakushev </span><span>Thanks, Nathan! A quick follow-up question. Is there a way to transform a vector so that the transform-fn receives an index of the element? Like </span><code>map-indexed</code><span>. All I could Google was </span><a href="https://github.com/nathanmarz/specter/issues/169">https://github.com/nathanmarz/specter/issues/169</a><span>, but in that case the iterable element was a map, where keys are more easily obtained.</span></div><div data-t="nathanmarz not in specter core"><span class="u" id="1500554128.804507">2017:07:20 12:35:28           nathanmarz </span><span>not in specter core</span></div><div data-t="nathanmarz you could define a navigator similar to  ALL  which navigates to [index value]"><span class="u" id="1500554145.811128">2017:07:20 12:35:45           nathanmarz </span><span>you could define a navigator similar to </span><code>ALL</code><span> which navigates to [index value]</span></div><div data-t="alexyakushev Hm, I didn&apos;t know it is this easy to define new navigators  🙂  This is excellent, thank you!"><span class="u" id="1500554180.824191">2017:07:20 12:36:20         alexyakushev </span><span>Hm, I didn&apos;t know it is this easy to define new navigators </span><b>🙂</b><span> This is excellent, thank you!</span></div><div data-t="felipe-campos looking for documentation or some examples about  recursive-path"><span class="u" id="1500998293.515517">2017:07:25 15:58:13        felipe-campos </span><span>looking for documentation or some examples about </span><code>recursive-path</code></div><div data-t="andrea.crotti hi guys"><span class="u" id="1501060379.073998">2017:07:26 09:12:59        andrea.crotti </span><span>hi guys</span></div><div data-t="andrea.crotti I&apos;m trying to implement something like this
 (get-capitals {&quot;A&quot; [&quot;hello&quot;]
               &quot;b&quot; [&quot;other&quot;]})

;; should return {&quot;A&quot; [&quot;hello&quot;]}
"><span class="u" id="1501060407.084832">2017:07:26 09:13:27        andrea.crotti </span><span>I&apos;m trying to implement something like this
</span><pre>(get-capitals {&quot;A&quot; [&quot;hello&quot;]
               &quot;b&quot; [&quot;other&quot;]})

;; should return {&quot;A&quot; [&quot;hello&quot;]}
</pre></div><div data-t="andrea.crotti with Specter, which in theory it&apos;s just a select right?"><span class="u" id="1501060423.091220">2017:07:26 09:13:43        andrea.crotti </span><span>with Specter, which in theory it&apos;s just a select right?</span></div><div data-t="andrea.crotti (defn get-capitals
  [probs]
  (specter/select
   [specter/MAP-KEYS #(Character/isUpperCase (first %))]
   probs))
"><span class="u" id="1501060426.092361">2017:07:26 09:13:46        andrea.crotti </span><pre>(defn get-capitals
  [probs]
  (specter/select
   [specter/MAP-KEYS #(Character/isUpperCase (first %))]
   probs))
</pre></div><div data-t="andrea.crotti this loses the original structure though"><span class="u" id="1501060435.095954">2017:07:26 09:13:55        andrea.crotti </span><span>this loses the original structure though</span></div><div data-t="schmee select  always return a sequence, so if you want to maintain the structure you have to use something else"><span class="u" id="1501060509.124855">2017:07:26 09:15:09               schmee </span><code>select</code><span> always return a sequence, so if you want to maintain the structure you have to use something else</span></div><div data-t="schmee gimmie a sec"><span class="u" id="1501060512.126169">2017:07:26 09:15:12               schmee </span><span>gimmie a sec</span></div><div data-t="andrea.crotti ah yes ok i can try with transofrm"><span class="u" id="1501060581.152806">2017:07:26 09:16:21        andrea.crotti </span><span>ah yes ok i can try with transofrm</span></div><div data-t="andrea.crotti but the function itself should be identity then?"><span class="u" id="1501060591.156619">2017:07:26 09:16:31        andrea.crotti </span><span>but the function itself should be identity then?</span></div><div data-t="schmee this should do it:  (defn get-capitals
  [probs]
  (specter/setval
   [specter/MAP-KEYS #(Character/isLowerCase (first %))]
   specter/NONE
   probs)
"><span class="u" id="1501060607.162755">2017:07:26 09:16:47               schmee </span><span>this should do it: </span><pre>(defn get-capitals
  [probs]
  (specter/setval
   [specter/MAP-KEYS #(Character/isLowerCase (first %))]
   specter/NONE
   probs)
</pre></div><div data-t="schmee it removes everything that is lower case, instead of selecting what is upper case"><span class="u" id="1501060624.169282">2017:07:26 09:17:04               schmee </span><span>it removes everything that is lower case, instead of selecting what is upper case</span></div><div data-t="andrea.crotti Ah this also works actualy
 (defn get-capitals
  [probs]
  (specter/transform
   [specter/MAP-KEYS #(Character/isUpperCase (first %))]
   identity
   probs))
"><span class="u" id="1501060625.169537">2017:07:26 09:17:05        andrea.crotti </span><span>Ah this also works actualy
</span><pre>(defn get-capitals
  [probs]
  (specter/transform
   [specter/MAP-KEYS #(Character/isUpperCase (first %))]
   identity
   probs))
</pre></div><div data-t="andrea.crotti I actually need both submaps really"><span class="u" id="1501060641.175904">2017:07:26 09:17:21        andrea.crotti </span><span>I actually need both submaps really</span></div><div data-t="andrea.crotti or maybe I can just use select to extract the two set of keys and reconstruct the maps later"><span class="u" id="1501060662.183644">2017:07:26 09:17:42        andrea.crotti </span><span>or maybe I can just use select to extract the two set of keys and reconstruct the maps later</span></div><div data-t="frankmoyer I have a straight-forward selector that, does not function as I expect it to when the last element is index reference to a collection. Here is the  select  without the index in the  keypath  followed by the  select  with the index (0) in the  keypath :

 (sp/select [(apply sp/keypath [:db :right :text-entry 0 :offset])])
[({:text &quot;180 West&quot;, :label &quot;&quot;})]

(sp/select [(apply sp/keypath [:db :right :text-entry 0 :offset 0])])
[nil]
 

The index navigator after  :text-entry  always works. It seems like it is just when the index is at the last position."><span class="u" id="1501103522.213697">2017:07:26 21:12:02           frankmoyer </span><span>I have a straight-forward selector that, does not function as I expect it to when the last element is index reference to a collection. Here is the </span><code>select</code><span> without the index in the </span><code>keypath</code><span> followed by the </span><code>select</code><span> with the index (0) in the </span><code>keypath</code><span>:

</span><pre>(sp/select [(apply sp/keypath [:db :right :text-entry 0 :offset])])
[({:text &quot;180 West&quot;, :label &quot;&quot;})]

(sp/select [(apply sp/keypath [:db :right :text-entry 0 :offset 0])])
[nil]
</pre><span>

The index navigator after </span><code>:text-entry</code><span> always works. It seems like it is just when the index is at the last position.</span></div><div data-t="nathanmarz @frankmoyer what&apos;s the input?"><span class="u" id="1501105888.277336">2017:07:26 21:51:28           nathanmarz </span><span>@frankmoyer what&apos;s the input?</span></div><div data-t="frankmoyer @nathanmarz I just figured out what was going on while I was compiling the input for you. A prior  transform  altered the portion of the structure that was being modified to be a  List . When I convert it to a  vec  in the form, subsequent  transform  operations are able to navigate to the index. Thank you!"><span class="u" id="1501107911.039382">2017:07:26 22:25:11           frankmoyer </span><span>@nathanmarz I just figured out what was going on while I was compiling the input for you. A prior </span><code>transform</code><span> altered the portion of the structure that was being modified to be a </span><code>List</code><span>. When I convert it to a </span><code>vec</code><span> in the form, subsequent </span><code>transform</code><span> operations are able to navigate to the index. Thank you!</span></div><div data-t="wei is there a way to make walker search only maps (not e.g. Datomic entitymaps?)  (def link-walker [(sp/walker ::link)])"><span class="u" id="1501107995.067009">2017:07:26 22:26:35                  wei </span><span>is there a way to make walker search only maps (not e.g. Datomic entitymaps?) </span><pre>(def link-walker [(sp/walker ::link)])</pre></div><div data-t="nathanmarz @frankmoyer cool, figured it would be something like that"><span class="u" id="1501108077.093150">2017:07:26 22:27:57           nathanmarz </span><span>@frankmoyer cool, figured it would be something like that</span></div><div data-t="wei I’m confused why these give different results:  dev.user=&gt; (sp/transform [(sp/walker ::link)] identity {:a 1 :b (d/entity (db/db) 17592186045447) ::link [:a 1]})
{:a 1, :b #:db{:id 17592186045447}, :dev.user/link [:a 1]}
dev.user=&gt; (sp/transform [(sp/walker ::link)] identity {:a 1 :b (d/entity (db/db) 17592186045447)})
AbstractMethodError   clojure.lang.RT.conj (RT.java:667)
"><span class="u" id="1501108146.115364">2017:07:26 22:29:06                  wei </span><span>I’m confused why these give different results: </span><pre>dev.user=&gt; (sp/transform [(sp/walker ::link)] identity {:a 1 :b (d/entity (db/db) 17592186045447) ::link [:a 1]})
{:a 1, :b #:db{:id 17592186045447}, :dev.user/link [:a 1]}
dev.user=&gt; (sp/transform [(sp/walker ::link)] identity {:a 1 :b (d/entity (db/db) 17592186045447)})
AbstractMethodError   clojure.lang.RT.conj (RT.java:667)
</pre></div><div data-t="wei oh nevermind, I think I know why-- depth first search descends in the second case but cuts off in the first case"><span class="u" id="1501108191.130447">2017:07:26 22:29:51                  wei </span><span>oh nevermind, I think I know why-- depth first search descends in the second case but cuts off in the first case</span></div><div data-t="nathanmarz @wei walker will blindly walk into any collection (functions like clojure.walk)"><span class="u" id="1501108198.133279">2017:07:26 22:29:58           nathanmarz </span><span>@wei walker will blindly walk into any collection (functions like clojure.walk)</span></div><div data-t="wei thanks @nathanmarz. looking for a good alternative to  walker  then"><span class="u" id="1501108228.144037">2017:07:26 22:30:28                  wei </span><span>thanks @nathanmarz. looking for a good alternative to </span><code>walker</code><span> then</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1352"><span class="u" id="1501108254.152819">2017:07:26 22:30:54           nathanmarz </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1352">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1352</a></div><div data-t="nathanmarz (walker ::link)  doesn&apos;t make much sense"><span class="u" id="1501108288.164258">2017:07:26 22:31:28           nathanmarz </span><code>(walker ::link)</code><span> doesn&apos;t make much sense</span></div><div data-t="nathanmarz look at the docstring"><span class="u" id="1501108303.168911">2017:07:26 22:31:43           nathanmarz </span><span>look at the docstring</span></div><div data-t="nathanmarz it&apos;s generally better to make your own recursive path tailored to the data structure / problem at hand"><span class="u" id="1501108338.180246">2017:07:26 22:32:18           nathanmarz </span><span>it&apos;s generally better to make your own recursive path tailored to the data structure / problem at hand</span></div><div data-t="nathanmarz and it&apos;s really easy to do"><span class="u" id="1501108353.185119">2017:07:26 22:32:33           nathanmarz </span><span>and it&apos;s really easy to do</span></div><div data-t="wei I’m trying to find maps with the key  ::link  in them, so it seems like a legit  afn  to me? could you explain what I’m missing?"><span class="u" id="1501108440.213483">2017:07:26 22:34:00                  wei </span><span>I’m trying to find maps with the key </span><code>::link</code><span> in them, so it seems like a legit </span><code>afn</code><span> to me? could you explain what I’m missing?</span></div><div data-t="wei (in my example above, the map passed in was contrived and I substituted  identity  with a function that actually does something useful)"><span class="u" id="1501108516.237900">2017:07:26 22:35:16                  wei </span><span>(in my example above, the map passed in was contrived and I substituted </span><code>identity</code><span> with a function that actually does something useful)</span></div><div data-t="nathanmarz it&apos;s going to call  ::link  on all values / data structures it sees"><span class="u" id="1501108540.245704">2017:07:26 22:35:40           nathanmarz </span><span>it&apos;s going to call </span><code>::link</code><span> on all values / data structures it sees</span></div><div data-t="nathanmarz e.g.  (::link 1)"><span class="u" id="1501108561.252010">2017:07:26 22:36:01           nathanmarz </span><span>e.g. </span><code>(::link 1)</code></div><div data-t="nathanmarz I wouldn&apos;t rely on that behavior"><span class="u" id="1501108572.255315">2017:07:26 22:36:12           nathanmarz </span><span>I wouldn&apos;t rely on that behavior</span></div><div data-t="nathanmarz #(and (map? %) (contains? % ::link))  is better i think"><span class="u" id="1501108629.272465">2017:07:26 22:37:09           nathanmarz </span><code>#(and (map? %) (contains? % ::link))</code><span> is better i think</span></div><div data-t="wei ah that makes more sense. unfortunately it’s still descending into the datomic entity I think. is there a way to make  walker  short-circuit, or is there a better alternative?  dev.user=&gt; (sp/transform [(sp/walker #(and (map? %) (contains? % ::link)))] identity {:a 1 :b (d/entity (db/db) 17592186045447)})
AbstractMethodError   clojure.lang.RT.conj (RT.java:667)
"><span class="u" id="1501108781.318657">2017:07:26 22:39:41                  wei </span><span>ah that makes more sense. unfortunately it’s still descending into the datomic entity I think. is there a way to make </span><code>walker</code><span> short-circuit, or is there a better alternative? </span><pre>dev.user=&gt; (sp/transform [(sp/walker #(and (map? %) (contains? % ::link)))] identity {:a 1 :b (d/entity (db/db) 17592186045447)})
AbstractMethodError   clojure.lang.RT.conj (RT.java:667)
</pre></div><div data-t="nathanmarz you can&apos;t avoid that with  walker"><span class="u" id="1501108847.340288">2017:07:26 22:40:47           nathanmarz </span><span>you can&apos;t avoid that with </span><code>walker</code></div><div data-t="nathanmarz an easy variant you could use is:
 (def walk-skipper
  (recursive-path [afn skip-fn] p
    (cond-path (pred skip-fn) STOP
               (pred afn) STAY
               coll? [ALL p]
               )))
"><span class="u" id="1501108857.343229">2017:07:26 22:40:57           nathanmarz </span><span>an easy variant you could use is:
</span><pre>(def walk-skipper
  (recursive-path [afn skip-fn] p
    (cond-path (pred skip-fn) STOP
               (pred afn) STAY
               coll? [ALL p]
               )))
</pre></div><div data-t="nathanmarz set the  skip-fn  to return true on datomic entities"><span class="u" id="1501108869.346824">2017:07:26 22:41:09           nathanmarz </span><span>set the </span><code>skip-fn</code><span> to return true on datomic entities</span></div><div data-t="nathanmarz or anything else you don&apos;t want to walk"><span class="u" id="1501108875.348655">2017:07:26 22:41:15           nathanmarz </span><span>or anything else you don&apos;t want to walk</span></div><div data-t="wei trying to understand  recursive-path  usage, where does  pred  come from in this case?"><span class="u" id="1501109065.407190">2017:07:26 22:44:25                  wei </span><span>trying to understand </span><code>recursive-path</code><span> usage, where does </span><code>pred</code><span> come from in this case?</span></div><div data-t="nathanmarz pred  is a navigator"><span class="u" id="1501109088.414273">2017:07:26 22:44:48           nathanmarz </span><code>pred</code><span> is a navigator</span></div><div data-t="nathanmarz that&apos;s what&apos;s implicitly used when you put a function into a path"><span class="u" id="1501109103.418690">2017:07:26 22:45:03           nathanmarz </span><span>that&apos;s what&apos;s implicitly used when you put a function into a path</span></div><div data-t="nathanmarz it&apos;s used in this case to avoid runtime conversion of function -&gt; navigator"><span class="u" id="1501109122.424932">2017:07:26 22:45:22           nathanmarz </span><span>it&apos;s used in this case to avoid runtime conversion of function -&gt; navigator</span></div><div data-t="nathanmarz (for performance)"><span class="u" id="1501109153.435229">2017:07:26 22:45:53           nathanmarz </span><span>(for performance)</span></div><div data-t="wei great, seems to be working as expected! i substituted  com.rpl.specter/pred  so I could define  walk-skipper  in my own ns. thanks for your help."><span class="u" id="1501109286.475308">2017:07:26 22:48:06                  wei </span><span>great, seems to be working as expected! i substituted </span><code>com.rpl.specter/pred</code><span> so I could define </span><code>walk-skipper</code><span> in my own ns. thanks for your help.</span></div><div data-t="wei sorry to bug you again @nathanmarz but the  walk-skipper  doesn’t seem to be working for me:  (def walk-skipper
  (sp/recursive-path [afn skip-fn] p
                     (sp/cond-path (sp/pred skip-fn) sp/STOP
                                   (sp/pred afn) sp/STAY
                                   coll? [sp/ALL p])))

dev.user=&gt; (sp/select [(sp/walker #(and (map? %) (contains? % :d)) )] {:a 1 :b 2 :c {:d 1}})
[{:d 1}]
dev.user=&gt; (sp/select [(walk-skipper #(and (map? %) (contains? % :d)) (complement map?))] {:a 1 :b 2 :c {:d 1}})
[]
"><span class="u" id="1501111274.051103">2017:07:26 23:21:14                  wei </span><span>sorry to bug you again @nathanmarz but the </span><code>walk-skipper</code><span> doesn’t seem to be working for me: </span><pre>(def walk-skipper
  (sp/recursive-path [afn skip-fn] p
                     (sp/cond-path (sp/pred skip-fn) sp/STOP
                                   (sp/pred afn) sp/STAY
                                   coll? [sp/ALL p])))

dev.user=&gt; (sp/select [(sp/walker #(and (map? %) (contains? % :d)) )] {:a 1 :b 2 :c {:d 1}})
[{:d 1}]
dev.user=&gt; (sp/select [(walk-skipper #(and (map? %) (contains? % :d)) (complement map?))] {:a 1 :b 2 :c {:d 1}})
[]
</pre></div><div data-t="wei still wrapping my head around how  recursive-path  works. mind helping me troubleshoot?"><span class="u" id="1501111327.065667">2017:07:26 23:22:07                  wei </span><span>still wrapping my head around how </span><code>recursive-path</code><span> works. mind helping me troubleshoot?</span></div><div data-t="nathanmarz @wei the definition of  walker  /  walk-skipper  traverses all collections via  ALL  to replicate clojure.walk semantics"><span class="u" id="1501113450.617923">2017:07:26 23:57:30           nathanmarz </span><span>@wei the definition of </span><code>walker</code><span> / </span><code>walk-skipper</code><span> traverses all collections via </span><code>ALL</code><span> to replicate clojure.walk semantics</span></div><div data-t="nathanmarz so that means it traverses each key/value pair as a vector, then traverses those to each key/value"><span class="u" id="1501113472.623651">2017:07:26 23:57:52           nathanmarz </span><span>so that means it traverses each key/value pair as a vector, then traverses those to each key/value</span></div><div data-t="nathanmarz since you stop navigation if encountering a non-map, it stops traversing once it reaches key/value pairs"><span class="u" id="1501113497.630151">2017:07:26 23:58:17           nathanmarz </span><span>since you stop navigation if encountering a non-map, it stops traversing once it reaches key/value pairs</span></div><div data-t="nathanmarz so never reaches the inner map"><span class="u" id="1501113503.631649">2017:07:26 23:58:23           nathanmarz </span><span>so never reaches the inner map</span></div><div data-t="nathanmarz like I said, it&apos;s better to make your own recursive path tailored to the data structure / problem at hand"><span class="u" id="1501113534.639246">2017:07:26 23:58:54           nathanmarz </span><span>like I said, it&apos;s better to make your own recursive path tailored to the data structure / problem at hand</span></div><div data-t="nathanmarz in this case you probably want to descend using  MAP-VALS  rather than  ALL"><span class="u" id="1501113568.647635">2017:07:26 23:59:28           nathanmarz </span><span>in this case you probably want to descend using </span><code>MAP-VALS</code><span> rather than </span><code>ALL</code></div><div data-t="nathanmarz will be a lot more performant as well by avoiding traversing totally irrelevant parts of the data structure"><span class="u" id="1501113606.657586">2017:07:27 00:00:06           nathanmarz </span><span>will be a lot more performant as well by avoiding traversing totally irrelevant parts of the data structure</span></div><div data-t="wei ^ I get it now, thanks for the help!"><span class="u" id="1501149454.169036">2017:07:27 09:57:34                  wei </span><span>^ I get it now, thanks for the help!</span></div><div data-t="souenzzo (setval [(walker #(contains? % :foo))] NONE [{:foo true}])  ;=&gt; [:com.rpl.specter.impl/NONE]
(setval [ALL (walker #(contains? % :foo))] NONE [{:foo true}])  ;=&gt; [] 
Is it a bug?"><span class="u" id="1501166293.205412">2017:07:27 14:38:13             souenzzo </span><pre>(setval [(walker #(contains? % :foo))] NONE [{:foo true}])  ;=&gt; [:com.rpl.specter.impl/NONE]
(setval [ALL (walker #(contains? % :foo))] NONE [{:foo true}])  ;=&gt; []</pre><span>
Is it a bug?</span></div><div data-t="nathanmarz @souenzzo you&apos;re using an old version"><span class="u" id="1501166753.504494">2017:07:27 14:45:53           nathanmarz </span><span>@souenzzo you&apos;re using an old version</span></div><div data-t="nathanmarz NONE  integration with  walker  was added in 1.0.2"><span class="u" id="1501166778.521493">2017:07:27 14:46:18           nathanmarz </span><code>NONE</code><span> integration with </span><code>walker</code><span> was added in 1.0.2</span></div><div data-t="souenzzo I was on 1.0.1. I did not see the new  😅  sorry"><span class="u" id="1501166847.566975">2017:07:27 14:47:27                  souenzzo </span><span>I was on 1.0.1. I did not see the new </span><b>😅</b><span> sorry</span></div><div data-t="eriktjacobsen First-time specter user today; How would I compose  [MAP-VALS (multi-path :checks :dependencies) ALL :relation]  and  [MAP-VALS :features MAP-VALS]  ?"><span class="u" id="1501205901.469642">2017:07:28 01:38:21        eriktjacobsen </span><span>First-time specter user today; How would I compose </span><code>[MAP-VALS (multi-path :checks :dependencies) ALL :relation]</code><span> and </span><code>[MAP-VALS :features MAP-VALS]</code><span> ?</span></div><div data-t="eriktjacobsen it looked like cond-path, but then it seems you&apos;re duplicating the multi-path and :features? Wasn&apos;t sure if there was a cleaner way. (ie  [MAP-VALS (cond-path (multi-path :checks :dependencies) [(multi-path :checks :dependencies) ALL :relation] :features [:features MAP-VALS])] )"><span class="u" id="1501206134.514835">2017:07:28 01:42:14        eriktjacobsen </span><span>it looked like cond-path, but then it seems you&apos;re duplicating the multi-path and :features? Wasn&apos;t sure if there was a cleaner way. (ie </span><code>[MAP-VALS (cond-path (multi-path :checks :dependencies) [(multi-path :checks :dependencies) ALL :relation] :features [:features MAP-VALS])]</code><span>)</span></div><div data-t="nathanmarz @eriktjacobsen not sure what you mean by &quot;compose&quot;"><span class="u" id="1501216392.304060">2017:07:28 04:33:12           nathanmarz </span><span>@eriktjacobsen not sure what you mean by &quot;compose&quot;</span></div><div data-t="nathanmarz if you want to do both paths at once it&apos;s just  multi-path  similar to what you&apos;re already doing"><span class="u" id="1501216426.309007">2017:07:28 04:33:46           nathanmarz </span><span>if you want to do both paths at once it&apos;s just </span><code>multi-path</code><span> similar to what you&apos;re already doing</span></div><div data-t="eriktjacobsen fair. the third block using cond-path is what I want, i just thought there might be another way besides duplicating the pieces in cond"><span class="u" id="1501216435.310332">2017:07:28 04:33:55        eriktjacobsen </span><span>fair. the third block using cond-path is what I want, i just thought there might be another way besides duplicating the pieces in cond</span></div><div data-t="nathanmarz putting  (multi-path :checks :dependencies)  as your condition does nothing"><span class="u" id="1501216480.317121">2017:07:28 04:34:40           nathanmarz </span><span>putting </span><code>(multi-path :checks :dependencies)</code><span> as your condition does nothing</span></div><div data-t="nathanmarz that condition is always true"><span class="u" id="1501216512.321832">2017:07:28 04:35:12           nathanmarz </span><span>that condition is always true</span></div><div data-t="nathanmarz conditionals in specter (`cond-path` and  if-path ) are true if at least one element is selected"><span class="u" id="1501216596.334739">2017:07:28 04:36:36           nathanmarz </span><span>conditionals in specter (`cond-path` and </span><code>if-path</code><span>) are true if at least one element is selected</span></div><div data-t="rcullito Hey all, I’m a little confused about how conceptually to think about using  filterer  versus just containing a predicate in my path. To take this example:"><span class="u" id="1501373493.879235">2017:07:30 00:11:33             rcullito </span><span>Hey all, I’m a little confused about how conceptually to think about using </span><code>filterer</code><span> versus just containing a predicate in my path. To take this example:</span></div><div data-t="rcullito (select (filterer even?) (range 10))
[[0 2 4 6 8]]

(select [ALL even?] (range 10))
[0 2 4 6 8]"><span class="u" id="1501373498.879527">2017:07:30 00:11:38             rcullito </span><pre>(select (filterer even?) (range 10))
[[0 2 4 6 8]]

(select [ALL even?] (range 10))
[0 2 4 6 8]</pre></div><div data-t="rcullito it is still unclear to me why the  filterer  version would be nested versus the second example."><span class="u" id="1501373522.881102">2017:07:30 00:12:02             rcullito </span><span>it is still unclear to me why the </span><code>filterer</code><span> version would be nested versus the second example.</span></div><div data-t="drowsy as far as I understand filterer navigates to the subcollection (so you could for example reverse it) while ALL pred navigates to every single number (so you could for example inc it)"><span class="u" id="1501374458.937523">2017:07:30 00:27:38               drowsy </span><span>as far as I understand filterer navigates to the subcollection (so you could for example reverse it) while ALL pred navigates to every single number (so you could for example inc it)</span></div><div data-t="nathanmarz @rcullito by navigating you to a sequence you can do things with  filterer  that you can&apos;t do with navigators that go straight to subvalues, e.g. selecting the last even number in a sequence:  (select-any [(filterer even?) LAST] (range 10)) ; =&gt; 8"><span class="u" id="1501376166.036402">2017:07:30 00:56:06           nathanmarz </span><span>@rcullito by navigating you to a sequence you can do things with </span><code>filterer</code><span> that you can&apos;t do with navigators that go straight to subvalues, e.g. selecting the last even number in a sequence: </span><code>(select-any [(filterer even?) LAST] (range 10)) ; =&gt; 8</code></div><div data-t="rcullito Thanks for the examples: @drowsy, @nathanmarz! Starting to pick up on the subtleties for when it is preferable to use  filterer . Much appreciated."><span class="u" id="1501397981.196471">2017:07:30 06:59:41             rcullito </span><span>Thanks for the examples: @drowsy, @nathanmarz! Starting to pick up on the subtleties for when it is preferable to use </span><code>filterer</code><span>. Much appreciated.</span></div><div data-t="levitanong Hi all, is there any way to mimic the functionality of multi-arity  map ?
 (map (fn [a b] ...) [1 2 3] [4 5 6])
"><span class="u" id="1501663505.022976">2017:08:02 08:45:05           levitanong </span><span>Hi all, is there any way to mimic the functionality of multi-arity </span><code>map</code><span>?
</span><pre>(map (fn [a b] ...) [1 2 3] [4 5 6])
</pre></div><div data-t="steveb8n I’m struggling with a conditional transform. seems simple but I can’t work it out. How do I transform a map value only if it is present?"><span class="u" id="1501720740.951880">2017:08:03 00:39:00             steveb8n </span><span>I’m struggling with a conditional transform. seems simple but I can’t work it out. How do I transform a map value only if it is present?</span></div><div data-t="steveb8n (transform [:b vector?] set {:a 1})"><span class="u" id="1501720758.955664">2017:08:03 00:39:18             steveb8n </span><code>(transform [:b vector?] set {:a 1})</code></div><div data-t="steveb8n will return  {:a 1, :b nil}"><span class="u" id="1501720784.961095">2017:08:03 00:39:44             steveb8n </span><span>will return </span><code>{:a 1, :b nil}</code></div><div data-t="steveb8n but I only want the “:b” transformed if “:b” is present"><span class="u" id="1501720817.968187">2017:08:03 00:40:17             steveb8n </span><span>but I only want the “:b” transformed if “:b” is present</span></div><div data-t="schmee @steveb8n  (s/must :b)"><span class="u" id="1501720911.987473">2017:08:03 00:41:51               schmee </span><span>@steveb8n </span><code>(s/must :b)</code></div><div data-t="schmee https://github.com/nathanmarz/specter/wiki/List-of-Navigators#must"><span class="u" id="1501720922.989715">2017:08:03 00:42:02               schmee </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#must">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#must</a></div><div data-t="steveb8n thanks @schmee I knew there had to be a simple answer"><span class="u" id="1501720974.000190">2017:08:03 00:42:54             steveb8n </span><span>thanks @schmee I knew there had to be a simple answer</span></div><div data-t="nathanmarz Released Specter 1.0.3  https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><span class="u" id="1502706946.550142">2017:08:14 10:35:46           nathanmarz </span><span>Released Specter 1.0.3 </span><a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></div><div data-t="nathanmarz (setval (index-nav 3) 1 [:a :b :c :d :e])
;; =&gt; [:a :d :b :c :e]

(select INDEXED-VALS [:a :b :c])
;; =&gt; [[0 :a] [1 :b] [2 :c]]

(setval [INDEXED-VALS FIRST] 0 [:a :b :c :d])
;; =&gt; [:d :c :b :a]

(setval (before-index 2) :a &apos;(0 1 2 3 4))
;; =&gt; (0 1 :a 2 3 4)
"><span class="u" id="1502707106.590765">2017:08:14 10:38:26           nathanmarz </span><pre>(setval (index-nav 3) 1 [:a :b :c :d :e])
;; =&gt; [:a :d :b :c :e]

(select INDEXED-VALS [:a :b :c])
;; =&gt; [[0 :a] [1 :b] [2 :c]]

(setval [INDEXED-VALS FIRST] 0 [:a :b :c :d])
;; =&gt; [:d :c :b :a]

(setval (before-index 2) :a &apos;(0 1 2 3 4))
;; =&gt; (0 1 :a 2 3 4)
</pre></div><div data-t="michaelwfogleman There was recently a very interesting question on Stack Overflow - no one has written a Specter-based solution yet... I am trying to write one."><span class="u" id="1503249656.000062">2017:08:20 17:20:56     michaelwfogleman </span><span>There was recently a very interesting question on Stack Overflow - no one has written a Specter-based solution yet... I am trying to write one.</span></div><div data-t="michaelwfogleman https://stackoverflow.com/questions/45764946/how-to-find-indexes-in-deeply-nested-data-structurevectors-and-lists-in-clojur"><span class="u" id="1503249669.000018">2017:08:20 17:21:09     michaelwfogleman </span><a href="https://stackoverflow.com/questions/45764946/how-to-find-indexes-in-deeply-nested-data-structurevectors-and-lists-in-clojur">https://stackoverflow.com/questions/45764946/how-to-find-indexes-in-deeply-nested-data-structurevectors-and-lists-in-clojur</a></div><div data-t="nathanmarz @michaelwfogleman I&apos;ll take a closer look later, but you basically want to use  recursive-path ,  collect-one , and  INDEXED-VALS"><span class="u" id="1503250122.000110">2017:08:20 17:28:42           nathanmarz </span><span>@michaelwfogleman I&apos;ll take a closer look later, but you basically want to use </span><code>recursive-path</code><span>, </span><code>collect-one</code><span>, and </span><code>INDEXED-VALS</code></div><div data-t="nathanmarz @michaelwfogleman looks like this:
 (defn find-index-route [v data]
  (let [p (recursive-path [] p
            (if-path sequential?
              [INDEXED-VALS
               (if-path [LAST (pred= v)]
                 FIRST
                 [(collect-one FIRST) LAST p]
                 )]))]
    (let [ret (select-first p data)]
      (if (vector? ret) ret [ret])
      )))
"><span class="u" id="1503254084.000035">2017:08:20 18:34:44           nathanmarz </span><span>@michaelwfogleman looks like this:
</span><pre>(defn find-index-route [v data]
  (let [p (recursive-path [] p
            (if-path sequential?
              [INDEXED-VALS
               (if-path [LAST (pred= v)]
                 FIRST
                 [(collect-one FIRST) LAST p]
                 )]))]
    (let [ret (select-first p data)]
      (if (vector? ret) ret [ret])
      )))
</pre></div><div data-t="souenzzo Mine, w/o specter but works on maps and find &quot;all&quot; routes
 (defn find-index-route
  &quot;find all routes to some value&quot;
  ([k x] (find-index-route k x []))
  ([k x p]
   (cond
     (= k x) [p]
     (coll? x) (-&gt;&gt; (if (map? x) x (vec x))
                    (reduce-kv (fn [acc i v]
                                 (into (vec (find-index-route k v (conj p i))) acc)) []))
     :else nil)))
"><span class="u" id="1503263743.000054">2017:08:20 21:15:43                  souenzzo </span><span>Mine, w/o specter but works on maps and find &quot;all&quot; routes
</span><pre>(defn find-index-route
  &quot;find all routes to some value&quot;
  ([k x] (find-index-route k x []))
  ([k x p]
   (cond
     (= k x) [p]
     (coll? x) (-&gt;&gt; (if (map? x) x (vec x))
                    (reduce-kv (fn [acc i v]
                                 (into (vec (find-index-route k v (conj p i))) acc)) []))
     :else nil)))
</pre></div><div data-t="nathanmarz @U2J4FRT2T a slight modification makes the specter version work for maps as well:
 (defn find-index-route [v data]
  (let [p (recursive-path [] p
            [(if-path map? ALL INDEXED-VALS)
             (if-path [LAST (pred= v)]
               FIRST
               [(collect-one FIRST) LAST coll? p]
               )])]
    (let [ret (select-first p data)]
      (if (or (nil? ret) (vector? ret)) ret [ret])
      )))
"><span class="u" id="1503300706.000315">2017:08:21 07:31:46                nathanmarz </span><span>@U2J4FRT2T a slight modification makes the specter version work for maps as well:
</span><pre>(defn find-index-route [v data]
  (let [p (recursive-path [] p
            [(if-path map? ALL INDEXED-VALS)
             (if-path [LAST (pred= v)]
               FIRST
               [(collect-one FIRST) LAST coll? p]
               )])]
    (let [ret (select-first p data)]
      (if (or (nil? ret) (vector? ret)) ret [ret])
      )))
</pre></div><div data-t="michaelwfogleman pred= and friends are great!"><span class="u" id="1503317335.000189">2017:08:21 12:08:55     michaelwfogleman </span><span>pred= and friends are great!</span></div><div data-t="michaelwfogleman @nathanmarz Is it possible to contribute to the Specter wiki?"><span class="u" id="1503318266.000227">2017:08:21 12:24:26     michaelwfogleman </span><span>@nathanmarz Is it possible to contribute to the Specter wiki?</span></div><div data-t="michaelwfogleman When you first mentioned recursive-path, I noticed it wasn&apos;t documented (in the Macros section?). I dug up the mention in Changes.MD that had an example. I cloned the wiki and made a change locally but would like to contribute it"><span class="u" id="1503318331.000223">2017:08:21 12:25:31     michaelwfogleman </span><span>When you first mentioned recursive-path, I noticed it wasn&apos;t documented (in the Macros section?). I dug up the mention in Changes.MD that had an example. I cloned the wiki and made a change locally but would like to contribute it</span></div><div data-t="nathanmarz @michaelwfogleman yea, I wish github had a way to make pull requests for project wikis"><span class="u" id="1503319230.000001">2017:08:21 12:40:30           nathanmarz </span><span>@michaelwfogleman yea, I wish github had a way to make pull requests for project wikis</span></div><div data-t="nathanmarz maybe I can make the specter wiki its own project and keep it in sync myself"><span class="u" id="1503319258.000312">2017:08:21 12:40:58           nathanmarz </span><span>maybe I can make the specter wiki its own project and keep it in sync myself</span></div><div data-t="nathanmarz @michaelwfogleman ok, make a pull request to  https://github.com/nathanmarz/specter-wiki"><span class="u" id="1503319385.000155">2017:08:21 12:43:05           nathanmarz </span><span>@michaelwfogleman ok, make a pull request to </span><a href="https://github.com/nathanmarz/specter-wiki">https://github.com/nathanmarz/specter-wiki</a></div><div data-t="michaelwfogleman Awesome! Done!"><span class="u" id="1503319598.000447">2017:08:21 12:46:38     michaelwfogleman </span><span>Awesome! Done!</span></div><div data-t="michaelwfogleman Happy to tweak the documentation if it&apos;s not quite right.  🙂"><span class="u" id="1503319616.000360">2017:08:21 12:46:56     michaelwfogleman </span><span>Happy to tweak the documentation if it&apos;s not quite right. </span><b>🙂</b></div><div data-t="nathanmarz awesome, merged"><span class="u" id="1503319818.000002">2017:08:21 12:50:18           nathanmarz </span><span>awesome, merged</span></div><div data-t="nathanmarz should probably add example of transform and an example of a parameterized recursive-path"><span class="u" id="1503319832.000246">2017:08:21 12:50:32           nathanmarz </span><span>should probably add example of transform and an example of a parameterized recursive-path</span></div><div data-t="nathanmarz can open issues on specter-wiki repository for anything you find that&apos;s lacking"><span class="u" id="1503319901.000148">2017:08:21 12:51:41           nathanmarz </span><span>can open issues on specter-wiki repository for anything you find that&apos;s lacking</span></div><div data-t="nathanmarz (which is probably a lot of things)"><span class="u" id="1503319909.000185">2017:08:21 12:51:49           nathanmarz </span><span>(which is probably a lot of things)</span></div><div data-t="twillis hello, just discovered specter yesterday and I thought it might help me transforming honeysql queries. for example given...


 {:select (:*), :from (:table), :where [:or [:and [:= :a 1] [:b 1]] [:and [:= :c 1] [:= :d 1]]]}
 

example: if i need to add  [:= :active true]  to each clause. 

having trouble specifying the path past  [:where ALL]  , i guess it&apos;s a problem with the sequences having a keyword as the first element."><span class="u" id="1503320303.000232">2017:08:21 12:58:23              twillis </span><span>hello, just discovered specter yesterday and I thought it might help me transforming honeysql queries. for example given...


</span><pre>{:select (:*), :from (:table), :where [:or [:and [:= :a 1] [:b 1]] [:and [:= :c 1] [:= :d 1]]]}
</pre><span>

example: if i need to add </span><code>[:= :active true]</code><span> to each clause. 

having trouble specifying the path past </span><code>[:where ALL]</code><span> , i guess it&apos;s a problem with the sequences having a keyword as the first element.</span></div><div data-t="nathanmarz @twillis do you want to add that clause to the top-level of  :where  (e.g.  [:and [:= :active true] [:or ...]] ) or within each  :and  clause?"><span class="u" id="1503325612.000536">2017:08:21 14:26:52           nathanmarz </span><span>@twillis do you want to add that clause to the top-level of </span><code>:where</code><span> (e.g. </span><code>[:and [:= :active true] [:or ...]]</code><span>) or within each </span><code>:and</code><span> clause?</span></div><div data-t="nathanmarz if the latter you&apos;ll probably need a recursive path since  :and  and  :or  can nest arbitrarily"><span class="u" id="1503325698.000633">2017:08:21 14:28:18           nathanmarz </span><span>if the latter you&apos;ll probably need a recursive path since </span><code>:and</code><span> and </span><code>:or</code><span> can nest arbitrarily</span></div><div data-t="twillis well in the above example I was thinking of adding to each clause but it was just an arbitrary example. but I think the issue i&apos;m having is that I dont know how to get to things in a vector where the first item is a keyword."><span class="u" id="1503325949.000484">2017:08:21 14:32:29              twillis </span><span>well in the above example I was thinking of adding to each clause but it was just an arbitrary example. but I think the issue i&apos;m having is that I dont know how to get to things in a vector where the first item is a keyword.</span></div><div data-t="nathanmarz you can use this to navigate to each node in tree: 
 (def TreeNodes
    (recursive-path [] p
     (if-path sequential?
       (continue-then-stay ALL p)
       STAY
       )))
"><span class="u" id="1503326314.000257">2017:08:21 14:38:34           nathanmarz </span><span>you can use this to navigate to each node in tree: 
</span><pre>(def TreeNodes
    (recursive-path [] p
     (if-path sequential?
       (continue-then-stay ALL p)
       STAY
       )))
</pre></div><div data-t="nathanmarz then something like this for your transform:
 (setval [:where TreeNodes vector? (selected? FIRST (pred= :and)) AFTER-ELEM] [:= :active true] data)
  "><span class="u" id="1503326512.000201">2017:08:21 14:41:52           nathanmarz </span><span>then something like this for your transform:
</span><pre>(setval [:where TreeNodes vector? (selected? FIRST (pred= :and)) AFTER-ELEM] [:= :active true] data)
</pre><span> </span></div><div data-t="twillis ok thanks for your help @nathanmarz"><span class="u" id="1503326727.000104">2017:08:21 14:45:27              twillis </span><span>ok thanks for your help @nathanmarz</span></div><div data-t="urbank Hm... where does  pred=  come from? Is it just a user defined function?"><span class="u" id="1503338358.000485">2017:08:21 17:59:18               urbank </span><span>Hm... where does </span><code>pred=</code><span> come from? Is it just a user defined function?</span></div><div data-t="urbank Oh, it&apos;s a specter function. Didn&apos;t notice that none of the functions were namespaced in the samples"><span class="u" id="1503338473.000247">2017:08:21 18:01:13               urbank </span><span>Oh, it&apos;s a specter function. Didn&apos;t notice that none of the functions were namespaced in the samples</span></div><div data-t="nathanmarz it&apos;s just a convenience, same as  #(= % some-val)"><span class="u" id="1503338833.000516">2017:08:21 18:07:13           nathanmarz </span><span>it&apos;s just a convenience, same as </span><code>#(= % some-val)</code></div><div data-t="urbank Yeah, figured. Just thought it was a part of clojure core or something"><span class="u" id="1503338994.000295">2017:08:21 18:09:54               urbank </span><span>Yeah, figured. Just thought it was a part of clojure core or something</span></div><div data-t="lvh Is there some way to coalesce a bunch of sequential transforms, and would there be a performance benefit from doing so?"><span class="u" id="1503531148.000206">2017:08:23 23:32:28                  lvh </span><span>Is there some way to coalesce a bunch of sequential transforms, and would there be a performance benefit from doing so?</span></div><div data-t="lvh (My transforms don’t commute.)"><span class="u" id="1503531156.000052">2017:08:23 23:32:36                  lvh </span><span>(My transforms don’t commute.)</span></div><div data-t="nathanmarz @lvh if there&apos;s shared navigation among the transforms then  multi-transform  can be used for major performance gains"><span class="u" id="1503538318.000001">2017:08:24 01:31:58           nathanmarz </span><span>@lvh if there&apos;s shared navigation among the transforms then </span><code>multi-transform</code><span> can be used for major performance gains</span></div><div data-t="nathanmarz a couple examples from benchmarks:  https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L336"><span class="u" id="1503538442.000030">2017:08:24 01:34:02           nathanmarz </span><span>a couple examples from benchmarks: </span><a href="https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L336">https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L336</a></div><div data-t="sandbags @nathanmarz here&apos;s my use case, see if you think Specter makes this easier. I&apos;m building a library for modular behaviour trees. i&apos;ve decided to represent these as nested vectors a la Hiccup markup so, for example  [:selector [:loop {:count 99} [:sequence [:randomly {:p 0.5} [:foo]] [:randomly {:p 0.25} [:bar]] [:baz]]]]"><span class="u" id="1503683635.000365">2017:08:25 17:53:55             sandbags </span><span>@nathanmarz here&apos;s my use case, see if you think Specter makes this easier. I&apos;m building a library for modular behaviour trees. i&apos;ve decided to represent these as nested vectors a la Hiccup markup so, for example </span><code>[:selector [:loop {:count 99} [:sequence [:randomly {:p 0.5} [:foo]] [:randomly {:p 0.25} [:bar]] [:baz]]]]</code></div><div data-t="sandbags what i want to do is (1) label each vector with an autogenerated id, (2) check that required options are specified (e.g.  :loop  must always have a  :count  option) (3) check required number of children is specified (e.g.  :loop  always has exactly 1 child)"><span class="u" id="1503683699.000115">2017:08:25 17:54:59             sandbags </span><span>what i want to do is (1) label each vector with an autogenerated id, (2) check that required options are specified (e.g. </span><code>:loop</code><span> must always have a </span><code>:count</code><span> option) (3) check required number of children is specified (e.g. </span><code>:loop</code><span> always has exactly 1 child)</span></div><div data-t="sandbags i have code doing this based on postwalk (well i&apos;ve not done 3 yet but it&apos;s a trivial modification of 2)"><span class="u" id="1503683740.000028">2017:08:25 17:55:40             sandbags </span><span>i have code doing this based on postwalk (well i&apos;ve not done 3 yet but it&apos;s a trivial modification of 2)</span></div><div data-t="sandbags at the moment I am hoisting the options map (and the id) into the metadata for the vector"><span class="u" id="1503683766.000261">2017:08:25 17:56:06             sandbags </span><span>at the moment I am hoisting the options map (and the id) into the metadata for the vector</span></div><div data-t="sandbags i&apos;m undecided whether a better approach would be to add an options map to all vectors and put the id in there instead"><span class="u" id="1503683797.000294">2017:08:25 17:56:37             sandbags </span><span>i&apos;m undecided whether a better approach would be to add an options map to all vectors and put the id in there instead</span></div><div data-t="nathanmarz @sandbags yes, this is exactly the kind of stuff specter excels at"><span class="u" id="1503685294.000384">2017:08:25 18:21:34           nathanmarz </span><span>@sandbags yes, this is exactly the kind of stuff specter excels at</span></div><div data-t="nathanmarz i&apos;ll show you an example"><span class="u" id="1503685303.000192">2017:08:25 18:21:43           nathanmarz </span><span>i&apos;ll show you an example</span></div><div data-t="sandbags (one thing that the walk approach does not seem to make particularly easy is giving diagnostic information)"><span class="u" id="1503685497.000364">2017:08:25 18:24:57             sandbags </span><span>(one thing that the walk approach does not seem to make particularly easy is giving diagnostic information)</span></div><div data-t="nathanmarz (def data [:selector [:loop {:count 99} [:sequence [:randomly {:p 0.5} [:foo]] [:randomly {:p 0.25} [:bar]] [:baz]]]])

(def ALL-VECTORS
  (recursive-path [] p
    (if-path vector?
      (continue-then-stay ALL p))))

(let [data2 (transform (subselect ALL-VECTORS META :id) (fn [s] (-&gt; s count range)) data)]
  (select [ALL-VECTORS (collect-one META :id)] data2))
;; =&gt;
[[0 [:foo]]
 [1 [:randomly {:p 0.5} [:foo]]]
 [2 [:bar]]
 [3 [:randomly {:p 0.25} [:bar]]]
 [4 [:baz]]
 [5
  [:sequence
   [:randomly {:p 0.5} [:foo]]
   [:randomly {:p 0.25} [:bar]]
   [:baz]]]
 [6
  [:loop
   {:count 99}
   [:sequence
    [:randomly {:p 0.5} [:foo]]
    [:randomly {:p 0.25} [:bar]]
    [:baz]]]]
 [7
  [:selector
   [:loop
    {:count 99}
    [:sequence
     [:randomly {:p 0.5} [:foo]]
     [:randomly {:p 0.25} [:bar]]
     [:baz]]]]]]
"><span class="u" id="1503685527.000380">2017:08:25 18:25:27           nathanmarz </span><pre>(def data [:selector [:loop {:count 99} [:sequence [:randomly {:p 0.5} [:foo]] [:randomly {:p 0.25} [:bar]] [:baz]]]])

(def ALL-VECTORS
  (recursive-path [] p
    (if-path vector?
      (continue-then-stay ALL p))))

(let [data2 (transform (subselect ALL-VECTORS META :id) (fn [s] (-&gt; s count range)) data)]
  (select [ALL-VECTORS (collect-one META :id)] data2))
;; =&gt;
[[0 [:foo]]
 [1 [:randomly {:p 0.5} [:foo]]]
 [2 [:bar]]
 [3 [:randomly {:p 0.25} [:bar]]]
 [4 [:baz]]
 [5
  [:sequence
   [:randomly {:p 0.5} [:foo]]
   [:randomly {:p 0.25} [:bar]]
   [:baz]]]
 [6
  [:loop
   {:count 99}
   [:sequence
    [:randomly {:p 0.5} [:foo]]
    [:randomly {:p 0.25} [:bar]]
    [:baz]]]]
 [7
  [:selector
   [:loop
    {:count 99}
    [:sequence
     [:randomly {:p 0.5} [:foo]]
     [:randomly {:p 0.25} [:bar]]
     [:baz]]]]]]
</pre></div><div data-t="nathanmarz that&apos;s adding the auto-generated id to the metadata of each vector, the  select  call is just so you can see what it did"><span class="u" id="1503685566.000505">2017:08:25 18:26:06           nathanmarz </span><span>that&apos;s adding the auto-generated id to the metadata of each vector, the </span><code>select</code><span> call is just so you can see what it did</span></div><div data-t="sandbags interesting, thank you"><span class="u" id="1503685644.000639">2017:08:25 18:27:24             sandbags </span><span>interesting, thank you</span></div><div data-t="sandbags i definitely need to go back and read the docs again"><span class="u" id="1503685681.000039">2017:08:25 18:28:01             sandbags </span><span>i definitely need to go back and read the docs again</span></div><div data-t="nathanmarz here&apos;s how you could insert ids at index 1 of each vector:
 (transform (subselect ALL-VECTORS (srange 1 1)) (fn [s] (-&gt;&gt; s count range (map vector))) data)
;;=&gt; [:selector 7 [:loop 6 {:count 99} [:sequence 5 [:randomly 1 {:p 0.5} [:foo 0]] [:randomly 3 {:p 0.25} [:bar 2]] [:baz 4]]]]
"><span class="u" id="1503685768.000240">2017:08:25 18:29:28           nathanmarz </span><span>here&apos;s how you could insert ids at index 1 of each vector:
</span><pre>(transform (subselect ALL-VECTORS (srange 1 1)) (fn [s] (-&gt;&gt; s count range (map vector))) data)
;;=&gt; [:selector 7 [:loop 6 {:count 99} [:sequence 5 [:randomly 1 {:p 0.5} [:foo 0]] [:randomly 3 {:p 0.25} [:bar 2]] [:baz 4]]]]
</pre></div><div data-t="nathanmarz and as one last example, here&apos;s how you would manipulate a particular node type in the tree:
 (defn node-type [kw] (path (selected? FIRST (pred= kw))))

(transform [ALL-VECTORS (node-type :randomly) (nthpath 1) :p] #(* 2 %) data)
;; =&gt; [:selector [:loop {:count 99} [:sequence [:randomly {:p 1.0} [:foo]] [:randomly {:p 0.5} [:bar]] [:baz]]]]
"><span class="u" id="1503685958.000083">2017:08:25 18:32:38           nathanmarz </span><span>and as one last example, here&apos;s how you would manipulate a particular node type in the tree:
</span><pre>(defn node-type [kw] (path (selected? FIRST (pred= kw))))

(transform [ALL-VECTORS (node-type :randomly) (nthpath 1) :p] #(* 2 %) data)
;; =&gt; [:selector [:loop {:count 99} [:sequence [:randomly {:p 1.0} [:foo]] [:randomly {:p 0.5} [:bar]] [:baz]]]]
</pre></div><div data-t="sandbags that&apos;s very cute"><span class="u" id="1503686009.000006">2017:08:25 18:33:29             sandbags </span><span>that&apos;s very cute</span></div><div data-t="sandbags it&apos;s really a shame Specter isn&apos;t better known. I know about it and a number of times i&apos;ve messed around for hours with walk/zippers etc. trying to do something that would have been easier with a bit of Specter"><span class="u" id="1503686078.000152">2017:08:25 18:34:38             sandbags </span><span>it&apos;s really a shame Specter isn&apos;t better known. I know about it and a number of times i&apos;ve messed around for hours with walk/zippers etc. trying to do something that would have been easier with a bit of Specter</span></div><div data-t="nathanmarz I consider it essential for immutable programming"><span class="u" id="1503686217.000108">2017:08:25 18:36:57           nathanmarz </span><span>I consider it essential for immutable programming</span></div><div data-t="nathanmarz I&apos;ve encountered a surprising amount of resistance to it though"><span class="u" id="1503686238.000296">2017:08:25 18:37:18           nathanmarz </span><span>I&apos;ve encountered a surprising amount of resistance to it though</span></div><div data-t="sandbags i guess one downside (but probably just inherent in this kind of complex structure bending) is that those expressions take some real picking apart"><span class="u" id="1503686241.000120">2017:08:25 18:37:21             sandbags </span><span>i guess one downside (but probably just inherent in this kind of complex structure bending) is that those expressions take some real picking apart</span></div><div data-t="sandbags it&apos;s always going to make for a bit of a learning hill"><span class="u" id="1503686268.000173">2017:08:25 18:37:48             sandbags </span><span>it&apos;s always going to make for a bit of a learning hill</span></div><div data-t="nathanmarz I wouldn&apos;t consider conciseness a downside, but the opposite"><span class="u" id="1503686273.000317">2017:08:25 18:37:53           nathanmarz </span><span>I wouldn&apos;t consider conciseness a downside, but the opposite</span></div><div data-t="nathanmarz definitely a learning curve"><span class="u" id="1503686276.000401">2017:08:25 18:37:56           nathanmarz </span><span>definitely a learning curve</span></div><div data-t="nathanmarz what you&apos;re seeing here is the result after me learning this stuff for years"><span class="u" id="1503686290.000049">2017:08:25 18:38:10           nathanmarz </span><span>what you&apos;re seeing here is the result after me learning this stuff for years</span></div><div data-t="sandbags that&apos;s what i mean"><span class="u" id="1503686295.000716">2017:08:25 18:38:15             sandbags </span><span>that&apos;s what i mean</span></div><div data-t="nathanmarz it&apos;s a different way of thinking"><span class="u" id="1503686317.000385">2017:08:25 18:38:37           nathanmarz </span><span>it&apos;s a different way of thinking</span></div><div data-t="nathanmarz but it brings true simplicity and an incredible amount of power over your data"><span class="u" id="1503686351.000442">2017:08:25 18:39:11           nathanmarz </span><span>but it brings true simplicity and an incredible amount of power over your data</span></div><div data-t="sandbags i don&apos;t doubt it"><span class="u" id="1503686382.000562">2017:08:25 18:39:42             sandbags </span><span>i don&apos;t doubt it</span></div><div data-t="sandbags what do Rich &amp; co. make of it?"><span class="u" id="1503686536.000083">2017:08:25 18:42:16             sandbags </span><span>what do Rich &amp; co. make of it?</span></div><div data-t="nathanmarz no idea, I&apos;m curious about that myself"><span class="u" id="1503686582.000491">2017:08:25 18:43:02           nathanmarz </span><span>no idea, I&apos;m curious about that myself</span></div><div data-t="nathanmarz they haven&apos;t said anything about it to my knowledge"><span class="u" id="1503686599.000376">2017:08:25 18:43:19           nathanmarz </span><span>they haven&apos;t said anything about it to my knowledge</span></div><div data-t="sandbags Stuart Holloway, for example, I should have thought would find this interesting."><span class="u" id="1503686618.000361">2017:08:25 18:43:38             sandbags </span><span>Stuart Holloway, for example, I should have thought would find this interesting.</span></div><div data-t="nathanmarz I suggested contributing specter to clojure awhile back, but the response from core team was &quot;no&quot; with minimal explanation  https://groups.google.com/forum/#!searchin/clojure/contribute$20specter%7Csort:relevance/clojure/qN1UPMVQmaM/uegIimKjCwAJ"><span class="u" id="1503686828.000169">2017:08:25 18:47:08           nathanmarz </span><span>I suggested contributing specter to clojure awhile back, but the response from core team was &quot;no&quot; with minimal explanation </span><a href="https://groups.google.com/forum/#!searchin/clojure/contribute$20specter%7Csort:relevance/clojure/qN1UPMVQmaM/uegIimKjCwAJ">https://groups.google.com/forum/#!searchin/clojure/contribute$20specter%7Csort:relevance/clojure/qN1UPMVQmaM/uegIimKjCwAJ</a></div><div data-t="nathanmarz also saw this recently which makes me think rich would have serious problems with specter:  https://gist.github.com/reborg/dc8b0c96c397a56668905e2767fd697f"><span class="u" id="1503686929.000437">2017:08:25 18:48:49           nathanmarz </span><span>also saw this recently which makes me think rich would have serious problems with specter: </span><a href="https://gist.github.com/reborg/dc8b0c96c397a56668905e2767fd697f">https://gist.github.com/reborg/dc8b0c96c397a56668905e2767fd697f</a></div><div data-t="nathanmarz since he&apos;s philosophically against the same function having different performance characteristics on different datatypes, he won&apos;t like how I designed the navigators"><span class="u" id="1503687014.000295">2017:08:25 18:50:14           nathanmarz </span><span>since he&apos;s philosophically against the same function having different performance characteristics on different datatypes, he won&apos;t like how I designed the navigators</span></div><div data-t="nathanmarz nthpath  for instance being O(n) on lists but faster on vectors (O(log n) I think)"><span class="u" id="1503687061.000579">2017:08:25 18:51:01           nathanmarz </span><code>nthpath</code><span> for instance being O(n) on lists but faster on vectors (O(log n) I think)</span></div><div data-t="sandbags hrmmm"><span class="u" id="1503687517.000358">2017:08:25 18:58:37             sandbags </span><span>hrmmm</span></div><div data-t="sandbags Ah well, perhaps for the best anyway"><span class="u" id="1503687847.000201">2017:08:25 19:04:07             sandbags </span><span>Ah well, perhaps for the best anyway</span></div><div data-t="franquito Hi! I&apos;ve been thinking of defining a new path with parameters. I saw that  paramsfn  is not available anymore. Now, I think of two possible ways to define the path:  (defn [&amp; params] (spec/path ...))  or with  declarepath  and  providepath  (BTW, for this last pair of functions there&apos;s not an example of using parameters on the wiki). Which one should I use?  🤔"><span class="u" id="1503851138.000009">2017:08:27 16:25:38            franquito </span><span>Hi! I&apos;ve been thinking of defining a new path with parameters. I saw that </span><code>paramsfn</code><span> is not available anymore. Now, I think of two possible ways to define the path: </span><code>(defn [&amp; params] (spec/path ...))</code><span> or with </span><code>declarepath</code><span> and </span><code>providepath</code><span> (BTW, for this last pair of functions there&apos;s not an example of using parameters on the wiki). Which one should I use? </span><b>🤔</b></div><div data-t="nathanmarz @franquito just use  defn  and define the returned path with  path"><span class="u" id="1503855690.000074">2017:08:27 17:41:30           nathanmarz </span><span>@franquito just use </span><code>defn</code><span> and define the returned path with </span><code>path</code></div><div data-t="nathanmarz examples:  https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L843"><span class="u" id="1503855975.000025">2017:08:27 17:46:15           nathanmarz </span><span>examples: </span><a href="https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L843">https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L843</a></div><div data-t="franquito Sweet! Thank you very much Nathan!"><span class="u" id="1503857367.000010">2017:08:27 18:09:27            franquito </span><span>Sweet! Thank you very much Nathan!</span></div><div data-t="alexyakushev Hi, I remember I saw something somewhere about Specter supporting iteration over multiple sequences (like Clojure&apos;s  map  does). Maybe, it was an explanation why Specter doesn&apos;t have this; anyway, I can&apos;t find the link. Can anyone help? A pointer how to work around this problem would be nice too. Thanks!"><span class="u" id="1503950023.000073">2017:08:28 19:53:43         alexyakushev </span><span>Hi, I remember I saw something somewhere about Specter supporting iteration over multiple sequences (like Clojure&apos;s </span><code>map</code><span> does). Maybe, it was an explanation why Specter doesn&apos;t have this; anyway, I can&apos;t find the link. Can anyone help? A pointer how to work around this problem would be nice too. Thanks!</span></div><div data-t="nathanmarz @alexyakushev no, Specter doesn&apos;t support that"><span class="u" id="1503950209.000303">2017:08:28 19:56:49           nathanmarz </span><span>@alexyakushev no, Specter doesn&apos;t support that</span></div><div data-t="nathanmarz besides questions of how to do a performant implementation of that, there&apos;s questions of semantics too"><span class="u" id="1503950298.000086">2017:08:28 19:58:18           nathanmarz </span><span>besides questions of how to do a performant implementation of that, there&apos;s questions of semantics too</span></div><div data-t="nathanmarz for instance, what would an  ALL  transform on a vector and a map produce?"><span class="u" id="1503950323.000269">2017:08:28 19:58:43           nathanmarz </span><span>for instance, what would an </span><code>ALL</code><span> transform on a vector and a map produce?</span></div><div data-t="alexyakushev @nathanmarz Yeah, I thought it was something along these lines.  map  was always an outlier among other sequence processing functions, it makes sense that Specter doesn&apos;t have it.
Regarding my problem, I need to  merge  two lists of lists of lists of maps. Without Specter, I solved it with an abhorrent lasagna of  (partial map ...) . Can Specter help here somehow?"><span class="u" id="1503950503.000269">2017:08:28 20:01:43         alexyakushev </span><span>@nathanmarz Yeah, I thought it was something along these lines. </span><code>map</code><span> was always an outlier among other sequence processing functions, it makes sense that Specter doesn&apos;t have it.
Regarding my problem, I need to </span><code>merge</code><span> two lists of lists of lists of maps. Without Specter, I solved it with an abhorrent lasagna of </span><code>(partial map ...)</code><span>. Can Specter help here somehow?</span></div><div data-t="nathanmarz @alexyakushev unfortunately not"><span class="u" id="1503950873.000645">2017:08:28 20:07:53           nathanmarz </span><span>@alexyakushev unfortunately not</span></div><div data-t="nathanmarz I had an idea open awhile ago that would have helped, or an extension of it  https://github.com/nathanmarz/specter/issues/49"><span class="u" id="1503950889.000451">2017:08:28 20:08:09           nathanmarz </span><span>I had an idea open awhile ago that would have helped, or an extension of it </span><a href="https://github.com/nathanmarz/specter/issues/49">https://github.com/nathanmarz/specter/issues/49</a></div><div data-t="nathanmarz basically you  locate  the specific paths to elements you care about, then use the element-specific path to get the corresponding value in the other data structure"><span class="u" id="1503950928.000134">2017:08:28 20:08:48           nathanmarz </span><span>basically you </span><code>locate</code><span> the specific paths to elements you care about, then use the element-specific path to get the corresponding value in the other data structure</span></div><div data-t="nathanmarz locate  is complicated to implement especially for substructure navigators like  srange"><span class="u" id="1503951021.000050">2017:08:28 20:10:21           nathanmarz </span><code>locate</code><span> is complicated to implement especially for substructure navigators like </span><code>srange</code></div><div data-t="nathanmarz I hadn&apos;t thought before about how something like  locate  would help with processing multiple data structures together"><span class="u" id="1503951130.000179">2017:08:28 20:12:10           nathanmarz </span><span>I hadn&apos;t thought before about how something like </span><code>locate</code><span> would help with processing multiple data structures together</span></div><div data-t="alexyakushev @nathanmarz Thanks! This is still quite helpful."><span class="u" id="1503951893.000031">2017:08:28 20:24:53         alexyakushev </span><span>@nathanmarz Thanks! This is still quite helpful.</span></div><div data-t="nathanmarz I ended up implementing something different than  locate  as described in that ticket, but this might be worth considering again"><span class="u" id="1503952085.000367">2017:08:28 20:28:05           nathanmarz </span><span>I ended up implementing something different than </span><code>locate</code><span> as described in that ticket, but this might be worth considering again</span></div><div data-t="nathanmarz Having a broader set of use cases would be needed to understand how to spec the new operation"><span class="u" id="1503952119.000264">2017:08:28 20:28:39           nathanmarz </span><span>Having a broader set of use cases would be needed to understand how to spec the new operation</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/issues/229"><span class="u" id="1503952793.000616">2017:08:28 20:39:53           nathanmarz </span><a href="https://github.com/nathanmarz/specter/issues/229">https://github.com/nathanmarz/specter/issues/229</a></div><div data-t="urzds Hi!"><span class="u" id="1504031801.000067">2017:08:29 18:36:41                urzds </span><span>Hi!</span></div><div data-t="urzds I have an ip-pool  {&quot;127.0.0.1&quot; {:k v}}  and would like to get first IP where  :k  is  nil . How would I do that? I would hope to get a more readable version of  (first (first (filter #(nil? (:k (second %))) ip-pool)"><span class="u" id="1504032254.000120">2017:08:29 18:44:14                urzds </span><span>I have an ip-pool </span><code>{&quot;127.0.0.1&quot; {:k v}}</code><span> and would like to get first IP where </span><code>:k</code><span> is </span><code>nil</code><span>. How would I do that? I would hope to get a more readable version of </span><code>(first (first (filter #(nil? (:k (second %))) ip-pool)</code></div><div data-t="nathanmarz @urzds what does &quot;first&quot; mean in this context given that your input is an unsorted map?"><span class="u" id="1504032383.000021">2017:08:29 18:46:23           nathanmarz </span><span>@urzds what does &quot;first&quot; mean in this context given that your input is an unsorted map?</span></div><div data-t="urzds any, but one is enough"><span class="u" id="1504032409.000228">2017:08:29 18:46:49                urzds </span><span>any, but one is enough</span></div><div data-t="urzds i.e. I don&apos;t care which one, but I want only one and not more. The result shall be the key, i.e. a string, e.g. &quot;127.0.0.1&quot;."><span class="u" id="1504032495.000068">2017:08:29 18:48:15                urzds </span><span>i.e. I don&apos;t care which one, but I want only one and not more. The result shall be the key, i.e. a string, e.g. &quot;127.0.0.1&quot;.</span></div><div data-t="urzds I don&apos;t like the regular-Clojure version I wrote above, because it is not immediately clear what the two  first s mean.  second  can be deduced, if one knows  ip-pool  is a map and how  filter  works, but I find the two  first  to be not obvious enough."><span class="u" id="1504032624.000039">2017:08:29 18:50:24                urzds </span><span>I don&apos;t like the regular-Clojure version I wrote above, because it is not immediately clear what the two </span><code>first</code><span>s mean. </span><code>second</code><span> can be deduced, if one knows </span><code>ip-pool</code><span> is a map and how </span><code>filter</code><span> works, but I find the two </span><code>first</code><span> to be not obvious enough.</span></div><div data-t="nathanmarz @urzds 
 (def data {&quot;127.0.0.1&quot; {:k 3} &quot;127.0.0.2&quot; {} &quot;127.0.0.3&quot; {:b 2}})
(select-first [ALL (selected? LAST :k nil?) FIRST] data)
"><span class="u" id="1504032808.000693">2017:08:29 18:53:28           nathanmarz </span><span>@urzds 
</span><pre>(def data {&quot;127.0.0.1&quot; {:k 3} &quot;127.0.0.2&quot; {} &quot;127.0.0.3&quot; {:b 2}})
(select-first [ALL (selected? LAST :k nil?) FIRST] data)
</pre></div><div data-t="nathanmarz if you want all of them just change  select-first  to  select"><span class="u" id="1504032835.000258">2017:08:29 18:53:55           nathanmarz </span><span>if you want all of them just change </span><code>select-first</code><span> to </span><code>select</code></div><div data-t="urzds (selected? ...)  is basically like  (some? (select ...)) ?"><span class="u" id="1504032988.000214">2017:08:29 18:56:28                urzds </span><code>(selected? ...)</code><span> is basically like </span><code>(some? (select ...))</code><span>?</span></div><div data-t="nathanmarz it&apos;s like  (not (empty? (select ...)))  except it runs far more efficiently than that"><span class="u" id="1504033070.000313">2017:08:29 18:57:50           nathanmarz </span><span>it&apos;s like </span><code>(not (empty? (select ...)))</code><span> except it runs far more efficiently than that</span></div><div data-t="nathanmarz no materialization of intermediate sequences and stops traversal as soon as it matches something"><span class="u" id="1504033102.000119">2017:08:29 18:58:22           nathanmarz </span><span>no materialization of intermediate sequences and stops traversal as soon as it matches something</span></div><div data-t="nathanmarz same as  select-first"><span class="u" id="1504033109.000001">2017:08:29 18:58:29           nathanmarz </span><span>same as </span><code>select-first</code></div><div data-t="urzds Thanks."><span class="u" id="1504033136.000054">2017:08:29 18:58:56                urzds </span><span>Thanks.</span></div><div data-t="urzds Guess I should alias LAST to VALUE and FIRST to KEY. That might make it easier to read..."><span class="u" id="1504033141.000553">2017:08:29 18:59:01                urzds </span><span>Guess I should alias LAST to VALUE and FIRST to KEY. That might make it easier to read...</span></div><div data-t="nathanmarz yea, that&apos;s easy enough"><span class="u" id="1504033177.000427">2017:08:29 18:59:37           nathanmarz </span><span>yea, that&apos;s easy enough</span></div><div data-t="urzds If I wanted to select the IP address where  :k  is 1, I would run  (select-first [ALL (selected? LAST :k #(= % 1)) FIRST] data)  ?"><span class="u" id="1504033232.000405">2017:08:29 19:00:32                urzds </span><span>If I wanted to select the IP address where </span><code>:k</code><span> is 1, I would run </span><code>(select-first [ALL (selected? LAST :k #(= % 1)) FIRST] data)</code><span> ?</span></div><div data-t="nathanmarz yea"><span class="u" id="1504033283.000388">2017:08:29 19:01:23           nathanmarz </span><span>yea</span></div><div data-t="nathanmarz can also say  (pred= 1)  instead of the anonymous function"><span class="u" id="1504033296.000385">2017:08:29 19:01:36           nathanmarz </span><span>can also say </span><code>(pred= 1)</code><span> instead of the anonymous function</span></div><div data-t="urzds pred=  is defined by Specter?"><span class="u" id="1504033324.000206">2017:08:29 19:02:04                urzds </span><code>pred=</code><span> is defined by Specter?</span></div><div data-t="nathanmarz yes"><span class="u" id="1504033327.000183">2017:08:29 19:02:07           nathanmarz </span><span>yes</span></div><div data-t="nathanmarz there&apos;s also  pred&gt; ,  pred&lt; ,  pred&lt;= , and  pred&gt;="><span class="u" id="1504033343.000281">2017:08:29 19:02:23           nathanmarz </span><span>there&apos;s also </span><code>pred&gt;</code><span>, </span><code>pred&lt;</code><span>, </span><code>pred&lt;=</code><span>, and </span><code>pred&gt;=</code></div><div data-t="nathanmarz just convenience navigators"><span class="u" id="1504033353.000575">2017:08:29 19:02:33           nathanmarz </span><span>just convenience navigators</span></div><div data-t="nathanmarz I find it slightly more readable"><span class="u" id="1504033365.000629">2017:08:29 19:02:45           nathanmarz </span><span>I find it slightly more readable</span></div><div data-t="urzds Thanks @nathanmarz !"><span class="u" id="1504034217.000663">2017:08:29 19:16:57                urzds </span><span>Thanks @nathanmarz !</span></div><div data-t="lvh I have a data structure like:

 {:x
 {:a {:y 1}
  :b {:y 2}
  :c {:y 3}}}
 

And I’d like  {:a 1 :b 2 :c 3} . I can write the select path that gets the values:  [:x (sr/multi-path :a :b :c) :y] , and I guess I can zipmap from there; but is there an elegant way to get specter to do that for me?"><span class="u" id="1504119717.000295">2017:08:30 19:01:57                  lvh </span><span>I have a data structure like:

</span><pre>{:x
 {:a {:y 1}
  :b {:y 2}
  :c {:y 3}}}
</pre><span>

And I’d like </span><code>{:a 1 :b 2 :c 3}</code><span>. I can write the select path that gets the values: </span><code>[:x (sr/multi-path :a :b :c) :y]</code><span>, and I guess I can zipmap from there; but is there an elegant way to get specter to do that for me?</span></div><div data-t="lvh sr/collect’ing the multi-path doesn’t really do what I expected:

 [[[{:y 1} {:y 2} {:y 3}] nil]]"><span class="u" id="1504119771.000330">2017:08:30 19:02:51                  lvh </span><span>sr/collect’ing the multi-path doesn’t really do what I expected:

</span><code>[[[{:y 1} {:y 2} {:y 3}] nil]]</code></div><div data-t="nathanmarz @lvh something like this?  (select-any [:x (transformed MAP-VALS :y)] data)"><span class="u" id="1504120941.000562">2017:08:30 19:22:21           nathanmarz </span><span>@lvh something like this? </span><code>(select-any [:x (transformed MAP-VALS :y)] data)</code></div><div data-t="lvh Cool; thanks! I guess my sample was a little underspecified; there are other keys in there I do not want; but I guess a multi-path instead of a MAP-VALS would probably do the trick; lemme try"><span class="u" id="1504120998.000525">2017:08:30 19:23:18                  lvh </span><span>Cool; thanks! I guess my sample was a little underspecified; there are other keys in there I do not want; but I guess a multi-path instead of a MAP-VALS would probably do the trick; lemme try</span></div><div data-t="nathanmarz for that you will want multi-transform with keys you don&apos;t want becoming  (terminal-val NONE)  and ones you do using  (terminal :y)"><span class="u" id="1504121076.000191">2017:08:30 19:24:36           nathanmarz </span><span>for that you will want multi-transform with keys you don&apos;t want becoming </span><code>(terminal-val NONE)</code><span> and ones you do using </span><code>(terminal :y)</code></div><div data-t="nathanmarz if you want to do it in a one-liner that is"><span class="u" id="1504121114.000234">2017:08:30 19:25:14           nathanmarz </span><span>if you want to do it in a one-liner that is</span></div><div data-t="nathanmarz can also just do the  select-any  followed by a  (setval [MAP-KEYS #{:k1 :k2 ...}] NONE data2)"><span class="u" id="1504121193.000421">2017:08:30 19:26:33           nathanmarz </span><span>can also just do the </span><code>select-any</code><span> followed by a </span><code>(setval [MAP-KEYS #{:k1 :k2 ...}] NONE data2)</code></div><div data-t="nathanmarz I would just do the latter since there&apos;s no  multi-transformed"><span class="u" id="1504121226.000336">2017:08:30 19:27:06           nathanmarz </span><span>I would just do the latter since there&apos;s no </span><code>multi-transformed</code></div><div data-t="nathanmarz actually, just use  submap  before  transformed"><span class="u" id="1504121369.000426">2017:08:30 19:29:29           nathanmarz </span><span>actually, just use </span><code>submap</code><span> before </span><code>transformed</code></div><div data-t="nathanmarz that&apos;s the easiest and most efficient"><span class="u" id="1504121375.000620">2017:08:30 19:29:35           nathanmarz </span><span>that&apos;s the easiest and most efficient</span></div><div data-t="nathanmarz [:x (submap [:k1 :k2...]) (transformed MAP-VALS :y)"><span class="u" id="1504121428.000135">2017:08:30 19:30:28           nathanmarz </span><code>[:x (submap [:k1 :k2...]) (transformed MAP-VALS :y)</code></div><div data-t="hmaurer Quick question: is there a set of “laws” that navigators are expected to follow? For example, I assume I should expect the following:
 (= (select path structure) (transform path (fn [x] x) structure))
 
or

 (= 42 (select path (transform path (fn [_] 42) structure)))
 
etc"><span class="u" id="1504350229.000001">2017:09:02 11:03:49              hmaurer </span><span>Quick question: is there a set of “laws” that navigators are expected to follow? For example, I assume I should expect the following:
</span><pre>(= (select path structure) (transform path (fn [x] x) structure))
</pre><span>
or

</span><pre>(= 42 (select path (transform path (fn [_] 42) structure)))
</pre><span>
etc</span></div><div data-t="nathanmarz @hmaurer well, those are both not true"><span class="u" id="1504352265.000031">2017:09:02 11:37:45           nathanmarz </span><span>@hmaurer well, those are both not true</span></div><div data-t="nathanmarz :a  for first one,  ALL  for second one shows falsehood"><span class="u" id="1504352299.000039">2017:09:02 11:38:19           nathanmarz </span><code>:a</code><span> for first one, </span><code>ALL</code><span> for second one shows falsehood</span></div><div data-t="hmaurer @nathanmarz ha! how so? transforming a path with the identity shouldn’t leave the values under that path unchanged?"><span class="u" id="1504352303.000027">2017:09:02 11:38:23              hmaurer </span><span>@nathanmarz ha! how so? transforming a path with the identity shouldn’t leave the values under that path unchanged?</span></div><div data-t="hmaurer oh sorry, my first example had a typo"><span class="u" id="1504352335.000025">2017:09:02 11:38:55              hmaurer </span><span>oh sorry, my first example had a typo</span></div><div data-t="hmaurer (= (select path structure) (select path (transform path (fn [x] x) structure)))
"><span class="u" id="1504352348.000041">2017:09:02 11:39:08              hmaurer </span><pre>(= (select path structure) (select path (transform path (fn [x] x) structure)))
</pre></div><div data-t="nathanmarz (transform (view inc) identity 1)"><span class="u" id="1504352370.000057">2017:09:02 11:39:30           nathanmarz </span><code>(transform (view inc) identity 1)</code></div><div data-t="nathanmarz returns 2"><span class="u" id="1504352392.000005">2017:09:02 11:39:52           nathanmarz </span><span>returns 2</span></div><div data-t="nathanmarz there&apos;s not any mathematical relations I can think of between  select  and  transform"><span class="u" id="1504352487.000024">2017:09:02 11:41:27           nathanmarz </span><span>there&apos;s not any mathematical relations I can think of between </span><code>select</code><span> and </span><code>transform</code></div><div data-t="nathanmarz only important property is that  select  and  transform  traverse same values in same order"><span class="u" id="1504352505.000001">2017:09:02 11:41:45           nathanmarz </span><span>only important property is that </span><code>select</code><span> and </span><code>transform</code><span> traverse same values in same order</span></div><div data-t="nathanmarz that&apos;s necessary for  subselect"><span class="u" id="1504352518.000063">2017:09:02 11:41:58           nathanmarz </span><span>that&apos;s necessary for </span><code>subselect</code></div><div data-t="hmaurer @nathanmarz in the case of  (view inc) , the invariant
 (= (select path structure) (select path (transform path (fn [x] x) structure)))
 
holds as far as I can see"><span class="u" id="1504352591.000037">2017:09:02 11:43:11              hmaurer </span><span>@nathanmarz in the case of </span><code>(view inc)</code><span>, the invariant
</span><pre>(= (select path structure) (select path (transform path (fn [x] x) structure)))
</pre><span>
holds as far as I can see</span></div><div data-t="hmaurer nevermind, it does not"><span class="u" id="1504352623.000003">2017:09:02 11:43:43              hmaurer </span><span>nevermind, it does not</span></div><div data-t="hmaurer ok, thank you!"><span class="u" id="1504352630.000031">2017:09:02 11:43:50              hmaurer </span><span>ok, thank you!</span></div><div data-t="hmaurer I need to wrap my head around paths that apply functions while navigating  😄"><span class="u" id="1504352682.000070">2017:09:02 11:44:42              hmaurer </span><span>I need to wrap my head around paths that apply functions while navigating </span><b>😄</b></div><div data-t="nathanmarz yea, those ones are different"><span class="u" id="1504352715.000017">2017:09:02 11:45:15           nathanmarz </span><span>yea, those ones are different</span></div><div data-t="nathanmarz just  view  and  transformed"><span class="u" id="1504352720.000081">2017:09:02 11:45:20           nathanmarz </span><span>just </span><code>view</code><span> and </span><code>transformed</code></div><div data-t="hmaurer @nathanmarz what is your mental model for navigation if the model “navigating to a nested structure” is too limiting/unsuitable?"><span class="u" id="1504352757.000039">2017:09:02 11:45:57              hmaurer </span><span>@nathanmarz what is your mental model for navigation if the model “navigating to a nested structure” is too limiting/unsuitable?</span></div><div data-t="hmaurer if that question makes sense"><span class="u" id="1504352762.000042">2017:09:02 11:46:02              hmaurer </span><span>if that question makes sense</span></div><div data-t="nathanmarz well most of the time that is my mental model"><span class="u" id="1504352818.000073">2017:09:02 11:46:58           nathanmarz </span><span>well most of the time that is my mental model</span></div><div data-t="nathanmarz including for substructure navigators like srange"><span class="u" id="1504352826.000040">2017:09:02 11:47:06           nathanmarz </span><span>including for substructure navigators like srange</span></div><div data-t="nathanmarz I literally visualize moving from one portion of a data structure to another"><span class="u" id="1504352851.000015">2017:09:02 11:47:31           nathanmarz </span><span>I literally visualize moving from one portion of a data structure to another</span></div><div data-t="nathanmarz it gets easier with practice"><span class="u" id="1504352917.000024">2017:09:02 11:48:37           nathanmarz </span><span>it gets easier with practice</span></div><div data-t="nathanmarz eventually it&apos;s like anything else in programming and its just instinctive"><span class="u" id="1504352940.000043">2017:09:02 11:49:00           nathanmarz </span><span>eventually it&apos;s like anything else in programming and its just instinctive</span></div><div data-t="hmaurer @nathanmarz I am having a little bit of difficulty picturing the  view  example you mentioned about. When selected (reading) values, this makes sense. We are “viewing” the result of applying a function to every navigated value"><span class="u" id="1504364123.000060">2017:09:02 14:55:23              hmaurer </span><span>@nathanmarz I am having a little bit of difficulty picturing the </span><code>view</code><span> example you mentioned about. When selected (reading) values, this makes sense. We are “viewing” the result of applying a function to every navigated value</span></div><div data-t="hmaurer However the  transform  case seems a bit odd to me. I would expect  transform  to apply the inverse function of the function passed to  view  when re-constructing the data"><span class="u" id="1504364161.000079">2017:09:02 14:56:01              hmaurer </span><span>However the </span><code>transform</code><span> case seems a bit odd to me. I would expect </span><code>transform</code><span> to apply the inverse function of the function passed to </span><code>view</code><span> when re-constructing the data</span></div><div data-t="hmaurer (aka flowing the data back “up the pipe”, if that makes sense)"><span class="u" id="1504364171.000032">2017:09:02 14:56:11              hmaurer </span><span>(aka flowing the data back “up the pipe”, if that makes sense)</span></div><div data-t="hmaurer Am I fundamentally misunderstanding somethng here?"><span class="u" id="1504364187.000085">2017:09:02 14:56:27              hmaurer </span><span>Am I fundamentally misunderstanding somethng here?</span></div><div data-t="hmaurer (regardless of the fact that, afaik, there is no way to compute the inverse of an arbitrary function in clojure)"><span class="u" id="1504364211.000016">2017:09:02 14:56:51              hmaurer </span><span>(regardless of the fact that, afaik, there is no way to compute the inverse of an arbitrary function in clojure)</span></div><div data-t="nathanmarz @hmaurer that&apos;s what  parser  does  https://github.com/nathanmarz/specter/wiki/List-of-Navigators#parser"><span class="u" id="1504364998.000029">2017:09:02 15:09:58           nathanmarz </span><span>@hmaurer that&apos;s what </span><code>parser</code><span> does </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#parser">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#parser</a></div><div data-t="nathanmarz think of  view  as like a transform function that then continues navigating into the result of the transform"><span class="u" id="1504365079.000071">2017:09:02 15:11:19           nathanmarz </span><span>think of </span><code>view</code><span> as like a transform function that then continues navigating into the result of the transform</span></div><div data-t="hmaurer @nathanmarz that clarifies things. So if my mental model looks like this:
 [ 1 ] -- inc --&gt; [ 2 ]
 
and I want to apply a transform to the value in the second box, which I then expect to be “flowed back” to the first box by inverting the computation, then  parser  is the way to go"><span class="u" id="1504365317.000111">2017:09:02 15:15:17              hmaurer </span><span>@nathanmarz that clarifies things. So if my mental model looks like this:
</span><pre>[ 1 ] -- inc --&gt; [ 2 ]
</pre><span>
and I want to apply a transform to the value in the second box, which I then expect to be “flowed back” to the first box by inverting the computation, then </span><code>parser</code><span> is the way to go</span></div><div data-t="nathanmarz that&apos;s right"><span class="u" id="1504365337.000001">2017:09:02 15:15:37           nathanmarz </span><span>that&apos;s right</span></div><div data-t="hmaurer and  view  would stay navigated in the first box?"><span class="u" id="1504365363.000102">2017:09:02 15:16:03              hmaurer </span><span>and </span><code>view</code><span> would stay navigated in the first box?</span></div><div data-t="nathanmarz the only use case we could think of for the function+inverse was parsing, but it could be used for other things as well"><span class="u" id="1504365381.000088">2017:09:02 15:16:21           nathanmarz </span><span>the only use case we could think of for the function+inverse was parsing, but it could be used for other things as well</span></div><div data-t="nathanmarz view  would stay at the second box"><span class="u" id="1504365392.000011">2017:09:02 15:16:32           nathanmarz </span><code>view</code><span> would stay at the second box</span></div><div data-t="nathanmarz (transform [(view inc) STOP] dec 1) ;; =&gt; 2"><span class="u" id="1504365414.000054">2017:09:02 15:16:54           nathanmarz </span><code>(transform [(view inc) STOP] dec 1) ;; =&gt; 2</code></div><div data-t="hmaurer Wait, I would be navigated to the second box with  view ? How so? If I am at the first box and navigate to the second box by applying some computation (here  view ), and I then use  setval  to set the value on that path (the second box), shouldn’t I expect the computation to be inverted to determine the value of the first box?"><span class="u" id="1504365664.000021">2017:09:02 15:21:04              hmaurer </span><span>Wait, I would be navigated to the second box with </span><code>view</code><span>? How so? If I am at the first box and navigate to the second box by applying some computation (here </span><code>view</code><span>), and I then use </span><code>setval</code><span> to set the value on that path (the second box), shouldn’t I expect the computation to be inverted to determine the value of the first box?</span></div><div data-t="hmaurer If  view  navigates to the second box, I don’t get why/how its behaviour differs from  parser  in the  transform  case"><span class="u" id="1504365687.000069">2017:09:02 15:21:27              hmaurer </span><span>If </span><code>view</code><span> navigates to the second box, I don’t get why/how its behaviour differs from </span><code>parser</code><span> in the </span><code>transform</code><span> case</span></div><div data-t="nathanmarz well it stays there"><span class="u" id="1504365744.000018">2017:09:02 15:22:24           nathanmarz </span><span>well it stays there</span></div><div data-t="nathanmarz maybe &quot;boxes&quot; is not the right analogy"><span class="u" id="1504365751.000012">2017:09:02 15:22:31           nathanmarz </span><span>maybe &quot;boxes&quot; is not the right analogy</span></div><div data-t="nathanmarz you can think of  view  not navigating at all, just changing the box it&apos;s at"><span class="u" id="1504365770.000006">2017:09:02 15:22:50           nathanmarz </span><span>you can think of </span><code>view</code><span> not navigating at all, just changing the box it&apos;s at</span></div><div data-t="nathanmarz and then the rest of the path continues with the new value"><span class="u" id="1504365781.000046">2017:09:02 15:23:01           nathanmarz </span><span>and then the rest of the path continues with the new value</span></div><div data-t="nathanmarz in that example I just showed you can see the  dec  function is never reached"><span class="u" id="1504365813.000012">2017:09:02 15:23:33           nathanmarz </span><span>in that example I just showed you can see the </span><code>dec</code><span> function is never reached</span></div><div data-t="nathanmarz but the  view  persists in the result"><span class="u" id="1504365819.000011">2017:09:02 15:23:39           nathanmarz </span><span>but the </span><code>view</code><span> persists in the result</span></div><div data-t="nathanmarz it&apos;s equivalent to  (transform STOP dec (transform STAY inc 1))"><span class="u" id="1504365852.000097">2017:09:02 15:24:12           nathanmarz </span><span>it&apos;s equivalent to </span><code>(transform STOP dec (transform STAY inc 1))</code></div><div data-t="hmaurer I see; thank you!"><span class="u" id="1504366259.000023">2017:09:02 15:30:59              hmaurer </span><span>I see; thank you!</span></div><div data-t="nathanmarz sure thing"><span class="u" id="1504366309.000113">2017:09:02 15:31:49           nathanmarz </span><span>sure thing</span></div><div data-t="hmaurer ah, last but not least, do you have an example of a scenario where  view  is useful but  parser  would be unsuitable?"><span class="u" id="1504366372.000020">2017:09:02 15:32:52              hmaurer </span><span>ah, last but not least, do you have an example of a scenario where </span><code>view</code><span> is useful but </span><code>parser</code><span> would be unsuitable?</span></div><div data-t="nathanmarz @hmaurer mostly I use it in  select s, where its more concise than  parser"><span class="u" id="1504367001.000014">2017:09:02 15:43:21           nathanmarz </span><span>@hmaurer mostly I use it in </span><code>select</code><span>s, where its more concise than </span><code>parser</code></div><div data-t="nathanmarz plus there&apos;s no  unparse-fn  for those cases"><span class="u" id="1504367018.000043">2017:09:02 15:43:38           nathanmarz </span><span>plus there&apos;s no </span><code>unparse-fn</code><span> for those cases</span></div><div data-t="nathanmarz one spot where I use it in a  transform  is needing to manipulate a string as a vector of characters"><span class="u" id="1504367049.000013">2017:09:02 15:44:09           nathanmarz </span><span>one spot where I use it in a </span><code>transform</code><span> is needing to manipulate a string as a vector of characters</span></div><div data-t="nathanmarz so I do a  (view vec)"><span class="u" id="1504367054.000049">2017:09:02 15:44:14           nathanmarz </span><span>so I do a </span><code>(view vec)</code></div><div data-t="hmaurer In that case though  parser ‘s behaviour would make sense, since when manipulating a string as a list of characters you are essentially navigating into the substructure of that string, right?"><span class="u" id="1504367129.000030">2017:09:02 15:45:29              hmaurer </span><span>In that case though </span><code>parser</code><span>‘s behaviour would make sense, since when manipulating a string as a list of characters you are essentially navigating into the substructure of that string, right?</span></div><div data-t="hmaurer which you could then re-construct"><span class="u" id="1504367136.000037">2017:09:02 15:45:36              hmaurer </span><span>which you could then re-construct</span></div><div data-t="nathanmarz it&apos;s actually for converting a vector of strings to a matrix of characters with some default rendering info attached to each character"><span class="u" id="1504367139.000064">2017:09:02 15:45:39           nathanmarz </span><span>it&apos;s actually for converting a vector of strings to a matrix of characters with some default rendering info attached to each character</span></div><div data-t="nathanmarz yea you could have an  unparse-fn  for that kind of navigation, but in this case the goal is to have vector of characters in the output"><span class="u" id="1504367180.000030">2017:09:02 15:46:20           nathanmarz </span><span>yea you could have an </span><code>unparse-fn</code><span> for that kind of navigation, but in this case the goal is to have vector of characters in the output</span></div><div data-t="nathanmarz (def card-back
[
&quot;.------.&quot;
&quot;|//////|&quot;
&quot;|//////|&quot;
&quot;|//////|&quot;
&quot;|//////|&quot;
&quot;`------&apos;&quot;
])
"><span class="u" id="1504367197.000046">2017:09:02 15:46:37           nathanmarz </span><pre>(def card-back
[
&quot;.------.&quot;
&quot;|//////|&quot;
&quot;|//////|&quot;
&quot;|//////|&quot;
&quot;|//////|&quot;
&quot;`------&apos;&quot;
])
</pre></div><div data-t="nathanmarz basically that&apos;s how I specify &quot;images&quot; and the subsequent  transform  converts it to something that can be rendered"><span class="u" id="1504367232.000106">2017:09:02 15:47:12           nathanmarz </span><span>basically that&apos;s how I specify &quot;images&quot; and the subsequent </span><code>transform</code><span> converts it to something that can be rendered</span></div><div data-t="nathanmarz (def cards
  (into {}
    (for [v [2 3 4 5 6 7 8 9 :T :J :Q :K :A]]
      [v
       (into {}
         (for [[s template] {:clubs clubs-template :diamonds diamonds-template
                             :spades spades-template :hearts hearts-template}]
           [s (transform ALL #(apply str %)
                (setval [ALL (view vec) ALL (pred= \?)] (last (str v)) template))]
           ))])))
"><span class="u" id="1504367285.000030">2017:09:02 15:48:05           nathanmarz </span><pre>(def cards
  (into {}
    (for [v [2 3 4 5 6 7 8 9 :T :J :Q :K :A]]
      [v
       (into {}
         (for [[s template] {:clubs clubs-template :diamonds diamonds-template
                             :spades spades-template :hearts hearts-template}]
           [s (transform ALL #(apply str %)
                (setval [ALL (view vec) ALL (pred= \?)] (last (str v)) template))]
           ))])))
</pre></div><div data-t="nathanmarz oh actually in this case it turns templates into vector of strings for each card value"><span class="u" id="1504367329.000086">2017:09:02 15:48:49           nathanmarz </span><span>oh actually in this case it turns templates into vector of strings for each card value</span></div><div data-t="nathanmarz forgot how this code works :/"><span class="u" id="1504367384.000041">2017:09:02 15:49:44           nathanmarz </span><span>forgot how this code works :/</span></div><div data-t="nathanmarz in this case  parser  would work"><span class="u" id="1504367403.000046">2017:09:02 15:50:03           nathanmarz </span><span>in this case </span><code>parser</code><span> would work</span></div><div data-t="hmaurer Mmh. Out of curiosity, is  view  the only (shipped with Specter) infraction to the invariant
 (= (select path structure) (select path (transform path identity structure)))
 
?"><span class="u" id="1504367485.000051">2017:09:02 15:51:25              hmaurer </span><span>Mmh. Out of curiosity, is </span><code>view</code><span> the only (shipped with Specter) infraction to the invariant
</span><pre>(= (select path structure) (select path (transform path identity structure)))
</pre><span>
?</span></div><div data-t="hmaurer When thinking of navigation as “diving into structure” it seems that this invariant should hold; I am a bit bothered that  view  does not maintain it with transform"><span class="u" id="1504367525.000098">2017:09:02 15:52:05              hmaurer </span><span>When thinking of navigation as “diving into structure” it seems that this invariant should hold; I am a bit bothered that </span><code>view</code><span> does not maintain it with transform</span></div><div data-t="hmaurer but I am probably just being picky  😄"><span class="u" id="1504367535.000112">2017:09:02 15:52:15              hmaurer </span><span>but I am probably just being picky </span><b>😄</b></div><div data-t="nathanmarz also  transformed ,  nil-&gt;val"><span class="u" id="1504367621.000049">2017:09:02 15:53:41           nathanmarz </span><span>also </span><code>transformed</code><span>, </span><code>nil-&gt;val</code></div><div data-t="nathanmarz here&apos;s a better example of  view  transform use case:  (transform [(view vec) ALL] (ichar-with-attrs prompt-attrs) prompt)"><span class="u" id="1504367639.000024">2017:09:02 15:53:59           nathanmarz </span><span>here&apos;s a better example of </span><code>view</code><span> transform use case: </span><code>(transform [(view vec) ALL] (ichar-with-attrs prompt-attrs) prompt)</code></div><div data-t="nathanmarz a &quot;prompt&quot; string is converted to a vector of characters with each character wrapped in a map also containing rendering attributes like color, font, etc."><span class="u" id="1504367679.000017">2017:09:02 15:54:39           nathanmarz </span><span>a &quot;prompt&quot; string is converted to a vector of characters with each character wrapped in a map also containing rendering attributes like color, font, etc.</span></div><div data-t="nathanmarz could also do  (transform ALL (ichar-with-attrs prompt-attrs) (vec prompt)) , but the style with  view  would be useful if needed to do that transformation if had something like a map of prompts"><span class="u" id="1504367747.000061">2017:09:02 15:55:47           nathanmarz </span><span>could also do </span><code>(transform ALL (ichar-with-attrs prompt-attrs) (vec prompt))</code><span>, but the style with </span><code>view</code><span> would be useful if needed to do that transformation if had something like a map of prompts</span></div><div data-t="nathanmarz invariants like that are important for monads where it really does affect the utility of the monad"><span class="u" id="1504367843.000130">2017:09:02 15:57:23           nathanmarz </span><span>invariants like that are important for monads where it really does affect the utility of the monad</span></div><div data-t="nathanmarz other than the traversal order thing I mentioned, invariants like that aren&apos;t needed for navigation"><span class="u" id="1504367865.000072">2017:09:02 15:57:45           nathanmarz </span><span>other than the traversal order thing I mentioned, invariants like that aren&apos;t needed for navigation</span></div><div data-t="hmaurer I was hoping to use such invariants to better understand what navigators can and can’t do"><span class="u" id="1504367923.000033">2017:09:02 15:58:43              hmaurer </span><span>I was hoping to use such invariants to better understand what navigators can and can’t do</span></div><div data-t="hmaurer But this discussion was very helpful  🙂"><span class="u" id="1504367936.000019">2017:09:02 15:58:56              hmaurer </span><span>But this discussion was very helpful </span><b>🙂</b></div><div data-t="nathanmarz you could try reading the source code of navigators in specter"><span class="u" id="1504367957.000067">2017:09:02 15:59:17           nathanmarz </span><span>you could try reading the source code of navigators in specter</span></div><div data-t="nathanmarz view  is one of the simplest"><span class="u" id="1504367964.000036">2017:09:02 15:59:24           nathanmarz </span><code>view</code><span> is one of the simplest</span></div><div data-t="nathanmarz navigators are just functions, so they have all the power a function has"><span class="u" id="1504368127.000005">2017:09:02 16:02:07           nathanmarz </span><span>navigators are just functions, so they have all the power a function has</span></div><div data-t="hmaurer @nathanmarz of course, but I assume that if I want other people to be able to use the navigators I write they should follow some expected behaviours"><span class="u" id="1504368209.000044">2017:09:02 16:03:29              hmaurer </span><span>@nathanmarz of course, but I assume that if I want other people to be able to use the navigators I write they should follow some expected behaviours</span></div><div data-t="hmaurer so as not to force them to completely swap their mental model around on every new navigator they encounter"><span class="u" id="1504368228.000103">2017:09:02 16:03:48              hmaurer </span><span>so as not to force them to completely swap their mental model around on every new navigator they encounter</span></div><div data-t="hmaurer I might be overthinking the issue though; I’ll dig into the source-code!"><span class="u" id="1504368243.000003">2017:09:02 16:04:03              hmaurer </span><span>I might be overthinking the issue though; I’ll dig into the source-code!</span></div><div data-t="nathanmarz the only types of navigators I&apos;ve encountered are &quot;subvalue&quot; (e.g. keypath, nthpath, META, ALL), &quot;substructure&quot; (e.g. srange, submap, subset), &quot;filter&quot; (e.g. pred, selected?), and &quot;view&quot; (e.g. view, nil-&gt;val, transformed)"><span class="u" id="1504368397.000040">2017:09:02 16:06:37           nathanmarz </span><span>the only types of navigators I&apos;ve encountered are &quot;subvalue&quot; (e.g. keypath, nthpath, META, ALL), &quot;substructure&quot; (e.g. srange, submap, subset), &quot;filter&quot; (e.g. pred, selected?), and &quot;view&quot; (e.g. view, nil-&gt;val, transformed)</span></div><div data-t="nathanmarz index-nav  is an interesting example of a &quot;subvalue&quot; navigator because it navigates you to an implicit value"><span class="u" id="1504368425.000034">2017:09:02 16:07:05           nathanmarz </span><code>index-nav</code><span> is an interesting example of a &quot;subvalue&quot; navigator because it navigates you to an implicit value</span></div><div data-t="hmaurer @nathanmarz oh that’s interesting indeed. The doc on  index-nav  is missing from the wiki by the way"><span class="u" id="1504368854.000070">2017:09:02 16:14:14              hmaurer </span><span>@nathanmarz oh that’s interesting indeed. The doc on </span><code>index-nav</code><span> is missing from the wiki by the way</span></div><div data-t="hmaurer Quick question: what is a “rich nav”?"><span class="u" id="1504368860.000024">2017:09:02 16:14:20              hmaurer </span><span>Quick question: what is a “rich nav”?</span></div><div data-t="nathanmarz @hmaurer yea the wiki is not up to date"><span class="u" id="1504369620.000016">2017:09:02 16:27:00           nathanmarz </span><span>@hmaurer yea the wiki is not up to date</span></div><div data-t="nathanmarz the API docs are the most up to date, but the wiki has more examples"><span class="u" id="1504369632.000063">2017:09:02 16:27:12           nathanmarz </span><span>the API docs are the most up to date, but the wiki has more examples</span></div><div data-t="nathanmarz richnav  exposes the full navigator interface when defining navigators"><span class="u" id="1504369652.000130">2017:09:02 16:27:32           nathanmarz </span><code>richnav</code><span> exposes the full navigator interface when defining navigators</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L3"><span class="u" id="1504369672.000025">2017:09:02 16:27:52           nathanmarz </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L3">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L3</a></div><div data-t="nathanmarz many navigators use  defrichnav  purely as an optimization"><span class="u" id="1504369691.000029">2017:09:02 16:28:11           nathanmarz </span><span>many navigators use </span><code>defrichnav</code><span> purely as an optimization</span></div><div data-t="nathanmarz defnav  wraps  next-fn  and puts  vals  in closure to pass along when it&apos;s called"><span class="u" id="1504369731.000130">2017:09:02 16:28:51           nathanmarz </span><code>defnav</code><span> wraps </span><code>next-fn</code><span> and puts </span><code>vals</code><span> in closure to pass along when it&apos;s called</span></div><div data-t="nathanmarz with  defrichnav  you can avoid all that allocation/indirection by passing the  vals  yourself"><span class="u" id="1504369750.000018">2017:09:02 16:29:10           nathanmarz </span><span>with </span><code>defrichnav</code><span> you can avoid all that allocation/indirection by passing the </span><code>vals</code><span> yourself</span></div><div data-t="nathanmarz unfortunately clojure doesn&apos;t optimize this case with inlining and neither does the JVM"><span class="u" id="1504369776.000084">2017:09:02 16:29:36           nathanmarz </span><span>unfortunately clojure doesn&apos;t optimize this case with inlining and neither does the JVM</span></div><div data-t="nathanmarz although in theory a compiler could do it"><span class="u" id="1504369790.000026">2017:09:02 16:29:50           nathanmarz </span><span>although in theory a compiler could do it</span></div><div data-t="nathanmarz so I do it manually for some cases where that optimization makes a difference – basically I try to do it wherever the navigation itself is very cheap so extra overhead will have noticeable performance impact"><span class="u" id="1504369842.000055">2017:09:02 16:30:42           nathanmarz </span><span>so I do it manually for some cases where that optimization makes a difference – basically I try to do it wherever the navigation itself is very cheap so extra overhead will have noticeable performance impact</span></div><div data-t="nathanmarz btw  vals  in that interface refers to &quot;collected vals&quot; collected with  VAL ,  collect , and  collect-one"><span class="u" id="1504369891.000127">2017:09:02 16:31:31           nathanmarz </span><span>btw </span><code>vals</code><span> in that interface refers to &quot;collected vals&quot; collected with </span><code>VAL</code><span>, </span><code>collect</code><span>, and </span><code>collect-one</code></div><div data-t="dadair How does Spectre compare in performance for recursively (and exhaustively) walking large trees (e.g., against  clojure.walk/prewalk )? Looked at posted benchmarks but didn&apos;t see any for walking trees"><span class="u" id="1504648456.000197">2017:09:05 21:54:16               dadair </span><span>How does Spectre compare in performance for recursively (and exhaustively) walking large trees (e.g., against </span><code>clojure.walk/prewalk</code><span>)? Looked at posted benchmarks but didn&apos;t see any for walking trees</span></div><div data-t="nathanmarz @dadair specter destroys the performance of anything in vanilla clojure for anything involving compound or recursive data structures"><span class="u" id="1504649372.000241">2017:09:05 22:09:32           nathanmarz </span><span>@dadair specter destroys the performance of anything in vanilla clojure for anything involving compound or recursive data structures</span></div><div data-t="nathanmarz clojure.walk  is a very brute force approach forcing you to traverse parts of data structures you don&apos;t care about (like map keys, key/value pairs)"><span class="u" id="1504649399.000209">2017:09:05 22:09:59           nathanmarz </span><code>clojure.walk</code><span> is a very brute force approach forcing you to traverse parts of data structures you don&apos;t care about (like map keys, key/value pairs)</span></div><div data-t="nathanmarz with specter you can make traversals that perform dramatically better"><span class="u" id="1504649429.000089">2017:09:05 22:10:29           nathanmarz </span><span>with specter you can make traversals that perform dramatically better</span></div><div data-t="nathanmarz even just in replicating  clojure.walk/postwalk  semantics specter is 40% better
 Benchmark: walker vs. clojure.walk version (150000 iterations)

Avg(ms)		vs best		Code
959.39 		 1.00 		 (transform (walker number?) inc data)
1347.1 		 1.40 		 (transform (walker-old number?) inc data)
"><span class="u" id="1504649453.000076">2017:09:05 22:10:53           nathanmarz </span><span>even just in replicating </span><code>clojure.walk/postwalk</code><span> semantics specter is 40% better
</span><pre>Benchmark: walker vs. clojure.walk version (150000 iterations)

Avg(ms)		vs best		Code
959.39 		 1.00 		 (transform (walker number?) inc data)
1347.1 		 1.40 		 (transform (walker-old number?) inc data)
</pre></div><div data-t="nathanmarz the implementation of  walker  is instructive for making your own recursive paths
 (def
  ^{:doc &quot;Navigate the data structure until reaching
          a value for which `afn` returns truthy. Has
          same semantics as clojure.walk.&quot;}
  walker
  (recursive-path [afn] p
    (cond-path (pred afn) STAY
               coll? [ALL p]
               )))
"><span class="u" id="1504649537.000384">2017:09:05 22:12:17           nathanmarz </span><span>the implementation of </span><code>walker</code><span> is instructive for making your own recursive paths
</span><pre>(def
  ^{:doc &quot;Navigate the data structure until reaching
          a value for which `afn` returns truthy. Has
          same semantics as clojure.walk.&quot;}
  walker
  (recursive-path [afn] p
    (cond-path (pred afn) STAY
               coll? [ALL p]
               )))
</pre></div><div data-t="dadair awesome, I&apos;ll take a look at spectre. I have a prewalk running in ~28ms that I need to cut down as much as possible"><span class="u" id="1504649677.000085">2017:09:05 22:14:37               dadair </span><span>awesome, I&apos;ll take a look at spectre. I have a prewalk running in ~28ms that I need to cut down as much as possible</span></div><div data-t="dadair Hi again! Just trying to grasp navigation and collection a bit better. Let&apos;s say I have a recursive structure like so:
 {:root {:name &quot;/&quot;
           :children {:a {:name &quot;a&quot; :children {&lt;recursive&gt;}}
                            :b {:name &quot;b&quot; :children {&lt;recursive&gt;}}}}}
 
I&apos;d like to augment each &quot;node&quot; with the direct path to take to that node:
 {:root {:name &quot;/&quot;
           :ref [:root]
           :children {:a {:name &quot;a&quot; :ref [:root :children :a] :children {&lt;recursive&gt;}}
                            :b {:name &quot;b&quot; :ref [:root :children :b] :children {&lt;recursive&gt;}}}}}
 
How would this work with mixing  recursive-path  and  collect ?"><span class="u" id="1504723967.000197">2017:09:06 18:52:47               dadair </span><span>Hi again! Just trying to grasp navigation and collection a bit better. Let&apos;s say I have a recursive structure like so:
</span><pre>{:root {:name &quot;/&quot;
           :children {:a {:name &quot;a&quot; :children {&lt;recursive&gt;}}
                            :b {:name &quot;b&quot; :children {&lt;recursive&gt;}}}}}
</pre><span>
I&apos;d like to augment each &quot;node&quot; with the direct path to take to that node:
</span><pre>{:root {:name &quot;/&quot;
           :ref [:root]
           :children {:a {:name &quot;a&quot; :ref [:root :children :a] :children {&lt;recursive&gt;}}
                            :b {:name &quot;b&quot; :ref [:root :children :b] :children {&lt;recursive&gt;}}}}}
</pre><span>
How would this work with mixing </span><code>recursive-path</code><span> and </span><code>collect</code><span>?</span></div><div data-t="nathanmarz @dadair you can do that example like this:
 (def data
 {:root {:name &quot;/&quot;
         :children {:a {:name &quot;a&quot;}
                    :b {:name &quot;b&quot;}}}})


(def nodes-with-path
  (recursive-path [] p
    (continue-then-stay
      (putval :children)
      (must :children)
      ALL
      (collect-one FIRST)
      LAST
      p)))

(transform [(putval :root) :root nodes-with-path :ref] (fn [&amp; args] (butlast args)) data)
"><span class="u" id="1504727287.000624">2017:09:06 19:48:07           nathanmarz </span><span>@dadair you can do that example like this:
</span><pre>(def data
 {:root {:name &quot;/&quot;
         :children {:a {:name &quot;a&quot;}
                    :b {:name &quot;b&quot;}}}})


(def nodes-with-path
  (recursive-path [] p
    (continue-then-stay
      (putval :children)
      (must :children)
      ALL
      (collect-one FIRST)
      LAST
      p)))

(transform [(putval :root) :root nodes-with-path :ref] (fn [&amp; args] (butlast args)) data)
</pre></div><div data-t="hmaurer @nathanmarz that’s very cool"><span class="u" id="1504727357.000431">2017:09:06 19:49:17              hmaurer </span><span>@nathanmarz that’s very cool</span></div><div data-t="hmaurer 😱"><span class="u" id="1504727360.000362">2017:09:06 19:49:20              hmaurer </span><b>😱</b></div><div data-t="hmaurer @nathanmarz completely uninformed question: are there similarities between Specter and Gremlin?"><span class="u" id="1504727588.000184">2017:09:06 19:53:08              hmaurer </span><span>@nathanmarz completely uninformed question: are there similarities between Specter and Gremlin?</span></div><div data-t="hmaurer (even though their intended use-cases are quite different)"><span class="u" id="1504727600.000055">2017:09:06 19:53:20              hmaurer </span><span>(even though their intended use-cases are quite different)</span></div><div data-t="nathanmarz @hmaurer I&apos;m not very familiar with Gremlin"><span class="u" id="1504729408.000672">2017:09:06 20:23:28           nathanmarz </span><span>@hmaurer I&apos;m not very familiar with Gremlin</span></div><div data-t="dadair thanks @nathanmarz that helps!"><span class="u" id="1504729490.000031">2017:09:06 20:24:50               dadair </span><span>thanks @nathanmarz that helps!</span></div><div data-t="dadair Would compiling recursive paths give any benefit? I&apos;ve tried a  compiled-transform  with  comp-paths  for the above path vector and don&apos;t see any performance benefits (using criterium to get means)"><span class="u" id="1504817863.000060">2017:09:07 20:57:43               dadair </span><span>Would compiling recursive paths give any benefit? I&apos;ve tried a </span><code>compiled-transform</code><span> with </span><code>comp-paths</code><span> for the above path vector and don&apos;t see any performance benefits (using criterium to get means)</span></div><div data-t="nathanmarz @dadair no that&apos;s not necessary anymore"><span class="u" id="1504820737.000321">2017:09:07 21:45:37           nathanmarz </span><span>@dadair no that&apos;s not necessary anymore</span></div><div data-t="nathanmarz since 0.11.0 specter does inline compilation/caching"><span class="u" id="1504820744.000369">2017:09:07 21:45:44           nathanmarz </span><span>since 0.11.0 specter does inline compilation/caching</span></div><div data-t="nathanmarz feel free to paste your path if you&apos;d like tips on performance"><span class="u" id="1504820814.000307">2017:09:07 21:46:54           nathanmarz </span><span>feel free to paste your path if you&apos;d like tips on performance</span></div><div data-t="dadair it&apos;s the exact path you provided in the code block above. It&apos;s improved my app performance quite substantially already, I was just curious of compilation would make it faster as I know the path beforehand"><span class="u" id="1504820894.000052">2017:09:07 21:48:14               dadair </span><span>it&apos;s the exact path you provided in the code block above. It&apos;s improved my app performance quite substantially already, I was just curious of compilation would make it faster as I know the path beforehand</span></div><div data-t="nathanmarz ah"><span class="u" id="1504820923.000227">2017:09:07 21:48:43           nathanmarz </span><span>ah</span></div><div data-t="nathanmarz yea that path&apos;s performance could be improved"><span class="u" id="1504820929.000428">2017:09:07 21:48:49           nathanmarz </span><span>yea that path&apos;s performance could be improved</span></div><div data-t="nathanmarz or rather that transform"><span class="u" id="1504821022.000217">2017:09:07 21:50:22           nathanmarz </span><span>or rather that transform</span></div><div data-t="nathanmarz (def terminal2
  (richnav [afn]
    (select* [this vals structure next-fn]
      (i/throw-illegal &quot;&apos;terminal2&apos; should only be used in multi-transform&quot;))
    (transform* [this vals structure next-fn]
      (afn vals structure))))
"><span class="u" id="1504821031.000124">2017:09:07 21:50:31           nathanmarz </span><pre>(def terminal2
  (richnav [afn]
    (select* [this vals structure next-fn]
      (i/throw-illegal &quot;&apos;terminal2&apos; should only be used in multi-transform&quot;))
    (transform* [this vals structure next-fn]
      (afn vals structure))))
</pre></div><div data-t="nathanmarz (multi-transform [(putval :root) :root nodes-with-path :ref (terminal2 (fn [vals _] vals))] data)"><span class="u" id="1504821067.000375">2017:09:07 21:51:07           nathanmarz </span><code>(multi-transform [(putval :root) :root nodes-with-path :ref (terminal2 (fn [vals _] vals))] data)</code></div><div data-t="nathanmarz try that"><span class="u" id="1504821077.000445">2017:09:07 21:51:17           nathanmarz </span><span>try that</span></div><div data-t="nathanmarz avoids the  apply  on the transform-fn and the  butlast  call"><span class="u" id="1504821134.000132">2017:09:07 21:52:14           nathanmarz </span><span>avoids the </span><code>apply</code><span> on the transform-fn and the </span><code>butlast</code><span> call</span></div><div data-t="dadair is terminal2 on  1.0.3 ?"><span class="u" id="1504821223.000258">2017:09:07 21:53:43               dadair </span><span>is terminal2 on </span><code>1.0.3</code><span>?</span></div><div data-t="nathanmarz no"><span class="u" id="1504821234.000258">2017:09:07 21:53:54           nathanmarz </span><span>no</span></div><div data-t="nathanmarz I should probably add something like that into a future version"><span class="u" id="1504821244.000221">2017:09:07 21:54:04           nathanmarz </span><span>I should probably add something like that into a future version</span></div><div data-t="nathanmarz that&apos;s a variant of  terminal  which is in specter"><span class="u" id="1504821276.000218">2017:09:07 21:54:36           nathanmarz </span><span>that&apos;s a variant of </span><code>terminal</code><span> which is in specter</span></div><div data-t="dadair yeah that improved it quite a bit again:  prewalk: 27ms, transform: 5.4ms, multi-transform: 1.3ms"><span class="u" id="1504821472.000290">2017:09:07 21:57:52               dadair </span><span>yeah that improved it quite a bit again: </span><code>prewalk: 27ms, transform: 5.4ms, multi-transform: 1.3ms</code></div><div data-t="dadair this is awesome thank you"><span class="u" id="1504821479.000308">2017:09:07 21:57:59               dadair </span><span>this is awesome thank you</span></div><div data-t="nathanmarz very nice"><span class="u" id="1504821486.000283">2017:09:07 21:58:06           nathanmarz </span><span>very nice</span></div><div data-t="nathanmarz that&apos;s probably close to optimal"><span class="u" id="1504821492.000229">2017:09:07 21:58:12           nathanmarz </span><span>that&apos;s probably close to optimal</span></div><div data-t="dadair I&apos;ve also replaced a  tree-seq &gt; group-by &gt; get  pipeline with:
 (def nodes-without-path
  (sp/recursive-path [] p
                     (sp/continue-then-stay
                      (sp/must :children)
                      sp/ALL
                      sp/LAST
                      p)))

(defn find-vals [root type]
  (sp/select [:root nodes-without-path (fn [x] (= type (-&gt; x :descriptor :type)))] root))
 
any performance tips there?"><span class="u" id="1504821548.000082">2017:09:07 21:59:08               dadair </span><span>I&apos;ve also replaced a </span><code>tree-seq &gt; group-by &gt; get</code><span> pipeline with:
</span><pre>(def nodes-without-path
  (sp/recursive-path [] p
                     (sp/continue-then-stay
                      (sp/must :children)
                      sp/ALL
                      sp/LAST
                      p)))

(defn find-vals [root type]
  (sp/select [:root nodes-without-path (fn [x] (= type (-&gt; x :descriptor :type)))] root))
</pre><span>
any performance tips there?</span></div><div data-t="nathanmarz no, that seems good"><span class="u" id="1504821610.000424">2017:09:07 22:00:10           nathanmarz </span><span>no, that seems good</span></div><div data-t="dadair also, when the predicate matches, that node will be a leaf, if that adds some performance considerations"><span class="u" id="1504821632.000231">2017:09:07 22:00:32               dadair </span><span>also, when the predicate matches, that node will be a leaf, if that adds some performance considerations</span></div><div data-t="nathanmarz oh, you can replace  ALL LAST  with  MAP-VALS"><span class="u" id="1504821684.000400">2017:09:07 22:01:24           nathanmarz </span><span>oh, you can replace </span><code>ALL LAST</code><span> with </span><code>MAP-VALS</code></div><div data-t="nathanmarz that will be a big performance boost"><span class="u" id="1504821690.000317">2017:09:07 22:01:30           nathanmarz </span><span>that will be a big performance boost</span></div><div data-t="nathanmarz as for the last property you said, you should be able to change the path to reflect that"><span class="u" id="1504821860.000111">2017:09:07 22:04:20           nathanmarz </span><span>as for the last property you said, you should be able to change the path to reflect that</span></div><div data-t="nathanmarz basically to only navigate to leaves, not to every intermediate node"><span class="u" id="1504821879.000339">2017:09:07 22:04:39           nathanmarz </span><span>basically to only navigate to leaves, not to every intermediate node</span></div><div data-t="nathanmarz depends on how you detect a leaf"><span class="u" id="1504821907.000167">2017:09:07 22:05:07           nathanmarz </span><span>depends on how you detect a leaf</span></div><div data-t="nathanmarz non-existence of  :children  key, or just  :children  key with empty map?"><span class="u" id="1504821922.000141">2017:09:07 22:05:22           nathanmarz </span><span>non-existence of </span><code>:children</code><span> key, or just </span><code>:children</code><span> key with empty map?</span></div><div data-t="dadair I was going to say  :children  with empty map but that&apos;s not necessarily true actually, it&apos;s more that certain nodes have  types   (-&gt; node :descriptor :type)  that reflect leaf &quot;value&quot; nodes, but internally they may have  :children  for sub-values"><span class="u" id="1504822058.000028">2017:09:07 22:07:38               dadair </span><span>I was going to say </span><code>:children</code><span> with empty map but that&apos;s not necessarily true actually, it&apos;s more that certain nodes have </span><code>types</code><span> </span><code>(-&gt; node :descriptor :type)</code><span> that reflect leaf &quot;value&quot; nodes, but internally they may have </span><code>:children</code><span> for sub-values</span></div><div data-t="dadair I could check if the type is in a known set of types"><span class="u" id="1504822077.000168">2017:09:07 22:07:57               dadair </span><span>I could check if the type is in a known set of types</span></div><div data-t="nathanmarz it would look like:"><span class="u" id="1504822092.000238">2017:09:07 22:08:12           nathanmarz </span><span>it would look like:</span></div><div data-t="nathanmarz (def leaf-nodes
  (recursive-path [] p
    (if-path leaf-node?
      STAY
      [:children MAP-VALS p]
      )))
"><span class="u" id="1504822096.000084">2017:09:07 22:08:16           nathanmarz </span><pre>(def leaf-nodes
  (recursive-path [] p
    (if-path leaf-node?
      STAY
      [:children MAP-VALS p]
      )))
</pre></div><div data-t="nathanmarz just fill in  leaf-node?"><span class="u" id="1504822102.000122">2017:09:07 22:08:22           nathanmarz </span><span>just fill in </span><code>leaf-node?</code></div><div data-t="dadair Great I&apos;ll give that a try, thanks! Specter is awesome, thanks for open sourcing it!"><span class="u" id="1504822354.000153">2017:09:07 22:12:34               dadair </span><span>Great I&apos;ll give that a try, thanks! Specter is awesome, thanks for open sourcing it!</span></div><div data-t="andrea.crotti I am trying to go recursively through a hiccup data structure"><span class="u" id="1505039986.000051">2017:09:10 10:39:46        andrea.crotti </span><span>I am trying to go recursively through a hiccup data structure</span></div><div data-t="andrea.crotti something like this
 (def nested
  [:div {:id &quot;hello&quot;}
   [:a {:href &quot;&quot;} :welcome]])
"><span class="u" id="1505040008.000034">2017:09:10 10:40:08        andrea.crotti </span><span>something like this
</span><pre>(def nested
  [:div {:id &quot;hello&quot;}
   [:a {:href &quot;&quot;} :welcome]])
</pre></div><div data-t="andrea.crotti and simply replace automaticaly (using the tongue library) every known symbol with its translation"><span class="u" id="1505040035.000045">2017:09:10 10:40:35        andrea.crotti </span><span>and simply replace automaticaly (using the tongue library) every known symbol with its translation</span></div><div data-t="andrea.crotti so given this dictionary
 (def dicts
  &quot;List of all the words/sentences that need localization&quot;
  {:en {:welcome &quot;Welcome&quot;}
   :it {:welcome &quot;Benvenuto&quot;}})

"><span class="u" id="1505040081.000024">2017:09:10 10:41:21        andrea.crotti </span><span>so given this dictionary
</span><pre>(def dicts
  &quot;List of all the words/sentences that need localization&quot;
  {:en {:welcome &quot;Welcome&quot;}
   :it {:welcome &quot;Benvenuto&quot;}})

</pre></div><div data-t="andrea.crotti I just tried this first
 (s/transform
 [s/ALL]
 #(do
    (print %)
    (if (contains? dicts %)
      (translate :en %)
      %))
 nested)
"><span class="u" id="1505040091.000026">2017:09:10 10:41:31        andrea.crotti </span><span>I just tried this first
</span><pre>(s/transform
 [s/ALL]
 #(do
    (print %)
    (if (contains? dicts %)
      (translate :en %)
      %))
 nested)
</pre></div><div data-t="andrea.crotti but it doesn&apos;t actually check :welcome, I also tried to follow the recursive example in the docs
 (s/transform
 (s/subselect TreeValues)
 #(do
    (print %)
    (if (contains? dicts %)
      (translate :en %)
      %))
 nested)
"><span class="u" id="1505040134.000001">2017:09:10 10:42:14        andrea.crotti </span><span>but it doesn&apos;t actually check :welcome, I also tried to follow the recursive example in the docs
</span><pre>(s/transform
 (s/subselect TreeValues)
 #(do
    (print %)
    (if (contains? dicts %)
      (translate :en %)
      %))
 nested)
</pre></div><div data-t="andrea.crotti but it looks like it&apos;s the same thing"><span class="u" id="1505040140.000026">2017:09:10 10:42:20        andrea.crotti </span><span>but it looks like it&apos;s the same thing</span></div><div data-t="andrea.crotti is it actually possible to do this somehow?"><span class="u" id="1505040152.000023">2017:09:10 10:42:32        andrea.crotti </span><span>is it actually possible to do this somehow?</span></div><div data-t="nathanmarz @andrea.crotti yes, that&apos;s easy"><span class="u" id="1505042222.000031">2017:09:10 11:17:02           nathanmarz </span><span>@andrea.crotti yes, that&apos;s easy</span></div><div data-t="nathanmarz where can the target keywords reside? only map values or also in arbitrary vector values or map keys?"><span class="u" id="1505042263.000052">2017:09:10 11:17:43           nathanmarz </span><span>where can the target keywords reside? only map values or also in arbitrary vector values or map keys?</span></div><div data-t="andrea.crotti I think only in nested vectors "><span class="u" id="1505042389.000051">2017:09:10 11:19:49        andrea.crotti </span><span>I think only in nested vectors </span></div><div data-t="andrea.crotti Since it&apos;s html text really"><span class="u" id="1505042452.000054">2017:09:10 11:20:52        andrea.crotti </span><span>Since it&apos;s html text really</span></div><div data-t="nathanmarz (def TreeValues
  (recursive-path [] p
    (if-path vector?
      [ALL p]
      STAY
      )))

(def nested
  [:div {:id &quot;hello&quot;}
   [:a {:href &quot;&quot;} :welcome]])

(def dicts
  {:en {:welcome &quot;Welcome&quot;}
   :it {:welcome &quot;Benvenuto&quot;}})

(let [dict (:en dicts)]
  (transform [TreeValues #(contains? dict %)] dict nested))
"><span class="u" id="1505042536.000007">2017:09:10 11:22:16           nathanmarz </span><pre>(def TreeValues
  (recursive-path [] p
    (if-path vector?
      [ALL p]
      STAY
      )))

(def nested
  [:div {:id &quot;hello&quot;}
   [:a {:href &quot;&quot;} :welcome]])

(def dicts
  {:en {:welcome &quot;Welcome&quot;}
   :it {:welcome &quot;Benvenuto&quot;}})

(let [dict (:en dicts)]
  (transform [TreeValues #(contains? dict %)] dict nested))
</pre></div><div data-t="nathanmarz that&apos;s one way to do it"><span class="u" id="1505042556.000053">2017:09:10 11:22:36           nathanmarz </span><span>that&apos;s one way to do it</span></div><div data-t="nathanmarz you can make it more precise by making a recursive path that doesn&apos;t go to the first 2 elements of vectors, so that you don&apos;t inadvertently translate the node type if something like  :div  is used in the dictionary"><span class="u" id="1505042636.000026">2017:09:10 11:23:56           nathanmarz </span><span>you can make it more precise by making a recursive path that doesn&apos;t go to the first 2 elements of vectors, so that you don&apos;t inadvertently translate the node type if something like </span><code>:div</code><span> is used in the dictionary</span></div><div data-t="andrea.crotti Ah nice thanks I&apos;ll try it out"><span class="u" id="1505053022.000045">2017:09:10 14:17:02        andrea.crotti </span><span>Ah nice thanks I&apos;ll try it out</span></div><div data-t="sandbags I&apos;m not grokking navigators for maps. I have a map like  {:a {:x {:y {:z ...}}} :b {:x {:y {:z ...}}} :c {:x {:y {:z ...}}}}  and I want to transform the value of  :z  for all keys in the map  :a ,  :b ,  :c  etc... but every permutation I try gets me something along the lines of  Error: Vector&apos;s key for assoc must be a number"><span class="u" id="1505122980.000127">2017:09:11 09:43:00             sandbags </span><span>I&apos;m not grokking navigators for maps. I have a map like </span><code>{:a {:x {:y {:z ...}}} :b {:x {:y {:z ...}}} :c {:x {:y {:z ...}}}}</code><span> and I want to transform the value of </span><code>:z</code><span> for all keys in the map </span><code>:a</code><span>, </span><code>:b</code><span>, </span><code>:c</code><span> etc... but every permutation I try gets me something along the lines of </span><code>Error: Vector&apos;s key for assoc must be a number</code></div><div data-t="sandbags i think the problem is about my root map being processed as a vector of key-pairs but i am finding it hard to understand what ids going on (it might help to understand that I do not visualise very well)"><span class="u" id="1505123081.000171">2017:09:11 09:44:41             sandbags </span><span>i think the problem is about my root map being processed as a vector of key-pairs but i am finding it hard to understand what ids going on (it might help to understand that I do not visualise very well)</span></div><div data-t="sandbags reaching in via a fixed keypath  [:a :x :y :z]  is okay, but how to put the  *  at the beginning..."><span class="u" id="1505123123.000310">2017:09:11 09:45:23             sandbags </span><span>reaching in via a fixed keypath </span><code>[:a :x :y :z]</code><span> is okay, but how to put the </span><code>*</code><span> at the beginning...</span></div><div data-t="sandbags hrmm... okay i&apos;m not sure what i am doing differently now to earlier but:"><span class="u" id="1505131155.000263">2017:09:11 11:59:15             sandbags </span><span>hrmm... okay i&apos;m not sure what i am doing differently now to earlier but:</span></div><div data-t="sandbags (nav/transform [nav/MAP-VALS :exits nav/ALL :available] #(not %) {:foo {:exits [{:to :bar :available true}]} :bar {:exits [{:to :foo :available false}]}})"><span class="u" id="1505131171.000002">2017:09:11 11:59:31             sandbags </span><code>(nav/transform [nav/MAP-VALS :exits nav/ALL :available] #(not %) {:foo {:exits [{:to :bar :available true}]} :bar {:exits [{:to :foo :available false}]}})</code></div><div data-t="sandbags works and is, structurally, my use case"><span class="u" id="1505131203.000025">2017:09:11 12:00:03             sandbags </span><span>works and is, structurally, my use case</span></div><div data-t="sandbags I will confess I am still feel quit uncertain about my use of these navigators"><span class="u" id="1505131623.000402">2017:09:11 12:07:03             sandbags </span><span>I will confess I am still feel quit uncertain about my use of these navigators</span></div><div data-t="levitanong @sandbags this should work for the data structure you posted
 (transform [MAP-VALS :x :y :z] (fn [z] (* 2 z)) {:a {:x {:y {:z 2}}} :b {:x {:y {:z 3}}} :c {:x {:y {:z 4}}}}"><span class="u" id="1505131733.000108">2017:09:11 12:08:53           levitanong </span><span>@sandbags this should work for the data structure you posted
</span><code>(transform [MAP-VALS :x :y :z] (fn [z] (* 2 z)) {:a {:x {:y {:z 2}}} :b {:x {:y {:z 3}}} :c {:x {:y {:z 4}}}}</code></div><div data-t="sandbags @levitanong i may have been making some kind of transliteration mistake as that kind of approach didn&apos;t work when i tried it, but yes - thanks. And the example I posted about is my actual use case (structurally at least)"><span class="u" id="1505131793.000066">2017:09:11 12:09:53             sandbags </span><span>@levitanong i may have been making some kind of transliteration mistake as that kind of approach didn&apos;t work when i tried it, but yes - thanks. And the example I posted about is my actual use case (structurally at least)</span></div><div data-t="levitanong @sandbags Well I’m glad things are working for you now.  😁"><span class="u" id="1505131870.000147">2017:09:11 12:11:10           levitanong </span><span>@sandbags Well I’m glad things are working for you now. </span><b>😁</b></div><div data-t="sandbags yes, thanks for your help"><span class="u" id="1505131885.000027">2017:09:11 12:11:25             sandbags </span><span>yes, thanks for your help</span></div><div data-t="sandbags i think a key problem i have (I have something called Aphantasia) is I struggle to visualise what is going on in the navigators"><span class="u" id="1505131909.000435">2017:09:11 12:11:49             sandbags </span><span>i think a key problem i have (I have something called Aphantasia) is I struggle to visualise what is going on in the navigators</span></div><div data-t="hmaurer @sandbags ah; sounds like there is room to develop a visualization app for navigators then!  🙂"><span class="u" id="1505133074.000181">2017:09:11 12:31:14              hmaurer </span><span>@sandbags ah; sounds like there is room to develop a visualization app for navigators then! </span><b>🙂</b></div><div data-t="sandbags or some kind of tutorial with some visualisations, yes"><span class="u" id="1505133094.000112">2017:09:11 12:31:34             sandbags </span><span>or some kind of tutorial with some visualisations, yes</span></div><div data-t="hmaurer yes, that’s what I meant"><span class="u" id="1505133103.000449">2017:09:11 12:31:43              hmaurer </span><span>yes, that’s what I meant</span></div><div data-t="hmaurer an interactive tutorial"><span class="u" id="1505133111.000176">2017:09:11 12:31:51              hmaurer </span><span>an interactive tutorial</span></div><div data-t="levitanong @hmaurer @sandbags Now there’s an idea.  🤔"><span class="u" id="1505133591.000370">2017:09:11 12:39:51           levitanong </span><span>@hmaurer @sandbags Now there’s an idea. </span><b>🤔</b></div><div data-t="hmaurer @levitanong something a bit like  http://rxmarbles.com/"><span class="u" id="1505133645.000128">2017:09:11 12:40:45              hmaurer </span><span>@levitanong something a bit like </span><a href="http://rxmarbles.com/">http://rxmarbles.com/</a></div><div data-t="michaelwfogleman I like  http://www.learndatalogtoday.org/  - not really visualizable but good for grokking a DSL"><span class="u" id="1505133723.000294">2017:09:11 12:42:03     michaelwfogleman </span><span>I like </span><a href="http://www.learndatalogtoday.org/">http://www.learndatalogtoday.org/</a><span> - not really visualizable but good for grokking a DSL</span></div><div data-t="nathanmarz @sandbags I&apos;d never heard of aphantasia before, reading about it just blew my mind"><span class="u" id="1505134301.000234">2017:09:11 12:51:41           nathanmarz </span><span>@sandbags I&apos;d never heard of aphantasia before, reading about it just blew my mind</span></div><div data-t="nathanmarz had no idea that was something that could differ between people"><span class="u" id="1505134336.000364">2017:09:11 12:52:16           nathanmarz </span><span>had no idea that was something that could differ between people</span></div><div data-t="nathanmarz a visualization is a good idea, I put some thoughts here  https://github.com/nathanmarz/specter/issues/56#issuecomment-328519037"><span class="u" id="1505134364.000264">2017:09:11 12:52:44           nathanmarz </span><span>a visualization is a good idea, I put some thoughts here </span><a href="https://github.com/nathanmarz/specter/issues/56#issuecomment-328519037">https://github.com/nathanmarz/specter/issues/56#issuecomment-328519037</a></div><div data-t="nathanmarz do you think that  visualize-path  command would be helpful?"><span class="u" id="1505134397.000056">2017:09:11 12:53:17           nathanmarz </span><span>do you think that </span><code>visualize-path</code><span> command would be helpful?</span></div><div data-t="michaelwfogleman @nathanmarz Yes!"><span class="u" id="1505134703.000234">2017:09:11 12:58:23     michaelwfogleman </span><span>@nathanmarz Yes!</span></div><div data-t="michaelwfogleman (Even for those of us without aphantasia)  🙂"><span class="u" id="1505134721.000053">2017:09:11 12:58:41     michaelwfogleman </span><span>(Even for those of us without aphantasia) </span><b>🙂</b></div><div data-t="michaelwfogleman Hadn&apos;t seen that issue, subscribing in case I can help..."><span class="u" id="1505134736.000253">2017:09:11 12:58:56     michaelwfogleman </span><span>Hadn&apos;t seen that issue, subscribing in case I can help...</span></div><div data-t="nathanmarz comments and ideas are welcome on that issue"><span class="u" id="1505134790.000056">2017:09:11 12:59:50           nathanmarz </span><span>comments and ideas are welcome on that issue</span></div><div data-t="nathanmarz and contributions, of course"><span class="u" id="1505134812.000395">2017:09:11 13:00:12           nathanmarz </span><span>and contributions, of course</span></div><div data-t="nathanmarz the specter wiki is in its own repository if anyone wants to contribute  https://github.com/nathanmarz/specter-wiki"><span class="u" id="1505134837.000497">2017:09:11 13:00:37           nathanmarz </span><span>the specter wiki is in its own repository if anyone wants to contribute </span><a href="https://github.com/nathanmarz/specter-wiki">https://github.com/nathanmarz/specter-wiki</a></div><div data-t="hmaurer I’ll try to tackle this when I have some time. It could be an interesting opportunity to write an interactive doc"><span class="u" id="1505134883.000521">2017:09:11 13:01:23              hmaurer </span><span>I’ll try to tackle this when I have some time. It could be an interesting opportunity to write an interactive doc</span></div><div data-t="hmaurer good project to get my hands on ClojureScript  🙂"><span class="u" id="1505134903.000520">2017:09:11 13:01:43              hmaurer </span><span>good project to get my hands on ClojureScript </span><b>🙂</b></div><div data-t="michaelwfogleman @nathanmarz Do you know off the top of your head which functions / macros etc. aren&apos;t documented or need more explanation? I&apos;m happy to write explanations for the ones I understand."><span class="u" id="1505134929.000546">2017:09:11 13:02:09     michaelwfogleman </span><span>@nathanmarz Do you know off the top of your head which functions / macros etc. aren&apos;t documented or need more explanation? I&apos;m happy to write explanations for the ones I understand.</span></div><div data-t="nathanmarz looks like almost everything added since 0.13.0"><span class="u" id="1505135085.000042">2017:09:11 13:04:45           nathanmarz </span><span>looks like almost everything added since 0.13.0</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><span class="u" id="1505135092.000030">2017:09:11 13:04:52           nathanmarz </span><a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></div><div data-t="nathanmarz nthpath ,  MAP-KEYS ,  BEFORE-ELEM ,  AFTER-ELEM ,  NONE-ELEM ,  NAME ,  NAMESPACE ,  map-key ,  set-elem ,  before-index ,  index-nav ,  INDEXED-VALS"><span class="u" id="1505135205.000505">2017:09:11 13:06:45           nathanmarz </span><code>nthpath</code><span>, </span><code>MAP-KEYS</code><span>, </span><code>BEFORE-ELEM</code><span>, </span><code>AFTER-ELEM</code><span>, </span><code>NONE-ELEM</code><span>, </span><code>NAME</code><span>, </span><code>NAMESPACE</code><span>, </span><code>map-key</code><span>, </span><code>set-elem</code><span>, </span><code>before-index</code><span>, </span><code>index-nav</code><span>, </span><code>INDEXED-VALS</code></div><div data-t="nathanmarz plus  eachnav , the improvements to  keypath /`must`, and the extension of many navigators to work with strings"><span class="u" id="1505135248.000237">2017:09:11 13:07:28           nathanmarz </span><span>plus </span><code>eachnav</code><span>, the improvements to </span><code>keypath</code><span>/`must`, and the extension of many navigators to work with strings</span></div><div data-t="michaelwfogleman @nathanmarz Can you give an example of transforming with INDEXED-VALS?"><span class="u" id="1505139003.000771">2017:09:11 14:10:03     michaelwfogleman </span><span>@nathanmarz Can you give an example of transforming with INDEXED-VALS?</span></div><div data-t="nathanmarz @michaelwfogleman there&apos;s some examples in the tests  https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L1620"><span class="u" id="1505140069.000421">2017:09:11 14:27:49           nathanmarz </span><span>@michaelwfogleman there&apos;s some examples in the tests </span><a href="https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L1620">https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L1620</a></div><div data-t="michaelwfogleman @nathanmarz About to push a big pull request for the wiki, did almost everything you listed save for eachnav and the improvement to keypath/must, but also did pred= and co, and traversed"><span class="u" id="1505145493.000375">2017:09:11 15:58:13     michaelwfogleman </span><span>@nathanmarz About to push a big pull request for the wiki, did almost everything you listed save for eachnav and the improvement to keypath/must, but also did pred= and co, and traversed</span></div><div data-t="hmaurer that was fast"><span class="u" id="1505149342.000464">2017:09:11 17:02:22                   hmaurer </span><span>that was fast</span></div><div data-t="michaelwfogleman Thanks!  🙂  I mostly adapted the tests and docstrings"><span class="u" id="1505154296.000524">2017:09:11 18:24:56          michaelwfogleman </span><span>Thanks! </span><b>🙂</b><span> I mostly adapted the tests and docstrings</span></div><div data-t="nathanmarz @michaelwfogleman merged it in, thanks!"><span class="u" id="1505160688.000276">2017:09:11 20:11:28           nathanmarz </span><span>@michaelwfogleman merged it in, thanks!</span></div><div data-t="sandbags @nathanmarz i only found out the name for it myself a few months ago. i&apos;ve known i was different for about 20 years but always assumed it was just me as nobody else ever seemed able to relate"><span class="u" id="1505205876.000260">2017:09:12 08:44:36             sandbags </span><span>@nathanmarz i only found out the name for it myself a few months ago. i&apos;ve known i was different for about 20 years but always assumed it was just me as nobody else ever seemed able to relate</span></div><div data-t="sandbags it turns out something like 2% of the population are somewhere on the spectrum in terms of low-no visualisation"><span class="u" id="1505205899.000468">2017:09:12 08:44:59             sandbags </span><span>it turns out something like 2% of the population are somewhere on the spectrum in terms of low-no visualisation</span></div><div data-t="sandbags i have a little, enough to confuse the issue but not enough to be useful ... some people have none at all"><span class="u" id="1505205917.000477">2017:09:12 08:45:17             sandbags </span><span>i have a little, enough to confuse the issue but not enough to be useful ... some people have none at all</span></div><div data-t="nathanmarz @sandbags crazy stuff, got me thinking a lot about how people can experience life differently"><span class="u" id="1505218779.000383">2017:09:12 12:19:39           nathanmarz </span><span>@sandbags crazy stuff, got me thinking a lot about how people can experience life differently</span></div><div data-t="nathanmarz fyi, someone on twitter pointed me to this facebook group for people with aphantasia  https://www.facebook.com/groups/204603509580186/?fref=mentions"><span class="u" id="1505218835.000146">2017:09:12 12:20:35           nathanmarz </span><span>fyi, someone on twitter pointed me to this facebook group for people with aphantasia </span><a href="https://www.facebook.com/groups/204603509580186/?fref=mentions">https://www.facebook.com/groups/204603509580186/?fref=mentions</a></div><div data-t="hmaurer I am impressed you manage to do your job as a programmer/engineer with aphantasia. Visualisation is such an important thing for me"><span class="u" id="1505218954.000121">2017:09:12 12:22:34              hmaurer </span><span>I am impressed you manage to do your job as a programmer/engineer with aphantasia. Visualisation is such an important thing for me</span></div><div data-t="hmaurer I cannot phantom how I would be able to work with abstract concepts without an ability to visualise them in one way or another"><span class="u" id="1505218983.000076">2017:09:12 12:23:03              hmaurer </span><span>I cannot phantom how I would be able to work with abstract concepts without an ability to visualise them in one way or another</span></div><div data-t="sandbags I&apos;ve never found it a problem with abstract concepts, perhaps more so with the details in fact!"><span class="u" id="1505230567.000331">2017:09:12 15:36:07             sandbags </span><span>I&apos;ve never found it a problem with abstract concepts, perhaps more so with the details in fact!</span></div><div data-t="nha To me it looks like some “specter exercises” would be better suited for learning specter first, and the visualisation part could come in later for more advanced use-cases, when there is lots of data/nested keywords etc.

At work we have dev helpers to trim or pprint data structures to files and use diff (or meld) to compare them since it’s no use printing them in Emacs (too big). But I did not need all that to learn how to manipulate data in Clojure.

For learning Clojure I used simple examples, easy exercises (I remember  http://clojurekoans.com/  being helpful for Clojure). I have yet to play with  https://github.com/gdeer81/specter-koans  by the way. In the meantime my use of specter is fairly limited."><span class="u" id="1505234636.000186">2017:09:12 16:43:56                  nha </span><span>To me it looks like some “specter exercises” would be better suited for learning specter first, and the visualisation part could come in later for more advanced use-cases, when there is lots of data/nested keywords etc.

At work we have dev helpers to trim or pprint data structures to files and use diff (or meld) to compare them since it’s no use printing them in Emacs (too big). But I did not need all that to learn how to manipulate data in Clojure.

For learning Clojure I used simple examples, easy exercises (I remember </span><a href="http://clojurekoans.com/">http://clojurekoans.com/</a><span> being helpful for Clojure). I have yet to play with </span><a href="https://github.com/gdeer81/specter-koans">https://github.com/gdeer81/specter-koans</a><span> by the way. In the meantime my use of specter is fairly limited.</span></div><div data-t="nathanmarz yea, specter is naturally suited for learning via a series of progressively more difficult use cases"><span class="u" id="1505234962.000430">2017:09:12 16:49:22           nathanmarz </span><span>yea, specter is naturally suited for learning via a series of progressively more difficult use cases</span></div><div data-t="gdeer81 Sorry I dropped the ball on writing the specter-koans. I get distracted easily"><span class="u" id="1505238307.000523">2017:09:12 17:45:07              gdeer81 </span><span>Sorry I dropped the ball on writing the specter-koans. I get distracted easily</span></div><div data-t="lvh I’m stuck writing a selector: I’d like to recursively walk down nested maps, and, if I get a choice, deepest first. So, for:

 {&quot;a&quot; {&quot;b&quot; {&quot;c&quot; 1}}}
 

I’d get  {&quot;c&quot; 1} ,  {&quot;b&quot; {&quot;c&quot; 1}} ,  {&quot;a&quot; {&quot;b&quot; {&quot;c&quot; 1}}} . I’ve been messing around with recursive-path but haven’t gotten far."><span class="u" id="1505264979.000148">2017:09:13 01:09:39                  lvh </span><span>I’m stuck writing a selector: I’d like to recursively walk down nested maps, and, if I get a choice, deepest first. So, for:

</span><pre>{&quot;a&quot; {&quot;b&quot; {&quot;c&quot; 1}}}
</pre><span>

I’d get </span><code>{&quot;c&quot; 1}</code><span>, </span><code>{&quot;b&quot; {&quot;c&quot; 1}}</code><span>, </span><code>{&quot;a&quot; {&quot;b&quot; {&quot;c&quot; 1}}}</code><span>. I’ve been messing around with recursive-path but haven’t gotten far.</span></div><div data-t="lvh writing the nested traversal that just grabs the values at the leaves is easy:

 (sr/recursive-path
   [] p
   (sr/cond-path
    map? (sr/stay-then-continue [p sr/MAP-VALS])
    sr/STAY sr/STAY))
"><span class="u" id="1505265166.000070">2017:09:13 01:12:46                  lvh </span><span>writing the nested traversal that just grabs the values at the leaves is easy:

</span><pre>(sr/recursive-path
   [] p
   (sr/cond-path
    map? (sr/stay-then-continue [p sr/MAP-VALS])
    sr/STAY sr/STAY))
</pre></div><div data-t="lvh This is almost what I want:

 (def tree-vals
  (sr/recursive-path
   [] p
   (sr/if-path map?
    [sr/VAL sr/MAP-VALS p]
    sr/STAY)))
 

is almost what I want: it just returns the  1  too"><span class="u" id="1505265450.000059">2017:09:13 01:17:30                  lvh </span><span>This is almost what I want:

</span><pre>(def tree-vals
  (sr/recursive-path
   [] p
   (sr/if-path map?
    [sr/VAL sr/MAP-VALS p]
    sr/STAY)))
</pre><span>

is almost what I want: it just returns the </span><code>1</code><span> too</span></div><div data-t="lvh (sr/NONE still selects nil; and I’m not sure how to say “ok you’re done now” — I don’t think it’s STOP, because that just stops navigation entirely, right?)"><span class="u" id="1505265508.000058">2017:09:13 01:18:28                  lvh </span><span>(sr/NONE still selects nil; and I’m not sure how to say “ok you’re done now” — I don’t think it’s STOP, because that just stops navigation entirely, right?)</span></div><div data-t="lvh Got it:
 (def tree-vals
  (sr/recursive-path
   [] p
   (sr/if-path map? (sr/continue-then-stay [sr/MAP-VALS p]))))
"><span class="u" id="1505282895.000107">2017:09:13 06:08:15                  lvh </span><span>Got it:
</span><pre>(def tree-vals
  (sr/recursive-path
   [] p
   (sr/if-path map? (sr/continue-then-stay [sr/MAP-VALS p]))))
</pre></div><div data-t="nathanmarz @lvh you can omit the  []  in  continue-then-stay"><span class="u" id="1505301383.000211">2017:09:13 11:16:23           nathanmarz </span><span>@lvh you can omit the </span><code>[]</code><span> in </span><code>continue-then-stay</code></div><div data-t="nathanmarz no performance difference, just a little nicer"><span class="u" id="1505301394.000117">2017:09:13 11:16:34           nathanmarz </span><span>no performance difference, just a little nicer</span></div><div data-t="lvh Ah, thanks :)"><span class="u" id="1505312908.000369">2017:09:13 14:28:28                  lvh </span><span>Ah, thanks :)</span></div><div data-t="michaelwfogleman @nathanmarz: Just pushed a PR for documentation of multiple arguments, wrapping up eachnav/keypath/must. If anything else needs documenting let me know and I&apos;ll try to take a stab at it  🙂"><span class="u" id="1505739194.000013">2017:09:18 12:53:14     michaelwfogleman </span><span>@nathanmarz: Just pushed a PR for documentation of multiple arguments, wrapping up eachnav/keypath/must. If anything else needs documenting let me know and I&apos;ll try to take a stab at it </span><b>🙂</b></div><div data-t="michaelwfogleman Also did a PR for recursive-path"><span class="u" id="1505740597.000055">2017:09:18 13:16:37          michaelwfogleman </span><span>Also did a PR for recursive-path</span></div><div data-t="nathanmarz @michaelwfogleman awesome, thanks! I left a couple comments"><span class="u" id="1505742623.000323">2017:09:18 13:50:23           nathanmarz </span><span>@michaelwfogleman awesome, thanks! I left a couple comments</span></div><div data-t="nathanmarz @michaelwfogleman something else that&apos;s pretty undocumented is the  com.rpl.specter.zipper  namespace"><span class="u" id="1505754548.000309">2017:09:18 17:09:08           nathanmarz </span><span>@michaelwfogleman something else that&apos;s pretty undocumented is the </span><code>com.rpl.specter.zipper</code><span> namespace</span></div><div data-t="michaelwfogleman @nathanmarz Would you want a separate section of the docs for that?"><span class="u" id="1505769278.000050">2017:09:18 21:14:38     michaelwfogleman </span><span>@nathanmarz Would you want a separate section of the docs for that?</span></div><div data-t="nathanmarz @michaelwfogleman yea, definitely"><span class="u" id="1505769850.000230">2017:09:18 21:24:10           nathanmarz </span><span>@michaelwfogleman yea, definitely</span></div><div data-t="nathanmarz those are infrequently needed so putting them with rest of docs would be confusing to new users"><span class="u" id="1505769893.000052">2017:09:18 21:24:53           nathanmarz </span><span>those are infrequently needed so putting them with rest of docs would be confusing to new users</span></div><div data-t="michaelwfogleman @nathanmarz  https://github.com/nathanmarz/specter-wiki/pull/7"><span class="u" id="1505862016.000080">2017:09:19 23:00:16     michaelwfogleman </span><span>@nathanmarz </span><a href="https://github.com/nathanmarz/specter-wiki/pull/7">https://github.com/nathanmarz/specter-wiki/pull/7</a></div><div data-t="nathanmarz @michaelwfogleman the zipper data structure is an implementation detail, I don&apos;t think showing those belongs in the documentation"><span class="u" id="1505863508.000254">2017:09:19 23:25:08           nathanmarz </span><span>@michaelwfogleman the zipper data structure is an implementation detail, I don&apos;t think showing those belongs in the documentation</span></div><div data-t="nathanmarz with zipper usage you always do the following steps: 1. navigate to zipper, 2. navigate with zippers to whatever you want to change 3. navigate using  NODE  or  NODE-SEQ  to the actual value for updates"><span class="u" id="1505863578.000100">2017:09:19 23:26:18           nathanmarz </span><span>with zipper usage you always do the following steps: 1. navigate to zipper, 2. navigate with zippers to whatever you want to change 3. navigate using </span><code>NODE</code><span> or </span><code>NODE-SEQ</code><span> to the actual value for updates</span></div><div data-t="nathanmarz e.g.  (transform [VECTOR-ZIP DOWN RIGHT RIGHT NODE] inc [1 2 3 4 5]) ; =&gt; [1 2 4 4 5]"><span class="u" id="1505863651.000238">2017:09:19 23:27:31           nathanmarz </span><span>e.g. </span><code>(transform [VECTOR-ZIP DOWN RIGHT RIGHT NODE] inc [1 2 3 4 5]) ; =&gt; [1 2 4 4 5]</code></div><div data-t="nathanmarz also here&apos;s an example of  NODE-SEQ  for you:
 (setval [VECTOR-ZIP DOWN RIGHT RIGHT NODE-SEQ] [:a :b :c] [1 2 3 4 5])
;; =&gt; [1 2 :a :b :c 4 5]
"><span class="u" id="1505863747.000179">2017:09:19 23:29:07           nathanmarz </span><span>also here&apos;s an example of </span><code>NODE-SEQ</code><span> for you:
</span><pre>(setval [VECTOR-ZIP DOWN RIGHT RIGHT NODE-SEQ] [:a :b :c] [1 2 3 4 5])
;; =&gt; [1 2 :a :b :c 4 5]
</pre></div><div data-t="michaelwfogleman @nathanmarz Thanks for the example!"><span class="u" id="1505912707.000289">2017:09:20 13:05:07     michaelwfogleman </span><span>@nathanmarz Thanks for the example!</span></div><div data-t="michaelwfogleman The overview is helpful too... I&apos;ve not really used zippers before"><span class="u" id="1505912724.000434">2017:09:20 13:05:24     michaelwfogleman </span><span>The overview is helpful too... I&apos;ve not really used zippers before</span></div><div data-t="michaelwfogleman For the part you don&apos;t think I should include - are you saying the example zipper?"><span class="u" id="1505912749.000531">2017:09:20 13:05:49     michaelwfogleman </span><span>For the part you don&apos;t think I should include - are you saying the example zipper?</span></div><div data-t="michaelwfogleman &quot;Let&apos;s also define a sample zipper that we can work with in the examples below.

 (def data [1 [[2 3 4] 5 6] 7 [8 9]])
(def data-zipper (zip/vector-zip data))
 &quot;"><span class="u" id="1505912752.000002">2017:09:20 13:05:52     michaelwfogleman </span><span>&quot;Let&apos;s also define a sample zipper that we can work with in the examples below.

</span><pre>(def data [1 [[2 3 4] 5 6] 7 [8 9]])
(def data-zipper (zip/vector-zip data))
</pre><span>&quot;</span></div><div data-t="michaelwfogleman I added the example of NODE-SEQ that you gave me, as well as a few others to compare to selecting and also using NODE instead"><span class="u" id="1505913126.000317">2017:09:20 13:12:06     michaelwfogleman </span><span>I added the example of NODE-SEQ that you gave me, as well as a few others to compare to selecting and also using NODE instead</span></div><div data-t="nathanmarz @michaelwfogleman yea, I wouldn&apos;t include  data-zipper"><span class="u" id="1505913679.000003">2017:09:20 13:21:19           nathanmarz </span><span>@michaelwfogleman yea, I wouldn&apos;t include </span><code>data-zipper</code></div><div data-t="nathanmarz that should all be encapsulated in the paths"><span class="u" id="1505913694.000576">2017:09:20 13:21:34           nathanmarz </span><span>that should all be encapsulated in the paths</span></div><div data-t="michaelwfogleman OK, I think I&apos;ve got what you are saying!  🙂"><span class="u" id="1505913728.000077">2017:09:20 13:22:08     michaelwfogleman </span><span>OK, I think I&apos;ve got what you are saying! </span><b>🙂</b></div><div data-t="michaelwfogleman Cool, just pushed a new version - let me know if that&apos;s not what you had in mind, or you see anything else  🙂"><span class="u" id="1505914099.000173">2017:09:20 13:28:19     michaelwfogleman </span><span>Cool, just pushed a new version - let me know if that&apos;s not what you had in mind, or you see anything else </span><b>🙂</b></div><div data-t="nathanmarz I still see zipper data structures printed out as results to the examples"><span class="u" id="1505914276.000259">2017:09:20 13:31:16           nathanmarz </span><span>I still see zipper data structures printed out as results to the examples</span></div><div data-t="nathanmarz like for  (S/select-any [SZ/VECTOR-ZIP SZ/DOWN] data)"><span class="u" id="1505914302.000381">2017:09:20 13:31:42           nathanmarz </span><span>like for </span><code>(S/select-any [SZ/VECTOR-ZIP SZ/DOWN] data)</code></div><div data-t="michaelwfogleman Got it, I see what you&apos;re saying now, that does make it a lot neater. I pushed a new version and also added your comment about the three steps - I can remove that but I found what you said useful  🙂"><span class="u" id="1505914977.000479">2017:09:20 13:42:57     michaelwfogleman </span><span>Got it, I see what you&apos;re saying now, that does make it a lot neater. I pushed a new version and also added your comment about the three steps - I can remove that but I found what you said useful </span><b>🙂</b></div><div data-t="pataprogramming I’m wrestling with figuring out recursive paths. Specifically, I’m processing and transforming some JSON-LD.  I’d like to perform some transformations at any level of the tree, with arbitrary nesting. To simplify, consider a map where keys are primitive strings and values can be a primitive, a nested map, or a vector of nested maps. 

A standard transformation might be: if a map has a key  jkl:mno  equal to  wibble , add a new key  jkl:123  equal to  whammy .  Here’s a test map:

 {&quot;abc:def&quot;: [{&quot;abc:ghi&quot;: {&quot;jkl:mno&quot;: &quot;womble&quot;,
                          &quot;jkl:qrs&quot;: 12345}},
             {&quot;abc:tuv&quot;: {&quot;jkl:mno&quot;: &quot;wibble&quot;,
                          &quot;abc:def&quot;: {&quot;abc:ghi&quot;: [{&quot;jkl:mno&quot;: &quot;wibble&quot;,
                                                   &quot;jkl:qrs&quot;: 0 },
                                                  {&quot;jkl:qrs&quot;: 20}]}}}],
 &quot;abc:wxy&quot;: {&quot;abc:def&quot;: {&quot;jkl:mno&quot;: &quot;wibble&quot;}}}"><span class="u" id="1505938888.000342">2017:09:20 20:21:28      pataprogramming </span><span>I’m wrestling with figuring out recursive paths. Specifically, I’m processing and transforming some JSON-LD.  I’d like to perform some transformations at any level of the tree, with arbitrary nesting. To simplify, consider a map where keys are primitive strings and values can be a primitive, a nested map, or a vector of nested maps. 

A standard transformation might be: if a map has a key </span><code>jkl:mno</code><span> equal to </span><code>wibble</code><span>, add a new key </span><code>jkl:123</code><span> equal to </span><code>whammy</code><span>.  Here’s a test map:

</span><pre>{&quot;abc:def&quot;: [{&quot;abc:ghi&quot;: {&quot;jkl:mno&quot;: &quot;womble&quot;,
                          &quot;jkl:qrs&quot;: 12345}},
             {&quot;abc:tuv&quot;: {&quot;jkl:mno&quot;: &quot;wibble&quot;,
                          &quot;abc:def&quot;: {&quot;abc:ghi&quot;: [{&quot;jkl:mno&quot;: &quot;wibble&quot;,
                                                   &quot;jkl:qrs&quot;: 0 },
                                                  {&quot;jkl:qrs&quot;: 20}]}}}],
 &quot;abc:wxy&quot;: {&quot;abc:def&quot;: {&quot;jkl:mno&quot;: &quot;wibble&quot;}}}</pre></div><div data-t="pataprogramming walker  terminates as soon as it matches, so it’s clear a recursive path is needed. Is  recursive-path  the right one to be using, or is this a job for a  extend-protocolpath  providing implementations for vectors and maps?"><span class="u" id="1505939087.000163">2017:09:20 20:24:47      pataprogramming </span><code>walker</code><span> terminates as soon as it matches, so it’s clear a recursive path is needed. Is </span><code>recursive-path</code><span> the right one to be using, or is this a job for a </span><code>extend-protocolpath</code><span> providing implementations for vectors and maps?</span></div><div data-t="pataprogramming Some of the maps are  sorted-maps , as well, to influence the serialization when the JSON is written out, so just providing an implementation for  clojure.lang.PersistentHashMap  won’t cut it  in the latter case."><span class="u" id="1505939470.000094">2017:09:20 20:31:10      pataprogramming </span><span>Some of the maps are </span><code>sorted-maps</code><span>, as well, to influence the serialization when the JSON is written out, so just providing an implementation for </span><code>clojure.lang.PersistentHashMap</code><span> won’t cut it  in the latter case.</span></div><div data-t="nathanmarz @pataprogramming use  recursive-path"><span class="u" id="1505940891.000614">2017:09:20 20:54:51           nathanmarz </span><span>@pataprogramming use </span><code>recursive-path</code></div><div data-t="nathanmarz I&apos;ll show you how"><span class="u" id="1505940894.000224">2017:09:20 20:54:54           nathanmarz </span><span>I&apos;ll show you how</span></div><div data-t="nathanmarz one sec"><span class="u" id="1505940895.000597">2017:09:20 20:54:55           nathanmarz </span><span>one sec</span></div><div data-t="nathanmarz (def data
  {&quot;abc:def&quot; [{&quot;abc:ghi&quot; {&quot;jkl:mno&quot; &quot;womble&quot;,
                          &quot;jkl:qrs&quot; 12345}},
               {&quot;abc:tuv&quot; {&quot;jkl:mno&quot; &quot;wibble&quot;,
                            &quot;abc:def&quot; {&quot;abc:ghi&quot; [{&quot;jkl:mno&quot; &quot;wibble&quot;,
                                                     &quot;jkl:qrs&quot; 0 },
                                                    {&quot;jkl:qrs&quot; 20}]}}}],
   &quot;abc:wxy&quot; {&quot;abc:def&quot; {&quot;jkl:mno&quot; &quot;wibble&quot;}}})


(def MY-WALKER
  (recursive-path [] p
    (continue-then-stay
      (cond-path
        map? [MAP-VALS p]
        sequential? [ALL p]
        ))))

(setval [MY-WALKER map? (selected? (keypath &quot;jkl:mno&quot;) (pred= &quot;wibble&quot;)) (keypath &quot;jkl:123&quot;)] &quot;whammy&quot; data)
"><span class="u" id="1505941281.000215">2017:09:20 21:01:21           nathanmarz </span><pre>(def data
  {&quot;abc:def&quot; [{&quot;abc:ghi&quot; {&quot;jkl:mno&quot; &quot;womble&quot;,
                          &quot;jkl:qrs&quot; 12345}},
               {&quot;abc:tuv&quot; {&quot;jkl:mno&quot; &quot;wibble&quot;,
                            &quot;abc:def&quot; {&quot;abc:ghi&quot; [{&quot;jkl:mno&quot; &quot;wibble&quot;,
                                                     &quot;jkl:qrs&quot; 0 },
                                                    {&quot;jkl:qrs&quot; 20}]}}}],
   &quot;abc:wxy&quot; {&quot;abc:def&quot; {&quot;jkl:mno&quot; &quot;wibble&quot;}}})


(def MY-WALKER
  (recursive-path [] p
    (continue-then-stay
      (cond-path
        map? [MAP-VALS p]
        sequential? [ALL p]
        ))))

(setval [MY-WALKER map? (selected? (keypath &quot;jkl:mno&quot;) (pred= &quot;wibble&quot;)) (keypath &quot;jkl:123&quot;)] &quot;whammy&quot; data)
</pre></div><div data-t="pataprogramming @nathanmarz: Oh, great, thanks!  cond-path  is what I didn’t know I was groping for. And that example also helps make it clear how to use  self-sym , which I wasn’t quite grokking."><span class="u" id="1505943701.000174">2017:09:20 21:41:41      pataprogramming </span><span>@nathanmarz: Oh, great, thanks! </span><code>cond-path</code><span> is what I didn’t know I was groping for. And that example also helps make it clear how to use </span><code>self-sym</code><span>, which I wasn’t quite grokking.</span></div><div data-t="pataprogramming Major kudos for specter, by the way. It’s a brilliant library."><span class="u" id="1505943880.000155">2017:09:20 21:44:40      pataprogramming </span><span>Major kudos for specter, by the way. It’s a brilliant library.</span></div><div data-t="nathanmarz happy to hear you&apos;re getting good use out of it"><span class="u" id="1505943913.000016">2017:09:20 21:45:13           nathanmarz </span><span>happy to hear you&apos;re getting good use out of it</span></div><div data-t="nha I have a recursive-path walker in the works, but I am hitting a not on a particular prismatic/shema record. In particular,  s/if  returns a record with two paths I would like to explore (say, left and right). I know how to extract them from the record but not how to navigate to both of them: 
 (def ^:private PATH-SCHEMA-WALKER
  (recursive-path [] p
                  (cond-path
                    (fn [v]
                      (instance? schema.core.ConditionalSchema v))
                    [ALL (collect-one FIRST) LAST p] ;; how do I walk left and right here?

                    (fn [v]
                      (cond
                        (primitive-schema? v) false
                        (map? v) true ;; this is a real path
                        :default false))
                    [ALL (collect-one FIRST) LAST p]

                    (fn [v] true) STAY)))
 
Here is my attempt above, but I don&apos;t know what to put for the first path. Here is how I can extract the schemas:
 (if (instance? schema.core.ConditionalSchema x)
    (let [[p+s1 s2] (:preds-and-schemas (s/if map?
                                          {:first :schema} {:second :schema})
                                        )]
      {:s1 (second p+s1) :s2 s2})
    x
    )
"><span class="u" id="1506078830.000153">2017:09:22 11:13:50                  nha </span><span>I have a recursive-path walker in the works, but I am hitting a not on a particular prismatic/shema record. In particular, </span><code>s/if</code><span> returns a record with two paths I would like to explore (say, left and right). I know how to extract them from the record but not how to navigate to both of them: 
</span><pre>(def ^:private PATH-SCHEMA-WALKER
  (recursive-path [] p
                  (cond-path
                    (fn [v]
                      (instance? schema.core.ConditionalSchema v))
                    [ALL (collect-one FIRST) LAST p] ;; how do I walk left and right here?

                    (fn [v]
                      (cond
                        (primitive-schema? v) false
                        (map? v) true ;; this is a real path
                        :default false))
                    [ALL (collect-one FIRST) LAST p]

                    (fn [v] true) STAY)))
</pre><span>
Here is my attempt above, but I don&apos;t know what to put for the first path. Here is how I can extract the schemas:
</span><pre>(if (instance? schema.core.ConditionalSchema x)
    (let [[p+s1 s2] (:preds-and-schemas (s/if map?
                                          {:first :schema} {:second :schema})
                                        )]
      {:s1 (second p+s1) :s2 s2})
    x
    )
</pre></div><div data-t="nathanmarz @nha to walk multiple paths the general answer is to use  multi-path , e.g.  (multi-path :left :right)"><span class="u" id="1506085418.000197">2017:09:22 13:03:38           nathanmarz </span><span>@nha to walk multiple paths the general answer is to use </span><code>multi-path</code><span>, e.g. </span><code>(multi-path :left :right)</code></div><div data-t="nha Will try, thanks  simple_smile  "><span class="u" id="1506086021.000146">2017:09:22 13:13:41                  nha </span><span>Will try, thanks </span><b>simple_smile</b><span> </span></div><div data-t="nathanmarz @nha btw instead of  (fn [v] true)  for default case you can just write  STAY"><span class="u" id="1506086761.000306">2017:09:22 13:26:01           nathanmarz </span><span>@nha btw instead of </span><code>(fn [v] true)</code><span> for default case you can just write </span><code>STAY</code></div><div data-t="sophiago Does Specter have known issues with OpenJDK7? I&apos;ve never used it myself, but just noticed an error on a Travis build."><span class="u" id="1506131248.000039">2017:09:23 01:47:28             sophiago </span><span>Does Specter have known issues with OpenJDK7? I&apos;ve never used it myself, but just noticed an error on a Travis build.</span></div><div data-t="nathanmarz @sophiago I haven&apos;t tested it on that, I&apos;d have to see the error to have an idea of whether that&apos;s related to Specter or not"><span class="u" id="1506133051.000067">2017:09:23 02:17:31           nathanmarz </span><span>@sophiago I haven&apos;t tested it on that, I&apos;d have to see the error to have an idea of whether that&apos;s related to Specter or not</span></div><div data-t="sophiago The error was  Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: com/rpl/specter/Util : Unsupported major.minor version 52.0, compiling:(com/rpl/specter/impl.cljc:1:1) . Let me know if you want me to file an issue."><span class="u" id="1506133523.000010">2017:09:23 02:25:23             sophiago </span><span>The error was </span><code>Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: com/rpl/specter/Util : Unsupported major.minor version 52.0, compiling:(com/rpl/specter/impl.cljc:1:1)</code><span>. Let me know if you want me to file an issue.</span></div><div data-t="sophiago (I understand that&apos;s not particularly informative)"><span class="u" id="1506133568.000016">2017:09:23 02:26:08             sophiago </span><span>(I understand that&apos;s not particularly informative)</span></div><div data-t="sophiago Oh, that was a fast Googling. I guess it just means the jar was built in 8 and I&apos;m trying to run it in 7."><span class="u" id="1506134104.000004">2017:09:23 02:35:04             sophiago </span><span>Oh, that was a fast Googling. I guess it just means the jar was built in 8 and I&apos;m trying to run it in 7.</span></div><div data-t="sophiago I&apos;m also on the 1.9 alpha, although I don&apos;t think that should factor in. I&apos;m getting the jar straight from Maven."><span class="u" id="1506134191.000038">2017:09:23 02:36:31             sophiago </span><span>I&apos;m also on the 1.9 alpha, although I don&apos;t think that should factor in. I&apos;m getting the jar straight from Maven.</span></div><div data-t="nathanmarz yea that&apos;s cause the java code was compiled to a different version"><span class="u" id="1506135700.000047">2017:09:23 03:01:40           nathanmarz </span><span>yea that&apos;s cause the java code was compiled to a different version</span></div><div data-t="nathanmarz not a specter issue"><span class="u" id="1506135703.000078">2017:09:23 03:01:43           nathanmarz </span><span>not a specter issue</span></div><div data-t="sophiago Sorry, could you please clarify? If I&apos;m just having Lein pull it from Maven then how would I control how it&apos;s built?"><span class="u" id="1506138806.000047">2017:09:23 03:53:26             sophiago </span><span>Sorry, could you please clarify? If I&apos;m just having Lein pull it from Maven then how would I control how it&apos;s built?</span></div><div data-t="nathanmarz @sophiago specter has a little bit of java code so the jar contains a couple classfiles"><span class="u" id="1506158837.000016">2017:09:23 09:27:17           nathanmarz </span><span>@sophiago specter has a little bit of java code so the jar contains a couple classfiles</span></div><div data-t="nathanmarz you can try building specter yourself by checking out the project and running  lein jar  or  lein install"><span class="u" id="1506158876.000011">2017:09:23 09:27:56           nathanmarz </span><span>you can try building specter yourself by checking out the project and running </span><code>lein jar</code><span> or </span><code>lein install</code></div><div data-t="sophiago In that case, I think I&apos;ll just drop support for OpenJDK7. I think for libraries that&apos;s an appropriate expectation now that JDK9 is out. I&apos;m not sure if this is something you&apos;d want to mention in your documentation, though (I will in mine). All other Clojure libraries I use support it."><span class="u" id="1506160090.000017">2017:09:23 09:48:10             sophiago </span><span>In that case, I think I&apos;ll just drop support for OpenJDK7. I think for libraries that&apos;s an appropriate expectation now that JDK9 is out. I&apos;m not sure if this is something you&apos;d want to mention in your documentation, though (I will in mine). All other Clojure libraries I use support it.</span></div><div data-t="Nick Drew Java 9 has support for jars with multiple versions of class files. might be a handy way to preserve backward compatibility @U173SEFUN "><span class="u" id="1506398579.000064">2017:09:26 04:02:59                 Nick Drew </span><span>Java 9 has support for jars with multiple versions of class files. might be a handy way to preserve backward compatibility @U173SEFUN </span></div><div data-t="chromalchemy If I my navigation leads to a vector of strings, how do I continue to navigate the strings as whole values instead of splicing into charachter subsequences?   (select [ALL FIRST] [&quot;aaa&quot; &quot;bbb&quot; &quot;ccc&quot;])   gives  [&quot;a&quot; &quot;b&quot; &quot;c&quot;]  instead of  [&quot;aaa&quot;]"><span class="u" id="1506381109.000162">2017:09:25 23:11:49         chromalchemy </span><span>If I my navigation leads to a vector of strings, how do I continue to navigate the strings as whole values instead of splicing into charachter subsequences?  </span><code>(select [ALL FIRST] [&quot;aaa&quot; &quot;bbb&quot; &quot;ccc&quot;]) </code><span> gives </span><code>[&quot;a&quot; &quot;b&quot; &quot;c&quot;]</code><span> instead of </span><code>[&quot;aaa&quot;]</code></div><div data-t="chromalchemy Using  keypath  on a list of maps gave me the vector of strings, and I want to use  srange  on it..."><span class="u" id="1506381179.000113">2017:09:25 23:12:59         chromalchemy </span><span>Using </span><code>keypath</code><span> on a list of maps gave me the vector of strings, and I want to use </span><code>srange</code><span> on it...</span></div><div data-t="nathanmarz @chromalchemy if you have a vector of strings and just want to navigate to the first one, it&apos;s just  FIRST"><span class="u" id="1506389954.000074">2017:09:26 01:39:14           nathanmarz </span><span>@chromalchemy if you have a vector of strings and just want to navigate to the first one, it&apos;s just </span><code>FIRST</code></div><div data-t="nathanmarz keypath  won&apos;t work on lists, but  nthpath  will"><span class="u" id="1506390002.000123">2017:09:26 01:40:02           nathanmarz </span><code>keypath</code><span> won&apos;t work on lists, but </span><code>nthpath</code><span> will</span></div><div data-t="teawaterwire Hi there, I&apos;m having trouble doing the following: 
 ;; Considering this map m
(def m {:a 3
        :b {10 {:c 3}
            2 {:d 4}
            20 {:c 5}}})
;; I&apos;d like to remove entries in the :b map if 
;; the key is &lt; 15
;; and 
;; the value doesn&apos;t contain :d 
;; so it&apos;s like:
; {:a 3
;  :b {2 {:d 4}
;      20 {:c 5}}}
"><span class="u" id="1506707235.000141">2017:09:29 17:47:15         teawaterwire </span><span>Hi there, I&apos;m having trouble doing the following: 
</span><pre>;; Considering this map m
(def m {:a 3
        :b {10 {:c 3}
            2 {:d 4}
            20 {:c 5}}})
;; I&apos;d like to remove entries in the :b map if 
;; the key is &lt; 15
;; and 
;; the value doesn&apos;t contain :d 
;; so it&apos;s like:
; {:a 3
;  :b {2 {:d 4}
;      20 {:c 5}}}
</pre></div><div data-t="teawaterwire I managed to do it with  (sp/setval [:b sp/ALL (fn [[k v]] (and (&lt; k 15) (not (contains? v :d))))] sp/NONE m)  but I guess there could be a more elegant solution?"><span class="u" id="1506707416.000322">2017:09:29 17:50:16         teawaterwire </span><span>I managed to do it with </span><code>(sp/setval [:b sp/ALL (fn [[k v]] (and (&lt; k 15) (not (contains? v :d))))] sp/NONE m)</code><span> but I guess there could be a more elegant solution?</span></div><div data-t="nathanmarz here&apos;s a way that doesn&apos;t use any anonymous functions:
 (setval
  [:b
   ALL
   (not-selected? LAST (must :d))
   FIRST
   (pred&lt; 15)]
  NONE
  m)
"><span class="u" id="1506710365.000112">2017:09:29 18:39:25           nathanmarz </span><span>here&apos;s a way that doesn&apos;t use any anonymous functions:
</span><pre>(setval
  [:b
   ALL
   (not-selected? LAST (must :d))
   FIRST
   (pred&lt; 15)]
  NONE
  m)
</pre></div><div data-t="teawaterwire Amazing, thanks!
I tried something with  not-selected?  but I got stuck at:
 (setval
 [:b
  (not-selected? MAP-VALS (must :d))
  MAP-KEYS
  (pred&lt; 15)]
 NONE
 m)
"><span class="u" id="1506711577.000418">2017:09:29 18:59:37         teawaterwire </span><span>Amazing, thanks!
I tried something with </span><code>not-selected?</code><span> but I got stuck at:
</span><pre>(setval
 [:b
  (not-selected? MAP-VALS (must :d))
  MAP-KEYS
  (pred&lt; 15)]
 NONE
 m)
</pre></div><div data-t="nathanmarz that  not-selected?  call is a filter on the map as a whole"><span class="u" id="1506711922.000413">2017:09:29 19:05:22           nathanmarz </span><span>that </span><code>not-selected?</code><span> call is a filter on the map as a whole</span></div><div data-t="nathanmarz using  ALL  lets you test both conditions on the same entry"><span class="u" id="1506712009.000433">2017:09:29 19:06:49           nathanmarz </span><span>using </span><code>ALL</code><span> lets you test both conditions on the same entry</span></div><div data-t="teawaterwire Neat  👍"><span class="u" id="1506713327.000417">2017:09:29 19:28:47         teawaterwire </span><span>Neat </span><b>👍</b></div><div data-t="michaelwfogleman I just found myself writing a helper function, (defn match-path [p] (if-path p STAY)) - is there a more idiomatic way to do that, or is that sensible (TM)?"><span class="u" id="1506823463.000050">2017:10:01 02:04:23     michaelwfogleman </span><span>I just found myself writing a helper function, (defn match-path [p] (if-path p STAY)) - is there a more idiomatic way to do that, or is that sensible (TM)?</span></div><div data-t="nathanmarz @michaelwfogleman that&apos;s  selected?"><span class="u" id="1506851982.000031">2017:10:01 09:59:42           nathanmarz </span><span>@michaelwfogleman that&apos;s </span><code>selected?</code></div><div data-t="nathanmarz also, that would be a very unperformant way to implement  selected? , since it would force recompilation of that subpath every single time the callsite is invoked"><span class="u" id="1506852031.000013">2017:10:01 10:00:31           nathanmarz </span><span>also, that would be a very unperformant way to implement </span><code>selected?</code><span>, since it would force recompilation of that subpath every single time the callsite is invoked</span></div><div data-t="nathanmarz (defdynamicnav match-path [p] (if-path p STAY))  fixes it"><span class="u" id="1506852051.000029">2017:10:01 10:00:51           nathanmarz </span><code>(defdynamicnav match-path [p] (if-path p STAY))</code><span> fixes it</span></div><div data-t="michaelwfogleman Got it, thanks! I don&apos;t think we&apos;ve documented defdynamicnav and defrichnav, anything I&apos;m missing? I&apos;ll try to make a PR at some point"><span class="u" id="1506877152.000007">2017:10:01 16:59:12     michaelwfogleman </span><span>Got it, thanks! I don&apos;t think we&apos;ve documented defdynamicnav and defrichnav, anything I&apos;m missing? I&apos;ll try to make a PR at some point</span></div><div data-t="michaelwfogleman Then again that may be above my pay grade...  🙂"><span class="u" id="1506879175.000013">2017:10:01 17:32:55     michaelwfogleman </span><span>Then again that may be above my pay grade... </span><b>🙂</b></div><div data-t="michaelwfogleman Ah it&apos;s in the inline caching implementation doc - had not read that"><span class="u" id="1506879693.000056">2017:10:01 17:41:33     michaelwfogleman </span><span>Ah it&apos;s in the inline caching implementation doc - had not read that</span></div><div data-t="nathanmarz yea, that would be a good one to document"><span class="u" id="1506893700.000110">2017:10:01 21:35:00           nathanmarz </span><span>yea, that would be a good one to document</span></div><div data-t="michaelwfogleman Have a basic PR submitted, just pointing to the inline caching doc- nothing for defrichnav"><span class="u" id="1506944187.000066">2017:10:02 11:36:27     michaelwfogleman </span><span>Have a basic PR submitted, just pointing to the inline caching doc- nothing for defrichnav</span></div><div data-t="hkjels Can I use  specter  to get the path of some deeply nested key using a predicate?
Say I want the path to the last value that’s  brown  here:
 {:a &quot;foo&quot; :b :_ :c {:d &quot;brown&quot; :e &quot;bar&quot;} :f [{:g &quot;pale&quot; :h &quot;brown&quot; :i {:j &quot;ale&quot; :k [{:l &quot;brown&quot;} {:l &quot;brown&quot;}]}}]}"><span class="u" id="1507210683.000280">2017:10:05 13:38:03               hkjels </span><span>Can I use </span><code>specter</code><span> to get the path of some deeply nested key using a predicate?
Say I want the path to the last value that’s </span><code>brown</code><span> here:
</span><code>{:a &quot;foo&quot; :b :_ :c {:d &quot;brown&quot; :e &quot;bar&quot;} :f [{:g &quot;pale&quot; :h &quot;brown&quot; :i {:j &quot;ale&quot; :k [{:l &quot;brown&quot;} {:l &quot;brown&quot;}]}}]}</code></div><div data-t="nathanmarz @hkjels yes, you use  recursive-path  and  collect-one"><span class="u" id="1507211956.000522">2017:10:05 13:59:16           nathanmarz </span><span>@hkjels yes, you use </span><code>recursive-path</code><span> and </span><code>collect-one</code></div><div data-t="nathanmarz a related example here:  https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure"><span class="u" id="1507211960.000496">2017:10:05 13:59:20           nathanmarz </span><span>a related example here: </span><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure</a></div><div data-t="hkjels @nathanmarz thanks! I’ll give that a shot
Looks like a really good lib"><span class="u" id="1507212895.000222">2017:10:05 14:14:55               hkjels </span><span>@nathanmarz thanks! I’ll give that a shot
Looks like a really good lib</span></div><div data-t="michaelwfogleman @nathanmarz: Just pushed a new version of PR with mutual recursion and the building blocks we&apos;ve been working on - could use an assist coming up with a better example for mutually recursive paths"><span class="u" id="1507220763.000502">2017:10:05 16:26:03     michaelwfogleman </span><span>@nathanmarz: Just pushed a new version of PR with mutual recursion and the building blocks we&apos;ve been working on - could use an assist coming up with a better example for mutually recursive paths</span></div><div data-t="nathanmarz @michaelwfogleman I only ever made a mutually recursive path once... and it&apos;s way too involved to use as an example"><span class="u" id="1507226009.000146">2017:10:05 17:53:29           nathanmarz </span><span>@michaelwfogleman I only ever made a mutually recursive path once... and it&apos;s way too involved to use as an example</span></div><div data-t="nathanmarz I think just showing the basics of how mutually recursive paths would be structured is sufficient"><span class="u" id="1507226042.000257">2017:10:05 17:54:02           nathanmarz </span><span>I think just showing the basics of how mutually recursive paths would be structured is sufficient</span></div><div data-t="gdeer81 speaking of examples, if anyone has any interesting ones that they want me to turn into a specter koan, just open an issue and paste it in  https://github.com/gdeer81/specter-koans/issues"><span class="u" id="1507231324.000723">2017:10:05 19:22:04              gdeer81 </span><span>speaking of examples, if anyone has any interesting ones that they want me to turn into a specter koan, just open an issue and paste it in </span><a href="https://github.com/gdeer81/specter-koans/issues">https://github.com/gdeer81/specter-koans/issues</a></div><div data-t="gdeer81 or you can just paste your scratchpad and I can mine it for any good nuggets"><span class="u" id="1507231379.000141">2017:10:05 19:22:59              gdeer81 </span><span>or you can just paste your scratchpad and I can mine it for any good nuggets</span></div><div data-t="michaelwfogleman @nathanmarz In that case, the PR should be either pretty close or good to go  🙂"><span class="u" id="1507242319.000072">2017:10:05 22:25:19     michaelwfogleman </span><span>@nathanmarz In that case, the PR should be either pretty close or good to go </span><b>🙂</b></div><div data-t="gdeer81 is  AFTER-ELEM  used in selections or is just primarily used with  setval  ? I want to make sure my koans cover possible use cases unless it doesn&apos;t make sense."><span class="u" id="1507303961.000498">2017:10:06 15:32:41              gdeer81 </span><span>is </span><code>AFTER-ELEM</code><span> used in selections or is just primarily used with </span><code>setval</code><span> ? I want to make sure my koans cover possible use cases unless it doesn&apos;t make sense.</span></div><div data-t="gdeer81 also, I watched the talk and was excited about specter keeping the collection type the same so I was surprised when I saw this  (setval AFTER-ELEM 2 #{1 2}) =&gt; (1 2 2)"><span class="u" id="1507304674.000388">2017:10:06 15:44:34              gdeer81 </span><span>also, I watched the talk and was excited about specter keeping the collection type the same so I was surprised when I saw this </span><code>(setval AFTER-ELEM 2 #{1 2}) =&gt; (1 2 2)</code></div><div data-t="gdeer81 the set was turned into a list"><span class="u" id="1507304703.000473">2017:10:06 15:45:03              gdeer81 </span><span>the set was turned into a list</span></div><div data-t="gdeer81 it does the same thing for a map"><span class="u" id="1507304943.000527">2017:10:06 15:49:03              gdeer81 </span><span>it does the same thing for a map</span></div><div data-t="gdeer81 I tried to pass a k/v pair to AFTER-ELEM as two args and go a wrong number of args error"><span class="u" id="1507305010.000157">2017:10:06 15:50:10              gdeer81 </span><span>I tried to pass a k/v pair to AFTER-ELEM as two args and go a wrong number of args error</span></div><div data-t="gdeer81 when I put the k/v pair as a map it just turned the original map into a vector, added it to a list and then added my k/v argument as a separate map in the list like this:  (setval AFTER-ELEM {:friend &quot;Mary&quot;} {:name &quot;Paul&quot;}) =&gt; ([:name &quot;Paul&quot;] {:friend &quot;Mary&quot;})  so since the result isn&apos;t treated like a map you don&apos;t need k/v pair balance  (setval AFTER-ELEM &quot;Mary&quot; {:name &quot;Paul&quot;}) =&gt; ([:name &quot;Paul&quot;] &quot;Mary&quot;)"><span class="u" id="1507305343.000591">2017:10:06 15:55:43              gdeer81 </span><span>when I put the k/v pair as a map it just turned the original map into a vector, added it to a list and then added my k/v argument as a separate map in the list like this: </span><code>(setval AFTER-ELEM {:friend &quot;Mary&quot;} {:name &quot;Paul&quot;}) =&gt; ([:name &quot;Paul&quot;] {:friend &quot;Mary&quot;})</code><span> so since the result isn&apos;t treated like a map you don&apos;t need k/v pair balance </span><code>(setval AFTER-ELEM &quot;Mary&quot; {:name &quot;Paul&quot;}) =&gt; ([:name &quot;Paul&quot;] &quot;Mary&quot;)</code></div><div data-t="gdeer81 I just want to make sure I&apos;m not documenting nonsense cases"><span class="u" id="1507305462.000444">2017:10:06 15:57:42              gdeer81 </span><span>I just want to make sure I&apos;m not documenting nonsense cases</span></div><div data-t="nathanmarz @gdeer81  AFTER-ELEM  is only intended for transformations"><span class="u" id="1507305554.000268">2017:10:06 15:59:14           nathanmarz </span><span>@gdeer81 </span><code>AFTER-ELEM</code><span> is only intended for transformations</span></div><div data-t="nathanmarz it doesn&apos;t make sense in the context of a set"><span class="u" id="1507305574.000352">2017:10:06 15:59:34           nathanmarz </span><span>it doesn&apos;t make sense in the context of a set</span></div><div data-t="nathanmarz to add a single element to a set most efficiently use  NONE-ELEM"><span class="u" id="1507305586.000330">2017:10:06 15:59:46           nathanmarz </span><span>to add a single element to a set most efficiently use </span><code>NONE-ELEM</code></div><div data-t="nathanmarz likewise, it doesn&apos;t make sense in the context of a map"><span class="u" id="1507305612.000417">2017:10:06 16:00:12           nathanmarz </span><span>likewise, it doesn&apos;t make sense in the context of a map</span></div><div data-t="nathanmarz for a map, just use  keypath"><span class="u" id="1507305616.000291">2017:10:06 16:00:16           nathanmarz </span><span>for a map, just use </span><code>keypath</code></div><div data-t="gdeer81 I figured that was the case"><span class="u" id="1507305664.000052">2017:10:06 16:01:04              gdeer81 </span><span>I figured that was the case</span></div><div data-t="gdeer81 so for each navigation I&apos;m trying to document intended use and collection types"><span class="u" id="1507306290.000288">2017:10:06 16:11:30              gdeer81 </span><span>so for each navigation I&apos;m trying to document intended use and collection types</span></div><div data-t="nathanmarz cool, that&apos;s good"><span class="u" id="1507306371.000240">2017:10:06 16:12:51           nathanmarz </span><span>cool, that&apos;s good</span></div><div data-t="nathanmarz would be a good thing to add to the docstrings too"><span class="u" id="1507306378.000330">2017:10:06 16:12:58           nathanmarz </span><span>would be a good thing to add to the docstrings too</span></div><div data-t="gdeer81 ha or even the spec, &quot;spec error: you shouldn&apos;t be using this on a set&quot;"><span class="u" id="1507306469.000632">2017:10:06 16:14:29              gdeer81 </span><span>ha or even the spec, &quot;spec error: you shouldn&apos;t be using this on a set&quot;</span></div><div data-t="michaelwfogleman Does Specter have specs? I didn&apos;t think it did"><span class="u" id="1507319425.000024">2017:10:06 19:50:25     michaelwfogleman </span><span>Does Specter have specs? I didn&apos;t think it did</span></div><div data-t="michaelwfogleman I&apos;m pretty new to specs but I&apos;d be willing to help spec Specter if that&apos;s of interest"><span class="u" id="1507319441.000586">2017:10:06 19:50:41     michaelwfogleman </span><span>I&apos;m pretty new to specs but I&apos;d be willing to help spec Specter if that&apos;s of interest</span></div><div data-t="michaelwfogleman Yeah, took another look and pretty sure it doesn&apos;t, since it&apos;s on 1.8.0 and there&apos;s no files included"><span class="u" id="1507321654.000042">2017:10:06 20:27:34     michaelwfogleman </span><span>Yeah, took another look and pretty sure it doesn&apos;t, since it&apos;s on 1.8.0 and there&apos;s no files included</span></div><div data-t="gdeer81 @nathanmarz  (let [my-vec ^{:author &quot;Gary&quot;} [1 2 3]] (meta (select ALL-WITH-META my-vec)))  returns nil , am I doing something wrong or is this a bug?"><span class="u" id="1507323596.000363">2017:10:06 20:59:56              gdeer81 </span><span>@nathanmarz </span><code>(let [my-vec ^{:author &quot;Gary&quot;} [1 2 3]] (meta (select ALL-WITH-META my-vec)))</code><span> returns nil , am I doing something wrong or is this a bug?</span></div><div data-t="michaelwfogleman @gdeer81 @nathanmarz I took a look, it looks like meta is preserved with a transform but not with the select implementation, you can see it in the code too"><span class="u" id="1507326363.000272">2017:10:06 21:46:03     michaelwfogleman </span><span>@gdeer81 @nathanmarz I took a look, it looks like meta is preserved with a transform but not with the select implementation, you can see it in the code too</span></div><div data-t="michaelwfogleman (let [my-num ^{:author &quot;Gary&quot;} [1]] (meta (transform ALL-WITH-META inc my-num)))"><span class="u" id="1507326372.000242">2017:10:06 21:46:12     michaelwfogleman </span><span>(let [my-num ^{:author &quot;Gary&quot;} [1]] (meta (transform ALL-WITH-META inc my-num)))</span></div><div data-t="michaelwfogleman (defnav
  ^{:doc &quot;Same as ALL, except maintains metadata on the structure.&quot;}
  ALL-WITH-META
  []
  (select* [this structure next-fn]
    (n/all-select structure next-fn))
  (transform* [this structure next-fn]
    (let [m (meta structure)
          res (n/all-transform structure next-fn)]
      (if (some? res)
        (with-meta res m)
        ))))"><span class="u" id="1507326383.000240">2017:10:06 21:46:23     michaelwfogleman </span><span>(defnav
  ^{:doc &quot;Same as ALL, except maintains metadata on the structure.&quot;}
  ALL-WITH-META
  []
  (select* [this structure next-fn]
    (n/all-select structure next-fn))
  (transform* [this structure next-fn]
    (let [m (meta structure)
          res (n/all-transform structure next-fn)]
      (if (some? res)
        (with-meta res m)
        ))))</span></div><div data-t="michaelwfogleman I think I can file a patch  🙂"><span class="u" id="1507326414.000163">2017:10:06 21:46:54     michaelwfogleman </span><span>I think I can file a patch </span><b>🙂</b></div><div data-t="nathanmarz there&apos;s no metadata to maintain on select, since it navigates into the subvalues"><span class="u" id="1507326484.000310">2017:10:06 21:48:04           nathanmarz </span><span>there&apos;s no metadata to maintain on select, since it navigates into the subvalues</span></div><div data-t="nathanmarz that nav purely exists for transforms, especially for  codewalker"><span class="u" id="1507326514.000128">2017:10:06 21:48:34           nathanmarz </span><span>that nav purely exists for transforms, especially for </span><code>codewalker</code></div><div data-t="michaelwfogleman @nathanmarz Ah, looks like this one isn&apos;t in the docs either, I&apos;ll submit a pr for it"><span class="u" id="1507326804.000200">2017:10:06 21:53:24     michaelwfogleman </span><span>@nathanmarz Ah, looks like this one isn&apos;t in the docs either, I&apos;ll submit a pr for it</span></div><div data-t="gdeer81 I&apos;m going to stick to creating koans for the things documented in the wiki until I&apos;m more attuned with the code"><span class="u" id="1507327266.000181">2017:10:06 22:01:06              gdeer81 </span><span>I&apos;m going to stick to creating koans for the things documented in the wiki until I&apos;m more attuned with the code</span></div><div data-t="michaelwfogleman Sent in a PR, and a few related to a new issue I opened about undocumented vars:  https://github.com/nathanmarz/specter-wiki/issues/17"><span class="u" id="1507329604.000090">2017:10:06 22:40:04     michaelwfogleman </span><span>Sent in a PR, and a few related to a new issue I opened about undocumented vars: </span><a href="https://github.com/nathanmarz/specter-wiki/issues/17">https://github.com/nathanmarz/specter-wiki/issues/17</a></div><div data-t="james Hi everyone, I made a screencast to introduce Specter to newcomers:  https://www.youtube.com/watch?v=rh5J4vacG98"><span class="u" id="1507331650.000182">2017:10:06 23:14:10                james </span><span>Hi everyone, I made a screencast to introduce Specter to newcomers: </span><a href="https://www.youtube.com/watch?v=rh5J4vacG98">https://www.youtube.com/watch?v=rh5J4vacG98</a></div><div data-t="michaelwfogleman I&apos;ve watched a bunch of your older videos, awesome to see one on Specter! Keep them coming!  🙂"><span class="u" id="1507333117.000157">2017:10:06 23:38:37          michaelwfogleman </span><span>I&apos;ve watched a bunch of your older videos, awesome to see one on Specter! Keep them coming! </span><b>🙂</b></div><div data-t="drewverlee This is awesome"><span class="u" id="1507343311.000073">2017:10:07 02:28:31                drewverlee </span><span>This is awesome</span></div><div data-t="gdeer81 ha, I love when I find holes in my understanding of how the code works. my new obsession is  INDEXED-VALS  on its own as a select it totally makes sense, but change it to a transform and compose it with another navigator and you blow my cognitive budget. I thought this code was going to return the collection unchanged  (setval [INDEXED-VALS FIRST] 0 [1 2 3])  but to achieve that result you have to pass it length - 1 instead of 0"><span class="u" id="1507343293.000007">2017:10:07 02:28:13              gdeer81 </span><span>ha, I love when I find holes in my understanding of how the code works. my new obsession is </span><code>INDEXED-VALS</code><span> on its own as a select it totally makes sense, but change it to a transform and compose it with another navigator and you blow my cognitive budget. I thought this code was going to return the collection unchanged </span><code>(setval [INDEXED-VALS FIRST] 0 [1 2 3])</code><span> but to achieve that result you have to pass it length - 1 instead of 0</span></div><div data-t="drewverlee So, i’m sure this has come up before. But i can’t find any discussion on it. Possible because its a nonsense idea. But isn’t HTML a deeply nested structure? Couldn’t Specter be used to manipulate it? Actual, come to think of it, is there any overlap in concept to something like jquery?"><span class="u" id="1507344199.000066">2017:10:07 02:43:19           drewverlee </span><span>So, i’m sure this has come up before. But i can’t find any discussion on it. Possible because its a nonsense idea. But isn’t HTML a deeply nested structure? Couldn’t Specter be used to manipulate it? Actual, come to think of it, is there any overlap in concept to something like jquery?</span></div><div data-t="drewverlee Also is there a way to just navigate to something based not on the path but based off some predicate? like any map with the key :foo"><span class="u" id="1507344324.000051">2017:10:07 02:45:24           drewverlee </span><span>Also is there a way to just navigate to something based not on the path but based off some predicate? like any map with the key :foo</span></div><div data-t="drewverlee um, yea. its called walker"><span class="u" id="1507344362.000061">2017:10:07 02:46:02           drewverlee </span><span>um, yea. its called walker</span></div><div data-t="gdeer81 I just realized that  (setval [INDEXED-VALS FIRST] 0 [1 2 3])  actually reverses the collection"><span class="u" id="1507345082.000113">2017:10:07 02:58:02              gdeer81 </span><span>I just realized that </span><code>(setval [INDEXED-VALS FIRST] 0 [1 2 3])</code><span> actually reverses the collection</span></div><div data-t="gdeer81 well anyway, I&apos;m going to put it in as a koan so it will be interesting to see how many people come to the channel to ask about this one ha"><span class="u" id="1507345420.000072">2017:10:07 03:03:40              gdeer81 </span><span>well anyway, I&apos;m going to put it in as a koan so it will be interesting to see how many people come to the channel to ask about this one ha</span></div><div data-t="nathanmarz @james Great screencast! I&apos;ll add it as a link to the readme"><span class="u" id="1507401525.000102">2017:10:07 18:38:45           nathanmarz </span><span>@james Great screencast! I&apos;ll add it as a link to the readme</span></div><div data-t="nathanmarz @drewverlee yea, Specter is perfect for manipulating HTML"><span class="u" id="1507401628.000023">2017:10:07 18:40:28           nathanmarz </span><span>@drewverlee yea, Specter is perfect for manipulating HTML</span></div><div data-t="nathanmarz it would be easy to make compound navigators to re-create the various query capabilities of jquery"><span class="u" id="1507401659.000089">2017:10:07 18:40:59           nathanmarz </span><span>it would be easy to make compound navigators to re-create the various query capabilities of jquery</span></div><div data-t="james @nathanmarz Thanks!"><span class="u" id="1507416160.000072">2017:10:07 22:42:40                james </span><span>@nathanmarz Thanks!</span></div><div data-t="hkjels @james really good introduction! Thank you"><span class="u" id="1507533010.000128">2017:10:09 07:10:10               hkjels </span><span>@james really good introduction! Thank you</span></div><div data-t="hkjels are you by any chance going to make one on how to use Specter recursively as well  😆"><span class="u" id="1507533131.000018">2017:10:09 07:12:11               hkjels </span><span>are you by any chance going to make one on how to use Specter recursively as well </span><b>😆</b></div><div data-t="schmee @hkjels I know it’s not a screencast, but have you seen  https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively ?"><span class="u" id="1507533209.000062">2017:10:09 07:13:29               schmee </span><span>@hkjels I know it’s not a screencast, but have you seen </span><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively</a><span>?</span></div><div data-t="hkjels yeah. It’s just not as easy to take in as a screencast when I have to kids running around"><span class="u" id="1507533266.000177">2017:10:09 07:14:26               hkjels </span><span>yeah. It’s just not as easy to take in as a screencast when I have to kids running around</span></div><div data-t="hkjels I’ve come to a point where I’m trying things at random   😡"><span class="u" id="1507546129.000291">2017:10:09 10:48:49               hkjels </span><span>I’ve come to a point where I’m trying things at random  </span><b>😡</b></div><div data-t="hkjels I’d really appreciate it if someone could explain what I’m doing wrong here:
 https://gist.github.com/hkjels/2bad9d432eb77c68e5dc31dc5df9f63f"><span class="u" id="1507547734.000024">2017:10:09 11:15:34               hkjels </span><span>I’d really appreciate it if someone could explain what I’m doing wrong here:
</span><a href="https://gist.github.com/hkjels/2bad9d432eb77c68e5dc31dc5df9f63f">https://gist.github.com/hkjels/2bad9d432eb77c68e5dc31dc5df9f63f</a></div><div data-t="schmee @hkjels I’m not sure exactly what’s wrong but one thing is that you are not using your recursive path (`p`) anywhere"><span class="u" id="1507556835.000493">2017:10:09 13:47:15               schmee </span><span>@hkjels I’m not sure exactly what’s wrong but one thing is that you are not using your recursive path (`p`) anywhere</span></div><div data-t="hkjels OK. I need to have another look at the docs"><span class="u" id="1507557723.000338">2017:10:09 14:02:03               hkjels </span><span>OK. I need to have another look at the docs</span></div><div data-t="michaelwfogleman @hjkels Tried to take a look but I&apos;m not sure exactly what you want - it might help to write a test to validate the output"><span class="u" id="1507574341.000331">2017:10:09 18:39:01     michaelwfogleman </span><span>@hjkels Tried to take a look but I&apos;m not sure exactly what you want - it might help to write a test to validate the output</span></div><div data-t="gdeer81 parinfer is a blessing and a curse"><span class="u" id="1507605854.000143">2017:10:10 03:24:14              gdeer81 </span><span>parinfer is a blessing and a curse</span></div><div data-t="gdeer81 latest version of the koans are up with all unparameterized and parameterized navigators covered"><span class="u" id="1507609326.000067">2017:10:10 04:22:06              gdeer81 </span><span>latest version of the koans are up with all unparameterized and parameterized navigators covered</span></div><div data-t="gdeer81 next step is covering the rest of the core macros in depth. I had a real chicken and egg problem when deciding how to organize the koans. it&apos;s like do I say &quot;look at  select [ALL]  ignore what  ALL  means, but here&apos;s what  select  returns vs  select-one  or do I say look what  [ALL]  does, it does something different if used with  select   setval  and  transform  but just know that no matter what you&apos;re doing, it gives you all the things&quot;"><span class="u" id="1507647916.000823">2017:10:10 15:05:16              gdeer81 </span><span>next step is covering the rest of the core macros in depth. I had a real chicken and egg problem when deciding how to organize the koans. it&apos;s like do I say &quot;look at </span><code>select [ALL]</code><span> ignore what </span><code>ALL</code><span> means, but here&apos;s what </span><code>select</code><span> returns vs </span><code>select-one</code><span> or do I say look what </span><code>[ALL]</code><span> does, it does something different if used with </span><code>select</code><span> </span><code>setval</code><span> and </span><code>transform</code><span> but just know that no matter what you&apos;re doing, it gives you all the things&quot;</span></div><div data-t="nathanmarz @gdeer81 in my mind I find the easiest mental model is distinguishing between subvalue, substructure, filter, and view navigators"><span class="u" id="1507650913.000681">2017:10:10 15:55:13           nathanmarz </span><span>@gdeer81 in my mind I find the easiest mental model is distinguishing between subvalue, substructure, filter, and view navigators</span></div><div data-t="nathanmarz subvalue navs I just imagine as taking me to subvalues of a data structure, and the operation (e.g. select, transform) just says what to do when I get there"><span class="u" id="1507650953.000272">2017:10:10 15:55:53           nathanmarz </span><span>subvalue navs I just imagine as taking me to subvalues of a data structure, and the operation (e.g. select, transform) just says what to do when I get there</span></div><div data-t="nathanmarz one example that would be good for the koans to illustrate what an operation does is  (select-any ALL data)"><span class="u" id="1507651035.000552">2017:10:10 15:57:15           nathanmarz </span><span>one example that would be good for the koans to illustrate what an operation does is </span><code>(select-any ALL data)</code></div><div data-t="gdeer81 @nathanmarz like this?  https://github.com/gdeer81/specter-koans/blob/55686414f70c8ba739c84bafffb88173b7ee9f9d/src/koans/01_selection.clj#L50"><span class="u" id="1507651354.000821">2017:10:10 16:02:34              gdeer81 </span><span>@nathanmarz like this? </span><a href="https://github.com/gdeer81/specter-koans/blob/55686414f70c8ba739c84bafffb88173b7ee9f9d/src/koans/01_selection.clj#L50">https://github.com/gdeer81/specter-koans/blob/55686414f70c8ba739c84bafffb88173b7ee9f9d/src/koans/01_selection.clj#L50</a></div><div data-t="gdeer81 After watching @james screencast I think you&apos;re right, the first thing that needs to be discussed is the concept of subvalues, substructures, filters, and views"><span class="u" id="1507651627.000675">2017:10:10 16:07:07              gdeer81 </span><span>After watching @james screencast I think you&apos;re right, the first thing that needs to be discussed is the concept of subvalues, substructures, filters, and views</span></div><div data-t="gdeer81 in koan 1 I kept running into it when illustrating navigation but never made it a first class concept"><span class="u" id="1507651742.000448">2017:10:10 16:09:02              gdeer81 </span><span>in koan 1 I kept running into it when illustrating navigation but never made it a first class concept</span></div><div data-t="nathanmarz ah yea, that&apos;s good"><span class="u" id="1507651801.000070">2017:10:10 16:10:01           nathanmarz </span><span>ah yea, that&apos;s good</span></div><div data-t="nathanmarz a series with  select-any ,  select-first ,  select-one , and  select-one!  to show the subtle differences would be good too"><span class="u" id="1507651840.000158">2017:10:10 16:10:40           nathanmarz </span><span>a series with </span><code>select-any</code><span>, </span><code>select-first</code><span>, </span><code>select-one</code><span>, and </span><code>select-one!</code><span> to show the subtle differences would be good too</span></div><div data-t="gdeer81 Yeah, I think I can flesh out the rest of koan 1 to operate on the same data structure, the trick is finding one that&apos;s complex enough to be interesting but not so unwieldy that it ruins the learning experience"><span class="u" id="1507651996.000500">2017:10:10 16:13:16              gdeer81 </span><span>Yeah, I think I can flesh out the rest of koan 1 to operate on the same data structure, the trick is finding one that&apos;s complex enough to be interesting but not so unwieldy that it ruins the learning experience</span></div><div data-t="gdeer81 I&apos;ve started mining github for examples by searching for repos where people have hand-written  map-vals"><span class="u" id="1507652104.000442">2017:10:10 16:15:04              gdeer81 </span><span>I&apos;ve started mining github for examples by searching for repos where people have hand-written </span><code>map-vals</code></div><div data-t="gdeer81 another one people seem to grok easily is product data. even ones with complex hierarchies"><span class="u" id="1507652351.000507">2017:10:10 16:19:11              gdeer81 </span><span>another one people seem to grok easily is product data. even ones with complex hierarchies</span></div><div data-t="nathanmarz I would start simple before getting to anything too compound"><span class="u" id="1507652384.000588">2017:10:10 16:19:44           nathanmarz </span><span>I would start simple before getting to anything too compound</span></div><div data-t="gdeer81 okay, I&apos;ll save it for the advanced koans then"><span class="u" id="1507652425.000391">2017:10:10 16:20:25              gdeer81 </span><span>okay, I&apos;ll save it for the advanced koans then</span></div><div data-t="nathanmarz if you want to make &quot;challenge koans&quot; towards the end, paths that require  subselect  are usually pretty challenging"><span class="u" id="1507652445.000164">2017:10:10 16:20:45           nathanmarz </span><span>if you want to make &quot;challenge koans&quot; towards the end, paths that require </span><code>subselect</code><span> are usually pretty challenging</span></div><div data-t="gdeer81 yeah, when I did the parameterized navigators koan and I got to subselect, I just copied and pasted the example from the wiki"><span class="u" id="1507652865.000435">2017:10:10 16:27:45              gdeer81 </span><span>yeah, when I did the parameterized navigators koan and I got to subselect, I just copied and pasted the example from the wiki</span></div><div data-t="gdeer81 it hurt my brain trying to think of a practical example that would work"><span class="u" id="1507652895.000369">2017:10:10 16:28:15              gdeer81 </span><span>it hurt my brain trying to think of a practical example that would work</span></div><div data-t="gdeer81 after playing with  subselect  a bit I&apos;m starting to get it. basically for transforms you want to use a function that takes a collection and returns a collection. a lot of these seem tricky in isolation but once you start understanding when you would use them, they become more intuitive"><span class="u" id="1507662961.000635">2017:10:10 19:16:01              gdeer81 </span><span>after playing with </span><code>subselect</code><span> a bit I&apos;m starting to get it. basically for transforms you want to use a function that takes a collection and returns a collection. a lot of these seem tricky in isolation but once you start understanding when you would use them, they become more intuitive</span></div><div data-t="gdeer81 my next endeavor is using specter with reframe.  most reframe events have pretty small effects like &quot;add this string to the todos vector&quot; but someone once said that you don&apos;t need to have a deeply nested data structure to get the benefits of specter. so if anything I will get to play around with visualizing specter transformations with refrisk"><span class="u" id="1507669073.000183">2017:10:10 20:57:53              gdeer81 </span><span>my next endeavor is using specter with reframe.  most reframe events have pretty small effects like &quot;add this string to the todos vector&quot; but someone once said that you don&apos;t need to have a deeply nested data structure to get the benefits of specter. so if anything I will get to play around with visualizing specter transformations with refrisk</span></div><div data-t="nathanmarz @gdeer81 a visualizer of navigation would be a tremendous addition to the project"><span class="u" id="1507670513.000211">2017:10:10 21:21:53           nathanmarz </span><span>@gdeer81 a visualizer of navigation would be a tremendous addition to the project</span></div><div data-t="nathanmarz I think that would really help people get over the learning curve"><span class="u" id="1507670523.000085">2017:10:10 21:22:03           nathanmarz </span><span>I think that would really help people get over the learning curve</span></div><div data-t="gdeer81 awesome I was able to get reframe events and subscriptions to use specter but refrisk doesn&apos;t show enough detail to visualize the transformation. Back to the drawing board"><span class="u" id="1507673531.000070">2017:10:10 22:12:11              gdeer81 </span><span>awesome I was able to get reframe events and subscriptions to use specter but refrisk doesn&apos;t show enough detail to visualize the transformation. Back to the drawing board</span></div><div data-t="gdeer81 I am pretty happy I got specter working with re-frame, even though I&apos;m doing anything mind blowing  (reg-sub :counter  (fn [db _] (specter/select-any [:counter] db)))  gets the current count of the counter and  (reg-event-db :inc-counter (fn [db _] (specter/transform [:counter] inc db))  increases the counter this is wired up to a div subscribed to the count and a button to dispatch the :inc-counter event"><span class="u" id="1507673732.000237">2017:10:10 22:15:32              gdeer81 </span><span>I am pretty happy I got specter working with re-frame, even though I&apos;m doing anything mind blowing </span><code>(reg-sub :counter  (fn [db _] (specter/select-any [:counter] db)))</code><span> gets the current count of the counter and </span><code>(reg-event-db :inc-counter (fn [db _] (specter/transform [:counter] inc db))</code><span> increases the counter this is wired up to a div subscribed to the count and a button to dispatch the :inc-counter event</span></div><div data-t="gdeer81 and of course the db is just  {counter 0}  but I wanted to get it working before I went too crazy with the nesting"><span class="u" id="1507674044.000349">2017:10:10 22:20:44              gdeer81 </span><span>and of course the db is just </span><code>{counter 0}</code><span> but I wanted to get it working before I went too crazy with the nesting</span></div><div data-t="gdeer81 tonight I&apos;ll explore the re-frame library that gives you undo capabilities since that will probably keep track of before/after app db state which would be helpful with the visualization"><span class="u" id="1507674221.000091">2017:10:10 22:23:41              gdeer81 </span><span>tonight I&apos;ll explore the re-frame library that gives you undo capabilities since that will probably keep track of before/after app db state which would be helpful with the visualization</span></div><div data-t="michaelwfogleman @nathanmarz Venturing into the code with an initial commit of a regex navigator  - I just have select working - might need an assist with the transform implementation"><span class="u" id="1507678073.000032">2017:10:10 23:27:53     michaelwfogleman </span><span>@nathanmarz Venturing into the code with an initial commit of a regex navigator  - I just have select working - might need an assist with the transform implementation</span></div><div data-t="nathanmarz @michaelwfogleman a regex can match many substrings, so your implementation doesn&apos;t look right"><span class="u" id="1507679538.000042">2017:10:10 23:52:18           nathanmarz </span><span>@michaelwfogleman a regex can match many substrings, so your implementation doesn&apos;t look right</span></div><div data-t="nathanmarz I&apos;m not sure what replacement facilities are available in the regex api"><span class="u" id="1507679636.000124">2017:10:10 23:53:56           nathanmarz </span><span>I&apos;m not sure what replacement facilities are available in the regex api</span></div><div data-t="hkjels I’m starting to get a feel for  recursive-path  now, but I don’t see how I can solve my problem with it.
I want to pluck all the parents of a particular map based on a predicate for that map.
The way I see it, I’ll either have to start the search from the leaves of my tree or remove branches as it goes.
The latter would require that I keep track of my tree with some local-state, so it doesn’t seem idiomatic to specter?"><span class="u" id="1507711260.000288">2017:10:11 08:41:00               hkjels </span><span>I’m starting to get a feel for </span><code>recursive-path</code><span> now, but I don’t see how I can solve my problem with it.
I want to pluck all the parents of a particular map based on a predicate for that map.
The way I see it, I’ll either have to start the search from the leaves of my tree or remove branches as it goes.
The latter would require that I keep track of my tree with some local-state, so it doesn’t seem idiomatic to specter?</span></div><div data-t="hkjels https://gist.github.com/hkjels/2bad9d432eb77c68e5dc31dc5df9f63f"><span class="u" id="1507711455.000332">2017:10:11 08:44:15               hkjels </span><a href="https://gist.github.com/hkjels/2bad9d432eb77c68e5dc31dc5df9f63f">https://gist.github.com/hkjels/2bad9d432eb77c68e5dc31dc5df9f63f</a></div><div data-t="hkjels This current solution will select the correct maps, but if I try to collect the previous result, that will happen for “bar” as well"><span class="u" id="1507711503.000375">2017:10:11 08:45:03               hkjels </span><span>This current solution will select the correct maps, but if I try to collect the previous result, that will happen for “bar” as well</span></div><div data-t="hkjels Almost at a solution now"><span class="u" id="1507720198.000186">2017:10:11 11:09:58               hkjels </span><span>Almost at a solution now</span></div><div data-t="hkjels Can I do a transformation from within a recursive-path macro"><span class="u" id="1507720301.000161">2017:10:11 11:11:41               hkjels </span><span>Can I do a transformation from within a recursive-path macro</span></div><div data-t="hkjels is that frowned upon?"><span class="u" id="1507720313.000120">2017:10:11 11:11:53               hkjels </span><span>is that frowned upon?</span></div><div data-t="nathanmarz @hkjels not entitely clear on what you&apos;re trying to do. Are you just trying to remove the children of all nodes matching a certain name?"><span class="u" id="1507735913.000416">2017:10:11 15:31:53           nathanmarz </span><span>@hkjels not entitely clear on what you&apos;re trying to do. Are you just trying to remove the children of all nodes matching a certain name?</span></div><div data-t="hkjels @nathanmarz I’m trying to retrieve all the parent nodes of nodes where the predicate is true and leave out all the children"><span class="u" id="1507738008.000467">2017:10:11 16:06:48               hkjels </span><span>@nathanmarz I’m trying to retrieve all the parent nodes of nodes where the predicate is true and leave out all the children</span></div><div data-t="hkjels of those nodes"><span class="u" id="1507738041.000445">2017:10:11 16:07:21               hkjels </span><span>of those nodes</span></div><div data-t="nathanmarz @hkjels so in this case you want to navigate to the parents of nodes with name &quot;qux&quot;?"><span class="u" id="1507738298.000261">2017:10:11 16:11:38           nathanmarz </span><span>@hkjels so in this case you want to navigate to the parents of nodes with name &quot;qux&quot;?</span></div><div data-t="hkjels yeah"><span class="u" id="1507738383.000359">2017:10:11 16:13:03               hkjels </span><span>yeah</span></div><div data-t="nathanmarz looks like this:
 (def data
  {:name &quot;foo&quot;
   :children
   [{:name &quot;bar&quot;
     :children []}
    {:name &quot;baz&quot;
     :children
     [{:name &quot;qux&quot;
       :children
       [{:name &quot;NO!&quot;
         :children
         []}]}]}
    {:name &quot;hello&quot;
     :children
     [{:name &quot;world&quot;
       :children
       [{:name &quot;qux&quot;
         :children
         [{:name &quot;NO!&quot;
           :children
           []}]}]}]}]})

(def NODES
  (recursive-path [] p
    (continue-then-stay :children ALL p)))

(defn nodes-with-child [name]
  (path NODES (selected? :children ALL :name (pred= name)))
  )

(select (nodes-with-child &quot;qux&quot;) data)
"><span class="u" id="1507738549.000514">2017:10:11 16:15:49           nathanmarz </span><span>looks like this:
</span><pre>(def data
  {:name &quot;foo&quot;
   :children
   [{:name &quot;bar&quot;
     :children []}
    {:name &quot;baz&quot;
     :children
     [{:name &quot;qux&quot;
       :children
       [{:name &quot;NO!&quot;
         :children
         []}]}]}
    {:name &quot;hello&quot;
     :children
     [{:name &quot;world&quot;
       :children
       [{:name &quot;qux&quot;
         :children
         [{:name &quot;NO!&quot;
           :children
           []}]}]}]}]})

(def NODES
  (recursive-path [] p
    (continue-then-stay :children ALL p)))

(defn nodes-with-child [name]
  (path NODES (selected? :children ALL :name (pred= name)))
  )

(select (nodes-with-child &quot;qux&quot;) data)
</pre></div><div data-t="nathanmarz easiest way to do a recursive navigation is first make a path that navigates to every node, then do whatever filtering you need on top of that"><span class="u" id="1507738575.000642">2017:10:11 16:16:15           nathanmarz </span><span>easiest way to do a recursive navigation is first make a path that navigates to every node, then do whatever filtering you need on top of that</span></div><div data-t="hkjels Nice tip!
There’s still the issue where children of the selected node is in the structure"><span class="u" id="1507739216.000337">2017:10:11 16:26:56               hkjels </span><span>Nice tip!
There’s still the issue where children of the selected node is in the structure</span></div><div data-t="nathanmarz if you want the results without children then specify that in your selection"><span class="u" id="1507739347.000229">2017:10:11 16:29:07           nathanmarz </span><span>if you want the results without children then specify that in your selection</span></div><div data-t="nathanmarz (select [(nodes-with-child &quot;qux&quot;) (transformed :children (constantly NONE))] data)"><span class="u" id="1507739394.000782">2017:10:11 16:29:54           nathanmarz </span><code>(select [(nodes-with-child &quot;qux&quot;) (transformed :children (constantly NONE))] data)</code></div><div data-t="hkjels That short-circuits the walk on the node prior to the one where the predicate is true"><span class="u" id="1507746888.000397">2017:10:11 18:34:48                    hkjels </span><span>That short-circuits the walk on the node prior to the one where the predicate is true</span></div><div data-t="Chris Dewar-English I want to cherry-pick a set of values from different parts of a nested structure.  Is that a reasonable thing to try to do with Specter?"><span class="u" id="1507740431.000100">2017:10:11 16:47:11  Chris Dewar-English </span><span>I want to cherry-pick a set of values from different parts of a nested structure.  Is that a reasonable thing to try to do with Specter?</span></div><div data-t="nathanmarz yes"><span class="u" id="1507740530.000510">2017:10:11 16:48:50           nathanmarz </span><span>yes</span></div><div data-t="Chris Dewar-English I currently use  get-in  and map over the keywords to get to each value.  It works fine, but what is the principle behind doing that with specter?"><span class="u" id="1507740687.000070">2017:10:11 16:51:27  Chris Dewar-English </span><span>I currently use </span><code>get-in</code><span> and map over the keywords to get to each value.  It works fine, but what is the principle behind doing that with specter?</span></div><div data-t="Chris Dewar-English In this sample dataset  https://pastebin.com/MgtqLCXg"><span class="u" id="1507740807.000030">2017:10:11 16:53:27  Chris Dewar-English </span><span>In this sample dataset </span><a href="https://pastebin.com/MgtqLCXg">https://pastebin.com/MgtqLCXg</a></div><div data-t="nathanmarz if you want to get all the summaries, it&apos;s  (select [(keypath &quot;issues&quot;) ALL (keypath &quot;fields&quot; &quot;summary&quot;)] data)"><span class="u" id="1507740876.000536">2017:10:11 16:54:36           nathanmarz </span><span>if you want to get all the summaries, it&apos;s </span><code>(select [(keypath &quot;issues&quot;) ALL (keypath &quot;fields&quot; &quot;summary&quot;)] data)</code></div><div data-t="Chris Dewar-English I would like to pull multiple values, i.e. from issues/id, issues/key, issues/fields/summary, issues/fields/project/name"><span class="u" id="1507740948.000195">2017:10:11 16:55:48  Chris Dewar-English </span><span>I would like to pull multiple values, i.e. from issues/id, issues/key, issues/fields/summary, issues/fields/project/name</span></div><div data-t="Chris Dewar-English I&apos;m not sure all those selects make sense in a single navigator do they?"><span class="u" id="1507740977.000034">2017:10:11 16:56:17  Chris Dewar-English </span><span>I&apos;m not sure all those selects make sense in a single navigator do they?</span></div><div data-t="nathanmarz how do you want the results structured?"><span class="u" id="1507740981.000149">2017:10:11 16:56:21           nathanmarz </span><span>how do you want the results structured?</span></div><div data-t="Chris Dewar-English I&apos;m essentially trying to flatten the JSON data into CSV."><span class="u" id="1507741025.000267">2017:10:11 16:57:05  Chris Dewar-English </span><span>I&apos;m essentially trying to flatten the JSON data into CSV.</span></div><div data-t="Chris Dewar-English And cherry-pick just the values I need."><span class="u" id="1507741060.000421">2017:10:11 16:57:40  Chris Dewar-English </span><span>And cherry-pick just the values I need.</span></div><div data-t="nathanmarz (select [(keypath &quot;issues&quot;) ALL (collect-one (keypath &quot;id&quot;)) (keypath &quot;fields&quot;) (collect-one (keypath &quot;summary&quot;)) (keypath &quot;project&quot; &quot;name&quot;)] data)"><span class="u" id="1507741079.000344">2017:10:11 16:57:59           nathanmarz </span><code>(select [(keypath &quot;issues&quot;) ALL (collect-one (keypath &quot;id&quot;)) (keypath &quot;fields&quot;) (collect-one (keypath &quot;summary&quot;)) (keypath &quot;project&quot; &quot;name&quot;)] data)</code></div><div data-t="nathanmarz that will get everything you need as a vector in that order"><span class="u" id="1507741107.000330">2017:10:11 16:58:27           nathanmarz </span><span>that will get everything you need as a vector in that order</span></div><div data-t="Chris Dewar-English Ok, so drill down to the end element, but collect the values as you go?"><span class="u" id="1507741123.000190">2017:10:11 16:58:43  Chris Dewar-English </span><span>Ok, so drill down to the end element, but collect the values as you go?</span></div><div data-t="nathanmarz yes"><span class="u" id="1507741158.000549">2017:10:11 16:59:18           nathanmarz </span><span>yes</span></div><div data-t="nathanmarz if you&apos;re doing a lot of navigation by string keys, it may be worth creating an implicit navigator for strings as is done for keywords  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1161"><span class="u" id="1507741184.000105">2017:10:11 16:59:44           nathanmarz </span><span>if you&apos;re doing a lot of navigation by string keys, it may be worth creating an implicit navigator for strings as is done for keywords </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1161">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1161</a></div><div data-t="nathanmarz then you can write  (select [&quot;issues&quot; ALL (collect-one &quot;id&quot;) ..."><span class="u" id="1507741202.000429">2017:10:11 17:00:02           nathanmarz </span><span>then you can write </span><code>(select [&quot;issues&quot; ALL (collect-one &quot;id&quot;) ...</code></div><div data-t="Chris Dewar-English That part is ok, the string keys are turned into keywords using Cheshire when it parses"><span class="u" id="1507741252.000655">2017:10:11 17:00:52  Chris Dewar-English </span><span>That part is ok, the string keys are turned into keywords using Cheshire when it parses</span></div><div data-t="Chris Dewar-English Regarding using  collect...  I&apos;ve just assumed  collect-one  was only applicable when doing a transform. I didn&apos;t realise it would just contain the final elements!"><span class="u" id="1507741291.000558">2017:10:11 17:01:31  Chris Dewar-English </span><span>Regarding using </span><code>collect...</code><span> I&apos;ve just assumed </span><code>collect-one</code><span> was only applicable when doing a transform. I didn&apos;t realise it would just contain the final elements!</span></div><div data-t="nathanmarz yep, that&apos;s the only behavior that makes sense for  select  codepath"><span class="u" id="1507741313.000284">2017:10:11 17:01:53           nathanmarz </span><span>yep, that&apos;s the only behavior that makes sense for </span><code>select</code><span> codepath</span></div><div data-t="Chris Dewar-English Good stuff. Thank you, Nathan."><span class="u" id="1507741364.000599">2017:10:11 17:02:44  Chris Dewar-English </span><span>Good stuff. Thank you, Nathan.</span></div><div data-t="gdeer81 okay, I think I&apos;ve found an interesting data structure for learning; koan 4 will be about writing transformations to facilitate a space-shooter game. this makes the examples like this easier to read  (transform [ALL (collect-one :velocity) #(:enemy? %) :y] (fn [velocity current-y] (* velocity current-y)) entities)"><span class="u" id="1507755978.000185">2017:10:11 21:06:18              gdeer81 </span><span>okay, I think I&apos;ve found an interesting data structure for learning; koan 4 will be about writing transformations to facilitate a space-shooter game. this makes the examples like this easier to read </span><code>(transform [ALL (collect-one :velocity) #(:enemy? %) :y] (fn [velocity current-y] (* velocity current-y)) entities)</code></div><div data-t="gdeer81 this transformation obviously takes all the entity maps and updates every enemy&apos;s y coordinate by its velocity"><span class="u" id="1507756193.000130">2017:10:11 21:09:53              gdeer81 </span><span>this transformation obviously takes all the entity maps and updates every enemy&apos;s y coordinate by its velocity</span></div><div data-t="gdeer81 that can process about 5k maps in sub-miliseconds (caveat: i&apos;m using  time  as my micro-benchmark tool)"><span class="u" id="1507756356.000158">2017:10:11 21:12:36              gdeer81 </span><span>that can process about 5k maps in sub-miliseconds (caveat: i&apos;m using </span><code>time</code><span> as my micro-benchmark tool)</span></div><div data-t="nathanmarz @gdeer81 cool, that sounds nice and tangible"><span class="u" id="1507760430.000184">2017:10:11 22:20:30           nathanmarz </span><span>@gdeer81 cool, that sounds nice and tangible</span></div><div data-t="gdeer81 differences in decisions about how you want to manipulate the game objects easily illustrate subtle differences in navigations"><span class="u" id="1507761381.000025">2017:10:11 22:36:21              gdeer81 </span><span>differences in decisions about how you want to manipulate the game objects easily illustrate subtle differences in navigations</span></div><div data-t="michaelwfogleman @nathanmarz: Perhaps what you are thinking of is using re-seq? (re-seq #&quot;.&quot;  &quot;abc&quot;)
(&quot;a&quot; &quot;b&quot; &quot;c&quot;)"><span class="u" id="1507762103.000102">2017:10:11 22:48:23     michaelwfogleman </span><span>@nathanmarz: Perhaps what you are thinking of is using re-seq? (re-seq #&quot;.&quot;  &quot;abc&quot;)
(&quot;a&quot; &quot;b&quot; &quot;c&quot;)</span></div><div data-t="michaelwfogleman (re-seq #&quot;abc+&quot;  &quot;abc&quot;)
(&quot;abc&quot;)"><span class="u" id="1507762115.000230">2017:10:11 22:48:35     michaelwfogleman </span><span>(re-seq #&quot;abc+&quot;  &quot;abc&quot;)
(&quot;abc&quot;)</span></div><div data-t="nathanmarz @michaelwfogleman yea, that looks right"><span class="u" id="1507762566.000047">2017:10:11 22:56:06           nathanmarz </span><span>@michaelwfogleman yea, that looks right</span></div><div data-t="michaelwfogleman ok cool"><span class="u" id="1507762699.000042">2017:10:11 22:58:19     michaelwfogleman </span><span>ok cool</span></div><div data-t="michaelwfogleman going to try and poke at the transform"><span class="u" id="1507762743.000150">2017:10:11 22:59:03     michaelwfogleman </span><span>going to try and poke at the transform</span></div><div data-t="gdeer81 can you do transforms on records? I&apos;m getting an error that specter can&apos;t create an empty record"><span class="u" id="1507774970.000102">2017:10:12 02:22:50              gdeer81 </span><span>can you do transforms on records? I&apos;m getting an error that specter can&apos;t create an empty record</span></div><div data-t="gdeer81 oh no, I think I tried to get too clever"><span class="u" id="1507775535.000240">2017:10:12 02:32:15              gdeer81 </span><span>oh no, I think I tried to get too clever</span></div><div data-t="michaelwfogleman @nathanmarz Do you have a sense of a transform implementation that&apos;s similar to what needs to be done for the Regex navigator?"><span class="u" id="1507915786.000199">2017:10:13 17:29:46     michaelwfogleman </span><span>@nathanmarz Do you have a sense of a transform implementation that&apos;s similar to what needs to be done for the Regex navigator?</span></div><div data-t="nathanmarz @michaelwfogleman no, the implementation will be fairly specific to that navigator"><span class="u" id="1507916858.000284">2017:10:13 17:47:38           nathanmarz </span><span>@michaelwfogleman no, the implementation will be fairly specific to that navigator</span></div><div data-t="nathanmarz needs to run replace matching substrings with result of running  next-fn  on the substring"><span class="u" id="1507916883.000706">2017:10:13 17:48:03           nathanmarz </span><span>needs to run replace matching substrings with result of running </span><code>next-fn</code><span> on the substring</span></div><div data-t="nathanmarz looks like  Pattern/split  and some of the functions in  Matcher  should be able to be used to implement it"><span class="u" id="1507917216.000658">2017:10:13 17:53:36           nathanmarz </span><span>looks like </span><code>Pattern/split</code><span> and some of the functions in </span><code>Matcher</code><span> should be able to be used to implement it</span></div><div data-t="michaelwfogleman Makes sense, I&apos;ll look into it"><span class="u" id="1507918548.000649">2017:10:13 18:15:48     michaelwfogleman </span><span>Makes sense, I&apos;ll look into it</span></div><div data-t="aisamu Hi!
Is it possible to  collect  a value of every &quot;branch&quot; separately instead of all of them?

I&apos;m trying to get all possible  get-in  path vectors for a given nested map (preferably excluding  :root ):
 (magic {:root {:a {:b 1 :c 2} :d {:e 1 :f 2}}})
 =&gt; [[:a :b] [:a :c] [:d :e] [:d :f]]`
 
The best I could manage so far was this:
 (select [MAP-VALS (collect MAP-KEYS) MAP-VALS MAP-KEYS]
        {:root {:a {:b 1 :c 2} :d {:e 1 :f 2}}})
=&gt; [[[:a :d] :b] [[:a :d] :c] [[:a :d] :e] [[:a :d] :f]]
 
...which is almost there, but  collect  grabs all the branches&apos; values at every step.
I could massage that second structure into what I need, but I suspect there is a nicer way of approaching this  🙂"><span class="u" id="1507948173.000028">2017:10:14 02:29:33               aisamu </span><span>Hi!
Is it possible to </span><code>collect</code><span> a value of every &quot;branch&quot; separately instead of all of them?

I&apos;m trying to get all possible </span><code>get-in</code><span> path vectors for a given nested map (preferably excluding </span><code>:root</code><span>):
</span><pre>(magic {:root {:a {:b 1 :c 2} :d {:e 1 :f 2}}})
 =&gt; [[:a :b] [:a :c] [:d :e] [:d :f]]`
</pre><span>
The best I could manage so far was this:
</span><pre>(select [MAP-VALS (collect MAP-KEYS) MAP-VALS MAP-KEYS]
        {:root {:a {:b 1 :c 2} :d {:e 1 :f 2}}})
=&gt; [[[:a :d] :b] [[:a :d] :c] [[:a :d] :e] [[:a :d] :f]]
</pre><span>
...which is almost there, but </span><code>collect</code><span> grabs all the branches&apos; values at every step.
I could massage that second structure into what I need, but I suspect there is a nicer way of approaching this </span><b>🙂</b></div><div data-t="nathanmarz @aisamu it&apos;s like this:
 (def data {:root {:a {:b 1 :c 2} :d {:e 1 :f 2}}})

(select [:root ALL (collect-one FIRST) LAST MAP-KEYS] data)
"><span class="u" id="1507999032.000012">2017:10:14 16:37:12           nathanmarz </span><span>@aisamu it&apos;s like this:
</span><pre>(def data {:root {:a {:b 1 :c 2} :d {:e 1 :f 2}}})

(select [:root ALL (collect-one FIRST) LAST MAP-KEYS] data)
</pre></div><div data-t="nathanmarz if your data is recursive, this example is instructive for how to collect all the paths (which can be arbitrary/varying lengths):  https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure"><span class="u" id="1507999118.000034">2017:10:14 16:38:38           nathanmarz </span><span>if your data is recursive, this example is instructive for how to collect all the paths (which can be arbitrary/varying lengths): </span><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure</a></div><div data-t="aisamu Thanks! That makes a lot of sense!"><span class="u" id="1508002080.000050">2017:10:14 17:28:00               aisamu </span><span>Thanks! That makes a lot of sense!</span></div><div data-t="hkjels Is it possible to start a search from a trees leaves?
Or select the deepest nested match only?"><span class="u" id="1508151626.000078">2017:10:16 11:00:26               hkjels </span><span>Is it possible to start a search from a trees leaves?
Or select the deepest nested match only?</span></div><div data-t="borkdude I have a data structure like  {:foo [{:bar #{:a x}} {:bar #{:b c}]}  and I want to filter  :foo  by some predicate. Now I’m using  (update m :foo filter-fn)  where  filter-fn  is something like  (filter coll pred) . 
How do I write this using Specter? Does it have some filter functionality?"><span class="u" id="1508167890.000829">2017:10:16 15:31:30             borkdude </span><span>I have a data structure like </span><code>{:foo [{:bar #{:a x}} {:bar #{:b c}]}</code><span> and I want to filter </span><code>:foo</code><span> by some predicate. Now I’m using </span><code>(update m :foo filter-fn)</code><span> where </span><code>filter-fn</code><span> is something like </span><code>(filter coll pred)</code><span>. 
How do I write this using Specter? Does it have some filter functionality?</span></div><div data-t="nathanmarz @hkjels you could do something like that with zippers, but there&apos;s probably a better way"><span class="u" id="1508168659.000839">2017:10:16 15:44:19           nathanmarz </span><span>@hkjels you could do something like that with zippers, but there&apos;s probably a better way</span></div><div data-t="nathanmarz for deepest match, you could do  select  with  putval  at every recursive step, and then choose longest result at end"><span class="u" id="1508168715.000436">2017:10:16 15:45:15           nathanmarz </span><span>for deepest match, you could do </span><code>select</code><span> with </span><code>putval</code><span> at every recursive step, and then choose longest result at end</span></div><div data-t="nathanmarz @borkdude that looks like  (setval [:foo ALL remove-fn?] NONE data)"><span class="u" id="1508168782.000749">2017:10:16 15:46:22           nathanmarz </span><span>@borkdude that looks like </span><code>(setval [:foo ALL remove-fn?] NONE data)</code></div><div data-t="borkdude ah great"><span class="u" id="1508168859.000014">2017:10:16 15:47:39             borkdude </span><span>ah great</span></div><div data-t="borkdude so setting NONE is semantically equivalent to removing an element in Specter"><span class="u" id="1508168891.000100">2017:10:16 15:48:11             borkdude </span><span>so setting NONE is semantically equivalent to removing an element in Specter</span></div><div data-t="nathanmarz yes"><span class="u" id="1508169099.000254">2017:10:16 15:51:39           nathanmarz </span><span>yes</span></div><div data-t="hkjels @nathanmarz I was overcomplicating it. I realized that I always need the fift level or deeper, so a simple predicate solved it"><span class="u" id="1508169268.000452">2017:10:16 15:54:28               hkjels </span><span>@nathanmarz I was overcomplicating it. I realized that I always need the fift level or deeper, so a simple predicate solved it</span></div><div data-t="borkdude Maybe there should be a Specter course on Clojure Academy  🙂"><span class="u" id="1508169473.000413">2017:10:16 15:57:53             borkdude </span><span>Maybe there should be a Specter course on Clojure Academy </span><b>🙂</b></div><div data-t="borkdude Almost what I want:
 (def data {:foo [{:bar [:a]}
                 {:bar [:a :b]}
                 {:bar [:c]}]})

(setval
 [:foo ALL :bar
  #(seq (set/intersection #{:a}
                          (set %)))]
 NONE
 data) ;;=&gt; {:foo [{} {} {:bar [:c]}]}
"><span class="u" id="1508169929.000503">2017:10:16 16:05:29             borkdude </span><span>Almost what I want:
</span><pre>(def data {:foo [{:bar [:a]}
                 {:bar [:a :b]}
                 {:bar [:c]}]})

(setval
 [:foo ALL :bar
  #(seq (set/intersection #{:a}
                          (set %)))]
 NONE
 data) ;;=&gt; {:foo [{} {} {:bar [:c]}]}
</pre></div><div data-t="borkdude but I want to get rid of the empty maps"><span class="u" id="1508169934.000123">2017:10:16 16:05:34             borkdude </span><span>but I want to get rid of the empty maps</span></div><div data-t="borkdude This works:
 (setval
 [:foo ALL
  #(seq (set/intersection #{:a}
                          (set (:bar %))))]
 NONE
 data)
"><span class="u" id="1508170002.000064">2017:10:16 16:06:42             borkdude </span><span>This works:
</span><pre>(setval
 [:foo ALL
  #(seq (set/intersection #{:a}
                          (set (:bar %))))]
 NONE
 data)
</pre></div><div data-t="hkjels More learning-material would be great. I saw one of your talks on Specter yesterday @nathanmarz and was really impressed by your presentation skills"><span class="u" id="1508170076.000650">2017:10:16 16:07:56               hkjels </span><span>More learning-material would be great. I saw one of your talks on Specter yesterday @nathanmarz and was really impressed by your presentation skills</span></div><div data-t="hkjels well done"><span class="u" id="1508170092.000090">2017:10:16 16:08:12               hkjels </span><span>well done</span></div><div data-t="borkdude actually it doesn’t work yet, hang on"><span class="u" id="1508170221.000307">2017:10:16 16:10:21             borkdude </span><span>actually it doesn’t work yet, hang on</span></div><div data-t="borkdude the predicate should be reversed, so with  empty?   🙂"><span class="u" id="1508170251.000607">2017:10:16 16:10:51             borkdude </span><span>the predicate should be reversed, so with </span><code>empty?</code><span> </span><b>🙂</b></div><div data-t="borkdude How do I update two paths in parallel, e.g.  {:foo 1 :bar 2} ,  (transform [#{:foo :bar} inc]) , is this possible?"><span class="u" id="1508170478.000532">2017:10:16 16:14:38             borkdude </span><span>How do I update two paths in parallel, e.g. </span><code>{:foo 1 :bar 2}</code><span>, </span><code>(transform [#{:foo :bar} inc])</code><span>, is this possible?</span></div><div data-t="borkdude ah, multi-path"><span class="u" id="1508170727.000561">2017:10:16 16:18:47             borkdude </span><span>ah, multi-path</span></div><div data-t="nathanmarz @borkdude for your empty map issue:
 (setval
  [:foo
   ALL
   (multi-path
     [:bar (selected? ALL (pred= :a))]
     empty?)]
  NONE
  data)
"><span class="u" id="1508174461.000046">2017:10:16 17:21:01           nathanmarz </span><span>@borkdude for your empty map issue:
</span><pre>(setval
  [:foo
   ALL
   (multi-path
     [:bar (selected? ALL (pred= :a))]
     empty?)]
  NONE
  data)
</pre></div><div data-t="nathanmarz @hkjels thanks"><span class="u" id="1508174474.000555">2017:10:16 17:21:14           nathanmarz </span><span>@hkjels thanks</span></div><div data-t="nathanmarz the wiki is much better nowadays and there was a screencast released recently"><span class="u" id="1508174497.000020">2017:10:16 17:21:37           nathanmarz </span><span>the wiki is much better nowadays and there was a screencast released recently</span></div><div data-t="nathanmarz linked on the readme"><span class="u" id="1508174503.000038">2017:10:16 17:21:43           nathanmarz </span><span>linked on the readme</span></div><div data-t="borkdude @nathanmarz that’s awesome"><span class="u" id="1508175260.000709">2017:10:16 17:34:20             borkdude </span><span>@nathanmarz that’s awesome</span></div><div data-t="borkdude @nathanmarz If I understand correctly, the function  empty?  is a selector for the path  :bar , after the right path has been applied, so it removes the empty map?"><span class="u" id="1508176137.000100">2017:10:16 17:48:57             borkdude </span><span>@nathanmarz If I understand correctly, the function </span><code>empty?</code><span> is a selector for the path </span><code>:bar</code><span>, after the right path has been applied, so it removes the empty map?</span></div><div data-t="borkdude On the wiki it says: for transforms it applies in order"><span class="u" id="1508176442.000173">2017:10:16 17:54:02             borkdude </span><span>On the wiki it says: for transforms it applies in order</span></div><div data-t="nathanmarz empty? is a filter run after removal of :bar values matching the first path"><span class="u" id="1508176520.000147">2017:10:16 17:55:20           nathanmarz </span><span>empty? is a filter run after removal of :bar values matching the first path</span></div><div data-t="borkdude ah now I get it, I read it wrong, as if  :bar  and  (selected? ....)  were both paths, but  empty?  itself is a “path” on the value returned by the previous path"><span class="u" id="1508176788.000427">2017:10:16 17:59:48             borkdude </span><span>ah now I get it, I read it wrong, as if </span><code>:bar</code><span> and </span><code>(selected? ....)</code><span> were both paths, but </span><code>empty?</code><span> itself is a “path” on the value returned by the previous path</span></div><div data-t="nathanmarz yea, that&apos;s right"><span class="u" id="1508176842.000425">2017:10:16 18:00:42           nathanmarz </span><span>yea, that&apos;s right</span></div><div data-t="nathanmarz that&apos;s also much more efficient than the set intersection approach"><span class="u" id="1508176996.000266">2017:10:16 18:03:16           nathanmarz </span><span>that&apos;s also much more efficient than the set intersection approach</span></div><div data-t="borkdude and because selected? stops the navigation, what is returned is the empty map, because no key-vals have been selected because pred= returned false"><span class="u" id="1508177091.000314">2017:10:16 18:04:51             borkdude </span><span>and because selected? stops the navigation, what is returned is the empty map, because no key-vals have been selected because pred= returned false</span></div><div data-t="borkdude correct?"><span class="u" id="1508177109.000733">2017:10:16 18:05:09             borkdude </span><span>correct?</span></div><div data-t="borkdude those are patterns worth remembering"><span class="u" id="1508177140.000002">2017:10:16 18:05:40             borkdude </span><span>those are patterns worth remembering</span></div><div data-t="nathanmarz well, selected? is run on the value of  :bar"><span class="u" id="1508177632.000656">2017:10:16 18:13:52           nathanmarz </span><span>well, selected? is run on the value of </span><code>:bar</code></div><div data-t="nathanmarz it selects any vectors that have  :a  in them"><span class="u" id="1508177644.000681">2017:10:16 18:14:04           nathanmarz </span><span>it selects any vectors that have </span><code>:a</code><span> in them</span></div><div data-t="nathanmarz which is then set to  NONE , removing the key/val pair from the map"><span class="u" id="1508177670.000169">2017:10:16 18:14:30           nathanmarz </span><span>which is then set to </span><code>NONE</code><span>, removing the key/val pair from the map</span></div><div data-t="nathanmarz then empty? is run, removing any maps from the vector that are now empty"><span class="u" id="1508177682.000533">2017:10:16 18:14:42           nathanmarz </span><span>then empty? is run, removing any maps from the vector that are now empty</span></div><div data-t="borkdude well, I need to check for multiple values, so I need the intersection, like this:
 (setval
 [:foo
  ALL
  (multi-path
   [:bar (selected? #(empty? (set/intersection #{:a :b} %)))]
   empty?)]
 NONE
 data)
"><span class="u" id="1508178123.000238">2017:10:16 18:22:03             borkdude </span><span>well, I need to check for multiple values, so I need the intersection, like this:
</span><pre>(setval
 [:foo
  ALL
  (multi-path
   [:bar (selected? #(empty? (set/intersection #{:a :b} %)))]
   empty?)]
 NONE
 data)
</pre></div><div data-t="nathanmarz you can do  [:bar (selected? ALL #{:a :b})]"><span class="u" id="1508178252.000232">2017:10:16 18:24:12           nathanmarz </span><span>you can do </span><code>[:bar (selected? ALL #{:a :b})]</code></div><div data-t="nathanmarz there&apos;s also no point to using  selected?  with only a function"><span class="u" id="1508178271.000381">2017:10:16 18:24:31           nathanmarz </span><span>there&apos;s also no point to using </span><code>selected?</code><span> with only a function</span></div><div data-t="nathanmarz sets are implicit filter predicates in specter"><span class="u" id="1508178287.000122">2017:10:16 18:24:47           nathanmarz </span><span>sets are implicit filter predicates in specter</span></div><div data-t="nathanmarz interpreted equivalent to a clojure function"><span class="u" id="1508178296.000328">2017:10:16 18:24:56           nathanmarz </span><span>interpreted equivalent to a clojure function</span></div><div data-t="borkdude This code does what I want:
 (def data (let [inner-data [{:bar #{:a}}
                            {:bar #{:a :b}}
                            {:bar #{:c}}]]
            {:a inner-data
             :b inner-data}))

(setval
 [(multi-path :a :b)
  ALL
  (multi-path
   [:bar (selected? ALL
                    (comp not #{:a :b}))]
   empty?)]
 NONE
 data)
 
but not in the case of  nil  or  {} , then it adds keys with nil"><span class="u" id="1508252287.000421">2017:10:17 14:58:07             borkdude </span><span>This code does what I want:
</span><pre>(def data (let [inner-data [{:bar #{:a}}
                            {:bar #{:a :b}}
                            {:bar #{:c}}]]
            {:a inner-data
             :b inner-data}))

(setval
 [(multi-path :a :b)
  ALL
  (multi-path
   [:bar (selected? ALL
                    (comp not #{:a :b}))]
   empty?)]
 NONE
 data)
</pre><span>
but not in the case of </span><code>nil</code><span> or </span><code>{}</code><span>, then it adds keys with nil</span></div><div data-t="nathanmarz @borkdude nil or {} for what?"><span class="u" id="1508252370.000325">2017:10:17 14:59:30           nathanmarz </span><span>@borkdude nil or {} for what?</span></div><div data-t="nathanmarz the inner maps?"><span class="u" id="1508252374.000274">2017:10:17 14:59:34           nathanmarz </span><span>the inner maps?</span></div><div data-t="borkdude the result,  {:a nil, :b nil}"><span class="u" id="1508252385.000566">2017:10:17 14:59:45             borkdude </span><span>the result, </span><code>{:a nil, :b nil}</code></div><div data-t="nathanmarz not following"><span class="u" id="1508252439.000675">2017:10:17 15:00:39           nathanmarz </span><span>not following</span></div><div data-t="borkdude (setval
 [(multi-path :a :b)
  ALL
  (multi-path
   [:bar (selected? ALL
                    (comp not #{:a :b}))]
   empty?)]
 NONE
 nil)
"><span class="u" id="1508252457.000293">2017:10:17 15:00:57             borkdude </span><pre>(setval
 [(multi-path :a :b)
  ALL
  (multi-path
   [:bar (selected? ALL
                    (comp not #{:a :b}))]
   empty?)]
 NONE
 nil)
</pre></div><div data-t="nathanmarz ah"><span class="u" id="1508252468.000086">2017:10:17 15:01:08           nathanmarz </span><span>ah</span></div><div data-t="borkdude ;;=&gt; {:a nil, :b nil}"><span class="u" id="1508252474.000172">2017:10:17 15:01:14             borkdude </span><code>;;=&gt; {:a nil, :b nil}</code></div><div data-t="nathanmarz you can use  (multi-path (must :a) (must :b))"><span class="u" id="1508252481.000222">2017:10:17 15:01:21           nathanmarz </span><span>you can use </span><code>(multi-path (must :a) (must :b))</code></div><div data-t="borkdude ah, a new construct… going to the wiki  🙂"><span class="u" id="1508252501.000887">2017:10:17 15:01:41             borkdude </span><span>ah, a new construct… going to the wiki </span><b>🙂</b></div><div data-t="borkdude when do you not want the behavior of  must ?"><span class="u" id="1508252543.000138">2017:10:17 15:02:23             borkdude </span><span>when do you not want the behavior of </span><code>must</code><span>?</span></div><div data-t="borkdude I mean, why is it not the default"><span class="u" id="1508252596.000622">2017:10:17 15:03:16             borkdude </span><span>I mean, why is it not the default</span></div><div data-t="nathanmarz i&apos;ve found the need to definitely navigate to a key is far more common"><span class="u" id="1508252663.000253">2017:10:17 15:04:23           nathanmarz </span><span>i&apos;ve found the need to definitely navigate to a key is far more common</span></div><div data-t="nathanmarz and it&apos;s faster"><span class="u" id="1508252665.000167">2017:10:17 15:04:25           nathanmarz </span><span>and it&apos;s faster</span></div><div data-t="nathanmarz also  (update {} :a identity) ;; =&gt; {:a nil}"><span class="u" id="1508252695.000009">2017:10:17 15:04:55           nathanmarz </span><span>also </span><code>(update {} :a identity) ;; =&gt; {:a nil}</code></div><div data-t="borkdude ah"><span class="u" id="1508252781.000214">2017:10:17 15:06:21             borkdude </span><span>ah</span></div><div data-t="borkdude Still I find the code incredibly hard to read compared to normal Clojure…"><span class="u" id="1508257112.000149">2017:10:17 16:18:32             borkdude </span><span>Still I find the code incredibly hard to read compared to normal Clojure…</span></div><div data-t="nathanmarz Specter 1.0.4 released"><span class="u" id="1508257128.000411">2017:10:17 16:18:48           nathanmarz </span><span>Specter 1.0.4 released</span></div><div data-t="borkdude Congrats on the new release"><span class="u" id="1508257161.000220">2017:10:17 16:19:21             borkdude </span><span>Congrats on the new release</span></div><div data-t="jeaye @nathanmarz Do you recommend using specter in lieu of clojure.core fns always? Or perhaps only when either 1) it&apos;s known to be faster; 2) it provides a much more robust solution;"><span class="u" id="1508259290.000291">2017:10:17 16:54:50                jeaye </span><span>@nathanmarz Do you recommend using specter in lieu of clojure.core fns always? Or perhaps only when either 1) it&apos;s known to be faster; 2) it provides a much more robust solution;</span></div><div data-t="jeaye Based on the benchmarks, it looks like specter isn&apos;t always faster. On a team, this makes it harder to bring in, since one can&apos;t just say &quot;We&apos;re using specter for data access now; it&apos;s faster and more robust.&quot; Unfortunately, the ruleset of when to use it (i.e.  get-in  seems slow,  transform  is very fast, unless you&apos;re doing a  mapv ) is complex, then makes it much more expensive to adopt and learn."><span class="u" id="1508259444.000503">2017:10:17 16:57:24                jeaye </span><span>Based on the benchmarks, it looks like specter isn&apos;t always faster. On a team, this makes it harder to bring in, since one can&apos;t just say &quot;We&apos;re using specter for data access now; it&apos;s faster and more robust.&quot; Unfortunately, the ruleset of when to use it (i.e. </span><code>get-in</code><span> seems slow, </span><code>transform</code><span> is very fast, unless you&apos;re doing a </span><code>mapv</code><span>) is complex, then makes it much more expensive to adopt and learn.</span></div><div data-t="nathanmarz @jeaye I use it always when it&apos;s more elegant than trying to do it in vanilla Clojure"><span class="u" id="1508260047.000507">2017:10:17 17:07:27           nathanmarz </span><span>@jeaye I use it always when it&apos;s more elegant than trying to do it in vanilla Clojure</span></div><div data-t="nathanmarz the overhead is generally quite small even for cases where the vanilla Clojure is just as elegant"><span class="u" id="1508260240.000295">2017:10:17 17:10:40           nathanmarz </span><span>the overhead is generally quite small even for cases where the vanilla Clojure is just as elegant</span></div><div data-t="nathanmarz the notable exception is  (select-any [:a :b :c] data)  vs.  (-&gt; data :a :b :c)"><span class="u" id="1508260259.000369">2017:10:17 17:10:59           nathanmarz </span><span>the notable exception is </span><code>(select-any [:a :b :c] data)</code><span> vs. </span><code>(-&gt; data :a :b :c)</code></div><div data-t="nathanmarz I do believe it&apos;s possible to eliminate most of the overhead for that with additional work on Specter"><span class="u" id="1508260316.000056">2017:10:17 17:11:56           nathanmarz </span><span>I do believe it&apos;s possible to eliminate most of the overhead for that with additional work on Specter</span></div><div data-t="nathanmarz though for a case like that I would do the latter expression in my own code since it&apos;s elegant"><span class="u" id="1508260361.000624">2017:10:17 17:12:41           nathanmarz </span><span>though for a case like that I would do the latter expression in my own code since it&apos;s elegant</span></div><div data-t="jeaye Word. Thanks for the info and congrats on the 1.0.4 release."><span class="u" id="1508261243.000456">2017:10:17 17:27:23                jeaye </span><span>Word. Thanks for the info and congrats on the 1.0.4 release.</span></div><div data-t="tanzoniteblack is there a way to use specter to select only distinct values (besides the obvious of  (distinct (specter/select apath structure))  which requires looping through the final result)"><span class="u" id="1508262119.000286">2017:10:17 17:41:59       tanzoniteblack </span><span>is there a way to use specter to select only distinct values (besides the obvious of </span><code>(distinct (specter/select apath structure))</code><span> which requires looping through the final result)</span></div><div data-t="tanzoniteblack (not that this is really a huge performance hit, but just curious)"><span class="u" id="1508262174.000101">2017:10:17 17:42:54       tanzoniteblack </span><span>(not that this is really a huge performance hit, but just curious)</span></div><div data-t="nathanmarz @tanzoniteblack you can do  (into #{} (traverse apath structure))"><span class="u" id="1508262457.000820">2017:10:17 17:47:37           nathanmarz </span><span>@tanzoniteblack you can do </span><code>(into #{} (traverse apath structure))</code></div><div data-t="nathanmarz that&apos;s the fastest"><span class="u" id="1508262463.000038">2017:10:17 17:47:43           nathanmarz </span><span>that&apos;s the fastest</span></div><div data-t="tanzoniteblack not the same though, since set&apos;s don&apos;t retain the order (which is important in this case)"><span class="u" id="1508262475.000310">2017:10:17 17:47:55       tanzoniteblack </span><span>not the same though, since set&apos;s don&apos;t retain the order (which is important in this case)</span></div><div data-t="tanzoniteblack (which I didn&apos;t specify in my question  🙂  , but  distinct  does retain the order, which is a useful property in my case)"><span class="u" id="1508262518.000171">2017:10:17 17:48:38       tanzoniteblack </span><span>(which I didn&apos;t specify in my question </span><b>🙂</b><span> , but </span><code>distinct</code><span> does retain the order, which is a useful property in my case)</span></div><div data-t="nathanmarz distinct  is the easiest, though  traverse  just returns a reducible so you can do it faster if needed"><span class="u" id="1508262697.000649">2017:10:17 17:51:37           nathanmarz </span><code>distinct</code><span> is the easiest, though </span><code>traverse</code><span> just returns a reducible so you can do it faster if needed</span></div><div data-t="nathanmarz reduce  over the  traverse  return to add into a vector while keeping a mutable set in scope in order to not append duplicates"><span class="u" id="1508262722.000028">2017:10:17 17:52:02           nathanmarz </span><code>reduce</code><span> over the </span><code>traverse</code><span> return to add into a vector while keeping a mutable set in scope in order to not append duplicates</span></div><div data-t="tanzoniteblack thanks"><span class="u" id="1508262768.000274">2017:10:17 17:52:48       tanzoniteblack </span><span>thanks</span></div><div data-t="nathanmarz actually  (into [] (distinct) (traverse apath structure))  might be equivalent to that"><span class="u" id="1508262811.000236">2017:10:17 17:53:31           nathanmarz </span><span>actually </span><code>(into [] (distinct) (traverse apath structure))</code><span> might be equivalent to that</span></div><div data-t="nathanmarz yea it is:
 user=&gt; (into [] (distinct) (traverse ALL [1 2 3 4 5 2 1 7]))
[1 2 3 4 5 7]
"><span class="u" id="1508262877.000244">2017:10:17 17:54:37           nathanmarz </span><span>yea it is:
</span><pre>user=&gt; (into [] (distinct) (traverse ALL [1 2 3 4 5 2 1 7]))
[1 2 3 4 5 7]
</pre></div><div data-t="tanzoniteblack nice to know I can use  traverse  with transducers"><span class="u" id="1508262916.000445">2017:10:17 17:55:16       tanzoniteblack </span><span>nice to know I can use </span><code>traverse</code><span> with transducers</span></div><div data-t="nathanmarz you can also make a specter-based transducer with  traverse-all"><span class="u" id="1508262950.000220">2017:10:17 17:55:50           nathanmarz </span><span>you can also make a specter-based transducer with </span><code>traverse-all</code></div><div data-t="borkdude @nathanmarz When you do a multi-path over an  ALL , will it iterate multiple times over the sequence? My code now looks like this:
 (setval
      [(multi-path (must :report) (must :highlights))
       ALL
       (multi-path
        [:pico
         #(not (some (set picos) %))]
        ;; if key is removed, remove the map entirely
        (comp not :pico))]
      NONE
      results)
"><span class="u" id="1508266998.000499">2017:10:17 19:03:18             borkdude </span><span>@nathanmarz When you do a multi-path over an </span><code>ALL</code><span>, will it iterate multiple times over the sequence? My code now looks like this:
</span><pre>(setval
      [(multi-path (must :report) (must :highlights))
       ALL
       (multi-path
        [:pico
         #(not (some (set picos) %))]
        ;; if key is removed, remove the map entirely
        (comp not :pico))]
      NONE
      results)
</pre></div><div data-t="borkdude but I could have used just a filter/remove function on the ALL"><span class="u" id="1508267035.000478">2017:10:17 19:03:55             borkdude </span><span>but I could have used just a filter/remove function on the ALL</span></div><div data-t="borkdude I could imagine that specter fuses these operations"><span class="u" id="1508267230.000425">2017:10:17 19:07:10             borkdude </span><span>I could imagine that specter fuses these operations</span></div><div data-t="nathanmarz that does not iterate over any sequence multiple times"><span class="u" id="1508267585.000368">2017:10:17 19:13:05           nathanmarz </span><span>that does not iterate over any sequence multiple times</span></div><div data-t="borkdude I think this is more readable though:
 (transform
      [(multi-path (must :report) (must :highlights))]
      #(remove
        (fn [m]
          (not (some (set picos) (:pico m)))) %)
      results)
"><span class="u" id="1508267650.000545">2017:10:17 19:14:10             borkdude </span><span>I think this is more readable though:
</span><pre>(transform
      [(multi-path (must :report) (must :highlights))]
      #(remove
        (fn [m]
          (not (some (set picos) (:pico m)))) %)
      results)
</pre></div><div data-t="borkdude but good to know it doesn’t iterate multiple times"><span class="u" id="1508267666.000050">2017:10:17 19:14:26             borkdude </span><span>but good to know it doesn’t iterate multiple times</span></div><div data-t="nathanmarz @borkdude the specter version can be done much simpler:
 (setval
  [(multi-path (must :report) (must :highlights))
   ALL
   (selected? :pico ALL (pred (set picos)))]
  NONE
  results)
"><span class="u" id="1508267965.000166">2017:10:17 19:19:25           nathanmarz </span><span>@borkdude the specter version can be done much simpler:
</span><pre>(setval
  [(multi-path (must :report) (must :highlights))
   ALL
   (selected? :pico ALL (pred (set picos)))]
  NONE
  results)
</pre></div><div data-t="borkdude nice!"><span class="u" id="1508268096.000170">2017:10:17 19:21:36             borkdude </span><span>nice!</span></div><div data-t="borkdude The problem is that  I need something slightly different:

 (def picos [:a :b])
(def results {:highlights [{:pico [:a]}    ;; keep
                           {:pico [:a :b]} ;; keep
                           {:pico [:c]}    ;; drop
                           {:pico [:c :d]} ;; drop
                           {:pico [:c :a]}]}) ;;keep

(transform
 [(multi-path (must :report) (must :highlights))]
 #(remove
   (fn [m]
     (not (some (set picos) (:pico m)))) %)
 results) ;;=&gt; {:highlights ({:pico [:a]} {:pico [:a :b]} {:pico [:c :a]})}
"><span class="u" id="1508269159.000194">2017:10:17 19:39:19             borkdude </span><span>The problem is that  I need something slightly different:

</span><pre>(def picos [:a :b])
(def results {:highlights [{:pico [:a]}    ;; keep
                           {:pico [:a :b]} ;; keep
                           {:pico [:c]}    ;; drop
                           {:pico [:c :d]} ;; drop
                           {:pico [:c :a]}]}) ;;keep

(transform
 [(multi-path (must :report) (must :highlights))]
 #(remove
   (fn [m]
     (not (some (set picos) (:pico m)))) %)
 results) ;;=&gt; {:highlights ({:pico [:a]} {:pico [:a :b]} {:pico [:c :a]})}
</pre></div><div data-t="borkdude so something like  (selected? :pico ANY (pred (comp not (set picos))))"><span class="u" id="1508269200.000751">2017:10:17 19:40:00             borkdude </span><span>so something like </span><code>(selected? :pico ANY (pred (comp not (set picos))))</code></div><div data-t="borkdude but I didn’t find something like  ANY"><span class="u" id="1508269209.000120">2017:10:17 19:40:09             borkdude </span><span>but I didn’t find something like </span><code>ANY</code></div><div data-t="nathanmarz ah you just need  (not-selected? ALL (set picos))"><span class="u" id="1508269587.000438">2017:10:17 19:46:27           nathanmarz </span><span>ah you just need </span><code>(not-selected? ALL (set picos))</code></div><div data-t="borkdude that works"><span class="u" id="1508269631.000002">2017:10:17 19:47:11             borkdude </span><span>that works</span></div><div data-t="nathanmarz btw, the  pred  is only there for performance, and is only needed if  picos  is a local variable"><span class="u" id="1508269675.000185">2017:10:17 19:47:55           nathanmarz </span><span>btw, the </span><code>pred</code><span> is only there for performance, and is only needed if </span><code>picos</code><span> is a local variable</span></div><div data-t="borkdude in my original code it is a local"><span class="u" id="1508269910.000612">2017:10:17 19:51:50             borkdude </span><span>in my original code it is a local</span></div><div data-t="nathanmarz the specter version will also preserve the sequence type"><span class="u" id="1508270383.000426">2017:10:17 19:59:43           nathanmarz </span><span>the specter version will also preserve the sequence type</span></div><div data-t="borkdude yes, that’s a bonus"><span class="u" id="1508270421.000117">2017:10:17 20:00:21             borkdude </span><span>yes, that’s a bonus</span></div><div data-t="nathanmarz also will only convert  picos  to a set once, instead of for every element"><span class="u" id="1508270444.000185">2017:10:17 20:00:44           nathanmarz </span><span>also will only convert </span><code>picos</code><span> to a set once, instead of for every element</span></div><div data-t="borkdude What is the explanation of this result? I don’t understand  selected?  and  not-selected?  well enough.
 (select [(selected? ALL odd?)] [1 2 3]) ;;=&gt; [[1 2 3]]"><span class="u" id="1508270475.000302">2017:10:17 20:01:15             borkdude </span><span>What is the explanation of this result? I don’t understand </span><code>selected?</code><span> and </span><code>not-selected?</code><span> well enough.
</span><code>(select [(selected? ALL odd?)] [1 2 3]) ;;=&gt; [[1 2 3]]</code></div><div data-t="nathanmarz selected?  stays navigated if the path selects at least one value"><span class="u" id="1508270523.000609">2017:10:17 20:02:03           nathanmarz </span><code>selected?</code><span> stays navigated if the path selects at least one value</span></div><div data-t="nathanmarz in this case it&apos;s run on the root, and it is true"><span class="u" id="1508270545.000369">2017:10:17 20:02:25           nathanmarz </span><span>in this case it&apos;s run on the root, and it is true</span></div><div data-t="nathanmarz so it selects the root  [1 2 3]"><span class="u" id="1508270558.000432">2017:10:17 20:02:38           nathanmarz </span><span>so it selects the root </span><code>[1 2 3]</code></div><div data-t="borkdude ah, that’s it"><span class="u" id="1508270565.000650">2017:10:17 20:02:45             borkdude </span><span>ah, that’s it</span></div><div data-t="borkdude so with a local I need  (pred (set picos))  and then it will substitute the value of the expression?"><span class="u" id="1508270773.000495">2017:10:17 20:06:13             borkdude </span><span>so with a local I need </span><code>(pred (set picos))</code><span> and then it will substitute the value of the expression?</span></div><div data-t="nathanmarz the  pred  in that case avoids a runtime conversion from an implicit navigator (a set) to a navigator"><span class="u" id="1508271261.000680">2017:10:17 20:14:21           nathanmarz </span><span>the </span><code>pred</code><span> in that case avoids a runtime conversion from an implicit navigator (a set) to a navigator</span></div><div data-t="nathanmarz sets are implicitly wrapped in  pred , but if the value at a spot is dynamic, then specter cannot know that until runtime"><span class="u" id="1508271332.000130">2017:10:17 20:15:32           nathanmarz </span><span>sets are implicitly wrapped in </span><code>pred</code><span>, but if the value at a spot is dynamic, then specter cannot know that until runtime</span></div><div data-t="nathanmarz it&apos;s not a huge deal, but it is a protocol invocation"><span class="u" id="1508271376.000164">2017:10:17 20:16:16           nathanmarz </span><span>it&apos;s not a huge deal, but it is a protocol invocation</span></div><div data-t="levitanong This is weird. on 1.0.3, while firing up my repl, I got a:
 java.lang.RuntimeException: Unable to resolve symbol: richnav in this context, compiling:(com/rpl/specter.cljc:62:6)
"><span class="u" id="1508339550.000463">2017:10:18 15:12:30           levitanong </span><span>This is weird. on 1.0.3, while firing up my repl, I got a:
</span><pre>java.lang.RuntimeException: Unable to resolve symbol: richnav in this context, compiling:(com/rpl/specter.cljc:62:6)
</pre></div><div data-t="levitanong what could this be?"><span class="u" id="1508339559.000178">2017:10:18 15:12:39           levitanong </span><span>what could this be?</span></div><div data-t="nathanmarz @levitanong is this clj or cljs?"><span class="u" id="1508358477.000028">2017:10:18 20:27:57           nathanmarz </span><span>@levitanong is this clj or cljs?</span></div><div data-t="levitanong @nathanmarz clj. Disappeared when I updated to 1.0.4 lol"><span class="u" id="1508358713.000003">2017:10:18 20:31:53           levitanong </span><span>@nathanmarz clj. Disappeared when I updated to 1.0.4 lol</span></div><div data-t="nathanmarz ok"><span class="u" id="1508359921.000038">2017:10:18 20:52:01           nathanmarz </span><span>ok</span></div><div data-t="gdeer81 the same thing happened to me when I was righting the specter-koans. it was because I started writing the koans in version 0.13.0 and picked it up again after the 1.0 release so my project.clj was sorely out of date. all was well after I bumped the specter version"><span class="u" id="1508368901.000065">2017:10:18 23:21:41              gdeer81 </span><span>the same thing happened to me when I was righting the specter-koans. it was because I started writing the koans in version 0.13.0 and picked it up again after the 1.0 release so my project.clj was sorely out of date. all was well after I bumped the specter version</span></div><div data-t="kishanov Hi there. How do I do the following transformation with specter:  (let [data {:a {:val 15}
            :b {:val 18}}]

  (-&gt;&gt; data
       (map (fn [[k v]]
              [k (assoc v :key (name k))]))
       (into {})))"><span class="u" id="1508385216.000102">2017:10:19 03:53:36             kishanov </span><span>Hi there. How do I do the following transformation with specter: </span><pre>(let [data {:a {:val 15}
            :b {:val 18}}]

  (-&gt;&gt; data
       (map (fn [[k v]]
              [k (assoc v :key (name k))]))
       (into {})))</pre></div><div data-t="kishanov i.e. is it possible to capture arguments in  transform  path and path them to transformation function?"><span class="u" id="1508385268.000011">2017:10:19 03:54:28             kishanov </span><span>i.e. is it possible to capture arguments in </span><code>transform</code><span> path and path them to transformation function?</span></div><div data-t="nathanmarz @kishanov yes, with value collection"><span class="u" id="1508386222.000153">2017:10:19 04:10:22           nathanmarz </span><span>@kishanov yes, with value collection</span></div><div data-t="nathanmarz (transform [ALL (collect-one FIRST NAME) LAST :key]
  (fn [n _] n)
  data)
"><span class="u" id="1508386226.000007">2017:10:19 04:10:26           nathanmarz </span><pre>(transform [ALL (collect-one FIRST NAME) LAST :key]
  (fn [n _] n)
  data)
</pre></div><div data-t="kishanov thnx @nathanmarz. Will the same approach work if I want to capture more then 1 value from the path? Ultimately I’m looking for the analog of “Capture groups” in instar"><span class="u" id="1508386414.000184">2017:10:19 04:13:34             kishanov </span><span>thnx @nathanmarz. Will the same approach work if I want to capture more then 1 value from the path? Ultimately I’m looking for the analog of “Capture groups” in instar</span></div><div data-t="nathanmarz yes, you can capture as many values as you want"><span class="u" id="1508386436.000045">2017:10:19 04:13:56           nathanmarz </span><span>yes, you can capture as many values as you want</span></div><div data-t="nathanmarz each  collect /`collect-one` call produces an extra argument to the transform function, in the order in which they&apos;re called"><span class="u" id="1508386457.000121">2017:10:19 04:14:17           nathanmarz </span><span>each </span><code>collect</code><span>/`collect-one` call produces an extra argument to the transform function, in the order in which they&apos;re called</span></div><div data-t="kishanov nice, thanks!"><span class="u" id="1508386478.000147">2017:10:19 04:14:38             kishanov </span><span>nice, thanks!</span></div><div data-t="eoliphant Hi i just discovered specter, it’s awesome.  I have a quick question.  I’m trying to add a map to a list of maps., but setval treats it as a collection and adding each k-v pair.  Like so:

 testmap
=&gt; {:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;}]}
(s/setval [:b s/END] {:id 5
                      :a 6} testmap)
=&gt; {:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;} [:id 5] [:a 6]]}
 

How do I get around this?"><span class="u" id="1509243163.000055">2017:10:29 02:12:43            eoliphant </span><span>Hi i just discovered specter, it’s awesome.  I have a quick question.  I’m trying to add a map to a list of maps., but setval treats it as a collection and adding each k-v pair.  Like so:

</span><pre>testmap
=&gt; {:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;}]}
(s/setval [:b s/END] {:id 5
                      :a 6} testmap)
=&gt; {:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;} [:id 5] [:a 6]]}
</pre><span>

How do I get around this?</span></div><div data-t="michaelwfogleman Not sure if this is the idiomatic way but does this do what you&apos;re looking for?"><span class="u" id="1509243515.000028">2017:10:29 02:18:35          michaelwfogleman </span><span>Not sure if this is the idiomatic way but does this do what you&apos;re looking for?</span></div><div data-t="michaelwfogleman (def test-map {:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;}]})
(transform [:b END] #(conj % {:id 5 :a 6}) test-map) "><span class="u" id="1509243517.000053">2017:10:29 02:18:37          michaelwfogleman </span><pre>(def test-map {:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;}]})
(transform [:b END] #(conj % {:id 5 :a 6}) test-map) </pre></div><div data-t="michaelwfogleman That returns  {:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;} {:id 5, :a 6}]}  for me"><span class="u" id="1509243530.000032">2017:10:29 02:18:50          michaelwfogleman </span><span>That returns </span><pre>{:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;} {:id 5, :a 6}]}</pre><span> for me</span></div><div data-t="eoliphant ah pass a function that returns it"><span class="u" id="1509243608.000041">2017:10:29 02:20:08                 eoliphant </span><span>ah pass a function that returns it</span></div><div data-t="eoliphant ok cool thanks will give that a shot"><span class="u" id="1509243615.000025">2017:10:29 02:20:15                 eoliphant </span><span>ok cool thanks will give that a shot</span></div><div data-t="michaelwfogleman I also don&apos;t think I needed end there"><span class="u" id="1509243633.000042">2017:10:29 02:20:33          michaelwfogleman </span><span>I also don&apos;t think I needed end there</span></div><div data-t="michaelwfogleman (transform [:b] #(conj % {:id 5 :a 6}) test-map)"><span class="u" id="1509243642.000012">2017:10:29 02:20:42          michaelwfogleman </span><pre>(transform [:b] #(conj % {:id 5 :a 6}) test-map)</pre></div><div data-t="michaelwfogleman that should do the same"><span class="u" id="1509243647.000009">2017:10:29 02:20:47          michaelwfogleman </span><span>that should do the same</span></div><div data-t="michaelwfogleman since a vector gets added to the end anyway"><span class="u" id="1509243654.000015">2017:10:29 02:20:54          michaelwfogleman </span><span>since a vector gets added to the end anyway</span></div><div data-t="eoliphant hey i just tried this too

 (s/setval [:b s/END] [{:id 5
                      :a 6}] testmap)
 
seems to work"><span class="u" id="1509244572.000012">2017:10:29 02:36:12                 eoliphant </span><span>hey i just tried this too

</span><pre>(s/setval [:b s/END] [{:id 5
                      :a 6}] testmap)
</pre><span>
seems to work</span></div><div data-t="michaelwfogleman Ah yeah!  🙂"><span class="u" id="1509245186.000012">2017:10:29 02:46:26          michaelwfogleman </span><span>Ah yeah! </span><b>🙂</b></div><div data-t="michaelwfogleman Nice!  🙂"><span class="u" id="1509245188.000012">2017:10:29 02:46:28          michaelwfogleman </span><span>Nice! </span><b>🙂</b></div><div data-t="nathanmarz @eoliphant use  AFTER-ELEM  to append a single element to a sequence"><span class="u" id="1509248329.000014">2017:10:29 03:38:49           nathanmarz </span><span>@eoliphant use </span><code>AFTER-ELEM</code><span> to append a single element to a sequence</span></div><div data-t="nathanmarz (setval [:b AFTER-ELEM] {:id 5 :a 6} testmap)"><span class="u" id="1509248350.000022">2017:10:29 03:39:10           nathanmarz </span><code>(setval [:b AFTER-ELEM] {:id 5 :a 6} testmap)</code></div><div data-t="nathanmarz that&apos;s more efficient than using  END  for this use case"><span class="u" id="1509248366.000013">2017:10:29 03:39:26           nathanmarz </span><span>that&apos;s more efficient than using </span><code>END</code><span> for this use case</span></div><div data-t="schmee this Specter snippet works, but I think it’s a bit of a code smell to have both  cond-path  and a  cond  in my transformation function. This being Specter, I suspect that there is a better way to do it  🙂 
 (def DATA-WALKER
  (s/recursive-path [] p
    (s/cond-path
      map? (s/continue-then-stay s/MAP-VALS p)
      seq? (s/continue-then-stay s/ALL p))))

(defn simplify [m]
  (s/transform
    DATA-WALKER
    #(cond
       (sequential? %) (vec %)
       (map? %) (into {} %))
    m))
 
Any suggestions?"><span class="u" id="1509266013.000008">2017:10:29 08:33:33               schmee </span><span>this Specter snippet works, but I think it’s a bit of a code smell to have both </span><code>cond-path</code><span> and a </span><code>cond</code><span> in my transformation function. This being Specter, I suspect that there is a better way to do it </span><b>🙂</b><span>
</span><pre>(def DATA-WALKER
  (s/recursive-path [] p
    (s/cond-path
      map? (s/continue-then-stay s/MAP-VALS p)
      seq? (s/continue-then-stay s/ALL p))))

(defn simplify [m]
  (s/transform
    DATA-WALKER
    #(cond
       (sequential? %) (vec %)
       (map? %) (into {} %))
    m))
</pre><span>
Any suggestions?</span></div><div data-t="schmee I’ve looked at  multi-transform , but I haven’t figured out how to use it with recursive paths"><span class="u" id="1509266039.000064">2017:10:29 08:33:59               schmee </span><span>I’ve looked at </span><code>multi-transform</code><span>, but I haven’t figured out how to use it with recursive paths</span></div><div data-t="nathanmarz @schmee  multi-transform  version would be  (multi-transform [DATA-WALKER (if-path map? (terminal #(into {} %)) (terminal vec))] m)"><span class="u" id="1509284301.000095">2017:10:29 13:38:21           nathanmarz </span><span>@schmee </span><code>multi-transform</code><span> version would be </span><code>(multi-transform [DATA-WALKER (if-path map? (terminal #(into {} %)) (terminal vec))] m)</code></div><div data-t="nathanmarz you don&apos;t need the  cond  since after  DATA-WALKER  it&apos;s either  map?  or  seq?"><span class="u" id="1509284336.000042">2017:10:29 13:38:56           nathanmarz </span><span>you don&apos;t need the </span><code>cond</code><span> since after </span><code>DATA-WALKER</code><span> it&apos;s either </span><code>map?</code><span> or </span><code>seq?</code></div><div data-t="schmee nice, thank you!  😄"><span class="u" id="1509293901.000044">2017:10:29 16:18:21               schmee </span><span>nice, thank you! </span><b>😄</b></div><div data-t="eoliphant hi i’ve got a quick path/select question.  In the following code
 (def testdata {:a
               {:b [{:c :d}
                    {:e :f}
                    {:g :h}]}})
 
I’d like to select out  :f  based on the fact that I know the  {:e :f}  map’s index
I get this far  (s/select [:a :b (s/srange 1 2)] testdata)   But can’t figure out what to add to the rest of the path"><span class="u" id="1509331192.000019">2017:10:30 02:39:52            eoliphant </span><span>hi i’ve got a quick path/select question.  In the following code
</span><pre>(def testdata {:a
               {:b [{:c :d}
                    {:e :f}
                    {:g :h}]}})
</pre><span>
I’d like to select out </span><code>:f</code><span> based on the fact that I know the </span><code>{:e :f}</code><span> map’s index
I get this far </span><code>(s/select [:a :b (s/srange 1 2)] testdata)</code><span>  But can’t figure out what to add to the rest of the path</span></div><div data-t="nathanmarz @eoliphant use  (nthpath 1)"><span class="u" id="1509332301.000004">2017:10:30 02:58:21           nathanmarz </span><span>@eoliphant use </span><code>(nthpath 1)</code></div><div data-t="eoliphant ah.. yeah that does it.  thanks!"><span class="u" id="1509332746.000071">2017:10:30 03:05:46            eoliphant </span><span>ah.. yeah that does it.  thanks!</span></div><div data-t="nathanmarz @eoliphant worth skimming through this page to see all the navigators that come with specter  https://github.com/nathanmarz/specter/wiki/List-of-Navigators"><span class="u" id="1509333933.000143">2017:10:30 03:25:33           nathanmarz </span><span>@eoliphant worth skimming through this page to see all the navigators that come with specter </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators">https://github.com/nathanmarz/specter/wiki/List-of-Navigators</a></div><div data-t="eoliphant hi @nathanmarz yeah re-read them after your help on that one.  I’d skimmed them before I started coding and really ‘got it’ lol.  Really great tool.  I’ve used lenses in Scala, which cover some of what Specter does. Clojure just makes everything better lol.  Specter is a much needed bit of special sauce,  I’m working on a pretty complex dynamic forms app, that needs a lot of deep structure querying/manipulation, spent the past 2 days ripping out all of my existing code for use cases that Specter covers"><span class="u" id="1509371923.000393">2017:10:30 13:58:43            eoliphant </span><span>hi @nathanmarz yeah re-read them after your help on that one.  I’d skimmed them before I started coding and really ‘got it’ lol.  Really great tool.  I’ve used lenses in Scala, which cover some of what Specter does. Clojure just makes everything better lol.  Specter is a much needed bit of special sauce,  I’m working on a pretty complex dynamic forms app, that needs a lot of deep structure querying/manipulation, spent the past 2 days ripping out all of my existing code for use cases that Specter covers</span></div><div data-t="nathanmarz @eoliphant great to hear"><span class="u" id="1509373885.000119">2017:10:30 14:31:25           nathanmarz </span><span>@eoliphant great to hear</span></div><div data-t="eoliphant is there a something like a ‘move’ macro/operation?  I’m picking my way through the use of recursive-path, etc. Basically, I’ve a use case where I need to find a node in a tree, save its current value, delete it from its current location, find a target node, then insert the saved node before or after the target.  Once I get the recursive locator stuff working, it seems like I’d need a select and two transforms, or a select and a multi-transform, is that more or less correct?"><span class="u" id="1509414724.000080">2017:10:31 01:52:04            eoliphant </span><span>is there a something like a ‘move’ macro/operation?  I’m picking my way through the use of recursive-path, etc. Basically, I’ve a use case where I need to find a node in a tree, save its current value, delete it from its current location, find a target node, then insert the saved node before or after the target.  Once I get the recursive locator stuff working, it seems like I’d need a select and two transforms, or a select and a multi-transform, is that more or less correct?</span></div><div data-t="nathanmarz best way to do something like that would be combining  multi-transform  and   collect-one"><span class="u" id="1509417111.000066">2017:10:31 02:31:51           nathanmarz </span><span>best way to do something like that would be combining </span><code>multi-transform</code><span> and  </span><code>collect-one</code></div><div data-t="nathanmarz depends on the use case though, some could require zippers"><span class="u" id="1509417204.000028">2017:10:31 02:33:24           nathanmarz </span><span>depends on the use case though, some could require zippers</span></div><div data-t="nathanmarz would need to see specifically what you&apos;re trying to do"><span class="u" id="1509417216.000117">2017:10:31 02:33:36           nathanmarz </span><span>would need to see specifically what you&apos;re trying to do</span></div><div data-t="eoliphant hi @nathanmarz sure, here’s a simplified example

 (def fakeform {:formdef {:form/id 1
                         :form/groups [{:group/id 2
                                        :group/type :page
                                        :group/fields [{:field/id 3
                                                        :field/name :fieldone}
                                                       {:field/id 4
                                                        :field/name :fieldtwo}
                                                       {:field/id 5
                                                        :field/name :fieldthree}]
                                        :group/subgroups  [{:group/id 6
                                                            :group/type :section
                                                            :group/fields [{:field/id 7
                                                                            :field/name :fieldfour}]}]}]}})
 

I’d like to approach simple transforms like “move the map identified by  :field/id 3  after the one identified by  :field/id 4 ” (which I can do with a srange/reverse, etc) as well as more arbitrarily complex ones like “move the map identified by  :field/id 3  after the one identified by  :field/id 7 ” in a consistent manner"><span class="u" id="1509457919.000180">2017:10:31 13:51:59            eoliphant </span><span>hi @nathanmarz sure, here’s a simplified example

</span><pre>(def fakeform {:formdef {:form/id 1
                         :form/groups [{:group/id 2
                                        :group/type :page
                                        :group/fields [{:field/id 3
                                                        :field/name :fieldone}
                                                       {:field/id 4
                                                        :field/name :fieldtwo}
                                                       {:field/id 5
                                                        :field/name :fieldthree}]
                                        :group/subgroups  [{:group/id 6
                                                            :group/type :section
                                                            :group/fields [{:field/id 7
                                                                            :field/name :fieldfour}]}]}]}})
</pre><span>

I’d like to approach simple transforms like “move the map identified by </span><code>:field/id 3</code><span> after the one identified by </span><code>:field/id 4</code><span>” (which I can do with a srange/reverse, etc) as well as more arbitrarily complex ones like “move the map identified by </span><code>:field/id 3</code><span> after the one identified by </span><code>:field/id 7</code><span>” in a consistent manner</span></div><div data-t="nathanmarz @eoliphant you can do this with a helper path that navigates you to a zipper pointing to the desired node"><span class="u" id="1509459357.000210">2017:10:31 14:15:57           nathanmarz </span><span>@eoliphant you can do this with a helper path that navigates you to a zipper pointing to the desired node</span></div><div data-t="nathanmarz (point-to 3)"><span class="u" id="1509459365.000027">2017:10:31 14:16:05           nathanmarz </span><code>(point-to 3)</code></div><div data-t="nathanmarz then you could do  (select-any [(point-to 3) zip/NODE] fakeform)  to get the value for 3"><span class="u" id="1509459393.000021">2017:10:31 14:16:33           nathanmarz </span><span>then you could do </span><code>(select-any [(point-to 3) zip/NODE] fakeform)</code><span> to get the value for 3</span></div><div data-t="nathanmarz (setval [(point-to 3) zip/NODE-SEQ] [] fakeform)  to remove 3"><span class="u" id="1509459414.000107">2017:10:31 14:16:54           nathanmarz </span><code>(setval [(point-to 3) zip/NODE-SEQ] [] fakeform)</code><span> to remove 3</span></div><div data-t="nathanmarz and  (setval [(point-to 7] zip/INNER-RIGHT] [value-for-3] fakeform)  to finish the move"><span class="u" id="1509459470.000668">2017:10:31 14:17:50           nathanmarz </span><span>and </span><code>(setval [(point-to 7] zip/INNER-RIGHT] [value-for-3] fakeform)</code><span> to finish the move</span></div><div data-t="nathanmarz actually you could combine the retrieval of 3&apos;s value with removal using  replace-in"><span class="u" id="1509459492.000722">2017:10:31 14:18:12           nathanmarz </span><span>actually you could combine the retrieval of 3&apos;s value with removal using </span><code>replace-in</code></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers"><span class="u" id="1509459527.000498">2017:10:31 14:18:47           nathanmarz </span><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers">https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers</a></div><div data-t="eoliphant Ok will give that a shot, so  point-to  will be my recursive-path based helper?"><span class="u" id="1509459532.000270">2017:10:31 14:18:52            eoliphant </span><span>Ok will give that a shot, so </span><code>point-to</code><span> will be my recursive-path based helper?</span></div><div data-t="nathanmarz yes"><span class="u" id="1509459568.000787">2017:10:31 14:19:28           nathanmarz </span><span>yes</span></div><div data-t="eoliphant gotcha, will play around with it"><span class="u" id="1509459579.000420">2017:10:31 14:19:39            eoliphant </span><span>gotcha, will play around with it</span></div><div data-t="eoliphant thanks!"><span class="u" id="1509459592.000196">2017:10:31 14:19:52            eoliphant </span><span>thanks!</span></div><div data-t="borkdude Hmm, why does this print tuples instead of single values?
 (setval
   [ALL
    #_(multi-path :target/source )
    :target/neighbours ALL first (fn [v]
                                   (println “is this the first?” v)
                                   v)
    (pred #{“medline”})]
   NONE
   [{:target/source “not” :target/neighbours [[“medline” 1] [“not 2”]]}
    {:target/source “medline” :target/neighbours [[“medline” 1] [“not 2&quot;]]}
    {:target/source “medline” :target/neighbours [[“medline” 1] [“not 2”]]}
    ])
"><span class="u" id="1509634906.000536">2017:11:02 15:01:46             borkdude </span><span>Hmm, why does this print tuples instead of single values?
</span><pre>(setval
   [ALL
    #_(multi-path :target/source )
    :target/neighbours ALL first (fn [v]
                                   (println “is this the first?” v)
                                   v)
    (pred #{“medline”})]
   NONE
   [{:target/source “not” :target/neighbours [[“medline” 1] [“not 2”]]}
    {:target/source “medline” :target/neighbours [[“medline” 1] [“not 2&quot;]]}
    {:target/source “medline” :target/neighbours [[“medline” 1] [“not 2”]]}
    ])
</pre></div><div data-t="borkdude ALL  (every map value),  :target/neighbours  (vector of tuples),  ALL  (every tuple),  first  … oh I see"><span class="u" id="1509634992.000607">2017:11:02 15:03:12             borkdude </span><code>ALL</code><span> (every map value), </span><code>:target/neighbours</code><span> (vector of tuples), </span><code>ALL</code><span> (every tuple), </span><code>first</code><span> … oh I see</span></div><div data-t="borkdude first  is acting as a predicate?"><span class="u" id="1509635012.000095">2017:11:02 15:03:32             borkdude </span><code>first</code><span> is acting as a predicate?</span></div><div data-t="borkdude ah,  FIRST , doh…"><span class="u" id="1509635226.000176">2017:11:02 15:07:06             borkdude </span><span>ah, </span><code>FIRST</code><span>, doh…</span></div><div data-t="borkdude I have trouble writing this in specter:
 ;; only x and y are allowed
  [{:name &quot;x&quot; :rels [&quot;x&quot; &quot;y&quot;]} ;=&gt; fine, keep as is
   {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot; &quot;z&quot;]} ;=&gt; keep only allowed rels: {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot;]}
   {:name &quot;y&quot; :rels [&quot;z&quot;]} ;=&gt; no allowed rels, remove map completely
   {:name &quot;z&quot; :rels [&quot;x&quot; &quot;y&quot;]}] ;=&gt; disallowed name, remove completely
  ;;=&gt;
  [{:name &quot;x&quot; :rels [&quot;x&quot; &quot;y&quot;]}
   {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot;]}]
   
as a single  setval  using  multi-path  and  not-selected? . I know it must be possible…"><span class="u" id="1509637128.000449">2017:11:02 15:38:48             borkdude </span><span>I have trouble writing this in specter:
</span><pre>;; only x and y are allowed
  [{:name &quot;x&quot; :rels [&quot;x&quot; &quot;y&quot;]} ;=&gt; fine, keep as is
   {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot; &quot;z&quot;]} ;=&gt; keep only allowed rels: {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot;]}
   {:name &quot;y&quot; :rels [&quot;z&quot;]} ;=&gt; no allowed rels, remove map completely
   {:name &quot;z&quot; :rels [&quot;x&quot; &quot;y&quot;]}] ;=&gt; disallowed name, remove completely
  ;;=&gt;
  [{:name &quot;x&quot; :rels [&quot;x&quot; &quot;y&quot;]}
   {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot;]}]
  </pre><span>
as a single </span><code>setval</code><span> using </span><code>multi-path</code><span> and </span><code>not-selected?</code><span>. I know it must be possible…</span></div><div data-t="nathanmarz @borkdude 
 (setval [ALL
         (transformed [:rels ALL (pred (complement #{&quot;x&quot; &quot;y&quot;}))] (fn [_] NONE))
         (selected?
          (multi-path
            (not-selected? :name #{&quot;x&quot; &quot;y&quot;})
            (not-selected? :rels ALL #{&quot;x&quot; &quot;y&quot;})))
         ]
  NONE
  data)
"><span class="u" id="1509637583.000039">2017:11:02 15:46:23           nathanmarz </span><span>@borkdude 
</span><pre>(setval [ALL
         (transformed [:rels ALL (pred (complement #{&quot;x&quot; &quot;y&quot;}))] (fn [_] NONE))
         (selected?
          (multi-path
            (not-selected? :name #{&quot;x&quot; &quot;y&quot;})
            (not-selected? :rels ALL #{&quot;x&quot; &quot;y&quot;})))
         ]
  NONE
  data)
</pre></div><div data-t="nathanmarz you can also do
 (setval [ALL
         (transformed [:rels ALL (pred (complement #{&quot;x&quot; &quot;y&quot;}))] (fn [_] NONE))
         (selected?
          (multi-path
            (not-selected? :name #{&quot;x&quot; &quot;y&quot;})
            [:rels empty?]))
         ]
  NONE
  data)
"><span class="u" id="1509637679.000385">2017:11:02 15:47:59           nathanmarz </span><span>you can also do
</span><pre>(setval [ALL
         (transformed [:rels ALL (pred (complement #{&quot;x&quot; &quot;y&quot;}))] (fn [_] NONE))
         (selected?
          (multi-path
            (not-selected? :name #{&quot;x&quot; &quot;y&quot;})
            [:rels empty?]))
         ]
  NONE
  data)
</pre></div><div data-t="borkdude cool, cool, thanks!"><span class="u" id="1509637963.000430">2017:11:02 15:52:43             borkdude </span><span>cool, cool, thanks!</span></div><div data-t="nathanmarz @borkdude looking at it again you don&apos;t need the  transformed :
 (setval [ALL
         (multi-path
          [:rels ALL (pred (complement #{&quot;x&quot; &quot;y&quot;}))]
          (selected?
           (multi-path
             (not-selected? :name #{&quot;x&quot; &quot;y&quot;})
             [:rels empty?])))]
  NONE
  data)
"><span class="u" id="1509638300.000126">2017:11:02 15:58:20           nathanmarz </span><span>@borkdude looking at it again you don&apos;t need the </span><code>transformed</code><span>:
</span><pre>(setval [ALL
         (multi-path
          [:rels ALL (pred (complement #{&quot;x&quot; &quot;y&quot;}))]
          (selected?
           (multi-path
             (not-selected? :name #{&quot;x&quot; &quot;y&quot;})
             [:rels empty?])))]
  NONE
  data)
</pre></div><div data-t="borkdude ah, that one makes even more sense"><span class="u" id="1509638357.000814">2017:11:02 15:59:17             borkdude </span><span>ah, that one makes even more sense</span></div><div data-t="borkdude More readable too. Wasn’t familiar with  transformed  yet"><span class="u" id="1509638532.000320">2017:11:02 16:02:12             borkdude </span><span>More readable too. Wasn’t familiar with </span><code>transformed</code><span> yet</span></div><div data-t="borkdude Eh, wait, I didn’t know  complement  exists either, I always do  comp not f   🙂"><span class="u" id="1509638760.000069">2017:11:02 16:06:00             borkdude </span><span>Eh, wait, I didn’t know </span><code>complement</code><span> exists either, I always do </span><code>comp not f</code><span> </span><b>🙂</b></div><div data-t="nathanmarz transformed  has same semantics as  view , useful when doing multiple distinct transforms in one traversal"><span class="u" id="1509638791.000548">2017:11:02 16:06:31           nathanmarz </span><code>transformed</code><span> has same semantics as </span><code>view</code><span>, useful when doing multiple distinct transforms in one traversal</span></div><div data-t="nathanmarz or for manipulating the results of a  select  in one go"><span class="u" id="1509638842.000465">2017:11:02 16:07:22           nathanmarz </span><span>or for manipulating the results of a </span><code>select</code><span> in one go</span></div><div data-t="borkdude @nathanmarz Does this make sense? I mean the  pred  thing in the  let . I’m not really sure when to wrap a function in  pred .

 (defn keep-allowed-relations [user-profile relations]
  (let [disallowed? (pred #(not (allowed-source? user-profile %)))]
    (setval
     [ALL
      (multi-path
       [:target/neighbours ALL
        (selected? FIRST
                   disallowed?)]
       (selected?
        (multi-path
         [:target/neighbours empty?]
         (selected? :target/source disallowed?)
         )))]
     NONE
     relations)))
"><span class="u" id="1509642526.000316">2017:11:02 17:08:46             borkdude </span><span>@nathanmarz Does this make sense? I mean the </span><code>pred</code><span> thing in the </span><code>let</code><span>. I’m not really sure when to wrap a function in </span><code>pred</code><span>.

</span><pre>(defn keep-allowed-relations [user-profile relations]
  (let [disallowed? (pred #(not (allowed-source? user-profile %)))]
    (setval
     [ALL
      (multi-path
       [:target/neighbours ALL
        (selected? FIRST
                   disallowed?)]
       (selected?
        (multi-path
         [:target/neighbours empty?]
         (selected? :target/source disallowed?)
         )))]
     NONE
     relations)))
</pre></div><div data-t="borkdude but it works"><span class="u" id="1509642528.000474">2017:11:02 17:08:48             borkdude </span><span>but it works</span></div><div data-t="borkdude little simplification:
 (setval
     [ALL
      (multi-path
       [:target/neighbours ALL
        (selected? FIRST
                   disallowed?)]
       (selected?
        (multi-path
         [:target/neighbours empty?]
         [:target/source disallowed?]
         )))]
     NONE
     relations)))
"><span class="u" id="1509642734.000249">2017:11:02 17:12:14             borkdude </span><span>little simplification:
</span><pre>(setval
     [ALL
      (multi-path
       [:target/neighbours ALL
        (selected? FIRST
                   disallowed?)]
       (selected?
        (multi-path
         [:target/neighbours empty?]
         [:target/source disallowed?]
         )))]
     NONE
     relations)))
</pre></div><div data-t="borkdude This is what I meant with, it must be possible with only  selected?  and  multi-path   🙂"><span class="u" id="1509642873.000623">2017:11:02 17:14:33             borkdude </span><span>This is what I meant with, it must be possible with only </span><code>selected?</code><span> and </span><code>multi-path</code><span> </span><b>🙂</b></div><div data-t="borkdude (my data looks a little different, hence the variation with  FIRST )"><span class="u" id="1509643023.000133">2017:11:02 17:17:03             borkdude </span><span>(my data looks a little different, hence the variation with </span><code>FIRST</code><span>)</span></div><div data-t="nathanmarz @borkdude that&apos;s fine though it will be slightly more efficient to use  pred  in the path declaration rather than outside it"><span class="u" id="1509645203.000022">2017:11:02 17:53:23           nathanmarz </span><span>@borkdude that&apos;s fine though it will be slightly more efficient to use </span><code>pred</code><span> in the path declaration rather than outside it</span></div><div data-t="nathanmarz that way specter knows statically it&apos;s a compiled navigator and doesn&apos;t have to do an  instance?  check at runtime"><span class="u" id="1509645231.000459">2017:11:02 17:53:51           nathanmarz </span><span>that way specter knows statically it&apos;s a compiled navigator and doesn&apos;t have to do an </span><code>instance?</code><span> check at runtime</span></div><div data-t="nathanmarz but that&apos;s not a big deal"><span class="u" id="1509645236.000271">2017:11:02 17:53:56           nathanmarz </span><span>but that&apos;s not a big deal</span></div><div data-t="nathanmarz wrapping with  pred  in the  let  is much better than not, in which case specter would have to do a protocol invocation to convert function -&gt; navigator every time that callsite is invoked"><span class="u" id="1509645272.000381">2017:11:02 17:54:32           nathanmarz </span><span>wrapping with </span><code>pred</code><span> in the </span><code>let</code><span> is much better than not, in which case specter would have to do a protocol invocation to convert function -&gt; navigator every time that callsite is invoked</span></div><div data-t="borkdude So, this works:
 (def data ;; only x and y are allowed
  [{:name &quot;x&quot; :rels [&quot;x&quot; &quot;y&quot;]} ;=&gt; fine, keep as is
   {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot; &quot;z&quot;]} ;=&gt; keep only allowed rels: {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot;]}
   {:name &quot;y&quot; :rels [&quot;z&quot;]} ;=&gt; no allowed rels, remove map completely
   {:name &quot;z&quot; :rels [&quot;x&quot; &quot;y&quot;]}] ;=&gt; disallowed name, remove completely
  )

(def disallowed? (complement #{&quot;x&quot; &quot;y&quot;}))

(setval
 [ALL
  (multi-path
   [:rels ALL
    (pred disallowed?)]
   (selected?
    (multi-path
     [:rels empty?]
     [:name (pred disallowed?)])))]
 NONE
 data)
 
I was wondering if it’s possible to first express  [:name (pred disallowed?)] , since it might be cheaper to look at the name first. Then it doesn’t have to process the  :rels . E.g.
 (setval
 [ALL
  (multi-path
   (selected? :name disallowed?)
   [:rels ALL disallowed?]
   (selected? :rels empty?))]
 NONE
 data)
 
But this triggers a  ClassCastException  probably because  NONE  is treated as a map or something."><span class="u" id="1509722833.000043">2017:11:03 15:27:13             borkdude </span><span>So, this works:
</span><pre>(def data ;; only x and y are allowed
  [{:name &quot;x&quot; :rels [&quot;x&quot; &quot;y&quot;]} ;=&gt; fine, keep as is
   {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot; &quot;z&quot;]} ;=&gt; keep only allowed rels: {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot;]}
   {:name &quot;y&quot; :rels [&quot;z&quot;]} ;=&gt; no allowed rels, remove map completely
   {:name &quot;z&quot; :rels [&quot;x&quot; &quot;y&quot;]}] ;=&gt; disallowed name, remove completely
  )

(def disallowed? (complement #{&quot;x&quot; &quot;y&quot;}))

(setval
 [ALL
  (multi-path
   [:rels ALL
    (pred disallowed?)]
   (selected?
    (multi-path
     [:rels empty?]
     [:name (pred disallowed?)])))]
 NONE
 data)
</pre><span>
I was wondering if it’s possible to first express </span><code>[:name (pred disallowed?)]</code><span>, since it might be cheaper to look at the name first. Then it doesn’t have to process the </span><code>:rels</code><span>. E.g.
</span><pre>(setval
 [ALL
  (multi-path
   (selected? :name disallowed?)
   [:rels ALL disallowed?]
   (selected? :rels empty?))]
 NONE
 data)
</pre><span>
But this triggers a </span><code>ClassCastException</code><span> probably because </span><code>NONE</code><span> is treated as a map or something.</span></div><div data-t="borkdude When I replace  NONE  with  {}  it kind of works. Maybe Specter paths should be able to play nicely with  NONE ?"><span class="u" id="1509722984.000784">2017:11:03 15:29:44             borkdude </span><span>When I replace </span><code>NONE</code><span> with </span><code>{}</code><span> it kind of works. Maybe Specter paths should be able to play nicely with </span><code>NONE</code><span>?</span></div><div data-t="borkdude This works:
 (setval
 [ALL
  (multi-path
   (selected? :name disallowed?)
   [#(not= NONE %) :rels ALL disallowed?]
   (selected? #(not= NONE %) :rels empty?))]
 NONE
 data)
"><span class="u" id="1509723160.000138">2017:11:03 15:32:40             borkdude </span><span>This works:
</span><pre>(setval
 [ALL
  (multi-path
   (selected? :name disallowed?)
   [#(not= NONE %) :rels ALL disallowed?]
   (selected? #(not= NONE %) :rels empty?))]
 NONE
 data)
</pre></div><div data-t="borkdude (defn SOME? [x]
  (not= NONE x))

(setval
 [ALL
  (multi-path
   (selected? :name disallowed?)
   [(pred SOME?) :rels ALL disallowed?]
   (selected? (pred SOME?) :rels empty?))]
 NONE
 data)
"><span class="u" id="1509723237.000395">2017:11:03 15:33:57             borkdude </span><pre>(defn SOME? [x]
  (not= NONE x))

(setval
 [ALL
  (multi-path
   (selected? :name disallowed?)
   [(pred SOME?) :rels ALL disallowed?]
   (selected? (pred SOME?) :rels empty?))]
 NONE
 data)
</pre></div><div data-t="borkdude I quite like the last solution. It almost reads literally like my requirement:
- drop when the name is disallowed
- drop all  :rels  that are disallowed
- drop when no  :rels  are left"><span class="u" id="1509723357.000401">2017:11:03 15:35:57             borkdude </span><span>I quite like the last solution. It almost reads literally like my requirement:
- drop when the name is disallowed
- drop all </span><code>:rels</code><span> that are disallowed
- drop when no </span><code>:rels</code><span> are left</span></div><div data-t="nathanmarz when you remove an element from a sequence, then future navigation in the same path will start at  NONE"><span class="u" id="1509724184.000745">2017:11:03 15:49:44           nathanmarz </span><span>when you remove an element from a sequence, then future navigation in the same path will start at </span><code>NONE</code></div><div data-t="nathanmarz that&apos;s the correct behavior from Specter, and getting a ClassCastException is expected and desired"><span class="u" id="1509724216.000757">2017:11:03 15:50:16           nathanmarz </span><span>that&apos;s the correct behavior from Specter, and getting a ClassCastException is expected and desired</span></div><div data-t="nathanmarz that solution with  SOME?  is fine"><span class="u" id="1509724243.000286">2017:11:03 15:50:43           nathanmarz </span><span>that solution with </span><code>SOME?</code><span> is fine</span></div><div data-t="nathanmarz you don&apos;t need the  pred  around  SOME?"><span class="u" id="1509724252.000607">2017:11:03 15:50:52           nathanmarz </span><span>you don&apos;t need the </span><code>pred</code><span> around </span><code>SOME?</code></div><div data-t="nathanmarz but you should have it around  disallowed?"><span class="u" id="1509724258.000634">2017:11:03 15:50:58           nathanmarz </span><span>but you should have it around </span><code>disallowed?</code></div><div data-t="nathanmarz or define  disallowed?  as  (pred (complement ...))"><span class="u" id="1509724268.000614">2017:11:03 15:51:08           nathanmarz </span><span>or define </span><code>disallowed?</code><span> as </span><code>(pred (complement ...))</code></div><div data-t="borkdude I’m not sure why it’s desired? Navigating to  NONE  could semantically be treated as a dead end?"><span class="u" id="1509724291.000026">2017:11:03 15:51:31             borkdude </span><span>I’m not sure why it’s desired? Navigating to </span><code>NONE</code><span> could semantically be treated as a dead end?</span></div><div data-t="nathanmarz actually nvm, you don&apos;t need it around  disallowed?  since it&apos;s defined globally"><span class="u" id="1509724308.000188">2017:11:03 15:51:48           nathanmarz </span><span>actually nvm, you don&apos;t need it around </span><code>disallowed?</code><span> since it&apos;s defined globally</span></div><div data-t="nathanmarz the element in the sequence was removed, so it&apos;s navigated to the &quot;void&quot;, represented consistently in Specter as  NONE"><span class="u" id="1509724355.000398">2017:11:03 15:52:35           nathanmarz </span><span>the element in the sequence was removed, so it&apos;s navigated to the &quot;void&quot;, represented consistently in Specter as </span><code>NONE</code></div><div data-t="borkdude well, in my ‘real’ code, disallowed is not able to be defined globally, but that’s why I wrapped it in a  pred  in the let. Now I don’t understand why I don’t need the  pred  around  SOME? , because it’s a global?"><span class="u" id="1509724364.000573">2017:11:03 15:52:44             borkdude </span><span>well, in my ‘real’ code, disallowed is not able to be defined globally, but that’s why I wrapped it in a </span><code>pred</code><span> in the let. Now I don’t understand why I don’t need the </span><code>pred</code><span> around </span><code>SOME?</code><span>, because it’s a global?</span></div><div data-t="nathanmarz multi-path  always executes every subpath in order"><span class="u" id="1509724381.000484">2017:11:03 15:53:01           nathanmarz </span><code>multi-path</code><span> always executes every subpath in order</span></div><div data-t="nathanmarz SOME?  is statically known to be a function"><span class="u" id="1509724389.000358">2017:11:03 15:53:09           nathanmarz </span><code>SOME?</code><span> is statically known to be a function</span></div><div data-t="nathanmarz so specter can figure that out at &quot;compile-time&quot;"><span class="u" id="1509724400.000034">2017:11:03 15:53:20           nathanmarz </span><span>so specter can figure that out at &quot;compile-time&quot;</span></div><div data-t="borkdude ok, so Specter intentionally allows navigating to NONE, so the user can do something with this?"><span class="u" id="1509724403.000193">2017:11:03 15:53:23             borkdude </span><span>ok, so Specter intentionally allows navigating to NONE, so the user can do something with this?</span></div><div data-t="nathanmarz AFTER-ELEM  and  BEFORE-ELEM  navigate to  NONE"><span class="u" id="1509724423.000474">2017:11:03 15:53:43           nathanmarz </span><code>AFTER-ELEM</code><span> and </span><code>BEFORE-ELEM</code><span> navigate to </span><code>NONE</code></div><div data-t="borkdude cool! so maybe Specter could use a primitive like  SOME?"><span class="u" id="1509724449.000322">2017:11:03 15:54:09             borkdude </span><span>cool! so maybe Specter could use a primitive like </span><code>SOME?</code></div><div data-t="borkdude I’m fine with my own for now"><span class="u" id="1509724467.000036">2017:11:03 15:54:27             borkdude </span><span>I’m fine with my own for now</span></div><div data-t="nathanmarz needing that function is very esoteric"><span class="u" id="1509724497.000306">2017:11:03 15:54:57           nathanmarz </span><span>needing that function is very esoteric</span></div><div data-t="nathanmarz btw a better way to implement it is  (defn SOME? [v] (not (identical? NONE v)))"><span class="u" id="1509724525.000714">2017:11:03 15:55:25           nathanmarz </span><span>btw a better way to implement it is </span><code>(defn SOME? [v] (not (identical? NONE v)))</code></div><div data-t="borkdude because eventually  =  will dispatch to that anyway"><span class="u" id="1509724570.000203">2017:11:03 15:56:10             borkdude </span><span>because eventually </span><code>=</code><span> will dispatch to that anyway</span></div><div data-t="nathanmarz yea, avoids some overhead"><span class="u" id="1509724642.000252">2017:11:03 15:57:22           nathanmarz </span><span>yea, avoids some overhead</span></div><div data-t="borkdude cool, I learned something  🙂"><span class="u" id="1509724742.000503">2017:11:03 15:59:02             borkdude </span><span>cool, I learned something </span><b>🙂</b></div><div data-t="borkdude Hack which makes  SOME?  obsolete:
 (alter-var-root #&apos;com.rpl.specter.impl/NONE (fn [_] {}))

(setval
 [ALL
  (multi-path
   (selected? :name disallowed?)
   [:rels ALL disallowed?]
   (selected? :rels empty?))]
 NONE
 data)
"><span class="u" id="1509725350.000012">2017:11:03 16:09:10             borkdude </span><span>Hack which makes </span><code>SOME?</code><span> obsolete:
</span><pre>(alter-var-root #&apos;com.rpl.specter.impl/NONE (fn [_] {}))

(setval
 [ALL
  (multi-path
   (selected? :name disallowed?)
   [:rels ALL disallowed?]
   (selected? :rels empty?))]
 NONE
 data)
</pre></div><div data-t="borkdude AFTER-ELEM  and  BEFORE-ELEM  still work"><span class="u" id="1509725472.000459">2017:11:03 16:11:12             borkdude </span><code>AFTER-ELEM</code><span> and </span><code>BEFORE-ELEM</code><span> still work</span></div><div data-t="borkdude hmm, but this is going to break other stuff probably, because it seems that Clojure uses a singleton object for representing the empty hash-map"><span class="u" id="1509725611.000378">2017:11:03 16:13:31             borkdude </span><span>hmm, but this is going to break other stuff probably, because it seems that Clojure uses a singleton object for representing the empty hash-map</span></div><div data-t="borkdude (identical? (hash-map) (hash-map)) ;;=&gt; true"><span class="u" id="1509725643.000148">2017:11:03 16:14:03             borkdude </span><code>(identical? (hash-map) (hash-map)) ;;=&gt; true</code></div><div data-t="nathanmarz yea lol"><span class="u" id="1509725666.000474">2017:11:03 16:14:26           nathanmarz </span><span>yea lol</span></div><div data-t="nathanmarz becomes very hard to set values to empty maps"><span class="u" id="1509725727.000012">2017:11:03 16:15:27           nathanmarz </span><span>becomes very hard to set values to empty maps</span></div><div data-t="borkdude This could work though:
 (def my-NONE {::NONE true})
(alter-var-root #&apos;com.rpl.specter.impl/NONE (fn [_] my-NONE))

(defn SOME? [x]
  (not (identical? NONE x)))

;; no SOME? needed

(setval
 [ALL
  (multi-path
   (selected? :name disallowed?)
   [:rels ALL disallowed?]
   (selected? :rels empty?))]
 NONE
 data)

(setval AFTER-ELEM 3 [1 2])
(setval BEFORE-ELEM 3 [1 2])
 
since  (identical? {::NONE true} {::NONE true}) ;;=&gt; false"><span class="u" id="1509725892.000354">2017:11:03 16:18:12             borkdude </span><span>This could work though:
</span><pre>(def my-NONE {::NONE true})
(alter-var-root #&apos;com.rpl.specter.impl/NONE (fn [_] my-NONE))

(defn SOME? [x]
  (not (identical? NONE x)))

;; no SOME? needed

(setval
 [ALL
  (multi-path
   (selected? :name disallowed?)
   [:rels ALL disallowed?]
   (selected? :rels empty?))]
 NONE
 data)

(setval AFTER-ELEM 3 [1 2])
(setval BEFORE-ELEM 3 [1 2])
</pre><span>
since </span><code>(identical? {::NONE true} {::NONE true}) ;;=&gt; false</code></div><div data-t="borkdude Don’t know if there is anything against changing this implementation detail?"><span class="u" id="1509726364.000575">2017:11:03 16:26:04             borkdude </span><span>Don’t know if there is anything against changing this implementation detail?</span></div><div data-t="borkdude Could make life with NONE somewhat easier"><span class="u" id="1509726372.000235">2017:11:03 16:26:12             borkdude </span><span>Could make life with NONE somewhat easier</span></div><div data-t="nathanmarz no, it&apos;s better to error when trying to navigate on  NONE"><span class="u" id="1509727476.000182">2017:11:03 16:44:36           nathanmarz </span><span>no, it&apos;s better to error when trying to navigate on </span><code>NONE</code></div><div data-t="nathanmarz this code makes  NONE  magically &quot;work&quot; for map navigators"><span class="u" id="1509727580.000749">2017:11:03 16:46:20           nathanmarz </span><span>this code makes </span><code>NONE</code><span> magically &quot;work&quot; for map navigators</span></div><div data-t="nathanmarz but it will still fail for all the other navigators"><span class="u" id="1509727591.000272">2017:11:03 16:46:31           nathanmarz </span><span>but it will still fail for all the other navigators</span></div><div data-t="nathanmarz better to handle it explicitly in code like this"><span class="u" id="1509727670.000254">2017:11:03 16:47:50           nathanmarz </span><span>better to handle it explicitly in code like this</span></div><div data-t="borkdude ok"><span class="u" id="1509727687.000391">2017:11:03 16:48:07             borkdude </span><span>ok</span></div><div data-t="borkdude Looking at the vanilla Clojure (which I didn’t write prior to writing Specter), it’s comparable length wise:
 https://gist.github.com/borkdude/5f9a4ae710217e893a9462ff90b6cac3#file-specter-clj-L20"><span class="u" id="1509727729.000406">2017:11:03 16:48:49             borkdude </span><span>Looking at the vanilla Clojure (which I didn’t write prior to writing Specter), it’s comparable length wise:
</span><a href="https://gist.github.com/borkdude/5f9a4ae710217e893a9462ff90b6cac3#file-specter-clj-L20">https://gist.github.com/borkdude/5f9a4ae710217e893a9462ff90b6cac3#file-specter-clj-L20</a></div><div data-t="nathanmarz it changes all the vectors to seqs"><span class="u" id="1509727838.000413">2017:11:03 16:50:38           nathanmarz </span><span>it changes all the vectors to seqs</span></div><div data-t="borkdude true. in this case I didn’t need the vectors much longer as it went out as JSON anyway"><span class="u" id="1509727856.000277">2017:11:03 16:50:56             borkdude </span><span>true. in this case I didn’t need the vectors much longer as it went out as JSON anyway</span></div><div data-t="nathanmarz length isn&apos;t always the best metric of code quality"><span class="u" id="1509727950.000446">2017:11:03 16:52:30           nathanmarz </span><span>length isn&apos;t always the best metric of code quality</span></div><div data-t="nathanmarz besides maintaining types, I find the Specter version far more readable"><span class="u" id="1509727976.000759">2017:11:03 16:52:56           nathanmarz </span><span>besides maintaining types, I find the Specter version far more readable</span></div><div data-t="nathanmarz pretty much read left to right instead of having lots of nested expressions"><span class="u" id="1509727994.000032">2017:11:03 16:53:14           nathanmarz </span><span>pretty much read left to right instead of having lots of nested expressions</span></div><div data-t="borkdude Running a poll…  🙂   https://twitter.com/borkdude/status/926493766441226240"><span class="u" id="1509728596.000126">2017:11:03 17:03:16             borkdude </span><span>Running a poll… </span><b>🙂</b><span> </span><a href="https://twitter.com/borkdude/status/926493766441226240">https://twitter.com/borkdude/status/926493766441226240</a></div><div data-t="borkdude The Clojure version appears to be twice as fast (running 100k times with time,  keep  wrapped in  doall , I know, not a robust profiling tool, but still?)"><span class="u" id="1509729531.000481">2017:11:03 17:18:51             borkdude </span><span>The Clojure version appears to be twice as fast (running 100k times with time, </span><code>keep</code><span> wrapped in </span><code>doall</code><span>, I know, not a robust profiling tool, but still?)</span></div><div data-t="borkdude Around 200ms for Clojure and 400ms for Specter"><span class="u" id="1509729640.000156">2017:11:03 17:20:40             borkdude </span><span>Around 200ms for Clojure and 400ms for Specter</span></div><div data-t="nathanmarz there&apos;s probably a bunch of micro-optimizations that can be done"><span class="u" id="1509729770.000646">2017:11:03 17:22:50           nathanmarz </span><span>there&apos;s probably a bunch of micro-optimizations that can be done</span></div><div data-t="nathanmarz empty?  is slow on vectors"><span class="u" id="1509729850.000311">2017:11:03 17:24:10           nathanmarz </span><code>empty?</code><span> is slow on vectors</span></div><div data-t="borkdude Could try  seq"><span class="u" id="1509729880.000225">2017:11:03 17:24:40             borkdude </span><span>Could try </span><code>seq</code></div><div data-t="nathanmarz #(= 0 (.length ^IPersistentVector v)) is fastest way I&apos;ve found"><span class="u" id="1509729881.000022">2017:11:03 17:24:41           nathanmarz </span><span>#(= 0 (.length ^IPersistentVector v)) is fastest way I&apos;ve found</span></div><div data-t="borkdude oh no wait, that’s the opposite  😛"><span class="u" id="1509729895.000147">2017:11:03 17:24:55             borkdude </span><span>oh no wait, that’s the opposite </span><b>😛</b></div><div data-t="borkdude ok"><span class="u" id="1509729902.000434">2017:11:03 17:25:02             borkdude </span><span>ok</span></div><div data-t="nathanmarz can also change to:
 (setval
 [ALL
  (if-path (selected? :name disallowed?)
   STAY
   (multi-path
    [:rels ALL disallowed?]
    (selected? :rels empty?)))]
 NONE
 data)
"><span class="u" id="1509729942.000417">2017:11:03 17:25:42           nathanmarz </span><span>can also change to:
</span><pre>(setval
 [ALL
  (if-path (selected? :name disallowed?)
   STAY
   (multi-path
    [:rels ALL disallowed?]
    (selected? :rels empty?)))]
 NONE
 data)
</pre></div><div data-t="nathanmarz so it stops doing work after removing on first condition"><span class="u" id="1509729953.000038">2017:11:03 17:25:53           nathanmarz </span><span>so it stops doing work after removing on first condition</span></div><div data-t="borkdude ah"><span class="u" id="1509729979.000620">2017:11:03 17:26:19             borkdude </span><span>ah</span></div><div data-t="nathanmarz #(-&gt; % :name disallowed?)  might be faster"><span class="u" id="1509730003.000701">2017:11:03 17:26:43           nathanmarz </span><code>#(-&gt; % :name disallowed?)</code><span> might be faster</span></div><div data-t="nathanmarz same with  #(-&gt; % :rels empty?)"><span class="u" id="1509730084.000022">2017:11:03 17:28:04           nathanmarz </span><span>same with </span><code>#(-&gt; % :rels empty?)</code></div><div data-t="borkdude (def my-empty? (fn [v] (= 0 (.length ^clojure.lang.IPersistentVector v))))

(time
 (dotimes [i 100000]
   (setval
    [ALL
     (if-path #(-&gt; % :name disallowed?)
              STAY
              (multi-path
               [:rels ALL disallowed?]
               #(-&gt; % :rels my-empty?)))]
    NONE
    data)))
 
Shaves off roughly 80ms"><span class="u" id="1509730186.000205">2017:11:03 17:29:46             borkdude </span><pre>(def my-empty? (fn [v] (= 0 (.length ^clojure.lang.IPersistentVector v))))

(time
 (dotimes [i 100000]
   (setval
    [ALL
     (if-path #(-&gt; % :name disallowed?)
              STAY
              (multi-path
               [:rels ALL disallowed?]
               #(-&gt; % :rels my-empty?)))]
    NONE
    data)))
</pre><span>
Shaves off roughly 80ms</span></div><div data-t="nathanmarz since specter version maintains types and clojure version constructs a different type, it&apos;s hard to say how much of difference comes from that"><span class="u" id="1509730364.000210">2017:11:03 17:32:44           nathanmarz </span><span>since specter version maintains types and clojure version constructs a different type, it&apos;s hard to say how much of difference comes from that</span></div><div data-t="nathanmarz @borkdude the inner call to  remove  is also not realizing the full computation"><span class="u" id="1509732932.000095">2017:11:03 18:15:32           nathanmarz </span><span>@borkdude the inner call to </span><code>remove</code><span> is also not realizing the full computation</span></div><div data-t="nathanmarz should wrap that in  doall  to make comparison fair"><span class="u" id="1509732956.000333">2017:11:03 18:15:56           nathanmarz </span><span>should wrap that in </span><code>doall</code><span> to make comparison fair</span></div><div data-t="borkdude @nathanmarz yes, did that, yields about 20ms extra"><span class="u" id="1509734307.000397">2017:11:03 18:38:27             borkdude </span><span>@nathanmarz yes, did that, yields about 20ms extra</span></div><div data-t="tanzoniteblack (defn vanilla []
  (doall (keep
          (fn [m]
            (if-not (disallowed? (:name m))
              (if-let [new-rels (doall (seq (remove disallowed? (:rels m))))]
                (assoc m :rels new-rels))))
          data)))  making this non-lazy (and measured with criterium)  Evaluation count : 558918 in 6 samples of 93153 calls.
             Execution time mean : 1.115634 µs
    Execution time std-deviation : 37.921802 ns
   Execution time lower quantile : 1.082254 µs ( 2.5%)
   Execution time upper quantile : 1.172033 µs (97.5%)
                   Overhead used : 1.603741 ns
 

This specter version:  (defn specter-v2 []
  (setval [ALL
           (if-path #(-&gt; % :name disallowed?)
                    STAY
                    (multi-path [:rels ALL disallowed?]
                                #(-&gt; % :rels empty?)))]
          NONE
          data))  also measured with criterium:  Evaluation count : 344118 in 6 samples of 57353 calls.
             Execution time mean : 1.732753 µs
    Execution time std-deviation : 12.525124 ns
   Execution time lower quantile : 1.716643 µs ( 2.5%)
   Execution time upper quantile : 1.744641 µs (97.5%)
                   Overhead used : 1.603741 ns
"><span class="u" id="1509735039.000307">2017:11:03 18:50:39       tanzoniteblack </span><pre>(defn vanilla []
  (doall (keep
          (fn [m]
            (if-not (disallowed? (:name m))
              (if-let [new-rels (doall (seq (remove disallowed? (:rels m))))]
                (assoc m :rels new-rels))))
          data)))</pre><span> making this non-lazy (and measured with criterium) </span><pre>Evaluation count : 558918 in 6 samples of 93153 calls.
             Execution time mean : 1.115634 µs
    Execution time std-deviation : 37.921802 ns
   Execution time lower quantile : 1.082254 µs ( 2.5%)
   Execution time upper quantile : 1.172033 µs (97.5%)
                   Overhead used : 1.603741 ns
</pre><span>

This specter version: </span><pre>(defn specter-v2 []
  (setval [ALL
           (if-path #(-&gt; % :name disallowed?)
                    STAY
                    (multi-path [:rels ALL disallowed?]
                                #(-&gt; % :rels empty?)))]
          NONE
          data))</pre><span> also measured with criterium: </span><pre>Evaluation count : 344118 in 6 samples of 57353 calls.
             Execution time mean : 1.732753 µs
    Execution time std-deviation : 12.525124 ns
   Execution time lower quantile : 1.716643 µs ( 2.5%)
   Execution time upper quantile : 1.744641 µs (97.5%)
                   Overhead used : 1.603741 ns
</pre></div><div data-t="tanzoniteblack so yeah...still faster with the hand-written clojure, but no where near as much as it was when factoring in the fact that one was lazy and the other not before"><span class="u" id="1509735081.000413">2017:11:03 18:51:21       tanzoniteblack </span><span>so yeah...still faster with the hand-written clojure, but no where near as much as it was when factoring in the fact that one was lazy and the other not before</span></div><div data-t="tanzoniteblack so...meh. Unless performance is absolutely critical to you, then it&apos;s just a style preference here? And if performance is absolutely critical...then always measure very carefully whatever you&apos;re doing"><span class="u" id="1509735131.000487">2017:11:03 18:52:11       tanzoniteblack </span><span>so...meh. Unless performance is absolutely critical to you, then it&apos;s just a style preference here? And if performance is absolutely critical...then always measure very carefully whatever you&apos;re doing</span></div><div data-t="borkdude @tanzoniteblack That criterium benchmark doesn’t draw a very different picture than what I already had"><span class="u" id="1509745999.000042">2017:11:03 21:53:19             borkdude </span><span>@tanzoniteblack That criterium benchmark doesn’t draw a very different picture than what I already had</span></div><div data-t="borkdude I had roughly 350ms for specter, 220 for clojure (x 1.5), criterium: x 1.55"><span class="u" id="1509746065.000338">2017:11:03 21:54:25             borkdude </span><span>I had roughly 350ms for specter, 220 for clojure (x 1.5), criterium: x 1.55</span></div><div data-t="borkdude but thanks for measuring"><span class="u" id="1509746081.000368">2017:11:03 21:54:41             borkdude </span><span>but thanks for measuring</span></div><div data-t="tanzoniteblack 🙂  wasn&apos;t saying my numbers were different then yours, I just couldn&apos;t find hard numbers for your final versions to directly compare, so decided to play with it myself"><span class="u" id="1509746096.000067">2017:11:03 21:54:56       tanzoniteblack </span><b>🙂</b><span> wasn&apos;t saying my numbers were different then yours, I just couldn&apos;t find hard numbers for your final versions to directly compare, so decided to play with it myself</span></div><div data-t="borkdude cool"><span class="u" id="1509746115.000349">2017:11:03 21:55:15             borkdude </span><span>cool</span></div><div data-t="tanzoniteblack also, I didn&apos;t see much of a difference between your custom empty and directly using  empty?  when measured with criterium. Don&apos;t remember the exact numbers, but only like 50-100 nanoseconds difference with the different empties swapped? Something within the realm of measuring error with the final result being in microseconds, anyways"><span class="u" id="1509746157.000332">2017:11:03 21:55:57       tanzoniteblack </span><span>also, I didn&apos;t see much of a difference between your custom empty and directly using </span><code>empty?</code><span> when measured with criterium. Don&apos;t remember the exact numbers, but only like 50-100 nanoseconds difference with the different empties swapped? Something within the realm of measuring error with the final result being in microseconds, anyways</span></div><div data-t="tanzoniteblack (just as an FYI)"><span class="u" id="1509746164.000276">2017:11:03 21:56:04       tanzoniteblack </span><span>(just as an FYI)</span></div><div data-t="borkdude Oh look, Alex wrote a transducers version too:  https://gist.github.com/borkdude/5f9a4ae710217e893a9462ff90b6cac3#gistcomment-2247156"><span class="u" id="1509746393.000333">2017:11:03 21:59:53             borkdude </span><span>Oh look, Alex wrote a transducers version too: </span><a href="https://gist.github.com/borkdude/5f9a4ae710217e893a9462ff90b6cac3#gistcomment-2247156">https://gist.github.com/borkdude/5f9a4ae710217e893a9462ff90b6cac3#gistcomment-2247156</a></div><div data-t="borkdude which is also slower than the non-transducer version"><span class="u" id="1509746419.000128">2017:11:03 22:00:19             borkdude </span><span>which is also slower than the non-transducer version</span></div><div data-t="michaelwfogleman Not sure if this has been mentioned before, but this library for string manipulation could be powerful to combine with Specter usage!  https://github.com/funcool/cuerdas"><span class="u" id="1510323314.000310">2017:11:10 14:15:14     michaelwfogleman </span><span>Not sure if this has been mentioned before, but this library for string manipulation could be powerful to combine with Specter usage! </span><a href="https://github.com/funcool/cuerdas">https://github.com/funcool/cuerdas</a></div><div data-t="gdeer81 Oh great, now every library is going to be the missing  X library."><span class="u" id="1510337027.000129">2017:11:10 18:03:47              gdeer81 </span><span>Oh great, now every library is going to be the missing  X library.</span></div><div data-t="gdeer81 I&apos;m going to update Marginalia&apos;s tag line to say &quot;The missing clojure literate programming documentation library&quot;"><span class="u" id="1510337079.000501">2017:11:10 18:04:39              gdeer81 </span><span>I&apos;m going to update Marginalia&apos;s tag line to say &quot;The missing clojure literate programming documentation library&quot;</span></div><div data-t="gdeer81 but it does look like an interesting library. and if you had some heavily nested text, it would be a powerful combo with Specter"><span class="u" id="1510337758.000057">2017:11:10 18:15:58              gdeer81 </span><span>but it does look like an interesting library. and if you had some heavily nested text, it would be a powerful combo with Specter</span></div><div data-t="borkdude Cuerdas looks great. It has one issue with DCE in Google Closure though"><span class="u" id="1510400447.000004">2017:11:11 11:40:47             borkdude </span><span>Cuerdas looks great. It has one issue with DCE in Google Closure though</span></div><div data-t="borkdude The issue is it adds 47kb / 19kb to your file size. Might be fine, but if you use only one or two functions…"><span class="u" id="1510400948.000066">2017:11:11 11:49:08             borkdude </span><span>The issue is it adds 47kb / 19kb to your file size. Might be fine, but if you use only one or two functions…</span></div><div data-t="hkjels Are sorted-maps not supported?"><span class="u" id="1510580990.000299">2017:11:13 13:49:50               hkjels </span><span>Are sorted-maps not supported?</span></div><div data-t="nathanmarz @hkjels they are... why do you ask?"><span class="u" id="1510583585.000066">2017:11:13 14:33:05           nathanmarz </span><span>@hkjels they are... why do you ask?</span></div><div data-t="hkjels My bad. Messed up a navigator"><span class="u" id="1510589280.000582">2017:11:13 16:08:00               hkjels </span><span>My bad. Messed up a navigator</span></div><div data-t="ul Hey folks, i&apos;m investigating options for organizing state in my client app. I want DB-like experience, but existing solutions are still not convincing, including DataScript. How do you think, is it viable to use just normalized maps and query/update them with Specter? Is it easy to emulate joins with Specter?"><span class="u" id="1510609024.000224">2017:11:13 21:37:04                   ul </span><span>Hey folks, i&apos;m investigating options for organizing state in my client app. I want DB-like experience, but existing solutions are still not convincing, including DataScript. How do you think, is it viable to use just normalized maps and query/update them with Specter? Is it easy to emulate joins with Specter?</span></div><div data-t="nathanmarz @ul joins are not in the scope of specter, but otherwise specter is very helpful for managing state"><span class="u" id="1510609417.000232">2017:11:13 21:43:37           nathanmarz </span><span>@ul joins are not in the scope of specter, but otherwise specter is very helpful for managing state</span></div><div data-t="nathanmarz since it&apos;s so elegant to handle data structures of arbitrary complexity, it gives you the freedom to model your data in the best possible way"><span class="u" id="1510609465.000218">2017:11:13 21:44:25           nathanmarz </span><span>since it&apos;s so elegant to handle data structures of arbitrary complexity, it gives you the freedom to model your data in the best possible way</span></div><div data-t="ul I see at least two pros on that way:
1. My data will be highly explorable outside main query mechanics (because it will stay just Clojure datastructures)
2. It will be friendly to reactive approach I use: Specter queries will fit perfectly into reactive formulas, and with proper data organization will trigger not much redundant recalculations."><span class="u" id="1510612816.000368">2017:11:13 22:40:16                   ul </span><span>I see at least two pros on that way:
1. My data will be highly explorable outside main query mechanics (because it will stay just Clojure datastructures)
2. It will be friendly to reactive approach I use: Specter queries will fit perfectly into reactive formulas, and with proper data organization will trigger not much redundant recalculations.</span></div><div data-t="nathanmarz Released Specter 1.0.5  https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><span class="u" id="1510860282.000380">2017:11:16 19:24:42           nathanmarz </span><span>Released Specter 1.0.5 </span><a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></div><div data-t="michaelwfogleman @nathanmarz Just curious, why did you decide against having numbers convert to index-nav?"><span class="u" id="1510881991.000106">2017:11:17 01:26:31     michaelwfogleman </span><span>@nathanmarz Just curious, why did you decide against having numbers convert to index-nav?</span></div><div data-t="nathanmarz so that  (select-any 0 {0 &quot;a&quot;})  would work"><span class="u" id="1510885414.000082">2017:11:17 02:23:34           nathanmarz </span><span>so that </span><code>(select-any 0 {0 &quot;a&quot;})</code><span> would work</span></div><div data-t="nathanmarz it matches semantics with clojure&apos;s  update-in  and  get-in , and it&apos;s less cases to remember for a user"><span class="u" id="1510885460.000253">2017:11:17 02:24:20           nathanmarz </span><span>it matches semantics with clojure&apos;s </span><code>update-in</code><span> and </span><code>get-in</code><span>, and it&apos;s less cases to remember for a user</span></div><div data-t="michaelwfogleman makes sense!  🙂"><span class="u" id="1510921353.000059">2017:11:17 12:22:33     michaelwfogleman </span><span>makes sense! </span><b>🙂</b></div><div data-t="nathanmarz @michaelwfogleman I&apos;m also considering this  https://github.com/nathanmarz/specter/issues/234"><span class="u" id="1510924993.000131">2017:11:17 13:23:13           nathanmarz </span><span>@michaelwfogleman I&apos;m also considering this </span><a href="https://github.com/nathanmarz/specter/issues/234">https://github.com/nathanmarz/specter/issues/234</a></div><div data-t="johanatan hi, i have a normalized map say:  version -&gt; entity_1 -&gt; entity_2  and I want to transform it into:  entity_1 -&gt; version -&gt; entity_2 . what is the best way to do this using specter?"><span class="u" id="1511302919.000138">2017:11:21 22:21:59            johanatan </span><span>hi, i have a normalized map say: </span><code>version -&gt; entity_1 -&gt; entity_2</code><span> and I want to transform it into: </span><code>entity_1 -&gt; version -&gt; entity_2</code><span>. what is the best way to do this using specter?</span></div><div data-t="johanatan [this is a map of maps of maps]"><span class="u" id="1511302934.000220">2017:11:21 22:22:14            johanatan </span><span>[this is a map of maps of maps]</span></div><div data-t="johanatan for example:

input:
 {1 {&quot;e1&quot; {&quot;p1&quot; nil &quot;p2&quot; 9} &quot;e2&quot; {&quot;p3&quot; nil &quot;p4&quot; 6}} 2 {&quot;e1&quot; {&quot;p6&quot; nil &quot;p7&quot; nil}}}
 

output:
 {&quot;e1&quot; {1 {&quot;p1&quot; nil &quot;p2&quot; 9} 2 {&quot;p6&quot; nil &quot;p7&quot; nil}} &quot;e2&quot; {1 {&quot;p3&quot; nil, &quot;p4&quot; 6}}}
"><span class="u" id="1511303665.000051">2017:11:21 22:34:25            johanatan </span><span>for example:

input:
</span><pre>{1 {&quot;e1&quot; {&quot;p1&quot; nil &quot;p2&quot; 9} &quot;e2&quot; {&quot;p3&quot; nil &quot;p4&quot; 6}} 2 {&quot;e1&quot; {&quot;p6&quot; nil &quot;p7&quot; nil}}}
</pre><span>

output:
</span><pre>{&quot;e1&quot; {1 {&quot;p1&quot; nil &quot;p2&quot; 9} 2 {&quot;p6&quot; nil &quot;p7&quot; nil}} &quot;e2&quot; {1 {&quot;p3&quot; nil, &quot;p4&quot; 6}}}
</pre></div><div data-t="nathanmarz @johanatan specter won&apos;t help that much with that since you&apos;re basically making a whole new data structure"><span class="u" id="1511303962.000213">2017:11:21 22:39:22           nathanmarz </span><span>@johanatan specter won&apos;t help that much with that since you&apos;re basically making a whole new data structure</span></div><div data-t="nathanmarz specter is for when you&apos;re changing part of a data structure, or changing many pieces the same way within the overall structure"><span class="u" id="1511303996.000083">2017:11:21 22:39:56           nathanmarz </span><span>specter is for when you&apos;re changing part of a data structure, or changing many pieces the same way within the overall structure</span></div><div data-t="johanatan well, i could do it with a transform/collect/map combo"><span class="u" id="1511304038.000269">2017:11:21 22:40:38            johanatan </span><span>well, i could do it with a transform/collect/map combo</span></div><div data-t="johanatan but that isn&apos;t much better than just doing it by hand in pure clj"><span class="u" id="1511304046.000082">2017:11:21 22:40:46            johanatan </span><span>but that isn&apos;t much better than just doing it by hand in pure clj</span></div><div data-t="johanatan but i fail to see how in principle the &quot;whole&quot; isn&apos;t just an all-encompassing &quot;part&quot;"><span class="u" id="1511304188.000318">2017:11:21 22:43:08            johanatan </span><span>but i fail to see how in principle the &quot;whole&quot; isn&apos;t just an all-encompassing &quot;part&quot;</span></div><div data-t="johanatan i.e., with any transformation-based language (say e.g. XSLT) changing the whole is just changing like changing a part where the part == the whole"><span class="u" id="1511304227.000119">2017:11:21 22:43:47            johanatan </span><span>i.e., with any transformation-based language (say e.g. XSLT) changing the whole is just changing like changing a part where the part == the whole</span></div><div data-t="johanatan in other words, it probably is possible with specter (and I would wager that the ultimate solution to it ends up being rather elegant once discovered) but the solution, like many (most?) in specter, is elusive and mind-bending to try to arrive at"><span class="u" id="1511304302.000253">2017:11:21 22:45:02            johanatan </span><span>in other words, it probably is possible with specter (and I would wager that the ultimate solution to it ends up being rather elegant once discovered) but the solution, like many (most?) in specter, is elusive and mind-bending to try to arrive at</span></div><div data-t="nathanmarz I don&apos;t think there&apos;s an elegant specter solution to this"><span class="u" id="1511304426.000080">2017:11:21 22:47:06           nathanmarz </span><span>I don&apos;t think there&apos;s an elegant specter solution to this</span></div><div data-t="nathanmarz this is a total restructuring"><span class="u" id="1511304445.000072">2017:11:21 22:47:25           nathanmarz </span><span>this is a total restructuring</span></div><div data-t="nathanmarz that it&apos;s still a map -&gt; map -&gt; map afterwards is deceiving"><span class="u" id="1511304466.000508">2017:11:21 22:47:46           nathanmarz </span><span>that it&apos;s still a map -&gt; map -&gt; map afterwards is deceiving</span></div><div data-t="johanatan you may be right.  🙂"><span class="u" id="1511304527.000198">2017:11:21 22:48:47            johanatan </span><span>you may be right. </span><b>🙂</b></div><div data-t="johanatan at least i know to not spend too much time searching for it lol"><span class="u" id="1511304543.000086">2017:11:21 22:49:03            johanatan </span><span>at least i know to not spend too much time searching for it lol</span></div><div data-t="nathanmarz it is an interesting use case"><span class="u" id="1511304627.000202">2017:11:21 22:50:27           nathanmarz </span><span>it is an interesting use case</span></div><div data-t="johanatan this works:
 (apply deep-merge (for [[version events] in] (specter/transform [specter/MAP-VALS] #(do {version %}) events)))
"><span class="u" id="1511305725.000286">2017:11:21 23:08:45            johanatan </span><span>this works:
</span><pre>(apply deep-merge (for [[version events] in] (specter/transform [specter/MAP-VALS] #(do {version %}) events)))
</pre></div><div data-t="johanatan where  deep-merge  is defined as:
 (defn deep-merge
  [&amp; vals]
  (if (every? map? vals)
    (apply merge-with deep-merge vals)
    (last vals)))
"><span class="u" id="1511305752.000196">2017:11:21 23:09:12            johanatan </span><span>where </span><code>deep-merge</code><span> is defined as:
</span><pre>(defn deep-merge
  [&amp; vals]
  (if (every? map? vals)
    (apply merge-with deep-merge vals)
    (last vals)))
</pre></div><div data-t="madstap Where specter isn&apos;t that well suited for this kind of transformation, there&apos;s this cool lib I remember seeing that should be perfect.   https://github.com/disalvjn/faconne"><span class="u" id="1511468798.000193">2017:11:23 20:26:38                   madstap </span><span>Where specter isn&apos;t that well suited for this kind of transformation, there&apos;s this cool lib I remember seeing that should be perfect.  </span><a href="https://github.com/disalvjn/faconne">https://github.com/disalvjn/faconne</a></div><div data-t="madstap The same thing in faconne
 (require &apos;[faconne.core :as fac])

(def f (fac/transformer {v {e1 {e2 x}}} {e1 {v {e2 x}}}))
"><span class="u" id="1511468848.000094">2017:11:23 20:27:28                   madstap </span><span>The same thing in faconne
</span><pre>(require &apos;[faconne.core :as fac])

(def f (fac/transformer {v {e1 {e2 x}}} {e1 {v {e2 x}}}))
</pre></div><div data-t="johanatan That&apos;s probably about as good/elegant as can be expected..."><span class="u" id="1511305792.000229">2017:11:21 23:09:52            johanatan </span><span>That&apos;s probably about as good/elegant as can be expected...</span></div><div data-t="benstox Hello, a very beginner question here. Say I have a data structure like this and I want to select all the foods that have 3 pieces of cheese in them:
 (def kitchen {:foods [{:type :sandwich :ingredients [{:type :bread :quantity 3}
                                                     {:type :cheese :quantity 2}
                                                     {:type :meatball :quantity 5}]}
                      {:type :sandwich :ingredients [{:type :bread :quantity 2}
                                                     {:type :cheese :quantity 3}
                                                     {:type :ham :quantity 2}]}
                      {:type :quiche :ingredients [{:type :egg :quantity 5}
                                                   {:type :cheese :quantity 5}]}]})
 
That is, I expect to return the ham sandwich and the quiche.
I understand how I could use Specter to navigate to all the quantities of cheese that are greater than 3:
 (select [:foods ALL :ingredients ALL #(= (:type %) :cheese) :quantity #(&gt;= % 3)] kitchen)
 
but what I really want to do is this:
 (defn three-cheese-food? [food]
  (-&gt;&gt; food
    (:ingredients)
    (some
      (fn [ingredient]
        (and
          (= (:type ingredient) :cheese)
          (&gt;= (:quantity ingredient) 3))))))

(filter three-cheese-food? (:foods kitchen))
 
Can I use Specter to do the work done in my filtering and  three-cheese-food?  function? Thanks!"><span class="u" id="1511627751.000081">2017:11:25 16:35:51              benstox </span><span>Hello, a very beginner question here. Say I have a data structure like this and I want to select all the foods that have 3 pieces of cheese in them:
</span><pre>(def kitchen {:foods [{:type :sandwich :ingredients [{:type :bread :quantity 3}
                                                     {:type :cheese :quantity 2}
                                                     {:type :meatball :quantity 5}]}
                      {:type :sandwich :ingredients [{:type :bread :quantity 2}
                                                     {:type :cheese :quantity 3}
                                                     {:type :ham :quantity 2}]}
                      {:type :quiche :ingredients [{:type :egg :quantity 5}
                                                   {:type :cheese :quantity 5}]}]})
</pre><span>
That is, I expect to return the ham sandwich and the quiche.
I understand how I could use Specter to navigate to all the quantities of cheese that are greater than 3:
</span><pre>(select [:foods ALL :ingredients ALL #(= (:type %) :cheese) :quantity #(&gt;= % 3)] kitchen)
</pre><span>
but what I really want to do is this:
</span><pre>(defn three-cheese-food? [food]
  (-&gt;&gt; food
    (:ingredients)
    (some
      (fn [ingredient]
        (and
          (= (:type ingredient) :cheese)
          (&gt;= (:quantity ingredient) 3))))))

(filter three-cheese-food? (:foods kitchen))
</pre><span>
Can I use Specter to do the work done in my filtering and </span><code>three-cheese-food?</code><span> function? Thanks!</span></div><div data-t="nathanmarz @benstox yes, use  selected?"><span class="u" id="1511630810.000021">2017:11:25 17:26:50           nathanmarz </span><span>@benstox yes, use </span><code>selected?</code></div><div data-t="nathanmarz (select [:foods
         ALL
         (selected? :ingredients ALL #(= :cheese (:type %)) :quantity (pred&gt;= 3))]
  kitchen)
"><span class="u" id="1511630814.000003">2017:11:25 17:26:54           nathanmarz </span><pre>(select [:foods
         ALL
         (selected? :ingredients ALL #(= :cheese (:type %)) :quantity (pred&gt;= 3))]
  kitchen)
</pre></div><div data-t="benstox Ah,  selected? ! That was the piece I was missing. Thanks!"><span class="u" id="1511631176.000077">2017:11:25 17:32:56              benstox </span><span>Ah, </span><code>selected?</code><span>! That was the piece I was missing. Thanks!</span></div><div data-t="benstox And the  pred&gt;=  too."><span class="u" id="1511631503.000093">2017:11:25 17:38:23              benstox </span><span>And the </span><code>pred&gt;=</code><span> too.</span></div><div data-t="benstox Is there a Specter-y way to add multiple conditions to the filtering? I thought of this:
 (select [:foods
         ALL
         (selected? :ingredients ALL #(= :cheese (:type %)) (multi-path [:quantity (pred&gt;= 3)]
                                                                        [:quality (pred&gt;= 10)]))])
 
But this seems to act like an OR when what I want is an AND."><span class="u" id="1511637450.000023">2017:11:25 19:17:30              benstox </span><span>Is there a Specter-y way to add multiple conditions to the filtering? I thought of this:
</span><pre>(select [:foods
         ALL
         (selected? :ingredients ALL #(= :cheese (:type %)) (multi-path [:quantity (pred&gt;= 3)]
                                                                        [:quality (pred&gt;= 10)]))])
</pre><span>
But this seems to act like an OR when what I want is an AND.</span></div><div data-t="swizzard i&apos;m having a tough time requiring specter in a lumo repl:"><span class="u" id="1511639842.000058">2017:11:25 19:57:22             swizzard </span><span>i&apos;m having a tough time requiring specter in a lumo repl:</span></div><div data-t="swizzard cljs.user=&gt; (require &apos;[com.rpl.specter :as s :refer-macros [select transform]])
Could not require com.rpl.specter.navs in file com/rpl/specter.cljc
Could not require com.rpl.specter in file com/rpl/specter/navs.cljc
         (new)
         Function.cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:1928:72)
         Function.cljs.analyzer.error.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:2539:92)
         Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5849:145)
         Object.cljs.js.load_macros (NO_SOURCE_FILE &lt;embedded&gt;:5883:41)
         (NO_SOURCE_FILE &lt;embedded&gt;:5883:374)
         Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5838:1)
         Object.cljs.js.load_macros (NO_SOURCE_FILE &lt;embedded&gt;:5883:41)
         (NO_SOURCE_FILE &lt;embedded&gt;:5905:316)
         (NO_SOURCE_FILE &lt;embedded&gt;:5918:218)

Invalid regular expression: /\.js$/: Stack overflow
         String.replace (NO_SOURCE_FILE &lt;anonymous&gt;)
         Object.clojure.string.replace_all (NO_SOURCE_FILE &lt;embedded&gt;:1959:385)
         Object.clojure.string.replace (NO_SOURCE_FILE &lt;embedded&gt;:1962:191)
         (Object.cljs$stacktrace$remove_ext)
         (Object.cljs$stacktrace$mapped_line_column_call)
         (Object.cljs$stacktrace$mapped_frame)
         Function.&lt;anonymous&gt; (evalmachine.&lt;anonymous&gt;:512:24)
         Function.cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:771:157)
         Function.cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$2 (NO_SOURCE_FILE &lt;embedded&gt;:770:188)
         Function.cljs.core.apply.cljs$core$IFn$_invoke$arity$2 (NO_SOURCE_FILE &lt;embedded&gt;:783:244)
"><span class="u" id="1511639844.000036">2017:11:25 19:57:24             swizzard </span><pre>cljs.user=&gt; (require &apos;[com.rpl.specter :as s :refer-macros [select transform]])
Could not require com.rpl.specter.navs in file com/rpl/specter.cljc
Could not require com.rpl.specter in file com/rpl/specter/navs.cljc
         (new)
         Function.cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:1928:72)
         Function.cljs.analyzer.error.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:2539:92)
         Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5849:145)
         Object.cljs.js.load_macros (NO_SOURCE_FILE &lt;embedded&gt;:5883:41)
         (NO_SOURCE_FILE &lt;embedded&gt;:5883:374)
         Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5838:1)
         Object.cljs.js.load_macros (NO_SOURCE_FILE &lt;embedded&gt;:5883:41)
         (NO_SOURCE_FILE &lt;embedded&gt;:5905:316)
         (NO_SOURCE_FILE &lt;embedded&gt;:5918:218)

Invalid regular expression: /\.js$/: Stack overflow
         String.replace (NO_SOURCE_FILE &lt;anonymous&gt;)
         Object.clojure.string.replace_all (NO_SOURCE_FILE &lt;embedded&gt;:1959:385)
         Object.clojure.string.replace (NO_SOURCE_FILE &lt;embedded&gt;:1962:191)
         (Object.cljs$stacktrace$remove_ext)
         (Object.cljs$stacktrace$mapped_line_column_call)
         (Object.cljs$stacktrace$mapped_frame)
         Function.&lt;anonymous&gt; (evalmachine.&lt;anonymous&gt;:512:24)
         Function.cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:771:157)
         Function.cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$2 (NO_SOURCE_FILE &lt;embedded&gt;:770:188)
         Function.cljs.core.apply.cljs$core$IFn$_invoke$arity$2 (NO_SOURCE_FILE &lt;embedded&gt;:783:244)
</pre></div><div data-t="nathanmarz @benstox  selected?  is true if it navigates to at least one value, so  multi-path  in a  selected?  acts like an or"><span class="u" id="1511640397.000050">2017:11:25 20:06:37           nathanmarz </span><span>@benstox </span><code>selected?</code><span> is true if it navigates to at least one value, so </span><code>multi-path</code><span> in a </span><code>selected?</code><span> acts like an or</span></div><div data-t="nathanmarz for multiple conditions just use multiple  selected?  or multiple predicates in the path, e.g.  [#(...) #(...) (selected? ...)]"><span class="u" id="1511640438.000053">2017:11:25 20:07:18           nathanmarz </span><span>for multiple conditions just use multiple </span><code>selected?</code><span> or multiple predicates in the path, e.g. </span><code>[#(...) #(...) (selected? ...)]</code></div><div data-t="nathanmarz @swizzard don&apos;t know anything about lumo, you&apos;ll probably have better luck in #clojurescript"><span class="u" id="1511640492.000030">2017:11:25 20:08:12           nathanmarz </span><span>@swizzard don&apos;t know anything about lumo, you&apos;ll probably have better luck in #clojurescript</span></div><div data-t="swizzard fair enough, thanks"><span class="u" id="1511640504.000043">2017:11:25 20:08:24             swizzard </span><span>fair enough, thanks</span></div><div data-t="drowsy @benstox I wrote a small lib to tackle such a selection more declarative:  https://github.com/IamDrowsy/ebenbild"><span class="u" id="1511642582.000026">2017:11:25 20:43:02               drowsy </span><span>@benstox I wrote a small lib to tackle such a selection more declarative: </span><a href="https://github.com/IamDrowsy/ebenbild">https://github.com/IamDrowsy/ebenbild</a></div><div data-t="drowsy in your case  (like {:type :cheese :quantity #(&gt;= % 3) :quality #(&gt;= % 10)})  would work"><span class="u" id="1511642662.000024">2017:11:25 20:44:22               drowsy </span><span>in your case </span><code>(like {:type :cheese :quantity #(&gt;= % 3) :quality #(&gt;= % 10)})</code><span> would work</span></div><div data-t="drowsy it returns a predicate that can be used directly in a specter path"><span class="u" id="1511642708.000124">2017:11:25 20:45:08               drowsy </span><span>it returns a predicate that can be used directly in a specter path</span></div><div data-t="benstox @nathanmarz Okay, makes sense. Thanks!
@drowsy Interesting! I’ll try your library out."><span class="u" id="1511647893.000060">2017:11:25 22:11:33              benstox </span><span>@nathanmarz Okay, makes sense. Thanks!
@drowsy Interesting! I’ll try your library out.</span></div><div data-t="plamen Hello Nathan,

1. Specter is an amazing library, thank you for providing it!
2. Couple of questions around recursion:

In the following map, I do currently a lot of transformations using reduce/reduce-kv, loops, assoc-in/update-in etc., but as I started to rewrite the manipulations using Specter, the code got of course more readable and consistent.
 
{:name       ’A
 :info       ...
 :parameters ...
 :backend    {:package-name “a”}
 :inputs     {’IA {:connector :csv
                   :endpoint  ...
                   :variables {’iax {:name ’ix
                                     :type :double
                                     :rank 0}
                               ’iay {:name ’iy
                                     :type :double
                                     :rank 2}}}
              ’IB {:...       ...
                   :variables {’ibx {...}
                               ’iby {...}}
                   }}
 :variables  {’Avx {
              ’Avy {...}
              ’Avz {:name      “Avz”
                    :backend   {:package-name “a.avz”
					            :array-layout :column-major
								:array-memory :off-heap}
                    :type      :record
                    :variables {’Avzx {...}
                                ’Avzy {...}
								’Avzz {...
								       :name ’Avzz
								       :backend {:package-name “a.avz.avzz”}}}}}}

Now - in recursion scenarios like in adding a key :name with value the key of the map itself (where select result and transformation target are the same) like
input:
                   :variables {’iax {:type :double
                                     :rank 0}
                               ’iay {:type :double
                                     :rank 2}}
output:
                   :variables {’iax {:name ’ix
                                     :type :double
                                     :rank 0}
                               ’iay {:name ’iy
                                     :type :double
                                     :rank 2}}

everything works, but I probably miss some documentation or understanding to do recursion involving values from nodes from an upper or dispatching on values from a lower level. Examples:
- how do I create recursively the entry 
    :backend   {:package-name ???} 
	- where ??? is the path of :name to the selected/trasfomed map (as in the manually added package names in ’A ’Avz and ’Avzz)
	- while in this case not touching :variables maps starting at the :inputs key in one case?
	- or transforming both :variables paths (starting at :variables AND :inputs)?
- is there a way to collect on the go the current depth of recursion in Specter (or path?) in that same transformation query?
- is there a way to dispatch (or do separate transformation over the structure), but whose input can be in higher level than the tranformation target (e.g. can I select/transform the variable ’Avzx based on a :backend value in ’Avz)? 
- is there a way to dispatch (or do separate transformation over the structure), but whose input can be in lower level than the tranformation target (e.g. can I select/transform the variable ’Avz based on a [:backend :array-layout] and [:backend :array-memory] values in ’Avz)? 

In all the questions my main problem is less how to solve it outside of Specter, but how to select and recurse where selection/collection come from other nodes that the transformation target."><span class="u" id="1511948027.000181">2017:11:29 09:33:47               plamen </span><span>Hello Nathan,

1. Specter is an amazing library, thank you for providing it!
2. Couple of questions around recursion:

In the following map, I do currently a lot of transformations using reduce/reduce-kv, loops, assoc-in/update-in etc., but as I started to rewrite the manipulations using Specter, the code got of course more readable and consistent.
 
{:name       ’A
 :info       ...
 :parameters ...
 :backend    {:package-name “a”}
 :inputs     {’IA {:connector :csv
                   :endpoint  ...
                   :variables {’iax {:name ’ix
                                     :type :double
                                     :rank 0}
                               ’iay {:name ’iy
                                     :type :double
                                     :rank 2}}}
              ’IB {:...       ...
                   :variables {’ibx {...}
                               ’iby {...}}
                   }}
 :variables  {’Avx {
              ’Avy {...}
              ’Avz {:name      “Avz”
                    :backend   {:package-name “a.avz”
					            :array-layout :column-major
								:array-memory :off-heap}
                    :type      :record
                    :variables {’Avzx {...}
                                ’Avzy {...}
								’Avzz {...
								       :name ’Avzz
								       :backend {:package-name “a.avz.avzz”}}}}}}

Now - in recursion scenarios like in adding a key :name with value the key of the map itself (where select result and transformation target are the same) like
input:
                   :variables {’iax {:type :double
                                     :rank 0}
                               ’iay {:type :double
                                     :rank 2}}
output:
                   :variables {’iax {:name ’ix
                                     :type :double
                                     :rank 0}
                               ’iay {:name ’iy
                                     :type :double
                                     :rank 2}}

everything works, but I probably miss some documentation or understanding to do recursion involving values from nodes from an upper or dispatching on values from a lower level. Examples:
- how do I create recursively the entry 
    :backend   {:package-name ???} 
	- where ??? is the path of :name to the selected/trasfomed map (as in the manually added package names in ’A ’Avz and ’Avzz)
	- while in this case not touching :variables maps starting at the :inputs key in one case?
	- or transforming both :variables paths (starting at :variables AND :inputs)?
- is there a way to collect on the go the current depth of recursion in Specter (or path?) in that same transformation query?
- is there a way to dispatch (or do separate transformation over the structure), but whose input can be in higher level than the tranformation target (e.g. can I select/transform the variable ’Avzx based on a :backend value in ’Avz)? 
- is there a way to dispatch (or do separate transformation over the structure), but whose input can be in lower level than the tranformation target (e.g. can I select/transform the variable ’Avz based on a [:backend :array-layout] and [:backend :array-memory] values in ’Avz)? 

In all the questions my main problem is less how to solve it outside of Specter, but how to select and recurse where selection/collection come from other nodes that the transformation target.</span></div><div data-t="nathanmarz for collecting a path as you go, look at  https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure"><span class="u" id="1511967540.000082">2017:11:29 14:59:00           nathanmarz </span><span>for collecting a path as you go, look at </span><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure</a></div><div data-t="nathanmarz by collecting a path as you go like that, you can compute the recursion depth"><span class="u" id="1511967566.000132">2017:11:29 14:59:26           nathanmarz </span><span>by collecting a path as you go like that, you can compute the recursion depth</span></div><div data-t="nathanmarz if you use a  multi-transform , you could dispatch the transformation function like:
 (if-path [:backend (pred= :a)]
  (terminal transformer1)
  (terminal transformer2))
"><span class="u" id="1511967644.000351">2017:11:29 15:00:44           nathanmarz </span><span>if you use a </span><code>multi-transform</code><span>, you could dispatch the transformation function like:
</span><pre>(if-path [:backend (pred= :a)]
  (terminal transformer1)
  (terminal transformer2))
</pre></div><div data-t="nathanmarz I&apos;m not sure what you mean by your last question, it would help if you simplified your example and showed desired input/output"><span class="u" id="1511967750.000345">2017:11:29 15:02:30           nathanmarz </span><span>I&apos;m not sure what you mean by your last question, it would help if you simplified your example and showed desired input/output</span></div><div data-t="plamen Hello Nathan, a lot of thanks for the reply! Will implement what you just showed to me first and will come back to the last questions with simplification again."><span class="u" id="1511968055.000374">2017:11:29 15:07:35               plamen </span><span>Hello Nathan, a lot of thanks for the reply! Will implement what you just showed to me first and will come back to the last questions with simplification again.</span></div><div data-t="plamen ok, the answers added a lot of light to my questions 2,3 and 4, but I still struggle with 1. I simplified it to:"><span class="u" id="1511992886.000249">2017:11:29 22:01:26               plamen </span><span>ok, the answers added a lot of light to my questions 2,3 and 4, but I still struggle with 1. I simplified it to:</span></div><div data-t="plamen how to transform the map of maps"><span class="u" id="1511992897.000809">2017:11:29 22:01:37               plamen </span><span>how to transform the map of maps</span></div><div data-t="plamen {:name “root”
 :a    {:name “a”
        :i    1
        :j    {:name “j”
               :m    :test}
        :k    2}
  😛     {:name “b”
        :m    {:name “m”
               :n    :test}}}"><span class="u" id="1511992903.000685">2017:11:29 22:01:43               plamen </span><span>{:name “root”
 :a    {:name “a”
        :i    1
        :j    {:name “j”
               :m    :test}
        :k    2}
 </span><b>😛</b><span>    {:name “b”
        :m    {:name “m”
               :n    :test}}}</span></div><div data-t="plamen (instead of a smiley, a keyword  😛  should be in the text…)"><span class="u" id="1511992941.000480">2017:11:29 22:02:21               plamen </span><span>(instead of a smiley, a keyword </span><b>😛</b><span> should be in the text…)</span></div><div data-t="plamen (instead of a smiley, a keyword “:b” should be in the text…)"><span class="u" id="1511992959.000844">2017:11:29 22:02:39               plamen </span><span>(instead of a smiley, a keyword “:b” should be in the text…)</span></div><div data-t="plamen to the map"><span class="u" id="1511992969.000865">2017:11:29 22:02:49               plamen </span><span>to the map</span></div><div data-t="plamen {:name “root”
 :package “root”
 :a    {:name “a”
        :package “root.a”
        :i    1
        :j    {:name “j”
               :package “root.a.j”
               :m    :test}
        :k    2}
  😛     {:name “b”
        :package “root.b”
        :m    {:name “m”
               :package “root.b.m”
               :n    :test}}}"><span class="u" id="1511992975.000135">2017:11:29 22:02:55               plamen </span><span>{:name “root”
 :package “root”
 :a    {:name “a”
        :package “root.a”
        :i    1
        :j    {:name “j”
               :package “root.a.j”
               :m    :test}
        :k    2}
 </span><b>😛</b><span>    {:name “b”
        :package “root.b”
        :m    {:name “m”
               :package “root.b.m”
               :n    :test}}}</span></div><div data-t="plamen (instead of a smiley, a keyword “:b” should be in the text…)"><span class="u" id="1511992984.000478">2017:11:29 22:03:04               plamen </span><span>(instead of a smiley, a keyword “:b” should be in the text…)</span></div><div data-t="plamen sorry for the lack of formatting - learning to use slack"><span class="u" id="1511993125.000646">2017:11:29 22:05:25               plamen </span><span>sorry for the lack of formatting - learning to use slack</span></div><div data-t="plamen here again: how to trasform"><span class="u" id="1511993132.000775">2017:11:29 22:05:32               plamen </span><span>here again: how to trasform</span></div><div data-t="plamen {:name &quot;root&quot;
 :a    {:name &quot;a&quot;
        :i    1
        :j    {:name &quot;j&quot;
               :m    :test}
        :k    2}
 :b    {:name &quot;b&quot;
        :m    {:name &quot;m&quot;
               :n    :test}}}"><span class="u" id="1511993136.000924">2017:11:29 22:05:36               plamen </span><pre>{:name &quot;root&quot;
 :a    {:name &quot;a&quot;
        :i    1
        :j    {:name &quot;j&quot;
               :m    :test}
        :k    2}
 :b    {:name &quot;b&quot;
        :m    {:name &quot;m&quot;
               :n    :test}}}</pre></div><div data-t="plamen into"><span class="u" id="1511993140.000750">2017:11:29 22:05:40               plamen </span><span>into</span></div><div data-t="plamen {:name &quot;root&quot;
 :package &quot;root&quot;
 :a    {:name &quot;a&quot;
        :package &quot;root.a&quot;
        :i    1
        :j    {:name &quot;j&quot;
               :package &quot;root.a.j&quot;
               :m    :test}
        :k    2}
 :b    {:name &quot;b&quot;
        :package &quot;root.b&quot;
        :m    {:name &quot;m&quot;
               :package &quot;root.b.m&quot;
               :n    :test}}}"><span class="u" id="1511993150.000350">2017:11:29 22:05:50               plamen </span><pre>{:name &quot;root&quot;
 :package &quot;root&quot;
 :a    {:name &quot;a&quot;
        :package &quot;root.a&quot;
        :i    1
        :j    {:name &quot;j&quot;
               :package &quot;root.a.j&quot;
               :m    :test}
        :k    2}
 :b    {:name &quot;b&quot;
        :package &quot;root.b&quot;
        :m    {:name &quot;m&quot;
               :package &quot;root.b.m&quot;
               :n    :test}}}</pre></div><div data-t="plamen where the  :package  is constructed recursively from the path defined by the  :name  values"><span class="u" id="1511993215.000290">2017:11:29 22:06:55               plamen </span><span>where the </span><pre>:package</pre><span> is constructed recursively from the path defined by the </span><pre>:name</pre><span> values</span></div><div data-t="plamen any help is greatly appreciated"><span class="u" id="1511993296.000391">2017:11:29 22:08:16               plamen </span><span>any help is greatly appreciated</span></div><div data-t="nathanmarz @plamen here&apos;s one way to do it:
 (def NODES-WITH-PATH
  (recursive-path [] p
    [(collect-one :name)
     (continue-then-stay MAP-VALS map? p)
     ]))

(transform [NODES-WITH-PATH :package]
  (fn [&amp; args]
    (let [path (butlast args)]
      (clojure.string/join &quot;.&quot; path)
      ))
  data
  )
"><span class="u" id="1511993975.000254">2017:11:29 22:19:35           nathanmarz </span><span>@plamen here&apos;s one way to do it:
</span><pre>(def NODES-WITH-PATH
  (recursive-path [] p
    [(collect-one :name)
     (continue-then-stay MAP-VALS map? p)
     ]))

(transform [NODES-WITH-PATH :package]
  (fn [&amp; args]
    (let [path (butlast args)]
      (clojure.string/join &quot;.&quot; path)
      ))
  data
  )
</pre></div><div data-t="plamen now starting to understand the benefit of continue-than-stay/stay-then-continue in combination with recursive-path. This was very enlightening (while I discovered Specter 2 days ago and still noob in it, spend may be 3 hours in bending with ALL/FIRST/LAST/p/collect-one for keys/values/recursion and always ended up either missing something from the path or ending in the value of the path key instead of the actual map etc…). A lot of thanks for taking time for my questions! Now everything is explained."><span class="u" id="1511994794.000446">2017:11:29 22:33:14               plamen </span><span>now starting to understand the benefit of continue-than-stay/stay-then-continue in combination with recursive-path. This was very enlightening (while I discovered Specter 2 days ago and still noob in it, spend may be 3 hours in bending with ALL/FIRST/LAST/p/collect-one for keys/values/recursion and always ended up either missing something from the path or ending in the value of the path key instead of the actual map etc…). A lot of thanks for taking time for my questions! Now everything is explained.</span></div><div data-t="plamen Amazing!"><span class="u" id="1511995111.000507">2017:11:29 22:38:31               plamen </span><span>Amazing!</span></div><div data-t="nathanmarz sure thing"><span class="u" id="1511995207.000264">2017:11:29 22:40:07           nathanmarz </span><span>sure thing</span></div><div data-t="eoliphant Hi, I have the following data
 (def testtree    {:form/id 1
                  :form/name &quot;Test Form&quot;
                  :form/description &quot;My Description&quot;
                  :form/version 1
                  :form/groups [{:group/id    2
                                 :group/title  &quot;Page 1&quot;
                                 :group/type   :page
                                 :group/layout :vertical
                                 :group/fields []}
                                {:group/id    4
                                 :group/title  &quot;Page 1&quot;
                                 :group/type   :page
                                 :group/layout :vertical
                                 :group/fields []}]}
  )
 

to insert a new map in  form/groups  I’m doing the following:
 (sp/setval [:form/groups
            ;sp/ALL 
            (sp/srange-dynamic
              (fn [x] (first (keep-indexed #(when (= (:group/id %2) 2) %1) x)))
              (fn [x] (first (keep-indexed #(when (= (:group/id %2) 2) %1) x)))
              )]
          [ {:group/id 4
            :group/title &quot;Inserted&quot;}]
           testtree )
 

Which generally does what I want, but I’m just wondering if there’s any cleaner (more specterish) way to compute the indicies for the srange-dynamic"><span class="u" id="1512074467.000425">2017:11:30 20:41:07            eoliphant </span><span>Hi, I have the following data
</span><pre>(def testtree    {:form/id 1
                  :form/name &quot;Test Form&quot;
                  :form/description &quot;My Description&quot;
                  :form/version 1
                  :form/groups [{:group/id    2
                                 :group/title  &quot;Page 1&quot;
                                 :group/type   :page
                                 :group/layout :vertical
                                 :group/fields []}
                                {:group/id    4
                                 :group/title  &quot;Page 1&quot;
                                 :group/type   :page
                                 :group/layout :vertical
                                 :group/fields []}]}
  )
</pre><span>

to insert a new map in </span><code>form/groups</code><span> I’m doing the following:
</span><pre>(sp/setval [:form/groups
            ;sp/ALL 
            (sp/srange-dynamic
              (fn [x] (first (keep-indexed #(when (= (:group/id %2) 2) %1) x)))
              (fn [x] (first (keep-indexed #(when (= (:group/id %2) 2) %1) x)))
              )]
          [ {:group/id 4
            :group/title &quot;Inserted&quot;}]
           testtree )
</pre><span>

Which generally does what I want, but I’m just wondering if there’s any cleaner (more specterish) way to compute the indicies for the srange-dynamic</span></div><div data-t="nathanmarz @eoliphant you&apos;re trying to insert before the map with  :group/id=2 , regardless of where it is in that sequence?"><span class="u" id="1512076729.000204">2017:11:30 21:18:49           nathanmarz </span><span>@eoliphant you&apos;re trying to insert before the map with </span><code>:group/id=2</code><span>, regardless of where it is in that sequence?</span></div><div data-t="eoliphant yes exactyl"><span class="u" id="1512076888.000042">2017:11:30 21:21:28            eoliphant </span><span>yes exactyl</span></div><div data-t="nathanmarz you can factor out that sort of navigation like this:
 (defn ^:direct-nav before-index-dynamic [p]
  (path
    (srange-dynamic
      (fn [aseq] (first (keep-indexed (fn [i e] (if (p e) i)) aseq)))
      (end-fn [_ s] s))
    BEFORE-ELEM))
"><span class="u" id="1512077177.000568">2017:11:30 21:26:17           nathanmarz </span><span>you can factor out that sort of navigation like this:
</span><pre>(defn ^:direct-nav before-index-dynamic [p]
  (path
    (srange-dynamic
      (fn [aseq] (first (keep-indexed (fn [i e] (if (p e) i)) aseq)))
      (end-fn [_ s] s))
    BEFORE-ELEM))
</pre></div><div data-t="nathanmarz then you can use it like this:
 user=&gt; (setval (before-index-dynamic #(= % 2)) :a [1 2 4 9 2 10])
[1 :a 2 4 9 2 10]
"><span class="u" id="1512077207.000071">2017:11:30 21:26:47           nathanmarz </span><span>then you can use it like this:
</span><pre>user=&gt; (setval (before-index-dynamic #(= % 2)) :a [1 2 4 9 2 10])
[1 :a 2 4 9 2 10]
</pre></div><div data-t="eoliphant ah gotcha.  Yes that’s much cleaner  🙂"><span class="u" id="1512077225.000329">2017:11:30 21:27:05            eoliphant </span><span>ah gotcha.  Yes that’s much cleaner </span><b>🙂</b></div><div data-t="eoliphant thanks"><span class="u" id="1512077227.000192">2017:11:30 21:27:07            eoliphant </span><span>thanks</span></div><div data-t="nathanmarz using  end-fn  also avoids computing the index twice"><span class="u" id="1512077256.000203">2017:11:30 21:27:36           nathanmarz </span><span>using </span><code>end-fn</code><span> also avoids computing the index twice</span></div><div data-t="eoliphant yeah that’s cool, that was annoying me as well"><span class="u" id="1512077283.000326">2017:11:30 21:28:03            eoliphant </span><span>yeah that’s cool, that was annoying me as well</span></div><div data-t="eoliphant it’s funny, I first started playing with specter a month or 2 ago and it kind of gave me a migraine lol.  But sometimes you have to step away, and come back.  Just picked it back up this morning and blew through a couple scenarios quite easily"><span class="u" id="1512077830.000122">2017:11:30 21:37:10            eoliphant </span><span>it’s funny, I first started playing with specter a month or 2 ago and it kind of gave me a migraine lol.  But sometimes you have to step away, and come back.  Just picked it back up this morning and blew through a couple scenarios quite easily</span></div><div data-t="nathanmarz any new way of thinking takes time to learn"><span class="u" id="1512078004.000278">2017:11:30 21:40:04           nathanmarz </span><span>any new way of thinking takes time to learn</span></div><div data-t="nathanmarz eventually it becomes really easy"><span class="u" id="1512078017.000446">2017:11:30 21:40:17           nathanmarz </span><span>eventually it becomes really easy</span></div><div data-t="eoliphant yeah definitely grokking it better now.  One more quick question, this data structure is for an interactive form builder.  So as you can see a group has fields, etc.  There will cases where say you move a field from one group to another.  Is there a way to ‘move’ something from one path to another, or do the delete and add together, kind of transactionally?"><span class="u" id="1512079582.000462">2017:11:30 22:06:22            eoliphant </span><span>yeah definitely grokking it better now.  One more quick question, this data structure is for an interactive form builder.  So as you can see a group has fields, etc.  There will cases where say you move a field from one group to another.  Is there a way to ‘move’ something from one path to another, or do the delete and add together, kind of transactionally?</span></div><div data-t="nathanmarz index-nav  can be used to move an element from one location in a sequence to another"><span class="u" id="1512080129.000057">2017:11:30 22:15:29           nathanmarz </span><code>index-nav</code><span> can be used to move an element from one location in a sequence to another</span></div><div data-t="nathanmarz otherwise you&apos;ll have to do removal and addition separately"><span class="u" id="1512080149.000390">2017:11:30 22:15:49           nathanmarz </span><span>otherwise you&apos;ll have to do removal and addition separately</span></div><div data-t="eoliphant Ok, will give that a whirl"><span class="u" id="1512080649.000014">2017:11:30 22:24:09            eoliphant </span><span>Ok, will give that a whirl</span></div><div data-t="eoliphant hi, i have a quick question.  I want to recursively search for an element in a data-structure (maps, that have lists, that have maps, etc), then do a setval before/after the element i found

so I have this test data structure
 #:designer{:cur-form-def #:form{:id #uuid&quot;4979e704-5047-48cf-bfe3-fdf9ca58bae8&quot;,
                                :name &quot;New Form&quot;,
                                :description &quot;Description&quot;,
                                :version 1,
                                :groups [#:group{:id #uuid&quot;d865ab2f-d114-4853-9a37-592a2c941152&quot;,
                                                 :title &quot;Page 1&quot;,
                                                 :type :page,
                                                 :layout :vertical,
                                                 :subgroups [#:group{:id #uuid&quot;237a7f3e-702e-4b63-8b4e-5df4da205e22&quot;,
                                                                     :name &quot;row1&quot;,
                                                                     :type :row,
                                                                     :layout :horizontal,
                                                                     :fields [#:field{:id #uuid&quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;,
                                                                                      :name :newfield,
                                                                                      :label &quot;New Fuekd&quot;,
                                                                                      :type :text}]}]}]}}
 

And I want to find the :newfield by its id and jam a new map in the containing vector after :newfield

so I do the following:

 (sp/setval [:designer/cur-form-def
            :form/groups
            sp/ALL
            (sp/walker #(= (:field/id %) #uuid &quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;))
            sp/AFTER-ELEM
            ] [{:test :newfield}] appdb)
 
which gives me this:

 #:designer{:cur-form-def #:form{:id #uuid&quot;4979e704-5047-48cf-bfe3-fdf9ca58bae8&quot;,
                                :name &quot;New Form&quot;,
                                :description &quot;Description&quot;,
                                :version 1,
                                :groups [#:group{:id #uuid&quot;d865ab2f-d114-4853-9a37-592a2c941152&quot;,
                                                 :title &quot;Page 1&quot;,
                                                 :type :page,
                                                 :layout :vertical,
                                                 :subgroups [#:group{:id #uuid&quot;237a7f3e-702e-4b63-8b4e-5df4da205e22&quot;,
                                                                     :name &quot;row1&quot;,
                                                                     :type :row,
                                                                     :layout :horizontal,
                                                                     :fields [([:field/id
                                                                                #uuid&quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;]
                                                                               [:field/name :newfield]
                                                                               [:field/label &quot;New Fuekd&quot;]
                                                                               [:field/type :text]
 
The walker selector worked fine, but now :group/fields has gone from a vector with a single map to a vector, that has a single list of k/v pairs including the new one.  So I’m obviously doing somethign wrong lol.  When if leave off the AFTER-ELEM, the map is set as one would expect but replaces the one that was ‘found’

I’ve figured that I need to ‘go up/out’ of the map to get back to the vector, at this point, just not sure how"><span class="u" id="1512331857.000030">2017:12:03 20:10:57            eoliphant </span><span>hi, i have a quick question.  I want to recursively search for an element in a data-structure (maps, that have lists, that have maps, etc), then do a setval before/after the element i found

so I have this test data structure
</span><pre>#:designer{:cur-form-def #:form{:id #uuid&quot;4979e704-5047-48cf-bfe3-fdf9ca58bae8&quot;,
                                :name &quot;New Form&quot;,
                                :description &quot;Description&quot;,
                                :version 1,
                                :groups [#:group{:id #uuid&quot;d865ab2f-d114-4853-9a37-592a2c941152&quot;,
                                                 :title &quot;Page 1&quot;,
                                                 :type :page,
                                                 :layout :vertical,
                                                 :subgroups [#:group{:id #uuid&quot;237a7f3e-702e-4b63-8b4e-5df4da205e22&quot;,
                                                                     :name &quot;row1&quot;,
                                                                     :type :row,
                                                                     :layout :horizontal,
                                                                     :fields [#:field{:id #uuid&quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;,
                                                                                      :name :newfield,
                                                                                      :label &quot;New Fuekd&quot;,
                                                                                      :type :text}]}]}]}}
</pre><span>

And I want to find the :newfield by its id and jam a new map in the containing vector after :newfield

so I do the following:

</span><pre>(sp/setval [:designer/cur-form-def
            :form/groups
            sp/ALL
            (sp/walker #(= (:field/id %) #uuid &quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;))
            sp/AFTER-ELEM
            ] [{:test :newfield}] appdb)
</pre><span>
which gives me this:

</span><pre>#:designer{:cur-form-def #:form{:id #uuid&quot;4979e704-5047-48cf-bfe3-fdf9ca58bae8&quot;,
                                :name &quot;New Form&quot;,
                                :description &quot;Description&quot;,
                                :version 1,
                                :groups [#:group{:id #uuid&quot;d865ab2f-d114-4853-9a37-592a2c941152&quot;,
                                                 :title &quot;Page 1&quot;,
                                                 :type :page,
                                                 :layout :vertical,
                                                 :subgroups [#:group{:id #uuid&quot;237a7f3e-702e-4b63-8b4e-5df4da205e22&quot;,
                                                                     :name &quot;row1&quot;,
                                                                     :type :row,
                                                                     :layout :horizontal,
                                                                     :fields [([:field/id
                                                                                #uuid&quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;]
                                                                               [:field/name :newfield]
                                                                               [:field/label &quot;New Fuekd&quot;]
                                                                               [:field/type :text]
</pre><span>
The walker selector worked fine, but now :group/fields has gone from a vector with a single map to a vector, that has a single list of k/v pairs including the new one.  So I’m obviously doing somethign wrong lol.  When if leave off the AFTER-ELEM, the map is set as one would expect but replaces the one that was ‘found’

I’ve figured that I need to ‘go up/out’ of the map to get back to the vector, at this point, just not sure how</span></div><div data-t="nathanmarz @eoliphant you need to do something similar to what I showed you before with  before-index-dynamic , except navigate after the index of the target element"><span class="u" id="1512335049.000047">2017:12:03 21:04:09           nathanmarz </span><span>@eoliphant you need to do something similar to what I showed you before with </span><code>before-index-dynamic</code><span>, except navigate after the index of the target element</span></div><div data-t="nathanmarz you could also use zippers for this task, see  https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers"><span class="u" id="1512335131.000077">2017:12:03 21:05:31           nathanmarz </span><span>you could also use zippers for this task, see </span><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers">https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers</a></div><div data-t="eoliphant hmm, ok so would it be something more like creating a recursive-path navigator instead of using walker?"><span class="u" id="1512337621.000084">2017:12:03 21:47:01            eoliphant </span><span>hmm, ok so would it be something more like creating a recursive-path navigator instead of using walker?</span></div><div data-t="nathanmarz definitely"><span class="u" id="1512337635.000119">2017:12:03 21:47:15           nathanmarz </span><span>definitely</span></div><div data-t="nathanmarz make a recursive path navigating to every &quot;group&quot; map, then navigate from there to the position next to your target element"><span class="u" id="1512337678.000094">2017:12:03 21:47:58           nathanmarz </span><span>make a recursive path navigating to every &quot;group&quot; map, then navigate from there to the position next to your target element</span></div><div data-t="nathanmarz there are really very few cases that justify the use of  walker"><span class="u" id="1512337737.000009">2017:12:03 21:48:57           nathanmarz </span><span>there are really very few cases that justify the use of </span><code>walker</code></div><div data-t="nathanmarz it traverses map keys, map key/value pairs, dives into record fields, all of which causes it to be much slower than necessary as well as lead to surprising bugs"><span class="u" id="1512337806.000035">2017:12:03 21:50:06           nathanmarz </span><span>it traverses map keys, map key/value pairs, dives into record fields, all of which causes it to be much slower than necessary as well as lead to surprising bugs</span></div><div data-t="eoliphant ok cool, that’s ironically sort of what I was thinking  🙂"><span class="u" id="1512337953.000031">2017:12:03 21:52:33            eoliphant </span><span>ok cool, that’s ironically sort of what I was thinking </span><b>🙂</b></div><div data-t="eoliphant and i see your point, walker is quick-and-dirty but far from optimal since I know specifically what I need to ’walk;"><span class="u" id="1512338022.000077">2017:12:03 21:53:42            eoliphant </span><span>and i see your point, walker is quick-and-dirty but far from optimal since I know specifically what I need to ’walk;</span></div><div data-t="eoliphant hi, I’m trying something like this:

 (def find-field
  (sp/recursive-path [uuid] p
                     (sp/cond-path
                       (sp/keypath :group/subgroups) [sp/ALL p]
                       (sp/keypath :group/fields) [sp/ALL p]
                       #(= (:field/id %) uuid) sp/STAY)))
 
and calling it like so
 (sp/select [:designer/cur-form-def
            :form/groups
            (find-field #uuid &quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot; )
            ]
            appdb)
 

I’ve tried it with and without the  keypath  call but I’m getting a “Don’t know how to create ISeq from: clojure.lang.Keyword  ” in both cases"><span class="u" id="1512342824.000050">2017:12:03 23:13:44            eoliphant </span><span>hi, I’m trying something like this:

</span><pre>(def find-field
  (sp/recursive-path [uuid] p
                     (sp/cond-path
                       (sp/keypath :group/subgroups) [sp/ALL p]
                       (sp/keypath :group/fields) [sp/ALL p]
                       #(= (:field/id %) uuid) sp/STAY)))
</pre><span>
and calling it like so
</span><pre>(sp/select [:designer/cur-form-def
            :form/groups
            (find-field #uuid &quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot; )
            ]
            appdb)
</pre><span>

I’ve tried it with and without the </span><code>keypath</code><span> call but I’m getting a “Don’t know how to create ISeq from: clojure.lang.Keyword  ” in both cases</span></div><div data-t="nathanmarz @eoliphant a few things"><span class="u" id="1512346164.000014">2017:12:04 00:09:24           nathanmarz </span><span>@eoliphant a few things</span></div><div data-t="nathanmarz you&apos;re misunderstanding  cond-path  and  keypath"><span class="u" id="1512346172.000054">2017:12:04 00:09:32           nathanmarz </span><span>you&apos;re misunderstanding </span><code>cond-path</code><span> and </span><code>keypath</code></div><div data-t="nathanmarz a condition is true if it selects anything"><span class="u" id="1512346179.000079">2017:12:04 00:09:39           nathanmarz </span><span>a condition is true if it selects anything</span></div><div data-t="nathanmarz keypath  always selects something, so it&apos;s pointless to be a condition on its own"><span class="u" id="1512346195.000095">2017:12:04 00:09:55           nathanmarz </span><code>keypath</code><span> always selects something, so it&apos;s pointless to be a condition on its own</span></div><div data-t="nathanmarz you&apos;re also trying to navigate the maps and find the field in the submap at the same time, which isn&apos;t the right approach"><span class="u" id="1512346259.000152">2017:12:04 00:10:59           nathanmarz </span><span>you&apos;re also trying to navigate the maps and find the field in the submap at the same time, which isn&apos;t the right approach</span></div><div data-t="nathanmarz instead do something like:  (def NODES (recursive-path [] p (continue-then-stay :subgroups ALL)))"><span class="u" id="1512346305.000133">2017:12:04 00:11:45           nathanmarz </span><span>instead do something like: </span><code>(def NODES (recursive-path [] p (continue-then-stay :subgroups ALL)))</code></div><div data-t="nathanmarz then from there you can do  (transform [NODES :fields ..."><span class="u" id="1512346348.000062">2017:12:04 00:12:28           nathanmarz </span><span>then from there you can do </span><code>(transform [NODES :fields ...</code></div><div data-t="eoliphant hmm ok, will give that a shot, yeah i’d just tossed in keypath in trying to figure out why it wasn’t working.  originally it was just  
 (sp/cond-path
  :group/subgroups [ALL p]
 

but ok i think I see understand it a little better will break it out"><span class="u" id="1512351419.000011">2017:12:04 01:36:59            eoliphant </span><span>hmm ok, will give that a shot, yeah i’d just tossed in keypath in trying to figure out why it wasn’t working.  originally it was just  
</span><pre>(sp/cond-path
  :group/subgroups [ALL p]
</pre><span>

but ok i think I see understand it a little better will break it out</span></div><div data-t="eoliphant ok.  so after banging my head for a bit because i’d mistyped the key in NODES function lol, I’ve got everything working, needs some cleanup, but basically this:
 (sp/setval [:designer/cur-form-def
            :form/groups
            sp/ALL
            NODES
            :group/fields
            #(some? %)
            (before-index-dynamic #(= (:field/id %) #uuid &quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;))

            ]
           [{:new :field}]
           appdb)
 

Will add  {:new field}  before the field with the matching id.  so good there.  However, had to do a bit of hacking because not all  :group/*  maps have  group/fields ,   This was initially blowing up the  before-index..  function as specter would dutifully provide a nil.  So I added the  some?  check.  That works, in terms of the field getting inserted, though I’m sure it’s not the best way, but the other thing is that the newly returned data structure adds a  {:group/fields nil}  to groups that didn’t have one, which surprised me as I thought the some? check would prevent that.    So I’m thinking the recursive path function should weed out groups that don’t have :group/fields?"><span class="u" id="1512358231.000131">2017:12:04 03:30:31            eoliphant </span><span>ok.  so after banging my head for a bit because i’d mistyped the key in NODES function lol, I’ve got everything working, needs some cleanup, but basically this:
</span><pre>(sp/setval [:designer/cur-form-def
            :form/groups
            sp/ALL
            NODES
            :group/fields
            #(some? %)
            (before-index-dynamic #(= (:field/id %) #uuid &quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;))

            ]
           [{:new :field}]
           appdb)
</pre><span>

Will add </span><code>{:new field}</code><span> before the field with the matching id.  so good there.  However, had to do a bit of hacking because not all </span><code>:group/*</code><span> maps have </span><code>group/fields</code><span>,   This was initially blowing up the </span><code>before-index..</code><span> function as specter would dutifully provide a nil.  So I added the </span><code>some?</code><span> check.  That works, in terms of the field getting inserted, though I’m sure it’s not the best way, but the other thing is that the newly returned data structure adds a </span><code>{:group/fields nil}</code><span> to groups that didn’t have one, which surprised me as I thought the some? check would prevent that.    So I’m thinking the recursive path function should weed out groups that don’t have :group/fields?</span></div><div data-t="nathanmarz @eoliphant ah you just need  before-index-dynamic  to navigate nowhere if there&apos;s no match"><span class="u" id="1512391752.000315">2017:12:04 12:49:12           nathanmarz </span><span>@eoliphant ah you just need </span><code>before-index-dynamic</code><span> to navigate nowhere if there&apos;s no match</span></div><div data-t="nathanmarz this does the trick:
 (defn ^:direct-nav before-index-dynamic [p]
  (path
    (srange-dynamic
      (fn [aseq]
        (if-let [i (first (keep-indexed (fn [i e] (if (p e) i)) aseq))]
          i
          (count aseq)
          ))
      (end-fn [aseq s]
        (if (= s (count aseq)) s (inc s))))
    (complement empty?)
    BEFORE-ELEM
    ))
"><span class="u" id="1512391757.000287">2017:12:04 12:49:17           nathanmarz </span><span>this does the trick:
</span><pre>(defn ^:direct-nav before-index-dynamic [p]
  (path
    (srange-dynamic
      (fn [aseq]
        (if-let [i (first (keep-indexed (fn [i e] (if (p e) i)) aseq))]
          i
          (count aseq)
          ))
      (end-fn [aseq s]
        (if (= s (count aseq)) s (inc s))))
    (complement empty?)
    BEFORE-ELEM
    ))
</pre></div><div data-t="nathanmarz if you only want to navigate to a value in a map if the key exists, then do  (must :somekey)"><span class="u" id="1512391864.000372">2017:12:04 12:51:04           nathanmarz </span><span>if you only want to navigate to a value in a map if the key exists, then do </span><code>(must :somekey)</code></div><div data-t="eoliphant ah yeah.  ok so even in my example just (must :group/fields), obviated the need for the (some? ..) and gave the proper result, will mess around with the path function as well to see what makes more sense"><span class="u" id="1512397180.000719">2017:12:04 14:19:40            eoliphant </span><span>ah yeah.  ok so even in my example just (must :group/fields), obviated the need for the (some? ..) and gave the proper result, will mess around with the path function as well to see what makes more sense</span></div><div data-t="mbertheau How would I do  (filterv #(-&gt; % :id nil?) foo)  with specter? Or would I not?"><span class="u" id="1512654011.000085">2017:12:07 13:40:11            mbertheau </span><span>How would I do </span><code>(filterv #(-&gt; % :id nil?) foo)</code><span> with specter? Or would I not?</span></div><div data-t="nathanmarz @mbertheau two approaches:
 (select [ALL #(-&gt; % :id nil?)] foo)
"><span class="u" id="1512654430.000284">2017:12:07 13:47:10           nathanmarz </span><span>@mbertheau two approaches:
</span><pre>(select [ALL #(-&gt; % :id nil?)] foo)
</pre></div><div data-t="nathanmarz (setval [ALL #(-&gt; % :id some?)] NONE foo)
"><span class="u" id="1512654445.000277">2017:12:07 13:47:25           nathanmarz </span><pre>(setval [ALL #(-&gt; % :id some?)] NONE foo)
</pre></div><div data-t="nathanmarz the first always returns a vector, the second maintains the type of whatever  foo  is"><span class="u" id="1512654459.000106">2017:12:07 13:47:39           nathanmarz </span><span>the first always returns a vector, the second maintains the type of whatever </span><code>foo</code><span> is</span></div><div data-t="mbertheau @nathanmarz I&apos;m just starting out with specter - thanks for helping me up the initial learning curve!"><span class="u" id="1512655610.000381">2017:12:07 14:06:50            mbertheau </span><span>@nathanmarz I&apos;m just starting out with specter - thanks for helping me up the initial learning curve!</span></div><div data-t="nathanmarz sure, no problem"><span class="u" id="1512656084.000444">2017:12:07 14:14:44           nathanmarz </span><span>sure, no problem</span></div><div data-t="mbjarland Hi @nathanmarz, now this might be a noob question, but how would I go about getting rid of the following warning when building my lein project (which has specter in the depenendency graph): 
 WARNING: any? already refers to: #&apos;clojure.core/any? in namespace: com.rpl.specter.impl, being replaced by: #&apos;com.rpl.specter.impl/any?
"><span class="u" id="1513173190.000041">2017:12:13 13:53:10            mbjarland </span><span>Hi @nathanmarz, now this might be a noob question, but how would I go about getting rid of the following warning when building my lein project (which has specter in the depenendency graph): 
</span><pre>WARNING: any? already refers to: #&apos;clojure.core/any? in namespace: com.rpl.specter.impl, being replaced by: #&apos;com.rpl.specter.impl/any?
</pre></div><div data-t="mbjarland clojure 1.9.0"><span class="u" id="1513173198.000080">2017:12:13 13:53:18            mbjarland </span><span>clojure 1.9.0</span></div><div data-t="nathanmarz @mbjarland ah i&apos;ll need to release a new version that renames those functions"><span class="u" id="1513173249.000300">2017:12:13 13:54:09           nathanmarz </span><span>@mbjarland ah i&apos;ll need to release a new version that renames those functions</span></div><div data-t="mbjarland I&apos;m using midje for testing which in turn pulls in marick/suchwow which in turn pulls in specter 0.13.0...ah ok"><span class="u" id="1513173265.000272">2017:12:13 13:54:25            mbjarland </span><span>I&apos;m using midje for testing which in turn pulls in marick/suchwow which in turn pulls in specter 0.13.0...ah ok</span></div><div data-t="mbjarland do you want the dependency graph or any other details from my side?"><span class="u" id="1513173304.000371">2017:12:13 13:55:04            mbjarland </span><span>do you want the dependency graph or any other details from my side?</span></div><div data-t="nathanmarz no, that&apos;s fine"><span class="u" id="1513173330.000160">2017:12:13 13:55:30           nathanmarz </span><span>no, that&apos;s fine</span></div><div data-t="nathanmarz you&apos;ll need to open an issue with midje to update its dependencies"><span class="u" id="1513173361.000397">2017:12:13 13:56:01           nathanmarz </span><span>you&apos;ll need to open an issue with midje to update its dependencies</span></div><div data-t="nathanmarz looks like it&apos;s really outdated"><span class="u" id="1513173372.000475">2017:12:13 13:56:12           nathanmarz </span><span>looks like it&apos;s really outdated</span></div><div data-t="mbjarland would be glad to, though it might be worth waiting until you do your update before creating the ticket"><span class="u" id="1513173408.000150">2017:12:13 13:56:48            mbjarland </span><span>would be glad to, though it might be worth waiting until you do your update before creating the ticket</span></div><div data-t="nathanmarz just checked, that function no longer exists in specter codebase so there are no warnings with latest version"><span class="u" id="1513173446.000433">2017:12:13 13:57:26           nathanmarz </span><span>just checked, that function no longer exists in specter codebase so there are no warnings with latest version</span></div><div data-t="mbjarland ha, ok I&apos;ll create a ticket now then"><span class="u" id="1513173476.000242">2017:12:13 13:57:56            mbjarland </span><span>ha, ok I&apos;ll create a ticket now then</span></div><div data-t="nathanmarz oh apparently I knew about and fixed this a long time ago:  https://github.com/nathanmarz/specter/blob/master/CHANGES.md#0131"><span class="u" id="1513173505.000044">2017:12:13 13:58:25           nathanmarz </span><span>oh apparently I knew about and fixed this a long time ago: </span><a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md#0131">https://github.com/nathanmarz/specter/blob/master/CHANGES.md#0131</a></div><div data-t="mbjarland unfortunate fact"><span class="u" id="1513173505.000409">2017:12:13 13:58:25            mbjarland </span><span>unfortunate fact</span></div><div data-t="mbjarland suchwow (which is the immediate dep of midje) has not changed since the 6.0.0 version which midje is using"><span class="u" id="1513173530.000589">2017:12:13 13:58:50            mbjarland </span><span>suchwow (which is the immediate dep of midje) has not changed since the 6.0.0 version which midje is using</span></div><div data-t="mbjarland this brings to mind Rich&apos;s talk about dependency hell..."><span class="u" id="1513173559.000284">2017:12:13 13:59:19            mbjarland </span><span>this brings to mind Rich&apos;s talk about dependency hell...</span></div><div data-t="mbjarland so I would have to file a ticket with suchwow and once they update, file a ticket with midje?"><span class="u" id="1513173685.000062">2017:12:13 14:01:25            mbjarland </span><span>so I would have to file a ticket with suchwow and once they update, file a ticket with midje?</span></div><div data-t="nathanmarz @mbjarland yea, it&apos;s an annoying problem with the jvm"><span class="u" id="1513175071.000620">2017:12:13 14:24:31           nathanmarz </span><span>@mbjarland yea, it&apos;s an annoying problem with the jvm</span></div><div data-t="nathanmarz but yes, that would be the approach to use"><span class="u" id="1513175085.000047">2017:12:13 14:24:45           nathanmarz </span><span>but yes, that would be the approach to use</span></div><div data-t="nathanmarz it would probably be a lot faster for you to just fork the projects yourself in the meantime"><span class="u" id="1513175105.000709">2017:12:13 14:25:05           nathanmarz </span><span>it would probably be a lot faster for you to just fork the projects yourself in the meantime</span></div><div data-t="mbjarland there is an existing PR on suchwow: 
 https://github.com/marick/suchwow/pull/9"><span class="u" id="1513175252.000014">2017:12:13 14:27:32            mbjarland </span><span>there is an existing PR on suchwow: 
</span><a href="https://github.com/marick/suchwow/pull/9">https://github.com/marick/suchwow/pull/9</a></div><div data-t="mbjarland I created a ticket and referenced the pr, now we wait"><span class="u" id="1513175371.000515">2017:12:13 14:29:31            mbjarland </span><span>I created a ticket and referenced the pr, now we wait</span></div><div data-t="mbjarland https://github.com/marick/suchwow/issues/10"><span class="u" id="1513175386.000035">2017:12:13 14:29:46            mbjarland </span><a href="https://github.com/marick/suchwow/issues/10">https://github.com/marick/suchwow/issues/10</a></div><div data-t="abdullahibra @nathanmarz (select [ALL (selected? :p1 ALL :name (pred= &quot;wow&quot;))] data) =&gt; this expression check for &quot;wow&quot; word, what if i want to check multiple  different words"><span class="u" id="1513178453.000548">2017:12:13 15:20:53         abdullahibra </span><span>@nathanmarz (select [ALL (selected? :p1 ALL :name (pred= &quot;wow&quot;))] data) =&gt; this expression check for &quot;wow&quot; word, what if i want to check multiple  different words</span></div><div data-t="abdullahibra for example:
all contains &quot;wow&quot; or contains &quot;good&quot;"><span class="u" id="1513178481.000051">2017:12:13 15:21:21         abdullahibra </span><span>for example:
all contains &quot;wow&quot; or contains &quot;good&quot;</span></div><div data-t="abdullahibra (or (pred= &quot;wow&quot;) (pred= &quot;good&quot;)) ?"><span class="u" id="1513178574.000150">2017:12:13 15:22:54         abdullahibra </span><span>(or (pred= &quot;wow&quot;) (pred= &quot;good&quot;)) ?</span></div><div data-t="nathanmarz @abdullahibra replace  (pred= &quot;wow&quot;)  with  #{&quot;wow&quot; &quot;good&quot;}"><span class="u" id="1513179643.000777">2017:12:13 15:40:43           nathanmarz </span><span>@abdullahibra replace </span><code>(pred= &quot;wow&quot;)</code><span> with </span><code>#{&quot;wow&quot; &quot;good&quot;}</code></div><div data-t="abdullahibra great"><span class="u" id="1513179658.000174">2017:12:13 15:40:58         abdullahibra </span><span>great</span></div><div data-t="abdullahibra what if i want to use custom function rather than match string? maybe regexp matcher for example"><span class="u" id="1513179767.000713">2017:12:13 15:42:47         abdullahibra </span><span>what if i want to use custom function rather than match string? maybe regexp matcher for example</span></div><div data-t="nathanmarz @abdullahibra you can insert any clojure function into a path"><span class="u" id="1513179794.000489">2017:12:13 15:43:14           nathanmarz </span><span>@abdullahibra you can insert any clojure function into a path</span></div><div data-t="nathanmarz if it returns nil or false, it ceases navigation there"><span class="u" id="1513179834.000506">2017:12:13 15:43:54           nathanmarz </span><span>if it returns nil or false, it ceases navigation there</span></div><div data-t="nathanmarz regexes are also natively supported, they navigate to every substring match"><span class="u" id="1513179870.000626">2017:12:13 15:44:30           nathanmarz </span><span>regexes are also natively supported, they navigate to every substring match</span></div><div data-t="abdullahibra #{&quot;wow&quot; (fn [s] (re-find #&quot;[g|G]ood&quot; s))} this is right?"><span class="u" id="1513179875.000874">2017:12:13 15:44:35         abdullahibra </span><span>#{&quot;wow&quot; (fn [s] (re-find #&quot;[g|G]ood&quot; s))} this is right?</span></div><div data-t="nathanmarz so  (selected? #&quot;aaa&quot;)  would act as a filter"><span class="u" id="1513179892.000437">2017:12:13 15:44:52           nathanmarz </span><span>so </span><code>(selected? #&quot;aaa&quot;)</code><span> would act as a filter</span></div><div data-t="nathanmarz no, sets are interpreted just like a function"><span class="u" id="1513179912.000674">2017:12:13 15:45:12           nathanmarz </span><span>no, sets are interpreted just like a function</span></div><div data-t="nathanmarz (since sets are functions in clojure)"><span class="u" id="1513179920.001024">2017:12:13 15:45:20           nathanmarz </span><span>(since sets are functions in clojure)</span></div><div data-t="nathanmarz you would want either  (fn [s] (or (= &quot;wow&quot; %) (re-find ...)))  or  (selected? (multi-path (pred= &quot;wow&quot;) #&quot;[g|G]ood&quot;))"><span class="u" id="1513179982.000717">2017:12:13 15:46:22           nathanmarz </span><span>you would want either </span><code>(fn [s] (or (= &quot;wow&quot; %) (re-find ...)))</code><span> or </span><code>(selected? (multi-path (pred= &quot;wow&quot;) #&quot;[g|G]ood&quot;))</code></div><div data-t="nathanmarz multi-path  within a  selected?  functions like an  or"><span class="u" id="1513180008.000462">2017:12:13 15:46:48           nathanmarz </span><code>multi-path</code><span> within a </span><code>selected?</code><span> functions like an </span><code>or</code></div><div data-t="nathanmarz you may wish to look through  https://github.com/nathanmarz/specter/wiki/List-of-Navigators"><span class="u" id="1513180028.000312">2017:12:13 15:47:08           nathanmarz </span><span>you may wish to look through </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators">https://github.com/nathanmarz/specter/wiki/List-of-Navigators</a></div><div data-t="abdullahibra that&apos;s really cool"><span class="u" id="1513180090.000287">2017:12:13 15:48:10         abdullahibra </span><span>that&apos;s really cool</span></div><div data-t="abdullahibra thanks man for this"><span class="u" id="1513180094.000824">2017:12:13 15:48:14         abdullahibra </span><span>thanks man for this</span></div><div data-t="abdullahibra for this data: [{:s1 &quot;cool&quot; :p1 [{:name &quot;hello&quot; :sen &quot;good&quot;} {:name &quot;world&quot;, :sen &quot;nothing&quot;}]},  {:s2 &quot;cool2&quot; :p1 [{:name &quot;wow&quot;, :sen &quot;fine&quot;} {:name &quot;world&quot;,, :sen &quot;none&quot;}]}]"><span class="u" id="1513182633.000004">2017:12:13 16:30:33         abdullahibra </span><span>for this data: [{:s1 &quot;cool&quot; :p1 [{:name &quot;hello&quot; :sen &quot;good&quot;} {:name &quot;world&quot;, :sen &quot;nothing&quot;}]},  {:s2 &quot;cool2&quot; :p1 [{:name &quot;wow&quot;, :sen &quot;fine&quot;} {:name &quot;world&quot;,, :sen &quot;none&quot;}]}]</span></div><div data-t="abdullahibra @nathanmarz helped me to extract all hash maps which match &quot;wow&quot; or regexp, and for multiple words i would like to do this:
(selected? (apply multi-path [#&quot;regexp1&quot; #&quot;regexp2&quot;])) and what if i want to match two cases in the same time, so i want to catch the :name which has regexp and :sen which has also regexp"><span class="u" id="1513182804.000756">2017:12:13 16:33:24         abdullahibra </span><span>@nathanmarz helped me to extract all hash maps which match &quot;wow&quot; or regexp, and for multiple words i would like to do this:
(selected? (apply multi-path [#&quot;regexp1&quot; #&quot;regexp2&quot;])) and what if i want to match two cases in the same time, so i want to catch the :name which has regexp and :sen which has also regexp</span></div><div data-t="nathanmarz don&apos;t do  (apply multi-path ...)"><span class="u" id="1513182877.000061">2017:12:13 16:34:37           nathanmarz </span><span>don&apos;t do </span><code>(apply multi-path ...)</code></div><div data-t="abdullahibra why ?"><span class="u" id="1513182881.000163">2017:12:13 16:34:41         abdullahibra </span><span>why ?</span></div><div data-t="nathanmarz inefficient and unecessary"><span class="u" id="1513182892.000248">2017:12:13 16:34:52           nathanmarz </span><span>inefficient and unecessary</span></div><div data-t="nathanmarz to match multiple cases just put multiple conditions consecutive in the path"><span class="u" id="1513182905.000654">2017:12:13 16:35:05           nathanmarz </span><span>to match multiple cases just put multiple conditions consecutive in the path</span></div><div data-t="abdullahibra what if i have big list of regexp?"><span class="u" id="1513182907.000362">2017:12:13 16:35:07         abdullahibra </span><span>what if i have big list of regexp?</span></div><div data-t="abdullahibra what i would like to get any hash map which match any from regexp-list1 and regexp-list2 from two different paths"><span class="u" id="1513182973.000155">2017:12:13 16:36:13         abdullahibra </span><span>what i would like to get any hash map which match any from regexp-list1 and regexp-list2 from two different paths</span></div><div data-t="abdullahibra one path from :name and other from :sen"><span class="u" id="1513182990.000179">2017:12:13 16:36:30         abdullahibra </span><span>one path from :name and other from :sen</span></div><div data-t="nathanmarz you can do the  (apply multi-path some-list)  but there will be ways to optimize that if you have perf problems"><span class="u" id="1513183061.000313">2017:12:13 16:37:41           nathanmarz </span><span>you can do the </span><code>(apply multi-path some-list)</code><span> but there will be ways to optimize that if you have perf problems</span></div><div data-t="nathanmarz (selected? (multi-path :key1 :key2) (multi-path (pred= &quot;wow&quot;) #&quot;some-regex&quot;))"><span class="u" id="1513183167.000396">2017:12:13 16:39:27           nathanmarz </span><code>(selected? (multi-path :key1 :key2) (multi-path (pred= &quot;wow&quot;) #&quot;some-regex&quot;))</code></div><div data-t="nathanmarz that would check that either :key1 or :key2 is either &quot;wow&quot; or matches that regex"><span class="u" id="1513183192.000514">2017:12:13 16:39:52           nathanmarz </span><span>that would check that either :key1 or :key2 is either &quot;wow&quot; or matches that regex</span></div><div data-t="abdullahibra i got this"><span class="u" id="1513183212.000054">2017:12:13 16:40:12         abdullahibra </span><span>i got this</span></div><div data-t="abdullahibra but if i would like to match :name is &quot;wow&quot; AND :sen is &quot;good&quot;"><span class="u" id="1513183233.000389">2017:12:13 16:40:33         abdullahibra </span><span>but if i would like to match :name is &quot;wow&quot; AND :sen is &quot;good&quot;</span></div><div data-t="abdullahibra so i don&apos;t get match for :name &quot;wow&quot; and :sen &quot;nothing&quot;"><span class="u" id="1513183261.000184">2017:12:13 16:41:01         abdullahibra </span><span>so i don&apos;t get match for :name &quot;wow&quot; and :sen &quot;nothing&quot;</span></div><div data-t="nathanmarz [#(= &quot;wow&quot; (:name %)) #(= &quot;good&quot; (:sen %))]"><span class="u" id="1513183272.000582">2017:12:13 16:41:12           nathanmarz </span><code>[#(= &quot;wow&quot; (:name %)) #(= &quot;good&quot; (:sen %))]</code></div><div data-t="abdullahibra without multipath ?"><span class="u" id="1513183296.000966">2017:12:13 16:41:36         abdullahibra </span><span>without multipath ?</span></div><div data-t="nathanmarz multi-path  navigates to multiple paths"><span class="u" id="1513183355.000026">2017:12:13 16:42:35           nathanmarz </span><code>multi-path</code><span> navigates to multiple paths</span></div><div data-t="nathanmarz for &quot;and&quot;, it&apos;s just multiple navigators in a row, for &quot;or&quot; it&apos;s  (selected? (multi-path ...))"><span class="u" id="1513183385.000392">2017:12:13 16:43:05           nathanmarz </span><span>for &quot;and&quot;, it&apos;s just multiple navigators in a row, for &quot;or&quot; it&apos;s </span><code>(selected? (multi-path ...))</code></div><div data-t="abdullahibra ah okay got this"><span class="u" id="1513183399.000014">2017:12:13 16:43:19         abdullahibra </span><span>ah okay got this</span></div><div data-t="nathanmarz these are just how those concepts emerge from navigation"><span class="u" id="1513183455.000249">2017:12:13 16:44:15           nathanmarz </span><span>these are just how those concepts emerge from navigation</span></div><div data-t="abdullahibra hi guys"><span class="u" id="1513252190.000046">2017:12:14 11:49:50         abdullahibra </span><span>hi guys</span></div><div data-t="abdullahibra for this data:"><span class="u" id="1513252194.000390">2017:12:14 11:49:54         abdullahibra </span><span>for this data:</span></div><div data-t="abdullahibra [{:s1 &quot;cool&quot;, :p1 [{:name &quot;hello&quot;, :sen &quot;good&quot;} {:name &quot;world&quot;, :sen &quot;nothing&quot;}]} {:s2 &quot;cool2&quot;, :p1 [{:name &quot;wow&quot;, :sen &quot;fine&quot;} {:name &quot;world&quot;, :sen &quot;none&quot;}]}][{:s1 &quot;cool&quot;, :p1 [{:name &quot;hello&quot;, :sen &quot;good&quot;} {:name &quot;world&quot;, :sen &quot;nothing&quot;}]}]"><span class="u" id="1513252204.000502">2017:12:14 11:50:04         abdullahibra </span><span>[{:s1 &quot;cool&quot;, :p1 [{:name &quot;hello&quot;, :sen &quot;good&quot;} {:name &quot;world&quot;, :sen &quot;nothing&quot;}]} {:s2 &quot;cool2&quot;, :p1 [{:name &quot;wow&quot;, :sen &quot;fine&quot;} {:name &quot;world&quot;, :sen &quot;none&quot;}]}][{:s1 &quot;cool&quot;, :p1 [{:name &quot;hello&quot;, :sen &quot;good&quot;} {:name &quot;world&quot;, :sen &quot;nothing&quot;}]}]</span></div><div data-t="abdullahibra i want to get only hash maps which contain :name &quot;world&quot; and :sen &quot;nothing&quot;"><span class="u" id="1513252236.000239">2017:12:14 11:50:36         abdullahibra </span><span>i want to get only hash maps which contain :name &quot;world&quot; and :sen &quot;nothing&quot;</span></div><div data-t="abdullahibra i have tried:"><span class="u" id="1513252252.000279">2017:12:14 11:50:52         abdullahibra </span><span>i have tried:</span></div><div data-t="abdullahibra (select [ALL (selected? :p1 ALL (multi-path :token :sen) [#(= &quot;world&quot; (:name %)) #(= &quot;nothing&quot; (:sen %))])] data)"><span class="u" id="1513252255.000029">2017:12:14 11:50:55         abdullahibra </span><span>(select [ALL (selected? :p1 ALL (multi-path :token :sen) [#(= &quot;world&quot; (:name %)) #(= &quot;nothing&quot; (:sen %))])] data)</span></div><div data-t="abdullahibra @nathanmarz"><span class="u" id="1513252303.000063">2017:12:14 11:51:43         abdullahibra </span><span>@nathanmarz</span></div><div data-t="nathanmarz @abdullahibra  (select [ALL (selected? :p1 ALL #(= (:name %) &quot;world&quot;) #(= (:sen %) &quot;nothing&quot;))] data)"><span class="u" id="1513256497.000333">2017:12:14 13:01:37           nathanmarz </span><span>@abdullahibra </span><code>(select [ALL (selected? :p1 ALL #(= (:name %) &quot;world&quot;) #(= (:sen %) &quot;nothing&quot;))] data)</code></div><div data-t="abdullahibra thanks man  🙂 , your video is very worthwhile i have watched it"><span class="u" id="1513259569.000115">2017:12:14 13:52:49         abdullahibra </span><span>thanks man </span><b>🙂</b><span>, your video is very worthwhile i have watched it</span></div><div data-t="nathanmarz @abdullahibra thanks"><span class="u" id="1513261612.000435">2017:12:14 14:26:52           nathanmarz </span><span>@abdullahibra thanks</span></div><div data-t="nathanmarz it&apos;s pretty out of date though, my blog post is the best introductory resource"><span class="u" id="1513261639.000511">2017:12:14 14:27:19           nathanmarz </span><span>it&apos;s pretty out of date though, my blog post is the best introductory resource</span></div><div data-t="benstox Hi there, a question about walkers. If I have a data structure like this and I want to get all the leaves that have more than just whitespace in them, but still return the structure where they live:
 (def structure [
  &quot;leaf1&quot;
  &quot;\n&quot;
  {:contents [
    {:contents [&quot;leaf3&quot;]}
    {:contents [
      {:contents [
        &quot;leaf5&quot;
        &quot;leaf6&quot;
        &quot;\n&quot;]}]}
    &quot;\n&quot;
    {:contents [
      &quot;\n&quot;
      &quot;\n&quot;]}]}
  {:contents [
    &quot;leaf2&quot;
    {:contents []}]}
  &quot;leaf4&quot;])
 
So I’d hope to return a structure like this:
 [
  &quot;leaf1&quot;
  {:contents [
    {:contents [&quot;leaf3&quot;]}
    {:contents [
      {:contents [
        &quot;leaf5&quot;
        &quot;leaf6&quot;]}]}]}
  {:contents [&quot;leaf2&quot;]}
  &quot;leaf4&quot;]
 
I can get all the right leaves but not the structure with this:
 (select [(walker #(and (string? %) (re-find #&quot;\S&quot; %)))] structure)
 
I thought maybe  filterer  would be the right tool for this but couldn’t get it to work. Am I going about this the right way?"><span class="u" id="1513261674.000128">2017:12:14 14:27:54              benstox </span><span>Hi there, a question about walkers. If I have a data structure like this and I want to get all the leaves that have more than just whitespace in them, but still return the structure where they live:
</span><pre>(def structure [
  &quot;leaf1&quot;
  &quot;\n&quot;
  {:contents [
    {:contents [&quot;leaf3&quot;]}
    {:contents [
      {:contents [
        &quot;leaf5&quot;
        &quot;leaf6&quot;
        &quot;\n&quot;]}]}
    &quot;\n&quot;
    {:contents [
      &quot;\n&quot;
      &quot;\n&quot;]}]}
  {:contents [
    &quot;leaf2&quot;
    {:contents []}]}
  &quot;leaf4&quot;])
</pre><span>
So I’d hope to return a structure like this:
</span><pre>[
  &quot;leaf1&quot;
  {:contents [
    {:contents [&quot;leaf3&quot;]}
    {:contents [
      {:contents [
        &quot;leaf5&quot;
        &quot;leaf6&quot;]}]}]}
  {:contents [&quot;leaf2&quot;]}
  &quot;leaf4&quot;]
</pre><span>
I can get all the right leaves but not the structure with this:
</span><pre>(select [(walker #(and (string? %) (re-find #&quot;\S&quot; %)))] structure)
</pre><span>
I thought maybe </span><code>filterer</code><span> would be the right tool for this but couldn’t get it to work. Am I going about this the right way?</span></div><div data-t="nathanmarz @benstox the right approach is to do a  transform  and remove elements that have whitespace"><span class="u" id="1513263665.000184">2017:12:14 15:01:05           nathanmarz </span><span>@benstox the right approach is to do a </span><code>transform</code><span> and remove elements that have whitespace</span></div><div data-t="nathanmarz don&apos;t use  walker"><span class="u" id="1513263675.000216">2017:12:14 15:01:15           nathanmarz </span><span>don&apos;t use </span><code>walker</code></div><div data-t="nathanmarz (def NODES
  (recursive-path [] p
    (continue-then-stay
      (cond-path vector? [ALL p]
                 map? [MAP-VALS p])
      )))

(defn whitespace? [s] (= &quot;\n&quot; s))

(setval [NODES (if-path string? whitespace? empty?)] NONE structure)
"><span class="u" id="1513263896.000527">2017:12:14 15:04:56           nathanmarz </span><pre>(def NODES
  (recursive-path [] p
    (continue-then-stay
      (cond-path vector? [ALL p]
                 map? [MAP-VALS p])
      )))

(defn whitespace? [s] (= &quot;\n&quot; s))

(setval [NODES (if-path string? whitespace? empty?)] NONE structure)
</pre></div><div data-t="nathanmarz just fill in  whitespace?  with a complete implementation"><span class="u" id="1513263943.000398">2017:12:14 15:05:43           nathanmarz </span><span>just fill in </span><code>whitespace?</code><span> with a complete implementation</span></div><div data-t="benstox I see. Thanks a lot! I’ll try something like that."><span class="u" id="1513264106.000167">2017:12:14 15:08:26              benstox </span><span>I see. Thanks a lot! I’ll try something like that.</span></div><div data-t="jrheard hi, specter rookie here, i’m sure there’s a simple way to do this:"><span class="u" id="1513298680.000078">2017:12:15 00:44:40              jrheard </span><span>hi, specter rookie here, i’m sure there’s a simple way to do this:</span></div><div data-t="jrheard i have a  grid , which is a vector of vectors of values; those values are either numbers or nil"><span class="u" id="1513298693.000199">2017:12:15 00:44:53              jrheard </span><span>i have a </span><code>grid</code><span>, which is a vector of vectors of values; those values are either numbers or nil</span></div><div data-t="jrheard i’d like to write a specter query that gets me the indexes of all non-nil elements in  grid"><span class="u" id="1513298717.000271">2017:12:15 00:45:17              jrheard </span><span>i’d like to write a specter query that gets me the indexes of all non-nil elements in </span><code>grid</code></div><div data-t="jrheard i can get the non-nil elements themselves by doing
 (select [ALL ALL (comp not nil?)]
                  (@app-state :grid))
 
which gives me eg  (8 2 3 5 7)"><span class="u" id="1513298756.000231">2017:12:15 00:45:56              jrheard </span><span>i can get the non-nil elements themselves by doing
</span><pre>(select [ALL ALL (comp not nil?)]
                  (@app-state :grid))
</pre><span>
which gives me eg </span><code>(8 2 3 5 7)</code></div><div data-t="jrheard but i’d like instead to be given eg  ([5 3] [2 2] [3 1] [6 1] [4 2])  or whatever"><span class="u" id="1513298775.000341">2017:12:15 00:46:15              jrheard </span><span>but i’d like instead to be given eg </span><code>([5 3] [2 2] [3 1] [6 1] [4 2])</code><span> or whatever</span></div><div data-t="jrheard i.e. a list of the locations of those non-nil values in the grid, encoded as x-y pairs"><span class="u" id="1513298798.000051">2017:12:15 00:46:38              jrheard </span><span>i.e. a list of the locations of those non-nil values in the grid, encoded as x-y pairs</span></div><div data-t="jrheard the vanilla clojure code i have to do this is  (apply concat
         (for [x (range (count grid))]
           (for [y (range (count (grid x)))
                 :when (not (nil? (get-in grid [x y])))]
             [x y])))) , but i have a comment above it saying “; xxx is there a way to do this in specter”, so here i am  🙂  thanks!"><span class="u" id="1513299046.000095">2017:12:15 00:50:46              jrheard </span><span>the vanilla clojure code i have to do this is </span><pre>(apply concat
         (for [x (range (count grid))]
           (for [y (range (count (grid x)))
                 :when (not (nil? (get-in grid [x y])))]
             [x y]))))</pre><span>, but i have a comment above it saying “; xxx is there a way to do this in specter”, so here i am </span><b>🙂</b><span> thanks!</span></div><div data-t="nathanmarz @jrheard like this:  (select [INDEXED-VALS (collect-one FIRST) LAST INDEXED-VALS (selected? LAST some?) FIRST] grid)"><span class="u" id="1513305827.000130">2017:12:15 02:43:47           nathanmarz </span><span>@jrheard like this: </span><code>(select [INDEXED-VALS (collect-one FIRST) LAST INDEXED-VALS (selected? LAST some?) FIRST] grid)</code></div><div data-t="nathanmarz will be a lot faster than that clojure code too"><span class="u" id="1513305859.000047">2017:12:15 02:44:19           nathanmarz </span><span>will be a lot faster than that clojure code too</span></div><div data-t="mbjarland @nathanmarz The dependency chain we discussed yesterday is a step closer to completion, the pull request on suchwow was accepted, I&apos;ve created a ticket on midje and we&apos;re waiting for build to get deployed to clojars for suchwow ( https://github.com/marick/Midje/issues/427 )"><span class="u" id="1513343621.000186">2017:12:15 13:13:41            mbjarland </span><span>@nathanmarz The dependency chain we discussed yesterday is a step closer to completion, the pull request on suchwow was accepted, I&apos;ve created a ticket on midje and we&apos;re waiting for build to get deployed to clojars for suchwow (</span><a href="https://github.com/marick/Midje/issues/427">https://github.com/marick/Midje/issues/427</a><span>)</span></div><div data-t="nathanmarz @mbjarland ok, that&apos;s good"><span class="u" id="1513361990.000285">2017:12:15 18:19:50           nathanmarz </span><span>@mbjarland ok, that&apos;s good</span></div><div data-t="nathanmarz btw, have you tried just overriding the dependency with the latest version? should make the warning go away"><span class="u" id="1513362016.000215">2017:12:15 18:20:16           nathanmarz </span><span>btw, have you tried just overriding the dependency with the latest version? should make the warning go away</span></div><div data-t="mbjarland @nathanmarz no haven’t done that yet and really, it’s just a warning during a test run so not that big a deal to begin with. I’m happy to wait for the transitive chain to percolate up to midje"><span class="u" id="1513362931.000318">2017:12:15 18:35:31            mbjarland </span><span>@nathanmarz no haven’t done that yet and really, it’s just a warning during a test run so not that big a deal to begin with. I’m happy to wait for the transitive chain to percolate up to midje</span></div><div data-t="jrheard thanks! that does give the same results, excellent"><span class="u" id="1513377035.000320">2017:12:15 22:30:35              jrheard </span><span>thanks! that does give the same results, excellent</span></div><div data-t="jrheard i don’t yet understand what the collecting-values is system is / how it works, will read the docs more closely!"><span class="u" id="1513377074.000200">2017:12:15 22:31:14              jrheard </span><span>i don’t yet understand what the collecting-values is system is / how it works, will read the docs more closely!</span></div><div data-t="jrheard the README makes it look pretty clear, i think i’ve just gotta play around with specter some more to build up some muscle memory and get to a point where this feels more natural  🙂"><span class="u" id="1513377180.000074">2017:12:15 22:33:00              jrheard </span><span>the README makes it look pretty clear, i think i’ve just gotta play around with specter some more to build up some muscle memory and get to a point where this feels more natural </span><b>🙂</b></div><div data-t="jrheard the examples at  https://github.com/nathanmarz/specter/wiki/List-of-Navigators#collect  are v helpful"><span class="u" id="1513377287.000132">2017:12:15 22:34:47              jrheard </span><span>the examples at </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#collect">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#collect</a><span> are v helpful</span></div><div data-t="nathanmarz @jrheard collected values are a vector that is passed along through navigation"><span class="u" id="1513378055.000069">2017:12:15 22:47:35           nathanmarz </span><span>@jrheard collected values are a vector that is passed along through navigation</span></div><div data-t="nathanmarz you can see the interface here:  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L3"><span class="u" id="1513378069.000053">2017:12:15 22:47:49           nathanmarz </span><span>you can see the interface here: </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L3">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L3</a></div><div data-t="jrheard and the result of the selection is basically (concat collected-values value-you-navigated-to) ?"><span class="u" id="1513378088.000080">2017:12:15 22:48:08              jrheard </span><span>and the result of the selection is basically (concat collected-values value-you-navigated-to) ?</span></div><div data-t="nathanmarz yes"><span class="u" id="1513378127.000076">2017:12:15 22:48:47           nathanmarz </span><span>yes</span></div><div data-t="jrheard sick"><span class="u" id="1513378130.000005">2017:12:15 22:48:50              jrheard </span><span>sick</span></div><div data-t="nathanmarz conj , not  concat"><span class="u" id="1513378132.000049">2017:12:15 22:48:52           nathanmarz </span><code>conj</code><span>, not </span><code>concat</code></div><div data-t="jrheard aha"><span class="u" id="1513378134.000337">2017:12:15 22:48:54              jrheard </span><span>aha</span></div><div data-t="jrheard right, i follow"><span class="u" id="1513378150.000240">2017:12:15 22:49:10              jrheard </span><span>right, i follow</span></div><div data-t="jrheard thanks!  🙂"><span class="u" id="1513378153.000116">2017:12:15 22:49:13              jrheard </span><span>thanks! </span><b>🙂</b></div><div data-t="jrheard thanks again for the help with my grid example, i wouldn’t have come up with that specter code but it makes a lot of sense to me now!"><span class="u" id="1513378184.000146">2017:12:15 22:49:44              jrheard </span><span>thanks again for the help with my grid example, i wouldn’t have come up with that specter code but it makes a lot of sense to me now!</span></div><div data-t="nathanmarz here&apos;s where it happens:  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L285"><span class="u" id="1513378218.000097">2017:12:15 22:50:18           nathanmarz </span><span>here&apos;s where it happens: </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L285">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L285</a></div><div data-t="jrheard niice"><span class="u" id="1513378238.000273">2017:12:15 22:50:38              jrheard </span><span>niice</span></div><div data-t="jrheard is there a natural way to use  srange , like, backward?"><span class="u" id="1513452476.000066">2017:12:16 19:27:56              jrheard </span><span>is there a natural way to use </span><code>srange</code><span>, like, backward?</span></div><div data-t="jrheard begin unreasonably long context dump for which i am greatly sorry:
again, i have a 2d grid of values that are integers or nil"><span class="u" id="1513452484.000022">2017:12:16 19:28:04              jrheard </span><span>begin unreasonably long context dump for which i am greatly sorry:
again, i have a 2d grid of values that are integers or nil</span></div><div data-t="jrheard i need to start at a particular x,y point on the grid and get the values seen as you walk four steps in each of the cardinal directions from that x,y point"><span class="u" id="1513452520.000020">2017:12:16 19:28:40              jrheard </span><span>i need to start at a particular x,y point on the grid and get the values seen as you walk four steps in each of the cardinal directions from that x,y point</span></div><div data-t="jrheard i call these “runs”, they’re related to the logic of this game i’m programming"><span class="u" id="1513452545.000106">2017:12:16 19:29:05              jrheard </span><span>i call these “runs”, they’re related to the logic of this game i’m programming</span></div><div data-t="jrheard so far, getting the right run and the down run is pretty straightforward:"><span class="u" id="1513452558.000054">2017:12:16 19:29:18              jrheard </span><span>so far, getting the right run and the down run is pretty straightforward:</span></div><div data-t="jrheard (let [x 6
        y 8]
    {:right-run (select [(srange (inc x) (+ x MAX-RUN-LENGTH)) ALL
                         y]
                        (@app-state :grid))
     :down-run (select [x
                        (srange (inc y) (+ y MAX-RUN-LENGTH)) ALL]
                       (@app-state :grid))
     })"><span class="u" id="1513452569.000005">2017:12:16 19:29:29              jrheard </span><pre>(let [x 6
        y 8]
    {:right-run (select [(srange (inc x) (+ x MAX-RUN-LENGTH)) ALL
                         y]
                        (@app-state :grid))
     :down-run (select [x
                        (srange (inc y) (+ y MAX-RUN-LENGTH)) ALL]
                       (@app-state :grid))
     })</pre></div><div data-t="jrheard but i’m having trouble figuring out how to do the left and up runs"><span class="u" id="1513452629.000026">2017:12:16 19:30:29              jrheard </span><span>but i’m having trouble figuring out how to do the left and up runs</span></div><div data-t="jrheard i could do it by hand in each of those cases - eg, if you’re going left, then in that situation you do  (srange (- x MAX-RUN-LENGTH) x)"><span class="u" id="1513452696.000091">2017:12:16 19:31:36              jrheard </span><span>i could do it by hand in each of those cases - eg, if you’re going left, then in that situation you do </span><code>(srange (- x MAX-RUN-LENGTH) x)</code></div><div data-t="jrheard maybe that’s just the sanest thing to do here"><span class="u" id="1513452725.000076">2017:12:16 19:32:05              jrheard </span><span>maybe that’s just the sanest thing to do here</span></div><div data-t="jrheard my preexisting clojure code involved a function (find-runs [x y xdir ydir]), with invocations like  (find-runs x y 0 -1) , and so inside that function you’ve got a single bit of run-finding code that can handle any of the four cardinal directions"><span class="u" id="1513452783.000132">2017:12:16 19:33:03              jrheard </span><span>my preexisting clojure code involved a function (find-runs [x y xdir ydir]), with invocations like </span><code>(find-runs x y 0 -1)</code><span>, and so inside that function you’ve got a single bit of run-finding code that can handle any of the four cardinal directions</span></div><div data-t="jrheard but it looks like if i want to specterize this code, the sanest thing is to write four specter  select  calls by hand, rather than reimplement  (find-runs x y xdir ydir)  in a way that uses a single  select  call whose path is heavily parameterized? apologies if any of this is foolish / obvious / doesn’t make any sense"><span class="u" id="1513452830.000082">2017:12:16 19:33:50              jrheard </span><span>but it looks like if i want to specterize this code, the sanest thing is to write four specter </span><code>select</code><span> calls by hand, rather than reimplement </span><code>(find-runs x y xdir ydir)</code><span> in a way that uses a single </span><code>select</code><span> call whose path is heavily parameterized? apologies if any of this is foolish / obvious / doesn’t make any sense</span></div><div data-t="jrheard preexisting implementation of  find-runs  in case it’s helpful:"><span class="u" id="1513452919.000119">2017:12:16 19:35:19              jrheard </span><span>preexisting implementation of </span><code>find-runs</code><span> in case it’s helpful:</span></div><div data-t="jrheard (reduce (fn [[run-length run-sum] num-steps-in-direction]
     ; Find the position of the cell we&apos;re currently examining.
     (let [run-x (+ x (* xdir num-steps-in-direction))
           run-y (+ y (* ydir num-steps-in-direction))]
       (if (or (not (cell-is-on-grid grid run-x run-y))
               (nil? (get-in grid [run-x run-y])))
         ; If the cell&apos;s value is nil or this position is off the grid, the run is over.
         (reduced [run-length run-sum])
         ; Otherwise, record this cell&apos;s value and continue following the run.
         [(inc run-length)
          (+ run-sum (get-in grid [run-x run-y]))])))
   [0 0]
   (map inc (range)))"><span class="u" id="1513452923.000072">2017:12:16 19:35:23              jrheard </span><pre>(reduce (fn [[run-length run-sum] num-steps-in-direction]
     ; Find the position of the cell we&apos;re currently examining.
     (let [run-x (+ x (* xdir num-steps-in-direction))
           run-y (+ y (* ydir num-steps-in-direction))]
       (if (or (not (cell-is-on-grid grid run-x run-y))
               (nil? (get-in grid [run-x run-y])))
         ; If the cell&apos;s value is nil or this position is off the grid, the run is over.
         (reduced [run-length run-sum])
         ; Otherwise, record this cell&apos;s value and continue following the run.
         [(inc run-length)
          (+ run-sum (get-in grid [run-x run-y]))])))
   [0 0]
   (map inc (range)))</pre></div><div data-t="jrheard the end goal here is to come up with a “run”, which is essentially  [(count run-values) (apply + run-values)]"><span class="u" id="1513452998.000066">2017:12:16 19:36:38              jrheard </span><span>the end goal here is to come up with a “run”, which is essentially </span><code>[(count run-values) (apply + run-values)]</code></div><div data-t="jrheard and again, the main problem i’m having trouble with is figuring out whether it’s sanely possible to write a single  select  call that’s parameterized on  x ,  y ,  xdir , and  ydir , or if that  select  call would be too grody and i should instead write four single-purpose  select  calls by hand"><span class="u" id="1513453083.000023">2017:12:16 19:38:03              jrheard </span><span>and again, the main problem i’m having trouble with is figuring out whether it’s sanely possible to write a single </span><code>select</code><span> call that’s parameterized on </span><code>x</code><span>, </span><code>y</code><span>, </span><code>xdir</code><span>, and </span><code>ydir</code><span>, or if that </span><code>select</code><span> call would be too grody and i should instead write four single-purpose </span><code>select</code><span> calls by hand</span></div><div data-t="jrheard i’ll do the by-hand approach for now, this is a toy project and doesn’t matter, but thanks in advance for your time and advice!  🙂"><span class="u" id="1513453114.000060">2017:12:16 19:38:34              jrheard </span><span>i’ll do the by-hand approach for now, this is a toy project and doesn’t matter, but thanks in advance for your time and advice! </span><b>🙂</b></div><div data-t="jrheard here’s what i ended up with: 
 (defn grid-range [start end direction]
  (srange (max start 0)
          (min end (if (= direction :horizontal)
                     GRID-WIDTH
                     GRID-HEIGHT))))

(let [x 6
      y 4]
  {:right-run (select [(grid-range (inc x) (+ x MAX-RUN-LENGTH) :horizontal) ALL
                       y]
                      (@app-state :grid))
   :down-run  (select [x
                       (grid-range (inc y) (+ y MAX-RUN-LENGTH) :vertical) ALL]
                      (@app-state :grid))
   :left-run  (select [(grid-range (- x (dec MAX-RUN-LENGTH)) x :horizontal) ALL
                       y]
                      (@app-state :grid))
   :up-run    (select [x
                       (grid-range (- y (dec MAX-RUN-LENGTH)) y :vertical) ALL]
                      (@app-state :grid))})
 
the sanest way i can think to clean it up is to make a function like eg  (get-run-selector-path x y :left) , which is implemented with just a  cond  with four branches, and the  :left  branch looks  like  [(grid-range (- x (dec MAX-RUN-LENGTH)) x :horizontal) ALL y] , etc; maybe there’s a saner thing to do here though?"><span class="u" id="1513453709.000030">2017:12:16 19:48:29              jrheard </span><span>here’s what i ended up with: 
</span><pre>(defn grid-range [start end direction]
  (srange (max start 0)
          (min end (if (= direction :horizontal)
                     GRID-WIDTH
                     GRID-HEIGHT))))

(let [x 6
      y 4]
  {:right-run (select [(grid-range (inc x) (+ x MAX-RUN-LENGTH) :horizontal) ALL
                       y]
                      (@app-state :grid))
   :down-run  (select [x
                       (grid-range (inc y) (+ y MAX-RUN-LENGTH) :vertical) ALL]
                      (@app-state :grid))
   :left-run  (select [(grid-range (- x (dec MAX-RUN-LENGTH)) x :horizontal) ALL
                       y]
                      (@app-state :grid))
   :up-run    (select [x
                       (grid-range (- y (dec MAX-RUN-LENGTH)) y :vertical) ALL]
                      (@app-state :grid))})
</pre><span>
the sanest way i can think to clean it up is to make a function like eg </span><code>(get-run-selector-path x y :left)</code><span>, which is implemented with just a </span><code>cond</code><span> with four branches, and the </span><code>:left</code><span> branch looks  like </span><code>[(grid-range (- x (dec MAX-RUN-LENGTH)) x :horizontal) ALL y]</code><span>, etc; maybe there’s a saner thing to do here though?</span></div><div data-t="jrheard all this is further complicated by the fact that i’d like all the runs’ values to be in order based on their direction from the origin cell because a “run” just means “a series of values in a row, in each cardinal direction, starting at this cell but excluding this cell’s value, with maximum length 4, stopping as soon as you see your first nil”."><span class="u" id="1513454076.000166">2017:12:16 19:54:36              jrheard </span><span>all this is further complicated by the fact that i’d like all the runs’ values to be in order based on their direction from the origin cell because a “run” just means “a series of values in a row, in each cardinal direction, starting at this cell but excluding this cell’s value, with maximum length 4, stopping as soon as you see your first nil”.</span></div><div data-t="jrheard so i’ll need to end up reversing  left-run  and  up-run  and then call  (take-until nil the-run)  on each of my four runs. and at the end of the day i’m like, maybe the end result in specter will be insane and i should just stick with my preexisting implementation, which is looking way better now that i’m comparing the two? and if so, that’s totally cool. again, sorry for the wall of text!"><span class="u" id="1513454122.000065">2017:12:16 19:55:22              jrheard </span><span>so i’ll need to end up reversing </span><code>left-run</code><span> and </span><code>up-run</code><span> and then call </span><code>(take-until nil the-run)</code><span> on each of my four runs. and at the end of the day i’m like, maybe the end result in specter will be insane and i should just stick with my preexisting implementation, which is looking way better now that i’m comparing the two? and if so, that’s totally cool. again, sorry for the wall of text!</span></div><div data-t="jrheard in case it’s helpful, the game board looks like this:  http://jrheard.com/quinto/ 

the “make a move” button has the AI detect the highest-scoring possible move and make it. there isn’t yet a way for the user to make a move, and there isn’t yet a visible score or any explanation of how the game works. the game’s basically scrabble but for numbers, the goal is to make “runs” of numbers that sum up to a multiple of five, it’s called quinto, my friend found it at goodwill and it seems like basically zero people in the world have ever played it"><span class="u" id="1513454636.000090">2017:12:16 20:03:56              jrheard </span><span>in case it’s helpful, the game board looks like this: </span><a href="http://jrheard.com/quinto/">http://jrheard.com/quinto/</a><span>

the “make a move” button has the AI detect the highest-scoring possible move and make it. there isn’t yet a way for the user to make a move, and there isn’t yet a visible score or any explanation of how the game works. the game’s basically scrabble but for numbers, the goal is to make “runs” of numbers that sum up to a multiple of five, it’s called quinto, my friend found it at goodwill and it seems like basically zero people in the world have ever played it</span></div><div data-t="nathanmarz @jrheard your use case is probably best handled with matrix-specific navigators"><span class="u" id="1513460315.000017">2017:12:16 21:38:35           nathanmarz </span><span>@jrheard your use case is probably best handled with matrix-specific navigators</span></div><div data-t="nathanmarz here&apos;s an excerpt from some code I have:
 (defnav matrix-elem [row col]
  (select* [this structure next-fn]
    (next-fn (-&gt; structure :rows (nth row) (nth col)))
    )
  (transform* [this structure next-fn]
    (let [rows (:rows structure)
          r (nth rows row)
          new-elem (next-fn (nth r col))]
      (-&gt;Matrix (assoc rows row (assoc r col new-elem)))
      )))
"><span class="u" id="1513460360.000005">2017:12:16 21:39:20           nathanmarz </span><span>here&apos;s an excerpt from some code I have:
</span><pre>(defnav matrix-elem [row col]
  (select* [this structure next-fn]
    (next-fn (-&gt; structure :rows (nth row) (nth col)))
    )
  (transform* [this structure next-fn]
    (let [rows (:rows structure)
          r (nth rows row)
          new-elem (next-fn (nth r col))]
      (-&gt;Matrix (assoc rows row (assoc r col new-elem)))
      )))
</pre></div><div data-t="nathanmarz you could also make a &quot;submat&quot; navigator that navigates you to a submatrix"><span class="u" id="1513460398.000009">2017:12:16 21:39:58           nathanmarz </span><span>you could also make a &quot;submat&quot; navigator that navigates you to a submatrix</span></div><div data-t="nathanmarz then you could do something like  (select [(submat 4 2 8 2) ALL ALL] mat)  to get the &quot;down run&quot;"><span class="u" id="1513460491.000037">2017:12:16 21:41:31           nathanmarz </span><span>then you could do something like </span><code>(select [(submat 4 2 8 2) ALL ALL] mat)</code><span> to get the &quot;down run&quot;</span></div><div data-t="nathanmarz for a less flexible approach you could have a  submat-elems  function like so:
 (defnav matrix-elem [row col]
  (select* [this structure next-fn]
    (next-fn (-&gt; structure(nth row) (nth col)))
    )
  (transform* [this structure next-fn]
    (let [rows (:rows structure)
          r (nth rows row)
          new-elem (next-fn (nth r col))]
      (assoc rows row (assoc r col new-elem))
      )))

(defn ^:direct-nav submat-elems [row col row2 col2]
  (reduce
    multi-path
    (for [r (range row (inc row2))
          c (range col (inc col2))]
      (matrix-elem r c)
      )))

(def data
  [[1   2   3   4]
   [5   6   7   8]
   [9   :a  :b  :c]
   [:d  :e  :f  :g]])

(select (submat-elems 1 1 3 1) data)
;; =&gt; [6 :a :e]
"><span class="u" id="1513460833.000048">2017:12:16 21:47:13           nathanmarz </span><span>for a less flexible approach you could have a </span><code>submat-elems</code><span> function like so:
</span><pre>(defnav matrix-elem [row col]
  (select* [this structure next-fn]
    (next-fn (-&gt; structure(nth row) (nth col)))
    )
  (transform* [this structure next-fn]
    (let [rows (:rows structure)
          r (nth rows row)
          new-elem (next-fn (nth r col))]
      (assoc rows row (assoc r col new-elem))
      )))

(defn ^:direct-nav submat-elems [row col row2 col2]
  (reduce
    multi-path
    (for [r (range row (inc row2))
          c (range col (inc col2))]
      (matrix-elem r c)
      )))

(def data
  [[1   2   3   4]
   [5   6   7   8]
   [9   :a  :b  :c]
   [:d  :e  :f  :g]])

(select (submat-elems 1 1 3 1) data)
;; =&gt; [6 :a :e]
</pre></div><div data-t="nathanmarz technically you don&apos;t really need  matrix-elem  and can just use  nthpath"><span class="u" id="1513460910.000081">2017:12:16 21:48:30           nathanmarz </span><span>technically you don&apos;t really need </span><code>matrix-elem</code><span> and can just use </span><code>nthpath</code></div><div data-t="jrheard thanks nathan! i’ll take a closer look at this tomorrow, much appreciated!  🙂"><span class="u" id="1513477024.000040">2017:12:17 02:17:04              jrheard </span><span>thanks nathan! i’ll take a closer look at this tomorrow, much appreciated! </span><b>🙂</b></div><div data-t="jrheard that absolutely did what i wanted - i added bounds checking and added my desired reversing behavior when row2 &lt; row or col2 &lt; col, and ended up with this, which i haven’t tested thoroughly but seems to be correct so far:"><span class="u" id="1513549956.000129">2017:12:17 22:32:36              jrheard </span><span>that absolutely did what i wanted - i added bounds checking and added my desired reversing behavior when row2 &lt; row or col2 &lt; col, and ended up with this, which i haven’t tested thoroughly but seems to be correct so far:</span></div><div data-t="jrheard (defn ^:direct-nav grid-values
  [x1 y1 x2 y2]
  (if (g/cell-is-on-grid x1 y1)
    (let [x2 (bound-between x2 0 (dec GRID-WIDTH))
          y2 (bound-between y2 0 (dec GRID-HEIGHT))]

      (reduce
        multi-path
        (for [x (if (&lt; x1 x2)
                  (range x1 (inc x2))
                  (reverse (range x2 (inc x1))))
              y (if (&lt; y1 y2)
                  (range y1 (inc y2))
                  (reverse (range y2 (inc y1))))]
          (nthpath x y))))

    STOP))"><span class="u" id="1513549960.000094">2017:12:17 22:32:40              jrheard </span><pre>(defn ^:direct-nav grid-values
  [x1 y1 x2 y2]
  (if (g/cell-is-on-grid x1 y1)
    (let [x2 (bound-between x2 0 (dec GRID-WIDTH))
          y2 (bound-between y2 0 (dec GRID-HEIGHT))]

      (reduce
        multi-path
        (for [x (if (&lt; x1 x2)
                  (range x1 (inc x2))
                  (reverse (range x2 (inc x1))))
              y (if (&lt; y1 y2)
                  (range y1 (inc y2))
                  (reverse (range y2 (inc y1))))]
          (nthpath x y))))

    STOP))</pre></div><div data-t="jrheard thanks so much for your help, i really appreciate it!"><span class="u" id="1513549969.000099">2017:12:17 22:32:49              jrheard </span><span>thanks so much for your help, i really appreciate it!</span></div><div data-t="jrheard final usage ends up looking like this, replacing my reduce from earlier:
 (fn [xdir ydir]
   (let [values-in-direction (select (grid-values (+ x xdir)
                                                  (+ y ydir)
                                                  (+ x (* xdir MAX-RUN-LENGTH))
                                                  (+ y (* ydir MAX-RUN-LENGTH)))
                                     grid)
         run-values (take-while (comp not nil?) values-in-direction)]
     [(count run-values) (apply + run-values)]))"><span class="u" id="1513550541.000052">2017:12:17 22:42:21              jrheard </span><span>final usage ends up looking like this, replacing my reduce from earlier:
</span><pre>(fn [xdir ydir]
   (let [values-in-direction (select (grid-values (+ x xdir)
                                                  (+ y ydir)
                                                  (+ x (* xdir MAX-RUN-LENGTH))
                                                  (+ y (* ydir MAX-RUN-LENGTH)))
                                     grid)
         run-values (take-while (comp not nil?) values-in-direction)]
     [(count run-values) (apply + run-values)]))</pre></div><div data-t="jrheard seems to be way slower than my previous reduce implementation though, dang - likely some mistake on my end, will profile"><span class="u" id="1513550569.000109">2017:12:17 22:42:49              jrheard </span><span>seems to be way slower than my previous reduce implementation though, dang - likely some mistake on my end, will profile</span></div><div data-t="jrheard ok yeah now my program spends 88% of its time in com.rpl.specter.impl.mk_dynamic_path_maker"><span class="u" id="1513551325.000048">2017:12:17 22:55:25              jrheard </span><span>ok yeah now my program spends 88% of its time in com.rpl.specter.impl.mk_dynamic_path_maker</span></div><div data-t="jrheard the specterized code above is awesome though, i really like it way more than my handrolled reduce from yesterday - it untangles the computation into its component parts (first get a list of up to 5 values in this direction, then drop everything after and including the first nil, then count the values and sum them)"><span class="u" id="1513551432.000104">2017:12:17 22:57:12              jrheard </span><span>the specterized code above is awesome though, i really like it way more than my handrolled reduce from yesterday - it untangles the computation into its component parts (first get a list of up to 5 values in this direction, then drop everything after and including the first nil, then count the values and sum them)</span></div><div data-t="jrheard whereas my previous code did all those things at once"><span class="u" id="1513551440.000017">2017:12:17 22:57:20              jrheard </span><span>whereas my previous code did all those things at once</span></div><div data-t="jrheard so i remain a big fan of specter and also remain appreciative of your help, but am not sure how to proceed performancewise"><span class="u" id="1513551461.000018">2017:12:17 22:57:41              jrheard </span><span>so i remain a big fan of specter and also remain appreciative of your help, but am not sure how to proceed performancewise</span></div><div data-t="jrheard it’s the weekend, this is a toy project and non-urgent, no rush on a reply  🙂  thanks!"><span class="u" id="1513551483.000002">2017:12:17 22:58:03              jrheard </span><span>it’s the weekend, this is a toy project and non-urgent, no rush on a reply </span><b>🙂</b><span> thanks!</span></div><div data-t="jrheard if it’s helpful, a screenshot of the profile data:  https://www.evernote.com/shard/s11/sh/73bf32be-7f86-414d-adcb-d61279942fd2/b3618565f1ea939f  (percentages shown are different because i’ve filtered for com.rpl.specter, i believe)"><span class="u" id="1513551857.000065">2017:12:17 23:04:17              jrheard </span><span>if it’s helpful, a screenshot of the profile data: </span><a href="https://www.evernote.com/shard/s11/sh/73bf32be-7f86-414d-adcb-d61279942fd2/b3618565f1ea939f">https://www.evernote.com/shard/s11/sh/73bf32be-7f86-414d-adcb-d61279942fd2/b3618565f1ea939f</a><span> (percentages shown are different because i’ve filtered for com.rpl.specter, i believe)</span></div><div data-t="jrheard and the profile itself (55MB):  http://jrheard.com/quinto_specter_profile"><span class="u" id="1513552080.000044">2017:12:17 23:08:00              jrheard </span><span>and the profile itself (55MB): </span><a href="http://jrheard.com/quinto_specter_profile">http://jrheard.com/quinto_specter_profile</a></div><div data-t="nathanmarz @jrheard it would be a lot faster as a first-class navigator"><span class="u" id="1513552225.000003">2017:12:17 23:10:25           nathanmarz </span><span>@jrheard it would be a lot faster as a first-class navigator</span></div><div data-t="nathanmarz implementation would be similar to  ALL , except in two dimensions"><span class="u" id="1513552245.000037">2017:12:17 23:10:45           nathanmarz </span><span>implementation would be similar to </span><code>ALL</code><span>, except in two dimensions</span></div><div data-t="nathanmarz it would be easy to also avoid needing to do two  nth  per element, since you can do every matching value in a row one after another"><span class="u" id="1513552319.000006">2017:12:17 23:11:59           nathanmarz </span><span>it would be easy to also avoid needing to do two </span><code>nth</code><span> per element, since you can do every matching value in a row one after another</span></div><div data-t="jrheard interesting, thanks for the tip! i’ll read through the docs and investigate that line of attack"><span class="u" id="1513552377.000025">2017:12:17 23:12:57              jrheard </span><span>interesting, thanks for the tip! i’ll read through the docs and investigate that line of attack</span></div><div data-t="jrheard hm, can’t tell if this is a foolish question - would the implementation actually look more like  srange  rather than  all ? the main difference i see is that srange takes arguments  start  and  end , and my thing will also take arguments (`x1`,  y1 ,  x2 ,  y2 )"><span class="u" id="1513553489.000069">2017:12:17 23:31:29              jrheard </span><span>hm, can’t tell if this is a foolish question - would the implementation actually look more like </span><code>srange</code><span> rather than </span><code>all</code><span>? the main difference i see is that srange takes arguments </span><code>start</code><span> and </span><code>end</code><span>, and my thing will also take arguments (`x1`, </span><code>y1</code><span>, </span><code>x2</code><span>, </span><code>y2</code><span>)</span></div><div data-t="jrheard also, i notice that  ALL  uses  doseqres  (  https://github.com/nathanmarz/specter/blob/5efafd2d9bc2714fd87ff81b1268ae6f88256a81/src/clj/com/rpl/specter/util_macros.clj#L3  ) - should i figure out what doseqres does, or can i safely ignore it?"><span class="u" id="1513553531.000015">2017:12:17 23:32:11              jrheard </span><span>also, i notice that </span><code>ALL</code><span> uses </span><code>doseqres</code><span> ( </span><a href="https://github.com/nathanmarz/specter/blob/5efafd2d9bc2714fd87ff81b1268ae6f88256a81/src/clj/com/rpl/specter/util_macros.clj#L3">https://github.com/nathanmarz/specter/blob/5efafd2d9bc2714fd87ff81b1268ae6f88256a81/src/clj/com/rpl/specter/util_macros.clj#L3</a><span> ) - should i figure out what doseqres does, or can i safely ignore it?</span></div><div data-t="nathanmarz @jrheard I mean it&apos;s going to be similar in function, navigating to many subvalues of a data structure"><span class="u" id="1513554475.000092">2017:12:17 23:47:55           nathanmarz </span><span>@jrheard I mean it&apos;s going to be similar in function, navigating to many subvalues of a data structure</span></div><div data-t="jrheard gotcha"><span class="u" id="1513554486.000018">2017:12:17 23:48:06              jrheard </span><span>gotcha</span></div><div data-t="nathanmarz implementation-wise it will be very different"><span class="u" id="1513554486.000048">2017:12:17 23:48:06           nathanmarz </span><span>implementation-wise it will be very different</span></div><div data-t="jrheard i ended up with this, it’s 4-5x faster than the previous specter approach but still roughly (no benchmarks collected, going solely on how the app feels to use)  1.5-2x slower than the reduce approach. it’s also kind of hideous but that’s my fault:
 (defnav
  grid-values-2
  [x1 y1 x2 y2]
  (select* [this structure next-fn]
           (assert (or (= x1 x2)
                       (= y1 y2)))

           (next-fn
             (if (cell-is-on-grid x1 y1)
               (let [x2 (bound-between x2 0 (dec GRID-WIDTH))
                     y2 (bound-between y2 0 (dec GRID-HEIGHT))]
                 (if (= x1 x2)
                   (let [column (nth structure x1)]
                     (if (&lt; y1 y2)
                       (subvec column y1 (inc y2))
                       (reverse (subvec column y2 (inc y1)))))

                   (for [x (if (&lt; x1 x2)
                             (range x1 (inc x2))
                             (reverse (range x2 (inc x1))))]
                     (-&gt; structure
                         (nth x)
                         (nth y1)))))
               [])))

  (transform* [this structure next-fn]
              ; punting on this for now
              (assert false)))"><span class="u" id="1513555158.000092">2017:12:17 23:59:18              jrheard </span><span>i ended up with this, it’s 4-5x faster than the previous specter approach but still roughly (no benchmarks collected, going solely on how the app feels to use)  1.5-2x slower than the reduce approach. it’s also kind of hideous but that’s my fault:
</span><pre>(defnav
  grid-values-2
  [x1 y1 x2 y2]
  (select* [this structure next-fn]
           (assert (or (= x1 x2)
                       (= y1 y2)))

           (next-fn
             (if (cell-is-on-grid x1 y1)
               (let [x2 (bound-between x2 0 (dec GRID-WIDTH))
                     y2 (bound-between y2 0 (dec GRID-HEIGHT))]
                 (if (= x1 x2)
                   (let [column (nth structure x1)]
                     (if (&lt; y1 y2)
                       (subvec column y1 (inc y2))
                       (reverse (subvec column y2 (inc y1)))))

                   (for [x (if (&lt; x1 x2)
                             (range x1 (inc x2))
                             (reverse (range x2 (inc x1))))]
                     (-&gt; structure
                         (nth x)
                         (nth y1)))))
               [])))

  (transform* [this structure next-fn]
              ; punting on this for now
              (assert false)))</pre></div><div data-t="jrheard i’m sure there’s a better and faster way to express this, will stare at it until something comes to mind  😄"><span class="u" id="1513555209.000210">2017:12:18 00:00:09              jrheard </span><span>i’m sure there’s a better and faster way to express this, will stare at it until something comes to mind </span><b>😄</b></div><div data-t="jrheard hell, sometimes the performance seems noticeably slower, sometimes it seems precisely the same or even faster"><span class="u" id="1513555953.000068">2017:12:18 00:12:33              jrheard </span><span>hell, sometimes the performance seems noticeably slower, sometimes it seems precisely the same or even faster</span></div><div data-t="jrheard perf is actually pretty acceptable when run through advanced compliation, nice"><span class="u" id="1513556402.000063">2017:12:18 00:20:02              jrheard </span><span>perf is actually pretty acceptable when run through advanced compliation, nice</span></div><div data-t="jrheard benchmarking stuff now; as you’d expect, that code runs pretty fast ( [:attrs nil] 1400 ms in 1000000 runs) when x1 != x2"><span class="u" id="1513557115.000087">2017:12:18 00:31:55              jrheard </span><span>benchmarking stuff now; as you’d expect, that code runs pretty fast (</span><del>35ms in 1000000 runs) when x1 = x2, but about 50x slower (</del><span>1400 ms in 1000000 runs) when x1 != x2</span></div><div data-t="jrheard so the codepath i need to focus on optimizing is  (for [x (if (&lt; x1 x2)
          (range x1 (inc x2))
          (reverse (range x2 (inc x1))))]
  (-&gt; data
      (nth x)
      (nth y1)))  . hm - i’m actually not sure how to do this in a more performant way - the ranges and reverses don’t seem to be the issue afaict, it’s just the bit where we have to use nth to index into each column and then call nth on that column to find our value"><span class="u" id="1513557182.000006">2017:12:18 00:33:02              jrheard </span><span>so the codepath i need to focus on optimizing is </span><pre>(for [x (if (&lt; x1 x2)
          (range x1 (inc x2))
          (reverse (range x2 (inc x1))))]
  (-&gt; data
      (nth x)
      (nth y1)))</pre><span> . hm - i’m actually not sure how to do this in a more performant way - the ranges and reverses don’t seem to be the issue afaict, it’s just the bit where we have to use nth to index into each column and then call nth on that column to find our value</span></div><div data-t="nathanmarz @jrheard the  select*  codepath should call  next-fn  on each grid cell, rather than calling  next-fn  on a sequence of cells"><span class="u" id="1513562021.000097">2017:12:18 01:53:41           nathanmarz </span><span>@jrheard the </span><code>select*</code><span> codepath should call </span><code>next-fn</code><span> on each grid cell, rather than calling </span><code>next-fn</code><span> on a sequence of cells</span></div><div data-t="nathanmarz that will be a lot more performant"><span class="u" id="1513562027.000143">2017:12:18 01:53:47           nathanmarz </span><span>that will be a lot more performant</span></div><div data-t="jrheard o nice, i’ll try that"><span class="u" id="1513562031.000121">2017:12:18 01:53:51              jrheard </span><span>o nice, i’ll try that</span></div><div data-t="nathanmarz be sure to read the spec for  select* :  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L6"><span class="u" id="1513562065.000028">2017:12:18 01:54:25           nathanmarz </span><span>be sure to read the spec for </span><code>select*</code><span>: </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L6">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L6</a></div><div data-t="jrheard will do, thanks!"><span class="u" id="1513562125.000146">2017:12:18 01:55:25              jrheard </span><span>will do, thanks!</span></div><div data-t="jrheard hm, that may have caused a speedup but not a drastic one"><span class="u" id="1513569512.000137">2017:12:18 03:58:32              jrheard </span><span>hm, that may have caused a speedup but not a drastic one</span></div><div data-t="jrheard ended up with this:
 (defnav
  grid-values
  [x1 y1 x2 y2]
  (select* [this structure next-fn]
           (assert (or (= x1 x2)
                       (= y1 y2)))

           (if (not (cell-is-on-grid x1 y1))
             ; If your starting cell isn&apos;t on the grid, you get nothing.
             []

             (let [x2 (bound-between x2 0 (dec GRID-WIDTH))
                   y2 (bound-between y2 0 (dec GRID-HEIGHT))]

               (if (= x1 x2)
                 (let [column (nth structure x1)]
                   (doseq [value (if (&lt; y1 y2)
                                 (subvec column y1 (inc y2))
                                 (reverse (subvec column y2 (inc y1))))]
                     (next-fn value)))

                 (doseq [x (if (&lt; x1 x2)
                           (range x1 (inc x2))
                           (reverse (range x2 (inc x1))))]
                   (next-fn
                     (-&gt; structure
                         (nth x)
                         (nth y1))))))))"><span class="u" id="1513569527.000116">2017:12:18 03:58:47              jrheard </span><span>ended up with this:
</span><pre>(defnav
  grid-values
  [x1 y1 x2 y2]
  (select* [this structure next-fn]
           (assert (or (= x1 x2)
                       (= y1 y2)))

           (if (not (cell-is-on-grid x1 y1))
             ; If your starting cell isn&apos;t on the grid, you get nothing.
             []

             (let [x2 (bound-between x2 0 (dec GRID-WIDTH))
                   y2 (bound-between y2 0 (dec GRID-HEIGHT))]

               (if (= x1 x2)
                 (let [column (nth structure x1)]
                   (doseq [value (if (&lt; y1 y2)
                                 (subvec column y1 (inc y2))
                                 (reverse (subvec column y2 (inc y1))))]
                     (next-fn value)))

                 (doseq [x (if (&lt; x1 x2)
                           (range x1 (inc x2))
                           (reverse (range x2 (inc x1))))]
                   (next-fn
                     (-&gt; structure
                         (nth x)
                         (nth y1))))))))</pre></div><div data-t="jrheard i noticed i had to use  doseq  rather than  for  - presumably  next-fn  is side-effecty?"><span class="u" id="1513569538.000192">2017:12:18 03:58:58              jrheard </span><span>i noticed i had to use </span><code>doseq</code><span> rather than </span><code>for</code><span> - presumably </span><code>next-fn</code><span> is side-effecty?</span></div><div data-t="jrheard nbd, just interesting"><span class="u" id="1513569542.000235">2017:12:18 03:59:02              jrheard </span><span>nbd, just interesting</span></div><div data-t="jrheard the only other perf thing i can think of is: rather than having  grid  be a 2d array, have it be a 1d array that’s primarily accessed via some function like  (get-cell grid x y) , so most consumers don’t treat it like a 1d array, but certain places like  select*  can treat it like a 1d array and perhaps get a speedup"><span class="u" id="1513569644.000064">2017:12:18 04:00:44              jrheard </span><span>the only other perf thing i can think of is: rather than having </span><code>grid</code><span> be a 2d array, have it be a 1d array that’s primarily accessed via some function like </span><code>(get-cell grid x y)</code><span>, so most consumers don’t treat it like a 1d array, but certain places like </span><code>select*</code><span> can treat it like a 1d array and perhaps get a speedup</span></div><div data-t="jrheard which, i think i just have to try and see what happens, and benchmark before and after"><span class="u" id="1513569651.000046">2017:12:18 04:00:51              jrheard </span><span>which, i think i just have to try and see what happens, and benchmark before and after</span></div><div data-t="nathanmarz doseq  is not very fast"><span class="u" id="1513569724.000072">2017:12:18 04:02:04           nathanmarz </span><code>doseq</code><span> is not very fast</span></div><div data-t="nathanmarz neither is  reverse"><span class="u" id="1513569727.000018">2017:12:18 04:02:07           nathanmarz </span><span>neither is </span><code>reverse</code></div><div data-t="jrheard is there anything less drastic that you’d recommend i try instead, or is this
 (doseq [x (if (&lt; x1 x2)
           (range x1 (inc x2))
           (reverse (range x2 (inc x1))))]
   (next-fn
     (-&gt; structure
         (nth x)
         (nth y1))))  unimproveable?"><span class="u" id="1513569731.000058">2017:12:18 04:02:11              jrheard </span><span>is there anything less drastic that you’d recommend i try instead, or is this
</span><pre>(doseq [x (if (&lt; x1 x2)
           (range x1 (inc x2))
           (reverse (range x2 (inc x1))))]
   (next-fn
     (-&gt; structure
         (nth x)
         (nth y1))))</pre><span> unimproveable?</span></div><div data-t="jrheard i’ve benchmarked the  reverse  codepath and it doesn’t seem noticeably slower, it seems to really be the two-nths situation afaict"><span class="u" id="1513569754.000171">2017:12:18 04:02:34              jrheard </span><span>i’ve benchmarked the </span><code>reverse</code><span> codepath and it doesn’t seem noticeably slower, it seems to really be the two-nths situation afaict</span></div><div data-t="nathanmarz also, you&apos;re making two  nth  calls per element, when you could do one  nth  call per row"><span class="u" id="1513569769.000043">2017:12:18 04:02:49           nathanmarz </span><span>also, you&apos;re making two </span><code>nth</code><span> calls per element, when you could do one </span><code>nth</code><span> call per row</span></div><div data-t="jrheard reverse is always getting a list of at most five items fwiw"><span class="u" id="1513569770.000091">2017:12:18 04:02:50              jrheard </span><span>reverse is always getting a list of at most five items fwiw</span></div><div data-t="jrheard hm"><span class="u" id="1513569778.000049">2017:12:18 04:02:58              jrheard </span><span>hm</span></div><div data-t="jrheard i see how i can do one  nth  call in the case where i’m just doing down the Y axis - eg going from x=4,y=4 to x=4,y=8, and getting all those values"><span class="u" id="1513569802.000012">2017:12:18 04:03:22              jrheard </span><span>i see how i can do one </span><code>nth</code><span> call in the case where i’m just doing down the Y axis - eg going from x=4,y=4 to x=4,y=8, and getting all those values</span></div><div data-t="jrheard but i don’t see how i can do it if i’m going down the x axis, eg x=4,y=4 to x=8, y=4"><span class="u" id="1513569818.000136">2017:12:18 04:03:38              jrheard </span><span>but i don’t see how i can do it if i’m going down the x axis, eg x=4,y=4 to x=8, y=4</span></div><div data-t="jrheard i extremely agree with you that the two  nth  calls seem to be the culprit - is there some obvious better way of doing things that i’m not seeing?"><span class="u" id="1513569878.000013">2017:12:18 04:04:38              jrheard </span><span>i extremely agree with you that the two </span><code>nth</code><span> calls seem to be the culprit - is there some obvious better way of doing things that i’m not seeing?</span></div><div data-t="nathanmarz calling  range  is also materializing an additional sequence that isn&apos;t necessary"><span class="u" id="1513569901.000004">2017:12:18 04:05:01           nathanmarz </span><span>calling </span><code>range</code><span> is also materializing an additional sequence that isn&apos;t necessary</span></div><div data-t="nathanmarz the fastest way to do this is probably with just  loop"><span class="u" id="1513569929.000193">2017:12:18 04:05:29           nathanmarz </span><span>the fastest way to do this is probably with just </span><code>loop</code></div><div data-t="jrheard (fwiw, in my second-to-most-recent snippet, there’s an  if  with two paths - the  (= x1 x2)  path is pretty fast, and it still has the  range  and  reverse )"><span class="u" id="1513569990.000037">2017:12:18 04:06:30              jrheard </span><span>(fwiw, in my second-to-most-recent snippet, there’s an </span><code>if</code><span> with two paths - the </span><code>(= x1 x2)</code><span> path is pretty fast, and it still has the </span><code>range</code><span> and </span><code>reverse</code><span>)</span></div><div data-t="jrheard loop’s a great idea! i forgot it existed  🙂"><span class="u" id="1513569997.000132">2017:12:18 04:06:37              jrheard </span><span>loop’s a great idea! i forgot it existed </span><b>🙂</b></div><div data-t="jrheard i’ll try loop in the morning, thanks nathan!"><span class="u" id="1513570002.000093">2017:12:18 04:06:42              jrheard </span><span>i’ll try loop in the morning, thanks nathan!</span></div><div data-t="jrheard started benchmarking things (just sloppily using cljs’s built-in  simple-benchmark , nothing fancy). i have a  pick-move  function that i’m calling 50 times, which causes this navigator codepath to be executed about a jillion times.
when i call  next-fn  a single time on the whole sequence, i see timings of about 9300ms for my benchmark.
when i call  next-fn  multiple times, once per each item of the sequence, i see the same timings.
this is probably because the sequence is always going to be at most five items long - i imagine that if calling  next-fn  once per item tends to give a speedup, perhaps the speedup is more obvious if you’re doing it on a ton of items as opposed to five?
(i should also note that i’m not using advanced compilation while gathering this data)"><span class="u" id="1513618488.000416">2017:12:18 17:34:48              jrheard </span><span>started benchmarking things (just sloppily using cljs’s built-in </span><code>simple-benchmark</code><span>, nothing fancy). i have a </span><code>pick-move</code><span> function that i’m calling 50 times, which causes this navigator codepath to be executed about a jillion times.
when i call </span><code>next-fn</code><span> a single time on the whole sequence, i see timings of about 9300ms for my benchmark.
when i call </span><code>next-fn</code><span> multiple times, once per each item of the sequence, i see the same timings.
this is probably because the sequence is always going to be at most five items long - i imagine that if calling </span><code>next-fn</code><span> once per item tends to give a speedup, perhaps the speedup is more obvious if you’re doing it on a ton of items as opposed to five?
(i should also note that i’m not using advanced compilation while gathering this data)</span></div><div data-t="jrheard i switched my slow, two-`nth`-calls  doseq  with  range  and  reverse  to a handrolled  loop , and that brought me down from 9300ms to 7200ms, which is a good start!"><span class="u" id="1513618520.000229">2017:12:18 17:35:20              jrheard </span><span>i switched my slow, two-`nth`-calls </span><code>doseq</code><span> with </span><code>range</code><span> and </span><code>reverse</code><span> to a handrolled </span><code>loop</code><span>, and that brought me down from 9300ms to 7200ms, which is a good start!</span></div><div data-t="jrheard i still wish i could figure out a way to not have to do two  nth  calls - the only one i can think of is to switch from having a 2d vector to having a 1d vector, and measuring the before-and-after"><span class="u" id="1513618557.000290">2017:12:18 17:35:57              jrheard </span><span>i still wish i could figure out a way to not have to do two </span><code>nth</code><span> calls - the only one i can think of is to switch from having a 2d vector to having a 1d vector, and measuring the before-and-after</span></div><div data-t="jrheard at this point i’m mainly digging into this just to satisfy my curiosity, perf’s acceptable for my toy app but i’d like to see if the 1d vector approach causes a huge speed boost, none at all, or somewhere inbetween; i’ll post the results later today when i’m done, and then i will stop spamming this channel  🙂"><span class="u" id="1513618596.000103">2017:12:18 17:36:36              jrheard </span><span>at this point i’m mainly digging into this just to satisfy my curiosity, perf’s acceptable for my toy app but i’d like to see if the 1d vector approach causes a huge speed boost, none at all, or somewhere inbetween; i’ll post the results later today when i’m done, and then i will stop spamming this channel </span><b>🙂</b></div><div data-t="jrheard huh, basically zero speedup! my base benchmark timings are different for this one because i used a different board/hand combination to test the 2d vs 1d vector implementations; the 2d vector implementation had a benchmark time of 3100ms-3300ms, and so did the 1d vector implementation (presumably because vectors are implemented under the hood as trees, and so a 1d vector doesn’t guarantee you a contiguous block of memory)"><span class="u" id="1513620376.000224">2017:12:18 18:06:16              jrheard </span><span>huh, basically zero speedup! my base benchmark timings are different for this one because i used a different board/hand combination to test the 2d vs 1d vector implementations; the 2d vector implementation had a benchmark time of 3100ms-3300ms, and so did the 1d vector implementation (presumably because vectors are implemented under the hood as trees, and so a 1d vector doesn’t guarantee you a contiguous block of memory)</span></div><div data-t="jrheard so i guess this is as good as it’s gonna get; my thing still spends most of its time making those two  nth  calls, and i don’t see how that can be avoided if you’ve got a 2d vector of values, the first dimension holds the columns, and you’re trying to select all the values from eg x=4,y=4 to x=8,y=4. it seems to me that you have to call  nth  two times in that situation, unless i’m missing something"><span class="u" id="1513620493.000631">2017:12:18 18:08:13              jrheard </span><span>so i guess this is as good as it’s gonna get; my thing still spends most of its time making those two </span><code>nth</code><span> calls, and i don’t see how that can be avoided if you’ve got a 2d vector of values, the first dimension holds the columns, and you’re trying to select all the values from eg x=4,y=4 to x=8,y=4. it seems to me that you have to call </span><code>nth</code><span> two times in that situation, unless i’m missing something</span></div><div data-t="jrheard but anyway this has been very interesting and educational for me but no longer has much to do with specter. my app’s specter-related perf seems to be as good as it’s going to get for this query, so again, thanks for all the help and for building this great tool!"><span class="u" id="1513620529.000272">2017:12:18 18:08:49              jrheard </span><span>but anyway this has been very interesting and educational for me but no longer has much to do with specter. my app’s specter-related perf seems to be as good as it’s going to get for this query, so again, thanks for all the help and for building this great tool!</span></div><div data-t="nathanmarz yea, for up and down it&apos;s two  nth  calls per element, but for left and right it&apos;s less"><span class="u" id="1513624215.000376">2017:12:18 19:10:15           nathanmarz </span><span>yea, for up and down it&apos;s two </span><code>nth</code><span> calls per element, but for left and right it&apos;s less</span></div><div data-t="jrheard right exactly"><span class="u" id="1513624254.000368">2017:12:18 19:10:54              jrheard </span><span>right exactly</span></div><div data-t="jrheard the one-`nth`-call-and-then-`subvec` dimension is super fast, the two-`nth`-calls-per-element one is 50x slower, and it seems like that’s just a fact of life"><span class="u" id="1513624272.000024">2017:12:18 19:11:12              jrheard </span><span>the one-`nth`-call-and-then-`subvec` dimension is super fast, the two-`nth`-calls-per-element one is 50x slower, and it seems like that’s just a fact of life</span></div><div data-t="jrheard oh well!"><span class="u" id="1513624274.000575">2017:12:18 19:11:14              jrheard </span><span>oh well!</span></div><div data-t="mbjarland @nathanmarz apropos our conversation about warnings under clojure 1.9.0, a new version of midje has been released with an updated (direct) dep on specter: 
 [midje &quot;1.9.1&quot; :scope &quot;test&quot;]
   [com.rpl/specter &quot;1.0.4&quot; :scope &quot;test&quot; :exclusions [[org.clojure/clojure] [org.clojure/clojurescript]]]
     [riddley &quot;0.1.12&quot; :scope &quot;test&quot;]
 
the warnings are gone and the related issue on midje ( https://github.com/marick/Midje/issues/427 ) closed"><span class="u" id="1513699734.000151">2017:12:19 16:08:54            mbjarland </span><span>@nathanmarz apropos our conversation about warnings under clojure 1.9.0, a new version of midje has been released with an updated (direct) dep on specter: 
</span><pre>[midje &quot;1.9.1&quot; :scope &quot;test&quot;]
   [com.rpl/specter &quot;1.0.4&quot; :scope &quot;test&quot; :exclusions [[org.clojure/clojure] [org.clojure/clojurescript]]]
     [riddley &quot;0.1.12&quot; :scope &quot;test&quot;]
</pre><span>
the warnings are gone and the related issue on midje (</span><a href="https://github.com/marick/Midje/issues/427">https://github.com/marick/Midje/issues/427</a><span>) closed</span></div><div data-t="nathanmarz @mbjarland great"><span class="u" id="1513703930.000191">2017:12:19 17:18:50           nathanmarz </span><span>@mbjarland great</span></div><div data-t="rafael Hi. Don&apos;t know if this is the right forum, I have a newbie specter question."><span class="u" id="1513704628.000268">2017:12:19 17:30:28               rafael </span><span>Hi. Don&apos;t know if this is the right forum, I have a newbie specter question.</span></div><div data-t="rafael I wanted to filter out elements not matching the path for a  transform  call."><span class="u" id="1513704675.000751">2017:12:19 17:31:15               rafael </span><span>I wanted to filter out elements not matching the path for a </span><code>transform</code><span> call.</span></div><div data-t="rafael It&apos;s easier to explain in code. The following  (specter/transform [specter/ALL (specter/must :a) (specter/must :b)] str [{:a {:b 10}} {:a {:z 42}}])  returns  [{:a {:b &quot;10&quot;}} {:a {:z 42}}]"><span class="u" id="1513704698.000463">2017:12:19 17:31:38               rafael </span><span>It&apos;s easier to explain in code. The following </span><code>(specter/transform [specter/ALL (specter/must :a) (specter/must :b)] str [{:a {:b 10}} {:a {:z 42}}])</code><span> returns </span><code>[{:a {:b &quot;10&quot;}} {:a {:z 42}}]</code></div><div data-t="rafael It called the transformation function for an element matching the path and returned the rest unchanged."><span class="u" id="1513704720.000292">2017:12:19 17:32:00               rafael </span><span>It called the transformation function for an element matching the path and returned the rest unchanged.</span></div><div data-t="rafael I&apos;m wondering if is there anything I can do to make a similar call return  [{:a {:b &quot;10&quot;}}]  instead?"><span class="u" id="1513704747.000491">2017:12:19 17:32:27               rafael </span><span>I&apos;m wondering if is there anything I can do to make a similar call return </span><code>[{:a {:b &quot;10&quot;}}]</code><span> instead?</span></div><div data-t="rafael (filtering out the non-matching  {:a {:b 10}}  element)"><span class="u" id="1513704773.000519">2017:12:19 17:32:53               rafael </span><span>(filtering out the non-matching </span><code>{:a {:b 10}}</code><span> element)</span></div><div data-t="tanzoniteblack @rafael if you want to do a select and a transform in the same operation, you probably want to do  select  to get only the value you want returned and then use the  view  selector to make your transformation ( https://github.com/nathanmarz/specter/wiki/List-of-Navigators#view )"><span class="u" id="1513705274.000495">2017:12:19 17:41:14       tanzoniteblack </span><span>@rafael if you want to do a select and a transform in the same operation, you probably want to do </span><code>select</code><span> to get only the value you want returned and then use the </span><code>view</code><span> selector to make your transformation (</span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#view">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#view</a><span>)</span></div><div data-t="tanzoniteblack i.e. how I think of it:  transform  is for modifying in place a piece of a structure;  select  is for pulling out specific information I want from a structure; and  select  with the  view  selector is for doing both selecting only a piece and applying a transformation"><span class="u" id="1513705365.000536">2017:12:19 17:42:45       tanzoniteblack </span><span>i.e. how I think of it: </span><code>transform</code><span> is for modifying in place a piece of a structure; </span><code>select</code><span> is for pulling out specific information I want from a structure; and </span><code>select</code><span> with the </span><code>view</code><span> selector is for doing both selecting only a piece and applying a transformation</span></div><div data-t="rafael Thanks @tanzoniteblack. I&apos;m trying it out now"><span class="u" id="1513705400.000248">2017:12:19 17:43:20               rafael </span><span>Thanks @tanzoniteblack. I&apos;m trying it out now</span></div><div data-t="rafael Naively applying view to the example above gets me:
 (specter/select [specter/ALL (specter/must :a) (specter/must :b) (specter/view str)] [{:a {:b 10}} {:a {:z 42}}]) 
 =&gt; [&quot;10&quot;]"><span class="u" id="1513705523.000505">2017:12:19 17:45:23               rafael </span><span>Naively applying view to the example above gets me:
</span><pre>(specter/select [specter/ALL (specter/must :a) (specter/must :b) (specter/view str)] [{:a {:b 10}} {:a {:z 42}}])</pre><span>
</span><pre>=&gt; [&quot;10&quot;]</pre></div><div data-t="rafael I wonder if is there a way to get  [{:a {:b &quot;10&quot;}}]  in the result."><span class="u" id="1513705551.000146">2017:12:19 17:45:51               rafael </span><span>I wonder if is there a way to get </span><code>[{:a {:b &quot;10&quot;}}]</code><span> in the result.</span></div><div data-t="tanzoniteblack https://github.com/nathanmarz/specter/wiki/List-of-Navigators#transformed  might do that?"><span class="u" id="1513705600.000381">2017:12:19 17:46:40       tanzoniteblack </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#transformed">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#transformed</a><span> might do that?</span></div><div data-t="rafael It would perfectly fine to chain a call to  select  and a another to  transform , or whatever, but even then I&apos;m having a hard time coming up with the right incantation  🙂"><span class="u" id="1513705601.000139">2017:12:19 17:46:41               rafael </span><span>It would perfectly fine to chain a call to </span><code>select</code><span> and a another to </span><code>transform</code><span>, or whatever, but even then I&apos;m having a hard time coming up with the right incantation </span><b>🙂</b></div><div data-t="tanzoniteblack not actually sure off the top of my head, sorry"><span class="u" id="1513705618.000048">2017:12:19 17:46:58       tanzoniteblack </span><span>not actually sure off the top of my head, sorry</span></div><div data-t="rafael No worries, thanks for the help. I&apos;m checking out  transformed  now"><span class="u" id="1513705662.000471">2017:12:19 17:47:42               rafael </span><span>No worries, thanks for the help. I&apos;m checking out </span><code>transformed</code><span> now</span></div><div data-t="tanzoniteblack (specter/select [(specter/filterer (specter/must :a) (specter/must :b)) 
                                            specter/ALL
                                            (specter/transformed [:a :b] str)]
                                           [{:a {:b 10}} {:a {:z 42}}])  @rafael that appears to do what I think you want?"><span class="u" id="1513706060.000459">2017:12:19 17:54:20       tanzoniteblack </span><pre>(specter/select [(specter/filterer (specter/must :a) (specter/must :b)) 
                                            specter/ALL
                                            (specter/transformed [:a :b] str)]
                                           [{:a {:b 10}} {:a {:z 42}}])</pre><span> @rafael that appears to do what I think you want?</span></div><div data-t="tanzoniteblack filterer  removes all items that don&apos;t have  :b  key inside the value at the  :a  key, and then for each item in that list, we&apos;re going to reach into the path  :a  then  :b  and run the function  str"><span class="u" id="1513706105.000091">2017:12:19 17:55:05       tanzoniteblack </span><code>filterer</code><span> removes all items that don&apos;t have </span><code>:b</code><span> key inside the value at the </span><code>:a</code><span> key, and then for each item in that list, we&apos;re going to reach into the path </span><code>:a</code><span> then </span><code>:b</code><span> and run the function </span><code>str</code></div><div data-t="tanzoniteblack probably not more efficient then the manual way of doing it? But no idea"><span class="u" id="1513706118.000732">2017:12:19 17:55:18       tanzoniteblack </span><span>probably not more efficient then the manual way of doing it? But no idea</span></div><div data-t="rafael The output looks right. I&apos;m trying to digest it before applying to my real use case (which deals with a structure a bit more complicated than the example). Efficiency is not super important for my use case, I&apos;m reaching for specter for the terseness in dealing with a deeply nested structure, so it should be alright"><span class="u" id="1513706248.000728">2017:12:19 17:57:28               rafael </span><span>The output looks right. I&apos;m trying to digest it before applying to my real use case (which deals with a structure a bit more complicated than the example). Efficiency is not super important for my use case, I&apos;m reaching for specter for the terseness in dealing with a deeply nested structure, so it should be alright</span></div><div data-t="nathanmarz @tanzoniteblack you&apos;re looking for  not-selected?"><span class="u" id="1513706774.000104">2017:12:19 18:06:14           nathanmarz </span><span>@tanzoniteblack you&apos;re looking for </span><code>not-selected?</code></div><div data-t="nathanmarz (setval [ALL (not-selected? (must :a :b))] NONE data)
"><span class="u" id="1513706782.000126">2017:12:19 18:06:22           nathanmarz </span><pre>(setval [ALL (not-selected? (must :a :b))] NONE data)
</pre></div><div data-t="rafael With  not-selected  and  setval  the complete example would then be:
 (-&gt;&gt; data
       (S/setval [S/ALL (S/not-selected? (S/must :a :b))] S/NONE)
       (S/transform [S/ALL (S/must :a :b)] str))
 ?"><span class="u" id="1513706961.000167">2017:12:19 18:09:21               rafael </span><span>With </span><code>not-selected</code><span> and </span><code>setval</code><span> the complete example would then be:
</span><pre>(-&gt;&gt; data
       (S/setval [S/ALL (S/not-selected? (S/must :a :b))] S/NONE)
       (S/transform [S/ALL (S/must :a :b)] str))
</pre><span>?</span></div><div data-t="nathanmarz yea, that would work"><span class="u" id="1513707090.000132">2017:12:19 18:11:30           nathanmarz </span><span>yea, that would work</span></div><div data-t="nathanmarz for second part you don&apos;t need  must  anymore since they&apos;re guaranteed to be there by first part"><span class="u" id="1513707113.000013">2017:12:19 18:11:53           nathanmarz </span><span>for second part you don&apos;t need </span><code>must</code><span> anymore since they&apos;re guaranteed to be there by first part</span></div><div data-t="rafael Cool, now off to apply it to the real use case  🙂"><span class="u" id="1513707167.000652">2017:12:19 18:12:47               rafael </span><span>Cool, now off to apply it to the real use case </span><b>🙂</b></div><div data-t="rafael Hi again. When applying to my actual use case things turned out to be more complicated. There are multiple S/ALL where we want to remove non-matching elements. Again, a code example is probably easier to explain:
 (def data [{:a [{:b 10}]} {:a [{:b 20} {:z 42}]}])

  (-&gt;&gt; data
       (S/setval [S/ALL (S/not-selected? (S/must :a) S/ALL (S/must :b))] S/NONE)
       (S/transform [S/ALL :a S/ALL :b] str))
 
results in 
 =&gt; [{:a [{:b &quot;10&quot;}]} {:a [{:b &quot;20&quot;} {:z 42, :b &quot;&quot;}]}]
 
but I wanted  [{:a [{:b &quot;10&quot;}]} {:a [{:b &quot;20&quot;}]}]"><span class="u" id="1513712366.000153">2017:12:19 19:39:26               rafael </span><span>Hi again. When applying to my actual use case things turned out to be more complicated. There are multiple S/ALL where we want to remove non-matching elements. Again, a code example is probably easier to explain:
</span><pre>(def data [{:a [{:b 10}]} {:a [{:b 20} {:z 42}]}])

  (-&gt;&gt; data
       (S/setval [S/ALL (S/not-selected? (S/must :a) S/ALL (S/must :b))] S/NONE)
       (S/transform [S/ALL :a S/ALL :b] str))
</pre><span>
results in 
</span><pre>=&gt; [{:a [{:b &quot;10&quot;}]} {:a [{:b &quot;20&quot;} {:z 42, :b &quot;&quot;}]}]
</pre><span>
but I wanted </span><code>[{:a [{:b &quot;10&quot;}]} {:a [{:b &quot;20&quot;}]}]</code></div><div data-t="rafael (it&apos;s a similar example to above, but with one extra nested sequence)"><span class="u" id="1513712392.000627">2017:12:19 19:39:52               rafael </span><span>(it&apos;s a similar example to above, but with one extra nested sequence)</span></div><div data-t="rafael I could get the output I wanted with an extra  setval :
 (-&gt;&gt; data
       (S/setval [S/ALL (S/not-selected? (S/must :a) S/ALL (S/must :b))] S/NONE)
       (S/setval [S/ALL (S/must :a) S/ALL (S/not-selected? (S/must :b))] S/NONE)
       (S/transform [S/ALL :a S/ALL :b] str))
"><span class="u" id="1513712416.000219">2017:12:19 19:40:16               rafael </span><span>I could get the output I wanted with an extra </span><code>setval</code><span>:
</span><pre>(-&gt;&gt; data
       (S/setval [S/ALL (S/not-selected? (S/must :a) S/ALL (S/must :b))] S/NONE)
       (S/setval [S/ALL (S/must :a) S/ALL (S/not-selected? (S/must :b))] S/NONE)
       (S/transform [S/ALL :a S/ALL :b] str))
</pre></div><div data-t="rafael This works, but I was wondering if there is any way of reducing the duplication"><span class="u" id="1513712428.000345">2017:12:19 19:40:28               rafael </span><span>This works, but I was wondering if there is any way of reducing the duplication</span></div><div data-t="nathanmarz @rafael  (setval [ALL :a ALL (transformed (must :b) str) (not-selected? (must :b))] NONE data)"><span class="u" id="1513713587.000342">2017:12:19 19:59:47           nathanmarz </span><span>@rafael </span><code>(setval [ALL :a ALL (transformed (must :b) str) (not-selected? (must :b))] NONE data)</code></div><div data-t="nathanmarz do you also want to remove top level maps that don&apos;t have any inner maps under  :a  with  :b ?"><span class="u" id="1513713674.000262">2017:12:19 20:01:14           nathanmarz </span><span>do you also want to remove top level maps that don&apos;t have any inner maps under </span><code>:a</code><span> with </span><code>:b</code><span>?</span></div><div data-t="rafael Ideally yeah, If data is  (def data [{:a [{:b 10}]} {:a [{:b 20} {:z 42}]} {:a [{:z 42}]}])  then I also need to remove the last  {:a [{:z 42}]}"><span class="u" id="1513713840.000218">2017:12:19 20:04:00               rafael </span><span>Ideally yeah, If data is </span><code>(def data [{:a [{:b 10}]} {:a [{:b 20} {:z 42}]} {:a [{:z 42}]}])</code><span> then I also need to remove the last </span><code>{:a [{:z 42}]}</code></div><div data-t="rafael (trying to understand your suggestion above... thank&apos;s for taking the time to help)"><span class="u" id="1513713973.000300">2017:12:19 20:06:13               rafael </span><span>(trying to understand your suggestion above... thank&apos;s for taking the time to help)</span></div><div data-t="nathanmarz @rafael this does the trick:
 (defdynamicnav with-matching [path]
  (if-path path
    path
    (terminal-val NONE)
    ))

(transform
  [ALL
   (with-matching (must :a))
   ALL
   (with-matching (must :b))
   ]
  str
  data)
"><span class="u" id="1513714413.000484">2017:12:19 20:13:33           nathanmarz </span><span>@rafael this does the trick:
</span><pre>(defdynamicnav with-matching [path]
  (if-path path
    path
    (terminal-val NONE)
    ))

(transform
  [ALL
   (with-matching (must :a))
   ALL
   (with-matching (must :b))
   ]
  str
  data)
</pre></div><div data-t="rafael Wow"><span class="u" id="1513714438.000533">2017:12:19 20:13:58               rafael </span><span>Wow</span></div><div data-t="nathanmarz even better:"><span class="u" id="1513714751.000287">2017:12:19 20:19:11           nathanmarz </span><span>even better:</span></div><div data-t="nathanmarz (defdynamicnav with-matching [path]
  (if-path path
    (multi-path path (if-path path STOP (terminal-val NONE)))
    (terminal-val NONE)
    ))

(defdynamicnav with-non-empty [path]
  (multi-path path (if-path empty? (terminal-val NONE)))
  )

(transform
  [ALL
   (with-matching (must :a))
   (with-non-empty ALL)
   (with-matching (must :b))
   ]
  str
  data)
"><span class="u" id="1513714755.000251">2017:12:19 20:19:15           nathanmarz </span><pre>(defdynamicnav with-matching [path]
  (if-path path
    (multi-path path (if-path path STOP (terminal-val NONE)))
    (terminal-val NONE)
    ))

(defdynamicnav with-non-empty [path]
  (multi-path path (if-path empty? (terminal-val NONE)))
  )

(transform
  [ALL
   (with-matching (must :a))
   (with-non-empty ALL)
   (with-matching (must :b))
   ]
  str
  data)
</pre></div><div data-t="nathanmarz with  [{:a [{:b 10}]} {:a [{:q 20} {:z 42}]}]  that removes the second map completely"><span class="u" id="1513714867.000110">2017:12:19 20:21:07           nathanmarz </span><span>with </span><code>[{:a [{:b 10}]} {:a [{:q 20} {:z 42}]}]</code><span> that removes the second map completely</span></div><div data-t="nathanmarz you can read about dynamic navs here:  https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation"><span class="u" id="1513714913.000426">2017:12:19 20:21:53           nathanmarz </span><span>you can read about dynamic navs here: </span><a href="https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation">https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation</a></div><div data-t="nathanmarz they&apos;re similar to macros"><span class="u" id="1513714919.000056">2017:12:19 20:21:59           nathanmarz </span><span>they&apos;re similar to macros</span></div><div data-t="rafael Looks like I have a lot of reading to do. Thanks"><span class="u" id="1513715206.000599">2017:12:19 20:26:46               rafael </span><span>Looks like I have a lot of reading to do. Thanks</span></div><div data-t="nathanmarz actually this is a more flexible implementation I think:
 (defdynamicnav with-matching [path]
  (if-path path
    (multi-path path (if-path path STOP (terminal-val NONE)))
    (terminal-val NONE)
    ))

(defn ^:direct-nav ensure-pred [pred-fn]
  (path (stay-then-continue (if-path (pred pred-fn) STOP (terminal-val NONE)))))

(transform
  [ALL
   (with-matching (must :a))
   (ensure-pred #(-&gt; % empty? not))
   ALL
   (with-matching (must :b))
   ]
  str
  data)
"><span class="u" id="1513715238.000291">2017:12:19 20:27:18           nathanmarz </span><span>actually this is a more flexible implementation I think:
</span><pre>(defdynamicnav with-matching [path]
  (if-path path
    (multi-path path (if-path path STOP (terminal-val NONE)))
    (terminal-val NONE)
    ))

(defn ^:direct-nav ensure-pred [pred-fn]
  (path (stay-then-continue (if-path (pred pred-fn) STOP (terminal-val NONE)))))

(transform
  [ALL
   (with-matching (must :a))
   (ensure-pred #(-&gt; % empty? not))
   ALL
   (with-matching (must :b))
   ]
  str
  data)
</pre></div><div data-t="nathanmarz I may add some variant of these into specter"><span class="u" id="1513715261.000513">2017:12:19 20:27:41           nathanmarz </span><span>I may add some variant of these into specter</span></div><div data-t="nathanmarz I think this is the simplest solution:
 (defdynamicnav ensure-matching* [path]
  (multi-path path (if-path path STOP (terminal-val NONE))))

(def ensure-matching (eachnav ensure-matching*))
    
(transform
  [ALL
   (ensure-matching (must :a) ALL (must :b))
   ]
  str
  data)
"><span class="u" id="1513715831.000355">2017:12:19 20:37:11           nathanmarz </span><span>I think this is the simplest solution:
</span><pre>(defdynamicnav ensure-matching* [path]
  (multi-path path (if-path path STOP (terminal-val NONE))))

(def ensure-matching (eachnav ensure-matching*))
    
(transform
  [ALL
   (ensure-matching (must :a) ALL (must :b))
   ]
  str
  data)
</pre></div><div data-t="rafael The  ensure-matching  solution above worked for us, thanks."><span class="u" id="1513868348.000619">2017:12:21 14:59:08               rafael </span><span>The </span><code>ensure-matching</code><span> solution above worked for us, thanks.</span></div><div data-t="rafael We also found the need for another defdynamicnav, I&apos;m posting it here in case anyone finds it helpful:
 (specter/defdynamicnav look-ahead [path]
  (specter/if-path path specter/STAY (specter/terminal-val specter/NONE)))
"><span class="u" id="1513868391.000219">2017:12:21 14:59:51               rafael </span><span>We also found the need for another defdynamicnav, I&apos;m posting it here in case anyone finds it helpful:
</span><pre>(specter/defdynamicnav look-ahead [path]
  (specter/if-path path specter/STAY (specter/terminal-val specter/NONE)))
</pre></div><div data-t="rafael It is used like this:
 (transform [ALL (schema-check/look-ahead (must :a))] str [{:a 1 :b 1} {:x 2 :b 2}]) 
evaluates to  =&gt;  [&quot;{:a 1, :b 1}&quot;]"><span class="u" id="1513868440.000280">2017:12:21 15:00:40               rafael </span><span>It is used like this:
</span><pre>(transform [ALL (schema-check/look-ahead (must :a))] str [{:a 1 :b 1} {:x 2 :b 2}])</pre><span>
evaluates to </span><code>=&gt;  [&quot;{:a 1, :b 1}&quot;]</code></div><div data-t="rafael Another example:
 (transform [ALL (schema-check/look-ahead (must :a)) :b] str [{:a 1 :b 1} {:x 2 :b 2}]) 
 =&gt; [{:a 1, :b &quot;1&quot;}]"><span class="u" id="1513868496.000520">2017:12:21 15:01:36               rafael </span><span>Another example:
</span><pre>(transform [ALL (schema-check/look-ahead (must :a)) :b] str [{:a 1 :b 1} {:x 2 :b 2}])</pre><span>
</span><pre>=&gt; [{:a 1, :b &quot;1&quot;}]</pre></div><div data-t="nathanmarz @rafael cool"><span class="u" id="1513868681.000546">2017:12:21 15:04:41           nathanmarz </span><span>@rafael cool</span></div><div data-t="nathanmarz I opened an issue to add functionality like this into Specter  https://github.com/nathanmarz/specter/issues/240"><span class="u" id="1513868709.000340">2017:12:21 15:05:09           nathanmarz </span><span>I opened an issue to add functionality like this into Specter </span><a href="https://github.com/nathanmarz/specter/issues/240">https://github.com/nathanmarz/specter/issues/240</a></div><div data-t="npetryk Can someone help me understand why  (setval (filterer even?) [:example] (range 0 10)) =&gt; (:example 1 3 5 7 9)  whereas  (setval (filterer even?) [] (range 0 10)) =&gt; (nil 1 3 5 7 9) , yet  (setval (filterer even?) [NONE] (range 0 10)) =&gt; (1 3 5 7 9)"><span class="u" id="1513908510.000068">2017:12:22 02:08:30              npetryk </span><span>Can someone help me understand why </span><code>(setval (filterer even?) [:example] (range 0 10)) =&gt; (:example 1 3 5 7 9)</code><span> whereas </span><code>(setval (filterer even?) [] (range 0 10)) =&gt; (nil 1 3 5 7 9)</code><span>, yet </span><code>(setval (filterer even?) [NONE] (range 0 10)) =&gt; (1 3 5 7 9)</code></div><div data-t="npetryk being able to resize a subselection is really beautiful, but this special case of resizing it to zero seems a bit odd, and I dont quite understand why it happens"><span class="u" id="1513908556.000087">2017:12:22 02:09:16              npetryk </span><span>being able to resize a subselection is really beautiful, but this special case of resizing it to zero seems a bit odd, and I dont quite understand why it happens</span></div><div data-t="npetryk I would expect replacing a sequence with an empty sequence would remove all elements, rather than leaving a  nil  in the first matching spot"><span class="u" id="1513908616.000214">2017:12:22 02:10:16              npetryk </span><span>I would expect replacing a sequence with an empty sequence would remove all elements, rather than leaving a </span><code>nil</code><span> in the first matching spot</span></div><div data-t="nathanmarz @npetryk looks like a bug"><span class="u" id="1513912821.000011">2017:12:22 03:20:21           nathanmarz </span><span>@npetryk looks like a bug</span></div><div data-t="nathanmarz try  (setval (filterer even?) nil (range 0 10))"><span class="u" id="1513912845.000007">2017:12:22 03:20:45           nathanmarz </span><span>try </span><code>(setval (filterer even?) nil (range 0 10))</code></div><div data-t="nathanmarz fixed for next version:  https://github.com/nathanmarz/specter/commit/7b646ca566bb3bdd362d43a348c2fe00457438b2"><span class="u" id="1513913115.000058">2017:12:22 03:25:15           nathanmarz </span><span>fixed for next version: </span><a href="https://github.com/nathanmarz/specter/commit/7b646ca566bb3bdd362d43a348c2fe00457438b2">https://github.com/nathanmarz/specter/commit/7b646ca566bb3bdd362d43a348c2fe00457438b2</a></div><div data-t="npetryk Thanks!"><span class="u" id="1514044070.000009">2017:12:23 15:47:50                   npetryk </span><span>Thanks!</span></div><div data-t="plamen Hello,

I again have a nested map in the form:"><span class="u" id="1513953181.000129">2017:12:22 14:33:01               plamen </span><span>Hello,

I again have a nested map in the form:</span></div><div data-t="plamen {... ...
 ’A {:type :double}
 :variables {... ...
             ’A {:type :int}
			 ’C {:type :double}
             :variables {... ...
			             ’B {:type :double
						     :formula “A + C”}
						 ... ...
			             }
		     ... ...}}

I also recursively traverse it and apply transformations to variables and other nodes (the map is an AST of a DSL)
						 
 (defn process-var-list [ast]
  (transform [NODES-VARIABLES :variables MAP-VALS]
             (fn [var]
               ; do something to var
               )
             ast))
			 
  `(def NODES-VARIABLES
  (recursive-path [] p
                  (cond-path (must :variables)
                             (continue-then-stay :variables MAP-VALS map? p))))"><span class="u" id="1513953198.000421">2017:12:22 14:33:18               plamen </span><pre>{... ...
 ’A {:type :double}
 :variables {... ...
             ’A {:type :int}
			 ’C {:type :double}
             :variables {... ...
			             ’B {:type :double
						     :formula “A + C”}
						 ... ...
			             }
		     ... ...}}

I also recursively traverse it and apply transformations to variables and other nodes (the map is an AST of a DSL)
						 
</pre><span>(defn process-var-list [ast]
  (transform [NODES-VARIABLES :variables MAP-VALS]
             (fn [var]
               ; do something to var
               )
             ast))
			 
</span><code></code><span>`(def NODES-VARIABLES
  (recursive-path [] p
                  (cond-path (must :variables)
                             (continue-then-stay :variables MAP-VALS map? p))))</span></div><div data-t="plamen In ‘process-vars’ I have access only to the current node which works for most transformations I need. Now if in that DSL I would like to provide variable scope/visibility rules like in Java for example, where the localness of a variable is directly mapped to the depth of it’s definition over the :variables subbranches, I would need to have access not only to var, but to the root of the datastructure AFTER it has been processed in a previous step. That means I can’t just pass ast as a second parameter, because it would have the original state only before any transformation through Specter. collect I think would also not help me in that situation."><span class="u" id="1513953252.000310">2017:12:22 14:34:12               plamen </span><span>In ‘process-vars’ I have access only to the current node which works for most transformations I need. Now if in that DSL I would like to provide variable scope/visibility rules like in Java for example, where the localness of a variable is directly mapped to the depth of it’s definition over the :variables subbranches, I would need to have access not only to var, but to the root of the datastructure AFTER it has been processed in a previous step. That means I can’t just pass ast as a second parameter, because it would have the original state only before any transformation through Specter. collect I think would also not help me in that situation.</span></div><div data-t="plamen So 
1. how one can pass not only the currently selected path element, but the whole structure as well in the already modified state on each invocation of the transform function?
2. if I would like that in the context of where variable B is definied, I would like to have access to variable A in the ast, then I should be able to get to the upper and recursively to all further upper levels up to the root from the current node transformed to access the variables defined there. I know how to do it in Clojure without specter, but how with Specter? (for example to pull the types of variables A and C for calculating B)
3. outside of Specter I have a lot of variable and other dependency analysis (essentially expressions/filters over topological sorts of the variables), but is there an idiomatic way to do it in Specter?

Any hints would be very helpful"><span class="u" id="1513953259.000050">2017:12:22 14:34:19               plamen </span><span>So 
1. how one can pass not only the currently selected path element, but the whole structure as well in the already modified state on each invocation of the transform function?
2. if I would like that in the context of where variable B is definied, I would like to have access to variable A in the ast, then I should be able to get to the upper and recursively to all further upper levels up to the root from the current node transformed to access the variables defined there. I know how to do it in Clojure without specter, but how with Specter? (for example to pull the types of variables A and C for calculating B)
3. outside of Specter I have a lot of variable and other dependency analysis (essentially expressions/filters over topological sorts of the variables), but is there an idiomatic way to do it in Specter?

Any hints would be very helpful</span></div><div data-t="nathanmarz @plamen don&apos;t understand what you&apos;re asking about getting root of data structure after it&apos;s been processed"><span class="u" id="1513955795.000180">2017:12:22 15:16:35           nathanmarz </span><span>@plamen don&apos;t understand what you&apos;re asking about getting root of data structure after it&apos;s been processed</span></div><div data-t="nathanmarz it would help if you simplified your examples to get at the heart of your questions"><span class="u" id="1513955842.000176">2017:12:22 15:17:22           nathanmarz </span><span>it would help if you simplified your examples to get at the heart of your questions</span></div><div data-t="plamen Hello Nathan, what I mean is that in the transform function I have as parameter only the current node in the tree as it gets recursed. I would like to pass in addition to it the whole structure so that I can walk it inside the transform function, but not in it’s inital state, but in it’s current (probably already processed state from previous steps in the recursion - my question is probably related to not knowing when exactly the transformation function is applied to the nodes - does first a walk happen in which paths get constructed, then the list is processed, or is it just as in the recursion - step by step depth first, or post-walk or…?) I hope this makes more sense."><span class="u" id="1513956138.000222">2017:12:22 15:22:18               plamen </span><span>Hello Nathan, what I mean is that in the transform function I have as parameter only the current node in the tree as it gets recursed. I would like to pass in addition to it the whole structure so that I can walk it inside the transform function, but not in it’s inital state, but in it’s current (probably already processed state from previous steps in the recursion - my question is probably related to not knowing when exactly the transformation function is applied to the nodes - does first a walk happen in which paths get constructed, then the list is processed, or is it just as in the recursion - step by step depth first, or post-walk or…?) I hope this makes more sense.</span></div><div data-t="plamen (not sure how to make the question simpler as the map with nested :variables keys consisting of lists of other such maps is the simplest one I can think of related to it. This is why I make the analogy with an abstract syntax tree/depth in the tree and variable scope/visibility as in languages like Java/C#)"><span class="u" id="1513956262.000411">2017:12:22 15:24:22               plamen </span><span>(not sure how to make the question simpler as the map with nested :variables keys consisting of lists of other such maps is the simplest one I can think of related to it. This is why I make the analogy with an abstract syntax tree/depth in the tree and variable scope/visibility as in languages like Java/C#)</span></div><div data-t="plamen (it is actually not an AST, but more of a types tree)"><span class="u" id="1513956308.000204">2017:12:22 15:25:08               plamen </span><span>(it is actually not an AST, but more of a types tree)</span></div><div data-t="plamen so, in the (defn process-var-list [ast]
 (transform [NODES-VARIABLES :variables MAP-VALS]
            (fn [var]
              ; do something to var
              )
            ast))"><span class="u" id="1513956384.000493">2017:12:22 15:26:24               plamen </span><span>so, in the (defn process-var-list [ast]
 (transform [NODES-VARIABLES :variables MAP-VALS]
            (fn [var]
              ; do something to var
              )
            ast))</span></div><div data-t="plamen if I rewrite it to"><span class="u" id="1513956462.000485">2017:12:22 15:27:42               plamen </span><span>if I rewrite it to</span></div><div data-t="plamen (defn process-var [var]
  ;do something and return the transformed var node)
  
(defn process-var-list [ast]
  (transform [NODES-VARIABLES :variables MAP-VALS]
             process-var
             ast))"><span class="u" id="1513956464.000098">2017:12:22 15:27:44               plamen </span><span>(defn process-var [var]
  ;do something and return the transformed var node)
  
(defn process-var-list [ast]
  (transform [NODES-VARIABLES :variables MAP-VALS]
             process-var
             ast))</span></div><div data-t="plamen what I mean is that in my understanding to achieve what I ask for in 1., passing ’ast as an additional argument to ’process-var would pass the inital state of ’ast before the recursion and possible transformation inside it happened?"><span class="u" id="1513956544.000493">2017:12:22 15:29:04               plamen </span><span>what I mean is that in my understanding to achieve what I ask for in 1., passing ’ast as an additional argument to ’process-var would pass the inital state of ’ast before the recursion and possible transformation inside it happened?</span></div><div data-t="plamen what I need is that during the recursion, during the invocation from Specter of the function ’process-var, inside ’process-var I get as parameter the ’ast as processed up to there. (which is possible only in pre-walk, but not post-walk, but this is also the point - I don’t know how to control or know when the invocation of ’process-var actually happens)"><span class="u" id="1513956761.000553">2017:12:22 15:32:41               plamen </span><span>what I need is that during the recursion, during the invocation from Specter of the function ’process-var, inside ’process-var I get as parameter the ’ast as processed up to there. (which is possible only in pre-walk, but not post-walk, but this is also the point - I don’t know how to control or know when the invocation of ’process-var actually happens)</span></div><div data-t="plamen (sorry - the “possibility” in the “pre-/post-walk” part of the last sentence is wrong)"><span class="u" id="1513956825.000320">2017:12:22 15:33:45               plamen </span><span>(sorry - the “possibility” in the “pre-/post-walk” part of the last sentence is wrong)</span></div><div data-t="plamen Does that make more sense?"><span class="u" id="1513956887.000226">2017:12:22 15:34:47               plamen </span><span>Does that make more sense?</span></div><div data-t="plamen or in other words which is probably more visual - how to transform"><span class="u" id="1513957153.000218">2017:12:22 15:39:13               plamen </span><span>or in other words which is probably more visual - how to transform</span></div><div data-t="plamen {... ...
 ’A {:type :double}
 :variables {... ...
             ’A {:type :int}
			 ’C {:type :double}
             :variables {... ...
			             ’B {:type :double
						     :formula “A + C”}
						 ... ...
			             }
		     ... ...}}"><span class="u" id="1513957159.000327">2017:12:22 15:39:19               plamen </span><span>{... ...
 ’A {:type :double}
 :variables {... ...
             ’A {:type :int}
			 ’C {:type :double}
             :variables {... ...
			             ’B {:type :double
						     :formula “A + C”}
						 ... ...
			             }
		     ... ...}}</span></div><div data-t="plamen into"><span class="u" id="1513957160.000172">2017:12:22 15:39:20               plamen </span><span>into</span></div><div data-t="plamen {... ...
 ’A {:type :double}
 ’D {:type :string}
 :variables {... ...
             ’A {:type :int}
			 ’C {:type :double}
             :variables {... ...
			             ’B {:type :double
						     :uses [[:variables ’A] [:variables ’B]]
							 :sees [’D [:variables ’A] [:variables ’B]]
						     :formula “A + C”}
						 ... ...
			             }
		     ... ...}}"><span class="u" id="1513957170.000338">2017:12:22 15:39:30               plamen </span><span>{... ...
 ’A {:type :double}
 ’D {:type :string}
 :variables {... ...
             ’A {:type :int}
			 ’C {:type :double}
             :variables {... ...
			             ’B {:type :double
						     :uses [[:variables ’A] [:variables ’B]]
							 :sees [’D [:variables ’A] [:variables ’B]]
						     :formula “A + C”}
						 ... ...
			             }
		     ... ...}}</span></div><div data-t="plamen where the vectors in :uses and :sees are either a path in a map as in ’get-in or may be even a Specter path if that’s possible easy."><span class="u" id="1513957241.000368">2017:12:22 15:40:41               plamen </span><span>where the vectors in :uses and :sees are either a path in a map as in ’get-in or may be even a Specter path if that’s possible easy.</span></div><div data-t="plamen (this is more about 2. and 3.)"><span class="u" id="1513957274.000097">2017:12:22 15:41:14               plamen </span><span>(this is more about 2. and 3.)</span></div><div data-t="plamen about question 1. another example"><span class="u" id="1513957294.000246">2017:12:22 15:41:34               plamen </span><span>about question 1. another example</span></div><div data-t="nathanmarz so when you process var 1 and then var 2, you want the var 2 transform fn to get the updated ast from processing var 1?"><span class="u" id="1513957318.000351">2017:12:22 15:41:58           nathanmarz </span><span>so when you process var 1 and then var 2, you want the var 2 transform fn to get the updated ast from processing var 1?</span></div><div data-t="plamen yes"><span class="u" id="1513957350.000214">2017:12:22 15:42:30               plamen </span><span>yes</span></div><div data-t="plamen exactly"><span class="u" id="1513957353.000241">2017:12:22 15:42:33               plamen </span><span>exactly</span></div><div data-t="plamen as in"><span class="u" id="1513957361.000217">2017:12:22 15:42:41               plamen </span><span>as in</span></div><div data-t="plamen initial tree"><span class="u" id="1513957365.000455">2017:12:22 15:42:45               plamen </span><span>initial tree</span></div><div data-t="plamen {... ...
 ’A {:type :double}
 :variables {... ...
             ’A {}
			 ’C {}
             :variables {... ...
			             ’B {:type :double
						     :formula “A + C”}
						 ... ...
			             }
		     ... ...}}"><span class="u" id="1513957367.000452">2017:12:22 15:42:47               plamen </span><span>{... ...
 ’A {:type :double}
 :variables {... ...
             ’A {}
			 ’C {}
             :variables {... ...
			             ’B {:type :double
						     :formula “A + C”}
						 ... ...
			             }
		     ... ...}}</span></div><div data-t="plamen when transforming ’A I can add {:type :int} to it"><span class="u" id="1513957385.000194">2017:12:22 15:43:05               plamen </span><span>when transforming ’A I can add {:type :int} to it</span></div><div data-t="nathanmarz I do exactly that with my graph navigators"><span class="u" id="1513957415.000135">2017:12:22 15:43:35           nathanmarz </span><span>I do exactly that with my graph navigators</span></div><div data-t="plamen and in the next recursion step when I process ’B, the :type values of ’A and ’C are already visible to the invocation of the transform function"><span class="u" id="1513957426.000313">2017:12:22 15:43:46               plamen </span><span>and in the next recursion step when I process ’B, the :type values of ’A and ’C are already visible to the invocation of the transform function</span></div><div data-t="nathanmarz my navigators don&apos;t navigate directly to a node, but to a pair of  [graph node-id]"><span class="u" id="1513957439.000314">2017:12:22 15:43:59           nathanmarz </span><span>my navigators don&apos;t navigate directly to a node, but to a pair of </span><code>[graph node-id]</code></div><div data-t="plamen I know how to do it outside of Specter, but specter gives me much more concise way"><span class="u" id="1513957451.000169">2017:12:22 15:44:11               plamen </span><span>I know how to do it outside of Specter, but specter gives me much more concise way</span></div><div data-t="plamen yes"><span class="u" id="1513957457.000394">2017:12:22 15:44:17               plamen </span><span>yes</span></div><div data-t="nathanmarz so when I do  TOPSORT , it navigates to  [graph node-id]  in topological order, with each step having the updates form previous steps"><span class="u" id="1513957459.000436">2017:12:22 15:44:19           nathanmarz </span><span>so when I do </span><code>TOPSORT</code><span>, it navigates to </span><code>[graph node-id]</code><span> in topological order, with each step having the updates form previous steps</span></div><div data-t="nathanmarz I believe you can do something similar for your use case with zippers"><span class="u" id="1513957479.000164">2017:12:22 15:44:39           nathanmarz </span><span>I believe you can do something similar for your use case with zippers</span></div><div data-t="nathanmarz look at com.rpl.specter.zipper"><span class="u" id="1513957488.000037">2017:12:22 15:44:48           nathanmarz </span><span>look at com.rpl.specter.zipper</span></div><div data-t="plamen in my normal clj code I also on each step have something like [root-node local-path-in-the-recursion]"><span class="u" id="1513957493.000018">2017:12:22 15:44:53               plamen </span><span>in my normal clj code I also on each step have something like [root-node local-path-in-the-recursion]</span></div><div data-t="plamen exactlyt"><span class="u" id="1513957507.000356">2017:12:22 15:45:07               plamen </span><span>exactlyt</span></div><div data-t="plamen -t"><span class="u" id="1513957509.000316">2017:12:22 15:45:09               plamen </span><span>-t</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers"><span class="u" id="1513957514.000047">2017:12:22 15:45:14           nathanmarz </span><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers">https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers</a></div><div data-t="plamen I even did’t tought about zippers, as in normal Clj I achieve it without them. Thank you for the big hint!"><span class="u" id="1513957575.000083">2017:12:22 15:46:15               plamen </span><span>I even did’t tought about zippers, as in normal Clj I achieve it without them. Thank you for the big hint!</span></div><div data-t="nathanmarz zippers are an advanced form of navigation"><span class="u" id="1513957597.000036">2017:12:22 15:46:37           nathanmarz </span><span>zippers are an advanced form of navigation</span></div><div data-t="plamen so when I do  TOPSORT , it navigates to  [graph node-id]  in topological order, with each step having the updates form previous step - was exactly what I was looking it"><span class="u" id="1513957607.000358">2017:12:22 15:46:47               plamen </span><span>so when I do </span><code>TOPSORT</code><span>, it navigates to </span><code>[graph node-id]</code><span> in topological order, with each step having the updates form previous step - was exactly what I was looking it</span></div><div data-t="plamen it=at"><span class="u" id="1513957611.000434">2017:12:22 15:46:51               plamen </span><span>it=at</span></div><div data-t="nathanmarz more indirect but can do things you can&apos;t with regular navigators"><span class="u" id="1513957615.000353">2017:12:22 15:46:55           nathanmarz </span><span>more indirect but can do things you can&apos;t with regular navigators</span></div><div data-t="nathanmarz at the cost of increased overhead"><span class="u" id="1513957625.000223">2017:12:22 15:47:05           nathanmarz </span><span>at the cost of increased overhead</span></div><div data-t="plamen will read"><span class="u" id="1513957628.000382">2017:12:22 15:47:08               plamen </span><span>will read</span></div><div data-t="plamen yes - the overhead is not that important for me as it will be used in a compilation phase, where not the compilation, but the runtime is important"><span class="u" id="1513957662.000065">2017:12:22 15:47:42               plamen </span><span>yes - the overhead is not that important for me as it will be used in a compilation phase, where not the compilation, but the runtime is important</span></div><div data-t="plamen while the topological order is important for me, because without it - no chance for correct code generation. but needed to ask first about step 1 and then to think how to overlay the order on top of it in Specter."><span class="u" id="1513957913.000529">2017:12:22 15:51:53               plamen </span><span>while the topological order is important for me, because without it - no chance for correct code generation. but needed to ask first about step 1 and then to think how to overlay the order on top of it in Specter.</span></div><div data-t="plamen reading the doc it looks to me that I have to solve couple of things (and rewire the brain a bit for using zippers)"><span class="u" id="1513958514.000397">2017:12:22 16:01:54               plamen </span><span>reading the doc it looks to me that I have to solve couple of things (and rewire the brain a bit for using zippers)</span></div><div data-t="plamen 1. I need to create a specter/zip constructor for nested maps and vectors which can be used from Specter"><span class="u" id="1513958559.000367">2017:12:22 16:02:39               plamen </span><span>1. I need to create a specter/zip constructor for nested maps and vectors which can be used from Specter</span></div><div data-t="plamen 2. not sure if I read it correctly from the examples, but all S/transform invoke a function with the node itself, but not with the zipper, so how would I navigate back to an upper level if the transform function (in the examples - inc) receives only the current value?"><span class="u" id="1513958716.000048">2017:12:22 16:05:16               plamen </span><span>2. not sure if I read it correctly from the examples, but all S/transform invoke a function with the node itself, but not with the zipper, so how would I navigate back to an upper level if the transform function (in the examples - inc) receives only the current value?</span></div><div data-t="plamen what I mean - from the examples the line (S/transform [SZ/VECTOR-ZIP SZ/DOWN SZ/NODE] inc data) invokes ’inc only with the value of the current node, but how would one consult upper nodes from inside ’inc?"><span class="u" id="1513958824.000249">2017:12:22 16:07:04               plamen </span><span>what I mean - from the examples the line (S/transform [SZ/VECTOR-ZIP SZ/DOWN SZ/NODE] inc data) invokes ’inc only with the value of the current node, but how would one consult upper nodes from inside ’inc?</span></div><div data-t="plamen 3. not sure yet how to do the recursion as the zip paths are to specific ‘coordinates’. I could using normal clojure recursion where on each node I construct a new zipper and walk/transform from there. Is this the right line of tought?"><span class="u" id="1513959239.000106">2017:12:22 16:13:59               plamen </span><span>3. not sure yet how to do the recursion as the zip paths are to specific ‘coordinates’. I could using normal clojure recursion where on each node I construct a new zipper and walk/transform from there. Is this the right line of tought?</span></div><div data-t="nathanmarz yea, on second thought zippers won&apos;t be enough for what you want to do"><span class="u" id="1513960583.000003">2017:12:22 16:36:23           nathanmarz </span><span>yea, on second thought zippers won&apos;t be enough for what you want to do</span></div><div data-t="nathanmarz you need a custom navigator that understands the data structure as a whole"><span class="u" id="1513960692.000506">2017:12:22 16:38:12           nathanmarz </span><span>you need a custom navigator that understands the data structure as a whole</span></div><div data-t="nathanmarz to do something like the  TOPSORT  I described"><span class="u" id="1513960698.000404">2017:12:22 16:38:18           nathanmarz </span><span>to do something like the </span><code>TOPSORT</code><span> I described</span></div><div data-t="nathanmarz for reference, my  TOPSORT  code looks like this:
 (defn- multi-anchor-path-select [graph getter next-fn]
  (doseqres NONE [anchor (getter graph)]
    (next-fn [graph anchor])))


(defn- multi-anchor-path-transform [graph getter next-fn]
  (reduce (fn [graph node-id]
            (-&gt; [graph node-id] next-fn first))
          graph
          (getter graph)))

(defnav multi-anchor-path [getter]
  (select* [this graph next-fn]
    (multi-anchor-path-select graph getter next-fn))
  (transform* [this graph next-fn]
    (multi-anchor-path-transform graph getter next-fn)))

(def TOPSORT (multi-anchor-path topsort))
"><span class="u" id="1513960852.000195">2017:12:22 16:40:52           nathanmarz </span><span>for reference, my </span><code>TOPSORT</code><span> code looks like this:
</span><pre>(defn- multi-anchor-path-select [graph getter next-fn]
  (doseqres NONE [anchor (getter graph)]
    (next-fn [graph anchor])))


(defn- multi-anchor-path-transform [graph getter next-fn]
  (reduce (fn [graph node-id]
            (-&gt; [graph node-id] next-fn first))
          graph
          (getter graph)))

(defnav multi-anchor-path [getter]
  (select* [this graph next-fn]
    (multi-anchor-path-select graph getter next-fn))
  (transform* [this graph next-fn]
    (multi-anchor-path-transform graph getter next-fn)))

(def TOPSORT (multi-anchor-path topsort))
</pre></div><div data-t="nathanmarz this is built on top of loom  https://github.com/aysylu/loom"><span class="u" id="1513960938.000120">2017:12:22 16:42:18           nathanmarz </span><span>this is built on top of loom </span><a href="https://github.com/aysylu/loom">https://github.com/aysylu/loom</a></div><div data-t="plamen Thank you for the direction, Nathan! I tought it is something trivial  🙂  Now I need to rethink"><span class="u" id="1513965845.000427">2017:12:22 18:04:05               plamen </span><span>Thank you for the direction, Nathan! I tought it is something trivial </span><b>🙂</b><span> Now I need to rethink</span></div><div data-t="plamen And for taking time again for my questions!"><span class="u" id="1513965859.000065">2017:12:22 18:04:19               plamen </span><span>And for taking time again for my questions!</span></div><div data-t="jvuillermet Hello, given a collection like this one  [:set1 :set2 :submit :set1 :submit :se2 :set3] 
I want a function that returns the items immediately before each  :submit  
if no  :submit  in the coll, I need an empty coll result

 user=&gt; (-&gt;&gt; [:set1 :set2 :submit :set1 :submit :se2 :set3] (partition-by #(= :submit %)) butlast (remove #(= (list :submit) %)) (map last))
(:set2 :set1) 
is my current solution using  partition-by .

Is there a way to do that with specter ? (or a better way in clojure for that matter, but I’m mainly interested in the specter version)"><span class="u" id="1514133244.000033">2017:12:24 16:34:04          jvuillermet </span><span>Hello, given a collection like this one </span><code>[:set1 :set2 :submit :set1 :submit :se2 :set3]</code><span>
I want a function that returns the items immediately before each </span><code>:submit</code><span> 
if no </span><code>:submit</code><span> in the coll, I need an empty coll result

</span><pre>user=&gt; (-&gt;&gt; [:set1 :set2 :submit :set1 :submit :se2 :set3] (partition-by #(= :submit %)) butlast (remove #(= (list :submit) %)) (map last))
(:set2 :set1)</pre><span>
is my current solution using </span><code>partition-by</code><span>.

Is there a way to do that with specter ? (or a better way in clojure for that matter, but I’m mainly interested in the specter version)</span></div><div data-t="nathanmarz @jvuillermet this is similar:
 user=&gt; (select [(continuous-subseqs #(not= :submit %)) LAST] data)
[:set2 :set1 :set3]
"><span class="u" id="1514144823.000049">2017:12:24 19:47:03           nathanmarz </span><span>@jvuillermet this is similar:
</span><pre>user=&gt; (select [(continuous-subseqs #(not= :submit %)) LAST] data)
[:set2 :set1 :set3]
</pre></div><div data-t="nathanmarz With  https://github.com/nathanmarz/specter/issues/236  you could get exactly the same behavior"><span class="u" id="1514144860.000001">2017:12:24 19:47:40           nathanmarz </span><span>With </span><a href="https://github.com/nathanmarz/specter/issues/236">https://github.com/nathanmarz/specter/issues/236</a><span> you could get exactly the same behavior</span></div><div data-t="mbjarland how would I go about calculating the sum of the string lengths in the following data structure (oh and yes, Nathan, I did cave in and pull in specter into my project, the convenience is just too alluring): 
 [{:delim [&quot;-&quot;]} {:align :L} {:delim [&quot;-&quot; :F &quot;-&quot;]} {:align :R} {:delim [&quot;-&quot;]}]
 
I’m assuming using: 
 (specter/traverse-all [ALL :delim ALL string?])
 
together with transduce would somehow do the trick?

the answer from the above data structure should be  4  as there are 4 strings of length 1 in the  :delim  maps in the exapmle"><span class="u" id="1514838555.000041">2018:01:01 20:29:15            mbjarland </span><span>how would I go about calculating the sum of the string lengths in the following data structure (oh and yes, Nathan, I did cave in and pull in specter into my project, the convenience is just too alluring): 
</span><pre>[{:delim [&quot;-&quot;]} {:align :L} {:delim [&quot;-&quot; :F &quot;-&quot;]} {:align :R} {:delim [&quot;-&quot;]}]
</pre><span>
I’m assuming using: 
</span><pre>(specter/traverse-all [ALL :delim ALL string?])
</pre><span>
together with transduce would somehow do the trick?

the answer from the above data structure should be </span><code>4</code><span> as there are 4 strings of length 1 in the </span><code>:delim</code><span> maps in the exapmle</span></div><div data-t="mbjarland I suspect I’m just not friendly enough with transducers and am tripping over myself here"><span class="u" id="1514838662.000001">2018:01:01 20:31:02            mbjarland </span><span>I suspect I’m just not friendly enough with transducers and am tripping over myself here</span></div><div data-t="mbjarland one way would be to step out from specter and do: 
 (reduce + 
        (map count 
          (specter/select [ALL :delim ALL string?] my-d)))
 
but I figured there might be some way of being even terser here"><span class="u" id="1514839121.000040">2018:01:01 20:38:41            mbjarland </span><span>one way would be to step out from specter and do: 
</span><pre>(reduce + 
        (map count 
          (specter/select [ALL :delim ALL string?] my-d)))
</pre><span>
but I figured there might be some way of being even terser here</span></div><div data-t="nathanmarz @mbjarland this works:  (reduce + (traverse [ALL :delim ALL string? (view count)] data))"><span class="u" id="1514839460.000013">2018:01:01 20:44:20           nathanmarz </span><span>@mbjarland this works: </span><code>(reduce + (traverse [ALL :delim ALL string? (view count)] data))</code></div><div data-t="nathanmarz using  view  lets you avoid needing transducers to make this efficient"><span class="u" id="1514839489.000021">2018:01:01 20:44:49           nathanmarz </span><span>using </span><code>view</code><span> lets you avoid needing transducers to make this efficient</span></div><div data-t="mbjarland view …suspected there was something like this in there. Specter is awesome"><span class="u" id="1514886672.000103">2018:01:02 09:51:12            mbjarland </span><code>view</code><span>…suspected there was something like this in there. Specter is awesome</span></div><div data-t="nathanmarz Specter 1.1.0 released  https://groups.google.com/forum/#!topic/clojure/_VOAYtRkuNc"><span class="u" id="1514903736.000304">2018:01:02 14:35:36           nathanmarz </span><span>Specter 1.1.0 released </span><a href="https://groups.google.com/forum/#!topic/clojure/_VOAYtRkuNc">https://groups.google.com/forum/#!topic/clojure/_VOAYtRkuNc</a></div><div data-t="mbjarland if I wanted to do a chain of transformations and wanted to avoid writing: 
 (let [data (transform ... data)
      data (transform ... data)
        ...] )
 
how would I go about that?"><span class="u" id="1514949985.000125">2018:01:03 03:26:25            mbjarland </span><span>if I wanted to do a chain of transformations and wanted to avoid writing: 
</span><pre>(let [data (transform ... data)
      data (transform ... data)
        ...] )
</pre><span>
how would I go about that?</span></div><div data-t="nathanmarz @mbjarland either  (-&gt;&gt; data (transform ...) (transform ...))  or use  multi-transform"><span class="u" id="1514953467.000077">2018:01:03 04:24:27           nathanmarz </span><span>@mbjarland either </span><code>(-&gt;&gt; data (transform ...) (transform ...))</code><span> or use </span><code>multi-transform</code></div><div data-t="nathanmarz i prefer the former except where paths share a lot of structure"><span class="u" id="1514953513.000154">2018:01:03 04:25:13           nathanmarz </span><span>i prefer the former except where paths share a lot of structure</span></div><div data-t="wcohen is specter the proper tool for long/wide data transformations, analogous to R’s reshape2?
in other words, conversions from something like:
 {{:id 1 :year 2016 :val foo}
{:id 1 :year 2017 :val bar}
{:id 2 :year 2016 :val abc}
{:id 2 :year 2017 :val def}} 

to something like:
 {{:id 1 :2016 foo :2017 bar}
{:id 2 :2016 abc :2017 def}}"><span class="u" id="1515092388.000010">2018:01:04 18:59:48               wcohen </span><span>is specter the proper tool for long/wide data transformations, analogous to R’s reshape2?
in other words, conversions from something like:
</span><pre>{{:id 1 :year 2016 :val foo}
{:id 1 :year 2017 :val bar}
{:id 2 :year 2016 :val abc}
{:id 2 :year 2017 :val def}}</pre><span>

to something like:
</span><pre>{{:id 1 :2016 foo :2017 bar}
{:id 2 :2016 abc :2017 def}}</pre></div><div data-t="nathanmarz @wcohen no, that&apos;s not what specter&apos;s for"><span class="u" id="1515092529.000574">2018:01:04 19:02:09           nathanmarz </span><span>@wcohen no, that&apos;s not what specter&apos;s for</span></div><div data-t="wcohen thanks!"><span class="u" id="1515093442.000299">2018:01:04 19:17:22               wcohen </span><span>thanks!</span></div><div data-t="chromalchemy What&apos;s a good way to conditionally add/remove a value based on whether it&apos;s already in a collection? Basically like  assoc  or  dissoc  for vectors, based on value instead of index. Example: If  :a  is not it  in  [:b :c] , add it, else remove it."><span class="u" id="1515238426.000038">2018:01:06 11:33:46         chromalchemy </span><span>What&apos;s a good way to conditionally add/remove a value based on whether it&apos;s already in a collection? Basically like </span><code>assoc</code><span> or </span><code>dissoc</code><span> for vectors, based on value instead of index. Example: If </span><code>:a</code><span> is not it  in </span><code>[:b :c]</code><span>, add it, else remove it.</span></div><div data-t="chromalchemy I want to reach for  if-path  but don&apos;t think I can use  setval  with that to conditionally set  :a  or  NONE"><span class="u" id="1515238520.000079">2018:01:06 11:35:20         chromalchemy </span><span>I want to reach for </span><code>if-path</code><span> but don&apos;t think I can use </span><code>setval</code><span> with that to conditionally set </span><code>:a</code><span> or </span><code>NONE</code></div><div data-t="chromalchemy Or should I just stick to using maps?"><span class="u" id="1515238689.000020">2018:01:06 11:38:09         chromalchemy </span><span>Or should I just stick to using maps?</span></div><div data-t="chromalchemy I&apos;m trying to filter some items on some keywords, and I wanted to avoid having  {:a true :b false}  or  {:a nil :b :nil}  cluttering my data up. I feel like map values are redundant, because I can get boolean truthiness by testing for the presence of keywords (in maps at least)."><span class="u" id="1515239077.000054">2018:01:06 11:44:37         chromalchemy </span><span>I&apos;m trying to filter some items on some keywords, and I wanted to avoid having </span><code>{:a true :b false}</code><span> or </span><code>{:a nil :b :nil}</code><span> cluttering my data up. I feel like map values are redundant, because I can get boolean truthiness by testing for the presence of keywords (in maps at least).</span></div><div data-t="chromalchemy Probably I should use a set instead of a vector. But don&apos;t think that deserializes from Firebase properly, which is what I&apos;m using for persistence."><span class="u" id="1515240549.000107">2018:01:06 12:09:09         chromalchemy </span><span>Probably I should use a set instead of a vector. But don&apos;t think that deserializes from Firebase properly, which is what I&apos;m using for persistence.</span></div><div data-t="schmee @chromalchemy I think you can use  https://github.com/nathanmarz/specter/wiki/List-of-Macros#multi-transform  for this"><span class="u" id="1515241402.000006">2018:01:06 12:23:22               schmee </span><span>@chromalchemy I think you can use </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#multi-transform">https://github.com/nathanmarz/specter/wiki/List-of-Macros#multi-transform</a><span> for this</span></div><div data-t="chromalchemy @nathanmarz Thank. Can I use  multi-transform  with  if-path ?"><span class="u" id="1515245287.000016">2018:01:06 13:28:07         chromalchemy </span><span>@nathanmarz Thank. Can I use </span><code>multi-transform</code><span> with </span><code>if-path</code><span>?</span></div><div data-t="chromalchemy instead of  multi-path  in the examples..."><span class="u" id="1515245306.000031">2018:01:06 13:28:26         chromalchemy </span><span>instead of </span><code>multi-path</code><span> in the examples...</span></div><div data-t="chromalchemy right now I&apos;m hung up on:
 (select
    (if-path (= 1 2) ; false condition
      [ALL (pred= :a)]
      [ALL (pred= :c)])
    [:a :b :c])
=&gt; [:a]"><span class="u" id="1515245328.000045">2018:01:06 13:28:48         chromalchemy </span><span>right now I&apos;m hung up on:
</span><pre>(select
    (if-path (= 1 2) ; false condition
      [ALL (pred= :a)]
      [ALL (pred= :c)])
    [:a :b :c])
=&gt; [:a]</pre></div><div data-t="chromalchemy Doesn&apos;t seem to want to return the second path, based on the negative condition"><span class="u" id="1515245422.000033">2018:01:06 13:30:22         chromalchemy </span><span>Doesn&apos;t seem to want to return the second path, based on the negative condition</span></div><div data-t="chromalchemy Oh I think I see. It must be a conditional-path, not a generic condition..."><span class="u" id="1515245459.000040">2018:01:06 13:30:59         chromalchemy </span><span>Oh I think I see. It must be a conditional-path, not a generic condition...</span></div><div data-t="chromalchemy This is working!  (multi-transform
  (if-path
    [ ALL (pred= :a)]
    [ ALL (pred= :a) (terminal-val NONE)]
    [ BEFORE-ELEM (terminal-val :a)])
  [:a :b :c])"><span class="u" id="1515247914.000030">2018:01:06 14:11:54         chromalchemy </span><span>This is working! </span><pre>(multi-transform
  (if-path
    [ ALL (pred= :a)]
    [ ALL (pred= :a) (terminal-val NONE)]
    [ BEFORE-ELEM (terminal-val :a)])
  [:a :b :c])</pre></div><div data-t="chromalchemy Do you think I am barking up the wrong tree performance-wise to use keywords in vectors this way? The set of keywords will be pretty small, so I hope sequential lookup with  (pred=)  is not too big a drag."><span class="u" id="1515248085.000052">2018:01:06 14:14:45         chromalchemy </span><span>Do you think I am barking up the wrong tree performance-wise to use keywords in vectors this way? The set of keywords will be pretty small, so I hope sequential lookup with </span><code>(pred=)</code><span> is not too big a drag.</span></div><div data-t="nathanmarz @chromalchemy if ordering isn&apos;t important, then using a set or multi-set would be much more natural"><span class="u" id="1515248175.000051">2018:01:06 14:16:15           nathanmarz </span><span>@chromalchemy if ordering isn&apos;t important, then using a set or multi-set would be much more natural</span></div><div data-t="schmee hmm… am I doing something wrong here or is this supposed to work?
 user=&gt; (def data {:a [:x] :b [:x :x] :c [:x :x :x]})
#&apos;user/data
user=&gt; (select [MAP-VALS (view count)] data)
[1 2 3]
user=&gt; (reduce + (traverse [MAP-VALS (view count)] data))
6
user=&gt; (transduce (traverse-all [MAP-VALS (view count)]) + 0 data)
ClassCastException clojure.lang.Keyword cannot be cast to java.util.Map$Entry  clojure.lang.APersistentMap$ValSeq.first (APersistentMap.java:234)
"><span class="u" id="1515274448.000057">2018:01:06 21:34:08               schmee </span><span>hmm… am I doing something wrong here or is this supposed to work?
</span><pre>user=&gt; (def data {:a [:x] :b [:x :x] :c [:x :x :x]})
#&apos;user/data
user=&gt; (select [MAP-VALS (view count)] data)
[1 2 3]
user=&gt; (reduce + (traverse [MAP-VALS (view count)] data))
6
user=&gt; (transduce (traverse-all [MAP-VALS (view count)]) + 0 data)
ClassCastException clojure.lang.Keyword cannot be cast to java.util.Map$Entry  clojure.lang.APersistentMap$ValSeq.first (APersistentMap.java:234)
</pre></div><div data-t="nathanmarz traverse-all   runs on each item of sequential input"><span class="u" id="1515278318.000004">2018:01:06 22:38:38           nathanmarz </span><code>traverse-all</code><span>  runs on each item of sequential input</span></div><div data-t="nathanmarz @schmee which is why is has the  -all  suffix"><span class="u" id="1515278337.000064">2018:01:06 22:38:57           nathanmarz </span><span>@schmee which is why is has the </span><code>-all</code><span> suffix</span></div><div data-t="nathanmarz that&apos;s generally what transducers do"><span class="u" id="1515278471.000032">2018:01:06 22:41:11           nathanmarz </span><span>that&apos;s generally what transducers do</span></div><div data-t="schmee ok, I think I see the difference now"><span class="u" id="1515278632.000029">2018:01:06 22:43:52               schmee </span><span>ok, I think I see the difference now</span></div><div data-t="schmee so  traverse-all  can be transduced but  traverse  is reducible but not transducible?"><span class="u" id="1515278814.000080">2018:01:06 22:46:54               schmee </span><span>so </span><code>traverse-all</code><span> can be transduced but </span><code>traverse</code><span> is reducible but not transducible?</span></div><div data-t="schmee if that makes any sense"><span class="u" id="1515278841.000033">2018:01:06 22:47:21               schmee </span><span>if that makes any sense</span></div><div data-t="nathanmarz traverse-all  creates a transducer"><span class="u" id="1515279023.000120">2018:01:06 22:50:23           nathanmarz </span><code>traverse-all</code><span> creates a transducer</span></div><div data-t="nathanmarz traverse  returns a reducible object"><span class="u" id="1515279030.000064">2018:01:06 22:50:30           nathanmarz </span><code>traverse</code><span> returns a reducible object</span></div><div data-t="nathanmarz traverse-all  exists to integrate specter with transducers"><span class="u" id="1515279064.000017">2018:01:06 22:51:04           nathanmarz </span><code>traverse-all</code><span> exists to integrate specter with transducers</span></div><div data-t="schmee gotcha, thanks for clarifying  :+1:"><span class="u" id="1515282440.000010">2018:01:06 23:47:20               schmee </span><span>gotcha, thanks for clarifying </span><b>:+1:</b></div><div data-t="alexisvincent Specter is AWESOME"><span class="u" id="1515337319.000051">2018:01:07 15:01:59        alexisvincent </span><span>Specter is AWESOME</span></div><div data-t="alexisvincent I replaced 14 lines of knarly clojure code with 3 lines of Specter calls. @nathanmarz this library makes a huge difference! Thanks! Super impressive engineering"><span class="u" id="1515366843.000135">2018:01:07 23:14:03        alexisvincent </span><span>I replaced 14 lines of knarly clojure code with 3 lines of Specter calls. @nathanmarz this library makes a huge difference! Thanks! Super impressive engineering</span></div><div data-t="nathanmarz @alexisvincent great to hear"><span class="u" id="1515370648.000002">2018:01:08 00:17:28           nathanmarz </span><span>@alexisvincent great to hear</span></div><div data-t="aaelony New to Specter. I&apos;m scraping  http://docs.h2o.ai/h2o/latest-stable/h2o-docs/rest-api-reference.html  to build a vector of maps where each map will have a key for :http-verb, :rest-path :inputs and outputs.   Another challenge is that the html appears to be in 4 conceptual sections, 1) a section of a href links with rest endpoints, 2) a section of h2 headings with the http-verb and rest endpoint followed by a table with Input and Output, 3) a section of a href links with schema nouns, and 4) a final section of h2 headings with schema noun name followed by a table of keys and their descriptions.  How might I keep the four sections separate, before combining them?  I&apos;m also unclear if I should use  select ,  collect ,  codewalker , or  continue-then-stay  to collect and surface nested pieces of information.    Thanks in advance."><span class="u" id="1515401957.000238">2018:01:08 08:59:17              aaelony </span><span>New to Specter. I&apos;m scraping </span><a href="http://docs.h2o.ai/h2o/latest-stable/h2o-docs/rest-api-reference.html">http://docs.h2o.ai/h2o/latest-stable/h2o-docs/rest-api-reference.html</a><span> to build a vector of maps where each map will have a key for :http-verb, :rest-path :inputs and outputs.   Another challenge is that the html appears to be in 4 conceptual sections, 1) a section of a href links with rest endpoints, 2) a section of h2 headings with the http-verb and rest endpoint followed by a table with Input and Output, 3) a section of a href links with schema nouns, and 4) a final section of h2 headings with schema noun name followed by a table of keys and their descriptions.  How might I keep the four sections separate, before combining them?  I&apos;m also unclear if I should use </span><code>select</code><span>, </span><code>collect</code><span>, </span><code>codewalker</code><span>, or </span><code>continue-then-stay</code><span> to collect and surface nested pieces of information.    Thanks in advance.</span></div><div data-t="aaelony https://pastebin.com/q0RQzLic"><span class="u" id="1515402257.000288">2018:01:08 09:04:17              aaelony </span><a href="https://pastebin.com/q0RQzLic">https://pastebin.com/q0RQzLic</a></div><div data-t="nathanmarz @aaelony you&apos;re going to have to be more specific"><span class="u" id="1515422775.000252">2018:01:08 14:46:15           nathanmarz </span><span>@aaelony you&apos;re going to have to be more specific</span></div><div data-t="nathanmarz you want to use specter to extract information out of html?"><span class="u" id="1515422813.000282">2018:01:08 14:46:53           nathanmarz </span><span>you want to use specter to extract information out of html?</span></div><div data-t="nathanmarz can you paste a sample of the html you&apos;re scraping, and what you want as output?"><span class="u" id="1515422843.000299">2018:01:08 14:47:23           nathanmarz </span><span>can you paste a sample of the html you&apos;re scraping, and what you want as output?</span></div><div data-t="aaelony ok, let me take some time to formulate a better question."><span class="u" id="1515429574.000381">2018:01:08 16:39:34              aaelony </span><span>ok, let me take some time to formulate a better question.</span></div><div data-t="aaelony hi @nathanmarz, here is the code in clojure that I&apos;m wondering how to produce in Specter."><span class="u" id="1515442843.000386">2018:01:08 20:20:43              aaelony </span><span>hi @nathanmarz, here is the code in clojure that I&apos;m wondering how to produce in Specter.</span></div><div data-t="aaelony (ns testing 
      (:require [net.cgrand.enlive-html :as html]                                                                                                                                                                                                                                  
            [org.httpkit.client :as http]                                                                                                                                                                                                                                      
            [clojure.string :as str] ))

(-&gt;&gt; (html/html-snippet
(:body @(http/get &quot;&quot;
{:insecure false})))
(filterv #(= (:tag %) :html))
first
:content
(filterv #(= (:tag %) :body))
first
:content
(filterv #(= (:tag %) :div))
first
:content
(filterv #(= (:tag %) :h2))
(mapv #(let [[verb endpoint] (-&gt; %
:content
first
(str/split #&quot; &quot;)
)
inputs (if endpoint
(re-seq #&quot;\{(.*?)\}&quot; endpoint))
]
{:verb verb :endpoint endpoint :inputs inputs}
))
(filterv #(or (= (:verb %) &quot;GET&quot;)
(= (:verb %) &quot;POST&quot;)
(= (:verb %) &quot;DELETE&quot;)
(= (:verb %) &quot;HEAD&quot;)))
)
"><span class="u" id="1515442845.000285">2018:01:08 20:20:45              aaelony </span><pre>(ns testing 
      (:require [net.cgrand.enlive-html :as html]                                                                                                                                                                                                                                  
            [org.httpkit.client :as http]                                                                                                                                                                                                                                      
            [clojure.string :as str] ))

(-&gt;&gt; (html/html-snippet
(:body @(http/get &quot;&quot;
{:insecure false})))
(filterv #(= (:tag %) :html))
first
:content
(filterv #(= (:tag %) :body))
first
:content
(filterv #(= (:tag %) :div))
first
:content
(filterv #(= (:tag %) :h2))
(mapv #(let [[verb endpoint] (-&gt; %
:content
first
(str/split #&quot; &quot;)
)
inputs (if endpoint
(re-seq #&quot;\{(.*?)\}&quot; endpoint))
]
{:verb verb :endpoint endpoint :inputs inputs}
))
(filterv #(or (= (:verb %) &quot;GET&quot;)
(= (:verb %) &quot;POST&quot;)
(= (:verb %) &quot;DELETE&quot;)
(= (:verb %) &quot;HEAD&quot;)))
)
</pre></div><div data-t="nathanmarz @aaelony with specter it would be something like:
 (defn first-matching-tag [tag]
  (path (filterer #(= (:tag %) tag)) FIRST))

(select
  [(first-matching-tag :html)
   :content
   (first-matching-tag :div)
   :content
   (first-matching-tag :h2)
   ALL
   :content
   FIRST
   (view #(str/split #&quot; &quot;))
   (fn [[verb _]] (#{&quot;GET&quot; &quot;POST&quot; &quot;DELETE&quot; &quot;HEAD&quot;} verb))
   
  ]
 data)
"><span class="u" id="1515457933.000340">2018:01:09 00:32:13           nathanmarz </span><span>@aaelony with specter it would be something like:
</span><pre>(defn first-matching-tag [tag]
  (path (filterer #(= (:tag %) tag)) FIRST))

(select
  [(first-matching-tag :html)
   :content
   (first-matching-tag :div)
   :content
   (first-matching-tag :h2)
   ALL
   :content
   FIRST
   (view #(str/split #&quot; &quot;))
   (fn [[verb _]] (#{&quot;GET&quot; &quot;POST&quot; &quot;DELETE&quot; &quot;HEAD&quot;} verb))
   
  ]
 data)
</pre></div><div data-t="nathanmarz plus a little extra code to do that processing of &quot;inputs&quot; in your code"><span class="u" id="1515457952.000052">2018:01:09 00:32:32           nathanmarz </span><span>plus a little extra code to do that processing of &quot;inputs&quot; in your code</span></div><div data-t="aaelony Thank-you, @nathanmarz. Looks more elegant and concise. I was unaware of the path macro. I’ll need to look into it. Eager to understand Specter better."><span class="u" id="1515459231.000151">2018:01:09 00:53:51              aaelony </span><span>Thank-you, @nathanmarz. Looks more elegant and concise. I was unaware of the path macro. I’ll need to look into it. Eager to understand Specter better.</span></div><div data-t="nathanmarz @aaelony  select ,  transform  etc. implicitly use that macro"><span class="u" id="1515459310.000046">2018:01:09 00:55:10           nathanmarz </span><span>@aaelony </span><code>select</code><span>, </span><code>transform</code><span> etc. implicitly use that macro</span></div><div data-t="nathanmarz path  is the heart of what makes specter work"><span class="u" id="1515459338.000021">2018:01:09 00:55:38           nathanmarz </span><code>path</code><span> is the heart of what makes specter work</span></div><div data-t="aaelony any reason why path instead of select in this case?"><span class="u" id="1515459606.000106">2018:01:09 01:00:06              aaelony </span><span>any reason why path instead of select in this case?</span></div><div data-t="nathanmarz first-matching-tag  returns a navigator to be composed with rest of path"><span class="u" id="1515459731.000032">2018:01:09 01:02:11           nathanmarz </span><code>first-matching-tag</code><span> returns a navigator to be composed with rest of path</span></div><div data-t="nathanmarz select  invokes a navigator on a piece of data"><span class="u" id="1515459748.000186">2018:01:09 01:02:28           nathanmarz </span><code>select</code><span> invokes a navigator on a piece of data</span></div><div data-t="aaelony got it. thanks again"><span class="u" id="1515465874.000280">2018:01:09 02:44:34              aaelony </span><span>got it. thanks again</span></div><div data-t="phreed Is there a way to do mutual navigation? A use would be to update one structure with data from another."><span class="u" id="1515710127.000222">2018:01:11 22:35:27               phreed </span><span>Is there a way to do mutual navigation? A use would be to update one structure with data from another.</span></div><div data-t="nathanmarz @phreed do you have an example of a transformation of this sort?"><span class="u" id="1515712537.000437">2018:01:11 23:15:37           nathanmarz </span><span>@phreed do you have an example of a transformation of this sort?</span></div><div data-t="phreed The general idea is seen in the &apos;reduce&apos; macro where one navigation is done over the collection and the reducing function navigates over and updates the accumulator. If the accumulator were implemented as a zipper the position would persist.
In the large, assume I have a database for which I have just received a message on a relevant topic with which I want to update my database. I will navigate the message and use the information found there to navigate the database.
There would be some collect object shared between the two navigators.
The database could be a graph."><span class="u" id="1515713752.000325">2018:01:11 23:35:52               phreed </span><span>The general idea is seen in the &apos;reduce&apos; macro where one navigation is done over the collection and the reducing function navigates over and updates the accumulator. If the accumulator were implemented as a zipper the position would persist.
In the large, assume I have a database for which I have just received a message on a relevant topic with which I want to update my database. I will navigate the message and use the information found there to navigate the database.
There would be some collect object shared between the two navigators.
The database could be a graph.</span></div><div data-t="nathanmarz @phreed you can use  collect  and  collect-one  to collect additional information about the data structure during navigation"><span class="u" id="1515714237.000226">2018:01:11 23:43:57           nathanmarz </span><span>@phreed you can use </span><code>collect</code><span> and </span><code>collect-one</code><span> to collect additional information about the data structure during navigation</span></div><div data-t="nathanmarz either as additional arguments to the transform function or returned with the navigated values in  select"><span class="u" id="1515714257.000090">2018:01:11 23:44:17           nathanmarz </span><span>either as additional arguments to the transform function or returned with the navigated values in </span><code>select</code></div><div data-t="nathanmarz there&apos;s an example of doing that with a recursive data structure here:  https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure"><span class="u" id="1515714304.000017">2018:01:11 23:45:04           nathanmarz </span><span>there&apos;s an example of doing that with a recursive data structure here: </span><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure</a></div><div data-t="phreed @nathanmarz Yes I have been using the collect twins with select which constructs a seq. I will take a look at the example."><span class="u" id="1515717018.000328">2018:01:12 00:30:18               phreed </span><span>@nathanmarz Yes I have been using the collect twins with select which constructs a seq. I will take a look at the example.</span></div><div data-t="schmee is there a way to make  transform  halt after the first successful navigation, something like  transform-one ?"><span class="u" id="1515745296.000170">2018:01:12 08:21:36               schmee </span><span>is there a way to make </span><code>transform</code><span> halt after the first successful navigation, something like </span><code>transform-one</code><span>?</span></div><div data-t="schmee I’m thinking about this case:  user=&gt; (def a [{:name &quot;foo&quot; :id 1} {:name &quot;bar&quot; :id 2}])
#&apos;user/a
user=&gt; (transform [ALL (selected? :id (pred= 2))] #(assoc % :name &quot;not-foo&quot;) a)
[{:id 1 :name &quot;foo&quot;} {:id 2 :name &quot;not-foo&quot;}]"><span class="u" id="1515745306.000006">2018:01:12 08:21:46               schmee </span><span>I’m thinking about this case: </span><pre>user=&gt; (def a [{:name &quot;foo&quot; :id 1} {:name &quot;bar&quot; :id 2}])
#&apos;user/a
user=&gt; (transform [ALL (selected? :id (pred= 2))] #(assoc % :name &quot;not-foo&quot;) a)
[{:id 1 :name &quot;foo&quot;} {:id 2 :name &quot;not-foo&quot;}]</pre></div><div data-t="schmee since ids are unique, there will only be one element selected so there is no need to check the rest of the elements once it has been found"><span class="u" id="1515745348.000004">2018:01:12 08:22:28               schmee </span><span>since ids are unique, there will only be one element selected so there is no need to check the rest of the elements once it has been found</span></div><div data-t="schmee I don’t know if that makes any sense  😄"><span class="u" id="1515745545.000199">2018:01:12 08:25:45               schmee </span><span>I don’t know if that makes any sense </span><b>😄</b></div><div data-t="nathanmarz @schmee no, nothing like that currently"><span class="u" id="1515766371.000233">2018:01:12 14:12:51           nathanmarz </span><span>@schmee no, nothing like that currently</span></div><div data-t="nathanmarz this idea might be applicable to that kind of behavior:  https://github.com/nathanmarz/specter/issues/121"><span class="u" id="1515766422.000002">2018:01:12 14:13:42           nathanmarz </span><span>this idea might be applicable to that kind of behavior: </span><a href="https://github.com/nathanmarz/specter/issues/121">https://github.com/nathanmarz/specter/issues/121</a></div><div data-t="schmee yeah that seems to be it, I’ll keep an eye on that issue  👍"><span class="u" id="1515767602.000045">2018:01:12 14:33:22               schmee </span><span>yeah that seems to be it, I’ll keep an eye on that issue </span><b>👍</b></div><div data-t="mbjarland how would I move a piece of a data structure (nested maps and vectors)  from one path to another? Seems transform points at a path and changes the value at that path using a function. Would it be a  select  followed by a  setval  or is there a one-liner?"><span class="u" id="1515883787.000018">2018:01:13 22:49:47            mbjarland </span><span>how would I move a piece of a data structure (nested maps and vectors)  from one path to another? Seems transform points at a path and changes the value at that path using a function. Would it be a </span><code>select</code><span> followed by a </span><code>setval</code><span> or is there a one-liner?</span></div><div data-t="mbjarland let me rephrase that because the case is more complex, how would I go from: 
 {:layout    [{:repeat [:a]}
             {:delim [&quot; &quot;]}
             {:repeat [:b]}],
 :apply-for [:odd :even]}
 
to
 {:layout    [{:repeat [:a] :apply-for :odd}
             {:delim [&quot; &quot;]}
             {:repeat [:b] :apply-for :even}]}
 
where there are as many elements in the  :apply-for  vector as there are  :repeat  maps in be before structure. So we are matching by index and moving the  :odd  and  :even  to the corresponding  :repeat  map"><span class="u" id="1515884227.000046">2018:01:13 22:57:07            mbjarland </span><span>let me rephrase that because the case is more complex, how would I go from: 
</span><pre>{:layout    [{:repeat [:a]}
             {:delim [&quot; &quot;]}
             {:repeat [:b]}],
 :apply-for [:odd :even]}
</pre><span>
to
</span><pre>{:layout    [{:repeat [:a] :apply-for :odd}
             {:delim [&quot; &quot;]}
             {:repeat [:b] :apply-for :even}]}
</pre><span>
where there are as many elements in the </span><code>:apply-for</code><span> vector as there are </span><code>:repeat</code><span> maps in be before structure. So we are matching by index and moving the </span><code>:odd</code><span> and </span><code>:even</code><span> to the corresponding </span><code>:repeat</code><span> map</span></div><div data-t="mbjarland I get the feeling I might have to select the vector and then do a stateful  transform  call where the transform function would pull items from the vector one-by-one, but let me know if there is some better way"><span class="u" id="1515884345.000027">2018:01:13 22:59:05            mbjarland </span><span>I get the feeling I might have to select the vector and then do a stateful </span><code>transform</code><span> call where the transform function would pull items from the vector one-by-one, but let me know if there is some better way</span></div><div data-t="nathanmarz @mbjarland use  subselect"><span class="u" id="1515886595.000084">2018:01:13 23:36:35           nathanmarz </span><span>@mbjarland use </span><code>subselect</code></div><div data-t="nathanmarz (let [af (:apply-for data)]
  (-&gt;&gt; data
       (setval [:layout
                (subselect
                  ALL
                  #(contains? % :repeat)
                  :apply-for)
                ]
                af)
       (setval :apply-for NONE)
       ))
"><span class="u" id="1515886608.000045">2018:01:13 23:36:48           nathanmarz </span><pre>(let [af (:apply-for data)]
  (-&gt;&gt; data
       (setval [:layout
                (subselect
                  ALL
                  #(contains? % :repeat)
                  :apply-for)
                ]
                af)
       (setval :apply-for NONE)
       ))
</pre></div><div data-t="mbjarland @nathanmarz wow…that is some kung-fu. Am I reading that right that we are essentially selecting a bunch of nodes in the datastructure as targets for the setval and then assigning using a vector and out comes the transformed data structure? That is perhaps the coolest statement I’ve seen so far from specter. I rewrote the subseelct path as  (subselect ALL (pred :repeat) :apply-for) , seems to do the same thing. Naturally the reward for an awesome answer is another question…is there a way in specter to select the node after a node we match in a vector, i.e. assume a vector: 
 [:a :b :c :d :e 1 :f :g]
 
and I would like to select the item after  :e"><span class="u" id="1515939901.000094">2018:01:14 14:25:01            mbjarland </span><span>@nathanmarz wow…that is some kung-fu. Am I reading that right that we are essentially selecting a bunch of nodes in the datastructure as targets for the setval and then assigning using a vector and out comes the transformed data structure? That is perhaps the coolest statement I’ve seen so far from specter. I rewrote the subseelct path as </span><code>(subselect ALL (pred :repeat) :apply-for)</code><span>, seems to do the same thing. Naturally the reward for an awesome answer is another question…is there a way in specter to select the node after a node we match in a vector, i.e. assume a vector: 
</span><pre>[:a :b :c :d :e 1 :f :g]
</pre><span>
and I would like to select the item after </span><code>:e</code></div><div data-t="nathanmarz subselect  lets you manipulate an arbitrary selection path as a sequence, where changes to the sequence apply at the original locations"><span class="u" id="1515940163.000062">2018:01:14 14:29:23           nathanmarz </span><code>subselect</code><span> lets you manipulate an arbitrary selection path as a sequence, where changes to the sequence apply at the original locations</span></div><div data-t="nathanmarz @mbjarland you can do that with zippers"><span class="u" id="1515940212.000166">2018:01:14 14:30:12           nathanmarz </span><span>@mbjarland you can do that with zippers</span></div><div data-t="nathanmarz also possible with  srange-dynamic"><span class="u" id="1515940231.000063">2018:01:14 14:30:31           nathanmarz </span><span>also possible with </span><code>srange-dynamic</code></div><div data-t="nathanmarz or you can make a custom navigator"><span class="u" id="1515940250.000059">2018:01:14 14:30:50           nathanmarz </span><span>or you can make a custom navigator</span></div><div data-t="jeremys Hey guys I have been scratching my head for some time now. I want to operate the following transformation :
 [&quot;toto&quot;
{:tag tag-to-unwrap :content [&quot;titi&quot; &quot;tutu&quot;]}
{:tag tag-to-unwrap :content [&quot;toto&quot;]}]
;=&gt;
[&quot;toto&quot; &quot;titi&quot; &quot;tutu&quot; &quot;toto&quot;]
 
Right now with:
 (transform [ALL XML-ZIP NEXT-WALK NODE map? #(= :tag-to-unwrap (:tag %))]
:content
[&quot;toto&quot;
{:tag tag-to-unwrap :content [&quot;titi&quot; &quot;tutu&quot;]}
{:tag tag-to-unwrap :content [&quot;toto&quot;]}])
 
I get
 [&quot;toto&quot; [&quot;titi&quot; &quot;tutu&quot;] [&quot;toto&quot;]] 
Can I get specter to “splice” the vectors  [&quot;titi&quot; &quot;tutu&quot;] and  [&quot;toto&quot;] in the result?"><span class="u" id="1516205242.000050">2018:01:17 16:07:22              jeremys </span><span>Hey guys I have been scratching my head for some time now. I want to operate the following transformation :
</span><pre>[&quot;toto&quot;
{:tag tag-to-unwrap :content [&quot;titi&quot; &quot;tutu&quot;]}
{:tag tag-to-unwrap :content [&quot;toto&quot;]}]
;=&gt;
[&quot;toto&quot; &quot;titi&quot; &quot;tutu&quot; &quot;toto&quot;]
</pre><span>
Right now with:
</span><pre>(transform [ALL XML-ZIP NEXT-WALK NODE map? #(= :tag-to-unwrap (:tag %))]
:content
[&quot;toto&quot;
{:tag tag-to-unwrap :content [&quot;titi&quot; &quot;tutu&quot;]}
{:tag tag-to-unwrap :content [&quot;toto&quot;]}])
</pre><span>
I get
</span><pre>[&quot;toto&quot; [&quot;titi&quot; &quot;tutu&quot;] [&quot;toto&quot;]]</pre><span>
Can I get specter to “splice” the vectors </span><code>[&quot;titi&quot; &quot;tutu&quot;]</code><span>and </span><code>[&quot;toto&quot;]</code><span>in the result?</span></div><div data-t="nathanmarz @jeremys with what&apos;s built-in you can do something like this:
 (require &apos;[com.rpl.specter.zipper :as z])

(def data
  [&quot;toto&quot;
    {:tag :a :content [&quot;titi&quot; &quot;tutu&quot;]}
    {:tag :a :content [&quot;toto&quot;]}]
  )

(transform
  [z/VECTOR-ZIP
   z/DOWN
   z/NEXT-WALK
   (selected? z/NODE map?)
   z/NODE-SEQ]
  #(select [FIRST :content ALL] %)
  data)
"><span class="u" id="1516206004.000517">2018:01:17 16:20:04           nathanmarz </span><span>@jeremys with what&apos;s built-in you can do something like this:
</span><pre>(require &apos;[com.rpl.specter.zipper :as z])

(def data
  [&quot;toto&quot;
    {:tag :a :content [&quot;titi&quot; &quot;tutu&quot;]}
    {:tag :a :content [&quot;toto&quot;]}]
  )

(transform
  [z/VECTOR-ZIP
   z/DOWN
   z/NEXT-WALK
   (selected? z/NODE map?)
   z/NODE-SEQ]
  #(select [FIRST :content ALL] %)
  data)
</pre></div><div data-t="nathanmarz it&apos;s also pretty easy to make an  ALL-SEQ  navigator which navigates to each element as a 1 element sequence, and then you could do:
 (transform [ALL-SEQ (selected? FIRST map?)]
  #(select [FIRST :content ALL] %)
  data
  )
"><span class="u" id="1516206070.000250">2018:01:17 16:21:10           nathanmarz </span><span>it&apos;s also pretty easy to make an </span><code>ALL-SEQ</code><span> navigator which navigates to each element as a 1 element sequence, and then you could do:
</span><pre>(transform [ALL-SEQ (selected? FIRST map?)]
  #(select [FIRST :content ALL] %)
  data
  )
</pre></div><div data-t="nathanmarz technically this would work:  (def ALL-SEQ (path z/VECTOR-ZIP z/DOWN z/NEXT-WALK z/NODE-SEQ))"><span class="u" id="1516206165.001072">2018:01:17 16:22:45           nathanmarz </span><span>technically this would work: </span><code>(def ALL-SEQ (path z/VECTOR-ZIP z/DOWN z/NEXT-WALK z/NODE-SEQ))</code></div><div data-t="nathanmarz though you could make it more efficient with a custom navigator"><span class="u" id="1516206174.000386">2018:01:17 16:22:54           nathanmarz </span><span>though you could make it more efficient with a custom navigator</span></div><div data-t="nathanmarz another solution:
 (transform (continuous-subseqs map?)
  #(select [ALL :content ALL] %)
  data
  )
"><span class="u" id="1516206346.000328">2018:01:17 16:25:46           nathanmarz </span><span>another solution:
</span><pre>(transform (continuous-subseqs map?)
  #(select [ALL :content ALL] %)
  data
  )
</pre></div><div data-t="jeremys Thx @nathanmarz I’ll take a look and see what I can come up with."><span class="u" id="1516206467.000785">2018:01:17 16:27:47              jeremys </span><span>Thx @nathanmarz I’ll take a look and see what I can come up with.</span></div><div data-t="jose hi, first of all, I&apos;m really enjoying specter and how easy makes many things, but I have a case where I&apos;m thinking that maybe is better to not use specter. I have a map where I want to remove and rename some keys.
e.g. with specter:
 (-&gt;&gt; {:id 1 :data_val 5 :bad nil}
    (s/select-one (s/submap [:id :data_val]))
    (s/transform [s/MAP-KEYS] #(case % :data_val :value %))
 
and without
 (-&gt; {:id 1 :data_val 5 :bad nil}
    (select-keys [:id :data_val])
    (clojure.set/rename-keys {:data_val :value}))
 
what do you think? makes sense to use specter here? Is there a better way to do it with specter?"><span class="u" id="1516276307.000124">2018:01:18 11:51:47                 jose </span><span>hi, first of all, I&apos;m really enjoying specter and how easy makes many things, but I have a case where I&apos;m thinking that maybe is better to not use specter. I have a map where I want to remove and rename some keys.
e.g. with specter:
</span><pre>(-&gt;&gt; {:id 1 :data_val 5 :bad nil}
    (s/select-one (s/submap [:id :data_val]))
    (s/transform [s/MAP-KEYS] #(case % :data_val :value %))
</pre><span>
and without
</span><pre>(-&gt; {:id 1 :data_val 5 :bad nil}
    (select-keys [:id :data_val])
    (clojure.set/rename-keys {:data_val :value}))
</pre><span>
what do you think? makes sense to use specter here? Is there a better way to do it with specter?</span></div><div data-t="souenzzo Almost the same perf
I think that w/o spec is more readable, in this case.
 (time
  (doseq [i (range 1000000)]
    (-&gt;&gt; {:id 1 :data_val 5 :bad nil}
         (s/select-one (s/submap [:id :data_val]))
         (s/transform [s/MAP-KEYS] #(case % :data_val :value %)))))
&quot;Elapsed time: 1031.939844 msecs&quot;
=&gt; nil
(time
  (doseq [i (range 1000000)]
    (-&gt; {:id 1 :data_val 5 :bad nil}
        (select-keys [:id :data_val])
        (clojure.set/rename-keys {:data_val :value}))))
&quot;Elapsed time: 1794.127254 msecs&quot;
"><span class="u" id="1516285512.000781">2018:01:18 14:25:12                  souenzzo </span><span>Almost the same perf
I think that w/o spec is more readable, in this case.
</span><pre>(time
  (doseq [i (range 1000000)]
    (-&gt;&gt; {:id 1 :data_val 5 :bad nil}
         (s/select-one (s/submap [:id :data_val]))
         (s/transform [s/MAP-KEYS] #(case % :data_val :value %)))))
&quot;Elapsed time: 1031.939844 msecs&quot;
=&gt; nil
(time
  (doseq [i (range 1000000)]
    (-&gt; {:id 1 :data_val 5 :bad nil}
        (select-keys [:id :data_val])
        (clojure.set/rename-keys {:data_val :value}))))
&quot;Elapsed time: 1794.127254 msecs&quot;
</pre></div><div data-t="souenzzo Mine is a bit faster. And has data/explicit params.
 (let [n 10000000]
  (prn &quot;specter&quot;)
  (time
    (doseq [i (range n)]
      (-&gt;&gt; {:id 1 :data_val 5 :bad nil}
           (s/select-one (s/submap [:id :data_val]))
           (s/transform [s/MAP-KEYS] #(case % :data_val :value %)))))
  (prn &quot;@souenzzo&quot;)
  (time
    (doseq [i (range n)]
      (let [from-&gt;to {:data_val :value
                      :id       :id}]
        (reduce-kv (fn [acc k v]
                     (if (contains? from-&gt;to k)
                       (assoc acc (from-&gt;to k) v)
                       acc)) {} {:id 1 :data_val 5 :bad nil})))))
"><span class="u" id="1516286101.000128">2018:01:18 14:35:01                  souenzzo </span><span>Mine is a bit faster. And has data/explicit params.
</span><pre>(let [n 10000000]
  (prn &quot;specter&quot;)
  (time
    (doseq [i (range n)]
      (-&gt;&gt; {:id 1 :data_val 5 :bad nil}
           (s/select-one (s/submap [:id :data_val]))
           (s/transform [s/MAP-KEYS] #(case % :data_val :value %)))))
  (prn &quot;@souenzzo&quot;)
  (time
    (doseq [i (range n)]
      (let [from-&gt;to {:data_val :value
                      :id       :id}]
        (reduce-kv (fn [acc k v]
                     (if (contains? from-&gt;to k)
                       (assoc acc (from-&gt;to k) v)
                       acc)) {} {:id 1 :data_val 5 :bad nil})))))
</pre></div><div data-t="jose @U2J4FRT2T thanks for your example, didn&apos;t know about reduce-kv"><span class="u" id="1516310934.000047">2018:01:18 21:28:54                      jose </span><span>@U2J4FRT2T thanks for your example, didn&apos;t know about reduce-kv</span></div><div data-t="jeremys Hey guys, I wanted to share how I am finally going about “splicing” some tags in a html tree. I realize I hadn’t properly formulated my problem... Anyway here’s the code:
 (require &apos;[com.rpl.specter :as sp])
(require &apos;[com.rpl.specter.zipper :as spz])
(require &apos;[clojure.zip :as zip])

(def tag-to-unwrap :tag-to-unwrap)
(defn tag-to-unwrap? [t] (= (:tag t) tag-to-unwrap))
(defn tag?-to-unwrap? [t] (and (map? t) (tag-to-unwrap? t)))

(def TAGS-TO-UNWRAP (sp/path [spz/XML-ZIP spz/NEXT-WALK
(sp/selected? [spz/NODE tag?-to-unwrap?])]))

(defn unwrap [zipper]
(let [cs (zip/children zipper)
zipper (reduce zip/insert-right zipper (reverse cs))]
(zip/remove zipper)))

(defn splice-doc [doc]
(sp/transform TAGS-TO-UNWRAP unwrap doc))

(splice-doc
{:tag :body
:content [&quot;toto&quot;
{:tag tag-to-unwrap :content [&quot;titi&quot; &quot;tutu&quot;]}
{:tag :div
:content [{:tag tag-to-unwrap :content [&quot;toto in a div&quot;]}]}]})
;=&gt;
{:tag :body, :content [&quot;toto&quot; &quot;titi&quot; &quot;tutu&quot; {:tag :div, :content [&quot;toto in a div&quot;]}]}
"><span class="u" id="1516378336.000402">2018:01:19 16:12:16              jeremys </span><span>Hey guys, I wanted to share how I am finally going about “splicing” some tags in a html tree. I realize I hadn’t properly formulated my problem... Anyway here’s the code:
</span><pre>(require &apos;[com.rpl.specter :as sp])
(require &apos;[com.rpl.specter.zipper :as spz])
(require &apos;[clojure.zip :as zip])

(def tag-to-unwrap :tag-to-unwrap)
(defn tag-to-unwrap? [t] (= (:tag t) tag-to-unwrap))
(defn tag?-to-unwrap? [t] (and (map? t) (tag-to-unwrap? t)))

(def TAGS-TO-UNWRAP (sp/path [spz/XML-ZIP spz/NEXT-WALK
(sp/selected? [spz/NODE tag?-to-unwrap?])]))

(defn unwrap [zipper]
(let [cs (zip/children zipper)
zipper (reduce zip/insert-right zipper (reverse cs))]
(zip/remove zipper)))

(defn splice-doc [doc]
(sp/transform TAGS-TO-UNWRAP unwrap doc))

(splice-doc
{:tag :body
:content [&quot;toto&quot;
{:tag tag-to-unwrap :content [&quot;titi&quot; &quot;tutu&quot;]}
{:tag :div
:content [{:tag tag-to-unwrap :content [&quot;toto in a div&quot;]}]}]})
;=&gt;
{:tag :body, :content [&quot;toto&quot; &quot;titi&quot; &quot;tutu&quot; {:tag :div, :content [&quot;toto in a div&quot;]}]}
</pre></div><div data-t="jeremys cheers"><span class="u" id="1516378342.000237">2018:01:19 16:12:22              jeremys </span><span>cheers</span></div><div data-t="dadair Given  add-ref  and  parse-tree  in the following snippet, is there a way to combine this pair of transform/traverse into a single traversal (to improve performance by not requiring a multi-pass of a large datastructure?)

 (def NODE
    (sp/recursive-path [] p
                       (sp/continue-then-stay
                        (sp/must :children)
                        sp/MAP-VALS
                        p)))

  (def terminal2
    (sp/richnav [afn]
                (sp/select* [this vals structure next-fn]
                            (throw (Exception. &quot;&apos;terminal2&apos; should only be used in multi-transform&quot;)))
                (sp/transform* [this vals structure next-fn]
                               (afn vals structure))))

  (def nodes-with-refs
    (sp/recursive-path [] p
                       (sp/continue-then-stay
                        (sp/putval :children)
                        (sp/must :children)
                        sp/ALL
                        (sp/collect-one sp/FIRST)
                        sp/LAST
                        p)))

  (defn add-ref [root]
    (sp/multi-transform
     [(sp/putval :root)
      :root
      nodes-with-refs
      :ref
      (terminal2 (fn [vals _] (ref/unparse vals)))]
     root))

  (defn parse-tree [root]
    (reduce
     (fn [result item]
       (if-let [parsed (parse-node item)]
         (conj result parsed)
         result))
     []
     (sp/traverse [:root :children MAP-VALS NODE] root)))

  (-&gt;&gt; test-segment ;; potentially large datastructure with form {:root {:name &quot;root&quot; .. :children {..}}}
       add-ref ;; add path down the tree to each node in the tree, e.g., &quot;/a/b/c&quot; where A, B, C are nodes with names a, b, c
       parse-tree)
"><span class="u" id="1516830137.000144">2018:01:24 21:42:17               dadair </span><span>Given </span><code>add-ref</code><span> and </span><code>parse-tree</code><span> in the following snippet, is there a way to combine this pair of transform/traverse into a single traversal (to improve performance by not requiring a multi-pass of a large datastructure?)

</span><pre>(def NODE
    (sp/recursive-path [] p
                       (sp/continue-then-stay
                        (sp/must :children)
                        sp/MAP-VALS
                        p)))

  (def terminal2
    (sp/richnav [afn]
                (sp/select* [this vals structure next-fn]
                            (throw (Exception. &quot;&apos;terminal2&apos; should only be used in multi-transform&quot;)))
                (sp/transform* [this vals structure next-fn]
                               (afn vals structure))))

  (def nodes-with-refs
    (sp/recursive-path [] p
                       (sp/continue-then-stay
                        (sp/putval :children)
                        (sp/must :children)
                        sp/ALL
                        (sp/collect-one sp/FIRST)
                        sp/LAST
                        p)))

  (defn add-ref [root]
    (sp/multi-transform
     [(sp/putval :root)
      :root
      nodes-with-refs
      :ref
      (terminal2 (fn [vals _] (ref/unparse vals)))]
     root))

  (defn parse-tree [root]
    (reduce
     (fn [result item]
       (if-let [parsed (parse-node item)]
         (conj result parsed)
         result))
     []
     (sp/traverse [:root :children MAP-VALS NODE] root)))

  (-&gt;&gt; test-segment ;; potentially large datastructure with form {:root {:name &quot;root&quot; .. :children {..}}}
       add-ref ;; add path down the tree to each node in the tree, e.g., &quot;/a/b/c&quot; where A, B, C are nodes with names a, b, c
       parse-tree)
</pre></div><div data-t="nathanmarz @dadair can you just collect the path in  parse-tree ?"><span class="u" id="1516830373.000644">2018:01:24 21:46:13           nathanmarz </span><span>@dadair can you just collect the path in </span><code>parse-tree</code><span>?</span></div><div data-t="nathanmarz besides that, the latest release adds  vtransform  which eliminate the need for you to do  multi-transform  with custom  terminal2"><span class="u" id="1516830422.000036">2018:01:24 21:47:02           nathanmarz </span><span>besides that, the latest release adds </span><code>vtransform</code><span> which eliminate the need for you to do </span><code>multi-transform</code><span> with custom </span><code>terminal2</code></div><div data-t="nathanmarz you might benefit here from a new  vselect  which navigates to  [collected-vals navigated-value]"><span class="u" id="1516830497.000573">2018:01:24 21:48:17           nathanmarz </span><span>you might benefit here from a new </span><code>vselect</code><span> which navigates to </span><code>[collected-vals navigated-value]</code></div><div data-t="dadair Thanks for pointing out  vtransform , cleans up the code! I’m not quite sure how I would go about collecting the path in parse-tree, and passing those collected values into the reducing function."><span class="u" id="1516831538.000535">2018:01:24 22:05:38               dadair </span><span>Thanks for pointing out </span><code>vtransform</code><span>, cleans up the code! I’m not quite sure how I would go about collecting the path in parse-tree, and passing those collected values into the reducing function.</span></div><div data-t="dadair hmm, are you suggesting that I could change the  sp/traverse  call to a  vselect , and then  item  in the reduce would be  [collected navigated] ?"><span class="u" id="1516831682.000415">2018:01:24 22:08:02               dadair </span><span>hmm, are you suggesting that I could change the </span><code>sp/traverse</code><span> call to a </span><code>vselect</code><span>, and then </span><code>item</code><span> in the reduce would be </span><code>[collected navigated]</code><span>?</span></div><div data-t="nathanmarz @dadair yes, that&apos;s right"><span class="u" id="1516842391.000053">2018:01:25 01:06:31           nathanmarz </span><span>@dadair yes, that&apos;s right</span></div><div data-t="nathanmarz would add a  vtraverse  as well"><span class="u" id="1516842441.000155">2018:01:25 01:07:21           nathanmarz </span><span>would add a </span><code>vtraverse</code><span> as well</span></div><div data-t="nathanmarz will probably do those for next release"><span class="u" id="1516842447.000228">2018:01:25 01:07:27           nathanmarz </span><span>will probably do those for next release</span></div><div data-t="nathanmarz but for now you can collect the path just like you&apos;re doing in  nodes-with-refs  and then parse it out of  item  when doing the  traverse"><span class="u" id="1516842512.000247">2018:01:25 01:08:32           nathanmarz </span><span>but for now you can collect the path just like you&apos;re doing in </span><code>nodes-with-refs</code><span> and then parse it out of </span><code>item</code><span> when doing the </span><code>traverse</code></div><div data-t="dadair Ok thank you I’ll give that a try"><span class="u" id="1516843780.000179">2018:01:25 01:29:40               dadair </span><span>Ok thank you I’ll give that a try</span></div><div data-t="schmee is there a more specter-y way to write  (view (juxt :color :symbol)) ?"><span class="u" id="1516923359.000212">2018:01:25 23:35:59               schmee </span><span>is there a more specter-y way to write </span><code>(view (juxt :color :symbol))</code><span>?</span></div><div data-t="nathanmarz @schmee looks good to me"><span class="u" id="1516923789.000155">2018:01:25 23:43:09           nathanmarz </span><span>@schmee looks good to me</span></div><div data-t="schmee is there something I can use in place of ??? to make this true?
 user=&gt; stuff
[{:color :red :symbol :moon} {:color :green :symbol :gear} {:color :yellow :symbol :star} {:color :blue :symbol :planet}]
user=&gt; (= (select (??? :color :symbol) stuff) [[:red :green :yellow :blue] [:moon :gear :star :planet]])
"><span class="u" id="1516924198.000269">2018:01:25 23:49:58               schmee </span><span>is there something I can use in place of ??? to make this true?
</span><pre>user=&gt; stuff
[{:color :red :symbol :moon} {:color :green :symbol :gear} {:color :yellow :symbol :star} {:color :blue :symbol :planet}]
user=&gt; (= (select (??? :color :symbol) stuff) [[:red :green :yellow :blue] [:moon :gear :star :planet]])
</pre></div><div data-t="schmee feels like a  multi-select"><span class="u" id="1516924251.000174">2018:01:25 23:50:51               schmee </span><span>feels like a </span><code>multi-select</code></div><div data-t="nathanmarz well, this will do it but it&apos;s better to just do it as two selects  (select (multi-path (subselect ALL :color) (subselect ALL :symbol)) stuff)"><span class="u" id="1516926773.000286">2018:01:26 00:32:53           nathanmarz </span><span>well, this will do it but it&apos;s better to just do it as two selects </span><code>(select (multi-path (subselect ALL :color) (subselect ALL :symbol)) stuff)</code></div><div data-t="cperrone Hi Nathan and all, I posted the problem in the #beginner channel, but someone suggested that I ask here. (I actually played with specter a bit (love it) but this is well beyond my current abilities).
At its simplest level, let’s say I have a ‘dumb’ container component, e.g.:
 (defn my-component [content]
[:div content]) 
… and a (possibly arbitrarily nested) tree structure, e.g.
 (def tree [[&quot;a&quot; [&quot;b&quot; &quot;c&quot; &quot;d&quot;]] &quot;e&quot;])  
What approach would you use to walk the tree, plug-in the component and its content to return something like this?
 (def result [:div
             [:div &quot;a&quot;
              [:div &quot;b&quot;]
              [:div &quot;c&quot;]
              [:div &quot;d&quot;]]
             [:div &quot;e&quot;]]) 
(My naive implementation has the component recursively calling itself on the children, which I really don’t want.)
Thanks so much in advance!"><span class="u" id="1517409170.000367">2018:01:31 14:32:50             cperrone </span><span>Hi Nathan and all, I posted the problem in the #beginner channel, but someone suggested that I ask here. (I actually played with specter a bit (love it) but this is well beyond my current abilities).
At its simplest level, let’s say I have a ‘dumb’ container component, e.g.:
</span><pre>(defn my-component [content]
[:div content])</pre><span>
… and a (possibly arbitrarily nested) tree structure, e.g.
</span><pre>(def tree [[&quot;a&quot; [&quot;b&quot; &quot;c&quot; &quot;d&quot;]] &quot;e&quot;])</pre><span> 
What approach would you use to walk the tree, plug-in the component and its content to return something like this?
</span><pre>(def result [:div
             [:div &quot;a&quot;
              [:div &quot;b&quot;]
              [:div &quot;c&quot;]
              [:div &quot;d&quot;]]
             [:div &quot;e&quot;]])</pre><span>
(My naive implementation has the component recursively calling itself on the children, which I really don’t want.)
Thanks so much in advance!</span></div><div data-t="nathanmarz @cperrone what exactly are the rules you want to follow for the transformation?"><span class="u" id="1517409598.000381">2018:01:31 14:39:58           nathanmarz </span><span>@cperrone what exactly are the rules you want to follow for the transformation?</span></div><div data-t="nathanmarz looks like you wrap leaf values in  :div , except for the case of  &quot;a&quot;"><span class="u" id="1517409639.000706">2018:01:31 14:40:39           nathanmarz </span><span>looks like you wrap leaf values in </span><code>:div</code><span>, except for the case of </span><code>&quot;a&quot;</code></div><div data-t="nathanmarz which wraps it and the children"><span class="u" id="1517409645.000322">2018:01:31 14:40:45           nathanmarz </span><span>which wraps it and the children</span></div><div data-t="nathanmarz but  &quot;b&quot;  doesn&apos;t follow that same rule"><span class="u" id="1517409651.000042">2018:01:31 14:40:51           nathanmarz </span><span>but </span><code>&quot;b&quot;</code><span> doesn&apos;t follow that same rule</span></div><div data-t="cperrone Let me think. In this case, a contains b c d (which are siblings), e is at the same level of a"><span class="u" id="1517409870.000694">2018:01:31 14:44:30             cperrone </span><span>Let me think. In this case, a contains b c d (which are siblings), e is at the same level of a</span></div><div data-t="cperrone So the rule (I think) is the same. my-component should be able to “render” its content recursively. An input map with nested :children vector may work as well, if it makes it easier. The crux of the problem is that the container wraps arbitrary content (which may include child containers)."><span class="u" id="1517410391.000439">2018:01:31 14:53:11             cperrone </span><span>So the rule (I think) is the same. my-component should be able to “render” its content recursively. An input map with nested :children vector may work as well, if it makes it easier. The crux of the problem is that the container wraps arbitrary content (which may include child containers).</span></div><div data-t="nathanmarz @cperrone this is pretty close to what you want:
 (defn my-component [node]
  `[:div ~(:val node) "><span class="u" id="1517411075.000605">2018:01:31 15:04:35           nathanmarz </span><span>@cperrone this is pretty close to what you want:
</span><pre>(defn my-component [node]
  `[:div ~(:val node) </pre></div><div data-t="cperrone oh man, thank you so much. My kid just arrived, so I need to take a break, but I’ll definitely play with it later on."><span class="u" id="1517411160.000685">2018:01:31 15:06:00             cperrone </span><span>oh man, thank you so much. My kid just arrived, so I need to take a break, but I’ll definitely play with it later on.</span></div><div data-t="nathanmarz sure thing"><span class="u" id="1517411166.000436">2018:01:31 15:06:06           nathanmarz </span><span>sure thing</span></div><div data-t="nathanmarz the key is to have a consistent and regular structure to your data"><span class="u" id="1517411198.000214">2018:01:31 15:06:38           nathanmarz </span><span>the key is to have a consistent and regular structure to your data</span></div><div data-t="cperrone yes, indeed. I love how declarative specter is by the way. It’s easy to see what’s going on. Ok, gotta go, but thank you again!"><span class="u" id="1517411292.000465">2018:01:31 15:08:12             cperrone </span><span>yes, indeed. I love how declarative specter is by the way. It’s easy to see what’s going on. Ok, gotta go, but thank you again!</span></div><div data-t="justinlee I use specter to manipulate my state object in the front end.  I’m curious: is there a way to apply multiple specter transformations to an atom atomically?  If I were doing this with the normal  swap!  function I’d just wrap all the transformations in a  fn .  But I’m not sure how to do that with specter.  (I’m asking because I’m worried that applying multiple specter transformations to a reagent atom might cause me grief, given that components get re-rendered in response to updates.  So far, I’m not 100% this is a real problem, because I think reagent batches updates, but I’m still curious.)"><span class="u" id="1517703611.000020">2018:02:04 00:20:11            justinlee </span><span>I use specter to manipulate my state object in the front end.  I’m curious: is there a way to apply multiple specter transformations to an atom atomically?  If I were doing this with the normal </span><code>swap!</code><span> function I’d just wrap all the transformations in a </span><code>fn</code><span>.  But I’m not sure how to do that with specter.  (I’m asking because I’m worried that applying multiple specter transformations to a reagent atom might cause me grief, given that components get re-rendered in response to updates.  So far, I’m not 100% this is a real problem, because I think reagent batches updates, but I’m still curious.)</span></div><div data-t="nathanmarz @lee.justin.m yes you can use  multi-transform  for that"><span class="u" id="1517704135.000059">2018:02:04 00:28:55           nathanmarz </span><span>@lee.justin.m yes you can use </span><code>multi-transform</code><span> for that</span></div><div data-t="nathanmarz e.g.  (multi-transform [ATOM (multi-path [:a (terminal inc)] [:b (terminal dec)])] state-object)"><span class="u" id="1517704170.000044">2018:02:04 00:29:30           nathanmarz </span><span>e.g. </span><code>(multi-transform [ATOM (multi-path [:a (terminal inc)] [:b (terminal dec)])] state-object)</code></div><div data-t="justinlee @nathanmarz super thanks!"><span class="u" id="1517704186.000068">2018:02:04 00:29:46            justinlee </span><span>@nathanmarz super thanks!</span></div><div data-t="justinlee oh i hadn’t seen this list-of-macros page.  there are all kinds of goodies here."><span class="u" id="1517704271.000084">2018:02:04 00:31:11            justinlee </span><span>oh i hadn’t seen this list-of-macros page.  there are all kinds of goodies here.</span></div><div data-t="nathanmarz definitely worth skimming through the wiki"><span class="u" id="1517704548.000053">2018:02:04 00:35:48           nathanmarz </span><span>definitely worth skimming through the wiki</span></div><div data-t="nathanmarz it&apos;s mostly up to date nowadays"><span class="u" id="1517704552.000088">2018:02:04 00:35:52           nathanmarz </span><span>it&apos;s mostly up to date nowadays</span></div><div data-t="justinlee @nathanmarz Just following up on the example you just used in #clojure, could you explain this:  (def data 
  {:a [:x :y]
   :b [:x :y]})
(select [ALL (collect-one FIRST) LAST] data)
;; -&gt; [[:a [:x :y]] [:b [:x :y]]]

;; The next statement will distribute the :a and :b
(select [ALL (collect-one FIRST) LAST ALL] data)
;; -≥ [[:a :x] [:a :y] [:b :x] [:b :y]]

;; But this, which applies the same selector to the intermediate result, does not
(select [ALL] [[:a [:x :y]] [:b [:x :y]]])
;; -&gt; [[:a [:x :y]] [:b [:x :y]]]
"><span class="u" id="1517775803.000151">2018:02:04 20:23:23            justinlee </span><span>@nathanmarz Just following up on the example you just used in #clojure, could you explain this: </span><pre>(def data 
  {:a [:x :y]
   :b [:x :y]})
(select [ALL (collect-one FIRST) LAST] data)
;; -&gt; [[:a [:x :y]] [:b [:x :y]]]

;; The next statement will distribute the :a and :b
(select [ALL (collect-one FIRST) LAST ALL] data)
;; -≥ [[:a :x] [:a :y] [:b :x] [:b :y]]

;; But this, which applies the same selector to the intermediate result, does not
(select [ALL] [[:a [:x :y]] [:b [:x :y]]])
;; -&gt; [[:a [:x :y]] [:b [:x :y]]]
</pre></div><div data-t="schmee @justinlee collecting variables is a special thing, search for “collect” in the readme for an explanation:  https://github.com/nathanmarz/specter"><span class="u" id="1517776160.000063">2018:02:04 20:29:20               schmee </span><span>@justinlee collecting variables is a special thing, search for “collect” in the readme for an explanation: </span><a href="https://github.com/nathanmarz/specter">https://github.com/nathanmarz/specter</a></div><div data-t="justinlee @schmee thanks yea i read that and the docs for  collect  and  collect-one  but i can’t for the life of me figure out how they alter the  ALL  selector in the context of a  select"><span class="u" id="1517776318.000114">2018:02:04 20:31:58            justinlee </span><span>@schmee thanks yea i read that and the docs for </span><code>collect</code><span> and </span><code>collect-one</code><span> but i can’t for the life of me figure out how they alter the </span><code>ALL</code><span> selector in the context of a </span><code>select</code></div><div data-t="justinlee there is some reference to adding a value to the ‘collected values’ but I haven’t seen how the collected values are used in selectors like  ALL  (though I understand how they are used in the  transform  example when you need an argument to the transforming function"><span class="u" id="1517776375.000114">2018:02:04 20:32:55            justinlee </span><span>there is some reference to adding a value to the ‘collected values’ but I haven’t seen how the collected values are used in selectors like </span><code>ALL</code><span> (though I understand how they are used in the </span><code>transform</code><span> example when you need an argument to the transforming function</span></div><div data-t="schmee user=&gt; (select [ALL (collect-one FIRST) LAST] data)
[[:a [:x :y]] [:b [:x :y]]]
user=&gt; (select [ALL (collect-one FIRST) (collect-one FIRST) LAST] data)
[[:a :a [:x :y]] [:b :b [:x :y]]]
"><span class="u" id="1517776470.000093">2018:02:04 20:34:30               schmee </span><pre>user=&gt; (select [ALL (collect-one FIRST) LAST] data)
[[:a [:x :y]] [:b [:x :y]]]
user=&gt; (select [ALL (collect-one FIRST) (collect-one FIRST) LAST] data)
[[:a :a [:x :y]] [:b :b [:x :y]]]
</pre></div><div data-t="schmee looks to me like  select  just calls  vector  on the collected arguments + the value(s) you’ve navigated to"><span class="u" id="1517776495.000039">2018:02:04 20:34:55               schmee </span><span>looks to me like </span><code>select</code><span> just calls </span><code>vector</code><span> on the collected arguments + the value(s) you’ve navigated to</span></div><div data-t="justinlee Yea I guess that’s it.  I’m not sure why it does that.   🙂    com.rpl.specter=&gt; (select [(putval &quot;a&quot;) ALL] [1 2 3])
[[&quot;a&quot; 1] [&quot;a&quot; 2] [&quot;a&quot; 3]]
com.rpl.specter=&gt; (select [(putval &quot;a&quot;) FIRST] [1 2 3])
[[&quot;a&quot; 1]]
com.rpl.specter=&gt; (select [(putval &quot;a&quot;) (putval &quot;b&quot;) ALL] [1 2 3])
[[&quot;a&quot; &quot;b&quot; 1] [&quot;a&quot; &quot;b&quot; 2] [&quot;a&quot; &quot;b&quot; 3]]"><span class="u" id="1517776763.000052">2018:02:04 20:39:23            justinlee </span><span>Yea I guess that’s it.  I’m not sure why it does that.  </span><b>🙂</b><span>  </span><pre>com.rpl.specter=&gt; (select [(putval &quot;a&quot;) ALL] [1 2 3])
[[&quot;a&quot; 1] [&quot;a&quot; 2] [&quot;a&quot; 3]]
com.rpl.specter=&gt; (select [(putval &quot;a&quot;) FIRST] [1 2 3])
[[&quot;a&quot; 1]]
com.rpl.specter=&gt; (select [(putval &quot;a&quot;) (putval &quot;b&quot;) ALL] [1 2 3])
[[&quot;a&quot; &quot;b&quot; 1] [&quot;a&quot; &quot;b&quot; 2] [&quot;a&quot; &quot;b&quot; 3]]</pre></div><div data-t="nathanmarz @lee.justin.m this is the code that creates that behavior:  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L294"><span class="u" id="1517778849.000073">2018:02:04 21:14:09           nathanmarz </span><span>@lee.justin.m this is the code that creates that behavior: </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L294">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L294</a></div><div data-t="justinlee got it thanks.  that makes sense."><span class="u" id="1517778903.000038">2018:02:04 21:15:03            justinlee </span><span>got it thanks.  that makes sense.</span></div><div data-t="phreed Which macro provides the ability to select nodes from a tree whose subpath matches a pattern?
e.g. Given 
(def foo {&quot;a1&quot; {:z :c1, :d &quot;e1&quot;}
               &quot;a2&quot; {:z :c2, :d &quot;e2&quot;}}) 
(select [ALL (magic [VAL :z :c1])] foo)
&gt; {&quot;a1&quot; {:z :c1, :d &quot;e1&quot;} }
What is the magic macro?
Should I be using transform instead of select?"><span class="u" id="1517853354.000829">2018:02:05 17:55:54               phreed </span><span>Which macro provides the ability to select nodes from a tree whose subpath matches a pattern?
e.g. Given 
(def foo {&quot;a1&quot; {:z :c1, :d &quot;e1&quot;}
               &quot;a2&quot; {:z :c2, :d &quot;e2&quot;}}) 
(select [ALL (magic [VAL :z :c1])] foo)
&gt; {&quot;a1&quot; {:z :c1, :d &quot;e1&quot;} }
What is the magic macro?
Should I be using transform instead of select?</span></div><div data-t="nathanmarz @phreed you&apos;re looking to filter submaps that don&apos;t contain a key-value pair  [:z :c1] ?"><span class="u" id="1517854159.000150">2018:02:05 18:09:19           nathanmarz </span><span>@phreed you&apos;re looking to filter submaps that don&apos;t contain a key-value pair </span><code>[:z :c1]</code><span>?</span></div><div data-t="phreed @nathanmarz yes, I think that is right."><span class="u" id="1517854386.000026">2018:02:05 18:13:06               phreed </span><span>@nathanmarz yes, I think that is right.</span></div><div data-t="nathanmarz the basic pattern for that is  (setval &lt;path&gt; NONE data)"><span class="u" id="1517854400.000416">2018:02:05 18:13:20           nathanmarz </span><span>the basic pattern for that is </span><code>(setval &lt;path&gt; NONE data)</code></div><div data-t="nathanmarz in this case  (setval [MAP-VALS (not-selected? :z (pred= :c1))] NONE foo)"><span class="u" id="1517854406.000319">2018:02:05 18:13:26           nathanmarz </span><span>in this case </span><code>(setval [MAP-VALS (not-selected? :z (pred= :c1))] NONE foo)</code></div><div data-t="phreed yes, pruning the tree with setval does the trick."><span class="u" id="1517854430.000285">2018:02:05 18:13:50               phreed </span><span>yes, pruning the tree with setval does the trick.</span></div><div data-t="phreed I am looking at the documentation for  not-selected?  it appears to take only one argument, a path. What is going on here  (not-selected? :z (pred= :c1))  that looks like two arguments. Is it equivalent to  (not-selected? [:z (pred= :c1)])  ?"><span class="u" id="1517856652.000675">2018:02:05 18:50:52               phreed </span><span>I am looking at the documentation for </span><code>not-selected?</code><span> it appears to take only one argument, a path. What is going on here </span><code>(not-selected? :z (pred= :c1))</code><span> that looks like two arguments. Is it equivalent to </span><code>(not-selected? [:z (pred= :c1)])</code><span> ?</span></div><div data-t="nathanmarz @phreed yes, those are equivalent"><span class="u" id="1517857094.000500">2018:02:05 18:58:14           nathanmarz </span><span>@phreed yes, those are equivalent</span></div><div data-t="nathanmarz similarly the path  [:a :b :c]  is the same as  [[:a] [[:b]] :c]"><span class="u" id="1517857118.000367">2018:02:05 18:58:38           nathanmarz </span><span>similarly the path </span><code>[:a :b :c]</code><span> is the same as </span><code>[[:a] [[:b]] :c]</code></div><div data-t="nathanmarz a path is just a composition of navigators"><span class="u" id="1517857178.000029">2018:02:05 18:59:38           nathanmarz </span><span>a path is just a composition of navigators</span></div><div data-t="nathanmarz a vector in a path is interpreted as a path"><span class="u" id="1517857201.000566">2018:02:05 19:00:01           nathanmarz </span><span>a vector in a path is interpreted as a path</span></div><div data-t="jamescroft Hi, I have a nested data structure like in the snippet above.  I can select all the nodes of a specified type, but I’m having trouble updating them.  I want the index of the node I am updating within the transform function.  Any pointers on how to do this?  Thanks"><span class="u" id="1517933559.000545">2018:02:06 16:12:39           jamescroft </span><span>Hi, I have a nested data structure like in the snippet above.  I can select all the nodes of a specified type, but I’m having trouble updating them.  I want the index of the node I am updating within the transform function.  Any pointers on how to do this?  Thanks</span></div><div data-t="nathanmarz @jamescroft you can do that with  subselect  and a slightly modified  NODES"><span class="u" id="1517934833.000079">2018:02:06 16:33:53           nathanmarz </span><span>@jamescroft you can do that with </span><code>subselect</code><span> and a slightly modified </span><code>NODES</code></div><div data-t="nathanmarz (def NODES (recursive-path [] p (stay-then-continue (must :nodes) ALL p)))
(transform [(subselect NODES #(= &quot;a&quot; (:type %)) :index) (view count)] range data)
"><span class="u" id="1517934835.000508">2018:02:06 16:33:55           nathanmarz </span><pre>(def NODES (recursive-path [] p (stay-then-continue (must :nodes) ALL p)))
(transform [(subselect NODES #(= &quot;a&quot; (:type %)) :index) (view count)] range data)
</pre></div><div data-t="jamescroft @nathanmarz great thanks! I wouldn’t have got there on my own!"><span class="u" id="1517935296.000553">2018:02:06 16:41:36           jamescroft </span><span>@nathanmarz great thanks! I wouldn’t have got there on my own!</span></div><div data-t="nathanmarz sure thing"><span class="u" id="1517935501.000119">2018:02:06 16:45:01           nathanmarz </span><span>sure thing</span></div><div data-t="nathanmarz I highly recommend skimming through  https://github.com/nathanmarz/specter/wiki/List-of-Navigators  to learn what&apos;s available"><span class="u" id="1517935524.000027">2018:02:06 16:45:24           nathanmarz </span><span>I highly recommend skimming through </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators">https://github.com/nathanmarz/specter/wiki/List-of-Navigators</a><span> to learn what&apos;s available</span></div><div data-t="nathanmarz Handy cheat sheet contributed by @djebbz  https://github.com/nathanmarz/specter/wiki/Cheat-Sheet"><span class="u" id="1518531331.000371">2018:02:13 14:15:31           nathanmarz </span><span>Handy cheat sheet contributed by @djebbz </span><a href="https://github.com/nathanmarz/specter/wiki/Cheat-Sheet">https://github.com/nathanmarz/specter/wiki/Cheat-Sheet</a></div><div data-t="johanatan hi, if i&apos;m  transform  over  [specter/MAP-VALS :some-key]  and inside my transform i want/need to access the KEY-VAL corresponding to the particular MAP-VAL that i&apos;m in, is that possible? or do these cases always degenerate into a case of  [specter/ALL]  with drilling down required inside the transform-fn"><span class="u" id="1518562261.000519">2018:02:13 22:51:01            johanatan </span><span>hi, if i&apos;m </span><code>transform</code><span> over </span><code>[specter/MAP-VALS :some-key]</code><span> and inside my transform i want/need to access the KEY-VAL corresponding to the particular MAP-VAL that i&apos;m in, is that possible? or do these cases always degenerate into a case of </span><code>[specter/ALL]</code><span> with drilling down required inside the transform-fn</span></div><div data-t="nathanmarz @johanatan accessing the key while transforming a map val is expressed as  (transform [ALL (collect-one FIRST) LAST] ...)"><span class="u" id="1518564602.000318">2018:02:13 23:30:02           nathanmarz </span><span>@johanatan accessing the key while transforming a map val is expressed as </span><code>(transform [ALL (collect-one FIRST) LAST] ...)</code></div><div data-t="johanatan ah, nice. what would be the signature be for capturing the key and the value?"><span class="u" id="1518564628.000063">2018:02:13 23:30:28            johanatan </span><span>ah, nice. what would be the signature be for capturing the key and the value?</span></div><div data-t="johanatan just  [[k v]]  ?"><span class="u" id="1518564635.000277">2018:02:13 23:30:35            johanatan </span><span>just </span><code>[[k v]]</code><span> ?</span></div><div data-t="johanatan [the transform-fn signature that is]"><span class="u" id="1518564666.000085">2018:02:13 23:31:06            johanatan </span><span>[the transform-fn signature that is]</span></div><div data-t="johanatan and also can you have additional filters (such as the kwd in my example) after the  LAST  ?"><span class="u" id="1518564736.000424">2018:02:13 23:32:16            johanatan </span><span>and also can you have additional filters (such as the kwd in my example) after the </span><code>LAST</code><span> ?</span></div><div data-t="nathanmarz @johanatan of course, navigators are infinitely composable"><span class="u" id="1518567459.000243">2018:02:14 00:17:39           nathanmarz </span><span>@johanatan of course, navigators are infinitely composable</span></div><div data-t="nathanmarz will be easier to show you the most elegant approach if you give an example of the input and desired output"><span class="u" id="1518567491.000255">2018:02:14 00:18:11           nathanmarz </span><span>will be easier to show you the most elegant approach if you give an example of the input and desired output</span></div><div data-t="cperrone Hi @nathanmarz and all,  I’m beginning to use Specter everywhere  🙂 . I’m still struggling with some admittedly basic recursion/tree transformation though. For example, here’s my input:
 (def tree [0
                 [1]
                 [2 [3]]])
 
The tree is arbitrarily nested, each node is a vector of type  [root &amp; children]  (e.g. [0] is the tree root, [1] and [2] its immediate children, [1] and [2] are siblings). My goal is to transform the tree into the following structure. In other words, each node under the root becomes an :li item. Also if a node has children, I’d like to “wrap” them with a :ul container. It should be simple, but I can’t get my head around it yet. But maybe you can help me on this one?
 [:ul
       [:li {:id &quot;1&quot;}]
       [:li {:id &quot;2&quot;}
        [:ul
         [:li {:id &quot;3&quot;}]]]]"><span class="u" id="1518612369.000227">2018:02:14 12:46:09             cperrone </span><span>Hi @nathanmarz and all,  I’m beginning to use Specter everywhere </span><b>🙂</b><span>. I’m still struggling with some admittedly basic recursion/tree transformation though. For example, here’s my input:
</span><pre>(def tree [0
                 [1]
                 [2 [3]]])
</pre><span>
The tree is arbitrarily nested, each node is a vector of type </span><pre>[root &amp; children]</pre><span> (e.g. [0] is the tree root, [1] and [2] its immediate children, [1] and [2] are siblings). My goal is to transform the tree into the following structure. In other words, each node under the root becomes an :li item. Also if a node has children, I’d like to “wrap” them with a :ul container. It should be simple, but I can’t get my head around it yet. But maybe you can help me on this one?
</span><pre>[:ul
       [:li {:id &quot;1&quot;}]
       [:li {:id &quot;2&quot;}
        [:ul
         [:li {:id &quot;3&quot;}]]]]</pre></div><div data-t="nathanmarz @cperrone here&apos;s one way to do it:
 (def tree [0
            [1]
            [2 [3]]])

(def NODE-CHILDREN
  (path INDEXED-VALS #(not= 0 (first %)) LAST))

(def NODES (recursive-path [] p
             (continue-then-stay
              NODE-CHILDREN
              p)))

(defn wrap [children id _]
  (if (empty? children)
    [:li {:id id}]
    [:li {:id id} (setval BEFORE-ELEM :ul children)]
    )
  )

(nth
  (transform
    [NODES
     (collect NODE-CHILDREN)
     (collect-one FIRST)
     ]
    wrap
    tree
    )
  2)
"><span class="u" id="1518617629.000521">2018:02:14 14:13:49           nathanmarz </span><span>@cperrone here&apos;s one way to do it:
</span><pre>(def tree [0
            [1]
            [2 [3]]])

(def NODE-CHILDREN
  (path INDEXED-VALS #(not= 0 (first %)) LAST))

(def NODES (recursive-path [] p
             (continue-then-stay
              NODE-CHILDREN
              p)))

(defn wrap [children id _]
  (if (empty? children)
    [:li {:id id}]
    [:li {:id id} (setval BEFORE-ELEM :ul children)]
    )
  )

(nth
  (transform
    [NODES
     (collect NODE-CHILDREN)
     (collect-one FIRST)
     ]
    wrap
    tree
    )
  2)
</pre></div><div data-t="cperrone ah brilliant, thank you @nathanmarz. I much appreciate it. I suspected I needed to collect values along the way, but I wasn’t sure how (I need to play more with that). Great answer. Would this be more typical of a zipper use, by the way? At some stage I wondered if walking with   (defn my-zipper [v]
  (z/zipper next rest my-make-node v))  (obviously then wrapped by the specter zipper :D) would have been easier for this case."><span class="u" id="1518619365.000100">2018:02:14 14:42:45             cperrone </span><span>ah brilliant, thank you @nathanmarz. I much appreciate it. I suspected I needed to collect values along the way, but I wasn’t sure how (I need to play more with that). Great answer. Would this be more typical of a zipper use, by the way? At some stage I wondered if walking with  </span><pre>(defn my-zipper [v]
  (z/zipper next rest my-make-node v))</pre><span> (obviously then wrapped by the specter zipper :D) would have been easier for this case.</span></div><div data-t="nathanmarz @cperrone zippers aren&apos;t needed in this case"><span class="u" id="1518621727.000466">2018:02:14 15:22:07           nathanmarz </span><span>@cperrone zippers aren&apos;t needed in this case</span></div><div data-t="nathanmarz it&apos;s best to avoid using zippers since they add a lot of overhead"><span class="u" id="1518621757.000438">2018:02:14 15:22:37           nathanmarz </span><span>it&apos;s best to avoid using zippers since they add a lot of overhead</span></div><div data-t="cperrone I’m still studying your approach to the problem, in particular, I was surprised by the setval within the transform fn"><span class="u" id="1518621869.000029">2018:02:14 15:24:29             cperrone </span><span>I’m still studying your approach to the problem, in particular, I was surprised by the setval within the transform fn</span></div><div data-t="nathanmarz your use case does two things: wrap in  :li  and wrap in  :ul"><span class="u" id="1518622046.000359">2018:02:14 15:27:26           nathanmarz </span><span>your use case does two things: wrap in </span><code>:li</code><span> and wrap in </span><code>:ul</code></div><div data-t="nathanmarz the inner setval prepends to a vector without changing the type (as  cons  would do)"><span class="u" id="1518622076.000896">2018:02:14 15:27:56           nathanmarz </span><span>the inner setval prepends to a vector without changing the type (as </span><code>cons</code><span> would do)</span></div><div data-t="cperrone yes. I guess I also need to check the result of the overall transform “before” you take the nth index."><span class="u" id="1518622216.000470">2018:02:14 15:30:16             cperrone </span><span>yes. I guess I also need to check the result of the overall transform “before” you take the nth index.</span></div><div data-t="nathanmarz yea, the handling of the root is special with how you laid out the problem"><span class="u" id="1518622269.000431">2018:02:14 15:31:09           nathanmarz </span><span>yea, the handling of the root is special with how you laid out the problem</span></div><div data-t="cperrone yes, maybe some slight tweaking on the input could help (as it’s often the case)"><span class="u" id="1518622436.000452">2018:02:14 15:33:56             cperrone </span><span>yes, maybe some slight tweaking on the input could help (as it’s often the case)</span></div><div data-t="nathanmarz if you have the control, then making the structure of the data as consistent as possible helps a lot"><span class="u" id="1518622493.000582">2018:02:14 15:34:53           nathanmarz </span><span>if you have the control, then making the structure of the data as consistent as possible helps a lot</span></div><div data-t="cperrone eh eh I do. I though I was consistent though. [root children children] all the way no?"><span class="u" id="1518622534.000146">2018:02:14 15:35:34             cperrone </span><span>eh eh I do. I though I was consistent though. [root children children] all the way no?</span></div><div data-t="nathanmarz yea, in this case it&apos;s the output that&apos;s slightly inconsistent"><span class="u" id="1518622565.000512">2018:02:14 15:36:05           nathanmarz </span><span>yea, in this case it&apos;s the output that&apos;s slightly inconsistent</span></div><div data-t="cperrone true, the wrapping is slightly tricky"><span class="u" id="1518622583.000301">2018:02:14 15:36:23             cperrone </span><span>true, the wrapping is slightly tricky</span></div><div data-t="cperrone i read somewhere that zippers are pretty lightweight by the way… I don’t particularly like the imperative navigation that it often leads to though."><span class="u" id="1518622683.000138">2018:02:14 15:38:03             cperrone </span><span>i read somewhere that zippers are pretty lightweight by the way… I don’t particularly like the imperative navigation that it often leads to though.</span></div><div data-t="nathanmarz &quot;lightweight&quot; is relative"><span class="u" id="1518622774.000545">2018:02:14 15:39:34           nathanmarz </span><span>&quot;lightweight&quot; is relative</span></div><div data-t="nathanmarz compared to a straight  reduce  it&apos;s not"><span class="u" id="1518622800.000764">2018:02:14 15:40:00           nathanmarz </span><span>compared to a straight </span><code>reduce</code><span> it&apos;s not</span></div><div data-t="nathanmarz it&apos;s not just performance, they also add conceptual overhead"><span class="u" id="1518622822.000626">2018:02:14 15:40:22           nathanmarz </span><span>it&apos;s not just performance, they also add conceptual overhead</span></div><div data-t="cperrone ah ah I guess so, especially in clojurescript, everything counts, so it’s a matter of tradeoffs"><span class="u" id="1518622823.000039">2018:02:14 15:40:23             cperrone </span><span>ah ah I guess so, especially in clojurescript, everything counts, so it’s a matter of tradeoffs</span></div><div data-t="cperrone indeed"><span class="u" id="1518622832.000051">2018:02:14 15:40:32             cperrone </span><span>indeed</span></div><div data-t="Peter Wilkins Hi @nathanmarz and all. I&apos;m stuck on a (probably) simple one. I have this xml:
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt;
&lt;book&gt;
&lt;frontmatter/&gt;
&lt;chapter name=&quot;Introduction&quot;&gt;
    &lt;para&gt;Here is the intro&lt;/para&gt;
    &lt;para&gt;Another paragraph&lt;/para&gt;
&lt;/chapter&gt;
&lt;chapter name=&quot;Conclusion&quot;&gt;
    &lt;para&gt;All done now&lt;/para&gt;
&lt;/chapter&gt;
&lt;/book&gt;"><span class="u" id="1518994021.000108">2018:02:18 22:47:01        Peter Wilkins </span><span>Hi @nathanmarz and all. I&apos;m stuck on a (probably) simple one. I have this xml:
</span><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt;
&lt;book&gt;
&lt;frontmatter/&gt;
&lt;chapter name=&quot;Introduction&quot;&gt;
    &lt;para&gt;Here is the intro&lt;/para&gt;
    &lt;para&gt;Another paragraph&lt;/para&gt;
&lt;/chapter&gt;
&lt;chapter name=&quot;Conclusion&quot;&gt;
    &lt;para&gt;All done now&lt;/para&gt;
&lt;/chapter&gt;
&lt;/book&gt;</pre></div><div data-t="Peter Wilkins the Challenge is to get the string content from chapter elements with attr name = &quot;Introduction&quot;

; using thread last
 (time (-&gt;&gt; [doc]
           (mapcat :content)
           (filter #(= :chapter (:tag %)))
           (filter #(= &quot;Introduction&quot; (get-in % [:attrs :name])))
           (mapcat :content)
           (filter #(= :para (:tag %)))
           (mapcat :content)
           (filter string?))) 

; transducers and compose
 (time (eduction
        (comp
          (mapcat :content)
          (filter (comp (partial = :chapter) :tag))
          (filter (comp (partial = &quot;Introduction&quot;) :attrs :name))
          (mapcat :content)
          (filter (comp (partial = :para) :tag))
          (mapcat :content)
          (filter string?))
        [doc])) 

; specter: this isn&apos;t correct yet...
 (select [:content ALL
         (filterer :tag #(= % :chapter))
         (filterer :attrs :name #(= % &quot;Introduction&quot;))
         :content ALL
         (filterer :tag #(= % :para))
         :content ALL
         string?] doc)"><span class="u" id="1518994049.000055">2018:02:18 22:47:29        Peter Wilkins </span><span>the Challenge is to get the string content from chapter elements with attr name = &quot;Introduction&quot;

; using thread last
</span><pre>(time (-&gt;&gt; [doc]
           (mapcat :content)
           (filter #(= :chapter (:tag %)))
           (filter #(= &quot;Introduction&quot; (get-in % [:attrs :name])))
           (mapcat :content)
           (filter #(= :para (:tag %)))
           (mapcat :content)
           (filter string?)))</pre><span>

; transducers and compose
</span><pre>(time (eduction
        (comp
          (mapcat :content)
          (filter (comp (partial = :chapter) :tag))
          (filter (comp (partial = &quot;Introduction&quot;) :attrs :name))
          (mapcat :content)
          (filter (comp (partial = :para) :tag))
          (mapcat :content)
          (filter string?))
        [doc]))</pre><span>

; specter: this isn&apos;t correct yet...
</span><pre>(select [:content ALL
         (filterer :tag #(= % :chapter))
         (filterer :attrs :name #(= % &quot;Introduction&quot;))
         :content ALL
         (filterer :tag #(= % :para))
         :content ALL
         string?] doc)</pre></div><div data-t="nathanmarz @poppetew I think you&apos;re looking for  selected?  rather than  filterer ?"><span class="u" id="1518995039.000067">2018:02:18 23:03:59           nathanmarz </span><span>@poppetew I think you&apos;re looking for </span><code>selected?</code><span> rather than </span><code>filterer</code><span>?</span></div><div data-t="nathanmarz (select [:content
         ALL
         (selected? :tag (pred= :chapter))
         (selected? :attrs :name (pred= &quot;Introduction&quot;))
         :content
         ALL
         (selected? :tag (pred= :para))
         :content
         ALL
         string?]
  doc)
"><span class="u" id="1518995043.000064">2018:02:18 23:04:03           nathanmarz </span><pre>(select [:content
         ALL
         (selected? :tag (pred= :chapter))
         (selected? :attrs :name (pred= &quot;Introduction&quot;))
         :content
         ALL
         (selected? :tag (pred= :para))
         :content
         ALL
         string?]
  doc)
</pre></div><div data-t="nathanmarz pred=  is also slightly nicer than doing  #(= % ...)"><span class="u" id="1518995068.000098">2018:02:18 23:04:28           nathanmarz </span><code>pred=</code><span> is also slightly nicer than doing </span><code>#(= % ...)</code></div><div data-t="Peter Wilkins thanks:+1:"><span class="u" id="1519029721.000363">2018:02:19 08:42:01        Peter Wilkins </span><span>thanks:+1:</span></div><div data-t="pepe selected?  is the navigator I was looking for, but was blind to see it. Thank you very much!"><span class="u" id="1519070210.000284">2018:02:19 19:56:50                 pepe </span><code>selected?</code><span> is the navigator I was looking for, but was blind to see it. Thank you very much!</span></div><div data-t="Nikolay Artamonov Hi all! Is it possible to get removed (via  NONE ) element, for example:

 (sr/setval [:elems
            (sr/filterer (sr/must :id) (sr/pred= 1))
            sr/FIRST] sr/NONE {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]})
=&gt; {:elems [{:id 2, :name &quot;B&quot;}]}
 

I want to get not only whole structure but also removed one:  {:id 1 :name &quot;A&quot;} ."><span class="u" id="1519213701.000051">2018:02:21 11:48:21    Nikolay Artamonov </span><span>Hi all! Is it possible to get removed (via </span><code>NONE</code><span>) element, for example:

</span><pre>(sr/setval [:elems
            (sr/filterer (sr/must :id) (sr/pred= 1))
            sr/FIRST] sr/NONE {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]})
=&gt; {:elems [{:id 2, :name &quot;B&quot;}]}
</pre><span>

I want to get not only whole structure but also removed one: </span><code>{:id 1 :name &quot;A&quot;}</code><span>.</span></div><div data-t="schmee @nartamonov you can use transform instead, like this:
 user=&gt; (sr/transform
  #_=&gt;  [:elems (sr/filterer (sr/must :id) (sr/pred= 1)) sr/FIRST]
  #_=&gt;  (fn [x] (println x) sr/NONE)
  #_=&gt;  {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]})
{:id 1, :name A}
{:elems [{:id 2 :name &quot;B&quot;}]}"><span class="u" id="1519219572.000126">2018:02:21 13:26:12               schmee </span><span>@nartamonov you can use transform instead, like this:
</span><pre>user=&gt; (sr/transform
  #_=&gt;  [:elems (sr/filterer (sr/must :id) (sr/pred= 1)) sr/FIRST]
  #_=&gt;  (fn [x] (println x) sr/NONE)
  #_=&gt;  {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]})
{:id 1, :name A}
{:elems [{:id 2 :name &quot;B&quot;}]}</pre></div><div data-t="schmee if you return  NONE  from the transformation function it will remove the element just like setval"><span class="u" id="1519219612.000321">2018:02:21 13:26:52               schmee </span><span>if you return </span><code>NONE</code><span> from the transformation function it will remove the element just like setval</span></div><div data-t="schmee also,  replace-in  might be of help:  https://github.com/nathanmarz/specter/wiki/List-of-Macros#replace-in"><span class="u" id="1519219730.000139">2018:02:21 13:28:50               schmee </span><span>also, </span><code>replace-in</code><span> might be of help: </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#replace-in">https://github.com/nathanmarz/specter/wiki/List-of-Macros#replace-in</a></div><div data-t="schmee actually,  replace-in  is perfect:
 user=&gt; (sr/replace-in
  #_=&gt;  [:elems (sr/filterer (sr/must :id) (sr/pred= 1)) sr/FIRST]
  #_=&gt;  (fn [x] [sr/NONE x])
  #_=&gt;  {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]})
[{:elems [{:id 2 :name &quot;B&quot;}]} ([:id 1] [:name &quot;A&quot;])]
"><span class="u" id="1519219881.000378">2018:02:21 13:31:21               schmee </span><span>actually, </span><code>replace-in</code><span> is perfect:
</span><pre>user=&gt; (sr/replace-in
  #_=&gt;  [:elems (sr/filterer (sr/must :id) (sr/pred= 1)) sr/FIRST]
  #_=&gt;  (fn [x] [sr/NONE x])
  #_=&gt;  {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]})
[{:elems [{:id 2 :name &quot;B&quot;}]} ([:id 1] [:name &quot;A&quot;])]
</pre></div><div data-t="souenzzo @nartamonov  path  works equally in  select  and  setval , so you can do something like it:
 (let [data {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]}
      path [:elems ALL (if-path [:id #{1}] STAY)]]
  {:data    (setval path NONE data)
   :removed (select path data)})
 
 replace-in  is a option too"><span class="u" id="1519220163.000171">2018:02:21 13:36:03             souenzzo </span><span>@nartamonov </span><code>path</code><span> works equally in </span><code>select</code><span> and </span><code>setval</code><span>, so you can do something like it:
</span><pre>(let [data {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]}
      path [:elems ALL (if-path [:id #{1}] STAY)]]
  {:data    (setval path NONE data)
   :removed (select path data)})
</pre><span>
</span><code>replace-in</code><span> is a option too</span></div><div data-t="Nikolay Artamonov @schmee Thanks, it works almost as I want. If instead  x  we use  [x]  then we&apos;ll get exactly the same structure (hashmap) that was removed:

 (sr/replace-in
    [:elems (sr/filterer (sr/must :id) (sr/pred= 1)) sr/FIRST]
    (fn [x] [sr/NONE [x]])
    {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]})
=&gt; [{:elems [{:id 2, :name &quot;B&quot;}]} ({:id 1, :name &quot;A&quot;})]
 

Though, don&apos;t understand why..."><span class="u" id="1519220896.000361">2018:02:21 13:48:16    Nikolay Artamonov </span><span>@schmee Thanks, it works almost as I want. If instead </span><code>x</code><span> we use </span><code>[x]</code><span> then we&apos;ll get exactly the same structure (hashmap) that was removed:

</span><pre>(sr/replace-in
    [:elems (sr/filterer (sr/must :id) (sr/pred= 1)) sr/FIRST]
    (fn [x] [sr/NONE [x]])
    {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]})
=&gt; [{:elems [{:id 2, :name &quot;B&quot;}]} ({:id 1, :name &quot;A&quot;})]
</pre><span>

Though, don&apos;t understand why...</span></div><div data-t="schmee ahh, sorry, I missed that the hash map changed into a seq, good that you found the solution"><span class="u" id="1519220974.000270">2018:02:21 13:49:34               schmee </span><span>ahh, sorry, I missed that the hash map changed into a seq, good that you found the solution</span></div><div data-t="schmee the reason is that the second element in the vector gets added to a sequence of return values, so if you have just a hash map it will be changed into a seq first, ie:
 user=&gt; (seq {:id 1, :name &quot;A&quot;})
([:id 1] [:name &quot;A&quot;])
"><span class="u" id="1519221065.000334">2018:02:21 13:51:05               schmee </span><span>the reason is that the second element in the vector gets added to a sequence of return values, so if you have just a hash map it will be changed into a seq first, ie:
</span><pre>user=&gt; (seq {:id 1, :name &quot;A&quot;})
([:id 1] [:name &quot;A&quot;])
</pre></div><div data-t="schmee vs
 user=&gt; (seq [{:id 1, :name &quot;A&quot;}])
({:id 1 :name &quot;A&quot;})
"><span class="u" id="1519221083.000454">2018:02:21 13:51:23               schmee </span><span>vs
</span><pre>user=&gt; (seq [{:id 1, :name &quot;A&quot;}])
({:id 1 :name &quot;A&quot;})
</pre></div><div data-t="Nikolay Artamonov Now I see, thank you!  🙂"><span class="u" id="1519221242.000360">2018:02:21 13:54:02    Nikolay Artamonov </span><span>Now I see, thank you! </span><b>🙂</b></div><div data-t="johanatan hi, is it possible to  specter/transform  a k/v pair in a map to another map and then have that merged with the original siblings?"><span class="u" id="1519242670.000461">2018:02:21 19:51:10            johanatan </span><span>hi, is it possible to </span><code>specter/transform</code><span> a k/v pair in a map to another map and then have that merged with the original siblings?</span></div><div data-t="nathanmarz @johanatan you can use the  submap  navigator for that"><span class="u" id="1519242789.000178">2018:02:21 19:53:09           nathanmarz </span><span>@johanatan you can use the </span><code>submap</code><span> navigator for that</span></div><div data-t="johanatan ah, ok. thx"><span class="u" id="1519242800.000174">2018:02:21 19:53:20            johanatan </span><span>ah, ok. thx</span></div><div data-t="spieden was just reaching for  clojure.walk  and learned  recursive-path  and  cond-path  instead — wasn’t disappointed =)"><span class="u" id="1519253056.000086">2018:02:21 22:44:16              spieden </span><span>was just reaching for </span><code>clojure.walk</code><span> and learned </span><code>recursive-path</code><span> and </span><code>cond-path</code><span> instead — wasn’t disappointed =)</span></div><div data-t="steveb8n I’m struggling to understand  compact . in the example, shouldn’t the :c that has a value be left alone?"><span class="u" id="1519262816.000143">2018:02:22 01:26:56             steveb8n </span><span>I’m struggling to understand </span><code>compact</code><span>. in the example, shouldn’t the :c that has a value be left alone?</span></div><div data-t="steveb8n (setval [ALL :a (compact :c)] 
        NONE
        [{:a {:b 1 :c 2}}
         {:a {:b 1 :c nil}}]) 

=&gt; 
 [{:a {:b 1}} {:a {:b 1}}]"><span class="u" id="1519262821.000112">2018:02:22 01:27:01             steveb8n </span><pre>(setval [ALL :a (compact :c)] 
        NONE
        [{:a {:b 1 :c 2}}
         {:a {:b 1 :c nil}}])</pre><span>

=&gt; 
</span><pre>[{:a {:b 1}} {:a {:b 1}}]</pre></div><div data-t="steveb8n the docstring says that it only applies when the value is empty. that is exactly what I want but I’m missing how to make that work"><span class="u" id="1519262868.000179">2018:02:22 01:27:48             steveb8n </span><span>the docstring says that it only applies when the value is empty. that is exactly what I want but I’m missing how to make that work</span></div><div data-t="nathanmarz @steveb8n  compact  applies to the value being navigated on, in this case the submaps"><span class="u" id="1519265491.000247">2018:02:22 02:11:31           nathanmarz </span><span>@steveb8n </span><code>compact</code><span> applies to the value being navigated on, in this case the submaps</span></div><div data-t="nathanmarz e.g.
 (setval [ALL :a (compact :c)] 
        NONE
        [{:a {:c 2}}
         {:a {:b 1 :c nil}}])
;; =&gt; [{} {:a {:b 1}}]
"><span class="u" id="1519265529.000204">2018:02:22 02:12:09           nathanmarz </span><span>e.g.
</span><pre>(setval [ALL :a (compact :c)] 
        NONE
        [{:a {:c 2}}
         {:a {:b 1 :c nil}}])
;; =&gt; [{} {:a {:b 1}}]
</pre></div><div data-t="steveb8n That makes sense. Reading that expression it makes  sense that it unconditionally removes the value. "><span class="u" id="1519265755.000020">2018:02:22 02:15:55             steveb8n </span><span>That makes sense. Reading that expression it makes  sense that it unconditionally removes the value. </span></div><div data-t="steveb8n But what if I want to conditionally remove it i.e. when value is nil. Is there an idiomatic way to do that? The docstring suggests that behaviour, hence my confusion."><span class="u" id="1519265855.000058">2018:02:22 02:17:35             steveb8n </span><span>But what if I want to conditionally remove it i.e. when value is nil. Is there an idiomatic way to do that? The docstring suggests that behaviour, hence my confusion.</span></div><div data-t="steveb8n I can write a transform fn or conditional navigation but wonder if you would use compact or some other elegance for that as well?"><span class="u" id="1519266035.000254">2018:02:22 02:20:35             steveb8n </span><span>I can write a transform fn or conditional navigation but wonder if you would use compact or some other elegance for that as well?</span></div><div data-t="steveb8n And thanks  🙂  "><span class="u" id="1519266092.000208">2018:02:22 02:21:32             steveb8n </span><span>And thanks </span><b>🙂</b><span> </span></div><div data-t="nathanmarz @steveb8n it&apos;s just  (setval [ALL :a :c nil?] NONE data)"><span class="u" id="1519266741.000047">2018:02:22 02:32:21           nathanmarz </span><span>@steveb8n it&apos;s just </span><code>(setval [ALL :a :c nil?] NONE data)</code></div><div data-t="steveb8n Ok. That works. Thanks again"><span class="u" id="1519267112.000226">2018:02:22 02:38:32             steveb8n </span><span>Ok. That works. Thanks again</span></div><div data-t="sashton i’m just trying out specter.
what’s the best way to select-keys at various levels of a tree:
 ;; input
{:a {:aa 1 :ab 2 :ac 3}
 :b {:ba 10 :ba 11}
 :c {:ca 100}}

;; desired output
{:a {:aa 1 :ab 2}
 :c {:ca 100}}
"><span class="u" id="1519321940.000728">2018:02:22 17:52:20              sashton </span><span>i’m just trying out specter.
what’s the best way to select-keys at various levels of a tree:
</span><pre>;; input
{:a {:aa 1 :ab 2 :ac 3}
 :b {:ba 10 :ba 11}
 :c {:ca 100}}

;; desired output
{:a {:aa 1 :ab 2}
 :c {:ca 100}}
</pre></div><div data-t="nathanmarz @sashton to maintain the structure of the input, select what to remove rather than what to keep:
 (setval (multi-path :b [:a :ac]) NONE data)
"><span class="u" id="1519322145.000612">2018:02:22 17:55:45           nathanmarz </span><span>@sashton to maintain the structure of the input, select what to remove rather than what to keep:
</span><pre>(setval (multi-path :b [:a :ac]) NONE data)
</pre></div><div data-t="sashton thanks @nathanmarz. is remove the only option? the data i’m looking at has lots of extra fields which i’m not interested in. while i could list all the fields to delete, it might get tedious."><span class="u" id="1519322311.000008">2018:02:22 17:58:31              sashton </span><span>thanks @nathanmarz. is remove the only option? the data i’m looking at has lots of extra fields which i’m not interested in. while i could list all the fields to delete, it might get tedious.</span></div><div data-t="nathanmarz there&apos;s also the  submap  navigator which for selects is equivalent to  select-keys"><span class="u" id="1519322338.000356">2018:02:22 17:58:58           nathanmarz </span><span>there&apos;s also the </span><code>submap</code><span> navigator which for selects is equivalent to </span><code>select-keys</code></div><div data-t="nathanmarz though it currently changes sorted maps to unsorted maps if used in a  select   https://github.com/nathanmarz/specter/issues/235"><span class="u" id="1519322521.000032">2018:02:22 18:02:01           nathanmarz </span><span>though it currently changes sorted maps to unsorted maps if used in a </span><code>select</code><span> </span><a href="https://github.com/nathanmarz/specter/issues/235">https://github.com/nathanmarz/specter/issues/235</a></div><div data-t="nathanmarz this is how you could go about doing it with  submap :
 (defdynamicnav viewed [path viewnav]
  (transformed path (fn [s] (select-any viewnav s)))
  )

(select-any [(viewed :a (submap [:aa :ab])) (submap [:a :c])] data)
"><span class="u" id="1519322802.000210">2018:02:22 18:06:42           nathanmarz </span><span>this is how you could go about doing it with </span><code>submap</code><span>:
</span><pre>(defdynamicnav viewed [path viewnav]
  (transformed path (fn [s] (select-any viewnav s)))
  )

(select-any [(viewed :a (submap [:aa :ab])) (submap [:a :c])] data)
</pre></div><div data-t="sashton thanks again. that works"><span class="u" id="1519330025.000262">2018:02:22 20:07:05              sashton </span><span>thanks again. that works</span></div><div data-t="kurt-o-sys I have a nested structure, combining vectors and maps like this:
 [{:__type &quot;some_type&quot;
  :mykey 1
  :date    #inst&quot;...&quot;
  :subs [{__type &quot;another_type&quot;
          :typekey &quot;value&quot;}
         {__type &quot;another_type&quot;}]
  :onesub {:__type &quot;random_type&quot;
           :subkey 2}]}
 
What I would like to do is tranform some keys of all maps of a certain type (the transformation is always the same). So, for example, what I would like to do something like (with the previous map as  m ):
 (resolve-values {&quot;some_type&quot; [:date :name] &quot;random_type&quot; [:another_key]} m) 
which would transform all  :date  and  :name  values of maps which have a  :__type &quot;some_type&quot;  entry and all  :another_key  values of maps which have a  :__type &quot;random_type  entry"><span class="u" id="1519455966.000029">2018:02:24 07:06:06           kurt-o-sys </span><span>I have a nested structure, combining vectors and maps like this:
</span><pre>[{:__type &quot;some_type&quot;
  :mykey 1
  :date    #inst&quot;...&quot;
  :subs [{__type &quot;another_type&quot;
          :typekey &quot;value&quot;}
         {__type &quot;another_type&quot;}]
  :onesub {:__type &quot;random_type&quot;
           :subkey 2}]}
</pre><span>
What I would like to do is tranform some keys of all maps of a certain type (the transformation is always the same). So, for example, what I would like to do something like (with the previous map as </span><code>m</code><span>):
</span><code>(resolve-values {&quot;some_type&quot; [:date :name] &quot;random_type&quot; [:another_key]} m)</code><span>
which would transform all </span><code>:date</code><span> and </span><code>:name</code><span> values of maps which have a </span><code>:__type &quot;some_type&quot;</code><span> entry and all </span><code>:another_key</code><span> values of maps which have a </span><code>:__type &quot;random_type</code><span> entry</span></div><div data-t="kurt-o-sys how would I do that using  specter  (I guess specter is the best way to do it  🙂  )"><span class="u" id="1519456004.000050">2018:02:24 07:06:44           kurt-o-sys </span><span>how would I do that using </span><code>specter</code><span> (I guess specter is the best way to do it </span><b>🙂</b><span> )</span></div><div data-t="kurt-o-sys it has to be some recursive path, but I can&apos;t really figure out how it would look like, so:
 (specter/transform [....?] resolve m)"><span class="u" id="1519456069.000040">2018:02:24 07:07:49           kurt-o-sys </span><span>it has to be some recursive path, but I can&apos;t really figure out how it would look like, so:
</span><code>(specter/transform [....?] resolve m)</code></div><div data-t="kurt-o-sys with  resolve  the function to apply to the values that have to be transformed, but what is  ...? ?"><span class="u" id="1519456102.000017">2018:02:24 07:08:22           kurt-o-sys </span><span>with </span><code>resolve</code><span> the function to apply to the values that have to be transformed, but what is </span><code>...?</code><span>?</span></div><div data-t="kurt-o-sys so, this is what I came up with so far for one type:
 (defn type-map-path [__type]
	(specter/recursive-path [] p
                        [(specter/walker #(= (:__type %) __type))
                         (specter/stay-then-continue [specter/ALL p])]))

(def SOME-TYPE-MAP-PATH (type-map-path &quot;some_type&quot;))
(def SOME-TYPE-KEYS-PATH (specter/multi-path :date :name))
"><span class="u" id="1519479995.000057">2018:02:24 13:46:35           kurt-o-sys </span><span>so, this is what I came up with so far for one type:
</span><pre>(defn type-map-path [__type]
	(specter/recursive-path [] p
                        [(specter/walker #(= (:__type %) __type))
                         (specter/stay-then-continue [specter/ALL p])]))

(def SOME-TYPE-MAP-PATH (type-map-path &quot;some_type&quot;))
(def SOME-TYPE-KEYS-PATH (specter/multi-path :date :name))
</pre></div><div data-t="kurt-o-sys Just wondering looping and walking several times would bring much benefit over trying to make  multi-path  work for different  __type s"><span class="u" id="1519480058.000094">2018:02:24 13:47:38           kurt-o-sys </span><span>Just wondering looping and walking several times would bring much benefit over trying to make </span><code>multi-path</code><span> work for different </span><code>__type</code><span>s</span></div><div data-t="nathanmarz @kurt-o-sys this is a better way to do it:
 (def MAPS
  (recursive-path [] p
    (cond-path
      map? (continue-then-stay MAP-VALS p)
      coll? [ALL p])
    ))

(transform [MAPS #(= (:__type %) &quot;another_type&quot;)] resolve data)
"><span class="u" id="1519483166.000041">2018:02:24 14:39:26           nathanmarz </span><span>@kurt-o-sys this is a better way to do it:
</span><pre>(def MAPS
  (recursive-path [] p
    (cond-path
      map? (continue-then-stay MAP-VALS p)
      coll? [ALL p])
    ))

(transform [MAPS #(= (:__type %) &quot;another_type&quot;)] resolve data)
</pre></div><div data-t="nathanmarz walker  is very wasteful in this case, since it traverses into map keys and key/value pairs"><span class="u" id="1519483201.000090">2018:02:24 14:40:01           nathanmarz </span><code>walker</code><span> is very wasteful in this case, since it traverses into map keys and key/value pairs</span></div><div data-t="nathanmarz this is a much more efficient way to navigate your data structure that leverages the structure of your data"><span class="u" id="1519483219.000042">2018:02:24 14:40:19           nathanmarz </span><span>this is a much more efficient way to navigate your data structure that leverages the structure of your data</span></div><div data-t="kurt-o-sys oh, nice, thx!"><span class="u" id="1519483766.000059">2018:02:24 14:49:26           kurt-o-sys </span><span>oh, nice, thx!</span></div><div data-t="kurt-o-sys I&apos;m starting to really fall in love with specter  😛"><span class="u" id="1519487048.000142">2018:02:24 15:44:08           kurt-o-sys </span><span>I&apos;m starting to really fall in love with specter </span><b>😛</b></div><div data-t="yogidevbear Hi everyone. I&apos;m trying to add Specter to a lein clojure project. I&apos;ve added  [com.rpl/specter &quot;1.1.0&quot;]  to my dependencies and  (:require [com.rpl.specter])  to my ns. I&apos;m getting the following error in my ns thought:  FileNotFoundException Could not locate com/rpl/specter__init.class or com/rpl/specter.clj on classpath.  clojure.lang.RT.load (RT.java:463) ."><span class="u" id="1519507501.000079">2018:02:24 21:25:01          yogidevbear </span><span>Hi everyone. I&apos;m trying to add Specter to a lein clojure project. I&apos;ve added </span><code>[com.rpl/specter &quot;1.1.0&quot;]</code><span> to my dependencies and </span><code>(:require [com.rpl.specter])</code><span> to my ns. I&apos;m getting the following error in my ns thought: </span><code>FileNotFoundException Could not locate com/rpl/specter__init.class or com/rpl/specter.clj on classpath.  clojure.lang.RT.load (RT.java:463)</code><span>.</span></div><div data-t="schmee @yogidevbear are you in a REPL?"><span class="u" id="1519507767.000074">2018:02:24 21:29:27               schmee </span><span>@yogidevbear are you in a REPL?</span></div><div data-t="yogidevbear I&apos;m working from within ProtoREPL doing inline evaluation inside atom io"><span class="u" id="1519508355.000008">2018:02:24 21:39:15          yogidevbear </span><span>I&apos;m working from within ProtoREPL doing inline evaluation inside atom io</span></div><div data-t="schmee okay, I don’t know how that works unfortunately"><span class="u" id="1519508993.000047">2018:02:24 21:49:53               schmee </span><span>okay, I don’t know how that works unfortunately</span></div><div data-t="schmee try running  lein deps  inside your project and see if that helps"><span class="u" id="1519509003.000030">2018:02:24 21:50:03               schmee </span><span>try running </span><code>lein deps</code><span> inside your project and see if that helps</span></div><div data-t="yogidevbear No luck"><span class="u" id="1519509079.000037">2018:02:24 21:51:19          yogidevbear </span><span>No luck</span></div><div data-t="nathanmarz @yogidevbear you&apos;re best off asking in #clojurescript"><span class="u" id="1519509079.000093">2018:02:24 21:51:19           nathanmarz </span><span>@yogidevbear you&apos;re best off asking in #clojurescript</span></div><div data-t="yogidevbear Hmmm, but I&apos;m not using ClojureScript"><span class="u" id="1519509098.000070">2018:02:24 21:51:38          yogidevbear </span><span>Hmmm, but I&apos;m not using ClojureScript</span></div><div data-t="nathanmarz oh sorry, misunderstood"><span class="u" id="1519509126.000071">2018:02:24 21:52:06           nathanmarz </span><span>oh sorry, misunderstood</span></div><div data-t="nathanmarz does it work from  lein repl ?"><span class="u" id="1519509143.000022">2018:02:24 21:52:23           nathanmarz </span><span>does it work from </span><code>lein repl</code><span>?</span></div><div data-t="yogidevbear Yup, seems to work if I do  (use &apos;com.rpl.specter)  from within  lein repl"><span class="u" id="1519509322.000052">2018:02:24 21:55:22          yogidevbear </span><span>Yup, seems to work if I do </span><code>(use &apos;com.rpl.specter)</code><span> from within </span><code>lein repl</code></div><div data-t="nathanmarz have you tried restarting protorepl?"><span class="u" id="1519509339.000066">2018:02:24 21:55:39           nathanmarz </span><span>have you tried restarting protorepl?</span></div><div data-t="yogidevbear I&apos;ll give that a try"><span class="u" id="1519509384.000041">2018:02:24 21:56:24          yogidevbear </span><span>I&apos;ll give that a try</span></div><div data-t="yogidevbear would it be worth clearing out my  .m2  folder too?"><span class="u" id="1519509399.000088">2018:02:24 21:56:39          yogidevbear </span><span>would it be worth clearing out my </span><code>.m2</code><span> folder too?</span></div><div data-t="nathanmarz doubtful given that it&apos;s working with a regular repl"><span class="u" id="1519509468.000082">2018:02:24 21:57:48           nathanmarz </span><span>doubtful given that it&apos;s working with a regular repl</span></div><div data-t="yogidevbear Fair point  🙂"><span class="u" id="1519509605.000133">2018:02:24 22:00:05          yogidevbear </span><span>Fair point </span><b>🙂</b></div><div data-t="frenata If I want to select some substructure out of a nested map, rather than just the leaves, what&apos;s the best way to do that with specter?
IE, I have  {:foo 1 :bar {:baz 2 :bat 3}} , and I want to select out  {:bar {:baz 2}} .

New to the library and just poking around. Thought  subselect  or  filterer  might work, but at least the way I&apos;m using them they aren&apos;t quite right."><span class="u" id="1520006534.000510">2018:03:02 16:02:14              frenata </span><span>If I want to select some substructure out of a nested map, rather than just the leaves, what&apos;s the best way to do that with specter?
IE, I have </span><code>{:foo 1 :bar {:baz 2 :bat 3}}</code><span>, and I want to select out </span><code>{:bar {:baz 2}}</code><span>.

New to the library and just poking around. Thought </span><code>subselect</code><span> or </span><code>filterer</code><span> might work, but at least the way I&apos;m using them they aren&apos;t quite right.</span></div><div data-t="nathanmarz @andrew354 it depends on the use case, but generally the most straightforward approach is to remove what you don&apos;t want"><span class="u" id="1520007537.000630">2018:03:02 16:18:57           nathanmarz </span><span>@andrew354 it depends on the use case, but generally the most straightforward approach is to remove what you don&apos;t want</span></div><div data-t="nathanmarz (setval (multi-path :foo [:bar :bat]) NONE data)
"><span class="u" id="1520007541.000511">2018:03:02 16:19:01           nathanmarz </span><pre>(setval (multi-path :foo [:bar :bat]) NONE data)
</pre></div><div data-t="frenata Ah, so naming the paths of things you want to get rid of."><span class="u" id="1520007641.000451">2018:03:02 16:20:41              frenata </span><span>Ah, so naming the paths of things you want to get rid of.</span></div><div data-t="frenata Unfortunately I think in my actual use-case, I want to keep a fairly small part of the structure, but I&apos;ll see if this approach will work."><span class="u" id="1520007662.000879">2018:03:02 16:21:02              frenata </span><span>Unfortunately I think in my actual use-case, I want to keep a fairly small part of the structure, but I&apos;ll see if this approach will work.</span></div><div data-t="nathanmarz @andrew354 another approach that explicitly selects the keys you want:"><span class="u" id="1520007843.000594">2018:03:02 16:24:03           nathanmarz </span><span>@andrew354 another approach that explicitly selects the keys you want:</span></div><div data-t="nathanmarz (defdynamicnav viewed [path viewnav]
  (transformed path #(select-any viewnav %)))

(select-any [(submap [:bar]) (viewed :bar (submap [:baz]))] data)
"><span class="u" id="1520007850.000586">2018:03:02 16:24:10           nathanmarz </span><pre>(defdynamicnav viewed [path viewnav]
  (transformed path #(select-any viewnav %)))

(select-any [(submap [:bar]) (viewed :bar (submap [:baz]))] data)
</pre></div><div data-t="frenata Interesting. I may try both approaches and see what is most clear."><span class="u" id="1520007928.000267">2018:03:02 16:25:28              frenata </span><span>Interesting. I may try both approaches and see what is most clear.</span></div><div data-t="nathanmarz could make a helper that takes in a list of keyword paths and produces the navigation"><span class="u" id="1520007939.000531">2018:03:02 16:25:39           nathanmarz </span><span>could make a helper that takes in a list of keyword paths and produces the navigation</span></div><div data-t="nathanmarz e.g.  (select-any (keep-keyword-paths [:bar :baz]) data)"><span class="u" id="1520007960.000488">2018:03:02 16:26:00           nathanmarz </span><span>e.g. </span><code>(select-any (keep-keyword-paths [:bar :baz]) data)</code></div><div data-t="schmee I think that  viewed  with a bit of polish could go into specter core  🙂"><span class="u" id="1520008139.000147">2018:03:02 16:28:59               schmee </span><span>I think that </span><code>viewed</code><span> with a bit of polish could go into specter core </span><b>🙂</b></div><div data-t="frenata btw, thanks @nathanmarz, the second approach worked out really nicely."><span class="u" id="1520035708.000305">2018:03:03 00:08:28              frenata </span><span>btw, thanks @nathanmarz, the second approach worked out really nicely.</span></div><div data-t="hkjels Can I use specter to create a matrix from a tree? Meaning that the first column will be populated with duplicates for all childrens children and so on"><span class="u" id="1520431025.000263">2018:03:07 13:57:05               hkjels </span><span>Can I use specter to create a matrix from a tree? Meaning that the first column will be populated with duplicates for all childrens children and so on</span></div><div data-t="nathanmarz @hkjels it would likely be helpful for traversing the tree in the order you want"><span class="u" id="1520432044.000592">2018:03:07 14:14:04           nathanmarz </span><span>@hkjels it would likely be helpful for traversing the tree in the order you want</span></div><div data-t="nathanmarz the code would look something like  (reduce build-my-matrix empty-matrix (traverse &lt;path&gt; my-tree))"><span class="u" id="1520432085.000102">2018:03:07 14:14:45           nathanmarz </span><span>the code would look something like </span><code>(reduce build-my-matrix empty-matrix (traverse &lt;path&gt; my-tree))</code></div><div data-t="hkjels Nice, I’ll give it a go"><span class="u" id="1520432798.000611">2018:03:07 14:26:38               hkjels </span><span>Nice, I’ll give it a go</span></div><div data-t="razum2um is there a way to express this better?
 =&gt; (transform [(if-path [#(contains? % :loc)] [:loc ALL])] inc {:x 1})
{:x 1}
=&gt; (transform [(if-path [#(contains? % :loc)] [:loc ALL])] inc {:loc [1]})
{:loc [2]}
 
don’t want extra key after simple
 =&gt; (transform [:loc ALL] inc {:x 1})
{:x 1, :loc nil}
"><span class="u" id="1520608721.000573">2018:03:09 15:18:41             razum2um </span><span>is there a way to express this better?
</span><pre>=&gt; (transform [(if-path [#(contains? % :loc)] [:loc ALL])] inc {:x 1})
{:x 1}
=&gt; (transform [(if-path [#(contains? % :loc)] [:loc ALL])] inc {:loc [1]})
{:loc [2]}
</pre><span>
don’t want extra key after simple
</span><pre>=&gt; (transform [:loc ALL] inc {:x 1})
{:x 1, :loc nil}
</pre></div><div data-t="nathanmarz @razum2um 
 (transform [(must :loc) ALL] inc data)
"><span class="u" id="1520609231.000702">2018:03:09 15:27:11           nathanmarz </span><span>@razum2um 
</span><pre>(transform [(must :loc) ALL] inc data)
</pre></div><div data-t="razum2um thanks!"><span class="u" id="1520609779.000570">2018:03:09 15:36:19                  razum2um </span><span>thanks!</span></div><div data-t="razum2um @nathanmarz btw, I had an idea about the vector as a forth program, did you think about this?"><span class="u" id="1520609909.000525">2018:03:09 15:38:29             razum2um </span><span>@nathanmarz btw, I had an idea about the vector as a forth program, did you think about this?</span></div><div data-t="nathanmarz @razum2um no, what do you mean?"><span class="u" id="1520611095.000379">2018:03:09 15:58:15           nathanmarz </span><span>@razum2um no, what do you mean?</span></div><div data-t="razum2um currently the library api interface looks convenient but adhoc, I feel there shoud be case out there which cannot fit into vector. I thought we could imagine the traversal as “bytecodes” steps to the lib (interpretator)"><span class="u" id="1520611275.000414">2018:03:09 16:01:15             razum2um </span><span>currently the library api interface looks convenient but adhoc, I feel there shoud be case out there which cannot fit into vector. I thought we could imagine the traversal as “bytecodes” steps to the lib (interpretator)</span></div><div data-t="razum2um I understand implementing VM for data traversal is not easy  😅   but just wanted to share this"><span class="u" id="1520611383.000347">2018:03:09 16:03:03             razum2um </span><span>I understand implementing VM for data traversal is not easy </span><b>😅</b><span>  but just wanted to share this</span></div><div data-t="razum2um just on the spot: e.g. in this way we could even allow some recursion steps in traversal"><span class="u" id="1520611423.000442">2018:03:09 16:03:43             razum2um </span><span>just on the spot: e.g. in this way we could even allow some recursion steps in traversal</span></div><div data-t="razum2um example2: my request above in this approach could look like  (transform [:loc &gt;nil? &lt;STOP ALL] inc {:x 1})  where  &gt;nil?  puts on stack if  loc  return value is nit  &lt;STOP  pops and shortcuts path if last val was true"><span class="u" id="1520611613.000587">2018:03:09 16:06:53             razum2um </span><span>example2: my request above in this approach could look like </span><code>(transform [:loc &gt;nil? &lt;STOP ALL] inc {:x 1})</code><span> where </span><code>&gt;nil?</code><span> puts on stack if </span><code>loc</code><span> return value is nit </span><code>&lt;STOP</code><span> pops and shortcuts path if last val was true</span></div><div data-t="nathanmarz that would increase the complexity of specter by 1000x"><span class="u" id="1520611667.000320">2018:03:09 16:07:47           nathanmarz </span><span>that would increase the complexity of specter by 1000x</span></div><div data-t="razum2um yeah  🙂"><span class="u" id="1520611679.000446">2018:03:09 16:07:59             razum2um </span><span>yeah </span><b>🙂</b></div><div data-t="nathanmarz specter is not a language, it&apos;s just an interface and an efficient method for composing them"><span class="u" id="1520611690.000853">2018:03:09 16:08:10           nathanmarz </span><span>specter is not a language, it&apos;s just an interface and an efficient method for composing them</span></div><div data-t="nathanmarz there&apos;s no known use cases it doesn&apos;t handle, so there&apos;s no reason to do something like that"><span class="u" id="1520611723.000367">2018:03:09 16:08:43           nathanmarz </span><span>there&apos;s no known use cases it doesn&apos;t handle, so there&apos;s no reason to do something like that</span></div><div data-t="razum2um don’t push you, just wanted to hear your thoughts"><span class="u" id="1520611725.000313">2018:03:09 16:08:45             razum2um </span><span>don’t push you, just wanted to hear your thoughts</span></div><div data-t="razum2um thanks for your efforts btw  :+1:"><span class="u" id="1520611750.000554">2018:03:09 16:09:10             razum2um </span><span>thanks for your efforts btw </span><b>:+1:</b></div><div data-t="razum2um is it ok if I’ll PR to the readme.md with  must  example?"><span class="u" id="1520611789.000135">2018:03:09 16:09:49             razum2um </span><span>is it ok if I’ll PR to the readme.md with </span><code>must</code><span> example?</span></div><div data-t="nathanmarz sure thing"><span class="u" id="1520611831.000648">2018:03:09 16:10:31           nathanmarz </span><span>sure thing</span></div><div data-t="nathanmarz not sure what to do with the readme, it&apos;s kind of just a random exploration of different kinds of manipulations"><span class="u" id="1520611876.000076">2018:03:09 16:11:16           nathanmarz </span><span>not sure what to do with the readme, it&apos;s kind of just a random exploration of different kinds of manipulations</span></div><div data-t="nathanmarz I don&apos;t think making that section longer than it already is will improve things"><span class="u" id="1520611942.000125">2018:03:09 16:12:22           nathanmarz </span><span>I don&apos;t think making that section longer than it already is will improve things</span></div><div data-t="nathanmarz the wiki is pretty good nowadays"><span class="u" id="1520611951.000383">2018:03:09 16:12:31           nathanmarz </span><span>the wiki is pretty good nowadays</span></div><div data-t="nathanmarz so I just point people there"><span class="u" id="1520611956.000002">2018:03:09 16:12:36           nathanmarz </span><span>so I just point people there</span></div><div data-t="nathanmarz and to answer your question about recursion, see  https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively"><span class="u" id="1520611989.000768">2018:03:09 16:13:09           nathanmarz </span><span>and to answer your question about recursion, see </span><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively</a></div><div data-t="razum2um hm, yes, I think now it’s quite too special example for readme..
but here is the point (from wiki)
&gt; Note that must stops navigation
I think there should be a list with such “stopping” things, wdyt?"><span class="u" id="1520612663.000744">2018:03:09 16:24:23             razum2um </span><span>hm, yes, I think now it’s quite too special example for readme..
but here is the point (from wiki)
&gt; Note that must stops navigation
I think there should be a list with such “stopping” things, wdyt?</span></div><div data-t="razum2um still, here you are  https://github.com/nathanmarz/specter/pull/249"><span class="u" id="1520612895.000158">2018:03:09 16:28:15             razum2um </span><span>still, here you are </span><a href="https://github.com/nathanmarz/specter/pull/249">https://github.com/nathanmarz/specter/pull/249</a></div><div data-t="razum2um I think we have ~300 people here and readme should represent most common used cases. e.g. in same format as in clojuredocs (crowd-examples, maybe on same engine, afair it’s oss)"><span class="u" id="1520613110.000372">2018:03:09 16:31:50             razum2um </span><span>I think we have ~300 people here and readme should represent most common used cases. e.g. in same format as in clojuredocs (crowd-examples, maybe on same engine, afair it’s oss)</span></div><div data-t="nathanmarz @razum2um this is the categorization I use when thinking of navigators:  https://github.com/nathanmarz/specter/wiki/Cheat-Sheet"><span class="u" id="1520613899.000172">2018:03:09 16:44:59           nathanmarz </span><span>@razum2um this is the categorization I use when thinking of navigators: </span><a href="https://github.com/nathanmarz/specter/wiki/Cheat-Sheet">https://github.com/nathanmarz/specter/wiki/Cheat-Sheet</a></div><div data-t="razum2um yeah, saw it. is there any other stopping word like  must ?"><span class="u" id="1520613965.000275">2018:03:09 16:46:05             razum2um </span><span>yeah, saw it. is there any other stopping word like </span><code>must</code><span>?</span></div><div data-t="nathanmarz ALL ,  MAP-KEYS ,  MAP-VALS  will stop if there&apos;s nothing in the collection"><span class="u" id="1520614008.000497">2018:03:09 16:46:48           nathanmarz </span><code>ALL</code><span>, </span><code>MAP-KEYS</code><span>, </span><code>MAP-VALS</code><span> will stop if there&apos;s nothing in the collection</span></div><div data-t="nathanmarz STOP  explicitly stops"><span class="u" id="1520614011.000770">2018:03:09 16:46:51           nathanmarz </span><code>STOP</code><span> explicitly stops</span></div><div data-t="nathanmarz terminal  navigators explicitly stop"><span class="u" id="1520614019.000737">2018:03:09 16:46:59           nathanmarz </span><code>terminal</code><span> navigators explicitly stop</span></div><div data-t="nathanmarz set-elem  and  map-key  stop if the elem/key isn&apos;t there"><span class="u" id="1520614047.000571">2018:03:09 16:47:27           nathanmarz </span><code>set-elem</code><span> and </span><code>map-key</code><span> stop if the elem/key isn&apos;t there</span></div><div data-t="razum2um ok, thanks  :+1:"><span class="u" id="1520614052.000811">2018:03:09 16:47:32             razum2um </span><span>ok, thanks </span><b>:+1:</b></div><div data-t="nathanmarz FIRST /`LAST` stop if the sequence is empty"><span class="u" id="1520614071.000257">2018:03:09 16:47:51           nathanmarz </span><code>FIRST</code><span>/`LAST` stop if the sequence is empty</span></div><div data-t="mbjarland How would I go about selecting a specific node in a vector of vectors structure like the following: 
 [:html
 {}
 [:body
  {}
  [:table
   {}
   [:tr {} [:th {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} &quot;Task Name&quot;] [:th {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} &quot;Description&quot;]]
   [:tr
    {}
    [:td {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} [:a {:shape &quot;rect&quot;, :href &quot;Tasks/unpack.html&quot;} &quot;GUnzip/BUnzip2/UnXZ&quot;]]
    [:td {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} [:p {} &quot;Expands a file packed using GZip, BZip2 or XZ.&quot;]]]
 
i.e. I would like to check the  :href  value on the second to last row and if it matches a predicate, return the string on the last row. Mainly I&apos;m confused in general about how to write paths against vectors with some kind of predicate logic for which paths to traverse and which to not"><span class="u" id="1520871599.000152">2018:03:12 16:19:59            mbjarland </span><span>How would I go about selecting a specific node in a vector of vectors structure like the following: 
</span><pre>[:html
 {}
 [:body
  {}
  [:table
   {}
   [:tr {} [:th {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} &quot;Task Name&quot;] [:th {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} &quot;Description&quot;]]
   [:tr
    {}
    [:td {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} [:a {:shape &quot;rect&quot;, :href &quot;Tasks/unpack.html&quot;} &quot;GUnzip/BUnzip2/UnXZ&quot;]]
    [:td {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} [:p {} &quot;Expands a file packed using GZip, BZip2 or XZ.&quot;]]]
</pre><span>
i.e. I would like to check the </span><code>:href</code><span> value on the second to last row and if it matches a predicate, return the string on the last row. Mainly I&apos;m confused in general about how to write paths against vectors with some kind of predicate logic for which paths to traverse and which to not</span></div><div data-t="mbjarland don&apos;t need a complete answer, just need to understand which navigator to use in a case like this"><span class="u" id="1520871645.000186">2018:03:12 16:20:45            mbjarland </span><span>don&apos;t need a complete answer, just need to understand which navigator to use in a case like this</span></div><div data-t="mbjarland somehow traverse to the first elems of vectors in the structure and if they match (in order)  :html ,  :body ,  :table   :tr  then check a predicate against the first  :td  and collect string from the second  :td  if predicate matches"><span class="u" id="1520871786.000183">2018:03:12 16:23:06            mbjarland </span><span>somehow traverse to the first elems of vectors in the structure and if they match (in order) </span><code>:html</code><span>, </span><code>:body</code><span>, </span><code>:table</code><span> </span><code>:tr</code><span> then check a predicate against the first </span><code>:td</code><span> and collect string from the second </span><code>:td</code><span> if predicate matches</span></div><div data-t="mbjarland ok figured out a solution, a tad ugly but it works: 
 (defn tag? [name]
  (fn [vec]
    (and (vector? vec) (= (first vec) name))))
 
and 
 (spctr/select 
  [spctr/ALL (tag? :body) spctr/ALL (tag? :table) spctr/ALL (tag? :tr) ... etc]
  data)
"><span class="u" id="1520872234.000440">2018:03:12 16:30:34            mbjarland </span><span>ok figured out a solution, a tad ugly but it works: 
</span><pre>(defn tag? [name]
  (fn [vec]
    (and (vector? vec) (= (first vec) name))))
</pre><span>
and 
</span><pre>(spctr/select 
  [spctr/ALL (tag? :body) spctr/ALL (tag? :table) spctr/ALL (tag? :tr) ... etc]
  data)
</pre></div><div data-t="nathanmarz @mbjarland you can capture more structure with this:
 (defdynamicnav tags-traversal [&amp; tags]
  (mapcat (fn [t] [ALL (tag? t)] tags))
  )
"><span class="u" id="1520874429.000794">2018:03:12 17:07:09           nathanmarz </span><span>@mbjarland you can capture more structure with this:
</span><pre>(defdynamicnav tags-traversal [&amp; tags]
  (mapcat (fn [t] [ALL (tag? t)] tags))
  )
</pre></div><div data-t="nathanmarz and then do  (select [(tags-traversal :body :table :tr) ...] data)"><span class="u" id="1520874458.000585">2018:03:12 17:07:38           nathanmarz </span><span>and then do </span><code>(select [(tags-traversal :body :table :tr) ...] data)</code></div><div data-t="mbjarland @nathanmarz : ) for once I wasn&apos;t far off then! Thanks, that is indeed cleaner"><span class="u" id="1520882803.000251">2018:03:12 19:26:43            mbjarland </span><span>@nathanmarz : ) for once I wasn&apos;t far off then! Thanks, that is indeed cleaner</span></div><div data-t="nathanmarz @mbjarland btw, here&apos;s a better way to implement those:
 (defn tag? [name]
  (pred
    (fn [vec]
      (and (vector? vec) (= (first vec) name)))))

(defdynamicnav tags-traversal [&amp; tags]
  (let [late-tag? (late-resolved-fn tag?)]
    (mapcat (fn [t] [ALL (late-tag? t)]) tags)
    ))
"><span class="u" id="1520885559.000126">2018:03:12 20:12:39           nathanmarz </span><span>@mbjarland btw, here&apos;s a better way to implement those:
</span><pre>(defn tag? [name]
  (pred
    (fn [vec]
      (and (vector? vec) (= (first vec) name)))))

(defdynamicnav tags-traversal [&amp; tags]
  (let [late-tag? (late-resolved-fn tag?)]
    (mapcat (fn [t] [ALL (late-tag? t)]) tags)
    ))
</pre></div><div data-t="nathanmarz adding  pred  to return of  tag?  increases performance by avoiding a runtime conversion from function to navigator"><span class="u" id="1520885593.000616">2018:03:12 20:13:13           nathanmarz </span><span>adding </span><code>pred</code><span> to return of </span><code>tag?</code><span> increases performance by avoiding a runtime conversion from function to navigator</span></div><div data-t="nathanmarz the  late-resolved-fn  call in  tags-traversal  allows that dynamicnav to handle dynamic parameters correctly (e.g.  (tags-traversal :html some-local) )"><span class="u" id="1520885635.000507">2018:03:12 20:13:55           nathanmarz </span><span>the </span><code>late-resolved-fn</code><span> call in </span><code>tags-traversal</code><span> allows that dynamicnav to handle dynamic parameters correctly (e.g. </span><code>(tags-traversal :html some-local)</code><span>)</span></div><div data-t="mbjarland ok well that brings us back to the normal cycle of “no there’s a much better way to do that” : ) 
many thanks, will noodle on this"><span class="u" id="1520885706.000699">2018:03:12 20:15:06            mbjarland </span><span>ok well that brings us back to the normal cycle of “no there’s a much better way to do that” : ) 
many thanks, will noodle on this</span></div><div data-t="mbjarland ok last one…how would I select the “rest” of a vector starting at an index…`srange` and  srange-dynamic  do not seem to do quite this from what I understand"><span class="u" id="1520887205.000298">2018:03:12 20:40:05            mbjarland </span><span>ok last one…how would I select the “rest” of a vector starting at an index…`srange` and </span><code>srange-dynamic</code><span> do not seem to do quite this from what I understand</span></div><div data-t="nathanmarz @mbjarland do you know the index before the  select  happens?"><span class="u" id="1520888879.000547">2018:03:12 21:07:59           nathanmarz </span><span>@mbjarland do you know the index before the </span><code>select</code><span> happens?</span></div><div data-t="mbjarland yes"><span class="u" id="1520892334.000406">2018:03:12 22:05:34            mbjarland </span><span>yes</span></div><div data-t="mbjarland index is fixed"><span class="u" id="1520892339.000068">2018:03:12 22:05:39            mbjarland </span><span>index is fixed</span></div><div data-t="mbjarland essentially it’s  (rest (rest coll))"><span class="u" id="1520892354.000367">2018:03:12 22:05:54            mbjarland </span><span>essentially it’s </span><code>(rest (rest coll))</code></div><div data-t="nathanmarz @mbjarland is this what you need?
 (defn subrest [i]
  (srange-dynamic (fn [_] i) (fn [s] (count s))))

(transform (subrest 2) reverse [1 2 3 4 5 6])
;; =&gt; [1 2 6 5 4 3]
"><span class="u" id="1520894522.000364">2018:03:12 22:42:02           nathanmarz </span><span>@mbjarland is this what you need?
</span><pre>(defn subrest [i]
  (srange-dynamic (fn [_] i) (fn [s] (count s))))

(transform (subrest 2) reverse [1 2 3 4 5 6])
;; =&gt; [1 2 6 5 4 3]
</pre></div><div data-t="mbjarland @nathanmarz well I do believe that is exactly what I need. Thanks again!"><span class="u" id="1520947281.000236">2018:03:13 13:21:21            mbjarland </span><span>@nathanmarz well I do believe that is exactly what I need. Thanks again!</span></div><div data-t="Marcus Pemer Hi - my first question to this channel, hope you all are doing well. I am processing some CSV input - fairly large file with four types of records in them. All records are grouped with a header line and they are separated with blank (empty) lines. I have come up with the following attempt to use Specter for the transformation:

 (let [data (-&gt;&gt;
            ;; my data comes in as text from a csv file
            (csv/parse-csv (slurp &quot;some-file-name.csv&quot;)
            ;; group by number of elements and remove group of empty rows
            (dissoc (group-by count csv) 1)
            ;; remove trailing empty cells within records
            (setval [MAP-VALS ALL LAST empty?] NONE)
            ;; prepare fields that will become map keys
            (transform [MAP-VALS FIRST ALL] keify)
            ;; turn the groups into maps
            (transform [MAP-VALS] sc/mappify)
            ;; lastly, read our data fields
            (transform [MAP-VALS ALL ALL] read-field)
            )]
  (def a-records (get data 6))
  (def b-records (get data 7))
  (def c-records (get data 11))
  (def d-records (get data 15)))
 

While this works for my immediate needs, I find myself navigating to MAP-VALS over and over again, thinking this can probably be done in a more elegant way. Is there a way in Specter to group the four transformations (setval + 3 transforms) into a sub-select of some sort? Should I even care about this type of optimization?"><span class="u" id="1521203680.000172">2018:03:16 12:34:40         Marcus Pemer </span><span>Hi - my first question to this channel, hope you all are doing well. I am processing some CSV input - fairly large file with four types of records in them. All records are grouped with a header line and they are separated with blank (empty) lines. I have come up with the following attempt to use Specter for the transformation:

</span><pre>(let [data (-&gt;&gt;
            ;; my data comes in as text from a csv file
            (csv/parse-csv (slurp &quot;some-file-name.csv&quot;)
            ;; group by number of elements and remove group of empty rows
            (dissoc (group-by count csv) 1)
            ;; remove trailing empty cells within records
            (setval [MAP-VALS ALL LAST empty?] NONE)
            ;; prepare fields that will become map keys
            (transform [MAP-VALS FIRST ALL] keify)
            ;; turn the groups into maps
            (transform [MAP-VALS] sc/mappify)
            ;; lastly, read our data fields
            (transform [MAP-VALS ALL ALL] read-field)
            )]
  (def a-records (get data 6))
  (def b-records (get data 7))
  (def c-records (get data 11))
  (def d-records (get data 15)))
</pre><span>

While this works for my immediate needs, I find myself navigating to MAP-VALS over and over again, thinking this can probably be done in a more elegant way. Is there a way in Specter to group the four transformations (setval + 3 transforms) into a sub-select of some sort? Should I even care about this type of optimization?</span></div><div data-t="drowsy @marcus165 There is multi-transform with multi-path to group setval and transform together.  (multi-transform [MAP-VALS (multi-path [ALL LAST empty? (terminal-val NONE)]
                                       [FIRST ALL (terminal keify)]
                                       [(terminal sc/mappify)]
                                       [ALL ALL (terminal read-file)])])"><span class="u" id="1521204298.000060">2018:03:16 12:44:58               drowsy </span><span>@marcus165 There is multi-transform with multi-path to group setval and transform together. </span><pre>(multi-transform [MAP-VALS (multi-path [ALL LAST empty? (terminal-val NONE)]
                                       [FIRST ALL (terminal keify)]
                                       [(terminal sc/mappify)]
                                       [ALL ALL (terminal read-file)])])</pre></div><div data-t="Marcus Pemer awesome - thank you @drowsy!"><span class="u" id="1521204512.000168">2018:03:16 12:48:32         Marcus Pemer </span><span>awesome - thank you @drowsy!</span></div><div data-t="phreed I want to navigate through a data structure having at the top a hash-map. What is the best way to start off a  traverse-all  into such a structure?
  (into [] (sr/traverse-all [:foo sr/ALL :bar]) [{:foo [{:bar &quot;one&quot; :baz &quot;two&quot;} {:bar &quot;three&quot; :biz &quot;four&quot;} ] :bing 5}])
Enclosing the object in a vector seems to work. Is that the recommended way to handle this?"><span class="u" id="1521501687.000018">2018:03:19 23:21:27               phreed </span><span>I want to navigate through a data structure having at the top a hash-map. What is the best way to start off a </span><code>traverse-all</code><span> into such a structure?
  (into [] (sr/traverse-all [:foo sr/ALL :bar]) [{:foo [{:bar &quot;one&quot; :baz &quot;two&quot;} {:bar &quot;three&quot; :biz &quot;four&quot;} ] :bing 5}])
Enclosing the object in a vector seems to work. Is that the recommended way to handle this?</span></div><div data-t="nathanmarz @phreed  traverse-all  is for integrating specter with transducers, which is not what you want in this case"><span class="u" id="1521508039.000196">2018:03:20 01:07:19           nathanmarz </span><span>@phreed </span><code>traverse-all</code><span> is for integrating specter with transducers, which is not what you want in this case</span></div><div data-t="nathanmarz that can just be done with  select :  (select [:foo ALL :bar] {:foo [{:bar &quot;one&quot; :baz &quot;two&quot;} {:bar &quot;three&quot; :biz &quot;four&quot;} ] :bing 5})"><span class="u" id="1521508058.000334">2018:03:20 01:07:38           nathanmarz </span><span>that can just be done with </span><code>select</code><span>: </span><code>(select [:foo ALL :bar] {:foo [{:bar &quot;one&quot; :baz &quot;two&quot;} {:bar &quot;three&quot; :biz &quot;four&quot;} ] :bing 5})</code></div><div data-t="nathanmarz traverse  is useful when you want a non-vector data structure back without materializing any intermediate data structure, e.g.:
 (into #{} (traverse [:foo ALL :bar] {:foo [{:bar &quot;one&quot; :baz &quot;two&quot;} {:bar &quot;three&quot; :biz &quot;four&quot;} ] :bing 5}))
"><span class="u" id="1521508109.000079">2018:03:20 01:08:29           nathanmarz </span><code>traverse</code><span> is useful when you want a non-vector data structure back without materializing any intermediate data structure, e.g.:
</span><pre>(into #{} (traverse [:foo ALL :bar] {:foo [{:bar &quot;one&quot; :baz &quot;two&quot;} {:bar &quot;three&quot; :biz &quot;four&quot;} ] :bing 5}))
</pre></div><div data-t="phreed Actually I do want to integrate with other transducers, the example I gave is contrived. I guess the issue is what does it mean to take a step with a single record?"><span class="u" id="1521555393.000885">2018:03:20 14:16:33               phreed </span><span>Actually I do want to integrate with other transducers, the example I gave is contrived. I guess the issue is what does it mean to take a step with a single record?</span></div><div data-t="nathanmarz @phreed transducers operate over collections"><span class="u" id="1521556245.000362">2018:03:20 14:30:45           nathanmarz </span><span>@phreed transducers operate over collections</span></div><div data-t="nathanmarz if you show a more complete example of your use case would be easier to help"><span class="u" id="1521556324.000460">2018:03:20 14:32:04           nathanmarz </span><span>if you show a more complete example of your use case would be easier to help</span></div><div data-t="pablore how would i write a deep-merge-right with specter?"><span class="u" id="1521689916.000084">2018:03:22 03:38:36              pablore </span><span>how would i write a deep-merge-right with specter?</span></div><div data-t="nathanmarz @pablore that&apos;s outside the scope of specter"><span class="u" id="1521696156.000003">2018:03:22 05:22:36           nathanmarz </span><span>@pablore that&apos;s outside the scope of specter</span></div><div data-t="pablore Thats too bad. I have a very ugly solution and thought maybe with specter I could get a more readable one"><span class="u" id="1521738147.000179">2018:03:22 17:02:27                   pablore </span><span>Thats too bad. I have a very ugly solution and thought maybe with specter I could get a more readable one</span></div><div data-t="Peter Wilkins Hello - noob question. I&apos;m trying to use transform to reverse the values in a map:
 (transform [ALL :average]
   reverse
            [{:average 0.14479934967087002}
             {:average 0.7736362292522883}
             {:average 0.6189089834018306}
             {:average 0.6188565442780262}]) 
but I get Don&apos;t know how to create ISeq from: java.lang.Double"><span class="u" id="1521805186.000008">2018:03:23 11:39:46        Peter Wilkins </span><span>Hello - noob question. I&apos;m trying to use transform to reverse the values in a map:
</span><pre>(transform [ALL :average]
   reverse
            [{:average 0.14479934967087002}
             {:average 0.7736362292522883}
             {:average 0.6189089834018306}
             {:average 0.6188565442780262}])</pre><span>
but I get Don&apos;t know how to create ISeq from: java.lang.Double</span></div><div data-t="nathanmarz @poppetew that&apos; because you&apos;re navigating to the individual values, so  reverse  is being applied to each of them"><span class="u" id="1521807826.000339">2018:03:23 12:23:46           nathanmarz </span><span>@poppetew that&apos; because you&apos;re navigating to the individual values, so </span><code>reverse</code><span> is being applied to each of them</span></div><div data-t="nathanmarz the correct way to do that is:
 (transform (subselect ALL :average)
   reverse
   [{:average 0.14479934967087002}
    {:average 0.7736362292522883}
    {:average 0.6189089834018306}
    {:average 0.6188565442780262}])
"><span class="u" id="1521807832.000486">2018:03:23 12:23:52           nathanmarz </span><span>the correct way to do that is:
</span><pre>(transform (subselect ALL :average)
   reverse
   [{:average 0.14479934967087002}
    {:average 0.7736362292522883}
    {:average 0.6189089834018306}
    {:average 0.6188565442780262}])
</pre></div><div data-t="nathanmarz subselect  lets you manipulate an arbitrary selection as a sequence, with changes applied at the original locations"><span class="u" id="1521807847.000180">2018:03:23 12:24:07           nathanmarz </span><code>subselect</code><span> lets you manipulate an arbitrary selection as a sequence, with changes applied at the original locations</span></div><div data-t="Peter Wilkins magic - thanks"><span class="u" id="1521809068.000350">2018:03:23 12:44:28        Peter Wilkins </span><span>magic - thanks</span></div><div data-t="axrs Hi all  🙂  
Is it possible to transform a collection and update in-place? For a simplified example, say I have a vector of  [1 2 3 4 5 ...] . 
The first iteration happens on index 0 first (`value 1 in this case`)  and adds 10 to the value to give 11 and updates the collection  [11 2 3 4 5...] .
The second iteration happens on index 1 (value  2 ), but uses an updated collection, i.e.  [11 2 3 4 5 ...] ."><span class="u" id="1522239258.000092">2018:03:28 12:14:18                 axrs </span><span>Hi all </span><b>🙂</b><span> 
Is it possible to transform a collection and update in-place? For a simplified example, say I have a vector of </span><code>[1 2 3 4 5 ...]</code><span>. 
The first iteration happens on index 0 first (`value 1 in this case`)  and adds 10 to the value to give 11 and updates the collection </span><code>[11 2 3 4 5...]</code><span>.
The second iteration happens on index 1 (value </span><code>2</code><span>), but uses an updated collection, i.e. </span><code>[11 2 3 4 5 ...]</code><span>.</span></div><div data-t="axrs I suppose what I need is a transient transform"><span class="u" id="1522240461.000491">2018:03:28 12:34:21                 axrs </span><span>I suppose what I need is a transient transform</span></div><div data-t="nathanmarz @axrs not sure what you mean"><span class="u" id="1522257875.000414">2018:03:28 17:24:35           nathanmarz </span><span>@axrs not sure what you mean</span></div><div data-t="nathanmarz you want the entire collection passed to the update function?"><span class="u" id="1522257922.000002">2018:03:28 17:25:22           nathanmarz </span><span>you want the entire collection passed to the update function?</span></div><div data-t="axrs hmm. Not quite. using sp/VAL I can get the entire collection. I&apos;m updating a single key for each map in a vector. As the transformation moves through the maps, they use values from a previous map entry to perform a calculation and provide a result.

 (def col [{:a 1} {:a 5} {:a 9}]) 

My transformation for each map entry would be
1. Get the previous map value for :a
2. Multiply that by 2 and add 8
3. Add to the current map value for :a
4. persist back into collection"><span class="u" id="1522275129.000201">2018:03:28 22:12:09                 axrs </span><span>hmm. Not quite. using sp/VAL I can get the entire collection. I&apos;m updating a single key for each map in a vector. As the transformation moves through the maps, they use values from a previous map entry to perform a calculation and provide a result.

</span><code>(def col [{:a 1} {:a 5} {:a 9}])</code><span>

My transformation for each map entry would be
1. Get the previous map value for :a
2. Multiply that by 2 and add 8
3. Add to the current map value for :a
4. persist back into collection</span></div><div data-t="axrs As a rough approximation. The actual calculation for the new value is more involved, but it requires an updated  col  as the transformation moves through"><span class="u" id="1522275291.000016">2018:03:28 22:14:51                 axrs </span><span>As a rough approximation. The actual calculation for the new value is more involved, but it requires an updated </span><code>col</code><span> as the transformation moves through</span></div><div data-t="nathanmarz @axrs that&apos;s a perfect use case for zipper navigators"><span class="u" id="1522276193.000120">2018:03:28 22:29:53           nathanmarz </span><span>@axrs that&apos;s a perfect use case for zipper navigators</span></div><div data-t="nathanmarz (require &apos;[com.rpl.specter.zipper :as z])
(transform
  [z/VECTOR-ZIP
   z/DOWN
   z/NEXT
   z/NEXT-WALK
   (collect-one z/PREV z/NODE :a)
   z/NODE
   :a]
  (fn [v curr]
    (+ curr (* 2 v) 8))
  col)
"><span class="u" id="1522276196.000453">2018:03:28 22:29:56           nathanmarz </span><pre>(require &apos;[com.rpl.specter.zipper :as z])
(transform
  [z/VECTOR-ZIP
   z/DOWN
   z/NEXT
   z/NEXT-WALK
   (collect-one z/PREV z/NODE :a)
   z/NODE
   :a]
  (fn [v curr]
    (+ curr (* 2 v) 8))
  col)
</pre></div><div data-t="axrs Ooo. That&apos;s a lot to consume, but looks like it would do the job. Thanks @nathanmarz, I&apos;ll have a look into it"><span class="u" id="1522276451.000171">2018:03:28 22:34:11                 axrs </span><span>Ooo. That&apos;s a lot to consume, but looks like it would do the job. Thanks @nathanmarz, I&apos;ll have a look into it</span></div><div data-t="nathanmarz this will be helpful for you  https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers"><span class="u" id="1522276563.000134">2018:03:28 22:36:03           nathanmarz </span><span>this will be helpful for you </span><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers">https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers</a></div><div data-t="spieden trying to recursively remove map entries with nil values. here’s a start on the path:  (def nil-map-entries
  (spr/recursive-path [] p
    (spr/cond-path
      #(and (instance? MapEntry %)
            (nil? (val %)))
      spr/STAY

      #(coll? %)
      [spr/ALL p])))
  although i can select them with this, transforming doesn’t seem to match on them:  (spr/select [nil-map-entries] {:foo nil :bar :bam})
=&gt; [[:foo nil]]
(spr/transform [nil-map-entries] (constantly spr/NONE) {:foo nil :bar :bam})
=&gt; {:foo nil, :bar :bam}  never experienced this kind of incongruity"><span class="u" id="1522447413.000098">2018:03:30 22:03:33              spieden </span><span>trying to recursively remove map entries with nil values. here’s a start on the path: </span><pre>(def nil-map-entries
  (spr/recursive-path [] p
    (spr/cond-path
      #(and (instance? MapEntry %)
            (nil? (val %)))
      spr/STAY

      #(coll? %)
      [spr/ALL p])))
</pre><span> although i can select them with this, transforming doesn’t seem to match on them: </span><pre>(spr/select [nil-map-entries] {:foo nil :bar :bam})
=&gt; [[:foo nil]]
(spr/transform [nil-map-entries] (constantly spr/NONE) {:foo nil :bar :bam})
=&gt; {:foo nil, :bar :bam}</pre><span> never experienced this kind of incongruity</span></div><div data-t="nathanmarz @spieden specter navigates to vector for map entries on transform, not  MapEntry  object"><span class="u" id="1522448458.000082">2018:03:30 22:20:58           nathanmarz </span><span>@spieden specter navigates to vector for map entries on transform, not </span><code>MapEntry</code><span> object</span></div><div data-t="nathanmarz I suggest handling maps separately from other collections in your path, which will make navigation more explicit and remove the need to check the type"><span class="u" id="1522448522.000192">2018:03:30 22:22:02           nathanmarz </span><span>I suggest handling maps separately from other collections in your path, which will make navigation more explicit and remove the need to check the type</span></div><div data-t="spieden ahh"><span class="u" id="1522449682.000068">2018:03:30 22:41:22              spieden </span><span>ahh</span></div><div data-t="spieden ok thanks! @nathanmarz"><span class="u" id="1522449694.000048">2018:03:30 22:41:34              spieden </span><span>ok thanks! @nathanmarz</span></div><div data-t="spieden here’s what i wound up with, for posterity:  (def nil-map-entries
  (spr/recursive-path [] p
    (spr/cond-path
      map?
      [spr/ALL (spr/if-path #(nil? (second %))
                            spr/STAY
                            p)]

      #(coll? %)
      [spr/ALL p])))   (spr/transform [nil-map-entries] (constantly spr/NONE) {:foo {:baz nil} :bar :bam})
=&gt; {:foo {}, :bar :bam}"><span class="u" id="1522450155.000265">2018:03:30 22:49:15              spieden </span><span>here’s what i wound up with, for posterity: </span><pre>(def nil-map-entries
  (spr/recursive-path [] p
    (spr/cond-path
      map?
      [spr/ALL (spr/if-path #(nil? (second %))
                            spr/STAY
                            p)]

      #(coll? %)
      [spr/ALL p])))</pre><span> </span><pre>(spr/transform [nil-map-entries] (constantly spr/NONE) {:foo {:baz nil} :bar :bam})
=&gt; {:foo {}, :bar :bam}</pre></div><div data-t="nathanmarz @spieden this is a more flexible way to approach that:
 (def MAP-NODES
  (recursive-path [] p
    (cond-path
      map? (stay-then-continue MAP-VALS p)
      coll? [ALL p]
      )))

(setval [MAP-NODES MAP-VALS nil?] NONE {:foo {:baz nil} :bar :bam})
"><span class="u" id="1522470239.000077">2018:03:31 04:23:59           nathanmarz </span><span>@spieden this is a more flexible way to approach that:
</span><pre>(def MAP-NODES
  (recursive-path [] p
    (cond-path
      map? (stay-then-continue MAP-VALS p)
      coll? [ALL p]
      )))

(setval [MAP-NODES MAP-VALS nil?] NONE {:foo {:baz nil} :bar :bam})
</pre></div><div data-t="nathanmarz MAP-NODES  could then be used for other things besides nil filtering"><span class="u" id="1522470282.000039">2018:03:31 04:24:42           nathanmarz </span><code>MAP-NODES</code><span> could then be used for other things besides nil filtering</span></div><div data-t="spieden indeed! thanks"><span class="u" id="1522470550.000007">2018:03:31 04:29:10              spieden </span><span>indeed! thanks</span></div><div data-t="Marcus Pemer I came across an interesting cunundrum this weekend and my initial attempts to find answers in the documentation has come up short. Hopefully someone on this channel will have a better grasp on things than I do.

Suppose I had a three-layer data structure of maps. I would like to run a transformation on the leaves, similar to this:
 (transform [MAP-VALS MAP-VALS :b] str/capitalize
           {:top-key-a
            {:middle-key-aa {:a &quot;a&quot; :b &quot;b&quot; :c &quot;c&quot;}
             :middle-key-ab {:a &quot;a&quot; :b &quot;b&quot; :c &quot;c&quot;}}
            :top-key-b
            {:middle-key-ba {:a &quot;x&quot; :b &quot;y&quot; :c &quot;z&quot;}
             :middle-key-bb {:a &quot;u&quot; :b &quot;v&quot; :c &quot;w&quot;}}})
 
Which yields:
 {:top-key-a
 {:middle-key-aa {:a &quot;a&quot;, :b &quot;B&quot;, :c &quot;c&quot;},
  :middle-key-ab {:a &quot;a&quot;, :b &quot;B&quot;, :c &quot;c&quot;}},
 :top-key-b
 {:middle-key-ba {:a &quot;z&quot;, :b &quot;Y&quot;, :c &quot;z&quot;},
  :middle-key-bb {:a &quot;u&quot;, :b &quot;V&quot;, :c &quot;w&quot;}}}
 

Now, suppose I want to run a slightly more complex transformation on the leaves. Instead of running  str/capitalize , which only takes the element itself as input, I would like to run my own custom function that takes the element to be transformed along with the ancestor keys following the path to the element. In this case I would like my transformation function to take  :top-key-n  and  :middle-key-xy . The actual invocations of my transform function would then look something like this:
 (my-xform :top-key-a :middle-key-aa :b &quot;b&quot;)
(my-xform :top-key-a :middle-key-ab :b &quot;b&quot;)
(my-xform :top-key-b :middle-key-ba :b &quot;y&quot;)
(my-xform :top-key-b :middle-key-bb :b &quot;v&quot;)
 
Is there an idiomatic way to achieve this in Specter? Any advice appreciated."><span class="u" id="1522749466.000370">2018:04:03 09:57:46         Marcus Pemer </span><span>I came across an interesting cunundrum this weekend and my initial attempts to find answers in the documentation has come up short. Hopefully someone on this channel will have a better grasp on things than I do.

Suppose I had a three-layer data structure of maps. I would like to run a transformation on the leaves, similar to this:
</span><pre>(transform [MAP-VALS MAP-VALS :b] str/capitalize
           {:top-key-a
            {:middle-key-aa {:a &quot;a&quot; :b &quot;b&quot; :c &quot;c&quot;}
             :middle-key-ab {:a &quot;a&quot; :b &quot;b&quot; :c &quot;c&quot;}}
            :top-key-b
            {:middle-key-ba {:a &quot;x&quot; :b &quot;y&quot; :c &quot;z&quot;}
             :middle-key-bb {:a &quot;u&quot; :b &quot;v&quot; :c &quot;w&quot;}}})
</pre><span>
Which yields:
</span><pre>{:top-key-a
 {:middle-key-aa {:a &quot;a&quot;, :b &quot;B&quot;, :c &quot;c&quot;},
  :middle-key-ab {:a &quot;a&quot;, :b &quot;B&quot;, :c &quot;c&quot;}},
 :top-key-b
 {:middle-key-ba {:a &quot;z&quot;, :b &quot;Y&quot;, :c &quot;z&quot;},
  :middle-key-bb {:a &quot;u&quot;, :b &quot;V&quot;, :c &quot;w&quot;}}}
</pre><span>

Now, suppose I want to run a slightly more complex transformation on the leaves. Instead of running </span><code>str/capitalize</code><span>, which only takes the element itself as input, I would like to run my own custom function that takes the element to be transformed along with the ancestor keys following the path to the element. In this case I would like my transformation function to take </span><code>:top-key-n</code><span> and </span><code>:middle-key-xy</code><span>. The actual invocations of my transform function would then look something like this:
</span><pre>(my-xform :top-key-a :middle-key-aa :b &quot;b&quot;)
(my-xform :top-key-a :middle-key-ab :b &quot;b&quot;)
(my-xform :top-key-b :middle-key-ba :b &quot;y&quot;)
(my-xform :top-key-b :middle-key-bb :b &quot;v&quot;)
</pre><span>
Is there an idiomatic way to achieve this in Specter? Any advice appreciated.</span></div><div data-t="drowsy @marcus165 not sure if it&apos;s the most idiomatic way, but you can use  collect  /  collect-one  to collect the keys on the way."><span class="u" id="1522757667.000256">2018:04:03 12:14:27               drowsy </span><span>@marcus165 not sure if it&apos;s the most idiomatic way, but you can use </span><code>collect</code><span> / </span><code>collect-one</code><span> to collect the keys on the way.</span></div><div data-t="drowsy You can even use a recursive path here to climb down arbitrary nested maps"><span class="u" id="1522757695.000125">2018:04:03 12:14:55               drowsy </span><span>You can even use a recursive path here to climb down arbitrary nested maps</span></div><div data-t="drowsy (def MAP-KV-NODES
  (recursive-path [] p
     (cond-path
       map? [ALL (collect-one FIRST) LAST p]
       :else STAY)))
(transform [MAP-KV-NODES] myx-form data)"><span class="u" id="1522757738.000499">2018:04:03 12:15:38               drowsy </span><pre>(def MAP-KV-NODES
  (recursive-path [] p
     (cond-path
       map? [ALL (collect-one FIRST) LAST p]
       :else STAY)))
(transform [MAP-KV-NODES] myx-form data)</pre></div><div data-t="drowsy slightly tricky part is, that you need to navigate to the key/value pairs of a map using  ALL , collect the key with  FIRST  and navigate to its val with  LAST"><span class="u" id="1522757848.000305">2018:04:03 12:17:28               drowsy </span><span>slightly tricky part is, that you need to navigate to the key/value pairs of a map using </span><code>ALL</code><span>, collect the key with </span><code>FIRST</code><span> and navigate to its val with </span><code>LAST</code></div><div data-t="nathanmarz @marcus165 @drowsy yes, value collection is the idiomatic way to do that"><span class="u" id="1522760322.000644">2018:04:03 12:58:42           nathanmarz </span><span>@marcus165 @drowsy yes, value collection is the idiomatic way to do that</span></div><div data-t="nathanmarz can easily make a wrapper around  [ALL (collect-one FIRST) LAST]  so you can do  (transform [MY-MAP-VALS MY-MAP-VALS MAP-VALS] (fn [top middle v] ...) data)"><span class="u" id="1522760485.000386">2018:04:03 13:01:25           nathanmarz </span><span>can easily make a wrapper around </span><code>[ALL (collect-one FIRST) LAST]</code><span> so you can do </span><code>(transform [MY-MAP-VALS MY-MAP-VALS MAP-VALS] (fn [top middle v] ...) data)</code></div><div data-t="Marcus Pemer Thank you @drowsy and @nathanmarz - that helped; I am now both enlightened and unblocked."><span class="u" id="1522761141.000007">2018:04:03 13:12:21         Marcus Pemer </span><span>Thank you @drowsy and @nathanmarz - that helped; I am now both enlightened and unblocked.</span></div><div data-t="nathanmarz @marcus784 take a look at &quot;Value Collection&quot; under  https://github.com/nathanmarz/specter/wiki/Cheat-Sheet  to see all the things you can do with collected values"><span class="u" id="1522761871.000345">2018:04:03 13:24:31           nathanmarz </span><span>@marcus784 take a look at &quot;Value Collection&quot; under </span><a href="https://github.com/nathanmarz/specter/wiki/Cheat-Sheet">https://github.com/nathanmarz/specter/wiki/Cheat-Sheet</a><span> to see all the things you can do with collected values</span></div><div data-t="Marcus Pemer Thank you @nathanmarz - after looking at the main readme.md I found a section that clearly documents this as well - this paragraph says it all:

&gt; When doing more involved transformations, you often find you lose context when navigating deep within a data structure and need information &quot;up&quot; the data structure to perform the transformation. Specter solves this problem by allowing you to collect values during navigation to use in the transform function.

In retrospect I don&apos;t know how I missed it. Thanks again."><span class="u" id="1522828972.000279">2018:04:04 08:02:52         Marcus Pemer </span><span>Thank you @nathanmarz - after looking at the main readme.md I found a section that clearly documents this as well - this paragraph says it all:

&gt; When doing more involved transformations, you often find you lose context when navigating deep within a data structure and need information &quot;up&quot; the data structure to perform the transformation. Specter solves this problem by allowing you to collect values during navigation to use in the transform function.

In retrospect I don&apos;t know how I missed it. Thanks again.</span></div><div data-t="levitanong @nathanmarz is there any plan to publish 1.1.1-SNAPSHOT in clojars?"><span class="u" id="1522868895.000146">2018:04:04 19:08:15           levitanong </span><span>@nathanmarz is there any plan to publish 1.1.1-SNAPSHOT in clojars?</span></div><div data-t="nathanmarz @levitanong just published it"><span class="u" id="1522869930.000168">2018:04:04 19:25:30           nathanmarz </span><span>@levitanong just published it</span></div><div data-t="levitanong Thanks @nathanmarz !"><span class="u" id="1522869993.000393">2018:04:04 19:26:33           levitanong </span><span>Thanks @nathanmarz !</span></div><div data-t="justinlee I’m having an issue in my reagent project where I’m getting atom updates unexpectedly.  I tried to debug this issue by creating an Error object in my add-watch and printing out the stack trace, but the stack bottoms out at this line:  com.rpl.specter.impl.combine_two_navs.com.rpl.specter.impl.t_com$rpl$specter$$rpl$specter$protocols$RichNavigator$transform_STAR_$arity$4 ()   Any idea why I’m losing stack context beyond this line?  I’d really like to figure out where in my code I’m calling specter that is doing this, but it is hard.  I wasn’t expecting specter to be async."><span class="u" id="1522880604.000205">2018:04:04 22:23:24            justinlee </span><span>I’m having an issue in my reagent project where I’m getting atom updates unexpectedly.  I tried to debug this issue by creating an Error object in my add-watch and printing out the stack trace, but the stack bottoms out at this line: </span><pre>com.rpl.specter.impl.combine_two_navs.com.rpl.specter.impl.t_com$rpl$specter$$rpl$specter$protocols$RichNavigator$transform_STAR_$arity$4 ()</pre><span>  Any idea why I’m losing stack context beyond this line?  I’d really like to figure out where in my code I’m calling specter that is doing this, but it is hard.  I wasn’t expecting specter to be async.</span></div><div data-t="nathanmarz @lee.justin.m there&apos;s nothing async or lazy about specter"><span class="u" id="1522881250.000436">2018:04:04 22:34:10           nathanmarz </span><span>@lee.justin.m there&apos;s nothing async or lazy about specter</span></div><div data-t="nathanmarz whenever i have an error with an unexpected stack trace I look to see if I&apos;m inadvertently using laziness somewhere"><span class="u" id="1522881291.000379">2018:04:04 22:34:51           nathanmarz </span><span>whenever i have an error with an unexpected stack trace I look to see if I&apos;m inadvertently using laziness somewhere</span></div><div data-t="nathanmarz e.g. if you&apos;re doing  (map #(transform ...) aseq)  and not realizing the result until later on"><span class="u" id="1522881327.000076">2018:04:04 22:35:27           nathanmarz </span><span>e.g. if you&apos;re doing </span><code>(map #(transform ...) aseq)</code><span> and not realizing the result until later on</span></div><div data-t="justinlee thanks @nathanmarz.  i’m probably misunderstanding something about laziness, but wouldn’t i see the lazy function at the bottom of the stack instead of seeing specter at the bottom?  that’s the part that is confusing me."><span class="u" id="1522881553.000003">2018:04:04 22:39:13            justinlee </span><span>thanks @nathanmarz.  i’m probably misunderstanding something about laziness, but wouldn’t i see the lazy function at the bottom of the stack instead of seeing specter at the bottom?  that’s the part that is confusing me.</span></div><div data-t="justinlee hm, now that i’m saying this out loud, maybe its because i’m in a go block?  that can shear stack traces."><span class="u" id="1522881579.000175">2018:04:04 22:39:39            justinlee </span><span>hm, now that i’m saying this out loud, maybe its because i’m in a go block?  that can shear stack traces.</span></div><div data-t="nathanmarz not sure, I don&apos;t use core.async"><span class="u" id="1522882033.000267">2018:04:04 22:47:13           nathanmarz </span><span>not sure, I don&apos;t use core.async</span></div><div data-t="justinlee ah yea that was it.  the one piece of async code that doesn’t log. too bad my little stacktrace trick doesn’t work across async boundaries.  sorry for the noise."><span class="u" id="1522882704.000076">2018:04:04 22:58:24            justinlee </span><span>ah yea that was it.  the one piece of async code that doesn’t log. too bad my little stacktrace trick doesn’t work across async boundaries.  sorry for the noise.</span></div><div data-t="frenata Having a weird issue where specter is failing only inside a cljs cider repl connection. Fine everywhere else: in the browser, in clj cider connections, and in a figwheel repl. Entirely possible this isn&apos;t especially specter related but I&apos;m stumped."><span class="u" id="1522946416.000289">2018:04:05 16:40:16              frenata </span><span>Having a weird issue where specter is failing only inside a cljs cider repl connection. Fine everywhere else: in the browser, in clj cider connections, and in a figwheel repl. Entirely possible this isn&apos;t especially specter related but I&apos;m stumped.</span></div><div data-t="justinlee are there any tricks to bringing the size of specter down?  it adds 178k before gzipping, which is a bit painful"><span class="u" id="1523043663.000349">2018:04:06 19:41:03            justinlee </span><span>are there any tricks to bringing the size of specter down?  it adds 178k before gzipping, which is a bit painful</span></div><div data-t="nathanmarz @lee.justin.m the navigators are completely independent from each other, so you could fork the project and remove any navigators you don&apos;t use"><span class="u" id="1523044529.000354">2018:04:06 19:55:29           nathanmarz </span><span>@lee.justin.m the navigators are completely independent from each other, so you could fork the project and remove any navigators you don&apos;t use</span></div><div data-t="justinlee @nathanmarz ah cool that’s good to know down the line.  i’ll still use it even it if is 178k  🙂"><span class="u" id="1523044575.000557">2018:04:06 19:56:15            justinlee </span><span>@nathanmarz ah cool that’s good to know down the line.  i’ll still use it even it if is 178k </span><b>🙂</b></div><div data-t="nathanmarz I don&apos;t really use cljs, but I was under the impression it did that kind of dead code elimination automatically"><span class="u" id="1523044606.000263">2018:04:06 19:56:46           nathanmarz </span><span>I don&apos;t really use cljs, but I was under the impression it did that kind of dead code elimination automatically</span></div><div data-t="justinlee DCE is a black art.  hard to say what it is doing"><span class="u" id="1523044639.000469">2018:04:06 19:57:19            justinlee </span><span>DCE is a black art.  hard to say what it is doing</span></div><div data-t="justinlee maybe it already is doing dce"><span class="u" id="1523044656.000217">2018:04:06 19:57:36            justinlee </span><span>maybe it already is doing dce</span></div><div data-t="zlrth I have a datastructure that&apos;s a combination of maps and vectors, with various amounts of nesting:
 [{:user &quot;matt&quot;
  :docs [{:fulltext &quot;the text&quot;
          :url &quot;&quot;
          :fragments []}
         ;; more docs
         ]}
 ;; more maps
 ] 

I want to update the data structure like so

 [{:user &quot;matt&quot;
  :docs [{:fulltext &quot;the text&quot;
          :url &quot;&quot;
          :fragments [{:date &quot;2018&quot; :text &quot;the &quot;}
                      {:date &quot;2017&quot; :text &quot;text&quot;}]}
         ;; more docs
         ]}
 ;; more maps
 ] 

I want to do: &quot;select the map with the key-value pair  :user  and  &quot;matt&quot; , then in the  :doc  vector, select the map with the kv pair  :fulltext  and  &quot;the text&quot;  and conj these two maps&quot;"><span class="u" id="1523065297.000119">2018:04:07 01:41:37                zlrth </span><span>I have a datastructure that&apos;s a combination of maps and vectors, with various amounts of nesting:
</span><pre>[{:user &quot;matt&quot;
  :docs [{:fulltext &quot;the text&quot;
          :url &quot;&quot;
          :fragments []}
         ;; more docs
         ]}
 ;; more maps
 ]</pre><span>

I want to update the data structure like so

</span><pre>[{:user &quot;matt&quot;
  :docs [{:fulltext &quot;the text&quot;
          :url &quot;&quot;
          :fragments [{:date &quot;2018&quot; :text &quot;the &quot;}
                      {:date &quot;2017&quot; :text &quot;text&quot;}]}
         ;; more docs
         ]}
 ;; more maps
 ]</pre><span>

I want to do: &quot;select the map with the key-value pair </span><code>:user</code><span> and </span><code>&quot;matt&quot;</code><span>, then in the </span><code>:doc</code><span> vector, select the map with the kv pair </span><code>:fulltext</code><span> and </span><code>&quot;the text&quot;</code><span> and conj these two maps&quot;</span></div><div data-t="zlrth I skimmed the Navigators docs, and couldn&apos;t find &quot;select the map containing the kv-pair.&quot; I suspect that I&apos;m trying to do something not idiomatic. In theory, I could make this data structure entirely out of nested maps--then this would be trivial--but i don&apos;t know if i can guarantee that a map will have a unique key."><span class="u" id="1523065946.000039">2018:04:07 01:52:26                zlrth </span><span>I skimmed the Navigators docs, and couldn&apos;t find &quot;select the map containing the kv-pair.&quot; I suspect that I&apos;m trying to do something not idiomatic. In theory, I could make this data structure entirely out of nested maps--then this would be trivial--but i don&apos;t know if i can guarantee that a map will have a unique key.</span></div><div data-t="nathanmarz @mfm looks like this:
 (defn map-with-kv [k v]
  (path ALL #(= v (get % k))))

(setval
  [(map-with-kv :user &quot;matt&quot;)
   :docs
   (map-with-kv :fulltext &quot;the text&quot;)
   :fragments
   END
   ]
  [{:date &quot;2018&quot; :text &quot;the &quot;}
   {:date &quot;2017&quot; :text &quot;text&quot;}]
  data)
"><span class="u" id="1523074193.000068">2018:04:07 04:09:53           nathanmarz </span><span>@mfm looks like this:
</span><pre>(defn map-with-kv [k v]
  (path ALL #(= v (get % k))))

(setval
  [(map-with-kv :user &quot;matt&quot;)
   :docs
   (map-with-kv :fulltext &quot;the text&quot;)
   :fragments
   END
   ]
  [{:date &quot;2018&quot; :text &quot;the &quot;}
   {:date &quot;2017&quot; :text &quot;text&quot;}]
  data)
</pre></div><div data-t="zlrth ah, thank you @nathanmarz!"><span class="u" id="1523103436.000028">2018:04:07 12:17:16                zlrth </span><span>ah, thank you @nathanmarz!</span></div><div data-t="steveh2018 Nathan, new to clojure, needed  get-in but will now pursue specter. Can it navigate through ref boundaries in deeply nested combos of maps and vectors?"><span class="u" id="1523839544.000138">2018:04:16 00:45:44           steveh2018 </span><span>Nathan, new to clojure, needed  get-in but will now pursue specter. Can it navigate through ref boundaries in deeply nested combos of maps and vectors?</span></div><div data-t="nathanmarz @steveh2009 yes, no problem"><span class="u" id="1523841512.000162">2018:04:16 01:18:32           nathanmarz </span><span>@steveh2009 yes, no problem</span></div><div data-t="nathanmarz for navigating into refs you&apos;d need to make your own navigator, but that is very easy – just use  ATOM  as an example:  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1081"><span class="u" id="1523841554.000045">2018:04:16 01:19:14           nathanmarz </span><span>for navigating into refs you&apos;d need to make your own navigator, but that is very easy – just use </span><code>ATOM</code><span> as an example: </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1081">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1081</a></div><div data-t="steveh2018 Fantastic. Off to YouTube to see your talks."><span class="u" id="1523841811.000042">2018:04:16 01:23:31           steveh2018 </span><span>Fantastic. Off to YouTube to see your talks.</span></div><div data-t="tanzoniteblack Is there a way I can implement take-while via specter? Specifically, I (eventually down a path) have a sequence of items, and I want to take every item up to (and including) a certain value.

Example:
 [{:id :a} {:id :b} {:id :c} {:id :d}]
;; up to (&amp; including) index: :c
;; ==&gt; [{:id :a} {:id :b} {:id :c}]
 

current implementation using  split-with :

 (let [[steps-before steps-after] (split-with #(not= (:id %) :c) [{:id :a} {:id :b} {:id :c} {:id :d}])]
     (concat steps-before (take 1 steps-after)))
"><span class="u" id="1523911227.000124">2018:04:16 20:40:27       tanzoniteblack </span><span>Is there a way I can implement take-while via specter? Specifically, I (eventually down a path) have a sequence of items, and I want to take every item up to (and including) a certain value.

Example:
</span><pre>[{:id :a} {:id :b} {:id :c} {:id :d}]
;; up to (&amp; including) index: :c
;; ==&gt; [{:id :a} {:id :b} {:id :c}]
</pre><span>

current implementation using </span><code>split-with</code><span>:

</span><pre>(let [[steps-before steps-after] (split-with #(not= (:id %) :c) [{:id :a} {:id :b} {:id :c} {:id :d}])]
     (concat steps-before (take 1 steps-after)))
</pre></div><div data-t="nathanmarz @tanzoniteblack you could do it with  srange-dynamic"><span class="u" id="1523911512.000148">2018:04:16 20:45:12           nathanmarz </span><span>@tanzoniteblack you could do it with </span><code>srange-dynamic</code></div><div data-t="tanzoniteblack thanks"><span class="u" id="1523911542.000277">2018:04:16 20:45:42       tanzoniteblack </span><span>thanks</span></div><div data-t="nathanmarz @tanzoniteblack with  https://github.com/nathanmarz/specter/issues/236  it could be done more efficiently/directly"><span class="u" id="1523911943.000595">2018:04:16 20:52:23           nathanmarz </span><span>@tanzoniteblack with </span><a href="https://github.com/nathanmarz/specter/issues/236">https://github.com/nathanmarz/specter/issues/236</a><span> it could be done more efficiently/directly</span></div><div data-t="spieden is there a way to splice a sequence into another starting at a specific index with specter? e.g.  (spr/setval [(spr/before-index 1)] [:a :b] [:x :y])
=&gt; [:x [:a :b] :y]
; want: [:x :a :b :y]"><span class="u" id="1524084808.000556">2018:04:18 20:53:28              spieden </span><span>is there a way to splice a sequence into another starting at a specific index with specter? e.g. </span><pre>(spr/setval [(spr/before-index 1)] [:a :b] [:x :y])
=&gt; [:x [:a :b] :y]
; want: [:x :a :b :y]</pre></div><div data-t="drowsy @spieden you can use  srange  to navigate to a subcollection."><span class="u" id="1524085473.000368">2018:04:18 21:04:33               drowsy </span><span>@spieden you can use </span><code>srange</code><span> to navigate to a subcollection.</span></div><div data-t="drowsy (setval [(srange 1 1)] [:a :b] [:x :y]) =&gt; [:x :a :b :y]"><span class="u" id="1524085478.000277">2018:04:18 21:04:38               drowsy </span><pre>(setval [(srange 1 1)] [:a :b] [:x :y]) =&gt; [:x :a :b :y]</pre></div><div data-t="spieden cool thanks! @drowsy"><span class="u" id="1524085496.000413">2018:04:18 21:04:56              spieden </span><span>cool thanks! @drowsy</span></div><div data-t="drowsy in this case you are navigating to an empty subcollection in the middle and replacing it with something nonempty"><span class="u" id="1524085539.000361">2018:04:18 21:05:39               drowsy </span><span>in this case you are navigating to an empty subcollection in the middle and replacing it with something nonempty</span></div><div data-t="spieden yes i had that idea in my head from using sets at some point but didn’t know to look for"><span class="u" id="1524085794.000233">2018:04:18 21:09:54              spieden </span><span>yes i had that idea in my head from using sets at some point but didn’t know to look for</span></div><div data-t="spieden s/to/what to/"><span class="u" id="1524085808.000400">2018:04:18 21:10:08              spieden </span><span>s/to/what to/</span></div><div data-t="levitanong @nathanmarz  https://github.com/nathanmarz/specter/blob/0ceda2115120cbe99ac9b600fce8d94e4575d236/src/clj/com/rpl/specter/impl.cljc#L910 
It seems that this line can’t get deadcode eliminated, so any project that includes specter will always be including  cljs.pprint  in advanced optimization. Any chance this can be handled differently?"><span class="u" id="1524209460.000501">2018:04:20 07:31:00           levitanong </span><span>@nathanmarz </span><a href="https://github.com/nathanmarz/specter/blob/0ceda2115120cbe99ac9b600fce8d94e4575d236/src/clj/com/rpl/specter/impl.cljc#L910">https://github.com/nathanmarz/specter/blob/0ceda2115120cbe99ac9b600fce8d94e4575d236/src/clj/com/rpl/specter/impl.cljc#L910</a><span>
It seems that this line can’t get deadcode eliminated, so any project that includes specter will always be including </span><code>cljs.pprint</code><span> in advanced optimization. Any chance this can be handled differently?</span></div><div data-t="nathanmarz @levitanong I&apos;ll have to think about that one"><span class="u" id="1524240180.000299">2018:04:20 16:03:00           nathanmarz </span><span>@levitanong I&apos;ll have to think about that one</span></div><div data-t="nathanmarz can you open an issue for it?"><span class="u" id="1524240184.000188">2018:04:20 16:03:04           nathanmarz </span><span>can you open an issue for it?</span></div><div data-t="levitanong @nathanmarz Will do!"><span class="u" id="1524240959.000489">2018:04:20 16:15:59           levitanong </span><span>@nathanmarz Will do!</span></div><div data-t="levitanong @nathanmarz done  https://github.com/nathanmarz/specter/issues/254"><span class="u" id="1524241144.000074">2018:04:20 16:19:04           levitanong </span><span>@nathanmarz done </span><a href="https://github.com/nathanmarz/specter/issues/254">https://github.com/nathanmarz/specter/issues/254</a></div><div data-t="nathanmarz Released Specter 1.1.1  https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><span class="u" id="1524497486.000212">2018:04:23 15:31:26           nathanmarz </span><span>Released Specter 1.1.1 </span><a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></div><div data-t="souenzzo There is something like  (if-not-path test-path get-path)"><span class="u" id="1524673532.000426">2018:04:25 16:25:32             souenzzo </span><span>There is something like </span><code>(if-not-path test-path get-path)</code></div><div data-t="nathanmarz @souenzzo 
 (defdynamicnav if-not-path [cond-path path]
  (if-path cond-path STOP path))
"><span class="u" id="1524673816.000469">2018:04:25 16:30:16           nathanmarz </span><span>@souenzzo 
</span><pre>(defdynamicnav if-not-path [cond-path path]
  (if-path cond-path STOP path))
</pre></div><div data-t="soulflyer I&apos;m trying to use  specter/zipper  to create a custom zipper. I have the  clojure.zip/zipper  working ok, but when I attempt to wrap it using specter/zipper I get this error:
 anh-front.tree&gt; (def tz (specter-tree-zip test-tree))
#object[TypeError TypeError: anh_front.tree.specter_tree_zip.call is not a function]
nil 
Heres the code, I have  clojure.zip  required as  zip  and  specter.zip  required as  sz 
 (defn tree-zip
  &quot;Returns a zipper for tree elements given a root element&quot;
  [root]
  (zip/zipper (complement string?)
              (fn [node] (if (:expanded node)
                           (seq (:children node))))
              (fn [node children]
                (assoc node :children (and children (apply vector children))))
              root))

(def specter-tree-zip (sz/zipper tree-zip)) 
Any idea what I have done wrong?"><span class="u" id="1525399370.000033">2018:05:04 02:02:50            soulflyer </span><span>I&apos;m trying to use </span><code>specter/zipper</code><span> to create a custom zipper. I have the </span><code>clojure.zip/zipper</code><span> working ok, but when I attempt to wrap it using specter/zipper I get this error:
</span><pre>anh-front.tree&gt; (def tz (specter-tree-zip test-tree))
#object[TypeError TypeError: anh_front.tree.specter_tree_zip.call is not a function]
nil</pre><span>
Heres the code, I have </span><code>clojure.zip</code><span> required as </span><code>zip</code><span> and </span><code>specter.zip</code><span> required as </span><code>sz</code><span>
</span><pre>(defn tree-zip
  &quot;Returns a zipper for tree elements given a root element&quot;
  [root]
  (zip/zipper (complement string?)
              (fn [node] (if (:expanded node)
                           (seq (:children node))))
              (fn [node children]
                (assoc node :children (and children (apply vector children))))
              root))

(def specter-tree-zip (sz/zipper tree-zip))</pre><span>
Any idea what I have done wrong?</span></div><div data-t="nathanmarz @soulflyer  sz/zipper  returns a navigator, not a function"><span class="u" id="1525400165.000023">2018:05:04 02:16:05           nathanmarz </span><span>@soulflyer </span><code>sz/zipper</code><span> returns a navigator, not a function</span></div><div data-t="nathanmarz you use it in a path to navigate to the zipper object"><span class="u" id="1525400175.000156">2018:05:04 02:16:15           nathanmarz </span><span>you use it in a path to navigate to the zipper object</span></div><div data-t="nathanmarz e.g.  (transform [specter-tree-zip sz/DOWN ..."><span class="u" id="1525400197.000088">2018:05:04 02:16:37           nathanmarz </span><span>e.g. </span><code>(transform [specter-tree-zip sz/DOWN ...</code></div><div data-t="soulflyer ah, that makes sense. I wrongly assumed I could just drop it in where I had used  clojure.zip/zipper  Thanks!"><span class="u" id="1525400545.000084">2018:05:04 02:22:25            soulflyer </span><span>ah, that makes sense. I wrongly assumed I could just drop it in where I had used </span><code>clojure.zip/zipper</code><span> Thanks!</span></div><div data-t="chromalchemy I am trying to do this:
 (select (srange 0 3) (select [ALL (selected? pred)] collection)) 
Is there a way to pop back up to a view of the collection before selecting each node through ALL, idiomatically in one path, instead of using two functions and nesting one? I&apos;m assuming there would be a transducer-like performance benefit to this, am I right?

Alternatively, can  srange  be used after  ALL  to still filter the root nodes in the collection?"><span class="u" id="1525479892.000093">2018:05:05 00:24:52         chromalchemy </span><span>I am trying to do this:
</span><pre>(select (srange 0 3) (select [ALL (selected? pred)] collection))</pre><span>
Is there a way to pop back up to a view of the collection before selecting each node through ALL, idiomatically in one path, instead of using two functions and nesting one? I&apos;m assuming there would be a transducer-like performance benefit to this, am I right?

Alternatively, can </span><code>srange</code><span> be used after </span><code>ALL</code><span> to still filter the root nodes in the collection?</span></div><div data-t="chromalchemy Also, is there a way to do side effects in the middle of a compound path like  [path1 (side-effect-fn) path2]  Or would it better to collect the necessary value for the side effect, then use a transform fn:  (transform [path1 collect path2] #(do (side-effect-fn %1) (main-fn %2)) collection)"><span class="u" id="1525480204.000106">2018:05:05 00:30:04         chromalchemy </span><span>Also, is there a way to do side effects in the middle of a compound path like </span><code>[path1 (side-effect-fn) path2]</code><span> Or would it better to collect the necessary value for the side effect, then use a transform fn: </span><pre>(transform [path1 collect path2] #(do (side-effect-fn %1) (main-fn %2)) collection)</pre></div><div data-t="nathanmarz @chromalchemy that first path is best written as  (select-any [(filterer pred) (srange 0 3)] collection)"><span class="u" id="1525482706.000034">2018:05:05 01:11:46           nathanmarz </span><span>@chromalchemy that first path is best written as </span><code>(select-any [(filterer pred) (srange 0 3)] collection)</code></div><div data-t="nathanmarz the definition of  filterer  is instructive:  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1137"><span class="u" id="1525482734.000121">2018:05:05 01:12:14           nathanmarz </span><span>the definition of </span><code>filterer</code><span> is instructive: </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1137">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1137</a></div><div data-t="nathanmarz you could do side effects in a path with something like:
 (defn side-effect [f]
  (view (fn [v] (f v) v)))
"><span class="u" id="1525482850.000099">2018:05:05 01:14:10           nathanmarz </span><span>you could do side effects in a path with something like:
</span><pre>(defn side-effect [f]
  (view (fn [v] (f v) v)))
</pre></div><div data-t="nathanmarz seems weird to me though to do something like that"><span class="u" id="1525482860.000141">2018:05:05 01:14:20           nathanmarz </span><span>seems weird to me though to do something like that</span></div><div data-t="chromalchemy @nathanmarz Thank you. I will get to know  subselect  and  select-any ."><span class="u" id="1525486659.000096">2018:05:05 02:17:39         chromalchemy </span><span>@nathanmarz Thank you. I will get to know </span><code>subselect</code><span> and </span><code>select-any</code><span>.</span></div><div data-t="jfntn Can specter do a recursive map traversal, collecting every value and its path?"><span class="u" id="1525650235.000052">2018:05:06 23:43:55                jfntn </span><span>Can specter do a recursive map traversal, collecting every value and its path?</span></div><div data-t="nathanmarz @jfntn yes there&apos;s an example of that on  https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure"><span class="u" id="1525658904.000024">2018:05:07 02:08:24           nathanmarz </span><span>@jfntn yes there&apos;s an example of that on </span><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure</a></div><div data-t="jfntn Thank you, I should have seen that! Handed up rolling my own it will be interesting to compare perf here"><span class="u" id="1525663132.000141">2018:05:07 03:18:52                     jfntn </span><span>Thank you, I should have seen that! Handed up rolling my own it will be interesting to compare perf here</span></div><div data-t="jjttjj I have a vector of maps:  [{:a 1} {:b 2 :d 4} {:c 3} {:d 4}]  and I want to find the map where :c = 3 and insert another map {:x 100} before it, resulting in  [{:a 1} {:b 2 :d 4} {:x 100} {:c 3} {:d 4}]  What&apos;s the best way to accomplish this in specter?"><span class="u" id="1525794321.000155">2018:05:08 15:45:21               jjttjj </span><span>I have a vector of maps: </span><pre>[{:a 1} {:b 2 :d 4} {:c 3} {:d 4}]</pre><span> and I want to find the map where :c = 3 and insert another map {:x 100} before it, resulting in </span><pre>[{:a 1} {:b 2 :d 4} {:x 100} {:c 3} {:d 4}]</pre><span> What&apos;s the best way to accomplish this in specter?</span></div><div data-t="jjttjj (I don&apos;t know the index I need to insert at, just the keys in the map I need to insert before )"><span class="u" id="1525794403.000239">2018:05:08 15:46:43               jjttjj </span><span>(I don&apos;t know the index I need to insert at, just the keys in the map I need to insert before )</span></div><div data-t="jjttjj I&apos;ve been messing with INDEXED-VALS and trying to collect the index and then insert the new map, but I&apos;m having trouble getting this to work and am not sure this is the right line of thinking or if there&apos;s a better way"><span class="u" id="1525794559.000765">2018:05:08 15:49:19               jjttjj </span><span>I&apos;ve been messing with INDEXED-VALS and trying to collect the index and then insert the new map, but I&apos;m having trouble getting this to work and am not sure this is the right line of thinking or if there&apos;s a better way</span></div><div data-t="nathanmarz @jjttjj I would do that with a select followed by a transform:

 (if-let [i (select-first [INDEXED-VALS (selected? LAST :c (pred= 3)) FIRST)] data)]
  (setval (before-index i) {:x 100} data))
"><span class="u" id="1525795533.000325">2018:05:08 16:05:33           nathanmarz </span><span>@jjttjj I would do that with a select followed by a transform:

</span><pre>(if-let [i (select-first [INDEXED-VALS (selected? LAST :c (pred= 3)) FIRST)] data)]
  (setval (before-index i) {:x 100} data))
</pre></div><div data-t="nathanmarz you can also do it in a single operation using zippers"><span class="u" id="1525795561.000077">2018:05:08 16:06:01           nathanmarz </span><span>you can also do it in a single operation using zippers</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers"><span class="u" id="1525795601.000093">2018:05:08 16:06:41           nathanmarz </span><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers">https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers</a></div><div data-t="jjttjj cool, that one works, thanks!"><span class="u" id="1525795604.000088">2018:05:08 16:06:44               jjttjj </span><span>cool, that one works, thanks!</span></div><div data-t="soulflyer I&apos;m seeing a difference in the behaviour of a specter  recursive-path  example (found on stack overflow) in the  clojure repl  and the  clojurescript repl . It works as expected in clojure but throws an error in clojurescript. In clojure I get this:
 user&gt; (def data
  {:items [{:name &quot;Washing machine&quot;
            :subparts [{:name &quot;Ballast&quot; :weight 1}
                       {:name &quot;Hull&quot; :weight 2}]}]}) 
#&apos;user/data
user&gt; (require &apos;[com.rpl.specter :as specter])
nil
user&gt; (specter/select
  [(specter/recursive-path [] p
     [(specter/walker :name) (specter/stay-then-continue [:subparts p])])
   :name]
  data)
[&quot;Washing machine&quot; &quot;Ballast&quot; &quot;Hull&quot;]
user&gt; user&gt; (def data
  {:items [{:name &quot;Washing machine&quot;
            :subparts [{:name &quot;Ballast&quot; :weight 1}
                       {:name &quot;Hull&quot; :weight 2}]}]})
#&apos;user/data
user&gt; (require &apos;[com.rpl.specter :as specter])
nil
user&gt; (specter/select
  [(specter/recursive-path [] p
     [(specter/walker :name) (specter/stay-then-continue [:subparts p])])
   :name]
  data)
[&quot;Washing machine&quot; &quot;Ballast&quot; &quot;Hull&quot;]
user&gt;  
whereas the same code tried under clojurescript throws an error  Unable to resolve var p :
 anh-front.tree&gt; (require &apos;[com.rpl.specter :as specter])
nil
anh-front.tree&gt; (def data
  {:items [{:name &quot;Washing machine&quot;
            :subparts [{:name &quot;Ballast&quot; :weight 1}
                       {:name &quot;Hull&quot; :weight 2}]}]})
#&apos;anh-front.tree/data
anh-front.tree&gt; (specter/select
  [(specter/recursive-path [] p
     [(specter/walker :name) (specter/stay-then-continue [:subparts p])])
   :name]
  data)
----  Could not Analyze  &lt;cljs form&gt;   line:1  column:1  ----

  Unable to resolve var: p in this context at line 1 &lt;cljs repl&gt;

  1                (specter/select
                   ^--- 
  2  [(specter/recursive-path [] p
  3     [(specter/walker :name) (specter/stay-then-continue [:subparts p])])
  4   :name]
  5  data)

----  Analysis Error  ----
nil
anh-front.tree&gt;  
Is there something special needed to get recursive-path to play nicely with clojurescript?"><span class="u" id="1525845264.000143">2018:05:09 05:54:24            soulflyer </span><span>I&apos;m seeing a difference in the behaviour of a specter </span><code>recursive-path</code><span> example (found on stack overflow) in the </span><code>clojure repl</code><span> and the </span><code>clojurescript repl</code><span>. It works as expected in clojure but throws an error in clojurescript. In clojure I get this:
</span><pre>user&gt; (def data
  {:items [{:name &quot;Washing machine&quot;
            :subparts [{:name &quot;Ballast&quot; :weight 1}
                       {:name &quot;Hull&quot; :weight 2}]}]}) 
#&apos;user/data
user&gt; (require &apos;[com.rpl.specter :as specter])
nil
user&gt; (specter/select
  [(specter/recursive-path [] p
     [(specter/walker :name) (specter/stay-then-continue [:subparts p])])
   :name]
  data)
[&quot;Washing machine&quot; &quot;Ballast&quot; &quot;Hull&quot;]
user&gt; user&gt; (def data
  {:items [{:name &quot;Washing machine&quot;
            :subparts [{:name &quot;Ballast&quot; :weight 1}
                       {:name &quot;Hull&quot; :weight 2}]}]})
#&apos;user/data
user&gt; (require &apos;[com.rpl.specter :as specter])
nil
user&gt; (specter/select
  [(specter/recursive-path [] p
     [(specter/walker :name) (specter/stay-then-continue [:subparts p])])
   :name]
  data)
[&quot;Washing machine&quot; &quot;Ballast&quot; &quot;Hull&quot;]
user&gt; </pre><span>
whereas the same code tried under clojurescript throws an error </span><code>Unable to resolve var p</code><span>:
</span><pre>anh-front.tree&gt; (require &apos;[com.rpl.specter :as specter])
nil
anh-front.tree&gt; (def data
  {:items [{:name &quot;Washing machine&quot;
            :subparts [{:name &quot;Ballast&quot; :weight 1}
                       {:name &quot;Hull&quot; :weight 2}]}]})
#&apos;anh-front.tree/data
anh-front.tree&gt; (specter/select
  [(specter/recursive-path [] p
     [(specter/walker :name) (specter/stay-then-continue [:subparts p])])
   :name]
  data)
----  Could not Analyze  &lt;cljs form&gt;   line:1  column:1  ----

  Unable to resolve var: p in this context at line 1 &lt;cljs repl&gt;

  1                (specter/select
                   ^--- 
  2  [(specter/recursive-path [] p
  3     [(specter/walker :name) (specter/stay-then-continue [:subparts p])])
  4   :name]
  5  data)

----  Analysis Error  ----
nil
anh-front.tree&gt; </pre><span>
Is there something special needed to get recursive-path to play nicely with clojurescript?</span></div><div data-t="soulflyer example pulled from:  https://stackoverflow.com/questions/42889373/recursive-map-query-using-specter"><span class="u" id="1525845322.000056">2018:05:09 05:55:22                 soulflyer </span><span>example pulled from: </span><a href="https://stackoverflow.com/questions/42889373/recursive-map-query-using-specter">https://stackoverflow.com/questions/42889373/recursive-map-query-using-specter</a></div><div data-t="nathanmarz @soulflyer does it work if you refactor the recursive-path definition out of the select with a let or def?"><span class="u" id="1525868970.000345">2018:05:09 12:29:30           nathanmarz </span><span>@soulflyer does it work if you refactor the recursive-path definition out of the select with a let or def?</span></div><div data-t="souenzzo Doing a cljsbuild with advanced
 May 09, 2018 1:13:26 PM com.google.javascript.jscomp.LoggerErrorManager printSummary
WARNING: 1 error(s), 0 warning(s)
ERROR: JSC_DUPLICATE_PARAM. Parse error. Duplicate parameter name &quot;G__13210_13216&quot; at /workspace/my-cool-project/target/cljsbuild-compiler-0/com/rpl/specter/impl.js line 543 : 32
[31mCompiling [&quot;resources/public/javascript/main.js&quot;] failed.[0m
java.lang.Exception: Closure compilation failed
 
It&apos;s a random error. Tryied to build again and it passes. Has anyone else ever had this problem?
Using:  [com.rpl/specter &quot;1.1.0&quot;] [org.clojure/clojurescript &quot;1.10.238&quot;] 
 https://github.com/nathanmarz/specter/blob/1.1.0/src/clj/com/rpl/specter/impl.cljc#L543"><span class="u" id="1525872115.000068">2018:05:09 13:21:55             souenzzo </span><span>Doing a cljsbuild with advanced
</span><pre>May 09, 2018 1:13:26 PM com.google.javascript.jscomp.LoggerErrorManager printSummary
WARNING: 1 error(s), 0 warning(s)
ERROR: JSC_DUPLICATE_PARAM. Parse error. Duplicate parameter name &quot;G__13210_13216&quot; at /workspace/my-cool-project/target/cljsbuild-compiler-0/com/rpl/specter/impl.js line 543 : 32
[31mCompiling [&quot;resources/public/javascript/main.js&quot;] failed.[0m
java.lang.Exception: Closure compilation failed
</pre><span>
It&apos;s a random error. Tryied to build again and it passes. Has anyone else ever had this problem?
Using: </span><code>[com.rpl/specter &quot;1.1.0&quot;] [org.clojure/clojurescript &quot;1.10.238&quot;]</code><span>
</span><a href="https://github.com/nathanmarz/specter/blob/1.1.0/src/clj/com/rpl/specter/impl.cljc#L543">https://github.com/nathanmarz/specter/blob/1.1.0/src/clj/com/rpl/specter/impl.cljc#L543</a></div><div data-t="soulflyer @nathanmarz yes, seems to work fine if I use  def ."><span class="u" id="1525872381.000643">2018:05:09 13:26:21            soulflyer </span><span>@nathanmarz yes, seems to work fine if I use </span><code>def</code><span>.</span></div><div data-t="soulflyer I&apos;m having trouble figuring out how to navigate to an entry that could have a variable number of steps. An individual navigate/transform  is easy enough and looks something like this: (sp/transform [(node-named &quot;2002&quot;) :children (node-named &quot;01&quot;) :expanded] invert test-tree) 
However I need to be able to provide a path that could have from 1 to 4 entries. In the above example it would be  [&quot;2002&quot; &quot;01&quot;] . What would be the best way to approach this?
I tried building the navigator with  for  in a  let  statement like this: (defn toggle [tree path]
  (let [nav (conj
              (vec
                (interpose :children (for [p path] (conj (seq [p]) &apos;node-named ))))
              :expanded)]
    (sp/transform nav invert tree)))
 
But although this gives me a value for  nav  that looks exactly right, running it throws  Not a navigator  errors"><span class="u" id="1525933461.000005">2018:05:10 06:24:21            soulflyer </span><span>I&apos;m having trouble figuring out how to navigate to an entry that could have a variable number of steps. An individual navigate/transform  is easy enough and looks something like this:</span><pre>(sp/transform [(node-named &quot;2002&quot;) :children (node-named &quot;01&quot;) :expanded] invert test-tree)</pre><span>
However I need to be able to provide a path that could have from 1 to 4 entries. In the above example it would be </span><code>[&quot;2002&quot; &quot;01&quot;]</code><span>. What would be the best way to approach this?
I tried building the navigator with </span><code>for</code><span> in a </span><code>let</code><span> statement like this:</span><pre>(defn toggle [tree path]
  (let [nav (conj
              (vec
                (interpose :children (for [p path] (conj (seq [p]) &apos;node-named ))))
              :expanded)]
    (sp/transform nav invert tree)))
</pre><span>
But although this gives me a value for </span><code>nav</code><span> that looks exactly right, running it throws </span><code>Not a navigator</code><span> errors</span></div><div data-t="soulflyer I&apos;m having trouble figuring out how to navigate to an entry that could have a variable number of steps. An individual navigate/transform  is easy enough and looks something like this: (sp/transform [(node-named &quot;2002&quot;) :children (node-named &quot;01&quot;) :expanded] invert test-tree) 
However I need to be able to provide a path that could have from 1 to 4 entries. In the above example it would be  [&quot;2002&quot; &quot;01&quot;] . What would be the best way to approach this?
I tried building the navigator with  for  in a  let  statement like this: (defn toggle [tree path]
  (let [nav (conj
              (vec
                (interpose :children (for [p path] (conj (seq [p]) &apos;node-named ))))
              :expanded)]
    (sp/transform nav invert tree)))
 
But although this gives me a value for  nav  that looks exactly right, running it throws  Not a navigator  errors"><span class="u" id="1525933461.000005">2018:05:10 06:24:21            soulflyer </span><span>I&apos;m having trouble figuring out how to navigate to an entry that could have a variable number of steps. An individual navigate/transform  is easy enough and looks something like this:</span><pre>(sp/transform [(node-named &quot;2002&quot;) :children (node-named &quot;01&quot;) :expanded] invert test-tree)</pre><span>
However I need to be able to provide a path that could have from 1 to 4 entries. In the above example it would be </span><code>[&quot;2002&quot; &quot;01&quot;]</code><span>. What would be the best way to approach this?
I tried building the navigator with </span><code>for</code><span> in a </span><code>let</code><span> statement like this:</span><pre>(defn toggle [tree path]
  (let [nav (conj
              (vec
                (interpose :children (for [p path] (conj (seq [p]) &apos;node-named ))))
              :expanded)]
    (sp/transform nav invert tree)))
</pre><span>
But although this gives me a value for </span><code>nav</code><span> that looks exactly right, running it throws </span><code>Not a navigator</code><span> errors</span></div><div data-t="soulflyer where  node-named   invert  and  test-tree  are: (defn node-named [n]
  (sp/walker #(= (:name %) n)))

(defn invert [b]
  (if b false true))

(def test-tree
  {:name &quot;root&quot;
   :focus [&quot;root&quot;]
   :expanded true
   :children [{:name &quot;2000&quot;
               :expanded true
               :children [{:name &quot;01&quot;
                           :expanded true
                           :children [{:name &quot;project-1&quot;}
                                      {:name &quot;project-2&quot;}]}
                          {:name &quot;02&quot;
                           :expanded true
                           :children [{:name &quot;project-5&quot;}
                                      {:name &quot;project-6&quot;}]}]}
              {:name &quot;2002&quot;
               :expanded false
               :children [{:name &quot;01&quot;
                           :expanded false
                           :children []}]}]})"><span class="u" id="1525933607.000072">2018:05:10 06:26:47                 soulflyer </span><span>where </span><code>node-named</code><span> </span><code>invert</code><span> and </span><code>test-tree</code><span> are:</span><pre>(defn node-named [n]
  (sp/walker #(= (:name %) n)))

(defn invert [b]
  (if b false true))

(def test-tree
  {:name &quot;root&quot;
   :focus [&quot;root&quot;]
   :expanded true
   :children [{:name &quot;2000&quot;
               :expanded true
               :children [{:name &quot;01&quot;
                           :expanded true
                           :children [{:name &quot;project-1&quot;}
                                      {:name &quot;project-2&quot;}]}
                          {:name &quot;02&quot;
                           :expanded true
                           :children [{:name &quot;project-5&quot;}
                                      {:name &quot;project-6&quot;}]}]}
              {:name &quot;2002&quot;
               :expanded false
               :children [{:name &quot;01&quot;
                           :expanded false
                           :children []}]}]})</pre></div><div data-t="schmee try something like this: 
 (defn navigator [strs]
  (path (mapcat (fn [s] [:children ALL #(= (:name %) s)]) strs)))
"><span class="u" id="1525939292.000207">2018:05:10 08:01:32                    schmee </span><span>try something like this: 
</span><pre>(defn navigator [strs]
  (path (mapcat (fn [s] [:children ALL #(= (:name %) s)]) strs)))
</pre></div><div data-t="schmee also, the  invert  function can be replaced with the core function  not   🙂"><span class="u" id="1525939620.000140">2018:05:10 08:07:00                    schmee </span><span>also, the </span><code>invert</code><span> function can be replaced with the core function </span><code>not</code><span> </span><b>🙂</b></div><div data-t="soulflyer @U3L6TFEJF That looks promising, thanks. I&apos;m getting the right node back now. Just got to massage it a bit to toggle :expanded. Which I will do with  not 😳"><span class="u" id="1525941542.000143">2018:05:10 08:39:02                 soulflyer </span><span>@U3L6TFEJF That looks promising, thanks. I&apos;m getting the right node back now. Just got to massage it a bit to toggle :expanded. Which I will do with </span><code>not</code><b>😳</b></div><div data-t="schmee remember that you can compose paths with a simple vector:  (transform [(navigator [&quot;2000&quot; &quot;01&quot;]) :expanded] not test-tree)"><span class="u" id="1525941592.000246">2018:05:10 08:39:52                    schmee </span><span>remember that you can compose paths with a simple vector: </span><pre>(transform [(navigator [&quot;2000&quot; &quot;01&quot;]) :expanded] not test-tree)</pre></div><div data-t="soulflyer yup, got it working now. Still waiting for the ah-ha moment with specter, but it is doing some useful things even though often I&apos;m not entirely sure why...."><span class="u" id="1525942217.000005">2018:05:10 08:50:17                 soulflyer </span><span>yup, got it working now. Still waiting for the ah-ha moment with specter, but it is doing some useful things even though often I&apos;m not entirely sure why....</span></div><div data-t="schmee stick with it!  🙂  like anything worth learning it takes practice but the payoff is worth it IMO"><span class="u" id="1525945030.000077">2018:05:10 09:37:10                    schmee </span><span>stick with it! </span><b>🙂</b><span> like anything worth learning it takes practice but the payoff is worth it IMO</span></div><div data-t="schmee you can always ask here if you get stuck  :+1:"><span class="u" id="1525945042.000354">2018:05:10 09:37:22                    schmee </span><span>you can always ask here if you get stuck </span><b>:+1:</b></div><div data-t="montanonic I&apos;m new to Specter and trying to figure out how to express finding all of the numbers in deeply nested data, except for those that are nested within maps (at any depth) containing a particular value.

Finding all the numbers is totally easy,  (traverse (walker number?) data) , it&apos;s the filtering out part that I&apos;m struggling with."><span class="u" id="1526458197.000084">2018:05:16 08:09:57           montanonic </span><span>I&apos;m new to Specter and trying to figure out how to express finding all of the numbers in deeply nested data, except for those that are nested within maps (at any depth) containing a particular value.

Finding all the numbers is totally easy, </span><code>(traverse (walker number?) data)</code><span>, it&apos;s the filtering out part that I&apos;m struggling with.</span></div><div data-t="nathanmarz @montanonic if you truly want to do a blind walk (including into map keys, key/value pairs) then you can do it like this:
 (def my-walker
  (recursive-path [afn] p
    (cond-path (pred afn) STAY
               map? [(not-selected? :key (pred= :val)) ALL p]
               coll? [ALL p]
               )))
"><span class="u" id="1526478924.000721">2018:05:16 13:55:24           nathanmarz </span><span>@montanonic if you truly want to do a blind walk (including into map keys, key/value pairs) then you can do it like this:
</span><pre>(def my-walker
  (recursive-path [afn] p
    (cond-path (pred afn) STAY
               map? [(not-selected? :key (pred= :val)) ALL p]
               coll? [ALL p]
               )))
</pre></div><div data-t="nathanmarz if you have any structure to your data, I highly recommend making a path tailored as such"><span class="u" id="1526478978.000599">2018:05:16 13:56:18           nathanmarz </span><span>if you have any structure to your data, I highly recommend making a path tailored as such</span></div><div data-t="montanonic The problem I&apos;m solving is just a for-fun code challenge with a pathologically nested data set; I&apos;m not sure how &quot;structured&quot; it is. Thanks for your help! I&apos;m going to need to spend a bit of time to understand what&apos;s going on there, particularly  map? [(not-selected? :key (pred= :val)) ALL p]"><span class="u" id="1526497573.000696">2018:05:16 19:06:13           montanonic </span><span>The problem I&apos;m solving is just a for-fun code challenge with a pathologically nested data set; I&apos;m not sure how &quot;structured&quot; it is. Thanks for your help! I&apos;m going to need to spend a bit of time to understand what&apos;s going on there, particularly </span><code>map? [(not-selected? :key (pred= :val)) ALL p]</code></div><div data-t="montanonic @nathanmarz Can you elaborate more on  :key  and  :val  in that code? Did you intend them to just be stand-ins?

I also don&apos;t, in this case, need to consider map keys, only values."><span class="u" id="1526498320.000618">2018:05:16 19:18:40           montanonic </span><span>@nathanmarz Can you elaborate more on </span><code>:key</code><span> and </span><code>:val</code><span> in that code? Did you intend them to just be stand-ins?

I also don&apos;t, in this case, need to consider map keys, only values.</span></div><div data-t="nathanmarz @montanonic yes, those are stand-ins"><span class="u" id="1526498502.000424">2018:05:16 19:21:42           nathanmarz </span><span>@montanonic yes, those are stand-ins</span></div><div data-t="nathanmarz this is better:
 (def my-walker
  (recursive-path [afn avoid-key avoid-value] p
    (cond-path (pred afn) STAY
               map? [(not-selected? (keypath avoid-key) (pred= avoid-value)) MAP-VALS p]
               coll? [ALL p]
               )))
"><span class="u" id="1526498511.000127">2018:05:16 19:21:51           nathanmarz </span><span>this is better:
</span><pre>(def my-walker
  (recursive-path [afn avoid-key avoid-value] p
    (cond-path (pred afn) STAY
               map? [(not-selected? (keypath avoid-key) (pred= avoid-value)) MAP-VALS p]
               coll? [ALL p]
               )))
</pre></div><div data-t="nathanmarz avoiding parts of data structures that are irrelevant makes a big impact on performance, and also avoids bugs"><span class="u" id="1526498550.000549">2018:05:16 19:22:30           nathanmarz </span><span>avoiding parts of data structures that are irrelevant makes a big impact on performance, and also avoids bugs</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/wiki/Cheat-Sheet  is a good resource for learning what those navigators are"><span class="u" id="1526498574.000727">2018:05:16 19:22:54           nathanmarz </span><a href="https://github.com/nathanmarz/specter/wiki/Cheat-Sheet">https://github.com/nathanmarz/specter/wiki/Cheat-Sheet</a><span> is a good resource for learning what those navigators are</span></div><div data-t="montanonic Since I&apos;m not concerned about the values of the keys themselves, would"><span class="u" id="1526498581.000640">2018:05:16 19:23:01           montanonic </span><span>Since I&apos;m not concerned about the values of the keys themselves, would</span></div><div data-t="montanonic [(not-selected? (pred= avoid-value)) MAP-VALS p]"><span class="u" id="1526498588.000686">2018:05:16 19:23:08           montanonic </span><code>[(not-selected? (pred= avoid-value)) MAP-VALS p]</code></div><div data-t="montanonic also work? sans   (keypath avoid-key)"><span class="u" id="1526498594.000731">2018:05:16 19:23:14           montanonic </span><span>also work? sans </span><code> (keypath avoid-key)</code></div><div data-t="montanonic Thanks for that resource! I&apos;ve been reading all the wiki pages repeatedly; they are very good; I just found my use-case to be one of the ones that was harder to figure out from them"><span class="u" id="1526498627.000459">2018:05:16 19:23:47           montanonic </span><span>Thanks for that resource! I&apos;ve been reading all the wiki pages repeatedly; they are very good; I just found my use-case to be one of the ones that was harder to figure out from them</span></div><div data-t="nathanmarz if you&apos;re avoiding maps which contain a specific value for any key, then do  [(not-selected? MAP-VALS (pred= avoid-value)) MAP-VALS p]"><span class="u" id="1526498649.000583">2018:05:16 19:24:09           nathanmarz </span><span>if you&apos;re avoiding maps which contain a specific value for any key, then do </span><code>[(not-selected? MAP-VALS (pred= avoid-value)) MAP-VALS p]</code></div><div data-t="montanonic Okay, wonderful. Thank you!"><span class="u" id="1526498691.000188">2018:05:16 19:24:51           montanonic </span><span>Okay, wonderful. Thank you!</span></div><div data-t="montanonic I think that makes total sense"><span class="u" id="1526498707.000275">2018:05:16 19:25:07           montanonic </span><span>I think that makes total sense</span></div><div data-t="nathanmarz with practice this becomes very easy"><span class="u" id="1526498734.000678">2018:05:16 19:25:34           nathanmarz </span><span>with practice this becomes very easy</span></div><div data-t="montanonic Wow, totally works. That&apos;s super great. I was struggling to figure out how to filter values, but I can see how  selected  and  not-selected?  help with that. Super!"><span class="u" id="1526498831.000402">2018:05:16 19:27:11           montanonic </span><span>Wow, totally works. That&apos;s super great. I was struggling to figure out how to filter values, but I can see how </span><code>selected</code><span> and </span><code>not-selected?</code><span> help with that. Super!</span></div><div data-t="montanonic Is there a better way to collect multiple keys than:  [ALL (collect-one :a) (collect-one :b) (collect-one :c)] , etc..?"><span class="u" id="1526505815.000061">2018:05:16 21:23:35           montanonic </span><span>Is there a better way to collect multiple keys than: </span><code>[ALL (collect-one :a) (collect-one :b) (collect-one :c)]</code><span>, etc..?</span></div><div data-t="tanzoniteblack @montanonic  (specter/collect (specter/multi-path :a :b :c))"><span class="u" id="1526505994.000478">2018:05:16 21:26:34       tanzoniteblack </span><span>@montanonic </span><code>(specter/collect (specter/multi-path :a :b :c))</code></div><div data-t="montanonic Great! thanks  🙂"><span class="u" id="1526506008.000351">2018:05:16 21:26:48           montanonic </span><span>Great! thanks </span><b>🙂</b></div><div data-t="tanzoniteblack (specter/select [specter/ALL (specter/collect (specter/multi-path :a :b :c))]
                [{:a &quot;cat&quot; :b &quot;dog&quot; :c &quot;c&quot;}
                 {:a 1 :b 2 :c 3}])  ==&gt;  [[[&quot;cat&quot; &quot;dog&quot; &quot;c&quot;] {:a &quot;cat&quot;, :b &quot;dog&quot;, :c &quot;c&quot;}]
 [[1 2 3] {:a 1, :b 2, :c 3}]]"><span class="u" id="1526506028.000220">2018:05:16 21:27:08       tanzoniteblack </span><pre>(specter/select [specter/ALL (specter/collect (specter/multi-path :a :b :c))]
                [{:a &quot;cat&quot; :b &quot;dog&quot; :c &quot;c&quot;}
                 {:a 1 :b 2 :c 3}])</pre><span> ==&gt; </span><pre>[[[&quot;cat&quot; &quot;dog&quot; &quot;c&quot;] {:a &quot;cat&quot;, :b &quot;dog&quot;, :c &quot;c&quot;}]
 [[1 2 3] {:a 1, :b 2, :c 3}]]</pre></div><div data-t="tanzoniteblack thanks for asking, I&apos;d never actually tried that before"><span class="u" id="1526506044.000245">2018:05:16 21:27:24       tanzoniteblack </span><span>thanks for asking, I&apos;d never actually tried that before</span></div><div data-t="nathanmarz @montanonic @tanzoniteblack can also use  eachnav :
 (select-any [((eachnav collect-one) :a :b :c) :d] {:a 1 :b 2 :c 3 :d 4})
;; =&gt; [1 2 3 4]
"><span class="u" id="1526507157.000389">2018:05:16 21:45:57           nathanmarz </span><span>@montanonic @tanzoniteblack can also use </span><code>eachnav</code><span>:
</span><pre>(select-any [((eachnav collect-one) :a :b :c) :d] {:a 1 :b 2 :c 3 :d 4})
;; =&gt; [1 2 3 4]
</pre></div><div data-t="montanonic Is there a more efficient or idiomatic way to do this with specter?

 (every? #(= 2 %) (select [MAP-VALS] coll)) 

That is: tell me if all of the values in a  coll  that is a map are equal to some value, in this case  2 ."><span class="u" id="1526514103.000152">2018:05:16 23:41:43           montanonic </span><span>Is there a more efficient or idiomatic way to do this with specter?

</span><code>(every? #(= 2 %) (select [MAP-VALS] coll))</code><span>

That is: tell me if all of the values in a </span><code>coll</code><span> that is a map are equal to some value, in this case </span><code>2</code><span>.</span></div><div data-t="nathanmarz you could make it slightly more efficient with a version of  every?  that uses reduce"><span class="u" id="1526515919.000331">2018:05:17 00:11:59           nathanmarz </span><span>you could make it slightly more efficient with a version of </span><code>every?</code><span> that uses reduce</span></div><div data-t="nathanmarz then you could use  traverse :  (every-reduce? #(= 2 %) (traverse [MAP-VALS] coll))"><span class="u" id="1526515945.000142">2018:05:17 00:12:25           nathanmarz </span><span>then you could use </span><code>traverse</code><span>: </span><code>(every-reduce? #(= 2 %) (traverse [MAP-VALS] coll))</code></div><div data-t="nathanmarz traverse  doesn&apos;t materialize any intermediate data structure"><span class="u" id="1526515958.000076">2018:05:17 00:12:38           nathanmarz </span><code>traverse</code><span> doesn&apos;t materialize any intermediate data structure</span></div><div data-t="nathanmarz on second thought this is a much better approach:
 (not (selected-any? [MAP-VALS #(not= 2 %)] coll))
"><span class="u" id="1526516045.000096">2018:05:17 00:14:05           nathanmarz </span><span>on second thought this is a much better approach:
</span><pre>(not (selected-any? [MAP-VALS #(not= 2 %)] coll))
</pre></div><div data-t="montanonic ahhh, nice. That&apos;s a good one"><span class="u" id="1526516574.000029">2018:05:17 00:22:54           montanonic </span><span>ahhh, nice. That&apos;s a good one</span></div><div data-t="Casey Are there any projects with source available that use specter heavily? Would like to see how specter is used at large in a project"><span class="u" id="1526565392.000273">2018:05:17 13:56:32                Casey </span><span>Are there any projects with source available that use specter heavily? Would like to see how specter is used at large in a project</span></div><div data-t="nathanmarz @ramblurr not that I&apos;m aware of, but at the end of this presentation I showed some of the ways I use it in production for manipulating dags  https://www.youtube.com/watch?v=VTCy_DkAJGk]"><span class="u" id="1526566749.000346">2018:05:17 14:19:09           nathanmarz </span><span>@ramblurr not that I&apos;m aware of, but at the end of this presentation I showed some of the ways I use it in production for manipulating dags </span><a href="https://www.youtube.com/watch?v=VTCy_DkAJGk]">https://www.youtube.com/watch?v=VTCy_DkAJGk]</a></div><div data-t="Casey thanks @nathanmarz"><span class="u" id="1526567903.000636">2018:05:17 14:38:23                Casey </span><span>thanks @nathanmarz</span></div><div data-t="sophiago Question: I have a simple  transform  expression with a recursive navigator very similar to the one in the example that I&apos;m using in a macro to navigate to every symbol in an AST and replace parts of certain ones (unfortunately converting to and from strings and using regex since I only need to replace part of these symbols). I&apos;d also like it to jump one level up in the AST from each match, or more precisely group of matches with the same substring, and wrap it in a list at that point. Can anyone recommend a starting point for thinking about defining a relative path with specter like this? I would ideally like to avoid the perf overhead of two separate  transform s."><span class="u" id="1526683102.000311">2018:05:18 22:38:22             sophiago </span><span>Question: I have a simple </span><code>transform</code><span> expression with a recursive navigator very similar to the one in the example that I&apos;m using in a macro to navigate to every symbol in an AST and replace parts of certain ones (unfortunately converting to and from strings and using regex since I only need to replace part of these symbols). I&apos;d also like it to jump one level up in the AST from each match, or more precisely group of matches with the same substring, and wrap it in a list at that point. Can anyone recommend a starting point for thinking about defining a relative path with specter like this? I would ideally like to avoid the perf overhead of two separate </span><code>transform</code><span>s.</span></div><div data-t="sophiago Oh, and this also ignores the issue of wanting to group together multiple occurrences of the same substring. So the symbol added in the second  transform  should only ever be one, but the predicate would have to be modified to match on the collection above all other collections that contain that exact substring."><span class="u" id="1526683764.000311">2018:05:18 22:49:24             sophiago </span><span>Oh, and this also ignores the issue of wanting to group together multiple occurrences of the same substring. So the symbol added in the second </span><code>transform</code><span> should only ever be one, but the predicate would have to be modified to match on the collection above all other collections that contain that exact substring.</span></div><div data-t="nathanmarz @sophiago that first one can be simplified to  (setval [TREE NAME #&quot;p[1-9]&quot;] &quot;p&quot; (macroexpand x))"><span class="u" id="1526684025.000256">2018:05:18 22:53:45           nathanmarz </span><span>@sophiago that first one can be simplified to </span><code>(setval [TREE NAME #&quot;p[1-9]&quot;] &quot;p&quot; (macroexpand x))</code></div><div data-t="sophiago @nathanmarz ah, thanks. I wrote this very late last night and was thinking I should have been able to do something like that"><span class="u" id="1526684086.000021">2018:05:18 22:54:46             sophiago </span><span>@nathanmarz ah, thanks. I wrote this very late last night and was thinking I should have been able to do something like that</span></div><div data-t="sophiago I just posted an example of what that  transform  does with what I hope is a slightly better description of what I&apos;d like to add to it"><span class="u" id="1526684124.000156">2018:05:18 22:55:24             sophiago </span><span>I just posted an example of what that </span><code>transform</code><span> does with what I hope is a slightly better description of what I&apos;d like to add to it</span></div><div data-t="sophiago (I also omitted mentioning I&apos;m using a fork of the compiler where the result would actually be valid...i.e. nested function literals where  %  shadow one another if necessary)"><span class="u" id="1526684197.000225">2018:05:18 22:56:37             sophiago </span><span>(I also omitted mentioning I&apos;m using a fork of the compiler where the result would actually be valid...i.e. nested function literals where </span><code>%</code><span> shadow one another if necessary)</span></div><div data-t="nathanmarz not understanding what you&apos;re trying to do with that second transform"><span class="u" id="1526684236.000063">2018:05:18 22:57:16           nathanmarz </span><span>not understanding what you&apos;re trying to do with that second transform</span></div><div data-t="sophiago Let me provide a more succinct and precise example"><span class="u" id="1526684264.000144">2018:05:18 22:57:44             sophiago </span><span>Let me provide a more succinct and precise example</span></div><div data-t="sophiago There&apos;s one place in the macroexpansion above where the bound variable occurs twice:  (*&apos;(long (. Math pow 10 (first p__13958#))) (second p__13958#))"><span class="u" id="1526684326.000217">2018:05:18 22:58:46             sophiago </span><span>There&apos;s one place in the macroexpansion above where the bound variable occurs twice: </span><code>(*&apos;(long (. Math pow 10 (first p__13958#))) (second p__13958#))</code></div><div data-t="sophiago So, ideally in the same  transform , I&apos;d like that to become:  (fn* [p__13958#] (*&apos;(long (. Math pow 10 (first p__13958#))) (second p__13958#))"><span class="u" id="1526684383.000016">2018:05:18 22:59:43             sophiago </span><span>So, ideally in the same </span><code>transform</code><span>, I&apos;d like that to become: </span><code>(fn* [p__13958#] (*&apos;(long (. Math pow 10 (first p__13958#))) (second p__13958#))</code></div><div data-t="sophiago The cases where the bound variables only appear once are simpler, although I&apos;m still unsure how to handle them in one pass with Specter"><span class="u" id="1526684441.000221">2018:05:18 23:00:41             sophiago </span><span>The cases where the bound variables only appear once are simpler, although I&apos;m still unsure how to handle them in one pass with Specter</span></div><div data-t="nathanmarz so you want to collect every unique symbol starting with &quot;p&quot; and wrap the expression with  (fn* [&lt;collected p&apos;s&gt;] ...) ?"><span class="u" id="1526684466.000116">2018:05:18 23:01:06           nathanmarz </span><span>so you want to collect every unique symbol starting with &quot;p&quot; and wrap the expression with </span><code>(fn* [&lt;collected p&apos;s&gt;] ...)</code><span>?</span></div><div data-t="sophiago Yes, but only wrap the deepest subexpression where the symbols are exactly the same. But the numerals will never repeat in the input, so saying exact substrings is good enough."><span class="u" id="1526684576.000295">2018:05:18 23:02:56             sophiago </span><span>Yes, but only wrap the deepest subexpression where the symbols are exactly the same. But the numerals will never repeat in the input, so saying exact substrings is good enough.</span></div><div data-t="nathanmarz for wrapping once you identify the subexpression you can do it like:
 (transform (collect TREE symbol? (selected? NAME #&quot;p[1-9]&quot;))
  (fn [psyms expr]
    `(fn* ["><span class="u" id="1526684630.000049">2018:05:18 23:03:50           nathanmarz </span><span>for wrapping once you identify the subexpression you can do it like:
</span><pre>(transform (collect TREE symbol? (selected? NAME #&quot;p[1-9]&quot;))
  (fn [psyms expr]
    `(fn* [</pre></div><div data-t="nathanmarz assuming  TREE  goes to every leaf"><span class="u" id="1526684645.000212">2018:05:18 23:04:05           nathanmarz </span><span>assuming </span><code>TREE</code><span> goes to every leaf</span></div><div data-t="sophiago TREE  goes to every coll currently"><span class="u" id="1526684662.000156">2018:05:18 23:04:22             sophiago </span><code>TREE</code><span> goes to every coll currently</span></div><div data-t="nathanmarz as for &quot;deepest subexpression where the symbols are exactly the same&quot; that sounds like a more involved algorithm"><span class="u" id="1526684675.000038">2018:05:18 23:04:35           nathanmarz </span><span>as for &quot;deepest subexpression where the symbols are exactly the same&quot; that sounds like a more involved algorithm</span></div><div data-t="nathanmarz the same &quot;p&quot; symbol could exist deeply nested across multiple branches"><span class="u" id="1526684695.000255">2018:05:18 23:04:55           nathanmarz </span><span>the same &quot;p&quot; symbol could exist deeply nested across multiple branches</span></div><div data-t="sophiago Right, that&apos;s much more involved than simple one list up."><span class="u" id="1526684702.000004">2018:05:18 23:05:02             sophiago </span><span>Right, that&apos;s much more involved than simple one list up.</span></div><div data-t="sophiago I can make some assumptions based on what would constitute valid input. For example, how px_foo means foo will always be the same for every x. Similarly, for each x: they&apos;ll be grouped together as far as depth in the entire AST (not sure whether that makes sense)."><span class="u" id="1526684821.000128">2018:05:18 23:07:01             sophiago </span><span>I can make some assumptions based on what would constitute valid input. For example, how px_foo means foo will always be the same for every x. Similarly, for each x: they&apos;ll be grouped together as far as depth in the entire AST (not sure whether that makes sense).</span></div><div data-t="nathanmarz not really"><span class="u" id="1526684905.000067">2018:05:18 23:08:25           nathanmarz </span><span>not really</span></div><div data-t="sophiago So both those in the example I pulled out started with p3. There would never be a p3 at a higher level of nesting or below the level where there&apos;s a p4. I&apos;m struggling for language to describe that. Like the &quot;x&quot; in &quot;px&quot; is monotonic with AST depth?"><span class="u" id="1526684907.000183">2018:05:18 23:08:27             sophiago </span><span>So both those in the example I pulled out started with p3. There would never be a p3 at a higher level of nesting or below the level where there&apos;s a p4. I&apos;m struggling for language to describe that. Like the &quot;x&quot; in &quot;px&quot; is monotonic with AST depth?</span></div><div data-t="nathanmarz you mean the depth of the root of the subexpression containing all instances of pn is monotonic with n?"><span class="u" id="1526684976.000004">2018:05:18 23:09:36           nathanmarz </span><span>you mean the depth of the root of the subexpression containing all instances of pn is monotonic with n?</span></div><div data-t="sophiago So when you mentioned multiple branches, I can actually ignore that. It&apos;s only a matter of variance in the number of lists you&apos;d need to jump up for the symbols to be in the same one."><span class="u" id="1526684977.000135">2018:05:18 23:09:37             sophiago </span><span>So when you mentioned multiple branches, I can actually ignore that. It&apos;s only a matter of variance in the number of lists you&apos;d need to jump up for the symbols to be in the same one.</span></div><div data-t="sophiago &quot;depth of the root of the subexpression containing all instances of pn is monotonic with n&quot; =&gt; I believe this is exactly what I&apos;m stating"><span class="u" id="1526685027.000225">2018:05:18 23:10:27             sophiago </span><span>&quot;depth of the root of the subexpression containing all instances of pn is monotonic with n&quot; =&gt; I believe this is exactly what I&apos;m stating</span></div><div data-t="sophiago Just some confusion over your use of the term &quot;root&quot;"><span class="u" id="1526685057.000150">2018:05:18 23:10:57             sophiago </span><span>Just some confusion over your use of the term &quot;root&quot;</span></div><div data-t="nathanmarz the difference between:
 [:a [1 [2]] [1 [2]]]

[:a [1 1] [[2] [2]]]
"><span class="u" id="1526685126.000102">2018:05:18 23:12:06           nathanmarz </span><span>the difference between:
</span><pre>[:a [1 [2]] [1 [2]]]

[:a [1 1] [[2] [2]]]
</pre></div><div data-t="nathanmarz in the first, the root for both is  [:a [1 [2]] [1 [2]]]"><span class="u" id="1526685144.000002">2018:05:18 23:12:24           nathanmarz </span><span>in the first, the root for both is </span><code>[:a [1 [2]] [1 [2]]]</code></div><div data-t="nathanmarz in the second, the root for &quot;1&quot; is  [1 1]  and for &quot;2&quot;  [[2] [2]]"><span class="u" id="1526685163.000239">2018:05:18 23:12:43           nathanmarz </span><span>in the second, the root for &quot;1&quot; is </span><code>[1 1]</code><span> and for &quot;2&quot; </span><code>[[2] [2]]</code></div><div data-t="nathanmarz is that what you&apos;re getting at?"><span class="u" id="1526685169.000125">2018:05:18 23:12:49           nathanmarz </span><span>is that what you&apos;re getting at?</span></div><div data-t="sophiago Yes. You can assume it&apos;s like your second example."><span class="u" id="1526685185.000041">2018:05:18 23:13:05             sophiago </span><span>Yes. You can assume it&apos;s like your second example.</span></div><div data-t="sophiago To backtrack a bit (no pun intended) in  (setval [TREE NAME #&quot;p[1-9]&quot;] &quot;p&quot; (macroexpand x))  will &quot;p&quot; be made into a symbol or do I need to add that?"><span class="u" id="1526685256.000252">2018:05:18 23:14:16             sophiago </span><span>To backtrack a bit (no pun intended) in </span><code>(setval [TREE NAME #&quot;p[1-9]&quot;] &quot;p&quot; (macroexpand x))</code><span> will &quot;p&quot; be made into a symbol or do I need to add that?</span></div><div data-t="sophiago I hate treating symbols as strings, but seems unavoidable here  😕"><span class="u" id="1526685281.000169">2018:05:18 23:14:41             sophiago </span><span>I hate treating symbols as strings, but seems unavoidable here </span><b>😕</b></div><div data-t="sophiago To be clear, the transformation at that level is p3__13962# =&gt; p__13962#"><span class="u" id="1526685365.000138">2018:05:18 23:16:05             sophiago </span><span>To be clear, the transformation at that level is p3__13962# =&gt; p__13962#</span></div><div data-t="nathanmarz it replaces the substring within the symbol"><span class="u" id="1526685716.000042">2018:05:18 23:21:56           nathanmarz </span><span>it replaces the substring within the symbol</span></div><div data-t="nathanmarz behind the scenes  NAME  is extracting the string for the symbol&apos;s name, manipulating it, and then reconstructing the symbol"><span class="u" id="1526685732.000136">2018:05:18 23:22:12           nathanmarz </span><span>behind the scenes </span><code>NAME</code><span> is extracting the string for the symbol&apos;s name, manipulating it, and then reconstructing the symbol</span></div><div data-t="sophiago Oh, that&apos;s awesome. Such a common pain point."><span class="u" id="1526685778.000214">2018:05:18 23:22:58             sophiago </span><span>Oh, that&apos;s awesome. Such a common pain point.</span></div><div data-t="nathanmarz as for the subexpression identification part, that seems more involved"><span class="u" id="1526685830.000140">2018:05:18 23:23:50           nathanmarz </span><span>as for the subexpression identification part, that seems more involved</span></div><div data-t="sophiago Also, in your second example, shouldn&apos;t  [  be either  {:tag :a, :attrs {:href &quot;/cdn-cgi/l/email-protection&quot;, :class &quot;__cf_email__&quot;, :data-cfemail &quot;f38db3&quot;}, :content (&quot;[email protected]&quot;)}  or  {:tag :a, :attrs {:href &quot;/cdn-cgi/l/email-protection&quot;, :class &quot;__cf_email__&quot;, :data-cfemail &quot;403e00&quot;}, :content (&quot;[email protected]&quot;)} ?"><span class="u" id="1526685836.000230">2018:05:18 23:23:56             sophiago </span><span>Also, in your second example, shouldn&apos;t </span><code>[</code><span> be either </span><code>{:tag :a, :attrs {:href &quot;/cdn-cgi/l/email-protection&quot;, :class &quot;__cf_email__&quot;, :data-cfemail &quot;f38db3&quot;}, :content (&quot;[email protected]&quot;)}</code><span> or </span><code>{:tag :a, :attrs {:href &quot;/cdn-cgi/l/email-protection&quot;, :class &quot;__cf_email__&quot;, :data-cfemail &quot;403e00&quot;}, :content (&quot;[email protected]&quot;)}</code><span>?</span></div><div data-t="sophiago into  or  vec , I&apos;d have to look"><span class="u" id="1526685870.000133">2018:05:18 23:24:30             sophiago </span><code>into</code><span> or </span><code>vec</code><span>, I&apos;d have to look</span></div><div data-t="nathanmarz /cdn-cgi/l/email-protection  within  []  uniques and puts all the symbols into a vector"><span class="u" id="1526685885.000175">2018:05:18 23:24:45           nathanmarz </span><a href="/cdn-cgi/l/email-protection">/cdn-cgi/l/email-protection</a><span> within </span><code>[]</code><span> uniques and puts all the symbols into a vector</span></div><div data-t="sophiago Oh, I assumed you&apos;d end up with a set inside a vector"><span class="u" id="1526685915.000281">2018:05:18 23:25:15             sophiago </span><span>Oh, I assumed you&apos;d end up with a set inside a vector</span></div><div data-t="nathanmarz that would be if you did  ~psyms"><span class="u" id="1526685928.000008">2018:05:18 23:25:28           nathanmarz </span><span>that would be if you did </span><code>~psyms</code></div><div data-t="sophiago I don&apos;t want to belabor that point, but you&apos;re saying  psyms  would evaluate to a set? My assumption was it would be like:  [(set [&quot;foo&quot; &quot;foo&quot;])]  =&gt;  [#{&quot;foo&quot;}]"><span class="u" id="1526686094.000041">2018:05:18 23:28:14             sophiago </span><span>I don&apos;t want to belabor that point, but you&apos;re saying </span><code>psyms</code><span> would evaluate to a set? My assumption was it would be like: </span><code>[(set [&quot;foo&quot; &quot;foo&quot;])]</code><span> =&gt; </span><code>[#{&quot;foo&quot;}]</code></div><div data-t="sophiago Also, I think depending on how your navigator in the second example works I may just be able to just apply another  transform  on  TREE  to  expr  to replace the values and that&apos;s all I need."><span class="u" id="1526686281.000100">2018:05:18 23:31:21             sophiago </span><span>Also, I think depending on how your navigator in the second example works I may just be able to just apply another </span><code>transform</code><span> on </span><code>TREE</code><span> to </span><code>expr</code><span> to replace the values and that&apos;s all I need.</span></div><div data-t="nathanmarz oops meant to write  ~(set psyms)"><span class="u" id="1526686435.000099">2018:05:18 23:33:55           nathanmarz </span><span>oops meant to write </span><code>~(set psyms)</code></div><div data-t="sophiago Oh, okay. That makes more sense"><span class="u" id="1526686463.000214">2018:05:18 23:34:23             sophiago </span><span>Oh, okay. That makes more sense</span></div><div data-t="sophiago I&apos;m thinking through what a navigator for even this example would need to look like. It is a bit more involved than I initially assumed"><span class="u" id="1526686504.000060">2018:05:18 23:35:04             sophiago </span><span>I&apos;m thinking through what a navigator for even this example would need to look like. It is a bit more involved than I initially assumed</span></div><div data-t="sophiago For it to work top-down in one traversal, it would have to backtrack after it either reaches the next x in depth or the bottom of the tree. That&apos;s the only way to make sure it adds in each symbol in a  fn* [..]  at the correct level."><span class="u" id="1526686644.000067">2018:05:18 23:37:24             sophiago </span><span>For it to work top-down in one traversal, it would have to backtrack after it either reaches the next x in depth or the bottom of the tree. That&apos;s the only way to make sure it adds in each symbol in a </span><code>fn* [..]</code><span> at the correct level.</span></div><div data-t="nathanmarz I&apos;ve done similar things with dags before"><span class="u" id="1526686680.000184">2018:05:18 23:38:00           nathanmarz </span><span>I&apos;ve done similar things with dags before</span></div><div data-t="sophiago This all comes down to me not understanding Specter well enough to hack it out at this level of complexity"><span class="u" id="1526686709.000014">2018:05:18 23:38:29             sophiago </span><span>This all comes down to me not understanding Specter well enough to hack it out at this level of complexity</span></div><div data-t="nathanmarz in that algorithm each node has an id, and I look at the list of node ids to the root from everything I&apos;m trying to find the lowest common root for"><span class="u" id="1526686737.000145">2018:05:18 23:38:57           nathanmarz </span><span>in that algorithm each node has an id, and I look at the list of node ids to the root from everything I&apos;m trying to find the lowest common root for</span></div><div data-t="sophiago I can&apos;t tell whether that means it would work for my purposes as stands or not"><span class="u" id="1526686798.000107">2018:05:18 23:39:58             sophiago </span><span>I can&apos;t tell whether that means it would work for my purposes as stands or not</span></div><div data-t="nathanmarz you could do it with multiple passes by annotating a generated id metadata to all subexpressions, then find the path of ids to each instance of &quot;p&quot; symbols"><span class="u" id="1526686843.000179">2018:05:18 23:40:43           nathanmarz </span><span>you could do it with multiple passes by annotating a generated id metadata to all subexpressions, then find the path of ids to each instance of &quot;p&quot; symbols</span></div><div data-t="nathanmarz then with the paths its easy to identify which subexpressions to target in another pass"><span class="u" id="1526686864.000038">2018:05:18 23:41:04           nathanmarz </span><span>then with the paths its easy to identify which subexpressions to target in another pass</span></div><div data-t="sophiago Oh, the problem with your example is when to stop recursing on  expr  because if I replace all the way down I&apos;ll screw up the next match"><span class="u" id="1526686886.000123">2018:05:18 23:41:26             sophiago </span><span>Oh, the problem with your example is when to stop recursing on </span><code>expr</code><span> because if I replace all the way down I&apos;ll screw up the next match</span></div><div data-t="sophiago It does seem like multiple passes might be a good start. Then I can refactor to combine them. It&apos;s much easier if I can just have the navigator stop at the next px it sees."><span class="u" id="1526686999.000072">2018:05:18 23:43:19             sophiago </span><span>It does seem like multiple passes might be a good start. Then I can refactor to combine them. It&apos;s much easier if I can just have the navigator stop at the next px it sees.</span></div><div data-t="sophiago Another way to break it down would be to apply the second  transform  before the first and use just two passes. Then it can add in the bindings at common roots and eliminate the numerals in symbols in the next pass."><span class="u" id="1526687071.000219">2018:05:18 23:44:31             sophiago </span><span>Another way to break it down would be to apply the second </span><code>transform</code><span> before the first and use just two passes. Then it can add in the bindings at common roots and eliminate the numerals in symbols in the next pass.</span></div><div data-t="sophiago That seems to make the most sense from how I&apos;m grokking it now"><span class="u" id="1526687089.000027">2018:05:18 23:44:49             sophiago </span><span>That seems to make the most sense from how I&apos;m grokking it now</span></div><div data-t="sophiago I&apos;m just trying to get a feel for picking out the roots by applying it to input that just uses literal variables, e.g.  %1 , rather than an actual literal. But having it also expand  -&gt;&gt;  is making me unsure whether I&apos;m placing all the functions correctly. Regardless, they definitely should not be all stacked at the top in order of the  transform  calls like that."><span class="u" id="1526690938.000163">2018:05:19 00:48:58             sophiago </span><span>I&apos;m just trying to get a feel for picking out the roots by applying it to input that just uses literal variables, e.g. </span><code>%1</code><span>, rather than an actual literal. But having it also expand </span><code>-&gt;&gt;</code><span> is making me unsure whether I&apos;m placing all the functions correctly. Regardless, they definitely should not be all stacked at the top in order of the </span><code>transform</code><span> calls like that.</span></div><div data-t="nathanmarz it doesn&apos;t identify common roots"><span class="u" id="1526691871.000086">2018:05:19 01:04:31           nathanmarz </span><span>it doesn&apos;t identify common roots</span></div><div data-t="nathanmarz that snippet was just to show doing a transformation that wraps after identifying the expression to wrap"><span class="u" id="1526691913.000057">2018:05:19 01:05:13           nathanmarz </span><span>that snippet was just to show doing a transformation that wraps after identifying the expression to wrap</span></div><div data-t="sophiago Okay, gotcha. I would think the way I&apos;m recursing on it would at least update at the next level up, though. Right now they&apos;re at the top-level. I may just be confused by the expanded  -&gt;&gt;  though..."><span class="u" id="1526692684.000097">2018:05:19 01:18:04             sophiago </span><span>Okay, gotcha. I would think the way I&apos;m recursing on it would at least update at the next level up, though. Right now they&apos;re at the top-level. I may just be confused by the expanded </span><code>-&gt;&gt;</code><span> though...</span></div><div data-t="sophiago Yup, it&apos;s the expansion of  -&gt;&gt;  that&apos;s throwing me. I&apos;ll pay around with this and probably come back when I have something that works but seems could be more efficient. Thanks, @nathanmarz !"><span class="u" id="1526693040.000083">2018:05:19 01:24:00             sophiago </span><span>Yup, it&apos;s the expansion of </span><code>-&gt;&gt;</code><span> that&apos;s throwing me. I&apos;ll pay around with this and probably come back when I have something that works but seems could be more efficient. Thanks, @nathanmarz !</span></div><div data-t="sophiago I&apos;m still a bit confused about a navigator for this. I&apos;m currently calling  transform  in multiple passes for each pattern and figure I can bypass having to find common root bindings by enforcing linearity but, e.g.  (subselect TREE symbol? (selected? NAME pattern)) , navigates to a vector containing the first symbol matching the pattern rather than the coll containing that symbol."><span class="u" id="1526752664.000011">2018:05:19 17:57:44             sophiago </span><span>I&apos;m still a bit confused about a navigator for this. I&apos;m currently calling </span><code>transform</code><span> in multiple passes for each pattern and figure I can bypass having to find common root bindings by enforcing linearity but, e.g. </span><code>(subselect TREE symbol? (selected? NAME pattern))</code><span>, navigates to a vector containing the first symbol matching the pattern rather than the coll containing that symbol.</span></div><div data-t="nathanmarz subselect  navigates to the result of running  select  on that path"><span class="u" id="1526752959.000021">2018:05:19 18:02:39           nathanmarz </span><code>subselect</code><span> navigates to the result of running </span><code>select</code><span> on that path</span></div><div data-t="nathanmarz (select-any (subselect ALL :a even?) [{:a 1} {:a 2} {:a 4}])
;; =&gt; [2 4]

(transform (subselect ALL :a even?) reverse [{:a 1} {:a 2} {:a 4}])
;; =&gt; [{:a 1} {:a 4} {:a 2}]
"><span class="u" id="1526752961.000106">2018:05:19 18:02:41           nathanmarz </span><pre>(select-any (subselect ALL :a even?) [{:a 1} {:a 2} {:a 4}])
;; =&gt; [2 4]

(transform (subselect ALL :a even?) reverse [{:a 1} {:a 2} {:a 4}])
;; =&gt; [{:a 1} {:a 4} {:a 2}]
</pre></div><div data-t="sophiago Sorry, seems I misread the docs. Is there a navigator that will act like  contains?  on lists?"><span class="u" id="1526753086.000074">2018:05:19 18:04:46             sophiago </span><span>Sorry, seems I misread the docs. Is there a navigator that will act like </span><code>contains?</code><span> on lists?</span></div><div data-t="nathanmarz contains?  doesn&apos;t work on lists"><span class="u" id="1526753136.000084">2018:05:19 18:05:36           nathanmarz </span><code>contains?</code><span> doesn&apos;t work on lists</span></div><div data-t="nathanmarz since it&apos;s not keyed"><span class="u" id="1526753140.000118">2018:05:19 18:05:40           nathanmarz </span><span>since it&apos;s not keyed</span></div><div data-t="sophiago I know. I suppose like  some"><span class="u" id="1526753167.000103">2018:05:19 18:06:07             sophiago </span><span>I know. I suppose like </span><code>some</code></div><div data-t="nathanmarz you mean something like  (selected? ALL even?)  ?"><span class="u" id="1526753180.000126">2018:05:19 18:06:20           nathanmarz </span><span>you mean something like </span><code>(selected? ALL even?)</code><span> ?</span></div><div data-t="sophiago I suppose if I could replace  even?  with a pattern and then navigate to top-most coll containing the pattern?"><span class="u" id="1526753288.000086">2018:05:19 18:08:08             sophiago </span><span>I suppose if I could replace </span><code>even?</code><span> with a pattern and then navigate to top-most coll containing the pattern?</span></div><div data-t="sophiago I&apos;m realizing using  let  bindings for linearity throws a wrench in that, but I should be able to figure it out. Seems easier than finding common roots."><span class="u" id="1526753326.000024">2018:05:19 18:08:46             sophiago </span><span>I&apos;m realizing using </span><code>let</code><span> bindings for linearity throws a wrench in that, but I should be able to figure it out. Seems easier than finding common roots.</span></div><div data-t="sophiago I would think I could just do  (collect TREE (selected? symbol? NAME pattern))  where  TREE  navigates to every coll, but then it just stops at the top level every time."><span class="u" id="1526753533.000052">2018:05:19 18:12:13             sophiago </span><span>I would think I could just do </span><code>(collect TREE (selected? symbol? NAME pattern))</code><span> where </span><code>TREE</code><span> navigates to every coll, but then it just stops at the top level every time.</span></div><div data-t="nathanmarz if  TREE  navigates to collections, then that  selected?  clause will always fail"><span class="u" id="1526754402.000101">2018:05:19 18:26:42           nathanmarz </span><span>if </span><code>TREE</code><span> navigates to collections, then that </span><code>selected?</code><span> clause will always fail</span></div><div data-t="sophiago Ah, well that does seem to be what&apos;s happening. You&apos;re implying I could have it navigate to every item? I was thinking maybe I should just use a zipper and then could specify relative paths once a pattern is matched."><span class="u" id="1526754486.000049">2018:05:19 18:28:06             sophiago </span><span>Ah, well that does seem to be what&apos;s happening. You&apos;re implying I could have it navigate to every item? I was thinking maybe I should just use a zipper and then could specify relative paths once a pattern is matched.</span></div><div data-t="nathanmarz user=&gt; (setval (selected? symbol?) :replaced [&apos;a 2 &apos;b])
[a 2 b]
user=&gt; (setval (selected? ALL symbol?) :replaced [&apos;a 2 &apos;b])
:replaced
"><span class="u" id="1526754492.000136">2018:05:19 18:28:12           nathanmarz </span><pre>user=&gt; (setval (selected? symbol?) :replaced [&apos;a 2 &apos;b])
[a 2 b]
user=&gt; (setval (selected? ALL symbol?) :replaced [&apos;a 2 &apos;b])
:replaced
</pre></div><div data-t="sophiago If I can combine zipper navigators with regular ones then it would seem something like  [TREE symbol? NAME pattern z/UP]  might be the simplest way to do this."><span class="u" id="1526754627.000038">2018:05:19 18:30:27             sophiago </span><span>If I can combine zipper navigators with regular ones then it would seem something like </span><code>[TREE symbol? NAME pattern z/UP]</code><span> might be the simplest way to do this.</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers"><span class="u" id="1526754911.000081">2018:05:19 18:35:11           nathanmarz </span><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers">https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers</a></div><div data-t="sophiago Yup, reading now."><span class="u" id="1526754982.000036">2018:05:19 18:36:22             sophiago </span><span>Yup, reading now.</span></div><div data-t="sophiago I&apos;m just uncertain whether zipper navigators can be combined with regular ones. It&apos;d be much easier in this case than using predfns."><span class="u" id="1526755279.000075">2018:05:19 18:41:19             sophiago </span><span>I&apos;m just uncertain whether zipper navigators can be combined with regular ones. It&apos;d be much easier in this case than using predfns.</span></div><div data-t="sophiago The answer would seem to be no based on the examples"><span class="u" id="1526755366.000103">2018:05:19 18:42:46             sophiago </span><span>The answer would seem to be no based on the examples</span></div><div data-t="nathanmarz zipper navigators operate on zipper data structures"><span class="u" id="1526756756.000053">2018:05:19 19:05:56           nathanmarz </span><span>zipper navigators operate on zipper data structures</span></div><div data-t="nathanmarz use navigators like  VECTOR-ZIP  and  NODE  to navigate in and out of zippers"><span class="u" id="1526756792.000109">2018:05:19 19:06:32           nathanmarz </span><span>use navigators like </span><code>VECTOR-ZIP</code><span> and </span><code>NODE</code><span> to navigate in and out of zippers</span></div><div data-t="sophiago The structure that zippers return doesn&apos;t seem to make them ideal for use with  transform  though. I&apos;m having some luck with  [ALL seq? (fn [x] some #(= % (symbol pattern)) x)] : on the first pass it at least matches the  seq  immediately above the pattern."><span class="u" id="1526757524.000064">2018:05:19 19:18:44             sophiago </span><span>The structure that zippers return doesn&apos;t seem to make them ideal for use with </span><code>transform</code><span> though. I&apos;m having some luck with </span><code>[ALL seq? (fn [x] some #(= % (symbol pattern)) x)]</code><span>: on the first pass it at least matches the </span><code>seq</code><span> immediately above the pattern.</span></div><div data-t="nathanmarz you generally don&apos;t navigate to a zipper data structure for the transform fn, you use  NODE  to navigate into the value the zipper is currently pointing at"><span class="u" id="1526758093.000044">2018:05:19 19:28:13           nathanmarz </span><span>you generally don&apos;t navigate to a zipper data structure for the transform fn, you use </span><code>NODE</code><span> to navigate into the value the zipper is currently pointing at</span></div><div data-t="sophiago If I use  NODE  then it again locates the pattern rather than the  seq  containing the pattern, though."><span class="u" id="1526758397.000079">2018:05:19 19:33:17             sophiago </span><span>If I use </span><code>NODE</code><span> then it again locates the pattern rather than the </span><code>seq</code><span> containing the pattern, though.</span></div><div data-t="sophiago So  (select [SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) NODE] (list (list &apos;% &apos;foo)))  =&gt;  [%]  rather than  (% foo)"><span class="u" id="1526758432.000012">2018:05:19 19:33:52             sophiago </span><span>So </span><code>(select [SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) NODE] (list (list &apos;% &apos;foo)))</code><span> =&gt; </span><code>[%]</code><span> rather than </span><code>(% foo)</code></div><div data-t="sophiago And if I use  (select [SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) UP] (list (list &apos;% &apos;foo)))  then it&apos;s not really in a form that I can call  transform  on."><span class="u" id="1526758546.000107">2018:05:19 19:35:46             sophiago </span><span>And if I use </span><code>(select [SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) UP] (list (list &apos;% &apos;foo)))</code><span> then it&apos;s not really in a form that I can call </span><code>transform</code><span> on.</span></div><div data-t="sophiago I really just want something like  [TREE symbol? NAME #&quot;%&quot;]  except navigating to the seq containing the pattern."><span class="u" id="1526758625.000123">2018:05:19 19:37:05             sophiago </span><span>I really just want something like </span><code>[TREE symbol? NAME #&quot;%&quot;]</code><span> except navigating to the seq containing the pattern.</span></div><div data-t="sophiago Obviously I can call  ffirst  on the zipper version, but that doesn&apos;t really help if I want to transform it preserving the structure it&apos;s in."><span class="u" id="1526758818.000013">2018:05:19 19:40:18             sophiago </span><span>Obviously I can call </span><code>ffirst</code><span> on the zipper version, but that doesn&apos;t really help if I want to transform it preserving the structure it&apos;s in.</span></div><div data-t="nathanmarz @sophiago how is  [SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) UP NODE]  not exactly what you want?"><span class="u" id="1526763562.000081">2018:05:19 20:59:22           nathanmarz </span><span>@sophiago how is </span><code>[SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) UP NODE]</code><span> not exactly what you want?</span></div><div data-t="nathanmarz it navigates to  (% foo)"><span class="u" id="1526763572.000091">2018:05:19 20:59:32           nathanmarz </span><span>it navigates to </span><code>(% foo)</code></div><div data-t="nathanmarz user=&gt; (transform [SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) UP NODE]
  #_=&gt;   (fn [expr]
  #_=&gt;     `(:wrapped ~expr))
  #_=&gt;   &apos;(+ 1 (% foo)))
(+ 1 (:wrapped (% foo)))
"><span class="u" id="1526763667.000016">2018:05:19 21:01:07           nathanmarz </span><pre>user=&gt; (transform [SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) UP NODE]
  #_=&gt;   (fn [expr]
  #_=&gt;     `(:wrapped ~expr))
  #_=&gt;   &apos;(+ 1 (% foo)))
(+ 1 (:wrapped (% foo)))
</pre></div><div data-t="sophiago I think I neglected to try that combination  😕"><span class="u" id="1526763710.000081">2018:05:19 21:01:50             sophiago </span><span>I think I neglected to try that combination </span><b>😕</b></div><div data-t="sophiago One sec, I&apos;m trying it in the  transform"><span class="u" id="1526763719.000030">2018:05:19 21:01:59             sophiago </span><span>One sec, I&apos;m trying it in the </span><code>transform</code></div><div data-t="sophiago I think that&apos;s it  🙂"><span class="u" id="1526763906.000085">2018:05:19 21:05:06             sophiago </span><span>I think that&apos;s it </span><b>🙂</b></div><div data-t="sophiago Oh, it&apos;s missing patterns inside let bindings. I knew that would be an issue when I decided on linearity"><span class="u" id="1526763995.000006">2018:05:19 21:06:35             sophiago </span><span>Oh, it&apos;s missing patterns inside let bindings. I knew that would be an issue when I decided on linearity</span></div><div data-t="sophiago I think it may just work out that the bindings are at common roots as long as I call  setval  separately instead of from inside  transform"><span class="u" id="1526764278.000067">2018:05:19 21:11:18             sophiago </span><span>I think it may just work out that the bindings are at common roots as long as I call </span><code>setval</code><span> separately instead of from inside </span><code>transform</code></div><div data-t="nathanmarz fyi you can rewrite the  transform  like this:
 (transform
  [SEQ-ZIP
   (find-first #(= % (symbol pattern)))
   UP
   NODE
   (transformed [TREE symbol? NAME (re-pattern pattern)]
     (fn [_] (str fresh-var)))]
  #(list `fn* [fresh-var] %)
  x)
"><span class="u" id="1526764625.000093">2018:05:19 21:17:05           nathanmarz </span><span>fyi you can rewrite the </span><code>transform</code><span> like this:
</span><pre>(transform
  [SEQ-ZIP
   (find-first #(= % (symbol pattern)))
   UP
   NODE
   (transformed [TREE symbol? NAME (re-pattern pattern)]
     (fn [_] (str fresh-var)))]
  #(list `fn* [fresh-var] %)
  x)
</pre></div><div data-t="sophiago Yeah, the common roots issue is difficult and I can&apos;t get around it by using let bindings with linearity. But there&apos;s something deeper to say about what structures allow this navigator to finds them anyway and structures that cause trouble. Like I have one where a bound variable repeats and it&apos;s wrapped correctly and one where it&apos;s not. I tend to think the latter could be solved with destructuring in the example."><span class="u" id="1526765531.000028">2018:05:19 21:32:11             sophiago </span><span>Yeah, the common roots issue is difficult and I can&apos;t get around it by using let bindings with linearity. But there&apos;s something deeper to say about what structures allow this navigator to finds them anyway and structures that cause trouble. Like I have one where a bound variable repeats and it&apos;s wrapped correctly and one where it&apos;s not. I tend to think the latter could be solved with destructuring in the example.</span></div><div data-t="sophiago I think it actually comes down to currying. The one where it doesn&apos;t naturally find a root needs to be a binary function for  map-indexed . Calling  first  and  second  after interleaving and partitioning to use plain  map  creates the same type of structure."><span class="u" id="1526765804.000026">2018:05:19 21:36:44             sophiago </span><span>I think it actually comes down to currying. The one where it doesn&apos;t naturally find a root needs to be a binary function for </span><code>map-indexed</code><span>. Calling </span><code>first</code><span> and </span><code>second</code><span> after interleaving and partitioning to use plain </span><code>map</code><span> creates the same type of structure.</span></div><div data-t="flowthing So I have a map like this:  {&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}} . I need to transform  &quot;foo&quot; , but I need to collect some of the map keys (`&quot;2018-05-22&quot;` and  :A ) along the way for the transformation function and I can&apos;t quite figure out how to do it."><span class="u" id="1526993315.000455">2018:05:22 12:48:35            flowthing </span><span>So I have a map like this: </span><code>{&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}}</code><span>. I need to transform </span><code>&quot;foo&quot;</code><span>, but I need to collect some of the map keys (`&quot;2018-05-22&quot;` and </span><code>:A</code><span>) along the way for the transformation function and I can&apos;t quite figure out how to do it.</span></div><div data-t="nathanmarz @flowthing How do you need to navigate to &quot;foo&quot;? Recursively?"><span class="u" id="1526998732.000070">2018:05:22 14:18:52           nathanmarz </span><span>@flowthing How do you need to navigate to &quot;foo&quot;? Recursively?</span></div><div data-t="flowthing With  MAP-VALS . Basically, I&apos;m doing something like this:

 (specter/transform [specter/MAP-VALS specter/MAP-VALS specter/MAP-VALS] (fn [&amp; args] ,,,) {&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}})
 

And I&apos;m wondering whether I can write the path such that the transformation fn gets  &quot;2018-05-22&quot;  and  :A  as arguments (in addition to  &quot;foo&quot; )."><span class="u" id="1526998972.000816">2018:05:22 14:22:52            flowthing </span><span>With </span><code>MAP-VALS</code><span>. Basically, I&apos;m doing something like this:

</span><pre>(specter/transform [specter/MAP-VALS specter/MAP-VALS specter/MAP-VALS] (fn [&amp; args] ,,,) {&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}})
</pre><span>

And I&apos;m wondering whether I can write the path such that the transformation fn gets </span><code>&quot;2018-05-22&quot;</code><span> and </span><code>:A</code><span> as arguments (in addition to </span><code>&quot;foo&quot;</code><span>).</span></div><div data-t="nathanmarz @flowthing yes, you want to make use of collection navigators"><span class="u" id="1526999151.000309">2018:05:22 14:25:51           nathanmarz </span><span>@flowthing yes, you want to make use of collection navigators</span></div><div data-t="nathanmarz (def MAP-VALS+ (path ALL (collect-one FIRST) LAST))
(transform [MAP-VALS+ MAP-VALS+ MAP-VALS]
  (fn [k1 k2 v]
    [k1 k2 v]
    )
  {&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}})
"><span class="u" id="1526999153.000347">2018:05:22 14:25:53           nathanmarz </span><pre>(def MAP-VALS+ (path ALL (collect-one FIRST) LAST))
(transform [MAP-VALS+ MAP-VALS+ MAP-VALS]
  (fn [k1 k2 v]
    [k1 k2 v]
    )
  {&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}})
</pre></div><div data-t="flowthing Perfect, thank you!"><span class="u" id="1526999821.000139">2018:05:22 14:37:01            flowthing </span><span>Perfect, thank you!</span></div><div data-t="flowthing I couldn&apos;t figure out how to compose  MAP-VALS+  myself."><span class="u" id="1526999883.000334">2018:05:22 14:38:03            flowthing </span><span>I couldn&apos;t figure out how to compose </span><code>MAP-VALS+</code><span> myself.</span></div><div data-t="sophiago @nathanmarz ironically enough I needed to also write a version of the macro I was struggling with over the weekend that does just stack the lambda bindings at the top of the AST and replaces all instances of corresponding locals. I did this as before by calling  setval  from inside  transform , which I get the sense is not an ideal way to use Specter, but don&apos;t fully understand how you rewrote it to use  transformed  inside the navigator."><span class="u" id="1527033801.000205">2018:05:23 00:03:21             sophiago </span><span>@nathanmarz ironically enough I needed to also write a version of the macro I was struggling with over the weekend that does just stack the lambda bindings at the top of the AST and replaces all instances of corresponding locals. I did this as before by calling </span><code>setval</code><span> from inside </span><code>transform</code><span>, which I get the sense is not an ideal way to use Specter, but don&apos;t fully understand how you rewrote it to use </span><code>transformed</code><span> inside the navigator.</span></div><div data-t="nathanmarz @sophiago it&apos;ll be easier to understand the navigators if you play with them on toy examples"><span class="u" id="1527042259.000034">2018:05:23 02:24:19           nathanmarz </span><span>@sophiago it&apos;ll be easier to understand the navigators if you play with them on toy examples</span></div><div data-t="sophiago True. I tell myself I&apos;m testing these on the simplest functions, but they&apos;re still macros doing fairly heavy source transformation. It seems clear the issue here is that I&apos;m trying to apply  transformed  directly to a symbol, and only the first one that matches as well, rather than in example you gave where it&apos;s one level up from the node in a zipper."><span class="u" id="1527042905.000145">2018:05:23 02:35:05             sophiago </span><span>True. I tell myself I&apos;m testing these on the simplest functions, but they&apos;re still macros doing fairly heavy source transformation. It seems clear the issue here is that I&apos;m trying to apply </span><code>transformed</code><span> directly to a symbol, and only the first one that matches as well, rather than in example you gave where it&apos;s one level up from the node in a zipper.</span></div><div data-t="sophiago I suppose it&apos;s just the combination of learning what&apos;s essentially a whole DSL and wanting to use it immediately given how well it fits so many of my problems. For example, it would seem calling  setval  from inside  transform  as in the first example shouldn&apos;t cause a significant hit in perf, but I&apos;d have to actually look at your macros or at least reread the wiki page about caching to make that judgment for sure. At least your docs are quite good  🙂"><span class="u" id="1527043124.000153">2018:05:23 02:38:44             sophiago </span><span>I suppose it&apos;s just the combination of learning what&apos;s essentially a whole DSL and wanting to use it immediately given how well it fits so many of my problems. For example, it would seem calling </span><code>setval</code><span> from inside </span><code>transform</code><span> as in the first example shouldn&apos;t cause a significant hit in perf, but I&apos;d have to actually look at your macros or at least reread the wiki page about caching to make that judgment for sure. At least your docs are quite good </span><b>🙂</b></div><div data-t="huthayfa hello guys, I am new to specter library. does anyone of you know which function is used to navigate the entire data structure tree and manipulate specific key"><span class="u" id="1527106169.000109">2018:05:23 20:09:29             huthayfa </span><span>hello guys, I am new to specter library. does anyone of you know which function is used to navigate the entire data structure tree and manipulate specific key</span></div><div data-t="huthayfa without providing a path to the key"><span class="u" id="1527106280.000319">2018:05:23 20:11:20             huthayfa </span><span>without providing a path to the key</span></div><div data-t="tanzoniteblack @huthayfa.ainqawi that&apos;s a little vague, can you give a minimal example of what you&apos;re working with and what you&apos;re trying to get to?"><span class="u" id="1527106287.000125">2018:05:23 20:11:27       tanzoniteblack </span><span>@huthayfa.ainqawi that&apos;s a little vague, can you give a minimal example of what you&apos;re working with and what you&apos;re trying to get to?</span></div><div data-t="huthayfa {
            &quot;key&quot;: &quot;hsq.contentjsonsample.sampleKey&quot;,
            &quot;value&quot;: {
               &quot;links&quot;:[{&quot;text&quot;:&quot;anytext&quot;,&quot;url&quot;:&quot; http://nowhere.com &quot;,&quot;precedence&quot;:&quot;1&quot;},{&quot;text&quot;:&quot;anytext&quot;,&quot;url&quot;:&quot; http://nowhere.com &quot;,&quot;precedence&quot;:&quot;2&quot;}],
               &quot;misc&quot;:[{&quot;key&quot;:&quot;keyName&quot;,&quot;value&quot;:&quot;valuessssssss&quot;},{&quot;key&quot;:&quot;keyName&quot;,&quot;value&quot;:&quot;valuessssssss&quot;}],
               &quot;assets&quot;:[{&quot;name&quot;:&quot;facebooklogo&quot;,&quot;location&quot;:&quot;/s3/cmb/facebooklogo.png&quot;,&quot;type&quot;:&quot;image&quot;},{&quot;name&quot;:&quot;mypdf&quot;,&quot;location&quot;:&quot;/pdfLocation&quot;,&quot;type&quot;:&quot;pdf&quot;}],
             },
            &quot;language&quot;:&quot;EN&quot;,
            &quot;shortName&quot;: &quot;my Sample Json key&quot;,
            &quot;description&quot;: &quot;my Sample Json key explain why this key&quot;
          }"><span class="u" id="1527106335.000722">2018:05:23 20:12:15             huthayfa </span><span>{
            &quot;key&quot;: &quot;hsq.contentjsonsample.sampleKey&quot;,
            &quot;value&quot;: {
               &quot;links&quot;:[{&quot;text&quot;:&quot;anytext&quot;,&quot;url&quot;:&quot;</span><a href="http://nowhere.com">http://nowhere.com</a><span>&quot;,&quot;precedence&quot;:&quot;1&quot;},{&quot;text&quot;:&quot;anytext&quot;,&quot;url&quot;:&quot;</span><a href="http://nowhere.com">http://nowhere.com</a><span>&quot;,&quot;precedence&quot;:&quot;2&quot;}],
               &quot;misc&quot;:[{&quot;key&quot;:&quot;keyName&quot;,&quot;value&quot;:&quot;valuessssssss&quot;},{&quot;key&quot;:&quot;keyName&quot;,&quot;value&quot;:&quot;valuessssssss&quot;}],
               &quot;assets&quot;:[{&quot;name&quot;:&quot;facebooklogo&quot;,&quot;location&quot;:&quot;/s3/cmb/facebooklogo.png&quot;,&quot;type&quot;:&quot;image&quot;},{&quot;name&quot;:&quot;mypdf&quot;,&quot;location&quot;:&quot;/pdfLocation&quot;,&quot;type&quot;:&quot;pdf&quot;}],
             },
            &quot;language&quot;:&quot;EN&quot;,
            &quot;shortName&quot;: &quot;my Sample Json key&quot;,
            &quot;description&quot;: &quot;my Sample Json key explain why this key&quot;
          }</span></div><div data-t="huthayfa wherever there is assets key, I want to manipulate it"><span class="u" id="1527106366.000369">2018:05:23 20:12:46             huthayfa </span><span>wherever there is assets key, I want to manipulate it</span></div><div data-t="tanzoniteblack I suspect you want  https://github.com/nathanmarz/specter/wiki/List-of-Navigators#walker"><span class="u" id="1527106379.000773">2018:05:23 20:12:59       tanzoniteblack </span><span>I suspect you want </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#walker">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#walker</a></div><div data-t="tanzoniteblack that said,  walker  is generally something I consider a &quot;I have no idea what data&apos;s coming in, and I have no control over the format, and I&apos;m ok with accidentally manipulating other keys that just happen to be called that&quot;, which is pretty heavy handed &amp; crude"><span class="u" id="1527106484.000626">2018:05:23 20:14:44       tanzoniteblack </span><span>that said, </span><code>walker</code><span> is generally something I consider a &quot;I have no idea what data&apos;s coming in, and I have no control over the format, and I&apos;m ok with accidentally manipulating other keys that just happen to be called that&quot;, which is pretty heavy handed &amp; crude</span></div><div data-t="tanzoniteblack so if you can narrow your path down to more (like,  assets  will always be inside a map stored at  links , or something) it can help to prevent random bugs"><span class="u" id="1527106529.000410">2018:05:23 20:15:29       tanzoniteblack </span><span>so if you can narrow your path down to more (like, </span><code>assets</code><span> will always be inside a map stored at </span><code>links</code><span>, or something) it can help to prevent random bugs</span></div><div data-t="schmee you don’t need specter for this, you can use  update  from core:  (update your-map :assets update-fn)"><span class="u" id="1527106544.000616">2018:05:23 20:15:44               schmee </span><span>you don’t need specter for this, you can use </span><code>update</code><span> from core: </span><code>(update your-map :assets update-fn)</code></div><div data-t="tanzoniteblack @schmee  update  will only do it if you are directly manipulating a map, not if you need to find a map nested in a bigger data structure"><span class="u" id="1527106577.000314">2018:05:23 20:16:17       tanzoniteblack </span><span>@schmee </span><code>update</code><span> will only do it if you are directly manipulating a map, not if you need to find a map nested in a bigger data structure</span></div><div data-t="huthayfa @schmee does update do a nested map search"><span class="u" id="1527106589.000276">2018:05:23 20:16:29             huthayfa </span><span>@schmee does update do a nested map search</span></div><div data-t="tanzoniteblack (or multiple maps nested in a bigger structure)"><span class="u" id="1527106589.000356">2018:05:23 20:16:29       tanzoniteblack </span><span>(or multiple maps nested in a bigger structure)</span></div><div data-t="schmee well, you need to specify what this larger data structure looks like in order to get a sensible answer"><span class="u" id="1527106646.000316">2018:05:23 20:17:26               schmee </span><span>well, you need to specify what this larger data structure looks like in order to get a sensible answer</span></div><div data-t="huthayfa I don&apos;t know where the assets happen in the structure, maybe at second or third level"><span class="u" id="1527106683.000551">2018:05:23 20:18:03             huthayfa </span><span>I don&apos;t know where the assets happen in the structure, maybe at second or third level</span></div><div data-t="huthayfa it depends on the jsonSchema"><span class="u" id="1527106690.000623">2018:05:23 20:18:10             huthayfa </span><span>it depends on the jsonSchema</span></div><div data-t="nathanmarz @huthayfa.ainqawi this code will run on every nested assets key with a walk that descends into all collections and map values (but not map keys):
 (def NESTED-MAPS
  (recursive-path [] p
    (cond-path map? (continue-then-stay MAP-VALS p)
               coll? [ALL p]
               )))

(transform [NESTED-MAPS (must &quot;assets&quot;)] my-transform-fn data)
"><span class="u" id="1527107099.000658">2018:05:23 20:24:59           nathanmarz </span><span>@huthayfa.ainqawi this code will run on every nested assets key with a walk that descends into all collections and map values (but not map keys):
</span><pre>(def NESTED-MAPS
  (recursive-path [] p
    (cond-path map? (continue-then-stay MAP-VALS p)
               coll? [ALL p]
               )))

(transform [NESTED-MAPS (must &quot;assets&quot;)] my-transform-fn data)
</pre></div><div data-t="huthayfa so the value returned from the NESTED-MAPS will replace the current value, right ?"><span class="u" id="1527107289.000709">2018:05:23 20:28:09             huthayfa </span><span>so the value returned from the NESTED-MAPS will replace the current value, right ?</span></div><div data-t="huthayfa @nathanmarz"><span class="u" id="1527107336.000678">2018:05:23 20:28:56             huthayfa </span><span>@nathanmarz</span></div><div data-t="huthayfa oh sorry, I didn&apos;t see my-transform-fn"><span class="u" id="1527107450.000307">2018:05:23 20:30:50             huthayfa </span><span>oh sorry, I didn&apos;t see my-transform-fn</span></div><div data-t="huthayfa @nathanmarz thank you so much"><span class="u" id="1527107465.000720">2018:05:23 20:31:05             huthayfa </span><span>@nathanmarz thank you so much</span></div><div data-t="huthayfa is there a function to collect the path to a given key"><span class="u" id="1527196608.000406">2018:05:24 21:16:48             huthayfa </span><span>is there a function to collect the path to a given key</span></div><div data-t="huthayfa if i have map like this {&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot;}}}, I want to collect the path to target-key which is [properties assets target-key]"><span class="u" id="1527196928.000080">2018:05:24 21:22:08             huthayfa </span><span>if i have map like this {&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot;}}}, I want to collect the path to target-key which is [properties assets target-key]</span></div><div data-t="huthayfa is there a function in specter that does this"><span class="u" id="1527196944.000634">2018:05:24 21:22:24             huthayfa </span><span>is there a function in specter that does this</span></div><div data-t="nathanmarz @huthayfa.ainqawi use the  collect  navigators"><span class="u" id="1527199122.000222">2018:05:24 21:58:42           nathanmarz </span><span>@huthayfa.ainqawi use the </span><code>collect</code><span> navigators</span></div><div data-t="nathanmarz someone just asked this recently"><span class="u" id="1527199155.000449">2018:05:24 21:59:15           nathanmarz </span><span>someone just asked this recently</span></div><div data-t="nathanmarz here&apos;s a code example:
 (def MAP-VALS+ (path ALL (collect-one FIRST) LAST))
(transform [MAP-VALS+ MAP-VALS+ MAP-VALS]
  (fn [k1 k2 v]
    [k1 k2 v]
    )
  {&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}})
"><span class="u" id="1527199164.000417">2018:05:24 21:59:24           nathanmarz </span><span>here&apos;s a code example:
</span><pre>(def MAP-VALS+ (path ALL (collect-one FIRST) LAST))
(transform [MAP-VALS+ MAP-VALS+ MAP-VALS]
  (fn [k1 k2 v]
    [k1 k2 v]
    )
  {&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}})
</pre></div><div data-t="huthayfa @nathanmarz how do I select the target key"><span class="u" id="1527201154.000350">2018:05:24 22:32:34             huthayfa </span><span>@nathanmarz how do I select the target key</span></div><div data-t="nathanmarz @huthayfa.ainqawi it&apos;ll be easier to help you if you give an example of the input and output you want"><span class="u" id="1527208411.000081">2018:05:25 00:33:31           nathanmarz </span><span>@huthayfa.ainqawi it&apos;ll be easier to help you if you give an example of the input and output you want</span></div><div data-t="huthayfa @nathanmarz input  {&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot;}}}  output: [properties assets target-key]"><span class="u" id="1527213654.000288">2018:05:25 02:00:54             huthayfa </span><span>@nathanmarz input  {&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot;}}}  output: [properties assets target-key]</span></div><div data-t="huthayfa input  ({&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot;}}}, target-key)   output: [properties assets target-key]"><span class="u" id="1527213690.000068">2018:05:25 02:01:30             huthayfa </span><span>input  ({&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot;}}}, target-key)   output: [properties assets target-key]</span></div><div data-t="nathanmarz @huthayfa.ainqawi that input isn&apos;t well formed"><span class="u" id="1527216147.000243">2018:05:25 02:42:27           nathanmarz </span><span>@huthayfa.ainqawi that input isn&apos;t well formed</span></div><div data-t="huthayfa input  ({&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot; &quot;value&quot;}}}, target-key) nested map"><span class="u" id="1527218427.000175">2018:05:25 03:20:27             huthayfa </span><span>input  ({&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot; &quot;value&quot;}}}, target-key) nested map</span></div><div data-t="fmn Hi, how do you navigate data structures with specter lazily? What I&apos;m trying to do is select the first item with matching predicate like this:

 (-&gt;&gt; very-long-vector
     (transform [ALL] my-fn)
     (select-first [ALL my-pred?]))
 

I believe doing that won&apos;t be very efficient since specter will &quot;realize&quot; each step"><span class="u" id="1527252214.000546">2018:05:25 12:43:34                  fmn </span><span>Hi, how do you navigate data structures with specter lazily? What I&apos;m trying to do is select the first item with matching predicate like this:

</span><pre>(-&gt;&gt; very-long-vector
     (transform [ALL] my-fn)
     (select-first [ALL my-pred?]))
</pre><span>

I believe doing that won&apos;t be very efficient since specter will &quot;realize&quot; each step</span></div><div data-t="nathanmarz @funyako.funyao156 there is no lazy computation with specter"><span class="u" id="1527254580.000445">2018:05:25 13:23:00           nathanmarz </span><span>@funyako.funyao156 there is no lazy computation with specter</span></div><div data-t="nathanmarz but if you do  (select-first [ALL (view my-fn) my-pred?] very-long-vector)  it will stop traversing the vector as soon as  my-pred?  is satisfied"><span class="u" id="1527254614.000252">2018:05:25 13:23:34           nathanmarz </span><span>but if you do </span><code>(select-first [ALL (view my-fn) my-pred?] very-long-vector)</code><span> it will stop traversing the vector as soon as </span><code>my-pred?</code><span> is satisfied</span></div><div data-t="fmn @nathanmarz so the  select-first  behave similar to  (first (filter pred ...))  in terms of &quot;lazy like&quot; ? Thanks!"><span class="u" id="1527255791.000397">2018:05:25 13:43:11                  fmn </span><span>@nathanmarz so the </span><code>select-first</code><span> behave similar to </span><code>(first (filter pred ...))</code><span> in terms of &quot;lazy like&quot; ? Thanks!</span></div><div data-t="nathanmarz @funyako.funyao156 it works via early termination"><span class="u" id="1527258007.000186">2018:05:25 14:20:07           nathanmarz </span><span>@funyako.funyao156 it works via early termination</span></div><div data-t="nathanmarz it uses  reduced /`reduced?` under the hood"><span class="u" id="1527258041.000006">2018:05:25 14:20:41           nathanmarz </span><span>it uses </span><code>reduced</code><span>/`reduced?` under the hood</span></div><div data-t="fmn @nathanmarz Thanks alot for answering me! Last one, sorry if I ask a lot. How do you return default value using  select-first  if no matching element found, for example:

 (select-first [ALL keyword? (nil-&gt;val :foo/bar)] [1 2 3])
 

That still return a nil."><span class="u" id="1527258152.000149">2018:05:25 14:22:32                  fmn </span><span>@nathanmarz Thanks alot for answering me! Last one, sorry if I ask a lot. How do you return default value using </span><code>select-first</code><span> if no matching element found, for example:

</span><pre>(select-first [ALL keyword? (nil-&gt;val :foo/bar)] [1 2 3])
</pre><span>

That still return a nil.</span></div><div data-t="nathanmarz that code never gets to the  nil-&gt;val  navigator since  keyword?  filters everything out"><span class="u" id="1527258481.000535">2018:05:25 14:28:01           nathanmarz </span><span>that code never gets to the </span><code>nil-&gt;val</code><span> navigator since </span><code>keyword?</code><span> filters everything out</span></div><div data-t="nathanmarz you can just do  (or (select-first [ALL keyword?] [1 2 3]) :foo/bar)"><span class="u" id="1527258501.000254">2018:05:25 14:28:21           nathanmarz </span><span>you can just do </span><code>(or (select-first [ALL keyword?] [1 2 3]) :foo/bar)</code></div><div data-t="fmn Right, silly me. Sorry I ask alot! Thanks again!"><span class="u" id="1527258548.000807">2018:05:25 14:29:08                  fmn </span><span>Right, silly me. Sorry I ask alot! Thanks again!</span></div><div data-t="nathanmarz no problem, that&apos;s what this channel is for"><span class="u" id="1527258624.000846">2018:05:25 14:30:24           nathanmarz </span><span>no problem, that&apos;s what this channel is for</span></div><div data-t="nathanmarz @huthayfa.ainqawi 
 user=&gt; (def MAP-VALS+ (path ALL (collect-one FIRST) LAST))
#&apos;user/MAP-VALS+
user=&gt; (select-any [MAP-VALS+ MAP-VALS+ MAP-KEYS] {&quot;properties&quot; { &quot;assets&quot; {&quot;target-key&quot; &quot;value&quot;}}})
[&quot;properties&quot; &quot;assets&quot; &quot;target-key&quot;]
"><span class="u" id="1527258764.000345">2018:05:25 14:32:44           nathanmarz </span><span>@huthayfa.ainqawi 
</span><pre>user=&gt; (def MAP-VALS+ (path ALL (collect-one FIRST) LAST))
#&apos;user/MAP-VALS+
user=&gt; (select-any [MAP-VALS+ MAP-VALS+ MAP-KEYS] {&quot;properties&quot; { &quot;assets&quot; {&quot;target-key&quot; &quot;value&quot;}}})
[&quot;properties&quot; &quot;assets&quot; &quot;target-key&quot;]
</pre></div><div data-t="johanatan has anyone tried 1.1.1 w/ deps.edn and lumo ?"><span class="u" id="1527709062.000249">2018:05:30 19:37:42            johanatan </span><span>has anyone tried 1.1.1 w/ deps.edn and lumo ?</span></div><div data-t="johanatan I am getting:

 Could not require com.rpl.specter.navs in file com/rpl/specter.cljc
	 (new)
	 Function.cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:2024:72)
	 Function.cljs.analyzer.error.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:2639:92)
	 Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5954:145)
	 Function.cljs.js.load_deps.cljs$core$IFn$_invoke$arity$7 (NO_SOURCE_FILE &lt;embedded&gt;:5965:119)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5965:570)
	 Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5943:1)
	 Function.cljs.js.load_deps.cljs$core$IFn$_invoke$arity$7 (NO_SOURCE_FILE &lt;embedded&gt;:5965:119)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5965:570)
	 Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5943:1)

Maximum call stack size exceeded
	 (NO_SOURCE_FILE &lt;embedded&gt;:6625:177)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6120:138)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6010:425)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6024:218)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5968:270)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5947:36)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6120:138)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6010:425)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6024:218)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5968:270)
 

when I do so."><span class="u" id="1527709081.000291">2018:05:30 19:38:01            johanatan </span><span>I am getting:

</span><pre>Could not require com.rpl.specter.navs in file com/rpl/specter.cljc
	 (new)
	 Function.cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:2024:72)
	 Function.cljs.analyzer.error.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:2639:92)
	 Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5954:145)
	 Function.cljs.js.load_deps.cljs$core$IFn$_invoke$arity$7 (NO_SOURCE_FILE &lt;embedded&gt;:5965:119)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5965:570)
	 Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5943:1)
	 Function.cljs.js.load_deps.cljs$core$IFn$_invoke$arity$7 (NO_SOURCE_FILE &lt;embedded&gt;:5965:119)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5965:570)
	 Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5943:1)

Maximum call stack size exceeded
	 (NO_SOURCE_FILE &lt;embedded&gt;:6625:177)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6120:138)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6010:425)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6024:218)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5968:270)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5947:36)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6120:138)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6010:425)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6024:218)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5968:270)
</pre><span>

when I do so.</span></div><div data-t="nathanmarz @johanatan don&apos;t see how that would have anything to do with specter, #tools-deps is probably a better place to ask"><span class="u" id="1527711727.000192">2018:05:30 20:22:07           nathanmarz </span><span>@johanatan don&apos;t see how that would have anything to do with specter, #tools-deps is probably a better place to ask</span></div><div data-t="johanatan well specter is the only dep that this method is failing for"><span class="u" id="1527711760.000505">2018:05:30 20:22:40            johanatan </span><span>well specter is the only dep that this method is failing for</span></div><div data-t="johanatan have you tried it?"><span class="u" id="1527711767.000562">2018:05:30 20:22:47            johanatan </span><span>have you tried it?</span></div><div data-t="johanatan apparently the lib needs to be cljs self-host compatible (not sure if specter is)"><span class="u" id="1527711783.000002">2018:05:30 20:23:03            johanatan </span><span>apparently the lib needs to be cljs self-host compatible (not sure if specter is)</span></div><div data-t="nathanmarz ah, well that would explain it"><span class="u" id="1527711923.000262">2018:05:30 20:25:23           nathanmarz </span><span>ah, well that would explain it</span></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/issues/136"><span class="u" id="1527711937.000210">2018:05:30 20:25:37           nathanmarz </span><a href="https://github.com/nathanmarz/specter/issues/136">https://github.com/nathanmarz/specter/issues/136</a></div><div data-t="johanatan @nathanmarz thx!"><span class="u" id="1527712707.000355">2018:05:30 20:38:27            johanatan </span><span>@nathanmarz thx!</span></div><div data-t="johanatan do you have any plan to fix it? should I create an issue to track it?"><span class="u" id="1527712724.000563">2018:05:30 20:38:44            johanatan </span><span>do you have any plan to fix it? should I create an issue to track it?</span></div><div data-t="nathanmarz that is the issue to track it"><span class="u" id="1527714517.000616">2018:05:30 21:08:37           nathanmarz </span><span>that is the issue to track it</span></div><div data-t="nathanmarz no plans to fix it since I don&apos;t use clojurescript"><span class="u" id="1527714529.000707">2018:05:30 21:08:49           nathanmarz </span><span>no plans to fix it since I don&apos;t use clojurescript</span></div><div data-t="nathanmarz a pull request for it would be welcome though"><span class="u" id="1527714544.000231">2018:05:30 21:09:04           nathanmarz </span><span>a pull request for it would be welcome though</span></div><div data-t="johanatan oh, sorry. i thought that was on the planck project (didn&apos;t look at the url)"><span class="u" id="1527717812.000113">2018:05:30 22:03:32            johanatan </span><span>oh, sorry. i thought that was on the planck project (didn&apos;t look at the url)</span></div><div data-t="punit-naik Hi Guys! I was just starting out with Specter. I had a few questions.
1. Are there error-handling functions implemented inside specter? Can I get errors as to where my navigator failed?
2. Can it work with lazy seqs? Will the laziness be preserved?
3. Can we use reducers in  setval ?"><span class="u" id="1527948246.000101">2018:06:02 14:04:06           punit-naik </span><span>Hi Guys! I was just starting out with Specter. I had a few questions.
1. Are there error-handling functions implemented inside specter? Can I get errors as to where my navigator failed?
2. Can it work with lazy seqs? Will the laziness be preserved?
3. Can we use reducers in </span><code>setval</code><span>?</span></div><div data-t="nathanmarz @punit-naik there&apos;s no particular error handling done by specter"><span class="u" id="1527948582.000094">2018:06:02 14:09:42           nathanmarz </span><span>@punit-naik there&apos;s no particular error handling done by specter</span></div><div data-t="nathanmarz I can usually tell where I messed up a path by looking at the stack trace"><span class="u" id="1527948594.000100">2018:06:02 14:09:54           nathanmarz </span><span>I can usually tell where I messed up a path by looking at the stack trace</span></div><div data-t="punit-naik So when I run  (transform [ALL :a] inc [{:a 1 :b 2} {:a 2 :b 1} {:b 3}]) , I get a very simple  Nullpointer exception  which is because the  nil  case is not handled by the  inc  fn. But don&apos;t you think one should get a more detailed exception like  :a key not found at index 2 ?"><span class="u" id="1527950024.000121">2018:06:02 14:33:44                punit-naik </span><span>So when I run </span><code>(transform [ALL :a] inc [{:a 1 :b 2} {:a 2 :b 1} {:b 3}])</code><span>, I get a very simple </span><code>Nullpointer exception</code><span> which is because the </span><code>nil</code><span> case is not handled by the </span><code>inc</code><span> fn. But don&apos;t you think one should get a more detailed exception like </span><code>:a key not found at index 2</code><span>?</span></div><div data-t="nathanmarz specter will never produce a lazy output"><span class="u" id="1527948642.000044">2018:06:02 14:10:42           nathanmarz </span><span>specter will never produce a lazy output</span></div><div data-t="punit-naik I tried running  (def x (lazy-seq [1 2 3 4])) (time (cons (inc (first x)) (rest x)))  and  (time (transform FIRST inc x))  and the running times for them were  0.08 msecs  and  0.5 msecs . Is this a considerable enough difference? So is specter indeed evaluating the entire lazy list?"><span class="u" id="1527951659.000124">2018:06:02 15:00:59                punit-naik </span><span>I tried running </span><code>(def x (lazy-seq [1 2 3 4])) (time (cons (inc (first x)) (rest x)))</code><span> and </span><code>(time (transform FIRST inc x))</code><span> and the running times for them were </span><code>0.08 msecs</code><span> and </span><code>0.5 msecs</code><span>. Is this a considerable enough difference? So is specter indeed evaluating the entire lazy list?</span></div><div data-t="nathanmarz though using  select-first  can accomplish many of the same things since it terminates navigation as soon as it encounters a matching value"><span class="u" id="1527948687.000115">2018:06:02 14:11:27           nathanmarz </span><span>though using </span><code>select-first</code><span> can accomplish many of the same things since it terminates navigation as soon as it encounters a matching value</span></div><div data-t="nathanmarz don&apos;t know what you mean by #3"><span class="u" id="1527948695.000052">2018:06:02 14:11:35           nathanmarz </span><span>don&apos;t know what you mean by #3</span></div><div data-t="nathanmarz don&apos;t know what you mean by #3"><span class="u" id="1527948695.000052">2018:06:02 14:11:35           nathanmarz </span><span>don&apos;t know what you mean by #3</span></div><div data-t="punit-naik What I meant was, is there a way to perform  reduce  using  navigators? I am thinking of using  select  for this. Am I correct?"><span class="u" id="1527951816.000121">2018:06:02 15:03:36                punit-naik </span><span>What I meant was, is there a way to perform </span><code>reduce</code><span> using  navigators? I am thinking of using </span><code>select</code><span> for this. Am I correct?</span></div><div data-t="nathanmarz @punit-naik the most efficient way to reduce over navigated values is with  traverse"><span class="u" id="1527952478.000009">2018:06:02 15:14:38           nathanmarz </span><span>@punit-naik the most efficient way to reduce over navigated values is with </span><code>traverse</code></div><div data-t="nathanmarz https://github.com/nathanmarz/specter/wiki/List-of-Macros#traverse"><span class="u" id="1527952496.000086">2018:06:02 15:14:56           nathanmarz </span><a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#traverse">https://github.com/nathanmarz/specter/wiki/List-of-Macros#traverse</a></div><div data-t="nathanmarz timing a single invocation tells you absolutely nothing, since neither specter nor the jvm have had a chance to optimize that callsite"><span class="u" id="1527952542.000144">2018:06:02 15:15:42           nathanmarz </span><span>timing a single invocation tells you absolutely nothing, since neither specter nor the jvm have had a chance to optimize that callsite</span></div><div data-t="nathanmarz use criterium for benchmarking"><span class="u" id="1527952561.000016">2018:06:02 15:16:01           nathanmarz </span><span>use criterium for benchmarking</span></div><div data-t="nathanmarz I think you want  (transform [ALL (must :a)] inc [{:a 1 :b 2} {:a 2 :b 1} {:b 3}])  for that code"><span class="u" id="1527952614.000121">2018:06:02 15:16:54           nathanmarz </span><span>I think you want </span><code>(transform [ALL (must :a)] inc [{:a 1 :b 2} {:a 2 :b 1} {:b 3}])</code><span> for that code</span></div><div data-t="punit-naik Okay but I if I just forget to use  must . The error stack-trace seems pretty unhelpful in that case no?"><span class="u" id="1527952858.000057">2018:06:02 15:20:58                punit-naik </span><span>Okay but I if I just forget to use </span><code>must</code><span>. The error stack-trace seems pretty unhelpful in that case no?</span></div><div data-t="nathanmarz your path says to navigate to that key"><span class="u" id="1527952873.000095">2018:06:02 15:21:13           nathanmarz </span><span>your path says to navigate to that key</span></div><div data-t="nathanmarz it&apos;s doing exactly what you instructed"><span class="u" id="1527952894.000044">2018:06:02 15:21:34           nathanmarz </span><span>it&apos;s doing exactly what you instructed</span></div><div data-t="nathanmarz it&apos;s like doing  (update {} :a inc)"><span class="u" id="1527952948.000132">2018:06:02 15:22:28           nathanmarz </span><span>it&apos;s like doing </span><code>(update {} :a inc)</code></div><div data-t="punit-naik okay."><span class="u" id="1527953076.000039">2018:06:02 15:24:36           punit-naik </span><span>okay.</span></div><div data-t="montanonic If I have a map, how would I transform  MAP-VALS  but also passing the key corresponding to the val to the function? The issue is that if I just use  ALL , it also transforms the keys, which I don&apos;t want; but if I use  MAP-VALS , then I lose the context of the key. I realize that with I can just use  map  to achieve this without Specter, but then I&apos;d have to use  (into {})  to get it back to a map. I&apos;m transforming the map a lot, so this is undesirable."><span class="u" id="1528000547.000072">2018:06:03 04:35:47           montanonic </span><span>If I have a map, how would I transform </span><code>MAP-VALS</code><span> but also passing the key corresponding to the val to the function? The issue is that if I just use </span><code>ALL</code><span>, it also transforms the keys, which I don&apos;t want; but if I use </span><code>MAP-VALS</code><span>, then I lose the context of the key. I realize that with I can just use </span><code>map</code><span> to achieve this without Specter, but then I&apos;d have to use </span><code>(into {})</code><span> to get it back to a map. I&apos;m transforming the map a lot, so this is undesirable.</span></div><div data-t="nathanmarz @montanonic the pattern for that is  (transform [ALL (collect-one FIRST) LAST] (fn [k v] ...) data)"><span class="u" id="1528001445.000038">2018:06:03 04:50:45           nathanmarz </span><span>@montanonic the pattern for that is </span><code>(transform [ALL (collect-one FIRST) LAST] (fn [k v] ...) data)</code></div><div data-t="montanonic Ahh, nice. Thanks!"><span class="u" id="1528001500.000023">2018:06:03 04:51:40           montanonic </span><span>Ahh, nice. Thanks!</span></div><div data-t="daveliepmann Hi folks. I have a map and want to  transform  it to a nested map by applying a function to the key. A contrived example would be  {&quot;ab&quot; 5, &quot;az&quot; 10}  would become  {&quot;a&quot; {&quot;b&quot; 5, &quot;z 10} . I don&apos;t see a way to do this with  transform —am I missing something?"><span class="u" id="1528208122.000829">2018:06:05 14:15:22         daveliepmann </span><span>Hi folks. I have a map and want to </span><code>transform</code><span> it to a nested map by applying a function to the key. A contrived example would be </span><code>{&quot;ab&quot; 5, &quot;az&quot; 10}</code><span> would become </span><code>{&quot;a&quot; {&quot;b&quot; 5, &quot;z 10}</code><span>. I don&apos;t see a way to do this with </span><code>transform</code><span>—am I missing something?</span></div><div data-t="nathanmarz @daveliepmann that&apos;s a restructure of the entire data structure, so specter won&apos;t be better than just doing it without"><span class="u" id="1528208470.000281">2018:06:05 14:21:10           nathanmarz </span><span>@daveliepmann that&apos;s a restructure of the entire data structure, so specter won&apos;t be better than just doing it without</span></div><div data-t="nathanmarz specter lets you target a precise part of a data structure and only change that part, which isn&apos;t the case here"><span class="u" id="1528208540.000769">2018:06:05 14:22:20           nathanmarz </span><span>specter lets you target a precise part of a data structure and only change that part, which isn&apos;t the case here</span></div><div data-t="daveliepmann I had that suspicion, but it helps to hear it from the source. Thanks!  🙂"><span class="u" id="1528208580.000311">2018:06:05 14:23:00         daveliepmann </span><span>I had that suspicion, but it helps to hear it from the source. Thanks! </span><b>🙂</b></div><div data-t="jeremyraines hi folks, wondering if someone can help me understand why the following are not equivalent"><span class="u" id="1528306057.000034">2018:06:06 17:27:37         jeremyraines </span><span>hi folks, wondering if someone can help me understand why the following are not equivalent</span></div><div data-t="jeremyraines where the contents of the atom  foo  are exactly the vec returned from the first expression"><span class="u" id="1528306133.000059">2018:06:06 17:28:53         jeremyraines </span><span>where the contents of the atom </span><code>foo</code><span> are exactly the vec returned from the first expression</span></div><div data-t="nathanmarz @jeremyraines  filterer  takes in a subpath and keeps elements for which that path navigates to at least one value"><span class="u" id="1528306270.000710">2018:06:06 17:31:10           nathanmarz </span><span>@jeremyraines </span><code>filterer</code><span> takes in a subpath and keeps elements for which that path navigates to at least one value</span></div><div data-t="nathanmarz :bar  always navigates"><span class="u" id="1528306277.000481">2018:06:06 17:31:17           nathanmarz </span><code>:bar</code><span> always navigates</span></div><div data-t="nathanmarz you can do  (sp/select [sp/ATOM (sp/filterer (pred :bar)) sp/ALL] foo)"><span class="u" id="1528306297.000548">2018:06:06 17:31:37           nathanmarz </span><span>you can do </span><code>(sp/select [sp/ATOM (sp/filterer (pred :bar)) sp/ALL] foo)</code></div><div data-t="jeremyraines ah, got it.  Thank you!"><span class="u" id="1528306321.000332">2018:06:06 17:32:01         jeremyraines </span><span>ah, got it.  Thank you!</span></div><div data-t="currentoor @nathanmarz I just started playing with specter, it’s been on my list for a while. I’m mad at myself for not using this work of art sooner! Just wanted to say thanks for making this and you’re doing God’s work!  😄"><span class="u" id="1528307713.000347">2018:06:06 17:55:13           currentoor </span><span>@nathanmarz I just started playing with specter, it’s been on my list for a while. I’m mad at myself for not using this work of art sooner! Just wanted to say thanks for making this and you’re doing God’s work! </span><b>😄</b></div><div data-t="nathanmarz @currentoor thanks :)"><span class="u" id="1528307884.000333">2018:06:06 17:58:04           nathanmarz </span><span>@currentoor thanks :)</span></div><div data-t="currentoor dealing the salesforce API just got a whole lot easier (and more fun)!"><span class="u" id="1528307913.000043">2018:06:06 17:58:33           currentoor </span><span>dealing the salesforce API just got a whole lot easier (and more fun)!</span></div><div data-t="sophiago I modified the  map-key-walker  example from the wiki page on recursive navigators so that it will look inside vectors as well as maps, but ideally i&apos;d like to navigate to the inverse so I can delete all other key-value pairs and leave the ones selected with the structure they were nested in."><span class="u" id="1528320559.000134">2018:06:06 21:29:19             sophiago </span><span>I modified the </span><code>map-key-walker</code><span> example from the wiki page on recursive navigators so that it will look inside vectors as well as maps, but ideally i&apos;d like to navigate to the inverse so I can delete all other key-value pairs and leave the ones selected with the structure they were nested in.</span></div><div data-t="nathanmarz @sophiago you&apos;re trying to do too much in those paths"><span class="u" id="1528327104.000153">2018:06:06 23:18:24           nathanmarz </span><span>@sophiago you&apos;re trying to do too much in those paths</span></div><div data-t="nathanmarz don&apos;t navigate to both all the recursive maps and to a specific key in the same path"><span class="u" id="1528327141.000105">2018:06:06 23:19:01           nathanmarz </span><span>don&apos;t navigate to both all the recursive maps and to a specific key in the same path</span></div><div data-t="nathanmarz have one path that navigates to all the maps and then navigate to the key from there"><span class="u" id="1528327154.000014">2018:06:06 23:19:14           nathanmarz </span><span>have one path that navigates to all the maps and then navigate to the key from there</span></div><div data-t="nathanmarz (def data {:baz &quot;qux&quot;, :locals [{:locals &quot;foo&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})

(def MAP-NODES
  (recursive-path [] p
   (cond-path map? (continue-then-stay MAP-VALS p)
              coll? [ALL p]
              )))

(transform MAP-NODES #(select-keys % [:locals]) data)
"><span class="u" id="1528327175.000031">2018:06:06 23:19:35           nathanmarz </span><pre>(def data {:baz &quot;qux&quot;, :locals [{:locals &quot;foo&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})

(def MAP-NODES
  (recursive-path [] p
   (cond-path map? (continue-then-stay MAP-VALS p)
              coll? [ALL p]
              )))

(transform MAP-NODES #(select-keys % [:locals]) data)
</pre></div><div data-t="nathanmarz not sure what you mean by &quot;inverse&quot;"><span class="u" id="1528327185.000017">2018:06:06 23:19:45           nathanmarz </span><span>not sure what you mean by &quot;inverse&quot;</span></div><div data-t="nathanmarz you mean get rid of all &quot;:locals&quot; keys in all maps?"><span class="u" id="1528327210.000166">2018:06:06 23:20:10           nathanmarz </span><span>you mean get rid of all &quot;:locals&quot; keys in all maps?</span></div><div data-t="sophiago No, I meant select for every k-v pair where the key is not the one specified. I figured using a navigator like that with  (setval [..] NONE ..)  would be the easiest way to preserve structure."><span class="u" id="1528327362.000204">2018:06:06 23:22:42             sophiago </span><span>No, I meant select for every k-v pair where the key is not the one specified. I figured using a navigator like that with </span><code>(setval [..] NONE ..)</code><span> would be the easiest way to preserve structure.</span></div><div data-t="nathanmarz that&apos;s just  [ALL (selected? FIRST #(not= % k)) LAST]"><span class="u" id="1528327404.000345">2018:06:06 23:23:24           nathanmarz </span><span>that&apos;s just </span><code>[ALL (selected? FIRST #(not= % k)) LAST]</code></div><div data-t="sophiago Ah. Okay, thanks. I don&apos;t think that&apos;s even necessary now, though. I was fairly close to your solution in some of the navigators I tried, but not quite  😛"><span class="u" id="1528327476.000243">2018:06:06 23:24:36             sophiago </span><span>Ah. Okay, thanks. I don&apos;t think that&apos;s even necessary now, though. I was fairly close to your solution in some of the navigators I tried, but not quite </span><b>😛</b></div><div data-t="sophiago I&apos;m still having trouble with your version of  MAP-NODES  and a full ast from  tools.analyzer.jvm  though"><span class="u" id="1528327636.000178">2018:06:06 23:27:16             sophiago </span><span>I&apos;m still having trouble with your version of </span><code>MAP-NODES</code><span> and a full ast from </span><code>tools.analyzer.jvm</code><span> though</span></div><div data-t="sophiago Right, it still doesn&apos;t search bottom-up meaning it will prune branches that still contain the keys I&apos;m looking for, e.g.  (def data {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})  returns an empty map."><span class="u" id="1528327780.000048">2018:06:06 23:29:40             sophiago </span><span>Right, it still doesn&apos;t search bottom-up meaning it will prune branches that still contain the keys I&apos;m looking for, e.g. </span><code>(def data {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})</code><span> returns an empty map.</span></div><div data-t="sophiago So that works as well as my second example above, but still fails on the same case"><span class="u" id="1528327845.000018">2018:06:06 23:30:45             sophiago </span><span>So that works as well as my second example above, but still fails on the same case</span></div><div data-t="sophiago I&apos;m realizing just how difficult it is to do breadth-first search in Clojure  😕"><span class="u" id="1528327912.000302">2018:06:06 23:31:52             sophiago </span><span>I&apos;m realizing just how difficult it is to do breadth-first search in Clojure </span><b>😕</b></div><div data-t="sophiago I mean, I can return the elements of a tree in breadth-first order but can&apos;t figure out how to transform it in that order."><span class="u" id="1528327986.000137">2018:06:06 23:33:06             sophiago </span><span>I mean, I can return the elements of a tree in breadth-first order but can&apos;t figure out how to transform it in that order.</span></div><div data-t="sophiago This is what I&apos;m going for with a lengthy example you&apos;d want to pretty-print:  https://gist.github.com/Sophia-Gold/d48be3ec125a453de7cec2033a465ef8"><span class="u" id="1528328755.000309">2018:06:06 23:45:55             sophiago </span><span>This is what I&apos;m going for with a lengthy example you&apos;d want to pretty-print: </span><a href="https://gist.github.com/Sophia-Gold/d48be3ec125a453de7cec2033a465ef8">https://gist.github.com/Sophia-Gold/d48be3ec125a453de7cec2033a465ef8</a></div><div data-t="sophiago But really, the tiny examples in my second paste above cover the problem. In case it wasn&apos;t clear, it was working on the first structure and failing on the second."><span class="u" id="1528328823.000102">2018:06:06 23:47:03             sophiago </span><span>But really, the tiny examples in my second paste above cover the problem. In case it wasn&apos;t clear, it was working on the first structure and failing on the second.</span></div><div data-t="nathanmarz @sophiago it&apos;s a lot easier if your maps have more information about what they represent"><span class="u" id="1528333649.000054">2018:06:07 01:07:29           nathanmarz </span><span>@sophiago it&apos;s a lot easier if your maps have more information about what they represent</span></div><div data-t="nathanmarz this would be a way to do it, though it&apos;s not very efficient:
 (def data {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot; :k &quot;v&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})

(def MAP-NODES
  (recursive-path [] p
   (cond-path map? (stay-then-continue MAP-VALS p)
              coll? [ALL p]
              )))

(transform
  [MAP-NODES
   (not-selected?
     MAP-VALS
     MAP-NODES
     (must :locals))]
  #(select-keys % [:locals])
  data)
"><span class="u" id="1528333670.000220">2018:06:07 01:07:50           nathanmarz </span><span>this would be a way to do it, though it&apos;s not very efficient:
</span><pre>(def data {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot; :k &quot;v&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})

(def MAP-NODES
  (recursive-path [] p
   (cond-path map? (stay-then-continue MAP-VALS p)
              coll? [ALL p]
              )))

(transform
  [MAP-NODES
   (not-selected?
     MAP-VALS
     MAP-NODES
     (must :locals))]
  #(select-keys % [:locals])
  data)
</pre></div><div data-t="sophiago Unfortunately, I don&apos;t have control over data representation in this case. But I think we&apos;re converging on something similar. I&apos;m trying something like this:  (setval [MAP-NODES #(and (not= :locals (first %)) (not (coll? (second %))))] NONE {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})"><span class="u" id="1528333822.000021">2018:06:07 01:10:22             sophiago </span><span>Unfortunately, I don&apos;t have control over data representation in this case. But I think we&apos;re converging on something similar. I&apos;m trying something like this: </span><code>(setval [MAP-NODES #(and (not= :locals (first %)) (not (coll? (second %))))] NONE {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})</code></div><div data-t="nathanmarz this is a cleaner way to write that:
 (setval
  [MAP-NODES
   ALL
   (not-selected? FIRST (pred= :locals))
   LAST
   (complement coll?)]
  NONE
  data)
"><span class="u" id="1528334127.000065">2018:06:07 01:15:27           nathanmarz </span><span>this is a cleaner way to write that:
</span><pre>(setval
  [MAP-NODES
   ALL
   (not-selected? FIRST (pred= :locals))
   LAST
   (complement coll?)]
  NONE
  data)
</pre></div><div data-t="nathanmarz if you want to get rid of the empty map you can do this:
 (def data {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot; :k &quot;v&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})

(def MAP-NODES
  (recursive-path [] p
   (cond-path map? (stay-then-continue MAP-VALS p)
              coll? [(compact ALL p)]
              )))

(setval
  [MAP-NODES
   ALL
   (not-selected? FIRST (pred= :locals))
   LAST
   (complement coll?)]
  NONE
  data)
"><span class="u" id="1528334178.000130">2018:06:07 01:16:18           nathanmarz </span><span>if you want to get rid of the empty map you can do this:
</span><pre>(def data {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot; :k &quot;v&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})

(def MAP-NODES
  (recursive-path [] p
   (cond-path map? (stay-then-continue MAP-VALS p)
              coll? [(compact ALL p)]
              )))

(setval
  [MAP-NODES
   ALL
   (not-selected? FIRST (pred= :locals))
   LAST
   (complement coll?)]
  NONE
  data)
</pre></div><div data-t="sophiago Nice. I think this might be what I&apos;m looking for"><span class="u" id="1528334265.000209">2018:06:07 01:17:45             sophiago </span><span>Nice. I think this might be what I&apos;m looking for</span></div><div data-t="sophiago Okay, yeah I think that&apos;s good enough I can follow it from here.  compact  is being called on a keyword at some point in the traversal of a full ast, but I probably want to clean up the results further. Thanks yet again, @nathanmarz"><span class="u" id="1528334594.000065">2018:06:07 01:23:14             sophiago </span><span>Okay, yeah I think that&apos;s good enough I can follow it from here. </span><code>compact</code><span> is being called on a keyword at some point in the traversal of a full ast, but I probably want to clean up the results further. Thanks yet again, @nathanmarz</span></div><div data-t="sophiago I should probably think about contributing to your docs if you think this is a common enough use case. I would think Specter is ideal for working with  tools.analyzer  and in fact there was one Jira ticket for the latter related to Ridley."><span class="u" id="1528334731.000175">2018:06:07 01:25:31             sophiago </span><span>I should probably think about contributing to your docs if you think this is a common enough use case. I would think Specter is ideal for working with </span><code>tools.analyzer</code><span> and in fact there was one Jira ticket for the latter related to Ridley.</span></div><div data-t="sophiago @nathanmarz sorry, one more thing I&apos;m stuck on with the navigators above: I&apos;d like the macros that call them to stop at any keys in  not-selected? ,  :locals  in this example, rather than just skipping them and navigating deeper. It would seem I just need to move the  not-selected?  navigators into  recursive-path  so navigation stops there and  setval  will only apply the other predicates to elements above it, but that doesn&apos;t seem to be working for me, even using separate macros."><span class="u" id="1528491920.000463">2018:06:08 21:05:20             sophiago </span><span>@nathanmarz sorry, one more thing I&apos;m stuck on with the navigators above: I&apos;d like the macros that call them to stop at any keys in </span><code>not-selected?</code><span>, </span><code>:locals</code><span> in this example, rather than just skipping them and navigating deeper. It would seem I just need to move the </span><code>not-selected?</code><span> navigators into </span><code>recursive-path</code><span> so navigation stops there and </span><code>setval</code><span> will only apply the other predicates to elements above it, but that doesn&apos;t seem to be working for me, even using separate macros.</span></div><div data-t="nathanmarz @sophiago you want it to stop navigation at map values whose key is not  :locals ?"><span class="u" id="1528492584.000102">2018:06:08 21:16:24           nathanmarz </span><span>@sophiago you want it to stop navigation at map values whose key is not </span><code>:locals</code><span>?</span></div><div data-t="sophiago The opposite. Stop recursive navigation into the value of that key."><span class="u" id="1528492647.000389">2018:06:08 21:17:27             sophiago </span><span>The opposite. Stop recursive navigation into the value of that key.</span></div><div data-t="nathanmarz so stop navigation at any map?"><span class="u" id="1528492660.000275">2018:06:08 21:17:40           nathanmarz </span><span>so stop navigation at any map?</span></div><div data-t="nathanmarz or stop navigation at maps with a  :locals  key?"><span class="u" id="1528492675.000039">2018:06:08 21:17:55           nathanmarz </span><span>or stop navigation at maps with a </span><code>:locals</code><span> key?</span></div><div data-t="sophiago So if I have  {:foo &quot;bar&quot; :env [{:locals &quot;baz&quot;} {:locals {:baz &quot;qux&quot;}}]}  I can use a macro like  setval  above and not have it delete  {:baz &quot;qux&quot;}"><span class="u" id="1528492800.000427">2018:06:08 21:20:00             sophiago </span><span>So if I have </span><code>{:foo &quot;bar&quot; :env [{:locals &quot;baz&quot;} {:locals {:baz &quot;qux&quot;}}]}</code><span> I can use a macro like </span><code>setval</code><span> above and not have it delete </span><code>{:baz &quot;qux&quot;}</code></div><div data-t="sophiago I&apos;ve been playing with it and it seems to come down to how I compose predicates in recursive paths"><span class="u" id="1528492839.000017">2018:06:08 21:20:39             sophiago </span><span>I&apos;ve been playing with it and it seems to come down to how I compose predicates in recursive paths</span></div><div data-t="nathanmarz ok, so basically don&apos;t recurse into  :locals"><span class="u" id="1528492872.000536">2018:06:08 21:21:12           nathanmarz </span><span>ok, so basically don&apos;t recurse into </span><code>:locals</code></div><div data-t="sophiago Yes"><span class="u" id="1528492892.000379">2018:06:08 21:21:32             sophiago </span><span>Yes</span></div><div data-t="sophiago And more generally, I just want to decouple the recursion from the predicates I&apos;m composing"><span class="u" id="1528492908.000185">2018:06:08 21:21:48             sophiago </span><span>And more generally, I just want to decouple the recursion from the predicates I&apos;m composing</span></div><div data-t="nathanmarz (def maps-with-key-stop
  (recursive-path [k] p
    (cond-path map? (if-path (must k)
                      STAY
                      (stay-then-continue MAP-VALS p))
               coll? (compact ALL p)
               )))

(setval
  [(maps-with-key-stop :locals)
   ALL
   (not-selected? FIRST (pred= :locals))
   LAST
   (complement coll?)]
  NONE
  data)
"><span class="u" id="1528493012.000086">2018:06:08 21:23:32           nathanmarz </span><pre>(def maps-with-key-stop
  (recursive-path [k] p
    (cond-path map? (if-path (must k)
                      STAY
                      (stay-then-continue MAP-VALS p))
               coll? (compact ALL p)
               )))

(setval
  [(maps-with-key-stop :locals)
   ALL
   (not-selected? FIRST (pred= :locals))
   LAST
   (complement coll?)]
  NONE
  data)
</pre></div><div data-t="sophiago Oh, I did not try something like that"><span class="u" id="1528493046.000224">2018:06:08 21:24:06             sophiago </span><span>Oh, I did not try something like that</span></div><div data-t="sophiago Let me give it a test"><span class="u" id="1528493052.000403">2018:06:08 21:24:12             sophiago </span><span>Let me give it a test</span></div><div data-t="nathanmarz actually you probably want
 (def maps-with-key-stop
  (recursive-path [k] p
    (cond-path map? (stay-then-continue
                      ALL
                      (not-selected? FIRST (pred= k))
                      LAST
                      p)
               coll? (compact ALL p)
               )))
"><span class="u" id="1528493139.000417">2018:06:08 21:25:39           nathanmarz </span><span>actually you probably want
</span><pre>(def maps-with-key-stop
  (recursive-path [k] p
    (cond-path map? (stay-then-continue
                      ALL
                      (not-selected? FIRST (pred= k))
                      LAST
                      p)
               coll? (compact ALL p)
               )))
</pre></div><div data-t="sophiago That looks more like what I was trying"><span class="u" id="1528493176.000157">2018:06:08 21:26:16             sophiago </span><span>That looks more like what I was trying</span></div><div data-t="sophiago I think I actually want this: (def maps-with-key-stop
  (recursive-path [k] p
    (cond-path map? (stay-then-continue
                      ALL
                      (not-selected? FIRST (pred= k))
                      ALL
                      p)
               coll? [ALL p])))"><span class="u" id="1528493356.000135">2018:06:08 21:29:16             sophiago </span><span>I think I actually want this:</span><pre>(def maps-with-key-stop
  (recursive-path [k] p
    (cond-path map? (stay-then-continue
                      ALL
                      (not-selected? FIRST (pred= k))
                      ALL
                      p)
               coll? [ALL p])))</pre></div><div data-t="sophiago Except I&apos;m trying to get the  k  to be a collection and  apply  isn&apos;t giving the same results"><span class="u" id="1528493614.000257">2018:06:08 21:33:34             sophiago </span><span>Except I&apos;m trying to get the </span><code>k</code><span> to be a collection and </span><code>apply</code><span> isn&apos;t giving the same results</span></div><div data-t="sophiago Oh, that&apos;s what  eachnav  is for, right?"><span class="u" id="1528493727.000283">2018:06:08 21:35:27             sophiago </span><span>Oh, that&apos;s what </span><code>eachnav</code><span> is for, right?</span></div><div data-t="nathanmarz that&apos;s not what  eachnav  is for"><span class="u" id="1528499094.000019">2018:06:08 23:04:54           nathanmarz </span><span>that&apos;s not what </span><code>eachnav</code><span> is for</span></div><div data-t="nathanmarz @sophiago I think you want:
 (def maps-with-key-stop
  (recursive-path [kset] p
    (cond-path map? (stay-then-continue
                      ALL
                      (not-selected? FIRST (pred kset))
                      LAST
                      p)
               coll? [ALL p]
               )))
"><span class="u" id="1528499137.000056">2018:06:08 23:05:37           nathanmarz </span><span>@sophiago I think you want:
</span><pre>(def maps-with-key-stop
  (recursive-path [kset] p
    (cond-path map? (stay-then-continue
                      ALL
                      (not-selected? FIRST (pred kset))
                      LAST
                      p)
               coll? [ALL p]
               )))
</pre></div><div data-t="sophiago Thanks, that works! Just a bit more verbose when I call it. I still have the first issue where it doesn&apos;t seem to be recursing inside other colls, though."><span class="u" id="1528499560.000236">2018:06:08 23:12:40             sophiago </span><span>Thanks, that works! Just a bit more verbose when I call it. I still have the first issue where it doesn&apos;t seem to be recursing inside other colls, though.</span></div><div data-t="sophiago And I have to delete the extra predicate argument from the first cond or none of these have worked. That seems to make sense to me: I don&apos;t actually want  (complement coll?)  added to the path if the key does match."><span class="u" id="1528499697.000287">2018:06:08 23:14:57             sophiago </span><span>And I have to delete the extra predicate argument from the first cond or none of these have worked. That seems to make sense to me: I don&apos;t actually want </span><code>(complement coll?)</code><span> added to the path if the key does match.</span></div><div data-t="ben.mumford what is the more elegant way to extract a value from a nested data structure and then apply a transform to it?"><span class="u" id="1528727056.000723">2018:06:11 14:24:16          ben.mumford </span><span>what is the more elegant way to extract a value from a nested data structure and then apply a transform to it?</span></div><div data-t="ben.mumford my use case is that i have lots of different types of input data structures and i want to normalise them so that i can compose and compare them"><span class="u" id="1528727143.000591">2018:06:11 14:25:43          ben.mumford </span><span>my use case is that i have lots of different types of input data structures and i want to normalise them so that i can compose and compare them</span></div><div data-t="ben.mumford so what i&apos;m doing is for each input object creating a new output object where each field is calculated using a select then a transform (so i guess question 2 is does this make specter a good fit for my use case as i&apos;m not modifying a pre-existing data structure)"><span class="u" id="1528727410.000568">2018:06:11 14:30:10          ben.mumford </span><span>so what i&apos;m doing is for each input object creating a new output object where each field is calculated using a select then a transform (so i guess question 2 is does this make specter a good fit for my use case as i&apos;m not modifying a pre-existing data structure)</span></div><div data-t="nathanmarz @ben.mumford620 you can use  view  or  transformed  at the end of the path to the select operation"><span class="u" id="1528732274.000467">2018:06:11 15:51:14           nathanmarz </span><span>@ben.mumford620 you can use </span><code>view</code><span> or </span><code>transformed</code><span> at the end of the path to the select operation</span></div><div data-t="jsa-aerial Would spectre be the &apos;natural/goto&apos; thing for taking a nested data structure and a &apos;key&apos; and replace any occurance of it with a value?  Where &apos;key&apos; would most probably be literally a keyword (or possibly string)?"><span class="u" id="1528734457.000177">2018:06:11 16:27:37           jsa-aerial </span><span>Would spectre be the &apos;natural/goto&apos; thing for taking a nested data structure and a &apos;key&apos; and replace any occurance of it with a value?  Where &apos;key&apos; would most probably be literally a keyword (or possibly string)?</span></div><div data-t="nathanmarz @jsa-aerial yes, that&apos;s a bread and butter use case"><span class="u" id="1528737378.000579">2018:06:11 17:16:18           nathanmarz </span><span>@jsa-aerial yes, that&apos;s a bread and butter use case</span></div><div data-t="nathanmarz walker  is the lazy way to do that, but if your data has any structure to it whatsoever it&apos;s better to make a precise path"><span class="u" id="1528737426.000533">2018:06:11 17:17:06           nathanmarz </span><code>walker</code><span> is the lazy way to do that, but if your data has any structure to it whatsoever it&apos;s better to make a precise path</span></div><div data-t="nathanmarz much higher performance + much less bug prone"><span class="u" id="1528737449.000446">2018:06:11 17:17:29           nathanmarz </span><span>much higher performance + much less bug prone</span></div><div data-t="jsa-aerial @nathanmarz OK, sounds promising. The data will have quite a lot of structure and the &apos;paths&apos; (there will typically be several such &apos;keys&apos;) will basically not be known ahead of time. So, this basically involves &apos;search&apos; and replace. Why would non precise path and  walker  tend to be more &apos;bug prone&apos;??"><span class="u" id="1528741522.000310">2018:06:11 18:25:22           jsa-aerial </span><span>@nathanmarz OK, sounds promising. The data will have quite a lot of structure and the &apos;paths&apos; (there will typically be several such &apos;keys&apos;) will basically not be known ahead of time. So, this basically involves &apos;search&apos; and replace. Why would non precise path and </span><code>walker</code><span> tend to be more &apos;bug prone&apos;??</span></div><div data-t="nathanmarz walker  will descend everywhere including places you don&apos;t expect, like records, map keys, etc."><span class="u" id="1528742166.000510">2018:06:11 18:36:06           nathanmarz </span><code>walker</code><span> will descend everywhere including places you don&apos;t expect, like records, map keys, etc.</span></div><div data-t="jsa-aerial But if the &apos;key&apos; can basically be anywhere, that would seem to be the &apos;right thing&apos;, correct?"><span class="u" id="1528742262.000618">2018:06:11 18:37:42                jsa-aerial </span><span>But if the &apos;key&apos; can basically be anywhere, that would seem to be the &apos;right thing&apos;, correct?</span></div><div data-t="jsa-aerial Actually, ALL almost looks like exactly what is needed here. Except it returns [k v] for map elements"><span class="u" id="1528742177.000701">2018:06:11 18:36:17           jsa-aerial </span><span>Actually, ALL almost looks like exactly what is needed here. Except it returns [k v] for map elements</span></div><div data-t="nathanmarz here&apos;s a variation of  walker  that doesn&apos;t descend into map keys / key/value pairs
 (def my-walker
  (recursive-path [afn] p
    (cond-path (pred afn) STAY
               map? [MAP-VALS p]
               coll? [ALL p]
               )))
"><span class="u" id="1528742269.000386">2018:06:11 18:37:49           nathanmarz </span><span>here&apos;s a variation of </span><code>walker</code><span> that doesn&apos;t descend into map keys / key/value pairs
</span><pre>(def my-walker
  (recursive-path [afn] p
    (cond-path (pred afn) STAY
               map? [MAP-VALS p]
               coll? [ALL p]
               )))
</pre></div><div data-t="nathanmarz if your data is truly completely unstructured, then  walker  is more appropriate"><span class="u" id="1528742306.000759">2018:06:11 18:38:26           nathanmarz </span><span>if your data is truly completely unstructured, then </span><code>walker</code><span> is more appropriate</span></div><div data-t="nathanmarz though even then, it&apos;s better to make a variation that doesn&apos;t navigate to key/value pairs"><span class="u" id="1528742323.000333">2018:06:11 18:38:43           nathanmarz </span><span>though even then, it&apos;s better to make a variation that doesn&apos;t navigate to key/value pairs</span></div><div data-t="nathanmarz e.g.
 (def my-walker
  (recursive-path [afn] p
    (cond-path (pred afn) STAY
               map? [(multi-path MAP-VALS MAP-KEYS) p]
               coll? [ALL p]
               )))
"><span class="u" id="1528742354.000360">2018:06:11 18:39:14           nathanmarz </span><span>e.g.
</span><pre>(def my-walker
  (recursive-path [afn] p
    (cond-path (pred afn) STAY
               map? [(multi-path MAP-VALS MAP-KEYS) p]
               coll? [ALL p]
               )))
</pre></div><div data-t="jsa-aerial I think we have a semantic issue here - you are using &apos;structured&apos; in a special way - not just to indicate a lot of structure in the data"><span class="u" id="1528742357.000793">2018:06:11 18:39:17           jsa-aerial </span><span>I think we have a semantic issue here - you are using &apos;structured&apos; in a special way - not just to indicate a lot of structure in the data</span></div><div data-t="nathanmarz by structure I mean that the organization of the data is precise and well-understood"><span class="u" id="1528742393.000643">2018:06:11 18:39:53           nathanmarz </span><span>by structure I mean that the organization of the data is precise and well-understood</span></div><div data-t="jsa-aerial Something like this {:a ::some-key ....} can occur and should become {:a &lt;the-value-for-::some-key&gt; ...}"><span class="u" id="1528742430.000479">2018:06:11 18:40:30           jsa-aerial </span><span>Something like this {:a ::some-key ....} can occur and should become {:a &lt;the-value-for-::some-key&gt; ...}</span></div><div data-t="jsa-aerial It&apos;s precise, it is just not fully known up front. And these &apos;keys&apos; can occur in all sorts of places. Basically, these structures will be &quot;parameterized&quot; vega-lite specifications."><span class="u" id="1528742524.000265">2018:06:11 18:42:04           jsa-aerial </span><span>It&apos;s precise, it is just not fully known up front. And these &apos;keys&apos; can occur in all sorts of places. Basically, these structures will be &quot;parameterized&quot; vega-lite specifications.</span></div><div data-t="nathanmarz if the paths to what you care about aren&apos;t known in advance, then I would call it unstructured"><span class="u" id="1528742557.000663">2018:06:11 18:42:37           nathanmarz </span><span>if the paths to what you care about aren&apos;t known in advance, then I would call it unstructured</span></div><div data-t="nathanmarz if you know it will never occur in a map key, then it&apos;s best your path reflect that"><span class="u" id="1528742589.000189">2018:06:11 18:43:09           nathanmarz </span><span>if you know it will never occur in a map key, then it&apos;s best your path reflect that</span></div><div data-t="nathanmarz or if you know any other constraints, those should be included in the path"><span class="u" id="1528742603.000619">2018:06:11 18:43:23           nathanmarz </span><span>or if you know any other constraints, those should be included in the path</span></div><div data-t="jsa-aerial OK, that is fine - now I know what you mean by that, it would seem  walker  is the way to go"><span class="u" id="1528742604.000494">2018:06:11 18:43:24           jsa-aerial </span><span>OK, that is fine - now I know what you mean by that, it would seem </span><code>walker</code><span> is the way to go</span></div><div data-t="jsa-aerial Yeah, those sorts of constraints and assumptions cannot be relied upon in this sort of scenario."><span class="u" id="1528742690.000161">2018:06:11 18:44:50           jsa-aerial </span><span>Yeah, those sorts of constraints and assumptions cannot be relied upon in this sort of scenario.</span></div><div data-t="jsa-aerial There are constraints and requirements in vega-lite data specs, but here the idea is to use a basic layout as a template which will have these &apos;keys&apos; replaced by values for specific cases and these &apos;keys&apos; could be standing in for both VL keys and/or values."><span class="u" id="1528742846.000596">2018:06:11 18:47:26           jsa-aerial </span><span>There are constraints and requirements in vega-lite data specs, but here the idea is to use a basic layout as a template which will have these &apos;keys&apos; replaced by values for specific cases and these &apos;keys&apos; could be standing in for both VL keys and/or values.</span></div><div data-t="jsa-aerial Hmmmm ALL maybe could still work if it is just called recursively on any [k v] pair returned"><span class="u" id="1528743046.000695">2018:06:11 18:50:46           jsa-aerial </span><span>Hmmmm ALL maybe could still work if it is just called recursively on any [k v] pair returned</span></div><div data-t="currentoor is it generally frowned upon to use  setval  inside of a  transform-fn  in a transform call?"><span class="u" id="1528757888.000151">2018:06:11 22:58:08           currentoor </span><span>is it generally frowned upon to use </span><code>setval</code><span> inside of a </span><code>transform-fn</code><span> in a transform call?</span></div><div data-t="nathanmarz @currentoor when that comes up I find that there&apos;s usually a better way to express the overall computation, though not always"><span class="u" id="1528807974.000658">2018:06:12 12:52:54           nathanmarz </span><span>@currentoor when that comes up I find that there&apos;s usually a better way to express the overall computation, though not always</span></div><div data-t="currentoor thanks!"><span class="u" id="1528842435.000362">2018:06:12 22:27:15           currentoor </span><span>thanks!</span></div><div data-t="nathanmarz @jsa-aerial with  walker  it&apos;s:
 (let [replacements {:b 77 :x :xxx}]
  (transform [(walker (complement coll?)) #(contains? replacements %)]
    replacements
    data
    ))
"><span class="u" id="1528946585.000160">2018:06:14 03:23:05           nathanmarz </span><span>@jsa-aerial with </span><code>walker</code><span> it&apos;s:
</span><pre>(let [replacements {:b 77 :x :xxx}]
  (transform [(walker (complement coll?)) #(contains? replacements %)]
    replacements
    data
    ))
</pre></div><div data-t="nathanmarz better than doing recursion manually in my opinion"><span class="u" id="1528946600.000213">2018:06:14 03:23:20           nathanmarz </span><span>better than doing recursion manually in my opinion</span></div><div data-t="jsa-aerial 💯  ah..."><span class="u" id="1528952990.000235">2018:06:14 05:09:50           jsa-aerial </span><b>💯</b><span> ah...</span></div><div data-t="lispyclouds Hello, I have the following structure"><span class="u" id="1528989860.001015">2018:06:14 15:24:20          lispyclouds </span><span>Hello, I have the following structure</span></div><div data-t="lispyclouds and a function  (get-details)  which does  url -&gt; [detailed-url1, detailed-url2 …]"><span class="u" id="1528989935.000629">2018:06:14 15:25:35          lispyclouds </span><span>and a function </span><code>(get-details)</code><span> which does </span><code>url -&gt; [detailed-url1, detailed-url2 …]</code></div><div data-t="lispyclouds What i need is the following"><span class="u" id="1528989953.000249">2018:06:14 15:25:53          lispyclouds </span><span>What i need is the following</span></div><div data-t="lispyclouds This is what Im using currently
 (defn categorized-urls []
  (-&gt;&gt; (input)
       (transform [ALL MAP-VALS ALL MAP-VALS ALL] get-details)
       (transform [ALL MAP-VALS ALL MAP-VALS] flatten)))
"><span class="u" id="1528990019.000325">2018:06:14 15:26:59          lispyclouds </span><span>This is what Im using currently
</span><pre>(defn categorized-urls []
  (-&gt;&gt; (input)
       (transform [ALL MAP-VALS ALL MAP-VALS ALL] get-details)
       (transform [ALL MAP-VALS ALL MAP-VALS] flatten)))
</pre></div><div data-t="lispyclouds Is there a better way?"><span class="u" id="1528990036.000992">2018:06:14 15:27:16          lispyclouds </span><span>Is there a better way?</span></div><div data-t="lispyclouds The input structure is pretty huge and its taking a while to execute this. Was wondering there might be a better way than twice transforms."><span class="u" id="1528990181.000645">2018:06:14 15:29:41          lispyclouds </span><span>The input structure is pretty huge and its taking a while to execute this. Was wondering there might be a better way than twice transforms.</span></div><div data-t="nathanmarz @rahul080327 this will speed it up:
 (defn categorized-urls [input]
  (multi-transform
    [ALL
     MAP-VALS
     ALL
     MAP-VALS
     (multi-path
       [ALL (terminal get-details)]
       (terminal #(into [] (mapcat identity) %)))]
    input))
"><span class="u" id="1528990979.000789">2018:06:14 15:42:59           nathanmarz </span><span>@rahul080327 this will speed it up:
</span><pre>(defn categorized-urls [input]
  (multi-transform
    [ALL
     MAP-VALS
     ALL
     MAP-VALS
     (multi-path
       [ALL (terminal get-details)]
       (terminal #(into [] (mapcat identity) %)))]
    input))
</pre></div><div data-t="nathanmarz traverses the data structure once instead of twice"><span class="u" id="1528990994.000836">2018:06:14 15:43:14           nathanmarz </span><span>traverses the data structure once instead of twice</span></div><div data-t="lispyclouds Ahan thanks a lot @nathanmarz superb  😃"><span class="u" id="1528991290.000143">2018:06:14 15:48:10          lispyclouds </span><span>Ahan thanks a lot @nathanmarz superb </span><b>😃</b></div><div data-t="luke.defeo Hello, am i able to use spectres navigation to define what im looking for  but return a structure several layers up, say for example i have the following data

 (def ctx [
          {
           :id    &quot;blah&quot;
           :name  &quot;News2&quot;
           :rules [[&quot;&quot; &quot;sport&quot; &quot;sport&quot;]
                   [&quot;&quot; &quot;messages&quot;]]}
          {
           :name  &quot;News&quot;
           :rules [[&quot;&quot; &quot;sport&quot;]
                   [&quot;&quot; &quot;messages&quot;]]}
          {
           :name  &quot;monitoring&quot;
           :rules [[&quot;new-relic&quot;]
                   [&quot;stack driver&quot;]]}])
 
 And navigation :
 (select-first [ALL :rules ALL ALL #(= % &quot;stack driver&quot;)] ctx)
 

This will return the string “stack driver” is possible it returns its outer record 
 {
           :name  &quot;monitoring&quot;
           :rules [[&quot;new-relic&quot;]
                   [&quot;stack driver&quot;]]}
"><span class="u" id="1529275017.000048">2018:06:17 22:36:57           luke.defeo </span><span>Hello, am i able to use spectres navigation to define what im looking for  but return a structure several layers up, say for example i have the following data

</span><pre>(def ctx [
          {
           :id    &quot;blah&quot;
           :name  &quot;News2&quot;
           :rules [[&quot;&quot; &quot;sport&quot; &quot;sport&quot;]
                   [&quot;&quot; &quot;messages&quot;]]}
          {
           :name  &quot;News&quot;
           :rules [[&quot;&quot; &quot;sport&quot;]
                   [&quot;&quot; &quot;messages&quot;]]}
          {
           :name  &quot;monitoring&quot;
           :rules [[&quot;new-relic&quot;]
                   [&quot;stack driver&quot;]]}])
</pre><span>
 And navigation :
</span><pre>(select-first [ALL :rules ALL ALL #(= % &quot;stack driver&quot;)] ctx)
</pre><span>

This will return the string “stack driver” is possible it returns its outer record 
</span><pre>{
           :name  &quot;monitoring&quot;
           :rules [[&quot;new-relic&quot;]
                   [&quot;stack driver&quot;]]}
</pre></div><div data-t="manas_marthi Hi Nathan, are there any sample data sets to try select and transform"><span class="u" id="1529275621.000110">2018:06:17 22:47:01         manas_marthi </span><span>Hi Nathan, are there any sample data sets to try select and transform</span></div><div data-t="nathanmarz @luke.defeo use  selected?  for that"><span class="u" id="1529275757.000082">2018:06:17 22:49:17           nathanmarz </span><span>@luke.defeo use </span><code>selected?</code><span> for that</span></div><div data-t="nathanmarz (select-first [ALL (selected? :rules ALL ALL #(= % &quot;stack driver&quot;))] ctx)"><span class="u" id="1529275759.000074">2018:06:17 22:49:19           nathanmarz </span><code>(select-first [ALL (selected? :rules ALL ALL #(= % &quot;stack driver&quot;))] ctx)</code></div><div data-t="nathanmarz @manas.marthi you can use anything"><span class="u" id="1529275824.000086">2018:06:17 22:50:24           nathanmarz </span><span>@manas.marthi you can use anything</span></div><div data-t="nathanmarz e.g. parse some html into a clojure data structure"><span class="u" id="1529275842.000009">2018:06:17 22:50:42           nathanmarz </span><span>e.g. parse some html into a clojure data structure</span></div><div data-t="nathanmarz or just make up small toy examples like in the documentation"><span class="u" id="1529275867.000070">2018:06:17 22:51:07           nathanmarz </span><span>or just make up small toy examples like in the documentation</span></div><div data-t="luke.defeo @nathanmarz thanks a lot"><span class="u" id="1529276577.000015">2018:06:17 23:02:57           luke.defeo </span><span>@nathanmarz thanks a lot</span></div><div data-t="manas_marthi @nathanmarz thank you!"><span class="u" id="1529276943.000085">2018:06:17 23:09:03         manas_marthi </span><span>@nathanmarz thank you!</span></div><div data-t="montanonic Any one-liner that can &quot;explode&quot; values while keeping things flat? Roughly speaking, like flatmap.

Example: turning  {:a 1 :b 2}  into  {:a 1 :b 2 &quot;a&quot; 1 &quot;b&quot; 2 &apos;a 1 &apos;b 2} , the keys get mapped to a set of new keys, but retain their original values, and the whole is returned as a single flat map."><span class="u" id="1529533354.000277">2018:06:20 22:22:34           montanonic </span><span>Any one-liner that can &quot;explode&quot; values while keeping things flat? Roughly speaking, like flatmap.

Example: turning </span><code>{:a 1 :b 2}</code><span> into </span><code>{:a 1 :b 2 &quot;a&quot; 1 &quot;b&quot; 2 &apos;a 1 &apos;b 2}</code><span>, the keys get mapped to a set of new keys, but retain their original values, and the whole is returned as a single flat map.</span></div><div data-t="montanonic https://github.com/nathanmarz/specter/issues/82#issuecomment-215098107  is close, but not structure-preserving, and passes the arguments inside of an additional vector (which is fine but ideally should be left an implementation detail)."><span class="u" id="1529534982.000032">2018:06:20 22:49:42           montanonic </span><a href="https://github.com/nathanmarz/specter/issues/82#issuecomment-215098107">https://github.com/nathanmarz/specter/issues/82#issuecomment-215098107</a><span> is close, but not structure-preserving, and passes the arguments inside of an additional vector (which is fine but ideally should be left an implementation detail).</span></div><div data-t="nathanmarz @montanonic you would need a new navigator for that"><span class="u" id="1529542620.000135">2018:06:21 00:57:00           nathanmarz </span><span>@montanonic you would need a new navigator for that</span></div><div data-t="nathanmarz fleshing out  ALL-ELEM-SEQ  from that issue to be structure preserving would work"><span class="u" id="1529542681.000110">2018:06:21 00:58:01           nathanmarz </span><span>fleshing out </span><code>ALL-ELEM-SEQ</code><span> from that issue to be structure preserving would work</span></div><div data-t="pepe Hello, I have this data: 

 [{:id 0}
 {:id 1}
 {:id 2 :parent-id 1 :val 1}
 {:id 3 :parent-id 1 :val 1}
 {:id 4 :parent-id 2 :val 2}
 {:id 5 :parent-id 3 :val 2}
 {:id 6 :parent-id 3 :val 2}
 {:id 7 :parent-id 0 :val 100}
 {:id 8 :parent-id 7 :val 200}
 {:id 9 :parent-id 6 :val 3}] 

And I would like to traverse all the :val for :id = 1 and all its descendants. Is it possible with specter?"><span class="u" id="1529850164.000109">2018:06:24 14:22:44                 pepe </span><span>Hello, I have this data: 

</span><pre>[{:id 0}
 {:id 1}
 {:id 2 :parent-id 1 :val 1}
 {:id 3 :parent-id 1 :val 1}
 {:id 4 :parent-id 2 :val 2}
 {:id 5 :parent-id 3 :val 2}
 {:id 6 :parent-id 3 :val 2}
 {:id 7 :parent-id 0 :val 100}
 {:id 8 :parent-id 7 :val 200}
 {:id 9 :parent-id 6 :val 3}]</pre><span>

And I would like to traverse all the :val for :id = 1 and all its descendants. Is it possible with specter?</span></div><div data-t="nathanmarz @pepe yes, you can do it with zippers"><span class="u" id="1529854161.000036">2018:06:24 15:29:21           nathanmarz </span><span>@pepe yes, you can do it with zippers</span></div><div data-t="pepe Is it that I have to first compose the tree first then?"><span class="u" id="1529854203.000017">2018:06:24 15:30:03                 pepe </span><span>Is it that I have to first compose the tree first then?</span></div><div data-t="nathanmarz no"><span class="u" id="1529854341.000004">2018:06:24 15:32:21           nathanmarz </span><span>no</span></div><div data-t="nathanmarz one sec I&apos;ll show you"><span class="u" id="1529854343.000057">2018:06:24 15:32:23           nathanmarz </span><span>one sec I&apos;ll show you</span></div><div data-t="nathanmarz @pepe
 (use &apos;com.rpl.specter)
(require &apos;[com.rpl.specter.zipper :as z])

(def data
  [{:id 0}
   {:id 1}
   {:id 2 :parent-id 1 :val 1}
   {:id 3 :parent-id 1 :val 1}
   {:id 4 :parent-id 2 :val 2}
   {:id 5 :parent-id 3 :val 2}
   {:id 6 :parent-id 3 :val 2}
   {:id 7 :parent-id 0 :val 100}
   {:id 8 :parent-id 7 :val 200}
   {:id 9 :parent-id 6 :val 3}])

(def TO-GRAPH (path z/VECTOR-ZIP z/DOWN))
(defn to-node [id]
  (z/find-first #(= (:id %) id))
  )

(def CHILDREN
  (path
    (collect-one z/NODE :id)
    z/LEFTMOST
    z/NEXT-WALK
    (collect-one z/NODE :parent-id)
    (collected? [id1 id2] (= id1 id2))
    DISPENSE
    ))

(def DESCENDANTS (recursive-path [] p (stay-then-continue CHILDREN p)))

(select [TO-GRAPH (to-node 1) DESCENDANTS z/NODE (must :val)] data)
"><span class="u" id="1529854653.000102">2018:06:24 15:37:33           nathanmarz </span><span>@pepe
</span><pre>(use &apos;com.rpl.specter)
(require &apos;[com.rpl.specter.zipper :as z])

(def data
  [{:id 0}
   {:id 1}
   {:id 2 :parent-id 1 :val 1}
   {:id 3 :parent-id 1 :val 1}
   {:id 4 :parent-id 2 :val 2}
   {:id 5 :parent-id 3 :val 2}
   {:id 6 :parent-id 3 :val 2}
   {:id 7 :parent-id 0 :val 100}
   {:id 8 :parent-id 7 :val 200}
   {:id 9 :parent-id 6 :val 3}])

(def TO-GRAPH (path z/VECTOR-ZIP z/DOWN))
(defn to-node [id]
  (z/find-first #(= (:id %) id))
  )

(def CHILDREN
  (path
    (collect-one z/NODE :id)
    z/LEFTMOST
    z/NEXT-WALK
    (collect-one z/NODE :parent-id)
    (collected? [id1 id2] (= id1 id2))
    DISPENSE
    ))

(def DESCENDANTS (recursive-path [] p (stay-then-continue CHILDREN p)))

(select [TO-GRAPH (to-node 1) DESCENDANTS z/NODE (must :val)] data)
</pre></div><div data-t="nathanmarz that said, it&apos;s a really bad representation for a tree"><span class="u" id="1529854667.000061">2018:06:24 15:37:47           nathanmarz </span><span>that said, it&apos;s a really bad representation for a tree</span></div><div data-t="pepe You mean my data? Yeah, some legacy stuff. I will try it and report back. Thank you very much for help!"><span class="u" id="1529854831.000013">2018:06:24 15:40:31                      pepe </span><span>You mean my data? Yeah, some legacy stuff. I will try it and report back. Thank you very much for help!</span></div><div data-t="pepe On some bigger trees I am getting  Maximum call stack size exceeded in CLJS. Indeed this representation is bad  😞"><span class="u" id="1529856422.000108">2018:06:24 16:07:02                      pepe </span><span>On some bigger trees I am getting  Maximum call stack size exceeded in CLJS. Indeed this representation is bad </span><b>😞</b></div><div data-t="pepe The thing as always, is that those data I am receiving from API. The call stack is exceeded in the recursive-path"><span class="u" id="1529858183.000127">2018:06:24 16:36:23                 pepe </span><span>The thing as always, is that those data I am receiving from API. The call stack is exceeded in the recursive-path</span></div><div data-t="nathanmarz @pepe you can do better with custom navigators rather than zippers"><span class="u" id="1529866559.000079">2018:06:24 18:55:59           nathanmarz </span><span>@pepe you can do better with custom navigators rather than zippers</span></div><div data-t="nathanmarz see  defnav"><span class="u" id="1529866623.000030">2018:06:24 18:57:03           nathanmarz </span><span>see </span><code>defnav</code></div><div data-t="nathanmarz navigate to pair of  [list-of-nodes index] , and then make custom  CHILDREN  navigator that does the search for indices that are direct children of currently navigated index"><span class="u" id="1529866683.000002">2018:06:24 18:58:03           nathanmarz </span><span>navigate to pair of </span><code>[list-of-nodes index]</code><span>, and then make custom </span><code>CHILDREN</code><span> navigator that does the search for indices that are direct children of currently navigated index</span></div><div data-t="pepe Thank you very much! I think it is little bit over my Specter-fu, but I will try."><span class="u" id="1529907296.000227">2018:06:25 06:14:56                      pepe </span><span>Thank you very much! I think it is little bit over my Specter-fu, but I will try.</span></div><div data-t="nathanmarz @pepe looks like
 (use &apos;com.rpl.specter)

(def data
  [{:id 0}
   {:id 1}
   {:id 2 :parent-id 1 :val 1}
   {:id 3 :parent-id 1 :val 1}
   {:id 4 :parent-id 2 :val 2}
   {:id 5 :parent-id 3 :val 2}
   {:id 6 :parent-id 3 :val 2}
   {:id 7 :parent-id 0 :val 100}
   {:id 8 :parent-id 7 :val 200}
   {:id 9 :parent-id 6 :val 3}])

(defn- node-index [graph id]
  (select-first
    [INDEXED-VALS
     (selected? LAST :id (pred= id))
     FIRST]
    graph
    ))

(defnav to-node [id]
  (select* [this graph next-fn]
    (if-let [i (node-index graph id)]
      (next-fn [graph i])
      NONE
      ))
  (transform* [this graph next-fn]
    (if-let [i (node-index graph id)]
      (first (next-fn [graph i]))
      graph
      )))

(defn- child-indices [graph id]
  (select
    [INDEXED-VALS
     (selected? LAST :parent-id (pred= id))
     FIRST]
    graph
    ))

(defnav CHILDREN []
  (select* [this [graph i] next-fn]
    (let [id (-&gt; graph (nth i) :id)
          child-i (child-indices graph id)]
      (if (empty? child-i)
        NONE
        (doseq [i child-i]
          (next-fn [graph i])
          ))))
  (transform* [this [graph i] next-fn]
    (let [id (-&gt; graph (nth i) :id)
          child-i (child-indices graph id)]
      (if (empty? child-i)
        [graph i]
        [(reduce
          (fn [graph ci] (first (next-fn [graph ci])))
          graph
          child-i
          )
         i]
         ))))

(defnav NODE []
  (select* [this [graph i] next-fn]
    (next-fn (nth graph i))
    )
  (transform* [this [graph i] next-fn]
    [(transform (nthpath i) next-fn graph) i]
    ))

(def DESCENDANTS (recursive-path [] p (stay-then-continue CHILDREN p)))
"><span class="u" id="1529925507.000309">2018:06:25 11:18:27           nathanmarz </span><span>@pepe looks like
</span><pre>(use &apos;com.rpl.specter)

(def data
  [{:id 0}
   {:id 1}
   {:id 2 :parent-id 1 :val 1}
   {:id 3 :parent-id 1 :val 1}
   {:id 4 :parent-id 2 :val 2}
   {:id 5 :parent-id 3 :val 2}
   {:id 6 :parent-id 3 :val 2}
   {:id 7 :parent-id 0 :val 100}
   {:id 8 :parent-id 7 :val 200}
   {:id 9 :parent-id 6 :val 3}])

(defn- node-index [graph id]
  (select-first
    [INDEXED-VALS
     (selected? LAST :id (pred= id))
     FIRST]
    graph
    ))

(defnav to-node [id]
  (select* [this graph next-fn]
    (if-let [i (node-index graph id)]
      (next-fn [graph i])
      NONE
      ))
  (transform* [this graph next-fn]
    (if-let [i (node-index graph id)]
      (first (next-fn [graph i]))
      graph
      )))

(defn- child-indices [graph id]
  (select
    [INDEXED-VALS
     (selected? LAST :parent-id (pred= id))
     FIRST]
    graph
    ))

(defnav CHILDREN []
  (select* [this [graph i] next-fn]
    (let [id (-&gt; graph (nth i) :id)
          child-i (child-indices graph id)]
      (if (empty? child-i)
        NONE
        (doseq [i child-i]
          (next-fn [graph i])
          ))))
  (transform* [this [graph i] next-fn]
    (let [id (-&gt; graph (nth i) :id)
          child-i (child-indices graph id)]
      (if (empty? child-i)
        [graph i]
        [(reduce
          (fn [graph ci] (first (next-fn [graph ci])))
          graph
          child-i
          )
         i]
         ))))

(defnav NODE []
  (select* [this [graph i] next-fn]
    (next-fn (nth graph i))
    )
  (transform* [this [graph i] next-fn]
    [(transform (nthpath i) next-fn graph) i]
    ))

(def DESCENDANTS (recursive-path [] p (stay-then-continue CHILDREN p)))
</pre></div><div data-t="pepe @U173SEFUN thank you very much for your time. I can&apos;t imagine coming with something like this myself. I will report back, how it works for me."><span class="u" id="1529931150.000399">2018:06:25 12:52:30                      pepe </span><span>@U173SEFUN thank you very much for your time. I can&apos;t imagine coming with something like this myself. I will report back, how it works for me.</span></div><div data-t="pepe I got to try it today and it again gives me Maximum call stack exceeded on around 1000 nodes. It seems I have to go recursive  🙂 . Still thank you very much, I have learned a lot from your code!"><span class="u" id="1530012911.000170">2018:06:26 11:35:11                      pepe </span><span>I got to try it today and it again gives me Maximum call stack exceeded on around 1000 nodes. It seems I have to go recursive </span><b>🙂</b><span>. Still thank you very much, I have learned a lot from your code!</span></div><div data-t="firstclassfunc Morning. I am trying to convert the  hiccup  output from  instaparse  into an associative structure. Is  specter  a good solution for converting  [:entity
 ([:name &quot;J&quot;]
  [:locations
   ([:address [:slot &quot;slot0&quot;] [:port &quot;1&quot;]]
    [:address [:slot &quot;slot1&quot;] [:port &quot;2&quot;]]
    [:address [:slot &quot;slot2&quot;] [:port &quot;3&quot;]]
    [:address [:slot &quot;slot3&quot;] [:port &quot;4&quot;]]
    [:address [:slot &quot;slot4&quot;] [:port &quot;5&quot;]]
    [:address [:slot &quot;slot5&quot;] [:port &quot;6&quot;]])])]   into  {:entity 
   [{:name &quot;J&quot;}
    {:locations 
     [{:address {:slot &quot;slot0&quot; :port &quot;1&quot;}} 
      {:address {:slot &quot;slot1&quot; :port &quot;2&quot;}}
      {:address {:slot &quot;slot2&quot; :port &quot;3&quot;}}
      {:address {:slot &quot;slot3&quot; :port &quot;4&quot;}}
      {:address {:slot &quot;slot4&quot; :port &quot;5&quot;}}
      {:address {:slot &quot;slot5&quot; :port &quot;6&quot;}}]}]} ?"><span class="u" id="1529932554.000085">2018:06:25 13:15:54       firstclassfunc </span><span>Morning. I am trying to convert the </span><code>hiccup</code><span> output from </span><code>instaparse</code><span> into an associative structure. Is </span><code>specter</code><span> a good solution for converting </span><pre>[:entity
 ([:name &quot;J&quot;]
  [:locations
   ([:address [:slot &quot;slot0&quot;] [:port &quot;1&quot;]]
    [:address [:slot &quot;slot1&quot;] [:port &quot;2&quot;]]
    [:address [:slot &quot;slot2&quot;] [:port &quot;3&quot;]]
    [:address [:slot &quot;slot3&quot;] [:port &quot;4&quot;]]
    [:address [:slot &quot;slot4&quot;] [:port &quot;5&quot;]]
    [:address [:slot &quot;slot5&quot;] [:port &quot;6&quot;]])])]</pre><span>  into </span><pre>{:entity 
   [{:name &quot;J&quot;}
    {:locations 
     [{:address {:slot &quot;slot0&quot; :port &quot;1&quot;}} 
      {:address {:slot &quot;slot1&quot; :port &quot;2&quot;}}
      {:address {:slot &quot;slot2&quot; :port &quot;3&quot;}}
      {:address {:slot &quot;slot3&quot; :port &quot;4&quot;}}
      {:address {:slot &quot;slot4&quot; :port &quot;5&quot;}}
      {:address {:slot &quot;slot5&quot; :port &quot;6&quot;}}]}]}</pre><span>?</span></div><div data-t="nathanmarz @firstclassfunc is the transformation vector -&gt; map and list -&gt; vector for all reachable vectors and lists?"><span class="u" id="1529932832.000800">2018:06:25 13:20:32           nathanmarz </span><span>@firstclassfunc is the transformation vector -&gt; map and list -&gt; vector for all reachable vectors and lists?</span></div><div data-t="firstclassfunc yes"><span class="u" id="1529932861.000526">2018:06:25 13:21:01       firstclassfunc </span><span>yes</span></div><div data-t="nathanmarz oh it&apos;s a little more complicated"><span class="u" id="1529933352.000172">2018:06:25 13:29:12           nathanmarz </span><span>oh it&apos;s a little more complicated</span></div><div data-t="nathanmarz since the  :slot  and  :port  vectors get combined into a single map"><span class="u" id="1529933387.000049">2018:06:25 13:29:47           nathanmarz </span><span>since the </span><code>:slot</code><span> and </span><code>:port</code><span> vectors get combined into a single map</span></div><div data-t="firstclassfunc ok well it can be done in multiple steps.."><span class="u" id="1529933406.000770">2018:06:25 13:30:06       firstclassfunc </span><span>ok well it can be done in multiple steps..</span></div><div data-t="nathanmarz but the general structure is
 (def NODES
  (recursive-path [] p
    (if-path coll?
      (continue-then-stay ALL p)
      )))

(multi-transform
  [NODES
   (if-path vector?
     (terminal vec-&gt;map)
     (terminal vec)
     )]
  data
  )
"><span class="u" id="1529933428.000310">2018:06:25 13:30:28           nathanmarz </span><span>but the general structure is
</span><pre>(def NODES
  (recursive-path [] p
    (if-path coll?
      (continue-then-stay ALL p)
      )))

(multi-transform
  [NODES
   (if-path vector?
     (terminal vec-&gt;map)
     (terminal vec)
     )]
  data
  )
</pre></div><div data-t="nathanmarz you fill in the  vec-&gt;map  function"><span class="u" id="1529933436.000556">2018:06:25 13:30:36           nathanmarz </span><span>you fill in the </span><code>vec-&gt;map</code><span> function</span></div><div data-t="firstclassfunc ah cool. Thanks so much (y)"><span class="u" id="1529933450.000040">2018:06:25 13:30:50       firstclassfunc </span><span>ah cool. Thanks so much (y)</span></div><div data-t="vigilancetech Can anyone tell me why I&apos;m getting: WARNING: Use of undeclared Var hello-world.core/ALL....??   Here&apos;s a repo that demos the error for me:

 https://github.com/vigilancetech-com/hello-world"><span class="u" id="1529983930.000066">2018:06:26 03:32:10        vigilancetech </span><span>Can anyone tell me why I&apos;m getting: WARNING: Use of undeclared Var hello-world.core/ALL....??   Here&apos;s a repo that demos the error for me:

</span><a href="https://github.com/vigilancetech-com/hello-world">https://github.com/vigilancetech-com/hello-world</a></div><div data-t="pepe Both ALL and END needs to have namespace so in your case sp/ALL sp/END"><span class="u" id="1530001434.000569">2018:06:26 08:23:54                      pepe </span><span>Both ALL and END needs to have namespace so in your case sp/ALL sp/END</span></div><div data-t="vigilancetech ah!   That&apos;s it!   Thank you!  It was my misperception that the leading macro (select, transform, setval, etc...) processed those kind of like keywords and not that they were functions in and of themselves."><span class="u" id="1530023933.000035">2018:06:26 14:38:53             vigilancetech </span><span>ah!   That&apos;s it!   Thank you!  It was my misperception that the leading macro (select, transform, setval, etc...) processed those kind of like keywords and not that they were functions in and of themselves.</span></div><div data-t="zalky Hi all, can anyone help explain the difference between  selected?  and  filterer ? Bit hazy on the difference."><span class="u" id="1530192636.000262">2018:06:28 13:30:36                zalky </span><span>Hi all, can anyone help explain the difference between </span><code>selected?</code><span> and </span><code>filterer</code><span>? Bit hazy on the difference.</span></div><div data-t="zalky Oh, hmm... nm, I think I figured it out."><span class="u" id="1530193131.000408">2018:06:28 13:38:51                zalky </span><span>Oh, hmm... nm, I think I figured it out.</span></div><div data-t="Bravi why isn’t this library in core?  😄"><span class="u" id="1530297233.000336">2018:06:29 18:33:53                Bravi </span><span>why isn’t this library in core? </span><b>😄</b></div><div data-t="Bravi this is so powerful!"><span class="u" id="1530297240.000126">2018:06:29 18:34:00                Bravi </span><span>this is so powerful!</span></div><div data-t="Bravi something I would have written in JS like this:
 userGroups
  .map(group =&gt; ({
    ...group,
    users: group.users
      .map( user =&gt;  &amp;&amp; user.profileViews &amp;&amp; user.profileViews.count &gt; 0
            ? ({...user,
                profileViews: {
                  ...user.profileViews,
                  count: user.profileViews.count + 1,
                }})
            : user
          )
  }));
 
managed to write using specter like this
 (transform [ALL :users ALL #(:online %) :profile-views :count (partial &lt; 0)] inc)
"><span class="u" id="1530297343.000304">2018:06:29 18:35:43                Bravi </span><span>something I would have written in JS like this:
</span><pre>userGroups
  .map(group =&gt; ({
    ...group,
    users: group.users
      .map( user =&gt;  &amp;&amp; user.profileViews &amp;&amp; user.profileViews.count &gt; 0
            ? ({...user,
                profileViews: {
                  ...user.profileViews,
                  count: user.profileViews.count + 1,
                }})
            : user
          )
  }));
</pre><span>
managed to write using specter like this
</span><pre>(transform [ALL :users ALL #(:online %) :profile-views :count (partial &lt; 0)] inc)
</pre></div><div data-t="pepe And you only scratched the surface in your example. I am doing things with it, I strongly believe are almost impossible in other langs/libs. And I still consider myself Specter newbie  🙂"><span class="u" id="1530628940.000133">2018:07:03 14:42:20                      pepe </span><span>And you only scratched the surface in your example. I am doing things with it, I strongly believe are almost impossible in other langs/libs. And I still consider myself Specter newbie </span><b>🙂</b></div><div data-t="Bravi would you mind posting some examples please? I’m struggling to find some good examples / solutions to problems"><span class="u" id="1530714318.000327">2018:07:04 14:25:18                     Bravi </span><span>would you mind posting some examples please? I’m struggling to find some good examples / solutions to problems</span></div><div data-t="nathanmarz @bravilogy  https://groups.google.com/forum/#!searchin/clojure/contribute$20specter%7Csort:date/clojure/qN1UPMVQmaM/uVUYENF6BwAJ"><span class="u" id="1530298838.000392">2018:06:29 19:00:38           nathanmarz </span><span>@bravilogy </span><a href="https://groups.google.com/forum/#!searchin/clojure/contribute$20specter%7Csort:date/clojure/qN1UPMVQmaM/uVUYENF6BwAJ">https://groups.google.com/forum/#!searchin/clojure/contribute$20specter%7Csort:date/clojure/qN1UPMVQmaM/uVUYENF6BwAJ</a></div><div data-t="jsa-aerial say you have a map { ... K V} and you are transforming the map via ALL with a transform function which returns NONE for V, strictly speaking you return [K NONE]. This seems to remove the [K V] pair entirely (exactly what I would like) but I can&apos;t find anything in the documentation indicating that this is the intended behavior. There are things addressing map KEYS being xformed to NONE for removal, but nothing about values. Is this intended behavior that can be counted on in future?"><span class="u" id="1530395164.000062">2018:06:30 21:46:04           jsa-aerial </span><span>say you have a map { ... K V} and you are transforming the map via ALL with a transform function which returns NONE for V, strictly speaking you return [K NONE]. This seems to remove the [K V] pair entirely (exactly what I would like) but I can&apos;t find anything in the documentation indicating that this is the intended behavior. There are things addressing map KEYS being xformed to NONE for removal, but nothing about values. Is this intended behavior that can be counted on in future?</span></div><div data-t="nathanmarz @jsa-aerial yes, that&apos;s intended behavior"><span class="u" id="1530407091.000037">2018:07:01 01:04:51           nathanmarz </span><span>@jsa-aerial yes, that&apos;s intended behavior</span></div><div data-t="jsa-aerial suppose you do not have a fixed (literal) path for things like setval, transform, etc. So, you have something like  (transform [ATOM (apply keypath ks)] inc db) . Does the &apos;This macro will do inline compilation and caching of the path.&apos; still apply in this sort of situation? If not, is it still comparable in performance to update-in?"><span class="u" id="1530890688.000423">2018:07:06 15:24:48           jsa-aerial </span><span>suppose you do not have a fixed (literal) path for things like setval, transform, etc. So, you have something like </span><code>(transform [ATOM (apply keypath ks)] inc db)</code><span>. Does the &apos;This macro will do inline compilation and caching of the path.&apos; still apply in this sort of situation? If not, is it still comparable in performance to update-in?</span></div><div data-t="jsa-aerial @nathanmarz ^^^"><span class="u" id="1530890711.000452">2018:07:06 15:25:11           jsa-aerial </span><span>@nathanmarz ^^^</span></div><div data-t="nathanmarz @jsa-aerial since  ks  is not static, you pay the cost of the  apply  and the  keypath  expansion on every invocation"><span class="u" id="1530898649.000012">2018:07:06 17:37:29           nathanmarz </span><span>@jsa-aerial since </span><code>ks</code><span> is not static, you pay the cost of the </span><code>apply</code><span> and the </span><code>keypath</code><span> expansion on every invocation</span></div><div data-t="nathanmarz not sure how it will compare to  update-in  but there will be a noticeable performance hit"><span class="u" id="1530898699.000105">2018:07:06 17:38:19           nathanmarz </span><span>not sure how it will compare to </span><code>update-in</code><span> but there will be a noticeable performance hit</span></div><div data-t="jsa-aerial Adventures in CLJS now... I require  [com.rpl.specter :as sp]  and require-macros  [com.rpl.specter.macros :refer [select-one transform setval]] .  When trying to compile, the following is issued: &apos;Invalid :refer, macro com.rpl.specter.macros/setval does not exist&apos;."><span class="u" id="1531181532.000083">2018:07:10 00:12:12           jsa-aerial </span><span>Adventures in CLJS now... I require </span><code>[com.rpl.specter :as sp]</code><span> and require-macros </span><code>[com.rpl.specter.macros :refer [select-one transform setval]]</code><span>.  When trying to compile, the following is issued: &apos;Invalid :refer, macro com.rpl.specter.macros/setval does not exist&apos;.</span></div><div data-t="jsa-aerial I am using figwheel"><span class="u" id="1531181548.000114">2018:07:10 00:12:28           jsa-aerial </span><span>I am using figwheel</span></div><div data-t="jsa-aerial Anyone using Specter in CLJS land have any ideas?"><span class="u" id="1531181577.000115">2018:07:10 00:12:57           jsa-aerial </span><span>Anyone using Specter in CLJS land have any ideas?</span></div><div data-t="jsa-aerial OK, it looking further in the doc, I see the CLJS incantation. Let me try that and see if it makes this go away."><span class="u" id="1531181724.000066">2018:07:10 00:15:24           jsa-aerial </span><span>OK, it looking further in the doc, I see the CLJS incantation. Let me try that and see if it makes this go away.</span></div><div data-t="jsa-aerial Yes, that fixes it. Sorry for the noise."><span class="u" id="1531181897.000038">2018:07:10 00:18:17           jsa-aerial </span><span>Yes, that fixes it. Sorry for the noise.</span></div><div data-t="souenzzo Require from com.rpl.specter. this namespace .macros is not used anymore"><span class="u" id="1531223656.000276">2018:07:10 11:54:16             souenzzo </span><span>Require from com.rpl.specter. this namespace .macros is not used anymore</span></div><div data-t="Bravi @jsa-aerial I always use  sp/select-one ,  sp/ALL  and etc"><span class="u" id="1531226615.000364">2018:07:10 12:43:35                Bravi </span><span>@jsa-aerial I always use </span><code>sp/select-one</code><span>, </span><code>sp/ALL</code><span> and etc</span></div><div data-t="Bravi in cljs"><span class="u" id="1531226619.000348">2018:07:10 12:43:39                Bravi </span><span>in cljs</span></div><div data-t="jsa-aerial @bravilogy That&apos;s what I do in CLJ - always namspace qualified for everything. But I thought you needed to explicitly name the macros in a require-macros or :refer-macros them for them to be available in CLJS land. Since macros are expanded and such in the JVM (well unless you are using self hosted) I admit I don&apos;t really understand the implementation details of how they are made available in CLJS."><span class="u" id="1531232150.000361">2018:07:10 14:15:50           jsa-aerial </span><span>@bravilogy That&apos;s what I do in CLJ - always namspace qualified for everything. But I thought you needed to explicitly name the macros in a require-macros or :refer-macros them for them to be available in CLJS land. Since macros are expanded and such in the JVM (well unless you are using self hosted) I admit I don&apos;t really understand the implementation details of how they are made available in CLJS.</span></div><div data-t="Bravi yeah I was just implying the fact that specter works differently in cljs, hence I don’t investigate any further than that  😄  haha. i just namespace them all"><span class="u" id="1531232684.000561">2018:07:10 14:24:44                Bravi </span><span>yeah I was just implying the fact that specter works differently in cljs, hence I don’t investigate any further than that </span><b>😄</b><span> haha. i just namespace them all</span></div><div data-t="jsa-aerial Well, other than pulling in the macro stuff (which is anything in cljs land) all the specter code I am using works exactly as in clojure. Very cool!"><span class="u" id="1531234366.000023">2018:07:10 14:52:46           jsa-aerial </span><span>Well, other than pulling in the macro stuff (which is anything in cljs land) all the specter code I am using works exactly as in clojure. Very cool!</span></div><div data-t="jsa-aerial No &apos;porting&apos; at all - just use!"><span class="u" id="1531234386.000092">2018:07:10 14:53:06           jsa-aerial </span><span>No &apos;porting&apos; at all - just use!</span></div><div data-t="funkrider hi - as a cljs noob I want to try out specter at the repl. I am using  (require &apos;[com.rpl.specter :as sp])  and then if i try to invoke a test using:  (sp/select [sp/ALL] [1 2])    i get a big nasty error about  No protocol method ImplicitNav.implicit-nav defined for type com.rpl.specter/t_com$specter79300: [object Object]]"><span class="u" id="1531343002.000515">2018:07:11 21:03:22            funkrider </span><span>hi - as a cljs noob I want to try out specter at the repl. I am using </span><code>(require &apos;[com.rpl.specter :as sp])</code><span> and then if i try to invoke a test using: </span><code>(sp/select [sp/ALL] [1 2])</code><span>   i get a big nasty error about </span><code>No protocol method ImplicitNav.implicit-nav defined for type com.rpl.specter/t_com$specter79300: [object Object]]</code></div><div data-t="funkrider Any help would be most appreciated"><span class="u" id="1531343011.000450">2018:07:11 21:03:31            funkrider </span><span>Any help would be most appreciated</span></div><div data-t="nathanmarz @ian.davies works fine for me"><span class="u" id="1531343590.000075">2018:07:11 21:13:10           nathanmarz </span><span>@ian.davies works fine for me</span></div><div data-t="nathanmarz try doing it from a checkout of specter from github"><span class="u" id="1531343653.000057">2018:07:11 21:14:13           nathanmarz </span><span>try doing it from a checkout of specter from github</span></div><div data-t="nathanmarz run  ./scripts/cljs-repl.sh"><span class="u" id="1531343672.000450">2018:07:11 21:14:32           nathanmarz </span><span>run </span><code>./scripts/cljs-repl.sh</code></div><div data-t="pepe I did not know about this. It is cool."><span class="u" id="1531381492.000098">2018:07:12 07:44:52                      pepe </span><span>I did not know about this. It is cool.</span></div><div data-t="funkrider oh ok ill give it a go. Thanks @nathanmarz"><span class="u" id="1531344386.000143">2018:07:11 21:26:26            funkrider </span><span>oh ok ill give it a go. Thanks @nathanmarz</span></div><div data-t="vigilancetech I got this strange situation:  I&apos;m using specter from clojurescript (hoplon) to build up a map in a function which when I feed it by hand works fine, but when I map values into it, it munges the map up.   Is mapping it making it try and do the operations in parallel somehow?   If so, how would I serialize them?"><span class="u" id="1531406365.000047">2018:07:12 14:39:25        vigilancetech </span><span>I got this strange situation:  I&apos;m using specter from clojurescript (hoplon) to build up a map in a function which when I feed it by hand works fine, but when I map values into it, it munges the map up.   Is mapping it making it try and do the operations in parallel somehow?   If so, how would I serialize them?</span></div><div data-t="nathanmarz @vigilancetech can you show the code?"><span class="u" id="1531406986.000538">2018:07:12 14:49:46           nathanmarz </span><span>@vigilancetech can you show the code?</span></div><div data-t="vigilancetech (defn stow-effect! [dev effect]
  (let [x (sp/setval [:lights (id-&gt;type dev) (id-&gt;key dev)] effect (:root @ui-state))
        y (sp/setval [:lights :all (id-&gt;key dev)] effect x)]
    ;(s/set-ui-state! @conn y)
    ;; there&apos;s some kind of issue with multi-processing here
    (reset! ui-state (sp/setval [:root] y @ui-state))))
"><span class="u" id="1531407131.000556">2018:07:12 14:52:11        vigilancetech </span><pre>(defn stow-effect! [dev effect]
  (let [x (sp/setval [:lights (id-&gt;type dev) (id-&gt;key dev)] effect (:root @ui-state))
        y (sp/setval [:lights :all (id-&gt;key dev)] effect x)]
    ;(s/set-ui-state! @conn y)
    ;; there&apos;s some kind of issue with multi-processing here
    (reset! ui-state (sp/setval [:root] y @ui-state))))
</pre></div><div data-t="vigilancetech (defn checkbox-checked [device-type]
  (let [x (map vals (sp/select [(n-device-records device-type) (sp/submap [:id :effect])] @data))]
    (map #(apply stow-effect! %) x)
    x))
"><span class="u" id="1531407153.000207">2018:07:12 14:52:33        vigilancetech </span><pre>(defn checkbox-checked [device-type]
  (let [x (map vals (sp/select [(n-device-records device-type) (sp/submap [:id :effect])] @data))]
    (map #(apply stow-effect! %) x)
    x))
</pre></div><div data-t="vigilancetech when I feed it with the second function it makes multiple :root tags, but when I feed it by hand it works properly making only one"><span class="u" id="1531407328.000646">2018:07:12 14:55:28        vigilancetech </span><span>when I feed it with the second function it makes multiple :root tags, but when I feed it by hand it works properly making only one</span></div><div data-t="nathanmarz what is  n-device-records ,  id-&gt;type ,  id-&gt;key ?"><span class="u" id="1531407704.000458">2018:07:12 15:01:44           nathanmarz </span><span>what is </span><code>n-device-records</code><span>, </span><code>id-&gt;type</code><span>, </span><code>id-&gt;key</code><span>?</span></div><div data-t="nathanmarz and what do you mean by &quot;makes multiple :root tags&quot;?"><span class="u" id="1531407806.000142">2018:07:12 15:03:26           nathanmarz </span><span>and what do you mean by &quot;makes multiple :root tags&quot;?</span></div><div data-t="nathanmarz doesn&apos;t look like  (map #(apply stow-effect! %) x)  will do anything"><span class="u" id="1531408557.000604">2018:07:12 15:15:57           nathanmarz </span><span>doesn&apos;t look like </span><code>(map #(apply stow-effect! %) x)</code><span> will do anything</span></div><div data-t="nathanmarz since  map  is lazy"><span class="u" id="1531408562.000527">2018:07:12 15:16:02           nathanmarz </span><span>since </span><code>map</code><span> is lazy</span></div><div data-t="vigilancetech cljs.user&gt; (s/set-ui-state! @d/conn nil )
nil
cljs.user&gt; (s/get-ui-state @d/conn)
nil
cljs.user&gt; @d/ui-state
{:root nil}
cljs.user&gt; (d/checkbox-checked :fan)
((&quot;Fan 0&quot; &quot;roll&quot;) (&quot;Fan 1&quot; &quot;static_color&quot;) (&quot;Fan 2&quot; &quot;none&quot;) (&quot;Fan 3&quot; &quot;none&quot;) (&quot;Fan 4&quot; &quot;none&quot;) (&quot;Fan 5&quot; &quot;none&quot;))
cljs.user&gt; @d/ui-state
{:root nil}
cljs.user&gt; (s/get-ui-state @d/conn)
nil
cljs.user&gt; @d/ui-state
{:root nil}
cljs.user&gt; (d/stow-effect! &quot;Fan 0&quot; &quot;roll&quot;)
{:root {:lights {:all {:Fan_0 &quot;roll&quot;}, :fan {:Fan_0 &quot;roll&quot;}}}}
cljs.user&gt; @d/ui-state
{:root {:lights {:all {:Fan_0 &quot;roll&quot;}, :fan {:Fan_0 &quot;roll&quot;}}}}
cljs.user&gt; (d/stow-effect! &quot;Fan 1&quot; &quot;static_color&quot;)
{:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}}}}
cljs.user&gt; (d/stow-effect! &quot;Fan 2&quot; &quot;none&quot;)
{:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}}}}
cljs.user&gt; (d/stow-effect! &quot;Strip 0&quot; &quot;police&quot;)
{:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Strip_0 &quot;police&quot;}, :strip {:Strip_0 &quot;police&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}}}}
cljs.user&gt; (s/set-ui-state! @d/conn nil )
nil
cljs.user&gt; (s/get-ui-state @d/conn)
nil
cljs.user&gt; @d/ui-state
{:root nil}
cljs.user&gt; (map #(apply d/stow-effect! %) &apos;((&quot;Fan 0&quot; &quot;roll&quot;) (&quot;Fan 1&quot; &quot;static_color&quot;) (&quot;Fan 2&quot; &quot;none&quot;) (&quot;Fan 3&quot; &quot;none&quot;) (&quot;Fan 4&quot; &quot;none&quot;) (&quot;Fan 5&quot; &quot;none&quot;)))
({:root {:lights {:all {:Fan_0 &quot;roll&quot;}, :fan {:Fan_0 &quot;roll&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_3 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_3 &quot;none&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_5 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_5 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}}}})
cljs.user&gt; 
"><span class="u" id="1531408937.000282">2018:07:12 15:22:17        vigilancetech </span><pre>cljs.user&gt; (s/set-ui-state! @d/conn nil )
nil
cljs.user&gt; (s/get-ui-state @d/conn)
nil
cljs.user&gt; @d/ui-state
{:root nil}
cljs.user&gt; (d/checkbox-checked :fan)
((&quot;Fan 0&quot; &quot;roll&quot;) (&quot;Fan 1&quot; &quot;static_color&quot;) (&quot;Fan 2&quot; &quot;none&quot;) (&quot;Fan 3&quot; &quot;none&quot;) (&quot;Fan 4&quot; &quot;none&quot;) (&quot;Fan 5&quot; &quot;none&quot;))
cljs.user&gt; @d/ui-state
{:root nil}
cljs.user&gt; (s/get-ui-state @d/conn)
nil
cljs.user&gt; @d/ui-state
{:root nil}
cljs.user&gt; (d/stow-effect! &quot;Fan 0&quot; &quot;roll&quot;)
{:root {:lights {:all {:Fan_0 &quot;roll&quot;}, :fan {:Fan_0 &quot;roll&quot;}}}}
cljs.user&gt; @d/ui-state
{:root {:lights {:all {:Fan_0 &quot;roll&quot;}, :fan {:Fan_0 &quot;roll&quot;}}}}
cljs.user&gt; (d/stow-effect! &quot;Fan 1&quot; &quot;static_color&quot;)
{:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}}}}
cljs.user&gt; (d/stow-effect! &quot;Fan 2&quot; &quot;none&quot;)
{:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}}}}
cljs.user&gt; (d/stow-effect! &quot;Strip 0&quot; &quot;police&quot;)
{:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Strip_0 &quot;police&quot;}, :strip {:Strip_0 &quot;police&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}}}}
cljs.user&gt; (s/set-ui-state! @d/conn nil )
nil
cljs.user&gt; (s/get-ui-state @d/conn)
nil
cljs.user&gt; @d/ui-state
{:root nil}
cljs.user&gt; (map #(apply d/stow-effect! %) &apos;((&quot;Fan 0&quot; &quot;roll&quot;) (&quot;Fan 1&quot; &quot;static_color&quot;) (&quot;Fan 2&quot; &quot;none&quot;) (&quot;Fan 3&quot; &quot;none&quot;) (&quot;Fan 4&quot; &quot;none&quot;) (&quot;Fan 5&quot; &quot;none&quot;)))
({:root {:lights {:all {:Fan_0 &quot;roll&quot;}, :fan {:Fan_0 &quot;roll&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_3 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_3 &quot;none&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_5 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_5 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}}}})
cljs.user&gt; 
</pre></div><div data-t="nathanmarz the repl realizes lazy sequences when it prints it"><span class="u" id="1531408996.000616">2018:07:12 15:23:16           nathanmarz </span><span>the repl realizes lazy sequences when it prints it</span></div><div data-t="nathanmarz the way you wrote  checkbox-checked  will not"><span class="u" id="1531409037.000210">2018:07:12 15:23:57           nathanmarz </span><span>the way you wrote </span><code>checkbox-checked</code><span> will not</span></div><div data-t="nathanmarz better to write that sort of code with  doseq"><span class="u" id="1531409055.000020">2018:07:12 15:24:15           nathanmarz </span><span>better to write that sort of code with </span><code>doseq</code></div><div data-t="vigilancetech ah, okay"><span class="u" id="1531409126.000599">2018:07:12 15:25:26        vigilancetech </span><span>ah, okay</span></div><div data-t="vigilancetech think that&apos;ll fix the multiple :root tag thing?"><span class="u" id="1531409139.000458">2018:07:12 15:25:39        vigilancetech </span><span>think that&apos;ll fix the multiple :root tag thing?</span></div><div data-t="nathanmarz don&apos;t know what you mean by that"><span class="u" id="1531409202.000240">2018:07:12 15:26:42           nathanmarz </span><span>don&apos;t know what you mean by that</span></div><div data-t="nathanmarz or what those other function references are"><span class="u" id="1531409223.000229">2018:07:12 15:27:03           nathanmarz </span><span>or what those other function references are</span></div><div data-t="vigilancetech (defn n-device-records [type] [:lights sp/ALL #(= (:type %) type)])"><span class="u" id="1531409338.000563">2018:07:12 15:28:58        vigilancetech </span><span>(defn n-device-records [type] [:lights sp/ALL #(= (:type %) type)])</span></div><div data-t="vigilancetech (defn id-&gt;key [id] (keyword (st/replace id \space \_)))"><span class="u" id="1531409367.000627">2018:07:12 15:29:27        vigilancetech </span><span>(defn id-&gt;key [id] (keyword (st/replace id \space \_)))</span></div><div data-t="vigilancetech (defn id-&gt;type [id] (let [x (st/split (st/lower-case id) #&quot; &quot;)]
                      (keyword (if (&gt; (count x) 2)
                                 (str (first x) \_ (second x))
                                 (first x)))))

"><span class="u" id="1531409413.000389">2018:07:12 15:30:13        vigilancetech </span><pre>(defn id-&gt;type [id] (let [x (st/split (st/lower-case id) #&quot; &quot;)]
                      (keyword (if (&gt; (count x) 2)
                                 (str (first x) \_ (second x))
                                 (first x)))))

</pre></div><div data-t="vigilancetech n-device-records navigates to all the records for a certain type of device.  The others just convert from a string to a (spaceless) tag"><span class="u" id="1531409473.000458">2018:07:12 15:31:13        vigilancetech </span><span>n-device-records navigates to all the records for a certain type of device.  The others just convert from a string to a (spaceless) tag</span></div><div data-t="vigilancetech thing is when I feed stow-effect! by hand, it builds ui-state properly with only one root tag, but when I map the values in, it screws it up, appending multiple root tags"><span class="u" id="1531409542.000104">2018:07:12 15:32:22        vigilancetech </span><span>thing is when I feed stow-effect! by hand, it builds ui-state properly with only one root tag, but when I map the values in, it screws it up, appending multiple root tags</span></div><div data-t="vigilancetech could that be a specter thing?  Or does that have something to do with map parallelizing the operation?"><span class="u" id="1531409825.000166">2018:07:12 15:37:05        vigilancetech </span><span>could that be a specter thing?  Or does that have something to do with map parallelizing the operation?</span></div><div data-t="alexyakushev In fact, map can&apos;t &quot;parallelize&quot; anything."><span class="u" id="1531409894.000206">2018:07:12 15:38:14         alexyakushev </span><span>In fact, map can&apos;t &quot;parallelize&quot; anything.</span></div><div data-t="alexyakushev Try replacing  map  with  mapv , would it work?"><span class="u" id="1531409908.000571">2018:07:12 15:38:28         alexyakushev </span><span>Try replacing </span><code>map</code><span> with </span><code>mapv</code><span>, would it work?</span></div><div data-t="vigilancetech nope, same thing"><span class="u" id="1531410070.000279">2018:07:12 15:41:10        vigilancetech </span><span>nope, same thing</span></div><div data-t="nathanmarz where is it appending multiple root tags?"><span class="u" id="1531410831.000147">2018:07:12 15:53:51           nathanmarz </span><span>where is it appending multiple root tags?</span></div><div data-t="vigilancetech when I do:
 (mapv #(apply d/stow-effect! %) &apos;((&quot;Fan 0&quot; &quot;roll&quot;) (&quot;Fan 1&quot; &quot;static_color&quot;) (&quot;Fan 2&quot; &quot;none&quot;) (&quot;Fan 3&quot; &quot;none&quot;) (&quot;Fan 4&quot; &quot;none&quot;) (&quot;Fan 5&quot; &quot;none&quot;)))
"><span class="u" id="1531410877.000422">2018:07:12 15:54:37        vigilancetech </span><span>when I do:
</span><pre>(mapv #(apply d/stow-effect! %) &apos;((&quot;Fan 0&quot; &quot;roll&quot;) (&quot;Fan 1&quot; &quot;static_color&quot;) (&quot;Fan 2&quot; &quot;none&quot;) (&quot;Fan 3&quot; &quot;none&quot;) (&quot;Fan 4&quot; &quot;none&quot;) (&quot;Fan 5&quot; &quot;none&quot;)))
</pre></div><div data-t="vigilancetech the result has multiple root tags, but if I feed those values in by hand, it works correctly, with only one root tag"><span class="u" id="1531410899.000307">2018:07:12 15:54:59        vigilancetech </span><span>the result has multiple root tags, but if I feed those values in by hand, it works correctly, with only one root tag</span></div><div data-t="vigilancetech its supposed to be {:root {:lights {:all {all records} {:fan {fan devices} :strip {strip devices.}}}}}"><span class="u" id="1531410978.000193">2018:07:12 15:56:18        vigilancetech </span><span>its supposed to be {:root {:lights {:all {all records} {:fan {fan devices} :strip {strip devices.}}}}}</span></div><div data-t="nathanmarz by result you mean the value of the atom  ui-state ?"><span class="u" id="1531411047.000604">2018:07:12 15:57:27           nathanmarz </span><span>by result you mean the value of the atom </span><code>ui-state</code><span>?</span></div><div data-t="vigilancetech yes"><span class="u" id="1531411060.000457">2018:07:12 15:57:40        vigilancetech </span><span>yes</span></div><div data-t="nathanmarz what does it look like before and after?"><span class="u" id="1531411089.000170">2018:07:12 15:58:09           nathanmarz </span><span>what does it look like before and after?</span></div><div data-t="vigilancetech the results are in the code display above."><span class="u" id="1531411110.000355">2018:07:12 15:58:30        vigilancetech </span><span>the results are in the code display above.</span></div><div data-t="nathanmarz I think you&apos;re reading the repl wrong"><span class="u" id="1531411177.000017">2018:07:12 15:59:37           nathanmarz </span><span>I think you&apos;re reading the repl wrong</span></div><div data-t="nathanmarz the sequence there is the result of  map"><span class="u" id="1531411183.000007">2018:07:12 15:59:43           nathanmarz </span><span>the sequence there is the result of </span><code>map</code></div><div data-t="nathanmarz which is showing the iterative changes to  ui-state"><span class="u" id="1531411195.000192">2018:07:12 15:59:55           nathanmarz </span><span>which is showing the iterative changes to </span><code>ui-state</code></div><div data-t="nathanmarz the final value in that sequence is the final value of  ui-state"><span class="u" id="1531411202.000473">2018:07:12 16:00:02           nathanmarz </span><span>the final value in that sequence is the final value of </span><code>ui-state</code></div><div data-t="alexyakushev I&apos;d suggest you minimize the reproducible case, it&apos;s really hard to follow without the context and the CLJS at hand."><span class="u" id="1531411217.000145">2018:07:12 16:00:17         alexyakushev </span><span>I&apos;d suggest you minimize the reproducible case, it&apos;s really hard to follow without the context and the CLJS at hand.</span></div><div data-t="vigilancetech oh, so maybe it IS working and the repl is just printing out intermediate results"><span class="u" id="1531411255.000190">2018:07:12 16:00:55        vigilancetech </span><span>oh, so maybe it IS working and the repl is just printing out intermediate results</span></div><div data-t="nathanmarz just do  @ui-state"><span class="u" id="1531411298.000581">2018:07:12 16:01:38           nathanmarz </span><span>just do </span><code>@ui-state</code></div><div data-t="vigilancetech yup, you&apos;re right.   When I check ui-state its correct.   Thanks.  That had me baffled"><span class="u" id="1531411301.000325">2018:07:12 16:01:41        vigilancetech </span><span>yup, you&apos;re right.   When I check ui-state its correct.   Thanks.  That had me baffled</span></div><div data-t="vigilancetech seems like most (lisp) repls I&apos;ve used before only show the final return value"><span class="u" id="1531411333.000480">2018:07:12 16:02:13        vigilancetech </span><span>seems like most (lisp) repls I&apos;ve used before only show the final return value</span></div><div data-t="alexyakushev Since you are doing  map , you get the list of values anyway."><span class="u" id="1531411362.000243">2018:07:12 16:02:42         alexyakushev </span><span>Since you are doing </span><code>map</code><span>, you get the list of values anyway.</span></div><div data-t="alexyakushev The final form of  stow-effect!  is a  reset!  call"><span class="u" id="1531411396.000531">2018:07:12 16:03:16         alexyakushev </span><span>The final form of </span><code>stow-effect!</code><span> is a </span><code>reset!</code><span> call</span></div><div data-t="alexyakushev reset!  sets a new value for an atom and returns that value too"><span class="u" id="1531411413.000091">2018:07:12 16:03:33         alexyakushev </span><code>reset!</code><span> sets a new value for an atom and returns that value too</span></div><div data-t="vigilancetech so that&apos;s where the accumulation is happening; yeah, makes sense now, since I&apos;m taking the side effect of that map rather than its result"><span class="u" id="1531411475.000574">2018:07:12 16:04:35        vigilancetech </span><span>so that&apos;s where the accumulation is happening; yeah, makes sense now, since I&apos;m taking the side effect of that map rather than its result</span></div><div data-t="alexyakushev Yep"><span class="u" id="1531411484.000236">2018:07:12 16:04:44         alexyakushev </span><span>Yep</span></div><div data-t="alexyakushev Also, if you need  map  for side effects only, you can use  run!  instead"><span class="u" id="1531411498.000180">2018:07:12 16:04:58         alexyakushev </span><span>Also, if you need </span><code>map</code><span> for side effects only, you can use </span><code>run!</code><span> instead</span></div><div data-t="alexyakushev That&apos;s like  mapc  in Lisp"><span class="u" id="1531411510.000386">2018:07:12 16:05:10         alexyakushev </span><span>That&apos;s like </span><code>mapc</code><span> in Lisp</span></div><div data-t="nathanmarz btw, you can clean up this code with  ATOM  and  view  navigators"><span class="u" id="1531411513.000591">2018:07:12 16:05:13           nathanmarz </span><span>btw, you can clean up this code with </span><code>ATOM</code><span> and </span><code>view</code><span> navigators</span></div><div data-t="vigilancetech yeah, I&apos;m a total noob to specter (and only slightly less so to clojure)"><span class="u" id="1531411559.000518">2018:07:12 16:05:59        vigilancetech </span><span>yeah, I&apos;m a total noob to specter (and only slightly less so to clojure)</span></div><div data-t="vigilancetech thanks guys!   Really loving this tool"><span class="u" id="1531411618.000148">2018:07:12 16:06:58        vigilancetech </span><span>thanks guys!   Really loving this tool</span></div><div data-t="idiomancy hi!"><span class="u" id="1531440605.000124">2018:07:13 00:10:05            idiomancy </span><span>hi!</span></div><div data-t="idiomancy I picked up specter to play with hiccup, and I&apos;m trying to form compound keys by grabbing the keys of sub elements within the data.

essentially, given
 [[:div.row
  [:div.column {:key &quot;A&quot;}]
  [:div.column {:key &quot;B&quot;}]]
 [:div.row
  [:div.culumn {:key &quot;C&quot;}]
  [:div.column {:key &quot;D&quot;}]]]
 

I want

 [[:div.row {:key &quot;AB&quot;}
  [:div.column {:key &quot;A&quot;}]
  [:div.column {:key &quot;B&quot;}]]
 [:div.row {:key &quot;CD&quot;}
  [:div.culumn {:key &quot;C&quot;}]
  [:div.column {:key &quot;D&quot;}]]]
 

I&apos;ll be working on this myself, but if anyone has any ideas, this is effing crazy to write with handrolled clojure, and it seems like the perfect specter magic trick from what I&apos;ve seen in the videos"><span class="u" id="1531441003.000168">2018:07:13 00:16:43            idiomancy </span><span>I picked up specter to play with hiccup, and I&apos;m trying to form compound keys by grabbing the keys of sub elements within the data.

essentially, given
</span><pre>[[:div.row
  [:div.column {:key &quot;A&quot;}]
  [:div.column {:key &quot;B&quot;}]]
 [:div.row
  [:div.culumn {:key &quot;C&quot;}]
  [:div.column {:key &quot;D&quot;}]]]
</pre><span>

I want

</span><pre>[[:div.row {:key &quot;AB&quot;}
  [:div.column {:key &quot;A&quot;}]
  [:div.column {:key &quot;B&quot;}]]
 [:div.row {:key &quot;CD&quot;}
  [:div.culumn {:key &quot;C&quot;}]
  [:div.column {:key &quot;D&quot;}]]]
</pre><span>

I&apos;ll be working on this myself, but if anyone has any ideas, this is effing crazy to write with handrolled clojure, and it seems like the perfect specter magic trick from what I&apos;ve seen in the videos</span></div><div data-t="nathanmarz @idiomancy 
 (def data
  [[:div.row
    [:div.column {:key &quot;A&quot;}]
    [:div.column {:key &quot;B&quot;}]]
   [:div.row
    [:div.culumn {:key &quot;C&quot;}]
    [:div.column {:key &quot;D&quot;}]]])

(transform
  [ALL
   (collect ALL coll? (nthpath 1) :key)
   (before-index 1)]
  (fn [keys _] {:key (apply str keys)})
  data
  )
"><span class="u" id="1531443029.000130">2018:07:13 00:50:29           nathanmarz </span><span>@idiomancy 
</span><pre>(def data
  [[:div.row
    [:div.column {:key &quot;A&quot;}]
    [:div.column {:key &quot;B&quot;}]]
   [:div.row
    [:div.culumn {:key &quot;C&quot;}]
    [:div.column {:key &quot;D&quot;}]]])

(transform
  [ALL
   (collect ALL coll? (nthpath 1) :key)
   (before-index 1)]
  (fn [keys _] {:key (apply str keys)})
  data
  )
</pre></div><div data-t="idiomancy oooh, man.  No way."><span class="u" id="1531443058.000036">2018:07:13 00:50:58            idiomancy </span><span>oooh, man.  No way.</span></div><div data-t="idiomancy It was gonna take me a while to figure out that &quot;collect&quot; navigator, I think  😆"><span class="u" id="1531443132.000041">2018:07:13 00:52:12            idiomancy </span><span>It was gonna take me a while to figure out that &quot;collect&quot; navigator, I think </span><b>😆</b></div><div data-t="idiomancy that&apos;s amazing!"><span class="u" id="1531443136.000198">2018:07:13 00:52:16            idiomancy </span><span>that&apos;s amazing!</span></div><div data-t="nathanmarz the cheat sheet is handy for finding navigators you need  https://github.com/nathanmarz/specter/wiki/Cheat-Sheet"><span class="u" id="1531443191.000003">2018:07:13 00:53:11           nathanmarz </span><span>the cheat sheet is handy for finding navigators you need </span><a href="https://github.com/nathanmarz/specter/wiki/Cheat-Sheet">https://github.com/nathanmarz/specter/wiki/Cheat-Sheet</a></div><div data-t="idiomancy let me spend a couple hours reverse engineering this.  thanks, @nathanmarz"><span class="u" id="1531443193.000129">2018:07:13 00:53:13            idiomancy </span><span>let me spend a couple hours reverse engineering this.  thanks, @nathanmarz</span></div><div data-t="denik I asked this in the #clojure channel and wondering if specter could be a solution:  https://clojurians.slack.com/archives/C03S1KBA2/p1531346207000010"><span class="u" id="1531493324.000153">2018:07:13 14:48:44                denik </span><span>I asked this in the #clojure channel and wondering if specter could be a solution: </span><a href="https://clojurians.slack.com/archives/C03S1KBA2/p1531346207000010">https://clojurians.slack.com/archives/C03S1KBA2/p1531346207000010</a></div><div data-t="denik the reason clojure.spec doesn’t work for this case is because spec tries to conform everything. The ebooks I looked at are highly inconsistent. I think what I’m looking for more like a data matcher, rather than a parser"><span class="u" id="1531493415.000288">2018:07:13 14:50:15                denik </span><span>the reason clojure.spec doesn’t work for this case is because spec tries to conform everything. The ebooks I looked at are highly inconsistent. I think what I’m looking for more like a data matcher, rather than a parser</span></div><div data-t="nathanmarz @denik don&apos;t understand the output you&apos;re looking for"><span class="u" id="1531494239.000332">2018:07:13 15:03:59           nathanmarz </span><span>@denik don&apos;t understand the output you&apos;re looking for</span></div><div data-t="nathanmarz {:class &quot;indent&quot; :content &quot;key lesson 1&quot;}  does not match  {:class &quot;indent&quot; :content &quot;key lesson 1&quot;}"><span class="u" id="1531494278.000128">2018:07:13 15:04:38           nathanmarz </span><code>{:class &quot;indent&quot; :content &quot;key lesson 1&quot;}</code><span> does not match </span><code>{:class &quot;indent&quot; :content &quot;key lesson 1&quot;}</code></div><div data-t="nathanmarz and there&apos;s no  &quot;key lesson 3&quot;  in your input"><span class="u" id="1531494288.000233">2018:07:13 15:04:48           nathanmarz </span><span>and there&apos;s no </span><code>&quot;key lesson 3&quot;</code><span> in your input</span></div><div data-t="denik @nathanmarz start at “START HERE” and match multiple  :class  fields, in this case  indent  and  indent1  but ignore these items before( and after with the stop condition  to  )"><span class="u" id="1531494379.000427">2018:07:13 15:06:19                denik </span><span>@nathanmarz start at “START HERE” and match multiple </span><code>:class</code><span> fields, in this case </span><code>indent</code><span> and </span><code>indent1</code><span> but ignore these items before( and after with the stop condition </span><code>to</code><span> )</span></div><div data-t="nathanmarz and you only want to keep items that match the  :filter  predicate?"><span class="u" id="1531494444.000375">2018:07:13 15:07:24           nathanmarz </span><span>and you only want to keep items that match the </span><code>:filter</code><span> predicate?</span></div><div data-t="denik yes, but only when they were found between  from  and  to  sequentially"><span class="u" id="1531494506.000363">2018:07:13 15:08:26                denik </span><span>yes, but only when they were found between </span><code>from</code><span> and </span><code>to</code><span> sequentially</span></div><div data-t="nathanmarz you can do it with specter like this:
 (defn start-index [data]
    ;; fill in
  )

(def end-index
  (end-fn [data start-index]
    ;; fill in
    ))


(select
  [(srange-dynamic start-index end-index)
   ALL
   (selected?
    (multi-path
      #(= &quot;START HERE&quot; (:class %))
      #(= &quot;bl&quot; (:class %))
      ))
   ]
  data)
"><span class="u" id="1531494797.000333">2018:07:13 15:13:17           nathanmarz </span><span>you can do it with specter like this:
</span><pre>(defn start-index [data]
    ;; fill in
  )

(def end-index
  (end-fn [data start-index]
    ;; fill in
    ))


(select
  [(srange-dynamic start-index end-index)
   ALL
   (selected?
    (multi-path
      #(= &quot;START HERE&quot; (:class %))
      #(= &quot;bl&quot; (:class %))
      ))
   ]
  data)
</pre></div><div data-t="nathanmarz but really this is better done with a parser"><span class="u" id="1531494807.000165">2018:07:13 15:13:27           nathanmarz </span><span>but really this is better done with a parser</span></div><div data-t="nathanmarz I&apos;m not very familiar with what spec is capable of, but this is real easy with monadic parser"><span class="u" id="1531494841.000474">2018:07:13 15:14:01           nathanmarz </span><span>I&apos;m not very familiar with what spec is capable of, but this is real easy with monadic parser</span></div><div data-t="denik thank you!"><span class="u" id="1531494942.000209">2018:07:13 15:15:42                     denik </span><span>thank you!</span></div><div data-t="denik here’s what that looks like in spec
 (require &apos;[clojure.spec.alpha :as s]
         &apos;[clojure.pprint :as pp])

(def ebook
  [{:class &quot;indent&quot; :content &quot;ignore&quot;}
   {:class &quot;indent&quot; :content &quot;ignore&quot;}
   {:class &quot;START HERE&quot; :content &quot;Key Lessons&quot;}
   {:class &quot;indent&quot; :content &quot;ignore&quot;}
   {:class &quot;indent1&quot; :content &quot;ignore&quot;}
   {:class &quot;bl&quot; :content &quot;key lesson 1&quot;}
   {:class &quot;bl&quot; :content &quot;key lesson 2&quot;}
   {:class &quot;indent3&quot; :content &quot;ignore&quot;}])

(s/def
  ::ebook-tree
  (s/and
    (s/cat
     :ignore (s/* (s/and map? #(= &quot;ignore&quot; (:content %))))
     :start (s/and map? #(= (:class %) &quot;START HERE&quot;))
     :body (s/* (s/alt
                 :ignore (s/and map? #(= &quot;ignore&quot; (:content %)))
                 :item (s/and map? #(= &quot;bl&quot; (:class %)))))
     :end (s/and map? #(= &quot;indent3&quot; (:class %))))
    (s/conformer
     (fn [{:keys [start body]}]
       (assoc start :children (for [[tag item] body
                                    :when (not= tag :ignore)]
                                item))))))

(pp/pprint
 (s/conform ::ebook-tree ebook))
"><span class="u" id="1531494951.000247">2018:07:13 15:15:51                     denik </span><span>here’s what that looks like in spec
</span><pre>(require &apos;[clojure.spec.alpha :as s]
         &apos;[clojure.pprint :as pp])

(def ebook
  [{:class &quot;indent&quot; :content &quot;ignore&quot;}
   {:class &quot;indent&quot; :content &quot;ignore&quot;}
   {:class &quot;START HERE&quot; :content &quot;Key Lessons&quot;}
   {:class &quot;indent&quot; :content &quot;ignore&quot;}
   {:class &quot;indent1&quot; :content &quot;ignore&quot;}
   {:class &quot;bl&quot; :content &quot;key lesson 1&quot;}
   {:class &quot;bl&quot; :content &quot;key lesson 2&quot;}
   {:class &quot;indent3&quot; :content &quot;ignore&quot;}])

(s/def
  ::ebook-tree
  (s/and
    (s/cat
     :ignore (s/* (s/and map? #(= &quot;ignore&quot; (:content %))))
     :start (s/and map? #(= (:class %) &quot;START HERE&quot;))
     :body (s/* (s/alt
                 :ignore (s/and map? #(= &quot;ignore&quot; (:content %)))
                 :item (s/and map? #(= &quot;bl&quot; (:class %)))))
     :end (s/and map? #(= &quot;indent3&quot; (:class %))))
    (s/conformer
     (fn [{:keys [start body]}]
       (assoc start :children (for [[tag item] body
                                    :when (not= tag :ignore)]
                                item))))))

(pp/pprint
 (s/conform ::ebook-tree ebook))
</pre></div><div data-t="nathanmarz with  https://github.com/nathanmarz/specter/issues/236  you could do it more easily with specter"><span class="u" id="1531495027.000489">2018:07:13 15:17:07           nathanmarz </span><span>with </span><a href="https://github.com/nathanmarz/specter/issues/236">https://github.com/nathanmarz/specter/issues/236</a><span> you could do it more easily with specter</span></div><div data-t="denik @nathanmarz I think that’s exactly what I’m looking for."><span class="u" id="1531496774.000423">2018:07:13 15:46:14                denik </span><span>@nathanmarz I think that’s exactly what I’m looking for.</span></div><div data-t="igrishaev Hi! In specter, is there a possibility to perform an upsert operation? For example, I’ve got a vector of maps like this:
 [{:id 1 :name &quot;John&quot;}
 {:id 2 :name &quot;Jim&quot;}
 {:id 3 :name &quot;Jane&quot;}]
 
Now a new map arrives and, depending on its id I need either to update (merge) it with an existing map or append it to the end of the vector. I now how to implement both insert/update separately, but a single  transform/setval  api call would be much more preferable."><span class="u" id="1531670969.000026">2018:07:15 16:09:29            igrishaev </span><span>Hi! In specter, is there a possibility to perform an upsert operation? For example, I’ve got a vector of maps like this:
</span><pre>[{:id 1 :name &quot;John&quot;}
 {:id 2 :name &quot;Jim&quot;}
 {:id 3 :name &quot;Jane&quot;}]
</pre><span>
Now a new map arrives and, depending on its id I need either to update (merge) it with an existing map or append it to the end of the vector. I now how to implement both insert/update separately, but a single </span><code>transform/setval</code><span> api call would be much more preferable.</span></div><div data-t="igrishaev As I see it, the only thing I don’t understand is how to compose a transformation path."><span class="u" id="1531671048.000033">2018:07:15 16:10:48            igrishaev </span><span>As I see it, the only thing I don’t understand is how to compose a transformation path.</span></div><div data-t="nathanmarz @igrishaev you can do it with a single path with zippers;
 (require &apos;[com.rpl.specter.zipper :as z])

(def truefn (constantly true))

(def target
  (recursive-path [id] p
    (cond-path
      [z/NODE #(= (:id %) id)]
      [z/NODE (submap nil)]

      (not-selected? z/NEXT)
      [z/INNER-RIGHT AFTER-ELEM]

      truefn
      [z/NEXT p]
      )))

(defn upsert [data n]
  (setval [z/VECTOR-ZIP z/DOWN (target (:id n))] n data))

(upsert data {:id 1 :name &quot;Joze&quot;})
;; =&gt; [{:id 1, :name &quot;Joze&quot;} {:id 2, :name &quot;Jim&quot;} {:id 3, :name &quot;Jane&quot;}]
(upsert data {:id 0 :name &quot;Joze&quot;})
;; =&gt; [{:id 1, :name &quot;John&quot;} {:id 2, :name &quot;Jim&quot;} {:id 3, :name &quot;Jane&quot;} {:id 0, :name &quot;Joze&quot;}]
"><span class="u" id="1531683306.000068">2018:07:15 19:35:06           nathanmarz </span><span>@igrishaev you can do it with a single path with zippers;
</span><pre>(require &apos;[com.rpl.specter.zipper :as z])

(def truefn (constantly true))

(def target
  (recursive-path [id] p
    (cond-path
      [z/NODE #(= (:id %) id)]
      [z/NODE (submap nil)]

      (not-selected? z/NEXT)
      [z/INNER-RIGHT AFTER-ELEM]

      truefn
      [z/NEXT p]
      )))

(defn upsert [data n]
  (setval [z/VECTOR-ZIP z/DOWN (target (:id n))] n data))

(upsert data {:id 1 :name &quot;Joze&quot;})
;; =&gt; [{:id 1, :name &quot;Joze&quot;} {:id 2, :name &quot;Jim&quot;} {:id 3, :name &quot;Jane&quot;}]
(upsert data {:id 0 :name &quot;Joze&quot;})
;; =&gt; [{:id 1, :name &quot;John&quot;} {:id 2, :name &quot;Jim&quot;} {:id 3, :name &quot;Jane&quot;} {:id 0, :name &quot;Joze&quot;}]
</pre></div><div data-t="nathanmarz but I would do it like this:
 (defn upsert [data n]
  (let [[data2 new] (replace-in [ALL #(= (:id %) (:id n)) (submap nil)]
                      (fn [_] [n nil])
                      data)]
    (if (nil? new)
      (setval AFTER-ELEM n data)
      data2
      )))
"><span class="u" id="1531683326.000033">2018:07:15 19:35:26           nathanmarz </span><span>but I would do it like this:
</span><pre>(defn upsert [data n]
  (let [[data2 new] (replace-in [ALL #(= (:id %) (:id n)) (submap nil)]
                      (fn [_] [n nil])
                      data)]
    (if (nil? new)
      (setval AFTER-ELEM n data)
      data2
      )))
</pre></div><div data-t="igrishaev thank you @nathanmarz, this combo looks solid!"><span class="u" id="1531726308.000078">2018:07:16 07:31:48            igrishaev </span><span>thank you @nathanmarz, this combo looks solid!</span></div><div data-t="igrishaev here is my final version to upsert into the re-frame database:
 (defn upsert [db path key-eq new]
  (letfn [(map-eq? [old] (= (get new key-eq) (get old key-eq)))
          (updater [old] [(merge old new)])]
    (let [full-path (conj path s/ALL map-eq?)
          [db2 updated?] (s/replace-in full-path updater db)]
      (if updated?
        db2
        (s/setval (conj path s/AFTER-ELEM) new db)))))
"><span class="u" id="1531733087.000099">2018:07:16 09:24:47            igrishaev </span><span>here is my final version to upsert into the re-frame database:
</span><pre>(defn upsert [db path key-eq new]
  (letfn [(map-eq? [old] (= (get new key-eq) (get old key-eq)))
          (updater [old] [(merge old new)])]
    (let [full-path (conj path s/ALL map-eq?)
          [db2 updated?] (s/replace-in full-path updater db)]
      (if updated?
        db2
        (s/setval (conj path s/AFTER-ELEM) new db)))))
</pre></div><div data-t="alexyakushev @igrishaev FWIW, I had a problem very similar to yours, and for it I implemented a simple custom data structure that keeps values in a vector and a map simultaneously. It implements all IPersistentMap methods, and  assoc  works as the upsert."><span class="u" id="1531743431.000310">2018:07:16 12:17:11         alexyakushev </span><span>@igrishaev FWIW, I had a problem very similar to yours, and for it I implemented a simple custom data structure that keeps values in a vector and a map simultaneously. It implements all IPersistentMap methods, and </span><code>assoc</code><span> works as the upsert.</span></div><div data-t="nathanmarz @igrishaev fyi, use the  path  macro for composing paths instead of  conj"><span class="u" id="1531744669.000060">2018:07:16 12:37:49           nathanmarz </span><span>@igrishaev fyi, use the </span><code>path</code><span> macro for composing paths instead of </span><code>conj</code></div><div data-t="nathanmarz will be much faster"><span class="u" id="1531744672.000298">2018:07:16 12:37:52           nathanmarz </span><span>will be much faster</span></div><div data-t="igrishaev thank you, will check that out"><span class="u" id="1531744716.000283">2018:07:16 12:38:36            igrishaev </span><span>thank you, will check that out</span></div><div data-t="igrishaev in my case,  path  is a vector to the actual data subset, say  [:tasks :completed]"><span class="u" id="1531744771.000254">2018:07:16 12:39:31            igrishaev </span><span>in my case, </span><code>path</code><span> is a vector to the actual data subset, say </span><code>[:tasks :completed]</code></div><div data-t="nathanmarz yea, you should pass that in as  (path :tasks :completed)"><span class="u" id="1531744953.000137">2018:07:16 12:42:33           nathanmarz </span><span>yea, you should pass that in as </span><code>(path :tasks :completed)</code></div><div data-t="nathanmarz path  uses inline caching to minimize runtime compilation of paths"><span class="u" id="1531745015.000067">2018:07:16 12:43:35           nathanmarz </span><code>path</code><span> uses inline caching to minimize runtime compilation of paths</span></div><div data-t="igrishaev If I have a vector like  [:foo :bar] , how can I apply it the the  path  macro then?"><span class="u" id="1531745090.000223">2018:07:16 12:44:50            igrishaev </span><span>If I have a vector like </span><code>[:foo :bar]</code><span>, how can I apply it the the </span><code>path</code><span> macro then?</span></div><div data-t="nathanmarz (path :foo :bar)"><span class="u" id="1531746164.000010">2018:07:16 13:02:44           nathanmarz </span><code>(path :foo :bar)</code></div><div data-t="igrishaev sure, but what if both foo and bar come as a vector?"><span class="u" id="1531747093.000152">2018:07:16 13:18:13            igrishaev </span><span>sure, but what if both foo and bar come as a vector?</span></div><div data-t="igrishaev as a func argument in my case"><span class="u" id="1531747120.000171">2018:07:16 13:18:40            igrishaev </span><span>as a func argument in my case</span></div><div data-t="nathanmarz if it&apos;s dynamic, then declare them using  path , not as a vector"><span class="u" id="1531747206.000144">2018:07:16 13:20:06           nathanmarz </span><span>if it&apos;s dynamic, then declare them using </span><code>path</code><span>, not as a vector</span></div><div data-t="nathanmarz (upsert db (path :foo :bar) ...)"><span class="u" id="1531747227.000515">2018:07:16 13:20:27           nathanmarz </span><code>(upsert db (path :foo :bar) ...)</code></div><div data-t="igrishaev the problem is I don’t know in advance what subset of the main db will be used."><span class="u" id="1531747322.000063">2018:07:16 13:22:02            igrishaev </span><span>the problem is I don’t know in advance what subset of the main db will be used.</span></div><div data-t="igrishaev I supposed a user passes an initial path as a vector, then I build the full transformation path"><span class="u" id="1531747383.000245">2018:07:16 13:23:03            igrishaev </span><span>I supposed a user passes an initial path as a vector, then I build the full transformation path</span></div><div data-t="nathanmarz ultimately it&apos;s an optimization"><span class="u" id="1531748255.000292">2018:07:16 13:37:35           nathanmarz </span><span>ultimately it&apos;s an optimization</span></div><div data-t="nathanmarz if your users declare their paths using  path  it will be faster, but if they use vectors it will still work"><span class="u" id="1531748274.000423">2018:07:16 13:37:54           nathanmarz </span><span>if your users declare their paths using </span><code>path</code><span> it will be faster, but if they use vectors it will still work</span></div><div data-t="igrishaev ok, so if a user passes smth like  (path :foo :bar)  as an initial path, how can I extend it?"><span class="u" id="1531748450.000372">2018:07:16 13:40:50            igrishaev </span><span>ok, so if a user passes smth like </span><code>(path :foo :bar)</code><span> as an initial path, how can I extend it?</span></div><div data-t="nathanmarz with  path"><span class="u" id="1531748567.000421">2018:07:16 13:42:47           nathanmarz </span><span>with </span><code>path</code></div><div data-t="nathanmarz e.g.  (path passed-in-user-path ALL)"><span class="u" id="1531748595.000199">2018:07:16 13:43:15           nathanmarz </span><span>e.g. </span><code>(path passed-in-user-path ALL)</code></div><div data-t="igrishaev oh, I see now, thanks"><span class="u" id="1531748617.000148">2018:07:16 13:43:37            igrishaev </span><span>oh, I see now, thanks</span></div><div data-t="roklenarcic I often have to transform map&apos;s values but I need value&apos;s key to do the transformation, so  MAP-VALS  doesn&apos;t cut it"><span class="u" id="1531816126.000045">2018:07:17 08:28:46          roklenarcic </span><span>I often have to transform map&apos;s values but I need value&apos;s key to do the transformation, so </span><code>MAP-VALS</code><span> doesn&apos;t cut it</span></div><div data-t="roklenarcic How do I solve this?"><span class="u" id="1531816132.000360">2018:07:17 08:28:52          roklenarcic </span><span>How do I solve this?</span></div><div data-t="roklenarcic ALL (collect FIRST) LAST ?"><span class="u" id="1531816168.000354">2018:07:17 08:29:28          roklenarcic </span><code>ALL (collect FIRST) LAST</code><span>?</span></div><div data-t="roklenarcic This case comes up all the time. I want to decide which path to take based on key, but I want to transform value."><span class="u" id="1531816688.000025">2018:07:17 08:38:08          roklenarcic </span><span>This case comes up all the time. I want to decide which path to take based on key, but I want to transform value.</span></div><div data-t="pepe @roklenarcic ALL returns [k v] vector on map so  (transform ALL (fn [[k v]] (if (= k :a) [k (inc v)] [k (dec v)])) {:a 1 :b 2})  works"><span class="u" id="1531817751.000100">2018:07:17 08:55:51                 pepe </span><span>@roklenarcic ALL returns [k v] vector on map so </span><code>(transform ALL (fn [[k v]] (if (= k :a) [k (inc v)] [k (dec v)])) {:a 1 :b 2})</code><span> works</span></div><div data-t="roklenarcic I know that one, but I hoped for a shorter solution."><span class="u" id="1531820160.000015">2018:07:17 09:36:00          roklenarcic </span><span>I know that one, but I hoped for a shorter solution.</span></div><div data-t="pepe Ok. Have you looked at if-path cond-path?"><span class="u" id="1531823266.000069">2018:07:17 10:27:46                 pepe </span><span>Ok. Have you looked at if-path cond-path?</span></div><div data-t="roklenarcic that&apos;s about the same amount of code"><span class="u" id="1531834132.000141">2018:07:17 13:28:52          roklenarcic </span><span>that&apos;s about the same amount of code</span></div><div data-t="nathanmarz @roklenarcic it will be easier to help you if you show the input/output of the transformation you want to do"><span class="u" id="1531834202.000178">2018:07:17 13:30:02           nathanmarz </span><span>@roklenarcic it will be easier to help you if you show the input/output of the transformation you want to do</span></div><div data-t="roklenarcic Already solved it"><span class="u" id="1531834370.000420">2018:07:17 13:32:50          roklenarcic </span><span>Already solved it</span></div><div data-t="roklenarcic (transform [ALL (collect-one FIRST) LAST ALL] map-fn result-of-group-by)"><span class="u" id="1531834414.000423">2018:07:17 13:33:34          roklenarcic </span><code>(transform [ALL (collect-one FIRST) LAST ALL] map-fn result-of-group-by)</code></div><div data-t="roklenarcic allows me to have map-fn of two arguments that processes lists in group-by map-of-vectors"><span class="u" id="1531834453.000173">2018:07:17 13:34:13          roklenarcic </span><span>allows me to have map-fn of two arguments that processes lists in group-by map-of-vectors</span></div><div data-t="roklenarcic what&apos;s the fastest way to drop certain indexes in a vector? e.g. given vector  [:a :b :c :d]  and indexes  [0 2]  I should get  [:b :d]"><span class="u" id="1532356811.000314">2018:07:23 14:40:11          roklenarcic </span><span>what&apos;s the fastest way to drop certain indexes in a vector? e.g. given vector </span><code>[:a :b :c :d]</code><span> and indexes </span><code>[0 2]</code><span> I should get </span><code>[:b :d]</code></div><div data-t="nathanmarz @roklenarcic you&apos;re best off doing that with a reduce"><span class="u" id="1532357364.000033">2018:07:23 14:49:24           nathanmarz </span><span>@roklenarcic you&apos;re best off doing that with a reduce</span></div><div data-t="nathanmarz each  (setval (nthpath i) NONE data)  invocation is O(n), and  INDEXED-VALS  doesn&apos;t currently support removal via  NONE"><span class="u" id="1532357395.000255">2018:07:23 14:49:55           nathanmarz </span><span>each </span><code>(setval (nthpath i) NONE data)</code><span> invocation is O(n), and </span><code>INDEXED-VALS</code><span> doesn&apos;t currently support removal via </span><code>NONE</code></div><div data-t="roklenarcic since you&apos;re here, how important is precompiling routes now?"><span class="u" id="1532357413.000130">2018:07:23 14:50:13          roklenarcic </span><span>since you&apos;re here, how important is precompiling routes now?</span></div><div data-t="nathanmarz completely unnecessary"><span class="u" id="1532357462.000053">2018:07:23 14:51:02           nathanmarz </span><span>completely unnecessary</span></div><div data-t="nathanmarz the inline compiler handles all cases"><span class="u" id="1532357469.000554">2018:07:23 14:51:09           nathanmarz </span><span>the inline compiler handles all cases</span></div><div data-t="roklenarcic thx"><span class="u" id="1532357511.000261">2018:07:23 14:51:51          roklenarcic </span><span>thx</span></div><div data-t="steveb8n anyone ever seen an error like this before at compile time?  java.lang.StackOverflowError, compiling:(com/rpl/specter/util_macros.clj:61:29  I’m seeing it when using Specter in Datomic Ions"><span class="u" id="1532415336.000098">2018:07:24 06:55:36             steveb8n </span><span>anyone ever seen an error like this before at compile time? </span><code>java.lang.StackOverflowError, compiling:(com/rpl/specter/util_macros.clj:61:29</code><span> I’m seeing it when using Specter in Datomic Ions</span></div><div data-t="steveb8n scratch that. It appears to be a side-effect of a dependencies problem"><span class="u" id="1532417142.000109">2018:07:24 07:25:42             steveb8n </span><span>scratch that. It appears to be a side-effect of a dependencies problem</span></div><div data-t="Petrus Theron I&apos;m learning Specter and trying to parse an XML response I got from Twilio. I&apos;m not super-familiar with Clojure zippers in general, but I suspect it&apos;ll be cleaner &amp; faster with Specter. I&apos;ve stumbled onto the  S/collect  function, but I&apos;m having a hard time fetching &quot;sibling&quot; nodes when dealing with a shape like this:

 {:tag :TwilioResponse,
 :attrs nil,
 :content [{:tag :Call,
            :attrs nil,
            :content [{:tag :AnsweredBy, :attrs nil, :content nil}
                      {:tag :PriceUnit, :attrs nil, :content [&quot;USD&quot;]}
                      {:tag :From, :attrs nil, :content [&quot;+2787...&quot;]}
                      {:tag :To, :attrs nil, :content [&quot;+2776...&quot;]}
}]}]}
 

How do I ask Specter to collect the deepest  :tag  and  :content  values in the structure, but only if the parent  :tag  is :TwilioResponse, with a  :Call  parent under :tag?

I managed to get what I want by doing the following, but it feels like there must be a cleaner way to refer to parents/siblings:
 (-&gt;&gt; my-parsed-xml (S/select-one [(S/collect-one :content S/FIRST :content)
                        :tag (S/pred= :TwilioResponse)])
         first
         (map (juxt :tag (comp first :content))))
"><span class="u" id="1532426365.000334">2018:07:24 09:59:25        Petrus Theron </span><span>I&apos;m learning Specter and trying to parse an XML response I got from Twilio. I&apos;m not super-familiar with Clojure zippers in general, but I suspect it&apos;ll be cleaner &amp; faster with Specter. I&apos;ve stumbled onto the </span><code>S/collect</code><span> function, but I&apos;m having a hard time fetching &quot;sibling&quot; nodes when dealing with a shape like this:

</span><pre>{:tag :TwilioResponse,
 :attrs nil,
 :content [{:tag :Call,
            :attrs nil,
            :content [{:tag :AnsweredBy, :attrs nil, :content nil}
                      {:tag :PriceUnit, :attrs nil, :content [&quot;USD&quot;]}
                      {:tag :From, :attrs nil, :content [&quot;+2787...&quot;]}
                      {:tag :To, :attrs nil, :content [&quot;+2776...&quot;]}
}]}]}
</pre><span>

How do I ask Specter to collect the deepest </span><code>:tag</code><span> and </span><code>:content</code><span> values in the structure, but only if the parent </span><code>:tag</code><span> is :TwilioResponse, with a </span><code>:Call</code><span> parent under :tag?

I managed to get what I want by doing the following, but it feels like there must be a cleaner way to refer to parents/siblings:
</span><pre>(-&gt;&gt; my-parsed-xml (S/select-one [(S/collect-one :content S/FIRST :content)
                        :tag (S/pred= :TwilioResponse)])
         first
         (map (juxt :tag (comp first :content))))
</pre></div><div data-t="nathanmarz @petrus not totally clear on what you want"><span class="u" id="1532436243.000266">2018:07:24 12:44:03           nathanmarz </span><span>@petrus not totally clear on what you want</span></div><div data-t="Petrus Theron if I restructure the response as a nested map (assuming no dupes)  {:TwilioResponse {:Call {:AnsweredBy nil :PriceUnit [&quot;USD&quot;] ...}}  I&apos;d be done with a  (get-in [:TwilioResponse :Call]]) , which I can do with with a few functions, but I&apos;m hoping this can be cleanly done with a Specter select and XML zippers."><span class="u" id="1532451566.000172">2018:07:24 16:59:26             Petrus Theron </span><span>if I restructure the response as a nested map (assuming no dupes) </span><code>{:TwilioResponse {:Call {:AnsweredBy nil :PriceUnit [&quot;USD&quot;] ...}}</code><span> I&apos;d be done with a </span><code>(get-in [:TwilioResponse :Call]])</code><span>, which I can do with with a few functions, but I&apos;m hoping this can be cleanly done with a Specter select and XML zippers.</span></div><div data-t="nathanmarz you want nodes in this tree that have a parent tag of  :Call  and grandparent tag of  :TwilioResponse ?"><span class="u" id="1532436272.000114">2018:07:24 12:44:32           nathanmarz </span><span>you want nodes in this tree that have a parent tag of </span><code>:Call</code><span> and grandparent tag of </span><code>:TwilioResponse</code><span>?</span></div><div data-t="nathanmarz can this substructure exist at any depth, or only starting at the root?"><span class="u" id="1532436305.000030">2018:07:24 12:45:05           nathanmarz </span><span>can this substructure exist at any depth, or only starting at the root?</span></div><div data-t="nathanmarz @petrus is this what you&apos;re looking for?
 (select-first
  [#(= :TwilioResponse (:tag %))
   :content
   ALL
   #(= :Call (:tag %))
   :content]
  data)
"><span class="u" id="1532451912.000216">2018:07:24 17:05:12           nathanmarz </span><span>@petrus is this what you&apos;re looking for?
</span><pre>(select-first
  [#(= :TwilioResponse (:tag %))
   :content
   ALL
   #(= :Call (:tag %))
   :content]
  data)
</pre></div><div data-t="nathanmarz or this?
 (select
  [#(= :TwilioResponse (:tag %))
   :content
   ALL
   #(= :Call (:tag %))
   :content
   ALL
   (collect-one :tag)
   :content
   (view first)]
  data)
"><span class="u" id="1532452048.000491">2018:07:24 17:07:28           nathanmarz </span><span>or this?
</span><pre>(select
  [#(= :TwilioResponse (:tag %))
   :content
   ALL
   #(= :Call (:tag %))
   :content
   ALL
   (collect-one :tag)
   :content
   (view first)]
  data)
</pre></div><div data-t="Petrus Theron yes, thanks @U173SEFUN!  🙂  exactly right after a call to  (into {} ...)  (assume no duplicate tags).

Is there a cleaner way to &quot;walk&quot; the XML tree  {:tag .. :content ...}  layout so that  {:tag :x :content :y}  becomes  [:x :y]  or  {:x :y} ?"><span class="u" id="1532452241.000114">2018:07:24 17:10:41             Petrus Theron </span><span>yes, thanks @U173SEFUN! </span><b>🙂</b><span> exactly right after a call to </span><code>(into {} ...)</code><span> (assume no duplicate tags).

Is there a cleaner way to &quot;walk&quot; the XML tree </span><code>{:tag .. :content ...}</code><span> layout so that </span><code>{:tag :x :content :y}</code><span> becomes </span><code>[:x :y]</code><span> or </span><code>{:x :y}</code><span>?</span></div><div data-t="nathanmarz you can factor out any composition of navigators as its own navigator"><span class="u" id="1532452616.000261">2018:07:24 17:16:56           nathanmarz </span><span>you can factor out any composition of navigators as its own navigator</span></div><div data-t="nathanmarz e.g.
 (def tag+content
  (path
    (collect-one :tag)
    :content
    (view first)))

(select
  [#(= :TwilioResponse (:tag %))
   :content
   ALL
   #(= :Call (:tag %))
   :content
   ALL
   tag+content]
  data)
"><span class="u" id="1532452626.000355">2018:07:24 17:17:06           nathanmarz </span><span>e.g.
</span><pre>(def tag+content
  (path
    (collect-one :tag)
    :content
    (view first)))

(select
  [#(= :TwilioResponse (:tag %))
   :content
   ALL
   #(= :Call (:tag %))
   :content
   ALL
   tag+content]
  data)
</pre></div><div data-t="Petrus Theron Would a  recursive-path  walker be cleaner for transforming the general  {:tag :content [{:tag ... :content [...]]}  shape returned by  clojure.xml/parse  in general, then selecting a simpler nested path from there?"><span class="u" id="1532452811.000030">2018:07:24 17:20:11             Petrus Theron </span><span>Would a </span><code>recursive-path</code><span> walker be cleaner for transforming the general </span><code>{:tag :content [{:tag ... :content [...]]}</code><span> shape returned by </span><code>clojure.xml/parse</code><span> in general, then selecting a simpler nested path from there?</span></div><div data-t="nathanmarz if you want to navigate to the pair, you can use subselect + multi-path"><span class="u" id="1532452720.000118">2018:07:24 17:18:40           nathanmarz </span><span>if you want to navigate to the pair, you can use subselect + multi-path</span></div><div data-t="nathanmarz (select
  [#(= :TwilioResponse (:tag %))
   :content
   ALL
   #(= :Call (:tag %))
   :content
   ALL
   (subselect (multi-path :tag [:content (view first)]))]
  data)
"><span class="u" id="1532452730.000280">2018:07:24 17:18:50           nathanmarz </span><pre>(select
  [#(= :TwilioResponse (:tag %))
   :content
   ALL
   #(= :Call (:tag %))
   :content
   ALL
   (subselect (multi-path :tag [:content (view first)]))]
  data)
</pre></div><div data-t="nathanmarz if you want to maintain the general structure, then yes"><span class="u" id="1532452870.000167">2018:07:24 17:21:10           nathanmarz </span><span>if you want to maintain the general structure, then yes</span></div><div data-t="Petrus Theron Thanks for feedback @nathanmarz. I sent your Specter talk to a friend and he commented: &quot;I didn&apos;t know Vin Diesel was into Clojure.&quot;  😄"><span class="u" id="1532517772.000017">2018:07:25 11:22:52        Petrus Theron </span><span>Thanks for feedback @nathanmarz. I sent your Specter talk to a friend and he commented: &quot;I didn&apos;t know Vin Diesel was into Clojure.&quot; </span><b>😄</b></div><div data-t="nathanmarz 😂"><span class="u" id="1532524510.000305">2018:07:25 13:15:10           nathanmarz </span><b>😂</b></div><div data-t="roklenarcic I have a double nested map like  {:a {:b 1}}  and I need  get all tuples key1, key2, value where value fits a predicate"><span class="u" id="1532632069.000222">2018:07:26 19:07:49          roklenarcic </span><span>I have a double nested map like </span><code>{:a {:b 1}}</code><span> and I need  get all tuples key1, key2, value where value fits a predicate</span></div><div data-t="roklenarcic Is there some way I can do this?"><span class="u" id="1532632086.000275">2018:07:26 19:08:06          roklenarcic </span><span>Is there some way I can do this?</span></div><div data-t="nathanmarz @roklenarcic 
 (def m {:a {:b 1 :c 2} :d {:e 3 :f 4}})
(def VALS-WITH-KEY (path ALL (collect-one FIRST) LAST))
(select [VALS-WITH-KEY VALS-WITH-KEY even?] m)
"><span class="u" id="1532633690.000255">2018:07:26 19:34:50           nathanmarz </span><span>@roklenarcic 
</span><pre>(def m {:a {:b 1 :c 2} :d {:e 3 :f 4}})
(def VALS-WITH-KEY (path ALL (collect-one FIRST) LAST))
(select [VALS-WITH-KEY VALS-WITH-KEY even?] m)
</pre></div><div data-t="roklenarcic hm I really need to experiment with subpaths more"><span class="u" id="1532634267.000129">2018:07:26 19:44:27          roklenarcic </span><span>hm I really need to experiment with subpaths more</span></div><div data-t="roklenarcic thanks"><span class="u" id="1532634285.000423">2018:07:26 19:44:45          roklenarcic </span><span>thanks</span></div><div data-t="roklenarcic using path operator is good for performance?"><span class="u" id="1532634442.000451">2018:07:26 19:47:22          roklenarcic </span><span>using path operator is good for performance?</span></div><div data-t="nathanmarz yes"><span class="u" id="1532634955.000526">2018:07:26 19:55:55           nathanmarz </span><span>yes</span></div><div data-t="alexisvincent Hi there, was wondering if you have a way of selecting a submap with a predicate on map keys or value. Perhaps something like the reverse of ALL for map entries?"><span class="u" id="1532712887.000253">2018:07:27 17:34:47        alexisvincent </span><span>Hi there, was wondering if you have a way of selecting a submap with a predicate on map keys or value. Perhaps something like the reverse of ALL for map entries?</span></div><div data-t="alexisvincent For example  (select [ALL (comp even? second)] {:a 1 :b 2 :c 3})  in this case to get back the submap {:b 2} rather then the list of entries. But as a path, so that it can be composed"><span class="u" id="1532713102.000261">2018:07:27 17:38:22        alexisvincent </span><span>For example </span><pre>(select [ALL (comp even? second)] {:a 1 :b 2 :c 3})</pre><span> in this case to get back the submap {:b 2} rather then the list of entries. But as a path, so that it can be composed</span></div><div data-t="nathanmarz @alexisvincent one common way to do that would be to do the inverse using  setval , e.g.  (setval [MAP-VALS odd?] NONE {:a 1 :b 2 :c 3})"><span class="u" id="1532714270.000338">2018:07:27 17:57:50           nathanmarz </span><span>@alexisvincent one common way to do that would be to do the inverse using </span><code>setval</code><span>, e.g. </span><code>(setval [MAP-VALS odd?] NONE {:a 1 :b 2 :c 3})</code></div><div data-t="alexisvincent Thanks Nathan! But what I’m really trying to achieve is to construct a path, that I can compose to access deeper things in the map."><span class="u" id="1532714348.000424">2018:07:27 17:59:08        alexisvincent </span><span>Thanks Nathan! But what I’m really trying to achieve is to construct a path, that I can compose to access deeper things in the map.</span></div><div data-t="alexisvincent Is it possible for instance to make a navigator that takes a list of entries and transforms it to a map, such that it still works with the reconstruction process?"><span class="u" id="1532714520.000156">2018:07:27 18:02:00        alexisvincent </span><span>Is it possible for instance to make a navigator that takes a list of entries and transforms it to a map, such that it still works with the reconstruction process?</span></div><div data-t="nathanmarz not sure what you mean by that"><span class="u" id="1532714984.000150">2018:07:27 18:09:44           nathanmarz </span><span>not sure what you mean by that</span></div><div data-t="nathanmarz do you have a representative example?"><span class="u" id="1532714991.000181">2018:07:27 18:09:51           nathanmarz </span><span>do you have a representative example?</span></div><div data-t="razum2um Hi, I started using  collect  but find it a bit awkward, passing 2 args into modify-fn:
 (def data {18 [{:rate 30} {:rate 15}], 50 [{:rate 35}]})
(transform [MAP-VALS (collect ALL :rate)] (fn [xs _] (average xs)) data) ;; ok
(transform [MAP-VALS (collect ALL :rate)] average data)
ArityException Wrong number of args (2) passed to: user/average
 
is there a more concise version of 2nd line (dont want to change average arity only for specter)?"><span class="u" id="1532727258.000071">2018:07:27 21:34:18             razum2um </span><span>Hi, I started using </span><code>collect</code><span> but find it a bit awkward, passing 2 args into modify-fn:
</span><pre>(def data {18 [{:rate 30} {:rate 15}], 50 [{:rate 35}]})
(transform [MAP-VALS (collect ALL :rate)] (fn [xs _] (average xs)) data) ;; ok
(transform [MAP-VALS (collect ALL :rate)] average data)
ArityException Wrong number of args (2) passed to: user/average
</pre><span>
is there a more concise version of 2nd line (dont want to change average arity only for specter)?</span></div><div data-t="nathanmarz @razum2um no, that&apos;s pretty idiomatic"><span class="u" id="1532728438.000163">2018:07:27 21:53:58           nathanmarz </span><span>@razum2um no, that&apos;s pretty idiomatic</span></div><div data-t="vigilancetech so now with the latest version of specter, what is one supposed to do regarding using path, comp-paths, etc..?   I think I&apos;m having problems with its and javelin&apos;s macros not playing well together."><span class="u" id="1533182206.000093">2018:08:02 03:56:46        vigilancetech </span><span>so now with the latest version of specter, what is one supposed to do regarding using path, comp-paths, etc..?   I think I&apos;m having problems with its and javelin&apos;s macros not playing well together.</span></div><div data-t="nathanmarz @vigilancetech just use  path"><span class="u" id="1533208610.000153">2018:08:02 11:16:50           nathanmarz </span><span>@vigilancetech just use </span><code>path</code></div><div data-t="miikka So I&apos;m pretty new to Specter, but I&apos;m trying to navigate a vector like  [{:id 1, :value 2} {:id 2, :value 1}]  by  :id . (I know that this would be ideally a map, but it&apos;s not for now.)  [MAP-VALS #(= x (:id %))]  seems to work, but how do I define a navigator so that it&apos;s reusable?"><span class="u" id="1533300887.000177">2018:08:03 12:54:47               miikka </span><span>So I&apos;m pretty new to Specter, but I&apos;m trying to navigate a vector like </span><code>[{:id 1, :value 2} {:id 2, :value 1}]</code><span> by </span><code>:id</code><span>. (I know that this would be ideally a map, but it&apos;s not for now.) </span><code>[MAP-VALS #(= x (:id %))]</code><span> seems to work, but how do I define a navigator so that it&apos;s reusable?</span></div><div data-t="miikka Is this the right way to do it?
 (defn by-id [id] (specter/path [specter/MAP-VALS #(= (:id %) id)]))
"><span class="u" id="1533300912.000151">2018:08:03 12:55:12               miikka </span><span>Is this the right way to do it?
</span><pre>(defn by-id [id] (specter/path [specter/MAP-VALS #(= (:id %) id)]))
</pre></div><div data-t="miikka uh, that should be  ALL , not  MAP-VALS"><span class="u" id="1533301621.000219">2018:08:03 13:07:01               miikka </span><span>uh, that should be </span><code>ALL</code><span>, not </span><code>MAP-VALS</code></div><div data-t="nathanmarz @miikka yes, that&apos;s exactly right"><span class="u" id="1533309562.000314">2018:08:03 15:19:22           nathanmarz </span><span>@miikka yes, that&apos;s exactly right</span></div><div data-t="vigilancetech anyone have an idea why I&apos;d be getting this error in 1.1.1 but not 1.1.0?

 WARNING: Use of undeclared Var cljs.core/MapEntry at line 84 /home/kevin/.boot/cache/tmp/home/kevin/0work/jbog/guardian-dashboard/cul/v9pufs/index.html.out/com/rpl/specter/navs.cljc
 

I just erased .boot/cache and recompiled and the same error is there"><span class="u" id="1533335174.000090">2018:08:03 22:26:14        vigilancetech </span><span>anyone have an idea why I&apos;d be getting this error in 1.1.1 but not 1.1.0?

</span><pre>WARNING: Use of undeclared Var cljs.core/MapEntry at line 84 /home/kevin/.boot/cache/tmp/home/kevin/0work/jbog/guardian-dashboard/cul/v9pufs/index.html.out/com/rpl/specter/navs.cljc
</pre><span>

I just erased .boot/cache and recompiled and the same error is there</span></div><div data-t="nathanmarz @vigilancetech that&apos;s related to a change in ClojureScript 1.10"><span class="u" id="1533337571.000103">2018:08:03 23:06:11           nathanmarz </span><span>@vigilancetech that&apos;s related to a change in ClojureScript 1.10</span></div><div data-t="nathanmarz you should upgrade your cljs"><span class="u" id="1533337575.000065">2018:08:03 23:06:15           nathanmarz </span><span>you should upgrade your cljs</span></div><div data-t="souenzzo I need to add a item(  :NEW  ) before a pred (  map?  ) just on first match.
exaple:   [:foo :bar {} {}]  into  [:foo :bar :NEW {} {}]  
I&apos;m using mapcat and a  atom  to say if it&apos;s the first match.
There is a simpler way to do that?"><span class="u" id="1533740380.000293">2018:08:08 14:59:40             souenzzo </span><span>I need to add a item( </span><code>:NEW</code><span> ) before a pred ( </span><code>map?</code><span> ) just on first match.
exaple:  </span><code>[:foo :bar {} {}]</code><span> into </span><code>[:foo :bar :NEW {} {}]</code><span> 
I&apos;m using mapcat and a </span><code>atom</code><span> to say if it&apos;s the first match.
There is a simpler way to do that?</span></div><div data-t="souenzzo There is  BEFORE-ELEM  but can&apos;t understand how to compose it."><span class="u" id="1533740867.000100">2018:08:08 15:07:47             souenzzo </span><span>There is </span><code>BEFORE-ELEM</code><span> but can&apos;t understand how to compose it.</span></div><div data-t="nathanmarz @souenzzo you can do something like:
 (defn index-matching [p]
  (fn [s]
    (select-first [INDEXED-VALS (selected? LAST (pred p)) FIRST] s)
    ))

(setval
  [(srange-dynamic (index-matching map?) (end-fn [_ i] i))
   BEFORE-ELEM]
  :NEW
  [:foo :bar {} {}]
  )
"><span class="u" id="1533740884.000058">2018:08:08 15:08:04           nathanmarz </span><span>@souenzzo you can do something like:
</span><pre>(defn index-matching [p]
  (fn [s]
    (select-first [INDEXED-VALS (selected? LAST (pred p)) FIRST] s)
    ))

(setval
  [(srange-dynamic (index-matching map?) (end-fn [_ i] i))
   BEFORE-ELEM]
  :NEW
  [:foo :bar {} {}]
  )
</pre></div><div data-t="nathanmarz probably want to modify it a little to handle the case where nothing matches the predicate"><span class="u" id="1533740921.000065">2018:08:08 15:08:41           nathanmarz </span><span>probably want to modify it a little to handle the case where nothing matches the predicate</span></div><div data-t="jsa-aerial suppose, you have a transform ALL function which makes substitutions that may themselves need to have substitutions and so reapply the transform on result until no more substitutions involved. Is the obvious soln such as  (-&gt;&gt; x (iterate xform) (drop-while (comp not test)) first)  still the &apos;right&apos; way to do this with specter? Or is there an even more idiomatic way?"><span class="u" id="1533757421.000064">2018:08:08 19:43:41           jsa-aerial </span><span>suppose, you have a transform ALL function which makes substitutions that may themselves need to have substitutions and so reapply the transform on result until no more substitutions involved. Is the obvious soln such as </span><code>(-&gt;&gt; x (iterate xform) (drop-while (comp not test)) first)</code><span> still the &apos;right&apos; way to do this with specter? Or is there an even more idiomatic way?</span></div><div data-t="nathanmarz @jsa-aerial you could always do something like:
 (def iterated-path
  (recursive-path [test] p
    (stay-then-continue
      (pred test)
      p
      )))
(transform (iterated-path #(&lt; % 10)) inc 1)
;; =&gt; 10
"><span class="u" id="1533758185.000260">2018:08:08 19:56:25           nathanmarz </span><span>@jsa-aerial you could always do something like:
</span><pre>(def iterated-path
  (recursive-path [test] p
    (stay-then-continue
      (pred test)
      p
      )))
(transform (iterated-path #(&lt; % 10)) inc 1)
;; =&gt; 10
</pre></div><div data-t="jsa-aerial @nathanmarz that looks very interesting - let me take a hack with that. Thanks!"><span class="u" id="1533759047.000106">2018:08:08 20:10:47           jsa-aerial </span><span>@nathanmarz that looks very interesting - let me take a hack with that. Thanks!</span></div><div data-t="jsa-aerial Hmmmm, actually the test needs the last two values. Basically let x1 and x2 be the last two values, iterate until (= x1 x2)."><span class="u" id="1533759384.000351">2018:08:08 20:16:24           jsa-aerial </span><span>Hmmmm, actually the test needs the last two values. Basically let x1 and x2 be the last two values, iterate until (= x1 x2).</span></div><div data-t="nathanmarz @jsa-aerial 
 (def FIXED-POINT-PATH
  (recursive-path [] p
    [(collect-one STAY)
     (multi-path
       [DISPENSE STAY]
       [(collect-one STAY)
        (if-path (collected? [a b] (= a b))
          STOP
          [DISPENSE p]
          )])
     ]))

(defn f [a] (min (inc a) 10))
(transform [:a FIXED-POINT-PATH] f {:a 1 :b 2})
;; =&gt; {:a 10 :b 2}
"><span class="u" id="1533760014.000370">2018:08:08 20:26:54           nathanmarz </span><span>@jsa-aerial 
</span><pre>(def FIXED-POINT-PATH
  (recursive-path [] p
    [(collect-one STAY)
     (multi-path
       [DISPENSE STAY]
       [(collect-one STAY)
        (if-path (collected? [a b] (= a b))
          STOP
          [DISPENSE p]
          )])
     ]))

(defn f [a] (min (inc a) 10))
(transform [:a FIXED-POINT-PATH] f {:a 1 :b 2})
;; =&gt; {:a 10 :b 2}
</pre></div><div data-t="nathanmarz that&apos;s an interesting one"><span class="u" id="1533760038.000170">2018:08:08 20:27:18           nathanmarz </span><span>that&apos;s an interesting one</span></div><div data-t="nathanmarz actually can shorten the definition like this:
 (def FIXED-POINT-PATH
  (recursive-path [] p
    [(collect-one STAY)
     (multi-path
       [DISPENSE STAY]
       [(collect-one STAY)
        (if-path (collected? [a b] (not= a b))
          [DISPENSE p]
          )])
     ]))
"><span class="u" id="1533760117.000197">2018:08:08 20:28:37           nathanmarz </span><span>actually can shorten the definition like this:
</span><pre>(def FIXED-POINT-PATH
  (recursive-path [] p
    [(collect-one STAY)
     (multi-path
       [DISPENSE STAY]
       [(collect-one STAY)
        (if-path (collected? [a b] (not= a b))
          [DISPENSE p]
          )])
     ]))
</pre></div><div data-t="nathanmarz I&apos;d probably just write that in regular clojure though"><span class="u" id="1533760236.000105">2018:08:08 20:30:36           nathanmarz </span><span>I&apos;d probably just write that in regular clojure though</span></div><div data-t="nathanmarz using  loop"><span class="u" id="1533760253.000322">2018:08:08 20:30:53           nathanmarz </span><span>using </span><code>loop</code></div><div data-t="jsa-aerial I think it will be instructive to study these two - even though for the particular case in question the solution actually looks simpler in straight clojure"><span class="u" id="1533760860.000319">2018:08:08 20:41:00           jsa-aerial </span><span>I think it will be instructive to study these two - even though for the particular case in question the solution actually looks simpler in straight clojure</span></div><div data-t="nathanmarz for sure"><span class="u" id="1533760978.000187">2018:08:08 20:42:58           nathanmarz </span><span>for sure</span></div><div data-t="blak3mill3r Does anyone know of any extant attempts at a  specter  visualization tool?"><span class="u" id="1533942033.000173">2018:08:10 23:00:33          blak3mill3r </span><span>Does anyone know of any extant attempts at a </span><code>specter</code><span> visualization tool?</span></div><div data-t="blak3mill3r I want one and I think I have a good idea for how to do it..."><span class="u" id="1533942052.000172">2018:08:10 23:00:52          blak3mill3r </span><span>I want one and I think I have a good idea for how to do it...</span></div><div data-t="nathanmarz @blak3mill3r what do you have in mind?"><span class="u" id="1533950285.000053">2018:08:11 01:18:05           nathanmarz </span><span>@blak3mill3r what do you have in mind?</span></div><div data-t="blak3mill3r @nathanmarz an  electron  window that pretty-prints some data and highlights the parts that a path selects, combined with some repl tools along the lines of  https://github.com/dgrnbrg/spyscope  ... so you would eval  #s/show (select [ALL :a MAP-VALS] something)  and then see  something  pretty-printed with some parts of it highlighted"><span class="u" id="1534018734.000074">2018:08:11 20:18:54          blak3mill3r </span><span>@nathanmarz an </span><code>electron</code><span> window that pretty-prints some data and highlights the parts that a path selects, combined with some repl tools along the lines of </span><a href="https://github.com/dgrnbrg/spyscope">https://github.com/dgrnbrg/spyscope</a><span> ... so you would eval </span><code>#s/show (select [ALL :a MAP-VALS] something)</code><span> and then see </span><code>something</code><span> pretty-printed with some parts of it highlighted</span></div><div data-t="nathanmarz @blak3mill3r that would be cool, especially if it showed the sequence of steps in a path in an interactive way"><span class="u" id="1534019410.000127">2018:08:11 20:30:10           nathanmarz </span><span>@blak3mill3r that would be cool, especially if it showed the sequence of steps in a path in an interactive way</span></div><div data-t="mmer Simple question - I want to collect a set of keys from a nested map (but not all the keys - is there a simple way to do this?"><span class="u" id="1534500031.000100">2018:08:17 10:00:31                 mmer </span><span>Simple question - I want to collect a set of keys from a nested map (but not all the keys - is there a simple way to do this?</span></div><div data-t="nathanmarz @mmer if you just want to filter by a predicate you can do  (select [MAP-KEYS even?] {1 :a 2 :b 3 :c 4 :d}) ;; =&gt; [2 4]"><span class="u" id="1534510547.000100">2018:08:17 12:55:47           nathanmarz </span><span>@mmer if you just want to filter by a predicate you can do </span><code>(select [MAP-KEYS even?] {1 :a 2 :b 3 :c 4 :d}) ;; =&gt; [2 4]</code></div><div data-t="mmer Thanks"><span class="u" id="1534512322.000100">2018:08:17 13:25:22                 mmer </span><span>Thanks</span></div><div data-t="mmer As always happens with this - getting back into using after a while can be brain twisting - I want to do a conditional collect.  I want to collect something based on a child map containing a certain key"><span class="u" id="1534512518.000100">2018:08:17 13:28:38                 mmer </span><span>As always happens with this - getting back into using after a while can be brain twisting - I want to do a conditional collect.  I want to collect something based on a child map containing a certain key</span></div><div data-t="mmer Also is there an easy way to select a map entry that has a certain key no matter where in a deeply nested data structure it is?"><span class="u" id="1534512636.000100">2018:08:17 13:30:36                 mmer </span><span>Also is there an easy way to select a map entry that has a certain key no matter where in a deeply nested data structure it is?</span></div><div data-t="nathanmarz @mmer do you have specific examples of what you&apos;re trying to do? It varies depending on the specifics"><span class="u" id="1534514047.000100">2018:08:17 13:54:07           nathanmarz </span><span>@mmer do you have specific examples of what you&apos;re trying to do? It varies depending on the specifics</span></div><div data-t="mmer I am working over a yaml datastructure.  I would like collect the name of the yaml item if the structure contains an item called &quot;tag&quot; ,  I also need the content of the tag."><span class="u" id="1534514497.000100">2018:08:17 14:01:37                 mmer </span><span>I am working over a yaml datastructure.  I would like collect the name of the yaml item if the structure contains an item called &quot;tag&quot; ,  I also need the content of the tag.</span></div><div data-t="mmer Interesting side point - until you asked this question I was unaware of the nastiness of the extra vectors as inmost case specter just did what I expected! --fantastic.  Just these odd cases"><span class="u" id="1534514579.000100">2018:08:17 14:02:59                 mmer </span><span>Interesting side point - until you asked this question I was unaware of the nastiness of the extra vectors as inmost case specter just did what I expected! --fantastic.  Just these odd cases</span></div><div data-t="nathanmarz @mmer is that map in the input supposed to be a vector?"><span class="u" id="1534515063.000100">2018:08:17 14:11:03           nathanmarz </span><span>@mmer is that map in the input supposed to be a vector?</span></div><div data-t="nathanmarz and by nested anywhere inside, you mean any one of those inner vectors could repeat the top-level structure?"><span class="u" id="1534515089.000100">2018:08:17 14:11:29           nathanmarz </span><span>and by nested anywhere inside, you mean any one of those inner vectors could repeat the top-level structure?</span></div><div data-t="mmer The input structure could be contained anywhere in a larger structure and yes that should be a map - sorry"><span class="u" id="1534515232.000100">2018:08:17 14:13:52                 mmer </span><span>The input structure could be contained anywhere in a larger structure and yes that should be a map - sorry</span></div><div data-t="nathanmarz @mmer do you have an example of a more deeply nested structure?"><span class="u" id="1534517480.000100">2018:08:17 14:51:20           nathanmarz </span><span>@mmer do you have an example of a more deeply nested structure?</span></div><div data-t="mmer Not sure I can share that - don&apos;t worry about it I will keep going.  I am making progress in other areas.  Thanks."><span class="u" id="1534517631.000100">2018:08:17 14:53:51                 mmer </span><span>Not sure I can share that - don&apos;t worry about it I will keep going.  I am making progress in other areas.  Thanks.</span></div><div data-t="roklenarcic I tend to use keywords as navigators for maps:  (transform [:a :b ... . It works but is it correct? Are there downsides to this"><span class="u" id="1535114633.000100">2018:08:24 12:43:53          roklenarcic </span><span>I tend to use keywords as navigators for maps: </span><code>(transform [:a :b ...</code><span>. It works but is it correct? Are there downsides to this</span></div><div data-t="idiomancy hoookay, trying to make a navigator path that selects the first value of every vector in a nested map of vectors like"><span class="u" id="1535163103.000100">2018:08:25 02:11:43            idiomancy </span><span>hoookay, trying to make a navigator path that selects the first value of every vector in a nested map of vectors like</span></div><div data-t="idiomancy"><span class="u" id="1535163110.000100">2018:08:25 02:11:50            idiomancy </span></div><div data-t="idiomancy i gather that I need a recursive path, and its straight blowin my mind"><span class="u" id="1535163162.000100">2018:08:25 02:12:42            idiomancy </span><span>i gather that I need a recursive path, and its straight blowin my mind</span></div><div data-t="idiomancy hmm"><span class="u" id="1535163895.000100">2018:08:25 02:24:55            idiomancy </span><span>hmm</span></div><div data-t="idiomancy"><span class="u" id="1535163932.000100">2018:08:25 02:25:32            idiomancy </span></div><div data-t="idiomancy damn.  thought this would work"><span class="u" id="1535164471.000100">2018:08:25 02:34:31            idiomancy </span><span>damn.  thought this would work</span></div><div data-t="idiomancy"><span class="u" id="1535164526.000100">2018:08:25 02:35:26            idiomancy </span></div><div data-t="idiomancy but it just blows up and says it exceeds recursion depth"><span class="u" id="1535164537.000100">2018:08:25 02:35:37            idiomancy </span><span>but it just blows up and says it exceeds recursion depth</span></div><div data-t="nathanmarz @roklenarcic if you want to navigate to the value for a keyword, then that&apos;s always the best way"><span class="u" id="1535179777.000100">2018:08:25 06:49:37           nathanmarz </span><span>@roklenarcic if you want to navigate to the value for a keyword, then that&apos;s always the best way</span></div><div data-t="nathanmarz there is also  must  which only navigates if the key exists"><span class="u" id="1535179824.000100">2018:08:25 06:50:24           nathanmarz </span><span>there is also </span><code>must</code><span> which only navigates if the key exists</span></div><div data-t="nathanmarz @idiomancy change VECTOR-NODES to ALL in the definition"><span class="u" id="1535179990.000100">2018:08:25 06:53:10           nathanmarz </span><span>@idiomancy change VECTOR-NODES to ALL in the definition</span></div><div data-t="idiomancy sorry for the delayed response but omg it works!  thanks @nathanmarz!"><span class="u" id="1535314654.000100">2018:08:26 20:17:34            idiomancy </span><span>sorry for the delayed response but omg it works!  thanks @nathanmarz!</span></div><div data-t="euccastro I just want to say specter is amazing.  After seeing a couple examples and just trying out wild guesses in a pet project everything is working as I expected"><span class="u" id="1535334910.000100">2018:08:27 01:55:10            euccastro </span><span>I just want to say specter is amazing.  After seeing a couple examples and just trying out wild guesses in a pet project everything is working as I expected</span></div><div data-t="jose I&apos;m trying to write a recursive navigator and I don&apos;t understand why this it&apos;s not working:
 (s/transform (s/recursive-path [] p (s/cond-path
                                        string? s/STAY
                                        map-entry? [s/ALL p]
                                        map? [s/ALL p]))
               keyword
               {&quot;A&quot; {&quot;B&quot; &quot;C&quot;} &quot;X&quot; 1})
"><span class="u" id="1535487003.000100">2018:08:28 20:10:03                 jose </span><span>I&apos;m trying to write a recursive navigator and I don&apos;t understand why this it&apos;s not working:
</span><pre>(s/transform (s/recursive-path [] p (s/cond-path
                                        string? s/STAY
                                        map-entry? [s/ALL p]
                                        map? [s/ALL p]))
               keyword
               {&quot;A&quot; {&quot;B&quot; &quot;C&quot;} &quot;X&quot; 1})
</pre></div><div data-t="jose by not working, I mean that nothing is transformed, but if instead of  transform  I use  select  I get
 [&quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;X&quot;]
 
as I was expecting"><span class="u" id="1535495312.000100">2018:08:28 22:28:32                 jose </span><span>by not working, I mean that nothing is transformed, but if instead of </span><code>transform</code><span> I use </span><code>select</code><span> I get
</span><pre>[&quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;X&quot;]
</pre><span>
as I was expecting</span></div><div data-t="nathanmarz @jlle  ALL  on maps during transform navigates to vectors for map entries"><span class="u" id="1535518951.000100">2018:08:29 05:02:31           nathanmarz </span><span>@jlle </span><code>ALL</code><span> on maps during transform navigates to vectors for map entries</span></div><div data-t="nathanmarz replace map? and map-entry? lines with coll? to fix it"><span class="u" id="1535518987.000100">2018:08:29 05:03:07           nathanmarz </span><span>replace map? and map-entry? lines with coll? to fix it</span></div><div data-t="jose @nathanmarz that was the piece I was missing, thanks for the info"><span class="u" id="1535540962.000100">2018:08:29 11:09:22                 jose </span><span>@nathanmarz that was the piece I was missing, thanks for the info</span></div><div data-t="jose My transformation is a bit more complex, what I&apos;m trying to do is to transform all the string to keywords, except for the map values where the map key matches some condition. Easier to understand with an example:"><span class="u" id="1535540969.000100">2018:08:29 11:09:29                 jose </span><span>My transformation is a bit more complex, what I&apos;m trying to do is to transform all the string to keywords, except for the map values where the map key matches some condition. Easier to understand with an example:</span></div><div data-t="jose"><span class="u" id="1535541013.000100">2018:08:29 11:10:13                 jose </span></div><div data-t="jose which returns  {:X &quot;Y&quot;, :Z 1, :I {:X &quot;Z&quot;}} 
I found that the transformation fails in cases like this:  {&quot;X&quot; &quot;Y&quot; &quot;I&quot; [&quot;X&quot; &quot;Z&quot;]} 
so I updated the transformation function to:"><span class="u" id="1535541045.000100">2018:08:29 11:10:45                 jose </span><span>which returns </span><code>{:X &quot;Y&quot;, :Z 1, :I {:X &quot;Z&quot;}}</code><span>
I found that the transformation fails in cases like this: </span><code>{&quot;X&quot; &quot;Y&quot; &quot;I&quot; [&quot;X&quot; &quot;Z&quot;]}</code><span>
so I updated the transformation function to:</span></div><div data-t="jose"><span class="u" id="1535541080.000100">2018:08:29 11:11:20                 jose </span></div><div data-t="nathanmarz @jlle don&apos;t handle the map entry case separately, hande it on map? case as  [ALL (if-path [FIRST (pred= &quot;X&quot;)] FIRST ALL) p]"><span class="u" id="1535561846.000100">2018:08:29 16:57:26           nathanmarz </span><span>@jlle don&apos;t handle the map entry case separately, hande it on map? case as </span><code>[ALL (if-path [FIRST (pred= &quot;X&quot;)] FIRST ALL) p]</code></div><div data-t="jose right, that&apos;s a better solution, thanks a lot for the tip"><span class="u" id="1535569637.000200">2018:08:29 19:07:17                 jose </span><span>right, that&apos;s a better solution, thanks a lot for the tip</span></div><div data-t="benzap I figured it out!"><span class="u" id="1535729364.000100">2018:08:31 15:29:24               benzap </span><span>I figured it out!</span></div><div data-t="idiomancy hmm, interesting.  I&apos;m trying to select the meta from some objects and use that in a transformation step.  It seems like when I put meta in the path, it acts as an identity function, returning the same values"><span class="u" id="1535751820.000100">2018:08:31 21:43:40            idiomancy </span><span>hmm, interesting.  I&apos;m trying to select the meta from some objects and use that in a transformation step.  It seems like when I put meta in the path, it acts as an identity function, returning the same values</span></div><div data-t="idiomancy oh, I see.  there&apos;s a specific  META  navigator"><span class="u" id="1535752022.000100">2018:08:31 21:47:02            idiomancy </span><span>oh, I see.  there&apos;s a specific </span><code>META</code><span> navigator</span></div><div data-t="idiomancy Okay.  So, for each element in this collection, I want to take its metadata key if it has metadata, or the key will be in a map as the second element of the list.

so, data looks like this:
 [^{:key &quot;hello&quot;} [:div]
                          [:div {:key &quot;world&quot;}]
                          [:div [:subdiv]]]
 

I want to select the keys, if they exist, for each.  So, something like
 (s/select 
  [s/ALL
   (s/if-path [s/META :key]
              [s/META :key]
              [#(&lt; 1 (count %)) (s/nthpath 1) map? :key])]
  [^{:key &quot;hello&quot;} [:div] 
                   [:div {:key &quot;world&quot;}]
                   [:div [:subdiv]]])
=&gt; [&quot;hello&quot; &quot;world&quot; nil]
 

but if-path isn&apos;t doing what I thought.  if-path tests the first element, and if it succeeds, uses that path for all of the elements.

How do I do what I&apos;m trying to do?"><span class="u" id="1535754514.000100">2018:08:31 22:28:34            idiomancy </span><span>Okay.  So, for each element in this collection, I want to take its metadata key if it has metadata, or the key will be in a map as the second element of the list.

so, data looks like this:
</span><pre>[^{:key &quot;hello&quot;} [:div]
                          [:div {:key &quot;world&quot;}]
                          [:div [:subdiv]]]
</pre><span>

I want to select the keys, if they exist, for each.  So, something like
</span><pre>(s/select 
  [s/ALL
   (s/if-path [s/META :key]
              [s/META :key]
              [#(&lt; 1 (count %)) (s/nthpath 1) map? :key])]
  [^{:key &quot;hello&quot;} [:div] 
                   [:div {:key &quot;world&quot;}]
                   [:div [:subdiv]]])
=&gt; [&quot;hello&quot; &quot;world&quot; nil]
</pre><span>

but if-path isn&apos;t doing what I thought.  if-path tests the first element, and if it succeeds, uses that path for all of the elements.

How do I do what I&apos;m trying to do?</span></div><div data-t="idiomancy I ended up doing it with a multi-path and a filter for now... is there a better way?"><span class="u" id="1535755498.000100">2018:08:31 22:44:58            idiomancy </span><span>I ended up doing it with a multi-path and a filter for now... is there a better way?</span></div><div data-t="idiomancy [s/ALL
 (s/multi-path [s/META :key]
               [#(&lt; 1 (count %))
                (s/nthpath 1)
                map? :key])
 some?]
 

and then I just manually select the first element of the path returned collect, because I don&apos;t know how to bring it back to a single element  😂"><span class="u" id="1535755592.000100">2018:08:31 22:46:32            idiomancy </span><pre>[s/ALL
 (s/multi-path [s/META :key]
               [#(&lt; 1 (count %))
                (s/nthpath 1)
                map? :key])
 some?]
</pre><span>

and then I just manually select the first element of the path returned collect, because I don&apos;t know how to bring it back to a single element </span><b>😂</b></div><div data-t="nathanmarz @idiomancy if-path&apos;s condition is true if the path selects at least one element"><span class="u" id="1535782792.000100">2018:09:01 06:19:52           nathanmarz </span><span>@idiomancy if-path&apos;s condition is true if the path selects at least one element</span></div><div data-t="nathanmarz since META and keywords always navigate to exactly one value, your condition is always true"><span class="u" id="1535782824.000100">2018:09:01 06:20:24           nathanmarz </span><span>since META and keywords always navigate to exactly one value, your condition is always true</span></div><div data-t="nathanmarz you want the condition path  [META (must :key)]"><span class="u" id="1535782873.000100">2018:09:01 06:21:13           nathanmarz </span><span>you want the condition path </span><code>[META (must :key)]</code></div><div data-t="idiomancy Thanks!  And thanks for the incredible library  :star-struck:   I&apos;m so addicted!"><span class="u" id="1535804668.000100">2018:09:01 12:24:28            idiomancy </span><span>Thanks!  And thanks for the incredible library </span><b>:star-struck:</b><span>  I&apos;m so addicted!</span></div><div data-t="unbalanced specific and general question.
General question: where does one go to level up in specter?  I feel like I&apos;ve already tapped out on talks/tutorials and I know I&apos;m only scratching the surface.  Case in point --
Specific question:

given

 (def contrived-data {:time 1535940129129
                       :data [{:a [{:start 389
                                    :stop  456}]}
                              {:b [{:start 113
                                    :stop  889}]}]}) 

I&apos;m attempting to sort by  :start .  It&apos;s blessedly simple to select the values via

 (sm/select [:data s/ALL s/MAP-VALS s/ALL :start] contrived-data) 

my intuition to do the operation would be

 (sm/transform [:data s/ALL s/MAP-VALS s/ALL :start] sort contrived-data) 

but I realized my thinking may have gone awry somewhere along the way"><span class="u" id="1535940639.000100">2018:09:03 02:10:39           unbalanced </span><span>specific and general question.
General question: where does one go to level up in specter?  I feel like I&apos;ve already tapped out on talks/tutorials and I know I&apos;m only scratching the surface.  Case in point --
Specific question:

given

</span><pre>(def contrived-data {:time 1535940129129
                       :data [{:a [{:start 389
                                    :stop  456}]}
                              {:b [{:start 113
                                    :stop  889}]}]})</pre><span>

I&apos;m attempting to sort by </span><code>:start</code><span>.  It&apos;s blessedly simple to select the values via

</span><pre>(sm/select [:data s/ALL s/MAP-VALS s/ALL :start] contrived-data)</pre><span>

my intuition to do the operation would be

</span><pre>(sm/transform [:data s/ALL s/MAP-VALS s/ALL :start] sort contrived-data)</pre><span>

but I realized my thinking may have gone awry somewhere along the way</span></div><div data-t="nathanmarz @goomba what do you want the result of that transform to be?"><span class="u" id="1535940832.000100">2018:09:03 02:13:52           nathanmarz </span><span>@goomba what do you want the result of that transform to be?</span></div><div data-t="unbalanced"><span class="u" id="1535940979.000100">2018:09:03 02:16:19           unbalanced </span></div><div data-t="unbalanced sorry, should&apos;ve posted that"><span class="u" id="1535940984.000100">2018:09:03 02:16:24           unbalanced </span><span>sorry, should&apos;ve posted that</span></div><div data-t="unbalanced as in,  :b  should come first because its  :start  value is lower"><span class="u" id="1535941002.000200">2018:09:03 02:16:42           unbalanced </span><span>as in, </span><code>:b</code><span> should come first because its </span><code>:start</code><span> value is lower</span></div><div data-t="nathanmarz what if the inner collection has multiple  :start  values?"><span class="u" id="1535941056.000200">2018:09:03 02:17:36           nathanmarz </span><span>what if the inner collection has multiple </span><code>:start</code><span> values?</span></div><div data-t="nathanmarz use the lowest?"><span class="u" id="1535941063.000100">2018:09:03 02:17:43           nathanmarz </span><span>use the lowest?</span></div><div data-t="unbalanced sure  😅"><span class="u" id="1535941078.000100">2018:09:03 02:17:58           unbalanced </span><span>sure </span><b>😅</b></div><div data-t="unbalanced hadn&apos;t thought that far ahead with my contrived example"><span class="u" id="1535941092.000100">2018:09:03 02:18:12           unbalanced </span><span>hadn&apos;t thought that far ahead with my contrived example</span></div><div data-t="unbalanced it&apos;s the fact that the keys  :a  and  :b  &quot;pre-fix&quot; the data makes any sort of normal  update-in /`sort-by` completely unusable, at least with any sort of elegance/performance"><span class="u" id="1535941132.000100">2018:09:03 02:18:52           unbalanced </span><span>it&apos;s the fact that the keys </span><code>:a</code><span> and </span><code>:b</code><span> &quot;pre-fix&quot; the data makes any sort of normal </span><code>update-in</code><span>/`sort-by` completely unusable, at least with any sort of elegance/performance</span></div><div data-t="unbalanced but I encounter this problem all the time"><span class="u" id="1535941152.000100">2018:09:03 02:19:12           unbalanced </span><span>but I encounter this problem all the time</span></div><div data-t="nathanmarz you can use something like  (fn [m] (reduce min (traverse [MAP-VALS ALL :start] m))  for a &quot;keyfn&quot; to  sort-by"><span class="u" id="1535941338.000100">2018:09:03 02:22:18           nathanmarz </span><span>you can use something like </span><code>(fn [m] (reduce min (traverse [MAP-VALS ALL :start] m))</code><span> for a &quot;keyfn&quot; to </span><code>sort-by</code></div><div data-t="nathanmarz and then  (transform :data #(sort-by keyfn %) data)"><span class="u" id="1535941396.000100">2018:09:03 02:23:16           nathanmarz </span><span>and then </span><code>(transform :data #(sort-by keyfn %) data)</code></div><div data-t="nathanmarz beware that  sort-by  will change that vector to a list"><span class="u" id="1535941495.000100">2018:09:03 02:24:55           nathanmarz </span><span>beware that </span><code>sort-by</code><span> will change that vector to a list</span></div><div data-t="unbalanced ohhhh mannn that is cooooolllllll  😄"><span class="u" id="1535941515.000100">2018:09:03 02:25:15           unbalanced </span><span>ohhhh mannn that is cooooolllllll </span><b>😄</b></div><div data-t="unbalanced thank you! how did you... well, I guess because you wrote it, I would&apos;ve thought to use  select  instead of  traverse"><span class="u" id="1535941631.000100">2018:09:03 02:27:11           unbalanced </span><span>thank you! how did you... well, I guess because you wrote it, I would&apos;ve thought to use </span><code>select</code><span> instead of </span><code>traverse</code></div><div data-t="nathanmarz always use  traverse  if all you&apos;ll be doing is a  reduce  over the result"><span class="u" id="1535941689.000100">2018:09:03 02:28:09           nathanmarz </span><span>always use </span><code>traverse</code><span> if all you&apos;ll be doing is a </span><code>reduce</code><span> over the result</span></div><div data-t="nathanmarz more efficient since no intermediate list is materialized"><span class="u" id="1535941714.000100">2018:09:03 02:28:34           nathanmarz </span><span>more efficient since no intermediate list is materialized</span></div><div data-t="unbalanced 🙏  fantastic.  Thanks again."><span class="u" id="1535941805.000100">2018:09:03 02:30:05           unbalanced </span><b>🙏</b><span> fantastic.  Thanks again.</span></div><div data-t="unbalanced forgive the neophyte inquiriry, I&apos;m attempting to emulate
 (update-in {} [:a :b :c] (fnil concat [])  [1 2 3])"><span class="u" id="1536020268.000100">2018:09:04 00:17:48           unbalanced </span><span>forgive the neophyte inquiriry, I&apos;m attempting to emulate
</span><pre>(update-in {} [:a :b :c] (fnil concat [])  [1 2 3])</pre></div><div data-t="unbalanced for practice I&apos;m just trying it on one nested value"><span class="u" id="1536020284.000200">2018:09:04 00:18:04           unbalanced </span><span>for practice I&apos;m just trying it on one nested value</span></div><div data-t="unbalanced (setval [:a NIL-&gt;VECTOR END] [1 2 3] {})"><span class="u" id="1536020301.000100">2018:09:04 00:18:21           unbalanced </span><pre>(setval [:a NIL-&gt;VECTOR END] [1 2 3] {})</pre></div><div data-t="unbalanced ah I see... so the above is working it&apos;s when I&apos;m dealing with a vector-as-a-key that it&apos;s an issue"><span class="u" id="1536021833.000100">2018:09:04 00:43:53           unbalanced </span><span>ah I see... so the above is working it&apos;s when I&apos;m dealing with a vector-as-a-key that it&apos;s an issue</span></div><div data-t="unbalanced (setval [:a (must [:b :c]) NIL-&gt;VECTOR END] [1 2 3] {:a {}})"><span class="u" id="1536021852.000100">2018:09:04 00:44:12           unbalanced </span><pre>(setval [:a (must [:b :c]) NIL-&gt;VECTOR END] [1 2 3] {:a {}})</pre></div><div data-t="unbalanced current working work around... not pretty but it works"><span class="u" id="1536023568.000100">2018:09:04 01:12:48           unbalanced </span><span>current working work around... not pretty but it works</span></div><div data-t="unbalanced"><span class="u" id="1536023610.000100">2018:09:04 01:13:30           unbalanced </span></div><div data-t="nathanmarz @goomba I think you want  (must :b :c)  or  (apply must [:b :c])"><span class="u" id="1536039253.000100">2018:09:04 05:34:13           nathanmarz </span><span>@goomba I think you want </span><code>(must :b :c)</code><span> or </span><code>(apply must [:b :c])</code></div><div data-t="unbalanced hmm well no luck so far but my guess is in general I&apos;m still not a high enough level specter yet"><span class="u" id="1536094253.000100">2018:09:04 20:50:53           unbalanced </span><span>hmm well no luck so far but my guess is in general I&apos;m still not a high enough level specter yet</span></div><div data-t="unbalanced you don&apos;t happen to know @nathanmarz of any open source projects that are making good use of your library do you?  Would love to see more examples"><span class="u" id="1536094289.000100">2018:09:04 20:51:29           unbalanced </span><span>you don&apos;t happen to know @nathanmarz of any open source projects that are making good use of your library do you?  Would love to see more examples</span></div><div data-t="unbalanced I&apos;m always getting so close to what I want to do but just always missing a piece"><span class="u" id="1536094349.000100">2018:09:04 20:52:29           unbalanced </span><span>I&apos;m always getting so close to what I want to do but just always missing a piece</span></div><div data-t="unbalanced for instance, navigating to the maximum of a set of elements"><span class="u" id="1536094357.000100">2018:09:04 20:52:37           unbalanced </span><span>for instance, navigating to the maximum of a set of elements</span></div><div data-t="unbalanced (select [MAP-VALS :index MAX] {:a {:index 0} :b {:index 1}})  ... I should be able to write or figure out  MAX  but sadly just not there yet"><span class="u" id="1536094435.000100">2018:09:04 20:53:55           unbalanced </span><pre>(select [MAP-VALS :index MAX] {:a {:index 0} :b {:index 1}})</pre><span> ... I should be able to write or figure out </span><code>MAX</code><span> but sadly just not there yet</span></div><div data-t="unbalanced of course that&apos;s simple enough to do with other functions but just trying to learn to think in specter haha"><span class="u" id="1536094504.000200">2018:09:04 20:55:04           unbalanced </span><span>of course that&apos;s simple enough to do with other functions but just trying to learn to think in specter haha</span></div><div data-t="nathanmarz @goomba I don&apos;t really keep track of how specter is used by other open source projects"><span class="u" id="1536096442.000100">2018:09:04 21:27:22           nathanmarz </span><span>@goomba I don&apos;t really keep track of how specter is used by other open source projects</span></div><div data-t="nathanmarz you can try doing a github search"><span class="u" id="1536096464.000100">2018:09:04 21:27:44           nathanmarz </span><span>you can try doing a github search</span></div><div data-t="unbalanced no problemo... working through some of your examples"><span class="u" id="1536096473.000100">2018:09:04 21:27:53           unbalanced </span><span>no problemo... working through some of your examples</span></div><div data-t="nathanmarz MAX  would have to be done with  defnav"><span class="u" id="1536096500.000100">2018:09:04 21:28:20           nathanmarz </span><code>MAX</code><span> would have to be done with </span><code>defnav</code></div><div data-t="roklenarcic Hm, I have two predicates and sequence. I would like to select items starting with an element that satisfies predicate1, up to an element that specifies predicate2."><span class="u" id="1536238512.000100">2018:09:06 12:55:12          roklenarcic </span><span>Hm, I have two predicates and sequence. I would like to select items starting with an element that satisfies predicate1, up to an element that specifies predicate2.</span></div><div data-t="roklenarcic I&apos;m a bit of a newbie when it comes to working subsequences with specter"><span class="u" id="1536238551.000100">2018:09:06 12:55:51          roklenarcic </span><span>I&apos;m a bit of a newbie when it comes to working subsequences with specter</span></div><div data-t="nathanmarz @roklenarcic you would need  https://github.com/nathanmarz/specter/issues/236  to do that"><span class="u" id="1536239181.000100">2018:09:06 13:06:21           nathanmarz </span><span>@roklenarcic you would need </span><a href="https://github.com/nathanmarz/specter/issues/236">https://github.com/nathanmarz/specter/issues/236</a><span> to do that</span></div><div data-t="nathanmarz you could make your own version of continuous-subseqs with the generalized behavior, it&apos;s not very complicated"><span class="u" id="1536239242.000100">2018:09:06 13:07:22           nathanmarz </span><span>you could make your own version of continuous-subseqs with the generalized behavior, it&apos;s not very complicated</span></div><div data-t="roklenarcic Fortunately this isn&apos;t nested in some other selector so I&apos;ll just use drop-while, take-while"><span class="u" id="1536239287.000100">2018:09:06 13:08:07          roklenarcic </span><span>Fortunately this isn&apos;t nested in some other selector so I&apos;ll just use drop-while, take-while</span></div><div data-t="bruno.bonacci Hi,
is there any way in Specter to have a something like a  mapcat ??
For example I’d like to denormalize a map like this:
 {:a 1 :b [&quot;a&quot; &quot;b&quot;]}
 
into
 {:a 1 :b &quot;a&quot;}
{:a 1 :b &quot;b&quot;}
 

same as

 (mapcat (fn [{:keys [b] :as m}]
          (map #(assoc m :b %) b))
        [{:a 1 :b [&quot;a&quot; &quot;b&quot;]} {:a 2 :b [&quot;c&quot; &quot;d&quot;]}])
;;=&gt; &apos;({:a 1, :b &quot;a&quot;} {:a 1, :b &quot;b&quot;} {:a 2, :b &quot;c&quot;} {:a 2, :b &quot;d&quot;})
 
But I havent found a way to concatenate the result and remove
the extra ’() in one step.

 (transform [ALL]
           (fn [{:keys [b] :as m}]
             (map #(assoc m :b %) b))
           [{:a 1 :b [&quot;a&quot; &quot;b&quot;]} {:a 2 :b [&quot;c&quot; &quot;d&quot;]}])
;;=&gt; [({:a 1, :b &quot;a&quot;} {:a 1, :b &quot;b&quot;})
;;    ({:a 2, :b &quot;c&quot;} {:a 2, :b &quot;d&quot;})]

"><span class="u" id="1536247576.000100">2018:09:06 15:26:16        bruno.bonacci </span><span>Hi,
is there any way in Specter to have a something like a </span><code>mapcat</code><span>??
For example I’d like to denormalize a map like this:
</span><pre>{:a 1 :b [&quot;a&quot; &quot;b&quot;]}
</pre><span>
into
</span><pre>{:a 1 :b &quot;a&quot;}
{:a 1 :b &quot;b&quot;}
</pre><span>

same as

</span><pre>(mapcat (fn [{:keys [b] :as m}]
          (map #(assoc m :b %) b))
        [{:a 1 :b [&quot;a&quot; &quot;b&quot;]} {:a 2 :b [&quot;c&quot; &quot;d&quot;]}])
;;=&gt; &apos;({:a 1, :b &quot;a&quot;} {:a 1, :b &quot;b&quot;} {:a 2, :b &quot;c&quot;} {:a 2, :b &quot;d&quot;})
</pre><span>
But I havent found a way to concatenate the result and remove
the extra ’() in one step.

</span><pre>(transform [ALL]
           (fn [{:keys [b] :as m}]
             (map #(assoc m :b %) b))
           [{:a 1 :b [&quot;a&quot; &quot;b&quot;]} {:a 2 :b [&quot;c&quot; &quot;d&quot;]}])
;;=&gt; [({:a 1, :b &quot;a&quot;} {:a 1, :b &quot;b&quot;})
;;    ({:a 2, :b &quot;c&quot;} {:a 2, :b &quot;d&quot;})]

</pre></div><div data-t="bruno.bonacci any idea?"><span class="u" id="1536247583.000100">2018:09:06 15:26:23        bruno.bonacci </span><span>any idea?</span></div><div data-t="nathanmarz @bruno.bonacci you can do something like:
 (transform ALL
  (fn [[m b]] (assoc m :b b))
  (select [ALL VAL :b ALL] data))
"><span class="u" id="1536254578.000100">2018:09:06 17:22:58           nathanmarz </span><span>@bruno.bonacci you can do something like:
</span><pre>(transform ALL
  (fn [[m b]] (assoc m :b b))
  (select [ALL VAL :b ALL] data))
</pre></div><div data-t="nathanmarz having two ALL&apos;s in a select can act like mapcat"><span class="u" id="1536254635.000100">2018:09:06 17:23:55           nathanmarz </span><span>having two ALL&apos;s in a select can act like mapcat</span></div><div data-t="bruno.bonacci ok, I understand what you are doing here. The  select  is creating a projection with the info and the  transform  is producing the final maps."><span class="u" id="1536254801.000100">2018:09:06 17:26:41        bruno.bonacci </span><span>ok, I understand what you are doing here. The </span><code>select</code><span> is creating a projection with the info and the </span><code>transform</code><span> is producing the final maps.</span></div><div data-t="bruno.bonacci interesting approach, thanks."><span class="u" id="1536254839.000100">2018:09:06 17:27:19        bruno.bonacci </span><span>interesting approach, thanks.</span></div><div data-t="nathanmarz with a modified  view  you could do it in a single  select"><span class="u" id="1536254875.000100">2018:09:06 17:27:55           nathanmarz </span><span>with a modified </span><code>view</code><span> you could do it in a single </span><code>select</code></div><div data-t="nathanmarz just by passing the collected vals into the view fn"><span class="u" id="1536254951.000100">2018:09:06 17:29:11           nathanmarz </span><span>just by passing the collected vals into the view fn</span></div><div data-t="bruno.bonacci got it, thanks"><span class="u" id="1536255027.000100">2018:09:06 17:30:27        bruno.bonacci </span><span>got it, thanks</span></div><div data-t="bruno.bonacci Sorry,  view  doesn’t seem to be affected by the collection of values"><span class="u" id="1536255837.000100">2018:09:06 17:43:57        bruno.bonacci </span><span>Sorry, </span><code>view</code><span> doesn’t seem to be affected by the collection of values</span></div><div data-t="bruno.bonacci (select [ALL VAL (view pr-str)] (range 5)) =&gt; [[0 &quot;0&quot;] [1 &quot;1&quot;] [2 &quot;2&quot;] [3 &quot;3&quot;] [4 &quot;4&quot;]]"><span class="u" id="1536255876.000100">2018:09:06 17:44:36        bruno.bonacci </span><code>(select [ALL VAL (view pr-str)] (range 5)) =&gt; [[0 &quot;0&quot;] [1 &quot;1&quot;] [2 &quot;2&quot;] [3 &quot;3&quot;] [4 &quot;4&quot;]]</code></div><div data-t="bruno.bonacci i was expecting that the  view  function would receive also the collected values"><span class="u" id="1536255922.000100">2018:09:06 17:45:22        bruno.bonacci </span><span>i was expecting that the </span><code>view</code><span> function would receive also the collected values</span></div><div data-t="bruno.bonacci here it appears it only receives the value in the navigation path"><span class="u" id="1536255968.000100">2018:09:06 17:46:08        bruno.bonacci </span><span>here it appears it only receives the value in the navigation path</span></div><div data-t="nathanmarz that&apos;s correct, that&apos;s why I said with a modified  view"><span class="u" id="1536256247.000100">2018:09:06 17:50:47           nathanmarz </span><span>that&apos;s correct, that&apos;s why I said with a modified </span><code>view</code></div><div data-t="nathanmarz (defrichnav cview [afn]
  (select* [this vals structure next-fn]
    (next-fn vals (apply afn (conj vals structure))))
  (transform* [this vals structure next-fn]
    (next-fn vals (apply afn (conj vals structure)))))
"><span class="u" id="1536256487.000100">2018:09:06 17:54:47           nathanmarz </span><pre>(defrichnav cview [afn]
  (select* [this vals structure next-fn]
    (next-fn vals (apply afn (conj vals structure))))
  (transform* [this vals structure next-fn]
    (next-fn vals (apply afn (conj vals structure)))))
</pre></div><div data-t="bruno.bonacci :+1:  Thanks"><span class="u" id="1536256549.000100">2018:09:06 17:55:49        bruno.bonacci </span><b>:+1:</b><span> Thanks</span></div><div data-t="miikka When should I use  nthpath  and when  index-nav ?"><span class="u" id="1536671025.000100">2018:09:11 13:03:45               miikka </span><span>When should I use </span><code>nthpath</code><span> and when </span><code>index-nav</code><span>?</span></div><div data-t="nathanmarz @miikka  nthpath  navigates to the value for the index,  index-nav  navigates to the actual index"><span class="u" id="1536672989.000100">2018:09:11 13:36:29           nathanmarz </span><span>@miikka </span><code>nthpath</code><span> navigates to the value for the index, </span><code>index-nav</code><span> navigates to the actual index</span></div><div data-t="nathanmarz take a look at the examples on the wiki"><span class="u" id="1536672999.000100">2018:09:11 13:36:39           nathanmarz </span><span>take a look at the examples on the wiki</span></div><div data-t="miikka Ah"><span class="u" id="1536673000.000100">2018:09:11 13:36:40               miikka </span><span>Ah</span></div><div data-t="idiomancy does anyone know how I would select a slice of elements within a sequence between two values?

I&apos;m slicing a datomic query, and I want everything between  :find  and  :when , so:

 [:find ?id . :where [?id :app/type :type/form]]
=&gt; [?id .]

[:find  [?tid ...] :where [?tid :app/type :type/task]]
=&gt; [[?tid ...]]
"><span class="u" id="1536863450.000100">2018:09:13 18:30:50            idiomancy </span><span>does anyone know how I would select a slice of elements within a sequence between two values?

I&apos;m slicing a datomic query, and I want everything between </span><code>:find</code><span> and </span><code>:when</code><span>, so:

</span><pre>[:find ?id . :where [?id :app/type :type/form]]
=&gt; [?id .]

[:find  [?tid ...] :where [?tid :app/type :type/task]]
=&gt; [[?tid ...]]
</pre></div><div data-t="idiomancy I guess I could use srange-dynamic"><span class="u" id="1536863625.000100">2018:09:13 18:33:45            idiomancy </span><span>I guess I could use srange-dynamic</span></div><div data-t="nathanmarz @idiomancy yes, srange-dynamic would work for that"><span class="u" id="1536896556.000100">2018:09:14 03:42:36           nathanmarz </span><span>@idiomancy yes, srange-dynamic would work for that</span></div><div data-t="mpenet how would you write a transform that modifies every string value in a tree? I have yet to check the doc but I figured I might just ask here in the meanwhile  😛"><span class="u" id="1536924737.000100">2018:09:14 11:32:17               mpenet </span><span>how would you write a transform that modifies every string value in a tree? I have yet to check the doc but I figured I might just ask here in the meanwhile </span><b>😛</b></div><div data-t="schmee (transform (walker string?) your-fn your-coll)"><span class="u" id="1536924825.000100">2018:09:14 11:33:45               schmee </span><code>(transform (walker string?) your-fn your-coll)</code></div><div data-t="schmee not the most efficient way but gets the job done"><span class="u" id="1536924839.000100">2018:09:14 11:33:59               schmee </span><span>not the most efficient way but gets the job done</span></div><div data-t="schmee if you need performance, write your own recursive navigator:  https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#a-basic-example"><span class="u" id="1536924879.000100">2018:09:14 11:34:39               schmee </span><span>if you need performance, write your own recursive navigator: </span><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#a-basic-example">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#a-basic-example</a></div><div data-t="mpenet reading that at the moment, that seems like what I am looking for indeed. thanks"><span class="u" id="1536924897.000100">2018:09:14 11:34:57               mpenet </span><span>reading that at the moment, that seems like what I am looking for indeed. thanks</span></div><div data-t="Petrus Theron Has anyone used Specter for Matrix algebra? I&apos;m dealing with Kalman filtering N streams of data, and I have to do all this ceremony around assigning an index to each sensor value, multiplying some matrixes together that are really about (premature) index-based optimization, then I have to un-index them again - basically, lensing."><span class="u" id="1536927010.000100">2018:09:14 12:10:10        Petrus Theron </span><span>Has anyone used Specter for Matrix algebra? I&apos;m dealing with Kalman filtering N streams of data, and I have to do all this ceremony around assigning an index to each sensor value, multiplying some matrixes together that are really about (premature) index-based optimization, then I have to un-index them again - basically, lensing.</span></div><div data-t="nathanmarz @petrus I&apos;ve done some stuff with matrices"><span class="u" id="1536929470.000100">2018:09:14 12:51:10           nathanmarz </span><span>@petrus I&apos;ve done some stuff with matrices</span></div><div data-t="nathanmarz you&apos;ll want custom navigators for them to do anything sophisticated"><span class="u" id="1536929546.000100">2018:09:14 12:52:26           nathanmarz </span><span>you&apos;ll want custom navigators for them to do anything sophisticated</span></div><div data-t="nathanmarz e.g. a &quot;submat&quot; navigator that navigates to an arbitrary sub-matrix"><span class="u" id="1536929588.000100">2018:09:14 12:53:08           nathanmarz </span><span>e.g. a &quot;submat&quot; navigator that navigates to an arbitrary sub-matrix</span></div><div data-t="nathanmarz &quot;row&quot; and &quot;col&quot; navigators can be useful too"><span class="u" id="1536929609.000100">2018:09:14 12:53:29           nathanmarz </span><span>&quot;row&quot; and &quot;col&quot; navigators can be useful too</span></div><div data-t="okocim I’m a complete novice with specter (fired it up about a day ago), but I’m liking it so far.  One thing that strikes me about the library is that it lends itself very well when you’re trying to simulate an “update in place” of a complex data structure. However, when I’m trying to completely change the shape of one data structure into a different structure (e.g. for transformation at a contract boundary), I find myself fighting with it a bit more.

Am I right in my thinking that this is more suited for changing values in an existing data structure, or was this library also intended to help reshape data structures, and I’m not yet understanding which of the helpers are used for that.

What I’ve been doing to date is calling  select  and collecting the values that I’m interested in, and then simply arranging the collected values into whatever shape I need. Is that the right approach?"><span class="u" id="1537458429.000100">2018:09:20 15:47:09               okocim </span><span>I’m a complete novice with specter (fired it up about a day ago), but I’m liking it so far.  One thing that strikes me about the library is that it lends itself very well when you’re trying to simulate an “update in place” of a complex data structure. However, when I’m trying to completely change the shape of one data structure into a different structure (e.g. for transformation at a contract boundary), I find myself fighting with it a bit more.

Am I right in my thinking that this is more suited for changing values in an existing data structure, or was this library also intended to help reshape data structures, and I’m not yet understanding which of the helpers are used for that.

What I’ve been doing to date is calling </span><code>select</code><span> and collecting the values that I’m interested in, and then simply arranging the collected values into whatever shape I need. Is that the right approach?</span></div><div data-t="nathanmarz @okocim you have it right, specter excels at doing partial changes of a data structure"><span class="u" id="1537463128.000100">2018:09:20 17:05:28           nathanmarz </span><span>@okocim you have it right, specter excels at doing partial changes of a data structure</span></div><div data-t="nathanmarz if you&apos;re restructuring the whole thing, specter probably won&apos;t help that much"><span class="u" id="1537463155.000100">2018:09:20 17:05:55           nathanmarz </span><span>if you&apos;re restructuring the whole thing, specter probably won&apos;t help that much</span></div><div data-t="okocim @nathanmarz Thanks for confirming, and thanks for the library. The partial update use-case is the one that I primarily used this for, and it really does feel like you’re providing a piece that’s missing in core clojure  👍"><span class="u" id="1537468338.000100">2018:09:20 18:32:18               okocim </span><span>@nathanmarz Thanks for confirming, and thanks for the library. The partial update use-case is the one that I primarily used this for, and it really does feel like you’re providing a piece that’s missing in core clojure </span><b>👍</b></div><div data-t="suskeyhose Hey, so I&apos;m working with specter a bit, and one problem that I&apos;ve noticed has come up several times which I feel has to have a normal solution, is that when I use  transform  there&apos;s no way to set the value if there is none already there. The solution I&apos;ve had to use on several occasions is this:
 (let [value (select-first [:path :to :val] structure)
      value (update-fn value)
      structure (setval [:path :to :val] value structure)]
  structure)
 
And this feels wrong on many levels, not the least of which because if  structure  is an atom, and I use  ATOM  in the path, that means that the operation is no longer atomic."><span class="u" id="1537720314.000100">2018:09:23 16:31:54           suskeyhose </span><span>Hey, so I&apos;m working with specter a bit, and one problem that I&apos;ve noticed has come up several times which I feel has to have a normal solution, is that when I use </span><code>transform</code><span> there&apos;s no way to set the value if there is none already there. The solution I&apos;ve had to use on several occasions is this:
</span><pre>(let [value (select-first [:path :to :val] structure)
      value (update-fn value)
      structure (setval [:path :to :val] value structure)]
  structure)
</pre><span>
And this feels wrong on many levels, not the least of which because if </span><code>structure</code><span> is an atom, and I use </span><code>ATOM</code><span> in the path, that means that the operation is no longer atomic.</span></div><div data-t="suskeyhose Everything else I&apos;ve used in specter always feels like a great addition to Clojure, but this one hiccup is something that I&apos;ve run into enough times that it almost makes me want to express this instead using a normal  swap!"><span class="u" id="1537720519.000100">2018:09:23 16:35:19           suskeyhose </span><span>Everything else I&apos;ve used in specter always feels like a great addition to Clojure, but this one hiccup is something that I&apos;ve run into enough times that it almost makes me want to express this instead using a normal </span><code>swap!</code></div><div data-t="jsa-aerial I&apos;m a bit confused. This sort of thing  (sp/transform [sp/ATOM key-path] update-fn db))  works just fine for me whether the final key exists or not. Also there is sp/BEGINNING and friends, which all work fine as well."><span class="u" id="1537721607.000100">2018:09:23 16:53:27           jsa-aerial </span><span>I&apos;m a bit confused. This sort of thing </span><code>(sp/transform [sp/ATOM key-path] update-fn db))</code><span> works just fine for me whether the final key exists or not. Also there is sp/BEGINNING and friends, which all work fine as well.</span></div><div data-t="jsa-aerial @suskeyhose ^^^^"><span class="u" id="1537721629.000100">2018:09:23 16:53:49           jsa-aerial </span><span>@suskeyhose ^^^^</span></div><div data-t="suskeyhose Really? I&apos;m not getting the function called at all with an example. Just a moment and I can give you the example that I&apos;m running."><span class="u" id="1537721668.000100">2018:09:23 16:54:28           suskeyhose </span><span>Really? I&apos;m not getting the function called at all with an example. Just a moment and I can give you the example that I&apos;m running.</span></div><div data-t="jsa-aerial Yeah, works great - if it didn&apos;t, I would be hurting"><span class="u" id="1537721747.000100">2018:09:23 16:55:47           jsa-aerial </span><span>Yeah, works great - if it didn&apos;t, I would be hurting</span></div><div data-t="suskeyhose Hmm. Well now it&apos;s working on the small example. Curious why it&apos;s not working in my larger code."><span class="u" id="1537721761.000100">2018:09:23 16:56:01           suskeyhose </span><span>Hmm. Well now it&apos;s working on the small example. Curious why it&apos;s not working in my larger code.</span></div><div data-t="jsa-aerial likely something else is happening"><span class="u" id="1537721781.000100">2018:09:23 16:56:21           jsa-aerial </span><span>likely something else is happening</span></div><div data-t="jsa-aerial Further, yielding sp/NONE for the value removes the element (for example, k/v pair in a map) which is really wonderful"><span class="u" id="1537721885.000100">2018:09:23 16:58:05           jsa-aerial </span><span>Further, yielding sp/NONE for the value removes the element (for example, k/v pair in a map) which is really wonderful</span></div><div data-t="suskeyhose Yeah, I&apos;ve used that a few times, which is fantastic"><span class="u" id="1537722255.000100">2018:09:23 17:04:15           suskeyhose </span><span>Yeah, I&apos;ve used that a few times, which is fantastic</span></div><div data-t="suskeyhose Okay, so the example in my code which this is working with is like this:
 (transform [ATOM
            ::ds/rate-limits
            ::ds/endpoint-specific-rate-limits
            {::ds/action :create-message
             ::ds/major-variable {::ds/major-variable-type ::ds/channel-id
                                  ::ds/major-variable-value &quot;286241942356885504&quot;}}]
           #(println %)
           (atom #:discljord.specs{:rate-limits #:discljord.specs{:endpoint-specific-rate-limits {}}, :channel (a/chan 100), :token &quot;TOKEN&quot;}))
 
The println doesn&apos;t get called at all"><span class="u" id="1537722877.000100">2018:09:23 17:14:37           suskeyhose </span><span>Okay, so the example in my code which this is working with is like this:
</span><pre>(transform [ATOM
            ::ds/rate-limits
            ::ds/endpoint-specific-rate-limits
            {::ds/action :create-message
             ::ds/major-variable {::ds/major-variable-type ::ds/channel-id
                                  ::ds/major-variable-value &quot;286241942356885504&quot;}}]
           #(println %)
           (atom #:discljord.specs{:rate-limits #:discljord.specs{:endpoint-specific-rate-limits {}}, :channel (a/chan 100), :token &quot;TOKEN&quot;}))
</pre><span>
The println doesn&apos;t get called at all</span></div><div data-t="suskeyhose (transform [:key {:doesnt-exist :blah}] #(do (println %) :blah) {:key {}})
 
here&apos;s a minimal example"><span class="u" id="1537722933.000200">2018:09:23 17:15:33           suskeyhose </span><pre>(transform [:key {:doesnt-exist :blah}] #(do (println %) :blah) {:key {}})
</pre><span>
here&apos;s a minimal example</span></div><div data-t="suskeyhose so apparently I can&apos;t use a map as a key and have it work"><span class="u" id="1537722941.000100">2018:09:23 17:15:41           suskeyhose </span><span>so apparently I can&apos;t use a map as a key and have it work</span></div><div data-t="suskeyhose user&gt; (select-first [{:blah :blah}] {{:blah :blah} :blah})
nil
user&gt; (transform [{:blah :blah}] #(do (println %) :blah2) {{:blah :blah} :blah})
{{:blah :blah} :blah}
 
Here&apos;s some more stuff from my repl session which shows a more minimal case of failure."><span class="u" id="1537723154.000100">2018:09:23 17:19:14           suskeyhose </span><pre>user&gt; (select-first [{:blah :blah}] {{:blah :blah} :blah})
nil
user&gt; (transform [{:blah :blah}] #(do (println %) :blah2) {{:blah :blah} :blah})
{{:blah :blah} :blah}
</pre><span>
Here&apos;s some more stuff from my repl session which shows a more minimal case of failure.</span></div><div data-t="schmee AFAIK using maps as paths doesn’t do anything"><span class="u" id="1537723395.000100">2018:09:23 17:23:15               schmee </span><span>AFAIK using maps as paths doesn’t do anything</span></div><div data-t="suskeyhose Yeah, that&apos;s the problem. I have need of using a map as a key, and if specter can&apos;t select or transform paths with maps, then I&apos;m kind of screwed."><span class="u" id="1537723496.000100">2018:09:23 17:24:56           suskeyhose </span><span>Yeah, that&apos;s the problem. I have need of using a map as a key, and if specter can&apos;t select or transform paths with maps, then I&apos;m kind of screwed.</span></div><div data-t="suskeyhose And just have to go back to traditional data manipulation"><span class="u" id="1537723504.000100">2018:09:23 17:25:04           suskeyhose </span><span>And just have to go back to traditional data manipulation</span></div><div data-t="jsa-aerial Well, you could try sp/map-key which maybe will work - but you are still not screwed. But you will need to create a custom navigator :  https://github.com/nathanmarz/specter/wiki/Cheat-Sheet#custom-navigators"><span class="u" id="1537724035.000100">2018:09:23 17:33:55           jsa-aerial </span><span>Well, you could try sp/map-key which maybe will work - but you are still not screwed. But you will need to create a custom navigator : </span><a href="https://github.com/nathanmarz/specter/wiki/Cheat-Sheet#custom-navigators">https://github.com/nathanmarz/specter/wiki/Cheat-Sheet#custom-navigators</a></div><div data-t="jsa-aerial @suskeyhose ^^^"><span class="u" id="1537724047.000100">2018:09:23 17:34:07           jsa-aerial </span><span>@suskeyhose ^^^</span></div><div data-t="suskeyhose Okay, thanks. I&apos;ll take a look at it"><span class="u" id="1537724089.000100">2018:09:23 17:34:49           suskeyhose </span><span>Okay, thanks. I&apos;ll take a look at it</span></div><div data-t="nathanmarz @suskeyhose if you want to use a map as a key wrap it in  keypath"><span class="u" id="1537725595.000100">2018:09:23 17:59:55           nathanmarz </span><span>@suskeyhose if you want to use a map as a key wrap it in </span><code>keypath</code></div><div data-t="suskeyhose oh, thanks!"><span class="u" id="1537725603.000100">2018:09:23 18:00:03           suskeyhose </span><span>oh, thanks!</span></div><div data-t="nathanmarz keypath  is the navigator that&apos;s implicitly used by keywords in paths"><span class="u" id="1537725630.000100">2018:09:23 18:00:30           nathanmarz </span><code>keypath</code><span> is the navigator that&apos;s implicitly used by keywords in paths</span></div><div data-t="suskeyhose Ah, okay. Well that&apos;s exactly the behavior that I&apos;d wanted, so that&apos;s exactly it. Thanks so much!"><span class="u" id="1537725665.000100">2018:09:23 18:01:05           suskeyhose </span><span>Ah, okay. Well that&apos;s exactly the behavior that I&apos;d wanted, so that&apos;s exactly it. Thanks so much!</span></div><div data-t="schmee out of curiosity, is it possible to provide custom implicit navigators?"><span class="u" id="1537726498.000100">2018:09:23 18:14:58               schmee </span><span>out of curiosity, is it possible to provide custom implicit navigators?</span></div><div data-t="nathanmarz @schmee yes, through the  ImplicitNav  protocol"><span class="u" id="1537727891.000100">2018:09:23 18:38:11           nathanmarz </span><span>@schmee yes, through the </span><code>ImplicitNav</code><span> protocol</span></div><div data-t="nathanmarz see  https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1188"><span class="u" id="1537727919.000100">2018:09:23 18:38:39           nathanmarz </span><span>see </span><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1188">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1188</a></div><div data-t="Logan Powell 👋  new guy here. I hope my question is simple: I&apos;m looking for a way to map a function to a specific set of indices within a collection. For example:
 (transform [ALL MAP-VALS [1 3 5]] inc [0 1 2 3 4 5 6])
;; wishful thinking =&gt; [0 2 2 4 4 6 6]
 
is such a thing straight-forward in  specter ?"><span class="u" id="1537976325.000100">2018:09:26 15:38:45         Logan Powell </span><b>👋</b><span> new guy here. I hope my question is simple: I&apos;m looking for a way to map a function to a specific set of indices within a collection. For example:
</span><pre>(transform [ALL MAP-VALS [1 3 5]] inc [0 1 2 3 4 5 6])
;; wishful thinking =&gt; [0 2 2 4 4 6 6]
</pre><span>
is such a thing straight-forward in </span><code>specter</code><span>?</span></div><div data-t="drowsy @loganpowell something like  (transform [INDEXED-VALS (selected? FIRST #{1 3 5}) LAST] inc [0 1 2 3 4 5 6])  works. Not sure if it&apos;s the best solution though."><span class="u" id="1537980627.000100">2018:09:26 16:50:27               drowsy </span><span>@loganpowell something like </span><code>(transform [INDEXED-VALS (selected? FIRST #{1 3 5}) LAST] inc [0 1 2 3 4 5 6])</code><span> works. Not sure if it&apos;s the best solution though.</span></div><div data-t="Logan Powell @drowsy Thank you thank you"><span class="u" id="1537981601.000100">2018:09:26 17:06:41         Logan Powell </span><span>@drowsy Thank you thank you</span></div><div data-t="Logan Powell works like a charm!"><span class="u" id="1537982764.000100">2018:09:26 17:26:04         Logan Powell </span><span>works like a charm!</span></div><div data-t="schmee @loganpowell shorter and faster version:
 user=&gt; (transform (multi-path 1 3 5) inc [0 1 2 3 4 5 6])
[0 2 2 4 4 6 6]
"><span class="u" id="1537983558.000100">2018:09:26 17:39:18               schmee </span><span>@loganpowell shorter and faster version:
</span><pre>user=&gt; (transform (multi-path 1 3 5) inc [0 1 2 3 4 5 6])
[0 2 2 4 4 6 6]
</pre></div><div data-t="Logan Powell @schmee Boom! Thank you!"><span class="u" id="1537983588.000100">2018:09:26 17:39:48         Logan Powell </span><span>@schmee Boom! Thank you!</span></div><div data-t="idiomancy is there a version of nil-&gt;val that also responds to  :com.rpl.specter.impl/NONE ?  The navigator I&apos;m building is &quot;if element 1is a hash-map, select that.  if not, insert a hash-map between element 0 and element 1 and select that&quot;"><span class="u" id="1538015210.000100">2018:09:27 02:26:50            idiomancy </span><span>is there a version of nil-&gt;val that also responds to </span><code>:com.rpl.specter.impl/NONE</code><span>?  The navigator I&apos;m building is &quot;if element 1is a hash-map, select that.  if not, insert a hash-map between element 0 and element 1 and select that&quot;</span></div><div data-t="nathanmarz @idiomancy that path can be expressed like:
 (transform 
  (if-path [1 map?]
    1
    [(before-index 1) (view (constantly {}))]
    )
  transform-fn
  data)
"><span class="u" id="1538045947.000100">2018:09:27 10:59:07           nathanmarz </span><span>@idiomancy that path can be expressed like:
</span><pre>(transform 
  (if-path [1 map?]
    1
    [(before-index 1) (view (constantly {}))]
    )
  transform-fn
  data)
</pre></div><div data-t="idiomancy holy crap that works."><span class="u" id="1538046924.000100">2018:09:27 11:15:24            idiomancy </span><span>holy crap that works.</span></div><div data-t="idiomancy man, thats crazy,  was landing on like 30 variations of that that didn&apos;t work"><span class="u" id="1538046947.000100">2018:09:27 11:15:47            idiomancy </span><span>man, thats crazy,  was landing on like 30 variations of that that didn&apos;t work</span></div><div data-t="schmee I have two selects that only differ in the argument to  must :  (select [ALL ALL (selected? (must x))] board) , where  x  is  :color  and  :robot"><span class="u" id="1538431424.000100">2018:10:01 22:03:44               schmee </span><span>I have two selects that only differ in the argument to </span><code>must</code><span>: </span><code>(select [ALL ALL (selected? (must x))] board)</code><span>, where </span><code>x</code><span> is </span><code>:color</code><span> and </span><code>:robot</code></div><div data-t="schmee any way to combine the two into one or should I just do them separately?"><span class="u" id="1538431477.000100">2018:10:01 22:04:37               schmee </span><span>any way to combine the two into one or should I just do them separately?</span></div><div data-t="tanzoniteblack if you want to do 1 call that returns both, you could probably do  (selected? (multi-path (must :color) (must :robot))) ?"><span class="u" id="1538432113.000100">2018:10:01 22:15:13       tanzoniteblack </span><span>if you want to do 1 call that returns both, you could probably do </span><code>(selected? (multi-path (must :color) (must :robot)))</code><span>?</span></div><div data-t="tanzoniteblack probably could also do  (must (multi-path :color :robot)) ?"><span class="u" id="1538432235.000100">2018:10:01 22:17:15       tanzoniteblack </span><span>probably could also do </span><code>(must (multi-path :color :robot))</code><span>?</span></div><div data-t="schmee oh sorry, I forgot to mention that I would like to get the results in two different arrays, sort of like this:
 user=&gt; (select [(multi-path (filterer odd?) (filterer even?))] (range 10))
[[1 3 5 7 9] [0 2 4 6 8]]
"><span class="u" id="1538432400.000100">2018:10:01 22:20:00               schmee </span><span>oh sorry, I forgot to mention that I would like to get the results in two different arrays, sort of like this:
</span><pre>user=&gt; (select [(multi-path (filterer odd?) (filterer even?))] (range 10))
[[1 3 5 7 9] [0 2 4 6 8]]
</pre></div><div data-t="schmee I have a vague recollection that I’ve asked this question before, and that the answer was no  😄"><span class="u" id="1538432549.000100">2018:10:01 22:22:29               schmee </span><span>I have a vague recollection that I’ve asked this question before, and that the answer was no </span><b>😄</b></div><div data-t="nathanmarz @schmee yea, there&apos;s no way to do that"><span class="u" id="1538433415.000100">2018:10:01 22:36:55           nathanmarz </span><span>@schmee yea, there&apos;s no way to do that</span></div><div data-t="nathanmarz besides doing  (multi-path (subselect ...) (subselect ...)) , but that&apos;s no more efficient than just doing two  select &apos;s"><span class="u" id="1538433456.000100">2018:10:01 22:37:36           nathanmarz </span><span>besides doing </span><code>(multi-path (subselect ...) (subselect ...))</code><span>, but that&apos;s no more efficient than just doing two </span><code>select</code><span>&apos;s</span></div><div data-t="idiomancy hmm. can anyone think of a way to say &quot;every element after the first element&quot; without knowing the length of the sequence in advance?  like a  rest  or  drop 1  navigator?"><span class="u" id="1538433983.000200">2018:10:01 22:46:23            idiomancy </span><span>hmm. can anyone think of a way to say &quot;every element after the first element&quot; without knowing the length of the sequence in advance?  like a </span><code>rest</code><span> or </span><code>drop 1</code><span> navigator?</span></div><div data-t="idiomancy hmm, maybe something with  not-selected"><span class="u" id="1538434128.000100">2018:10:01 22:48:48            idiomancy </span><span>hmm, maybe something with </span><code>not-selected</code></div><div data-t="nathanmarz @idiomancy you can do that with  srange-dynamic  or  INDEXED-VALS"><span class="u" id="1538434632.000100">2018:10:01 22:57:12           nathanmarz </span><span>@idiomancy you can do that with </span><code>srange-dynamic</code><span> or </span><code>INDEXED-VALS</code></div><div data-t="idiomancy gotcha, yeah that makes sense"><span class="u" id="1538434657.000100">2018:10:01 22:57:37            idiomancy </span><span>gotcha, yeah that makes sense</span></div><div data-t="idiomancy so something like  (def REST [(spr/srange-dynamic #(do 1) #(count %)) spr/ALL])"><span class="u" id="1538434782.000100">2018:10:01 22:59:42            idiomancy </span><span>so something like </span><code>(def REST [(spr/srange-dynamic #(do 1) #(count %)) spr/ALL])</code></div><div data-t="nathanmarz @idiomancy yes"><span class="u" id="1538436473.000100">2018:10:01 23:27:53           nathanmarz </span><span>@idiomancy yes</span></div><div data-t="nathanmarz actually  (def REST (path (srange-dynamic #(do 1) count) ALL))  is better"><span class="u" id="1538436517.000100">2018:10:01 23:28:37           nathanmarz </span><span>actually </span><code>(def REST (path (srange-dynamic #(do 1) count) ALL))</code><span> is better</span></div><div data-t="nathanmarz more efficient to use when constructing paths dynamically"><span class="u" id="1538436556.000200">2018:10:01 23:29:16           nathanmarz </span><span>more efficient to use when constructing paths dynamically</span></div><div data-t="idiomancy huh, interesting!  Thanks for the tip!  So, what do you mean by &quot;dynamically&quot; here?  Is there some way to construct them at compile time instead?"><span class="u" id="1538436605.000100">2018:10:01 23:30:05            idiomancy </span><span>huh, interesting!  Thanks for the tip!  So, what do you mean by &quot;dynamically&quot; here?  Is there some way to construct them at compile time instead?</span></div><div data-t="idiomancy nvm, referring to the documentation now"><span class="u" id="1538436729.000100">2018:10:01 23:32:09            idiomancy </span><span>nvm, referring to the documentation now</span></div><div data-t="idiomancy again, thanks!"><span class="u" id="1538436737.000100">2018:10:01 23:32:17            idiomancy </span><span>again, thanks!</span></div><div data-t="kingcode I am trying to set values at different indexes within a flat vector in once call, e.g. [0 0 0 0] =&gt; [0 1 0 3]. I tried
 (setval [(nthpath 1)(nthpath 3)] [1 3] [0 0 0 0]) 
but got a runtime exc….What should I use instead?
Thanks in advance.."><span class="u" id="1538823480.000100">2018:10:06 10:58:00             kingcode </span><span>I am trying to set values at different indexes within a flat vector in once call, e.g. [0 0 0 0] =&gt; [0 1 0 3]. I tried
</span><code>(setval [(nthpath 1)(nthpath 3)] [1 3] [0 0 0 0])</code><span>
but got a runtime exc….What should I use instead?
Thanks in advance..</span></div><div data-t="nathanmarz @kingcode there&apos;s two approaches:
 (setval (subselect (multi-path 1 3)) [1 3] [0 0 0 0])
 
or
 (multi-transform
  (multi-path
    [1 (terminal-val 1)]
    [3 (terminal-val 3)])
  [0 0 0 0])
"><span class="u" id="1538829743.000100">2018:10:06 12:42:23           nathanmarz </span><span>@kingcode there&apos;s two approaches:
</span><pre>(setval (subselect (multi-path 1 3)) [1 3] [0 0 0 0])
</pre><span>
or
</span><pre>(multi-transform
  (multi-path
    [1 (terminal-val 1)]
    [3 (terminal-val 3)])
  [0 0 0 0])
</pre></div><div data-t="nathanmarz @kingcode there&apos;s two approaches:
 (setval (subselect (multi-path 1 3)) [1 3] [0 0 0 0])
 
or
 (multi-transform
  (multi-path
    [1 (terminal-val 1)]
    [3 (terminal-val 3)])
  [0 0 0 0])
"><span class="u" id="1538829743.000100">2018:10:06 12:42:23           nathanmarz </span><span>@kingcode there&apos;s two approaches:
</span><pre>(setval (subselect (multi-path 1 3)) [1 3] [0 0 0 0])
</pre><span>
or
</span><pre>(multi-transform
  (multi-path
    [1 (terminal-val 1)]
    [3 (terminal-val 3)])
  [0 0 0 0])
</pre></div><div data-t="manas_marthi Hi Nathan, if I have a vector of vectors with index &amp; new-values,or a vector of maps with index &amp; new-value pairs, then how do I rewrite the above. please advise.. thank you"><span class="u" id="1539014607.000100">2018:10:08 16:03:27              manas_marthi </span><span>Hi Nathan, if I have a vector of vectors with index &amp; new-values,or a vector of maps with index &amp; new-value pairs, then how do I rewrite the above. please advise.. thank you</span></div><div data-t="nathanmarz do you have an example input/output of what you&apos;re trying to do?"><span class="u" id="1539025991.000100">2018:10:08 19:13:11                nathanmarz </span><span>do you have an example input/output of what you&apos;re trying to do?</span></div><div data-t="manas_marthi I am thinking of this data
 input vec: [:a  :b  :c ... :m ... :z]

A map of indices and new values
{
 2 :c2
 12 :m2
 25 :z2
}
Or a map of old value new value pairs
{
 :c :c2
 :m :m2
 :z :z2
}

output vec: [:a  :b  :c2 ... :m2 ... :z2] "><span class="u" id="1539089080.000100">2018:10:09 12:44:40              manas_marthi </span><span>I am thinking of this data
</span><pre>input vec: [:a  :b  :c ... :m ... :z]

A map of indices and new values
{
 2 :c2
 12 :m2
 25 :z2
}
Or a map of old value new value pairs
{
 :c :c2
 :m :m2
 :z :z2
}

output vec: [:a  :b  :c2 ... :m2 ... :z2] </pre></div><div data-t="manas_marthi Essentially how to deal with the scenario when I have a lot of values to be replaced and not just a handful of indices that can be hardcoded in the multipath selector expression.."><span class="u" id="1539090336.000100">2018:10:09 13:05:36              manas_marthi </span><span>Essentially how to deal with the scenario when I have a lot of values to be replaced and not just a handful of indices that can be hardcoded in the multipath selector expression..</span></div><div data-t="nathanmarz for the latter you can do  (transform [ALL #(contains? replacements %)] replacements data)"><span class="u" id="1539101201.000100">2018:10:09 16:06:41                nathanmarz </span><span>for the latter you can do </span><code>(transform [ALL #(contains? replacements %)] replacements data)</code></div><div data-t="nathanmarz for the first I would just do that with a  reduce"><span class="u" id="1539101223.000100">2018:10:09 16:07:03                nathanmarz </span><span>for the first I would just do that with a </span><code>reduce</code></div><div data-t="manas_marthi Noted thank you"><span class="u" id="1539167572.000100">2018:10:10 10:32:52              manas_marthi </span><span>Noted thank you</span></div><div data-t="nathanmarz the second is more efficient"><span class="u" id="1538829762.000100">2018:10:06 12:42:42           nathanmarz </span><span>the second is more efficient</span></div><div data-t="kingcode Thank you @nathanmarz!"><span class="u" id="1538829768.000100">2018:10:06 12:42:48             kingcode </span><span>Thank you @nathanmarz!</span></div><div data-t="kingcode Looking forward to learn and use more of this great library:)"><span class="u" id="1538829799.000100">2018:10:06 12:43:19             kingcode </span><span>Looking forward to learn and use more of this great library:)</span></div><div data-t="darwin Hi, I&apos;m probably being bitten by  https://github.com/nathanmarz/specter/commit/e7abb2b5384b0b64d871fb347be7c34a15473eb2 
any ideas how to rewrite this to work around the issue?
 https://github.com/binaryage/dirac/blob/master/src/implant/dirac/implant/automation/reps.cljs#L46-L51"><span class="u" id="1539007626.000100">2018:10:08 14:07:06               darwin </span><span>Hi, I&apos;m probably being bitten by </span><a href="https://github.com/nathanmarz/specter/commit/e7abb2b5384b0b64d871fb347be7c34a15473eb2">https://github.com/nathanmarz/specter/commit/e7abb2b5384b0b64d871fb347be7c34a15473eb2</a><span>
any ideas how to rewrite this to work around the issue?
</span><a href="https://github.com/binaryage/dirac/blob/master/src/implant/dirac/implant/automation/reps.cljs#L46-L51">https://github.com/binaryage/dirac/blob/master/src/implant/dirac/implant/automation/reps.cljs#L46-L51</a></div><div data-t="darwin confirmed, running with specter from master resolved the issue"><span class="u" id="1539008029.000100">2018:10:08 14:13:49               darwin </span><span>confirmed, running with specter from master resolved the issue</span></div><div data-t="Logan Powell How might I pull the key/value pairs out of a map like this?"><span class="u" id="1539616221.000100">2018:10:15 15:10:21         Logan Powell </span><span>How might I pull the key/value pairs out of a map like this?</span></div><div data-t="Logan Powell Is there some sort of &quot;lift&quot; functionality?"><span class="u" id="1539617227.000100">2018:10:15 15:27:07         Logan Powell </span><span>Is there some sort of &quot;lift&quot; functionality?</span></div><div data-t="Logan Powell Figured it out!"><span class="u" id="1539617439.000100">2018:10:15 15:30:39         Logan Powell </span><span>Figured it out!</span></div><div data-t="nathanmarz @loganpowell this is a more efficient and more concise way to express that subexpression:  (into {} (traverse [:g MAP-VALS] mix-me-in))"><span class="u" id="1539617702.000100">2018:10:15 15:35:02           nathanmarz </span><span>@loganpowell this is a more efficient and more concise way to express that subexpression: </span><code>(into {} (traverse [:g MAP-VALS] mix-me-in))</code></div><div data-t="Logan Powell Thank you @nathanmarz  🙏  and thank you for Specter!  😍"><span class="u" id="1539617780.000100">2018:10:15 15:36:20         Logan Powell </span><span>Thank you @nathanmarz </span><b>🙏</b><span> and thank you for Specter! </span><b>😍</b></div><div data-t="Logan Powell 👋  I&apos;m assuming this isn&apos;t the most elegant solution, but I&apos;m trying to compose multiple  specter  functions together..."><span class="u" id="1539804686.000100">2018:10:17 19:31:26         Logan Powell </span><b>👋</b><span> I&apos;m assuming this isn&apos;t the most elegant solution, but I&apos;m trying to compose multiple </span><code>specter</code><span> functions together...</span></div><div data-t="Logan Powell The reason for all the map manipulation is due to how  go  contexts rearrange  PersistentArrayMap"><span class="u" id="1539804733.000100">2018:10:17 19:32:13         Logan Powell </span><span>The reason for all the map manipulation is due to how </span><code>go</code><span> contexts rearrange </span><code>PersistentArrayMap</code></div><div data-t="Logan Powell btw, this works, but I was wondering if I&apos;m &quot;doing it wrong&quot;"><span class="u" id="1539804772.000100">2018:10:17 19:32:52         Logan Powell </span><span>btw, this works, but I was wondering if I&apos;m &quot;doing it wrong&quot;</span></div><div data-t="nathanmarz @loganpowell would be more elegant with  multi-transform"><span class="u" id="1539814383.000100">2018:10:17 22:13:03           nathanmarz </span><span>@loganpowell would be more elegant with </span><code>multi-transform</code></div><div data-t="nathanmarz though I don&apos;t understand the point of the  #(into {} %)  part"><span class="u" id="1539814490.000100">2018:10:17 22:14:50           nathanmarz </span><span>though I don&apos;t understand the point of the </span><code>#(into {} %)</code><span> part</span></div><div data-t="nathanmarz why use linked maps in the first place if you&apos;re just going to convert to a regular map?"><span class="u" id="1539814506.000100">2018:10:17 22:15:06           nathanmarz </span><span>why use linked maps in the first place if you&apos;re just going to convert to a regular map?</span></div><div data-t="Logan Powell Thank you! I&apos;ll look into mult-transform. The map manipulation is a necessary evil in the black-magic of a go block"><span class="u" id="1539814831.000100">2018:10:17 22:20:31         Logan Powell </span><span>Thank you! I&apos;ll look into mult-transform. The map manipulation is a necessary evil in the black-magic of a go block</span></div><div data-t="roklenarcic here&apos;s a simple transformation: I want to delete all map entries where value is empty string"><span class="u" id="1540556209.000900">2018:10:26 12:16:49          roklenarcic </span><span>here&apos;s a simple transformation: I want to delete all map entries where value is empty string</span></div><div data-t="roklenarcic tried with compact and transform function that transforms &quot;&quot; values to nil"><span class="u" id="1540556233.001500">2018:10:26 12:17:13          roklenarcic </span><span>tried with compact and transform function that transforms &quot;&quot; values to nil</span></div><div data-t="roklenarcic but that doesn&apos;t remove the key"><span class="u" id="1540556239.001700">2018:10:26 12:17:19          roklenarcic </span><span>but that doesn&apos;t remove the key</span></div><div data-t="roklenarcic nvm figured it out:  (setval [MAP-VALS (pred= &quot;&quot;)] NONE {:a &quot;&quot; :b 5})"><span class="u" id="1540556427.002200">2018:10:26 12:20:27          roklenarcic </span><span>nvm figured it out: </span><code>(setval [MAP-VALS (pred= &quot;&quot;)] NONE {:a &quot;&quot; :b 5})</code></div><div data-t="fmn What is the efficient way to do reduction after some transformation?

Currently I&apos;m doing it like this:  (reduce merge {} (traverse (view to-map-fn) xs))"><span class="u" id="1540633712.003300">2018:10:27 09:48:32                  fmn </span><span>What is the efficient way to do reduction after some transformation?

Currently I&apos;m doing it like this: </span><code>(reduce merge {} (traverse (view to-map-fn) xs))</code></div><div data-t="nathanmarz @funyako.funyao156  traverse  is efficient way to do reduction of a selection of subvalues"><span class="u" id="1540646531.003900">2018:10:27 13:22:11           nathanmarz </span><span>@funyako.funyao156 </span><code>traverse</code><span> is efficient way to do reduction of a selection of subvalues</span></div><div data-t="nathanmarz that particular snippet doesn&apos;t really do anything, it&apos;s the same as  (merge {} (to-map-fn xs))"><span class="u" id="1540646567.004600">2018:10:27 13:22:47           nathanmarz </span><span>that particular snippet doesn&apos;t really do anything, it&apos;s the same as </span><code>(merge {} (to-map-fn xs))</code></div><div data-t="fmn @nathanmarz Thank you!"><span class="u" id="1540653737.006400">2018:10:27 15:22:17                  fmn </span><span>@nathanmarz Thank you!</span></div><div data-t="schmee is there a better way to construct this path? maybe something involving  recursive-path ?
 (defn tag-path [&amp; tag-names]
  (apply
    concat
    (interpose
      [ALL]
      (map
        #(vector (selected? :tag (pred= %)) :value)
        tag-names))))
"><span class="u" id="1540884496.007400">2018:10:30 07:28:16               schmee </span><span>is there a better way to construct this path? maybe something involving </span><code>recursive-path</code><span>?
</span><pre>(defn tag-path [&amp; tag-names]
  (apply
    concat
    (interpose
      [ALL]
      (map
        #(vector (selected? :tag (pred= %)) :value)
        tag-names))))
</pre></div><div data-t="schmee (tag-path &quot;EA&quot; &quot;C1&quot;) =&gt; [(selected? :tag (pred= &quot;EA&quot;)) :value ALL (selected? :tag (pred= &quot;C1&quot;)) :value]
"><span class="u" id="1540884611.008400">2018:10:30 07:30:11               schmee </span><pre>(tag-path &quot;EA&quot; &quot;C1&quot;) =&gt; [(selected? :tag (pred= &quot;EA&quot;)) :value ALL (selected? :tag (pred= &quot;C1&quot;)) :value]
</pre></div><div data-t="nathanmarz @schmee dynamic navs will dramatically increase performance when  tag-path  is called with dynamic params (eg. a local variable)"><span class="u" id="1540904148.009300">2018:10:30 12:55:48           nathanmarz </span><span>@schmee dynamic navs will dramatically increase performance when </span><code>tag-path</code><span> is called with dynamic params (eg. a local variable)</span></div><div data-t="nathanmarz (defdynamicnav tag-path [&amp; tag-names]
  (let [late-pred= (late-resolved-fn pred=)]
    (apply
      concat
      (interpose
        [ALL]
        (map
          #(vector (selected? :tag (late-pred= %)) :value)
          tag-names)
          ))))
"><span class="u" id="1540904152.009500">2018:10:30 12:55:52           nathanmarz </span><pre>(defdynamicnav tag-path [&amp; tag-names]
  (let [late-pred= (late-resolved-fn pred=)]
    (apply
      concat
      (interpose
        [ALL]
        (map
          #(vector (selected? :tag (late-pred= %)) :value)
          tag-names)
          ))))
</pre></div><div data-t="nathanmarz things like this are where you get huge speedup:
 (defn f [a data]
  (select (tag-path a &quot;b&quot;) data)
  )
"><span class="u" id="1540904211.009800">2018:10:30 12:56:51           nathanmarz </span><span>things like this are where you get huge speedup:
</span><pre>(defn f [a data]
  (select (tag-path a &quot;b&quot;) data)
  )
</pre></div><div data-t="schmee nice! I haven’t delved into dynamic navs yet, I’ll check them out!"><span class="u" id="1540904295.010300">2018:10:30 12:58:15               schmee </span><span>nice! I haven’t delved into dynamic navs yet, I’ll check them out!</span></div><div data-t="schmee but would you say that is an OK way to write the  tag-path  function?"><span class="u" id="1540904311.010900">2018:10:30 12:58:31               schmee </span><span>but would you say that is an OK way to write the </span><code>tag-path</code><span> function?</span></div><div data-t="schmee with all the interpose and apply and whatnot…"><span class="u" id="1540904332.011200">2018:10:30 12:58:52               schmee </span><span>with all the interpose and apply and whatnot…</span></div><div data-t="nathanmarz not very much documentation on them, just this  https://github.com/nathanmarz/specter/wiki/Specter%27s-inline-caching-implementation"><span class="u" id="1540904339.011300">2018:10:30 12:58:59           nathanmarz </span><span>not very much documentation on them, just this </span><a href="https://github.com/nathanmarz/specter/wiki/Specter%27s-inline-caching-implementation">https://github.com/nathanmarz/specter/wiki/Specter%27s-inline-caching-implementation</a></div><div data-t="nathanmarz yes, it&apos;s fine"><span class="u" id="1540904350.011500">2018:10:30 12:59:10           nathanmarz </span><span>yes, it&apos;s fine</span></div><div data-t="nathanmarz all that logic only ever executes once per callsite"><span class="u" id="1540904363.011900">2018:10:30 12:59:23           nathanmarz </span><span>all that logic only ever executes once per callsite</span></div><div data-t="nathanmarz because of dynamicnav"><span class="u" id="1540904366.012100">2018:10:30 12:59:26           nathanmarz </span><span>because of dynamicnav</span></div><div data-t="schmee excellent, thanks for the help as always"><span class="u" id="1540904387.012400">2018:10:30 12:59:47               schmee </span><span>excellent, thanks for the help as always</span></div><div data-t="nathanmarz you&apos;ve now delved into the most advanced part of specter ;)"><span class="u" id="1540904449.012800">2018:10:30 13:00:49           nathanmarz </span><span>you&apos;ve now delved into the most advanced part of specter ;)</span></div><div data-t="nathanmarz let me know if you have questions"><span class="u" id="1540904459.013100">2018:10:30 13:00:59           nathanmarz </span><span>let me know if you have questions</span></div><div data-t="schmee will do!"><span class="u" id="1540904478.013300">2018:10:30 13:01:18               schmee </span><span>will do!</span></div><div data-t="schmee is there any way to get access to collected values in  view ?"><span class="u" id="1540935474.013900">2018:10:30 21:37:54               schmee </span><span>is there any way to get access to collected values in </span><code>view</code><span>?</span></div><div data-t="nathanmarz @schmee no, but it&apos;s easy to make a custom navigator with that functionality"><span class="u" id="1540936939.014300">2018:10:30 22:02:19           nathanmarz </span><span>@schmee no, but it&apos;s easy to make a custom navigator with that functionality</span></div><div data-t="nathanmarz see  defrichnav"><span class="u" id="1540936943.014500">2018:10:30 22:02:23           nathanmarz </span><span>see </span><code>defrichnav</code></div><div data-t="schmee 👍"><span class="u" id="1540939009.014800">2018:10:30 22:36:49               schmee </span><b>👍</b></div><div data-t="npetryk Hey @nathanmarz, in a few of your blog posts you mention using specter for some pretty interesting graph stuff. I was interested in making specialized navigators for  https://jsonapi.org/  and thought some examples of defining navigators for &quot;specialized&quot; domains might be helpful. Do you have any more information / examples about your graph implementation?"><span class="u" id="1540995537.016500">2018:10:31 14:18:57              npetryk </span><span>Hey @nathanmarz, in a few of your blog posts you mention using specter for some pretty interesting graph stuff. I was interested in making specialized navigators for </span><a href="https://jsonapi.org/">https://jsonapi.org/</a><span> and thought some examples of defining navigators for &quot;specialized&quot; domains might be helpful. Do you have any more information / examples about your graph implementation?</span></div><div data-t="npetryk IDK if ur familiar with the spec but the most kludgey thing it requires me to do is to hold onto the top level document, or some kind of id -&gt; entity index, while I&apos;m navigating through the tree structure w/ specter"><span class="u" id="1540995613.017700">2018:10:31 14:20:13              npetryk </span><span>IDK if ur familiar with the spec but the most kludgey thing it requires me to do is to hold onto the top level document, or some kind of id -&gt; entity index, while I&apos;m navigating through the tree structure w/ specter</span></div><div data-t="npetryk I&apos;m handling that by attaching metadata onto the things I&apos;m navigating into, but like I said, its a little kludgy"><span class="u" id="1540995707.018700">2018:10:31 14:21:47              npetryk </span><span>I&apos;m handling that by attaching metadata onto the things I&apos;m navigating into, but like I said, its a little kludgy</span></div><div data-t="nathanmarz @npetryk my graph navigators are specifically for dag&apos;s"><span class="u" id="1540996495.019100">2018:10:31 14:34:55           nathanmarz </span><span>@npetryk my graph navigators are specifically for dag&apos;s</span></div><div data-t="nathanmarz TOPSORT  is like  ALL  but visits nodes in topological order"><span class="u" id="1540996511.019500">2018:10:31 14:35:11           nathanmarz </span><code>TOPSORT</code><span> is like </span><code>ALL</code><span> but visits nodes in topological order</span></div><div data-t="jsa-aerial Wow. This looks to be exactly what I will be needing in rewriting a DAG transformer! Specter is awesome!  💯"><span class="u" id="1541000519.025200">2018:10:31 15:41:59                jsa-aerial </span><span>Wow. This looks to be exactly what I will be needing in rewriting a DAG transformer! Specter is awesome! </span><b>💯</b></div><div data-t="nathanmarz REVERSE-TOPSORT  is the same but opposite order"><span class="u" id="1540996546.020000">2018:10:31 14:35:46           nathanmarz </span><code>REVERSE-TOPSORT</code><span> is the same but opposite order</span></div><div data-t="nathanmarz CHILDREN  goes from node to all children"><span class="u" id="1540996559.020300">2018:10:31 14:35:59           nathanmarz </span><code>CHILDREN</code><span> goes from node to all children</span></div><div data-t="nathanmarz likewise  PARENTS ,  DESCENDANTS"><span class="u" id="1540996567.020600">2018:10:31 14:36:07           nathanmarz </span><span>likewise </span><code>PARENTS</code><span>, </span><code>DESCENDANTS</code></div><div data-t="nathanmarz NODE  goes from a pointer to a node (which the aforementioned ones navigate you to) to the value for that node"><span class="u" id="1540996591.021000">2018:10:31 14:36:31           nathanmarz </span><code>NODE</code><span> goes from a pointer to a node (which the aforementioned ones navigate you to) to the value for that node</span></div><div data-t="nathanmarz node-nav  navigates to a specific node"><span class="u" id="1540996616.021300">2018:10:31 14:36:56           nathanmarz </span><code>node-nav</code><span> navigates to a specific node</span></div><div data-t="nathanmarz and then a couple navigators for navigating to sub-dag&apos;s, with metadata and ids on nodes used to determine how to attach the transformed sub-dag into the parent dag"><span class="u" id="1540996678.022100">2018:10:31 14:37:58           nathanmarz </span><span>and then a couple navigators for navigating to sub-dag&apos;s, with metadata and ids on nodes used to determine how to attach the transformed sub-dag into the parent dag</span></div><div data-t="nathanmarz there&apos;s a few more but those are the main ones"><span class="u" id="1540996729.022500">2018:10:31 14:38:49           nathanmarz </span><span>there&apos;s a few more but those are the main ones</span></div><div data-t="nathanmarz for navigating a tree you probably don&apos;t need custom navigator implementations, just a few composite navigators using  recursive-path"><span class="u" id="1540996830.023100">2018:10:31 14:40:30           nathanmarz </span><span>for navigating a tree you probably don&apos;t need custom navigator implementations, just a few composite navigators using </span><code>recursive-path</code></div><div data-t="nathanmarz if you have some examples I can walk you through it"><span class="u" id="1540996835.023300">2018:10:31 14:40:35           nathanmarz </span><span>if you have some examples I can walk you through it</span></div><div data-t="npetryk Thanks!  https://github.com/nathanmarz/specter/issues/241  also gave me some insight. It looks like that instead of passing  [graph node-id]  around I can just pass my tree &quot;context&quot; as metadata on individual nodes. The bit about reducing in the transform is also helpful for when I need to make updates to my tree"><span class="u" id="1540998612.025000">2018:10:31 15:10:12              npetryk </span><span>Thanks! </span><a href="https://github.com/nathanmarz/specter/issues/241">https://github.com/nathanmarz/specter/issues/241</a><span> also gave me some insight. It looks like that instead of passing </span><code>[graph node-id]</code><span> around I can just pass my tree &quot;context&quot; as metadata on individual nodes. The bit about reducing in the transform is also helpful for when I need to make updates to my tree</span></div><div data-t="miikka FYI, I&apos;m getting &quot;Maximum call stack exceeded&quot; from specter&apos;s Subvec coerce-path implementation"><span class="u" id="1541062823.025900">2018:11:01 09:00:23               miikka </span><span>FYI, I&apos;m getting &quot;Maximum call stack exceeded&quot; from specter&apos;s Subvec coerce-path implementation</span></div><div data-t="miikka Hmm, looking at the changelog, maybe I should try 1.1.2-SNAPSHOT"><span class="u" id="1541062862.026200">2018:11:01 09:01:02               miikka </span><span>Hmm, looking at the changelog, maybe I should try 1.1.2-SNAPSHOT</span></div><div data-t="miikka Yeah that helps."><span class="u" id="1541063125.026400">2018:11:01 09:05:25               miikka </span><span>Yeah that helps.</span></div><div data-t="miikka What&apos;s missing from the above is that the problem happened with latest ClojureScript master but not with the latest release (1.10.339)."><span class="u" id="1541063679.027900">2018:11:01 09:14:39               miikka </span><span>What&apos;s missing from the above is that the problem happened with latest ClojureScript master but not with the latest release (1.10.339).</span></div><div data-t="miikka @nathanmarz Could you do a release soon with the subvec fix? So that I can easily update to the next ClojureScript release once it&apos;s out?  😎"><span class="u" id="1541063828.029800">2018:11:01 09:17:08               miikka </span><span>@nathanmarz Could you do a release soon with the subvec fix? So that I can easily update to the next ClojureScript release once it&apos;s out? </span><b>😎</b></div><div data-t="nathanmarz ok, released 1.1.2  https://clojars.org/com.rpl/specter"><span class="u" id="1541122915.030400">2018:11:02 01:41:55           nathanmarz </span><span>ok, released 1.1.2 </span><a href="https://clojars.org/com.rpl/specter">https://clojars.org/com.rpl/specter</a></div><div data-t="miikka thanks!"><span class="u" id="1541142812.031000">2018:11:02 07:13:32               miikka </span><span>thanks!</span></div><div data-t="pepe Hello. With latest shadow-cljs and clojurescript I am getting theese warnings:
 ------ WARNING #1 --------------------------------------------------------------
 File: com/rpl/specter.cljc:1275:19
--------------------------------------------------------------------------------
1272 |           ns (namespace structure)]
1273 |       (cond (keyword? structure) (keyword ns new-name)
1274 |             (symbol? structure) (symbol ns new-name)
1275 |             :else (i/throw-illegal &quot;NAME can only be used on symbols or keywords - &quot; structure)
-------------------------^------------------------------------------------------
 Use of undeclared Var com.rpl.specter/java
--------------------------------------------------------------------------------
1276 |             ))))
1277 | 
1278 | (defnav ^{:doc &quot;Navigates to the namespace portion of the keyword or symbol&quot;}
1279 |   NAMESPACE
--------------------------------------------------------------------------------

------ WARNING #2 --------------------------------------------------------------
 File: com/rpl/specter.cljc:1288:19
--------------------------------------------------------------------------------
1285 |           new-ns (next-fn (namespace structure))]
1286 |       (cond (keyword? structure) (keyword new-ns name)
1287 |             (symbol? structure) (symbol new-ns name)
1288 |             :else (i/throw-illegal &quot;NAMESPACE can only be used on symbols or keywords - &quot; structure)
-------------------------^------------------------------------------------------
 Use of undeclared Var com.rpl.specter/java
--------------------------------------------------------------------------------
1289 |             ))))
1290 | 
1291 | (defdynamicnav
1292 |   ^{:doc &quot;Adds the result of running select with the given path on the
--------------------------------------------------------------------------------
"><span class="u" id="1541577450.032800">2018:11:07 07:57:30                 pepe </span><span>Hello. With latest shadow-cljs and clojurescript I am getting theese warnings:
</span><pre>------ WARNING #1 --------------------------------------------------------------
 File: com/rpl/specter.cljc:1275:19
--------------------------------------------------------------------------------
1272 |           ns (namespace structure)]
1273 |       (cond (keyword? structure) (keyword ns new-name)
1274 |             (symbol? structure) (symbol ns new-name)
1275 |             :else (i/throw-illegal &quot;NAME can only be used on symbols or keywords - &quot; structure)
-------------------------^------------------------------------------------------
 Use of undeclared Var com.rpl.specter/java
--------------------------------------------------------------------------------
1276 |             ))))
1277 | 
1278 | (defnav ^{:doc &quot;Navigates to the namespace portion of the keyword or symbol&quot;}
1279 |   NAMESPACE
--------------------------------------------------------------------------------

------ WARNING #2 --------------------------------------------------------------
 File: com/rpl/specter.cljc:1288:19
--------------------------------------------------------------------------------
1285 |           new-ns (next-fn (namespace structure))]
1286 |       (cond (keyword? structure) (keyword new-ns name)
1287 |             (symbol? structure) (symbol new-ns name)
1288 |             :else (i/throw-illegal &quot;NAMESPACE can only be used on symbols or keywords - &quot; structure)
-------------------------^------------------------------------------------------
 Use of undeclared Var com.rpl.specter/java
--------------------------------------------------------------------------------
1289 |             ))))
1290 | 
1291 | (defdynamicnav
1292 |   ^{:doc &quot;Adds the result of running select with the given path on the
--------------------------------------------------------------------------------
</pre></div><div data-t="pepe I had some warnings about  js  in my project, so I think it is connected to the new type interence in latest clojurescript"><span class="u" id="1541577510.034000">2018:11:07 07:58:30                 pepe </span><span>I had some warnings about </span><code>js</code><span> in my project, so I think it is connected to the new type interence in latest clojurescript</span></div><div data-t="nathanmarz @pepe the cljs  throw-illegal  is:
 (defn throw-illegal [&amp; args]
     (throw (js/Error. (apply str args)))))
"><span class="u" id="1541597242.034400">2018:11:07 13:27:22           nathanmarz </span><span>@pepe the cljs </span><code>throw-illegal</code><span> is:
</span><pre>(defn throw-illegal [&amp; args]
     (throw (js/Error. (apply str args)))))
</pre></div><div data-t="nathanmarz there&apos;s no var named  java  in the specter source"><span class="u" id="1541597262.034800">2018:11:07 13:27:42           nathanmarz </span><span>there&apos;s no var named </span><code>java</code><span> in the specter source</span></div><div data-t="nathanmarz sounds like a cljs issue"><span class="u" id="1541597264.035000">2018:11:07 13:27:44           nathanmarz </span><span>sounds like a cljs issue</span></div><div data-t="pepe I was looking into the code also, and have not found anything. Thank you! I will try to investigate it."><span class="u" id="1541597750.036100">2018:11:07 13:35:50                 pepe </span><span>I was looking into the code also, and have not found anything. Thank you! I will try to investigate it.</span></div><div data-t="lxsli Hi, I have this:
 (transform [ALL] (fn [[k v]] [k (transform [ALL] (fn [[k1 v1]] [k1 (resolver-key k k1)]) v)]) rs)) 

With rs like:
 {:Entry {:foo _ :bar _} ...} 

I get my result:
 {:Entry {:foo :Entry-foo :bar :Entry-bar} ...}"><span class="u" id="1541689207.037800">2018:11:08 15:00:07                lxsli </span><span>Hi, I have this:
</span><pre>(transform [ALL] (fn [[k v]] [k (transform [ALL] (fn [[k1 v1]] [k1 (resolver-key k k1)]) v)]) rs))</pre><span>

With rs like:
</span><pre>{:Entry {:foo _ :bar _} ...}</pre><span>

I get my result:
</span><pre>{:Entry {:foo :Entry-foo :bar :Entry-bar} ...}</pre></div><div data-t="lxsli It feels like if there was a way to use MAP-VALS but collect the key as I did so, that would be easier?"><span class="u" id="1541689259.038800">2018:11:08 15:00:59                lxsli </span><span>It feels like if there was a way to use MAP-VALS but collect the key as I did so, that would be easier?</span></div><div data-t="nathanmarz @lxsi you want to use value collection for this:
 (def MAP-VALS-WITH-KEY (path ALL (collect-one FIRST) LAST))
(transform [MAP-VALS-WITH-KEY MAP-VALS-WITH-KEY] (fn [k1 k2 _] (resolver-key k1 k2)) data)
"><span class="u" id="1541689492.039300">2018:11:08 15:04:52           nathanmarz </span><span>@lxsi you want to use value collection for this:
</span><pre>(def MAP-VALS-WITH-KEY (path ALL (collect-one FIRST) LAST))
(transform [MAP-VALS-WITH-KEY MAP-VALS-WITH-KEY] (fn [k1 k2 _] (resolver-key k1 k2)) data)
</pre></div><div data-t="lxsli Sweet, thank you!"><span class="u" id="1541689522.039500">2018:11:08 15:05:22                lxsli </span><span>Sweet, thank you!</span></div><div data-t="wilkerlucio @nathanmarz we can check by the output that its using the clj version, so its a fact that the JS out is using the CLJ version, macros sometimes are confusing on CLJS side, IME what works best is separate clj and cljs macros in different namespaces (both been  .clj ) and conditionally import then, this usually works with the least surprises"><span class="u" id="1541770517.040900">2018:11:09 13:35:17          wilkerlucio </span><span>@nathanmarz we can check by the output that its using the clj version, so its a fact that the JS out is using the CLJ version, macros sometimes are confusing on CLJS side, IME what works best is separate clj and cljs macros in different namespaces (both been </span><code>.clj</code><span>) and conditionally import then, this usually works with the least surprises</span></div><div data-t="wilkerlucio example code in pathom doing this:  https://github.com/wilkerlucio/pathom/blob/master/src/com/wsscode/pathom/connect.cljc#L9-L12"><span class="u" id="1541770548.041200">2018:11:09 13:35:48          wilkerlucio </span><span>example code in pathom doing this: </span><a href="https://github.com/wilkerlucio/pathom/blob/master/src/com/wsscode/pathom/connect.cljc#L9-L12">https://github.com/wilkerlucio/pathom/blob/master/src/com/wsscode/pathom/connect.cljc#L9-L12</a></div><div data-t="Logan Powell 👋  Hi everyone, can anyone tell me how to  :require  individual navigators? (e.g.,  MAP-KEYS )"><span class="u" id="1541786583.042000">2018:11:09 18:03:03         Logan Powell </span><b>👋</b><span> Hi everyone, can anyone tell me how to </span><code>:require</code><span> individual navigators? (e.g., </span><code>MAP-KEYS</code><span>)</span></div><div data-t="Logan Powell in clojurescript"><span class="u" id="1541786594.042200">2018:11:09 18:03:14         Logan Powell </span><span>in clojurescript</span></div><div data-t="Logan Powell It seems to work using
 (:require [com.rpl.specter   :refer [MAP-VALS MAP-KEYS]  :refer-macros [select transform traverse setval]])
 
but Intellij no likey, no big deal as long as I&apos;m not &quot;doing it wrong&quot;  ™"><span class="u" id="1541787738.043300">2018:11:09 18:22:18         Logan Powell </span><span>It seems to work using
</span><pre>(:require [com.rpl.specter   :refer [MAP-VALS MAP-KEYS]  :refer-macros [select transform traverse setval]])
</pre><span>
but Intellij no likey, no big deal as long as I&apos;m not &quot;doing it wrong&quot; </span><b>™</b></div><div data-t="jsa-aerial Are you doing this in Clojure or ClojureScript? If the former the :refer-macros does not make sense. If the latter (cljs), then this looks correct. In Clojure you can just refer the macros in the :refer vector."><span class="u" id="1541788039.045300">2018:11:09 18:27:19           jsa-aerial </span><span>Are you doing this in Clojure or ClojureScript? If the former the :refer-macros does not make sense. If the latter (cljs), then this looks correct. In Clojure you can just refer the macros in the :refer vector.</span></div><div data-t="Logan Powell cljs, yes"><span class="u" id="1541788052.045600">2018:11:09 18:27:32         Logan Powell </span><span>cljs, yes</span></div><div data-t="jsa-aerial Not sure how intellij (Cursive??) works with CLJS..."><span class="u" id="1541788085.046200">2018:11:09 18:28:05           jsa-aerial </span><span>Not sure how intellij (Cursive??) works with CLJS...</span></div><div data-t="Logan Powell Cursive, yes"><span class="u" id="1541788093.046400">2018:11:09 18:28:13         Logan Powell </span><span>Cursive, yes</span></div><div data-t="jsa-aerial I don&apos;t use Cursive, but in emacs I do that sort of thing all the time with no problems"><span class="u" id="1541788116.047000">2018:11:09 18:28:36           jsa-aerial </span><span>I don&apos;t use Cursive, but in emacs I do that sort of thing all the time with no problems</span></div><div data-t="Logan Powell sweet"><span class="u" id="1541788124.047200">2018:11:09 18:28:44         Logan Powell </span><span>sweet</span></div><div data-t="Logan Powell in cljs?"><span class="u" id="1541788127.047400">2018:11:09 18:28:47         Logan Powell </span><span>in cljs?</span></div><div data-t="jsa-aerial Yes, in cljs"><span class="u" id="1541788132.047600">2018:11:09 18:28:52           jsa-aerial </span><span>Yes, in cljs</span></div><div data-t="Logan Powell thank you sir"><span class="u" id="1541788136.047800">2018:11:09 18:28:56         Logan Powell </span><span>thank you sir</span></div><div data-t="jsa-aerial So, it probably is some limitation / issue with Cursive and CLJS"><span class="u" id="1541788161.048300">2018:11:09 18:29:21           jsa-aerial </span><span>So, it probably is some limitation / issue with Cursive and CLJS</span></div><div data-t="Logan Powell yep, no worries, as long as I&apos;m not doing it incorrectly  😉"><span class="u" id="1541788180.048700">2018:11:09 18:29:40         Logan Powell </span><span>yep, no worries, as long as I&apos;m not doing it incorrectly </span><b>😉</b></div><div data-t="martinklepsch are there any known issues with specter and CLJS? Getting the following when running cljs.analyzer on the specter code:

 com/rpl/specter.cljc - root cause: clojure.lang.ExceptionInfo Unable to resolve var: coll? in this context at line 1449 specter/com/rpl/specter.cljc
"><span class="u" id="1542452845.050600">2018:11:17 11:07:25        martinklepsch </span><span>are there any known issues with specter and CLJS? Getting the following when running cljs.analyzer on the specter code:

</span><pre>com/rpl/specter.cljc - root cause: clojure.lang.ExceptionInfo Unable to resolve var: coll? in this context at line 1449 specter/com/rpl/specter.cljc
</pre></div><div data-t="nathanmarz @martinklepsch there&apos;s currently this issue but I think it&apos;s unrelated  https://github.com/nathanmarz/specter/issues/267"><span class="u" id="1542467458.051100">2018:11:17 15:10:58           nathanmarz </span><span>@martinklepsch there&apos;s currently this issue but I think it&apos;s unrelated </span><a href="https://github.com/nathanmarz/specter/issues/267">https://github.com/nathanmarz/specter/issues/267</a></div><div data-t="jsa-aerial @martinklepsch Is cljdoc on using cljs later than 1.10.238?  That is the version I am using and that code works just fine. I just checked and the current release is 1.10.439(!!) The one I&apos;m using is only a few months old. Seems to be changing at a crazy rate. Let me see what happens if I try the newest version."><span class="u" id="1542470749.054600">2018:11:17 16:05:49           jsa-aerial </span><span>@martinklepsch Is cljdoc on using cljs later than 1.10.238?  That is the version I am using and that code works just fine. I just checked and the current release is 1.10.439(!!) The one I&apos;m using is only a few months old. Seems to be changing at a crazy rate. Let me see what happens if I try the newest version.</span></div><div data-t="jsa-aerial @nathanmarz @martinklepsch OK, somewhere along the line in those 201 new releases something has changed and causes regressions. Using the latest cljs the code compiles ok (no errors / warning and signals successful completion) but fails immediately when trying to run it with this:"><span class="u" id="1542471717.057500">2018:11:17 16:21:57           jsa-aerial </span><span>@nathanmarz @martinklepsch OK, somewhere along the line in those 201 new releases something has changed and causes regressions. Using the latest cljs the code compiles ok (no errors / warning and signals successful completion) but fails immediately when trying to run it with this:</span></div><div data-t="jsa-aerial #object[RangeError RangeError: Maximum call stack size exceeded]
   cljs.core/build-subvec (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:5908:25)
   cljs$core$IWithMeta$_with_meta$arity$2 (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:5793:28)
   cljs.core/-with-meta (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:686:21)
   cljs.core/with-meta (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:2059:8)
   cljs.core/vec (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:5662:6)
   com$rpl$specter$impl$CoercePath$coerce_path$arity$1 (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:180:27)
   com.rpl.specter.impl/coerce-path (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:155:17)
   com$rpl$specter$impl$CoercePath$coerce_path$arity$1 (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:180:14)
   com$rpl$specter$impl$coerce_path (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:155:17)
aerial.hanami.core&gt; 
"><span class="u" id="1542471732.057800">2018:11:17 16:22:12           jsa-aerial </span><pre>#object[RangeError RangeError: Maximum call stack size exceeded]
   cljs.core/build-subvec (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:5908:25)
   cljs$core$IWithMeta$_with_meta$arity$2 (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:5793:28)
   cljs.core/-with-meta (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:686:21)
   cljs.core/with-meta (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:2059:8)
   cljs.core/vec (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:5662:6)
   com$rpl$specter$impl$CoercePath$coerce_path$arity$1 (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:180:27)
   com.rpl.specter.impl/coerce-path (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:155:17)
   com$rpl$specter$impl$CoercePath$coerce_path$arity$1 (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:180:14)
   com$rpl$specter$impl$coerce_path (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:155:17)
aerial.hanami.core&gt; 
</pre></div><div data-t="jsa-aerial I think I will try a mini binary search to try to pin point in which release cljs was broken (or less likely, &apos;fixed&apos; something that was broken but causes regressions)"><span class="u" id="1542471842.059000">2018:11:17 16:24:02           jsa-aerial </span><span>I think I will try a mini binary search to try to pin point in which release cljs was broken (or less likely, &apos;fixed&apos; something that was broken but causes regressions)</span></div><div data-t="jsa-aerial OK, didn&apos;t take long. Despite a couple hundred point increments, the releases go from 1.10.439 to 1.10.339 as a first jump. 1.10.339 works fine. So, 1.10.439 is what is broken. It has a very large number of differences across &apos;changes&apos;, &apos;enhancements&apos;, and &apos;fixes&apos;. So, it is not too surprising it went off the rails..."><span class="u" id="1542472497.061400">2018:11:17 16:34:57           jsa-aerial </span><span>OK, didn&apos;t take long. Despite a couple hundred point increments, the releases go from 1.10.439 to 1.10.339 as a first jump. 1.10.339 works fine. So, 1.10.439 is what is broken. It has a very large number of differences across &apos;changes&apos;, &apos;enhancements&apos;, and &apos;fixes&apos;. So, it is not too surprising it went off the rails...</span></div><div data-t="jsa-aerial Just to finish, the actual releases go 1.10.238 -&gt; 1.10.312 (a lot of &apos;fixes&apos;) -&gt; 1.10.329 (a few &apos;fixes&apos;) -&gt; 1.10.339 (just a transit-clj version bump) -&gt; 1.10.439"><span class="u" id="1542472915.062900">2018:11:17 16:41:55           jsa-aerial </span><span>Just to finish, the actual releases go 1.10.238 -&gt; 1.10.312 (a lot of &apos;fixes&apos;) -&gt; 1.10.329 (a few &apos;fixes&apos;) -&gt; 1.10.339 (just a transit-clj version bump) -&gt; 1.10.439</span></div><div data-t="jsa-aerial Likely &apos;goats&apos;/culprits:  CLJS-2805: Bump tools.reader to 1.3.0 ,  Align ClojureScript AST to tools.analyzer ,  CLJS-2442: set and vec performance enhancements .  Those last two definitely smell bad given where the problems here are manifesting..."><span class="u" id="1542473054.064600">2018:11:17 16:44:14           jsa-aerial </span><span>Likely &apos;goats&apos;/culprits: </span><code>CLJS-2805: Bump tools.reader to 1.3.0</code><span>, </span><code>Align ClojureScript AST to tools.analyzer</code><span>, </span><code>CLJS-2442: set and vec performance enhancements</code><span>.  Those last two definitely smell bad given where the problems here are manifesting...</span></div><div data-t="martinklepsch @jsa-aerial that&apos;s very interesting, thanks for digging in"><span class="u" id="1542473245.065100">2018:11:17 16:47:25        martinklepsch </span><span>@jsa-aerial that&apos;s very interesting, thanks for digging in</span></div><div data-t="martinklepsch I previously had another problem with the analyzer (turned out it was my fault) but I think if you could create a minimal repro how the analyzer fails with specter that would be very interesting to #cljs-dev"><span class="u" id="1542473435.066700">2018:11:17 16:50:35        martinklepsch </span><span>I previously had another problem with the analyzer (turned out it was my fault) but I think if you could create a minimal repro how the analyzer fails with specter that would be very interesting to #cljs-dev</span></div><div data-t="martinklepsch https://gist.github.com/martinklepsch/9f885feb061ec3f03f365e22d0d9bf5b#old-description-ignore-this"><span class="u" id="1542473445.066900">2018:11:17 16:50:45        martinklepsch </span><a href="https://gist.github.com/martinklepsch/9f885feb061ec3f03f365e22d0d9bf5b#old-description-ignore-this">https://gist.github.com/martinklepsch/9f885feb061ec3f03f365e22d0d9bf5b#old-description-ignore-this</a></div><div data-t="martinklepsch ☝️  you can take a look at this for how this could look"><span class="u" id="1542473465.067400">2018:11:17 16:51:05        martinklepsch </span><b>☝️</b><span> you can take a look at this for how this could look</span></div><div data-t="martinklepsch the analyze-file call would need to be pointed at  com/rpl/specter.cljc  and you&apos;d need to add specter to the  :deps  map."><span class="u" id="1542473527.068300">2018:11:17 16:52:07        martinklepsch </span><span>the analyze-file call would need to be pointed at </span><code>com/rpl/specter.cljc</code><span> and you&apos;d need to add specter to the </span><code>:deps</code><span> map.</span></div><div data-t="martinklepsch btw, I also get the  coll?  issue in 1.10.339"><span class="u" id="1542473853.068700">2018:11:17 16:57:33        martinklepsch </span><span>btw, I also get the </span><code>coll?</code><span> issue in 1.10.339</span></div><div data-t="jsa-aerial @martinklepsch just to be clear - I do not get any analyzer problem in my code with any of those releases. So, I can&apos;t make that repo. So, if it is still happening with 1.10.339 I would suggest going back further to try to isolate that. For me, the error happens at runtime and since it occurs in  vec , I would guess those &apos;enhancements&apos; to  set  and  vec  for performance are the problem."><span class="u" id="1542474226.072100">2018:11:17 17:03:46           jsa-aerial </span><span>@martinklepsch just to be clear - I do not get any analyzer problem in my code with any of those releases. So, I can&apos;t make that repo. So, if it is still happening with 1.10.339 I would suggest going back further to try to isolate that. For me, the error happens at runtime and since it occurs in </span><code>vec</code><span>, I would guess those &apos;enhancements&apos; to </span><code>set</code><span> and </span><code>vec</code><span> for performance are the problem.</span></div><div data-t="jsa-aerial @martinklepsch one other thing of note: I have another repo (Saite) which uses Hanami (the one causing cljdoc bogus analyzer error) which sails through cljdoc just fine. So, maybe there is something wrong in the way cljdoc sets up the analyzer for this?"><span class="u" id="1542474369.073800">2018:11:17 17:06:09           jsa-aerial </span><span>@martinklepsch one other thing of note: I have another repo (Saite) which uses Hanami (the one causing cljdoc bogus analyzer error) which sails through cljdoc just fine. So, maybe there is something wrong in the way cljdoc sets up the analyzer for this?</span></div><div data-t="jsa-aerial To be clear: Both of those use the specter lib in question, and both use it in exactly the same way."><span class="u" id="1542474439.074700">2018:11:17 17:07:19           jsa-aerial </span><span>To be clear: Both of those use the specter lib in question, and both use it in exactly the same way.</span></div><div data-t="martinklepsch Interesting, can you provide dependency coordinates for both of these projects so I can compare?  🙂"><span class="u" id="1542494582.075300">2018:11:17 22:43:02        martinklepsch </span><span>Interesting, can you provide dependency coordinates for both of these projects so I can compare? </span><b>🙂</b></div><div data-t="jsa-aerial Not sure what &apos;dependency coordinates&apos; means. Maybe the repo URLs?"><span class="u" id="1542566253.075500">2018:11:18 18:37:33                jsa-aerial </span><span>Not sure what &apos;dependency coordinates&apos; means. Maybe the repo URLs?</span></div><div data-t="jsa-aerial https://github.com/jsa-aerial/hanami"><span class="u" id="1542566285.075700">2018:11:18 18:38:05                jsa-aerial </span><a href="https://github.com/jsa-aerial/hanami">https://github.com/jsa-aerial/hanami</a></div><div data-t="jsa-aerial https://github.com/jsa-aerial/saite"><span class="u" id="1542566311.076000">2018:11:18 18:38:31                jsa-aerial </span><a href="https://github.com/jsa-aerial/saite">https://github.com/jsa-aerial/saite</a></div><div data-t="Marc O&apos;Morain 👋 

Hi there. I’m looking for a way to author a specter path that can select a string or vector of strings.

My data looks like this: (emails for the  postal  library).

 (def m1 {:to [&quot; 

I want to collect all email addresses in the message, using  specter/select"><span class="u" id="1543414897.079400">2018:11:28 14:21:37        Marc O'Morain </span><b>👋</b><span>

Hi there. I’m looking for a way to author a specter path that can select a string or vector of strings.

My data looks like this: (emails for the </span><code>postal</code><span> library).

</span><pre>(def m1 {:to [&quot;</pre><span>

I want to collect all email addresses in the message, using </span><code>specter/select</code></div><div data-t="Marc O&apos;Morain I ended up with:

 (defn- has-recipients?
  &quot;True if this email has any recipients&quot;
  [message]
  (s/selected-any? [(s/multi-path :to :cc :bcc)
                    (s/if-path sequential? s/ALL some?)]
                   message))
"><span class="u" id="1543415411.079900">2018:11:28 14:30:11        Marc O'Morain </span><span>I ended up with:

</span><pre>(defn- has-recipients?
  &quot;True if this email has any recipients&quot;
  [message]
  (s/selected-any? [(s/multi-path :to :cc :bcc)
                    (s/if-path sequential? s/ALL some?)]
                   message))
</pre></div><div data-t="nathanmarz @marc-omorain that&apos;s perfect"><span class="u" id="1543419881.080200">2018:11:28 15:44:41           nathanmarz </span><span>@marc-omorain that&apos;s perfect</span></div><div data-t="Marc O&apos;Morain Thanks!"><span class="u" id="1543419915.080400">2018:11:28 15:45:15        Marc O'Morain </span><span>Thanks!</span></div><div data-t="Timo Freiberg hey everyone, i&apos;m trying to use specter to build a tree-structure of nested maps and struggling with what kinds of values are allowed in the path in  setval"><span class="u" id="1544788328.003500">2018:12:14 11:52:08        Timo Freiberg </span><span>hey everyone, i&apos;m trying to use specter to build a tree-structure of nested maps and struggling with what kinds of values are allowed in the path in </span><code>setval</code></div><div data-t="Timo Freiberg my pre-specter implementation just uses  (update-in tree [:field1 field1-val ...] (fnil conj #{}) key-of-entity)"><span class="u" id="1544788419.005000">2018:12:14 11:53:39        Timo Freiberg </span><span>my pre-specter implementation just uses </span><code>(update-in tree [:field1 field1-val ...] (fnil conj #{}) key-of-entity)</code></div><div data-t="Timo Freiberg so in the end i get a big map like
 {:field1 {&quot;1&quot; {:field2 {nil {:field3 {&quot;B&quot; {..}}}}}
          &quot;2&quot; {:field2 {nil {:field3 {&quot;C&quot; {..}}}}}}}
"><span class="u" id="1544788549.006000">2018:12:14 11:55:49        Timo Freiberg </span><span>so in the end i get a big map like
</span><pre>{:field1 {&quot;1&quot; {:field2 {nil {:field3 {&quot;B&quot; {..}}}}}
          &quot;2&quot; {:field2 {nil {:field3 {&quot;C&quot; {..}}}}}}}
</pre></div><div data-t="Timo Freiberg my problem is that some values are  nil  and some values are hashmaps themselves. and specter doesn&apos;t seem to use  nil  and hashmaps in the path of  setval"><span class="u" id="1544788606.006900">2018:12:14 11:56:46        Timo Freiberg </span><span>my problem is that some values are </span><code>nil</code><span> and some values are hashmaps themselves. and specter doesn&apos;t seem to use </span><code>nil</code><span> and hashmaps in the path of </span><code>setval</code></div><div data-t="Timo Freiberg i already replaced  nil  with a  :empty , that solved that problem"><span class="u" id="1544788618.007300">2018:12:14 11:56:58        Timo Freiberg </span><span>i already replaced </span><code>nil</code><span> with a </span><code>:empty</code><span>, that solved that problem</span></div><div data-t="Timo Freiberg but i rely on the hashmap values for equality. my current plan for a workaround is represent that data as a sorted string and hope i can get a canonical representation working"><span class="u" id="1544788707.008800">2018:12:14 11:58:27        Timo Freiberg </span><span>but i rely on the hashmap values for equality. my current plan for a workaround is represent that data as a sorted string and hope i can get a canonical representation working</span></div><div data-t="Timo Freiberg maybe someone can help me with this problem or confirm that specter doesn&apos;t use  nil  or hashmaps/hashsets as map keys in  setval ?"><span class="u" id="1544788833.010000">2018:12:14 12:00:33        Timo Freiberg </span><span>maybe someone can help me with this problem or confirm that specter doesn&apos;t use </span><code>nil</code><span> or hashmaps/hashsets as map keys in </span><code>setval</code><span>?</span></div><div data-t="Timo Freiberg example:
 (S/setval [:field1 &quot;1&quot;
           :field2 :empty
           :field3 &quot;A&quot;
           :field4 (S/multi-path
                    :c
                    #{:a :b}
                    {:a #{:b :c}})]
          &quot;ID&quot;
          {})
;; =&gt; {:field1 {&quot;1&quot; {:field2 {:empty {:field3 {&quot;A&quot; {:field4 {:c &quot;ID&quot;}}}}}}}}
 

I&apos;d like for the paths  #{:a :b}  and  {:a #{:b :c}}  to also be created"><span class="u" id="1544789049.011100">2018:12:14 12:04:09        Timo Freiberg </span><span>example:
</span><pre>(S/setval [:field1 &quot;1&quot;
           :field2 :empty
           :field3 &quot;A&quot;
           :field4 (S/multi-path
                    :c
                    #{:a :b}
                    {:a #{:b :c}})]
          &quot;ID&quot;
          {})
;; =&gt; {:field1 {&quot;1&quot; {:field2 {:empty {:field3 {&quot;A&quot; {:field4 {:c &quot;ID&quot;}}}}}}}}
</pre><span>

I&apos;d like for the paths </span><code>#{:a :b}</code><span> and </span><code>{:a #{:b :c}}</code><span> to also be created</span></div><div data-t="nathanmarz @timo.freiberg if you want to use a map as a key, wrap it in the  keypath  navigator"><span class="u" id="1544801596.011700">2018:12:14 15:33:16           nathanmarz </span><span>@timo.freiberg if you want to use a map as a key, wrap it in the </span><code>keypath</code><span> navigator</span></div><div data-t="nathanmarz only basic types like keywords, strings, and numbers are automatically inferred use  keypath  navigation"><span class="u" id="1544801630.012400">2018:12:14 15:33:50           nathanmarz </span><span>only basic types like keywords, strings, and numbers are automatically inferred use </span><code>keypath</code><span> navigation</span></div><div data-t="nathanmarz see this for a complete listing of navigators available to you:  https://github.com/nathanmarz/specter/wiki/Cheat-Sheet"><span class="u" id="1544801641.012700">2018:12:14 15:34:01           nathanmarz </span><span>see this for a complete listing of navigators available to you: </span><a href="https://github.com/nathanmarz/specter/wiki/Cheat-Sheet">https://github.com/nathanmarz/specter/wiki/Cheat-Sheet</a></div><div data-t="Timo Freiberg awesome, that did it"><span class="u" id="1544803324.013000">2018:12:14 16:02:04        Timo Freiberg </span><span>awesome, that did it</span></div><div data-t="ro6 Today I found myself using  assoc-in  on the  ex-data  inside an exception while keeping the rest of the info the same, then re-forming and re-throwing. It definitely felt like a &quot;Specter-shaped&quot; problem. Is this the sort of thing Specter could do (or already does)? If so, what would be the approach to implementing a navigator for a closed data object like an  IExceptionInfo ?"><span class="u" id="1545057357.016100">2018:12:17 14:35:57                  ro6 </span><span>Today I found myself using </span><code>assoc-in</code><span> on the </span><code>ex-data</code><span> inside an exception while keeping the rest of the info the same, then re-forming and re-throwing. It definitely felt like a &quot;Specter-shaped&quot; problem. Is this the sort of thing Specter could do (or already does)? If so, what would be the approach to implementing a navigator for a closed data object like an </span><code>IExceptionInfo</code><span>?</span></div><div data-t="nathanmarz @robert.mather.rmm you can make customer navigators with  defnav"><span class="u" id="1545057493.016400">2018:12:17 14:38:13           nathanmarz </span><span>@robert.mather.rmm you can make customer navigators with </span><code>defnav</code></div><div data-t="nathanmarz though for that i think the best approach would be something like the new datafy stuff"><span class="u" id="1545057538.016800">2018:12:17 14:38:58           nathanmarz </span><span>though for that i think the best approach would be something like the new datafy stuff</span></div><div data-t="nathanmarz where you can turn the closed object into regular clojure data, navigate it normally, and then at the end convert it back"><span class="u" id="1545057569.017200">2018:12:17 14:39:29           nathanmarz </span><span>where you can turn the closed object into regular clojure data, navigate it normally, and then at the end convert it back</span></div><div data-t="nathanmarz so something like this would be ideal:  (transform [DATAFY :some-field ALL] inc some-obj) , where  DATAFY  would do the conversion both ways"><span class="u" id="1545057623.018200">2018:12:17 14:40:23           nathanmarz </span><span>so something like this would be ideal: </span><code>(transform [DATAFY :some-field ALL] inc some-obj)</code><span>, where </span><code>DATAFY</code><span> would do the conversion both ways</span></div><div data-t="puzzler Is there a protocol that &quot;goes the other way&quot; for datafy?  I agree that&apos;s a good idea, if so."><span class="u" id="1545290109.019000">2018:12:20 07:15:09              puzzler </span><span>Is there a protocol that &quot;goes the other way&quot; for datafy?  I agree that&apos;s a good idea, if so.</span></div><div data-t="nathanmarz @puzzler doesn&apos;t look like it, so it would have to be independently defined"><span class="u" id="1545310377.019900">2018:12:20 12:52:57           nathanmarz </span><span>@puzzler doesn&apos;t look like it, so it would have to be independently defined</span></div><div data-t="aaelony If anyone is looking for a nasty data structure to play with Specter, I think I’ve found one here: “ https://pricing.us-east-1.amazonaws.com/offers/v1.0/aws/AmazonEC2/current/index.json ”"><span class="u" id="1545340632.021200">2018:12:20 21:17:12              aaelony </span><span>If anyone is looking for a nasty data structure to play with Specter, I think I’ve found one here: “</span><a href="https://pricing.us-east-1.amazonaws.com/offers/v1.0/aws/AmazonEC2/current/index.json">https://pricing.us-east-1.amazonaws.com/offers/v1.0/aws/AmazonEC2/current/index.json</a><span>”</span></div><div data-t="idiomancy Alright so I have a hell of a difficult one and specter would be perfect for this... but it is a bear.

so AWS&apos;s nosql, DynamoDB, stores records in this wonky schema&apos;d format.

Heres an example.   The key indicates how the record should be transformed.  Essentially the leaf values are S and N, for strings and numbers respectively.
I want to traverse recursively and replace the {:type-key val} with just the val.  which involves crazy collection between recursed layers  😮"><span class="u" id="1545342230.023600">2018:12:20 21:43:50            idiomancy </span><span>Alright so I have a hell of a difficult one and specter would be perfect for this... but it is a bear.

so AWS&apos;s nosql, DynamoDB, stores records in this wonky schema&apos;d format.

Heres an example.   The key indicates how the record should be transformed.  Essentially the leaf values are S and N, for strings and numbers respectively.
I want to traverse recursively and replace the {:type-key val} with just the val.  which involves crazy collection between recursed layers </span><b>😮</b></div><div data-t="idiomancy"><span class="u" id="1545342246.023700">2018:12:20 21:44:06            idiomancy </span></div><div data-t="idiomancy is that even possible?"><span class="u" id="1545342400.024100">2018:12:20 21:46:40            idiomancy </span><span>is that even possible?</span></div><div data-t="idiomancy I ended up just doing it with regular recursion"><span class="u" id="1545344647.024400">2018:12:20 22:24:07            idiomancy </span><span>I ended up just doing it with regular recursion</span></div><div data-t="idiomancy it recursively called specter"><span class="u" id="1545344662.024700">2018:12:20 22:24:22            idiomancy </span><span>it recursively called specter</span></div><div data-t="nathanmarz @idiomancy you could use  walker"><span class="u" id="1545350437.025400">2018:12:21 00:00:37           nathanmarz </span><span>@idiomancy you could use </span><code>walker</code></div><div data-t="nathanmarz (defn target? [o] (and (map? o) (= 1 (count o)) (#{:S :N} (-&gt; o first first))))
(transform (walker target?) #(-&gt; % last last) data)
"><span class="u" id="1545350459.025800">2018:12:21 00:00:59           nathanmarz </span><pre>(defn target? [o] (and (map? o) (= 1 (count o)) (#{:S :N} (-&gt; o first first))))
(transform (walker target?) #(-&gt; % last last) data)
</pre></div><div data-t="idiomancy hahaha, you bloody wizard you!  let me try it out"><span class="u" id="1545350557.026800">2018:12:21 00:02:37            idiomancy </span><span>hahaha, you bloody wizard you!  let me try it out</span></div><div data-t="nathanmarz using  cond-path  you could do it more precisely"><span class="u" id="1545350723.027100">2018:12:21 00:05:23           nathanmarz </span><span>using </span><code>cond-path</code><span> you could do it more precisely</span></div><div data-t="nathanmarz definitely an annoying data format"><span class="u" id="1545350727.027300">2018:12:21 00:05:27           nathanmarz </span><span>definitely an annoying data format</span></div><div data-t="nlessa Hi, I found an old discussion about defining a nav like this. But it seems something wrong with the GROUP-BY definition."><span class="u" id="1545759070.012100">2018:12:25 17:31:10               nlessa </span><span>Hi, I found an old discussion about defining a nav like this. But it seems something wrong with the GROUP-BY definition.</span></div><div data-t="nlessa"><span class="u" id="1545759254.013300">2018:12:25 17:34:14               nlessa </span></div><div data-t="nathanmarz @nlessa it hasn&apos;t been possible to compile path without parameters since 0.13.0"><span class="u" id="1545761757.014100">2018:12:25 18:15:57           nathanmarz </span><span>@nlessa it hasn&apos;t been possible to compile path without parameters since 0.13.0</span></div><div data-t="nathanmarz now you would do  (defn group-by-nav [f] (path (group-by-view f) ALL LAST)))"><span class="u" id="1545761790.014700">2018:12:25 18:16:30           nathanmarz </span><span>now you would do </span><code>(defn group-by-nav [f] (path (group-by-view f) ALL LAST)))</code></div><div data-t="nlessa Hum, OK. thanks @nathanmarz!!"><span class="u" id="1545761847.015200">2018:12:25 18:17:27               nlessa </span><span>Hum, OK. thanks @nathanmarz!!</span></div><div data-t="johanatan hi, is it possible to  collect  two levels of map keys in the process of navigating to a third level in a nested map ?"><span class="u" id="1546291527.016300">2019:12:31 21:25:27            johanatan </span><span>hi, is it possible to </span><code>collect</code><span> two levels of map keys in the process of navigating to a third level in a nested map ?</span></div><div data-t="johanatan so, i have  {:a {:b {:c :d}}}  and i want to  map /`transform` over  {:c :d}  but while retaining the context  [:a :b] ."><span class="u" id="1546291569.017200">2019:12:31 21:26:09            johanatan </span><span>so, i have </span><code>{:a {:b {:c :d}}}</code><span> and i want to </span><code>map</code><span>/`transform` over </span><code>{:c :d}</code><span> but while retaining the context </span><code>[:a :b]</code><span>.</span></div><div data-t="johanatan (specter/collect specter/MAP-KEYS specter/MAP-KEYS)  gives the error &quot;Don&apos;t know how to create ISeq from clojure.lang.Keyword&quot;."><span class="u" id="1546291608.017900">2019:12:31 21:26:48            johanatan </span><code>(specter/collect specter/MAP-KEYS specter/MAP-KEYS)</code><span> gives the error &quot;Don&apos;t know how to create ISeq from clojure.lang.Keyword&quot;.</span></div><div data-t="johanatan thanks in advance!"><span class="u" id="1546291628.018100">2019:12:31 21:27:08            johanatan </span><span>thanks in advance!</span></div><div data-t="nathanmarz @johanatan just use multiple collect calls:
 (select [ALL (collect-one FIRST) LAST ALL (collect-one FIRST) LAST] {:a {:b {:c :d}}})
;; =&gt; [[:a :b {:c :d}]]
"><span class="u" id="1546378643.018900">2019:01:01 21:37:23           nathanmarz </span><span>@johanatan just use multiple collect calls:
</span><pre>(select [ALL (collect-one FIRST) LAST ALL (collect-one FIRST) LAST] {:a {:b {:c :d}}})
;; =&gt; [[:a :b {:c :d}]]
</pre></div><div data-t="johanatan Ah, I guess I’m confused why you can’t use MAP-KEYS?"><span class="u" id="1546378702.019500">2019:01:01 21:38:22            johanatan </span><span>Ah, I guess I’m confused why you can’t use MAP-KEYS?</span></div><div data-t="johanatan (For either the collection or the navigation)"><span class="u" id="1546378745.019900">2019:01:01 21:39:05            johanatan </span><span>(For either the collection or the navigation)</span></div><div data-t="nathanmarz MAP-KEYS  navigates you to each key of the map"><span class="u" id="1546380064.020500">2019:01:01 22:01:04           nathanmarz </span><code>MAP-KEYS</code><span> navigates you to each key of the map</span></div><div data-t="nathanmarz so navigating  MAP-KEYS  again will navigate you to the keys of the keys"><span class="u" id="1546380077.020900">2019:01:01 22:01:17           nathanmarz </span><span>so navigating </span><code>MAP-KEYS</code><span> again will navigate you to the keys of the keys</span></div><div data-t="nathanmarz since the first set of keys are keywords you get that error"><span class="u" id="1546380096.021400">2019:01:01 22:01:36           nathanmarz </span><span>since the first set of keys are keywords you get that error</span></div><div data-t="johanatan Oh, I meant MAP-VALS instead of ALL/LAST in your example "><span class="u" id="1546451253.022300">2019:01:02 17:47:33            johanatan </span><span>Oh, I meant MAP-VALS instead of ALL/LAST in your example </span></div><div data-t="nathanmarz @johanatan because it needs to collect the key"><span class="u" id="1546456711.022600">2019:01:02 19:18:31           nathanmarz </span><span>@johanatan because it needs to collect the key</span></div><div data-t="johanatan Ah, got it. Thx "><span class="u" id="1546456963.022900">2019:01:02 19:22:43            johanatan </span><span>Ah, got it. Thx </span></div><div data-t="zlrth i have some xml:
 &apos;({:tag :CategoryName_1, :attrs {}, :content (&quot;cats&quot;)}
  {:tag :CategoryId_1, :attrs {}, :content (&quot;cat260062&quot;)}
  {:tag :Items,
   :attrs {},
   :content
   ({:tag :ItemId, :attrs {}, :content (&quot;1000388464506500&quot;)}
    {:tag :ItemId, :attrs {}, :content (&quot;1000388464506405&quot;)})})
 
that i&apos;d like to turn into into this map:
 {:CategoryName_1 &quot;cats&quot;, :CategoryId_1 &quot;cat260062&quot;, :Items [&quot;1000388464506500&quot; &quot;1000388464506405&quot;]}
 
that is, for recursive  :content s, i&apos;d like them collected into a vector, and for non-recursive, their tags and contents are key value pairs"><span class="u" id="1546804993.025800">2019:01:06 20:03:13                zlrth </span><span>i have some xml:
</span><pre>&apos;({:tag :CategoryName_1, :attrs {}, :content (&quot;cats&quot;)}
  {:tag :CategoryId_1, :attrs {}, :content (&quot;cat260062&quot;)}
  {:tag :Items,
   :attrs {},
   :content
   ({:tag :ItemId, :attrs {}, :content (&quot;1000388464506500&quot;)}
    {:tag :ItemId, :attrs {}, :content (&quot;1000388464506405&quot;)})})
</pre><span>
that i&apos;d like to turn into into this map:
</span><pre>{:CategoryName_1 &quot;cats&quot;, :CategoryId_1 &quot;cat260062&quot;, :Items [&quot;1000388464506500&quot; &quot;1000388464506405&quot;]}
</pre><span>
that is, for recursive </span><code>:content</code><span>s, i&apos;d like them collected into a vector, and for non-recursive, their tags and contents are key value pairs</span></div><div data-t="zlrth the following works, but i&apos;m using glue code to compensate for my lack of specter experience:
 (let [top-level-tags [:CategoryName_1 :CategoryId_1]
      xml &apos;({:tag :CategoryName_1, :attrs {}, :content (&quot;cats&quot;)}
            {:tag :CategoryId_1, :attrs {}, :content (&quot;cat260062&quot;)}
            {:tag :Items,
             :attrs {},
             :content
             ({:tag :ItemId, :attrs {}, :content (&quot;1000388464506500&quot;)}
              {:tag :ItemId, :attrs {}, :content (&quot;1000388464506405&quot;)})})
      map-by-tags (group-by :tag xml)
      top-level (sp/transform
                  [sp/MAP-VALS]
                  (fn [v] (-&gt; v first :content first))
                  (select-keys map-by-tags top-level-tags))
      Items (sp/select
             [:Items sp/ALL :content sp/ALL :content sp/FIRST]
             map-by-tags)]
  (merge top-level {:Items Items}))
"><span class="u" id="1546805085.026800">2019:01:06 20:04:45                zlrth </span><span>the following works, but i&apos;m using glue code to compensate for my lack of specter experience:
</span><pre>(let [top-level-tags [:CategoryName_1 :CategoryId_1]
      xml &apos;({:tag :CategoryName_1, :attrs {}, :content (&quot;cats&quot;)}
            {:tag :CategoryId_1, :attrs {}, :content (&quot;cat260062&quot;)}
            {:tag :Items,
             :attrs {},
             :content
             ({:tag :ItemId, :attrs {}, :content (&quot;1000388464506500&quot;)}
              {:tag :ItemId, :attrs {}, :content (&quot;1000388464506405&quot;)})})
      map-by-tags (group-by :tag xml)
      top-level (sp/transform
                  [sp/MAP-VALS]
                  (fn [v] (-&gt; v first :content first))
                  (select-keys map-by-tags top-level-tags))
      Items (sp/select
             [:Items sp/ALL :content sp/ALL :content sp/FIRST]
             map-by-tags)]
  (merge top-level {:Items Items}))
</pre></div><div data-t="zlrth i didn&apos;t find an example in the docs of &quot;collecting a deeper value and putting it upward&quot;, but that could be my user error. i would thank you very much for tips!"><span class="u" id="1546805295.028800">2019:01:06 20:08:15                zlrth </span><span>i didn&apos;t find an example in the docs of &quot;collecting a deeper value and putting it upward&quot;, but that could be my user error. i would thank you very much for tips!</span></div><div data-t="zlrth ok i have something i&apos;m happier with via  cond-path  and  collect . why is the third element of the  :Items  vector the complete  {:tag :Items ...  map?"><span class="u" id="1546812127.029600">2019:01:06 22:02:07                zlrth </span><span>ok i have something i&apos;m happier with via </span><code>cond-path</code><span> and </span><code>collect</code><span>. why is the third element of the </span><code>:Items</code><span> vector the complete </span><code>{:tag :Items ...</code><span> map?</span></div><div data-t="nathanmarz @mfm you can do that like this:
 (def CONTENT-WALKER
  (recursive-path [] p
    [ALL
     (if-path map?
       [:content p]
       STAY
       )]))

(into {}
  (select
    [ALL
     (collect-one :tag)
     :content
     (subselect CONTENT-WALKER)
     (if-path #(= 1 (count %)) FIRST STAY)
     ]
    data)
    )
"><span class="u" id="1546870633.030400">2019:01:07 14:17:13           nathanmarz </span><span>@mfm you can do that like this:
</span><pre>(def CONTENT-WALKER
  (recursive-path [] p
    [ALL
     (if-path map?
       [:content p]
       STAY
       )]))

(into {}
  (select
    [ALL
     (collect-one :tag)
     :content
     (subselect CONTENT-WALKER)
     (if-path #(= 1 (count %)) FIRST STAY)
     ]
    data)
    )
</pre></div><div data-t="zlrth thank you!"><span class="u" id="1546870661.030600">2019:01:07 14:17:41                zlrth </span><span>thank you!</span></div><div data-t="roklenarcic I&apos;m having problems expressing the following: I want to find an element in the vector, and edit that, but if it doesn&apos;t exist I want to add a default element to the vector"><span class="u" id="1547120473.031900">2019:01:10 11:41:13          roklenarcic </span><span>I&apos;m having problems expressing the following: I want to find an element in the vector, and edit that, but if it doesn&apos;t exist I want to add a default element to the vector</span></div><div data-t="nathanmarz @roklenarcic you can do this:
 (multi-transform
  [(if-path [ALL (pred= :a)]
     [ALL (pred= :a) (terminal-val :c)]
     [AFTER-ELEM (terminal-val :DEFAULT)]
     )]
  [:b :a :b])
"><span class="u" id="1547135577.032200">2019:01:10 15:52:57           nathanmarz </span><span>@roklenarcic you can do this:
</span><pre>(multi-transform
  [(if-path [ALL (pred= :a)]
     [ALL (pred= :a) (terminal-val :c)]
     [AFTER-ELEM (terminal-val :DEFAULT)]
     )]
  [:b :a :b])
</pre></div><div data-t="nathanmarz can probably do it more efficiently with a custom navigator"><span class="u" id="1547135586.032500">2019:01:10 15:53:06           nathanmarz </span><span>can probably do it more efficiently with a custom navigator</span></div><div data-t="lexwin Wow @nathanmarz, I came here looking for exactly this answer."><span class="u" id="1547505633.033800">2019:01:14 22:40:33               lexwin </span><span>Wow @nathanmarz, I came here looking for exactly this answer.</span></div><div data-t="souenzzo (select-one ALL [:a :b])

Execution error (IllegalArgumentException) at com.rpl.specter.impl/compiled-select-one*$result-fn (impl.cljc:375).
More than one element found in structure: :b
(select-one ALL [:a nil])

Execution error (IllegalArgumentException) at com.rpl.specter.impl/compiled-select-one*$result-fn (impl.cljc:375).
More than one element found in structure:
 
 https://github.com/nathanmarz/specter/blob/7790213b163b07ef830fdbb1745fffcda61d40f6/src/clj/com/rpl/specter/impl.cljc#L379 
Here should be  (pr-str structure)  to better error messages."><span class="u" id="1547510368.034600">2019:01:14 23:59:28             souenzzo </span><pre>(select-one ALL [:a :b])

Execution error (IllegalArgumentException) at com.rpl.specter.impl/compiled-select-one*$result-fn (impl.cljc:375).
More than one element found in structure: :b
(select-one ALL [:a nil])

Execution error (IllegalArgumentException) at com.rpl.specter.impl/compiled-select-one*$result-fn (impl.cljc:375).
More than one element found in structure:
</pre><span>
</span><a href="https://github.com/nathanmarz/specter/blob/7790213b163b07ef830fdbb1745fffcda61d40f6/src/clj/com/rpl/specter/impl.cljc#L379">https://github.com/nathanmarz/specter/blob/7790213b163b07ef830fdbb1745fffcda61d40f6/src/clj/com/rpl/specter/impl.cljc#L379</a><span>
Here should be </span><code>(pr-str structure)</code><span> to better error messages.</span></div><div data-t="fmn How do you translate this vanilla clj function to a specter one?

 (defn web-server-config
  [config]
  (let [{:keys [port] :as config} (:web-server config)
        port                      (if (pos-int? port) port 8080)]
    (assoc config :port port)))
 

I can easily got it working with this, but I&apos;m just wondering if there&apos;s a better way to do it with specter:

 (defn web-server-config
  [config]
  (-&gt;&gt; config
       (sp/transform [:web-server :port] #(if (pos-int? %) % 8080))
       (sp/select-one [:web-server (sp/nil-&gt;val {})])))
"><span class="u" id="1547511641.034900">2019:01:15 00:20:41                  fmn </span><span>How do you translate this vanilla clj function to a specter one?

</span><pre>(defn web-server-config
  [config]
  (let [{:keys [port] :as config} (:web-server config)
        port                      (if (pos-int? port) port 8080)]
    (assoc config :port port)))
</pre><span>

I can easily got it working with this, but I&apos;m just wondering if there&apos;s a better way to do it with specter:

</span><pre>(defn web-server-config
  [config]
  (-&gt;&gt; config
       (sp/transform [:web-server :port] #(if (pos-int? %) % 8080))
       (sp/select-one [:web-server (sp/nil-&gt;val {})])))
</pre></div><div data-t="nathanmarz @funyako.funyao156 you can do it in one line like this:
 (select-any
  [:web-server
   (nil-&gt;val {})
   (transformed [:port (complement pos-int?)] (fn [_] 8000))
   ]
  config)
"><span class="u" id="1547529975.035400">2019:01:15 05:26:15           nathanmarz </span><span>@funyako.funyao156 you can do it in one line like this:
</span><pre>(select-any
  [:web-server
   (nil-&gt;val {})
   (transformed [:port (complement pos-int?)] (fn [_] 8000))
   ]
  config)
</pre></div><div data-t="nathanmarz not a big difference"><span class="u" id="1547529979.035600">2019:01:15 05:26:19           nathanmarz </span><span>not a big difference</span></div><div data-t="fmn @nathanmarz thank you!"><span class="u" id="1547631099.036000">2019:01:16 09:31:39                  fmn </span><span>@nathanmarz thank you!</span></div><div data-t="phil Hey, all. In discovery phase and stuck on one already: given  [[&quot;1&quot; &quot;2&quot;] [&quot;3&quot; &quot;4&quot;] [nil &quot;6&quot;]] , how would I get back 6? In other words find seq where the first value is  nil  and return the second value?"><span class="u" id="1548162865.038900">2019:01:22 13:14:25                 phil </span><span>Hey, all. In discovery phase and stuck on one already: given </span><code>[[&quot;1&quot; &quot;2&quot;] [&quot;3&quot; &quot;4&quot;] [nil &quot;6&quot;]]</code><span>, how would I get back 6? In other words find seq where the first value is </span><code>nil</code><span> and return the second value?</span></div><div data-t="schmee @phil here is one way to do it:
 user=&gt; a
[[&quot;1&quot; &quot;2&quot;] [&quot;3&quot; &quot;4&quot;] [nil &quot;6&quot;]]

user=&gt; (select-one [ALL (selected? FIRST (pred= nil)) 1] a)
&quot;6&quot;"><span class="u" id="1548163234.039300">2019:01:22 13:20:34               schmee </span><span>@phil here is one way to do it:
</span><pre>user=&gt; a
[[&quot;1&quot; &quot;2&quot;] [&quot;3&quot; &quot;4&quot;] [nil &quot;6&quot;]]

user=&gt; (select-one [ALL (selected? FIRST (pred= nil)) 1] a)
&quot;6&quot;</pre></div><div data-t="phil @schmee Thanks."><span class="u" id="1548163313.039500">2019:01:22 13:21:53                 phil </span><span>@schmee Thanks.</span></div><div data-t="phil Is moving stuff within a complex structure generally something you would do in one op or in a fetch, delete, insert treo?"><span class="u" id="1548247804.041000">2019:01:23 12:50:04                 phil </span><span>Is moving stuff within a complex structure generally something you would do in one op or in a fetch, delete, insert treo?</span></div><div data-t="nathanmarz @phil probably the latter, but depends on the use case"><span class="u" id="1548253110.041600">2019:01:23 14:18:30           nathanmarz </span><span>@phil probably the latter, but depends on the use case</span></div><div data-t="okocim Question about updating a list of lists:

If I have the following structure:
 [[?x :a/b ?y]
 [?y :b/c ?z]
 ;; I WANT TO NAVIGATE HERE FOR INSERTION
 [?z :d/e ?a]]
 
where I want to insert:
 [[?z :x/y &quot;FOO&quot;]
 [?z :x/k &quot;BAR&quot;]]
 

resulting in:
 [[?x :a/b ?y]
 [?y :b/c ?z]
 [?z :x/y &quot;FOO&quot;]
 [?z :x/k &quot;BAR&quot;]
 [?z :d/e ?a]]
 

What is the path, and does that require transform? or replace-in?
I’m trying to use

 [S/ALL
 (S/pred= &apos;[?y :b/c ?z])
 S/AFTER-ELEM]
 

for my path with a transform But that’s not working.
I can’t assure the  index of the insertion point will always be the same"><span class="u" id="1548360785.043300">2019:01:24 20:13:05               okocim </span><span>Question about updating a list of lists:

If I have the following structure:
</span><pre>[[?x :a/b ?y]
 [?y :b/c ?z]
 ;; I WANT TO NAVIGATE HERE FOR INSERTION
 [?z :d/e ?a]]
</pre><span>
where I want to insert:
</span><pre>[[?z :x/y &quot;FOO&quot;]
 [?z :x/k &quot;BAR&quot;]]
</pre><span>

resulting in:
</span><pre>[[?x :a/b ?y]
 [?y :b/c ?z]
 [?z :x/y &quot;FOO&quot;]
 [?z :x/k &quot;BAR&quot;]
 [?z :d/e ?a]]
</pre><span>

What is the path, and does that require transform? or replace-in?
I’m trying to use

</span><pre>[S/ALL
 (S/pred= &apos;[?y :b/c ?z])
 S/AFTER-ELEM]
</pre><span>

for my path with a transform But that’s not working.
I can’t assure the  index of the insertion point will always be the same</span></div><div data-t="schmee @okocim here’s a kludgy two-step solution:
 user=&gt; a
[[?x :a/b ?y] [?y :b/c ?z] [?z :d/e ?a]]

user=&gt; b
[[?z :x/y &quot;FOO&quot;] [?z :x/k &quot;BAR&quot;]]

user=&gt; (def i (select-one [INDEXED-VALS (selected? LAST (pred= &apos;[?y :b/c ?z])) FIRST] a))
#&apos;user/i

user=&gt; (setval [(srange i (inc i)) END] b a)
[[?x :a/b ?y]
 [?y :b/c ?z]
 [?z :x/y &quot;FOO&quot;]
 [?z :x/k &quot;BAR&quot;]
 [?z :d/e ?a]]"><span class="u" id="1548362406.044000">2019:01:24 20:40:06               schmee </span><span>@okocim here’s a kludgy two-step solution:
</span><pre>user=&gt; a
[[?x :a/b ?y] [?y :b/c ?z] [?z :d/e ?a]]

user=&gt; b
[[?z :x/y &quot;FOO&quot;] [?z :x/k &quot;BAR&quot;]]

user=&gt; (def i (select-one [INDEXED-VALS (selected? LAST (pred= &apos;[?y :b/c ?z])) FIRST] a))
#&apos;user/i

user=&gt; (setval [(srange i (inc i)) END] b a)
[[?x :a/b ?y]
 [?y :b/c ?z]
 [?z :x/y &quot;FOO&quot;]
 [?z :x/k &quot;BAR&quot;]
 [?z :d/e ?a]]</pre></div><div data-t="okocim Thanks, I’ll take it for now. It is a bit fumbly, but I think I can cordon that off until I can come up with something better"><span class="u" id="1548362548.045000">2019:01:24 20:42:28               okocim </span><span>Thanks, I’ll take it for now. It is a bit fumbly, but I think I can cordon that off until I can come up with something better</span></div><div data-t="schmee If you find something cleaner post it here!"><span class="u" id="1548363424.045400">2019:01:24 20:57:04               schmee </span><span>If you find something cleaner post it here!</span></div><div data-t="okocim I will. I was headed down the path of doing the two steps (find the index and splice-in) when you posted this, so thank you.  I will be happy to return the favor if I can."><span class="u" id="1548363488.046600">2019:01:24 20:58:08               okocim </span><span>I will. I was headed down the path of doing the two steps (find the index and splice-in) when you posted this, so thank you.  I will be happy to return the favor if I can.</span></div><div data-t="twashing I have a set of nested records.

In my structure, I want to STAY on the i. the value nodes with :bar keys, that are ii. not seqable? and iii. not of type myns.Foo.

But I can’t seem to get the recursive navigator correctly. Any ideas here?

 (def a #myns.Foo{:bar #myns.Foo{:bar (#myns.Foo{:bar :a :x 1 :y 2} :b :c :d)}})

(def b (recursive-path
         [] p
         (cond-path
           seqable? [ALL p]
           [:matcher (comp clojure.core/not parser-combinator?)] (continue-then-stay ALL p)
           [:matcher (comp clojure.core/not seqable?)] [ALL p])))

(select b a)
"><span class="u" id="1548411518.046900">2019:01:25 10:18:38             twashing </span><span>I have a set of nested records.

In my structure, I want to STAY on the i. the value nodes with :bar keys, that are ii. not seqable? and iii. not of type myns.Foo.

But I can’t seem to get the recursive navigator correctly. Any ideas here?

</span><pre>(def a #myns.Foo{:bar #myns.Foo{:bar (#myns.Foo{:bar :a :x 1 :y 2} :b :c :d)}})

(def b (recursive-path
         [] p
         (cond-path
           seqable? [ALL p]
           [:matcher (comp clojure.core/not parser-combinator?)] (continue-then-stay ALL p)
           [:matcher (comp clojure.core/not seqable?)] [ALL p])))

(select b a)
</pre></div><div data-t="nathanmarz @twashing it would be more clear if you showed desired input and output"><span class="u" id="1548429836.047900">2019:01:25 15:23:56           nathanmarz </span><span>@twashing it would be more clear if you showed desired input and output</span></div><div data-t="twashing Hey @nathanmarz, absolutely. So I’m trying to find the  recursive-path  that gives me the output in *B, given the input from A*."><span class="u" id="1548452635.048400">2019:01:25 21:43:55             twashing </span><span>Hey @nathanmarz, absolutely. So I’m trying to find the </span><code>recursive-path</code><span> that gives me the output in *B, given the input from A*.</span></div><div data-t="twashing ;; A input structure
(defrecord Foo [bar])
(def a #user.Foo{:bar #user.Foo{:bar &apos;(#user.Foo{:bar :a :x 1 :y 2} :b :c :d)}})

;; B output 
:a ;; (the i. the value nodes with :bar keys, that are ii. not seqable? and iii. not of type myns.Foo)
"><span class="u" id="1548452636.048600">2019:01:25 21:43:56             twashing </span><pre>;; A input structure
(defrecord Foo [bar])
(def a #user.Foo{:bar #user.Foo{:bar &apos;(#user.Foo{:bar :a :x 1 :y 2} :b :c :d)}})

;; B output 
:a ;; (the i. the value nodes with :bar keys, that are ii. not seqable? and iii. not of type myns.Foo)
</pre></div><div data-t="nathanmarz @twashing is this what you&apos;re looking for?
 (def MY-WALKER
  (recursive-path [] p
    (cond-path
      #(instance? Foo %) [:bar p]
      seqable? [ALL #(instance? Foo %) p]
      STAY STAY
      )))
"><span class="u" id="1548455437.049000">2019:01:25 22:30:37           nathanmarz </span><span>@twashing is this what you&apos;re looking for?
</span><pre>(def MY-WALKER
  (recursive-path [] p
    (cond-path
      #(instance? Foo %) [:bar p]
      seqable? [ALL #(instance? Foo %) p]
      STAY STAY
      )))
</pre></div><div data-t="twashing @nathanmarz Hmm, if I put this into my repl, I get an empty result set."><span class="u" id="1548455919.049300">2019:01:25 22:38:39             twashing </span><span>@nathanmarz Hmm, if I put this into my repl, I get an empty result set.</span></div><div data-t="twashing (use &apos;com.rpl.specter)

(defrecord Foo [bar])

(def a #user.Foo{:bar #user.Foo{:bar &apos;(#user.Foo{:bar :a :x 1 :y 2} :b :c :d)}})

(def MY-WALKER
  (recursive-path [] p
    (cond-path
      #(instance? Foo %) [:bar p]
      seqable? [ALL #(instance? Foo %) p]
      STAY STAY)))

(select MY-WALKER a)

;; [] - empty result set returned
"><span class="u" id="1548455948.049800">2019:01:25 22:39:08             twashing </span><pre>(use &apos;com.rpl.specter)

(defrecord Foo [bar])

(def a #user.Foo{:bar #user.Foo{:bar &apos;(#user.Foo{:bar :a :x 1 :y 2} :b :c :d)}})

(def MY-WALKER
  (recursive-path [] p
    (cond-path
      #(instance? Foo %) [:bar p]
      seqable? [ALL #(instance? Foo %) p]
      STAY STAY)))

(select MY-WALKER a)

;; [] - empty result set returned
</pre></div><div data-t="twashing It’s a tricky one."><span class="u" id="1548455959.050000">2019:01:25 22:39:19             twashing </span><span>It’s a tricky one.</span></div><div data-t="nathanmarz @twashing probably because you meant to do  (def a #user.Foo{:bar #user.Foo{:bar (#user.Foo{:bar :a :x 1 :y 2} :b :c :d)}})  ?"><span class="u" id="1548457236.050400">2019:01:25 23:00:36           nathanmarz </span><span>@twashing probably because you meant to do </span><code>(def a #user.Foo{:bar #user.Foo{:bar (#user.Foo{:bar :a :x 1 :y 2} :b :c :d)}})</code><span> ?</span></div><div data-t="twashing Ah ok."><span class="u" id="1548457586.051400">2019:01:25 23:06:26             twashing </span><span>Ah ok.</span></div><div data-t="twashing Didn’t realise the reader macro stopped the list from being eval’d… Cool."><span class="u" id="1548457611.052000">2019:01:25 23:06:51             twashing </span><span>Didn’t realise the reader macro stopped the list from being eval’d… Cool.</span></div><div data-t="twashing Cheers mate. I think I have a better understanding of the semantics of  if-path  and  cond-path ."><span class="u" id="1548457767.052800">2019:01:25 23:09:27             twashing </span><span>Cheers mate. I think I have a better understanding of the semantics of </span><code>if-path</code><span> and </span><code>cond-path</code><span>.</span></div><div data-t="twashing Although  STAY STAY  (to capture the leaves) is still a bit foggy.. used as both a predicate and navigator."><span class="u" id="1548457859.053900">2019:01:25 23:10:59             twashing </span><span>Although </span><code>STAY STAY</code><span> (to capture the leaves) is still a bit foggy.. used as both a predicate and navigator.</span></div><div data-t="twashing Thanks for a great library!"><span class="u" id="1548457872.054200">2019:01:25 23:11:12             twashing </span><span>Thanks for a great library!</span></div><div data-t="nathanmarz @twashing An  if-path /`cond-path` condition is &quot;true&quot; if it navigates to at least one value"><span class="u" id="1548459275.054700">2019:01:25 23:34:35           nathanmarz </span><span>@twashing An </span><code>if-path</code><span>/`cond-path` condition is &quot;true&quot; if it navigates to at least one value</span></div><div data-t="nathanmarz so  STAY  is the navigation equivalent of  true"><span class="u" id="1548459283.055000">2019:01:25 23:34:43           nathanmarz </span><span>so </span><code>STAY</code><span> is the navigation equivalent of </span><code>true</code></div><div data-t="twashing Gotcha  👍 :skin-tone-5:"><span class="u" id="1548459365.055400">2019:01:25 23:36:05             twashing </span><span>Gotcha </span><b>👍</b><b>:skin-tone-5:</b></div><div data-t="steveb8n I’m having trouble with a recursive requirement. Here’s the example:
 (-&gt;&gt; {:gender :male
        :type    :person
        :name    &quot;Luke&quot;
        :mother  {:gender :female
                  :type :person
                  :name &quot;Padme&quot;}
        :friends [{:gender :male
                   :type :person
                   :name &quot;Han&quot;}
                  {:gender :male
                   :type :person
                   :name &quot;Chewbacca&quot;}]
        :mentors {:type   :group
                  :people [{:gender :male
                            :type :person
                            :name &quot;Obiwan&quot;}
                           {:gender :male
                            :type :person
                            :name &quot;Yoda&quot;}]}}
       (select [(recursive-path [] p
                                (if-path (fn [v] (and (map? v) (:gender v)))
                                         (continue-then-stay (multi-path [(must :friends) ALL]
                                                                         [MAP-VALS #(:gender %)])
                                                             p)))]))
 
=&gt;
 [{:gender :male, :type :person, :name &quot;Han&quot;}
 {:gender :male, :type :person, :name &quot;Chewbacca&quot;}
 {:gender :female, :type :person, :name &quot;Padme&quot;}
 {:gender :male,
  :type :person,
  :name &quot;Luke&quot;,
  :mother {:gender :female, :type :person, :name &quot;Padme&quot;},
  :friends [{:gender :male, :type :person, :name &quot;Han&quot;} {:gender :male, :type :person, :name &quot;Chewbacca&quot;}],
  :mentors {:type :group,
            :people [{:gender :male, :type :person, :name &quot;Obiwan&quot;} {:gender :male, :type :person, :name &quot;Yoda&quot;}]}}]
 

How can I get it to also return the mentors? They are :persons as well"><span class="u" id="1548906162.056300">2019:01:31 03:42:42             steveb8n </span><span>I’m having trouble with a recursive requirement. Here’s the example:
</span><pre>(-&gt;&gt; {:gender :male
        :type    :person
        :name    &quot;Luke&quot;
        :mother  {:gender :female
                  :type :person
                  :name &quot;Padme&quot;}
        :friends [{:gender :male
                   :type :person
                   :name &quot;Han&quot;}
                  {:gender :male
                   :type :person
                   :name &quot;Chewbacca&quot;}]
        :mentors {:type   :group
                  :people [{:gender :male
                            :type :person
                            :name &quot;Obiwan&quot;}
                           {:gender :male
                            :type :person
                            :name &quot;Yoda&quot;}]}}
       (select [(recursive-path [] p
                                (if-path (fn [v] (and (map? v) (:gender v)))
                                         (continue-then-stay (multi-path [(must :friends) ALL]
                                                                         [MAP-VALS #(:gender %)])
                                                             p)))]))
</pre><span>
=&gt;
</span><pre>[{:gender :male, :type :person, :name &quot;Han&quot;}
 {:gender :male, :type :person, :name &quot;Chewbacca&quot;}
 {:gender :female, :type :person, :name &quot;Padme&quot;}
 {:gender :male,
  :type :person,
  :name &quot;Luke&quot;,
  :mother {:gender :female, :type :person, :name &quot;Padme&quot;},
  :friends [{:gender :male, :type :person, :name &quot;Han&quot;} {:gender :male, :type :person, :name &quot;Chewbacca&quot;}],
  :mentors {:type :group,
            :people [{:gender :male, :type :person, :name &quot;Obiwan&quot;} {:gender :male, :type :person, :name &quot;Yoda&quot;}]}}]
</pre><span>

How can I get it to also return the mentors? They are :persons as well</span></div><div data-t="steveb8n multi-path only seems to support 2 variations. I guess another way of asking this is how can I combine the selections of 3 paths into 1?"><span class="u" id="1548906362.057700">2019:01:31 03:46:02             steveb8n </span><span>multi-path only seems to support 2 variations. I guess another way of asking this is how can I combine the selections of 3 paths into 1?</span></div><div data-t="steveb8n One way would be to use a clojure.walk to extract all :person maps and wrap that in a specter nav (maybe view). I can’t use specter/walker because it stops on matches in each branch so it would only return 1 mentor. ideally I’d like some specter native nav composition but can’t see how."><span class="u" id="1548914227.060000">2019:01:31 05:57:07             steveb8n </span><span>One way would be to use a clojure.walk to extract all :person maps and wrap that in a specter nav (maybe view). I can’t use specter/walker because it stops on matches in each branch so it would only return 1 mentor. ideally I’d like some specter native nav composition but can’t see how.</span></div><div data-t="nathanmarz @steveb8n I think you&apos;re looking for:
 (def PEOPLE
  (recursive-path [] p
    (continue-then-stay
      (multi-path
        (must :mother)
        (must :father)
        [(must :friends) ALL]
        [(must :mentors) :people ALL]
        )
      p
      )))
"><span class="u" id="1548920080.060600">2019:01:31 07:34:40           nathanmarz </span><span>@steveb8n I think you&apos;re looking for:
</span><pre>(def PEOPLE
  (recursive-path [] p
    (continue-then-stay
      (multi-path
        (must :mother)
        (must :father)
        [(must :friends) ALL]
        [(must :mentors) :people ALL]
        )
      p
      )))
</pre></div><div data-t="steveb8n thanks. let me try that"><span class="u" id="1548920110.060700">2019:01:31 07:35:10                  steveb8n </span><span>thanks. let me try that</span></div><div data-t="steveb8n awesome. works like a charm."><span class="u" id="1548920216.060900">2019:01:31 07:36:56                  steveb8n </span><span>awesome. works like a charm.</span></div><div data-t="vigilancetech any idea why I&apos;d be getting this?

 ------ WARNING #1 --------------------------------------------------------------
 File: com/rpl/specter.cljc:1275:19
--------------------------------------------------------------------------------
1272 |           ns (namespace structure)]
1273 |       (cond (keyword? structure) (keyword ns new-name)
1274 |             (symbol? structure) (symbol ns new-name)
1275 |             :else (i/throw-illegal &quot;NAME can only be used on symbols or keywords - &quot; st
ructure)
-------------------------^------------------------------------------------------
 Use of undeclared Var com.rpl.specter/java
--------------------------------------------------------------------------------
1276 |             ))))
1277 |
1278 | (defnav ^{:doc &quot;Navigates to the namespace portion of the keyword or symbol&quot;}
1279 |   NAMESPACE
--------------------------------------------------------------------------------

------ WARNING #2 --------------------------------------------------------------
 File: com/rpl/specter.cljc:1288:19
--------------------------------------------------------------------------------
1285 |           new-ns (next-fn (namespace structure))]
1286 |       (cond (keyword? structure) (keyword new-ns name)
1287 |             (symbol? structure) (symbol new-ns name)
1288 |             :else (i/throw-illegal &quot;NAMESPACE can only be used on symbols or keywords -
 &quot; structure)
-------------------------^------------------------------------------------------
 Use of undeclared Var com.rpl.specter/java
--------------------------------------------------------------------------------
1289 |             ))))
1290 |
1291 | (defdynamicnav
1292 |   ^{:doc &quot;Adds the result of running select with the given path on the
--------------------------------------------------------------------------------
"><span class="u" id="1550297424.000600">2019:02:16 06:10:24        vigilancetech </span><span>any idea why I&apos;d be getting this?

</span><pre>------ WARNING #1 --------------------------------------------------------------
 File: com/rpl/specter.cljc:1275:19
--------------------------------------------------------------------------------
1272 |           ns (namespace structure)]
1273 |       (cond (keyword? structure) (keyword ns new-name)
1274 |             (symbol? structure) (symbol ns new-name)
1275 |             :else (i/throw-illegal &quot;NAME can only be used on symbols or keywords - &quot; st
ructure)
-------------------------^------------------------------------------------------
 Use of undeclared Var com.rpl.specter/java
--------------------------------------------------------------------------------
1276 |             ))))
1277 |
1278 | (defnav ^{:doc &quot;Navigates to the namespace portion of the keyword or symbol&quot;}
1279 |   NAMESPACE
--------------------------------------------------------------------------------

------ WARNING #2 --------------------------------------------------------------
 File: com/rpl/specter.cljc:1288:19
--------------------------------------------------------------------------------
1285 |           new-ns (next-fn (namespace structure))]
1286 |       (cond (keyword? structure) (keyword new-ns name)
1287 |             (symbol? structure) (symbol new-ns name)
1288 |             :else (i/throw-illegal &quot;NAMESPACE can only be used on symbols or keywords -
 &quot; structure)
-------------------------^------------------------------------------------------
 Use of undeclared Var com.rpl.specter/java
--------------------------------------------------------------------------------
1289 |             ))))
1290 |
1291 | (defdynamicnav
1292 |   ^{:doc &quot;Adds the result of running select with the given path on the
--------------------------------------------------------------------------------
</pre></div><div data-t="vigilancetech this is a project under shadow-cljs"><span class="u" id="1550297463.000900">2019:02:16 06:11:03        vigilancetech </span><span>this is a project under shadow-cljs</span></div><div data-t="vigilancetech okay, I got it to go away by running the latest snapshot.   Any idea when that version will be un-snapshotted so my program doesn&apos;t break again here in a few weeks?"><span class="u" id="1550303780.001700">2019:02:16 07:56:20        vigilancetech </span><span>okay, I got it to go away by running the latest snapshot.   Any idea when that version will be un-snapshotted so my program doesn&apos;t break again here in a few weeks?</span></div><div data-t="axrs Is it possible to insert a value after a predicate match with specter? I thought  AFTER-ELEM  would work, but it converts map to a sequence  ([:spec :test-2] :inserted) 

Something like:
 (sp/setval 
  [sp/ALL (comp (partial = :test-2) :spec) sp/AFTER] 
  :inserted 
  [{:spec :test} {:spec :test-2} {:spec :test-3}])
 
I&apos;m looking for the result to be:
 [{:spec :test} {:spec :test-2} :inserted {:spec :test-3}]"><span class="u" id="1550543636.002500">2019:02:19 02:33:56                 axrs </span><span>Is it possible to insert a value after a predicate match with specter? I thought </span><code>AFTER-ELEM</code><span> would work, but it converts map to a sequence </span><code>([:spec :test-2] :inserted)</code><span>

Something like:
</span><pre>(sp/setval 
  [sp/ALL (comp (partial = :test-2) :spec) sp/AFTER] 
  :inserted 
  [{:spec :test} {:spec :test-2} {:spec :test-3}])
</pre><span>
I&apos;m looking for the result to be:
</span><code>[{:spec :test} {:spec :test-2} :inserted {:spec :test-3}]</code></div><div data-t="nathanmarz @axrs  ALL  navigates you into the value, so you&apos;re no longer in the context of the sequence"><span class="u" id="1550582437.003100">2019:02:19 13:20:37           nathanmarz </span><span>@axrs </span><code>ALL</code><span> navigates you into the value, so you&apos;re no longer in the context of the sequence</span></div><div data-t="nathanmarz you can accomplish your goal by using the zipper navigators"><span class="u" id="1550582461.003700">2019:02:19 13:21:01           nathanmarz </span><span>you can accomplish your goal by using the zipper navigators</span></div><div data-t="roklenarcic Is there some way to say  STAY if SUBPATH 1 and SUBPATH 2 match"><span class="u" id="1550749704.000700">2019:02:21 11:48:24          roklenarcic </span><span>Is there some way to say </span><code>STAY if SUBPATH 1 and SUBPATH 2 match</code></div><div data-t="roklenarcic I cannot find a way to check if two subpaths are both present"><span class="u" id="1550749723.001200">2019:02:21 11:48:43          roklenarcic </span><span>I cannot find a way to check if two subpaths are both present</span></div><div data-t="roklenarcic to implement collecting an item if prop1 = x and prop2 = y"><span class="u" id="1550749756.001800">2019:02:21 11:49:16          roklenarcic </span><span>to implement collecting an item if prop1 = x and prop2 = y</span></div><div data-t="roklenarcic used multiple  selected?  to accomplish that"><span class="u" id="1550750653.002200">2019:02:21 12:04:13          roklenarcic </span><span>used multiple </span><code>selected?</code><span> to accomplish that</span></div><div data-t="eoliphant hi I’m trying to figure out how exactly INDEXED-VALS works.  Like the example .  For say  [0 1 2 3 4] , I want to move say the 3 at index 3, to say the 0th or some other index.  The select is clear to me, basically like  map-indexed .  But I’m not quite grokking what’s happening in the  setval  example.

This looks like it would do something like set all the indicies to 0.    (sp/setval [sp/INDEXED-VALS sp/FIRST] 0 [0 1 2 3 4])   but say  (sp/setval [sp/INDEXED-VALS sp/FIRST 2] 0 [0 1 2 3 4])  would move 2 to the front of the list.  That’s obviously not how it works lol"><span class="u" id="1550788186.004500">2019:02:21 22:29:46            eoliphant </span><span>hi I’m trying to figure out how exactly INDEXED-VALS works.  Like the example .  For say </span><code>[0 1 2 3 4]</code><span>, I want to move say the 3 at index 3, to say the 0th or some other index.  The select is clear to me, basically like </span><code>map-indexed</code><span>.  But I’m not quite grokking what’s happening in the </span><code>setval</code><span> example.

This looks like it would do something like set all the indicies to 0.   </span><code>(sp/setval [sp/INDEXED-VALS sp/FIRST] 0 [0 1 2 3 4])</code><span>  but say </span><code>(sp/setval [sp/INDEXED-VALS sp/FIRST 2] 0 [0 1 2 3 4])</code><span> would move 2 to the front of the list.  That’s obviously not how it works lol</span></div><div data-t="nathanmarz it traverses the values in order, so it moves them all to index 0 in order, having the effect of reversing the vector"><span class="u" id="1550789866.005300">2019:02:21 22:57:46           nathanmarz </span><span>it traverses the values in order, so it moves them all to index 0 in order, having the effect of reversing the vector</span></div><div data-t="nathanmarz you can move just one particular value like this:
 user=&gt; (setval [INDEXED-VALS (selected? LAST (pred= 3)) FIRST] 0 [0 1 2 3 4])
[3 0 1 2 4]
"><span class="u" id="1550789877.005600">2019:02:21 22:57:57           nathanmarz </span><span>you can move just one particular value like this:
</span><pre>user=&gt; (setval [INDEXED-VALS (selected? LAST (pred= 3)) FIRST] 0 [0 1 2 3 4])
[3 0 1 2 4]
</pre></div><div data-t="nathanmarz but  index-nav  is better for moving one value at a specific position:
 user=&gt; (setval (index-nav 3) 0 [0 1 2 3 4])
[3 0 1 2 4]
"><span class="u" id="1550789912.006100">2019:02:21 22:58:32           nathanmarz </span><span>but </span><code>index-nav</code><span> is better for moving one value at a specific position:
</span><pre>user=&gt; (setval (index-nav 3) 0 [0 1 2 3 4])
[3 0 1 2 4]
</pre></div><div data-t="eoliphant gotcha that makes sense., thanks!"><span class="u" id="1550794692.006700">2019:02:22 00:18:12            eoliphant </span><span>gotcha that makes sense., thanks!</span></div><div data-t="miikka We tried to use  (transiorm [ALL] ...)  with Instaparse&apos;s AutoFlattenSeq, but the results are in reverse order – probably because if you  into  into an empty AutoFlattenSeq, it behaves like a linked list and the results are in the reverse order."><span class="u" id="1551174468.008700">2019:02:26 09:47:48               miikka </span><span>We tried to use </span><code>(transiorm [ALL] ...)</code><span> with Instaparse&apos;s AutoFlattenSeq, but the results are in reverse order – probably because if you </span><code>into</code><span> into an empty AutoFlattenSeq, it behaves like a linked list and the results are in the reverse order.</span></div><div data-t="miikka We solved it by making  a custom navigator with  (transform* [this structure next-fn] (map next-fn structure))  – we do not care about preserving the type – but I&apos;m wondering if there&apos;s a way to make  ALL  work with AutoFlattenSeq?"><span class="u" id="1551174529.010000">2019:02:26 09:48:49               miikka </span><span>We solved it by making  a custom navigator with </span><code>(transform* [this structure next-fn] (map next-fn structure))</code><span> – we do not care about preserving the type – but I&apos;m wondering if there&apos;s a way to make </span><code>ALL</code><span> work with AutoFlattenSeq?</span></div><div data-t="nathanmarz @miikka yes, you can extend  com.rpl.specter.navs/AllTransformProtocol"><span class="u" id="1551183998.010300">2019:02:26 12:26:38           nathanmarz </span><span>@miikka yes, you can extend </span><code>com.rpl.specter.navs/AllTransformProtocol</code></div><div data-t="miikka Ah, thanks"><span class="u" id="1551197018.010500">2019:02:26 16:03:38               miikka </span><span>Ah, thanks</span></div><div data-t="lxsli Nathan are you writing a book on how to use Specter? Because I&apos;d buy the hell out of that"><span class="u" id="1551437844.000400">2019:03:01 10:57:24                lxsli </span><span>Nathan are you writing a book on how to use Specter? Because I&apos;d buy the hell out of that</span></div><div data-t="nathanmarz @alee thanks, but I&apos;m done writing books for awhile..."><span class="u" id="1551454781.000900">2019:03:01 15:39:41           nathanmarz </span><span>@alee thanks, but I&apos;m done writing books for awhile...</span></div><div data-t="idiomancy any libraries out there for navigating core.async channels with specter?"><span class="u" id="1551665502.002000">2019:03:04 02:11:42            idiomancy </span><span>any libraries out there for navigating core.async channels with specter?</span></div><div data-t="akond does specter handle refs the way it handles atoms?"><span class="u" id="1551702953.002700">2019:03:04 12:35:53                akond </span><span>does specter handle refs the way it handles atoms?</span></div><div data-t="akond i mean how do i change a ref?"><span class="u" id="1551702976.003000">2019:03:04 12:36:16                akond </span><span>i mean how do i change a ref?</span></div><div data-t="akond (dosync
    (alter storage #(setval [...] (merge-with + field offset) %))) 
does the job, but maybe there is a nicer way to do this?"><span class="u" id="1551704146.003800">2019:03:04 12:55:46                akond </span><pre>(dosync
    (alter storage #(setval [...] (merge-with + field offset) %)))</pre><span>
does the job, but maybe there is a nicer way to do this?</span></div><div data-t="nathanmarz @akond there&apos;s no built-in navigator for refs"><span class="u" id="1551739788.004200">2019:03:04 22:49:48           nathanmarz </span><span>@akond there&apos;s no built-in navigator for refs</span></div><div data-t="nathanmarz you&apos;d have to make your own"><span class="u" id="1551739791.004400">2019:03:04 22:49:51           nathanmarz </span><span>you&apos;d have to make your own</span></div><div data-t="akond is there a reason for not having one or it just happend?"><span class="u" id="1551761781.005400">2019:03:05 04:56:21                akond </span><span>is there a reason for not having one or it just happend?</span></div><div data-t="sogaiu @alee perhaps you are already familiar with the following?   https://leanpub.com/specter/read"><span class="u" id="1551776015.006100">2019:03:05 08:53:35               sogaiu </span><span>@alee perhaps you are already familiar with the following?  </span><a href="https://leanpub.com/specter/read">https://leanpub.com/specter/read</a></div><div data-t="lxsli @sogaiu yes, I&apos;m afraid I didn&apos;t find it very useful. It&apos;s not finished by any stretch - it doesn&apos;t cover many of the navigators or even the macros"><span class="u" id="1551776163.007100">2019:03:05 08:56:03                lxsli </span><span>@sogaiu yes, I&apos;m afraid I didn&apos;t find it very useful. It&apos;s not finished by any stretch - it doesn&apos;t cover many of the navigators or even the macros</span></div><div data-t="lxsli I&apos;m unconvinced that digging into the internals is the best way to understand it either"><span class="u" id="1551776211.007600">2019:03:05 08:56:51                lxsli </span><span>I&apos;m unconvinced that digging into the internals is the best way to understand it either</span></div><div data-t="lxsli I&apos;m most interested in a cookbook. For example one of my questions is &quot;how much should I do in one Specter call?&quot;. I&apos;ve had more luck composing calls than building super-paths so far.
Dynamic paths seem very powerful, I&apos;d like to see some examples of those. Same for multi-path.
I have yet to figure out when to use STAY, CONTINUE etc. Just about getting the hang of collection."><span class="u" id="1551776459.010900">2019:03:05 09:00:59                lxsli </span><span>I&apos;m most interested in a cookbook. For example one of my questions is &quot;how much should I do in one Specter call?&quot;. I&apos;ve had more luck composing calls than building super-paths so far.
Dynamic paths seem very powerful, I&apos;d like to see some examples of those. Same for multi-path.
I have yet to figure out when to use STAY, CONTINUE etc. Just about getting the hang of collection.</span></div><div data-t="sogaiu @alee when working on a port to clojure clr, i found that the tests were quite extensive.  have you had a look at those?  fwiw, i&apos;m definitely not a seasoned specter user :)"><span class="u" id="1551780463.015500">2019:03:05 10:07:43               sogaiu </span><span>@alee when working on a port to clojure clr, i found that the tests were quite extensive.  have you had a look at those?  fwiw, i&apos;m definitely not a seasoned specter user :)</span></div><div data-t="lxsli I&apos;ll check them out when I have time, good idea"><span class="u" id="1551780589.015800">2019:03:05 10:09:49                lxsli </span><span>I&apos;ll check them out when I have time, good idea</span></div><div data-t="lxsli java.lang.UnsupportedOperationException: Can&apos;t create empty: user_api.records.FrobRec
	at user_api.records.FrobRec.empty(records.clj:367)
	at clojure.core$empty.invokeStatic(core.clj:5247)
	at clojure.core$empty.invoke(core.clj:5241)
	at com.rpl.specter.navs$eval2165$fn__2170.invoke(navs.cljc:372)
	at com.rpl.specter.navs$eval2099$fn__2113$G__2090__2120.invoke(navs.cljc:222)
	at com.rpl.specter$reify__2852.transform_STAR_(specter.cljc:718)
    ... 

Anything that can be done about this? For now I&apos;m just passing  (into {} rec)  instead of simply  rec"><span class="u" id="1555053697.000900">2019:04:12 07:21:37                lxsli </span><pre>java.lang.UnsupportedOperationException: Can&apos;t create empty: user_api.records.FrobRec
	at user_api.records.FrobRec.empty(records.clj:367)
	at clojure.core$empty.invokeStatic(core.clj:5247)
	at clojure.core$empty.invoke(core.clj:5241)
	at com.rpl.specter.navs$eval2165$fn__2170.invoke(navs.cljc:372)
	at com.rpl.specter.navs$eval2099$fn__2113$G__2090__2120.invoke(navs.cljc:222)
	at com.rpl.specter$reify__2852.transform_STAR_(specter.cljc:718)
    ...</pre><span>

Anything that can be done about this? For now I&apos;m just passing </span><code>(into {} rec)</code><span> instead of simply </span><code>rec</code></div><div data-t="nathanmarz what&apos;s your path?"><span class="u" id="1555088261.001300">2019:04:12 16:57:41           nathanmarz </span><span>what&apos;s your path?</span></div><div data-t="theeternalpulse If I am doing a transform with multi/path how can I refer to the las tthing selected before that path for example
 (multi-transform [LAST
                    (multi-path [:a (terminal #_something-here-to-reference-LAST-object)]
                                [:b (terminal dec)])]
                   [1 2 3 4 5 {:a 1 :b 5 :c nil}])"><span class="u" id="1557115377.003700">2019:05:06 04:02:57      theeternalpulse </span><span>If I am doing a transform with multi/path how can I refer to the las tthing selected before that path for example
</span><pre>(multi-transform [LAST
                    (multi-path [:a (terminal #_something-here-to-reference-LAST-object)]
                                [:b (terminal dec)])]
                   [1 2 3 4 5 {:a 1 :b 5 :c nil}])</pre></div><div data-t="theeternalpulse how can In the terminal statement can I say &quot;give me the LAST from the previous selector before I started branching off&quot;"><span class="u" id="1557115409.004400">2019:05:06 04:03:29      theeternalpulse </span><span>how can In the terminal statement can I say &quot;give me the LAST from the previous selector before I started branching off&quot;</span></div><div data-t="theeternalpulse do I have ot just have a path that is like  [(terminal #(update % :a some-fn (:c %)...)"><span class="u" id="1557115986.005000">2019:05:06 04:13:06      theeternalpulse </span><span>do I have ot just have a path that is like </span><code>[(terminal #(update % :a some-fn (:c %)...)</code></div><div data-t="theeternalpulse (multi-transform [LAST
                    (multi-path [(terminal #(update % :a + (:b %)))]
                                [:b (terminal dec)]
                                [:c (terminal-val 123)])]
                   [1 2 3 4 5 {:a 1 :b 5 :c nil}]) 
seems to work but wonder if there&apos;s a more specter way of doing that"><span class="u" id="1557116151.005400">2019:05:06 04:15:51           theeternalpulse </span><pre>(multi-transform [LAST
                    (multi-path [(terminal #(update % :a + (:b %)))]
                                [:b (terminal dec)]
                                [:c (terminal-val 123)])]
                   [1 2 3 4 5 {:a 1 :b 5 :c nil}])</pre><span>
seems to work but wonder if there&apos;s a more specter way of doing that</span></div><div data-t="nathanmarz @theeternalpulse use one of the value collection navs, like  collect  or  collect-one"><span class="u" id="1557148796.006200">2019:05:06 13:19:56           nathanmarz </span><span>@theeternalpulse use one of the value collection navs, like </span><code>collect</code><span> or </span><code>collect-one</code></div><div data-t="theeternalpulse Ah I see, now that makes the subsequent multipath fns have to take two arguments"><span class="u" id="1557152528.006800">2019:05:06 14:22:08      theeternalpulse </span><span>Ah I see, now that makes the subsequent multipath fns have to take two arguments</span></div><div data-t="theeternalpulse no I tried it, nice solution, need to read through these again,  (multi-transform [LAST
                    (multi-path
                     [(collect-one :b) :a (terminal +)]
                     [:b (terminal dec)]
                     [:c (terminal-val 123)])]
                   [1 2 3 4 5 {:a 1 :b 5 :c nil}])"><span class="u" id="1557154955.007600">2019:05:06 15:02:35      theeternalpulse </span><span>no I tried it, nice solution, need to read through these again, </span><pre>(multi-transform [LAST
                    (multi-path
                     [(collect-one :b) :a (terminal +)]
                     [:b (terminal dec)]
                     [:c (terminal-val 123)])]
                   [1 2 3 4 5 {:a 1 :b 5 :c nil}])</pre></div><div data-t="suskeyhose Is there an equivalent to select-keys? I&apos;m currently trying to translate some of my vanilla clojure code to using specter (great library by the way, I use it in almost all my projects), and trying to navigate to a view of all the values in a map where the key for it is contained in some collection seems to me to be a not-uncommon usecase. I&apos;ve tried a couple of solutions for it, from using  (apply multi-path (map keypath coll))  to  (filterer (comp set-name first))  and no matter what I do, the performance is always at least twice as poor as just calling  select-keys . I&apos;ve been perusing the docs, but nothing is jumping out at me."><span class="u" id="1558890665.002700">2019:05:26 17:11:05           suskeyhose </span><span>Is there an equivalent to select-keys? I&apos;m currently trying to translate some of my vanilla clojure code to using specter (great library by the way, I use it in almost all my projects), and trying to navigate to a view of all the values in a map where the key for it is contained in some collection seems to me to be a not-uncommon usecase. I&apos;ve tried a couple of solutions for it, from using </span><code>(apply multi-path (map keypath coll))</code><span> to </span><code>(filterer (comp set-name first))</code><span> and no matter what I do, the performance is always at least twice as poor as just calling </span><code>select-keys</code><span>. I&apos;ve been perusing the docs, but nothing is jumping out at me.</span></div><div data-t="suskeyhose I see that  submap  is what I was looking for"><span class="u" id="1558891897.003000">2019:05:26 17:31:37           suskeyhose </span><span>I see that </span><code>submap</code><span> is what I was looking for</span></div><div data-t="suskeyhose submap  has much more acceptable performance, being only slightly slower than the  select-keys  implementation. Again, thanks for the library!"><span class="u" id="1558892017.003800">2019:05:26 17:33:37           suskeyhose </span><code>submap</code><span> has much more acceptable performance, being only slightly slower than the </span><code>select-keys</code><span> implementation. Again, thanks for the library!</span></div><div data-t="nathanmarz @suskeyhose thanks, glad you&apos;re finding it useful"><span class="u" id="1559002056.004200">2019:05:28 00:07:36           nathanmarz </span><span>@suskeyhose thanks, glad you&apos;re finding it useful</span></div><div data-t="lvh Is there a way to run specter but without eval being called ever (I&apos;m trying to get it working under Graal -- and for my recursive path, closed-code still ends up getting called, and that relies on eval even when using  select* )"><span class="u" id="1559766329.001000">2019:06:05 20:25:29                  lvh </span><span>Is there a way to run specter but without eval being called ever (I&apos;m trying to get it working under Graal -- and for my recursive path, closed-code still ends up getting called, and that relies on eval even when using </span><code>select*</code><span>)</span></div><div data-t="nathanmarz @lvh if you avoid all the macros eval won&apos;t be called"><span class="u" id="1559767596.001600">2019:06:05 20:46:36           nathanmarz </span><span>@lvh if you avoid all the macros eval won&apos;t be called</span></div><div data-t="nathanmarz recursive-path  calls down to  path"><span class="u" id="1559767601.001800">2019:06:05 20:46:41           nathanmarz </span><code>recursive-path</code><span> calls down to </span><code>path</code></div><div data-t="nathanmarz which is what generates code that calls eval"><span class="u" id="1559767613.002100">2019:06:05 20:46:53           nathanmarz </span><span>which is what generates code that calls eval</span></div><div data-t="nathanmarz recursive-path  is just a helper, so you could probably construct a recursive path with no dynamic parameters by making your own helper"><span class="u" id="1559767706.003100">2019:06:05 20:48:26           nathanmarz </span><code>recursive-path</code><span> is just a helper, so you could probably construct a recursive path with no dynamic parameters by making your own helper</span></div><div data-t="lvh Is there a way to &quot;prime&quot; a navigator applied to a data structure? Context: I have a data structure which I&apos;ll be calling setval on a pile of times, always with different values but always at the same locations, so I&apos;m wondering if there are efficiency gains to be had by only navigating once and then reusing that. Disclaimer: I don&apos;t understand the caching magic at all so maybe specter is essentially already doing that?"><span class="u" id="1560886499.006000">2019:06:18 19:34:59                  lvh </span><span>Is there a way to &quot;prime&quot; a navigator applied to a data structure? Context: I have a data structure which I&apos;ll be calling setval on a pile of times, always with different values but always at the same locations, so I&apos;m wondering if there are efficiency gains to be had by only navigating once and then reusing that. Disclaimer: I don&apos;t understand the caching magic at all so maybe specter is essentially already doing that?</span></div><div data-t="nathanmarz @lvh the inline compiler is already ensuring that the most optimal path possible is used for all runs of the callsite after the first"><span class="u" id="1560898069.007300">2019:06:18 22:47:49           nathanmarz </span><span>@lvh the inline compiler is already ensuring that the most optimal path possible is used for all runs of the callsite after the first</span></div><div data-t="nathanmarz you can tighten things up for certain cases by using  ^:direct-nav"><span class="u" id="1560898121.007600">2019:06:18 22:48:41           nathanmarz </span><span>you can tighten things up for certain cases by using </span><code>^:direct-nav</code></div><div data-t="lvh Awesome, thanks :)"><span class="u" id="1560902038.008000">2019:06:18 23:53:58                  lvh </span><span>Awesome, thanks :)</span></div><div data-t="oskarkv I don&apos;t understand  compact .  😛"><span class="u" id="1562423725.008400">2019:07:06 14:35:25              oskarkv </span><span>I don&apos;t understand </span><code>compact</code><span>. </span><b>😛</b></div><div data-t="oskarkv Can anyone explain this?
 &gt; (s/setval (s/regex-nav #&quot;(?&lt;=( |^))[a-z]&quot;) &quot;_&quot; &quot;hello world&quot;)
&quot;_ello _orld&quot;
&gt; (s/select (s/regex-nav #&quot;(?&lt;=( |^))[a-z]&quot;) &quot;hello world&quot;)
[[&quot;h&quot; &quot;&quot;] [&quot;e&quot; &quot;&quot;] [&quot;l&quot; &quot;&quot;] [&quot;l&quot; &quot;&quot;] [&quot;o&quot; &quot;&quot;] [&quot;w&quot; &quot; &quot;] [&quot;o&quot; &quot;&quot;] [&quot;r&quot; &quot;&quot;] [&quot;l&quot; &quot;&quot;] [&quot;d&quot; &quot;&quot;]]
"><span class="u" id="1562425255.009400">2019:07:06 15:00:55              oskarkv </span><span>Can anyone explain this?
</span><pre>&gt; (s/setval (s/regex-nav #&quot;(?&lt;=( |^))[a-z]&quot;) &quot;_&quot; &quot;hello world&quot;)
&quot;_ello _orld&quot;
&gt; (s/select (s/regex-nav #&quot;(?&lt;=( |^))[a-z]&quot;) &quot;hello world&quot;)
[[&quot;h&quot; &quot;&quot;] [&quot;e&quot; &quot;&quot;] [&quot;l&quot; &quot;&quot;] [&quot;l&quot; &quot;&quot;] [&quot;o&quot; &quot;&quot;] [&quot;w&quot; &quot; &quot;] [&quot;o&quot; &quot;&quot;] [&quot;r&quot; &quot;&quot;] [&quot;l&quot; &quot;&quot;] [&quot;d&quot; &quot;&quot;]]
</pre></div><div data-t="oskarkv Oh, it&apos;s because  re-seq  looks at &quot;hello world&quot;, then &quot;ello world&quot;, etc."><span class="u" id="1562426324.010100">2019:07:06 15:18:44              oskarkv </span><span>Oh, it&apos;s because </span><code>re-seq</code><span> looks at &quot;hello world&quot;, then &quot;ello world&quot;, etc.</span></div><div data-t="currentoor what can you do with the result of  traverse  that you can’t do with the result of  select ?"><span class="u" id="1562437326.010600">2019:07:06 18:22:06           currentoor </span><span>what can you do with the result of </span><code>traverse</code><span> that you can’t do with the result of </span><code>select</code><span>?</span></div><div data-t="currentoor also, is there a simple way, given a sequence, to remove the first match and leave the rest?"><span class="u" id="1562521732.011500">2019:07:07 17:48:52           currentoor </span><span>also, is there a simple way, given a sequence, to remove the first match and leave the rest?</span></div><div data-t="currentoor (specter/setval [specter/ALL (specter/pred= 1)] specter/NONE [1 2 1 3])"><span class="u" id="1562521750.011700">2019:07:07 17:49:10           currentoor </span><code>(specter/setval [specter/ALL (specter/pred= 1)] specter/NONE [1 2 1 3])</code></div><div data-t="currentoor this removes all the matches"><span class="u" id="1562521757.012000">2019:07:07 17:49:17           currentoor </span><span>this removes all the matches</span></div><div data-t="oskarkv @currentoor In that case you can do  (s/setval [(s/filterer (s/pred= 1)) s/FIRST] s/NONE [1 2 1 3])"><span class="u" id="1562526392.012500">2019:07:07 19:06:32              oskarkv </span><span>@currentoor In that case you can do </span><code>(s/setval [(s/filterer (s/pred= 1)) s/FIRST] s/NONE [1 2 1 3])</code></div><div data-t="currentoor cool thanks!"><span class="u" id="1562526406.012700">2019:07:07 19:06:46           currentoor </span><span>cool thanks!</span></div><div data-t="oskarkv Or, hm it doesn&apos;t work as I expected"><span class="u" id="1562526502.013100">2019:07:07 19:08:22              oskarkv </span><span>Or, hm it doesn&apos;t work as I expected</span></div><div data-t="oskarkv game.core&gt; (s/setval [(s/filterer (s/pred= 1)) s/FIRST] s/NONE [1 2 1 3])
[1 2 3]
 
I would expect  [2 1 3]  out"><span class="u" id="1562526759.013600">2019:07:07 19:12:39              oskarkv </span><pre>game.core&gt; (s/setval [(s/filterer (s/pred= 1)) s/FIRST] s/NONE [1 2 1 3])
[1 2 3]
</pre><span>
I would expect </span><code>[2 1 3]</code><span> out</span></div><div data-t="oskarkv @currentoor Did you notice?"><span class="u" id="1562526774.014000">2019:07:07 19:12:54              oskarkv </span><span>@currentoor Did you notice?</span></div><div data-t="currentoor yeah i would too"><span class="u" id="1562526868.014200">2019:07:07 19:14:28           currentoor </span><span>yeah i would too</span></div><div data-t="currentoor but actually i just need to remove one occurrence of an element"><span class="u" id="1562526892.015000">2019:07:07 19:14:52           currentoor </span><span>but actually i just need to remove one occurrence of an element</span></div><div data-t="currentoor so this works"><span class="u" id="1562526896.015200">2019:07:07 19:14:56           currentoor </span><span>so this works</span></div><div data-t="oskarkv hehe"><span class="u" id="1562526899.015400">2019:07:07 19:14:59              oskarkv </span><span>hehe</span></div><div data-t="nathanmarz @currentoor  traverse  is more efficient than  select  if you just want to reduce over the navigated values"><span class="u" id="1562549711.016000">2019:07:08 01:35:11           nathanmarz </span><span>@currentoor </span><code>traverse</code><span> is more efficient than </span><code>select</code><span> if you just want to reduce over the navigated values</span></div><div data-t="ben.mumford given a nested data structure (values could be strings, nil, vectors of maps or maps) what is the best way to prune the tree so that nil entries, empty map entries, empty vectors are removed?"><span class="u" id="1562851234.017600">2019:07:11 13:20:34          ben.mumford </span><span>given a nested data structure (values could be strings, nil, vectors of maps or maps) what is the best way to prune the tree so that nil entries, empty map entries, empty vectors are removed?</span></div><div data-t="ben.mumford (do-something {:a {:aa 1}                                             
     :b {:ba -1                                             
         :bb 2                                              
         :bc nil
         :bd &quot;&quot;
         :be []
         :bf {}
         :bg {:bga nil}
         :bh [nil]
         :bi [{}]
         :bj [{:bja nil}]}
     :c nil
     :d &quot;&quot;
     :e []
     :f {}
     :g {:ga nil}
     :h [nil]
     :i [{}]
     :j [{:ja nil}]}
=&gt;
{:a {:aa 1} 
     :b {:ba -1 
         :bb 2}}
"><span class="u" id="1562851309.018500">2019:07:11 13:21:49          ben.mumford </span><pre>(do-something {:a {:aa 1}                                             
     :b {:ba -1                                             
         :bb 2                                              
         :bc nil
         :bd &quot;&quot;
         :be []
         :bf {}
         :bg {:bga nil}
         :bh [nil]
         :bi [{}]
         :bj [{:bja nil}]}
     :c nil
     :d &quot;&quot;
     :e []
     :f {}
     :g {:ga nil}
     :h [nil]
     :i [{}]
     :j [{:ja nil}]}
=&gt;
{:a {:aa 1} 
     :b {:ba -1 
         :bb 2}}
</pre></div><div data-t="ben.mumford any help would be much appreciated  🙂"><span class="u" id="1562851369.019000">2019:07:11 13:22:49          ben.mumford </span><span>any help would be much appreciated </span><b>🙂</b></div><div data-t="nathanmarz @ben.mumford620 here&apos;s how to do that:
 (def COMPACTED-VALS-PATH
  (recursive-path [] p
    (continue-then-stay
      (cond-path
        map? [(compact MAP-VALS) p]
        vector? [(compact ALL) p]
        ))))
        
(setval [COMPACTED-VALS-PATH #(or (nil? %) (= &quot;&quot; %))] NONE data)
"><span class="u" id="1562869459.019500">2019:07:11 18:24:19           nathanmarz </span><span>@ben.mumford620 here&apos;s how to do that:
</span><pre>(def COMPACTED-VALS-PATH
  (recursive-path [] p
    (continue-then-stay
      (cond-path
        map? [(compact MAP-VALS) p]
        vector? [(compact ALL) p]
        ))))
        
(setval [COMPACTED-VALS-PATH #(or (nil? %) (= &quot;&quot; %))] NONE data)
</pre></div><div data-t="ben.mumford cheers pal"><span class="u" id="1562916366.021000">2019:07:12 07:26:06               ben.mumford </span><span>cheers pal</span></div><div data-t="nathanmarz you can insert a  MAP-VALS  at the start of the path to make sure the top-level data structure stays an empty map instead of becoming NONE if everything gets compacted"><span class="u" id="1562869556.020400">2019:07:11 18:25:56           nathanmarz </span><span>you can insert a </span><code>MAP-VALS</code><span> at the start of the path to make sure the top-level data structure stays an empty map instead of becoming NONE if everything gets compacted</span></div><div data-t="dharrigan that&apos;s pretty awesome"><span class="u" id="1562869673.020700">2019:07:11 18:27:53            dharrigan </span><span>that&apos;s pretty awesome</span></div><div data-t="donavan Hi, just started using Specter and so far it&apos;s been amazing. Replaced my naive handwritten code in less lines and it was faster!

One issue I&apos;m having though relates to CLJS not supporting  apply  with more than 21 args for  IFn  here:  https://github.com/clojure/clojurescript/blob/master/src/main/cljs/cljs/core.cljs#L2054  and  defdynamicnav  via  multi-path  whose var has meta (though I suspect the  IFn  limitation would be hit without  MetaFn  anyway).

So this is maybe an abuse of  multi-path  but I would like to dynamically create a collection of paths that may be bigger than the 21 count limit. Before I manually chunk the paths and apply them in stages I was wondering if anyone had noticed this before and had a simple workaround. Or maybe chunking the paths is the simple workaround..."><span class="u" id="1563360405.028600">2019:07:17 10:46:45              donavan </span><span>Hi, just started using Specter and so far it&apos;s been amazing. Replaced my naive handwritten code in less lines and it was faster!

One issue I&apos;m having though relates to CLJS not supporting </span><code>apply</code><span> with more than 21 args for </span><code>IFn</code><span> here: </span><a href="https://github.com/clojure/clojurescript/blob/master/src/main/cljs/cljs/core.cljs#L2054">https://github.com/clojure/clojurescript/blob/master/src/main/cljs/cljs/core.cljs#L2054</a><span> and </span><code>defdynamicnav</code><span> via </span><code>multi-path</code><span> whose var has meta (though I suspect the </span><code>IFn</code><span> limitation would be hit without </span><code>MetaFn</code><span> anyway).

So this is maybe an abuse of </span><code>multi-path</code><span> but I would like to dynamically create a collection of paths that may be bigger than the 21 count limit. Before I manually chunk the paths and apply them in stages I was wondering if anyone had noticed this before and had a simple workaround. Or maybe chunking the paths is the simple workaround...</span></div><div data-t="donavan Actually I can just reduce over the paths as that is what would happen with  (apply multi-path...  anyway!"><span class="u" id="1563361090.028800">2019:07:17 10:58:10                   donavan </span><span>Actually I can just reduce over the paths as that is what would happen with </span><code>(apply multi-path...</code><span> anyway!</span></div><div data-t="oskarkv I want to make a function that is kind of like  merge-with , but recursive, i.e. if I call this function, let&apos;s call it  f , like
 (f + {:a {:b 1 :c 2} :b {:d 4 :e 5}} {:a {:b 3 :c 3} :b {:d 5 :e 5}}) 
I want the output  {:a {:b 4 :c 5} :b {:d 9 :e 10}} 
Can specter help with that? I don&apos;t see how, but it&apos;s very possible I&apos;m wrong."><span class="u" id="1563890114.002900">2019:07:23 13:55:14              oskarkv </span><span>I want to make a function that is kind of like </span><code>merge-with</code><span>, but recursive, i.e. if I call this function, let&apos;s call it </span><code>f</code><span>, like
</span><pre>(f + {:a {:b 1 :c 2} :b {:d 4 :e 5}} {:a {:b 3 :c 3} :b {:d 5 :e 5}})</pre><span>
I want the output </span><code>{:a {:b 4 :c 5} :b {:d 9 :e 10}}</code><span>
Can specter help with that? I don&apos;t see how, but it&apos;s very possible I&apos;m wrong.</span></div><div data-t="oskarkv It was not too hard to write without specter, so I doubt specter will help much either way  😛"><span class="u" id="1563891772.003700">2019:07:23 14:22:52              oskarkv </span><span>It was not too hard to write without specter, so I doubt specter will help much either way </span><b>😛</b></div><div data-t="oskarkv It would be cool if  transform  could take several structures, like map does, and apply the function to all the elements of all the structures."><span class="u" id="1563894823.004600">2019:07:23 15:13:43              oskarkv </span><span>It would be cool if </span><code>transform</code><span> could take several structures, like map does, and apply the function to all the elements of all the structures.</span></div><div data-t="oskarkv Then my function would be trivial with specter  😛"><span class="u" id="1563895059.004900">2019:07:23 15:17:39              oskarkv </span><span>Then my function would be trivial with specter </span><b>😛</b></div><div data-t="jsa-aerial I think I&apos;m confused."><span class="u" id="1565109577.006200">2019:08:06 16:39:37           jsa-aerial </span><span>I think I&apos;m confused.</span></div><div data-t="nathanmarz filterer  navigates to a sequence of all &quot;locations&quot; in the sequence matching the predicate"><span class="u" id="1565110540.007100">2019:08:06 16:55:40           nathanmarz </span><code>filterer</code><span> navigates to a sequence of all &quot;locations&quot; in the sequence matching the predicate</span></div><div data-t="nathanmarz with index 0 being the first location, index 1 being the second, and so on"><span class="u" id="1565110553.007500">2019:08:06 16:55:53           nathanmarz </span><span>with index 0 being the first location, index 1 being the second, and so on</span></div><div data-t="nathanmarz transformations to the sequence navigated to by  filterer  can only affect those locations"><span class="u" id="1565110572.007900">2019:08:06 16:56:12           nathanmarz </span><span>transformations to the sequence navigated to by </span><code>filterer</code><span> can only affect those locations</span></div><div data-t="nathanmarz increasing the size of the sequence just causes indexes past the last location to be ignored"><span class="u" id="1565110611.008400">2019:08:06 16:56:51           nathanmarz </span><span>increasing the size of the sequence just causes indexes past the last location to be ignored</span></div><div data-t="nathanmarz there&apos;s a special case for when you reduce the size of the sequence to set the removed locations to  NONE"><span class="u" id="1565110646.009100">2019:08:06 16:57:26           nathanmarz </span><span>there&apos;s a special case for when you reduce the size of the sequence to set the removed locations to </span><code>NONE</code></div><div data-t="jsa-aerial Hmmmm, OK. So, there is no &apos;obvious / out of the box&apos; way to insert? Using a combo of  index-vals  and  before-index  works fine, is that the &apos;right way&apos; to do this?"><span class="u" id="1565111741.011600">2019:08:06 17:15:41           jsa-aerial </span><span>Hmmmm, OK. So, there is no &apos;obvious / out of the box&apos; way to insert? Using a combo of </span><code>index-vals</code><span> and </span><code>before-index</code><span> works fine, is that the &apos;right way&apos; to do this?</span></div><div data-t="nathanmarz zipper navigators are good for this use case"><span class="u" id="1565112583.012000">2019:08:06 17:29:43           nathanmarz </span><span>zipper navigators are good for this use case</span></div><div data-t="nathanmarz com.rpl.specter.zipper"><span class="u" id="1565112609.012200">2019:08:06 17:30:09           nathanmarz </span><code>com.rpl.specter.zipper</code></div><div data-t="nathanmarz user=&gt; (setval [z/VECTOR-ZIP (z/find-first #(= &quot;b&quot; %)) z/INNER-LEFT] [77] [&quot;a&quot; &quot;b&quot; &quot;c&quot;])
[&quot;a&quot; 77 &quot;b&quot; &quot;c&quot;]
"><span class="u" id="1565112808.012400">2019:08:06 17:33:28           nathanmarz </span><pre>user=&gt; (setval [z/VECTOR-ZIP (z/find-first #(= &quot;b&quot; %)) z/INNER-LEFT] [77] [&quot;a&quot; &quot;b&quot; &quot;c&quot;])
[&quot;a&quot; 77 &quot;b&quot; &quot;c&quot;]
</pre></div><div data-t="jsa-aerial 😮"><span class="u" id="1565114369.012600">2019:08:06 17:59:29           jsa-aerial </span><b>😮</b></div><div data-t="jsa-aerial Presumably that is much more efficient as well?"><span class="u" id="1565114442.013000">2019:08:06 18:00:42           jsa-aerial </span><span>Presumably that is much more efficient as well?</span></div><div data-t="nathanmarz unclear"><span class="u" id="1565117954.013200">2019:08:06 18:59:14           nathanmarz </span><span>unclear</span></div><div data-t="nathanmarz zippers do have overhead"><span class="u" id="1565117968.013500">2019:08:06 18:59:28           nathanmarz </span><span>zippers do have overhead</span></div><div data-t="nathanmarz the  com.rpl.specter.zipper  namespace is not totally fleshed out, so there are other navigators that could be added to make it more efficient"><span class="u" id="1565118005.014300">2019:08:06 19:00:05           nathanmarz </span><span>the </span><code>com.rpl.specter.zipper</code><span> namespace is not totally fleshed out, so there are other navigators that could be added to make it more efficient</span></div><div data-t="nathanmarz such as the zipper equivalent of  before-index  instead of doing  INNER-LEFT"><span class="u" id="1565118030.014900">2019:08:06 19:00:30           nathanmarz </span><span>such as the zipper equivalent of </span><code>before-index</code><span> instead of doing </span><code>INNER-LEFT</code></div><div data-t="lellis Hi All, i have a question. Why when use this symbol ’[?e :a  true] inside a select nav its resolve to [?e :a  G__161070]? ex:  (select [ALL (pred #(= (log/spy %) (log/spy &apos;[?e true])))]  [&apos;[?e true]])  return []."><span class="u" id="1565118354.016200">2019:08:06 19:05:54               lellis </span><span>Hi All, i have a question. Why when use this symbol ’[?e :a  true] inside a select nav its resolve to [?e :a  G__161070]? ex: </span><code>(select [ALL (pred #(= (log/spy %) (log/spy &apos;[?e true])))]  [&apos;[?e true]])</code><span> return [].</span></div><div data-t="puzzler Is there a variant of select that returns a lazy sequence instead of a vector? I&apos;ve tried things like (sequence (traverse ...)) but that doesn&apos;t work."><span class="u" id="1565736635.017900">2019:08:13 22:50:35              puzzler </span><span>Is there a variant of select that returns a lazy sequence instead of a vector? I&apos;ve tried things like (sequence (traverse ...)) but that doesn&apos;t work.</span></div><div data-t="puzzler No, I need a lazy sequence because I&apos;m producing a potentially large return value for a library API, and I don&apos;t know how people will consume it. But thanks for the info. I didn&apos;t realize select-first had early termination, since doc says it is no more efficient that select."><span class="u" id="1565738665.020100">2019:08:13 23:24:25              puzzler </span><span>No, I need a lazy sequence because I&apos;m producing a potentially large return value for a library API, and I don&apos;t know how people will consume it. But thanks for the info. I didn&apos;t realize select-first had early termination, since doc says it is no more efficient that select.</span></div><div data-t="puzzler For use case where you are substituting an existing get-in call where you want  a nil return value, would you use select-first, select-one, or would you use select-any and then call its return value with a function to convert NONE to nil?"><span class="u" id="1565739049.021100">2019:08:13 23:30:49              puzzler </span><span>For use case where you are substituting an existing get-in call where you want  a nil return value, would you use select-first, select-one, or would you use select-any and then call its return value with a function to convert NONE to nil?</span></div><div data-t="puzzler Or maybe just use select-any and stick (nil-&gt;val nil) at the end of the navigator?"><span class="u" id="1565740000.021600">2019:08:13 23:46:40              puzzler </span><span>Or maybe just use select-any and stick (nil-&gt;val nil) at the end of the navigator?</span></div><div data-t="puzzler Ah, select-any returns nil in that particular case anyway. Never mind."><span class="u" id="1565740297.022000">2019:08:13 23:51:37              puzzler </span><span>Ah, select-any returns nil in that particular case anyway. Never mind.</span></div><div data-t="nathanmarz @puzzler  select-one  is the same as  select-first  except it enforces that your path navigates to at most one value"><span class="u" id="1565742794.022800">2019:08:14 00:33:14           nathanmarz </span><span>@puzzler </span><code>select-one</code><span> is the same as </span><code>select-first</code><span> except it enforces that your path navigates to at most one value</span></div><div data-t="nathanmarz corrected the wiki entry on  select-first , thanks for letting me know"><span class="u" id="1565742994.023200">2019:08:14 00:36:34           nathanmarz </span><span>corrected the wiki entry on </span><code>select-first</code><span>, thanks for letting me know</span></div><div data-t="nathanmarz you probably want  select-one  for your use case"><span class="u" id="1565743122.023500">2019:08:14 00:38:42           nathanmarz </span><span>you probably want </span><code>select-one</code><span> for your use case</span></div><div data-t="puzzler I recall a time when you sketched out a navigator for transforming a nested map in such a way that on the way out, it would recursively delete any keys with empty maps. I can&apos;t find it in the slack logs. Do you by any chance have a handy pointer to that?"><span class="u" id="1565758920.025000">2019:08:14 05:02:00              puzzler </span><span>I recall a time when you sketched out a navigator for transforming a nested map in such a way that on the way out, it would recursively delete any keys with empty maps. I can&apos;t find it in the slack logs. Do you by any chance have a handy pointer to that?</span></div><div data-t="ben.mumford i asked a similar question here and on SO and posted nathan&apos;s answer:  https://stackoverflow.com/a/57002777/1185536"><span class="u" id="1565770202.025600">2019:08:14 08:10:02          ben.mumford </span><span>i asked a similar question here and on SO and posted nathan&apos;s answer: </span><a href="https://stackoverflow.com/a/57002777/1185536">https://stackoverflow.com/a/57002777/1185536</a></div><div data-t="puzzler I saw that, but it looks like the answers are all about scanning through a whole nested map structure removing nil leaves. That&apos;s not really what I want. I want things to get removed if the output of the transformation is NONE, and that causes its map to be empty, and so on."><span class="u" id="1565770334.027000">2019:08:14 08:12:14              puzzler </span><span>I saw that, but it looks like the answers are all about scanning through a whole nested map structure removing nil leaves. That&apos;s not really what I want. I want things to get removed if the output of the transformation is NONE, and that causes its map to be empty, and so on.</span></div><div data-t="puzzler So something like: (setval (keypath-remove-empties :a :c :d) NONE {:b 1, :a {:c {:d 0}}}) gives back {:b 1}"><span class="u" id="1565770448.028900">2019:08:14 08:14:08              puzzler </span><span>So something like: (setval (keypath-remove-empties :a :c :d) NONE {:b 1, :a {:c {:d 0}}}) gives back {:b 1}</span></div><div data-t="schmee @puzzler I believe you’re looking for  compact ?
 user=&gt; (sp/setval (sp/compact :a :c :d) sp/NONE {:b 1, :a {:c {:d 0}}})
{:b 1}
"><span class="u" id="1565773135.029400">2019:08:14 08:58:55               schmee </span><span>@puzzler I believe you’re looking for </span><code>compact</code><span>?
</span><pre>user=&gt; (sp/setval (sp/compact :a :c :d) sp/NONE {:b 1, :a {:c {:d 0}}})
{:b 1}
</pre></div><div data-t="puzzler @schmee Yes, thanks!"><span class="u" id="1565782054.029700">2019:08:14 11:27:34              puzzler </span><span>@schmee Yes, thanks!</span></div><div data-t="nathanmarz you probably don&apos;t want to return NONE if the top-level structure becomes empty, so something like  (setval [:a (compact :c :d)] NONE data)  is generally the pattern to use"><span class="u" id="1565786929.030900">2019:08:14 12:48:49           nathanmarz </span><span>you probably don&apos;t want to return NONE if the top-level structure becomes empty, so something like </span><code>(setval [:a (compact :c :d)] NONE data)</code><span> is generally the pattern to use</span></div><div data-t="lxsli I&apos;ve finally figured out why I can&apos;t use  filterer  after MAP-KEYS; it expects a sequence where MAP-KEYS navigates to a view of many keyword (for me) elements"><span class="u" id="1565792334.031700">2019:08:14 14:18:54                lxsli </span><span>I&apos;ve finally figured out why I can&apos;t use </span><code>filterer</code><span> after MAP-KEYS; it expects a sequence where MAP-KEYS navigates to a view of many keyword (for me) elements</span></div><div data-t="lxsli Which is better:  (setval [MAP-KEYS #(#{&quot;a&quot;} (namespace %))] NONE mymap) 
or:  (setval [(filterer [FIRST NAMESPACE #{&quot;a&quot;}]) MAP-KEYS] NONE mymap)  please?"><span class="u" id="1565792414.033300">2019:08:14 14:20:14                lxsli </span><span>Which is better: </span><code>(setval [MAP-KEYS #(#{&quot;a&quot;} (namespace %))] NONE mymap)</code><span>
or: </span><code>(setval [(filterer [FIRST NAMESPACE #{&quot;a&quot;}]) MAP-KEYS] NONE mymap)</code><span> please?</span></div><div data-t="lxsli or y&apos;know something else"><span class="u" id="1565792430.033500">2019:08:14 14:20:30                lxsli </span><span>or y&apos;know something else</span></div><div data-t="lxsli The difference seems more substantial when using  select ; the latter form allows me to get the whole entries whereas the former has irrevocably descended to the keys"><span class="u" id="1565792741.034600">2019:08:14 14:25:41                lxsli </span><span>The difference seems more substantial when using </span><code>select</code><span>; the latter form allows me to get the whole entries whereas the former has irrevocably descended to the keys</span></div><div data-t="lxsli My initial attempt btw was something like  (setval [MAP-KEYS (filterer NAMESPACE #{&quot;a&quot;})] NONE mymap)"><span class="u" id="1565792788.035400">2019:08:14 14:26:28                lxsli </span><span>My initial attempt btw was something like </span><code>(setval [MAP-KEYS (filterer NAMESPACE #{&quot;a&quot;})] NONE mymap)</code></div><div data-t="nathanmarz @alee you can also do  (setval [MAP-KEYS (selected? NAMESPACE (pred= &quot;a&quot;))] NONE mymap)"><span class="u" id="1565797375.035900">2019:08:14 15:42:55           nathanmarz </span><span>@alee you can also do </span><code>(setval [MAP-KEYS (selected? NAMESPACE (pred= &quot;a&quot;))] NONE mymap)</code></div><div data-t="lxsli Cracking, thank you!"><span class="u" id="1565853350.036100">2019:08:15 07:15:50                lxsli </span><span>Cracking, thank you!</span></div><div data-t="Pragyan Tripathi I am trying to write a merge method to generate CSS styles dynamically. This method should take breakpoints, and styles param and generates a map which can be used for styling using stylefy.

I am trying to do this using specter, but unable to get desired results. The method should work as follows:

 (def breakpoints [320 600 1280])
(def style {:padding-top [&quot;20px&quot; &quot;30px&quot; &quot;40px&quot; &quot;50px&quot;]
            :margin &quot;30px&quot;
           })

(merge-style breakpoints style)
 
The output should look like the following:

 {:padding-top &quot;20px&quot;
 :margin &quot;30px&quot;
 ::stylefy/media {{:min-width &quot;320px&quot;} {:padding-top &quot;30px&quot;}
                  {:min-width &quot;600px&quot;} {:padding-top &quot;40px&quot;}
                  {:min-width &quot;1280px&quot;} {:padding-top &quot;50px&quot;}}
 }
"><span class="u" id="1566217831.037000">2019:08:19 12:30:31     Pragyan Tripathi </span><span>I am trying to write a merge method to generate CSS styles dynamically. This method should take breakpoints, and styles param and generates a map which can be used for styling using stylefy.

I am trying to do this using specter, but unable to get desired results. The method should work as follows:

</span><pre>(def breakpoints [320 600 1280])
(def style {:padding-top [&quot;20px&quot; &quot;30px&quot; &quot;40px&quot; &quot;50px&quot;]
            :margin &quot;30px&quot;
           })

(merge-style breakpoints style)
</pre><span>
The output should look like the following:

</span><pre>{:padding-top &quot;20px&quot;
 :margin &quot;30px&quot;
 ::stylefy/media {{:min-width &quot;320px&quot;} {:padding-top &quot;30px&quot;}
                  {:min-width &quot;600px&quot;} {:padding-top &quot;40px&quot;}
                  {:min-width &quot;1280px&quot;} {:padding-top &quot;50px&quot;}}
 }
</pre></div><div data-t="Pragyan Tripathi The code I have written till now is as follows:
 (defn merge-style
  [breakpoints style]
  (let [media-queries (s/transform [s/ALL] #(hash-map :min-width (str %1 &quot;px&quot;)) breakpoints)]
  breakpoints))
"><span class="u" id="1566219430.037700">2019:08:19 12:57:10     Pragyan Tripathi </span><span>The code I have written till now is as follows:
</span><pre>(defn merge-style
  [breakpoints style]
  (let [media-queries (s/transform [s/ALL] #(hash-map :min-width (str %1 &quot;px&quot;)) breakpoints)]
  breakpoints))
</pre></div><div data-t="Pragyan Tripathi @U3L6TFEJF Thanks a lot for the suggestions. I have been able to solve the problem I had with following method:
 (defn- get-media-queries
  [breakpoints styles]
  (let [base-style (s/transform [s/MAP-VALS] #(%1 0) styles)
        styles-maps (s/setval [s/MAP-VALS empty?] s/NONE (s/setval [s/MAP-VALS s/FIRST] s/NONE styles))
        styles-list (map (fn [[key val]] (map #(hash-map key %1) val)) styles-maps)
        styles-final (apply vdu/merge-maps styles-list)
        breaks (map #(hash-map :min-width %1) breakpoints)
        styles-merged (into {} (mapv vector breaks styles-final))
        ]
    (assoc base-style ::stylefy/media styles-merged)))
"><span class="u" id="1566369135.041800">2019:08:21 06:32:15          Pragyan Tripathi </span><span>@U3L6TFEJF Thanks a lot for the suggestions. I have been able to solve the problem I had with following method:
</span><pre>(defn- get-media-queries
  [breakpoints styles]
  (let [base-style (s/transform [s/MAP-VALS] #(%1 0) styles)
        styles-maps (s/setval [s/MAP-VALS empty?] s/NONE (s/setval [s/MAP-VALS s/FIRST] s/NONE styles))
        styles-list (map (fn [[key val]] (map #(hash-map key %1) val)) styles-maps)
        styles-final (apply vdu/merge-maps styles-list)
        breaks (map #(hash-map :min-width %1) breakpoints)
        styles-merged (into {} (mapv vector breaks styles-final))
        ]
    (assoc base-style ::stylefy/media styles-merged)))
</pre></div><div data-t="Pragyan Tripathi As I am a beginner in clojurescript. I am finding it hard to solve this in functional way using specter."><span class="u" id="1566219492.038700">2019:08:19 12:58:12     Pragyan Tripathi </span><span>As I am a beginner in clojurescript. I am finding it hard to solve this in functional way using specter.</span></div><div data-t="schmee creating new data structures out of two existing ones it not really something Specter is suited for, it is better suited for transformations of an existing data structure"><span class="u" id="1566220042.039700">2019:08:19 13:07:22               schmee </span><span>creating new data structures out of two existing ones it not really something Specter is suited for, it is better suited for transformations of an existing data structure</span></div><div data-t="schmee this is probably easier to solve with regular Clojure code"><span class="u" id="1566220057.040200">2019:08:19 13:07:37               schmee </span><span>this is probably easier to solve with regular Clojure code</span></div><div data-t="Pragyan Tripathi got it. I am trying to learn specter so may be that’s why I thinking in those terms all the time. Will figure out a way to in normal clojure code. Thanks."><span class="u" id="1566220561.041700">2019:08:19 13:16:01     Pragyan Tripathi </span><span>got it. I am trying to learn specter so may be that’s why I thinking in those terms all the time. Will figure out a way to in normal clojure code. Thanks.</span></div><div data-t="Petrus Theron Can Specter emit reductions over a lensed collection? E.g.  (something-specter [ALL :amount (reducer +)] [{:amount 10.0M} {:amount 20.0M} ...]) =&gt; [{:amount 10.0M} {:amount 30.0M} ...]"><span class="u" id="1566467177.044100">2019:08:22 09:46:17        Petrus Theron </span><span>Can Specter emit reductions over a lensed collection? E.g. </span><code>(something-specter [ALL :amount (reducer +)] [{:amount 10.0M} {:amount 20.0M} ...]) =&gt; [{:amount 10.0M} {:amount 30.0M} ...]</code></div><div data-t="Petrus Theron E.g. w/o Specter:
 (reductions
    (fn [[latest acc] [when amount]]
      [when (+ acc amount)])
    [0 0.0M]
    (zipmap (range 10) (range 10)))
=&gt; ([0 0.0M] [0 0.0M] [7 7.0M] [1 8.0M] [4 12.0M] [6 18.0M] [3 21.0M] [2 23.0M] [9 32.0M] [5 37.0M] [8 45.0M])
"><span class="u" id="1566467224.044400">2019:08:22 09:47:04        Petrus Theron </span><span>E.g. w/o Specter:
</span><pre>(reductions
    (fn [[latest acc] [when amount]]
      [when (+ acc amount)])
    [0 0.0M]
    (zipmap (range 10) (range 10)))
=&gt; ([0 0.0M] [0 0.0M] [7 7.0M] [1 8.0M] [4 12.0M] [6 18.0M] [3 21.0M] [2 23.0M] [9 32.0M] [5 37.0M] [8 45.0M])
</pre></div><div data-t="lxsli @petrus Could  traversed  be what you&apos;re after?"><span class="u" id="1566474904.044800">2019:08:22 11:55:04                lxsli </span><span>@petrus Could </span><code>traversed</code><span> be what you&apos;re after?</span></div><div data-t="Petrus Theron Thanks @U9MDWLP5Y  traversed  looks like it might work  🙂   (select-any (traversed ALL +) [1 2 3 4])"><span class="u" id="1566477572.045500">2019:08:22 12:39:32             Petrus Theron </span><span>Thanks @U9MDWLP5Y </span><code>traversed</code><span> looks like it might work </span><b>🙂</b><span> </span><code>(select-any (traversed ALL +) [1 2 3 4])</code></div><div data-t="lxsli Alternatively you might get mileage out of  collect"><span class="u" id="1566474945.045100">2019:08:22 11:55:45                lxsli </span><span>Alternatively you might get mileage out of </span><code>collect</code></div><div data-t="lxsli Not an expert myself so no promises"><span class="u" id="1566474967.045400">2019:08:22 11:56:07                lxsli </span><span>Not an expert myself so no promises</span></div><div data-t="jvtrigueros I&apos;m trying to use specter to help me generate a map structure that can be converted to an XML string using  clojure.data.xml . With a map function, I can do this:
 (mapv (fn [[k v]] {:tag k :content [v]})
      {:A 1
       :B 2
       :C 3})
;; =&gt; [{:tag :A, :content [1]} {:tag :B, :content [2]} {:tag :C, :content [3]}]
 
I tried to do something similar with  transform :
 (r/transform
  r/ALL
  (fn [[k v]] {:tag k :content [v]})
  {:A 1
   :B 2
   :C 3})
;; Execution error (UnsupportedOperationException) at com.rpl.specter.navs/eval18222$fn (navs.cljc:124).
nth not supported on this type: PersistentArrayMap
 
I don&apos;t understand the error that specter is giving me. Is it possible to do what I want to do with specter?"><span class="u" id="1567103740.004200">2019:08:29 18:35:40          jvtrigueros </span><span>I&apos;m trying to use specter to help me generate a map structure that can be converted to an XML string using </span><code>clojure.data.xml</code><span>. With a map function, I can do this:
</span><pre>(mapv (fn [[k v]] {:tag k :content [v]})
      {:A 1
       :B 2
       :C 3})
;; =&gt; [{:tag :A, :content [1]} {:tag :B, :content [2]} {:tag :C, :content [3]}]
</pre><span>
I tried to do something similar with </span><code>transform</code><span>:
</span><pre>(r/transform
  r/ALL
  (fn [[k v]] {:tag k :content [v]})
  {:A 1
   :B 2
   :C 3})
;; Execution error (UnsupportedOperationException) at com.rpl.specter.navs/eval18222$fn (navs.cljc:124).
nth not supported on this type: PersistentArrayMap
</pre><span>
I don&apos;t understand the error that specter is giving me. Is it possible to do what I want to do with specter?</span></div><div data-t="nathanmarz @jvtrigueros transform replaces navigated vals and otherwise leaves the structure the same"><span class="u" id="1567107553.004600">2019:08:29 19:39:13           nathanmarz </span><span>@jvtrigueros transform replaces navigated vals and otherwise leaves the structure the same</span></div><div data-t="nathanmarz since you are navigating to key/value pairs, it&apos;s expecting you to replace the key/value pairs with key/value pairs"><span class="u" id="1567107575.005100">2019:08:29 19:39:35           nathanmarz </span><span>since you are navigating to key/value pairs, it&apos;s expecting you to replace the key/value pairs with key/value pairs</span></div><div data-t="jvtrigueros I see"><span class="u" id="1567107583.005300">2019:08:29 19:39:43          jvtrigueros </span><span>I see</span></div><div data-t="nathanmarz for this particular use case specter isn&apos;t really relevant"><span class="u" id="1567107599.005600">2019:08:29 19:39:59           nathanmarz </span><span>for this particular use case specter isn&apos;t really relevant</span></div><div data-t="jvtrigueros I understand, I&apos;m using specter to select values in a deeply nested XML tree which worked great. I was trying to use it to generate the XML map datastructure as well.

I can simply do the  mapv  operation as the input map is fairly flat."><span class="u" id="1567107775.007300">2019:08:29 19:42:55          jvtrigueros </span><span>I understand, I&apos;m using specter to select values in a deeply nested XML tree which worked great. I was trying to use it to generate the XML map datastructure as well.

I can simply do the </span><code>mapv</code><span> operation as the input map is fairly flat.</span></div><div data-t="Ani Banerjee Does specter work with integer valued keys in int-map? Any issues to expect compared to keyword based maps?"><span class="u" id="1571957952.001800">2019:10:24 22:59:12         Ani Banerjee </span><span>Does specter work with integer valued keys in int-map? Any issues to expect compared to keyword based maps?</span></div><div data-t="Ani Banerjee More context: I have a map of entities, which are all indexed by an integer id. The value is a map with attributes
 {1 {:name &quot;foo&quot; :type &quot;a&quot;} 
  2 {:name &quot;bar&quot; :type &quot;b&quot;}}"><span class="u" id="1571958082.003900">2019:10:24 23:01:22         Ani Banerjee </span><span>More context: I have a map of entities, which are all indexed by an integer id. The value is a map with attributes
</span><pre>{1 {:name &quot;foo&quot; :type &quot;a&quot;} 
  2 {:name &quot;bar&quot; :type &quot;b&quot;}}</pre></div><div data-t="nathanmarz @eerjree yes, it works fine"><span class="u" id="1571970941.005100">2019:10:25 02:35:41           nathanmarz </span><span>@eerjree yes, it works fine</span></div><div data-t="Trevor Hi folks, what would be the best way to change this:

 [
{:name &quot;a&quot; :args [1 2 3]}
{:name &quot;a&quot; :args [5 6 7]}
{:name &quot;b&quot; :args [1]}
]
 

into this:
 {
:name &quot;a&quot; :arg-list [ [1 2 3] [5 6 7]]
:name &quot;b&quot; :arg-list [[1]]
}
 

I want to take a vector of maps which have a bunch of duplicate  :name  values with different vectors of  :args  and map the  :names  to a vector of vectors of their args.

I&apos;m using Spectre for most of the json transformations, but I&apos;m new to clojure and this transformation is non-obvious to me."><span class="u" id="1572111423.005600">2019:10:26 17:37:03               Trevor </span><span>Hi folks, what would be the best way to change this:

</span><pre>[
{:name &quot;a&quot; :args [1 2 3]}
{:name &quot;a&quot; :args [5 6 7]}
{:name &quot;b&quot; :args [1]}
]
</pre><span>

into this:
</span><pre>{
:name &quot;a&quot; :arg-list [ [1 2 3] [5 6 7]]
:name &quot;b&quot; :arg-list [[1]]
}
</pre><span>

I want to take a vector of maps which have a bunch of duplicate </span><code>:name</code><span> values with different vectors of </span><code>:args</code><span> and map the </span><code>:names</code><span> to a vector of vectors of their args.

I&apos;m using Spectre for most of the json transformations, but I&apos;m new to clojure and this transformation is non-obvious to me.</span></div><div data-t="nathanmarz @trevor670 that&apos;s best done with a reduce"><span class="u" id="1572183964.005900">2019:10:27 13:46:04           nathanmarz </span><span>@trevor670 that&apos;s best done with a reduce</span></div><div data-t="nathanmarz specter can help with the reducing function"><span class="u" id="1572183972.006200">2019:10:27 13:46:12           nathanmarz </span><span>specter can help with the reducing function</span></div><div data-t="nathanmarz (reduce
 (fn [res m]
  (setval [(keypath (:name m))
           :args-list
           NIL-&gt;VECTOR
           AFTER-ELEM]
    (:args m)
    res))
  {}
  data)
"><span class="u" id="1572183974.006400">2019:10:27 13:46:14           nathanmarz </span><pre>(reduce
 (fn [res m]
  (setval [(keypath (:name m))
           :args-list
           NIL-&gt;VECTOR
           AFTER-ELEM]
    (:args m)
    res))
  {}
  data)
</pre></div><div data-t="Trevor Thanks @nathanmarz! I&apos;m really new to clojure and found it so surprising that (map fn coll) doesnt preserve the original map! changes vectors to lists and lazy sequences! Very confusing for a beginner! While it might lead to some gaps in understanding idiomatic clojure, I&apos;ve been finding spectre a lot easier to read and understand (from the perspective of a new learner) and things behave how I would expect them too! Thanks for making Spectre!"><span class="u" id="1572208554.011700">2019:10:27 20:35:54               Trevor </span><span>Thanks @nathanmarz! I&apos;m really new to clojure and found it so surprising that (map fn coll) doesnt preserve the original map! changes vectors to lists and lazy sequences! Very confusing for a beginner! While it might lead to some gaps in understanding idiomatic clojure, I&apos;ve been finding spectre a lot easier to read and understand (from the perspective of a new learner) and things behave how I would expect them too! Thanks for making Spectre!</span></div><div data-t="sogaiu @trevor670 fwiw, i also experienced confusion initially, but once i focused on the distinction between collections and sequences, things started to make a lot more sense to me."><span class="u" id="1572216544.014100">2019:10:27 22:49:04               sogaiu </span><span>@trevor670 fwiw, i also experienced confusion initially, but once i focused on the distinction between collections and sequences, things started to make a lot more sense to me.</span></div><div data-t="Trevor Interesting, I&apos;ll keep that in mind!"><span class="u" id="1572221217.015600">2019:10:28 00:06:57                    Trevor </span><span>Interesting, I&apos;ll keep that in mind!</span></div><div data-t="Ani Banerjee @nathanmarz Need some help with a recursive query: I have a map of maps which which stores top-level entities and entity details:
 (def process-db {:process {:p1 {:name &quot;P1&quot;} :p2 {:name &quot;P2&quot;}}
                 :process-flow {:pf1 {:process_id :p1} :pf2 {:process_id :p2}}})
 
I want to get the process :name navigating from a process-flow-id.
 (select [:process-flow MAP-VALS :process_id] process-db)
=&gt; [:p1 :p2]
 
How do I write a select query that &quot;loops back&quot; to process-db, and does a lookup on  [:process MAP-VALS :name]"><span class="u" id="1572217768.015100">2019:10:27 23:09:28         Ani Banerjee </span><span>@nathanmarz Need some help with a recursive query: I have a map of maps which which stores top-level entities and entity details:
</span><pre>(def process-db {:process {:p1 {:name &quot;P1&quot;} :p2 {:name &quot;P2&quot;}}
                 :process-flow {:pf1 {:process_id :p1} :pf2 {:process_id :p2}}})
</pre><span>
I want to get the process :name navigating from a process-flow-id.
</span><pre>(select [:process-flow MAP-VALS :process_id] process-db)
=&gt; [:p1 :p2]
</pre><span>
How do I write a select query that &quot;loops back&quot; to process-db, and does a lookup on </span><pre>[:process MAP-VALS :name]</pre></div><div data-t="mikerod When navigating within a structure is there any way to get access to the “current path” you are navigated to?"><span class="u" id="1574196048.017100">2019:11:19 20:40:48              mikerod </span><span>When navigating within a structure is there any way to get access to the “current path” you are navigated to?</span></div><div data-t="mikerod I’ve found plenty of sort of related topics, but nothing I’m sure is the same thing I’m looking for"><span class="u" id="1574196063.017500">2019:11:19 20:41:03              mikerod </span><span>I’ve found plenty of sort of related topics, but nothing I’m sure is the same thing I’m looking for</span></div><div data-t="nathanmarz no, that&apos;s currently not possible"><span class="u" id="1574196166.018100">2019:11:19 20:42:46           nathanmarz </span><span>no, that&apos;s currently not possible</span></div><div data-t="mikerod thanks, that’s what I was thinking based on related issues I have found"><span class="u" id="1574196196.018600">2019:11:19 20:43:16              mikerod </span><span>thanks, that’s what I was thinking based on related issues I have found</span></div><div data-t="wegi Hi, when I use specter in emacs with the cider-repl all macros like transform and select are marked as &quot;unable to resolve symbol&quot;. I used :refer :all in the require call. It works when i evaluate it, but the lines with the functions are still marked by cider."><span class="u" id="1574694992.020600">2019:11:25 15:16:32                 wegi </span><span>Hi, when I use specter in emacs with the cider-repl all macros like transform and select are marked as &quot;unable to resolve symbol&quot;. I used :refer :all in the require call. It works when i evaluate it, but the lines with the functions are still marked by cider.</span></div><div data-t="wegi Maybe somebody else had the same problem."><span class="u" id="1574694999.020900">2019:11:25 15:16:39                 wegi </span><span>Maybe somebody else had the same problem.</span></div><div data-t="jsa-aerial Never had any problem like that.  I never  :refer :all   always use  :as sp  for the require so don&apos;t know if that is the issue"><span class="u" id="1574783206.022800">2019:11:26 15:46:46           jsa-aerial </span><span>Never had any problem like that.  I never </span><code>:refer :all</code><span>  always use </span><code>:as sp</code><span> for the require so don&apos;t know if that is the issue</span></div><div data-t="lxsli I have a similar issue with clojure-lsp in vim because many of Specter&apos;s macros are defined with macros. Not a Specter issue but tooling."><span class="u" id="1575283969.023800">2019:12:02 10:52:49                lxsli </span><span>I have a similar issue with clojure-lsp in vim because many of Specter&apos;s macros are defined with macros. Not a Specter issue but tooling.</span></div><div data-t="lxsli @wegi"><span class="u" id="1575283988.024000">2019:12:02 10:53:08                lxsli </span><span>@wegi</span></div><div data-t="wegi Jeah thanks. Figured as much. If you use emacs you can define the known macros in the.jokerrc"><span class="u" id="1575284463.025100">2019:12:02 11:01:03                 wegi </span><span>Jeah thanks. Figured as much. If you use emacs you can define the known macros in the.jokerrc</span></div><div data-t="roklenarcic hm here;’s a question, let’s say you have a predicate that will, given 2 values (key and value) tell you if you need to remove this map entry, how would you transform a map to drop those entries"><span class="u" id="1576678105.001200">2019:12:18 14:08:25          roklenarcic </span><span>hm here;’s a question, let’s say you have a predicate that will, given 2 values (key and value) tell you if you need to remove this map entry, how would you transform a map to drop those entries</span></div><div data-t="roklenarcic I tried `
 [(collect-one MAP-KEYS) MAP-VALS] 
"><span class="u" id="1576678130.001500">2019:12:18 14:08:50          roklenarcic </span><span>I tried `
</span><pre>[(collect-one MAP-KEYS) MAP-VALS]</pre><span>
</span></div><div data-t="roklenarcic but that doesn’t work since collect-one’s select must return a single value"><span class="u" id="1576678158.002100">2019:12:18 14:09:18          roklenarcic </span><span>but that doesn’t work since collect-one’s select must return a single value</span></div><div data-t="nathanmarz @roklenarcic the pattern for that is  (setval [ALL (fn [[k v]] ...)] NONE my-map)"><span class="u" id="1576705909.003000">2019:12:18 21:51:49           nathanmarz </span><span>@roklenarcic the pattern for that is </span><code>(setval [ALL (fn [[k v]] ...)] NONE my-map)</code></div><div data-t="roklenarcic so any function can act as predicate in path? What’s the difference between that and using  pred"><span class="u" id="1576706474.003900">2019:12:18 22:01:14          roklenarcic </span><span>so any function can act as predicate in path? What’s the difference between that and using </span><code>pred</code></div><div data-t="nathanmarz a function in a path implicitly uses  pred"><span class="u" id="1576706629.004300">2019:12:18 22:03:49           nathanmarz </span><span>a function in a path implicitly uses </span><code>pred</code></div><div data-t="nathanmarz you can use  pred  manually for something like  (pred :a)"><span class="u" id="1576706647.004700">2019:12:18 22:04:07           nathanmarz </span><span>you can use </span><code>pred</code><span> manually for something like </span><code>(pred :a)</code></div><div data-t="nathanmarz :a  by itself would navigate to  :a , whereas  (pred :a)  would filter based on the value of  :a"><span class="u" id="1576706679.005300">2019:12:18 22:04:39           nathanmarz </span><code>:a</code><span> by itself would navigate to </span><code>:a</code><span>, whereas </span><code>(pred :a)</code><span> would filter based on the value of </span><code>:a</code></div><div data-t="roklenarcic ok thank you"><span class="u" id="1576712055.005500">2019:12:18 23:34:15          roklenarcic </span><span>ok thank you</span></div><div data-t="donavan Has a form of collection that collects into a map been considered?"><span class="u" id="1576764964.000700">2019:12:19 14:16:04              donavan </span><span>Has a form of collection that collects into a map been considered?</span></div><div data-t="nathanmarz @donavan I&apos;ve thought about that a little, but it would complicate the API and I don&apos;t really have any use cases for it"><span class="u" id="1576771147.001600">2019:12:19 15:59:07           nathanmarz </span><span>@donavan I&apos;ve thought about that a little, but it would complicate the API and I don&apos;t really have any use cases for it</span></div><div data-t="donavan Good points. The only cases where I have wanted it are covered by  with-fresh-collected  I guess."><span class="u" id="1576774670.001700">2019:12:19 16:57:50                   donavan </span><span>Good points. The only cases where I have wanted it are covered by </span><code>with-fresh-collected</code><span> I guess.</span></div><div data-t="donavan This question  https://github.com/redplanetlabs/specter/issues/287  got me thinking about how to solve the problem in the general case and I thought it would be nice to have a subselect like nav that allowed transformation to multiple values like srange. While this implementation is broken it better illustrates what I mean:

 (sp/defdynamicnav seqsubselect
  [&amp; path]
  (sp/late-bound-nav
   [late (sp/late-path path)]

   (select*
    [this structure next-fn]
    (next-fn (sp/compiled-select late structure)))

   (transform*
    [this structure next-fn]
    (let [select-result (sp/compiled-select late structure)]
      (reduce
       (fn [structure s]
         (i/srange-transform* structure s (inc s) next-fn))
       structure
       (map #(.indexOf structure %) (reverse select-result)))))))

(sp/transform
 [(seqsubselect
   [sp/ALL
    vector?])]
 (fn [structure]
   (mapcat
    (fn [x]
      (concat
       (filter odd? x)
       [(into [] (filter even? x))]))
    structure))
 [:a [2 4 6] :b [5 6 7 8] :c [3 5 7] :d [1 2 3 4]])

;; =&gt; [:a [2 4 6] :b 5 7 [6 8] :c 3 5 7 [] :d 1 3 [2 4]]"><span class="u" id="1577824051.004300">2020:12:31 20:27:31              donavan </span><span>This question </span><a href="https://github.com/redplanetlabs/specter/issues/287">https://github.com/redplanetlabs/specter/issues/287</a><span> got me thinking about how to solve the problem in the general case and I thought it would be nice to have a subselect like nav that allowed transformation to multiple values like srange. While this implementation is broken it better illustrates what I mean:

</span><pre>(sp/defdynamicnav seqsubselect
  [&amp; path]
  (sp/late-bound-nav
   [late (sp/late-path path)]

   (select*
    [this structure next-fn]
    (next-fn (sp/compiled-select late structure)))

   (transform*
    [this structure next-fn]
    (let [select-result (sp/compiled-select late structure)]
      (reduce
       (fn [structure s]
         (i/srange-transform* structure s (inc s) next-fn))
       structure
       (map #(.indexOf structure %) (reverse select-result)))))))

(sp/transform
 [(seqsubselect
   [sp/ALL
    vector?])]
 (fn [structure]
   (mapcat
    (fn [x]
      (concat
       (filter odd? x)
       [(into [] (filter even? x))]))
    structure))
 [:a [2 4 6] :b [5 6 7 8] :c [3 5 7] :d [1 2 3 4]])

;; =&gt; [:a [2 4 6] :b 5 7 [6 8] :c 3 5 7 [] :d 1 3 [2 4]]</pre></div><div data-t="theeternalpulse Is there a general naming pattern for paths.  For example I have this recursive path function
 (defn node-finder
  &quot;Generates a recursive-path finder that visits
  matching `pred-fn`&quot;
  [pred-fn]
  (recursive-path
    [] p
    (specter/cond-path
      pred-fn STAY
      map? [MAP-VALS p]
      vector? [ALL p]))) 
That generates a path that finds a key-value that matches a certain pattern.  I&apos;m thinking node-finder should be node-path, should then the result be bound to something like FUNCTION-VALUE or FUNCTION-PATH?  I&apos;m guessing the former seems more consistent with the naming of the core paths."><span class="u" id="1579548520.002000">2020:01:20 19:28:40      theeternalpulse </span><span>Is there a general naming pattern for paths.  For example I have this recursive path function
</span><pre>(defn node-finder
  &quot;Generates a recursive-path finder that visits
  matching `pred-fn`&quot;
  [pred-fn]
  (recursive-path
    [] p
    (specter/cond-path
      pred-fn STAY
      map? [MAP-VALS p]
      vector? [ALL p])))</pre><span>
That generates a path that finds a key-value that matches a certain pattern.  I&apos;m thinking node-finder should be node-path, should then the result be bound to something like FUNCTION-VALUE or FUNCTION-PATH?  I&apos;m guessing the former seems more consistent with the naming of the core paths.</span></div><div data-t="nathanmarz I would call something like that  matching-nodes"><span class="u" id="1579552158.002300">2020:01:20 20:29:18           nathanmarz </span><span>I would call something like that </span><code>matching-nodes</code></div><div data-t="theeternalpulse the function or the bound resulting path"><span class="u" id="1579574035.002600">2020:01:21 02:33:55      theeternalpulse </span><span>the function or the bound resulting path</span></div><div data-t="nathanmarz the function"><span class="u" id="1579612407.002800">2020:01:21 13:13:27           nathanmarz </span><span>the function</span></div><div data-t="nathanmarz so it reads like  (select [ALL (matching-nodes even?)] data)"><span class="u" id="1579612435.003300">2020:01:21 13:13:55           nathanmarz </span><span>so it reads like </span><code>(select [ALL (matching-nodes even?)] data)</code></div><div data-t="theeternalpulse ah, great idea."><span class="u" id="1579642616.003600">2020:01:21 21:36:56      theeternalpulse </span><span>ah, great idea.</span></div><div data-t="akond the documentation says i can have additional params to  declarepath , but i can only see declarepath with only one param."><span class="u" id="1579862702.005500">2020:01:24 10:45:02                akond </span><span>the documentation says i can have additional params to </span><code>declarepath</code><span>, but i can only see declarepath with only one param.</span></div><div data-t="akond (defmacro declarepath [name]
  `(def ~name (i/local-declarepath))) 
where is the other one?"><span class="u" id="1579862730.005800">2020:01:24 10:45:30                akond </span><pre>(defmacro declarepath [name]
  `(def ~name (i/local-declarepath)))</pre><span>
where is the other one?</span></div><div data-t="nathanmarz @akond that wiki page was out of date"><span class="u" id="1579888622.006200">2020:01:24 17:57:02           nathanmarz </span><span>@akond that wiki page was out of date</span></div><div data-t="nathanmarz those params are unnecessary now"><span class="u" id="1579888631.006500">2020:01:24 17:57:11           nathanmarz </span><span>those params are unnecessary now</span></div><div data-t="akond @nathanmarz understood. is it possible then to create a parametrized navigator for say something like  [:rations s/ALL (fn-&gt; :id (= id)) :day-rations]  so that it looks like  [(new-nav id)]  instead?"><span class="u" id="1580022394.008800">2020:01:26 07:06:34                akond </span><span>@nathanmarz understood. is it possible then to create a parametrized navigator for say something like </span><code>[:rations s/ALL (fn-&gt; :id (= id)) :day-rations]</code><span> so that it looks like </span><code>[(new-nav id)]</code><span> instead?</span></div><div data-t="nathanmarz sure"><span class="u" id="1580055545.009000">2020:01:26 16:19:05           nathanmarz </span><span>sure</span></div><div data-t="nathanmarz (defn new-nav [id]
  (path :rations s/ALL (fn-&gt; :id (= id)) :day-rations))"><span class="u" id="1580055551.009300">2020:01:26 16:19:11           nathanmarz </span><pre>(defn new-nav [id]
  (path :rations s/ALL (fn-&gt; :id (= id)) :day-rations))</pre></div><div data-t="akond thank you very much. i see that  path  is also undocumented."><span class="u" id="1580122051.010300">2020:01:27 10:47:31                akond </span><span>thank you very much. i see that </span><code>path</code><span> is also undocumented.</span></div><div data-t="joshkh is this an okay place to ask for help with an example? i have a simple tree, and i would like to collect a value from each parent and combine it with a value on its direct descendants. for example:
 (def tree {:id       1
           :value    &quot;one&quot;
           :children [{:id    2
                       :value &quot;two&quot;}
                      {:id       3
                       :value    &quot;three&quot;
                       :children [{:id    4
                                   :value &quot;four&quot;}]}]}) 
where after a transformation, each child gets a  :parent+myvalue  key which is equal to  (str (:value parent) (:value self)) 
 (s/transform [...path] xfn tree)

{:id       1
 :value    &quot;one&quot;
 :children [{:id             2
             :value          &quot;two&quot;
             :parent+myvalue &quot;onetwo&quot;}
            {:id             3
             :value          &quot;three&quot;
             :parent+myvalue &quot;onethree&quot;
             :children       [{:id             4
                               :value          &quot;four&quot;
                               :parent+myvalue &quot;threefour&quot;}]}]} 
is Specter well suited for this, or should i just use core walk functions?"><span class="u" id="1580405973.015000">2020:01:30 17:39:33               joshkh </span><span>is this an okay place to ask for help with an example? i have a simple tree, and i would like to collect a value from each parent and combine it with a value on its direct descendants. for example:
</span><pre>(def tree {:id       1
           :value    &quot;one&quot;
           :children [{:id    2
                       :value &quot;two&quot;}
                      {:id       3
                       :value    &quot;three&quot;
                       :children [{:id    4
                                   :value &quot;four&quot;}]}]})</pre><span>
where after a transformation, each child gets a </span><code>:parent+myvalue</code><span> key which is equal to </span><code>(str (:value parent) (:value self))</code><span>
</span><pre>(s/transform [...path] xfn tree)

{:id       1
 :value    &quot;one&quot;
 :children [{:id             2
             :value          &quot;two&quot;
             :parent+myvalue &quot;onetwo&quot;}
            {:id             3
             :value          &quot;three&quot;
             :parent+myvalue &quot;onethree&quot;
             :children       [{:id             4
                               :value          &quot;four&quot;
                               :parent+myvalue &quot;threefour&quot;}]}]}</pre><span>
is Specter well suited for this, or should i just use core walk functions?</span></div><div data-t="joshkh i suspect  s/collect  comes into play"><span class="u" id="1580406110.015500">2020:01:30 17:41:50               joshkh </span><span>i suspect </span><code>s/collect</code><span> comes into play</span></div><div data-t="nathanmarz @joshkh this is the kind of stuff specter is very good at"><span class="u" id="1580407970.016000">2020:01:30 18:12:50           nathanmarz </span><span>@joshkh this is the kind of stuff specter is very good at</span></div><div data-t="nathanmarz (def CHILDREN (path (must :children) ALL))
(def VALUE+CHILDREN (path (collect-one :value) CHILDREN))

(def WALKER
  (recursive-path [] p
    (continue-then-stay
      DISPENSE
      VALUE+CHILDREN
      )))

(transform [VALUE+CHILDREN WALKER (collect-one :value) :parent+myvalue]
  (fn [parent-value my-value _]
    (str parent-value my-value))
  tree)"><span class="u" id="1580407979.016300">2020:01:30 18:12:59           nathanmarz </span><pre>(def CHILDREN (path (must :children) ALL))
(def VALUE+CHILDREN (path (collect-one :value) CHILDREN))

(def WALKER
  (recursive-path [] p
    (continue-then-stay
      DISPENSE
      VALUE+CHILDREN
      )))

(transform [VALUE+CHILDREN WALKER (collect-one :value) :parent+myvalue]
  (fn [parent-value my-value _]
    (str parent-value my-value))
  tree)</pre></div><div data-t="nathanmarz that&apos;s one way to solve it"><span class="u" id="1580407986.016500">2020:01:30 18:13:06           nathanmarz </span><span>that&apos;s one way to solve it</span></div><div data-t="joshkh aha, thanks for the working example. i always come back to specter after just long enough away to forget its paradigms  🙂"><span class="u" id="1580408107.017700">2020:01:30 18:15:07               joshkh </span><span>aha, thanks for the working example. i always come back to specter after just long enough away to forget its paradigms </span><b>🙂</b></div><div data-t="richiardiandrea Hi specter folks it&apos;s been a while and I am rusty  😄 

How do I navigate to all the vectors and makes sure that if they have only one element I unwrap it?"><span class="u" id="1580846820.025100">2020:02:04 20:07:00      richiardiandrea </span><span>Hi specter folks it&apos;s been a while and I am rusty </span><b>😄</b><span>

How do I navigate to all the vectors and makes sure that if they have only one element I unwrap it?</span></div><div data-t="richiardiandrea so from
 (xf/one-item-vector-&gt;map {:data {:a [1 2 3] :b [{:foo :bar}]}}) 
to
 (xf/one-item-vector-&gt;map {:data {:a [1 2 3] :b {:foo :bar}}})"><span class="u" id="1580846847.025700">2020:02:04 20:07:27      richiardiandrea </span><span>so from
</span><pre>(xf/one-item-vector-&gt;map {:data {:a [1 2 3] :b [{:foo :bar}]}})</pre><span>
to
</span><pre>(xf/one-item-vector-&gt;map {:data {:a [1 2 3] :b {:foo :bar}}})</pre></div><div data-t="richiardiandrea I think I am kind of missing how to drill down any map of maps"><span class="u" id="1580847193.026200">2020:02:04 20:13:13      richiardiandrea </span><span>I think I am kind of missing how to drill down any map of maps</span></div><div data-t="richiardiandrea like in  clojure.walk"><span class="u" id="1580847200.026400">2020:02:04 20:13:20      richiardiandrea </span><span>like in </span><code>clojure.walk</code></div><div data-t="akond (let [data {:data {:a [1 2 3] :b [{:foo :bar}]}}]
 (is (= (s/transform (s/walker (every-pred vector? (fn-&gt; count (= 1)) )) first data)
      {:data {:a [1 2 3] :b {:foo :bar}}}))) 
"><span class="u" id="1580885902.026600">2020:02:05 06:58:22                akond </span><pre>(let [data {:data {:a [1 2 3] :b [{:foo :bar}]}}]
 (is (= (s/transform (s/walker (every-pred vector? (fn-&gt; count (= 1)) )) first data)
      {:data {:a [1 2 3] :b {:foo :bar}}})))</pre><span>
</span></div><div data-t="richiardiandrea thanks a lot for answering!"><span class="u" id="1581225469.030000">2020:02:09 05:17:49           richiardiandrea </span><span>thanks a lot for answering!</span></div><div data-t="steveb8n @akond thanks, I learned from that example too. a couple of questions: 1/ which lib does fn-&gt; come from? 2/ the docs for walker imply it stops navigation when the predicate is satisfied once but, when I add another match, it transforms that too. this is what I want but it seems to contradict the docstring. what am I missing?"><span class="u" id="1580942365.029200">2020:02:05 22:39:25             steveb8n </span><span>@akond thanks, I learned from that example too. a couple of questions: 1/ which lib does fn-&gt; come from? 2/ the docs for walker imply it stops navigation when the predicate is satisfied once but, when I add another match, it transforms that too. this is what I want but it seems to contradict the docstring. what am I missing?</span></div><div data-t="akond fn-&gt; comes from plumbing:  https://plumatic.github.io/plumbing/plumbing.core.html#var-fn-.3E"><span class="u" id="1580970334.029300">2020:02:06 06:25:34                     akond </span><span>fn-&gt; comes from plumbing: </span><a href="https://plumatic.github.io/plumbing/plumbing.core.html#var-fn-.3E">https://plumatic.github.io/plumbing/plumbing.core.html#var-fn-.3E</a></div><div data-t="akond docs might be not up to date"><span class="u" id="1580970378.029500">2020:02:06 06:26:18                     akond </span><span>docs might be not up to date</span></div><div data-t="jimi Can someone help me translates this function into a specter one?
 (defn get-component!
  [system component-key]
  (or (get system component-key)
      (-&gt;&gt; system
           (filter (fn [[current-key]]
                     (and (vector? current-key)
                          (= 2 (count current-key))
                          (= component-key (second current-key)))))
           (map val)
           (first))
      (throw (ex-info &quot;missing component&quot; {:tag ::get-component!
                                           :component component-key}))))"><span class="u" id="1582456257.000600">2020:02:23 11:10:57                 jimi </span><span>Can someone help me translates this function into a specter one?
</span><pre>(defn get-component!
  [system component-key]
  (or (get system component-key)
      (-&gt;&gt; system
           (filter (fn [[current-key]]
                     (and (vector? current-key)
                          (= 2 (count current-key))
                          (= component-key (second current-key)))))
           (map val)
           (first))
      (throw (ex-info &quot;missing component&quot; {:tag ::get-component!
                                           :component component-key}))))</pre></div><div data-t="aengelberg Is there a navigator that navigates to the singleton subsequence containing each element of a collection? This would give the transformer the opportunity to turn one element into many elements, and “splice” them back into the parent collection."><span class="u" id="1584487928.003600">2020:03:17 23:32:08           aengelberg </span><span>Is there a navigator that navigates to the singleton subsequence containing each element of a collection? This would give the transformer the opportunity to turn one element into many elements, and “splice” them back into the parent collection.</span></div><div data-t="aengelberg in other words, it would navigate to  (srange 0 1) , then  (srange 1 2) , etc"><span class="u" id="1584487971.004100">2020:03:17 23:32:51           aengelberg </span><span>in other words, it would navigate to </span><code>(srange 0 1)</code><span>, then </span><code>(srange 1 2)</code><span>, etc</span></div><div data-t="aengelberg continuous-subseqs  is close to what I want, but I want the subseqs to not be continuous"><span class="u" id="1584488344.004900">2020:03:17 23:39:04           aengelberg </span><code>continuous-subseqs</code><span> is close to what I want, but I want the subseqs to not be continuous</span></div><div data-t="nathanmarz @aengelberg this issue would let you do that with  continuous-subseqs   https://github.com/redplanetlabs/specter/issues/236"><span class="u" id="1584517205.005400">2020:03:18 07:40:05           nathanmarz </span><span>@aengelberg this issue would let you do that with </span><code>continuous-subseqs</code><span> </span><a href="https://github.com/redplanetlabs/specter/issues/236">https://github.com/redplanetlabs/specter/issues/236</a></div><div data-t="nathanmarz otherwise you&apos;d have to write a custom navigator"><span class="u" id="1584517215.005800">2020:03:18 07:40:15           nathanmarz </span><span>otherwise you&apos;d have to write a custom navigator</span></div><div data-t="stuartrexking When navigating how do you ignore the first element? I&apos;m transforming a CSV and I want to ignore the header line."><span class="u" id="1586133881.001300">2020:04:06 00:44:41        stuartrexking </span><span>When navigating how do you ignore the first element? I&apos;m transforming a CSV and I want to ignore the header line.</span></div><div data-t="stuartrexking Answered here  https://github.com/redplanetlabs/specter/issues/288#issuecomment-609547864"><span class="u" id="1586153943.001700">2020:04:06 06:19:03        stuartrexking </span><span>Answered here </span><a href="https://github.com/redplanetlabs/specter/issues/288#issuecomment-609547864">https://github.com/redplanetlabs/specter/issues/288#issuecomment-609547864</a></div><div data-t="narkisr Hi Specter team I&apos;m looking for a way to collect values in a multi-path:

 (select [MAP-VALS ATOM (multi-path MAP-KEYS [MAP-VALS MAP-VALS :ttl])] results)       
I&apos;m getting back:

 [&quot;4fcb9fdd4ef847aa9b0a906e3effcf3b&quot;                                                                             
 1586267405166
 1586267416251
 &quot;31a915847bff41a788c1c34521ffe7a9&quot;
 1586265826511
 &quot;5a6c3fc3a587437baf497f9c80c858ca&quot;
 1586266864089
 1586266891300] 
And id like to group the [MAP-VALS MAP-VALS :ttl] into a vector:

 [&quot;4fcb9fdd4ef847aa9b0a906e3effcf3b&quot;                                                                             
 [1586267405166 1586267416251]
 &quot;31a915847bff41a788c1c34521ffe7a9&quot;
 [1586265826511]
 &quot;5a6c3fc3a587437baf497f9c80c858ca&quot;
 [1586266864089 1586266891300]] 
This is probably simple but using collect/VAL etc didn&apos;t work, what am I missing?  🙂"><span class="u" id="1586268926.003800">2020:04:07 14:15:26              narkisr </span><span>Hi Specter team I&apos;m looking for a way to collect values in a multi-path:

</span><pre>(select [MAP-VALS ATOM (multi-path MAP-KEYS [MAP-VALS MAP-VALS :ttl])] results)      </pre><span>
I&apos;m getting back:

</span><pre>[&quot;4fcb9fdd4ef847aa9b0a906e3effcf3b&quot;                                                                             
 1586267405166
 1586267416251
 &quot;31a915847bff41a788c1c34521ffe7a9&quot;
 1586265826511
 &quot;5a6c3fc3a587437baf497f9c80c858ca&quot;
 1586266864089
 1586266891300]</pre><span>
And id like to group the [MAP-VALS MAP-VALS :ttl] into a vector:

</span><pre>[&quot;4fcb9fdd4ef847aa9b0a906e3effcf3b&quot;                                                                             
 [1586267405166 1586267416251]
 &quot;31a915847bff41a788c1c34521ffe7a9&quot;
 [1586265826511]
 &quot;5a6c3fc3a587437baf497f9c80c858ca&quot;
 [1586266864089 1586266891300]]</pre><span>
This is probably simple but using collect/VAL etc didn&apos;t work, what am I missing? </span><b>🙂</b></div><div data-t="nathanmarz @narkisr you can use  subselect"><span class="u" id="1586289018.004100">2020:04:07 19:50:18           nathanmarz </span><span>@narkisr you can use </span><code>subselect</code></div><div data-t="narkisr That worked thank you @nathanmarz"><span class="u" id="1586358482.004500">2020:04:08 15:08:02              narkisr </span><span>That worked thank you @nathanmarz</span></div><div data-t="thom What&apos;s an efficient way to find a value that comes after (in a vector) something matched by a  walker ? Should I just be matching one level up instead? For example, in  [:foo [:bar [:arbitrarily-nested-stuff [:baz 42]]]  if I was interested in the value 42 next to that deeply nested :baz?"><span class="u" id="1586359455.006400">2020:04:08 15:24:15                 thom </span><span>What&apos;s an efficient way to find a value that comes after (in a vector) something matched by a </span><code>walker</code><span>? Should I just be matching one level up instead? For example, in </span><code>[:foo [:bar [:arbitrarily-nested-stuff [:baz 42]]]</code><span> if I was interested in the value 42 next to that deeply nested :baz?</span></div><div data-t="nathanmarz @thom704 yea, you would want to match one level higher"><span class="u" id="1586364754.006700">2020:04:08 16:52:34           nathanmarz </span><span>@thom704 yea, you would want to match one level higher</span></div><div data-t="thom I think I had a slightly wrong-headed zippers way of thinking about it where I could get to somewhere and then just navigate around arbitrarily"><span class="u" id="1586364811.007100">2020:04:08 16:53:31                 thom </span><span>I think I had a slightly wrong-headed zippers way of thinking about it where I could get to somewhere and then just navigate around arbitrarily</span></div><div data-t="nonrecursive hey hey  🙂  How would I return a map where all paths that don’t terminate in an integer have been pruned?

Given:
 {:a {:b {:c 10
         :d &quot;&quot;}}
 :f 5
 :k [10]
 :m &quot;&quot;
 :x {:y {:z &quot;&quot;}}} 
I want:
 {:a {:b {:c 10}}
 :f 5
 :k [10]}"><span class="u" id="1586749652.008700">2020:04:13 03:47:32         nonrecursive </span><span>hey hey </span><b>🙂</b><span> How would I return a map where all paths that don’t terminate in an integer have been pruned?

Given:
</span><pre>{:a {:b {:c 10
         :d &quot;&quot;}}
 :f 5
 :k [10]
 :m &quot;&quot;
 :x {:y {:z &quot;&quot;}}}</pre><span>
I want:
</span><pre>{:a {:b {:c 10}}
 :f 5
 :k [10]}</pre></div><div data-t="nathanmarz @nonrecursive you can do that with a custom walker and  compact  :
 (def COMPACTING-WALKER
  (recursive-path [] p
    (cond-path map? [(compact MAP-VALS) p]
               coll? [(compact ALL) p]
               STAY STAY
               )))

(setval [COMPACTING-WALKER (complement number?)]
  NONE
  data
  ) 
"><span class="u" id="1586817384.009700">2020:04:13 22:36:24           nathanmarz </span><span>@nonrecursive you can do that with a custom walker and </span><code>compact</code><span> :
</span><pre>(def COMPACTING-WALKER
  (recursive-path [] p
    (cond-path map? [(compact MAP-VALS) p]
               coll? [(compact ALL) p]
               STAY STAY
               )))

(setval [COMPACTING-WALKER (complement number?)]
  NONE
  data
  )</pre><span>
</span></div><div data-t="nonrecursive @nathan that worked beautifully, thanks for your help!"><span class="u" id="1586878435.010400">2020:04:14 15:33:55         nonrecursive </span><span>@nathan that worked beautifully, thanks for your help!</span></div><div data-t="lvh What I have:

 (def m (-&gt; {} (assoc-in [:a :b :c :d] 1) (assoc-in [:x :y :z] 2)))

(def INDEXED
  &quot;A path that visits v and collects k in [[k v], ...].&quot;
  [sr/ALL (sr/putval  sr/FIRST) sr/LAST])

(def INDEXED-SEQ
  &quot;A selector that visits all elements of a seq, and collects their indices.&quot;
  [(sr/view #(map-indexed vector %)) INDEXED])

(def NESTED-PATHS
  (sr/recursive-path
   [] p
   (sr/cond-path
    map? [INDEXED p]
    coll? [INDEXED-SEQ p]
    sr/STAY sr/STAY)))

(sr/select [NESTED-PATHS] m)
;; =&gt; [[:a :b :c :d 1] [:x :y :z 2]] 
What I would like (so I can peek/pop to destructure, since the &quot;path&quot; is separate from the final value):

 [[[:a :b :c :d] 1] [[:x :y :z] 2]] 

Of course I can just do that with last &amp; butlast but if there was a more efficient/elegant/different version I&apos;d love to know"><span class="u" id="1587147899.015400">2020:04:17 18:24:59                  lvh </span><span>What I have:

</span><pre>(def m (-&gt; {} (assoc-in [:a :b :c :d] 1) (assoc-in [:x :y :z] 2)))

(def INDEXED
  &quot;A path that visits v and collects k in [[k v], ...].&quot;
  [sr/ALL (sr/putval  sr/FIRST) sr/LAST])

(def INDEXED-SEQ
  &quot;A selector that visits all elements of a seq, and collects their indices.&quot;
  [(sr/view #(map-indexed vector %)) INDEXED])

(def NESTED-PATHS
  (sr/recursive-path
   [] p
   (sr/cond-path
    map? [INDEXED p]
    coll? [INDEXED-SEQ p]
    sr/STAY sr/STAY)))

(sr/select [NESTED-PATHS] m)
;; =&gt; [[:a :b :c :d 1] [:x :y :z 2]]</pre><span>
What I would like (so I can peek/pop to destructure, since the &quot;path&quot; is separate from the final value):

</span><pre>[[[:a :b :c :d] 1] [[:x :y :z] 2]]</pre><span>

Of course I can just do that with last &amp; butlast but if there was a more efficient/elegant/different version I&apos;d love to know</span></div><div data-t="lvh i could also solve this problem if I had a version of  view   that showed me the currently collected values"><span class="u" id="1587148728.016000">2020:04:17 18:38:48                  lvh </span><span>i could also solve this problem if I had a version of </span><code>view</code><span>  that showed me the currently collected values</span></div><div data-t="lvh Subtle variant of that:

 (def path-finder
  &quot;Finds the first entry matching `pred` in a deeply nested structure of maps
  and vectors, and collects the path on the way there.&quot;
  (sr/recursive-path
   [term-pred] p
   (sr/cond-path
    (sr/pred term-pred) sr/STAY
    map? [INDEXED p]
    coll? [INDEXED-SEQ p]))) 
(basically the same thing but with a predicate). This works fine (as expected when selecting):

 (sr/select
 (path-finder string?)
 {:a [&quot;x&quot;] :b {:c :d}})
;; =&gt; [[:a 0 &quot;x&quot;]] 
But when transforming I get this unexpected behavior:

 (= (sr/transform
    [(path-finder string?)]
    (fn [&amp; path-and-val] (-&gt; path-and-val last str/upper-case))
    {:a [&quot;x&quot;] :b {:c :d}})
   (sr/transform
    [NESTED-PATHS string?]
    (fn [&amp; path-and-val] (-&gt; path-and-val last str/upper-case))
    {:a [&quot;x&quot;] :b {:c :d}})
   {:a &apos;([0 &quot;X&quot;]), :b {:c :d}}) 
Why is that zero there all of a sudden and how do I fix that?"><span class="u" id="1587322155.017400">2020:04:19 18:49:15                  lvh </span><span>Subtle variant of that:

</span><pre>(def path-finder
  &quot;Finds the first entry matching `pred` in a deeply nested structure of maps
  and vectors, and collects the path on the way there.&quot;
  (sr/recursive-path
   [term-pred] p
   (sr/cond-path
    (sr/pred term-pred) sr/STAY
    map? [INDEXED p]
    coll? [INDEXED-SEQ p])))</pre><span>
(basically the same thing but with a predicate). This works fine (as expected when selecting):

</span><pre>(sr/select
 (path-finder string?)
 {:a [&quot;x&quot;] :b {:c :d}})
;; =&gt; [[:a 0 &quot;x&quot;]]</pre><span>
But when transforming I get this unexpected behavior:

</span><pre>(= (sr/transform
    [(path-finder string?)]
    (fn [&amp; path-and-val] (-&gt; path-and-val last str/upper-case))
    {:a [&quot;x&quot;] :b {:c :d}})
   (sr/transform
    [NESTED-PATHS string?]
    (fn [&amp; path-and-val] (-&gt; path-and-val last str/upper-case))
    {:a [&quot;x&quot;] :b {:c :d}})
   {:a &apos;([0 &quot;X&quot;]), :b {:c :d}})</pre><span>
Why is that zero there all of a sudden and how do I fix that?</span></div><div data-t="Alex Ragone Hi everyone! I am trying to navigate a 4D array and would like to get all the indicies (the path to get there). How do I do that? So far I have the following
 (transform [ALL (collect-one INDEXED-VALS FIRST)
              ALL (collect-one INDEXED-VALS FIRST)
              ALL (collect-one INDEXED-VALS FIRST)
              ALL (collect-one INDEXED-VALS)]
             (fn [d1 d2 d3 d4 item]
                 ...))
             4d-array)) 
But I don’t quite understand how the collect function works? Can anyone please help me?  🙂  Thank you."><span class="u" id="1588778966.022300">2020:05:06 15:29:26          Alex Ragone </span><span>Hi everyone! I am trying to navigate a 4D array and would like to get all the indicies (the path to get there). How do I do that? So far I have the following
</span><pre>(transform [ALL (collect-one INDEXED-VALS FIRST)
              ALL (collect-one INDEXED-VALS FIRST)
              ALL (collect-one INDEXED-VALS FIRST)
              ALL (collect-one INDEXED-VALS)]
             (fn [d1 d2 d3 d4 item]
                 ...))
             4d-array))</pre><span>
But I don’t quite understand how the collect function works? Can anyone please help me? </span><b>🙂</b><span> Thank you.</span></div><div data-t="nathanmarz @ragonedk you want something more like:
 (transform [INDEXED-VALS
            (collect-one FIRST)
            LAST
            INDEXED-VALS
            (collect-one FIRST)
            LAST
            INDEXED-VALS
            (collect-one FIRST)
            LAST
            INDEXED-VALS
            (collect-one FIRST)
            LAST
            ]
  (fn [d1 d2 d3 d4 item]
    )
  4d-arr
  )"><span class="u" id="1588794894.023100">2020:05:06 19:54:54           nathanmarz </span><span>@ragonedk you want something more like:
</span><pre>(transform [INDEXED-VALS
            (collect-one FIRST)
            LAST
            INDEXED-VALS
            (collect-one FIRST)
            LAST
            INDEXED-VALS
            (collect-one FIRST)
            LAST
            INDEXED-VALS
            (collect-one FIRST)
            LAST
            ]
  (fn [d1 d2 d3 d4 item]
    )
  4d-arr
  )</pre></div><div data-t="nathanmarz you can shorten that like this:
 (def ALL-AND-COLLECT-INDEX (path INDEXED-VALS (collect-one FIRST) LAST))

(transform [ALL-AND-COLLECT-INDEX
            ALL-AND-COLLECT-INDEX
            ALL-AND-COLLECT-INDEX
            ALL-AND-COLLECT-INDEX]
  (fn [d1 d2 d3 d4 item]
    )
  4d-arr
  )"><span class="u" id="1588794957.023400">2020:05:06 19:55:57           nathanmarz </span><span>you can shorten that like this:
</span><pre>(def ALL-AND-COLLECT-INDEX (path INDEXED-VALS (collect-one FIRST) LAST))

(transform [ALL-AND-COLLECT-INDEX
            ALL-AND-COLLECT-INDEX
            ALL-AND-COLLECT-INDEX
            ALL-AND-COLLECT-INDEX]
  (fn [d1 d2 d3 d4 item]
    )
  4d-arr
  )</pre></div><div data-t="Alex Ragone Awesome, that worked! Thank you :)"><span class="u" id="1588795035.024100">2020:05:06 19:57:15          Alex Ragone </span><span>Awesome, that worked! Thank you :)</span></div><div data-t="Joe Hello, I have a 9x9 matrix using nested vectors, and I want to pull out the top left &apos;subsquare&apos; , i.e. elements at [0-2, 0-2]. I got the results I wanted with  (select [(srange 0 3) ALL (srange 0 3)] data)  , but I don&apos;t understand the need for the  ALL  inbetween the two  sranges . I was thinking the first srange would grab the first 3 vectors, and the second would grab the first 3 elements from each of them - what&apos;s the concept I&apos;m missing that means you need the  ALL  in the middle?
Here&apos;s the data:
 (def data
  [[5 3 0 0 7 0 0 0 0]
   [6 0 0 1 9 5 0 0 0]
   [0 9 8 0 0 0 0 6 0]
   [8 0 0 0 6 0 0 0 3]
   [4 0 0 8 0 3 0 0 1]
   [7 0 0 0 2 0 0 0 6]
   [0 6 0 0 0 0 2 8 0]
   [0 0 0 4 1 9 0 0 5]
   [0 0 0 0 8 0 0 7 9]]) "><span class="u" id="1588803134.029400">2020:05:06 22:12:14                  Joe </span><span>Hello, I have a 9x9 matrix using nested vectors, and I want to pull out the top left &apos;subsquare&apos; , i.e. elements at [0-2, 0-2]. I got the results I wanted with </span><code>(select [(srange 0 3) ALL (srange 0 3)] data)</code><span> , but I don&apos;t understand the need for the </span><code>ALL</code><span> inbetween the two </span><code>sranges</code><span>. I was thinking the first srange would grab the first 3 vectors, and the second would grab the first 3 elements from each of them - what&apos;s the concept I&apos;m missing that means you need the </span><code>ALL</code><span> in the middle?
Here&apos;s the data:
</span><pre>(def data
  [[5 3 0 0 7 0 0 0 0]
   [6 0 0 1 9 5 0 0 0]
   [0 9 8 0 0 0 0 6 0]
   [8 0 0 0 6 0 0 0 3]
   [4 0 0 8 0 3 0 0 1]
   [7 0 0 0 2 0 0 0 6]
   [0 6 0 0 0 0 2 8 0]
   [0 0 0 4 1 9 0 0 5]
   [0 0 0 0 8 0 0 7 9]]) </pre></div><div data-t="nathanmarz @allaboutthatmace1789  srange  navigates to a single subsequence,  ALL  navigates to each element"><span class="u" id="1588804625.029900">2020:05:06 22:37:05           nathanmarz </span><span>@allaboutthatmace1789 </span><code>srange</code><span> navigates to a single subsequence, </span><code>ALL</code><span> navigates to each element</span></div><div data-t="Joe So the first  srange  gets to  [[1 2 3 ,,,] [1 2 3 ,,,] [1 2 3 ,,,]] , you need the  ALL  to tell it grab every element  [1 2 3 ,,,] [1 2 3 ,,,] [1 2 3 ,,,] , then for each of those elements the second  srange  gets the subseq of first 3 elements  [1 2 3] [1 2 3] [1 2 3]  - then wraps everything back up again?"><span class="u" id="1588805542.033400">2020:05:06 22:52:22                  Joe </span><span>So the first </span><code>srange</code><span> gets to </span><code>[[1 2 3 ,,,] [1 2 3 ,,,] [1 2 3 ,,,]]</code><span>, you need the </span><code>ALL</code><span> to tell it grab every element </span><code>[1 2 3 ,,,] [1 2 3 ,,,] [1 2 3 ,,,]</code><span>, then for each of those elements the second </span><code>srange</code><span> gets the subseq of first 3 elements </span><code>[1 2 3] [1 2 3] [1 2 3]</code><span> - then wraps everything back up again?</span></div><div data-t="nathanmarz in a select that would just return the individual elements"><span class="u" id="1588819496.033700">2020:05:07 02:44:56           nathanmarz </span><span>in a select that would just return the individual elements</span></div><div data-t="nathanmarz in a transform it would change the values in their locations in which you navigated to them"><span class="u" id="1588819522.034200">2020:05:07 02:45:22           nathanmarz </span><span>in a transform it would change the values in their locations in which you navigated to them</span></div><div data-t="mmer Hi a simple question but one that I have struggled to find an answer:  I have a vector of maps and I want to return all the maps that contains a map entry that matches a particular value, for example all maps where :lang contains &quot;EN&quot;."><span class="u" id="1589816742.040700">2020:05:18 15:45:42                 mmer </span><span>Hi a simple question but one that I have struggled to find an answer:  I have a vector of maps and I want to return all the maps that contains a map entry that matches a particular value, for example all maps where :lang contains &quot;EN&quot;.</span></div><div data-t="spieden @mmer I believe  (spr/select [spr/ALL #(= &quot;EN&quot; (:lang %))] v-of-m)  should do it"><span class="u" id="1589817714.041500">2020:05:18 16:01:54              spieden </span><span>@mmer I believe </span><code>(spr/select [spr/ALL #(= &quot;EN&quot; (:lang %))] v-of-m)</code><span> should do it</span></div><div data-t="mmer So obvious when you see it in front of you!  Thanks @spieden"><span class="u" id="1589817771.042700">2020:05:18 16:02:51                 mmer </span><span>So obvious when you see it in front of you!  Thanks @spieden</span></div><div data-t="spieden @nathanmarz I&apos;m having an interesting issue combining  transform  and  stay-then-continue  . I&apos;m replacing a map with a string via transform, and then specter seems to try to navigate the new value like it&apos;s still a map and I get  class java.lang.String cannot be cast to class clojure.lang.Associative  from  do-keypath-transform  . Does that sound familiar at all?"><span class="u" id="1589817901.045700">2020:05:18 16:05:01              spieden </span><span>@nathanmarz I&apos;m having an interesting issue combining </span><code>transform</code><span> and </span><code>stay-then-continue</code><span> . I&apos;m replacing a map with a string via transform, and then specter seems to try to navigate the new value like it&apos;s still a map and I get </span><code>class java.lang.String cannot be cast to class clojure.lang.Associative</code><span> from </span><code>do-keypath-transform</code><span> . Does that sound familiar at all?</span></div><div data-t="lvh I&apos;m confused: isn&apos;t that what stay then continue is supposed to do?"><span class="u" id="1589920068.052400">2020:05:19 20:27:48                       lvh </span><span>I&apos;m confused: isn&apos;t that what stay then continue is supposed to do?</span></div><div data-t="lvh how do you want to transform the map if you&apos;ve already stringified its contents? do you have a more complete toy example?"><span class="u" id="1589920104.052600">2020:05:19 20:28:24                       lvh </span><span>how do you want to transform the map if you&apos;ve already stringified its contents? do you have a more complete toy example?</span></div><div data-t="lvh i&apos;d assume you want postorder there"><span class="u" id="1589920113.052800">2020:05:19 20:28:33                       lvh </span><span>i&apos;d assume you want postorder there</span></div><div data-t="lvh ugh, sorry, I just read the backlog"><span class="u" id="1589920126.053000">2020:05:19 20:28:46                       lvh </span><span>ugh, sorry, I just read the backlog</span></div><div data-t="spieden Yeah that&apos;s what I ended up doing  ⬇️"><span class="u" id="1589920129.053200">2020:05:19 20:28:49                   spieden </span><span>Yeah that&apos;s what I ended up doing </span><b>⬇️</b></div><div data-t="spieden :)"><span class="u" id="1589920132.053400">2020:05:19 20:28:52                   spieden </span><span>:)</span></div><div data-t="mmer There is another step to this:  I have a vector of pairs of vectors.  I want to add a value to the first vector based on a property in the second vector.  Again a simple use case, and probably has a simple answer"><span class="u" id="1589817954.046400">2020:05:18 16:05:54                 mmer </span><span>There is another step to this:  I have a vector of pairs of vectors.  I want to add a value to the first vector based on a property in the second vector.  Again a simple use case, and probably has a simple answer</span></div><div data-t="spieden @mmer You&apos;d probably just handle all that inside your transform function"><span class="u" id="1589818335.047100">2020:05:18 16:12:15              spieden </span><span>@mmer You&apos;d probably just handle all that inside your transform function</span></div><div data-t="mmer @spieden thanks,  I was expecting to be able to pass the first vector to the transform function without having selected it based on the values in the second function."><span class="u" id="1589818419.048200">2020:05:18 16:13:39                 mmer </span><span>@spieden thanks,  I was expecting to be able to pass the first vector to the transform function without having selected it based on the values in the second function.</span></div><div data-t="spieden Ah hrm, well you can pass the whole tuple to the transform based on a value in the second"><span class="u" id="1589818481.049000">2020:05:18 16:14:41              spieden </span><span>Ah hrm, well you can pass the whole tuple to the transform based on a value in the second</span></div><div data-t="spieden .. and then just transform the first vector in it and leave the other alone"><span class="u" id="1589818494.049300">2020:05:18 16:14:54              spieden </span><span>.. and then just transform the first vector in it and leave the other alone</span></div><div data-t="mmer That makes sense"><span class="u" id="1589818523.049800">2020:05:18 16:15:23                 mmer </span><span>That makes sense</span></div><div data-t="spieden (spr/transform [spr/ALL #(fn [[_ v2]] (pred? v2)] transform-v1 vs)"><span class="u" id="1589818568.050800">2020:05:18 16:16:08              spieden </span><code>(spr/transform [spr/ALL #(fn [[_ v2]] (pred? v2)] transform-v1 vs)</code></div><div data-t="mmer Thanks"><span class="u" id="1589818707.051000">2020:05:18 16:18:27                 mmer </span><span>Thanks</span></div><div data-t="spieden @nathanmarz Looks like switching to postorder via  continue-then-stay  did the trick!"><span class="u" id="1589820070.051600">2020:05:18 16:41:10              spieden </span><span>@nathanmarz Looks like switching to postorder via </span><code>continue-then-stay</code><span> did the trick!</span></div><div data-t="spieden Many thanks for specter, as always -- not sure how I&apos;d accomplish this work I&apos;m doing without it"><span class="u" id="1589820094.052000">2020:05:18 16:41:34              spieden </span><span>Many thanks for specter, as always -- not sure how I&apos;d accomplish this work I&apos;m doing without it</span></div><div data-t="Endre Bakken Stovner How do I select multiple things at different levels?

 "><span class="u" id="1590140081.054500">2020:05:22 09:34:41 Endre Bakken Stovner </span><span>How do I select multiple things at different levels?

</span><pre></pre></div><div data-t="Endre Bakken Stovner Test data:

 (def testrules {:plot-quals {:out {:graph &quot;quals.svg&quot; :data &quot;quals.tsv&quot;},},
                :samtools-index {:out &quot;bam/sorted.bam.bai&quot;,},
                :samtools-sort {:out &quot;bam/sorted.bam&quot;}}) 
I want to get the first key and value of out. Was thinking it would start something like

 (select [(collect-one KEY) ALL ALL :out] testrules)"><span class="u" id="1590140201.056500">2020:05:22 09:36:41 Endre Bakken Stovner </span><span>Test data:

</span><pre>(def testrules {:plot-quals {:out {:graph &quot;quals.svg&quot; :data &quot;quals.tsv&quot;},},
                :samtools-index {:out &quot;bam/sorted.bam.bai&quot;,},
                :samtools-sort {:out &quot;bam/sorted.bam&quot;}})</pre><span>
I want to get the first key and value of out. Was thinking it would start something like

</span><pre>(select [(collect-one KEY) ALL ALL :out] testrules)</pre></div><div data-t="Endre Bakken Stovner (select [(collect ALL) ALL :out] testrules) 
got me closer."><span class="u" id="1590140353.057300">2020:05:22 09:39:13      Endre Bakken Stovner </span><pre>(select [(collect ALL) ALL :out] testrules)</pre><span>
got me closer.</span></div><div data-t="mmer (select [(collect-one FIRST FIRST)  ALL LAST :out] testrules)  yields  [[:plot-quals {:graph &quot;quals.svg&quot;, :data &quot;quals.tsv&quot;}] 
  [:plot-quals &quot;bam/sorted.bam.bai&quot;] 
  [:plot-quals &quot;bam/sorted.bam&quot;]]"><span class="u" id="1590157924.057500">2020:05:22 14:32:04                      mmer </span><code>(select [(collect-one FIRST FIRST)  ALL LAST :out] testrules)</code><span> yields </span><code>[[:plot-quals {:graph &quot;quals.svg&quot;, :data &quot;quals.tsv&quot;}]</code><span>
 </span><code>[:plot-quals &quot;bam/sorted.bam.bai&quot;]</code><span>
 </span><code>[:plot-quals &quot;bam/sorted.bam&quot;]]</code></div><div data-t="Endre Bakken Stovner Working through the tutorials now, but thanks for helping me solve some immediate problems :)"><span class="u" id="1590405657.057800">2020:05:25 11:20:57      Endre Bakken Stovner </span><span>Working through the tutorials now, but thanks for helping me solve some immediate problems :)</span></div><div data-t="dadair Can I use spectre to recursively transform java.util.HashMap of java.util.HashMaps to regular clojure maps?"><span class="u" id="1591399618.059200">2020:06:05 23:26:58               dadair </span><span>Can I use spectre to recursively transform java.util.HashMap of java.util.HashMaps to regular clojure maps?</span></div><div data-t="dadair I&apos;m basically trying to go from the top here, where all the maps are java.util.HashMap, to the bottom, where all maps are IAssociative:

 {&quot;name&quot; &quot;foo&quot;
 &quot;children&quot; {&quot;bar&quot; {&quot;name&quot; &quot;bar&quot;
                    &quot;children&quot; {}}
             &quot;baz&quot; {&quot;name&quot; &quot;baz&quot;
                    &quot;children&quot; {&quot;quux&quot; {&quot;name&quot; &quot;quux&quot;
                                        &quot;children&quot; {}}}}}}

;;=&gt; (addition of `ref`, keywordize the keys, make standard IAssociative)

{:name &quot;foo&quot;
 :children {:bar {:name &quot;bar&quot;
                  :children {}
                  :ref &quot;foo/bar&quot;}
            :baz {:name &quot;baz&quot;
                  :children {:quux {:name &quot;quux&quot;
                                    :children {}
                                    :ref &quot;foo/baz/quux&quot;}}
                  :ref &quot;foo/baz&quot;}}
 :ref &quot;foo&quot;}"><span class="u" id="1591400677.059800">2020:06:05 23:44:37               dadair </span><span>I&apos;m basically trying to go from the top here, where all the maps are java.util.HashMap, to the bottom, where all maps are IAssociative:

</span><pre>{&quot;name&quot; &quot;foo&quot;
 &quot;children&quot; {&quot;bar&quot; {&quot;name&quot; &quot;bar&quot;
                    &quot;children&quot; {}}
             &quot;baz&quot; {&quot;name&quot; &quot;baz&quot;
                    &quot;children&quot; {&quot;quux&quot; {&quot;name&quot; &quot;quux&quot;
                                        &quot;children&quot; {}}}}}}

;;=&gt; (addition of `ref`, keywordize the keys, make standard IAssociative)

{:name &quot;foo&quot;
 :children {:bar {:name &quot;bar&quot;
                  :children {}
                  :ref &quot;foo/bar&quot;}
            :baz {:name &quot;baz&quot;
                  :children {:quux {:name &quot;quux&quot;
                                    :children {}
                                    :ref &quot;foo/baz/quux&quot;}}
                  :ref &quot;foo/baz&quot;}}
 :ref &quot;foo&quot;}</pre></div><div data-t="dadair Had an implementation using both clojure.walk and spectre, but want to do it in 1 pass, if possible"><span class="u" id="1591400705.060200">2020:06:05 23:45:05               dadair </span><span>Had an implementation using both clojure.walk and spectre, but want to do it in 1 pass, if possible</span></div><div data-t="dadair I can select each with:
 (def HASH-MAPS
    (sp/recursive-path
     []
     p
     (sp/stay-then-continue
      (sp/must &quot;children&quot;)
      sp/MAP-VALS
      p)))

  (clojure.pprint/pprint
   (sp/select
    [:root HASH-MAPS]
    {:root hm}))"><span class="u" id="1591401102.060800">2020:06:05 23:51:42               dadair </span><span>I can select each with:
</span><pre>(def HASH-MAPS
    (sp/recursive-path
     []
     p
     (sp/stay-then-continue
      (sp/must &quot;children&quot;)
      sp/MAP-VALS
      p)))

  (clojure.pprint/pprint
   (sp/select
    [:root HASH-MAPS]
    {:root hm}))</pre></div><div data-t="dadair It&apos;s the transform in one pass that&apos;s getting me confused &gt;.&lt;"><span class="u" id="1591401115.061200">2020:06:05 23:51:55               dadair </span><span>It&apos;s the transform in one pass that&apos;s getting me confused &gt;.&lt;</span></div><div data-t="mmer @dadair I was going to answer your question thinking it was simple, but then I realise the issue is that you need the name of parent key to be able to construct the ref.  I had a similar issue when traversing a tree.  It is as if you need to collect it on your way but I could never understand how to reference the collected value."><span class="u" id="1591793361.064500">2020:06:10 12:49:21                 mmer </span><span>@dadair I was going to answer your question thinking it was simple, but then I realise the issue is that you need the name of parent key to be able to construct the ref.  I had a similar issue when traversing a tree.  It is as if you need to collect it on your way but I could never understand how to reference the collected value.</span></div><div data-t="dadair I have a working solution if you’re interested,"><span class="u" id="1591923291.064900">2020:06:12 00:54:51               dadair </span><span>I have a working solution if you’re interested,</span></div><div data-t="dadair It was more involved than I thought, but not so bad. Had to extend IKVReduce for Java.util.HashMaps and the map-vals spectre protocols, but all in all it’s pretty succinct code "><span class="u" id="1591923348.066600">2020:06:12 00:55:48               dadair </span><span>It was more involved than I thought, but not so bad. Had to extend IKVReduce for Java.util.HashMaps and the map-vals spectre protocols, but all in all it’s pretty succinct code </span></div><div data-t="dadair I can post a gist maybe tomorrow "><span class="u" id="1591923392.067700">2020:06:12 00:56:32               dadair </span><span>I can post a gist maybe tomorrow </span></div><div data-t="fmn Is there any performance benefit of using  select-first   over  select-one  ? My use case is to select the first one matching the path without considering if there&apos;s any duplicate in the collection."><span class="u" id="1591928632.068800">2020:06:12 02:23:52                  fmn </span><span>Is there any performance benefit of using </span><code>select-first</code><span>  over </span><code>select-one</code><span> ? My use case is to select the first one matching the path without considering if there&apos;s any duplicate in the collection.</span></div><div data-t="nathanmarz @funyako.funyao156 select-first will terminate navigation early if relevant"><span class="u" id="1591978541.069300">2020:06:12 16:15:41           nathanmarz </span><span>@funyako.funyao156 select-first will terminate navigation early if relevant</span></div><div data-t="nathanmarz e.g.  (select-first [ALL even?] data)  will be faster than  (select-one [ALL even?] data)"><span class="u" id="1591978564.069800">2020:06:12 16:16:04           nathanmarz </span><span>e.g. </span><code>(select-first [ALL even?] data)</code><span> will be faster than </span><code>(select-one [ALL even?] data)</code></div><div data-t="fmn Thank you"><span class="u" id="1592009417.070100">2020:06:13 00:50:17                  fmn </span><span>Thank you</span></div><div data-t="Casey hey folks, given a vector of vectors of integers, and a separate vector of integers to remove, how can I remove all integers from the sub-vectors that are in the separate vector?

 (def to-remove [ 4 5 6 ])
(def coll [ [1 2 4] [3 5 8 ] [6] [] ])
(specter/transform [(specter/filterer not-empty) specter/ALL ..?.. ] specter/NONE coll)

;; =&gt; [ [1 2] [3 8] [] [] ]"><span class="u" id="1592918834.072000">2020:06:23 13:27:14                Casey </span><span>hey folks, given a vector of vectors of integers, and a separate vector of integers to remove, how can I remove all integers from the sub-vectors that are in the separate vector?

</span><pre>(def to-remove [ 4 5 6 ])
(def coll [ [1 2 4] [3 5 8 ] [6] [] ])
(specter/transform [(specter/filterer not-empty) specter/ALL ..?.. ] specter/NONE coll)

;; =&gt; [ [1 2] [3 8] [] [] ]</pre></div><div data-t="Casey Seems like this works, is there a more efficient way to write it?

 (specter/setval [specter/ALL specter/ALL (fn [val]  (some #(= val %) to-remove))] specter/NONE coll)"><span class="u" id="1592919594.073300">2020:06:23 13:39:54                Casey </span><span>Seems like this works, is there a more efficient way to write it?

</span><pre>(specter/setval [specter/ALL specter/ALL (fn [val]  (some #(= val %) to-remove))] specter/NONE coll)</pre></div><div data-t="jsa-aerial Might be nicer if you made  to-remove  a set, then it is just  (to-remove val)  or replace  fn  form with  #(to-remove %)"><span class="u" id="1592932007.074700">2020:06:23 17:06:47           jsa-aerial </span><span>Might be nicer if you made </span><code>to-remove</code><span> a set, then it is just </span><code>(to-remove val)</code><span> or replace </span><code>fn</code><span> form with </span><code>#(to-remove %)</code></div><div data-t="avi Hi, sorry if this is a FAQ, but how can I navigate to a map, and then filter the entries in the map, based on certain nested values in the values?"><span class="u" id="1592935258.075800">2020:06:23 18:00:58                  avi </span><span>Hi, sorry if this is a FAQ, but how can I navigate to a map, and then filter the entries in the map, based on certain nested values in the values?</span></div><div data-t="avi Here’s what I’m doing in “plain old Clojure” (plus Medley) that I’m curious how to translate to Specter:

 (-&gt;&gt; (db/read &quot;db&quot;)
     (:technologies)
     (medley/filter-vals
       (fn [tech] (some (fn [rec] (rec &quot;ratified&quot;))
                        (get tech &quot;recommendations&quot;)))))"><span class="u" id="1592935283.075900">2020:06:23 18:01:23                       avi </span><span>Here’s what I’m doing in “plain old Clojure” (plus Medley) that I’m curious how to translate to Specter:

</span><pre>(-&gt;&gt; (db/read &quot;db&quot;)
     (:technologies)
     (medley/filter-vals
       (fn [tech] (some (fn [rec] (rec &quot;ratified&quot;))
                        (get tech &quot;recommendations&quot;)))))</pre></div><div data-t="avi Thanks!"><span class="u" id="1592935286.076100">2020:06:23 18:01:26                       avi </span><span>Thanks!</span></div><div data-t="phronmophobic not sure it&apos;s the most straightforward approach, but you could probably use:
 [:technology MAP-VALS] 
for the path. in your transform function:
• return the original value to keep it
• return spec/NONE to remove a value"><span class="u" id="1592935462.076600">2020:06:23 18:04:22             phronmophobic </span><span>not sure it&apos;s the most straightforward approach, but you could probably use:
</span><pre>[:technology MAP-VALS]</pre><span>
for the path. in your transform function:
• return the original value to keep it
• return spec/NONE to remove a value</span></div><div data-t="avi Thanks! But I’m not looking to transform, just to query."><span class="u" id="1592935488.076800">2020:06:23 18:04:48                       avi </span><span>Thanks! But I’m not looking to transform, just to query.</span></div><div data-t="phronmophobic oh"><span class="u" id="1592935506.077100">2020:06:23 18:05:06             phronmophobic </span><span>oh</span></div><div data-t="avi Yeah, I left if off but when I ran the above code, the last form in the thread-last form was  keys"><span class="u" id="1592935532.077300">2020:06:23 18:05:32                       avi </span><span>Yeah, I left if off but when I ran the above code, the last form in the thread-last form was </span><code>keys</code></div><div data-t="phronmophobic [:technology MAP-VALS (fn [tech] (some (fn [rec] (rec &quot;ratified&quot;))
                        (get tech &quot;recommendations&quot;)))] 
"><span class="u" id="1592935601.077500">2020:06:23 18:06:41             phronmophobic </span><pre>[:technology MAP-VALS (fn [tech] (some (fn [rec] (rec &quot;ratified&quot;))
                        (get tech &quot;recommendations&quot;)))]</pre><span>
</span></div><div data-t="avi interesting, I thought I tried that… I’ll try again, brb!"><span class="u" id="1592935621.077800">2020:06:23 18:07:01                       avi </span><span>interesting, I thought I tried that… I’ll try again, brb!</span></div><div data-t="phronmophobic i&apos;m not specter expert either ¯\(ツ)/¯"><span class="u" id="1592935653.078000">2020:06:23 18:07:33             phronmophobic </span><span>i&apos;m not specter expert either ¯\(ツ)/¯</span></div><div data-t="avi Wait… that’ll navigate to the results of the predicate, right? But I want the map under  :technologies , just filtered"><span class="u" id="1592935689.078400">2020:06:23 18:08:09                       avi </span><span>Wait… that’ll navigate to the results of the predicate, right? But I want the map under </span><code>:technologies</code><span>, just filtered</span></div><div data-t="avi I’m very new to Specter but I’d think it’d have something roughly equivalent to Medley’s  filter-vals  (which filters a map by applying a predicate to the vals in the map, and returns a map containing the matching entries)"><span class="u" id="1592935821.078600">2020:06:23 18:10:21                       avi </span><span>I’m very new to Specter but I’d think it’d have something roughly equivalent to Medley’s </span><code>filter-vals</code><span> (which filters a map by applying a predicate to the vals in the map, and returns a map containing the matching entries)</span></div><div data-t="avi (Or something equivalent to  filter  that I could use to the same effect)"><span class="u" id="1592935845.078800">2020:06:23 18:10:45                       avi </span><span>(Or something equivalent to </span><code>filter</code><span> that I could use to the same effect)</span></div><div data-t="phronmophobic https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#filterer"><span class="u" id="1592935873.079000">2020:06:23 18:11:13             phronmophobic </span><a href="https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#filterer">https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#filterer</a></div><div data-t="avi Right! I tried that but had trouble with it. Thought maybe I just didn’t understand it. I’ll try again… brb"><span class="u" id="1592935904.079200">2020:06:23 18:11:44                       avi </span><span>Right! I tried that but had trouble with it. Thought maybe I just didn’t understand it. I’ll try again… brb</span></div><div data-t="phronmophobic imo, specter is much more useful if you&apos;re transforming or setting data in a deeply nested data structure. if you&apos;re just drilling into a nested data structure, I usually just use the normal clojure functions"><span class="u" id="1592935932.079400">2020:06:23 18:12:12             phronmophobic </span><span>imo, specter is much more useful if you&apos;re transforming or setting data in a deeply nested data structure. if you&apos;re just drilling into a nested data structure, I usually just use the normal clojure functions</span></div><div data-t="avi that makes sense."><span class="u" id="1592935952.079700">2020:06:23 18:12:32                       avi </span><span>that makes sense.</span></div><div data-t="avi But I’d like to build up my own intuition as to when to use Specter, by seeing what it’s like to use it in cases like this"><span class="u" id="1592935974.079900">2020:06:23 18:12:54                       avi </span><span>But I’d like to build up my own intuition as to when to use Specter, by seeing what it’s like to use it in cases like this</span></div><div data-t="phronmophobic 👍"><span class="u" id="1592936000.080100">2020:06:23 18:13:20             phronmophobic </span><b>👍</b></div><div data-t="avi Also, I had to walk a Clojure newbie through the above code and it was non-trivial to explain. I think the path concept could maybe be much more straightforward for folks new to Clojure and Lisps."><span class="u" id="1592936026.080300">2020:06:23 18:13:46                       avi </span><span>Also, I had to walk a Clojure newbie through the above code and it was non-trivial to explain. I think the path concept could maybe be much more straightforward for folks new to Clojure and Lisps.</span></div><div data-t="phronmophobic i&apos;m only a specter novice, so there&apos;s probably a very straightforward way to do it that I don&apos;t know about"><span class="u" id="1592936053.080500">2020:06:23 18:14:13             phronmophobic </span><span>i&apos;m only a specter novice, so there&apos;s probably a very straightforward way to do it that I don&apos;t know about</span></div><div data-t="avi I hear ya, I have the same suspicion"><span class="u" id="1592936241.080700">2020:06:23 18:17:21                       avi </span><span>I hear ya, I have the same suspicion</span></div><div data-t="avi Trying this:

 (select [:technologies
         (filterer MAP-VALS &quot;recommendations&quot; ALL &quot;ratified&quot;)
         MAP-KEYS]
        db) 
getting:  java.lang.ClassCastException:  &quot;class java.lang.String cannot be cast to class java.util.Map$Entry…"><span class="u" id="1592936278.080900">2020:06:23 18:17:58                       avi </span><span>Trying this:

</span><pre>(select [:technologies
         (filterer MAP-VALS &quot;recommendations&quot; ALL &quot;ratified&quot;)
         MAP-KEYS]
        db)</pre><span>
getting: </span><code>java.lang.ClassCastException:  &quot;class java.lang.String cannot be cast to class java.util.Map$Entry…</code></div><div data-t="phronmophobic specter doesn&apos;t recognize strings as map keys like it does for keywords"><span class="u" id="1592936323.081100">2020:06:23 18:18:43             phronmophobic </span><span>specter doesn&apos;t recognize strings as map keys like it does for keywords</span></div><div data-t="avi really?"><span class="u" id="1592936335.081300">2020:06:23 18:18:55                       avi </span><span>really?</span></div><div data-t="phronmophobic I think &quot;recommendations&quot; needs to be (keypath &quot;recommendations&quot;)"><span class="u" id="1592936341.081500">2020:06:23 18:19:01             phronmophobic </span><span>I think &quot;recommendations&quot; needs to be (keypath &quot;recommendations&quot;)</span></div><div data-t="avi I thought i saw that work, one sec…"><span class="u" id="1592936344.081700">2020:06:23 18:19:04                       avi </span><span>I thought i saw that work, one sec…</span></div><div data-t="phronmophobic hmmm, maybe it does"><span class="u" id="1592936379.081900">2020:06:23 18:19:39             phronmophobic </span><span>hmmm, maybe it does</span></div><div data-t="avi Yeah, this works:  (select [:technologies MAP-VALS &quot;recommendations&quot; ALL] db)"><span class="u" id="1592936386.082100">2020:06:23 18:19:46                       avi </span><span>Yeah, this works: </span><code>(select [:technologies MAP-VALS &quot;recommendations&quot; ALL] db)</code></div><div data-t="phronmophobic filterer is complaining because it&apos;s turning the map into a sequence"><span class="u" id="1592937943.084700">2020:06:23 18:45:43             phronmophobic </span><span>filterer is complaining because it&apos;s turning the map into a sequence</span></div><div data-t="phronmophobic maybe something like:
 (spec/select [:technologies
              (spec/filterer  (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot;)
              ALL
              (spec/nthpath 0)]
        db)"><span class="u" id="1592937950.084900">2020:06:23 18:45:50             phronmophobic </span><span>maybe something like:
</span><pre>(spec/select [:technologies
              (spec/filterer  (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot;)
              ALL
              (spec/nthpath 0)]
        db)</pre></div><div data-t="avi huh, that’s surprising. I wonder why it’s doing that. I’d think that’d be antithetical to Specter’s general behavior of leaving types as-is"><span class="u" id="1592938007.085100">2020:06:23 18:46:47                       avi </span><span>huh, that’s surprising. I wonder why it’s doing that. I’d think that’d be antithetical to Specter’s general behavior of leaving types as-is</span></div><div data-t="avi also: thank you!"><span class="u" id="1592938018.085300">2020:06:23 18:46:58                       avi </span><span>also: thank you!</span></div><div data-t="avi interesting… this “works”, but the result is incorrect:

 (select [:technologies
         (filterer (nthpath 1) &quot;recommendations&quot; ALL &quot;ratified&quot;)
         MAP-KEYS]
        db)"><span class="u" id="1592938113.085500">2020:06:23 18:48:33                       avi </span><span>interesting… this “works”, but the result is incorrect:

</span><pre>(select [:technologies
         (filterer (nthpath 1) &quot;recommendations&quot; ALL &quot;ratified&quot;)
         MAP-KEYS]
        db)</pre></div><div data-t="phronmophobic shoot"><span class="u" id="1592938268.085700">2020:06:23 18:51:08             phronmophobic </span><span>shoot</span></div><div data-t="phronmophobic &gt; with the path yields anything other than an empty sequence."><span class="u" id="1592938302.085900">2020:06:23 18:51:42             phronmophobic </span><span>&gt; with the path yields anything other than an empty sequence.</span></div><div data-t="phronmophobic the path is probably yielding false"><span class="u" id="1592938308.086100">2020:06:23 18:51:48             phronmophobic </span><span>the path is probably yielding false</span></div><div data-t="avi the path in  filterer  ?"><span class="u" id="1592938324.086300">2020:06:23 18:52:04                       avi </span><span>the path in </span><code>filterer</code><span> ?</span></div><div data-t="phronmophobic right"><span class="u" id="1592938329.086500">2020:06:23 18:52:09             phronmophobic </span><span>right</span></div><div data-t="avi I wouldn’t think so…?"><span class="u" id="1592938332.086700">2020:06:23 18:52:12                       avi </span><span>I wouldn’t think so…?</span></div><div data-t="avi why would it yield false?"><span class="u" id="1592938338.086900">2020:06:23 18:52:18                       avi </span><span>why would it yield false?</span></div><div data-t="avi I thought any path to something that doesn’t exist yields nil?"><span class="u" id="1592938348.087100">2020:06:23 18:52:28                       avi </span><span>I thought any path to something that doesn’t exist yields nil?</span></div><div data-t="phronmophobic or whatever is in the ratified key"><span class="u" id="1592938349.087300">2020:06:23 18:52:29             phronmophobic </span><span>or whatever is in the ratified key</span></div><div data-t="phronmophobic does the ratified key exist even for unratified recommendations?"><span class="u" id="1592938372.087500">2020:06:23 18:52:52             phronmophobic </span><span>does the ratified key exist even for unratified recommendations?</span></div><div data-t="avi right. but most of the maps in the sequences that correspond to the &quot;recommendations&quot; keys do not have the key &quot;ratified&quot;; only a few do. I’m trying to find those technologies that have recommendations that have been ratified"><span class="u" id="1592938402.087700">2020:06:23 18:53:22                       avi </span><span>right. but most of the maps in the sequences that correspond to the &quot;recommendations&quot; keys do not have the key &quot;ratified&quot;; only a few do. I’m trying to find those technologies that have recommendations that have been ratified</span></div><div data-t="phronmophobic this seems to work:
 (def data {:technologies
           {0 {&quot;recommendations&quot; [{&quot;ratified&quot; true}]}
            1 {&quot;recommendations&quot; [{&quot;ratified&quot; false}]}
            2 {&quot;recommendations&quot; []}}})

(spec/select [:technologies

              (spec/filterer  (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot; identity)
              spec/MAP-KEYS
              ;; ALL
              ;;(spec/nthpath 0)
              ]
             data)"><span class="u" id="1592938457.087900">2020:06:23 18:54:17             phronmophobic </span><span>this seems to work:
</span><pre>(def data {:technologies
           {0 {&quot;recommendations&quot; [{&quot;ratified&quot; true}]}
            1 {&quot;recommendations&quot; [{&quot;ratified&quot; false}]}
            2 {&quot;recommendations&quot; []}}})

(spec/select [:technologies

              (spec/filterer  (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot; identity)
              spec/MAP-KEYS
              ;; ALL
              ;;(spec/nthpath 0)
              ]
             data)</pre></div><div data-t="phronmophobic the above will return [0]"><span class="u" id="1592938493.088100">2020:06:23 18:54:53             phronmophobic </span><span>the above will return [0]</span></div><div data-t="avi it does!"><span class="u" id="1592938500.088300">2020:06:23 18:55:00                       avi </span><span>it does!</span></div><div data-t="avi I don’t get it though  🙃"><span class="u" id="1592938507.088500">2020:06:23 18:55:07                       avi </span><span>I don’t get it though </span><b>🙃</b></div><div data-t="avi why is the  identity  needed? what is it doing?"><span class="u" id="1592938536.088700">2020:06:23 18:55:36                       avi </span><span>why is the </span><code>identity</code><span> needed? what is it doing?</span></div><div data-t="phronmophobic so without identity and removing filterer:
 (def data {:technologies
           {0 {&quot;recommendations&quot; [{&quot;ratified&quot; true}]}
            1 {&quot;recommendations&quot; [{&quot;ratified&quot; false}]}
            2 {&quot;recommendations&quot; []}}})

(spec/select [:technologies
              ALL
              (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot; 
              ;; spec/MAP-KEYS
              ;; ALL
              ;;(spec/nthpath 0)
              ]
             data)"><span class="u" id="1592938587.088900">2020:06:23 18:56:27             phronmophobic </span><span>so without identity and removing filterer:
</span><pre>(def data {:technologies
           {0 {&quot;recommendations&quot; [{&quot;ratified&quot; true}]}
            1 {&quot;recommendations&quot; [{&quot;ratified&quot; false}]}
            2 {&quot;recommendations&quot; []}}})

(spec/select [:technologies
              ALL
              (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot; 
              ;; spec/MAP-KEYS
              ;; ALL
              ;;(spec/nthpath 0)
              ]
             data)</pre></div><div data-t="phronmophobic you get [true false]"><span class="u" id="1592938596.089100">2020:06:23 18:56:36             phronmophobic </span><span>you get [true false]</span></div><div data-t="avi That’s not what I’m getting"><span class="u" id="1592938630.089400">2020:06:23 18:57:10                       avi </span><span>That’s not what I’m getting</span></div><div data-t="phronmophobic basically, it can navigate to the &quot;ratified&quot; key"><span class="u" id="1592938630.089600">2020:06:23 18:57:10             phronmophobic </span><span>basically, it can navigate to the &quot;ratified&quot; key</span></div><div data-t="avi oh wait…"><span class="u" id="1592938637.089800">2020:06:23 18:57:17                       avi </span><span>oh wait…</span></div><div data-t="phronmophobic I also removed the filterer"><span class="u" id="1592938642.090000">2020:06:23 18:57:22             phronmophobic </span><span>I also removed the filterer</span></div><div data-t="avi ah interesting"><span class="u" id="1592938649.090200">2020:06:23 18:57:29                       avi </span><span>ah interesting</span></div><div data-t="phronmophobic and the path exists if it can navigate there"><span class="u" id="1592938653.090400">2020:06:23 18:57:33             phronmophobic </span><span>and the path exists if it can navigate there</span></div><div data-t="avi I see, you did that as a way to debug the filterer path?"><span class="u" id="1592938665.090600">2020:06:23 18:57:45                       avi </span><span>I see, you did that as a way to debug the filterer path?</span></div><div data-t="phronmophobic so filterer will keep paths that it can navigate to, even if the value it navigates to is falsey"><span class="u" id="1592938684.090900">2020:06:23 18:58:04             phronmophobic </span><span>so filterer will keep paths that it can navigate to, even if the value it navigates to is falsey</span></div><div data-t="avi cool, that’s clever, makes sense!"><span class="u" id="1592938686.091100">2020:06:23 18:58:06                       avi </span><span>cool, that’s clever, makes sense!</span></div><div data-t="avi that’s… surprising"><span class="u" id="1592938694.091300">2020:06:23 18:58:14                       avi </span><span>that’s… surprising</span></div><div data-t="avi but, so be it"><span class="u" id="1592938697.091500">2020:06:23 18:58:17                       avi </span><span>but, so be it</span></div><div data-t="phronmophobic so identity is the simplest function that I can think of to filter based on truthiness"><span class="u" id="1592938705.091700">2020:06:23 18:58:25             phronmophobic </span><span>so identity is the simplest function that I can think of to filter based on truthiness</span></div><div data-t="phronmophobic I think filterer has the right design, but it is a little surprising at first"><span class="u" id="1592938736.091900">2020:06:23 18:58:56             phronmophobic </span><span>I think filterer has the right design, but it is a little surprising at first</span></div><div data-t="avi some?  ?"><span class="u" id="1592938751.092100">2020:06:23 18:59:11                       avi </span><code>some?</code><span> ?</span></div><div data-t="phronmophobic (some? false)  =&gt; true"><span class="u" id="1592938789.092300">2020:06:23 18:59:49             phronmophobic </span><code>(some? false)</code><span> =&gt; true</span></div><div data-t="phronmophobic actually,  boolean  is probably clearer"><span class="u" id="1592938815.092500">2020:06:23 19:00:15             phronmophobic </span><span>actually, </span><code>boolean</code><span> is probably clearer</span></div><div data-t="avi 😵"><span class="u" id="1592938836.092700">2020:06:23 19:00:36                       avi </span><b>😵</b></div><div data-t="phronmophobic (def data {:technologies
           {0 {&quot;recommendations&quot; [{&quot;ratified&quot; true}]}
            1 {&quot;recommendations&quot; [{&quot;ratified&quot; false}]}
            2 {&quot;recommendations&quot; []}}})

(spec/select [:technologies
              (spec/filterer  (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot; boolean)
              spec/MAP-KEYS
              ]
             data)"><span class="u" id="1592938839.092900">2020:06:23 19:00:39             phronmophobic </span><pre>(def data {:technologies
           {0 {&quot;recommendations&quot; [{&quot;ratified&quot; true}]}
            1 {&quot;recommendations&quot; [{&quot;ratified&quot; false}]}
            2 {&quot;recommendations&quot; []}}})

(spec/select [:technologies
              (spec/filterer  (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot; boolean)
              spec/MAP-KEYS
              ]
             data)</pre></div><div data-t="phronmophobic some? &apos;s doc string is correct:
 clojure.core/some?
 [x]
Added in 1.6
  Returns true if x is not nil, false otherwise."><span class="u" id="1592938897.093100">2020:06:23 19:01:37             phronmophobic </span><code>some?</code><span>&apos;s doc string is correct:
</span><pre>clojure.core/some?
 [x]
Added in 1.6
  Returns true if x is not nil, false otherwise.</pre></div><div data-t="avi So  some?  is equivalent to  (complement nil?)    …. ?"><span class="u" id="1592938948.093300">2020:06:23 19:02:28                       avi </span><span>So </span><code>some?</code><span> is equivalent to </span><code>(complement nil?)</code><span>   …. ?</span></div><div data-t="avi Anyway, I still don’t quite get  filterer  — but a prerequisite to getting it is seeing what works. Which I’ve got now. Thank you so much!"><span class="u" id="1592938988.093500">2020:06:23 19:03:08                       avi </span><span>Anyway, I still don’t quite get </span><code>filterer</code><span> — but a prerequisite to getting it is seeing what works. Which I’ve got now. Thank you so much!</span></div><div data-t="Casey Is there away to setval on a path but only set the first matching value?"><span class="u" id="1592936998.083000">2020:06:23 18:29:58                Casey </span><span>Is there away to setval on a path but only set the first matching value?</span></div><div data-t="Casey Using my example from before, if coll was  (def coll [ [1 2 4] [3 5 8 4] [6] [] ])    I&apos;d like the result to be  ;; =&gt; [ [1 2] [3 8 4] [] [] ]   (that is, the 4 is only removed once)"><span class="u" id="1592937265.083900">2020:06:23 18:34:25                Casey </span><span>Using my example from before, if coll was </span><code>(def coll [ [1 2 4] [3 5 8 4] [6] [] ])</code><span>   I&apos;d like the result to be </span><code>;; =&gt; [ [1 2] [3 8 4] [] [] ]</code><span>  (that is, the 4 is only removed once)</span></div><div data-t="Casey If I add a  FIRST  after the  (fn ...)  in the path, I get a  Error: 4 is not ISeqable"><span class="u" id="1592937324.084600">2020:06:23 18:35:24                Casey </span><span>If I add a </span><code>FIRST</code><span> after the </span><code>(fn ...)</code><span> in the path, I get a </span><code>Error: 4 is not ISeqable</code></div><div data-t="Vincent Cantin Hi. I am trying to collect all values which are associated to a keyword  :tags  in a hierarchy of maps. Is there an easy way to do that using Specter?"><span class="u" id="1595853735.099600">2020:07:27 12:42:15       Vincent Cantin </span><span>Hi. I am trying to collect all values which are associated to a keyword </span><code>:tags</code><span> in a hierarchy of maps. Is there an easy way to do that using Specter?</span></div><div data-t="Vincent Cantin I tried this, but it does not walk into maps which have  :tags :
 (s/select [(s/walker #(and (map? %) (contains? % :tags))) :tags s/ALL]
          {:a {:tags [1 {:tags [2]}]}
           :b {:tags [3]}})
; =&gt; [1 {:tags [2]} 3]"><span class="u" id="1595855579.101000">2020:07:27 13:12:59       Vincent Cantin </span><span>I tried this, but it does not walk into maps which have </span><code>:tags</code><span>:
</span><pre>(s/select [(s/walker #(and (map? %) (contains? % :tags))) :tags s/ALL]
          {:a {:tags [1 {:tags [2]}]}
           :b {:tags [3]}})
; =&gt; [1 {:tags [2]} 3]</pre></div><div data-t="nathanmarz @vincent.cantin easy to do with  recursive-path 
 user=&gt; (def data
  #_=&gt;   {:a {:tags [1 {:tags [2]}]}
  #_=&gt;    :b {:tags [3]}})
#&apos;user/data
user=&gt; 

user=&gt; (def MY-WALKER
  #_=&gt;   (recursive-path [] p
  #_=&gt;     (continue-then-stay
  #_=&gt;       (cond-path map? MAP-VALS
  #_=&gt;                  sequential? ALL)
  #_=&gt;       p
  #_=&gt;       )))
#&apos;user/MY-WALKER
user=&gt; 

user=&gt; (select [MY-WALKER map? (must :tags) ALL] data)
[2 1 {:tags [2]} 3] 
"><span class="u" id="1595876002.102400">2020:07:27 18:53:22           nathanmarz </span><span>@vincent.cantin easy to do with </span><code>recursive-path</code><span>
</span><pre>user=&gt; (def data
  #_=&gt;   {:a {:tags [1 {:tags [2]}]}
  #_=&gt;    :b {:tags [3]}})
#&apos;user/data
user=&gt; 

user=&gt; (def MY-WALKER
  #_=&gt;   (recursive-path [] p
  #_=&gt;     (continue-then-stay
  #_=&gt;       (cond-path map? MAP-VALS
  #_=&gt;                  sequential? ALL)
  #_=&gt;       p
  #_=&gt;       )))
#&apos;user/MY-WALKER
user=&gt; 

user=&gt; (select [MY-WALKER map? (must :tags) ALL] data)
[2 1 {:tags [2]} 3]</pre><span>
</span></div><div data-t="Vincent Cantin @nathanmarz Thx"><span class="u" id="1595899775.103300">2020:07:28 01:29:35       Vincent Cantin </span><span>@nathanmarz Thx</span></div><div data-t="mbertheau Hi! How would I go about sorting a sequence in specter, letting specter worry about creating the same sequence type?"><span class="u" id="1597674113.106600">2020:08:17 14:21:53            mbertheau </span><span>Hi! How would I go about sorting a sequence in specter, letting specter worry about creating the same sequence type?</span></div><div data-t="phronmophobic how nested is your data? you might be able to get away with  (into (empty coll) (sort coll))"><span class="u" id="1597675137.108200">2020:08:17 14:38:57             phronmophobic </span><span>how nested is your data? you might be able to get away with </span><code>(into (empty coll) (sort coll))</code></div><div data-t="Vincent Cantin Assuming that we have a vector of hashmaps containing addresses, how to use specter to group them by  :country , then by  :city  ?
(I could do it without specter, but I am curious)"><span class="u" id="1597771966.110300">2020:08:18 17:32:46       Vincent Cantin </span><span>Assuming that we have a vector of hashmaps containing addresses, how to use specter to group them by </span><code>:country</code><span>, then by </span><code>:city</code><span> ?
(I could do it without specter, but I am curious)</span></div><div data-t="isak (specter/select [(specter/transformed [] (partial group-by :country))
                   (specter/transformed [specter/MAP-VALS] (partial group-by :city))]
                  addresses)"><span class="u" id="1597773926.110400">2020:08:18 18:05:26                      isak </span><pre>(specter/select [(specter/transformed [] (partial group-by :country))
                   (specter/transformed [specter/MAP-VALS] (partial group-by :city))]
                  addresses)</pre></div><div data-t="isak (i&apos;m kind of new, so maybe there is a smarter way)"><span class="u" id="1597773945.110600">2020:08:18 18:05:45                      isak </span><span>(i&apos;m kind of new, so maybe there is a smarter way)</span></div><div data-t="Vincent Cantin I noticed the  s/view  that could be used instead of  s/transformed"><span class="u" id="1598189671.000100">2020:08:23 13:34:31            Vincent Cantin </span><span>I noticed the </span><code>s/view</code><span> that could be used instead of </span><code>s/transformed</code></div><div data-t="fredmonroe im trying to make this:
 (def cells {:4 {:2 {:text &quot;fred&quot;, :datatype nil}}, :5 {:4 {:text &quot;bob&quot;, :datatype nil}}, :8 {:1 {:text &quot;fred&quot;, :datatype nil}}) 

become:
 [{:row 5 :col 5 :text &quot;bob&quot; :datattype nil}] 

so far i have this nav:
 (defn bob? [x] (= (:text x) &quot;bob&quot;)) 

 (s/select [s/MAP-VALS s/MAP-VALS bob?]  cells) 

which gives:
 [{:text &quot;bob&quot;, :datatype nil} 

i can&apos;t seem to figure out collect-*, putval and friends well enough to grab the keys along the path, appreciate any guidance anybody might have thank you"><span class="u" id="1598474703.004600">2020:08:26 20:45:03           fredmonroe </span><span>im trying to make this:
</span><code>(def cells {:4 {:2 {:text &quot;fred&quot;, :datatype nil}}, :5 {:4 {:text &quot;bob&quot;, :datatype nil}}, :8 {:1 {:text &quot;fred&quot;, :datatype nil}})</code><span>

become:
</span><code>[{:row 5 :col 5 :text &quot;bob&quot; :datattype nil}]</code><span>

so far i have this nav:
</span><code>(defn bob? [x] (= (:text x) &quot;bob&quot;))</code><span>

</span><code>(s/select [s/MAP-VALS s/MAP-VALS bob?]  cells)</code><span>

which gives:
</span><code>[{:text &quot;bob&quot;, :datatype nil}</code><span>

i can&apos;t seem to figure out collect-*, putval and friends well enough to grab the keys along the path, appreciate any guidance anybody might have thank you</span></div><div data-t="arwakode Does this help?

 (sp/select [ALL (sp/collect-one [FIRST]) LAST
              ALL (sp/collect-one [FIRST]) LAST
              bob?] cells) 
"><span class="u" id="1598478954.005100">2020:08:26 21:55:54             arwakode </span><span>Does this help?

</span><pre>(sp/select [ALL (sp/collect-one [FIRST]) LAST
              ALL (sp/collect-one [FIRST]) LAST
              bob?] cells)</pre><span>
</span></div><div data-t="arwakode I use  ALL (sp/collect-one [FIRST]) LAST  pattern to collect keys and continue on traversing."><span class="u" id="1598479003.006100">2020:08:26 21:56:43             arwakode </span><span>I use </span><code>ALL (sp/collect-one [FIRST]) LAST</code><span> pattern to collect keys and continue on traversing.</span></div><div data-t="arwakode You get  [[:5 :4 {:text &quot;bob&quot;, :datatype nil}]]  which then i then guess you have to  (map)  to something to integrate into the the map at the third slot."><span class="u" id="1598479073.007200">2020:08:26 21:57:53             arwakode </span><span>You get </span><code>[[:5 :4 {:text &quot;bob&quot;, :datatype nil}]]</code><span> which then i then guess you have to </span><code>(map)</code><span> to something to integrate into the the map at the third slot.</span></div><div data-t="fredmonroe YES thank you, you gave me a great insight there - by using MAP-VALS i was effectively stripping off access to the keys i needed to collect - i like the way you indented everything too - helps make clear how it works. thank you!"><span class="u" id="1598480240.009100">2020:08:26 22:17:20           fredmonroe </span><span>YES thank you, you gave me a great insight there - by using MAP-VALS i was effectively stripping off access to the keys i needed to collect - i like the way you indented everything too - helps make clear how it works. thank you!</span></div><div data-t="Daniel Craig @nathanmarz Hi would you be interesting in presenting Specter for our meetup group?  We’re the #mid-cities-meetup group based in Southlake Texas.  We meet online every first Monday of the month and @johnjelinek and I are interested in learning about what Specter can do"><span class="u" id="1599506171.005400">2020:09:07 19:16:11         Daniel Craig </span><span>@nathanmarz Hi would you be interesting in presenting Specter for our meetup group?  We’re the #mid-cities-meetup group based in Southlake Texas.  We meet online every first Monday of the month and @johnjelinek and I are interested in learning about what Specter can do</span></div><div data-t="nathanmarz @danielmartincraig don&apos;t have time unfortunately"><span class="u" id="1599517901.006100">2020:09:07 22:31:41           nathanmarz </span><span>@danielmartincraig don&apos;t have time unfortunately</span></div><div data-t="Daniel Craig Ok thanks anyways"><span class="u" id="1599525335.006500">2020:09:08 00:35:35         Daniel Craig </span><span>Ok thanks anyways</span></div><div data-t="Jeff Evans Is there any appetite for incorporating  spec  into Specter?  Setting aside the tongue-twistedness of that combination…"><span class="u" id="1599598993.007400">2020:09:08 21:03:13           Jeff Evans </span><span>Is there any appetite for incorporating </span><code>spec</code><span> into Specter?  Setting aside the tongue-twistedness of that combination…</span></div><div data-t="nathanmarz how so?"><span class="u" id="1599623430.007600">2020:09:09 03:50:30           nathanmarz </span><span>how so?</span></div><div data-t="Petrus Theron How can I transform a nested data structure lazily and recursively with Specter, e.g. to recursively build out a tree with children given some roots?

I read through the docs on Using Specter Recursively, but it&apos;s not obvious to me how to &quot;inject&quot; new values into the data structure while navigating."><span class="u" id="1599655307.009900">2020:09:09 12:41:47        Petrus Theron </span><span>How can I transform a nested data structure lazily and recursively with Specter, e.g. to recursively build out a tree with children given some roots?

I read through the docs on Using Specter Recursively, but it&apos;s not obvious to me how to &quot;inject&quot; new values into the data structure while navigating.</span></div><div data-t="Jeff Evans Re: spec, was just thinking in terms of validating arguments to the macros.  Although, that’s already happening in some places via:  https://github.com/redplanetlabs/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L379"><span class="u" id="1599668670.010400">2020:09:09 16:24:30           Jeff Evans </span><span>Re: spec, was just thinking in terms of validating arguments to the macros.  Although, that’s already happening in some places via: </span><a href="https://github.com/redplanetlabs/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L379">https://github.com/redplanetlabs/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L379</a></div><div data-t="unbalanced Hiya @nathanmarz!  I was inspired by your recent hackernews article to try and jump into Specter again.  I&apos;ve tried a few times in the path and... well, I&apos;m kind of thick, I think.  Is there a most recent &quot;best way&quot; to learn Specter from the ground up?"><span class="u" id="1599750408.011800">2020:09:10 15:06:48           unbalanced </span><span>Hiya @nathanmarz!  I was inspired by your recent hackernews article to try and jump into Specter again.  I&apos;ve tried a few times in the path and... well, I&apos;m kind of thick, I think.  Is there a most recent &quot;best way&quot; to learn Specter from the ground up?</span></div><div data-t="Jeff Evans did you see all the stuff listed here?   https://github.com/redplanetlabs/specter"><span class="u" id="1599751698.011900">2020:09:10 15:28:18                Jeff Evans </span><span>did you see all the stuff listed here?  </span><a href="https://github.com/redplanetlabs/specter">https://github.com/redplanetlabs/specter</a></div><div data-t="Jeff Evans Just noticed something interesting today.  Having a dangling  selected?  (i.e. no more paths after it) works in  clj  but fails in  cljs  .
 (require &apos;[com.rpl.specter :as sp])
(sp/select [sp/ALL even? sp/selected?] [1 3 5])
# in clj
=&gt; []
# in cljs
Error: No protocol method ImplicitNav.implicit-nav defined for type cljs.core/MetaFn: [object Object]"><span class="u" id="1599767043.014000">2020:09:10 19:44:03           Jeff Evans </span><span>Just noticed something interesting today.  Having a dangling </span><code>selected?</code><span> (i.e. no more paths after it) works in </span><code>clj</code><span> but fails in </span><code>cljs</code><span> .
</span><pre>(require &apos;[com.rpl.specter :as sp])
(sp/select [sp/ALL even? sp/selected?] [1 3 5])
# in clj
=&gt; []
# in cljs
Error: No protocol method ImplicitNav.implicit-nav defined for type cljs.core/MetaFn: [object Object]</pre></div><div data-t="nathanmarz @goomba the Learn Specter section on the github page is probably best place to start"><span class="u" id="1599775045.015500">2020:09:10 21:57:25           nathanmarz </span><span>@goomba the Learn Specter section on the github page is probably best place to start</span></div><div data-t="nathanmarz @jeffrey.wayne.evans I guess  MetaFn  in cljs is not a  function"><span class="u" id="1599775181.016600">2020:09:10 21:59:41           nathanmarz </span><span>@jeffrey.wayne.evans I guess </span><code>MetaFn</code><span> in cljs is not a </span><code>function</code></div><div data-t="nathanmarz so the implicit nav doesn&apos;t kick in"><span class="u" id="1599775186.016800">2020:09:10 21:59:46           nathanmarz </span><span>so the implicit nav doesn&apos;t kick in</span></div><div data-t="jsabeaudry Which predicate to use to only transform if the key is present? for example  (transform [:a ?] inc {:b 2})"><span class="u" id="1600190715.018100">2020:09:15 17:25:15           jsabeaudry </span><span>Which predicate to use to only transform if the key is present? for example </span><code>(transform [:a ?] inc {:b 2})</code></div><div data-t="phronmophobic must  ?  https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#must"><span class="u" id="1600191552.018500">2020:09:15 17:39:12        phronmophobic </span><code>must</code><span> ? </span><a href="https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#must">https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#must</a></div><div data-t="jsabeaudry Yup, exactly! Thank you!"><span class="u" id="1600193493.019000">2020:09:15 18:11:33                jsabeaudry </span><span>Yup, exactly! Thank you!</span></div><div data-t="phronmophobic &gt; (spec/transform [spec/ALL (spec/must :a)] inc [{:b 2}
                                                 {:a 2}])
[{:b 2} {:a 3}]"><span class="u" id="1600191668.018900">2020:09:15 17:41:08        phronmophobic </span><pre>&gt; (spec/transform [spec/ALL (spec/must :a)] inc [{:b 2}
                                                 {:a 2}])
[{:b 2} {:a 3}]</pre></div><div data-t="Jeff Evans Has anyone managed to use Specter in self-hosted CLJS?"><span class="u" id="1600992553.000900">2020:09:25 00:09:13           Jeff Evans </span><span>Has anyone managed to use Specter in self-hosted CLJS?</span></div><div data-t="nathanmarz there&apos;s some tickets open for that"><span class="u" id="1601037322.001100">2020:09:25 12:35:22           nathanmarz </span><span>there&apos;s some tickets open for that</span></div><div data-t="nathanmarz from what I recall there&apos;s some changes needed to the inline caching implementation to support bootstrap"><span class="u" id="1601037349.001500">2020:09:25 12:35:49           nathanmarz </span><span>from what I recall there&apos;s some changes needed to the inline caching implementation to support bootstrap</span></div><div data-t="nathanmarz https://github.com/redplanetlabs/specter/issues/72"><span class="u" id="1601037354.001700">2020:09:25 12:35:54           nathanmarz </span><a href="https://github.com/redplanetlabs/specter/issues/72">https://github.com/redplanetlabs/specter/issues/72</a></div><div data-t="jeaye Is there a more efficient way to do this (while keeping the recursive abilities)?

 (def ALL-RECURSIVE (recursive-path [] p
                                   (cond-path
                                     map? (stay-then-continue MAP-VALS p)
                                     coll? (stay-then-continue ALL p))))
(transform [ALL-RECURSIVE MAP-VALS (pred #(and (map? %) (contains? % :foo)))]
           :foo
           {:a {:foo :b}}) ; =&gt; {:a :b}"><span class="u" id="1601345025.003200">2020:09:29 02:03:45                jeaye </span><span>Is there a more efficient way to do this (while keeping the recursive abilities)?

</span><pre>(def ALL-RECURSIVE (recursive-path [] p
                                   (cond-path
                                     map? (stay-then-continue MAP-VALS p)
                                     coll? (stay-then-continue ALL p))))
(transform [ALL-RECURSIVE MAP-VALS (pred #(and (map? %) (contains? % :foo)))]
           :foo
           {:a {:foo :b}}) ; =&gt; {:a :b}</pre></div><div data-t="Lucy Wang using walker?
 (transform [(walker (clojure.core/every-pred map? :foo))]
           :foo
           {:a {:foo :b}})"><span class="u" id="1601345762.003600">2020:09:29 02:16:02            Lucy Wang </span><span>using walker?
</span><pre>(transform [(walker (clojure.core/every-pred map? :foo))]
           :foo
           {:a {:foo :b}})</pre></div><div data-t="jeaye I&apos;ll benchmark it."><span class="u" id="1601346661.003800">2020:09:29 02:31:01                jeaye </span><span>I&apos;ll benchmark it.</span></div><div data-t="jeaye A bit slower, it seems. Mine was  [:attrs nil] 13µs. I&apos;m doing some other things in the benchmark, which is why the numbers are higher than just benchmarking that one transform, but those things are constant across both tests."><span class="u" id="1601346868.005400">2020:09:29 02:34:28                jeaye </span><span>A bit slower, it seems. Mine was </span><del>11µs. With the walker, it's </del><span>13µs. I&apos;m doing some other things in the benchmark, which is why the numbers are higher than just benchmarking that one transform, but those things are constant across both tests.</span></div><div data-t="jeaye Seems like your usage of  every-pred  is marginally faster than my  and , though.  🙂"><span class="u" id="1601347056.005900">2020:09:29 02:37:36                jeaye </span><span>Seems like your usage of </span><code>every-pred</code><span> is marginally faster than my </span><code>and</code><span>, though. </span><b>🙂</b></div><div data-t="Lucy Wang Or use meander
 (require &apos;[meander.epsilon :as m]
         &apos;[meander.strategy.epsilon :as m*])

(def replace-foo
  (m*/rewrite
   {:foo (m/some ?xs)} ?xs))

(def replace-all-foos
  (m*/until =
    (m*/bottom-up
     (m*/attempt replace-foo))))

(replace-all-foos {:a {:foo :b}}) 
"><span class="u" id="1601362253.006400">2020:09:29 06:50:53            Lucy Wang </span><span>Or use meander
</span><pre>(require &apos;[meander.epsilon :as m]
         &apos;[meander.strategy.epsilon :as m*])

(def replace-foo
  (m*/rewrite
   {:foo (m/some ?xs)} ?xs))

(def replace-all-foos
  (m*/until =
    (m*/bottom-up
     (m*/attempt replace-foo))))

(replace-all-foos {:a {:foo :b}})</pre><span>
</span></div><div data-t="Patrick Farwick Is there a good way to get the value of a key that is the most deeply nested in a map? The map could have any level of nesting.
So if I have  {:a {:a 1 :b {:c 2 :d {:a {:e 4}}}}} 
I want  {:e 4}  but am having trouble getting there. Thanks"><span class="u" id="1601875329.009100">2020:10:05 05:22:09      Patrick Farwick </span><span>Is there a good way to get the value of a key that is the most deeply nested in a map? The map could have any level of nesting.
So if I have </span><code>{:a {:a 1 :b {:c 2 :d {:a {:e 4}}}}}</code><span>
I want </span><code>{:e 4}</code><span> but am having trouble getting there. Thanks</span></div><div data-t="Jeff Evans you can use recursion.
 (def GET-E [(s/recursive-path [] p
                    (s/if-path map?
                               (s/if-path (s/must :e) (s/continue-then-stay [s/MAP-VALS p]) [s/MAP-VALS p]) s/STOP)) (s/submap [:e])])

(s/select GET-E {:a {:a 1 :b {:c 2 :d {:a {:e 4 :l 5}}}}})
=&gt; [{:e 4}]"><span class="u" id="1601914683.009500">2020:10:05 16:18:03           Jeff Evans </span><span>you can use recursion.
</span><pre>(def GET-E [(s/recursive-path [] p
                    (s/if-path map?
                               (s/if-path (s/must :e) (s/continue-then-stay [s/MAP-VALS p]) [s/MAP-VALS p]) s/STOP)) (s/submap [:e])])

(s/select GET-E {:a {:a 1 :b {:c 2 :d {:a {:e 4 :l 5}}}}})
=&gt; [{:e 4}]</pre></div><div data-t="Petrus Theron How can I transform a map based on the key? E.g.
 (let [key-&gt;xf {:a inc, :b :dec}]
  (S/transform [?] key-&gt;xf {:a 10, :b 20, :c 30}))
=&gt; {:a 11, :b 19, :c 30} 
I suspect I can use  view  or  transformed  for this, but not sure how. I found a  FIND-KEYS  navigator on SO that navigates to the values of matching keys, but it isn’t quite what I’m looking for:
 (def FIND-KEYS
  &quot;Like clojure.walk/postwalk but for Specter.
  Use as [FIND-KEYS (S/must :key)].&quot;
  (S/recursive-path [] p
    (S/cond-path map?
      (S/continue-then-stay [S/MAP-VALS p])
      vector? [S/ALL p]
      S/STAY))) 
E.g.
 (S/select [FIND-KEYS (S/must :c)] {:a 123 :b {:c 456}})
=&gt; 456 
I guess I can do it with a plain-old reduce-kv, but hoping I could do it with Specter:
 (defn transform-map
  [mappings m]
  (reduce-kv
    (fn [acc k vf]
      (if (contains? acc k)
        (update acc k vf)
        acc)) m mappings))

(transform-map {:a inc, :b dec} {:a 10, :b 20})
=&gt; {:a 11, :b 19}"><span class="u" id="1602062645.012100">2020:10:07 09:24:05        Petrus Theron </span><span>How can I transform a map based on the key? E.g.
</span><pre>(let [key-&gt;xf {:a inc, :b :dec}]
  (S/transform [?] key-&gt;xf {:a 10, :b 20, :c 30}))
=&gt; {:a 11, :b 19, :c 30}</pre><span>
I suspect I can use </span><code>view</code><span> or </span><code>transformed</code><span> for this, but not sure how. I found a </span><code>FIND-KEYS</code><span> navigator on SO that navigates to the values of matching keys, but it isn’t quite what I’m looking for:
</span><pre>(def FIND-KEYS
  &quot;Like clojure.walk/postwalk but for Specter.
  Use as [FIND-KEYS (S/must :key)].&quot;
  (S/recursive-path [] p
    (S/cond-path map?
      (S/continue-then-stay [S/MAP-VALS p])
      vector? [S/ALL p]
      S/STAY)))</pre><span>
E.g.
</span><pre>(S/select [FIND-KEYS (S/must :c)] {:a 123 :b {:c 456}})
=&gt; 456</pre><span>
I guess I can do it with a plain-old reduce-kv, but hoping I could do it with Specter:
</span><pre>(defn transform-map
  [mappings m]
  (reduce-kv
    (fn [acc k vf]
      (if (contains? acc k)
        (update acc k vf)
        acc)) m mappings))

(transform-map {:a inc, :b dec} {:a 10, :b 20})
=&gt; {:a 11, :b 19}</pre></div><div data-t="Jeff Evans (def key-&gt;xf {:a inc :b dec :c identity})
(s/transform [s/ALL] (fn [entry] (let [[k v] entry] [k ((k key-&gt;xf) v)])) {:a 10, :b 20, :c 30})
=&gt; {:a 11, :b 19, :c 30}"><span class="u" id="1602082300.012800">2020:10:07 14:51:40           Jeff Evans </span><pre>(def key-&gt;xf {:a inc :b dec :c identity})
(s/transform [s/ALL] (fn [entry] (let [[k v] entry] [k ((k key-&gt;xf) v)])) {:a 10, :b 20, :c 30})
=&gt; {:a 11, :b 19, :c 30}</pre></div><div data-t="Jeff Evans (`ALL` gives you key/value pairs in a vec)"><span class="u" id="1602082337.013100">2020:10:07 14:52:17           Jeff Evans </span><span>(`ALL` gives you key/value pairs in a vec)</span></div><div data-t="Lucy Wang ☝️  IMHO the above code already lost the expressiveness people want to achieve by using specter"><span class="u" id="1602147585.014400">2020:10:08 08:59:45            Lucy Wang </span><b>☝️</b><span> IMHO the above code already lost the expressiveness people want to achieve by using specter</span></div><div data-t="cjmurphy I also want to find particular keys and change their values, but in a recursive data structure. Here  data  just gets returned. Wanting to see the value  [{:d 1} {:e 1}]  be replaced by  {:COUNTED 2} ."><span class="u" id="1602626414.014800">2020:10:13 22:00:14             cjmurphy </span><span>I also want to find particular keys and change their values, but in a recursive data structure. Here </span><code>data</code><span> just gets returned. Wanting to see the value </span><code>[{:d 1} {:e 1}]</code><span> be replaced by </span><code>{:COUNTED 2}</code><span>.</span></div><div data-t="Lucy Wang (def map-walker
    (recursive-path [] p
      (cond-path
       map?
       [ALL p]

       [vector? FIRST #(= % :c)]
       LAST

       [vector?]
       [ALL p]
       )))

(let [data {:a 1
            :b [{:z 1 :c [1 2 3]}
                {:c [{:d 1} {:e 1}]}]}]
  (transform [map-walker] #(array-map :COUNTED (count %)) data)) 
"><span class="u" id="1602646719.015300">2020:10:14 03:38:39            Lucy Wang </span><pre>(def map-walker
    (recursive-path [] p
      (cond-path
       map?
       [ALL p]

       [vector? FIRST #(= % :c)]
       LAST

       [vector?]
       [ALL p]
       )))

(let [data {:a 1
            :b [{:z 1 :c [1 2 3]}
                {:c [{:d 1} {:e 1}]}]}]
  (transform [map-walker] #(array-map :COUNTED (count %)) data))</pre><span>
</span></div><div data-t="Lucy Wang The only downside is it would also transform a vector whose first element is :c as well"><span class="u" id="1602649063.015600">2020:10:14 04:17:43                 Lucy Wang </span><span>The only downside is it would also transform a vector whose first element is :c as well</span></div><div data-t="cjmurphy In reality there would never be such an element, because every vector has entities (maps) in it. Seems tricky compared to a solution not using specter. I honestly though the solution would be more straightforward than that. I just used  being-counted-attributes  rather than  #(= % :c)  , so  #{:c}  . Thank you @UP90Q48J3."><span class="u" id="1602657176.015800">2020:10:14 06:32:56                  cjmurphy </span><span>In reality there would never be such an element, because every vector has entities (maps) in it. Seems tricky compared to a solution not using specter. I honestly though the solution would be more straightforward than that. I just used </span><code>being-counted-attributes</code><span> rather than </span><code>#(= % :c)</code><span> , so </span><code>#{:c}</code><span> . Thank you @UP90Q48J3.</span></div><div data-t="Lucy Wang Yeah, for such cases you can simply write a recursive function instead of using specter, or combine specter with a recursive helper function."><span class="u" id="1602677707.016100">2020:10:14 12:15:07                 Lucy Wang </span><span>Yeah, for such cases you can simply write a recursive function instead of using specter, or combine specter with a recursive helper function.</span></div><div data-t="Lucy Wang @cjmurphy"><span class="u" id="1602646724.015500">2020:10:14 03:38:44            Lucy Wang </span><span>@cjmurphy</span></div><div data-t="Jeff Evans well, I think I finally managed to get Specter working in cljs bootstrap:  https://github.com/redplanetlabs/specter/issues/72"><span class="u" id="1602704091.016600">2020:10:14 19:34:51           Jeff Evans </span><span>well, I think I finally managed to get Specter working in cljs bootstrap: </span><a href="https://github.com/redplanetlabs/specter/issues/72">https://github.com/redplanetlabs/specter/issues/72</a></div><div data-t="abdullahibra Hi everyone,"><span class="u" id="1603288873.017600">2020:10:21 14:01:13         abdullahibra </span><span>Hi everyone,</span></div><div data-t="abdullahibra if i have a tree of nested lists with all keyword data type, what is the efficient pattern to select all sublists that start with specific keyword ?"><span class="u" id="1603288917.018600">2020:10:21 14:01:57         abdullahibra </span><span>if i have a tree of nested lists with all keyword data type, what is the efficient pattern to select all sublists that start with specific keyword ?</span></div><div data-t="idiomancy can you give an example input output?"><span class="u" id="1603288944.018900">2020:10:21 14:02:24            idiomancy </span><span>can you give an example input output?</span></div><div data-t="abdullahibra (:a
  (:x
   (:x :xoo) 
   (:y (:ya :yay))
   (:z (:t :till)
        (:y (:v :hello) (:h :world)))))"><span class="u" id="1603289180.019700">2020:10:21 14:06:20         abdullahibra </span><pre>(:a
  (:x
   (:x :xoo) 
   (:y (:ya :yay))
   (:z (:t :till)
        (:y (:v :hello) (:h :world)))))</pre></div><div data-t="abdullahibra need to select all lists that starts with :y"><span class="u" id="1603289196.020100">2020:10:21 14:06:36         abdullahibra </span><span>need to select all lists that starts with :y</span></div><div data-t="abdullahibra output
 (:y (:ya :yay))
(:y (:v :hello) (:h :world))"><span class="u" id="1603289248.020800">2020:10:21 14:07:28         abdullahibra </span><span>output
</span><pre>(:y (:ya :yay))
(:y (:v :hello) (:h :world))</pre></div><div data-t="schmee @abdullahibra
 (def LISTS
    (recursive-path [] p
      (if-path list?
        (stay-then-continue ALL p)
        STOP)))

  user=&gt; (select [LISTS (selected? FIRST (pred= :y))] your-list)
  [(:y (:ya :yay)) (:y (:v :hello) (:h :world))])"><span class="u" id="1603296151.021100">2020:10:21 16:02:31               schmee </span><span>@abdullahibra
</span><pre>(def LISTS
    (recursive-path [] p
      (if-path list?
        (stay-then-continue ALL p)
        STOP)))

  user=&gt; (select [LISTS (selected? FIRST (pred= :y))] your-list)
  [(:y (:ya :yay)) (:y (:v :hello) (:h :world))])</pre></div><div data-t="Lucy Wang or use walker
 (select [(walker (fn [x]
                   (and (list? x)
                        (= (first x) :y))))]
        &apos;(:a
         (:x
          (:x :xoo)
          (:y (:ya :yay))
          (:z (:t :till)
           (:y (:v :hello) (:h :world))))))
;; =&gt; [(:y (:ya :yay)) (:y (:v :hello) (:h :world))] 
"><span class="u" id="1603297053.021500">2020:10:21 16:17:33            Lucy Wang </span><span>or use walker
</span><pre>(select [(walker (fn [x]
                   (and (list? x)
                        (= (first x) :y))))]
        &apos;(:a
         (:x
          (:x :xoo)
          (:y (:ya :yay))
          (:z (:t :till)
           (:y (:v :hello) (:h :world))))))
;; =&gt; [(:y (:ya :yay)) (:y (:v :hello) (:h :world))]</pre><span>
</span></div><div data-t="abdullahibra i have used tree-seq and filter based on some conditions and it&apos;s working, but it&apos;s worth to try those approaches too"><span class="u" id="1603297137.022100">2020:10:21 16:18:57         abdullahibra </span><span>i have used tree-seq and filter based on some conditions and it&apos;s working, but it&apos;s worth to try those approaches too</span></div><div data-t="mathpunk I think I&apos;ve got a use case that specter might help, but I&apos;m brand new to it. I&apos;ve got data that looks like this:
 {:name &quot;Conditional Sections E2E Workflow&quot;
 :application {:name &quot;Conditional Sections&quot;
               :id &quot;someId&quot;}}  
There&apos;s nested maps, and any time there&apos;s an  :id  key in the map, I need to look up the value of  :id  in another map, and assoc that value in place."><span class="u" id="1603821850.025100">2020:10:27 18:04:10             mathpunk </span><span>I think I&apos;ve got a use case that specter might help, but I&apos;m brand new to it. I&apos;ve got data that looks like this:
</span><pre>{:name &quot;Conditional Sections E2E Workflow&quot;
 :application {:name &quot;Conditional Sections&quot;
               :id &quot;someId&quot;}} </pre><span>
There&apos;s nested maps, and any time there&apos;s an </span><code>:id</code><span> key in the map, I need to look up the value of </span><code>:id</code><span> in another map, and assoc that value in place.</span></div><div data-t="mathpunk I&apos;m reading about navigators now... if y&apos;all have a pointer to the one/ones I need, I&apos;d appreciate it"><span class="u" id="1603822171.025800">2020:10:27 18:09:31             mathpunk </span><span>I&apos;m reading about navigators now... if y&apos;all have a pointer to the one/ones I need, I&apos;d appreciate it</span></div><div data-t="idiomancy usually the best way to get help around here is to give a sample input and output.  Someone will invariably take up the challenge as a little brain teaser to occupy themselves while they wait for their next meeting to start and post the answer"><span class="u" id="1603822295.027700">2020:10:27 18:11:35            idiomancy </span><span>usually the best way to get help around here is to give a sample input and output.  Someone will invariably take up the challenge as a little brain teaser to occupy themselves while they wait for their next meeting to start and post the answer</span></div><div data-t="mathpunk I can do that, I&apos;ll find a good one"><span class="u" id="1603822346.028000">2020:10:27 18:12:26             mathpunk </span><span>I can do that, I&apos;ll find a good one</span></div><div data-t="mathpunk Okay, suppose there is a map called  state  floating about, like shown. Here&apos;s the given data, and the desired data:
 {:state {&quot;FzPIxXKk&quot; {:name &quot;Conditional Sections E2E Workflow&quot;
                          :id &quot;var&quot;}}
      :given {:name &quot;Conditional Sections E2E Workflow&quot;
              :application {:name &quot;Conditional Sections&quot;
                            :id &quot;FzPIxXKk&quot;}}
      :desired {:name &quot;Conditional Sections E2E Workflow&quot;
                :application {:name &quot;Conditional Sections&quot;
                              :id &quot;var&quot;}}} 
"><span class="u" id="1603823259.029300">2020:10:27 18:27:39             mathpunk </span><span>Okay, suppose there is a map called </span><code>state</code><span> floating about, like shown. Here&apos;s the given data, and the desired data:
</span><pre>{:state {&quot;FzPIxXKk&quot; {:name &quot;Conditional Sections E2E Workflow&quot;
                          :id &quot;var&quot;}}
      :given {:name &quot;Conditional Sections E2E Workflow&quot;
              :application {:name &quot;Conditional Sections&quot;
                            :id &quot;FzPIxXKk&quot;}}
      :desired {:name &quot;Conditional Sections E2E Workflow&quot;
                :application {:name &quot;Conditional Sections&quot;
                              :id &quot;var&quot;}}}</pre><span>
</span></div><div data-t="mathpunk For reference, here is the brittle &quot;let&apos;s hope we got all the cases&quot; code I have for doing this:
 (defn return-with-id [exchange state]
  (assoc-in exchange [:required :id] (get (get state (get-in exchange [:required :id])) :id)))

(defn return-with-application [exchange state]
  (assoc-in exchange [:required :application :id] (get (get state (get-in exchange [:required :application :id])) :id)))

(defn return-with-parent [exchange state]
  (assoc-in exchange [:required :parent :id] (get (get state (get-in exchange [:required :parent :id])) :id)))

(defn return-with-target [exchange state]
  (assoc-in exchange [:required :target :id] (get (get state (get-in exchange [:required :target :id])) :id)))

(defn return [state exchange]
  (if (seq? exchange)
    (throw (Exception. &quot;Multiple requirements needed, invalidating my assumption about our data&quot;))
    (cond-&gt; exchange
      (get state (get-in exchange [:required :id])) (return-with-id state)
      (get state (get-in exchange [:required :application :id])) (return-with-application state)
      (get state (get-in exchange [:required :target :id])) (return-with-target state)
      (get state (get-in exchange [:required :parent :id])) (return-with-parent state))))"><span class="u" id="1603823363.030000">2020:10:27 18:29:23             mathpunk </span><span>For reference, here is the brittle &quot;let&apos;s hope we got all the cases&quot; code I have for doing this:
</span><pre>(defn return-with-id [exchange state]
  (assoc-in exchange [:required :id] (get (get state (get-in exchange [:required :id])) :id)))

(defn return-with-application [exchange state]
  (assoc-in exchange [:required :application :id] (get (get state (get-in exchange [:required :application :id])) :id)))

(defn return-with-parent [exchange state]
  (assoc-in exchange [:required :parent :id] (get (get state (get-in exchange [:required :parent :id])) :id)))

(defn return-with-target [exchange state]
  (assoc-in exchange [:required :target :id] (get (get state (get-in exchange [:required :target :id])) :id)))

(defn return [state exchange]
  (if (seq? exchange)
    (throw (Exception. &quot;Multiple requirements needed, invalidating my assumption about our data&quot;))
    (cond-&gt; exchange
      (get state (get-in exchange [:required :id])) (return-with-id state)
      (get state (get-in exchange [:required :application :id])) (return-with-application state)
      (get state (get-in exchange [:required :target :id])) (return-with-target state)
      (get state (get-in exchange [:required :parent :id])) (return-with-parent state))))</pre></div><div data-t="mathpunk I could replace those copypasta functions with one function that takes a path -- but it would still be, explicit paths."><span class="u" id="1603823408.031000">2020:10:27 18:30:08             mathpunk </span><span>I could replace those copypasta functions with one function that takes a path -- but it would still be, explicit paths.</span></div><div data-t="mathpunk Then I&apos;d have,
 (defn update-with-path [state exchange path]
  (cond-&gt; exchange
    (get state (get-in exchange (concat [:required] path)))
    (assoc-in (concat [:required] path) (get (get state (get-in exchange (concat [:required] path))) :id))))

(defn return [state exchange]
  (if (seq? exchange)
    (throw (Exception. &quot;Multiple requirements needed, invalidating my assumption about our data&quot;))
    (let [update-fn (partial update-with-path state)]
      (-&gt; exchange
          (update-fn [:id])
          (update-fn [:application :id])
          (update-fn [:target :id])
          (update-fn [:parent :id])))))"><span class="u" id="1603824150.031500">2020:10:27 18:42:30             mathpunk </span><span>Then I&apos;d have,
</span><pre>(defn update-with-path [state exchange path]
  (cond-&gt; exchange
    (get state (get-in exchange (concat [:required] path)))
    (assoc-in (concat [:required] path) (get (get state (get-in exchange (concat [:required] path))) :id))))

(defn return [state exchange]
  (if (seq? exchange)
    (throw (Exception. &quot;Multiple requirements needed, invalidating my assumption about our data&quot;))
    (let [update-fn (partial update-with-path state)]
      (-&gt; exchange
          (update-fn [:id])
          (update-fn [:application :id])
          (update-fn [:target :id])
          (update-fn [:parent :id])))))</pre></div><div data-t="mathpunk And hey, that does work:
 {:state {&quot;FzPIxXKk&quot; {:name &quot;Conditional Sections E2E Workflow&quot;
                     :id &quot;var&quot;}}
 :given {:method &quot;POST&quot;
         :url &quot;&quot;
         :required {:name &quot;Conditional Sections E2E Workflow&quot;
                    :application {:name &quot;Conditional Sections&quot;
                                  :id &quot;FzPIxXKk&quot;}}} ;; &lt;-- needs updating
 :result {:method &quot;POST&quot;
          :url &quot;&quot;
          :required {:name &quot;Conditional Sections E2E Workflow&quot;
                     :application {:name &quot;Conditional Sections&quot;
                                   :id &quot;var&quot;}}}} ;; &lt;-- updated"><span class="u" id="1603824215.032000">2020:10:27 18:43:35             mathpunk </span><span>And hey, that does work:
</span><pre>{:state {&quot;FzPIxXKk&quot; {:name &quot;Conditional Sections E2E Workflow&quot;
                     :id &quot;var&quot;}}
 :given {:method &quot;POST&quot;
         :url &quot;&quot;
         :required {:name &quot;Conditional Sections E2E Workflow&quot;
                    :application {:name &quot;Conditional Sections&quot;
                                  :id &quot;FzPIxXKk&quot;}}} ;; &lt;-- needs updating
 :result {:method &quot;POST&quot;
          :url &quot;&quot;
          :required {:name &quot;Conditional Sections E2E Workflow&quot;
                     :application {:name &quot;Conditional Sections&quot;
                                   :id &quot;var&quot;}}}} ;; &lt;-- updated</pre></div><div data-t="mathpunk but like i said, not generic, seems brittle, gotta know what paths to :id&apos;s exist in order to explicitly supply them"><span class="u" id="1603824237.032300">2020:10:27 18:43:57             mathpunk </span><span>but like i said, not generic, seems brittle, gotta know what paths to :id&apos;s exist in order to explicitly supply them</span></div><div data-t="nathanmarz @mathpunk take a look at  recursive-path ,  MAP-VALS , and  stay-then-continue"><span class="u" id="1603826040.033000">2020:10:27 19:14:00           nathanmarz </span><span>@mathpunk take a look at </span><code>recursive-path</code><span>, </span><code>MAP-VALS</code><span>, and </span><code>stay-then-continue</code></div><div data-t="nathanmarz you can define a navigator that goes to every nested map, and then from there do your lookup of the id"><span class="u" id="1603826057.033500">2020:10:27 19:14:17           nathanmarz </span><span>you can define a navigator that goes to every nested map, and then from there do your lookup of the id</span></div><div data-t="nathanmarz e.g.  (transform [ALL-MAPS (must :id)] (fn [id] (lookup-val-for-id id)) data)"><span class="u" id="1603826107.034500">2020:10:27 19:15:07           nathanmarz </span><span>e.g. </span><code>(transform [ALL-MAPS (must :id)] (fn [id] (lookup-val-for-id id)) data)</code></div><div data-t="mathpunk great, thank you!"><span class="u" id="1603826275.034800">2020:10:27 19:17:55             mathpunk </span><span>great, thank you!</span></div></body>