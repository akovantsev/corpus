<!DOCTYPE html>
<head><title>core-logic</title><meta charset="UTF-8" /><style type="text/css">body {
    font-family: Monaco, Menlo, Consolas, "Courier New", sans-serif;
    font-size: 12px;
    margin: 15px;
}
h2 {text-align: center}
pre,
code {
    font-family: Monaco, Menlo, Consolas, "Courier New", monospace;
    color: #333;
    line-break: anywhere;
}
a {
    line-break: anywhere;
}
code {
    /*line-height: 1.2;*/
    white-space: normal;
    color: #c25;
    background-color: #f7f7f9;
    border: 1px solid #e1e1e8;
}
pre {
    margin: .5rem 0 .2rem;
    font-size: .75rem;
    /*line-height: 1.15rem;*/
    background: #fbfaf8;
    padding: .5rem;
    word-break: normal;
    display: block;
    border: 1px solid rgba(0, 0, 0, .15);
    white-space: pre-wrap;
    word-wrap: break-word;
    border-radius: 4px;
}
/*span {*/
z {
    white-space: pre-wrap;
}

d {padding-right: 8px;}
h {padding-right: 16px;}

w, r {
    margin-right: 10px;
    padding-right: 8px;
    text-align: right;
}

d,h,w,r {
    background-color: lavender;
    margin-top: 1px;
    display: inline-table; /* prevents doubleclick selection spillover into neighbour elements */
}

h:hover,
d:hover {
    text-decoration: underline;
    color: blue;
    cursor: row-resize;
}
d {padding-right: 8px;}
h {padding-right: 16px;}

z {display: block;}

z:target > r,
z:target > w,
z:target > d,
z:target > h {
    background-color: aquamarine
}

#filters-container {
    position: fixed;
    left: 50px;
    z-index: 1;
}
#filters-container > input {
    /*column:*/
    display: block;
    outline-color: aquamarine;
}

y {
    cursor: pointer;
    text-decoration: none;
    color: blue;
    position: absolute;
    left: 3px;
}

y:hover {
    text-decoration: underline;
    color: aquamarine;
}


</style></head><body><style id="css-username">w {min-width: 128px;} r {min-width: 160px;}</style><style id="css-text-filter"></style><style id="css-date-filter"></style><style id="css-filter-override"></style><p id="filters-container"><input id="text-filter" onkeyup="debtextfilter(this.value)" placeholder="filter text" type="string" /><button hidden="hidden" id="date-filter" onclick="cleardatefilter()"></button></p><h2>#core-logic</h2><pre><i>generated UTC: 2020-11-22 15:15</i><i>
latest data: <a href="https://clojurians-log.clojureverse.org/core-logic/2020-11-06">https://clojurians-log.clojureverse.org/core-logic/2020-11-06</a></i><i>
messages: 1080</i>
pro tips:
* Double click on text to filter by it. (doubleclick + cmd-f for extra points).
* Click on date to keep day visible regardless of filter.
* Click on time to keep hour visible regardless of filter.</pre><script>const textFilterInput = document.getElementById("text-filter");
const dateFilterInput = document.getElementById("date-filter");
const filterTextStyle = document.getElementById("css-text-filter");
const filterDateStyle = document.getElementById("css-date-filter");
const filterStyleOverride = document.getElementById("css-filter-override");



function textFilter(text) {
    var style = '';
    if (text.trim() !== '') {
        text.split(' ').forEach(function (t) {
            if (t !== '') {
                style = style + "z:not([t*='" + t + "' i]) {display: none; opacity: 0.6}";
            }
        });
    }
    filterTextStyle.innerHTML = style;
}


function filterSelection (e) {
    let sel = document.getSelection();
    let txt = sel.toString();
    textFilterInput.value = (txt || "");
    textFilter(txt);
}
function debounce1(callback, delay) {
    let timeout;
    return function(arg) {
        clearTimeout(timeout);
        timeout = setTimeout(callback, delay, arg);
    }
}

function keyUp (e) {
    if (e.code === "KeyF" && e.ctrlKey) {
        let txt = document.getSelection().toString();
        if (txt.length > 0) {
            textFilterInput.value = (txt || "");
            textFilter(txt);
        }
    }
}


function showDateTimes (el, datestr, hourstr) {
    dateFilterInput.innerText = "clear: " + datestr + " " + hourstr;
    dateFilterInput.hidden = false;
    let ids = [];
    const clicked = el.parentElement;  // el = z#id/t
    ids.push(clicked.id);
    // var idbefore, idafter;
    let cursor = clicked;
    function nextCursor (cursor) {
        const id = (cursor && cursor.id);
        const d = (cursor && cursor.children[1]);
        const h = (cursor && cursor.children[2])
        if (id) {
            ids.push(id); //includes 1st next-id not matching date.
        } else {
            cursor = null;
        }
        if (d && (d.textContent === datestr) && (!hourstr || (h && h.textContent.startsWith(hourstr)))) {
        } else {
            cursor = null;
        }
        return cursor;
    }
    while (cursor) {
        cursor = nextCursor(cursor.previousElementSibling);
    }

    cursor = clicked;

    while (cursor) {
        cursor = nextCursor(cursor.nextElementSibling);
    }


    var style1 = '';
    var style2 = '';
    var content;
    if (datestr.includes(" ")) { //hour
        content = " *";
    } else {
        content = "**";
    }
    ids.forEach(function (id) {
        if (id) {
            style1 = style1 + ", #" + id;
            style2 = style2 + ", #" + id + " h:after";
        }
    })
    if (style1) {
        style1 = style1.substring(1) + " {display: block !important}";
    }
    if (style2) {
        style2 = style2.substring(1) + " {content: \"" + content + "\"; position: absolute}"
    }
    filterDateStyle.innerHTML = style1 + "\n" + style2;
}

// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView
function filterDay (el) {
    showDateTimes(el, el.textContent);
    el.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
}

function filterHours (el) {
    showDateTimes(el, el.previousElementSibling.textContent, el.textContent.substring(0, 2));
    el.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
}

function forceShowSelected (el) {
    var id = el.parentElement.id
    if (id) {
        window.location.hash = "#" + id;
        filterStyleOverride.innerHTML = ""
            + "#" + id
            + " {display: block !important;}"
            + "#" + id + " h:after"
            + " {content: \"  #\"; position: absolute}";

    } else {
        window.location.hash = "";
        filterStyleOverride.innerHTML = "";
    }
}


function cleardatefilter () {
    dateFilterInput.hidden = true;
    dateFilterInput.innerText = "";
    filterDateStyle.innerHTML = "";
}

const debtextfilter = debounce1(textFilter, 200);

function doubleClick (e) {
    if (e.target.tagName !== "INPUT"
        && e.target.tagName !== "D"
        && e.target.tagName !== "H") {

        filterSelection();
        e.target.scrollIntoView({behavior: "auto", block: "center", inline: "start"});
    }
}

function onclick(e) {
    if (e.target.tagName === "Y") {
        e.preventDefault();
        forceShowSelected(e.target);
    } else if (e.target.tagName === "D") {
        e.preventDefault();
        filterDay(e.target);
    } else if (e.target.tagName === "H") {
        e.preventDefault();
        filterHours(e.target);
    }
}

document.onclick = onclick;
document.ondblclick = doubleClick;
document.onkeyup = keyUp;
textFilterInput.focus();
</script><div><z id="t1437987862000006" t="tsdh Can someone enlighten me with some ccl result?"><y>#</y><d>2015-07-27</d><h>09:04</h><w>tsdh</w>Can someone enlighten me with some ccl result?</z><z id="t1437987881000007" t="tsdh (run* [q] (fresh [a b c] (== q [a b c]) (membero 1 q) (membero 3 q) (conde [(conso 1 [b c] q)] [(conjo [a b] 3 q)]))) ;; ([1 3 _0] ;; [1 3 3] ;; [1 _0 3] ;; ([1 _0 3] :- (clojure.core.logic/conjo [&lt;lvar:a__21997&gt; &lt;lvar:b__21998&gt;] 3 [1 _0 3])) ;; [3 1 3] ;; [1 1 3] ;; ([_0 1 3] :- (clojure.core.logic/conjo [&lt;lvar:a__21997&gt; &lt;lvar:b__21998&gt;] 3 [_0 1 3])) ;; ([3 _0 1] :- (clojure.core.logic/conjo [&lt;lvar:a__21997&gt; &lt;lvar:b__21998&gt;] 3 [3 _0 1])) ;; [1 3 1] ;; ([_0 3 1] :- (clojure.core.logic/conjo [&lt;lvar:a__21997&gt; &lt;lvar:b__21998&gt;] 3 [_0 3 1]))) "><y>#</y><d>2015-07-27</d><h>09:04</h><w>tsdh</w><pre>(run* [q]
  (fresh [a b c]
    (== q [a b c])
    (membero 1 q)
    (membero 3 q)
    (conde
     [(conso 1 [b c] q)]
     [(conjo [a b] 3 q)])))
;; ([1 3 _0]
;;  [1 3 3]
;;  [1 _0 3]
;;  ([1 _0 3] :- (clojure.core.logic/conjo [&lt;lvar:a__21997&gt; &lt;lvar:b__21998&gt;] 3 [1 _0 3]))
;;  [3 1 3]
;;  [1 1 3]
;;  ([_0 1 3] :- (clojure.core.logic/conjo [&lt;lvar:a__21997&gt; &lt;lvar:b__21998&gt;] 3 [_0 1 3]))
;;  ([3 _0 1] :- (clojure.core.logic/conjo [&lt;lvar:a__21997&gt; &lt;lvar:b__21998&gt;] 3 [3 _0 1]))
;;  [1 3 1]
;;  ([_0 3 1] :- (clojure.core.logic/conjo [&lt;lvar:a__21997&gt; &lt;lvar:b__21998&gt;] 3 [_0 3 1])))
</pre></z><z id="t1437987941000008" t="tsdh For example, the fourth result is already subsumed by the third, and the 8th and the last result can never become true, no?"><y>#</y><d>2015-07-27</d><h>09:05</h><w>tsdh</w>For example, the fourth result is already subsumed by the third, and the 8th and the last result can never become true, no?</z><z id="t1437994320000009" t="tsdh Another thing: Is is somehow possible to do logic programming with strings? One could use conso , resto , and appendo with lists of characters of course, but can this be done somewhat transparently so that I could define (stro a b ab) which is like appendo but translates from/to lists of characters as needed?"><y>#</y><d>2015-07-27</d><h>10:52</h><w>tsdh</w>Another thing: Is is somehow possible to do logic programming with strings?  One could use <code>conso</code>, <code>resto</code>, and <code>appendo</code> with lists of characters of course, but can this be done somewhat transparently so that I could define <code>(stro a b ab)</code> which is like <code>appendo</code> but translates from/to lists of characters as needed?</z><z id="t1438012678000011" t="jballanc tsdh: to answer your second question first, you can always write your own string-based methods either using the core.logic primatives, or just deconstructing/reconstructing the string and using conso and friends"><y>#</y><d>2015-07-27</d><h>15:57</h><w>jballanc</w>tsdh: to answer your second question first, you can always write your own string-based methods either using the <code>core.logic</code> primatives, or just deconstructing/reconstructing the string and using <code>conso</code> and friends</z><z id="t1438017597000012" t="tsdh @jballanc: looking at how complicated firsto and friends are with their LCons deftype etc, reusing that seems like the way to go. However, I just wondered if I could get the conversion from/to lists of characters transparently/implicitly rather than doing it from outside of run*."><y>#</y><d>2015-07-27</d><h>17:19</h><w>tsdh</w>@jballanc: looking at how complicated firsto and friends are with their LCons deftype etc, reusing that seems like the way to go. However, I just wondered if I could get the conversion from/to lists of characters transparently/implicitly rather than doing it from outside of run*.</z><z id="t1438018238000013" t="tsdh FWIW, I don&apos;t need to have relations on lists of characters, so that representation could be reserved for strings."><y>#</y><d>2015-07-27</d><h>17:30</h><w>tsdh</w>FWIW, I don&apos;t need to have relations on lists of characters, so that representation could be reserved for strings.</z><z id="t1438023547000014" t="jballanc hmm…I think it should be possible to pass strings around…have to think about it"><y>#</y><d>2015-07-27</d><h>18:59</h><w>jballanc</w>hmm…I think it should be possible to pass strings around…have to think about it</z><z id="t1438023645000015" t="jballanc oh, and about your first question…not sure but I think what’s happening is: 1. for the 4th result, you’re swapping a and b as to which is 1 and which is unbound (`_0`) 2. for the 8th result, one of your fresh vars in the conjo is empty…I think"><y>#</y><d>2015-07-27</d><h>19:00</h><w>jballanc</w>oh, and about your first question…not sure but I think what’s happening is:
1. for the 4th result, you’re swapping <code>a</code> and <code>b</code> as to which is <code>1</code> and which is unbound (`_0`)
2. for the 8th result, one of your fresh vars in the <code>conjo</code> is empty…I think</z><z id="t1438023655000016" t="jballanc would have to double-check that last one, though"><y>#</y><d>2015-07-27</d><h>19:00</h><w>jballanc</w>would have to double-check that last one, though</z><z id="t1438064115000017" t="tsdh @jballanc: Yes, in the code, b could be anything as long as 1 and 3 are member of the vector q and a is 1 or c is 3. So with the 8th result, there&apos;s no way to complete it to a solution, no matter what you insert for b ."><y>#</y><d>2015-07-28</d><h>06:15</h><w>tsdh</w>@jballanc: Yes, in the code, <code>b</code> could be anything as long as 1 and 3 are member of the vector <code>q</code> and <code>a</code> is 1 or <code>c</code> is 3. So with the 8th result, there&apos;s no way to complete it to a solution, no matter what you insert for <code>b</code>.</z><z id="t1438075145000018" t="tsdh Does someone have a minimal example showing the difference between conda and condu ? As far as I understand, (run* [x y] (conda ;; or condu [(== x 1) (membero 2 y)] [(== x 2) (== y 3)])) should blow the stack whereas it should work with condu and deliver ([1 (2)]) . But actually it also blows the stack with condu ."><y>#</y><d>2015-07-28</d><h>09:19</h><w>tsdh</w>Does someone have a minimal example showing the difference between <code>conda</code> and <code>condu</code>?  As far as I understand,
<pre>(run* [x y]
  (conda  ;; or condu
   [(== x 1) (membero 2 y)]
   [(== x 2) (== y 3)]))
</pre>
should blow the stack whereas it should work with <code>condu</code> and deliver <code>([1 (2)])</code>. But actually it also blows the stack with <code>condu</code>.</z><z id="t1438075257000019" t="tsdh Well, with condu it might also return ([1 #{2}]) or ([1 [2]]) since the collection type isn&apos;t fixed, and of course the collection doesn&apos;t need to be minimal although that would make sense."><y>#</y><d>2015-07-28</d><h>09:20</h><w>tsdh</w>Well, with <code>condu</code> it might also return <code>([1 #{2}])</code> or <code>([1 [2]])</code> since the collection type isn&apos;t fixed, and of course the collection doesn&apos;t need to be minimal although that would make sense.</z><z id="t1438075743000020" t="tsdh Or with a much simpler example: (defn y-or-n [x] (conde [(== x :y)] [(== x :n)])) (run* [x y] (condu [(== x 1) (y-or-n y)] [(== x 2) (== y 3)])) ;;=&gt; ([1 :y] [1 :n]) I had expected to get only ([1 :y]) . Why the second solution? condu should succeed at most once for any goal in the clause it committed to, no?"><y>#</y><d>2015-07-28</d><h>09:29</h><w>tsdh</w>Or with a much simpler example:
<pre>(defn y-or-n [x]
  (conde
   [(== x :y)]
   [(== x :n)]))

(run* [x y]
  (condu
   [(== x 1) (y-or-n y)]
   [(== x 2) (== y 3)]))
;;=&gt; ([1 :y] [1 :n])
</pre>
I had expected to get only <code>([1 :y])</code>.  Why the second solution?  <code>condu</code> should succeed at most once for any goal in the clause it committed to, no?</z><z id="t1438076769000022" t="tsdh Hm, it works when I swap the two goals in the first clause. So it seems that only the head goal has the once-semantics."><y>#</y><d>2015-07-28</d><h>09:46</h><w>tsdh</w>Hm, it works when I swap the two goals in the first clause.  So it seems that only the head goal has the once-semantics.</z><z id="t1438089748000023" t="jballanc tsdh: I implemented FizzBuzz with core.logic (don’t ask), and made use of condu (in the form of defnu ) - https://github.com/jballanc/logicbuzz/blob/master/src/logicbuzz/core.clj#L17"><y>#</y><d>2015-07-28</d><h>13:22</h><w>jballanc</w>tsdh: I implemented FizzBuzz with core.logic (don’t ask), and made use of <code>condu</code> (in the form of <code>defnu</code>) - <a href="https://github.com/jballanc/logicbuzz/blob/master/src/logicbuzz/core.clj#L17" target="_blank">https://github.com/jballanc/logicbuzz/blob/master/src/logicbuzz/core.clj#L17</a></z><z id="t1438089958000025" t="jballanc essentially, as I understand it, you’re building up a tree of solutions: first make the first condition pass, then cycle back and fill in any remaining fresh vars, then make the second condition pass, then cycle back and fill remaining fresh, etc."><y>#</y><d>2015-07-28</d><h>13:25</h><w>jballanc</w>essentially, as I understand it, you’re building up a tree of solutions: first make the first condition pass, then cycle back and fill in any remaining fresh vars, then make the second condition pass, then cycle back and fill remaining fresh, etc.</z><z id="t1438089979000026" t="jballanc with condu , if you can make the first condition pass, then you fill the remaining fresh vars and stop"><y>#</y><d>2015-07-28</d><h>13:26</h><w>jballanc</w>with <code>condu</code>, if you can make the first condition pass, then you fill the remaining fresh vars and stop</z><z id="t1438089990000027" t="jballanc if you can’t, then you try the second, and so on"><y>#</y><d>2015-07-28</d><h>13:26</h><w>jballanc</w>if you can’t, then you try the second, and so on</z><z id="t1438090133000028" t="tsdh @jballanc: I think with your fizzbuzzo you can use defna and defnu . Both commit to a clause as soon as the head goal succeeds."><y>#</y><d>2015-07-28</d><h>13:28</h><w>tsdh</w>@jballanc: I think with your <code>fizzbuzzo</code> you can use <code>defna</code> and <code>defnu</code>.  Both commit to a clause as soon as the head goal succeeds.</z><z id="t1438090153000029" t="tsdh @jballanc: And in your case, x is always ground."><y>#</y><d>2015-07-28</d><h>13:29</h><w>tsdh</w>@jballanc: And in your case, <code>x</code> is always ground.</z><z id="t1438090214000030" t="jballanc it’s been a while, but I think I tried defna and didn’t have success..."><y>#</y><d>2015-07-28</d><h>13:30</h><w>jballanc</w>it’s been a while, but I think I tried <code>defna</code> and didn’t have success...</z><z id="t1438090305000031" t="tsdh @jballanc: The difference with conda /`defna` versus condu /`defnu` only shows up when the head goal of a clause may produce multiple solutions. With the former, all of them are considered, with the latter, only the first one is considered. Thus, some programs which diverge with conda may terminate with condu ."><y>#</y><d>2015-07-28</d><h>13:31</h><w>tsdh</w>@jballanc: The difference with <code>conda</code>/`defna` versus <code>condu</code>/`defnu` only shows up when the head goal of a clause may produce multiple solutions. With the former, all of them are considered, with the latter, only the first one is considered. Thus, some programs which diverge with <code>conda</code> may terminate with <code>condu</code>.</z><z id="t1438090329000032" t="jballanc hmm…ok"><y>#</y><d>2015-07-28</d><h>13:32</h><w>jballanc</w>hmm…ok</z><z id="t1438090370000033" t="tsdh At least that&apos;s what I&apos;ve read in W. Byrd&apos;s thesis and validated with experimentation here."><y>#</y><d>2015-07-28</d><h>13:32</h><w>tsdh</w>At least that&apos;s what I&apos;ve read in W. Byrd&apos;s thesis and validated with experimentation here.</z><z id="t1438090669000034" t="jballanc ok, yeah, stated that way I think it matches with what I’ve found in the past"><y>#</y><d>2015-07-28</d><h>13:37</h><w>jballanc</w>ok, yeah, stated that way I think it matches with what I’ve found in the past</z><z id="t1438090701000035" t="jballanc (that FizzBuzz solution was a lot of trial and error to get everything done with only using core.logic )"><y>#</y><d>2015-07-28</d><h>13:38</h><w>jballanc</w>(that FizzBuzz solution was a lot of trial and error to get everything done with only using <code>core.logic</code>)</z><z id="t1438162944000036" t="tsdh Say you have a unary relation (1to10 n) which unifies n with the 1, 2,... , 10. And say you have two logic variables n1 and n2 both resulting from unification with 1to10 , and you want to express that n1 comes before n2 in 1to10 . Is that possible? (`clojure.core.logic.fd/&lt;` is of course cheating)"><y>#</y><d>2015-07-29</d><h>09:42</h><w>tsdh</w>Say you have a unary relation <code>(1to10 n)</code> which unifies <code>n</code> with the 1, 2,... , 10.  And say you have two logic variables <code>n1</code> and <code>n2</code> both resulting from unification with <code>1to10</code>, and you want to express that <code>n1</code> comes before <code>n2</code> in <code>1to10</code>. Is that possible?  (`clojure.core.logic.fd/&lt;` is of course cheating)</z><z id="t1438185021000037" t="jballanc When it comes to working with numbers-as-lvars, I think fd is pretty much your only choice"><y>#</y><d>2015-07-29</d><h>15:50</h><w>jballanc</w>When it comes to working with numbers-as-lvars, I think <code>fd</code> is pretty much your only choice</z><z id="t1438185051000038" t="jballanc the only other thing I could think of would be to encode them as Church numerals and re-implement basic math as list operations"><y>#</y><d>2015-07-29</d><h>15:50</h><w>jballanc</w>the only other thing I could think of would be to encode them as Church numerals and re-implement basic math as list operations</z><z id="t1438185111000039" t="jballanc …hmm…or you could use a range with conso in reverse to trim n2 then check with membero for n1"><y>#</y><d>2015-07-29</d><h>15:51</h><w>jballanc</w>…hmm…or you could use a range with <code>conso</code> in reverse to trim <code>n2</code> then check with <code>membero</code> for <code>n1</code></z><z id="t1438259839000041" t="tsdh @jballanc: That I&apos;ve used numbers is just for simplicity. The more general question is: if (thingo x) can unify x with both :fork and :spoon , is there a way to tell if x is unified first with :fork and then :spoon or the other way round?"><y>#</y><d>2015-07-30</d><h>12:37</h><w>tsdh</w>@jballanc: That I&apos;ve used numbers is just for simplicity.  The more general question is: if <code>(thingo x)</code> can unify <code>x</code> with both <code>:fork</code> and <code>:spoon</code>, is there a way to tell if <code>x</code> is unified first with <code>:fork</code> and then <code>:spoon</code> or the other way round?</z><z id="t1438259995000042" t="tsdh @jballanc: Basically, what I am looking for is a way to transform between multiple unifications and a list of the unifications."><y>#</y><d>2015-07-30</d><h>12:39</h><w>tsdh</w>@jballanc: Basically, what I am looking for is a way to transform between multiple unifications and a list of the unifications.</z><z id="t1438263983000043" t="jballanc tsdh: hmm…if I understand you correctly, I’d be tempted to say that this falls into the category of “implementation detail” in core.logic"><y>#</y><d>2015-07-30</d><h>13:46</h><w>jballanc</w>tsdh: hmm…if I understand you correctly, I’d be tempted to say that this falls into the category of “implementation detail” in <code>core.logic</code></z><z id="t1438264026000044" t="jballanc that is, if you have, say: (run* [q] (conde [(== q 1) (== q 2)])) and you want to know did q match 1 first, or 2 first?"><y>#</y><d>2015-07-30</d><h>13:47</h><w>jballanc</w>that is, if you have, say: <code>(run* [q] (conde [(== q 1) (== q 2)]))</code> and you want to know did <code>q</code> match 1 first, or 2 first?</z><z id="t1438264045000045" t="tsdh @jballanc: Exactly."><y>#</y><d>2015-07-30</d><h>13:47</h><w>tsdh</w>@jballanc: Exactly.</z><z id="t1438264098000046" t="jballanc yeah…I mean, IIRC the implementation of conde and friends is more-or-less a depth-first tree walk, so unifications should happen in roughly the order they’re provided"><y>#</y><d>2015-07-30</d><h>13:48</h><w>jballanc</w>yeah…I mean, IIRC the implementation of <code>conde</code> and friends is more-or-less a depth-first tree walk, so unifications should happen in roughly the order they’re provided</z><z id="t1438264153000047" t="jballanc …but I think that’s definitely “implementation detail” since, as I understand it, in Will Byrd’s ideal world all mini-Kanren conditions would be relational, i.e. order independent"><y>#</y><d>2015-07-30</d><h>13:49</h><w>jballanc</w>…but I think that’s definitely “implementation detail” since, as I understand it, in Will Byrd’s ideal world all mini-Kanren conditions would be relational, i.e. order independent</z><z id="t1438264230000048" t="jballanc He does a really good job explaining that concept in this podcast: http://www.functionalgeekery.com/episode-9-william-e-byrd/"><y>#</y><d>2015-07-30</d><h>13:50</h><w>jballanc</w>He does a really good job explaining that concept in this podcast: <a href="http://www.functionalgeekery.com/episode-9-william-e-byrd/" target="_blank">http://www.functionalgeekery.com/episode-9-william-e-byrd/</a></z><z id="t1438264272000050" t="jballanc So, while it might be possible to hack a solution to get what you want, I think you have to keep in mind that you’d be directly controverting one of the goals of mini-Kanren as a logic system"><y>#</y><d>2015-07-30</d><h>13:51</h><w>jballanc</w>So, while it might be possible to hack a solution to get what you want, I think you have to keep in mind that you’d be directly controverting one of the goals of mini-Kanren as a logic system</z><z id="t1438264282000051" t="jballanc 😕"><y>#</y><d>2015-07-30</d><h>13:51</h><w>jballanc</w><b>😕</b></z><z id="t1438264292000052" t="jballanc (…but I’m far from an expert on the matter)"><y>#</y><d>2015-07-30</d><h>13:51</h><w>jballanc</w>(…but I’m far from an expert on the matter)</z><z id="t1438267491000053" t="tsdh @jballanc: Yes, I&apos;m with you in your concrete example. But with your own relations, you can define the order in which things get unified. For example, say you deal with the concepts block and statement in some programming language. Clearly, a block contains statements, and the order of statements in a block does matter. Now you have to choices to model that with relations: 1. (block-has-stmto block stmt) where the relation unifies stmt once for each statement in a concrete block, or 2. (block-has-stmts block stmts) where stmts gets unified with the list of statements in a concrete block. Variant 1 is much nicer to work with in case you don&apos;t care about the order. With variant 2, you have the order but if you don&apos;t care about it, queries become a bit more complicated (basically you need membero goals over the place)."><y>#</y><d>2015-07-30</d><h>14:44</h><w>tsdh</w>@jballanc: Yes, I&apos;m with you in your concrete example. But with your own relations, you can define the order in which things get unified. For example, say you deal with the concepts block and statement in some programming language. Clearly, a block contains statements, and the order of statements in a block does matter. Now you have to choices to model that with relations: 1. <code>(block-has-stmto block stmt)</code> where the relation unifies <code>stmt</code> once for each statement in a concrete block, or 2. <code>(block-has-stmts block stmts)</code> where <code>stmts</code> gets unified with the list of statements in a concrete block.  Variant 1 is much nicer to work with in case you don&apos;t care about the order. With variant 2, you have the order but if you don&apos;t care about it, queries become a bit more complicated (basically you need <code>membero</code> goals over the place).</z><z id="t1438267679000054" t="tsdh @jballanc: Well, I guess just providing both versions makes everybody happy, and variant 1 can easily be implemented on top of variant 2."><y>#</y><d>2015-07-30</d><h>14:47</h><w>tsdh</w>@jballanc: Well, I guess just providing both versions makes everybody happy, and variant 1 can easily be implemented on top of variant 2.</z><z id="t1438267740000055" t="tsdh @jballanc: Just the reverse seems to be not so trivial, and of course I started with variant 1. simple_smile"><y>#</y><d>2015-07-30</d><h>14:49</h><w>tsdh</w>@jballanc: Just the reverse seems to be not so trivial, and of course I started with variant 1. <b>simple_smile</b></z><z id="t1438271186000056" t="jballanc tsdh: It’s an interesting use-case to be sure. About the only thing I can think of that might make it easier to work with is if you could describe an ordering relationship between the individual statements. Something like: endif must come after if but before enddef …or something like that. I suspect, though, that you’d quickly find yourself implementing a full parser/AST walker."><y>#</y><d>2015-07-30</d><h>15:46</h><w>jballanc</w>tsdh: It’s an interesting use-case to be sure. About the only thing I can think of that might make it easier to work with is if you could describe an ordering relationship between the individual statements. Something like: <code>endif</code> must come after <code>if</code> but before <code>enddef</code>…or something like that. I suspect, though, that you’d quickly find yourself implementing a full parser/AST walker.</z><z id="t1438271231000057" t="jballanc …which, to be sure, is definitely an interesting use case. You might be interested to check out Will Byrd’s Quine generator in mini-Kanren, as it has similar-ish elements as I recall."><y>#</y><d>2015-07-30</d><h>15:47</h><w>jballanc</w>…which, to be sure, is definitely an interesting use case. You might be interested to check out Will Byrd’s Quine generator in mini-Kanren, as it has similar-ish elements as I recall.</z><z id="t1438273091000058" t="tsdh @jballanc: ok, thanks for the pointer"><y>#</y><d>2015-07-30</d><h>16:18</h><w>tsdh</w>@jballanc: ok, thanks for the pointer</z><z id="t1438276628000059" t="tsdh Another thing: can I define a relation which asserts that some goal succeeds but some other goal fails? I&apos;d be fine with such a must-fail construct was non-relational, that is, only applicable if all logic variables of the goal are ground."><y>#</y><d>2015-07-30</d><h>17:17</h><w>tsdh</w>Another thing: can I define a relation which asserts that some goal succeeds but some other goal fails? I&apos;d be fine with such a must-fail construct was non-relational, that is, only applicable if all logic variables of the goal are ground.</z><z id="t1438276680000060" t="tsdh I guess that&apos;s easy to implement myself but probably there&apos;s already something predefined."><y>#</y><d>2015-07-30</d><h>17:18</h><w>tsdh</w>I guess that&apos;s easy to implement myself but probably there&apos;s already something predefined.</z><z id="t1438277997000061" t="nberger @tsdh I think nafc ( https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic.clj#L2725 ) is what you are looking for. See the tests ( https://github.com/clojure/core.logic/blob/29a46db8a294b29a37d8046fe7ed52be51f126f0/src/test/clojure/clojure/core/logic/tests.clj#L3169 ) for examples"><y>#</y><d>2015-07-30</d><h>17:39</h><w>nberger</w>@tsdh I think <code>nafc</code> (<a href="https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic.clj#L2725" target="_blank">https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic.clj#L2725</a>) is what you are looking for. See the tests (<a href="https://github.com/clojure/core.logic/blob/29a46db8a294b29a37d8046fe7ed52be51f126f0/src/test/clojure/clojure/core/logic/tests.clj#L3169" target="_blank">https://github.com/clojure/core.logic/blob/29a46db8a294b29a37d8046fe7ed52be51f126f0/src/test/clojure/clojure/core/logic/tests.clj#L3169</a>) for examples</z><z id="t1438278128000065" t="tsdh @nberger: great, thank you!"><y>#</y><d>2015-07-30</d><h>17:42</h><w>tsdh</w>@nberger: great, thank you!</z><z id="t1438278250000067" t="nberger @tsdh: you are welcome"><y>#</y><d>2015-07-30</d><h>17:44</h><w>nberger</w>@tsdh: you are welcome</z><z id="t1438326727000068" t="tsdh Hm, can anyone explain this? (run* [q] (fresh [a b] (== q (list a b)) (fd/in a b (fd/interval 1 3)) (fd/&lt; a b) (nafc membero 2 q))) ;=&gt; ((1 2) (2 3) (1 3)) The negation as failure constraint is supposed to ensure that 2 is not a member of the list q , so I expected to get only the solution (1 3) ..."><y>#</y><d>2015-07-31</d><h>07:12</h><w>tsdh</w>Hm, can anyone explain this?
<pre>(run* [q]
  (fresh [a b]
    (== q (list a b))
    (fd/in a b (fd/interval 1 3))
    (fd/&lt; a b)
    (nafc membero 2 q)))
;=&gt; ((1 2) (2 3) (1 3))
</pre>
The negation as failure constraint is supposed to ensure that 2 is not a member of the list <code>q</code>, so I expected to get only the solution <code>(1 3)</code>...</z><z id="t1438327024000069" t="tsdh It works if I replace the constraint with (nafc == a 2) (nafc == b 2) or (!= a 2) (!= b 2) but that gets cumbersome if the length of the list collection is long or even unknown..."><y>#</y><d>2015-07-31</d><h>07:17</h><w>tsdh</w>It works if I replace the constraint with <code>(nafc == a 2) (nafc == b 2)</code> or <code>(!= a 2) (!= b 2)</code> but that gets cumbersome if the length of the list collection is long or even unknown...</z><z id="t1438327672000070" t="tsdh Well, I think this is a bug so I&apos;ve reported it: http://dev.clojure.org/jira/browse/LOGIC-172"><y>#</y><d>2015-07-31</d><h>07:27</h><w>tsdh</w>Well, I think this is a bug so I&apos;ve reported it: <a href="http://dev.clojure.org/jira/browse/LOGIC-172" target="_blank">http://dev.clojure.org/jira/browse/LOGIC-172</a></z><z id="t1438328227000071" t="tsdh Hm, it seems the problem only occurs stuff unified by clojure.core.logic.fd relations..."><y>#</y><d>2015-07-31</d><h>07:37</h><w>tsdh</w>Hm, it seems the problem only occurs stuff unified by <code>clojure.core.logic.fd</code> relations...</z><z id="t1438356048000072" t="nberger @tsdh it&apos;s not an issue with fd, but it&apos;s because a and b are not ground. nafc works only on grounded terms"><y>#</y><d>2015-07-31</d><h>15:20</h><w>nberger</w>@tsdh it&apos;s not an issue with fd, but it&apos;s because <code>a</code> and <code>b</code> are not ground. <code>nafc</code> works only on grounded terms</z><z id="t1438356132000073" t="nberger So the following does what you expected: (run* [q] (fresh [a b] (== q (list a b)) (fd/in a b (fd/interval 1 3)) (fd/&lt; a b) (== a 1) (== b 2) (l/nafc l/membero 2 q))) ;=&gt; () "><y>#</y><d>2015-07-31</d><h>15:22</h><w>nberger</w>So the following does what you expected:

<pre>(run* [q]
        (fresh [a b]
               (== q (list a b))
               (fd/in a b (fd/interval 1 3))
               (fd/&lt; a b)
               (== a 1)
               (== b 2)
               (l/nafc l/membero 2 q)))
;=&gt; ()
</pre></z><z id="t1438356225000075" t="nberger while the following doesn&apos;t: (run* [q] (fresh [a b] (== q (list a b)) (fd/in a b (fd/interval 1 3)) (fd/&lt; a b) (== a 1) (l/nafc l/membero 2 q) (== b 2))) ;=&gt; ((1 2)) "><y>#</y><d>2015-07-31</d><h>15:23</h><w>nberger</w>while the following doesn&apos;t:

<pre>(run* [q]
        (fresh [a b]
               (== q (list a b))
               (fd/in a b (fd/interval 1 3))
               (fd/&lt; a b)
               (== a 1)
               (l/nafc l/membero 2 q)
               (== b 2)))
;=&gt; ((1 2))
</pre></z><z id="t1438356287000076" t="nberger in the second example, b is not ground for the nafc"><y>#</y><d>2015-07-31</d><h>15:24</h><w>nberger</w>in the second example, <code>b</code> is not ground for the <code>nafc</code></z><z id="t1438356550000077" t="nberger a smaller example: (run* [q] (membero q [1 2]) (nafc membero 2 q)) ;=&gt; (1 2) "><y>#</y><d>2015-07-31</d><h>15:29</h><w>nberger</w>a smaller example:

<pre>(run* [q]
        (membero q [1 2])
        (nafc membero 2 q))
  ;=&gt; (1 2)
</pre></z><z id="t1438357675000078" t="nberger One way to accomplish what you were trying: (run* [q] (fresh [a b] (== q (list a b)) (fd/in a b (fd/interval 1 3)) (fd/&lt; a b) (everyg #(!= 2 %) q))) ;=&gt; ((1 3)) "><y>#</y><d>2015-07-31</d><h>15:47</h><w>nberger</w>One way to accomplish what you were trying:

<pre>(run* [q]
    (fresh [a b]
      (== q (list a b))
      (fd/in a b (fd/interval 1 3))
      (fd/&lt; a b)
      (everyg #(!= 2 %) q)))
  ;=&gt; ((1 3))
</pre></z><z id="t1438357699000079" t="nberger And if you have an arbitrary number of vars: (let [vars (map lvar (range 4))] (run* [q] (== q vars) (everyg #(fd/in % (fd/interval 1 6)) vars) (everyg #(apply fd/&lt; %) (partition 2 1 vars)) (everyg #(!= 2 %) q))) ;=&gt; ((1 3 4 5) (3 4 5 6) (1 4 5 6) (1 3 5 6) (1 3 4 6)) "><y>#</y><d>2015-07-31</d><h>15:48</h><w>nberger</w>And if you have an arbitrary number of vars:

<pre>(let [vars (map lvar (range 4))]
    (run* [q]
      (== q vars)
      (everyg #(fd/in % (fd/interval 1 6)) vars)
      (everyg #(apply fd/&lt; %) (partition 2 1 vars))
      (everyg #(!= 2 %) q)))
  ;=&gt; ((1 3 4 5) (3 4 5 6) (1 4 5 6) (1 3 5 6) (1 3 4 6))
</pre></z><z id="t1438359182000080" t="tsdh @nberger: But the nafc docs say that if the vars aren&apos;t ground, the evaluation of the constraint will be deferred."><y>#</y><d>2015-07-31</d><h>16:13</h><w>tsdh</w>@nberger: But the <code>nafc</code> docs say that if the vars aren&apos;t ground, the evaluation of the constraint will be deferred.</z><z id="t1438359349000081" t="tsdh ...which I read as &quot;it should work also for fresh vars where the actual check is deferred until the point where all vars are ground.&quot;"><y>#</y><d>2015-07-31</d><h>16:15</h><w>tsdh</w>...which I read as &quot;it should work also for fresh vars where the actual check is deferred until the point where all vars are ground.&quot;</z><z id="t1438359646000082" t="tsdh I think your smaller example is wrong. q takes the values 1 and 2, and of course (membero 2 1) and (membero 2 2) fail."><y>#</y><d>2015-07-31</d><h>16:20</h><w>tsdh</w>I think your smaller example is wrong.  <code>q</code> takes the values 1 and 2, and of course <code>(membero 2 1)</code> and <code>(membero 2 2)</code> fail.</z><z id="t1438359729000083" t="tsdh Probably you meant this: (run* [q] (== q [1 2]) (nafc membero 2 q)) ;=&gt; () which actually gives the right answer."><y>#</y><d>2015-07-31</d><h>16:22</h><w>tsdh</w>Probably you meant this:
<pre>(run* [q]
        (== q [1 2])
        (nafc membero 2 q))
;=&gt; ()
</pre>
which actually gives the right answer.</z><z id="t1438360208000084" t="nberger Yes, sorry, my example was wrong, so nafc is doing fine in that case. And reading again, I agree, deferred evaluation should do what you said"><y>#</y><d>2015-07-31</d><h>16:30</h><w>nberger</w>Yes, sorry, my example was wrong, so nafc is doing fine in that case. And reading again, I agree, deferred evaluation should do what you said</z><z id="t1438360902000085" t="tsdh Well, we&apos;ll see if someone with more knowledge on the implementation comments on the JIRA issue."><y>#</y><d>2015-07-31</d><h>16:41</h><w>tsdh</w>Well, we&apos;ll see if someone with more knowledge on the implementation comments on the JIRA issue.</z><z id="t1438360926000086" t="nberger yep simple_smile"><y>#</y><d>2015-07-31</d><h>16:42</h><w>nberger</w>yep <b>simple_smile</b></z><z id="t1438587136000087" t="tsdh nafc delays evaluation somehow until the args to the goal became ground. Is there some generic support for this delaying? I looked at the implementation but, well, didn&apos;t really get a clue. Maybe cgoal is the essence of it."><y>#</y><d>2015-08-03</d><h>07:32</h><w>tsdh</w><code>nafc</code> delays evaluation somehow until the args to the goal became ground. Is there some generic support for this delaying?  I looked at the implementation but, well, didn&apos;t really get a clue.  Maybe <code>cgoal</code> is the essence of it.</z><z id="t1438587245000088" t="tsdh But in my actual use-case, I don&apos;t have a constraint but a relation (foo a b c) which requires that at least a and b , or c are ground. It would be nice if I could delay that until that is the case."><y>#</y><d>2015-08-03</d><h>07:34</h><w>tsdh</w>But in my actual use-case, I don&apos;t have a constraint but a relation <code>(foo a b c)</code> which requires that at least <code>a</code> and <code>b</code>, or <code>c</code> are ground.  It would be nice if I could delay that until that is the case.</z><z id="t1438612194000089" t="jballanc @tsdh: I think it’s in the IConstraintStep reification: IRunnable (-runnable? [_] (every? #(ground-term? % s) args)))) "><y>#</y><d>2015-08-03</d><h>14:29</h><w>jballanc</w>@tsdh: I think it’s in the <code>IConstraintStep</code> reification:
<pre>IRunnable
           (-runnable? [_]
             (every? #(ground-term? % s) args))))
</pre></z><z id="t1438612198000090" t="jballanc https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic.clj#L2711"><y>#</y><d>2015-08-03</d><h>14:29</h><w>jballanc</w><a href="https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic.clj#L2711" target="_blank">https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic.clj#L2711</a></z><z id="t1438612370000092" t="tsdh @jballanc: That&apos;s probably it. I&apos;ll tinker around with that if I find some time."><y>#</y><d>2015-08-03</d><h>14:32</h><w>tsdh</w>@jballanc: That&apos;s probably it.  I&apos;ll tinker around with that if I find some time.</z><z id="t1438612373000093" t="tsdh Thanks"><y>#</y><d>2015-08-03</d><h>14:32</h><w>tsdh</w>Thanks</z><z id="t1438612378000094" t="jballanc np"><y>#</y><d>2015-08-03</d><h>14:32</h><w>jballanc</w>np</z><z id="t1440312821000106" t="nblumoe Hey, I am dabbling in core.logic. Playing with some naive ideas like the following, which shows some weird behavior (see the indicated return values from the solver):"><y>#</y><d>2015-08-23</d><h>06:53</h><w>nblumoe</w>Hey, I am dabbling in core.logic. Playing with some naive ideas like the following, which shows some weird behavior (see the indicated return values from the solver):</z><z id="t1440312825000107" t="nblumoe (defn sub-string? [s sub] (boolean (re-find (re-pattern sub) s))) (sub-string? &quot;123&quot; &quot;3&quot;) ;=&gt; true (sub-string? &quot;123&quot; &quot;4&quot;) ;=&gt; false (l/run* [q] (l/membero q (range 200 1000 12)) (l/== (sub-string? (str q) &quot;9&quot;) true)) ; randomly (?) returns either () or all the matches from the first logical ; expression, ignoring the second one "><y>#</y><d>2015-08-23</d><h>06:53</h><w>nblumoe</w><pre>(defn sub-string? [s sub]
  (boolean (re-find (re-pattern sub) s)))

(sub-string? &quot;123&quot; &quot;3&quot;)
;=&gt; true

(sub-string? &quot;123&quot; &quot;4&quot;)
;=&gt; false

(l/run* [q]
  (l/membero q (range 200 1000 12))
  (l/== (sub-string? (str q) &quot;9&quot;) true))
; randomly (?) returns either () or all the matches from the first logical
; expression, ignoring the second one
</pre></z><z id="t1440313021000111" t="nblumoe I guess I am doing something wrong with using a regular function in the logical expression. but how would I make such a thing work?"><y>#</y><d>2015-08-23</d><h>06:57</h><w>nblumoe</w>I guess I am doing something wrong with using a regular function in the logical expression. but how would I make such a thing work?</z><z id="t1440328621000114" t="nblumoe The string representation of q is probably not representing it&apos;s value. But how to check for q &apos;s value then?"><y>#</y><d>2015-08-23</d><h>11:17</h><w>nblumoe</w>The string representation of <code>q</code> is probably not representing it&apos;s value. But how to check for <code>q</code>&apos;s value then?</z><z id="t1440330911000116" t="nberger q is an lvar. You could use pred to &quot; Check a predicate against the value logic var.&quot;"><y>#</y><d>2015-08-23</d><h>11:55</h><w>nberger</w><code>q</code> is an lvar. You could use <code>pred</code> to &quot; Check a predicate against the value logic var.&quot;</z><z id="t1440330990000117" t="nberger https://clojure.github.io/core.logic/#clojure.core.logic/pred"><y>#</y><d>2015-08-23</d><h>11:56</h><w>nberger</w><a href="https://clojure.github.io/core.logic/#clojure.core.logic/pred" target="_blank">https://clojure.github.io/core.logic/#clojure.core.logic/pred</a></z><z id="t1440343075000118" t="nblumoe hm, thanks @nberger. this seemed to be pointing in the right direction. I could not make it work with (str q) but at least with comparing q as an int like #(= % 224) . However, I made an odd observation. Why is the result dependent on the order of logical expressions in these two cases:"><y>#</y><d>2015-08-23</d><h>15:17</h><w>nblumoe</w>hm, thanks @nberger. this seemed to be pointing in the right direction. I could not make it work with <code>(str q)</code> but at least with comparing <code>q</code> as an int like <code>#(= % 224)</code>. However, I made an odd observation. Why is the result dependent on the order of logical expressions in these two cases:</z><z id="t1440343086000119" t="nblumoe (l/run* [q] (l/project [q] (l/== q 224)) (l/pred q #(= % 224)) (l/membero q (range 200 1000 12))) ; =&gt; (224) (l/run* [q] (l/pred q #(= % 224)) (l/project [q] (l/== q 224)) (l/membero q (range 200 1000 12))) ; =&gt; () "><y>#</y><d>2015-08-23</d><h>15:18</h><w>nblumoe</w><pre>(l/run* [q]
  (l/project [q] (l/== q 224))
  (l/pred q #(=  % 224))
  (l/membero q (range 200 1000 12)))
; =&gt; (224)

(l/run* [q]
  (l/pred q #(=  % 224))
  (l/project [q] (l/== q 224))
  (l/membero q (range 200 1000 12)))
; =&gt; ()
</pre></z><z id="t1440343103000120" t="nblumoe Is that expected?? &lt;!channel&gt;"><y>#</y><d>2015-08-23</d><h>15:18</h><w>nblumoe</w>Is that expected?? &lt;!channel&gt;</z><z id="t1440344109000123" t="bhagany @nblumoe: I am a complete noob at this, so this will likely get corrected, but - I think your anonymous function assumes that q is ground. Here, == grounds q before the anonymous function in example 1, but not in example 2. "><y>#</y><d>2015-08-23</d><h>15:35</h><w>bhagany</w>@nblumoe: I am a complete noob at this, so this will likely get corrected, but - I think your anonymous function assumes that q is ground. Here, == grounds q before the anonymous function in example 1, but not in example 2. </z><z id="t1440344215000124" t="bhagany iirc, the order dependence is kind of an implementation detail, but it does leak in cases like this. "><y>#</y><d>2015-08-23</d><h>15:36</h><w>bhagany</w>iirc, the order dependence is kind of an implementation detail, but it does leak in cases like this. </z><z id="t1440344722000125" t="nblumoe cool, thanks @bhagany. was able to get my initial idea working now: (l/run* [q] (l/membero q (range 200 1000 12)) (l/pred q #(sub-string? (str %) &quot;9&quot;))) "><y>#</y><d>2015-08-23</d><h>15:45</h><w>nblumoe</w>cool, thanks @bhagany. was able to get my initial idea working now:
<pre>(l/run* [q]
  (l/membero q (range 200 1000 12))
  (l/pred q #(sub-string? (str %) &quot;9&quot;)))
</pre></z><z id="t1440344815000126" t="nblumoe Is there some kind of idiomatic way to make this order dependence explicit? Or is it just an issue for me because of my dangerous lack of knowledge about logic programming? 😄"><y>#</y><d>2015-08-23</d><h>15:46</h><w>nblumoe</w>Is there some kind of idiomatic way to  make this order dependence explicit? Or is it just an issue for me because of my dangerous lack of knowledge about logic programming? <b>😄</b></z><z id="t1440346077000127" t="bhagany @nblumoe: I&apos;m not aware of any idiom ... My instinct is to avoid things that depend on order, but I also haven&apos;t really internalized the kind of thinking necessary for logic programs :)"><y>#</y><d>2015-08-23</d><h>16:07</h><w>bhagany</w>@nblumoe: I&apos;m not aware of any idiom ... My instinct is to avoid things that depend on order, but I also haven&apos;t really internalized the kind of thinking necessary for logic programs :)</z><z id="t1440346115000128" t="bhagany I just hang out here hoping to absorb useful things "><y>#</y><d>2015-08-23</d><h>16:08</h><w>bhagany</w>I just hang out here hoping to absorb useful things </z><z id="t1440348513000129" t="nberger Yeah, many things depend on order... There&apos;s not much to do about that except knowing the exact semantics of each constraint, which is not trivial if your name isn&apos;t David :P"><y>#</y><d>2015-08-23</d><h>16:48</h><w>nberger</w>Yeah, many things depend on order... There&apos;s not much to do about that except knowing the exact semantics of each constraint, which is not trivial if your name isn&apos;t David :P</z><z id="t1440348608000130" t="nberger I now found that predc might be better than pred because it will delay evaluation if the var is not ground, like in the second of your two examples"><y>#</y><d>2015-08-23</d><h>16:50</h><w>nberger</w>I now found that <code>predc</code> might be better than <code>pred</code> because it will delay evaluation if the var is not ground, like in the second of your two examples</z><z id="t1440348642000131" t="nberger Haven&apos;t tried it tho because I&apos;m not close to a computer now"><y>#</y><d>2015-08-23</d><h>16:50</h><w>nberger</w>Haven&apos;t tried it tho because I&apos;m not close to a computer now</z><z id="t1440348685000132" t="nberger ^^^ @nblumoe"><y>#</y><d>2015-08-23</d><h>16:51</h><w>nberger</w>^^^ @nblumoe</z><z id="t1440348939000133" t="nberger The problem in the second example is that q is not ground yet, so it&apos;s an lvar when the predicate is evaluated... And an lvar is never equal to 224 . In the first example it was already unified with 224 on the first constraint, so by the time of the second constraint it&apos;s grounded to 224 , which is course is equal to 224 :)"><y>#</y><d>2015-08-23</d><h>16:55</h><w>nberger</w>The problem in the second example is that q is not ground yet, so it&apos;s an <code>lvar</code> when the predicate is evaluated... And an lvar is never equal to <code>224</code>. In the first example it was already unified with <code>224</code> on the first constraint, so by the time of the second constraint it&apos;s grounded to <code>224</code>, which is course is equal to <code>224</code> :)</z><z id="t1440349042000135" t="nberger Perhaps I just said the same as @bhagany did, but using more words :/"><y>#</y><d>2015-08-23</d><h>16:57</h><w>nberger</w>Perhaps I just said the same as @bhagany did, but using more words :/</z><z id="t1440349676000136" t="nblumoe (l/run 3 [q] (l/predc q #(boolean (re-find #&quot;9&quot; (str %)))) (l/membero q (range 200 1000 12))) ; =&gt; (296 392 596) :+1:"><y>#</y><d>2015-08-23</d><h>17:07</h><w>nblumoe</w><pre>(l/run 3 [q]
  (l/predc q #(boolean (re-find #&quot;9&quot; (str %))))
  (l/membero q (range 200 1000 12)))
; =&gt; (296 392 596)
</pre>
<b>:+1:</b></z><z id="t1440351083000137" t="nberger Cool simple_smile"><y>#</y><d>2015-08-23</d><h>17:31</h><w>nberger</w>Cool <b>simple_smile</b></z><z id="t1440375207000138" t="dmich @nblumoe: It is VERY bad etiquette to use (AT)channel. Everyone in channel gets notified!"><y>#</y><d>2015-08-24</d><h>00:13</h><w>dmich</w>@nblumoe: It is VERY bad etiquette to use  (AT)channel. Everyone in channel gets notified!</z><z id="t1440375216000139" t="dmich very annoying"><y>#</y><d>2015-08-24</d><h>00:13</h><w>dmich</w>very annoying</z><z id="t1440412798000141" t="nblumoe yes you are right @dmich, sorry. it&apos;s just annoying that we run into the 10k message limit so quickly. so if no one reads it on time, it&apos;s lost. also I think who does not want to be pinged would disable it. but to be sure: I fully understand, won&apos;t ping the channel anymore"><y>#</y><d>2015-08-24</d><h>10:39</h><w>nblumoe</w>yes you are right @dmich, sorry. it&apos;s just annoying that we run into the 10k message limit so quickly. so if no one reads it on time, it&apos;s lost. also I think who does not want to be pinged would disable it. but to be sure: I fully understand, won&apos;t ping the channel anymore</z><z id="t1440412908000142" t="nblumoe I do have another question though. how can I simplify the following small logic program? (def talents [{:email &quot; The logic seems to be right, I want to get all talents, that have at least one application with status :active . But the usage of project is quite verbose. Is there a way to make this whole thing more concise?"><y>#</y><d>2015-08-24</d><h>10:41</h><w>nblumoe</w>I do have another question though. how can I simplify the following small logic program?
<pre>(def talents
  [{:email &quot;</pre>
The logic seems to be right, I want to get all talents, that have at least one application with status <code>:active</code>. But the usage of <code>project</code> is quite verbose. Is there a way to make this whole thing more concise?</z><z id="t1440413248000143" t="nblumoe Okay, I got this now. Already a bit better: (defn active-talents [talents] (l/run* [q] (l/fresh [candidate candidates application applications] (l/membero q talents) (l/featurec q {:candidates candidates}) (l/membero candidate candidates) (l/featurec candidate {:applications applications}) (l/membero application applications) (l/featurec application {:status :active})))) "><y>#</y><d>2015-08-24</d><h>10:47</h><w>nblumoe</w>Okay, I got this now. Already a bit better:
<pre>(defn active-talents
  [talents]
  (l/run* [q]
    (l/fresh [candidate candidates application applications]
      (l/membero q talents)
      (l/featurec q {:candidates candidates})
      (l/membero candidate candidates)
      (l/featurec candidate {:applications applications})
      (l/membero application applications)
      (l/featurec application {:status :active}))))
</pre></z><z id="t1440413255000144" t="dmich @nblumoe: There are actually logs for this entire Slack team. See http://clojurians-log.mantike.pro/"><y>#</y><d>2015-08-24</d><h>10:47</h><w>dmich</w>@nblumoe: There are actually logs for this entire Slack team. See <a href="http://clojurians-log.mantike.pro/" target="_blank">http://clojurians-log.mantike.pro/</a></z><z id="t1440413275000145" t="dmich (Though I don&apos;t know how many people bother to read the back logs)"><y>#</y><d>2015-08-24</d><h>10:47</h><w>dmich</w>(Though I don&apos;t know how many people bother to read the back logs)</z><z id="t1440413310000146" t="nblumoe @dmich, true. But I would assume no one goes to the logs to check if there were any missed questions, but only if one already knows that there is something on the logs one would like to pick up."><y>#</y><d>2015-08-24</d><h>10:48</h><w>nblumoe</w>@dmich, true. But I would assume no one goes to the logs to check if there were any missed questions, but only if one already knows that there is something on the logs one would like to pick up.</z><z id="t1440413522000147" t="dmich Also, some people (not me), are set up to have a text message sent to their phone when notified in a Slack channel. And on more popular channels you can really see the hate that is invoked when someone abuses the here command let alone the channel command 😛"><y>#</y><d>2015-08-24</d><h>10:52</h><w>dmich</w>Also, some people (not me), are set up to have a text message sent to their phone when notified in a Slack channel. And on more popular channels you can really see the hate that is invoked when someone abuses the <code>here</code> command let alone the <code>channel</code> command <b>😛</b></z><z id="t1440413552000148" t="dmich So best practice is, if you don&apos;t eventually get an answer, ask again."><y>#</y><d>2015-08-24</d><h>10:52</h><w>dmich</w>So best practice is, if you don&apos;t eventually get an answer, ask again.</z><z id="t1440413686000149" t="nblumoe yeah, yeah. I know. It&apos;s an recurring issue with the notifications. I am good in ignoring selectively, but I understand others like to use this differently. I think flowdock&apos;s (at)team mentions are a good idea. As I would never expect anything urgent to happen on the Clojurians slack channels (like &quot;WTF, were did production go?&quot;) I don&apos;t see a need for this here though. But anyways, sorry again and back to topic. Maybe you have an idea about my too verbose code above? simple_smile"><y>#</y><d>2015-08-24</d><h>10:54</h><w>nblumoe</w>yeah, yeah. I know. It&apos;s an recurring issue with the notifications. I am good in ignoring selectively, but I understand others like to use this differently. I think flowdock&apos;s (at)team mentions are a good idea. As I would never expect anything urgent to happen on the Clojurians slack channels (like &quot;WTF, were did production go?&quot;) I don&apos;t see a need for this here though. But anyways, sorry again and back to topic. Maybe you have an idea about my too verbose code above? <b>simple_smile</b></z><z id="t1440413908000150" t="dmich Haha. sorry."><y>#</y><d>2015-08-24</d><h>10:58</h><w>dmich</w>Haha. sorry.</z><z id="t1440413922000151" t="dmich I am in this channel just to see what core-logic is all about."><y>#</y><d>2015-08-24</d><h>10:58</h><w>dmich</w>I am in this channel just to see what core-logic is all about.</z><z id="t1440413935000152" t="dmich You might have more luck in #C03S1KBA2 channel."><y>#</y><d>2015-08-24</d><h>10:58</h><w>dmich</w>You might have more luck in #C03S1KBA2 channel.</z><z id="t1440413944000153" t="dmich Also the Clojure IRC channel is VERY active"><y>#</y><d>2015-08-24</d><h>10:59</h><w>dmich</w>Also the Clojure IRC channel is VERY active</z><z id="t1440413965000154" t="dmich moreso than the slack channel"><y>#</y><d>2015-08-24</d><h>10:59</h><w>dmich</w>moreso than the slack channel</z><z id="t1440413995000155" t="dmich There have only been very few messages in this channel"><y>#</y><d>2015-08-24</d><h>10:59</h><w>dmich</w>There have only been very few messages in this channel</z><z id="t1440414089000157" t="dmich Yours was like only the second one this month"><y>#</y><d>2015-08-24</d><h>11:01</h><w>dmich</w>Yours was like only the second one this month</z><z id="t1444252325000003" t="jetzajac Hello everyone! Does anybody know if there is any constraint on type of the value? How can I assert that something is a symbol or number? miniKanren has such symbolo and numbero constraint but I can&apos;t find them in CL."><y>#</y><d>2015-10-07</d><h>21:12</h><w>jetzajac</w>Hello everyone! Does anybody know if there is any constraint on type of the value? How can I assert that something is a symbol or number? miniKanren has such symbolo and numbero constraint but I can&apos;t find them in CL.</z><z id="t1444738654000008" t="algernon @jetzajac: (project) can help: user=&gt; (run* [q] (conde [(== q 1)] [(== q &quot;foobar&quot;)]) (project [q] (== (type q) Long))) (1)"><y>#</y><d>2015-10-13</d><h>12:17</h><w>algernon</w>@jetzajac:  (project) can help: user=&gt; (run* [q] (conde [(== q 1)] [(== q &quot;foobar&quot;)]) (project [q] (== (type q) Long)))
(1)</z><z id="t1444738670000009" t="algernon mind you, project is non-relational"><y>#</y><d>2015-10-13</d><h>12:17</h><w>algernon</w>mind you, project is non-relational</z><z id="t1444738715000010" t="jetzajac yeah, that&apos;s kind of solution but I need a relational version of it if I want to write some interpreter."><y>#</y><d>2015-10-13</d><h>12:18</h><w>jetzajac</w>yeah, that&apos;s kind of solution but I need a relational version of it if I want to write some interpreter.</z><z id="t1444738772000012" t="jetzajac Actually I found @dnolen version of it here https://github.com/webyrd/symbolo-numbero-tests-for-core-logic/blob/master/symbolo/src/symbolo/core.clj"><y>#</y><d>2015-10-13</d><h>12:19</h><w>jetzajac</w>Actually I found @dnolen  version of it here <a href="https://github.com/webyrd/symbolo-numbero-tests-for-core-logic/blob/master/symbolo/src/symbolo/core.clj" target="_blank">https://github.com/webyrd/symbolo-numbero-tests-for-core-logic/blob/master/symbolo/src/symbolo/core.clj</a></z><z id="t1444738839000015" t="jetzajac Thus I&apos;m not sure why it&apos;s not in the library then"><y>#</y><d>2015-10-13</d><h>12:20</h><w>jetzajac</w>Thus I&apos;m not sure why it&apos;s not in the library then</z><z id="t1445981888000018" t="jeremyraines is there anywhere that explains core.logic pattern matching well?"><y>#</y><d>2015-10-27</d><h>21:38</h><w>jeremyraines</w>is there anywhere that explains core.logic pattern matching well?</z><z id="t1445981908000019" t="jeremyraines I can’t make sense of the zebras example here: https://github.com/swannodette/logic-tutorial"><y>#</y><d>2015-10-27</d><h>21:38</h><w>jeremyraines</w>I can’t make sense of the zebras example here: <a href="https://github.com/swannodette/logic-tutorial" target="_blank">https://github.com/swannodette/logic-tutorial</a></z><z id="t1445982438000021" t="nberger @jeremyraines: Perhaps there&apos;s something better, but this might help: http://objectcommando.com/blog/2011/10/13/appendo-the-great/"><y>#</y><d>2015-10-27</d><h>21:47</h><w>nberger</w>@jeremyraines: Perhaps there&apos;s something better, but this might help: <a href="http://objectcommando.com/blog/2011/10/13/appendo-the-great/" target="_blank">http://objectcommando.com/blog/2011/10/13/appendo-the-great/</a></z><z id="t1445982603000023" t="jeremyraines thanks, I’ll check it out"><y>#</y><d>2015-10-27</d><h>21:50</h><w>jeremyraines</w>thanks, I’ll check it out</z><z id="t1445982765000024" t="nberger @jeremyraines: just to be clear, it will help mostly in understanding righto , not the rest"><y>#</y><d>2015-10-27</d><h>21:52</h><w>nberger</w>@jeremyraines: just to be clear, it will help mostly in understanding <code>righto</code>, not the rest</z><z id="t1445982933000025" t="jeremyraines ok, cool"><y>#</y><d>2015-10-27</d><h>21:55</h><w>jeremyraines</w>ok, cool</z><z id="t1445983370000026" t="jeremyraines are the ?-prefixed variables logic variables? Like a named _ ?"><y>#</y><d>2015-10-27</d><h>22:02</h><w>jeremyraines</w>are the ?-prefixed variables logic variables?  Like a named _ ?</z><z id="t1445983456000027" t="nberger They are logic vars there, yes"><y>#</y><d>2015-10-27</d><h>22:04</h><w>nberger</w>They are logic vars there, yes</z><z id="t1445983491000028" t="nberger I think it&apos;s just a convention, and they would be vars even without the ? , but not sure"><y>#</y><d>2015-10-27</d><h>22:04</h><w>nberger</w>I think it&apos;s just a convention, and they would be vars even without the <code>?</code>, but not sure</z><z id="t1445983584000029" t="jeremyraines oh, got it."><y>#</y><d>2015-10-27</d><h>22:06</h><w>jeremyraines</w>oh, got it.</z><z id="t1446056843000036" t="jeremyraines what’s the right way to iterate over a bunch of lvars and apply separate constraints to each of them?"><y>#</y><d>2015-10-28</d><h>18:27</h><w>jeremyraines</w>what’s the right way to iterate over a bunch of lvars and apply separate constraints to each of them?</z><z id="t1446056891000037" t="jeremyraines I’m trying this: (map constrain-item lvars my-constraints) with no luck"><y>#</y><d>2015-10-28</d><h>18:28</h><w>jeremyraines</w>I’m trying this:  <code>(map constrain-item  lvars  my-constraints)</code> with no luck</z><z id="t1446057054000038" t="jeremyraines separate goals, I should say"><y>#</y><d>2015-10-28</d><h>18:30</h><w>jeremyraines</w>separate goals, I should say</z><z id="t1446057457000039" t="jeremyraines looks like I just needed to pass the resulting list of goals to and*"><y>#</y><d>2015-10-28</d><h>18:37</h><w>jeremyraines</w>looks like I just needed to pass the resulting list of goals to <code>and*</code></z><z id="t1446564408000044" t="thomas hi"><y>#</y><d>2015-11-03</d><h>15:26</h><w>thomas</w>hi</z><z id="t1446564470000045" t="thomas just a quick question... how actively is core.logic still developed these days.... the github repo seems to quiet."><y>#</y><d>2015-11-03</d><h>15:27</h><w>thomas</w>just a quick question... how actively is core.logic still developed these days.... the github repo seems to quiet.</z><z id="t1446584669000046" t="dnolen @thomas not very active, I’m too busy with ClojureScript stuff these days"><y>#</y><d>2015-11-03</d><h>21:04</h><w>dnolen</w>@thomas not very active, I’m too busy with ClojureScript stuff these days</z><z id="t1446584684000047" t="dnolen happy to see people take it up and push it along - I definitely have a massive list of todos"><y>#</y><d>2015-11-03</d><h>21:04</h><w>dnolen</w>happy to see people take it up and push it along - I definitely have a massive list of todos</z><z id="t1446648099000049" t="thomas @dnolen: ok thank you for letting us know."><y>#</y><d>2015-11-04</d><h>14:41</h><w>thomas</w>@dnolen:  ok thank you for letting us know.</z><z id="t1446648154000050" t="dnolen that’s said what’s there works perfectly fine"><y>#</y><d>2015-11-04</d><h>14:42</h><w>dnolen</w>that’s said what’s there works perfectly fine</z><z id="t1446648196000051" t="dnolen esp. the core miniKanren bits"><y>#</y><d>2015-11-04</d><h>14:43</h><w>dnolen</w>esp. the core miniKanren bits</z><z id="t1446649771000052" t="thomas cheers"><y>#</y><d>2015-11-04</d><h>15:09</h><w>thomas</w>cheers</z><z id="t1446654992000053" t="jano @dnolen can you give a pointer to the todo list?"><y>#</y><d>2015-11-04</d><h>16:36</h><w>jano</w>@dnolen can you give a pointer to the todo list?</z><z id="t1446657378000054" t="dnolen fix up CLP(FD), port to ClojureScript"><y>#</y><d>2015-11-04</d><h>17:16</h><w>dnolen</w>fix up CLP(FD), port to ClojureScript</z><z id="t1446657385000055" t="dnolen that would be the immediate todos"><y>#</y><d>2015-11-04</d><h>17:16</h><w>dnolen</w>that would be the immediate todos</z><z id="t1446657390000056" t="dnolen ideally convert to .cljc"><y>#</y><d>2015-11-04</d><h>17:16</h><w>dnolen</w>ideally convert to .cljc</z><z id="t1446657425000058" t="dnolen after that would be to enhance CLP(FD) to be less naive"><y>#</y><d>2015-11-04</d><h>17:17</h><w>dnolen</w>after that would be to enhance CLP(FD) to be less naive</z><z id="t1446657443000059" t="dnolen we should implement the algorithms used by Mozart for CLP(FD)"><y>#</y><d>2015-11-04</d><h>17:17</h><w>dnolen</w>we should implement the algorithms used by Mozart for CLP(FD)</z><z id="t1446657606000060" t="dnolen environment trimming would also be another big one"><y>#</y><d>2015-11-04</d><h>17:20</h><w>dnolen</w>environment trimming would also be another big one</z><z id="t1446657617000061" t="dnolen then you could use core.logic for fun simple parsing tasks"><y>#</y><d>2015-11-04</d><h>17:20</h><w>dnolen</w>then you could use core.logic for fun simple parsing tasks</z><z id="t1458941412000005" t="lvh Is there some code that already exists that finds free (logic, although perhaps that doesn’t really matter) in a quoted logic program?"><y>#</y><d>2016-03-25</d><h>21:30</h><w>lvh</w>Is there some code that already exists that finds free (logic, although perhaps that doesn’t really matter) in a quoted logic program?</z><z id="t1458941425000006" t="lvh (I’m writing some code that generates logic programs.)"><y>#</y><d>2016-03-25</d><h>21:30</h><w>lvh</w>(I’m writing some code that generates logic programs.)</z><z id="t1458944867000007" t="hiredman that could be very challenging depending on how thorough you want it to be, have you considered including that information with the code you generate?"><y>#</y><d>2016-03-25</d><h>22:27</h><w>hiredman</w>that could be very challenging depending on how thorough you want it to be, have you considered including that information with the code you generate?</z><z id="t1458944925000008" t="hiredman for arbitrary core.logic programs I think you would need to analyze arbitrary clojure forms for free variables (which tools.analyzer may have something you can use)"><y>#</y><d>2016-03-25</d><h>22:28</h><w>hiredman</w>for arbitrary core.logic programs I think you would need to analyze arbitrary clojure forms for free variables (which tools.analyzer may have something you can use)</z><z id="t1458945014000009" t="hiredman but since you control the generator, it isn&apos;t really arbitrary core.logic programs, so you can restrict the generator to a subset and only analyze the subset, and once you are tinkering with the generator, it may be easier to sort of build that information up in the generated programs vs analyzing the generated programs to recover it"><y>#</y><d>2016-03-25</d><h>22:30</h><w>hiredman</w>but since you control the generator, it isn&apos;t really arbitrary core.logic programs, so you can restrict the generator to a subset and only analyze the subset, and once you are tinkering with the generator, it may be easier to sort of build that information up in the generated programs vs analyzing the generated programs to recover it</z><z id="t1458945238000010" t="lvh Yeah; that’s the problem I ran into trying to do this as well"><y>#</y><d>2016-03-25</d><h>22:33</h><w>lvh</w>Yeah; that’s the problem I ran into trying to do this as well</z><z id="t1458945249000011" t="lvh (the source query language is not core.logic; it compiles down to core.logic)"><y>#</y><d>2016-03-25</d><h>22:34</h><w>lvh</w>(the source query language is not core.logic; it compiles down to core.logic)</z><z id="t1458945254000012" t="lvh I ended up doing metadata annotation"><y>#</y><d>2016-03-25</d><h>22:34</h><w>lvh</w>I ended up doing metadata annotation</z><z id="t1458945266000013" t="lvh (see first hunks of https://github.com/RackSec/desdemona/pull/111/files if you’re interested)"><y>#</y><d>2016-03-25</d><h>22:34</h><w>lvh</w>(see first hunks of <a href="https://github.com/RackSec/desdemona/pull/111/files" target="_blank">https://github.com/RackSec/desdemona/pull/111/files</a> if you’re interested)</z><z id="t1458945435000015" t="hiredman so it sounds like you have a source language, do a pass over that to turn it in to core.logic, then want to recover the free variable information from the core.logic program. I think the classic thing to do (compiler wise) would be to get that information in an analysis pass over the source language before compilation"><y>#</y><d>2016-03-25</d><h>22:37</h><w>hiredman</w>so it sounds like you have a source language, do a pass over that to turn it in to core.logic, then want to recover the free variable information from the core.logic program. I think the classic thing to do (compiler wise) would be to get that information in an analysis pass over the source language before compilation</z><z id="t1458945470000016" t="lvh hiredman: Yup. That’s exactly what I did simple_smile"><y>#</y><d>2016-03-25</d><h>22:37</h><w>lvh</w>hiredman: Yup. That’s exactly what I did <b>simple_smile</b></z><z id="t1458945490000017" t="lvh hiredman: I was hoping to do it in a completely disjoint step so that the intermediary step doesn’t have to understand what a free variable is"><y>#</y><d>2016-03-25</d><h>22:38</h><w>lvh</w>hiredman: I was hoping to do it in a completely disjoint step so that the intermediary step doesn’t have to understand what a free variable is</z><z id="t1458945498000018" t="lvh but as you pointed out that way lies madness"><y>#</y><d>2016-03-25</d><h>22:38</h><w>lvh</w>but as you pointed out that way lies madness</z><z id="t1458945581000019" t="lvh (there’s one extra step: the source language is infix)"><y>#</y><d>2016-03-25</d><h>22:39</h><w>lvh</w>(there’s one extra step: the source language is infix)</z><z id="t1459109359000020" t="exupero How should I do math with core.logic in ClojureScript without clojure.core.logic.fd?"><y>#</y><d>2016-03-27</d><h>20:09</h><w>exupero</w>How should I do math with core.logic in ClojureScript without clojure.core.logic.fd?</z><z id="t1459109375000021" t="exupero At the moment all I need is addition."><y>#</y><d>2016-03-27</d><h>20:09</h><w>exupero</w>At the moment all I need is addition.</z><z id="t1459111430000022" t="hiredman it sort of depends, if the variables are ground , you can use project"><y>#</y><d>2016-03-27</d><h>20:43</h><w>hiredman</w>it sort of depends, if the variables are ground , you can use project</z><z id="t1459112619000023" t="exupero @hiredman: Thanks for the pointer, but I don’t understand what that means. Can you elaborate or point me somewhere that talks about that?"><y>#</y><d>2016-03-27</d><h>21:03</h><w>exupero</w>@hiredman: Thanks for the pointer, but I don’t understand what that means. Can you elaborate or point me somewhere that talks about that?</z><z id="t1459113396000024" t="hiredman project is a non-relational thing, because it depends on the order in which your logic program executes, and what it does is, give a logic variable, if by the time the project executes the logic program has already figured out the value of that logic variable, it gives you that value"><y>#</y><d>2016-03-27</d><h>21:16</h><w>hiredman</w>project is a non-relational thing, because it depends on the order in which your logic program executes, and what it does is, give a logic variable, if by the time the project executes the logic program has already figured out the value of that logic variable, it gives you that value</z><z id="t1459113522000025" t="hiredman so something like (run [q] (fresh [a] (== a 1) (project [a] (== q (inc a)))) will work (I forget the syntax for project)"><y>#</y><d>2016-03-27</d><h>21:18</h><w>hiredman</w>so something like <pre>(run [q] (fresh [a] (== a 1) (project [a] (== q (inc a))))</pre> will work (I forget the syntax for project)</z><z id="t1459113555000026" t="hiredman (run [q] (fresh [a] (project [a] (== q (inc a))) (= a 1))) will not"><y>#</y><d>2016-03-27</d><h>21:19</h><w>hiredman</w><pre>(run [q] (fresh [a]  (project [a] (== q (inc a))) (= a 1)))</pre> will not</z><z id="t1459113695000027" t="hiredman err that should be &apos;(== a 1)&apos; at the end"><y>#</y><d>2016-03-27</d><h>21:21</h><w>hiredman</w>err that should be &apos;(== a 1)&apos; at the end</z><z id="t1459115285000028" t="exupero Thanks. I’ll play with that."><y>#</y><d>2016-03-27</d><h>21:48</h><w>exupero</w>Thanks. I’ll play with that.</z><z id="t1459116223000029" t="exupero Perfect. Thanks!"><y>#</y><d>2016-03-27</d><h>22:03</h><w>exupero</w>Perfect. Thanks!</z><z id="t1459886928000032" t="josh.freckleton what are some real-world use cases for logical programming?"><y>#</y><d>2016-04-05</d><h>20:08</h><w>josh.freckleton</w>what are some real-world use cases for logical programming?</z><z id="t1459887254000033" t="hiredman threatgrid was(is? but they were acquired by cisco a while back) using core.logic for, uh, I guess threat recognition, they actually contributed the pldb fact database thing to core.logic"><y>#</y><d>2016-04-05</d><h>20:14</h><w>hiredman</w>threatgrid was(is? but they were acquired by cisco a while back) using core.logic for, uh, I guess threat recognition, they actually contributed the pldb fact database thing to core.logic</z><z id="t1459887350000034" t="hiredman I think rackspace is actually planning on something similar (also using core.logic)"><y>#</y><d>2016-04-05</d><h>20:15</h><w>hiredman</w>I think rackspace is actually planning on something similar (also using core.logic)</z><z id="t1459887365000035" t="hiredman https://github.com/RackSec/desdemona"><y>#</y><d>2016-04-05</d><h>20:16</h><w>hiredman</w><a href="https://github.com/RackSec/desdemona" target="_blank">https://github.com/RackSec/desdemona</a></z><z id="t1459887498000037" t="hiredman I&apos;ve actually never ended up using core.logic at work, but since I have spent a little time with core.logic, and implemented minikanren, a lot of the ideas around searching and generating and unification have ended up popping up in stuff I do"><y>#</y><d>2016-04-05</d><h>20:18</h><w>hiredman</w>I&apos;ve actually never ended up using core.logic at work, but since I have spent a little time with core.logic, and implemented minikanren, a lot of the ideas around searching and generating and unification have ended up popping up in stuff I do</z><z id="t1459887821000038" t="josh.freckleton @hiredman: woh cool! I&apos;m trying to get a feel of whether or not it&apos;s worth investing the time to learn logical programming in clj. Are there generic classes of problems that solve well in logical programming?"><y>#</y><d>2016-04-05</d><h>20:23</h><w>josh.freckleton</w>@hiredman: woh cool! I&apos;m trying to get a feel of whether or not it&apos;s worth investing the time to learn logical programming in clj. Are there generic classes of problems that solve well in logical programming?</z><z id="t1459888118000039" t="hiredman well, so I think desdemona and threatgrid&apos;s use most likely look sort of like an expert system or rules engine"><y>#</y><d>2016-04-05</d><h>20:28</h><w>hiredman</w>well, so I think desdemona and threatgrid&apos;s use most likely look sort of like an expert system or rules engine</z><z id="t1459888250000040" t="hiredman I like to try and use it to figure out my inlaws secrete santa every year"><y>#</y><d>2016-04-05</d><h>20:30</h><w>hiredman</w>I like to try and use it to figure out my inlaws secrete santa every year</z><z id="t1459888296000041" t="hiredman they set certain rules on the exchange about couples not getting each other in the exchange, that sort of thing"><y>#</y><d>2016-04-05</d><h>20:31</h><w>hiredman</w>they set certain rules on the exchange about couples not getting each other in the exchange, that sort of thing</z><z id="t1459888392000042" t="hiredman so I write a core.logic program that takes in to account those rules, and generates all possible gifting pairs, and then I observe and try to find out more facts and add them to the program until it gets down to one possible set"><y>#</y><d>2016-04-05</d><h>20:33</h><w>hiredman</w>so I write a core.logic program that takes in to account those rules, and generates all possible gifting pairs, and then I observe and try to find out more facts and add them to the program until it gets down to one possible set</z><z id="t1459888417000043" t="hiredman it rarely goes well, they practice good opsec"><y>#</y><d>2016-04-05</d><h>20:33</h><w>hiredman</w>it rarely goes well, they practice good opsec</z><z id="t1459888585000045" t="josh.freckleton hahaha! that&apos;s awesome. so expert systems, rules engines, got it. I&apos;ll at least learn it for fun simple_smile"><y>#</y><d>2016-04-05</d><h>20:36</h><w>josh.freckleton</w>hahaha! that&apos;s awesome. so expert systems, rules engines, got it. I&apos;ll at least learn it for fun <b>simple_smile</b></z><z id="t1459889220000046" t="hiredman I started woodworking as a hobby and ended up using core.logic figure out dimensions for a workbench, https://gist.github.com/hiredman/05befd5b39eef89b86ca (I don&apos;t recommend this workbench btw)"><y>#</y><d>2016-04-05</d><h>20:47</h><w>hiredman</w>I started woodworking as a hobby and ended up using core.logic figure out dimensions for a workbench, <a href="https://gist.github.com/hiredman/05befd5b39eef89b86ca" target="_blank">https://gist.github.com/hiredman/05befd5b39eef89b86ca</a> (I don&apos;t recommend this workbench btw)</z><z id="t1459889632000047" t="josh.freckleton @hiredman: huh, that&apos;s kind of awesome. So you give it constraints on what the table should look like, and it figures out the dimensions of all of the pieces of wood?"><y>#</y><d>2016-04-05</d><h>20:53</h><w>josh.freckleton</w>@hiredman: huh, that&apos;s kind of awesome. So you give it constraints on what the table should look like, and it figures out the dimensions of all of the pieces of wood?</z><z id="t1459889742000048" t="hiredman yeah"><y>#</y><d>2016-04-05</d><h>20:55</h><w>hiredman</w>yeah</z><z id="t1459890828000049" t="josh.freckleton @hiredman: why do you not recommend it?"><y>#</y><d>2016-04-05</d><h>21:13</h><w>josh.freckleton</w>@hiredman: why do you not recommend it?</z><z id="t1459891685000050" t="hiredman it is basically a really heavy table, which is maybe 80% of want you want from a handtool woodworking bench, but the 20%, the work holding, is kind of clutch. It is also on the small side (I was living in an apartment when I came up the dimensions). I have been contemplating building what people are calling a knockdown nicholson for a while now"><y>#</y><d>2016-04-05</d><h>21:28</h><w>hiredman</w>it is basically a really heavy table, which is maybe 80% of want you want from a handtool woodworking bench, but the 20%, the work holding, is kind of clutch. It is also on the small side (I was living in an apartment when I came up the dimensions).  I have been contemplating building what people are calling a knockdown nicholson for a while now</z><z id="t1459892635000051" t="josh.freckleton @hiredman: that looks awesome! I built a guitar from scratch a few years ago, and I&apos;ve been craving getting back into wood working. Using code for wood projects is a cool junction simple_smile Hey, can I ask a simple question? I&apos;m going through some prolog &quot;puzzles&quot; to learn core.logic and I can&apos;t solve the first one, I just don&apos;t get how to &quot;destructure&quot; variable length lists. I just want to take the last of a list, and this is kinda what my approach is: (run* [q] (== [_ | q] [1 2 3 4]) ) or second from last: (run* [q] (== [_ | q _] [1 2 3 4]) ) Any idea if I&apos;m on the right track?"><y>#</y><d>2016-04-05</d><h>21:43</h><w>josh.freckleton</w>@hiredman: that looks awesome! I built a guitar from scratch a few years ago, and I&apos;ve been craving getting back into wood working. Using code for wood projects is a cool junction <b>simple_smile</b>

Hey, can I ask a simple question? I&apos;m going through some prolog &quot;puzzles&quot; to learn <code>core.logic</code> and I can&apos;t solve the first one, I just don&apos;t get how to &quot;destructure&quot; variable length lists.

I just want to take the last of a list, and this is kinda what my approach is:

<pre>(run* [q]
  (== [_ | q] [1 2 3 4])
  )</pre>

or second from last:

<pre>(run* [q]
  (== [_ | q _] [1 2 3 4])
  )</pre>

Any idea if I&apos;m on the right track?</z><z id="t1459892817000053" t="hiredman the translation from prolog isn&apos;t that direct"><y>#</y><d>2016-04-05</d><h>21:46</h><w>hiredman</w>the translation from prolog isn&apos;t that direct</z><z id="t1459892835000054" t="hiredman == doesn&apos;t have any kind sugar, just unification"><y>#</y><d>2016-04-05</d><h>21:47</h><w>hiredman</w>== doesn&apos;t have any kind sugar, just unification</z><z id="t1459892889000055" t="hiredman so something like (== [(lvar) q (lvar) (lvar) (lvar)] [1 2 3 4]) might work (I forget exactly the name of the function to generate a fresh lvar)"><y>#</y><d>2016-04-05</d><h>21:48</h><w>hiredman</w>so something like (== [(lvar) q (lvar) (lvar) (lvar)] [1 2 3 4]) might work (I forget exactly the name of the function to generate a fresh lvar)</z><z id="t1459892943000056" t="hiredman there are some macros for defining functions that can do pattern matching sort of unification on arguments, but I haven&apos;t really used those"><y>#</y><d>2016-04-05</d><h>21:49</h><w>hiredman</w>there are some macros for defining functions that can do pattern matching sort of unification on arguments, but I haven&apos;t really used those</z><z id="t1459893002000057" t="josh.freckleton nice, it does work: (run* [q] (== [(lvar) (lvar) (lvar) q] [1 2 3 4]))"><y>#</y><d>2016-04-05</d><h>21:50</h><w>josh.freckleton</w>nice, it does work:

<pre>(run* [q]
  (== [(lvar) (lvar) (lvar) q] [1 2 3 4]))</pre></z><z id="t1459893011000058" t="josh.freckleton now to figure out variable lengths..."><y>#</y><d>2016-04-05</d><h>21:50</h><w>josh.freckleton</w>now to figure out variable lengths...</z><z id="t1459898554000059" t="josh.freckleton I can grab the first like this, but not the last: (run* [q] (fresh [a o] (== a [1 2 3 4 5]) (matche [a] ([ [o . _] ] (== q o)))))"><y>#</y><d>2016-04-05</d><h>23:22</h><w>josh.freckleton</w>I can grab the first like this, but not the last:
<pre>(run* [q]
  (fresh [a o]
    (== a [1 2 3 4 5])
    (matche [a]
            ([ [o . _] ]
             (== q o)))))</pre></z><z id="t1459915681000060" t="josh.freckleton How can I get all multiples of3 in range 50 using core.logic ? This is all I&apos;ve got: (run* [q] (membero q (range 50)) (conde [(== (mod q 3) 0)]))"><y>#</y><d>2016-04-06</d><h>04:08</h><w>josh.freckleton</w>How can I get all multiples of3 in range 50 using <code>core.logic</code>? This is all I&apos;ve got:
<pre>(run* [q]
  (membero q (range 50))
  (conde
   [(== (mod q 3) 0)]))</pre></z><z id="t1459915707000061" t="josh.freckleton I get the error clojure.core.logic.LVar cannot be cast to java.lang.Number"><y>#</y><d>2016-04-06</d><h>04:08</h><w>josh.freckleton</w>I get the error <code> clojure.core.logic.LVar cannot be cast to java.lang.Number</code></z><z id="t1459973454000063" t="hiredman @josh.freckleton: the thing is, core.logic doesn&apos;t have its own notion of names, so when you see &apos;q&apos; there what you are seeing is a clojure name &apos;q&apos; which is bound to an lvar. mod of course is a clojure function which has no idea what to do with an lvar. the only meaningful operations on lvars are constraints (via unification or something else). for numeric stuff often what you want can be achieved using https://github.com/clojure/core.logic/wiki/Features#clpfd"><y>#</y><d>2016-04-06</d><h>20:10</h><w>hiredman</w>@josh.freckleton: the thing is, core.logic doesn&apos;t have its own notion of names, so when you see &apos;q&apos; there what you are seeing is a clojure name &apos;q&apos; which is bound to an lvar. mod of course is a clojure function which has no idea what to do with an lvar. the only meaningful operations on lvars are constraints (via unification or something else). for numeric stuff often what you want can be achieved using <a href="https://github.com/clojure/core.logic/wiki/Features#clpfd" target="_blank">https://github.com/clojure/core.logic/wiki/Features#clpfd</a></z><z id="t1459973516000065" t="josh.freckleton @hiredman: thanks, I&apos;m spending some time with &quot;the reasoned schemer&quot;, and some of this is starting to become clear, thanks for your help!"><y>#</y><d>2016-04-06</d><h>20:11</h><w>josh.freckleton</w>@hiredman: thanks, I&apos;m spending some time with &quot;the reasoned schemer&quot;, and some of this is starting to become clear, thanks for your help!</z><z id="t1459981751000066" t="josh.freckleton can I ask another question? I&apos;m trying to sum up all multiples of 3 and 5, and I&apos;ve got everything working except I can&apos;t connect the sumo to the list of multiples of 3/5: (defnc divxc [x y] ; is it divisible? (zero? (mod x y))) (defn sumo [x out] ; sum up a list (conde ((emptyo x) (== out 0)) (s# (fresh [f r rs] (firsto x f) (resto x r) (sumo r rs) (fd/+ f rs out))))) (defn mult35o [x] ; list of things divisible by 3 or 5 (fresh [a] (fd/in a (fd/interval 1 50)) (fd/distinct [a]) (conde ((divxc a 3)) ((divxc a 5))) (== x a))) (run* [x] ; test (mult35o x)) (run* [x] ; test (sumo [1 2 3 4] x)) (run* [x] (fresh [a b] (mult35o a) (firsto a b) (sumo b x))) "><y>#</y><d>2016-04-06</d><h>22:29</h><w>josh.freckleton</w>can I ask another question? I&apos;m trying to sum up all multiples of 3 and 5, and I&apos;ve got everything working except I can&apos;t connect the <code>sumo</code> to the list of multiples of 3/5:

<pre>(defnc divxc [x y] ; is it divisible?
  (zero? (mod x y)))

(defn sumo [x out] ; sum up a list
  (conde
   ((emptyo x) (== out 0))
   (s# (fresh [f r rs]
         (firsto x f)
         (resto x r)
         (sumo r rs)
         (fd/+ f rs out)))))

(defn mult35o [x] ; list of things divisible by 3 or 5
  (fresh [a]
    (fd/in a (fd/interval 1 50))
    (fd/distinct [a])
    (conde
     ((divxc a 3))
     ((divxc a 5)))
    (== x a)))

(run* [x] ; test
  (mult35o x))
(run* [x] ; test
  (sumo [1 2 3 4] x))

(run* [x]
  (fresh [a b]
    (mult35o a)
    (firsto a b)
    (sumo b x)))
</pre></z><z id="t1459981835000067" t="josh.freckleton it seems that a is getting assigned something like ((3 5 ...)) , so I try to &quot;unpack&quot; it with firsto , but in the end this doesn&apos;t work..."><y>#</y><d>2016-04-06</d><h>22:30</h><w>josh.freckleton</w>it seems that <code>a</code> is getting assigned something like <code>((3 5 ...))</code>, so I try to &quot;unpack&quot; it with <code>firsto</code>, but in the end this doesn&apos;t work...</z><z id="t1459981838000068" t="josh.freckleton 😞"><y>#</y><d>2016-04-06</d><h>22:30</h><w>josh.freckleton</w><b>😞</b></z><z id="t1460156168000070" t="josh.freckleton How do I disunify correctly? I posted details on SO: https://stackoverflow.com/questions/36509025/how-can-i-disunify-b-lvar-from-a-a-b-b-c-c-in-clojure-core-lo"><y>#</y><d>2016-04-08</d><h>22:56</h><w>josh.freckleton</w>How do I disunify correctly? I posted details on SO:
<a href="https://stackoverflow.com/questions/36509025/how-can-i-disunify-b-lvar-from-a-a-b-b-c-c-in-clojure-core-lo" target="_blank">https://stackoverflow.com/questions/36509025/how-can-i-disunify-b-lvar-from-a-a-b-b-c-c-in-clojure-core-lo</a></z><z id="t1460160879000072" t="hiredman I am not entirely sure, but I suspect the issue is the lvar not being grounded in your second set of examples, because the lvar isn&apos;t bound to a definite value it is sort of undecided either way"><y>#</y><d>2016-04-09</d><h>00:14</h><w>hiredman</w>I am not entirely sure, but I suspect the issue is the lvar not being grounded in your second set of examples, because the lvar isn&apos;t bound to a definite value it is sort of undecided either way</z><z id="t1460160917000073" t="hiredman I think to do what you want, instead of using the lvar like that, you want to say none of the elements of the sequence have a first value that is &apos;:b&apos;"><y>#</y><d>2016-04-09</d><h>00:15</h><w>hiredman</w>I think to do what you want, instead of using the lvar like that, you want to say none of the elements of the sequence have a first value that is &apos;:b&apos;</z><z id="t1461630017000002" t="exupero How can I do aggregation in core.logic?"><y>#</y><d>2016-04-26</d><h>00:20</h><w>exupero</w>How can I do aggregation in core.logic?</z><z id="t1464886681000009" t="tristefigure Hi. I was wondering : how can I sort multiple results coming out of run* ? The idea is to sort them using core.logic itself by expressing preferences rules ? In particular, I’m wondering how I can express an ‘arbitrary’ preference order such as : prefer ?a over ?b. I’ve already used systems that worked this way : they checked for acyclicity so as to avoid contradiction in the preference statements (which were just binary relations)."><y>#</y><d>2016-06-02</d><h>16:58</h><w>tristefigure</w>Hi. I was wondering : how can I sort multiple results coming out of <code>run*</code> ? The idea is to sort them using core.logic itself by expressing preferences rules ? In particular, I’m wondering how I can express an ‘arbitrary’ preference order such as : prefer ?a over ?b. I’ve already used systems that worked this way : they checked for acyclicity so as to avoid contradiction in the preference statements (which were just binary relations).</z><z id="t1464886887000010" t="tristefigure I think i really am just looking for a way to make a topological sort. Any idea ?"><y>#</y><d>2016-06-02</d><h>17:01</h><w>tristefigure</w>I think i really am just looking for a way to make a topological sort. Any idea ?</z><z id="t1464887137000011" t="hiredman minikanren, on which core.logic is based, does this interleaving of goals to make it so non-convergent goals don&apos;t continue to not converge infinitely while a convergent goal never gets a chance to run"><y>#</y><d>2016-06-02</d><h>17:05</h><w>hiredman</w>minikanren, on which core.logic is based, does this interleaving of goals to make it so non-convergent goals don&apos;t continue to not converge infinitely while a convergent goal never gets a chance to run</z><z id="t1464887175000012" t="hiredman I think that would make it difficult to impossible to get ordering without some deeper modifications"><y>#</y><d>2016-06-02</d><h>17:06</h><w>hiredman</w>I think that would make it difficult to impossible to get ordering without some deeper modifications</z><z id="t1464887347000013" t="hiredman https://scholarworks.iu.edu/dspace/bitstream/handle/2022/8777/Byrd_indiana_0093A_10344.pdf you can search for &quot;interleaving&quot; to read more about it, they mention it a lot, are very proud of it, and contrast it with prolog"><y>#</y><d>2016-06-02</d><h>17:09</h><w>hiredman</w><a href="https://scholarworks.iu.edu/dspace/bitstream/handle/2022/8777/Byrd_indiana_0093A_10344.pdf" target="_blank">https://scholarworks.iu.edu/dspace/bitstream/handle/2022/8777/Byrd_indiana_0093A_10344.pdf</a> you can search for &quot;interleaving&quot; to read more about it, they mention it a lot, are very proud of it, and contrast it with prolog</z><z id="t1464887546000014" t="hiredman without the interleaving, given a conde, the first branch would be searched exhaustively, then the next, etc"><y>#</y><d>2016-06-02</d><h>17:12</h><w>hiredman</w>without the interleaving, given a conde, the first branch would be searched exhaustively, then the next, etc</z><z id="t1464888532000015" t="tristefigure Indeed this seems non-trivial, I’m probably better off doing the sort using functional programming rather than relational programming. Actually, I’m currently investigating minikanren in order to express business rules. I haven’t found much resources about this and I must confess I am somehow disappointed – but maybe this is because I haven’t employed many rules in my experiments so far. I’d be interested in reading stuffs (blogs, books, whatever) about solving business related problems with minikanren. So far, most of the use of minikanren I saw concerned small problems that had some kind of mathematical purity at their heart (the sudoku solver for instance), whereas I’m trying to determine if it could be of any use in cases where there a many rules such as in a business related environment (for instance, billing rules)."><y>#</y><d>2016-06-02</d><h>17:28</h><w>tristefigure</w>Indeed this seems non-trivial, I’m probably better off doing the sort using functional programming rather than relational programming.
Actually, I’m currently investigating minikanren in order to express business rules. I haven’t found much resources about this and I must confess I am somehow disappointed – but maybe this is because I haven’t employed many rules in my experiments so far. I’d be interested in reading stuffs (blogs, books, whatever) about solving business related problems with minikanren. So far, most of the use of minikanren I saw concerned small problems that had some kind of mathematical purity at their heart (the sudoku solver for instance), whereas I’m trying to determine if it could be of any use in cases where there a many rules such as in a business related environment (for instance, billing rules).</z><z id="t1464888683000016" t="hiredman minikanren isn&apos;t a rules engine"><y>#</y><d>2016-06-02</d><h>17:31</h><w>hiredman</w>minikanren isn&apos;t a rules engine</z><z id="t1464889288000017" t="hiredman with a billing system in minikanren, you could ask questions like &quot;is it possible to get a bill with the properties x y and z&quot;, which is interesting and in many circumstances useful, but I think most businesses are concerned with if this then that style rules, which you can do in a relational language, but you&apos;ll be able to do better using a rules engine"><y>#</y><d>2016-06-02</d><h>17:41</h><w>hiredman</w>with a billing system in minikanren, you could ask questions like &quot;is it possible to get a bill with the properties x y and z&quot;, which is interesting and in many circumstances useful, but I think most businesses are concerned with if this then that style rules,  which you can do in a relational language, but you&apos;ll be able to do better using a rules engine</z><z id="t1464889432000018" t="hiredman I think this split is what is referred to as backwards chaining (what relational languages do) and forward chaining (what rules engines do)"><y>#</y><d>2016-06-02</d><h>17:43</h><w>hiredman</w>I think this split is what is referred to as backwards chaining (what relational languages do) and forward chaining (what rules engines do)</z><z id="t1464889463000019" t="hiredman the split isn&apos;t entirely black and white, mature rules engines and relational environments tend to support both"><y>#</y><d>2016-06-02</d><h>17:44</h><w>hiredman</w>the split isn&apos;t entirely black and white, mature rules engines and relational environments tend to support both</z><z id="t1465961552000002" t="hiredman you can do some combination of offer! and the internal cljs.core.async.impl.dispatch/process-messages , offer the line to the channel, and if the channel can&apos;t take the line, run process-messages then loop"><y>#</y><d>2016-06-15</d><h>03:32</h><w>hiredman</w>you can do some combination of <code>offer! </code>and the internal <code>cljs.core.async.impl.dispatch/process-messages</code>, offer the line to the channel, and if the channel can&apos;t take the line, run process-messages then loop</z><z id="t1471857562000011" t="alexati Hi! Newbie question. I’m trying to get to generate maps from partial maps but I feel like I miss some key piece of knowledge. If I run: (run 1 [q] (featurec q {:a 1})) I get: ((_0 :- (clojure.core.logic/featurec _0 {:a 1}))) Which makes complete sense. But I’m wondering, how can I “ground” the sequence so the first result is {:a 1}, without anything else? I’m stuck..."><y>#</y><d>2016-08-22</d><h>09:19</h><w>alexati</w>Hi! Newbie question. I’m trying to get to generate maps from partial maps but I feel like I miss some key piece of knowledge. If I run:
<code>(run 1 [q] (featurec q {:a 1}))</code>
I get:
<code>((_0 :- (clojure.core.logic/featurec _0 {:a 1})))</code>
Which makes complete sense. But I’m wondering, how can I “ground” the sequence so the first result is {:a 1}, without anything else? I’m stuck...</z><z id="t1475157900000003" t="abdullahibra hi guys"><y>#</y><d>2016-09-29</d><h>14:05</h><w>abdullahibra</w>hi guys</z><z id="t1475157964000004" t="abdullahibra why can&apos;t i do this? (run* [q1 q2] (= q1 (* q2 q2))) ?"><y>#</y><d>2016-09-29</d><h>14:06</h><w>abdullahibra</w>why can&apos;t i do this?
(run* [q1 q2] (= q1 (* q2 q2))) ?</z><z id="t1475157997000005" t="abdullahibra i got this: ClassCastException clojure.core.logic.LVar cannot be cast to java.lang.Number clojure.lang.Numbers.multiply (Numbers.java:148)"><y>#</y><d>2016-09-29</d><h>14:06</h><w>abdullahibra</w>i got this: 
ClassCastException clojure.core.logic.LVar cannot be cast to java.lang.Number  clojure.lang.Numbers.multiply (Numbers.java:148)</z><z id="t1475158043000006" t="abdullahibra user=&gt; (run* [q1] (== q1 1)) (1)"><y>#</y><d>2016-09-29</d><h>14:07</h><w>abdullahibra</w>user=&gt; (run* [q1] (== q1 1))
(1)</z><z id="t1475158086000007" t="abdullahibra user=&gt; (run* [q1 q2] (= q1 q2 1)) ClassCastException java.lang.Boolean cannot be cast to clojure.lang.IFn clojure.core.logic.Substitutions (logic.clj:425)"><y>#</y><d>2016-09-29</d><h>14:08</h><w>abdullahibra</w>user=&gt; (run* [q1 q2] (= q1 q2 1))
ClassCastException java.lang.Boolean cannot be cast to clojure.lang.IFn  clojure.core.logic.Substitutions (logic.clj:425)</z><z id="t1475158175000008" t="abdullahibra oh == is unification which is different"><y>#</y><d>2016-09-29</d><h>14:09</h><w>abdullahibra</w>oh == is unification which is different</z><z id="t1475158218000009" t="abdullahibra (run* [q1 q2] (== [3 q1] [q2 2])) ([2 3])"><y>#</y><d>2016-09-29</d><h>14:10</h><w>abdullahibra</w>(run* [q1 q2] (== [3 q1] [q2 2]))
([2 3])</z><z id="t1475158228000010" t="abdullahibra got it"><y>#</y><d>2016-09-29</d><h>14:10</h><w>abdullahibra</w>got it</z><z id="t1476828184000013" t="atroche hi everyone, i’m using core.logic to help me implement http://mason.gmu.edu/~rhanson/equatalk.html"><y>#</y><d>2016-10-18</d><h>22:03</h><w>atroche</w>hi everyone, i’m using core.logic to help me implement <a href="http://mason.gmu.edu/~rhanson/equatalk.html" target="_blank">http://mason.gmu.edu/~rhanson/equatalk.html</a></z><z id="t1476828223000017" t="atroche my problem is that i want the additional constraint that the numbers should form a roughly normal distribution"><y>#</y><d>2016-10-18</d><h>22:03</h><w>atroche</w>my problem is that i want the additional constraint that the numbers should form a roughly normal distribution</z><z id="t1476828260000018" t="atroche not sure if that gist link above is coming through right, but core.logic part starts at line 46"><y>#</y><d>2016-10-18</d><h>22:04</h><w>atroche</w>not sure if that gist link above is coming through right, but core.logic part starts at line 46</z><z id="t1476828290000019" t="atroche is there a way to do that with core.logic?"><y>#</y><d>2016-10-18</d><h>22:04</h><w>atroche</w>is there a way to do that with core.logic?</z><z id="t1476830988000020" t="atroche actually, let me ask another simpler question first: what’s a good way to sort a list of numbers in core.logic, or to find the median of them?"><y>#</y><d>2016-10-18</d><h>22:49</h><w>atroche</w>actually, let me ask another simpler question first: what’s a good way to sort a list of numbers in core.logic, or to find the median of them?</z><z id="t1476831183000021" t="hiredman you would have to express it as relations"><y>#</y><d>2016-10-18</d><h>22:53</h><w>hiredman</w>you would have to express it as relations</z><z id="t1476831226000022" t="hiredman each element in list X is one of the elements in list Y"><y>#</y><d>2016-10-18</d><h>22:53</h><w>hiredman</w>each element in list X is one of the elements in list Y</z><z id="t1476831288000023" t="hiredman the first element in list X is less than the second, etc"><y>#</y><d>2016-10-18</d><h>22:54</h><w>hiredman</w>the first element in list X is less than the second, etc</z><z id="t1476831432000024" t="hiredman I am sure it can be done, but I am not sure I would do it"><y>#</y><d>2016-10-18</d><h>22:57</h><w>hiredman</w>I am sure it can be done, but I am not sure I would do it</z><z id="t1476831480000025" t="hiredman the logic stuff is sort of a combination of generators that generate possible matches and filters that reject things that don&apos;t match"><y>#</y><d>2016-10-18</d><h>22:58</h><w>hiredman</w>the logic stuff is sort of a combination of generators that generate possible matches and filters that reject things that don&apos;t match</z><z id="t1476831518000026" t="hiredman so you&apos;ll end up generating all permutations of Y and rejecting the ones where your sorted relation doesn&apos;t hold"><y>#</y><d>2016-10-18</d><h>22:58</h><w>hiredman</w>so you&apos;ll end up generating all permutations of Y and rejecting the ones where your sorted relation doesn&apos;t hold</z><z id="t1476831567000027" t="atroche when you say you’re not sure you would do it, is it because of performance reasons?"><y>#</y><d>2016-10-18</d><h>22:59</h><w>atroche</w>when you say you’re not sure you would do it, is it because of performance reasons?</z><z id="t1476831666000028" t="hiredman it just seems like a mismatch between sorting and relational programming"><y>#</y><d>2016-10-18</d><h>23:01</h><w>hiredman</w>it just seems like a mismatch between sorting and relational programming</z><z id="t1476831683000029" t="hiredman maybe there is a paper some way with some cool prolog quicksort or something"><y>#</y><d>2016-10-18</d><h>23:01</h><w>hiredman</w>maybe there is a paper some way with some cool prolog quicksort or something</z><z id="t1476831731000030" t="hiredman me saying it seems like a mismatch, this guy saying it is beautiful"><y>#</y><d>2016-10-18</d><h>23:02</h><w>hiredman</w>me saying it seems like a mismatch, this guy saying it is beautiful</z><z id="t1476831732000031" t="hiredman https://www.cp.eng.chula.ac.th/~piak/teaching/dsys/2004/quick-prolog.htm"><y>#</y><d>2016-10-18</d><h>23:02</h><w>hiredman</w><a href="https://www.cp.eng.chula.ac.th/~piak/teaching/dsys/2004/quick-prolog.htm" target="_blank">https://www.cp.eng.chula.ac.th/~piak/teaching/dsys/2004/quick-prolog.htm</a></z><z id="t1476831841000032" t="atroche aha: https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic/bench.clj#L395-L396"><y>#</y><d>2016-10-18</d><h>23:04</h><w>atroche</w>aha: <a href="https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic/bench.clj#L395-L396" target="_blank">https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic/bench.clj#L395-L396</a></z><z id="t1476832284000034" t="atroche can’t say i understand how it works or even how to use it yet"><y>#</y><d>2016-10-18</d><h>23:11</h><w>atroche</w>can’t say i understand how it works or even how to use it yet</z><z id="t1476832289000035" t="atroche do you, @hiredman ?"><y>#</y><d>2016-10-18</d><h>23:11</h><w>atroche</w>do you, @hiredman ?</z><z id="t1476832354000036" t="atroche e.g. why does qsorto there have [l r r0] ?"><y>#</y><d>2016-10-18</d><h>23:12</h><w>atroche</w>e.g. why does qsorto there have [l r r0] ?</z><z id="t1476832616000037" t="hiredman I believe the [l r r0] line is for tabling"><y>#</y><d>2016-10-18</d><h>23:16</h><w>hiredman</w>I believe the [l r r0] line is for tabling</z><z id="t1476832666000038" t="hiredman tabling is some kind of optimization sort of like memoizing"><y>#</y><d>2016-10-18</d><h>23:17</h><w>hiredman</w>tabling is some kind of optimization sort of like memoizing</z><z id="t1476832677000039" t="atroche okay, cool"><y>#</y><d>2016-10-18</d><h>23:17</h><w>atroche</w>okay, cool</z><z id="t1476832693000040" t="atroche so if i’m looking for a constraint that says that the list is sorted"><y>#</y><d>2016-10-18</d><h>23:18</h><w>atroche</w>so if i’m looking for a constraint that says that the list is sorted</z><z id="t1476832702000041" t="hiredman which is not say I understand qsorto"><y>#</y><d>2016-10-18</d><h>23:18</h><w>hiredman</w>which is not say I understand qsorto</z><z id="t1476832708000042" t="atroche and i have the qsorto as written there…"><y>#</y><d>2016-10-18</d><h>23:18</h><w>atroche</w>and i have the qsorto as written there…</z><z id="t1476833774000043" t="atroche i clearly have more reading to do 🙂"><y>#</y><d>2016-10-18</d><h>23:36</h><w>atroche</w>i clearly have more reading to do <b>🙂</b></z><z id="t1476899737000077" t="johanatan Hi, is there a way to AND a dynamically generated list of constraints? [Cannot apply all or run as they are macros]"><y>#</y><d>2016-10-19</d><h>17:55</h><w>johanatan</w>Hi, is there a way to AND a dynamically generated list of constraints? [Cannot apply <code>all</code> or <code>run</code> as they are macros]</z><z id="t1476899794000078" t="exupero (every? true? coll)"><y>#</y><d>2016-10-19</d><h>17:56</h><w>exupero</w><code>(every? true? coll)</code></z><z id="t1476899815000079" t="johanatan Is true? part of core.logic?"><y>#</y><d>2016-10-19</d><h>17:56</h><w>johanatan</w>Is <code>true?</code> part of core.logic?</z><z id="t1476899840000080" t="exupero Sorry, didn’t notice the channel. Thinking in clojure.core."><y>#</y><d>2016-10-19</d><h>17:57</h><w>exupero</w>Sorry, didn’t notice the channel. Thinking in clojure.core.</z><z id="t1476899843000081" t="johanatan Can a boolean be converted to a goal?"><y>#</y><d>2016-10-19</d><h>17:57</h><w>johanatan</w>Can a <code>boolean</code> be converted to a goal?</z><z id="t1476899846000082" t="johanatan Ahh 🙂"><y>#</y><d>2016-10-19</d><h>17:57</h><w>johanatan</w>Ahh <b>🙂</b></z><z id="t1476900096000083" t="johanatan Answer from dnolen: dnolen [11:00 AM] @johanatan yes, you can reduce your goals with bind"><y>#</y><d>2016-10-19</d><h>18:01</h><w>johanatan</w>Answer from dnolen: 
dnolen [11:00 AM]  
@johanatan yes, you can reduce your goals with bind</z><z id="t1476931663000096" t="johanatan actually bind is not working for constraints created with fd/dom e.g."><y>#</y><d>2016-10-20</d><h>02:47</h><w>johanatan</w>actually <code>bind</code> is not working for constraints created with <code>fd/dom</code> e.g.</z><z id="t1476931678000097" t="johanatan anybody else have any ideas?"><y>#</y><d>2016-10-20</d><h>02:47</h><w>johanatan</w>anybody else have any ideas?</z><z id="t1476932531000099" t="johanatan This is the result in its basest form: slipstream.core=&gt; (run* [q] (clojure.core.logic.protocols/bind s# (fd/dom q (fd/interval 0 10)))) ArityException Wrong number of args (1) passed to: logic/eval1901/fn--1902/-inc--1903 clojure.lang.AFn.throwArity (AFn.java:429) "><y>#</y><d>2016-10-20</d><h>03:02</h><w>johanatan</w>This is the result in its basest form:

<pre>slipstream.core=&gt; (run* [q] (clojure.core.logic.protocols/bind s# (fd/dom q (fd/interval 0 10))))

ArityException Wrong number of args (1) passed to: logic/eval1901/fn--1902/-inc--1903  clojure.lang.AFn.throwArity (AFn.java:429)
</pre></z><z id="t1476936173000101" t="johanatan This works as expected: slipstream.core=&gt; (run* [q] (fd/dom q (fd/interval 0 10))) (0 1 2 3 4 5 6 7 8 9 10) slipstream.core=&gt; "><y>#</y><d>2016-10-20</d><h>04:02</h><w>johanatan</w>This works as expected:
<pre>slipstream.core=&gt; (run* [q] (fd/dom q (fd/interval 0 10)))
(0 1 2 3 4 5 6 7 8 9 10)
slipstream.core=&gt; 
</pre></z><z id="t1476936230000102" t="johanatan @dnolen ^"><y>#</y><d>2016-10-20</d><h>04:03</h><w>johanatan</w>@dnolen  ^</z><z id="t1476937833000103" t="johanatan doh!"><y>#</y><d>2016-10-20</d><h>04:30</h><w>johanatan</w>doh!</z><z id="t1476937845000104" t="johanatan Looks like: (everyg identity goals) works!"><y>#</y><d>2016-10-20</d><h>04:30</h><w>johanatan</w>Looks like:
<code>(everyg identity goals)</code> works!</z><z id="t1479411560000371" t="josh.freckleton I would expect the first program to return (5,6)"><y>#</y><d>2016-11-17</d><h>19:39</h><w>josh.freckleton</w>I would expect the first program to return <code>(5,6)</code></z><z id="t1479412399000372" t="hiredman being an embedded dsl, core.logic sort of interleaves regular clojure with logic programming"><y>#</y><d>2016-11-17</d><h>19:53</h><w>hiredman</w>being an embedded dsl, core.logic sort of interleaves regular clojure with logic programming</z><z id="t1479412412000373" t="hiredman what fresh does is bind a clojure variable to a logic variable"><y>#</y><d>2016-11-17</d><h>19:53</h><w>hiredman</w>what fresh does is bind a clojure variable to a logic variable</z><z id="t1479412435000374" t="hiredman so you can imagine it as something like (let [r (fresh-logic-var)] ...)"><y>#</y><d>2016-11-17</d><h>19:53</h><w>hiredman</w>so you can imagine it as something like (let [r (fresh-logic-var)] ...)</z><z id="t1479412526000375" t="hiredman so given a clojure program, where the local r is bound to a logic variable, is there some expression like (... x ...) that can result in r being bound to something else?"><y>#</y><d>2016-11-17</d><h>19:55</h><w>hiredman</w>so given a clojure program, where the local <code>r</code> is bound to a logic variable, is there some expression like <code>(... x ...)</code> that can result in <code>r</code> being bound to something else?</z><z id="t1479412587000376" t="hiredman a logic program doesn&apos;t change the value of bound clojure locals, it constrains the value of the logic variables bound by locals"><y>#</y><d>2016-11-17</d><h>19:56</h><w>hiredman</w>a logic program doesn&apos;t change the value of bound clojure locals, it constrains the value of the logic variables bound by locals</z><z id="t1479412689000377" t="hiredman you can use project to look up the value of a logic variable (an LVar) but that is not relational"><y>#</y><d>2016-11-17</d><h>19:58</h><w>hiredman</w>you can use project to look up the value of a logic variable (an LVar) but that is not relational</z><z id="t1479412775000378" t="hiredman what you should do is something like (compose-goals-with-or (for [constraint [fd/+ fd/*]] (constraint 2 3 q)))"><y>#</y><d>2016-11-17</d><h>19:59</h><w>hiredman</w>what you should do is something like <code>(compose-goals-with-or (for [constraint [fd/+ fd/*]] (constraint 2 3 q)))</code></z><z id="t1479412789000379" t="hiredman but I don&apos;t recall what compose-goals-with-or would be"><y>#</y><d>2016-11-17</d><h>19:59</h><w>hiredman</w>but I don&apos;t recall what compose-goals-with-or would be</z><z id="t1479412880000380" t="hiredman https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic.clj#L1185-L1198"><y>#</y><d>2016-11-17</d><h>20:01</h><w>hiredman</w><a href="https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic.clj#L1185-L1198" target="_blank">https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic.clj#L1185-L1198</a></z><z id="t1479412906000382" t="josh.freckleton @hiredman thanks! this is exactly what I needed!"><y>#</y><d>2016-11-17</d><h>20:01</h><w>josh.freckleton</w>@hiredman thanks! this is exactly what I needed!</z><z id="t1479413124000383" t="josh.freckleton I&apos;m hoping to make sense of some of these less obvious logic functions and I&apos;ll write up some posts to hopefully make logic easier to get running with!"><y>#</y><d>2016-11-17</d><h>20:05</h><w>josh.freckleton</w>I&apos;m hoping to make sense of some of these less obvious <code>logic</code> functions and I&apos;ll write up some posts to hopefully make <code>logic</code> easier to get running with!</z><z id="t1480101015000428" t="josh.freckleton how can I generate, say, an infinite list of all combinations of [:a :b :c] , eg, [[:a], [:a :b], [:a :b :c], [:a :b :c :a], ...]"><y>#</y><d>2016-11-25</d><h>19:10</h><w>josh.freckleton</w>how can I generate, say, an infinite list of all combinations of <code>[:a :b :c]</code>, eg, <code>[[:a], [:a :b], [:a :b :c], [:a :b :c :a], ...]</code></z><z id="t1480101023000429" t="josh.freckleton (using core.logic)"><y>#</y><d>2016-11-25</d><h>19:10</h><w>josh.freckleton</w>(using core.logic)</z><z id="t1480946329000016" t="mac Does anyone know of extensions to core.logic for working with dates, so one could do something like: (run 1 [q] (day-after q (date-time 1986 10 14))) =&gt;(#&lt;DateTime 1986-10-15T00:00:00.000Z&gt;)"><y>#</y><d>2016-12-05</d><h>13:58</h><w>mac</w>Does anyone know of extensions to core.logic for working with dates, so one could do something like: <code>(run 1 [q] (day-after q (date-time 1986 10 14))) =&gt;(#&lt;DateTime 1986-10-15T00:00:00.000Z&gt;)</code></z><z id="t1481706169000074" t="mattiasw What is wrong with the proposed solution for nonmembero in https://stackoverflow.com/questions/16370327/why-does-my-clojure-core-logic-nonmember-function-return-two-values/41138478#41138478 ? And why does my non-defne work as expected? Is there a problem with defne?"><y>#</y><d>2016-12-14</d><h>09:02</h><w>mattiasw</w>What is wrong with the proposed solution for nonmembero in <a href="https://stackoverflow.com/questions/16370327/why-does-my-clojure-core-logic-nonmember-function-return-two-values/41138478#41138478" target="_blank">https://stackoverflow.com/questions/16370327/why-does-my-clojure-core-logic-nonmember-function-return-two-values/41138478#41138478</a> ? And why does my non-defne work as expected? Is there a problem with defne?</z><z id="t1485058016000244" t="nathansmutz Is there any way to emulate set operations in core.logic? It looks like everyg wont work on an LCons so you can&apos;t make relational goals like: (defn subseto [sub super] (everyg* #(membero % super) sub))"><y>#</y><d>2017-01-22</d><h>04:06</h><w>nathansmutz</w>Is there any way to emulate set operations in core.logic?  
It looks like everyg wont work on an LCons so you can&apos;t make relational goals like:
(defn subseto [sub super]
  (everyg* #(membero % super) sub))</z><z id="t1485076780000249" t="nathansmutz On researching, here&apos;s what I found so far. I&apos;ll post here as I make tests: https://gist.github.com/martintrojer/3792630 (defne subseto &quot;is s1 is a subset of s2?&quot; [s1 s2] ([() _]) ([[x . xs] _] (membero x s2) (subseto xs s2))) (defne any-membero &quot;any member of s1 is a member of s2?&quot; [s1 s2] ([[x . xs] _] (membero x s2)) ([[x . xs] _] (any-membero xs s2)))"><y>#</y><d>2017-01-22</d><h>09:19</h><w>nathansmutz</w>On researching, here&apos;s what I found so far.  I&apos;ll post here as I make tests: 

<a href="https://gist.github.com/martintrojer/3792630" target="_blank">https://gist.github.com/martintrojer/3792630</a>
(defne subseto
  &quot;is s1 is a subset of s2?&quot;
  [s1 s2]
  ([() _])
  ([[x . xs] _]
     (membero x s2)
     (subseto xs s2)))
 

(defne any-membero
  &quot;any member of s1 is a member of s2?&quot;
  [s1 s2]
  ([[x . xs] _]
     (membero x s2))
  ([[x . xs] _]
     (any-membero xs s2)))</z><z id="t1485112451000252" t="nathansmutz This works: (run 5 [q] (distincto q) (subseto q [1 2])) Doing a &quot;(run 6 ...&quot; with the above hangs. I&apos;m off to learn more kanren-foo. Maybe something with walk can make this halt. I hope its a solvable problem. "><y>#</y><d>2017-01-22</d><h>19:14</h><w>nathansmutz</w>This works:
(run 5 [q]
  (distincto q)
  (subseto q [1 2]))

Doing a &quot;(run 6 ...&quot; with the above hangs.  
I&apos;m off to learn more kanren-foo.  Maybe something with walk can make this halt.
I hope its a solvable problem.

</z><z id="t1486654973000309" t="gamecubate About to embark on the development of a web-front-end (CLJS + Reagent) to an expert system shell. Is core.logic a good choice for the expert system?"><y>#</y><d>2017-02-09</d><h>15:42</h><w>gamecubate</w>About to embark on the development of a web-front-end (CLJS + Reagent) to an expert system shell. Is core.logic a good choice for the expert system?</z><z id="t1486865121000316" t="devn @gamecubate: saw that you were messing with Clara "><y>#</y><d>2017-02-12</d><h>02:05</h><w>devn</w>@gamecubate: saw that you were messing with Clara </z><z id="t1486865130000317" t="devn Will be interested to hear where you wind up "><y>#</y><d>2017-02-12</d><h>02:05</h><w>devn</w>Will be interested to hear where you wind up </z><z id="t1486939320000321" t="gamecubate @devn There’s a lot to learn and figure out at this stage. Plus I have this nagging suspicion that a self-hosted clojurescript front end shell might not be able to support the adding of rules to a session db. First need to learn quite a bit more about core.logic and then Clara. This will take weeks… I will share examples once significant progress is made."><y>#</y><d>2017-02-12</d><h>22:42</h><w>gamecubate</w>@devn There’s a lot to learn and figure out at this stage. Plus I have this nagging suspicion that a self-hosted clojurescript front end shell might not be able to support the adding of rules to a session db. First need to learn quite a bit more about core.logic and then Clara. This will take weeks… I will share examples once significant progress is made.</z><z id="t1487224550000333" t="ddrbt Hey people, I&apos;d appreciate some help here: I&apos;m trying to build up a pldb/db which starts with some precedence relations between tasks and fills in the blanks. How can I write a relational function that identifies which tasks do not have a precedence relation with every other task? Here&apos;s some example code: [precedence-db]( https://gist.github.com/daveduthie/f91dc1c9587daacbba50f6b656bb8cab )"><y>#</y><d>2017-02-16</d><h>05:55</h><w>ddrbt</w>Hey people, I&apos;d appreciate some help here:

I&apos;m trying to build up a <code>pldb/db</code> which starts with some precedence relations between tasks and fills in the blanks. How can I write a relational function that identifies which tasks do not have a precedence relation with every other task?

Here&apos;s some example code: [precedence-db](<a href="https://gist.github.com/daveduthie/f91dc1c9587daacbba50f6b656bb8cab" target="_blank">https://gist.github.com/daveduthie/f91dc1c9587daacbba50f6b656bb8cab</a>)</z><z id="t1487256352000343" t="ddrbt Anyone?"><y>#</y><d>2017-02-16</d><h>14:45</h><w>ddrbt</w>Anyone?</z><z id="t1487277551000349" t="hiredman you need to use, uh, there should be some negation of a goal operator, not sure what it is"><y>#</y><d>2017-02-16</d><h>20:39</h><w>hiredman</w>you need to use, uh, there should be some negation of a goal operator, not sure what it is</z><z id="t1487277569000350" t="hiredman instead of a disequality constraint"><y>#</y><d>2017-02-16</d><h>20:39</h><w>hiredman</w>instead of a disequality constraint</z><z id="t1487277631000351" t="hiredman so you have a search for the join of tasks of precedences, and then search for the tasks where that search doesn&apos;t have any results"><y>#</y><d>2017-02-16</d><h>20:40</h><w>hiredman</w>so you have a search for the join of tasks of precedences, and then search for the tasks where that search doesn&apos;t have any results</z><z id="t1487294805000357" t="ddrbt @hiredman, thanks, I’ll check it out"><y>#</y><d>2017-02-17</d><h>01:26</h><w>ddrbt</w>@hiredman, thanks, I’ll check it out</z><z id="t1487295074000359" t="ddrbt This almost works. (Stepping through with the debugger, it works. Running ordinarily, I get (4 3 2 1))"><y>#</y><d>2017-02-17</d><h>01:31</h><w>ddrbt</w>This almost works. (Stepping through with the debugger, it works. Running ordinarily, I get (4 3 2 1))</z><z id="t1487295101000360" t="ddrbt Is it a bad idea to nest run statements?"><y>#</y><d>2017-02-17</d><h>01:31</h><w>ddrbt</w>Is it a bad idea to nest <code>run</code> statements?</z><z id="t1487491182000423" t="ddrbt I skirted the issue by using :none as the precedence when two tasks have not yet been related to one another."><y>#</y><d>2017-02-19</d><h>07:59</h><w>ddrbt</w>I skirted the issue by using <code>:none</code> as the precedence when two tasks have not yet been related to one another.</z><z id="t1488527832000525" t="kneiva Having a list of integers how would I find the biggest square area that can fit in the columns? With clojure.logic or preferrably with https://github.com/aengelberg/loco . I couldn’t find an example or a tutorial that help me with this kind of problem. Examples: 1234321 321 423 0 0 *** 0 0 0 0***0 ** **0 00***00 **0 **0 = 3 = 2 = 2 "><y>#</y><d>2017-03-03</d><h>07:57</h><w>kneiva</w>Having a list of integers how would I find the biggest square area that can fit in the columns? With clojure.logic or preferrably with <a href="https://github.com/aengelberg/loco" target="_blank">https://github.com/aengelberg/loco</a>. I couldn’t find an example or a tutorial that help me with this kind of problem.

Examples:
<pre>1234321     321     423

   0                0
  ***       0       0 0
 0***0      **      **0
00***00     **0     **0
= 3         = 2     = 2
</pre></z><z id="t1488528163000527" t="hiredman it seems like the kind of think you might be able to find a formula for"><y>#</y><d>2017-03-03</d><h>08:02</h><w>hiredman</w>it seems like the kind of think you might be able to find a formula for</z><z id="t1488528374000528" t="hiredman I think with logic programming or some kind of sat solver you are going to have trouble, because both of those tend to be good answering &quot;does a solution to this exist&quot; and less so at solving &quot;find me the solution with property x&quot;"><y>#</y><d>2017-03-03</d><h>08:06</h><w>hiredman</w>I think with logic programming or some kind of sat solver you are going to have trouble, because both of those tend to be good answering &quot;does a solution to this exist&quot; and less so at solving &quot;find me the solution with property x&quot;</z><z id="t1488529075000529" t="hiredman actually, I think you can put that in terms of does X exist: &quot;Does X exist where X is a number that fits in row 0, and row 0 + X, and X+1 doesn&apos;t fit in row 0 + X + 1&quot;"><y>#</y><d>2017-03-03</d><h>08:17</h><w>hiredman</w>actually, I think you can put that in terms of does X exist: &quot;Does X exist where X is a number that fits in row 0, and row 0 + X, and X+1 doesn&apos;t fit in row 0 + X + 1&quot;</z><z id="t1488529434000531" t="hiredman the biggest result or smallest result, is a constraint relative to all the other answers, which means you have to compute all the other possible answers"><y>#</y><d>2017-03-03</d><h>08:23</h><w>hiredman</w>the biggest result or smallest result, is a constraint relative to all the other answers, which means you have to compute all the other possible answers</z><z id="t1488529593000532" t="kneiva Ok, I think that helps. I’ll ponder on it. Thanks!"><y>#</y><d>2017-03-03</d><h>08:26</h><w>kneiva</w>Ok, I think that helps. I’ll ponder on it. Thanks!</z><z id="t1488901792000535" t="eraserhd Is there any documentation on core.logic&apos;s protocols, or an example of how to extend it for a new, basically opaque type?"><y>#</y><d>2017-03-07</d><h>15:49</h><w>eraserhd</w>Is there any documentation on core.logic&apos;s protocols, or an example of how to extend it for a new, basically opaque type?</z><z id="t1488901852000536" t="eraserhd I&apos;m just using the core.logic unifier in my tests in order to verify that two or three places in the structure have the same value, but I don&apos;t care what that value is."><y>#</y><d>2017-03-07</d><h>15:50</h><w>eraserhd</w>I&apos;m just using the core.logic unifier in my tests in order to verify that two or three places in the structure have the same value, but I don&apos;t care what that value is.</z><z id="t1488901876000537" t="eraserhd Unfortunately, I&apos;ve had to change that value from a string to a Datomic tempid, and that means the unifier breaks."><y>#</y><d>2017-03-07</d><h>15:51</h><w>eraserhd</w>Unfortunately, I&apos;ve had to change that value from a string to a Datomic tempid, and that means the unifier breaks.</z><z id="t1488901907000538" t="eraserhd Because IUninitialized is not implemented on datomic.db.DbId."><y>#</y><d>2017-03-07</d><h>15:51</h><w>eraserhd</w>Because IUninitialized is not implemented on datomic.db.DbId.</z><z id="t1489028644000539" t="ddrbt run* returns a lazy sequence. Would it be possible to put some finite domain constraints in an atom and have the constraints consulted each time I want to realise more of the sequence? Failing this, I&apos;d have to call run* each time I have updated constraints. "><y>#</y><d>2017-03-09</d><h>03:04</h><w>ddrbt</w>run* returns a lazy sequence. Would it be possible to put some finite domain constraints in an atom and have the constraints consulted each time I want to realise more of the sequence? Failing this, I&apos;d have to call run* each time I have updated constraints. </z><z id="t1489028680000540" t="ddrbt (As some background, I&apos;m using data coming out of run* to derive constraints as I go)"><y>#</y><d>2017-03-09</d><h>03:04</h><w>ddrbt</w>(As some background, I&apos;m using data coming out of run* to derive constraints as I go)</z><z id="t1490079648238325" t="tomjack ([... [var _8]] :- (swap [a_10 a_7] _8 a_6) ...) 😞"><y>#</y><d>2017-03-21</d><h>07:00</h><w>tomjack</w><pre>([... [var _8]] :- (swap [a_10 a_7] _8 a_6) ...)
</pre>
<b>😞</b></z><z id="t1494089300771825" t="sandbags I have a problem that I think core.logic might be a fit for. I did some Prolog many moons ago so I&apos;ve a vague familiarity with this stuff and reading the core.logic tutorial I grasp it, at least at a superficial level. Anyone working with it enough that I can describe what I am doing and they can tell me if it seems like a good fit?"><y>#</y><d>2017-05-06</d><h>16:48</h><w>sandbags</w>I have a problem that I think core.logic might be a fit for. I did some Prolog many moons ago so I&apos;ve a vague familiarity with this stuff and reading the core.logic tutorial I grasp it, at least at a superficial level. Anyone working with it enough that I can describe what I am doing and they can tell me if it seems like a good fit?</z><z id="t1494089668797149" t="sandbags Well let me describe it a little, if anyone has a view I can go into more details. The high level problem is to create acronyms (yes this is the stupid side project gone mad) based on a set of rules. An example rule could be must include one of &quot;Strategy&quot; or &quot;Plan&quot; so the word must have an s or a p . Another rule could be must include one of &quot;Technology&quot; or &quot;Digital&quot; ergo a t d or d must be present. Another type of rule can include either &quot;Operations&quot; or &quot;Process&quot; means that an o or p could appear if necessary to match a word. So you have a set of rules that govern how letters can be used. Then I smash a dictionary through the rules to create a series of acronyms. Given the rules described above you might have the word sot match as Strategy Operations Technology (this example would use both of the the required rules and the optional rule) and so on. st , ts , tos , tps , and spt are also legal solutions but, since they are not dictionary words, they would never come up. The approach I have taken most recently ended up labelling each letter of the word under test with each of the rules that it can possibly match. It&apos;s not hard then to come up with one solution that uses all required labelings (and optional ones if required). But to get all legal solutions for a given word felt like a backtracking type problem and, hence, my interest in core.logic ."><y>#</y><d>2017-05-06</d><h>16:54</h><w>sandbags</w>Well let me describe it a little, if anyone has a view I can go into more details. The high level problem is to create acronyms (yes this is the stupid side project gone mad) based on a set of rules. An example rule could be <code>must include one of &quot;Strategy&quot; or &quot;Plan&quot;</code> so the word must have an <code>s</code> or a <code>p</code>. Another rule could be <code>must include one of &quot;Technology&quot; or &quot;Digital&quot;</code> ergo a <code>t</code>d or <code>d</code> must be present. Another type of rule <code>can include either &quot;Operations&quot; or &quot;Process&quot;</code> means that an <code>o</code> or <code>p</code> could appear if necessary to match a word. So you have a set of rules that govern how letters can be used. Then I smash a dictionary through the rules to create a series of acronyms. Given the rules described above you might have the word <code>sot</code> match as <code>Strategy Operations Technology</code> (this example would use both of the the required rules and the optional rule) and so on. <code>st</code>, <code>ts</code>, <code>tos</code>, <code>tps</code>, and <code>spt</code> are also legal solutions but, since they are not dictionary words, they would never come up. The approach I have taken most recently ended up labelling each letter of the word under test with each of the rules that it can possibly match. It&apos;s not hard then to come up with one solution that uses all required labelings (and optional ones if required). But to get all legal solutions for a given word felt like a backtracking type problem and, hence, my interest in <code>core.logic</code>.</z><z id="t1496813038630112" t="fabrao Hello all, I have something like this [:A :B] [:A :C] [:B :C] how can I get the result [:A [:B :C]], is that possible with core.logic?"><y>#</y><d>2017-06-07</d><h>05:23</h><w>fabrao</w>Hello all, I have something like this <code>[:A :B] [:A :C] [:B :C]</code> how can I get the result [:A [:B :C]], is that possible with core.logic?</z><z id="t1496849231882086" t="norman What exactly are you asking? Are you asking how to transform the results of your core.logic query? Or are you asking how to rewrite your core.logic query? (in which we’d need a query)"><y>#</y><d>2017-06-07</d><h>15:27</h><w>norman</w>What exactly are you asking? Are you asking how to transform the results of your core.logic query?  Or are you asking how to rewrite your core.logic query? (in which we’d need a query)</z><z id="t1496850290335328" t="norman If it’s the former, this might get you started:"><y>#</y><d>2017-06-07</d><h>15:44</h><w>norman</w>If it’s the former, this might get you started:</z><z id="t1496850290335571" t="norman user&gt; (reduce (fn [m [k v]] (update-in m [k] #(conj (or % #{}) v))) {} [[:A :B] [:A :C] [:B :C]]) {:A #{:B :C}, :B #{:C}}"><y>#</y><d>2017-06-07</d><h>15:44</h><w>norman</w>user&gt; (reduce (fn [m [k v]] (update-in m [k] #(conj (or % #{}) v))) {} [[:A :B] [:A :C] [:B :C]])
{:A #{:B :C}, :B #{:C}}</z><z id="t1496850310344053" t="norman No time to make that cleaner, but it’s something to work from"><y>#</y><d>2017-06-07</d><h>15:45</h><w>norman</w>No time to make that cleaner, but it’s something to work from</z><z id="t1496850389378253" t="norman user&gt; (for [[k v] *1] [k (vec v)])"><y>#</y><d>2017-06-07</d><h>15:46</h><w>norman</w>user&gt; (for [[k v] *1]
        [k (vec v)])</z><z id="t1496850396381236" t="norman ([:A [:B :C]] [:B [:C]])"><y>#</y><d>2017-06-07</d><h>15:46</h><w>norman</w>([:A [:B :C]] [:B [:C]])</z><z id="t1496850404384544" t="norman if you need to get it back to vectors, I guess"><y>#</y><d>2017-06-07</d><h>15:46</h><w>norman</w>if you need to get it back to vectors, I guess</z><z id="t1496851843994436" t="newres Hi, is there a way to use core.logic as a kind of backward chaining rule engine? I kind of figured out that I can write a goal to encapsulate the singe execution of a rule, but how could I express that a portion of goal could be used multiple times to derive a conclusion?"><y>#</y><d>2017-06-07</d><h>16:10</h><w>newres</w>Hi, is there a way to use core.logic as a kind of backward chaining rule engine? I kind of figured out that I can write a goal to encapsulate the singe execution of a rule, but how could I express that a portion of goal could be used multiple times to derive a conclusion?</z><z id="t1496871821209325" t="fabrao @norman well, I´m trying to use it like I used to use in Prolog as I remember repetition ([X|T]) :- repetition(X,A), repetition(X,B), A != B. I don´t know if it´s correct"><y>#</y><d>2017-06-07</d><h>21:43</h><w>fabrao</w>@norman well, I´m trying to use it like I used to use in Prolog as I remember
<pre>repetition ([X|T]) :- repetition(X,A), repetition(X,B), A != B.
</pre> I don´t know if it´s correct</z><z id="t1496871878224934" t="fabrao but that´s the idea"><y>#</y><d>2017-06-07</d><h>21:44</h><w>fabrao</w>but that´s the idea</z><z id="t1496871953245052" t="norman Sorry - i don’t understand what you want."><y>#</y><d>2017-06-07</d><h>21:45</h><w>norman</w>Sorry - i don’t understand what you want.</z><z id="t1496872066275478" t="fabrao 🙂 ok, I´m trying to use core.logic instead of using something like http://www.clara-rules.org/"><y>#</y><d>2017-06-07</d><h>21:47</h><w>fabrao</w><b>🙂</b> ok, I´m trying to use core.logic instead of using something like <a href="http://www.clara-rules.org/" target="_blank">http://www.clara-rules.org/</a></z><z id="t1499440754596929" t="mrchance Hi! Can someone give me a hint on how to add error handling to my logic programs? I&apos;d like to receive a little more information than () when my program fails to produce a result 🙂"><y>#</y><d>2017-07-07</d><h>15:19</h><w>mrchance</w>Hi! Can someone give me a hint on how to add error handling to my logic programs? I&apos;d like to receive a little more information than <code>()</code> when my program fails to produce a result <b>🙂</b></z><z id="t1499440848652051" t="mrchance I was thinking about a fall through case that unifies an error parameter to something meaningful, but I am not sure if that is a good idea or even how to do it well"><y>#</y><d>2017-07-07</d><h>15:20</h><w>mrchance</w>I was thinking about a fall through case that unifies an error parameter to something meaningful, but I am not sure if that is a good idea or even how to do it well</z><z id="t1501114591924242" t="swizzard hi all, i’m working my way through the reasoned schemer with core.logic; i’ve read https://github.com/clojure/core.logic/wiki/Differences-from-The-Reasoned-Schemer , but i’m still a little confused?"><y>#</y><d>2017-07-27</d><h>00:16</h><w>swizzard</w>hi all, i’m working my way through the reasoned schemer with core.logic; i’ve read <a href="https://github.com/clojure/core.logic/wiki/Differences-from-The-Reasoned-Schemer" target="_blank">https://github.com/clojure/core.logic/wiki/Differences-from-The-Reasoned-Schemer</a>, but i’m still a little confused?</z><z id="t1501114705949069" t="swizzard specifically by the use of the non-prefixed cond , e.g.:"><y>#</y><d>2017-07-27</d><h>00:18</h><w>swizzard</w>specifically by the use of the non-prefixed <code>cond</code>, e.g.:</z><z id="t1501114804971158" t="swizzard also, i’m not sure how to get conde to properly evaluate:"><y>#</y><d>2017-07-27</d><h>00:20</h><w>swizzard</w>also, i’m not sure how to get <code>conde</code> to properly evaluate:</z><z id="t1501116811397477" t="norman (run* [q] (conde [fail succeed] [succeed fail]))"><y>#</y><d>2017-07-27</d><h>00:53</h><w>norman</w>(run* [q]
                   (conde
                    [fail succeed]
                    [succeed fail]))</z><z id="t1501118083668456" t="norman @swizzard The book examples aren’t really great in isolation. I’d have to check my copy of the book when I get home to see the context of this."><y>#</y><d>2017-07-27</d><h>01:14</h><w>norman</w>@swizzard The book examples aren’t really great in isolation. I’d have to check my copy of the book when I get home to see the context of this.</z><z id="t1501118107673297" t="norman But the above is how to run an equivalent core.logic conde"><y>#</y><d>2017-07-27</d><h>01:15</h><w>norman</w>But the above is how to run an equivalent core.logic conde</z><z id="t1501172903402124" t="swizzard when/why would you use lcons instead of just list ?"><y>#</y><d>2017-07-27</d><h>16:28</h><w>swizzard</w>when/why would you use <code>lcons</code> instead of just <code>list</code>?</z><z id="t1501174315204848" t="norman I don’t think I’ve ever used lcons"><y>#</y><d>2017-07-27</d><h>16:51</h><w>norman</w>I don’t think I’ve ever used lcons</z><z id="t1501174330213106" t="norman Probably you’d just use it when trying to do examples from minkanren"><y>#</y><d>2017-07-27</d><h>16:52</h><w>norman</w>Probably you’d just use it when trying to do examples from minkanren</z><z id="t1501174745453235" t="swizzard @norman that’s kind of what i assumed, but wanted to be sure, thanks 🙂"><y>#</y><d>2017-07-27</d><h>16:59</h><w>swizzard</w>@norman that’s kind of what i assumed, but wanted to be sure, thanks <b>🙂</b></z><z id="t1501174836508242" t="norman We (ThreatGRID) have probably one of the only production apps with a signficant core.logic component, so I’m heavily biased towards the practical things"><y>#</y><d>2017-07-27</d><h>17:00</h><w>norman</w>We (ThreatGRID) have probably one of the only production apps with a signficant core.logic component, so I’m heavily biased towards the practical things</z><z id="t1501174886538134" t="swizzard i hope you don’t get annoyed by me asking a bunch more dumb questions, because i’m only on chapter 2 of TRS"><y>#</y><d>2017-07-27</d><h>17:01</h><w>swizzard</w>i hope you don’t get annoyed by me asking a bunch more dumb questions, because i’m only on chapter 2 of TRS</z><z id="t1501174900546336" t="norman That’s 2 more chapters than most 🙂"><y>#</y><d>2017-07-27</d><h>17:01</h><w>norman</w>That’s 2 more chapters than most <b>🙂</b></z><z id="t1501174984596312" t="swizzard i have vague dreams of using CLP and maybe rete to build an “is my rpg breakable?” tester"><y>#</y><d>2017-07-27</d><h>17:03</h><w>swizzard</w>i have vague dreams of using CLP and maybe rete to build an “is my rpg breakable?” tester</z><z id="t1501174994602624" t="swizzard so i figure i need to actually understand logic programming first"><y>#</y><d>2017-07-27</d><h>17:03</h><w>swizzard</w>so i figure i need to actually understand logic programming first</z><z id="t1501452757994240" t="swizzard is there a good tutorial/documentation of core.logic-specific stuff? i’m probably just kind of dumb but i don’t really understand how e.g. defne works"><y>#</y><d>2017-07-30</d><h>22:12</h><w>swizzard</w>is there a good tutorial/documentation of core.logic-specific stuff? i’m probably just kind of dumb but i don’t really understand how e.g. <code>defne</code> works</z><z id="t1501452798997336" t="swizzard i’ve gone through the wiki a few times but it’s a little too high-level and scattershot for my taste"><y>#</y><d>2017-07-30</d><h>22:13</h><w>swizzard</w>i’ve gone through the wiki a few times but it’s a little too high-level and scattershot for my taste</z><z id="t1501452852001144" t="swizzard i’m also a bit dismayed about how old most of the projects on github that actually use c.l are, but that’s a separate issue"><y>#</y><d>2017-07-30</d><h>22:14</h><w>swizzard</w>i’m also a bit dismayed about how old most of the projects on github that actually use c.l are, but that’s a separate issue</z><z id="t1501516951879863" t="norman Not really. Many of the examples out there outdated, and few of them are written by people who have a strong understanding of core.logic. I don’t see much new being written, since for the most part core.logic has been abandoned. Being a core.* project with JIRA and the whole clojure process behind it means it’s unlikely that it will get significant contributions"><y>#</y><d>2017-07-31</d><h>16:02</h><w>norman</w>Not really. Many of the examples out there outdated, and few of them are written by people who have a strong understanding of core.logic.  I don’t see much new being written, since for the most part core.logic has been abandoned. Being a core.* project with JIRA and the whole clojure process behind it means it’s unlikely that it will get significant contributions</z><z id="t1501520522929785" t="mrchance @swizzard I am currently learning it too, maybe we can discover stuff together ;) defne, as I understood it, is just a short form for defn + matche "><y>#</y><d>2017-07-31</d><h>17:02</h><w>mrchance</w>@swizzard I am currently learning it too, maybe we can discover stuff together ;) defne, as I understood it, is just a short form for defn + matche </z><z id="t1501520554948755" t="swizzard @norman why has it been abandoned? is there a better alternative?"><y>#</y><d>2017-07-31</d><h>17:02</h><w>swizzard</w>@norman why has it been abandoned? is there a better alternative?</z><z id="t1501520561952870" t="norman Nope"><y>#</y><d>2017-07-31</d><h>17:02</h><w>norman</w>Nope</z><z id="t1501520575961353" t="norman You could consider it basically done"><y>#</y><d>2017-07-31</d><h>17:02</h><w>norman</w>You could consider it basically done</z><z id="t1501520581964213" t="swizzard ok"><y>#</y><d>2017-07-31</d><h>17:03</h><w>swizzard</w>ok</z><z id="t1501520587967659" t="norman Although there’s lots more that could be done if anyone cared"><y>#</y><d>2017-07-31</d><h>17:03</h><w>norman</w>Although there’s lots more that could be done if anyone cared</z><z id="t1501520628991444" t="norman I think the bigger problem is that it’s a technology without much of a clear use."><y>#</y><d>2017-07-31</d><h>17:03</h><w>norman</w>I think the bigger problem is that it’s a technology without much of a clear use.</z><z id="t1501520665012695" t="norman At one point I considered possibly writing a core.logic book"><y>#</y><d>2017-07-31</d><h>17:04</h><w>norman</w>At one point I considered possibly writing a core.logic book</z><z id="t1501520685023767" t="norman So then I went out trying to find other people using core.logic in real applications"><y>#</y><d>2017-07-31</d><h>17:04</h><w>norman</w>So then I went out trying to find other people using core.logic in real applications</z><z id="t1501520701033111" t="norman And I really couldn’t find anyone besides us using"><y>#</y><d>2017-07-31</d><h>17:05</h><w>norman</w>And I really couldn’t find anyone besides us using</z><z id="t1501520704034871" t="swizzard hm"><y>#</y><d>2017-07-31</d><h>17:05</h><w>swizzard</w>hm</z><z id="t1501520727048520" t="norman Maybe more people would use it if they understood it"><y>#</y><d>2017-07-31</d><h>17:05</h><w>norman</w>Maybe more people would use it if they understood it</z><z id="t1501520729049376" t="norman 🙂"><y>#</y><d>2017-07-31</d><h>17:05</h><w>norman</w><b>🙂</b></z><z id="t1501520760066761" t="swizzard ha, perhaps"><y>#</y><d>2017-07-31</d><h>17:06</h><w>swizzard</w>ha, perhaps</z><z id="t1501520803090332" t="norman As you’ve discovered, the reasoned schemer approach to learning core.logic isn’t great"><y>#</y><d>2017-07-31</d><h>17:06</h><w>norman</w>As you’ve discovered, the reasoned schemer approach to learning core.logic isn’t great</z><z id="t1501521357396542" t="hiredman at one point rackspace&apos;s managed security was using or planning on using core.logic, but I haven&apos;t seen them asking about it in a while so they may have changed it up"><y>#</y><d>2017-07-31</d><h>17:15</h><w>hiredman</w>at one point rackspace&apos;s managed security was using or planning on using core.logic, but I haven&apos;t seen them asking about it in a while so they may have changed it up</z><z id="t1501521466456906" t="hiredman I can&apos;t imagine any of the clojure teams I&apos;ve worked with letting something written in core.logic through code review. The first comment would be &quot;this would be clearer if you used map / filter / etc&quot;"><y>#</y><d>2017-07-31</d><h>17:17</h><w>hiredman</w>I can&apos;t imagine any of the clojure teams I&apos;ve worked with letting something written in core.logic through code review. The first comment would be &quot;this would be clearer if you used map / filter / etc&quot;</z><z id="t1501521907708465" t="norman We use core.logic because it’s the cleanest/clearest way to write complex queries."><y>#</y><d>2017-07-31</d><h>17:25</h><w>norman</w>We use core.logic because it’s the cleanest/clearest way to write complex queries.</z><z id="t1501521922717111" t="norman The abstraction you can get is really great"><y>#</y><d>2017-07-31</d><h>17:25</h><w>norman</w>The abstraction you can get is really great</z><z id="t1501521945730030" t="norman We have non-clojurists writing core.logic queries and they don’t even know it"><y>#</y><d>2017-07-31</d><h>17:25</h><w>norman</w>We have non-clojurists writing core.logic queries and they don’t even know it</z><z id="t1501521969743682" t="hiredman sure"><y>#</y><d>2017-07-31</d><h>17:26</h><w>hiredman</w>sure</z><z id="t1501522006764757" t="norman But we’ve worked really hard to give them good abstractions"><y>#</y><d>2017-07-31</d><h>17:26</h><w>norman</w>But we’ve worked really hard to give them good abstractions</z><z id="t1501522012768347" t="hiredman the initial introduction of core.logic is a tough hill to climb"><y>#</y><d>2017-07-31</d><h>17:26</h><w>hiredman</w>the initial introduction of core.logic is a tough hill to climb</z><z id="t1501522044786860" t="hiredman because at the beginning what you are doing isn&apos;t so complicated, so it seems like you could just do it with map and filter and whatever, and it would be easier for people to follow"><y>#</y><d>2017-07-31</d><h>17:27</h><w>hiredman</w>because at the beginning what you are doing isn&apos;t so complicated, so it seems like you could just do it with map and filter and whatever, and it would be easier for people to follow</z><z id="t1501522068800164" t="norman I mean, 95% of what we are using it for could honestly be done with datalog"><y>#</y><d>2017-07-31</d><h>17:27</h><w>norman</w>I mean, 95% of what we are using it for could honestly be done with datalog</z><z id="t1501522074803802" t="norman except the queries would be brutal"><y>#</y><d>2017-07-31</d><h>17:27</h><w>norman</w>except the queries would be brutal</z><z id="t1501522103820379" t="hiredman the seq library is some kind of local maxima, and it takes a bunch of energy to get to something else"><y>#</y><d>2017-07-31</d><h>17:28</h><w>hiredman</w>the seq library is some kind of local maxima, and it takes a bunch of energy to get to something else</z><z id="t1501522166857822" t="hiredman I don&apos;t think a lot of teams can do it (as I&apos;ve said none of the teams I&apos;ve been on seemed to want to spend energy in that way)"><y>#</y><d>2017-07-31</d><h>17:29</h><w>hiredman</w>I don&apos;t think a lot of teams can do it (as I&apos;ve said none of the teams I&apos;ve been on seemed to want to spend energy in that way)</z><z id="t1501522183867580" t="hiredman which is a shame (for core.logic and other things)"><y>#</y><d>2017-07-31</d><h>17:29</h><w>hiredman</w>which is a shame (for core.logic and other things)</z><z id="t1501522351967370" t="norman I’d like to think there are good use cases for core.logic besides ours…"><y>#</y><d>2017-07-31</d><h>17:32</h><w>norman</w>I’d like to think there are good use cases for core.logic besides ours…</z><z id="t1501522402997376" t="hiredman sorry, I think I am not being clear, I 100% think core.logic is a better for a lot of cases"><y>#</y><d>2017-07-31</d><h>17:33</h><w>hiredman</w>sorry, I think I am not being clear, I 100% think core.logic is a better for a lot of cases</z><z id="t1501522511060010" t="hiredman but it doesn&apos;t get used because programmers aren&apos;t willing to expend extra energy to escape the local maxima(the seq library) to get to something better"><y>#</y><d>2017-07-31</d><h>17:35</h><w>hiredman</w>but it doesn&apos;t get used because programmers aren&apos;t willing to expend extra energy to escape the local maxima(the seq library) to get to something better</z><z id="t1501523198450791" t="norman I don’t know clojure developers like that."><y>#</y><d>2017-07-31</d><h>17:46</h><w>norman</w>I don’t know clojure developers like that.</z><z id="t1501523249480138" t="norman But if I can’t tell them practical things they can do with core.logic, I can’t criticize them much for not using it"><y>#</y><d>2017-07-31</d><h>17:47</h><w>norman</w>But if I can’t tell them practical things they can do with core.logic, I can’t criticize them much for not using it</z><z id="t1501523617693887" t="mrchance I want to use it to write a type checker, maybe you can help? I saw the basic type checker example, and I am wondering how I can get type errors from my program instead of () "><y>#</y><d>2017-07-31</d><h>17:53</h><w>mrchance</w>I want to use it to write a type checker, maybe you can help? I saw the basic type checker example, and I am wondering how I can get type errors from my program instead of <code>()</code> </z><z id="t1501523866842561" t="hiredman use conde"><y>#</y><d>2017-07-31</d><h>17:57</h><w>hiredman</w>use conde</z><z id="t1501523886854004" t="hiredman the type terms unify or add this error to a list of error messages"><y>#</y><d>2017-07-31</d><h>17:58</h><w>hiredman</w>the type terms unify or add this error to a list of error messages</z><z id="t1501524067965700" t="hiredman (I guess you&apos;d want conda instead maybe)"><y>#</y><d>2017-07-31</d><h>18:01</h><w>hiredman</w>(I guess you&apos;d want conda instead maybe)</z><z id="t1501524174030258" t="mrchance Ok, that goes in the direction what I thought too, gonna try that "><y>#</y><d>2017-07-31</d><h>18:02</h><w>mrchance</w>Ok, that goes in the direction what I thought too, gonna try that </z><z id="t1501524245072010" t="mrchance I read that conda is a non relational goal, what does that imply? "><y>#</y><d>2017-07-31</d><h>18:04</h><w>mrchance</w>I read that conda is a non relational goal, what does that imply? </z><z id="t1501525205622570" t="hiredman I haven&apos;t used conda much, but if I recall it is committed choice"><y>#</y><d>2017-07-31</d><h>18:20</h><w>hiredman</w>I haven&apos;t used conda much, but if I recall it is committed choice</z><z id="t1501525276663939" t="hiredman with conde all the arms are tried in &quot;parallel&quot;, but conda only the first arm with the first goal that succeeds will be tried"><y>#</y><d>2017-07-31</d><h>18:21</h><w>hiredman</w>with conde all the arms are tried in &quot;parallel&quot;, but conda only the first arm with the first goal that succeeds will be tried</z><z id="t1501525318688163" t="hiredman which would make sense here, I think, if the type terms unify you don&apos;t care about building up a list of errors"><y>#</y><d>2017-07-31</d><h>18:21</h><w>hiredman</w>which would make sense here, I think, if the type terms unify you don&apos;t care about building up a list of errors</z><z id="t1501526308269241" t="mrchance Right, also confirms my expectations, was just worried it might have a performance impact or something"><y>#</y><d>2017-07-31</d><h>18:38</h><w>mrchance</w>Right, also confirms my expectations, was just worried it might have a performance impact or something</z><z id="t1501529389995408" t="urbank Is there still a plan to completely port it to clojurescript?"><y>#</y><d>2017-07-31</d><h>19:29</h><w>urbank</w>Is there still a plan to completely port it to clojurescript?</z><z id="t1502117799412606" t="apeep Hi, I&apos;m new to this field, and from what I can see there&apos;s little activity towards implementing a probabilistic element to core.logic along the lines of probKanren, is that the case? Are there any projects out there using core.logic and applying fuzzy logic or answering problems with a probability-based answer?"><y>#</y><d>2017-08-07</d><h>14:56</h><w>apeep</w>Hi, I&apos;m new to this field, and from what I can see there&apos;s little activity towards implementing a probabilistic element to  core.logic along the lines of probKanren, is that the case? Are there any projects out there using core.logic and applying fuzzy logic or answering problems with a probability-based answer?</z><z id="t1503400767000008" t="zilti How can I execute a core.logic goal repeatedly until exhausted, and use the result as a list in my logic program? I&apos;m looking for the equivalent to &quot;nesting&quot; a run expression, so to speak."><y>#</y><d>2017-08-22</d><h>11:19</h><w>zilti</w>How can I execute a <code>core.logic</code> goal repeatedly until exhausted, and use the result as a list in my logic program? I&apos;m looking for the equivalent to &quot;nesting&quot; a run expression, so to speak.</z><z id="t1503410322000524" t="zilti Basically what I have now is: (defn next-free-license [ltype] (run 1 [q] (fresh [licid tid link links license] (datascript= [tid :type/name ltype]) (datascript= [licid :license/type tid]) (datascript= [licid :license/key license]) (datascript= [licid :license/user link]) (membero link links) (== q [links licid license])))) Which gets me [(138 . _0) 6 &quot;532f16c2c9b13540eb6a&quot;] but I need [(138 143 151 153) 6 &quot;532f16c2c9b13540eb6a&quot;]"><y>#</y><d>2017-08-22</d><h>13:58</h><w>zilti</w>Basically what I have now is:
<pre>(defn next-free-license [ltype]
  (run 1 [q]
       (fresh [licid tid link links license]
              (datascript= [tid :type/name ltype])
              (datascript= [licid :license/type tid])
              (datascript= [licid :license/key license])
              (datascript= [licid :license/user link])
              (membero link links)
              (== q [links licid license]))))
</pre>

Which gets me <code>[(138 . _0) 6 &quot;532f16c2c9b13540eb6a&quot;]</code> but I need <code>[(138 143 151 153) 6 &quot;532f16c2c9b13540eb6a&quot;]</code></z><z id="t1508750006000375" t="xtreak29 How can I get all the successions in the conde elements as below I need to store the values of z as a list. Similar to https://en.wikibooks.org/wiki/Prolog/Recursive_Rules where all the ancestors are listed (defn route [x y] (conde [(c x y)] [(fresh [z] (c x z) (route z y))])) (def facts (pldb/db [c &apos;a &apos;b] [c &apos;a &apos;x] [c &apos;b &apos;c] [c &apos;c &apos;d] [c &apos;d &apos;e])) (pldb/with-db facts (run* [q] (fresh [x y] (== x &apos;a) (== y &apos;e) (route x y) (== q (route x y))))) I need the result as [[a b][b c][c d][d e]] . Is it possible with core.logic ?"><y>#</y><d>2017-10-23</d><h>09:13</h><w>xtreak29</w>How can I get all the successions in the conde elements as below I need to store the values of z as a list. Similar to <a href="https://en.wikibooks.org/wiki/Prolog/Recursive_Rules" target="_blank">https://en.wikibooks.org/wiki/Prolog/Recursive_Rules</a> where all the ancestors are listed

<pre>(defn route [x y]
  (conde
   [(c x y)]
   [(fresh [z]
      (c x z)
      (route z y))]))

(def facts
  (pldb/db
   [c &apos;a &apos;b]
   [c &apos;a &apos;x]
   [c &apos;b &apos;c]
   [c &apos;c &apos;d]
   [c &apos;d &apos;e]))

(pldb/with-db facts
                 (run* [q]
                   (fresh [x y]
                     (== x &apos;a)
                     (== y &apos;e)
                     (route x y)
                     (== q  (route x y)))))
</pre>

I need the result as <code>[[a b][b c][c d][d e]]</code> . Is it possible with core.logic ?</z><z id="t1508751429000328" t="xtreak29 It seems it&apos;s not possible with core.logic : https://stackoverflow.com/questions/12563351/listing-unique-dag-parents-with-core-logic?rq=1 . Can someone explain the answer where David Nolen points out passing it to set constructor ?"><y>#</y><d>2017-10-23</d><h>09:37</h><w>xtreak29</w>It seems it&apos;s not possible with core.logic : <a href="https://stackoverflow.com/questions/12563351/listing-unique-dag-parents-with-core-logic?rq=1" target="_blank">https://stackoverflow.com/questions/12563351/listing-unique-dag-parents-with-core-logic?rq=1</a> . Can someone explain the answer where David Nolen points out passing it to set constructor ?</z><z id="t1508765822000429" t="norman I’d have to think some, but a couple notes: First, goals are not functions that return values. (== q (route x y)) is nonsensical on core.logic."><y>#</y><d>2017-10-23</d><h>13:37</h><w>norman</w>I’d have to think some, but a couple notes: First, goals are not functions that return values.  (== q (route x y)) is nonsensical on core.logic.</z><z id="t1508765837000528" t="norman If this is easily double you’d need:"><y>#</y><d>2017-10-23</d><h>13:37</h><w>norman</w>If this is easily double you’d need:</z><z id="t1508765859000376" t="norman (route r x y) which asserts r is a route between x and y"><y>#</y><d>2017-10-23</d><h>13:37</h><w>norman</w>(route r x y) which asserts r is a route between x and y</z><z id="t1508765875000072" t="norman given the provided facts"><y>#</y><d>2017-10-23</d><h>13:37</h><w>norman</w>given the provided facts</z><z id="t1508765944000113" t="norman Then you’d assert (route q ’a ’e)"><y>#</y><d>2017-10-23</d><h>13:39</h><w>norman</w>Then you’d assert (route q ’a ’e)</z><z id="t1508766041000136" t="norman Otherwise you can’t generate the path, only the fact that a path exists"><y>#</y><d>2017-10-23</d><h>13:40</h><w>norman</w>Otherwise you can’t generate the path, only the fact that a path exists</z><z id="t1508769276000548" t="xtreak29 @norman Thanks I am currently a newbie to core.logic and still trying to grasp it. I was trying to convert the Prolog examples of recursive relations to core.logic and also found the definition of relations using functions at https://github.com/swannodette/logic-tutorial/blob/master/src/logic_tutorial/tut1.clj#L18 and thought it&apos;s right to use functions as goals. The closest I have got to working is as below : (run-db* facts [q] (fresh [x] (== x &apos;a) (route x q))) ;; (x b c d e) "><y>#</y><d>2017-10-23</d><h>14:34</h><w>xtreak29</w>@norman Thanks I am currently a newbie to core.logic and still trying to grasp it. I was trying to convert the Prolog examples of recursive relations to core.logic and also found the definition of relations using functions at <a href="https://github.com/swannodette/logic-tutorial/blob/master/src/logic_tutorial/tut1.clj#L18" target="_blank">https://github.com/swannodette/logic-tutorial/blob/master/src/logic_tutorial/tut1.clj#L18</a> and thought it&apos;s right to use functions as goals. The closest I have got to working is as below : 

<pre>(run-db* facts [q]
                        (fresh [x]
                          (== x &apos;a)
                          (route x q))) ;; (x b c d e)
</pre></z><z id="t1508770159000379" t="norman Yes, that route is just a fact that asserts a route exists"><y>#</y><d>2017-10-23</d><h>14:49</h><w>norman</w>Yes, that route is just a fact that asserts a route exists</z><z id="t1508993893000137" t="bbss I&apos;m getting errors when using fd example: (run* [q] (fresh [x y] (fd/in x y (fd/interval 1 10)) (fd/+ x y 10) (== q [x y]))) ; =&gt; ([1 9] [2 8] [3 7] [4 6] [5 5] [6 4] [7 3] [8 2] [9 1]) Gives Exception Constrained variable &lt;lvar:q__50256&gt; without domain clojure.core.logic/verify-all-bound/verify-all-bound*--48690 (logic.clj:2136) from: https://github.com/clojure/core.logic/wiki/Features"><y>#</y><d>2017-10-26</d><h>04:58</h><w>bbss</w>I&apos;m getting errors when using fd example:
<pre>(run* [q]
  (fresh [x y]
    (fd/in x y (fd/interval 1 10))
    (fd/+ x y 10)
    (== q [x y]))) ; =&gt; ([1 9] [2 8] [3 7] [4 6] [5 5] [6 4] [7 3] [8 2] [9 1])
</pre>

Gives 
<pre>Exception Constrained variable &lt;lvar:q__50256&gt; without domain  clojure.core.logic/verify-all-bound/verify-all-bound*--48690 (logic.clj:2136)</pre>
from:
<a href="https://github.com/clojure/core.logic/wiki/Features" target="_blank">https://github.com/clojure/core.logic/wiki/Features</a></z><z id="t1508993925000054" t="bbss some of the fd examples from the test namespace also fail. using 0.8.11"><y>#</y><d>2017-10-26</d><h>04:58</h><w>bbss</w>some of the fd  examples from the test namespace also fail. using <code>0.8.11</code></z><z id="t1508993960000104" t="bbss it seems perfect for the problem I want to solve, finding build orders in StarCraft II 🙂"><y>#</y><d>2017-10-26</d><h>04:59</h><w>bbss</w>it seems perfect for the problem I want to solve, finding build orders in StarCraft II <b>🙂</b></z><z id="t1508994743000090" t="bbss I think in general core.logic would make for a useful tool in an RTS AI. What do people here think?"><y>#</y><d>2017-10-26</d><h>05:12</h><w>bbss</w>I think in general core.logic would make for a useful tool in an RTS AI. What do people here think?</z><z id="t1508994811000153" t="bbss Maybe generate data to help train a neural net, or help it make decisions, that could then more easily be visualized."><y>#</y><d>2017-10-26</d><h>05:13</h><w>bbss</w>Maybe generate data to help train a neural net, or help it make decisions, that could then more easily be visualized.</z><z id="t1509003255000006" t="bbss figured out I was importing wrong, got it working now 🙂"><y>#</y><d>2017-10-26</d><h>07:34</h><w>bbss</w>figured out I was importing wrong, got it working now <b>🙂</b></z><z id="t1509048961000386" t="xtreak29 Is there a way to generate the constraints in a macro. I need the following : (pldb/with-db db (run 1 [q] (fresh [x y z a b c] (foo x y) (foo a b) (foo b c) ;; more constraints (== q [x y z a b c]))) "><y>#</y><d>2017-10-26</d><h>20:16</h><w>xtreak29</w>Is there a way to generate the constraints in a macro. I need the following : 

<pre>(pldb/with-db db (run 1 [q]
                     (fresh [x y z a b c]
                       (foo x y)
                       (foo a b)
                       (foo b c)
                       ;; more constraints
                       (== q [x y z a b c])))
</pre></z><z id="t1509049356000612" t="xtreak29 I can have many number of vars to fresh and also a lot of foo constraints. I have the following macro but it&apos;s not working. (defmacro my-fresh [db districts res] `(pldb/with-db ~db (run 1 [q] (fresh ~districts (map (fn [[x y]] (&apos;foo x y)) ~res) (== q ~districts))))) "><y>#</y><d>2017-10-26</d><h>20:22</h><w>xtreak29</w>I can have many number of vars to fresh and also a lot of foo constraints. I have the following macro but it&apos;s not working. 

<pre>(defmacro my-fresh
  [db districts res]
  `(pldb/with-db ~db (run 1 [q]
                       (fresh ~districts
                         (map (fn [[x y]] (&apos;foo x y)) ~res)
                         (== q ~districts)))))
</pre></z><z id="t1509050497000175" t="hiredman you don&apos;t need a macro"><y>#</y><d>2017-10-26</d><h>20:41</h><w>hiredman</w>you don&apos;t need a macro</z><z id="t1509050529000585" t="hiredman there is a goal that will combine a sequence of goals in to a single goal (via conjunction)"><y>#</y><d>2017-10-26</d><h>20:42</h><w>hiredman</w>there is a goal that will combine a sequence of goals in to a single goal (via conjunction)</z><z id="t1509050571000445" t="hiredman https://github.com/clojure/core.logic/blob/29917372ef066c42ca362e3a94f68d620ddd1b56/src/main/clojure/clojure/core/logic.clj#L1273"><y>#</y><d>2017-10-26</d><h>20:42</h><w>hiredman</w><a href="https://github.com/clojure/core.logic/blob/29917372ef066c42ca362e3a94f68d620ddd1b56/src/main/clojure/clojure/core/logic.clj#L1273" target="_blank">https://github.com/clojure/core.logic/blob/29917372ef066c42ca362e3a94f68d620ddd1b56/src/main/clojure/clojure/core/logic.clj#L1273</a></z><z id="t1509083642000219" t="xtreak29 @hiredman Thanks. But how can I represent the lvars in fresh. I might have 3 lvars or 10 lvars to fresh and I might have and those lvars of the name mapped to different constraints. I am trying to solve the coloring problem using core.logic and I want to make the state var to be supplied as lvar to fresh . Also I have the neighbor clauses which I want to generate from a map. Does using and* correctly match the lvars from fresh to the one generated. I might be doing something wrong here since I am new to core.logic and clojure macros."><y>#</y><d>2017-10-27</d><h>05:54</h><w>xtreak29</w>@hiredman Thanks. But how can I represent the lvars in fresh. I might have 3 lvars or 10 lvars to fresh and I might have and those lvars of the name mapped to different constraints. I am trying to solve the coloring problem using core.logic and I want to make the <code>state</code> var to be supplied as lvar to <code>fresh</code>. Also I have the <code>neighbor</code> clauses which I want to generate from a map. Does using and* correctly match the lvars from fresh to the one generated. I might be doing something wrong here since I am new to core.logic and clojure macros.</z><z id="t1509083676000159" t="xtreak29 Here I want states to be supplied to fresh : https://gist.github.com/tirkarthi/df7b99ad5d9d04745b67040093598984"><y>#</y><d>2017-10-27</d><h>05:54</h><w>xtreak29</w>Here I want states to be supplied to fresh : <a href="https://gist.github.com/tirkarthi/df7b99ad5d9d04745b67040093598984" target="_blank">https://gist.github.com/tirkarthi/df7b99ad5d9d04745b67040093598984</a></z><z id="t1509083768000203" t="hiredman https://gist.github.com/hiredman/05befd5b39eef89b86ca#file-bench-clj-L33-L35 is an old example of generating lvars dynamiclly"><y>#</y><d>2017-10-27</d><h>05:56</h><w>hiredman</w><a href="https://gist.github.com/hiredman/05befd5b39eef89b86ca#file-bench-clj-L33-L35" target="_blank">https://gist.github.com/hiredman/05befd5b39eef89b86ca#file-bench-clj-L33-L35</a> is an old example of generating lvars dynamiclly</z><z id="t1509083808000097" t="hiredman fresh you can think of as a macro, (fresh [x] ...) -&gt; (let [x (lvar)] ...)"><y>#</y><d>2017-10-27</d><h>05:56</h><w>hiredman</w>fresh you can think of as a macro, (fresh [x] ...) -&gt; (let [x (lvar)] ...)</z><z id="t1509084363000083" t="xtreak29 Thanks. I saw the code for solve-bench . So I can just use (run 1 [q] (and (foo (:x bench) (:y bench)) (foo (:y bench) (:x bench))) (== q bench)) "><y>#</y><d>2017-10-27</d><h>06:06</h><w>xtreak29</w>Thanks. I saw the code for <code>solve-bench</code>. So I can just use 
<pre>(run 1 [q] 
(and (foo (:x bench) (:y bench)) 
        (foo (:y bench) (:x bench))) 
(== q bench))
</pre></z><z id="t1509084407000020" t="hiredman yes"><y>#</y><d>2017-10-27</d><h>06:06</h><w>hiredman</w>yes</z><z id="t1509084714000005" t="xtreak29 Is there a limit on the stack or anything in JVM for the number of lvars. I am trying to unify some 600 lvars against around 4000 goals. The prolog version segfaulted on my machine. Just wanted to know if something that big is done or possible technically."><y>#</y><d>2017-10-27</d><h>06:11</h><w>xtreak29</w>Is there a limit on the stack or anything in JVM for the number of lvars. I am trying to unify some 600 lvars against around 4000 goals. The prolog version segfaulted on my machine. Just wanted to know if something that big is done or possible technically.</z><z id="t1509084743000067" t="xtreak29 Also I realize the whole unification is dependent on each other and cannot be parallelized"><y>#</y><d>2017-10-27</d><h>06:12</h><w>xtreak29</w>Also I realize the whole unification is dependent on each other and cannot be parallelized</z><z id="t1509084822000064" t="hiredman I don&apos;t know"><y>#</y><d>2017-10-27</d><h>06:13</h><w>hiredman</w>I don&apos;t know</z><z id="t1509085723000008" t="pbaille Hi! I&apos;m a beginner with logic programing. does anyone mind to tell me how can I make this code work:"><y>#</y><d>2017-10-27</d><h>06:28</h><w>pbaille</w>Hi! I&apos;m a beginner with logic programing. does anyone mind to tell me how can I make this code work:</z><z id="t1509085747000186" t="pbaille (run 1 [q] (fresh [dom a b] (== dom (apply fd/domain (range 11))) (l/everyg #(fd/in % dom) [a b]) (== q [a b]) (fd/* a b 100))) "><y>#</y><d>2017-10-27</d><h>06:29</h><w>pbaille</w><pre>(run 1 [q]
       (fresh [dom a b]
              (== dom (apply fd/domain (range 11)))
              (l/everyg #(fd/in % dom) [a b])
              (== q [a b])
              (fd/* a b 100)))
</pre></z><z id="t1509085797000081" t="pbaille I&apos;ve got this error: IllegalArgumentException No implementation of method: :-lb of protocol: #&apos;clojure.core.logic.fd/IInterval found for class: clojure.core.logic.LVar clojure.core/-cache-protocol-fn (core_deftype.clj:568)"><y>#</y><d>2017-10-27</d><h>06:29</h><w>pbaille</w>I&apos;ve got this error: <code>IllegalArgumentException No implementation of method: :-lb of protocol: #&apos;clojure.core.logic.fd/IInterval found for class: clojure.core.logic.LVar  clojure.core/-cache-protocol-fn (core_deftype.clj:568)</code></z><z id="t1509085932000270" t="pbaille ok I&apos;ve found"><y>#</y><d>2017-10-27</d><h>06:32</h><w>pbaille</w>ok I&apos;ve found</z><z id="t1509085945000066" t="pbaille I have to use interval intead of row lvars"><y>#</y><d>2017-10-27</d><h>06:32</h><w>pbaille</w>I have to use interval intead of row lvars</z><z id="t1509085954000168" t="pbaille sorry for the noise"><y>#</y><d>2017-10-27</d><h>06:32</h><w>pbaille</w>sorry for the noise</z><z id="t1509090682000103" t="pbaille what are some logic programing utils libraries built on top of core.logic?"><y>#</y><d>2017-10-27</d><h>07:51</h><w>pbaille</w>what are some logic programing utils libraries built on top of core.logic?</z><z id="t1509265386000013" t="pbaille anybody?"><y>#</y><d>2017-10-29</d><h>08:23</h><w>pbaille</w>anybody?</z><z id="t1509265499000018" t="pbaille I&apos;m struggling with this simple relation, the results are incomplete, and I don&apos;t understand why. I&apos;m beginning with core.logic I don&apos;t know if it is a bug or my bad understanding of it. (require &apos;[clojure.core.logic :as l]) (require &apos;[clojure.core.logic.fd :as fd]) (defn zip+o [x y z] (l/conde [(l/== () x) (l/== () y) (l/== () z)] [(l/fresh [fx rx fy ry fz rz] (l/conso fx rx x) (l/conso fy ry y) (l/conso fz rz z) (fd/in fx fy fz (fd/interval 10)) (fd/+ fx fy fz) (zip+o rx ry rz))])) ; the same with defne macro (comment (l/defne zip+o [x y z] ([() () ()]) ([[fx . rx] [fy . ry] [fz . rz]] (fd/in fx fy fz (fd/interval 10)) (fd/+ fx fy fz) (zip+o rx ry rz)))) (def expected-solutions #{{:x [0 0] :y [1 1]} {:x [0 1] :y [1 0]} {:x [1 1] :y [0 0]} {:x [1 0] :y [0 1]}}) (l/run* [q] (l/fresh [x y] (l/== q {:x x :y y}) (zip+o x y [1 1]))) ;=&gt; ({:x (1 0), :y (0 1)} ; {:x (0 0), :y (1 1)}) "><y>#</y><d>2017-10-29</d><h>08:24</h><w>pbaille</w>I&apos;m struggling with this simple relation, the results are incomplete, and I don&apos;t understand why.  

I&apos;m beginning with core.logic I don&apos;t know if it is a bug or my bad understanding of it.  

<pre>(require &apos;[clojure.core.logic :as l])
    (require &apos;[clojure.core.logic.fd :as fd])
    
    (defn zip+o [x y z]
      (l/conde
        [(l/== () x) (l/== () y) (l/== () z)]
        [(l/fresh [fx rx fy ry fz rz]
                  (l/conso fx rx x)
                  (l/conso fy ry y)
                  (l/conso fz rz z)
                  (fd/in fx fy fz (fd/interval 10))
                  (fd/+ fx fy fz)
                  (zip+o rx ry rz))]))
    
    ; the same with defne macro
    (comment
      (l/defne zip+o [x y z]
               ([() () ()])
               ([[fx . rx]
                 [fy . ry]
                 [fz . rz]]
                 (fd/in fx fy fz (fd/interval 10))
                 (fd/+ fx fy fz)
                 (zip+o rx ry rz))))
    
    (def expected-solutions
      #{{:x [0 0] :y [1 1]}
        {:x [0 1] :y [1 0]}
        {:x [1 1] :y [0 0]}
        {:x [1 0] :y [0 1]}})
    
    (l/run* [q]
            (l/fresh [x y]
                     (l/== q {:x x :y y})
                     (zip+o x y [1 1])))
    
    ;=&gt; ({:x (1 0), :y (0 1)}
    ;    {:x (0 0), :y (1 1)})
</pre></z><z id="t1509377330000304" t="norman I’m not familiar with the finite domain work."><y>#</y><d>2017-10-30</d><h>15:28</h><w>norman</w>I’m not familiar with the finite domain work.</z><z id="t1509377339000345" t="norman But if you change the fd/in to"><y>#</y><d>2017-10-30</d><h>15:28</h><w>norman</w>But if you change the fd/in to</z><z id="t1509377341000047" t="norman (l/membero fx [0 1 2 3 4 5]) (l/membero fy [0 1 2 3 4 5]) (l/membero fz [0 1 2 3 4 5])"><y>#</y><d>2017-10-30</d><h>15:29</h><w>norman</w>(l/membero fx [0 1 2 3 4 5])
                (l/membero fy [0 1 2 3 4 5])
                (l/membero fz [0 1 2 3 4 5])</z><z id="t1509377341000859" t="norman it works"><y>#</y><d>2017-10-30</d><h>15:29</h><w>norman</w>it works</z><z id="t1509377463000515" t="norman So I suppose either there is a bug in fd/in or you are not using correctly here."><y>#</y><d>2017-10-30</d><h>15:31</h><w>norman</w>So I suppose either there is a bug in fd/in or you are not using correctly here.</z><z id="t1509630649000691" t="pbaille thank you @norman, i&apos;ve found a way to obtain the correct solution, see this ticket if interested https://dev.clojure.org/jira/browse/LOGIC-185"><y>#</y><d>2017-11-02</d><h>13:50</h><w>pbaille</w>thank you @norman, i&apos;ve found a way to obtain the correct solution, see this ticket if interested <a href="https://dev.clojure.org/jira/browse/LOGIC-185" target="_blank">https://dev.clojure.org/jira/browse/LOGIC-185</a></z><z id="t1509630673000001" t="pbaille I&apos;ve got another question"><y>#</y><d>2017-11-02</d><h>13:51</h><w>pbaille</w>I&apos;ve got another question</z><z id="t1509630810000634" t="pbaille I&apos;m going thru the reasoned schemer and i&apos;ve noticed that the order of excecution differ sometimes in core.logic. in particular &apos;conde&apos; seems to behave differently, looks like it tries all branch before doing any recursion. Any toughts on this?"><y>#</y><d>2017-11-02</d><h>13:53</h><w>pbaille</w>I&apos;m going thru the reasoned schemer and i&apos;ve noticed that the order of excecution differ sometimes in core.logic. in particular &apos;conde&apos; seems to behave differently, looks like it tries all branch before doing any recursion. Any toughts on this?</z><z id="t1509631319000448" t="pbaille (defn pairo [x] (fresh [y] (firsto x y))) (defn unwrapo [x y] (conde [(pairo x) (fresh [a] (firsto x a) (unwrapo a y))] [(== x y)])) (run* [q] (unwrapo &apos;(((pizza))) q)) ; ((((pizza))) ; ((pizza)) ; (pizza) ; pizza ; ) ;while in TRS it returns ; (pizza ; (pizza) ; ((pizza)) ; (((pizza))) ; ) ;both: (run 1 [q] (unwrapo q &apos;pizza)) ;and (run 1 [q] (unwrapo (list (list q)) &apos;pizza)) ;returns: ;=&gt; (pizza) ;while in TRS it returns ;=&gt; () "><y>#</y><d>2017-11-02</d><h>14:01</h><w>pbaille</w><pre>(defn pairo [x]
  (fresh [y] (firsto x y)))

(defn unwrapo [x y]
  (conde
    [(pairo x) (fresh [a] (firsto x a) (unwrapo a y))]
    [(== x y)]))

(run* [q] (unwrapo &apos;(((pizza))) q))
; ((((pizza))) 
;  ((pizza)) 
;  (pizza) 
;  pizza
; )

;while in TRS it returns

; (pizza
;  (pizza)
;  ((pizza))
;  (((pizza)))
; )


;both:
(run 1 [q] (unwrapo q &apos;pizza))
;and
(run 1 [q] (unwrapo (list (list q)) &apos;pizza))

;returns:

;=&gt; (pizza)

;while in TRS it returns

;=&gt; ()
</pre></z><z id="t1509645573000246" t="pbaille the wiki actually explain this difference, i&apos;ve missed it, sorry"><y>#</y><d>2017-11-02</d><h>17:59</h><w>pbaille</w>the wiki actually explain this difference, i&apos;ve missed it, sorry</z><z id="t1512598519000391" t="noprompt is there a rationale for why lvars as map keys do not unify? (run* [q] (fresh [a b] (== {a b} {:a 2}) (== q (list a b)))) ;; =&gt; () "><y>#</y><d>2017-12-06</d><h>22:15</h><w>noprompt</w>is there a rationale for why lvars as map keys do not unify?
<pre>(run* [q]
  (fresh [a b]
    (== {a b} {:a 2})
    (== q (list a b))))
;; =&gt; ()
</pre></z><z id="t1512598786000616" t="noprompt in my spare time i’ve been working on a term rewriting engine and was also confronted with the problem of unifying maps. i was able to find a solution that achieves this. i was surprised to find that core.logic doesn’t support this, however, i wouldn’t be surprised if i may have overlooked something in my own algorithm."><y>#</y><d>2017-12-06</d><h>22:19</h><w>noprompt</w>in my spare time i’ve been working on a term rewriting engine and was also confronted with the problem of unifying maps. i was able to find a solution that achieves this. i was surprised to find that <code>core.logic</code> doesn’t support this, however, i wouldn’t be surprised if i may have overlooked something in my own algorithm.</z><z id="t1512600267000219" t="hiredman there is no one way to do it"><y>#</y><d>2017-12-06</d><h>22:44</h><w>hiredman</w>there is no one way to do it</z><z id="t1512600505000038" t="noprompt @hiredman explain."><y>#</y><d>2017-12-06</d><h>22:48</h><w>noprompt</w>@hiredman explain.</z><z id="t1512600551000027" t="hiredman (== {a b c d} {:a 1 😛 2})"><y>#</y><d>2017-12-06</d><h>22:49</h><w>hiredman</w>(== {a b c d} {:a 1 <b>😛</b> 2})</z><z id="t1512600557000194" t="hiredman (== {a b c d} {:a 1 :b 2})"><y>#</y><d>2017-12-06</d><h>22:49</h><w>hiredman</w><code>(== {a b c d} {:a 1 :b 2})</code></z><z id="t1512600609000510" t="noprompt the algorithm i wrote unifies ground entries, then entries with ground values, then entries with ground keys, then entries where both the key and value are variable."><y>#</y><d>2017-12-06</d><h>22:50</h><w>noprompt</w>the algorithm i wrote unifies ground entries, then entries with ground values, then entries with ground keys, then entries where both the key and value are variable.</z><z id="t1512600635000396" t="hiredman there is no single unification for that"><y>#</y><d>2017-12-06</d><h>22:50</h><w>hiredman</w>there is no single unification for that</z><z id="t1512600642000255" t="noprompt your example can be unified in multiple ways, the values can be streamed to a, b, c, and d in those cases."><y>#</y><d>2017-12-06</d><h>22:50</h><w>noprompt</w>your example can be unified in multiple ways, the values can be streamed to a, b, c, and d in those cases.</z><z id="t1512600657000466" t="noprompt actually, that’s not true."><y>#</y><d>2017-12-06</d><h>22:50</h><w>noprompt</w>actually, that’s not true.</z><z id="t1512600674000085" t="noprompt the fact there exists a solution refutes that argument."><y>#</y><d>2017-12-06</d><h>22:51</h><w>noprompt</w>the fact there exists a solution refutes that argument.</z><z id="t1512600729000035" t="noprompt so maybe my understanding here is misguided."><y>#</y><d>2017-12-06</d><h>22:52</h><w>noprompt</w>so maybe my understanding here is misguided.</z><z id="t1512600747000448" t="noprompt can you explain your emphasis on “single”?"><y>#</y><d>2017-12-06</d><h>22:52</h><w>noprompt</w>can you explain your emphasis on “single”?</z><z id="t1512600848000213" t="hiredman lists are defined inductively via cons, so there is a one order they can be walked for unification, and that orders arises from the definition"><y>#</y><d>2017-12-06</d><h>22:54</h><w>hiredman</w>lists are defined inductively via cons, so there is a one order they can be walked for unification, and that orders arises from the definition</z><z id="t1512600920000058" t="hiredman maps are not inductively defined, so there is no single iteration order, so there is no fixed thing to wire in to the unifier"><y>#</y><d>2017-12-06</d><h>22:55</h><w>hiredman</w>maps are not inductively defined, so there is no single iteration order, so there is no fixed thing to wire in to the unifier</z><z id="t1512600969000185" t="hiredman you can do it, but you will have to make some choices to do it that preclude being general, which is what a library like core.logic is trying to do"><y>#</y><d>2017-12-06</d><h>22:56</h><w>hiredman</w>you can do it, but you will have to make some choices to do it that preclude being general, which is what a library like core.logic is trying to do</z><z id="t1512601038000055" t="noprompt i see. can you elaborate more on why the inductive property is important?"><y>#</y><d>2017-12-06</d><h>22:57</h><w>noprompt</w>i see. can you elaborate more on why the inductive property is important?</z><z id="t1512601092000111" t="noprompt wrt core.logic?"><y>#</y><d>2017-12-06</d><h>22:58</h><w>noprompt</w>wrt core.logic?</z><z id="t1512601380000094" t="noprompt i’m guessing the solution here would be to use another goal in favor of == which does stream the substitutions."><y>#</y><d>2017-12-06</d><h>23:03</h><w>noprompt</w>i’m guessing the solution here would be to use another goal in favor of <code>==</code> which does stream the substitutions.</z><z id="t1512601410000068" t="hiredman because unification has to traverse datastructures, if a datastructure is defined inductively, that is an order the structure can be traversed"><y>#</y><d>2017-12-06</d><h>23:03</h><w>hiredman</w>because unification has to traverse datastructures, if a datastructure is defined inductively, that is an order the structure can be traversed</z><z id="t1512601486000255" t="hiredman I bet you could make it work if you either only used one concrete map type, or sorted it before unifying"><y>#</y><d>2017-12-06</d><h>23:04</h><w>hiredman</w>I bet you could make it work if you either only used one concrete map type, or sorted it before unifying</z><z id="t1512601565000200" t="noprompt the strategy i mentioned above works pretty well. although, again, my setting is term rewriting which expects the left-hand side of the equation to be ground."><y>#</y><d>2017-12-06</d><h>23:06</h><w>noprompt</w>the strategy i mentioned above works pretty well. although, again, my setting is term rewriting which expects the left-hand side of the equation to be ground.</z><z id="t1512601603000490" t="hiredman sure, if your model is less general then you can do more"><y>#</y><d>2017-12-06</d><h>23:06</h><w>hiredman</w>sure, if your model is less general then you can do more</z><z id="t1512602047000297" t="noprompt so, in the context of core logic, would the solution then be two stream the solutions via a custom goal?"><y>#</y><d>2017-12-06</d><h>23:14</h><w>noprompt</w>so, in the context of core logic, would the solution then be two stream the solutions via a custom goal?</z><z id="t1512602167000182" t="noprompt i understand the rationale above now."><y>#</y><d>2017-12-06</d><h>23:16</h><w>noprompt</w>i understand the rationale above now.</z><z id="t1512606023000225" t="noprompt okay the custom goal seems to be the ticket."><y>#</y><d>2017-12-07</d><h>00:20</h><w>noprompt</w>okay the custom goal seems to be the ticket.</z><z id="t1512606058000231" t="noprompt @hiredman thanks for your answers previously. it’s clear now. 🙂"><y>#</y><d>2017-12-07</d><h>00:20</h><w>noprompt</w>@hiredman thanks for your answers previously. it’s clear now. <b>🙂</b></z><z id="t1512770160000160" t="noprompt so now i’m curious, why not have == be guided by a protocol underneath that returns Substitutions ? since goals are expected to return a stream of substitutions it seems like it doesn’t necessarily need to be limited to either the unit stream or nil ."><y>#</y><d>2017-12-08</d><h>21:56</h><w>noprompt</w>so now i’m curious, why not have <code>==</code> be guided by a protocol underneath that returns <code>Substitutions</code>? since goals are expected to return a stream of substitutions it seems like it doesn’t necessarily need to be limited to either the unit stream or <code>nil</code>.</z><z id="t1513032676000223" t="paulocuneo but it already does something like that(kinda), see IUnifyTerms"><y>#</y><d>2017-12-11</d><h>22:51</h><r>paulocuneo</r>but it already does something like that(kinda), see IUnifyTerms</z><z id="t1512770228000119" t="noprompt iow you could have an implementation of == for maps such that it returns a goal which, if possible, produces a stream all of the possible substitutions."><y>#</y><d>2017-12-08</d><h>21:57</h><w>noprompt</w>iow you could have an implementation of <code>==</code> for maps such that it returns a goal which, if possible, produces a stream all of the possible substitutions.</z><z id="t1512865004000086" t="noprompt Any takers? ☝️ :skin-tone-4:"><y>#</y><d>2017-12-10</d><h>00:16</h><w>noprompt</w>Any takers? <b>☝️</b><b>:skin-tone-4:</b></z><z id="t1513121730000157" t="paulocuneo may I post a patch to any of the bugs from core.logic jira? most of them are not bugs, but a few are"><y>#</y><d>2017-12-12</d><h>23:35</h><w>paulocuneo</w>may I post a patch to any of the bugs from core.logic jira?
most of them are not bugs, but a few are</z><z id="t1513267111000492" t="noprompt @paulocuneo have you signed the contributor agreement?"><y>#</y><d>2017-12-14</d><h>15:58</h><w>noprompt</w>@paulocuneo have you signed the contributor agreement?</z><z id="t1513908427000110" t="paulocuneo now I have"><y>#</y><d>2017-12-22</d><h>02:07</h><r>paulocuneo</r>now I have</z><z id="t1513277076000232" t="zignd in core.logic, considering i have a map as a logic variable, is it it possible to compare to the value of a specific keyword? i thought about doing it like this, but it doesn&apos;t work: (logic/run* [q] (logic/membero q [{:id 1 :name &quot;foo&quot;} {:id 2 :name &quot;bar&quot;} {:id 3 :name &quot;foo&quot;}]) (logic/== (:name q) &quot;foo&quot;)) =&gt; () the only solution i found was to compare the logic variable to a map and adding logic variables to the values i don&apos;t know (logic/run* [q x] (logic/membero q [{:id 1 :name &quot;foo&quot;} {:id 2 :name &quot;bar&quot;} {:id 3 :name &quot;foo&quot;}]) (logic/== q {:id x :name &quot;foo&quot;})) =&gt; ([{:id 1, :name &quot;foo&quot;} 1] [{:id 3, :name &quot;foo&quot;} 3]) "><y>#</y><d>2017-12-14</d><h>18:44</h><w>zignd</w>in core.logic, considering i have a map as a logic variable, is it it possible to compare to the value of a specific keyword?
i thought about doing it like this, but it doesn&apos;t work:
<pre>(logic/run* [q]
(logic/membero q [{:id 1 :name &quot;foo&quot;} {:id 2 :name &quot;bar&quot;} {:id 3 :name &quot;foo&quot;}])
(logic/== (:name q) &quot;foo&quot;))
=&gt; ()
</pre>
the only solution i found was to compare the logic variable to a map and adding logic variables to the values i don&apos;t know
<pre>(logic/run* [q x]
(logic/membero q [{:id 1 :name &quot;foo&quot;} {:id 2 :name &quot;bar&quot;} {:id 3 :name &quot;foo&quot;}])
(logic/== q {:id x :name &quot;foo&quot;}))
=&gt; ([{:id 1, :name &quot;foo&quot;} 1] [{:id 3, :name &quot;foo&quot;} 3])
</pre></z><z id="t1513278858000186" t="hiredman I use featurec (I think that is the name of the thing)"><y>#</y><d>2017-12-14</d><h>19:14</h><w>hiredman</w>I use featurec (I think that is the name of the thing)</z><z id="t1513279035000300" t="zignd it works! thanks @hiredman!"><y>#</y><d>2017-12-14</d><h>19:17</h><w>zignd</w>it works! thanks @hiredman!</z><z id="t1513279041000393" t="zignd (logic/run* [q] (logic/membero q [{:id 1 :name &quot;foo&quot;} {:id 2 :name &quot;bar&quot;} {:id 3 :name &quot;foo&quot;}]) (logic/featurec q {:name &quot;foo&quot;})) =&gt; ({:id 1, :name &quot;foo&quot;} {:id 3, :name &quot;foo&quot;}) "><y>#</y><d>2017-12-14</d><h>19:17</h><w>zignd</w><pre>(logic/run* [q]
  (logic/membero q [{:id 1 :name &quot;foo&quot;} {:id 2 :name &quot;bar&quot;} {:id 3 :name &quot;foo&quot;}])
  (logic/featurec q {:name &quot;foo&quot;}))
=&gt; ({:id 1, :name &quot;foo&quot;} {:id 3, :name &quot;foo&quot;})
</pre></z><z id="t1513283767000593" t="dominicm https://stackoverflow.com/a/14532781 I&apos;m trying to do something similar to this. Except, I want to potentially build the query based on other lvars. I&apos;m not certain this makes sense as a question. How can I get a list of potential candidate values for an lvar at a the point of my query?"><y>#</y><d>2017-12-14</d><h>20:36</h><w>dominicm</w><a href="https://stackoverflow.com/a/14532781" target="_blank">https://stackoverflow.com/a/14532781</a> I&apos;m trying to do something similar to this. Except, I want to potentially build the query based on other lvars. I&apos;m not certain this makes sense as a question. How can I get a list of potential candidate values for an lvar at a the point of my query?</z><z id="t1513283807000650" t="dominicm I pretty much just want to know &quot;oh, it&apos;s one of these numbers? I&apos;ll grab data for them&quot; vs &quot;Could be anything? I&apos;ll grab it all&quot; Might be nice to have some assertions in cases where I can only grab it with some constraint."><y>#</y><d>2017-12-14</d><h>20:36</h><w>dominicm</w>I pretty much just want to know &quot;oh, it&apos;s one of these numbers? I&apos;ll grab data for them&quot; vs &quot;Could be anything? I&apos;ll grab it all&quot; Might be nice to have some assertions in cases where I can only grab it with some constraint.</z><z id="t1513284009000452" t="hiredman you might look at https://github.com/hiredman/jiralog"><y>#</y><d>2017-12-14</d><h>20:40</h><w>hiredman</w>you might look at <a href="https://github.com/hiredman/jiralog" target="_blank">https://github.com/hiredman/jiralog</a></z><z id="t1513284060000093" t="dominicm That sounds very similar to my actual end goal, so probably a perfect example."><y>#</y><d>2017-12-14</d><h>20:41</h><w>dominicm</w>That sounds very similar to my actual end goal, so probably a perfect example.</z><z id="t1513284116000034" t="hiredman I think maybe I started from https://gist.github.com/terjesb/3181018"><y>#</y><d>2017-12-14</d><h>20:41</h><w>hiredman</w>I think maybe I started from <a href="https://gist.github.com/terjesb/3181018" target="_blank">https://gist.github.com/terjesb/3181018</a></z><z id="t1513284131000443" t="hiredman (or maybe the original that was forked from)"><y>#</y><d>2017-12-14</d><h>20:42</h><w>hiredman</w>(or maybe the original that was forked from)</z><z id="t1513356871000463" t="dominicm I&apos;m using core logic to get a list of things, and infer properties about them. No answers (`nil`) is a perfectly valid answer, but I don&apos;t want to throw away an item which doesn&apos;t have an answer for a particular question. How can I do this?"><y>#</y><d>2017-12-15</d><h>16:54</h><w>dominicm</w>I&apos;m using core logic to get a list of things, and infer properties about them. No answers (`nil`) is a perfectly valid answer, but I don&apos;t want to throw away an item which doesn&apos;t have an answer for a particular question. How can I do this?</z><z id="t1513357750000187" t="hiredman user=&gt; (l/run* [q] (l/== q nil)) (nil) user=&gt; "><y>#</y><d>2017-12-15</d><h>17:09</h><w>hiredman</w><pre>user=&gt; (l/run* [q] (l/== q nil))
(nil)
user=&gt;
</pre></z><z id="t1513358283000002" t="dominicm @hiredman I&apos;ve potentially already got an answer for my question though, so I can&apos;t do that."><y>#</y><d>2017-12-15</d><h>17:18</h><w>dominicm</w>@hiredman I&apos;ve potentially already got an answer for my question though, so I can&apos;t do that.</z><z id="t1513358341000367" t="hiredman user=&gt; (l/run* [q] (l/conde [(l/== q nil)] [(l/!= q nil)])) (nil (_0 :- (!= (_0 nil)))) user=&gt; "><y>#</y><d>2017-12-15</d><h>17:19</h><w>hiredman</w><pre>user=&gt; (l/run* [q] (l/conde [(l/== q nil)] [(l/!= q nil)]))
(nil (_0 :- (!= (_0 nil))))
user=&gt;
</pre></z><z id="t1513358672000153" t="dominicm @hiredman Thanks, that led me to my solution."><y>#</y><d>2017-12-15</d><h>17:24</h><w>dominicm</w>@hiredman Thanks, that led me to my solution.</z><z id="t1513359519000363" t="dominicm (l/run* [x q] (l/== x 10) (fn [a] (l/to-stream []))) I have a case where this could happen. How can I detect that q hasn&apos;t been bound and mark it as nil, so that I still get an answer about x?"><y>#</y><d>2017-12-15</d><h>17:38</h><w>dominicm</w><pre>(l/run*
    [x q]
    (l/== x 10)
    (fn [a]
      (l/to-stream [])))
</pre>

I have a case where this could happen. How can I detect that q hasn&apos;t been bound and mark it as nil, so that I still get an answer about x?</z><z id="t1513375578000125" t="paulocuneo do you really really really really need to check if x is &quot;fresh&quot; (i guess thats what you mean with unbound)? ;; Following code loses relational properties (conde [(lvaro q) ;; q is fresh... ] [(nonlvaro q) ;; q is not fresh ])"><y>#</y><d>2017-12-15</d><h>22:06</h><w>paulocuneo</w>do you really really really really need to check if x is &quot;fresh&quot; (i guess thats what you mean with unbound)? 

;; Following code loses relational properties

(conde [(lvaro q) 
             ;; q is fresh...
             ] 
            [(nonlvaro q)
             ;; q is not fresh 
            ])</z><z id="t1513383525000087" t="dominicm Maybe I need to figure out aggregates properly, and this will go away. I&apos;m using core logic as a query engine, so I&apos;m doing a sort of &quot;get this relationship or else return nothing&quot;, all centred around a main entity."><y>#</y><d>2017-12-16</d><h>00:18</h><w>dominicm</w>Maybe I need to figure out aggregates properly, and this will go away. I&apos;m using core logic as a query engine, so I&apos;m doing a sort of &quot;get this relationship or else return nothing&quot;, all centred around a main entity.</z><z id="t1513384028000176" t="hiredman you should look at the string contains constraint in jiralog"><y>#</y><d>2017-12-16</d><h>00:27</h><w>hiredman</w>you should look at the string contains constraint in jiralog</z><z id="t1513384427000027" t="hiredman when writing a core.logic connector to some datastore, what I recommend starting with, which is the simplest thing, is to not have much of a query optimizer. just pull everything out of the datastore, feed it through to-stream"><y>#</y><d>2017-12-16</d><h>00:33</h><w>hiredman</w>when  writing a core.logic connector to some datastore, what I recommend starting with, which is the simplest thing, is to not have much of a query optimizer. just pull everything out of the datastore, feed it through <code>to-stream</code></z><z id="t1513384726000022" t="hiredman the way to write that is as a relation like (edge a b) , the simple implementation being something that takes a and looks in your datastore for the edges, then does the to-stream magic to generate a stream of results where b is bound to each edge"><y>#</y><d>2017-12-16</d><h>00:38</h><w>hiredman</w>the way to write that is as a relation like <code>(edge a b)</code>, the simple implementation being something that takes a  and looks in your datastore for the edges, then does the to-stream magic to generate a stream of results where b is bound to each edge</z><z id="t1513384758000039" t="hiredman but at some point you will want to write a logic program where a is not ground at the point where the search reaches that goal"><y>#</y><d>2017-12-16</d><h>00:39</h><w>hiredman</w>but at some point you will want to write a logic program where a is not ground at the point where the search reaches that goal</z><z id="t1513384786000038" t="hiredman and you can&apos;t send a logic variable to your datastore for searching"><y>#</y><d>2017-12-16</d><h>00:39</h><w>hiredman</w>and you can&apos;t send a logic variable to your datastore for searching</z><z id="t1513384920000089" t="hiredman instead of a normal relation goal you can write a constraint, which can sort of delay its actions until a and b are both ground, constraints can&apos;t generate possible solutions in the search tree, they only prune it"><y>#</y><d>2017-12-16</d><h>00:42</h><w>hiredman</w>instead of a normal relation goal you can write a constraint, which can sort of delay its actions until a and b are both ground, constraints can&apos;t generate possible solutions in the search tree, they only prune it</z><z id="t1513384951000159" t="hiredman (I could be misremembering that, but I don&apos;t think I am)"><y>#</y><d>2017-12-16</d><h>00:42</h><w>hiredman</w>(I could be misremembering that, but I don&apos;t think I am)</z><z id="t1513385216000073" t="hiredman depending on what exactly you are doing, you may be better off writing your own datalog, which would feel similar to core.logic but give you more control over the guts"><y>#</y><d>2017-12-16</d><h>00:46</h><w>hiredman</w>depending on what exactly you are doing, you may be better off writing your own datalog, which would feel similar to core.logic but give you more control over the guts</z><z id="t1513433198000029" t="zignd is it possible to define ordering in the results of a run* call?"><y>#</y><d>2017-12-16</d><h>14:06</h><w>zignd</w>is it possible to define ordering in the results of a <code>run*</code> call?</z><z id="t1513433253000043" t="zignd i&apos;m using core.logic to query data structures that are basically vectors of maps"><y>#</y><d>2017-12-16</d><h>14:07</h><w>zignd</w>i&apos;m using <code>core.logic</code> to query data structures that are basically vectors of maps</z><z id="t1513433288000016" t="zignd and right now i&apos;m doing it from the outside, using sort-by for example"><y>#</y><d>2017-12-16</d><h>14:08</h><w>zignd</w>and right now i&apos;m doing it from the outside, using <code>sort-by</code> for example</z><z id="t1513433386000029" t="zignd considering run* accepts lvars and expressions to constrain the result it doesn&apos;t really make sense i suppose, but i&apos;d like to confirm"><y>#</y><d>2017-12-16</d><h>14:09</h><w>zignd</w>considering <code>run*</code> accepts lvars and expressions to constrain the result it doesn&apos;t really make sense i suppose, but i&apos;d like to confirm</z><z id="t1515466776000145" t="timothypratley Invalid :refer, var cljs.core.logic/permuteo does not exist --- is this expected? (ClojureScript)"><y>#</y><d>2018-01-09</d><h>02:59</h><w>timothypratley</w>Invalid :refer, var cljs.core.logic/permuteo does not exist    --- is this expected? (ClojureScript)</z><z id="t1515470551000029" t="noprompt @timothypratley are you able to use permuteo without :refer ? i.e. logic/permuteo ."><y>#</y><d>2018-01-09</d><h>04:02</h><w>noprompt</w>@timothypratley are you able to use <code>permuteo</code> without <code>:refer</code>? i.e. <code>logic/permuteo</code>.</z><z id="t1515490544000069" t="reefersleep I’ve got a hobby project building a Dominion ( https://boardgamegeek.com/boardgame/36218/dominion ) randomizer with a web interface. For those that don’t know Dominion, the purpose of a randomizer is to set up an initial game state by randomly picking 10 piles of cards from those piles available, with a few custom rules occasionally. That task is very simple in and of itself, but I’d like to make it possible for the end user to customize the randomization with certain parameters, like, “less than 5 piles must contain attack cards” and “1 of the piles must be a certain pile” and “more than 2 piles must be victory cards” (and probably more constraints will appear once the possibilities start unfolding 🙂 ). Is core.logic a good fit for something like this?"><y>#</y><d>2018-01-09</d><h>09:35</h><w>reefersleep</w>I’ve got a hobby project building a Dominion ( <a href="https://boardgamegeek.com/boardgame/36218/dominion" target="_blank">https://boardgamegeek.com/boardgame/36218/dominion</a> ) randomizer with a web interface. For those that don’t know Dominion, the purpose of a randomizer is to set up an initial game state by randomly picking 10 piles of cards from those piles available, with a few custom rules occasionally. That task is very simple in and of itself, but I’d like to make it possible for the end user to customize the randomization with certain parameters, like, “less than 5 piles must contain attack cards” and “1 of the piles must be a certain pile” and “more than 2 piles must be victory cards” (and probably more constraints will appear once the possibilities start unfolding <b>🙂</b> ). Is <code>core.logic</code> a good fit for something like this?</z><z id="t1515512835000174" t="timothypratley hi @noprompt 🙂 no, I am unable to use permuteo by qualifying it either."><y>#</y><d>2018-01-09</d><h>15:47</h><w>timothypratley</w>hi @noprompt <b>🙂</b> no, I am unable to use <code>permuteo</code> by qualifying it either.</z><z id="t1515512909000677" t="timothypratley @reefersleep IMO yes, perfect 🙂"><y>#</y><d>2018-01-09</d><h>15:48</h><w>timothypratley</w>@reefersleep IMO yes, perfect <b>🙂</b></z><z id="t1515519757000585" t="noprompt @timothypratley sounds like you’ve got a bug report to make! 😉"><y>#</y><d>2018-01-09</d><h>17:42</h><w>noprompt</w>@timothypratley sounds like you’ve got a bug report to make! <b>😉</b></z><z id="t1515520039000602" t="timothypratley hehehe okidoki"><y>#</y><d>2018-01-09</d><h>17:47</h><w>timothypratley</w>hehehe okidoki</z><z id="t1515575558000157" t="reefersleep @timothypratley thanks, I’ll give it a go then! I’ve been wanting an excuse to learn and use logic programmin anyway 😉"><y>#</y><d>2018-01-10</d><h>09:12</h><w>reefersleep</w>@timothypratley thanks, I’ll give it a go then! I’ve been wanting an excuse to learn and use logic programmin anyway <b>😉</b></z><z id="t1515575955000111" t="reefersleep I’ve been reading the examples https://github.com/clojure/core.logic/wiki/Examples and the Primer https://github.com/clojure/core.logic/wiki/A-Core.logic-Primer , so I think I get the gist of core.logic . But there are many functions in the namespace, and I don’t feel the docstrings https://clojure.github.io/core.logic/ get me all the way to understanding them. There are a lot of references in all kinds of directions in the wiki, but do you know of one(s) that explains the usage of core.logic (and core.logic.fd ) beyond the Primer?"><y>#</y><d>2018-01-10</d><h>09:19</h><w>reefersleep</w>I’ve been reading the examples <a href="https://github.com/clojure/core.logic/wiki/Examples" target="_blank">https://github.com/clojure/core.logic/wiki/Examples</a> and the Primer <a href="https://github.com/clojure/core.logic/wiki/A-Core.logic-Primer" target="_blank">https://github.com/clojure/core.logic/wiki/A-Core.logic-Primer</a>, so I think I get the gist of <code>core.logic</code>. But there are many functions in the namespace, and I don’t feel the docstrings <a href="https://clojure.github.io/core.logic/" target="_blank">https://clojure.github.io/core.logic/</a> get me all the way to understanding them. There are a lot of references in all kinds of directions in the wiki, but do you know of one(s) that explains the usage of <code>core.logic</code> (and  <code>core.logic.fd</code> ) beyond the Primer?</z><z id="t1515675418000271" t="reefersleep A guy at work told me I should just read up on MiniKanren, since core.logic is an implementation of that. So maybe William Byrd’s dissertation, as linked in the core.logic README http://pqdtopen.proquest.com/#abstract?dispub=3380156 , should be my go-to resource?"><y>#</y><d>2018-01-11</d><h>12:56</h><w>reefersleep</w>A guy at work told me I should just read up on MiniKanren, since <code>core.logic</code> is an implementation of that. So maybe William Byrd’s dissertation, as linked in the <code>core.logic</code> README <a href="http://pqdtopen.proquest.com/#abstract?dispub=3380156" target="_blank">http://pqdtopen.proquest.com/#abstract?dispub=3380156</a> , should be my go-to resource?</z><z id="t1515702404000257" t="dominicm @reefersleep Depending on your time, I understand that &quot;The Reasoned Schemer&quot; can be followed with core.logic with few exceptions."><y>#</y><d>2018-01-11</d><h>20:26</h><w>dominicm</w>@reefersleep Depending on your time, I understand that &quot;The Reasoned Schemer&quot; can be followed with core.logic with few exceptions.</z><z id="t1515703513000161" t="hiredman µKanren is also a thing now ( http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf ) which is a further reduced set of core primitives"><y>#</y><d>2018-01-11</d><h>20:45</h><w>hiredman</w>µKanren is also a thing now (<a href="http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf" target="_blank">http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf</a>) which is a further reduced set of core primitives</z><z id="t1515854772000022" t="reefersleep @dominicm cheers 🙂"><y>#</y><d>2018-01-13</d><h>14:46</h><w>reefersleep</w>@dominicm cheers <b>🙂</b></z><z id="t1515854787000019" t="reefersleep core.logic does not seem easily approachable!"><y>#</y><d>2018-01-13</d><h>14:46</h><w>reefersleep</w><code>core.logic</code> does not seem easily approachable!</z><z id="t1515950329000068" t="norman #understatement 🙂"><y>#</y><d>2018-01-14</d><h>17:18</h><w>norman</w>#understatement <b>🙂</b></z><z id="t1515950865000079" t="reefersleep So, I want to input a number of parameters, and have core.logic deliver some success scenarios to me. If I want to guarantee randomness among those scenarios, I’m guessing I can’t rely on core.logic ? That is - I have to take all of those success scenarios, and pick randomly among them, post run ."><y>#</y><d>2018-01-14</d><h>17:27</h><w>reefersleep</w>So, I want to input a number of parameters, and have <code>core.logic</code> deliver some success scenarios to me. If I want to guarantee randomness among those scenarios, I’m guessing I can’t rely on <code>core.logic</code>? That is - I have to take all of those success scenarios, and pick randomly among them, post <code>run</code>.</z><z id="t1515950905000005" t="reefersleep However, if sufficiently few parameters (they are all optional) are input, I predict that the number of success scenarios will be astronomic.."><y>#</y><d>2018-01-14</d><h>17:28</h><w>reefersleep</w>However, if sufficiently few parameters (they are all optional) are input, I predict that the number of success scenarios will be astronomic..</z><z id="t1515950921000084" t="reefersleep Is there a smart way to solve this"><y>#</y><d>2018-01-14</d><h>17:28</h><w>reefersleep</w>Is there a smart way to solve this</z><z id="t1515950922000056" t="reefersleep ?"><y>#</y><d>2018-01-14</d><h>17:28</h><w>reefersleep</w>?</z><z id="t1515967870000133" t="reefersleep To be clear; I’m expecting core.logic to output an astromonomic number of solutions. Ideally, I’d like the final result to be a completely random one of these solution. Since it may be that the entire corpus of solutions cannot fit in memory, ideally, I’d like core.logic to ensure randomness in its resulting seq of solutions, if possible. Can it? Or do I have to puzzle out some adequate post-`run*` randomization myself?"><y>#</y><d>2018-01-14</d><h>22:11</h><w>reefersleep</w>To be clear; I’m expecting <code>core.logic</code> to output an astromonomic number of solutions. Ideally, I’d like the final result to be a completely random one of these solution. Since it may be that the entire corpus of solutions cannot fit in memory, ideally, I’d like <code>core.logic</code> to ensure randomness in its resulting seq of solutions, if possible. Can it? Or do I have to puzzle out some adequate post-`run*` randomization myself?</z><z id="t1516078460000272" t="norman core.logic does not guarantee (or attempt to provide) randomness"><y>#</y><d>2018-01-16</d><h>04:54</h><w>norman</w>core.logic does not guarantee (or attempt to provide) randomness</z><z id="t1516094752000187" t="reefersleep Cheers @norman, that confirms my suspicion"><y>#</y><d>2018-01-16</d><h>09:25</h><w>reefersleep</w>Cheers @norman, that confirms my suspicion</z><z id="t1516094987000625" t="reefersleep So potentially, I can use core.logic to know whether there is a viable solution for my set of parameters or not, and, if I slack on the randomness, what such a solution could look like. Hm. I think it may still make sense to incorporate it in my program logic, but I have to think more about how 🙂"><y>#</y><d>2018-01-16</d><h>09:29</h><w>reefersleep</w>So potentially, I can use <code>core.logic</code> to know whether there is a viable solution for my set of parameters or not, and, if I slack on the randomness, what such a solution could look like. Hm. I think it may still make sense to incorporate it in my program logic, but I have to think more about how <b>🙂</b></z><z id="t1516121730000578" t="reefersleep In The Reasoned Schemer, definition 54 (of membero), I don&apos;t understand how the nullo line can be left out. From my perspective, this would then cause an infinite recursive loop in the &quot;else&quot; part."><y>#</y><d>2018-01-16</d><h>16:55</h><w>reefersleep</w>In The Reasoned Schemer, definition 54 (of membero), I don&apos;t understand how the nullo line can be left out. From my perspective, this would then cause an infinite recursive loop in the &quot;else&quot; part.</z><z id="t1516121800000652" t="reefersleep Maybe I don&apos;t fully understand cdro - I suppose that this should fail when given an empty list and a fresh lvar."><y>#</y><d>2018-01-16</d><h>16:56</h><w>reefersleep</w>Maybe I don&apos;t fully understand cdro - I suppose that this should fail when given an empty list and a fresh lvar.</z><z id="t1516122059000130" t="reefersleep Ah, I see, I think... I&apos;ll end up with (== (lvar1 lvar2) ()) or something to that effect inside the cdro body."><y>#</y><d>2018-01-16</d><h>17:00</h><w>reefersleep</w>Ah, I see, I think... I&apos;ll end up with (== (lvar1 lvar2) ()) or something to that effect inside the cdro body.</z><z id="t1516134132000714" t="reefersleep Thanks for rubber ducking, everyone 😄"><y>#</y><d>2018-01-16</d><h>20:22</h><w>reefersleep</w>Thanks for rubber ducking, everyone <b>😄</b></z><z id="t1516134280000103" t="reefersleep What can one use instead of everyg in Clojurescript core.logic ?"><y>#</y><d>2018-01-16</d><h>20:24</h><w>reefersleep</w>What can one use instead of <code>everyg</code> in Clojurescript <code>core.logic</code>?</z><z id="t1518220968000135" t="Justin hey, I am extremely-not a logical programming pro, I&apos;ve been trying to use core.logic to generate test cases with somewhat complex constraints, and it works pretty decently for the most part as far as being a nice way to specify my constraints. the problem I&apos;m facing now is that it tends to get stuck in particular branches of the search tree, when in reality I&apos;d like to do something of a uniform-ish (for some meaning of uniform) sampling of the search tree - is there a way of doing this kind of thing in core.logic or am I using the wrong tool?"><y>#</y><d>2018-02-10</d><h>00:02</h><w>Justin</w>hey, I am extremely-not a logical programming pro, I&apos;ve been trying to use core.logic to generate test cases with somewhat complex constraints, and it works pretty decently for the most part as far as being a nice way to specify my constraints. the problem I&apos;m facing now is that it tends to get stuck in particular branches of the search tree, when in reality I&apos;d like to do something of a uniform-ish (for some meaning of uniform) sampling of the search tree - is there a way of doing this kind of thing in core.logic or am I using the wrong tool?</z><z id="t1518221415000078" t="hiredman what do you mean by stuck?"><y>#</y><d>2018-02-10</d><h>00:10</h><w>hiredman</w>what do you mean by stuck?</z><z id="t1518221464000075" t="hiredman core.logic uses a sort of streaming interleaving technique to avoid getting stuck in divergent goals"><y>#</y><d>2018-02-10</d><h>00:11</h><w>hiredman</w>core.logic uses a sort of streaming interleaving technique to avoid getting stuck in divergent goals</z><z id="t1518221641000159" t="Justin so I guess it&apos;s possible that I don&apos;t fully understand my problem 🙂 I guess what I&apos;m seeing more concretely is like, the DFS is very observable in the output of my program"><y>#</y><d>2018-02-10</d><h>00:14</h><w>Justin</w>so I guess it&apos;s possible that I don&apos;t fully understand my problem <b>🙂</b> I guess what I&apos;m seeing more concretely is like, the DFS is very observable in the output of my program</z><z id="t1518221673000166" t="Justin perhaps &quot;stuck&quot; was the wrong word - it is finding plenty of solutions, I would like to somehow have a way of generating more varied solutions"><y>#</y><d>2018-02-10</d><h>00:14</h><w>Justin</w>perhaps &quot;stuck&quot; was the wrong word - it is finding plenty of solutions, I would like to somehow have a way of generating more varied solutions</z><z id="t1518221745000244" t="hiredman it will depend on the structure of your goals, but if you have a recursive goal that never reaches a base case for example, core.logic will still search other branches around that goal"><y>#</y><d>2018-02-10</d><h>00:15</h><w>hiredman</w>it will depend on the structure of your goals, but if you have a recursive goal that never reaches a base case for example, core.logic will still search other branches around that goal</z><z id="t1518221774000221" t="hiredman core.logic will generate every possible solution"><y>#</y><d>2018-02-10</d><h>00:16</h><w>hiredman</w>core.logic will generate every possible solution</z><z id="t1518221801000307" t="hiredman but you have little to no control of the order in which it generates them"><y>#</y><d>2018-02-10</d><h>00:16</h><w>hiredman</w>but you have little to no control of the order in which it generates them</z><z id="t1518221982000152" t="Justin I see, and there&apos;s no way I can say. limit the number of solutions that are reported from a particular branch?"><y>#</y><d>2018-02-10</d><h>00:19</h><w>Justin</w>I see, and there&apos;s no way I can say. limit the number of solutions that are reported from a particular branch?</z><z id="t1518222000000251" t="hiredman no"><y>#</y><d>2018-02-10</d><h>00:20</h><w>hiredman</w>no</z><z id="t1518222018000313" t="Justin i see, ok, thanks"><y>#</y><d>2018-02-10</d><h>00:20</h><w>Justin</w>i see, ok, thanks</z><z id="t1518222067000152" t="hiredman you may want to look at test.check or data.generators, or spec for generating test cases"><y>#</y><d>2018-02-10</d><h>00:21</h><w>hiredman</w>you may want to look at test.check or data.generators, or spec for generating test cases</z><z id="t1518222179000295" t="Justin I haven&apos;t looked at test.check specifically but none of the quickcheck-likes I investigated seemed to allow me to do the same kind of branching search and goal-specifying that a prolog-like would"><y>#</y><d>2018-02-10</d><h>00:22</h><w>Justin</w>I haven&apos;t looked at test.check specifically but none of the quickcheck-likes I investigated seemed to allow me to do the same kind of branching search and goal-specifying that a prolog-like would</z><z id="t1518222186000043" t="Justin I feel like what I really want is some hybrid of those"><y>#</y><d>2018-02-10</d><h>00:23</h><w>Justin</w>I feel like what I really want is some hybrid of those</z><z id="t1518222304000155" t="hiredman of course I don&apos;t know what you are generating, but I would be surprised you couldn&apos;t do it via test.check"><y>#</y><d>2018-02-10</d><h>00:25</h><w>hiredman</w>of course I don&apos;t know what you are generating, but I would be surprised you couldn&apos;t do it via test.check</z><z id="t1518222355000133" t="Justin ok, I will investigate that, thanks for the assistance"><y>#</y><d>2018-02-10</d><h>00:25</h><w>Justin</w>ok, I will investigate that, thanks for the assistance</z><z id="t1519509067000167" t="rapskalian Hi all, I&apos;m currently making my way through The Reasoned Schemer and have hit a bit of a block upon reaching chapter 4. I&apos;m noticing that &quot;the second commandment&quot; produces logic functions that don&apos;t actually result in valid solutions. Especially in the case of rembero , e.g. frame 49. I skipped ahead a few pages to find the definition of surpriso , in which the book does admit that something strange is going on, but it wasn&apos;t followed with any kind of explanation as to a fix to this issue. Chapter 5 seems to continue right along without an explanation either... Anyone else encounter this?"><y>#</y><d>2018-02-24</d><h>21:51</h><w>rapskalian</w>Hi all, I&apos;m currently making my way through The Reasoned Schemer and have hit a bit of a block upon reaching chapter 4. I&apos;m noticing that &quot;the second commandment&quot; produces logic functions that don&apos;t actually result in valid solutions. Especially in the case of <code>rembero</code>, e.g. frame 49. I skipped ahead a few pages to find the definition of <code>surpriso</code>, in which the book does admit that something strange is going on, but it wasn&apos;t followed with any kind of explanation as to a fix to this issue. Chapter 5 seems to continue right along without an explanation either...
Anyone else encounter this?</z><z id="t1519509241000061" t="rapskalian Quick example to illustrate the point: (defn rembero [x l out] (conde [(emptyo l) (== out &apos;())] [(eq-firsto l x) (resto l out)] [s# (fresh [a d res] (conso a d l) (rembero x d res) (conso a res out))])) (run* [r] (fresh [y z] (rembero y (list y &apos;d z &apos;e) (list y &apos;d &apos;e)) (== (list y z) r))) ;; =&gt; ((d d) ;; (d d) ;; (_0 _0) ;; (e e)) "><y>#</y><d>2018-02-24</d><h>21:54</h><w>rapskalian</w>Quick example to illustrate the point:
<pre>(defn rembero
  [x l out]
  (conde
   [(emptyo l) (== out &apos;())]
   [(eq-firsto l x) (resto l out)]
   [s# (fresh [a d res]
         (conso a d l)
         (rembero x d res)
         (conso a res out))]))

(run* [r]
  (fresh [y z]
    (rembero y (list y &apos;d z &apos;e) (list y &apos;d &apos;e))
    (== (list y z) r)))
;; =&gt; ((d d)
;;     (d d)
;;     (_0 _0)
;;     (e e))
</pre></z><z id="t1519509276000022" t="rapskalian The last two solutions ((_0 _0) (e e)) don&apos;t satisfy the original constraint..."><y>#</y><d>2018-02-24</d><h>21:54</h><w>rapskalian</w>The last two solutions <code>((_0 _0) (e e))</code> don&apos;t satisfy the original constraint...</z><z id="t1519509611000097" t="rapskalian Ah, I found this thread https://groups.google.com/forum/#!topic/clojure/_z6-ZDiPh6A But no satisfying reply has yet been posted. @dnolen looks like maybe you came up against this issue as well (albeit years ago). Did you ever reach a satisfying conclusion?"><y>#</y><d>2018-02-24</d><h>22:00</h><w>rapskalian</w>Ah, I found this thread <a href="https://groups.google.com/forum/#!topic/clojure/_z6-ZDiPh6A" target="_blank">https://groups.google.com/forum/#!topic/clojure/_z6-ZDiPh6A</a>
But no satisfying reply has yet been posted. @dnolen looks like maybe you came up against this issue as well (albeit years ago). Did you ever reach a satisfying conclusion?</z><z id="t1519667175000794" t="rapskalian Looks like the solution is to use the != function, as described here: https://groups.google.com/forum/#!topic/minikanren/JCKJV7k7lGU"><y>#</y><d>2018-02-26</d><h>17:46</h><w>rapskalian</w>Looks like the solution is to use the <code>!=</code> function, as described here: <a href="https://groups.google.com/forum/#!topic/minikanren/JCKJV7k7lGU" target="_blank">https://groups.google.com/forum/#!topic/minikanren/JCKJV7k7lGU</a></z><z id="t1519667483000187" t="rapskalian Turns out rembero is a core.logic function already as well, in case anyone is interested: (defne rembero &quot;A relation between l and o where x is removed from l exactly one time.&quot; [x l o] ([_ [x . xs] xs]) ([_ [y . ys] [y . zs]] (!= y x) (rembero x ys zs))) "><y>#</y><d>2018-02-26</d><h>17:51</h><w>rapskalian</w>Turns out <code>rembero</code> is a core.logic function already as well, in case anyone is interested:
<pre>(defne rembero
  &quot;A relation between l and o where x is removed from
   l exactly one time.&quot;
  [x l o]
  ([_ [x . xs] xs])
  ([_ [y . ys] [y . zs]]
     (!= y x)
     (rembero x ys zs)))
</pre></z><z id="t1519785391000029" t="devn @cjsauer out of curiosity which version of the reasoned schemer?"><y>#</y><d>2018-02-28</d><h>02:36</h><w>devn</w>@cjsauer out of curiosity which version of the reasoned schemer?</z><z id="t1519833372000746" t="rapskalian @devn this is the first edition text (2005). I noticed that there is a second edition being released soon here ( https://mitpress.mit.edu/books/reasoned-schemer-0 )"><y>#</y><d>2018-02-28</d><h>15:56</h><w>rapskalian</w>@devn this is the first edition text (2005). I noticed that there is a second edition being released soon here (<a href="https://mitpress.mit.edu/books/reasoned-schemer-0" target="_blank">https://mitpress.mit.edu/books/reasoned-schemer-0</a>)</z><z id="t1519923961000449" t="devn @cjsauer ah, i have a draft copy of that if you&apos;re looking for what it says on a particular page"><y>#</y><d>2018-03-01</d><h>17:06</h><w>devn</w>@cjsauer ah, i have a draft copy of that if you&apos;re looking for what it says on a particular page</z><z id="t1519945049000207" t="rapskalian @devn ooh very nice. I&apos;m most curious about the 4th chapter...does it still end in a &quot;surprise&quot; as they called it? Or have they now included the != catch mentioned above?"><y>#</y><d>2018-03-01</d><h>22:57</h><w>rapskalian</w>@devn ooh very nice. I&apos;m most curious about the 4th chapter...does it still end in a &quot;surprise&quot; as they called it? Or have they now included the <code>!=</code> catch mentioned above?</z><z id="t1519969479000114" t="devn @cjsauer remind me to peek tomorrow? (DMs are fine)"><y>#</y><d>2018-03-02</d><h>05:44</h><w>devn</w>@cjsauer remind me to peek tomorrow? (DMs are fine)</z><z id="t1521029294000387" t="andrea.crotti I&apos;m trying to solve a problem which I think is a good fit for core.logic"><y>#</y><d>2018-03-14</d><h>12:08</h><w>andrea.crotti</w>I&apos;m trying to solve a problem which I think is a good fit for core.logic</z><z id="t1521029314000172" t="andrea.crotti in short given various groups of people and a set of tables for 10 people each"><y>#</y><d>2018-03-14</d><h>12:08</h><w>andrea.crotti</w>in short given various groups of people and a set of tables for 10 people each</z><z id="t1521029340000147" t="andrea.crotti place the various groups in the various tables trying to maximize the space used, not splitting groups and possibly a few other constraints"><y>#</y><d>2018-03-14</d><h>12:09</h><w>andrea.crotti</w>place the various groups in the various tables trying to maximize the space used, not splitting groups and possibly a few other constraints</z><z id="t1521029382000457" t="andrea.crotti but for example I don&apos;t see anything in the API to add constraints on the length of the produced vector"><y>#</y><d>2018-03-14</d><h>12:09</h><w>andrea.crotti</w>but for example I don&apos;t see anything in the API to add constraints on the length of the produced vector</z><z id="t1521460521000390" t="abdullahibra is it possible make core.logic works on existing data say in sql database ?"><y>#</y><d>2018-03-19</d><h>11:55</h><w>abdullahibra</w>is it possible make core.logic works on existing data say in sql database ?</z><z id="t1521697919000186" t="xtreak29 Came across this that might be interesting : https://www.youtube.com/watch?v=HHZ8iqswiCw"><y>#</y><d>2018-03-22</d><h>05:51</h><r>xtreak29</r>Came across this that might be interesting : <a href="https://www.youtube.com/watch?v=HHZ8iqswiCw" target="_blank">https://www.youtube.com/watch?v=HHZ8iqswiCw</a></z><z id="t1521461165000459" t="xtreak29 Some helpful links : https://stackoverflow.com/questions/14529965/how-do-i-connect-clojure-core-logic-to-a-database https://github.com/clojure/core.logic/wiki/Extending-core.logic-%28Datomic-example%29 https://groups.google.com/forum/#!topic/clojure/YUNpTSS65Pc"><y>#</y><d>2018-03-19</d><h>12:06</h><w>xtreak29</w>Some helpful links : 
<a href="https://stackoverflow.com/questions/14529965/how-do-i-connect-clojure-core-logic-to-a-database" target="_blank">https://stackoverflow.com/questions/14529965/how-do-i-connect-clojure-core-logic-to-a-database</a>
<a href="https://github.com/clojure/core.logic/wiki/Extending-core.logic-%28Datomic-example%29" target="_blank">https://github.com/clojure/core.logic/wiki/Extending-core.logic-%28Datomic-example%29</a>
<a href="https://groups.google.com/forum/#!topic/clojure/YUNpTSS65Pc" target="_blank">https://groups.google.com/forum/#!topic/clojure/YUNpTSS65Pc</a></z><z id="t1521461262000226" t="abdullahibra @xtreak29 very good thanks"><y>#</y><d>2018-03-19</d><h>12:07</h><w>abdullahibra</w>@xtreak29 very good thanks</z><z id="t1521524754000073" t="benzap Would you recommend learning prolog before learning core.logic? What&apos;s the best course of action?"><y>#</y><d>2018-03-20</d><h>05:45</h><w>benzap</w>Would you recommend learning prolog before learning core.logic? What&apos;s the best course of action?</z><z id="t1521525399000202" t="xtreak29 I tried prolog initially because it had a better syntax IMO but core.logic seemed to offer the same as I looked into it. There is an online REPL to write prolog without installing anything. SWI prolog is the recommended implementation. I used &quot;learn prolog now&quot; which is introductory and good. I wrote some basic programs in prolog to find relations and so on. Online repl : https://swish.swi-prolog.org/ Learn prolog now : http://learnprolognow.org/ Solving graph coloring problem in prolog : https://bernardopires.com/2013/10/try-logic-programming-a-gentle-introduction-to-prolog/ My experience with prolog and core.logic (Shameless plug) : https://tirkarthi.github.io/clojure/2017/10/28/coloring-india.html In case you want a full fledged book the art of prolog is said to be a good one : https://mitpress.mit.edu/books/art-prolog I am curious about others perspective on this."><y>#</y><d>2018-03-20</d><h>05:56</h><w>xtreak29</w>I tried prolog initially because it had a better syntax IMO but core.logic seemed to offer the same as I looked into it. There is an online REPL to write prolog without installing anything. SWI prolog is the recommended implementation. I used &quot;learn prolog now&quot; which is introductory and good. I wrote some basic programs in prolog to find relations and so on. 

Online repl : <a href="https://swish.swi-prolog.org/" target="_blank">https://swish.swi-prolog.org/</a>
Learn prolog now : <a href="http://learnprolognow.org/" target="_blank">http://learnprolognow.org/</a>
Solving graph coloring problem in prolog : <a href="https://bernardopires.com/2013/10/try-logic-programming-a-gentle-introduction-to-prolog/" target="_blank">https://bernardopires.com/2013/10/try-logic-programming-a-gentle-introduction-to-prolog/</a>
My experience with prolog and core.logic (Shameless plug) : <a href="https://tirkarthi.github.io/clojure/2017/10/28/coloring-india.html" target="_blank">https://tirkarthi.github.io/clojure/2017/10/28/coloring-india.html</a>

In case you want a full fledged book the art of prolog is said to be a good one : <a href="https://mitpress.mit.edu/books/art-prolog" target="_blank">https://mitpress.mit.edu/books/art-prolog</a>

I am curious about others perspective on this.</z><z id="t1521535705000320" t="benzap I have a few books on logic programming that I should probably go through"><y>#</y><d>2018-03-20</d><h>08:48</h><w>benzap</w>I have a few books on logic programming that I should probably go through</z><z id="t1521535729000222" t="benzap I&apos;m going to check out that http://learnprolognow.org"><y>#</y><d>2018-03-20</d><h>08:48</h><w>benzap</w>I&apos;m going to check out that <a href="http://learnprolognow.org" target="_blank">http://learnprolognow.org</a></z><z id="t1521535851000239" t="benzap so far i&apos;ve been able to get a swig prolog repl working in emacs, which is a godsend 🙂"><y>#</y><d>2018-03-20</d><h>08:50</h><w>benzap</w>so far i&apos;ve been able to get a swig prolog repl working in emacs, which is a godsend <b>🙂</b></z><z id="t1521689330000148" t="benzap So I got through http://learnprolognow.org , and the blog post which introduces core.logic is very well done. I&apos;m thinking I might try and do the http://learnprolognow.org exercises in core.logic, I was able to get through quite a few of them fairly easily with only a few misunderstandings"><y>#</y><d>2018-03-22</d><h>03:28</h><w>benzap</w>So I got through <a href="http://learnprolognow.org" target="_blank">http://learnprolognow.org</a>, and the blog post which introduces core.logic is very well done. I&apos;m thinking I might try and do the <a href="http://learnprolognow.org" target="_blank">http://learnprolognow.org</a> exercises in core.logic, I was able to get through quite a few of them fairly easily with only a few misunderstandings</z><z id="t1521831466000787" t="ajs Where is that blog post?"><y>#</y><d>2018-03-23</d><h>18:57</h><r>ajs</r>Where is that blog post?</z><z id="t1521972761000049" t="benzap Ah sorry, just caught this, here you go https://bernardopires.com/2013/10/try-logic-programming-a-gentle-introduction-to-prolog/"><y>#</y><d>2018-03-25</d><h>10:12</h><r>benzap</r>Ah sorry, just caught this, here you go


<a href="https://bernardopires.com/2013/10/try-logic-programming-a-gentle-introduction-to-prolog/" target="_blank">https://bernardopires.com/2013/10/try-logic-programming-a-gentle-introduction-to-prolog/</a></z><z id="t1521972763000074" t="benzap https://tirkarthi.github.io/clojure/2017/10/28/coloring-india.html"><y>#</y><d>2018-03-25</d><h>10:12</h><r>benzap</r><a href="https://tirkarthi.github.io/clojure/2017/10/28/coloring-india.html" target="_blank">https://tirkarthi.github.io/clojure/2017/10/28/coloring-india.html</a></z><z id="t1521972783000004" t="benzap The second one is the india coloring problem done in core.logic"><y>#</y><d>2018-03-25</d><h>10:13</h><r>benzap</r>The second one is the india coloring problem done in core.logic</z><z id="t1522012880000083" t="ajs Thanx!"><y>#</y><d>2018-03-25</d><h>21:21</h><r>ajs</r>Thanx!</z><z id="t1521689363000277" t="benzap I kind of skipped the Definite Clause Grammars section of the book, is it really necessary? http://learnprolognow.org/lpnpage.php?pagetype=html&amp;amp;pageid=lpn-htmlch7"><y>#</y><d>2018-03-22</d><h>03:29</h><w>benzap</w>I kind of skipped the Definite Clause Grammars section of the book, is it really necessary? <a href="http://learnprolognow.org/lpnpage.php?pagetype=html&amp;amp;pageid=lpn-htmlch7" target="_blank">http://learnprolognow.org/lpnpage.php?pagetype=html&amp;amp;pageid=lpn-htmlch7</a></z><z id="t1521689455000041" t="benzap Kindof skimmed over the Cuts, green cuts, red cuts, and negation stuff as well, but i&apos;m probably going to come back to that"><y>#</y><d>2018-03-22</d><h>03:30</h><w>benzap</w>Kindof skimmed over the Cuts, green cuts, red cuts, and negation stuff as well, but i&apos;m probably going to come back to that</z><z id="t1521697841000047" t="xtreak29 Thanks, I haven&apos;t read the learnprolognow completely. If you want more info and lispish content there is https://mitpress.mit.edu/books/reasoned-schemer and the last chapter on SICP I think implements a logic programming DSL from scratch using Scheme."><y>#</y><d>2018-03-22</d><h>05:50</h><w>xtreak29</w>Thanks, I haven&apos;t read the learnprolognow completely. If you want more info and lispish content there is <a href="https://mitpress.mit.edu/books/reasoned-schemer" target="_blank">https://mitpress.mit.edu/books/reasoned-schemer</a> and the last chapter on  SICP I think implements a logic programming DSL from scratch using Scheme.</z><z id="t1528981867000147" t="mrchance Is it possible to define a lookup relation for map keys, similar to (geto k m v) ? I saw that maps unify only over values, so this might be hard."><y>#</y><d>2018-06-14</d><h>13:11</h><w>mrchance</w>Is it possible to define a lookup relation for map keys, similar to <code>(geto k m v)</code> ? I saw that maps unify only over values, so this might be hard.</z><z id="t1529012606000577" t="mrchance Okay, (defn geto [m k v] (featurec m {k v})) Seems to do the trick, at least when k really is a keyword. I don&apos;t understand why it&apos;s limited to values though"><y>#</y><d>2018-06-14</d><h>21:43</h><w>mrchance</w>Okay,
<pre>(defn geto [m k v]
  (featurec m {k v}))
</pre>
Seems to do the trick, at least when k really is a keyword. I don&apos;t understand why it&apos;s limited to values though</z><z id="t1529013349000145" t="hiredman it is very tricky"><y>#</y><d>2018-06-14</d><h>21:55</h><w>hiredman</w>it is very tricky</z><z id="t1529013384000437" t="hiredman if k is a key in m, and v is a value in m, and q unifies with m, what values does q have?"><y>#</y><d>2018-06-14</d><h>21:56</h><w>hiredman</w>if k is a key in m, and v is a value in m, and q unifies with m, what values does q have?</z><z id="t1529013452000274" t="hiredman (values in the sense of, what are the possible values of q)"><y>#</y><d>2018-06-14</d><h>21:57</h><w>hiredman</w>(values in the sense of, what are the possible values of q)</z><z id="t1529013478000434" t="mrchance Hmm, I&apos;d assume all values that (featurec m {k v}) produces? 😉"><y>#</y><d>2018-06-14</d><h>21:57</h><w>mrchance</w>Hmm, I&apos;d assume all values that <code>(featurec m {k v})</code> produces? <b>😉</b></z><z id="t1529013515000325" t="hiredman it is trivial to determine the values when keys are ground"><y>#</y><d>2018-06-14</d><h>21:58</h><w>hiredman</w>it is trivial to determine the values  when keys are ground</z><z id="t1529013537000182" t="mrchance What do you mean by ground?"><y>#</y><d>2018-06-14</d><h>21:58</h><w>mrchance</w>What do you mean by ground?</z><z id="t1529013546000444" t="hiredman a concrete value"><y>#</y><d>2018-06-14</d><h>21:59</h><w>hiredman</w>a concrete value</z><z id="t1529013557000327" t="hiredman a known keyword"><y>#</y><d>2018-06-14</d><h>21:59</h><w>hiredman</w>a known keyword</z><z id="t1529013565000029" t="mrchance Ok"><y>#</y><d>2018-06-14</d><h>21:59</h><w>mrchance</w>Ok</z><z id="t1529013572000399" t="hiredman (as opposed to a logic variable with an unknown value)"><y>#</y><d>2018-06-14</d><h>21:59</h><w>hiredman</w>(as opposed to a logic variable with an unknown value)</z><z id="t1529013587000458" t="mrchance Yeah, got it"><y>#</y><d>2018-06-14</d><h>21:59</h><w>mrchance</w>Yeah, got it</z><z id="t1529013620000383" t="hiredman basically you can&apos;t use just a clojure map to represent that"><y>#</y><d>2018-06-14</d><h>22:00</h><w>hiredman</w>basically you can&apos;t use just a clojure map to represent that</z><z id="t1529013652000181" t="hiredman you need some more complicated datastructure that understands unification and can do things like merge keys that are unified"><y>#</y><d>2018-06-14</d><h>22:00</h><w>hiredman</w>you need some more complicated datastructure that understands unification and can do things like merge keys that are unified</z><z id="t1529013685000205" t="hiredman like if you say (get m k v) (get m y x) (== y k)"><y>#</y><d>2018-06-14</d><h>22:01</h><w>hiredman</w>like if you say (get m k v) (get m y x) (== y k)</z><z id="t1529013700000035" t="hiredman uh, geto"><y>#</y><d>2018-06-14</d><h>22:01</h><w>hiredman</w>uh, geto</z><z id="t1529013707000239" t="mrchance Hm, so it would be possible, but only if I converted my maps to that richer datastructure before?"><y>#</y><d>2018-06-14</d><h>22:01</h><w>mrchance</w>Hm, so it would be possible, but only if I converted my maps to that richer datastructure before?</z><z id="t1529013732000002" t="mrchance And I&apos;d have to make it extend the unification protocol?"><y>#</y><d>2018-06-14</d><h>22:02</h><w>mrchance</w>And I&apos;d have to make it extend the unification protocol?</z><z id="t1529013740000031" t="hiredman I am not sure"><y>#</y><d>2018-06-14</d><h>22:02</h><w>hiredman</w>I am not sure</z><z id="t1529013832000081" t="hiredman I feel like I was reading a paper on unifying maps recently"><y>#</y><d>2018-06-14</d><h>22:03</h><w>hiredman</w>I feel like I was reading a paper on unifying maps recently</z><z id="t1529013869000143" t="mrchance Really? Nice coincidence then 🙂"><y>#</y><d>2018-06-14</d><h>22:04</h><w>mrchance</w>Really? Nice coincidence then <b>🙂</b></z><z id="t1529013870000105" t="hiredman oh, no, it was clp(set)"><y>#</y><d>2018-06-14</d><h>22:04</h><w>hiredman</w>oh, no, it was clp(set)</z><z id="t1529013878000360" t="mrchance Ah, ok"><y>#</y><d>2018-06-14</d><h>22:04</h><w>mrchance</w>Ah, ok</z><z id="t1529013880000521" t="hiredman but I think that would be really similar"><y>#</y><d>2018-06-14</d><h>22:04</h><w>hiredman</w>but I think that would be really similar</z><z id="t1529013896000173" t="hiredman e.g. you would represent the map as a set of k/v pairs"><y>#</y><d>2018-06-14</d><h>22:04</h><w>hiredman</w>e.g. you would represent the map as a set of k/v pairs</z><z id="t1529013929000017" t="hiredman https://github.com/clojure/core.logic/wiki/CLP(Set)"><y>#</y><d>2018-06-14</d><h>22:05</h><w>hiredman</w><a href="https://github.com/clojure/core.logic/wiki/CLP(Set)" target="_blank">https://github.com/clojure/core.logic/wiki/CLP(Set)</a></z><z id="t1529013954000116" t="hiredman there is a scheme implementation somewhere that needs porting"><y>#</y><d>2018-06-14</d><h>22:05</h><w>hiredman</w>there is a scheme implementation somewhere that needs porting</z><z id="t1529013991000450" t="mrchance Hm yeah, it looks like this would do it, if it were implemented, which it doesn&apos;t seem to be 😄"><y>#</y><d>2018-06-14</d><h>22:06</h><w>mrchance</w>Hm yeah, it looks like this would do it, if it were implemented, which it doesn&apos;t seem to be <b>😄</b></z><z id="t1529013998000048" t="hiredman https://github.com/namin/clpset-miniKanren"><y>#</y><d>2018-06-14</d><h>22:06</h><w>hiredman</w><a href="https://github.com/namin/clpset-miniKanren" target="_blank">https://github.com/namin/clpset-miniKanren</a></z><z id="t1529014014000025" t="hiredman (the link to the paper is in the readme on that repo)"><y>#</y><d>2018-06-14</d><h>22:06</h><w>hiredman</w>(the link to the paper is in the readme on that repo)</z><z id="t1529014125000016" t="mrchance Hm, that looks more like a weekend-y kind of thing 😉"><y>#</y><d>2018-06-14</d><h>22:08</h><w>mrchance</w>Hm, that looks more like a weekend-y kind of thing <b>😉</b></z><z id="t1529014161000155" t="mrchance I wouldn&apos;t mind a simpler way to achieve my goal, which is basically have an interpreter for a very simple language"><y>#</y><d>2018-06-14</d><h>22:09</h><w>mrchance</w>I wouldn&apos;t mind a simpler way to achieve my goal, which is basically have an interpreter for a very simple language</z><z id="t1529014216000005" t="hiredman I think the scheme guys just use a list of pairs"><y>#</y><d>2018-06-14</d><h>22:10</h><w>hiredman</w>I think the scheme guys just use a list of pairs</z><z id="t1529014236000319" t="mrchance Yeah, that might be the way to go for now"><y>#</y><d>2018-06-14</d><h>22:10</h><w>mrchance</w>Yeah, that might be the way to go for now</z><z id="t1529014303000238" t="mrchance Thanks, I&apos;ll try that"><y>#</y><d>2018-06-14</d><h>22:11</h><w>mrchance</w>Thanks, I&apos;ll try that</z><z id="t1529014317000043" t="mrchance Also read the paper when I have a moment, which might be a while 😉"><y>#</y><d>2018-06-14</d><h>22:11</h><w>mrchance</w>Also read the paper when I have a moment, which might be a while <b>😉</b></z><z id="t1531410125000412" t="bajrachar Is it possible to replace pldb in core logic with something like lmdb and if so how do I go about doing so"><y>#</y><d>2018-07-12</d><h>15:42</h><w>bajrachar</w>Is it possible to replace pldb in core logic with something like lmdb and if so how do I go about doing so</z><z id="t1531410279000120" t="bajrachar I did see this - https://github.com/clojure/core.logic/wiki/Extending-core.logic-(Datomic-example)"><y>#</y><d>2018-07-12</d><h>15:44</h><w>bajrachar</w>I did see this - <a href="https://github.com/clojure/core.logic/wiki/Extending-core.logic-(Datomic-example)" target="_blank">https://github.com/clojure/core.logic/wiki/Extending-core.logic-(Datomic-example)</a></z><z id="t1531410332000218" t="bajrachar having trouble particularly loading a large data set in memory with pldb"><y>#</y><d>2018-07-12</d><h>15:45</h><w>bajrachar</w>having trouble particularly loading a large data set in memory with pldb</z><z id="t1531410383000329" t="norman how large is large? We use pldb with very large data sets"><y>#</y><d>2018-07-12</d><h>15:46</h><w>norman</w>how large is large? We use pldb with very large data sets</z><z id="t1531410429000567" t="norman But obviously not so large that we can’t load it in memory"><y>#</y><d>2018-07-12</d><h>15:47</h><w>norman</w>But obviously not so large that we can’t load it in memory</z><z id="t1531410713000649" t="bajrachar well the size of the file I am loading from is close to 6GB"><y>#</y><d>2018-07-12</d><h>15:51</h><w>bajrachar</w>well the size of the file I am loading from is close to 6GB</z><z id="t1531410757000407" t="bajrachar When I add in the facts - it blows up all the way up to 19GB in memory"><y>#</y><d>2018-07-12</d><h>15:52</h><w>bajrachar</w>When I add in the facts - it blows up all the way up to 19GB in memory</z><z id="t1531410799000384" t="bajrachar This could be due to intermediates created via clojure data structures?"><y>#</y><d>2018-07-12</d><h>15:53</h><w>bajrachar</w>This could be due to intermediates created via clojure data structures?</z><z id="t1531411011000502" t="norman Are you indexing a lot? There’s a lot of work to create the in memory index"><y>#</y><d>2018-07-12</d><h>15:56</h><w>norman</w>Are you indexing a lot? There’s a lot of work to create the in memory index</z><z id="t1531411053000272" t="norman I did not optimize that code for memory efficiency."><y>#</y><d>2018-07-12</d><h>15:57</h><w>norman</w>I did not optimize that code for memory efficiency.</z><z id="t1531411087000389" t="bajrachar Yes I do have few indices"><y>#</y><d>2018-07-12</d><h>15:58</h><w>bajrachar</w>Yes I do have few indices</z><z id="t1531411092000153" t="norman I would say our “large” is 100-1000MB, which is definitely a lot less than your “large”"><y>#</y><d>2018-07-12</d><h>15:58</h><w>norman</w>I would say our “large” is 100-1000MB, which is definitely a lot less than your “large”</z><z id="t1531411154000207" t="norman At some point an actual database is better. I don’t think that example is current, and if I recall it wasn’t actually a very good example"><y>#</y><d>2018-07-12</d><h>15:59</h><w>norman</w>At some point an actual database is better. I don’t think that example is current, and if I recall it wasn’t actually a very good example</z><z id="t1531411276000347" t="norman I probably can’t help too much though. I wrote pldb, but our use of core.logic and pldb has been stable for many years now, so it’s not code I touch on a day to day basis anymore. And since core.logic is under the clojure CA and dev process, I haven’t been terribly motivated to actively contribute"><y>#</y><d>2018-07-12</d><h>16:01</h><w>norman</w>I probably can’t help too much though. I wrote pldb, but our use of core.logic and pldb has been stable for many years now, so it’s not code I touch on a day to day basis anymore. And since core.logic is under the clojure CA and dev process, I haven’t been terribly motivated to actively contribute</z><z id="t1531411346000067" t="bajrachar I think the size bloat could be due to indexing as you pointed out - maybe I can play around with it and see if it reduces further"><y>#</y><d>2018-07-12</d><h>16:02</h><w>bajrachar</w>I think the size bloat could be due to indexing as you pointed out - maybe I can play around with it and see if it reduces further</z><z id="t1531411409000240" t="norman If you don’t need them, then remove them. But if you do, you’ll just be trading memory for CPU"><y>#</y><d>2018-07-12</d><h>16:03</h><w>norman</w>If you don’t need them, then remove them. But if you do, you’ll just be trading memory for CPU</z><z id="t1531411467000095" t="bajrachar Also I&apos;ve realized that clojure data structures by default occupy quite a bit of memory when operated on - unless we use transient"><y>#</y><d>2018-07-12</d><h>16:04</h><w>bajrachar</w>Also I&apos;ve realized that clojure data structures by default occupy quite a bit of memory when operated on - unless we use transient</z><z id="t1531411496000476" t="bajrachar so - I will also try if I serialize the db to disk and read back from it - if that reduces the size"><y>#</y><d>2018-07-12</d><h>16:04</h><w>bajrachar</w>so - I will also try if I serialize the db to disk and read back from it - if that reduces the size</z><z id="t1531411519000505" t="norman I’m fairly certain the pldb code does not do that, but it might. It’s been a loong time 🙂"><y>#</y><d>2018-07-12</d><h>16:05</h><w>norman</w>I’m fairly certain the pldb code does not do that, but it might. It’s been a loong time <b>🙂</b></z><z id="t1531411543000511" t="norman You can definitely serialize it. At one point we were saving pldbs in riak"><y>#</y><d>2018-07-12</d><h>16:05</h><w>norman</w>You can definitely serialize it. At one point we were saving pldbs in riak</z><z id="t1531411558000068" t="hiredman if anything, serializing it will make it larger"><y>#</y><d>2018-07-12</d><h>16:05</h><w>hiredman</w>if anything, serializing it will make it larger</z><z id="t1531411558000122" t="bajrachar ok"><y>#</y><d>2018-07-12</d><h>16:05</h><w>bajrachar</w>ok</z><z id="t1531411621000397" t="hiredman serializing will remove any structural sharing in the data"><y>#</y><d>2018-07-12</d><h>16:07</h><w>hiredman</w>serializing will remove any structural sharing in the data</z><z id="t1531411624000401" t="bajrachar Thank you for your help @norman"><y>#</y><d>2018-07-12</d><h>16:07</h><w>bajrachar</w>Thank you for your help @norman</z><z id="t1531411639000287" t="bajrachar I am pretty new to Clojure and core.logic"><y>#</y><d>2018-07-12</d><h>16:07</h><w>bajrachar</w>I am pretty new to Clojure and core.logic</z><z id="t1531411698000539" t="bajrachar using it for a clinical decision support tool - and as such it&apos;s knowledge base is pretty large"><y>#</y><d>2018-07-12</d><h>16:08</h><w>bajrachar</w>using it for a clinical decision support tool - and as such it&apos;s knowledge base is pretty large</z><z id="t1531411740000352" t="hiredman https://gist.github.com/terjesb/3181018 might be a good place to start if you want to use core.logic without storing things in memory"><y>#</y><d>2018-07-12</d><h>16:09</h><w>hiredman</w><a href="https://gist.github.com/terjesb/3181018" target="_blank">https://gist.github.com/terjesb/3181018</a> might be a good place to start if you want to use core.logic without storing things in memory</z><z id="t1531411825000201" t="bajrachar oh cool - thanks @hiredman -"><y>#</y><d>2018-07-12</d><h>16:10</h><w>bajrachar</w>oh cool - thanks @hiredman -</z><z id="t1531411862000051" t="bajrachar the dataset here being the lucene index?"><y>#</y><d>2018-07-12</d><h>16:11</h><w>bajrachar</w>the dataset here being the lucene index?</z><z id="t1531413000000159" t="hiredman in that code sure, but you can do something similar to extend it to other datastores, I was thinking of it more as example"><y>#</y><d>2018-07-12</d><h>16:30</h><w>hiredman</w>in that code sure, but you can do something similar to extend it to other datastores, I was thinking of it more as example</z><z id="t1531413036000148" t="bajrachar ok - I understand - thanks"><y>#</y><d>2018-07-12</d><h>16:30</h><w>bajrachar</w>ok - I understand - thanks</z><z id="t1533316853000094" t="bajrachar I am trying to understand how a tabled goal works in core.logic?"><y>#</y><d>2018-08-03</d><h>17:20</h><w>bajrachar</w>I am trying to understand how a tabled goal works in core.logic?</z><z id="t1533316898000069" t="bajrachar can it be used to eliminate circular references in for example a graph traversal for example"><y>#</y><d>2018-08-03</d><h>17:21</h><w>bajrachar</w>can it be used to eliminate circular references in for example a graph traversal for example</z><z id="t1533317066000039" t="bajrachar or is it supposed to eliminate duplicates in the result"><y>#</y><d>2018-08-03</d><h>17:24</h><w>bajrachar</w>or is it supposed to eliminate duplicates in the result</z><z id="t1533317310000507" t="bajrachar I have a logic expression as such - which traverses a child hierarchy. CHD stands for Child relation and RN stands for narrow relation"><y>#</y><d>2018-08-03</d><h>17:28</h><w>bajrachar</w>I have a logic expression as such - which traverses a child hierarchy. CHD stands for Child relation and RN stands for narrow relation</z><z id="t1533317369000217" t="bajrachar Issue is - it can go into endless loop if there are circular references"><y>#</y><d>2018-08-03</d><h>17:29</h><w>bajrachar</w>Issue is - it can go into endless loop if there are circular references</z><z id="t1533318374000325" t="hiredman I think it is more like a performance optimization, if you have a goal that diverges it won&apos;t stop it from diverging"><y>#</y><d>2018-08-03</d><h>17:46</h><w>hiredman</w>I think it is more like a performance optimization, if you have a goal that diverges it won&apos;t stop it from diverging</z><z id="t1533318573000066" t="hiredman there is a correspondence between proof by induction and recursion, they both need a base case"><y>#</y><d>2018-08-03</d><h>17:49</h><w>hiredman</w>there is a correspondence between proof by induction and recursion, they both need a base case</z><z id="t1533318633000080" t="hiredman you might be able to get by using one of the non-relational variants of conde"><y>#</y><d>2018-08-03</d><h>17:50</h><w>hiredman</w>you might be able to get by using one of the non-relational variants of conde</z><z id="t1533318663000446" t="hiredman maybe conda"><y>#</y><d>2018-08-03</d><h>17:51</h><w>hiredman</w>maybe conda</z><z id="t1533318711000336" t="hiredman or make the clauses in your conde mutually exclusive"><y>#</y><d>2018-08-03</d><h>17:51</h><w>hiredman</w>or make the clauses in your conde mutually exclusive</z><z id="t1533318766000503" t="bajrachar Thank you @hiredman - as always your responses are very helpful"><y>#</y><d>2018-08-03</d><h>17:52</h><w>bajrachar</w>Thank you @hiredman - as always your responses are very helpful</z><z id="t1533318822000051" t="bajrachar just so I follow what you&apos;re saying - &quot;divergence&quot; means there is a cycle right?"><y>#</y><d>2018-08-03</d><h>17:53</h><w>bajrachar</w>just so I follow what you&apos;re saying - &quot;divergence&quot; means there is a cycle right?</z><z id="t1533318936000064" t="hiredman it could be caused by cycle in something you are are traversing recursively, my very rough understanding of it is divergence == infinitely looping logic program"><y>#</y><d>2018-08-03</d><h>17:55</h><w>hiredman</w>it could be caused by cycle in something you are are traversing recursively, my very rough understanding of it is divergence == infinitely looping logic program</z><z id="t1533319088000077" t="bajrachar by making the clauses mutually exclusive - do you mean adding something like !="><y>#</y><d>2018-08-03</d><h>17:58</h><w>bajrachar</w>by making the clauses mutually exclusive - do you mean adding something like !=</z><z id="t1533319145000008" t="bajrachar sorry if this is a very stupid question 🙂 - still learning the ropes of core.logic"><y>#</y><d>2018-08-03</d><h>17:59</h><w>bajrachar</w>sorry if this is a very stupid question <b>🙂</b> - still learning the ropes of core.logic</z><z id="t1533319174000260" t="bajrachar It is very interesting - at the same time very difficult to wrap your head around"><y>#</y><d>2018-08-03</d><h>17:59</h><w>bajrachar</w>It is very interesting - at the same time very difficult to wrap your head around</z><z id="t1533319195000524" t="hiredman yeah, != or some other goal that will fail on the one branch if the other branch is the one you want"><y>#</y><d>2018-08-03</d><h>17:59</h><w>hiredman</w>yeah, != or some other goal that will fail on the one branch if the other branch is the one you want</z><z id="t1533319277000221" t="bajrachar Ah - Thank you - I will try that"><y>#</y><d>2018-08-03</d><h>18:01</h><w>bajrachar</w>Ah - Thank you - I will try that</z><z id="t1533320341000153" t="hiredman I was wrong about tabling: https://github.com/clojure/core.logic/wiki/Features#tabling the docs say it will turn a non-terminating logic program in to a terminating one"><y>#</y><d>2018-08-03</d><h>18:19</h><w>hiredman</w>I was wrong about tabling: <a href="https://github.com/clojure/core.logic/wiki/Features#tabling" target="_blank">https://github.com/clojure/core.logic/wiki/Features#tabling</a> the docs say it will turn a non-terminating logic program in to a terminating one</z><z id="t1533320811000154" t="bajrachar that was what I thought it was supposed to do - but still I see it is diverging - maybe I need to table only the recursive portion"><y>#</y><d>2018-08-03</d><h>18:26</h><w>bajrachar</w>that was what I thought it was supposed to do - but still I see it is diverging - maybe I need to table only the recursive portion</z><z id="t1533955412000014" t="bajrachar Does core.logic take advantage of concurrency/parallelization ?"><y>#</y><d>2018-08-11</d><h>02:43</h><w>bajrachar</w>Does core.logic take advantage of concurrency/parallelization ?</z><z id="t1533955458000059" t="bajrachar I notice that it isn&apos;t making use of all the cores when it is running"><y>#</y><d>2018-08-11</d><h>02:44</h><w>bajrachar</w>I notice that it isn&apos;t making use of all the cores when it is running</z><z id="t1533955514000048" t="bajrachar Also was wondering if anyone has experience with working with the parallel version of core.logic using fork/join --&gt; http://www.clojure.net/2012/10/02/More-core.logic/"><y>#</y><d>2018-08-11</d><h>02:45</h><w>bajrachar</w>Also was wondering if anyone has experience with working with the parallel version of core.logic using fork/join --&gt; <a href="http://www.clojure.net/2012/10/02/More-core.logic/" target="_blank">http://www.clojure.net/2012/10/02/More-core.logic/</a></z><z id="t1533956045000027" t="bajrachar @norman - I was wondering if I could go about parallelizing query in pldb code by using reducers or pmap in the fact search portion or if this is more of a issue with unification side"><y>#</y><d>2018-08-11</d><h>02:54</h><w>bajrachar</w>@norman - I was wondering if I could go about parallelizing query in pldb code by using reducers or pmap in the fact search portion or if this is more of a issue with unification side</z><z id="t1533956069000029" t="bajrachar it seems more of the latter"><y>#</y><d>2018-08-11</d><h>02:54</h><w>bajrachar</w>it seems more of the latter</z><z id="t1533956091000038" t="norman I doubt it, given the way queries evaluate"><y>#</y><d>2018-08-11</d><h>02:54</h><w>norman</w>I doubt it, given the way queries evaluate</z><z id="t1533956199000030" t="bajrachar Currently I&apos;ve managed to represent a graph using pldb - and when I query for path that are two step [depth = 2] - it takes a long time"><y>#</y><d>2018-08-11</d><h>02:56</h><w>bajrachar</w>Currently I&apos;ve managed to represent a graph using pldb - and when I query for path that are two step [depth = 2] - it takes a long time</z><z id="t1533956224000050" t="bajrachar and I notice it isn&apos;t taking advantage of all the cores in the machine"><y>#</y><d>2018-08-11</d><h>02:57</h><w>bajrachar</w>and I notice it isn&apos;t taking advantage of all the cores in the machine</z><z id="t1533956253000046" t="norman Yes, I believe that"><y>#</y><d>2018-08-11</d><h>02:57</h><w>norman</w>Yes, I believe that</z><z id="t1533956273000063" t="norman the execution model of core.logic is probably not very amenable to parallelization"><y>#</y><d>2018-08-11</d><h>02:57</h><w>norman</w>the execution model of core.logic is probably not very amenable to parallelization</z><z id="t1533956282000003" t="bajrachar I also noticed a slightly older post from jim deuy on using fork/join with core.logic --&gt; http://www.clojure.net/2012/10/02/More-core.logic/"><y>#</y><d>2018-08-11</d><h>02:58</h><w>bajrachar</w>I also noticed a slightly older post from jim deuy on using fork/join with core.logic --&gt; <a href="http://www.clojure.net/2012/10/02/More-core.logic/" target="_blank">http://www.clojure.net/2012/10/02/More-core.logic/</a></z><z id="t1533956337000024" t="norman Yes, you’d have to fundamentally change the execution moel"><y>#</y><d>2018-08-11</d><h>02:58</h><w>norman</w>Yes, you’d have to fundamentally change the execution moel</z><z id="t1533956376000080" t="bajrachar hmm ... ok ... sounds like a interesting challenge to try out over the weekend 🙂"><y>#</y><d>2018-08-11</d><h>02:59</h><w>bajrachar</w>hmm ... ok ... sounds like a interesting challenge to try out over the weekend <b>🙂</b></z><z id="t1533956411000018" t="bajrachar will try to use the jim duey&apos;s branch and see if it helps"><y>#</y><d>2018-08-11</d><h>03:00</h><w>bajrachar</w>will try to use the jim duey&apos;s branch and see if it helps</z><z id="t1533956790000051" t="bajrachar @norman - what is the current state of core.logic and it&apos;s roadmap?"><y>#</y><d>2018-08-11</d><h>03:06</h><w>bajrachar</w>@norman - what is the current state of core.logic and it&apos;s roadmap?</z><z id="t1533957005000049" t="norman It’s not being actively developed"><y>#</y><d>2018-08-11</d><h>03:10</h><w>norman</w>It’s not being actively developed</z><z id="t1533957037000031" t="norman Unless it’s spun out of clojure core, I’m not inclined to contribute further"><y>#</y><d>2018-08-11</d><h>03:10</h><w>norman</w>Unless it’s spun out of clojure core, I’m not inclined to contribute further</z><z id="t1536145566000100" t="rickmoynihan Are there any docs on tabling in core.logic and how it works?"><y>#</y><d>2018-09-05</d><h>11:06</h><w>rickmoynihan</w>Are there any docs on tabling in core.logic and how it works?</z><z id="t1536146000000100" t="rickmoynihan Backstory: I’ve implemented a SPARQL/Datalog-like query DSL for querying in memory RDF graphs with core.logic. The DSL essentially tries to hide a lot of the minikanren/relational-programming stuff and present a simpler “SPARQL like” model, where you don’t need to fresh variables etc… I use db-rel to get acceptable performance. Currently I compile the Basic Graph Pattern vectors my macro receives and convert them to calls to db-rel . What I have works quite well, but it does of course mean that you can’t generate queries at runtime. I’d like to explore doing the same but with functions, so I can also provide a way to build tabled queries dynamically. Is this possible?"><y>#</y><d>2018-09-05</d><h>11:13</h><w>rickmoynihan</w>Backstory: I’ve implemented a SPARQL/Datalog-like query DSL for querying in memory RDF graphs with core.logic.  The DSL essentially tries to hide a lot of the minikanren/relational-programming stuff and present a simpler “SPARQL like” model, where you don’t need to <code>fresh</code> variables etc…

I use <code>db-rel</code> to get acceptable performance.  Currently I compile the Basic Graph Pattern vectors my macro receives and convert them to calls to <code>db-rel</code>.  What I have works quite well, but it does of course mean that you can’t generate queries at runtime.  I’d like to explore doing the same but with functions, so I can also provide a way to build tabled queries dynamically.

Is this possible?</z><z id="t1536146019000100" t="rickmoynihan For reference this is the project: https://github.com/Swirrl/matcha"><y>#</y><d>2018-09-05</d><h>11:13</h><w>rickmoynihan</w>For reference this is the project: <a href="https://github.com/Swirrl/matcha" target="_blank">https://github.com/Swirrl/matcha</a></z><z id="t1536147609000100" t="rickmoynihan e.g. the graph pattern [[:foo ?p ?o]] would currently compile into something like:"><y>#</y><d>2018-09-05</d><h>11:40</h><w>rickmoynihan</w>e.g. the graph pattern <code>[[:foo ?p ?o]]</code> would currently compile into something like:</z><z id="t1536147611000100" t="rickmoynihan (clojure.core.logic/fresh [?p ?o] (grafter.matcha.alpha/triple ?s ?p ?o)) "><y>#</y><d>2018-09-05</d><h>11:40</h><w>rickmoynihan</w><pre>(clojure.core.logic/fresh
          [?p ?o]
          (grafter.matcha.alpha/triple ?s ?p ?o))
</pre></z><z id="t1536147806000100" t="rickmoynihan I can obviously define a relation that will recursively apply the triple relation, but won’t that eliminate the advantages of indexing? I’m also not entirely sure of all the semantics around using clojure inside relations etc, which was my first instinct to avoid using a macro."><y>#</y><d>2018-09-05</d><h>11:43</h><w>rickmoynihan</w>I can obviously define a relation that will recursively apply the <code>triple</code> relation, but won’t that eliminate the advantages of indexing?

I’m also not entirely sure of all the semantics around using clojure inside relations etc, which was my first instinct to avoid using a macro.</z><z id="t1536161547000100" t="bajrachar @rickmoynihan - sounds like an interesting project - It would be great to have something to query in-memory graph - without digging into minikanren"><y>#</y><d>2018-09-05</d><h>15:32</h><w>bajrachar</w>@rickmoynihan - sounds like an interesting project - It would be great to have something to query in-memory graph - without digging into minikanren</z><z id="t1536161565000100" t="bajrachar I didn&apos;t quite follow what you mean by generating queries dynamically"><y>#</y><d>2018-09-05</d><h>15:32</h><w>bajrachar</w>I didn&apos;t quite follow what you mean by generating queries dynamically</z><z id="t1536161638000100" t="bajrachar I recently also used core.logic for graph traversal - but due to large size of the db it wasnt as efficient"><y>#</y><d>2018-09-05</d><h>15:33</h><w>bajrachar</w>I recently also used core.logic for graph traversal - but due to large size of the db it wasnt as efficient</z><z id="t1536161692000100" t="rickmoynihan Sometimes you want to generate queries dynamically based on inputs. Currently in Matcha you can’t do this kinda thing: (let [query-pattern (conj &apos;[?s ?p] &apos;?o)] ((select query-pattern) friends)"><y>#</y><d>2018-09-05</d><h>15:34</h><w>rickmoynihan</w>Sometimes you want to generate queries dynamically based on inputs.

Currently in Matcha you can’t do this kinda thing: <code>(let [query-pattern (conj &apos;[?s ?p] &apos;?o)] ((select query-pattern) friends)</code></z><z id="t1536161754000100" t="rickmoynihan because select is a macro, so query-pattern has to be hardcoded as a literal value at compile time"><y>#</y><d>2018-09-05</d><h>15:35</h><w>rickmoynihan</w>because <code>select</code> is a macro, so <code>query-pattern</code> has to be hardcoded as a literal value at compile time</z><z id="t1536162352000200" t="bajrachar ok I see what you mean - how does tabling help in this scenario?"><y>#</y><d>2018-09-05</d><h>15:45</h><w>bajrachar</w>ok I see what you mean - how does tabling help in this scenario?</z><z id="t1536162372000100" t="rickmoynihan it makes it orders of magnitude faster"><y>#</y><d>2018-09-05</d><h>15:46</h><w>rickmoynihan</w>it makes it orders of magnitude faster</z><z id="t1536162499000100" t="bajrachar and you want to use functions in place of macro"><y>#</y><d>2018-09-05</d><h>15:48</h><w>bajrachar</w>and you want to use functions in place of macro</z><z id="t1536162533000100" t="bajrachar sorry - just trying to understand the problem 🙂 -"><y>#</y><d>2018-09-05</d><h>15:48</h><w>bajrachar</w>sorry - just trying to understand the problem <b>🙂</b> -</z><z id="t1536163508000100" t="bajrachar I don&apos;t know if it is applicable in this particular case - but for my particular use case of making graph traversal faster on a very large in-memory db - I went about re-writing some parts of pldb and db-rel"><y>#</y><d>2018-09-05</d><h>16:05</h><w>bajrachar</w>I don&apos;t know if it is applicable in this particular case - but for my particular use case of making graph traversal faster on a very large in-memory db - I went about re-writing some parts of pldb and db-rel</z><z id="t1536163645000100" t="bajrachar making the matching logic parallel - which seemed to work better than tabling"><y>#</y><d>2018-09-05</d><h>16:07</h><w>bajrachar</w>making the matching logic parallel - which seemed to work better than tabling</z><z id="t1536163672000100" t="bajrachar as issue for me wasn&apos;t that query was diverging"><y>#</y><d>2018-09-05</d><h>16:07</h><w>bajrachar</w>as issue for me wasn&apos;t that query was diverging</z><z id="t1536164278000100" t="rickmoynihan &gt; and you want to use functions in place of macro @bajrachar Yes."><y>#</y><d>2018-09-05</d><h>16:17</h><w>rickmoynihan</w>&gt; and you want to use functions in place of macro

@bajrachar Yes.</z><z id="t1536165103000200" t="rickmoynihan I think the problem is that without tabling I’d need to scan the database on each join, so performance becomes exponential?/quadratic?/something-really bad. Making it parallel might help, but at best parallelisation will only make linear gains in terms of processors; rather than the orders of magnitude gains you can get through indexing/tabling/memoization/better-algorithms. For me querying just 1000 edges was taking my naive version longer than querying millions of edges with tabling"><y>#</y><d>2018-09-05</d><h>16:31</h><w>rickmoynihan</w>I think the problem is that without tabling I’d need to scan the database on each join, so performance becomes exponential?/quadratic?/something-really bad.

Making it parallel might help, but at best parallelisation will only make linear gains in terms of processors; rather than the orders of magnitude gains you can get through indexing/tabling/memoization/better-algorithms.

For me querying just 1000 edges was taking my naive version longer than querying millions of edges with tabling</z><z id="t1536166676000100" t="bajrachar sounds interesting - definitely would like to see how you&apos;ve used tabling"><y>#</y><d>2018-09-05</d><h>16:57</h><w>bajrachar</w>sounds interesting - definitely would like to see how you&apos;ve used tabling</z><z id="t1536166736000100" t="bajrachar by join - I assume its traversing the graph to depth n?"><y>#</y><d>2018-09-05</d><h>16:58</h><w>bajrachar</w>by join - I assume its traversing the graph to depth n?</z><z id="t1536171680000100" t="rickmoynihan I mean join in the RDBMS sense. Effectively a triple store is a single table with three columns; every time you walk from one edge (row) to another through a ?variable binding you’re effectively doing a self join back on that table. But yes each traversal is effectively another join."><y>#</y><d>2018-09-05</d><h>18:21</h><w>rickmoynihan</w>I mean join in the RDBMS sense.  Effectively a triple store is a single table with three columns; every time you walk from one edge (row) to another through a <code>?variable</code> binding you’re effectively doing a self join back on that table.  But yes each traversal is effectively another join.</z><z id="t1536172344000100" t="rickmoynihan ahhh ha! https://github.com/clojure/core.logic/blob/10ee95eb2bed70af5bc29ea3bd78b380f054a8b4/src/main/clojure/clojure/core/logic.clj#L1801-L1807"><y>#</y><d>2018-09-05</d><h>18:32</h><w>rickmoynihan</w>ahhh ha!

<a href="https://github.com/clojure/core.logic/blob/10ee95eb2bed70af5bc29ea3bd78b380f054a8b4/src/main/clojure/clojure/core/logic.clj#L1801-L1807" target="_blank">https://github.com/clojure/core.logic/blob/10ee95eb2bed70af5bc29ea3bd78b380f054a8b4/src/main/clojure/clojure/core/logic.clj#L1801-L1807</a></z><z id="t1536172368000100" t="rickmoynihan some references: http://scholarworks.iu.edu/dspace/bitstream/handle/2022/8777/Byrd_indiana_0093A_10344.pdf?sequence=1 https://code.google.com/p/iucs-relational-research/"><y>#</y><d>2018-09-05</d><h>18:32</h><w>rickmoynihan</w>some references: <a href="http://scholarworks.iu.edu/dspace/bitstream/handle/2022/8777/Byrd_indiana_0093A_10344.pdf?sequence=1" target="_blank">http://scholarworks.iu.edu/dspace/bitstream/handle/2022/8777/Byrd_indiana_0093A_10344.pdf?sequence=1</a>

<a href="https://code.google.com/p/iucs-relational-research/" target="_blank">https://code.google.com/p/iucs-relational-research/</a></z><z id="t1536172465000100" t="rickmoynihan I think I understand roughly how this works; but need to figure out the finer details"><y>#</y><d>2018-09-05</d><h>18:34</h><w>rickmoynihan</w>I think I understand roughly how this works; but need to figure out the finer details</z><z id="t1536172508000100" t="rickmoynihan the second link in the source code 404&apos;s 😞"><y>#</y><d>2018-09-05</d><h>18:35</h><w>rickmoynihan</w>the second link in the source code 404&apos;s <b>😞</b></z><z id="t1536172575000100" t="rickmoynihan I think the first link is Byrds thesis… I’ve skimmed this before; but can’t recall the details of tabling"><y>#</y><d>2018-09-05</d><h>18:36</h><w>rickmoynihan</w>I think the first link is Byrds thesis… I’ve skimmed this before; but can’t recall the details of tabling</z><z id="t1536176206000100" t="rickmoynihan hmmm… maybe I’m misunderstanding the relationship between tabling and pldb"><y>#</y><d>2018-09-05</d><h>19:36</h><w>rickmoynihan</w>hmmm… maybe I’m misunderstanding the relationship between tabling and pldb</z><z id="t1536286433000100" t="bajrachar @rickmoynihan - sounds interesting. I&apos;d love to take a look at matcha and play around when I have some time - perhaps this weekend."><y>#</y><d>2018-09-07</d><h>02:13</h><w>bajrachar</w>@rickmoynihan - sounds interesting. I&apos;d love to take a look at matcha and play around when I have some time - perhaps this weekend.</z><z id="t1536286519000100" t="bajrachar SPARQL queries are a bit verbose for my liking - but I do like the idea of query string being a function and also a representation of the relationship you&apos;re querying"><y>#</y><d>2018-09-07</d><h>02:15</h><w>bajrachar</w>SPARQL queries are a bit verbose for my liking - but I do like the idea of query string being a function and also a representation of the relationship you&apos;re querying</z><z id="t1536286632000100" t="bajrachar goes well with &quot;code is data&quot; mantra 🙂"><y>#</y><d>2018-09-07</d><h>02:17</h><w>bajrachar</w>goes well with &quot;code is data&quot; mantra <b>🙂</b></z><z id="t1536308291000100" t="rickmoynihan @bajrachar: Thanks. What what’s there should be quite useful for us… Being a macro it obviously makes use of “code is data”, but I’d prefer to also offer a “data is data” model, so we can generate queries directly. Matcha is really just the BGP bit of SPARQL, so it’s hard to see how it could be made more terse… At some point I’ll probably add property paths to Matcha, to make it even more terse i.e. things like (construct-1 ?foafoafoaf [[:rick [:foaf/knows :foaf/knows :foaf/knows] ?foafoafoaf]])"><y>#</y><d>2018-09-07</d><h>08:18</h><w>rickmoynihan</w>@bajrachar: Thanks.  What what’s there should be quite useful for us…  Being a macro it obviously makes use of “code is data”, but I’d prefer to also offer a “data is data” model, so we can generate queries directly.

Matcha is really just the BGP bit of SPARQL, so it’s hard to see how it could be made more terse…  At some point I’ll probably add property paths to Matcha, to make it even more terse i.e. things like <code>(construct-1 ?foafoafoaf [[:rick [:foaf/knows :foaf/knows :foaf/knows] ?foafoafoaf]])</code></z><z id="t1536308438000100" t="rickmoynihan and also an equivalent of VALUES clauses: (construct-1 ?label-or-title [[:resource #{:rdfs/label :dcterms/title} ?label-or-title]])"><y>#</y><d>2018-09-07</d><h>08:20</h><w>rickmoynihan</w>and also an equivalent of <code>VALUES</code> clauses: <code>(construct-1 ?label-or-title [[:resource #{:rdfs/label :dcterms/title} ?label-or-title]])</code></z><z id="t1536746951000100" t="risto hi everyone"><y>#</y><d>2018-09-12</d><h>10:09</h><w>risto</w>hi everyone</z><z id="t1536746965000100" t="risto i&apos;m trying to figure out what&apos;s making appendo terminate, from the looks of it, it seems like it should just be infinite like anyo"><y>#</y><d>2018-09-12</d><h>10:09</h><w>risto</w>i&apos;m trying to figure out what&apos;s making <code>appendo</code> terminate, from the looks of it, it seems like it should just be infinite like <code>anyo</code></z><z id="t1536746970000100" t="risto does anyone have any insight into that?"><y>#</y><d>2018-09-12</d><h>10:09</h><w>risto</w>does anyone have any insight into that?</z><z id="t1536769800000100" t="hiredman it is a recursive goal with 3 args (x y z) and 2 cases. the first case is the base case and is only true if x unifies with the empty list and z unifies with y, the second case is only true if the first element of x and the first element of z unify, and if it is true it calls appendo again with the rest of x, y, and the rest of z"><y>#</y><d>2018-09-12</d><h>16:30</h><w>hiredman</w>it is a recursive goal with 3 args (x y z) and 2 cases. the first case is the base case and is only true if x unifies with the empty list and z unifies with y, the second case is only true if the first element of x and the first element of z unify, and if it is true it calls appendo again with the rest of x, y, and the rest of z</z><z id="t1536770307000100" t="hiredman so it must terminate because every step where case 2 matches causes the recursive call to be made with the rest of x, so the x argument gets smaller and smaller, until case 2 no long holds and case 1 might hold"><y>#</y><d>2018-09-12</d><h>16:38</h><w>hiredman</w>so it must terminate because every step where case 2 matches causes the recursive call to be made with the rest of x, so the x argument gets smaller and smaller, until case 2 no long holds and case 1 might hold</z><z id="t1536776264000100" t="risto that makes sense, but the issue for me is how conj and disj are implemented"><y>#</y><d>2018-09-12</d><h>18:17</h><w>risto</w>that makes sense, but the issue for me is how <code>conj</code> and <code>disj</code> are implemented</z><z id="t1536776289000100" t="risto even though it&apos;s a lazy stream, conj is implemented using flatmap and disj with a fair append"><y>#</y><d>2018-09-12</d><h>18:18</h><w>risto</w>even though it&apos;s a lazy stream, <code>conj</code> is implemented using <code>flatmap</code> and <code>disj</code> with a fair <code>append</code></z><z id="t1536776307000100" t="risto so it seems like it would continue to recurse forever, because under the hood it&apos;s calling flatmap or append"><y>#</y><d>2018-09-12</d><h>18:18</h><w>risto</w>so it seems like it would continue to recurse forever, because under the hood it&apos;s calling <code>flatmap</code> or <code>append</code></z><z id="t1536776625000100" t="hiredman are you actually asking about core.logic or minikanren? because flatmap isn&apos;t a string that appears in core.logic"><y>#</y><d>2018-09-12</d><h>18:23</h><w>hiredman</w>are you actually asking about core.logic or minikanren? because flatmap isn&apos;t a string that appears in core.logic</z><z id="t1536776740000100" t="hiredman append is not the same thing as appendo"><y>#</y><d>2018-09-12</d><h>18:25</h><w>hiredman</w>append is not the same thing as appendo</z><z id="t1536776864000100" t="risto isn&apos;t core.logic an implementation of minikanren?"><y>#</y><d>2018-09-12</d><h>18:27</h><w>risto</w>isn&apos;t core.logic an implementation of minikanren?</z><z id="t1536777042000100" t="risto (def appendo [xs ys out] (conde [(eq xs []) (eq ys out)] [(fresh [first rest rec] (conso first rest xs) (conso first rec out) (appendo rest ys out))])) here fresh is calling call-fresh and conj under the hood, and conj is implemented using flatmap aka bind aka mapcat-stream"><y>#</y><d>2018-09-12</d><h>18:30</h><w>risto</w><pre>(def appendo [xs ys out]
   (conde
     [(eq xs []) (eq ys out)]
     [(fresh [first rest rec]
        (conso first rest xs)
        (conso first rec out)
        (appendo rest ys out))]))
</pre>
here <code>fresh</code> is calling <code>call-fresh</code> and <code>conj</code> under the hood, and <code>conj</code> is implemented using <code>flatmap</code> aka <code>bind</code> aka <code>mapcat-stream</code></z><z id="t1536777069000100" t="risto so it would just keep going forever it seems, like anyo"><y>#</y><d>2018-09-12</d><h>18:31</h><w>risto</w>so it would just keep going forever it seems, like <code>anyo</code></z><z id="t1536777158000100" t="hiredman no"><y>#</y><d>2018-09-12</d><h>18:32</h><w>hiredman</w>no</z><z id="t1536777180000100" t="hiredman you are confusing goals implemented in core.logic with functions implemented in clojure"><y>#</y><d>2018-09-12</d><h>18:33</h><w>hiredman</w>you are confusing goals implemented in core.logic with functions implemented in clojure</z><z id="t1536777203000100" t="risto why do you think i&apos;m confusing it with functions in clojure?"><y>#</y><d>2018-09-12</d><h>18:33</h><w>risto</w>why do you think i&apos;m confusing it with functions in clojure?</z><z id="t1536777232000100" t="hiredman actually it is hard to say, because call-fresh doesn&apos;t exist in core.logic either"><y>#</y><d>2018-09-12</d><h>18:33</h><w>hiredman</w>actually it is hard to say, because call-fresh doesn&apos;t exist in core.logic either</z><z id="t1536777254000100" t="hiredman because conj in clojure is the function clojure.core/conj which is definitely not implemented using flatmap"><y>#</y><d>2018-09-12</d><h>18:34</h><w>hiredman</w>because conj in clojure is the function clojure.core/conj which is definitely not implemented using flatmap</z><z id="t1536777287000100" t="hiredman there is a core.logic goal called conjo, which is a constraint goal, which is kind of a different kettle of fish"><y>#</y><d>2018-09-12</d><h>18:34</h><w>hiredman</w>there is a core.logic goal called conjo, which is a constraint goal, which is kind of a different kettle of fish</z><z id="t1536777298000100" t="risto ah i see the confusion, i&apos;m referring to the names of these things from the minikanren implementation"><y>#</y><d>2018-09-12</d><h>18:34</h><w>risto</w>ah i see the confusion, i&apos;m referring to the names of these things from the minikanren implementation</z><z id="t1536777312000100" t="risto maybe core.logic is using a different scheme for it, but it&apos;s implementing minikanren under the hood"><y>#</y><d>2018-09-12</d><h>18:35</h><w>risto</w>maybe core.logic is using a different scheme for it, but it&apos;s implementing minikanren under the hood</z><z id="t1536777337000100" t="risto yeah i meant conjo , sorry"><y>#</y><d>2018-09-12</d><h>18:35</h><w>risto</w>yeah i meant <code>conjo</code>, sorry</z><z id="t1536777364000200" t="risto it has something called conj under the hood which isn&apos;t a goal"><y>#</y><d>2018-09-12</d><h>18:36</h><w>risto</w>it has something called <code>conj</code> under the hood which isn&apos;t a goal</z><z id="t1536777372000100" t="risto but not the same as clojure.core/conj"><y>#</y><d>2018-09-12</d><h>18:36</h><w>risto</w>but not the same as clojure.core/conj</z><z id="t1536777372000200" t="hiredman it is minikanren in a kind of hand wavey sense, it isn&apos;t a direct port"><y>#</y><d>2018-09-12</d><h>18:36</h><w>hiredman</w>it is minikanren in a kind of hand wavey sense, it isn&apos;t a direct port</z><z id="t1536777443000100" t="hiredman I don&apos;t think core-logic&apos;s conjo is the same as conj in minikanren"><y>#</y><d>2018-09-12</d><h>18:37</h><w>hiredman</w>I don&apos;t think core-logic&apos;s conjo is the same as conj in minikanren</z><z id="t1536777511000100" t="hiredman I think, and it has been a long time since I&apos;ve looked at minikanren, conj in mk is an operator on the underlying lazy stream implementation"><y>#</y><d>2018-09-12</d><h>18:38</h><w>hiredman</w>I think, and it has been a long time since I&apos;ve looked at minikanren, conj in mk is an operator on the underlying lazy stream implementation</z><z id="t1536777588000100" t="risto yeah, it has a minimal implementation at the end of the paper http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf"><y>#</y><d>2018-09-12</d><h>18:39</h><w>risto</w>yeah, it has a minimal implementation at the end of the paper <a href="http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf" target="_blank">http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf</a></z><z id="t1536777650000100" t="hiredman so it is a level of abstraction problem"><y>#</y><d>2018-09-12</d><h>18:40</h><w>hiredman</w>so it is a level of abstraction problem</z><z id="t1536777654000100" t="risto but that&apos;s not enough to stop it from infinitely recursing appendo afaict. It might be because it&apos;s such a minimal implementation of kanren that they leave out the more important parts to make something like appendo work, not sure"><y>#</y><d>2018-09-12</d><h>18:40</h><w>risto</w>but that&apos;s not enough to stop it from infinitely recursing <code>appendo</code> afaict. It might be because it&apos;s such a minimal implementation of kanren that they leave out the more important parts to make something like <code>appendo</code> work, not sure</z><z id="t1536777663000100" t="hiredman mk is not implemented in mk"><y>#</y><d>2018-09-12</d><h>18:41</h><w>hiredman</w>mk is not implemented in mk</z><z id="t1536777701000100" t="hiredman micro kanren is another thing again"><y>#</y><d>2018-09-12</d><h>18:41</h><w>hiredman</w>micro kanren is another thing again</z><z id="t1536777728000100" t="risto what&apos;s the difference between minikanren and microkaren? microkanren is just an even more minimal version of kanren?"><y>#</y><d>2018-09-12</d><h>18:42</h><w>risto</w>what&apos;s the difference between minikanren and microkaren? microkanren is just an even more minimal version of kanren?</z><z id="t1536777776000100" t="risto its on the minikanren website, i thought it was the same thing"><y>#</y><d>2018-09-12</d><h>18:42</h><w>risto</w>its on the minikanren website, i thought it was the same thing</z><z id="t1536778072000100" t="hiredman yeah, it is an even more stripped down version"><y>#</y><d>2018-09-12</d><h>18:47</h><w>hiredman</w>yeah, it is an even more stripped down version</z><z id="t1536778231000100" t="risto yeah"><y>#</y><d>2018-09-12</d><h>18:50</h><w>risto</w>yeah</z><z id="t1536778282000100" t="risto anyways, it says on the minikaren website that core.logic is an implementation of it.. even if it deviates somewhat it has to have some way of making sure appendo doesn&apos;t just recurse forever. I guess my question is how they manage to pull that off without ending up with a neverending stream like anyo"><y>#</y><d>2018-09-12</d><h>18:51</h><w>risto</w>anyways, it says on the minikaren website that core.logic is an implementation of it.. even if it deviates somewhat it has to have some way of making sure <code>appendo</code> doesn&apos;t just recurse forever. I guess my question is how they manage to pull that off without ending up with a neverending stream like <code>anyo</code></z><z id="t1536842661000100" t="rickmoynihan @risto: minikanren and microkanren are different beasts in terms of implementation. The stream stuff is specific to microkanren and descendants of it I believe. Minikanren as I understand it is as described/used in the reasoned schemer. microkanren in the reasoned schemer 2nd edition. Also Byrd’s thesis is minikanren / Hemann’s paper microkanren. I’m only just delving into the differences here myself, but I’m not sure programs written for one are always portable to the other… e.g. microkanren skips the occurs check for infinite loops — which might be pertinent to what you’re saying."><y>#</y><d>2018-09-13</d><h>12:44</h><w>rickmoynihan</w>@risto: minikanren and microkanren are different beasts in terms of implementation.  The stream stuff is specific to microkanren and descendants of it I believe.  Minikanren as I understand it is as described/used in the reasoned schemer.  microkanren in the reasoned schemer 2nd edition.  Also Byrd’s thesis is minikanren / Hemann’s paper microkanren.

I’m only just delving into the differences here myself, but I’m not sure programs written for one are always portable to the other… e.g. microkanren skips the occurs check for infinite loops — which might be pertinent to what you’re saying.</z><z id="t1536842830000100" t="rickmoynihan I think it’s more or less true that minikanren semantics is what core.logic essentially implements. So if you’re looking at a core.logic appendo and wondering how it works with reference to the microkanren scheme implementation… I’d first check to see if there is an important difference between how appendo is written for the two dialects. It may be the same, but I wouldn’t be surprised if it wasn’t."><y>#</y><d>2018-09-13</d><h>12:47</h><w>rickmoynihan</w>I think it’s more or less true that minikanren semantics is what core.logic essentially implements.  So if you’re looking at a core.logic <code>appendo</code> and wondering how it works with reference to the microkanren scheme implementation… I’d first check to see if there is an important difference between how <code>appendo</code> is written for the two dialects.

It may be the same, but I wouldn’t be surprised if it wasn’t.</z><z id="t1536843312000100" t="risto ugh..."><y>#</y><d>2018-09-13</d><h>12:55</h><w>risto</w>ugh...</z><z id="t1536843329000100" t="risto does anyone know any paper I can read on this or something similar? I can&apos;t find anything on this"><y>#</y><d>2018-09-13</d><h>12:55</h><w>risto</w>does anyone know any paper I can read on this or something similar? I can&apos;t find anything on this</z><z id="t1536843378000100" t="risto i don&apos;t want to rely on reverse engineering some implementation in case they&apos;re doing something weird to make it work, which could end up breaking other abstractions in weird ways"><y>#</y><d>2018-09-13</d><h>12:56</h><w>risto</w>i don&apos;t want to rely on reverse engineering some implementation in case they&apos;re doing something weird to make it work, which could end up breaking other abstractions in weird ways</z><z id="t1536853770000100" t="rickmoynihan If you’re using core.logic I think you’re probably safest sticking to minikanren literature…. but I have questions about this stuff myself, because i’m not 100% sure either."><y>#</y><d>2018-09-13</d><h>15:49</h><w>rickmoynihan</w>If you’re using core.logic I think you’re probably safest sticking to minikanren literature…. but I have questions about this stuff myself, because i’m not 100% sure either.</z><z id="t1536853818000100" t="hiredman core.logic is a minikanren like clojure is a lisp"><y>#</y><d>2018-09-13</d><h>15:50</h><w>hiredman</w>core.logic is a minikanren like clojure is a lisp</z><z id="t1536853886000100" t="hiredman I still think you are likely encountering a confusion of different levels, and the things you think are calling each other are at different levels of abstraction and not actually calling each other"><y>#</y><d>2018-09-13</d><h>15:51</h><w>hiredman</w>I still think you are likely encountering a confusion of different levels, and the things you think are calling each other are at different levels of abstraction and not actually calling each other</z><z id="t1536856763000100" t="risto i&apos;m not confusing different levels of abstraction"><y>#</y><d>2018-09-13</d><h>16:39</h><w>risto</w>i&apos;m not confusing different levels of abstraction</z><z id="t1536856770000100" t="risto i&apos;m working on implementing minikanren"><y>#</y><d>2018-09-13</d><h>16:39</h><w>risto</w>i&apos;m working on implementing minikanren</z><z id="t1536856847000100" t="hiredman sure, I&apos;ve done that, I followed the original thesis paper describing it"><y>#</y><d>2018-09-13</d><h>16:40</h><w>hiredman</w>sure, I&apos;ve done that, I followed the original thesis paper describing it</z><z id="t1536856943000200" t="hiredman which seems to be a dead link now 😕"><y>#</y><d>2018-09-13</d><h>16:42</h><w>hiredman</w>which seems to be a dead link now <b>😕</b></z><z id="t1536880859000100" t="rickmoynihan I think this is the best link for that paper now btw: https://github.com/webyrd/dissertation-single-spaced/blob/master/thesis.pdf"><y>#</y><d>2018-09-13</d><h>23:20</h><w>rickmoynihan</w>I think this is the best link for that paper now btw: <a href="https://github.com/webyrd/dissertation-single-spaced/blob/master/thesis.pdf" target="_blank">https://github.com/webyrd/dissertation-single-spaced/blob/master/thesis.pdf</a></z><z id="t1536881013000100" t="rickmoynihan Incidentally I can confirm there are differences in appendo between minikanren and microkanren… though they’re pretty close: The reasoned schemer 2nd edition (microkanren) lists it as: (defrel (appendo l t out) (conde ((nullo l) (== t out)) ((fresh (res) (fresh (d) (cdro l d) (appendo d t res)) (fresh (a) (caro l a) (conso a res out)))))) "><y>#</y><d>2018-09-13</d><h>23:23</h><w>rickmoynihan</w>Incidentally I can confirm there are differences in appendo between minikanren and microkanren… though they’re pretty close:

The reasoned schemer 2nd edition (microkanren) lists it as:
<pre>(defrel (appendo l t out)
  (conde
    ((nullo l) (== t out))
    ((fresh (res)
     (fresh (d)
       (cdro l d)
       (appendo d t res))
     (fresh (a)
       (caro l a)
       (conso a res out))))))
</pre></z><z id="t1536881231000100" t="rickmoynihan 1st edition (minikanren) as: (define appendo (lambda (l s out) (conde ((nullo l) (== s out)) (else (fresh (a d res) (caro l a) (cdro l d) (appendo d s res) (conso a res out)))))) "><y>#</y><d>2018-09-13</d><h>23:27</h><w>rickmoynihan</w>1st edition (minikanren) as:

<pre>(define appendo
  (lambda (l s out)
  (conde
    ((nullo l) (== s out))
    (else
      (fresh (a d res)
        (caro l a)
        (cdro l d)
        (appendo d s res)
        (conso a res out))))))
</pre></z><z id="t1536881379000100" t="rickmoynihan (I hand typed those — so there may be errors)"><y>#</y><d>2018-09-13</d><h>23:29</h><w>rickmoynihan</w>(I hand typed those — so there may be errors)</z><z id="t1536881448000100" t="rickmoynihan most differences are pretty negligible… main one here seems to be that fresh in microkanren doesn’t handle multiple bindings at once, and that conde no longer takes an else in microkanren"><y>#</y><d>2018-09-13</d><h>23:30</h><w>rickmoynihan</w>most differences are pretty negligible… main one here seems to be that <code>fresh</code> in microkanren doesn’t handle multiple bindings at once, and that <code>conde</code> no longer takes an <code>else</code> in microkanren</z><z id="t1536881672000100" t="hiredman I know you keep saying it isn&apos;t a level confusion issue, but I really still think it is, because bind, flatmap, etc are part of the little mini monadic library used for the the lazy streams of results from goals, but they are not actually used in goals themselves"><y>#</y><d>2018-09-13</d><h>23:34</h><w>hiredman</w>I know you keep saying it isn&apos;t a level confusion issue, but I really still think it is, because bind, flatmap, etc are part of the little mini monadic library used for the the lazy streams of results from goals, but they are not actually used in goals themselves</z><z id="t1536881791000100" t="hiredman and it has been pretty much a million years since I read the paper, and my implementation was in go, so I didn&apos;t bother with any of the list processing library and instead built stuff for using reflection to unify over go records, so I didn&apos;t implement appendo or conso"><y>#</y><d>2018-09-13</d><h>23:36</h><w>hiredman</w>and it has been pretty much a million years since I read the paper, and my implementation was in go, so I didn&apos;t bother with any of the list processing library and instead built stuff for using reflection to unify over go records, so I didn&apos;t implement appendo or conso</z><z id="t1536881928000100" t="hiredman conso, appendo, pretty much anything ending in o is a relation(or function returning a goal), that exists sort of within the domain of minikanren, but bind and flatmap are functions that exist outside of the domain of minikaren and are used to implement it"><y>#</y><d>2018-09-13</d><h>23:38</h><w>hiredman</w>conso, appendo, pretty much anything ending in o is a relation(or function returning a goal), that exists sort of within the domain of minikanren, but bind and flatmap are functions that exist outside of the domain of minikaren and are used to implement it</z><z id="t1536882024000100" t="hiredman the papers tend translate the &apos;o&apos; suffix as a ° (degree symbol) which can make it easy to miss and confuse the names"><y>#</y><d>2018-09-13</d><h>23:40</h><w>hiredman</w>the papers tend translate the &apos;o&apos; suffix as a ° (degree symbol) which can make it easy to miss and confuse the names</z><z id="t1536929909000100" t="rickmoynihan agreed. I think the confusion is also perhaps because conj in microkanren is not clojure’s conj. It’s conj^2 which is conjunctive (`and`)… likewise disj in microkanren is disjuntive i.e. or . Not sure if core.logic ports these functions directly either, as they’re part of microkanren… and perhaps not minikanren… would need to look."><y>#</y><d>2018-09-14</d><h>12:58</h><w>rickmoynihan</w>agreed.  I think the confusion is also perhaps because <code>conj</code> in microkanren is not clojure’s conj.  It’s <code>conj^2</code> which is conjunctive (`and`)… likewise <code>disj</code> in microkanren is disjuntive i.e. <code>or</code>.  Not sure if core.logic ports these functions directly either, as they’re part of microkanren… and perhaps not minikanren… would need to look.</z><z id="t1536929977000100" t="rickmoynihan I don’t have the papers in front of me though so could also be wrong…"><y>#</y><d>2018-09-14</d><h>12:59</h><w>rickmoynihan</w>I don’t have the papers in front of me though so could also be wrong…</z><z id="t1536957791000100" t="risto i know -o is a relation, how those lazy streams and conj/disj are implremented key in making sure appendo doesnt recurse forever and blow the stack"><y>#</y><d>2018-09-14</d><h>20:43</h><w>risto</w>i know -o is a relation, how those lazy streams and conj/disj are implremented key in making sure appendo doesnt recurse forever and blow the stack</z><z id="t1536958001000100" t="hiredman thats not true, the fact that appendo does case analysis and only one of the cases can be true at a time, and induction on the first argument (the first argument is smaller on every recursvie call) is what guarantees termination"><y>#</y><d>2018-09-14</d><h>20:46</h><w>hiredman</w>thats not true, the fact that appendo does case analysis and only one of the cases can be true at a time, and induction on the first argument (the first argument is smaller on every recursvie call) is what guarantees termination</z><z id="t1536958100000100" t="hiredman ah, the blowing the stack"><y>#</y><d>2018-09-14</d><h>20:48</h><w>hiredman</w>ah, the blowing the stack</z><z id="t1536958143000100" t="hiredman that is because in your implementation you are doing the recursive call to appendo when appendo is called, not as the logic program is running"><y>#</y><d>2018-09-14</d><h>20:49</h><w>hiredman</w>that is because in your implementation you are doing the recursive call to appendo when appendo is called, not as the logic program is running</z><z id="t1536958159000100" t="hiredman doing that switch is tricky in a language without macros"><y>#</y><d>2018-09-14</d><h>20:49</h><w>hiredman</w>doing that switch is tricky in a language without macros</z><z id="t1536958208000100" t="hiredman in my go implementation I had a special goal constructor for making recursive calls to make that work"><y>#</y><d>2018-09-14</d><h>20:50</h><w>hiredman</w>in my go implementation I had a special goal constructor for making recursive calls to make that work</z><z id="t1536958286000100" t="hiredman https://github.com/hiredman/gologic/blob/master/gologic.go#L533-L550 https://github.com/hiredman/gologic/blob/master/gologic_test.go#L110-L116"><y>#</y><d>2018-09-14</d><h>20:51</h><w>hiredman</w><a href="https://github.com/hiredman/gologic/blob/master/gologic.go#L533-L550" target="_blank">https://github.com/hiredman/gologic/blob/master/gologic.go#L533-L550</a> <a href="https://github.com/hiredman/gologic/blob/master/gologic_test.go#L110-L116" target="_blank">https://github.com/hiredman/gologic/blob/master/gologic_test.go#L110-L116</a></z><z id="t1536958305000100" t="risto yeah"><y>#</y><d>2018-09-14</d><h>20:51</h><w>risto</w>yeah</z><z id="t1536958323000100" t="risto there&apos;s something key with that which im messing up"><y>#</y><d>2018-09-14</d><h>20:52</h><w>risto</w>there&apos;s something key with that which im messing up</z><z id="t1536958350000100" t="hiredman it doesn&apos;t have to do with the stream implementation"><y>#</y><d>2018-09-14</d><h>20:52</h><w>hiredman</w>it doesn&apos;t have to do with the stream implementation</z><z id="t1536958392000100" t="hiredman it has to do with goal construction, which without macros, you can&apos;t delay the recursive call until you know if you have to do it"><y>#</y><d>2018-09-14</d><h>20:53</h><w>hiredman</w>it has to do with goal construction, which without macros, you can&apos;t delay the recursive call until you know if you have to do it</z><z id="t1536958458000100" t="hiredman so if or or disj is a regular function, all of its arguments must be evaluated before it is called, and if one of those is a recursive call, boom"><y>#</y><d>2018-09-14</d><h>20:54</h><w>hiredman</w>so if <code>or</code> or <code>disj</code> is a regular function, all of its arguments must be evaluated before it is called, and if one of those is a recursive call, boom</z><z id="t1536958498000100" t="risto yeah, it has to delay the goal somehow"><y>#</y><d>2018-09-14</d><h>20:54</h><w>risto</w>yeah, it has to delay the goal somehow</z><z id="t1536958601000100" t="hiredman so my Call goal constructor in go would look something like (fn [goal &amp; args] (fn [package] ((apply goal args) package))) in clojure"><y>#</y><d>2018-09-14</d><h>20:56</h><w>hiredman</w>so my Call goal constructor in go would look something like <code>(fn [goal &amp; args] (fn [package] ((apply goal args) package)))</code> in clojure</z><z id="t1536958880000100" t="hiredman which has a similar structure to what conde in core.logic expands to https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic.clj#L1175-L1183"><y>#</y><d>2018-09-14</d><h>21:01</h><w>hiredman</w>which has a similar structure to what conde in core.logic expands to <a href="https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic.clj#L1175-L1183" target="_blank">https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic.clj#L1175-L1183</a></z><z id="t1537017465000100" t="andrea.crotti If there something like ntho available or any suggestions about how to implement it? "><y>#</y><d>2018-09-15</d><h>13:17</h><w>andrea.crotti</w>If there something like ntho available or any suggestions about how to implement it? </z><z id="t1537017507000100" t="andrea.crotti I just need a logic express to check that an element is at a certain index of a vector "><y>#</y><d>2018-09-15</d><h>13:18</h><w>andrea.crotti</w>I just need a logic express to check that an element is at a certain index of a vector </z><z id="t1537032006000100" t="andrea.crotti Never mind that was the wrong approach, I&apos;ll try a few more things first I might be close already "><y>#</y><d>2018-09-15</d><h>17:20</h><w>andrea.crotti</w>Never mind that was the wrong approach, I&apos;ll try a few more things first I might be close already </z><z id="t1537032069000100" t="andrea.crotti In short I would like to have something that given a scrabble configuration and a list of letters return all the possible valid words "><y>#</y><d>2018-09-15</d><h>17:21</h><w>andrea.crotti</w>In short I would like to have something that given a scrabble configuration and a list of letters return all the possible valid words </z><z id="t1537032143000100" t="andrea.crotti So given with configuration &quot;h_ll_&quot; and letters &quot;hello&quot; it would return trivially just (&quot;hello&quot;) "><y>#</y><d>2018-09-15</d><h>17:22</h><w>andrea.crotti</w>So given with configuration &quot;h_ll_&quot; and letters &quot;hello&quot;  it would return trivially just (&quot;hello&quot;) </z><z id="t1537032186000100" t="andrea.crotti It can be modelled similarly to sudoku actually and I think I&apos;m close"><y>#</y><d>2018-09-15</d><h>17:23</h><w>andrea.crotti</w>It can be modelled similarly to sudoku actually and I think I&apos;m close</z><z id="t1540755810004400" t="folcon Just kicking around core logic with one of the initial tutorials and I have this basic definition set: (pldb/db-rel parent x y) (defn grandparent [x y] (logic/fresh [z] (parent x z) (parent z y))) Now if I do this: (apply pldb/db [[parent :Bob :Mike] [parent :Mike :John]]) #_=&gt; {&quot;logic.test/parent_2&quot; #:cljs.core.logic.pldb{:unindexed #{(:Bob :Mike) (:Mike :John)}}} I get the result I expect, but when I do this: (apply pldb/db [[grandparent :Bob :John] [parent :Mike :John]]) #_=&gt; {nil #:cljs.core.logic.pldb{:unindexed #{(:Bob :John)}}, &quot;logic.test/parent_2&quot; #:cljs.core.logic.pldb{:unindexed #{(:Mike :John)}}} I get the above which I don’t understand, how do I not have the (:Bob :Mike) relation? Have I misunderstood something? Note: I have tried: (grandparent :Bob :John) =&gt; #object[Function] ((grandparent :Bob :John)) =&gt; #object[cljs.core.logic.Inc] but feeding them into the apply pldb/db statement just gave exceptions, so I thought I was going down the wrong track…"><y>#</y><d>2018-10-28</d><h>19:43</h><w>folcon</w>Just kicking around core logic with one of the initial tutorials and I have this basic definition set:
<pre>(pldb/db-rel parent x y)
(defn grandparent [x y]
  (logic/fresh [z]
      (parent x z)
      (parent z y)))
</pre>
Now if I do this:
<pre>(apply pldb/db
    [[parent :Bob :Mike] [parent :Mike :John]])
#_=&gt; {&quot;logic.test/parent_2&quot;
 #:cljs.core.logic.pldb{:unindexed #{(:Bob :Mike) (:Mike :John)}}}
</pre>
I get the result I expect, but when I do this:
<pre>(apply pldb/db
    [[grandparent :Bob :John] [parent :Mike :John]])
#_=&gt; {nil #:cljs.core.logic.pldb{:unindexed #{(:Bob :John)}},
 &quot;logic.test/parent_2&quot;
 #:cljs.core.logic.pldb{:unindexed #{(:Mike :John)}}}
</pre>
I get the above which I don’t understand, how do I not have the <code>(:Bob :Mike)</code> relation? Have I misunderstood something?
Note: I have tried:
<code>(grandparent :Bob :John)</code> =&gt; <code>#object[Function]</code>
<code>((grandparent :Bob :John))</code> =&gt; <code>#object[cljs.core.logic.Inc]</code>
but feeding them into the <code>apply pldb/db</code> statement just gave exceptions, so I thought I was going down the wrong track…</z><z id="t1540762282004900" t="hiredman you can&apos;t really call things in core.logic like that"><y>#</y><d>2018-10-28</d><h>21:31</h><w>hiredman</w>you can&apos;t really call things in core.logic like that</z><z id="t1540762313005500" t="hiredman the grandparent function is returning a a goal, and the goal has to be inside a call to run or run* to see what the result is"><y>#</y><d>2018-10-28</d><h>21:31</h><w>hiredman</w>the grandparent function is returning a a goal, and the goal has to be inside a call to run or run* to see what the result is</z><z id="t1540762431006500" t="hiredman I haven&apos;t really used pldb, but my guess is to create facts you call the name of the relation as a function"><y>#</y><d>2018-10-28</d><h>21:33</h><w>hiredman</w>I haven&apos;t really used pldb, but my guess is to create facts you call the name of the relation as a function</z><z id="t1540762456007000" t="hiredman (parent :Bob :Mike) not [parent :Bob :Mike]"><y>#</y><d>2018-10-28</d><h>21:34</h><w>hiredman</w><code>(parent :Bob :Mike)</code> not <code>[parent :Bob :Mike]</code></z><z id="t1540762488007400" t="hiredman but I might be wrong there"><y>#</y><d>2018-10-28</d><h>21:34</h><w>hiredman</w>but I might be wrong there</z><z id="t1540762594007900" t="hiredman and I am, the pldb tests show the vector thing (at least on the clojure side) https://github.com/clojure/core.logic/blob/master/src/test/clojure/clojure/core/logic/pldb/tests.clj#L15"><y>#</y><d>2018-10-28</d><h>21:36</h><w>hiredman</w>and I am, the pldb tests show the vector thing (at least on the clojure side) <a href="https://github.com/clojure/core.logic/blob/master/src/test/clojure/clojure/core/logic/pldb/tests.clj#L15" target="_blank">https://github.com/clojure/core.logic/blob/master/src/test/clojure/clojure/core/logic/pldb/tests.clj#L15</a></z><z id="t1540762719009500" t="hiredman in your example, grandparent is a core.logic goal, not a pldb fact, so you cannot use it like that"><y>#</y><d>2018-10-28</d><h>21:38</h><w>hiredman</w>in your example, grandparent is a core.logic goal, not a pldb fact, so you cannot use it like that</z><z id="t1540762801010500" t="hiredman a core.logic goal is like a query you can run over facts, in this case grandparent is a query you can run over a database of parent relationships to derive grandparent relationships"><y>#</y><d>2018-10-28</d><h>21:40</h><w>hiredman</w>a core.logic goal is like a query you can run over facts, in this case grandparent is a query you can run over a database of parent relationships to derive grandparent relationships</z><z id="t1540763039012000" t="folcon Ok, but given these are relational operators, is there no way that I can take the statement [grandparent :Bob :John] and derive that that means =&gt; [parent :Bob _] [parent _ :John] ?"><y>#</y><d>2018-10-28</d><h>21:43</h><w>folcon</w>Ok, but given these are relational operators, is there no way that I can take the statement <code>[grandparent :Bob :John]</code> and derive that that means =&gt; <code>[parent :Bob _] [parent _ :John]</code>?</z><z id="t1540763072012400" t="folcon It’s very likely that I’m formulating these incorrectly."><y>#</y><d>2018-10-28</d><h>21:44</h><w>folcon</w>It’s very likely that I’m formulating these incorrectly.</z><z id="t1540763113013000" t="folcon Basically I’m trying to understand how I can create new facts, from statements."><y>#</y><d>2018-10-28</d><h>21:45</h><w>folcon</w>Basically I’m trying to understand how I can create new facts, from statements.</z><z id="t1540763133013200" t="folcon Or is that just not possible?"><y>#</y><d>2018-10-28</d><h>21:45</h><w>folcon</w>Or is that just not possible?</z><z id="t1540763199013700" t="folcon Do I need to work out how to define grandparent as a db-rel perhaps?"><y>#</y><d>2018-10-28</d><h>21:46</h><w>folcon</w>Do I need to work out how to define <code>grandparent</code> as a <code>db-rel</code> perhaps?</z><z id="t1540763663014800" t="hiredman you are looking to infer new facts based on existing facts and definitions of relationships between facts"><y>#</y><d>2018-10-28</d><h>21:54</h><w>hiredman</w>you are looking to infer new facts based on existing facts and definitions of relationships between facts</z><z id="t1540763817017000" t="hiredman you have sort of half that, the missing half is you have to write something that runs the grandparents (rewritten to return some kind of inferred list of parent facts) and adds the results to the database"><y>#</y><d>2018-10-28</d><h>21:56</h><w>hiredman</w>you have sort of half that, the missing half is you have to write something that runs the grandparents (rewritten to return some kind of inferred list of parent facts) and adds the results to the database</z><z id="t1540763841017400" t="hiredman you might want something more like a rules engine, like clara"><y>#</y><d>2018-10-28</d><h>21:57</h><w>hiredman</w>you might want something more like a rules engine, like clara</z><z id="t1540763863017600" t="hiredman http://www.clara-rules.org/"><y>#</y><d>2018-10-28</d><h>21:57</h><w>hiredman</w><a href="http://www.clara-rules.org/" target="_blank">http://www.clara-rules.org/</a></z><z id="t1540763939018300" t="hiredman clara has a fairly active slack channel if it does look like what you want #clara"><y>#</y><d>2018-10-28</d><h>21:58</h><w>hiredman</w>clara has a fairly active slack channel if it does look like what you want #clara</z><z id="t1540763999019700" t="hiredman but I dunno, maybe not, because rules engines generally don&apos;t have logic variables"><y>#</y><d>2018-10-28</d><h>21:59</h><w>hiredman</w>but I dunno, maybe not, because rules engines generally don&apos;t have logic variables</z><z id="t1540764053021000" t="hiredman so [parent :Bob ?x] [parent ?x :John] isn&apos;t going to be directly something you can assert in to it"><y>#</y><d>2018-10-28</d><h>22:00</h><w>hiredman</w>so [parent :Bob ?x] [parent ?x :John] isn&apos;t going to be directly something you can assert in to it</z><z id="t1540764167022400" t="hiredman on the other hand, given the definition of grandparent, by construction if grandparent is true then we know [parent :Bob ?x] [parent ?x :John] is already true in the database, so there is no point in asserting it"><y>#</y><d>2018-10-28</d><h>22:02</h><w>hiredman</w>on the other hand, given the definition of grandparent, by construction if grandparent is true then we know  [parent :Bob ?x] [parent ?x :John] is already true in the database, so there is no point in asserting it</z><z id="t1540764208022800" t="folcon Thanks for mentioning clara =)…"><y>#</y><d>2018-10-28</d><h>22:03</h><w>folcon</w>Thanks for mentioning clara =)…</z><z id="t1540764248023400" t="folcon I’m still going through the Reasoned Schemer at the moment, so I’m going to keep reading that and banging my head against this for at least the next week or so and see if I can get somewhere and if that completely fails I’ll give it a look. Much appreciate your help though :)…"><y>#</y><d>2018-10-28</d><h>22:04</h><w>folcon</w>I’m still going through the Reasoned Schemer at the moment, so I’m going to keep reading that and banging my head against this for at least the next week or so and see if I can get somewhere and if that completely fails I’ll give it a look. Much appreciate your help though :)…</z><z id="t1540769977024300" t="folcon Also just out of curiosity, is there a reason that a lot of the examples I see use symbols? Instead of say keywords?"><y>#</y><d>2018-10-28</d><h>23:39</h><w>folcon</w>Also just out of curiosity, is there a reason that a lot of the examples I see use symbols? Instead of say keywords?</z><z id="t1540770015024800" t="folcon I just got bitten by this: (l/run* [q] (l/== &apos;((pea) pod) `((pea) ~q))) =&gt; () (l/run* [q] (l/== &apos;(pea pod) `(pea ~q))) =&gt; () (l/run* [q] (l/== &apos;(:pea :pod) `(:pea ~q))) =&gt; (:pod) "><y>#</y><d>2018-10-28</d><h>23:40</h><w>folcon</w>I just got bitten by this:
<pre>(l/run* [q]
  (l/== 
    &apos;((pea)  pod)
    `((pea) ~q)))
=&gt; ()
(l/run* [q]
  (l/== 
    &apos;(pea  pod)
    `(pea ~q)))
=&gt; ()
(l/run* [q]
  (l/== 
    &apos;(:pea  :pod)
    `(:pea ~q)))
=&gt; (:pod)
</pre></z><z id="t1540770075025800" t="folcon Finally realised it’s because in clojure the “`” resolves the symbol to the namespace, so the two symbols aren’t equal."><y>#</y><d>2018-10-28</d><h>23:41</h><w>folcon</w>Finally realised it’s because in clojure the “`” resolves the symbol to the namespace, so the two symbols aren’t equal.</z><z id="t1540907362032600" t="rickmoynihan FYI the clojure syntax to unqualify a symbol during a is to use ~&apos;foo`"><y>#</y><d>2018-10-30</d><h>13:49</h><r>rickmoynihan</r>FYI the clojure syntax to unqualify a symbol during a <code> </code> <code> is to use </code>~&apos;foo`</z><z id="t1540907510032900" t="rickmoynihan I’m assuming by examples you mean minikanren/TRS examples, that you’re porting to clojure rather than core.logic ones"><y>#</y><d>2018-10-30</d><h>13:51</h><r>rickmoynihan</r>I’m assuming by examples you mean minikanren/TRS examples, that you’re porting to clojure rather than <code>core.logic</code> ones</z><z id="t1540778245029100" t="folcon I’m somewhat surprised by how different the syntax is between core.logic and what’s in the reasoned schemer, it’s taking me a while to find the exact matching functions. For example, I spent a while I thinking that conj2 was conjo right up until this happened: (l/run* [q] (l/conjo u# (l/== &apos;corn q))) =&gt; (_0) eventually I worked out it was just: (l/run* [q] (l/and* [u# (l/== &apos;corn q)])) =&gt; () But this stuff isn’t obvious and so far googling hasn’t shown that those two functions match. (Assuming that I’m right about that…)"><y>#</y><d>2018-10-29</d><h>01:57</h><w>folcon</w>I’m somewhat surprised by how different the syntax is between <code>core.logic</code> and what’s in the reasoned schemer, it’s taking me a while to find the exact matching functions. For example, I spent a while I thinking that <code>conj2</code> was <code>conjo</code> right up until this happened:
<pre>(l/run* [q]
  (l/conjo u# (l/== &apos;corn q)))
=&gt; (_0)
</pre>
eventually I worked out it was just:
<pre>(l/run* [q]
  (l/and* [u# (l/== &apos;corn q)]))
=&gt; ()
</pre>
But this stuff isn’t obvious and so far googling hasn’t shown that those two functions match. (Assuming that I’m right about that…)</z><z id="t1540778301029900" t="folcon I’m recording all the gotcha’s that I’m finding, but not really sure if it’s really of interest seeing as it’s not really been written anywhere…"><y>#</y><d>2018-10-29</d><h>01:58</h><w>folcon</w>I’m recording all the gotcha’s that I’m finding, but not really sure if it’s really of interest seeing as it’s not really been written anywhere…</z><z id="t1540894492030200" t="deliciousowl https://github.com/clojure/core.logic/wiki/Differences-from-The-Reasoned-Schemer"><y>#</y><d>2018-10-30</d><h>10:14</h><w>deliciousowl</w><a href="https://github.com/clojure/core.logic/wiki/Differences-from-The-Reasoned-Schemer" target="_blank">https://github.com/clojure/core.logic/wiki/Differences-from-The-Reasoned-Schemer</a></z><z id="t1540907226032400" t="rickmoynihan @folcon: do you have 1st or 2nd edition reasoned schemer? Because the minikanren implementation changed between those versions… and core.logic was derived from the 1st edition of the reasoned schemer not the 2nd. I’m not sure of all the differences might be caused that, but there will certainly be some. It might be worth mentioning this on that wiki page."><y>#</y><d>2018-10-30</d><h>13:47</h><w>rickmoynihan</w>@folcon: do you have 1st or 2nd edition reasoned schemer?  Because the minikanren implementation changed between those versions… and core.logic was derived from the 1st edition of the reasoned schemer not the 2nd.

I’m not sure of all the differences might be caused that, but there will certainly be some.

It might be worth mentioning this on that wiki page.</z><z id="t1540912770033200" t="folcon 2nd edition"><y>#</y><d>2018-10-30</d><h>15:19</h><w>folcon</w>2nd edition</z><z id="t1540912786033600" t="folcon as I’m going to it fresh so I thought I’d get the 2nd ed"><y>#</y><d>2018-10-30</d><h>15:19</h><w>folcon</w>as I’m going to it fresh so I thought I’d get the 2nd ed</z><z id="t1540912835034300" t="folcon I’m happy to document it somewhere, I was planning on doing a write up anyway…"><y>#</y><d>2018-10-30</d><h>15:20</h><w>folcon</w>I’m happy to document it somewhere, I was planning on doing a write up anyway…</z><z id="t1540912852034600" t="folcon Hopefully others don’t get stuck =)…"><y>#</y><d>2018-10-30</d><h>15:20</h><w>folcon</w>Hopefully others don’t get stuck =)…</z><z id="t1540915604035100" t="rickmoynihan @folcon: IIRC someone else was on here a few weeks ago who had some similar confusion."><y>#</y><d>2018-10-30</d><h>16:06</h><w>rickmoynihan</w>@folcon: IIRC someone else was on here a few weeks ago who had some similar confusion.</z><z id="t1540915716035400" t="rickmoynihan See in the logs here: https://clojurians-log.clojureverse.org/core-logic/2018-09-12 and here: https://clojurians-log.clojureverse.org/core-logic/2018-09-13"><y>#</y><d>2018-10-30</d><h>16:08</h><w>rickmoynihan</w>See in the logs here:

<a href="https://clojurians-log.clojureverse.org/core-logic/2018-09-12" target="_blank">https://clojurians-log.clojureverse.org/core-logic/2018-09-12</a>

and here:

<a href="https://clojurians-log.clojureverse.org/core-logic/2018-09-13" target="_blank">https://clojurians-log.clojureverse.org/core-logic/2018-09-13</a></z><z id="t1540916031035700" t="folcon Thanks, I’ll have a read 😃"><y>#</y><d>2018-10-30</d><h>16:13</h><w>folcon</w>Thanks, I’ll have a read <b>😃</b></z><z id="t1543217979039400" t="Jacob O&apos;Bryant I&apos;m trying to write a program to calculate the solution in the board game Clue. I&apos;m very new to core.logic , so I&apos;m starting off with a really simple version: given all the cards in my hand and in my opponents&apos; hands, what are the three remaining cards? I&apos;ve written the code below, but (do-query) just makes the CPU max out and never returns. How should I write this? Should I take a different approach? (def players [:green :scarlet :peacock :mustard :white :plum]) (def rooms [:study :hall :lounge :dining-room :kitchen :ballroom :conservatory :billiard-room :library]) (def weapons [:candlestick :lead-pipe :revolver :wrench :rope :knife]) (def all-cards (concat players rooms weapons)) (defn do-query [] (let [cards (repeatedly 21 logic/lvar) [solution remaining] (split-at 3 cards) [my-cards remaining] (split-at 6 remaining) [green-cards scarlet-cards] (split-at 6 remaining)] (logic/run 1 [p r w] (logic/== solution [p r w]) (logic/permuteo all-cards cards) (logic/== my-cards [:rope :study :scarlet :conservatory :mustard :wrench]) (logic/== green-cards [:green :lead-pipe :knife :dining-room :billiard-room :library]) (logic/== scarlet-cards [:revolver :plum :hall :lounge :kitchen :white]) (logic/membero p players) (logic/membero r rooms) (logic/membero w weapons)))) "><y>#</y><d>2018-11-26</d><h>07:39</h><w>Jacob O'Bryant</w>I&apos;m trying to write a program to calculate the solution in the board game Clue. I&apos;m very new to <code>core.logic</code>, so I&apos;m starting off with a really simple version: given all the cards in my hand and in my opponents&apos; hands, what are the three remaining cards? I&apos;ve written the code below, but <code>(do-query)</code> just makes the CPU max out and never returns. How should I write this? Should I take a different approach?

<pre>(def players [:green :scarlet :peacock :mustard :white :plum])
(def rooms [:study :hall :lounge :dining-room :kitchen :ballroom
            :conservatory :billiard-room :library])
(def weapons [:candlestick :lead-pipe :revolver :wrench :rope :knife])
(def all-cards (concat players rooms weapons))

(defn do-query []
  (let [cards (repeatedly 21 logic/lvar)
        [solution remaining] (split-at 3 cards)
        [my-cards remaining] (split-at 6 remaining)
        [green-cards scarlet-cards] (split-at 6 remaining)]
    (logic/run 1 [p r w]
      (logic/== solution [p r w])
      (logic/permuteo all-cards cards)
      (logic/== my-cards [:rope :study :scarlet
                          :conservatory :mustard :wrench])
      (logic/== green-cards [:green :lead-pipe :knife :dining-room
                             :billiard-room :library])
      (logic/== scarlet-cards [:revolver :plum :hall
                               :lounge :kitchen :white])
      (logic/membero p players)
      (logic/membero r rooms)
      (logic/membero w weapons))))
</pre></z><z id="t1543251958039700" t="hiredman the permuteo is what does it"><y>#</y><d>2018-11-26</d><h>17:05</h><w>hiredman</w>the permuteo is what does it</z><z id="t1543252075040300" t="hiredman it results in a search tree with a lot of branches"><y>#</y><d>2018-11-26</d><h>17:07</h><w>hiredman</w>it results in a search tree with a lot of branches</z><z id="t1543252192040800" t="hiredman come to think of it, I don&apos;t think I&apos;ve ever played clue"><y>#</y><d>2018-11-26</d><h>17:09</h><w>hiredman</w>come to think of it, I don&apos;t think I&apos;ve ever played clue</z><z id="t1543252928042300" t="hiredman I think I would start from a map of card names to lvars, where each lvar will have a value like :mine, :opponent, or :deck (if deck is valid in clue)"><y>#</y><d>2018-11-26</d><h>17:22</h><w>hiredman</w>I think I would start from a map of card names to lvars, where each lvar will have a value like :mine, :opponent, or :deck (if deck is valid in clue)</z><z id="t1543376034049000" t="Jacob O&apos;Bryant thanks, I&apos;ll try going down that route"><y>#</y><d>2018-11-28</d><h>03:33</h><r>Jacob O'Bryant</r>thanks, I&apos;ll try going down that route</z><z id="t1543267348043300" t="schmee if I have a core.logic goal that looks like this (fresh [?1 ?2 ?3 ?4] (membero ?1 vars) (membero ?2 vars) (membero ?3 vars) (membero ?4 vars) ...) will that expand into vars × vars × vars × vars in memory, even if I have other goals that constrain the answer set to something much smaller?"><y>#</y><d>2018-11-26</d><h>21:22</h><w>schmee</w>if I have a core.logic goal that looks like this
<pre>(fresh [?1 ?2 ?3 ?4]
      (membero ?1 vars)
      (membero ?2 vars)
      (membero ?3 vars)
      (membero ?4 vars)
      ...)
</pre>
will that expand into <code>vars × vars × vars × vars</code> in memory, even if I have other goals that constrain the answer set to something much smaller?</z><z id="t1543267406043600" t="hiredman it depends what you mean by expands in memory"><y>#</y><d>2018-11-26</d><h>21:23</h><w>hiredman</w>it depends what you mean by expands in memory</z><z id="t1543267455044600" t="hiredman you will end up with a search tree that has at least that many branches, but the search tree typically is walked in a lazy fashion so the whole thing isn&apos;t realized at once"><y>#</y><d>2018-11-26</d><h>21:24</h><w>hiredman</w>you will end up with a search tree that has at least that many branches, but the search tree typically is walked in a lazy fashion so the whole thing isn&apos;t realized at once</z><z id="t1543301721045300" t="schmee here’s the actual thing: (run* [q] (init vars legs) (with-fresh (membero ?1 vars) (membero ?2 vars) (membero ?3 vars) (membero ?4 vars) (== ?1 [&quot;M&quot; ?a1 ?b1]) (== ?2 [&quot;T&quot; ?a2 ?b2]) (== ?3 [&quot;W&quot; ?a3 ?b3]) (== ?4 [&quot;R&quot; ?a4 ?b4]) (== ?b1 ?a2) (== ?b2 ?a3) (== ?b3 ?a4) (== q [?1 ?2 ?3 ?4])))) "><y>#</y><d>2018-11-27</d><h>06:55</h><w>schmee</w>here’s the actual thing:
<pre>(run* [q]
    (init vars legs)
    (with-fresh
      (membero ?1 vars)
      (membero ?2 vars)
      (membero ?3 vars)
      (membero ?4 vars)
      (== ?1 [&quot;M&quot; ?a1 ?b1])
      (== ?2 [&quot;T&quot; ?a2 ?b2])
      (== ?3 [&quot;W&quot; ?a3 ?b3])
      (== ?4 [&quot;R&quot; ?a4 ?b4])
      (== ?b1 ?a2)
      (== ?b2 ?a3)
      (== ?b3 ?a4)
      (== q [?1 ?2 ?3 ?4]))))
</pre></z><z id="t1543301747045800" t="schmee vars is a collection of tuples like this: [&quot;M&quot; &quot;SAN_ANTONIO&quot; &quot;HOUSTON&quot;] (day of week, start, end)"><y>#</y><d>2018-11-27</d><h>06:55</h><w>schmee</w><code>vars</code> is a collection of tuples like this: <code>[&quot;M&quot; &quot;SAN_ANTONIO&quot; &quot;HOUSTON&quot;]</code> (day of week, start, end)</z><z id="t1543301779046200" t="schmee I’m messing around with a core.logic solution to https://kevinlynagh.com/notes/shipping-puzzle/"><y>#</y><d>2018-11-27</d><h>06:56</h><w>schmee</w>I’m messing around with a core.logic solution to <a href="https://kevinlynagh.com/notes/shipping-puzzle/" target="_blank">https://kevinlynagh.com/notes/shipping-puzzle/</a></z><z id="t1543301828047100" t="schmee but running the above with just 100 tuples take 15 minutes to produce one result"><y>#</y><d>2018-11-27</d><h>06:57</h><w>schmee</w>but running the above with just 100 tuples take 15 minutes to produce one result</z><z id="t1543301911047900" t="schmee (`with-fresh` just binds all ? variables to a fresh lvar)"><y>#</y><d>2018-11-27</d><h>06:58</h><w>schmee</w>(`with-fresh` just binds all <code>?</code> variables to a fresh lvar)</z><z id="t1543346342048900" t="norman How much faster does it go if you move the memberos to the end?"><y>#</y><d>2018-11-27</d><h>19:19</h><w>norman</w>How much faster does it go if you move the memberos to the end?</z><z id="t1543449343049600" t="arohner Are there any examples of core.logic being used with functions(rather than macros)? I have a problem where I want to build up goals from data, so the heavy-macro usage seems to get in the way"><y>#</y><d>2018-11-28</d><h>23:55</h><w>arohner</w>Are there any examples of core.logic being used with functions(rather than macros)? I have a problem where I want to build up goals from data, so the heavy-macro usage seems to get in the way</z><z id="t1543449353049900" t="arohner also the number of logic variables is unknown at compile time"><y>#</y><d>2018-11-28</d><h>23:55</h><w>arohner</w>also the number of logic variables is unknown at compile time</z><z id="t1543449620051500" t="hiredman https://gist.github.com/hiredman/05befd5b39eef89b86ca#file-bench-clj-L28-L35 isn&apos;t all that dynamic but it creates lvars via a function call, and then uses l/composeg to constrain all the generate lvars"><y>#</y><d>2018-11-29</d><h>00:00</h><w>hiredman</w><a href="https://gist.github.com/hiredman/05befd5b39eef89b86ca#file-bench-clj-L28-L35" target="_blank">https://gist.github.com/hiredman/05befd5b39eef89b86ca#file-bench-clj-L28-L35</a> isn&apos;t all that dynamic but it creates lvars via a function call,  and then uses l/composeg to constrain all the generate lvars</z><z id="t1543449690051700" t="arohner thanks"><y>#</y><d>2018-11-29</d><h>00:01</h><w>arohner</w>thanks</z><z id="t1543449760052600" t="arohner my number of goals is also dynamic based on the data. Clearly I can read the source and call the macro expansions directly, just wondering how ‘against the grain’ that is"><y>#</y><d>2018-11-29</d><h>00:02</h><w>arohner</w>my number of goals is also dynamic based on the data. Clearly I can read the source and call the macro expansions directly, just wondering how ‘against the grain’ that is</z><z id="t1543449802053000" t="hiredman https://gist.github.com/terjesb/3181018 might another interesting thing to look at, particular the usage of to-stream"><y>#</y><d>2018-11-29</d><h>00:03</h><w>hiredman</w><a href="https://gist.github.com/terjesb/3181018" target="_blank">https://gist.github.com/terjesb/3181018</a> might another interesting thing to look at, particular the usage of to-stream</z><z id="t1543449899054500" t="hiredman I kind of doubt you actually want that, it would be similar to a clojure program with a dynamic number of functions based on the data, it is possible, but much more likely you have a fixed number of functions and you want to drive the composition via the data"><y>#</y><d>2018-11-29</d><h>00:04</h><w>hiredman</w>I kind of doubt you actually want that, it would be similar to a clojure program with a dynamic number of functions based on the data, it is possible, but much more likely you have a fixed number of functions and you want to drive the composition via the data</z><z id="t1543449960055300" t="hiredman but, for example, that code I linked generates a goal per items in a map, and then composes them all in to one goal"><y>#</y><d>2018-11-29</d><h>00:06</h><w>hiredman</w>but, for example, that code I linked generates a goal per items in a map, and then composes them all in to one goal</z><z id="t1543450071056000" t="arohner I think there are a fixed set of functions, with an unknown number of function calls"><y>#</y><d>2018-11-29</d><h>00:07</h><w>arohner</w>I think there are a fixed set of functions, with an unknown number of function calls</z><z id="t1543450174057500" t="hiredman I don&apos;t think that is against the grain at all"><y>#</y><d>2018-11-29</d><h>00:09</h><w>hiredman</w>I don&apos;t think that is against the grain at all</z><z id="t1543450410058900" t="hiredman likely you&apos;ll end up with a lot of stuff similar pos-int-vals in that first example, where you map some function over all your data generating a goal for each part of the data, then reduce it with composeg to create a single goal"><y>#</y><d>2018-11-29</d><h>00:13</h><w>hiredman</w>likely you&apos;ll end up with a lot of stuff similar pos-int-vals in that first example, where you map some function over all your data generating a goal for each part of the data, then reduce it with composeg to create a single goal</z><z id="t1543450478059400" t="hiredman composeg is conjuction of goals, and there is another one for disjunction"><y>#</y><d>2018-11-29</d><h>00:14</h><w>hiredman</w>composeg is conjuction of goals, and there is another one for disjunction</z><z id="t1543934038000500" t="rickmoynihan @arohner: I’d like to do something similar"><y>#</y><d>2018-12-04</d><h>14:33</h><w>rickmoynihan</w>@arohner: I’d like to do something similar</z><z id="t1550899798000400" t="Kelly Innes Hello!"><y>#</y><d>2019-02-23</d><h>05:29</h><w>Kelly Innes</w>Hello!</z><z id="t1550899837001200" t="Kelly Innes I&apos;m trying to work through latest edition of the The Reasoned Schemer in Clojure and I&apos;m encountering some Scheme syntax I don&apos;t quite know how to translate."><y>#</y><d>2019-02-23</d><h>05:30</h><w>Kelly Innes</w>I&apos;m trying to work through latest edition of the The Reasoned Schemer in Clojure and I&apos;m encountering some Scheme syntax I don&apos;t quite know how to translate.</z><z id="t1550899975002800" t="Kelly Innes (run* [q] (== `(((,q)) pod) &apos;(((pea) pod)))) (run* [q] (== &apos;(((pea)) pod) `(((pea)) ,q))) are analogues for chapter 1, frame 33 and 34, and should associate q with pod and pea, respectively"><y>#</y><d>2019-02-23</d><h>05:32</h><w>Kelly Innes</w><pre>(run* [q]
  (== `(((,q)) pod) &apos;(((pea) pod))))

(run* [q]
  (== &apos;(((pea)) pod) `(((pea)) ,q)))
</pre>

are analogues for chapter 1, frame 33 and 34, and should associate q with <code>pod and </code>pea, respectively</z><z id="t1550900003003500" t="Kelly Innes However, I&apos;m getting () for both when I eval then with CIDER. Am I doing something incorrectly?"><y>#</y><d>2019-02-23</d><h>05:33</h><w>Kelly Innes</w>However, I&apos;m getting <code>()</code> for both when I eval then with CIDER. Am I doing something incorrectly?</z><z id="t1550900187003700" t="hiredman , is ~"><y>#</y><d>2019-02-23</d><h>05:36</h><w>hiredman</w>, is ~</z><z id="t1550900205004100" t="hiredman , is unquote in scheme and whitespace in clojure"><y>#</y><d>2019-02-23</d><h>05:36</h><w>hiredman</w><code>,</code> is unquote in scheme and whitespace in clojure</z><z id="t1550900222004500" t="hiredman ~ is syntax-unquote in clojure"><y>#</y><d>2019-02-23</d><h>05:37</h><w>hiredman</w><code>~</code> is syntax-unquote in clojure</z><z id="t1550900269004700" t="Kelly Innes Awesome, thank you~"><y>#</y><d>2019-02-23</d><h>05:37</h><w>Kelly Innes</w>Awesome, thank you~</z><z id="t1550900395004900" t="Kelly Innes Wonderful, that&apos;s working~"><y>#</y><d>2019-02-23</d><h>05:39</h><w>Kelly Innes</w>Wonderful, that&apos;s working~</z><z id="t1550900401005100" t="Kelly Innes (run* [q] (fresh [x] (== `(~x) q))) "><y>#</y><d>2019-02-23</d><h>05:40</h><w>Kelly Innes</w><pre>(run* [q]
  (fresh [x]
    (== `(~x) q)))
</pre></z><z id="t1550901466005800" t="Kelly Innes HM, I still must have something wrong because these two are evaluating incorrectly:"><y>#</y><d>2019-02-23</d><h>05:57</h><w>Kelly Innes</w>HM, I still must have something wrong because these two are evaluating incorrectly:</z><z id="t1550901467006000" t="Kelly Innes (run* [q] (== &apos;(((pea)) pod) `(((pea)) ~q))) (run* [q] (fresh [x] (== `(((~q)) ~x) `(((~x)) pod)))) "><y>#</y><d>2019-02-23</d><h>05:57</h><w>Kelly Innes</w><pre>(run* [q]
  (== &apos;(((pea)) pod) `(((pea)) ~q)))

(run* [q]
  (fresh [x]
    (== `(((~q)) ~x) `(((~x)) pod))))
</pre></z><z id="t1550903470006600" t="yuhan that&apos;s due to the auto namespacing of symbols in syntax-quoted forms"><y>#</y><d>2019-02-23</d><h>06:31</h><w>yuhan</w>that&apos;s due to the auto namespacing of symbols in syntax-quoted forms</z><z id="t1550903614007900" t="yuhan ie. the first pea is a regular non-namespaced symbol but the second expands to your-ns/pea"><y>#</y><d>2019-02-23</d><h>06:33</h><w>yuhan</w>ie. the first <code>pea</code> is a regular non-namespaced symbol but the second expands to <code>your-ns/pea</code></z><z id="t1550903670008600" t="yuhan I think a much more idomatic way of doing this in Clojure is using vectors"><y>#</y><d>2019-02-23</d><h>06:34</h><w>yuhan</w>I think a much more idomatic way of doing this in Clojure is using vectors</z><z id="t1550903691008800" t="yuhan (run* [q] (== [[[&apos;pea]] &apos;pod] [[[&apos;pea]] q])) (run* [q] (fresh [x] (== [[[q]] x] [[[x]] &apos;pod]))) "><y>#</y><d>2019-02-23</d><h>06:34</h><w>yuhan</w><pre>(run* [q]
  (== [[[&apos;pea]] &apos;pod] [[[&apos;pea]] q]))

(run* [q]
  (fresh [x]
    (== [[[q]] x] [[[x]] &apos;pod])))
</pre></z><z id="t1550938041009400" t="Kelly Innes Cool, thank you -- I&apos;ll try replacing the lists with vectors when I hit a snag like this again."><y>#</y><d>2019-02-23</d><h>16:07</h><w>Kelly Innes</w>Cool, thank you -- I&apos;ll try replacing the lists with vectors when I hit a snag like this again.</z><z id="t1550946858009700" t="Kelly Innes Awesome, I was able to get through chapter 1! https://github.com/kellyi/clj-lisp-sandbox/blob/master/reasoned-schemer/src/reasoned_schemer/one.clj"><y>#</y><d>2019-02-23</d><h>18:34</h><w>Kelly Innes</w>Awesome, I was able to get through chapter 1! <a href="https://github.com/kellyi/clj-lisp-sandbox/blob/master/reasoned-schemer/src/reasoned_schemer/one.clj" target="_blank">https://github.com/kellyi/clj-lisp-sandbox/blob/master/reasoned-schemer/src/reasoned_schemer/one.clj</a></z><z id="t1551148279010100" t="devn Yusssssssss"><y>#</y><d>2019-02-26</d><h>02:31</h><w>devn</w>Yusssssssss</z><z id="t1551646089000600" t="Kelly Innes Completed translations of Chapters 3 and 4 of Reasoned Schemer into Clojure here, too: https://github.com/kellyi/clj-lisp-sandbox/tree/master/reasoned-schemer/src/reasoned_schemer"><y>#</y><d>2019-03-03</d><h>20:48</h><w>Kelly Innes</w>Completed translations of Chapters 3 and 4 of Reasoned Schemer into Clojure here, too: <a href="https://github.com/kellyi/clj-lisp-sandbox/tree/master/reasoned-schemer/src/reasoned_schemer" target="_blank">https://github.com/kellyi/clj-lisp-sandbox/tree/master/reasoned-schemer/src/reasoned_schemer</a></z><z id="t1551646120001000" t="Kelly Innes I noticed that https://github.com/clojure/core.logic/wiki/Differences-from-The-Reasoned-Schemer recommends not using vectors generally but instead sticking with list or llist :"><y>#</y><d>2019-03-03</d><h>20:48</h><w>Kelly Innes</w>I noticed that <a href="https://github.com/clojure/core.logic/wiki/Differences-from-The-Reasoned-Schemer" target="_blank">https://github.com/clojure/core.logic/wiki/Differences-from-The-Reasoned-Schemer</a> recommends not using vectors generally but instead sticking with <code>list</code> or <code>llist</code>:</z><z id="t1551646137001200" t="Kelly Innes &gt; Related, implementing list? as shown in TRS 3-1 is unnecessary. seq? is more appropriate in Clojure. This is because proper list-like things and pairs are not conflated in Clojure as they are in Scheme. In general you should not use vectors when working through TRS. Use list or a quoted list. TRS examples that use Scheme quasiquote will need to be written like so (TRS 3-7):"><y>#</y><d>2019-03-03</d><h>20:48</h><w>Kelly Innes</w>&gt; Related, implementing list? as shown in TRS 3-1 is unnecessary. seq? is more appropriate in Clojure. This is because proper list-like things and pairs are not conflated in Clojure as they are in Scheme. In general you should not use vectors when working through TRS. Use list or a quoted list. TRS examples that use Scheme quasiquote will need to be written like so (TRS 3-7):</z><z id="t1560542804001700" t="nblumoe Hi! Is there a way to express disequality with core.logic in CLJS? Here is a small example what I would like to do: (l/run* [p] (l/fresh [pos-1 pos-2] (l/membero pos-1 [0 1]) (l/membero pos-2 [0 1]) (l/!= pos-1 pos-2) ;; pos-1 must not be equal to pos-2 (l/== p [{:x pos-1} {:x pos-2}]))) https://github.com/clojure/core.logic/wiki/Using-core.logic-with-ClojureScript says disequality constraints aren&apos;t available on CLJS. Is there a way around this? Are finite domains available on CLJS?"><y>#</y><d>2019-06-14</d><h>20:06</h><w>nblumoe</w>Hi! Is there a way to express disequality with core.logic in CLJS?

Here is a small example what I would like to do:
<pre>(l/run* [p]
          (l/fresh [pos-1 pos-2]
                   (l/membero pos-1 [0 1])
                   (l/membero pos-2 [0 1])
                   (l/!= pos-1 pos-2)                 ;; pos-1 must not be equal to pos-2
                   (l/== p [{:x pos-1}
                            {:x pos-2}])))
</pre>

<a href="https://github.com/clojure/core.logic/wiki/Using-core.logic-with-ClojureScript" target="_blank">https://github.com/clojure/core.logic/wiki/Using-core.logic-with-ClojureScript</a> says disequality constraints aren&apos;t available on CLJS. Is there a way around this?

Are finite domains available on CLJS?</z><z id="t1560543389001800" t="noprompt I can’t speak to core logic but you can express this kind of thing in a forward way with Meander. If you’re interested, feel free to share your problem in #meander."><y>#</y><d>2019-06-14</d><h>20:16</h><r>noprompt</r>I can’t speak to core logic but you can express this kind of thing in a forward way with Meander. If you’re interested, feel free to share your problem in #meander.</z><z id="t1564094472004800" t="javazquez Hi everyone, I just started digging into core.logic and trying to wrap my brain around it. I created a family tree that looks like the following (def facts (pldb/db [parento :james :jerry] [parento :jerry :jordan] [parento :jerry :richard] [parento :jerry :harry] [parento :jerry :jackson] [parento :george :james])) Jerry has multiple kiddos and George is the great grand father to jordan, richard, harry and jackson. I have been struggling to write code that given one of these children, would produce all the ancestors without dups ex. given :jackson return jerry, james, george any help would be greatly appreciated 🙂"><y>#</y><d>2019-07-25</d><h>22:41</h><w>javazquez</w>Hi everyone, I just started digging into core.logic and trying to wrap my brain around it.
I created a family tree that looks like the following
(def facts
  (pldb/db
   [parento :james :jerry]
   [parento :jerry :jordan]
   [parento :jerry :richard]
   [parento :jerry :harry]
   [parento :jerry :jackson]
   [parento :george :james]))
Jerry has multiple kiddos and George is the great grand father to jordan, richard, harry and jackson.
I have been struggling to write code that given one of these children, would produce all the ancestors without dups
ex.  given :jackson return
jerry, james, george

any help would be greatly appreciated <b>🙂</b></z><z id="t1564095355007100" t="hiredman something of the form (defn accesto [foo q] (l/conde [(parento q foo)][(l/fresh [x] (parento q x) (parento x foo))])) but I haven&apos;t really used pldb and I am pretty rusty"><y>#</y><d>2019-07-25</d><h>22:55</h><w>hiredman</w>something of the form <code>(defn accesto [foo q] (l/conde [(parento q foo)][(l/fresh [x] (parento q x) (parento x foo))]))</code> but I haven&apos;t really used pldb and I am pretty rusty</z><z id="t1564095458008100" t="hiredman but unique results can be difficult to achieve, just because of the iterative way queries run"><y>#</y><d>2019-07-25</d><h>22:57</h><w>hiredman</w>but unique results can be difficult to achieve, just because of the iterative way queries run</z><z id="t1564095566008400" t="javazquez i see"><y>#</y><d>2019-07-25</d><h>22:59</h><w>javazquez</w>i see</z><z id="t1564095569008600" t="javazquez ok"><y>#</y><d>2019-07-25</d><h>22:59</h><w>javazquez</w>ok</z><z id="t1564095574008800" t="javazquez Thank you!"><y>#</y><d>2019-07-25</d><h>22:59</h><w>javazquez</w>Thank you!</z><z id="t1564097318010300" t="javazquez Out of curiosity and learning, would you model the data differently?"><y>#</y><d>2019-07-25</d><h>23:28</h><w>javazquez</w>Out of curiosity and learning, would you model the data differently?</z><z id="t1564098265010600" t="hiredman nope"><y>#</y><d>2019-07-25</d><h>23:44</h><w>hiredman</w>nope</z><z id="t1564567139011700" t="cheatex Hi. I&apos;m experimenting with the pldb module. And the only sample fails when I try it."><y>#</y><d>2019-07-31</d><h>09:58</h><w>cheatex</w>Hi. I&apos;m experimenting with the pldb module. And the only sample fails when I try it.</z><z id="t1564567158012000" t="cheatex ClassCastException class clojure.core.logic.LVar cannot be cast to class java.lang.Number (clojure.core.logic.LVar is in unnamed module of loader clojure.lang.DynamicClassLoader @7dffda8b; java.lang.Number is in module java.base of loader &apos;bootstrap&apos;) clojure.lang.Numbers.equiv (Numbers.java:213)"><y>#</y><d>2019-07-31</d><h>09:59</h><w>cheatex</w><code>ClassCastException class clojure.core.logic.LVar cannot be cast to class java.lang.Number (clojure.core.logic.LVar is in unnamed module of loader clojure.lang.DynamicClassLoader @7dffda8b; java.lang.Number is in module java.base of loader &apos;bootstrap&apos;)  clojure.lang.Numbers.equiv (Numbers.java:213)</code></z><z id="t1564568097012300" t="cheatex Ok, i&apos;ve messed up namespaces"><y>#</y><d>2019-07-31</d><h>10:14</h><w>cheatex</w>Ok, i&apos;ve messed up namespaces</z><z id="t1570733021006500" t="hiredman clojure contrib projects (which basically means anything under the clojure org in github) don&apos;t take pull requests"><y>#</y><d>2019-10-10</d><h>18:43</h><w>hiredman</w>clojure contrib projects (which basically means anything under the clojure org in github) don&apos;t take pull requests</z><z id="t1570733028006700" t="hiredman you have to file a patch in jira"><y>#</y><d>2019-10-10</d><h>18:43</h><w>hiredman</w>you have to file a patch in jira</z><z id="t1570733110007300" t="hiredman it has been over two years since the last patch went in, so you may have to wait awhile"><y>#</y><d>2019-10-10</d><h>18:45</h><w>hiredman</w>it has been over two years since the last patch went in, so you may have to wait awhile</z><z id="t1572756494008000" t="sogaiu does lein classpath work for anyone else with the latest?"><y>#</y><d>2019-11-03</d><h>04:48</h><w>sogaiu</w>does lein classpath work for anyone else with the latest?</z><z id="t1572756557008300" t="sogaiu or lein deps for that matter 🙂"><y>#</y><d>2019-11-03</d><h>04:49</h><w>sogaiu</w>or lein deps for that matter <b>🙂</b></z><z id="t1572757033009200" t="sogaiu commenting out the [cider/cider-nrepl &quot;0.8.1&quot;] portion of project.clj alows those commands to complete..."><y>#</y><d>2019-11-03</d><h>04:57</h><w>sogaiu</w>commenting out the [cider/cider-nrepl &quot;0.8.1&quot;] portion of project.clj alows those commands to complete...</z><z id="t1572759031009700" t="dpsutton that&apos;s over four years old and from a time when cider wouldn&apos;t auto-inject its own dependencies. it should be removed"><y>#</y><d>2019-11-03</d><h>05:30</h><w>dpsutton</w>that&apos;s over four years old and from a time when cider wouldn&apos;t auto-inject its own dependencies. it should be removed</z><z id="t1572759087010000" t="sogaiu @dpsutton perhaps i should file an issue?"><y>#</y><d>2019-11-03</d><h>05:31</h><w>sogaiu</w>@dpsutton perhaps i should file an issue?</z><z id="t1572759148010800" t="dpsutton i can&apos;t speak for the project maintainer or who would want it but that sounds reasonable. possibly make a new question on http://ask.clojure.com ? I think that&apos;s the way for tickets to be approved into jira"><y>#</y><d>2019-11-03</d><h>05:32</h><w>dpsutton</w>i can&apos;t speak for the project maintainer or who would want it but that sounds reasonable. possibly make a new question on <a href="http://ask.clojure.com" target="_blank">http://ask.clojure.com</a>? I think that&apos;s the way for tickets to be approved into jira</z><z id="t1572759177011200" t="sogaiu thanks, i&apos;ll look into ask.clojure"><y>#</y><d>2019-11-03</d><h>05:32</h><w>sogaiu</w>thanks, i&apos;ll look into ask.clojure</z><z id="t1572989729012800" t="sogaiu after some reconsideration and spelunking...@seancorfield i noticed you have made some commits to core.logic in the past, perhaps you would know what a good way to report about the project.clj issue mentioned above is."><y>#</y><d>2019-11-05</d><h>21:35</h><w>sogaiu</w>after some reconsideration and spelunking...@seancorfield i noticed you have made some commits to core.logic in the past, perhaps you would know what a good way to report about the project.clj issue mentioned above is.</z><z id="t1572990063013600" t="seancorfield My commits have been purely administrative -- I haven&apos;t touched the code and I&apos;ve never used core.logic ."><y>#</y><d>2019-11-05</d><h>21:41</h><w>seancorfield</w>My commits have been purely administrative -- I haven&apos;t touched the code and I&apos;ve never used <code>core.logic</code>.</z><z id="t1572990224014400" t="seancorfield According to https://clojure.org/community/contrib_libs core.logic is &quot;Stable&quot; -- meaning development is irregular at best."><y>#</y><d>2019-11-05</d><h>21:43</h><w>seancorfield</w>According to <a href="https://clojure.org/community/contrib_libs" target="_blank">https://clojure.org/community/contrib_libs</a> <code>core.logic</code> is &quot;Stable&quot; -- meaning development is irregular at best.</z><z id="t1572990302014700" t="seancorfield If you have a JIRA account, you can log an issue here https://clojure.atlassian.net/projects/LOGIC/issues"><y>#</y><d>2019-11-05</d><h>21:45</h><w>seancorfield</w>If you have a JIRA account, you can log an issue here <a href="https://clojure.atlassian.net/projects/LOGIC/issues" target="_blank">https://clojure.atlassian.net/projects/LOGIC/issues</a></z><z id="t1572990351015600" t="seancorfield Otherwise, write up an issue on http://ask.clojure.org and Alex should see it and if it&apos;s just a matter of updating project.clj or the instructions, he may go ahead and do it @sogaiu"><y>#</y><d>2019-11-05</d><h>21:45</h><w>seancorfield</w>Otherwise, write up an issue on <a href="http://ask.clojure.org" target="_blank">http://ask.clojure.org</a> and Alex should see it and if it&apos;s just a matter of updating <code>project.clj</code> or the instructions, he may go ahead and do it @sogaiu</z><z id="t1572990400016000" t="sogaiu @seancorfield thanks for the help!"><y>#</y><d>2019-11-05</d><h>21:46</h><w>sogaiu</w>@seancorfield thanks for the help!</z><z id="t1573562718016700" t="rickmoynihan Looks like that fix was applied: https://github.com/clojure/core.logic/commit/3b63f43097667d4686043d78a90affb967af93de"><y>#</y><d>2019-11-12</d><h>12:45</h><w>rickmoynihan</w>Looks like that fix was applied: <a href="https://github.com/clojure/core.logic/commit/3b63f43097667d4686043d78a90affb967af93de" target="_blank">https://github.com/clojure/core.logic/commit/3b63f43097667d4686043d78a90affb967af93de</a></z><z id="t1573571548018400" t="sogaiu yes, thanks to dpsutton and seancorfield suggesting the ask.clojure route. alexmiller was very helpful there: https://ask.clojure.org/index.php/8831/lein-deps-lein-classpath-fail-current-core-logic-where-report"><y>#</y><d>2019-11-12</d><h>15:12</h><w>sogaiu</w>yes, thanks to dpsutton and seancorfield suggesting the ask.clojure route.  alexmiller was very helpful there: <a href="https://ask.clojure.org/index.php/8831/lein-deps-lein-classpath-fail-current-core-logic-where-report" target="_blank">https://ask.clojure.org/index.php/8831/lein-deps-lein-classpath-fail-current-core-logic-where-report</a></z><z id="t1573724411018700" t="rickmoynihan cool TIL: mvn -q dependency:build-classpath -Dmdep.outputFile=classpath.txt"><y>#</y><d>2019-11-14</d><h>09:40</h><w>rickmoynihan</w>cool TIL: <code>mvn -q dependency:build-classpath -Dmdep.outputFile=classpath.txt</code></z><z id="t1573726293019300" t="rickmoynihan The one thing I’d like fixed in core.logic is this warning on newer clojure versions: WARNING: indexed? already refers to: #&apos;clojure.core/indexed? in namespace: clojure.core.logic.pldb, being replaced by: #&apos;clojure.core.logic.pldb/indexed? "><y>#</y><d>2019-11-14</d><h>10:11</h><w>rickmoynihan</w>The one thing I’d like fixed in core.logic is this warning on newer clojure versions:

<pre>WARNING: indexed? already refers to: #&apos;clojure.core/indexed? in namespace: clojure.core.logic.pldb, being replaced by: #&apos;clojure.core.logic.pldb/indexed?
</pre></z><z id="t1573726323019700" t="rickmoynihan not a major issue, but it winds me up 🙂"><y>#</y><d>2019-11-14</d><h>10:12</h><w>rickmoynihan</w>not a major issue, but it winds me up <b>🙂</b></z><z id="t1573743611020600" t="sogaiu @rickmoynihan the maven thing was nice indeed -- wanted to be able to send the output to stdout to pass it on to another program (without using an intermediate file), but haven&apos;t had much luck figuring that one out."><y>#</y><d>2019-11-14</d><h>15:00</h><w>sogaiu</w>@rickmoynihan the maven thing was nice indeed -- wanted to be able to send the output to stdout to pass it on to another program (without using an intermediate file), but haven&apos;t had much luck figuring that one out.</z><z id="t1573865471022900" t="xiongtx I’m trying to find a more natural way of destructuring maps. Basically, I want: (require &apos;[clojure.core.logic :as l) (l/run* [q b d] (l/featurec q {:a {:b b} :d d}) &lt;some other constraints&gt; (l/== q {:a {:b 1 :c &quot;irrelevant&quot;} :d [1 2 3] :e &quot;whatever&quot;})) To return ([{:a {:b 1}, :d [1 2 3]} 1 [1 2 3]]) , i.e. q should have only the form specified in the featurec constraint. What’s the best way to do that?"><y>#</y><d>2019-11-16</d><h>00:51</h><w>xiongtx</w>I’m trying to find a more natural way of destructuring maps. Basically, I want:

<pre>(require &apos;[clojure.core.logic :as l)

(l/run* [q b d]
  (l/featurec q {:a {:b b}
                 :d d})
&lt;some other constraints&gt;
  (l/== q {:a {:b 1
               :c &quot;irrelevant&quot;}
           :d [1 2 3]
           :e &quot;whatever&quot;}))
</pre>

To return <code>([{:a {:b 1}, :d [1 2 3]} 1 [1 2 3]])</code>, i.e. <code>q</code> should have only the form specified in the <code>featurec</code> constraint. What’s the best way to do that?</z><z id="t1573869575027900" t="noprompt @U2J7JRTDX Meander’s pattern matcher is suited for this task (among others): (m/find {:a {:b 1 :c &quot;irrelevant&quot;} :d [1 2 3] :e &quot;whatever&quot;} {:a {:b ?b} :d ?d :as ?q} [?q ?b ?d]) ;; =&gt; [{:a {:b 1, :c &quot;irrelevant&quot;} :d [1 2 3] :e &quot;whatever&quot;} 1 [1 2 3]] "><y>#</y><d>2019-11-16</d><h>01:59</h><r>noprompt</r>@U2J7JRTDX Meander’s pattern matcher is suited for this task (among others): <pre>(m/find {:a {:b 1
             :c &quot;irrelevant&quot;}
         :d [1 2 3]
         :e &quot;whatever&quot;}
  {:a {:b ?b}
   :d ?d
   :as ?q}
  [?q ?b ?d])
;; =&gt;
[{:a {:b 1, :c &quot;irrelevant&quot;}
  :d [1 2 3]
  :e &quot;whatever&quot;}
 1
 [1 2 3]]
</pre></z><z id="t1573869593028100" t="noprompt https://github.com/noprompt/meander"><y>#</y><d>2019-11-16</d><h>01:59</h><r>noprompt</r><a href="https://github.com/noprompt/meander" target="_blank">https://github.com/noprompt/meander</a></z><z id="t1573869806028800" t="xiongtx Ah, I knew this had to be a solved problem! Thanks!"><y>#</y><d>2019-11-16</d><h>02:03</h><r>xiongtx</r>Ah, I knew this had to be a solved problem! Thanks!</z><z id="t1573869828029000" t="noprompt You can even query maps for multiple answers."><y>#</y><d>2019-11-16</d><h>02:03</h><r>noprompt</r>You can even query maps for multiple answers.</z><z id="t1573869830029200" t="noprompt (m/search {:a {:b 1 :c &quot;irrelevant&quot;} :d [1 2 3] :e {:f &quot;whatever&quot;}} {?k {:as ?v}} [?k ?v]) ;; =&gt; ([:e {:f &quot;whatever&quot;}] [:a {:b 1, :c &quot;irrelevant&quot;}]) "><y>#</y><d>2019-11-16</d><h>02:03</h><r>noprompt</r><pre>(m/search {:a {:b 1
               :c &quot;irrelevant&quot;}
           :d [1 2 3]
           :e {:f &quot;whatever&quot;}}
  {?k {:as ?v}}
  [?k ?v])
;; =&gt;
([:e {:f &quot;whatever&quot;}] [:a {:b 1, :c &quot;irrelevant&quot;}])
</pre></z><z id="t1573869858029400" t="noprompt We’re located in the #meander channel for more on the topic of pattern matching/rewriting."><y>#</y><d>2019-11-16</d><h>02:04</h><r>noprompt</r>We’re located in the #meander channel for more on the topic of pattern matching/rewriting.</z><z id="t1573869882029600" t="noprompt Its a work in progress but we can do some neat stuff if you have these kinds of problems 🙂"><y>#</y><d>2019-11-16</d><h>02:04</h><r>noprompt</r>Its a work in progress but we can do some neat stuff if you have these kinds of problems <b>🙂</b></z><z id="t1573872716029800" t="xiongtx Actually, I see that the ?q returned by meander is still contains keys that aren’t specified in the matching map, i.e. :c &amp; :e ."><y>#</y><d>2019-11-16</d><h>02:51</h><r>xiongtx</r>Actually, I see that the <code>?q</code> returned by <code>meander</code> is still contains keys that aren’t specified in the matching map, i.e. <code>:c</code> &amp; <code>:e</code>.</z><z id="t1573873035030000" t="xiongtx Here’s more what I had in mind, based on https://stackoverflow.com/a/40560433 (obviously not a comprehensive solution). (defn pathwalk [f path e] (let [e&apos; (f path e)] (cond (map? e&apos;) (-&gt;&gt; e&apos; (map (fn [[k x]] [k (pathwalk f (conj path k) x)])) (into (empty e&apos;))) (coll? e&apos;) (-&gt;&gt; e&apos; (map-indexed (fn [i x] (pathwalk f (conj path i) x))) (into (empty e&apos;))) :else e&apos;))) (defn match-only [match m] (let [bindings (atom {}) form (atom {})] (pathwalk (fn [path v] (when (symbol? v) (let [x (get-in m path)] (swap! form assoc-in path x) (swap! bindings assoc v x))) v) [] match) [@form @bindings])) (match-only &apos;{:a {:b b} :d d} {:a {:b 1 :c &quot;irrelevant&quot;} :d [1 2 3] :e &quot;whatever&quot;}) ;; =&gt; [{:a {:b 1}, :d [1 2 3]} {b 1, d [1 2 3]}] "><y>#</y><d>2019-11-16</d><h>02:57</h><r>xiongtx</r>Here’s more what I had in mind, based on <a href="https://stackoverflow.com/a/40560433" target="_blank">https://stackoverflow.com/a/40560433</a> (obviously not a comprehensive solution).

<pre>(defn pathwalk [f path e]
  (let [e&apos; (f path e)]
    (cond
      (map? e&apos;)  (-&gt;&gt; e&apos;
                      (map (fn [[k x]] [k (pathwalk f (conj path k) x)]))
                      (into (empty e&apos;)))
      (coll? e&apos;) (-&gt;&gt; e&apos;
                      (map-indexed (fn [i x] (pathwalk f (conj path i) x)))
                      (into (empty e&apos;)))
      :else e&apos;)))

(defn match-only
  [match m]
  (let [bindings (atom {})
        form (atom {})]
    (pathwalk (fn [path v]
                (when (symbol? v)
                  (let [x (get-in m path)]
                    (swap! form assoc-in path x)
                    (swap! bindings assoc v x)))
                v)
              []
              match)
    [@form @bindings]))
</pre>

<pre>(match-only &apos;{:a {:b b}
              :d d}
            {:a {:b 1
                 :c &quot;irrelevant&quot;}
             :d [1 2 3]
             :e &quot;whatever&quot;})
;; =&gt; [{:a {:b 1}, :d [1 2 3]} {b 1, d [1 2 3]}]
</pre></z><z id="t1573935103030300" t="noprompt @U2J7JRTDX Sorry for the late reply. It is possible to return only the part of the map that matched but it requires some advanced use of the library. If you know what you’re querying for (which is usually half the battle) you could simply construct the data on the right side as so: (m/find {:a {:b 1 :c &quot;irrelevant&quot;} :d [1 2 3] :e &quot;whatever&quot;} {:a {:b ?b} :d ?d} [{:a {:b ?b} :d ?d} {:b ?b} ?d]) ;; =&gt; [{:a {:b 1}, :d [1 2 3]} {:b 1} [1 2 3]] "><y>#</y><d>2019-11-16</d><h>20:11</h><r>noprompt</r>@U2J7JRTDX Sorry for the late reply. It is possible to return only the part of the map that matched but it requires some advanced use of the library. If you know what you’re querying for (which is usually half the battle) you could simply construct the data on the right side as so: <pre>(m/find {:a {:b 1
             :c &quot;irrelevant&quot;}
         :d [1 2 3]
         :e &quot;whatever&quot;}
  {:a {:b ?b}
   :d ?d}
  [{:a {:b ?b} :d ?d}
   {:b ?b}
   ?d])
;; =&gt;
[{:a {:b 1}, :d [1 2 3]} {:b 1} [1 2 3]]
</pre></z><z id="t1574126862030500" t="xiongtx Been using meander for value extraction in some of our tests &amp; it’s been great! E.g. :nauseated_face: (-&gt; query graphql-request (get-in [:data :applications :edges]) first (get-in [:node :app_accounts :edges]) first :node (select-keys [:account_name])) to 😄 (meander/match (graphql-request query) {:data {:applications {:edges [{:node {:app_accounts {:edges [{:node {:account_name ?account-name}}]}}}]}}} {:account_name ?account-name}) Great job!"><y>#</y><d>2019-11-19</d><h>01:27</h><r>xiongtx</r>Been using <code>meander</code> for value extraction in some of our tests &amp; it’s been great! E.g.

<b>:nauseated_face:</b>
<pre>(-&gt; query
    graphql-request
    (get-in [:data :applications :edges])
    first
    (get-in [:node :app_accounts :edges])
    first
    :node
    (select-keys [:account_name]))
</pre>

to

<b>😄</b>
<pre>(meander/match (graphql-request query)
  {:data
   {:applications
    {:edges
     [{:node
       {:app_accounts
        {:edges
         [{:node
           {:account_name ?account-name}}]}}}]}}}
  {:account_name ?account-name})
</pre>

Great job!</z><z id="t1574127293030800" t="noprompt Sweet! :+1:"><y>#</y><d>2019-11-19</d><h>01:34</h><r>noprompt</r>Sweet! <b>:+1:</b></z><z id="t1573865870023500" t="hiredman you can&apos;t really"><y>#</y><d>2019-11-16</d><h>00:57</h><w>hiredman</w>you can&apos;t really</z><z id="t1573865931023800" t="hiredman I take that back, you can"><y>#</y><d>2019-11-16</d><h>00:58</h><w>hiredman</w>I take that back, you can</z><z id="t1573866044026100" t="hiredman I am back to can&apos;t. basically the way to build structures via unification requires and exact match, and featurec does not require an exact match, and core.logic doesn&apos;t provide relational operations on maps"><y>#</y><d>2019-11-16</d><h>01:00</h><w>hiredman</w>I am back to can&apos;t. basically the way to build structures via unification requires and exact match, and featurec does not require an exact match, and core.logic doesn&apos;t provide relational operations on maps</z><z id="t1573866448026600" t="xiongtx Hmm, so you’re saying unification can’t do a partial match?"><y>#</y><d>2019-11-16</d><h>01:07</h><w>xiongtx</w>Hmm, so you’re saying unification can’t do a partial match?</z><z id="t1573866528026900" t="hiredman right"><y>#</y><d>2019-11-16</d><h>01:08</h><w>hiredman</w>right</z><z id="t1575514329031300" t="dpsutton if i have 6 logic variables, is there a way to ensure that 5 of them are distinct?"><y>#</y><d>2019-12-05</d><h>02:52</h><w>dpsutton</w>if i have 6 logic variables, is there a way to ensure that 5 of them are distinct?</z><z id="t1575536148031400" t="nitaai See distinct under https://github.com/clojure/core.logic/wiki/Features#clpfd I assume that’s what you are looking for."><y>#</y><d>2019-12-05</d><h>08:55</h><r>nitaai</r>See <code>distinct</code> under <a href="https://github.com/clojure/core.logic/wiki/Features#clpfd" target="_blank">https://github.com/clojure/core.logic/wiki/Features#clpfd</a>

I assume that’s what you are looking for.</z><z id="t1575624216034500" t="yuhan That&apos;s only for fd logic variables though, I would think the question was equivalent to &quot;at most one pair out of the 6 lvars can unify&quot;"><y>#</y><d>2019-12-06</d><h>09:23</h><r>yuhan</r>That&apos;s only for <code>fd</code> logic variables though, I would think the question was equivalent to &quot;at most one pair out of the 6 lvars can unify&quot;</z><z id="t1575624319034700" t="yuhan Can&apos;t think of an easy way to express that (besides macroexpanding all the permutations by brute force)"><y>#</y><d>2019-12-06</d><h>09:25</h><r>yuhan</r>Can&apos;t think of an easy way to express that (besides macroexpanding all the permutations by brute force)</z><z id="t1575624474034900" t="nitaai Oh yes, good point. I interpreted the question rather as “I know which 5 of the 6 lvars should be distinct”."><y>#</y><d>2019-12-06</d><h>09:27</h><r>nitaai</r>Oh yes, good point. I interpreted the question rather as “I know which 5 of the 6 lvars should be distinct”.</z><z id="t1575890333035100" t="Stefan What about defining something like this: (untested) (defnc 5-distinct [a b c d e f] (= 5 (count (set [a b c d e f])))) and then using that as a goal inside run ?"><y>#</y><d>2019-12-09</d><h>11:18</h><r>Stefan</r>What about defining something like this: (untested)

<pre>(defnc 5-distinct [a b c d e f]
  (= 5 (count (set [a b c d e f]))))</pre>
and then using that as a goal inside <code>run</code>?</z><z id="t1575572321032700" t="eoliphant hi I’m getting a weird error in the repl as I work through the core.logic getting started. I’m on jDK 11, wondering if it’s module related (l/run* [q] (l/fresh [a] (l/membero a [1 2 3]) (l/membero q [3 4 5]) (== a q))) Error printing return value (ClassCastException) at clojure.lang.Numbers/equiv (Numbers.java:238). class clojure.core.logic.LVar cannot be cast to class java.lang.Number (clojure.core.logic.LVar is in unnamed module of loader clojure.lang.DynamicClassLoader @11da06db; java.lang.Number is in module java.base of loader &apos;bootstrap&apos;)"><y>#</y><d>2019-12-05</d><h>18:58</h><w>eoliphant</w>hi I’m getting a weird error in the repl as I work through the core.logic getting started.  I’m on jDK 11, wondering if it’s module related
<pre>(l/run* [q]
  (l/fresh [a]
    (l/membero a [1 2 3])
    (l/membero q [3 4 5])
    (== a q)))
Error printing return value (ClassCastException) at clojure.lang.Numbers/equiv (Numbers.java:238).
class clojure.core.logic.LVar cannot be cast to class java.lang.Number (clojure.core.logic.LVar is in unnamed module of loader clojure.lang.DynamicClassLoader @11da06db; java.lang.Number is in module java.base of loader &apos;bootstrap&apos;)</pre></z><z id="t1575573161033000" t="hiredman you need l/== not =="><y>#</y><d>2019-12-05</d><h>19:12</h><w>hiredman</w>you need <code>l/==</code> not <code>==</code></z><z id="t1575573210033700" t="hiredman == is clojure core&apos;s numeric comparison function, l/== is core.logic&apos;s unification goal"><y>#</y><d>2019-12-05</d><h>19:13</h><w>hiredman</w><code>==</code> is clojure core&apos;s numeric comparison function, <code>l/==</code> is core.logic&apos;s unification goal</z><z id="t1575573326034100" t="dpsutton i hit that yesterday. the guide uses use clojure.core.logic so its easy to miss"><y>#</y><d>2019-12-05</d><h>19:15</h><w>dpsutton</w>i hit that yesterday. the guide uses <code>use clojure.core.logic</code> so its easy to miss</z><z id="t1575586535034400" t="eoliphant ah duh lol thanks guys"><y>#</y><d>2019-12-05</d><h>22:55</h><w>eoliphant</w>ah duh lol thanks guys</z><z id="t1577233405000400" t="erwinrooijakkers Hi all"><y>#</y><d>2019-12-25</d><h>00:23</h><w>erwinrooijakkers</w>Hi all</z><z id="t1577233425000800" t="erwinrooijakkers I am trying to solve Advent of Code day 14 using core.logic"><y>#</y><d>2019-12-25</d><h>00:23</h><w>erwinrooijakkers</w>I am trying to solve Advent of Code day 14 using core.logic</z><z id="t1577233466001500" t="erwinrooijakkers Day 14 is about “Stoichemetry” and minimizing reactants. It has constraints like this: 10 ORE =&gt; 10 A 1 ORE =&gt; 1 B 7 A, 1 B =&gt; 1 C 7 A, 1 C =&gt; 1 D 7 A, 1 D =&gt; 1 E 7 A, 1 E =&gt; 1 FUEL"><y>#</y><d>2019-12-25</d><h>00:24</h><w>erwinrooijakkers</w>Day 14 is about “Stoichemetry” and minimizing reactants. It has constraints like this:

<pre>10 ORE =&gt; 10 A
1 ORE =&gt; 1 B
7 A, 1 B =&gt; 1 C
7 A, 1 C =&gt; 1 D
7 A, 1 D =&gt; 1 E
7 A, 1 E =&gt; 1 FUEL</pre></z><z id="t1577233484001900" t="erwinrooijakkers This means 1 FUEL can be made of 7A and 1E"><y>#</y><d>2019-12-25</d><h>00:24</h><w>erwinrooijakkers</w>This means 1 FUEL can be made of 7A and 1E</z><z id="t1577233497002300" t="erwinrooijakkers The goal is to find how much ORE is needed for 1 FUEL"><y>#</y><d>2019-12-25</d><h>00:24</h><w>erwinrooijakkers</w>The goal is to find how much ORE is needed for 1 FUEL</z><z id="t1577233507002600" t="erwinrooijakkers Any pointers on how to do this?"><y>#</y><d>2019-12-25</d><h>00:25</h><w>erwinrooijakkers</w>Any pointers on how to do this?</z><z id="t1577233552003000" t="erwinrooijakkers What type of features can I use?"><y>#</y><d>2019-12-25</d><h>00:25</h><w>erwinrooijakkers</w>What type of features can I use?</z><z id="t1577233577003500" t="erwinrooijakkers Any examples that solve a similar problem?"><y>#</y><d>2019-12-25</d><h>00:26</h><w>erwinrooijakkers</w>Any examples that solve a similar problem?</z><z id="t1577233848004100" t="erwinrooijakkers I’ll watch these videos: • https://www.youtube.com/watch?v=irjP8BO1B8Y • https://www.youtube.com/watch?v=lzCIyvFgUVk"><y>#</y><d>2019-12-25</d><h>00:30</h><w>erwinrooijakkers</w>I’ll watch these videos:

• <a href="https://www.youtube.com/watch?v=irjP8BO1B8Y" target="_blank">https://www.youtube.com/watch?v=irjP8BO1B8Y</a>
• <a href="https://www.youtube.com/watch?v=lzCIyvFgUVk" target="_blank">https://www.youtube.com/watch?v=lzCIyvFgUVk</a></z><z id="t1577234001004800" t="erwinrooijakkers I have the input now as a hash map from output to inputs: {[1 &quot;D&quot;] ([7 &quot;A&quot;] [1 &quot;C&quot;]), [1 &quot;FUEL&quot;] ([7 &quot;A&quot;] [1 &quot;E&quot;]), [10 &quot;A&quot;] ([10 &quot;ORE&quot;]), [1 &quot;C&quot;] ([7 &quot;A&quot;] [1 &quot;B&quot;]), [1 &quot;B&quot;] ([1 &quot;ORE&quot;]), [1 &quot;E&quot;] ([7 &quot;A&quot;] [1 &quot;D&quot;])}"><y>#</y><d>2019-12-25</d><h>00:33</h><w>erwinrooijakkers</w>I have the input now as a hash map from output to inputs:

<pre>{[1 &quot;D&quot;] ([7 &quot;A&quot;] [1 &quot;C&quot;]),
 [1 &quot;FUEL&quot;] ([7 &quot;A&quot;] [1 &quot;E&quot;]),
 [10 &quot;A&quot;] ([10 &quot;ORE&quot;]),
 [1 &quot;C&quot;] ([7 &quot;A&quot;] [1 &quot;B&quot;]),
 [1 &quot;B&quot;] ([1 &quot;ORE&quot;]),
 [1 &quot;E&quot;] ([7 &quot;A&quot;] [1 &quot;D&quot;])}</pre></z><z id="t1577234041005100" t="erwinrooijakkers Hope someone can give me some pointers! Merry Christmas"><y>#</y><d>2019-12-25</d><h>00:34</h><w>erwinrooijakkers</w>Hope someone can give me some pointers! Merry Christmas</z><z id="t1577240999008000" t="hiredman I think key is representation, you&apos;ll want to use a map of thing to count of thing instead of those pairs of thing and count"><y>#</y><d>2019-12-25</d><h>02:29</h><w>hiredman</w>I think key is representation, you&apos;ll want to use a map of thing to count of thing instead of those pairs of thing and count</z><z id="t1577241258014800" t="hiredman And write a relation, call it reduco that takes an input map and an output map, and it has a bunch of conde clauses that do things like constrain the fuel count of output to be one less them the input, and the count of a to be 7 more, and the count of e to be 1 one, using the fd namespace"><y>#</y><d>2019-12-25</d><h>02:34</h><w>hiredman</w>And write a relation, call it reduco that takes an input map and an output map, and it has a bunch of conde clauses that do things like constrain the fuel count of output to be one less them the input, and the count of a to be 7 more, and the count of e to be 1 one, using the fd namespace</z><z id="t1577242054016100" t="hiredman so something like (require &apos;[clojure.core.logic :as l] &apos;[clojure.core.logic.fd :as fd]) (defn reduco [input output] (l/conde [(fd/&gt; (get input &quot;FUEL&quot;) 0) (fd/- (get input &quot;FUEL&quot;) 1 (get output &quot;FUEL&quot;)) (fd/+ (get input &quot;A&quot;) 7 (get output &quot;A&quot;)) (fd/+ (get input &quot;E&quot;) 1 (get output &quot;E&quot;)) ;; (l/== (get input &quot;ORE&quot;) (get output &quot;ORE&quot;)) (l/== (get input &quot;B&quot;) (get output &quot;B&quot;)) (l/== (get input &quot;C&quot;) (get output &quot;C&quot;)) (l/== (get input &quot;D&quot;) (get output &quot;D&quot;)) ])) (l/run 1 [output] (l/fresh [ore a b c d e fuel] (l/== output {&quot;FUEL&quot; fuel &quot;ORE&quot; ore &quot;A&quot; a &quot;B&quot; b &quot;C&quot; c &quot;D&quot; d &quot;E&quot; e}) (reduco {&quot;FUEL&quot; 1 &quot;ORE&quot; 0 &quot;A&quot; 0 &quot;B&quot; 0 &quot;C&quot; 0 &quot;D&quot; 0 &quot;E&quot; 0} {&quot;FUEL&quot; fuel &quot;ORE&quot; ore &quot;A&quot; a &quot;B&quot; b &quot;C&quot; c &quot;D&quot; d &quot;E&quot; e}))) but with reduco fleshed out with the rest of the reduction rules and then with some driving goal that recursively calls reduco until you get back a map with nothing but ore in it"><y>#</y><d>2019-12-25</d><h>02:47</h><w>hiredman</w>so something like
<pre>(require &apos;[clojure.core.logic :as l]
         &apos;[clojure.core.logic.fd :as fd])

(defn reduco [input output]
  (l/conde
   [(fd/&gt; (get input &quot;FUEL&quot;) 0)
    (fd/- (get input &quot;FUEL&quot;) 1 (get output &quot;FUEL&quot;))
    (fd/+ (get input &quot;A&quot;) 7 (get output &quot;A&quot;))
    (fd/+ (get input &quot;E&quot;) 1 (get output &quot;E&quot;))
    ;;
    (l/== (get input &quot;ORE&quot;) (get output &quot;ORE&quot;))
    (l/== (get input &quot;B&quot;) (get output &quot;B&quot;))
    (l/== (get input &quot;C&quot;) (get output &quot;C&quot;))
    (l/== (get input &quot;D&quot;) (get output &quot;D&quot;))
    ]))


(l/run 1 [output]
  (l/fresh [ore a b c d e fuel]
    (l/== output {&quot;FUEL&quot; fuel
                  &quot;ORE&quot; ore
                  &quot;A&quot; a
                  &quot;B&quot; b
                  &quot;C&quot; c
                  &quot;D&quot; d
                  &quot;E&quot; e})
    (reduco {&quot;FUEL&quot; 1
             &quot;ORE&quot; 0
             &quot;A&quot; 0
             &quot;B&quot; 0
             &quot;C&quot; 0
             &quot;D&quot; 0
             &quot;E&quot; 0}
            {&quot;FUEL&quot; fuel
                  &quot;ORE&quot; ore
                  &quot;A&quot; a
                  &quot;B&quot; b
                  &quot;C&quot; c
                  &quot;D&quot; d
                  &quot;E&quot; e})))</pre>
but with reduco fleshed out with the rest of the reduction rules and then with some driving goal that recursively calls reduco until you get back a map with nothing but ore in it</z><z id="t1577242088016700" t="hiredman the tricky thing with mixing maps and core.logic is map stuff will be non-relational, so just watch out for it"><y>#</y><d>2019-12-25</d><h>02:48</h><w>hiredman</w>the tricky thing with mixing maps and core.logic is map stuff will be non-relational, so just watch out for it</z><z id="t1577268683017100" t="erwinrooijakkers Thanks!!!"><y>#</y><d>2019-12-25</d><h>10:11</h><w>erwinrooijakkers</w>Thanks!!!</z><z id="t1577276533018300" t="erwinrooijakkers Why doesn’t this find negative values? (defn sqrts [n] (l/run 2 [x] (fd/in x (fd/interval (- n) n)) (fd/* x x n))) (sqrts 4) ;; =&gt; (2) (sqrts 25) ;; =&gt; (5)"><y>#</y><d>2019-12-25</d><h>12:22</h><w>erwinrooijakkers</w>Why doesn’t this find negative values?

<pre>(defn sqrts [n]
  (l/run 2 [x]
    (fd/in x (fd/interval (- n) n))
    (fd/* x x n)))

(sqrts 4)
;; =&gt; (2)

(sqrts 25)
;; =&gt; (5)</pre></z><z id="t1577321426019000" t="hiredman dunno why, but fd/interval as written turns negative bounds into 0"><y>#</y><d>2019-12-26</d><h>00:50</h><w>hiredman</w>dunno why, but fd/interval as written turns negative bounds into 0</z><z id="t1577321502019200" t="hiredman https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic/fd.clj#L363-L364"><y>#</y><d>2019-12-26</d><h>00:51</h><w>hiredman</w><a href="https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic/fd.clj#L363-L364" target="_blank">https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic/fd.clj#L363-L364</a></z><z id="t1577359659019700" t="erwinrooijakkers Aha 🙂"><y>#</y><d>2019-12-26</d><h>11:27</h><w>erwinrooijakkers</w>Aha <b>🙂</b></z><z id="t1577359665020000" t="erwinrooijakkers &gt; non negative integer or more generally discrete constraints. These last constraints, sometimes also called finite domain constraints, are generally studied in the Constraint Satisfaction Problems (CSP)"><y>#</y><d>2019-12-26</d><h>11:27</h><w>erwinrooijakkers</w>&gt; non negative integer or more generally discrete constraints. These last constraints, sometimes also called finite domain constraints, are generally studied in the Constraint Satisfaction Problems (CSP)</z><z id="t1577359669020200" t="erwinrooijakkers Source: https://www.sciencedirect.com/topics/computer-science/finite-domain-constraint"><y>#</y><d>2019-12-26</d><h>11:27</h><w>erwinrooijakkers</w>Source: <a href="https://www.sciencedirect.com/topics/computer-science/finite-domain-constraint" target="_blank">https://www.sciencedirect.com/topics/computer-science/finite-domain-constraint</a></z><z id="t1577359680020500" t="erwinrooijakkers So a finite domain is nonnegative by definition"><y>#</y><d>2019-12-26</d><h>11:28</h><w>erwinrooijakkers</w>So a finite domain is nonnegative by definition</z><z id="t1577360118020700" t="erwinrooijakkers Related question: https://stackoverflow.com/questions/13195493/core-logic-finite-domain-with-ve-values"><y>#</y><d>2019-12-26</d><h>11:35</h><w>erwinrooijakkers</w>Related question: <a href="https://stackoverflow.com/questions/13195493/core-logic-finite-domain-with-ve-values" target="_blank">https://stackoverflow.com/questions/13195493/core-logic-finite-domain-with-ve-values</a></z><z id="t1577360556021600" t="erwinrooijakkers There might be a reason related to increasing search space why negative numbers are excluded, but I can’t find it anywhere"><y>#</y><d>2019-12-26</d><h>11:42</h><w>erwinrooijakkers</w>There might be a reason related to increasing search space why negative numbers are excluded, but I can’t find it anywhere</z><z id="t1577360791022100" t="erwinrooijakkers But anyway for this specific problem I don’t need negative numbers"><y>#</y><d>2019-12-26</d><h>11:46</h><w>erwinrooijakkers</w>But anyway for this specific problem I don’t need negative numbers</z><z id="t1577360833022300" t="erwinrooijakkers I don’t need to represent the input as maps"><y>#</y><d>2019-12-26</d><h>11:47</h><w>erwinrooijakkers</w>I don’t need to represent the input as maps</z><z id="t1580156407001600" t="Nico hi, I&apos;m having some trouble with core.logic and function arities. I&apos;m going through the reasoned schemer to learn and I&apos;ve been trying to write some of my own relations as exercises. I wrote a simple implementation of concat which worked fine, and I tried to convert it to a relation: (defn dumb-concat [x y] (cond (empty? y) x (empty? x) y :else (recur (conj x (first y)) (rest y)))) (defn dumb-concato [x y out] (l/conde [(l/emptyo y) (l/== out x)] [(l/emptyo x) (l/== out y)] [l/succeed (l/fresh [f r c] (l/conso f r y) (l/conjo x f c) (dumb-concato c r) )]))"><y>#</y><d>2020-01-27</d><h>20:20</h><w>Nico</w>hi, I&apos;m having some trouble with core.logic and function arities. I&apos;m going through the reasoned schemer to learn and I&apos;ve been trying to write some of my own relations as exercises. I wrote a simple implementation of <code>concat</code> which worked fine, and I tried to convert it to a relation:
<pre>(defn dumb-concat [x y]
  (cond
    (empty? y) x
    (empty? x) y
    :else (recur (conj x (first y)) (rest y))))

(defn dumb-concato [x y out]
  (l/conde
    [(l/emptyo y) (l/== out x)]
    [(l/emptyo x) (l/== out y)]
    [l/succeed (l/fresh [f r c]
                   (l/conso f r y)
                   (l/conjo x f c)
                   (dumb-concato c r)
                   )]))</pre></z><z id="t1580156483002400" t="Nico however, when I try and test this with (l/run 1 [q] (dumb-concato [0 1 2 3] [5 4 3] q)) it just says Wrong number of args (2) passed to: logic-practice.core/dumb-concato"><y>#</y><d>2020-01-27</d><h>20:21</h><w>Nico</w>however, when I try and test this with <code>(l/run 1 [q] (dumb-concato [0 1 2 3] [5 4 3] q))</code>  it just says <code>Wrong number of args (2) passed to: logic-practice.core/dumb-concato</code></z><z id="t1580156489002700" t="Nico what am I doing wrong? Or is this a bug?"><y>#</y><d>2020-01-27</d><h>20:21</h><w>Nico</w>what am I doing wrong? Or is this a bug?</z><z id="t1580157017003100" t="Nico because I&apos;m certainly passing 3 arguments to it (the two vectors and the lvar)"><y>#</y><d>2020-01-27</d><h>20:30</h><w>Nico</w>because I&apos;m certainly passing 3 arguments to it (the two vectors and the lvar)</z><z id="t1580157189003500" t="jimmy (dumb-concato c r)"><y>#</y><d>2020-01-27</d><h>20:33</h><w>jimmy</w><code>(dumb-concato c r)</code></z><z id="t1580157235003900" t="jimmy ^ That line looks like the error to me."><y>#</y><d>2020-01-27</d><h>20:33</h><w>jimmy</w>^ That line looks like the error to me.</z><z id="t1580158074004900" t="hiredman Dum-concato is just a regular function, not a core.logic relation, so you can&apos;t use it like that"><y>#</y><d>2020-01-27</d><h>20:47</h><w>hiredman</w>Dum-concato is just a regular function, not a core.logic relation, so you can&apos;t use it like that</z><z id="t1580158092005100" t="hiredman Err"><y>#</y><d>2020-01-27</d><h>20:48</h><w>hiredman</w>Err</z><z id="t1580158102005400" t="hiredman Dumb-concat"><y>#</y><d>2020-01-27</d><h>20:48</h><w>hiredman</w>Dumb-concat</z><z id="t1580158267009000" t="hiredman What exactly a core.logic relation is kind of complicated, but a recursive definition would be something like, a core.logic relation is a function whose body is composed of core.logic relations"><y>#</y><d>2020-01-27</d><h>20:51</h><w>hiredman</w>What exactly a  core.logic relation is kind of complicated, but a recursive definition would be something like, a core.logic relation is a function whose body is composed of core.logic relations</z><z id="t1580158373012000" t="hiredman So dumb-concato would be a relation if it didn&apos;t call dumb-concat, but the body of dumb-concat is all non-relations (it is all functions from clojure.core)"><y>#</y><d>2020-01-27</d><h>20:52</h><w>hiredman</w>So dumb-concato would be a relation if it didn&apos;t call dumb-concat, but the body of dumb-concat is all non-relations (it is all functions from clojure.core)</z><z id="t1580158493013900" t="hiredman The kind of problem you get with calling clojure.core functions in a logic program is they don&apos;t know how to deal with logic variables"><y>#</y><d>2020-01-27</d><h>20:54</h><w>hiredman</w>The kind of problem you get with calling clojure.core functions in a logic program is they don&apos;t know how to deal with logic variables</z><z id="t1580158530014800" t="hiredman And relations don&apos;t return values, but functions do"><y>#</y><d>2020-01-27</d><h>20:55</h><w>hiredman</w>And relations don&apos;t return values, but functions do</z><z id="t1580158571015300" t="hiredman Oh"><y>#</y><d>2020-01-27</d><h>20:56</h><w>hiredman</w>Oh</z><z id="t1580158583015700" t="hiredman I misread your code though"><y>#</y><d>2020-01-27</d><h>20:56</h><w>hiredman</w>I misread your code though</z><z id="t1580158647017600" t="hiredman What I read as a call to dumb-concat is actually a call to dumb-concato with the wrong number if arguments which is exactly what the error you got says"><y>#</y><d>2020-01-27</d><h>20:57</h><w>hiredman</w>What I read as a call to dumb-concat is actually a call to dumb-concato with the wrong number if arguments which is exactly what the error you got says</z><z id="t1580161261018100" t="Nico ...how did I miss the obvious mistake"><y>#</y><d>2020-01-27</d><h>21:41</h><w>Nico</w>...how did I miss the obvious mistake</z><z id="t1580161263018300" t="Nico thanks guys"><y>#</y><d>2020-01-27</d><h>21:41</h><w>Nico</w>thanks guys</z><z id="t1580161268018500" t="Nico somehow managed to make that mistake almost every time"><y>#</y><d>2020-01-27</d><h>21:41</h><w>Nico</w>somehow managed to make that mistake almost every time</z><z id="t1583188808002200" t="niveauverleih I am looking for a coherent intro to core.logic and also for an up-to-date reference."><y>#</y><d>2020-03-02</d><h>22:40</h><w>niveauverleih</w>I am looking for a coherent intro to core.logic and also for an up-to-date reference.</z><z id="t1583409632002600" t="rickmoynihan The reasoned schemer is probably the best reference — it’s almost directly applicable to core.logic; bar a few minor mostly syntactic differences."><y>#</y><d>2020-03-05</d><h>12:00</h><r>rickmoynihan</r>The reasoned schemer is probably the best reference — it’s almost directly applicable to core.logic; bar a few minor mostly syntactic differences.</z><z id="t1583413932002800" t="niveauverleih Thank you, Rick! I had a look at it but found it too implicit. I&apos;m a perfect customer for the dummies series of books. Luckily Martin Trojer put the clojure code for the little schemer on github: https://github.com/martintrojer/reasoned-schemer-core.logic/blob/master/src/reasoned-schemer/ch1.clj"><y>#</y><d>2020-03-05</d><h>13:12</h><r>niveauverleih</r>Thank you, Rick! I had a look at it but found it too implicit. I&apos;m a perfect customer for the dummies series of books. Luckily Martin Trojer put the clojure code for the little schemer on github: <a href="https://github.com/martintrojer/reasoned-schemer-core.logic/blob/master/src/reasoned-schemer/ch1.clj" target="_blank">https://github.com/martintrojer/reasoned-schemer-core.logic/blob/master/src/reasoned-schemer/ch1.clj</a></z><z id="t1583518881004000" t="niveauverleih Lars Hupel has presented core.logic on ClojureD 2020 https://twitter.com/larsr_h/status/1233729156980072453?s=20"><y>#</y><d>2020-03-06</d><h>18:21</h><w>niveauverleih</w>Lars Hupel has presented core.logic on ClojureD 2020 <a href="https://twitter.com/larsr_h/status/1233729156980072453?s=20" target="_blank">https://twitter.com/larsr_h/status/1233729156980072453?s=20</a></z><z id="t1583933471006700" t="niveauverleih In the reasoned Schemer and core logic primer succeed and fail are called constants, whereas the source code defines them as functions. I&apos;m confused."><y>#</y><d>2020-03-11</d><h>13:31</h><w>niveauverleih</w>In the reasoned Schemer and core logic primer succeed and fail are called constants, whereas the source code defines them as functions. I&apos;m confused.</z><z id="t1583941242008300" t="hiredman They are goals that don&apos;t depend on any passed in values, so constant in that sense"><y>#</y><d>2020-03-11</d><h>15:40</h><w>hiredman</w>They are goals that don&apos;t depend on any passed in values, so constant in that sense</z><z id="t1583944798008500" t="rickmoynihan @nick.romer all goals are functions iirc"><y>#</y><d>2020-03-11</d><h>16:39</h><w>rickmoynihan</w>@nick.romer all goals are functions iirc</z><z id="t1583944989009900" t="rickmoynihan You just use them as if they were constants at the minikanren/core.logic language level; but underneath they’re implemented as functions."><y>#</y><d>2020-03-11</d><h>16:43</h><w>rickmoynihan</w>You just use them as if they were constants at the minikanren/core.logic language level; but underneath they’re implemented as functions.</z><z id="t1583945027010400" t="rickmoynihan internally core logic will apply values to them as with any other goal. They’ll just always succeed or fail."><y>#</y><d>2020-03-11</d><h>16:43</h><w>rickmoynihan</w>internally core logic will apply values to them as with any other goal.  They’ll just always succeed or fail.</z><z id="t1583948487011200" t="niveauverleih I see. Thank you both!"><y>#</y><d>2020-03-11</d><h>17:41</h><w>niveauverleih</w>I see. Thank you both!</z><z id="t1585173770003800" t="niveauverleih Could someone explain the term &quot;list with an improper tail&quot; to me, please? I am trying to understand dotted pairs, lcons and llist, while reading the reasoned schemer."><y>#</y><d>2020-03-25</d><h>22:02</h><w>niveauverleih</w>Could someone explain the term &quot;list with an improper tail&quot; to me, please? I am trying to understand dotted pairs, lcons and llist, while reading the reasoned schemer.</z><z id="t1585176122004300" t="hiredman in scheme a cons cell is basically a 2 element array"><y>#</y><d>2020-03-25</d><h>22:42</h><w>hiredman</w>in scheme a cons cell is basically a 2 element array</z><z id="t1585176138004700" t="hiredman and you can put anything in either slot"><y>#</y><d>2020-03-25</d><h>22:42</h><w>hiredman</w>and you can put anything in either slot</z><z id="t1585176182005600" t="hiredman a list is a cons cell or series of cons cells where the second element (the cdr) is a cons cell or nil"><y>#</y><d>2020-03-25</d><h>22:43</h><w>hiredman</w>a list is a cons cell or series of cons cells where the second element (the cdr) is a cons cell or nil</z><z id="t1585176230006400" t="hiredman an improper list is a series of cons cells where the lest cons cell doesn&apos;t have nil as the cdr"><y>#</y><d>2020-03-25</d><h>22:43</h><w>hiredman</w>an improper list is a series of cons cells where the lest cons cell doesn&apos;t have nil as the cdr</z><z id="t1585241338017000" t="niveauverleih Thank you, @hiredman! So in Clojure, cons doesn&apos;t allow me to explicitly set the right hand side of a cell, because it expects a list as 2nd argument. In Clojure, a list is made up of cons cells, but I cannot manipulate the cells directly, right?"><y>#</y><d>2020-03-26</d><h>16:48</h><w>niveauverleih</w>Thank you, @hiredman! So in Clojure, cons doesn&apos;t allow me to explicitly set the right hand side of a cell, because it expects a list as 2nd argument. In Clojure, a list is made up of cons cells, but I cannot manipulate the cells directly, right?</z><z id="t1585241474017800" t="hiredman it is complicated, clojure tends to be more concerned with seqs, which are not a concrete data type"><y>#</y><d>2020-03-26</d><h>16:51</h><w>hiredman</w>it is complicated, clojure tends to be more concerned with seqs, which are not a concrete data type</z><z id="t1585241515018700" t="hiredman clojure has an explicit list type, but it isn&apos;t used nearly as often, most of the time when you think something is a list it is actually some species of seq"><y>#</y><d>2020-03-26</d><h>16:51</h><w>hiredman</w>clojure has an explicit list type, but it isn&apos;t used nearly as often, most of the time when you think something is a list it is actually some species of seq</z><z id="t1585241540019200" t="hiredman and clojure.core/cons builds a seq, not a list"><y>#</y><d>2020-03-26</d><h>16:52</h><w>hiredman</w>and clojure.core/cons builds a seq, not a list</z><z id="t1585241569019600" t="hiredman but it is true that neither seqs nor lists can be improper in clojure"><y>#</y><d>2020-03-26</d><h>16:52</h><w>hiredman</w>but it is true that neither seqs nor lists can be improper in clojure</z><z id="t1585302216021600" t="yuhan core.logic has a function lcons to model these improper-tail cons cells, I&apos;ve only used it when translating the Reasoned Schemer exercises."><y>#</y><d>2020-03-27</d><h>09:43</h><w>yuhan</w>core.logic has a function <code>lcons</code> to model these improper-tail cons cells, I&apos;ve only used it when translating the Reasoned Schemer exercises.</z><z id="t1585302244021800" t="yuhan also llist"><y>#</y><d>2020-03-27</d><h>09:44</h><w>yuhan</w>also <code>llist</code></z><z id="t1585560120022700" t="dmarjenburgh Wat is the benefit of using finite domains instead of just constraining a var to a set of values with membero?"><y>#</y><d>2020-03-30</d><h>09:22</h><w>dmarjenburgh</w>Wat is the benefit of using finite domains instead of just constraining a var to a set of values with membero?</z><z id="t1585570647025400" t="rickmoynihan It has optimisations that mean not all values need to be specified up front; e.g. you can specify a lower and upper bound on a constraint, and it can operate and propagate constraints on the intervals directly. Also it gives you relational versions of operators like &lt; &gt; + - etc that leverage the above."><y>#</y><d>2020-03-30</d><h>12:17</h><w>rickmoynihan</w>It has optimisations that mean not all values need to be specified up front; e.g. you can specify a lower and upper bound on a constraint, and it can operate and propagate constraints on the intervals directly.

Also it gives you relational versions of operators like <code>&lt;</code> <code>&gt;</code> <code>+</code> <code>-</code> etc that  leverage the above.</z><z id="t1586762085027900" t="dmarjenburgh Hi, I&apos;m interested in symbolic equation solvers. Does anyone know a good source to read about the &apos;state-of-things&apos; regarding research in this area? I&apos;m familiar with PRESS (PRolog Equation Solving System) and am looking to implement something similar in core.logic, but need a good place to start reading up."><y>#</y><d>2020-04-13</d><h>07:14</h><w>dmarjenburgh</w>Hi, I&apos;m interested in symbolic equation solvers. Does anyone know a good source to read about the &apos;state-of-things&apos; regarding research in this area? I&apos;m familiar with PRESS (PRolog Equation Solving System) and am looking to implement something similar in core.logic, but need a good place to start reading up.</z><z id="t1586954759028100" t="Joe Lane Hi @U05469DKJ Does this fit the bill? https://github.com/clojure-numerics/expresso https://github.com/mschuene/expresso-tutorial"><y>#</y><d>2020-04-15</d><h>12:45</h><r>Joe Lane</r>Hi @U05469DKJ Does this fit the bill?

<a href="https://github.com/clojure-numerics/expresso" target="_blank">https://github.com/clojure-numerics/expresso</a>

<a href="https://github.com/mschuene/expresso-tutorial" target="_blank">https://github.com/mschuene/expresso-tutorial</a></z><z id="t1586955822028500" t="dmarjenburgh Thanks, have seen it. Doesn&apos;t appear active anymore and couldn&apos;t find reference to research in the code. I might learn something from diving into the codebase though."><y>#</y><d>2020-04-15</d><h>13:03</h><r>dmarjenburgh</r>Thanks, have seen it. Doesn&apos;t appear active anymore and couldn&apos;t find reference to research in the code. I might learn something from diving into the codebase though.</z><z id="t1587010436028700" t="EmmanuelOga have you seen these books by any chance?"><y>#</y><d>2020-04-16</d><h>04:13</h><r>EmmanuelOga</r>have you seen these books by any chance?</z><z id="t1587010437028900" t="EmmanuelOga https://www.amazon.com/Joel-S-Cohen/e/B001K8MI06"><y>#</y><d>2020-04-16</d><h>04:13</h><r>EmmanuelOga</r><a href="https://www.amazon.com/Joel-S-Cohen/e/B001K8MI06" target="_blank">https://www.amazon.com/Joel-S-Cohen/e/B001K8MI06</a></z><z id="t1587010475029200" t="EmmanuelOga disclaimer: I know nothing about the subject, I just always have on the back burner to relearn some math, and I found the books when I was looking for computer algebra books"><y>#</y><d>2020-04-16</d><h>04:14</h><r>EmmanuelOga</r>disclaimer: I know nothing about the subject, I just always have on the back burner to relearn some math, and I found the books when I was looking for computer algebra books</z><z id="t1587010509029400" t="EmmanuelOga also, they are ~20 year old books so maybe not precisely state of the art haha"><y>#</y><d>2020-04-16</d><h>04:15</h><r>EmmanuelOga</r>also, they are ~20 year old books so maybe not precisely state of the art haha</z><z id="t1587010810029600" t="EmmanuelOga the source of sympy seems like a good resource too"><y>#</y><d>2020-04-16</d><h>04:20</h><r>EmmanuelOga</r>the source of sympy seems like a good resource too</z><z id="t1587010811029800" t="EmmanuelOga say:"><y>#</y><d>2020-04-16</d><h>04:20</h><r>EmmanuelOga</r>say:</z><z id="t1587010813030000" t="EmmanuelOga https://github.com/sympy/sympy/blob/09565e28d2373ba4e130a7bacff6c7a1c01a4a64/sympy/calculus/finite_diff.py"><y>#</y><d>2020-04-16</d><h>04:20</h><r>EmmanuelOga</r><a href="https://github.com/sympy/sympy/blob/09565e28d2373ba4e130a7bacff6c7a1c01a4a64/sympy/calculus/finite_diff.py" target="_blank">https://github.com/sympy/sympy/blob/09565e28d2373ba4e130a7bacff6c7a1c01a4a64/sympy/calculus/finite_diff.py</a></z><z id="t1587012904030300" t="dmarjenburgh I had not seen those books. Thanks!"><y>#</y><d>2020-04-16</d><h>04:55</h><r>dmarjenburgh</r>I had not seen those books. Thanks!</z><z id="t1588523155032700" t="skykanin Are there any good resources for learning core logic? I&apos;m looking to translate a prolog sudoku CLP rule to clojure."><y>#</y><d>2020-05-03</d><h>16:25</h><w>skykanin</w>Are there any good resources for learning core logic? I&apos;m looking to translate a prolog sudoku CLP rule to clojure.</z><z id="t1588578489033000" t="rickmoynihan The reasoned schemer is probably the main one. There are some minor differences to core logic, but they’re mainly just syntactic ones."><y>#</y><d>2020-05-04</d><h>07:48</h><r>rickmoynihan</r>The reasoned schemer is probably the main one.

There are some minor differences to core logic, but they’re mainly just syntactic ones.</z><z id="t1588578563033300" t="rickmoynihan Also the core.logic unit tests… iirc there is a sudoku solver as an example in there"><y>#</y><d>2020-05-04</d><h>07:49</h><r>rickmoynihan</r>Also the core.logic unit tests…  iirc there is a sudoku solver as an example in there</z><z id="t1588743199033500" t="EmmanuelOga I don&apos;t really understand the reasoner schemer and the rest of the books on that series"><y>#</y><d>2020-05-06</d><h>05:33</h><r>EmmanuelOga</r>I don&apos;t really understand the reasoner schemer and the rest of the books on that series</z><z id="t1588743263033700" t="EmmanuelOga I thought it was supposed to be a way to teach difficult concepts in a way that &quot;anybody could understand them&quot;, starting &quot;from the beginning&quot; and just putting some effort behind..."><y>#</y><d>2020-05-06</d><h>05:34</h><r>EmmanuelOga</r>I thought it was supposed to be a way to teach difficult concepts in a way that &quot;anybody could understand them&quot;, starting &quot;from the beginning&quot; and just putting some effort behind...</z><z id="t1588743280033900" t="EmmanuelOga I find those books assume a HUGE amount of pre-existent knowledge"><y>#</y><d>2020-05-06</d><h>05:34</h><r>EmmanuelOga</r>I find those books assume a HUGE amount of pre-existent knowledge</z><z id="t1588743343034100" t="EmmanuelOga I determined that the best way to learn core.logic will probably have to be to learn prolog first, since there seems to be at least a couple of... normal books to learn from 🙂"><y>#</y><d>2020-05-06</d><h>05:35</h><r>EmmanuelOga</r>I determined that the best way to learn core.logic will probably have to be to learn prolog first, since there seems to be at least a couple of... normal books to learn from <b>🙂</b></z><z id="t1588743421034300" t="EmmanuelOga maybe some other resource on http://minikanren.org/ could be useful but I haven&apos;t gone through the avalanche of links yet."><y>#</y><d>2020-05-06</d><h>05:37</h><r>EmmanuelOga</r>maybe some other resource on <a href="http://minikanren.org/" target="_blank">http://minikanren.org/</a> could be useful but I haven&apos;t gone through the avalanche of links yet.</z><z id="t1588743474034500" t="EmmanuelOga https://mitpress.mit.edu/books/art-prolog-second-edition looks promising"><y>#</y><d>2020-05-06</d><h>05:37</h><r>EmmanuelOga</r><a href="https://mitpress.mit.edu/books/art-prolog-second-edition" target="_blank">https://mitpress.mit.edu/books/art-prolog-second-edition</a> looks promising</z><z id="t1588761429035000" t="rickmoynihan I personally really like the reasoned schemer and the other books in the series. Each panel builds on the last, and I don’t think they require much prior knowledge (beyond perhaps some of the little schemer, or a rough familiarity with a lisp e.g. clojure). I think the problem with those books isn’t so much that they assume any pre existing knowledge about logic programming; you can and should I think really read them without a computer… It’s more that they don’t tell you anything about why you should care, or how to apply it in practice… or even really what each chapter is teaching you. However, I also happened to have learned prolog 20 years ago, so :man-shrugging: Regardless the art of prolog is a great book; though you’ll probably want to learn minikanren as its own thing too. Many examples won’t translate directly."><y>#</y><d>2020-05-06</d><h>10:37</h><r>rickmoynihan</r>I personally really like the reasoned schemer and the other books in the series.  Each panel builds on the last, and I don’t think they require much prior knowledge (beyond perhaps some of the little schemer, or a rough familiarity with a lisp e.g. clojure).

I think the problem with those books isn’t so much that they assume any pre existing knowledge about logic programming; you can and should I think really read them without a computer…  It’s more that they don’t tell you anything about why you should care, or how to apply it in practice… or even really what each chapter is teaching you.

However, I also happened to have learned prolog 20 years ago, so <b>:man-shrugging:</b>

Regardless the art of prolog is a great book; though you’ll probably want to learn minikanren as its own thing too.  Many examples won’t translate directly.</z><z id="t1588544028032800" t="porkostomus This looks like it might help: https://github.com/daveray/logic-99"><y>#</y><d>2020-05-03</d><h>22:13</h><w>porkostomus</w>This looks like it might help: <a href="https://github.com/daveray/logic-99" target="_blank">https://github.com/daveray/logic-99</a></z><z id="t1591378706039800" t="niveauverleih Can anybody explain the difference between miniKanren and STRIPS? they seem to be used ti solve tbe same kind if problems; cf https://www.youtube.com/watch?v=jzLSnadyYso"><y>#</y><d>2020-06-05</d><h>17:38</h><w>niveauverleih</w>Can anybody explain the difference  between miniKanren and STRIPS? they seem to be used ti solve tbe same kind if problems; cf <a href="https://www.youtube.com/watch?v=jzLSnadyYso" target="_blank">https://www.youtube.com/watch?v=jzLSnadyYso</a></z><z id="t1591615906047300" t="rickmoynihan Not seen STRIPS before; and I’m no expert here but it looks like it’s essentially a planner; which is roughly speaking a programming system designed to find the right sequence of actions to achieve a goal. It’s probably similar to minikanren in that it’s essentially a search strategy over some solution space; where the program in the language defines what those solutions/constraints look like… But I think the flavour of expression will be different. A planner will more typically be oriented around finding sequences of actions that get you from where you are into a particular goal state. Whilst minikanren aims to be more general purpose… You should be able to implement a planner in minikanren (or a logic language like prolog), but I’m not sure the reverse would typically be desirable… Having said that it looks like STRIPS smells a bit like horn clauses Preconditions being the antecedents and Postconditions being the consequents. Also minikanren has goals of being purely relational, and is as much about having a simple implementation for research/educational purposes as anything else."><y>#</y><d>2020-06-08</d><h>11:31</h><w>rickmoynihan</w>Not seen STRIPS before; and I’m no expert here but it looks like it’s essentially a planner; which is roughly speaking a programming system designed to find the right sequence of actions to achieve a goal.

It’s probably similar to minikanren in that it’s essentially  a search strategy over some solution space; where the program in the language defines what those solutions/constraints look like…

But I think the flavour of expression will be different.  A planner will more typically be oriented around finding sequences of actions that get you from where you are into a particular goal state.

Whilst minikanren aims to be more general purpose…  You should be able to implement a planner in minikanren (or a logic language like prolog), but I’m not sure the reverse would typically be desirable…

Having said that it looks like STRIPS smells a bit like horn clauses Preconditions being the antecedents and Postconditions being the consequents.

Also minikanren has goals of being purely relational, and is as much about having a simple implementation for research/educational purposes as anything else.</z><z id="t1601410498000500" t="nathanmarz what&apos;s the purpose of clojure.core.logic.protocols/IUninitialized ?"><y>#</y><d>2020-09-29</d><h>20:14</h><w>nathanmarz</w>what&apos;s the purpose of <code>clojure.core.logic.protocols/IUninitialized</code>?</z><z id="t1601410545001400" t="nathanmarz I found I&apos;m unable to write constraints on values of custom records without that record implementing that protocol, but I&apos;m unclear what -uninitialized is supposed to do"><y>#</y><d>2020-09-29</d><h>20:15</h><w>nathanmarz</w>I found I&apos;m unable to write constraints on values of custom records without that record implementing that protocol, but I&apos;m unclear what <code>-uninitialized</code> is supposed to do</z><z id="t1601877157002500" t="devn @nathanmarz https://groups.google.com/g/clojure/c/0bM3nLj18SM/m/RMumUuy4IZ4J might be of some help in understanding the history there."><y>#</y><d>2020-10-05</d><h>05:52</h><w>devn</w>@nathanmarz <a href="https://groups.google.com/g/clojure/c/0bM3nLj18SM/m/RMumUuy4IZ4J" target="_blank">https://groups.google.com/g/clojure/c/0bM3nLj18SM/m/RMumUuy4IZ4J</a> might be of some help in understanding the history there.</z><z id="t1604587581005200" t="nitaai hi. i have ported one prolog example to core.logic: % P07 (**) Flatten a nested list structure. my_flatten(X,[X]) :- \+ is_list(X). my_flatten([],[]). my_flatten([X|Xs],Zs) :- my_flatten(X,Y), my_flatten(Xs,Ys), append(Y,Ys,Zs). (defne flatteno [l1 l2] ([x [x]] (pred x (comp not seq?))) ([[] []]) ([[x . xs] zs] (fresh [y ys] (flatteno x y) (flatteno xs ys) (appendo y ys zs)))) can someone tell me why the clojure version produces multiple results: ([[1 [2]]] (1 [2]) (1 2)) and the prolog version only one: [1 2] ?"><y>#</y><d>2020-11-05</d><h>14:46</h><w>nitaai</w>hi. i have ported one prolog example to core.logic:
<pre>% P07 (**) Flatten a nested list structure.
my_flatten(X,[X]) :- \+ is_list(X).
my_flatten([],[]).
my_flatten([X|Xs],Zs) :- my_flatten(X,Y), my_flatten(Xs,Ys), append(Y,Ys,Zs).

(defne flatteno [l1 l2]
  ([x [x]] (pred x (comp not seq?)))
  ([[] []])
  ([[x . xs] zs]
   (fresh [y ys]
     (flatteno x y)
     (flatteno xs ys)
     (appendo y ys zs))))</pre>
can someone tell me why the clojure version produces multiple results:
<code>([[1 [2]]] (1 [2]) (1 2))</code>
and the prolog version only one:
<code>[1 2]</code>
?</z><z id="t1604588115005300" t="nitaai I assume some rearrangement of the clauses and use of defna or defnu .."><y>#</y><d>2020-11-05</d><h>14:55</h><r>nitaai</r>I assume some rearrangement of the clauses and use of <code>defna</code> or <code>defnu</code>..</z><z id="t1604588418005500" t="nitaai yes, my assumption was right: (defna flatteno [l1 l2] ([[x . xs] zs] (fresh [y ys] (flatteno x y) (flatteno xs ys) (appendo y ys zs))) ([x [x]] (pred x (comp not seq?))) ([[] []])) both defna and defnu do the job and clauses have to be rearranged. Someone who knows prolog can tell me why this kind of cut is necessary in clojure and not in prolog?"><y>#</y><d>2020-11-05</d><h>15:00</h><r>nitaai</r>yes, my assumption was right:
<pre>(defna flatteno [l1 l2]
  ([[x . xs] zs]
   (fresh [y ys]
     (flatteno x y)
     (flatteno xs ys)
     (appendo y ys zs)))
  ([x [x]] (pred x (comp not seq?)))
  ([[] []]))</pre>
both <code>defna</code> and <code>defnu</code> do the job and clauses have to be rearranged.

Someone who knows prolog can tell me why this kind of cut is necessary in clojure and not in prolog?</z><z id="t1604601521005800" t="Jan K the \+ negation in prolog also does a cut: http://cs.union.edu/~striegnk/learn-prolog-now/html/node90.html#sec.l10.negation.as.failure"><y>#</y><d>2020-11-05</d><h>18:38</h><r>Jan K</r>the \+ negation in prolog also does a cut:
<a href="http://cs.union.edu/~striegnk/learn-prolog-now/html/node90.html#sec.l10.negation.as.failure" target="_blank">http://cs.union.edu/~striegnk/learn-prolog-now/html/node90.html#sec.l10.negation.as.failure</a></z><z id="t1604601681006000" t="hiredman I would strongly recommend against using pred, and seq? is likely the wrong predicate there"><y>#</y><d>2020-11-05</d><h>18:41</h><r>hiredman</r>I would strongly recommend against using pred, and seq? is likely the wrong predicate there</z><z id="t1604601779006200" t="hiredman the re-arrangement of the clauses and using defna or defna are both consequences of seq? being the wrong predicate"><y>#</y><d>2020-11-05</d><h>18:42</h><r>hiredman</r>the re-arrangement of the clauses and using defna or defna are both consequences of seq? being the wrong predicate</z><z id="t1604601799006400" t="hiredman user=&gt; (seq? []) false user=&gt; "><y>#</y><d>2020-11-05</d><h>18:43</h><r>hiredman</r><pre>user=&gt; (seq? [])
false
user=&gt;</pre>
</z><z id="t1604601839006600" t="hiredman but using defna you should be able to get rid of the pred usage altogether"><y>#</y><d>2020-11-05</d><h>18:43</h><r>hiredman</r>but using defna you should be able to get rid of the pred usage altogether</z><z id="t1604602763006800" t="nitaai Great and interesting hints. Thanks @UCPGSBNQ4 and @U0NCTKEV8. Will look into that…"><y>#</y><d>2020-11-05</d><h>18:59</h><r>nitaai</r>Great and interesting hints. Thanks @UCPGSBNQ4 and @U0NCTKEV8. Will look into that…</z><z id="t1604650933007000" t="nitaai (defna flatteno [l1 l2] ([[] []]) ([[x . xs] zs] (fresh [y ys] (flatteno x y) (flatteno xs ys) (appendo y ys zs))) ([x [x]])) i think this is the best solution. it got rid of pred as @U0NCTKEV8 suggested and uses defna . the arrangement of the clauses still matters, but it makes sense."><y>#</y><d>2020-11-06</d><h>08:22</h><r>nitaai</r><pre>(defna flatteno [l1 l2]
  ([[] []])
  ([[x . xs] zs]
   (fresh [y ys]
     (flatteno x y)
     (flatteno xs ys)
     (appendo y ys zs)))
  ([x [x]]))</pre>
i think this is the best solution. it got rid of <code>pred</code>as @U0NCTKEV8 suggested and uses <code>defna</code>. the arrangement of the clauses still matters, but it makes sense.</z><z id="t1604655278008000" t="nitaai another question. are recursive anonymous goals possible in core.logic ? i can’t get it working analogous to the regular fn ."><y>#</y><d>2020-11-06</d><h>09:34</h><w>nitaai</w>another question. are recursive anonymous goals possible in <code>core.logic</code>? i can’t get it working analogous to the regular <code>fn</code>.</z><z id="t1604663848008100" t="nitaai this workaround seems to work: (defn packo [l1 l2] (letfn [(transfero [a b c d] (matche [a b c d] ([x [] [] [x]]) ([x [y . ys] [y . ys] [x]] (!= x y)) ([x [x . xs] ys [x . zs]] (transfero x xs ys zs))))] (matche [l1 l2] ([[] []]) ([[x . xs] [z . zs]] (fresh [ys] (transfero x xs ys z) (packo ys zs)))))) "><y>#</y><d>2020-11-06</d><h>11:57</h><r>nitaai</r>this workaround seems to work:
<pre>(defn packo [l1 l2]
  (letfn [(transfero [a b c d]
            (matche [a b c d]
              ([x [] [] [x]])
              ([x [y . ys] [y . ys] [x]] (!= x y))
              ([x [x . xs] ys [x . zs]] (transfero x xs ys zs))))]
    (matche [l1 l2]
      ([[] []])
      ([[x . xs] [z . zs]]
       (fresh [ys]
         (transfero x xs ys z)
         (packo ys zs))))))</pre>
</z><z id="t1604663952008300" t="nitaai may be even more readable than fne etc on the other hand i think it should support naming the anonymous function and thus enable recursion, like the ordinary fn does. but maybe there is a reason why it doesn’t."><y>#</y><d>2020-11-06</d><h>11:59</h><r>nitaai</r>may be even more readable than <code>fne</code> etc on the other hand i think it should support naming the anonymous function and thus enable recursion, like the ordinary <code>fn</code> does. but maybe there is a reason why it doesn’t.</z></div></body>