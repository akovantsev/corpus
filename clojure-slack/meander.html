<!DOCTYPE html>
<head><title>meander</title><meta charset="UTF-8" /><style type="text/css">body {
    font-family: Monaco, Menlo, Consolas, "Courier New", sans-serif;
    font-size: 12px;
    margin: 15px;
}
h2 {text-align: center}
pre,
code {
    font-family: Monaco, Menlo, Consolas, "Courier New", monospace;
    color: #333;
    line-break: anywhere;
}
a {
    line-break: anywhere;
}
code {
    /*line-height: 1.2;*/
    white-space: normal;
    color: #c25;
    background-color: #f7f7f9;
    border: 1px solid #e1e1e8;
}
pre {
    margin: .5rem 0 .2rem;
    font-size: .75rem;
    /*line-height: 1.15rem;*/
    background: #fbfaf8;
    padding: .5rem;
    word-break: normal;
    display: block;
    border: 1px solid rgba(0, 0, 0, .15);
    white-space: pre-wrap;
    word-wrap: break-word;
    border-radius: 4px;
}
/*span {*/
z {
    white-space: pre-wrap;
}

d {padding-right: 8px;}
h {padding-right: 16px;}

w, r {
    margin-right: 10px;
    padding-right: 8px;
    text-align: right;
}

d,h,w,r {
    background-color: lavender;
    margin-top: 1px;
    display: inline-table; /* prevents doubleclick selection spillover into neighbour elements */
}

h:hover,
d:hover {
    text-decoration: underline;
    color: blue;
    cursor: row-resize;
}
d {padding-right: 8px;}
h {padding-right: 16px;}

z {display: block;}

z:target > r,
z:target > w,
z:target > d,
z:target > h {
    background-color: aquamarine
}

#filters-container {
    position: fixed;
    left: 50px;
    z-index: 1;
}
#filters-container > input {
    /*column:*/
    display: block;
    outline-color: aquamarine;
}

y {
    cursor: pointer;
    text-decoration: none;
    color: blue;
    position: absolute;
    left: 3px;
}

y:hover {
    text-decoration: underline;
    color: aquamarine;
}


</style></head><body><style id="css-username">w {min-width: 176px;} r {min-width: 208px;}</style><style id="css-text-filter"></style><style id="css-date-filter"></style><style id="css-filter-override"></style><p id="filters-container"><input id="text-filter" onkeyup="debtextfilter(this.value)" placeholder="filter text" type="string" /><button hidden="hidden" id="date-filter" onclick="cleardatefilter()"></button></p><h2>#meander</h2><pre><i>generated UTC: 2024-04-12 07:06</i><i>
latest data: <a href="https://clojurians-log.clojureverse.org/meander/2024-03-23">https://clojurians-log.clojureverse.org/meander/2024-03-23</a></i><i>
messages: 5326</i>
pro tips:
* Double click on text to filter by it. (doubleclick + cmd-f for extra points).
* Click on date to keep day visible regardless of filter.
* Click on time to keep hour visible regardless of filter.</pre><script>const textFilterInput = document.getElementById("text-filter");
const dateFilterInput = document.getElementById("date-filter");
const filterTextStyle = document.getElementById("css-text-filter");
const filterDateStyle = document.getElementById("css-date-filter");
const filterStyleOverride = document.getElementById("css-filter-override");



function textFilter2(text) {
    var style = '';
    if (text.trim() !== '') {
        text.split(' ').forEach(function (t) {
            if (t !== '') {
                style = style + "z:not([t*='" + t + "' i]) {display: none; opacity: 0.6}";
            }
        });
    }
    filterTextStyle.innerHTML = style;
}
function textFilter(text) {
    filterTextStyle.innerHTML = "";
    if (text.trim() !== '') {
        var sections = document.getElementsByTagName("g");
        var sectionsArr = Array.prototype.slice.call(sections);
        sectionsArr.forEach(function (s){
            var sid = s.getAttribute("id");
            text.split(' ').forEach(function (t) {
                if (t !== '') {
                    filterTextStyle.innerHTML += "\ng#" + sid + " > z:not([t*='" + t + "' i]) {display: none; opacity: 0.6}";
                }
            });
        })
    }
}
function textFilter3(text) {
    console.time("text search");
    filterTextStyle.innerHTML = "";
    if (text.trim() !== '') {
        const re = new RegExp( text, "i");
        var sections = document.getElementsByTagName("g");
        var sectionsArr = Array.prototype.slice.call(sections);
        sectionsArr.forEach(function (w){
            var zs = w.getElementsByTagName ("z");
            var zsArr = Array.prototype.slice.call(zs);
            var ids = zsArr
                .filter(function (el) {
                    return !re.test(el.innerText);
                })
                .map(function (el){
                    return el.getAttribute("id");
                });
            if (ids) {
                filterTextStyle.innerHTML += "\n#" + ids.join(",#") + " {display: none; opacity: 0.6}";
            }
        })
    }
    console.timeEnd("text search");
}


function filterSelection (e) {
    let sel = document.getSelection();
    let txt = sel.toString();
    textFilterInput.value = (txt || "");
    textFilter(txt);
}
function debounce1(callback, delay) {
    let timeout;
    return function(arg) {
        clearTimeout(timeout);
        timeout = setTimeout(callback, delay, arg);
    }
}

function keyUp (e) {
    if (e.code === "KeyF" && e.ctrlKey) {
        let txt = document.getSelection().toString();
        if (txt.length > 0) {
            textFilterInput.value = (txt || "");
            textFilter(txt);
        }
    }
}


function showDateTimes (el, datestr, hourstr) {
    dateFilterInput.innerText = "clear: " + datestr + " " + hourstr;
    dateFilterInput.hidden = false;
    let ids = [];
    const clicked = el.parentElement;  // el = z#id/t
    ids.push(clicked.id);
    // var idbefore, idafter;
    let cursor = clicked;
    function nextCursor (cursor) {
        const id = (cursor && cursor.id);
        const d = (cursor && cursor.children[1]);
        const h = (cursor && cursor.children[2])
        if (id) {
            ids.push(id); //includes 1st next-id not matching date.
        } else {
            cursor = null;
        }
        if (d && (d.textContent === datestr) && (!hourstr || (h && h.textContent.startsWith(hourstr)))) {
        } else {
            cursor = null;
        }
        return cursor;
    }
    while (cursor) {
        cursor = nextCursor(cursor.previousElementSibling);
    }

    cursor = clicked;

    while (cursor) {
        cursor = nextCursor(cursor.nextElementSibling);
    }


    var style1 = '';
    var style2 = '';
    var content;
    if (datestr.includes(" ")) { //hour
        content = " *";
    } else {
        content = "**";
    }
    ids.forEach(function (id) {
        if (id) {
            style1 = style1 + ", #" + id;
            style2 = style2 + ", #" + id + " h:after";
        }
    })
    if (style1) {
        style1 = style1.substring(1) + " {display: block !important}";
    }
    if (style2) {
        style2 = style2.substring(1) + " {content: \"" + content + "\"; position: absolute}"
    }
    filterDateStyle.innerHTML = style1 + "\n" + style2;
}

// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView
function filterDay (el) {
    showDateTimes(el, el.textContent);
    el.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
}

function filterHours (el) {
    showDateTimes(el, el.previousElementSibling.textContent, el.textContent.substring(0, 2));
    el.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
}

function forceShowSelected (el) {
    var id = el.parentElement.id
    if (id) {
        window.location.hash = "#" + id;
        filterStyleOverride.innerHTML = ""
            + "#" + id
            + " {display: block !important;}"
            + "#" + id + " h:after"
            + " {content: \"  #\"; position: absolute}";

    } else {
        window.location.hash = "";
        filterStyleOverride.innerHTML = "";
    }
}


function cleardatefilter () {
    dateFilterInput.hidden = true;
    dateFilterInput.innerText = "";
    filterDateStyle.innerHTML = "";
}

const debtextfilter = debounce1(textFilter, 200);

function doubleClick (e) {
    if (e.target.tagName !== "INPUT"
        && e.target.tagName !== "D"
        && e.target.tagName !== "H") {

        filterSelection();
        e.target.scrollIntoView({behavior: "auto", block: "center", inline: "start"});
    }
}

function onclick(e) {
    if (e.target.tagName === "Y") {
        e.preventDefault();
        forceShowSelected(e.target);
    } else if (e.target.tagName === "D") {
        e.preventDefault();
        filterDay(e.target);
    } else if (e.target.tagName === "H") {
        e.preventDefault();
        filterHours(e.target);
    }
}

document.onclick = onclick;
document.ondblclick = doubleClick;
document.onkeyup = keyUp;
textFilterInput.focus();
</script><div><g id="s0"><z id="t1582297560" t="simongray defsyntax doesn’t work in ClojureScript? I’m using rewrite in the same namespace just fine… 😕 "><y>#</y><d>2020-02-21</d><h>15:06</h><w>simongray</w>defsyntax doesn’t work in ClojureScript? I’m using rewrite in the same namespace just fine… <b>😕</b>
</z><z id="t1582297560" t="simongray ------ WARNING #1 - :undeclared-var -------------------------------------------- File: /Users/rqf595/Code/facsimile/dev/user.cljs:50:1 -------------------------------------------------------------------------------- 47 | (reduced comp)))] 48 | (reduce-kv (matching-comp node) nil pred-&gt;comp))) 49 | 50 | (m/defsyntax number -------^------------------------------------------------------------------------ Use of undeclared Var meander.syntax.epsilon/*form* -------------------------------------------------------------------------------- 51 | ([] `(number _#)) 52 | ([pattern] (if (m/match-syntax? &amp;env) 53 | `(m/pred number? ~pattern) 54 | &amp;form))) -------------------------------------------------------------------------------- ------ WARNING #2 - :undeclared-var -------------------------------------------- File: /Users/rqf595/Code/facsimile/dev/user.cljs:50:1 -------------------------------------------------------------------------------- 47 | (reduced comp)))] 48 | (reduce-kv (matching-comp node) nil pred-&gt;comp))) 49 | 50 | (m/defsyntax number -------^------------------------------------------------------------------------ Use of undeclared Var meander.syntax.epsilon/*env* -------------------------------------------------------------------------------- 51 | ([] `(number _#)) 52 | ([pattern] (if (m/match-syntax? &amp;env) 53 | `(m/pred number? ~pattern) 54 | &amp;form))) -------------------------------------------------------------------------------- ------ WARNING #3 - :undeclared-var -------------------------------------------- File: /Users/rqf595/Code/facsimile/dev/user.cljs:52:19 -------------------------------------------------------------------------------- 49 | 50 | (m/defsyntax number 51 | ([] `(number _#)) 52 | ([pattern] (if (m/match-syntax? &amp;env) -------------------------^------------------------------------------------------ Use of undeclared Var meander.epsilon/match-syntax? -------------------------------------------------------------------------------- 53 | `(m/pred number? ~pattern) 54 | &amp;form))) 55 | 56 | (m/rewrite [:glen {:data-ref &quot;glen&quot;}] -------------------------------------------------------------------------------- ------ WARNING #4 - :dynamic --------------------------------------------------- File: /Users/rqf595/Code/facsimile/dev/user.cljs:50:1 -------------------------------------------------------------------------------- 47 | (reduced comp)))] 48 | (reduce-kv (matching-comp node) nil pred-&gt;comp))) 49 | 50 | (m/defsyntax number -------^------------------------------------------------------------------------ meander.syntax.epsilon/*form* not declared ^:dynamic -------------------------------------------------------------------------------- 51 | ([] `(number _#)) 52 | ([pattern] (if (m/match-syntax? &amp;env) 53 | `(m/pred number? ~pattern) 54 | &amp;form))) -------------------------------------------------------------------------------- ------ WARNING #5 - :dynamic --------------------------------------------------- File: /Users/rqf595/Code/facsimile/dev/user.cljs:50:1 -------------------------------------------------------------------------------- 47 | (reduced comp)))] 48 | (reduce-kv (matching-comp node) nil pred-&gt;comp))) 49 | 50 | (m/defsyntax number -------^------------------------------------------------------------------------ meander.syntax.epsilon/*env* not declared ^:dynamic -------------------------------------------------------------------------------- 51 | ([] `(number _#)) 52 | ([pattern] (if (m/match-syntax? &amp;env) 53 | `(m/pred number? ~pattern) 54 | &amp;form))) -------------------------------------------------------------------------------- ------ WARNING #6 - :undeclared-var -------------------------------------------- File: /Users/rqf595/Code/facsimile/dev/user.cljs:50:1 -------------------------------------------------------------------------------- 47 | (reduced comp)))] 48 | (reduce-kv (matching-comp node) nil pred-&gt;comp))) 49 | 50 | (m/defsyntax number -------^------------------------------------------------------------------------ Use of undeclared Var meander.syntax.epsilon/global-expander-registry -------------------------------------------------------------------------------- 51 | ([] `(number _#)) 52 | ([pattern] (if (m/match-syntax? &amp;env) 53 | `(m/pred number? ~pattern) 54 | &amp;form))) --------------------------------------------------------------------------------"><y>#</y><d>2020-02-21</d><h>15:06</h><w>simongray</w><pre>------ WARNING #1 - :undeclared-var --------------------------------------------
 File: /Users/rqf595/Code/facsimile/dev/user.cljs:50:1
--------------------------------------------------------------------------------
  47 |                            (reduced comp)))]
  48 |     (reduce-kv (matching-comp node) nil pred-&gt;comp)))
  49 | 
  50 | (m/defsyntax number
-------^------------------------------------------------------------------------
 Use of undeclared Var meander.syntax.epsilon/*form*
--------------------------------------------------------------------------------
  51 |   ([] `(number _#))
  52 |   ([pattern] (if (m/match-syntax? &amp;env)
  53 |                `(m/pred number? ~pattern)
  54 |                &amp;form)))
--------------------------------------------------------------------------------

------ WARNING #2 - :undeclared-var --------------------------------------------
 File: /Users/rqf595/Code/facsimile/dev/user.cljs:50:1
--------------------------------------------------------------------------------
  47 |                            (reduced comp)))]
  48 |     (reduce-kv (matching-comp node) nil pred-&gt;comp)))
  49 | 
  50 | (m/defsyntax number
-------^------------------------------------------------------------------------
 Use of undeclared Var meander.syntax.epsilon/*env*
--------------------------------------------------------------------------------
  51 |   ([] `(number _#))
  52 |   ([pattern] (if (m/match-syntax? &amp;env)
  53 |                `(m/pred number? ~pattern)
  54 |                &amp;form)))
--------------------------------------------------------------------------------

------ WARNING #3 - :undeclared-var --------------------------------------------
 File: /Users/rqf595/Code/facsimile/dev/user.cljs:52:19
--------------------------------------------------------------------------------
  49 | 
  50 | (m/defsyntax number
  51 |   ([] `(number _#))
  52 |   ([pattern] (if (m/match-syntax? &amp;env)
-------------------------^------------------------------------------------------
 Use of undeclared Var meander.epsilon/match-syntax?
--------------------------------------------------------------------------------
  53 |                `(m/pred number? ~pattern)
  54 |                &amp;form)))
  55 | 
  56 | (m/rewrite [:glen {:data-ref &quot;glen&quot;}]
--------------------------------------------------------------------------------

------ WARNING #4 - :dynamic ---------------------------------------------------
 File: /Users/rqf595/Code/facsimile/dev/user.cljs:50:1
--------------------------------------------------------------------------------
  47 |                            (reduced comp)))]
  48 |     (reduce-kv (matching-comp node) nil pred-&gt;comp)))
  49 | 
  50 | (m/defsyntax number
-------^------------------------------------------------------------------------
 meander.syntax.epsilon/*form* not declared ^:dynamic
--------------------------------------------------------------------------------
  51 |   ([] `(number _#))
  52 |   ([pattern] (if (m/match-syntax? &amp;env)
  53 |                `(m/pred number? ~pattern)
  54 |                &amp;form)))
--------------------------------------------------------------------------------

------ WARNING #5 - :dynamic ---------------------------------------------------
 File: /Users/rqf595/Code/facsimile/dev/user.cljs:50:1
--------------------------------------------------------------------------------
  47 |                            (reduced comp)))]
  48 |     (reduce-kv (matching-comp node) nil pred-&gt;comp)))
  49 | 
  50 | (m/defsyntax number
-------^------------------------------------------------------------------------
 meander.syntax.epsilon/*env* not declared ^:dynamic
--------------------------------------------------------------------------------
  51 |   ([] `(number _#))
  52 |   ([pattern] (if (m/match-syntax? &amp;env)
  53 |                `(m/pred number? ~pattern)
  54 |                &amp;form)))
--------------------------------------------------------------------------------

------ WARNING #6 - :undeclared-var --------------------------------------------
 File: /Users/rqf595/Code/facsimile/dev/user.cljs:50:1
--------------------------------------------------------------------------------
  47 |                            (reduced comp)))]
  48 |     (reduce-kv (matching-comp node) nil pred-&gt;comp)))
  49 | 
  50 | (m/defsyntax number
-------^------------------------------------------------------------------------
 Use of undeclared Var meander.syntax.epsilon/global-expander-registry
--------------------------------------------------------------------------------
  51 |   ([] `(number _#))
  52 |   ([pattern] (if (m/match-syntax? &amp;env)
  53 |                `(m/pred number? ~pattern)
  54 |                &amp;form)))
--------------------------------------------------------------------------------</pre></z><z id="t1582297947" t="Jimmy Miller [:attrs {:href &quot;/_/_/users/U4P4NREBY&quot;}] I will take a look into what is going on. I can&apos;t remember off the top of my head if defsyntax needs to be defined in clojure like a macro and then used in clojurescript or not. Just blanking out on that at the moment. (I think that might be the case)"><y>#</y><d>2020-02-21</d><h>15:12</h><w>Jimmy Miller</w><a>@simongray</a> I will take a look into what is going on. I can&apos;t remember off the top of my head if defsyntax needs to be defined in clojure like a macro and then used in clojurescript or not. Just blanking out on that at the moment. (I think that might be the case)</z><z id="t1582298665" t="Jimmy Miller [:attrs {:href &quot;/_/_/users/U4P4NREBY&quot;}] Yeah, you should treat defsyntax just like you would a macro. You define it in a clojure file, require that file in your clojurescript and you can use it in your clojurescript matches."><y>#</y><d>2020-02-21</d><h>15:24</h><w>Jimmy Miller</w><a>@simongray</a> Yeah, you should treat defsyntax just like you would a macro. You define it in a clojure file, require that file in your clojurescript and you can use it in your clojurescript matches.</z><z id="t1582298760" t="simongray thanks! macros in CLJS always trip me up :)"><y>#</y><d>2020-02-21</d><h>15:26</h><r>simongray</r>thanks! macros in CLJS always trip me up :)</z><z id="t1582299080" t="Jimmy Miller I agree 100%"><y>#</y><d>2020-02-21</d><h>15:31</h><r>Jimmy Miller</r>I agree 100%</z><z id="t1582299121" t="Jimmy Miller Might be good to give a better error for this. I&apos;ll see what we can do about that."><y>#</y><d>2020-02-21</d><h>15:32</h><r>Jimmy Miller</r>Might be good to give a better error for this. I&apos;ll see what we can do about that.</z><z id="t1582299168" t="markaddleman My data can match one of two patterns using m/or . Regardless of which pattern it matches, the output requires a single lvar. One of the two patterns needs a join so it has an extra lvar for &quot;internal&quot; join purposes. Meander requires that every branch of the m/or declare the same lvars even though, in this case, the &quot;internal&quot; lvar is never used anywhere but its branch. This forces some minor, unnecessary complexity in the other branch. It&apos;s a small thing but could meander be enhanced to handle this case more gracefully?"><y>#</y><d>2020-02-21</d><h>15:32</h><w>markaddleman</w>My data can match one of two patterns using <code>m/or</code>.  Regardless of which pattern it matches, the output requires a single lvar.  One of the two patterns needs a join so it has an extra lvar for &quot;internal&quot; join purposes.  Meander requires that every branch of the <code>m/or</code> declare the same lvars even though, in this case, the &quot;internal&quot; lvar is never used anywhere but its branch.  This forces some minor, unnecessary complexity in the other branch.  It&apos;s a small thing but could meander be enhanced to handle this case more gracefully?</z><z id="t1582299364" t="Jimmy Miller If you can give an example that would be super helpful. I think understand what you are saying, but seeing something concrete helps a lot."><y>#</y><d>2020-02-21</d><h>15:36</h><r>Jimmy Miller</r>If you can give an example that would be super helpful. I think understand what you are saying, but seeing something concrete helps a lot.</z><z id="t1582300015" t="Jimmy Miller If I have an example, I can disable some checks, run things through and think more about what problems not having the logic var in both branches might cause. It could be that we are overly restrictive and there is some less strict property that is still safe. But I&apos;m not 100% sure."><y>#</y><d>2020-02-21</d><h>15:46</h><r>Jimmy Miller</r>If I have an example, I can disable some checks, run things through and think more about what problems not having the logic var in both branches might cause.

It could be that we are overly restrictive and there is some less strict property that is still safe. But I&apos;m not 100% sure.</z><z id="t1582300192" t="markaddleman The let and ?join-key in the second or branch isn&apos;t strictly necessary"><y>#</y><d>2020-02-21</d><h>15:49</h><r>markaddleman</r>The let and ?join-key in the second or branch isn&apos;t strictly necessary</z><z id="t1582300719" t="Jimmy Miller Super helpful. Thanks, I&apos;ll look into things and think about what we might be able to do. If you don&apos;t hear back from me, feel free to either bug me again or file a github issue."><y>#</y><d>2020-02-21</d><h>15:58</h><r>Jimmy Miller</r>Super helpful. Thanks, I&apos;ll look into things and think about what we might be able to do. If you don&apos;t hear back from me, feel free to either bug me again or file a github issue.</z><z id="t1582300896" t="Jimmy Miller So I will say, that I just checked it won&apos;t be as easy as changing the check. As it stands now, without that check the code we generate will not work. I don&apos;t think this is a fundamental limitation, but one we do have right now."><y>#</y><d>2020-02-21</d><h>16:01</h><r>Jimmy Miller</r>So I will say, that  I just checked it won&apos;t be as easy as changing the check. As it stands now, without that check the code we generate will not work. I don&apos;t think this is a fundamental limitation, but one we do have right now.</z><z id="t1582301310" t="markaddleman No worries, it&apos;s not a big thing - just a thing 🙂"><y>#</y><d>2020-02-21</d><h>16:08</h><r>markaddleman</r>No worries, it&apos;s not a big thing - just a thing <b>🙂</b></z><z id="t1582301392" t="markaddleman One related thing : Can the check message include the missing vars? Meaning, if I didn&apos;t have the let in the second branch, could the message say, &quot;Yo! You&apos;re missing ?join-key in one of the or branches&quot;"><y>#</y><d>2020-02-21</d><h>16:09</h><r>markaddleman</r>One related thing :  Can the check message include the missing vars?  Meaning, if I didn&apos;t have the let in the second branch, could the message say, &quot;Yo!  You&apos;re missing ?join-key in one of the or branches&quot;</z><z id="t1582301842" t="Jimmy Miller The variables that are missing are in the ex-info. Not sure your setup, but I see them when I run your code: {:env {:lvrs #{}, :mvrs #{}, :refs {}, :path []}, :problems [{:pattern (m/scan {(m/some &quot;a3&quot;) ?value}), :absent #{?join-key}}], :syntax-trace [(m/or (m/and (m/scan {&quot;join&quot; ?join-key, (m/some &quot;a1&quot;) ?value}) (m/scan {&quot;join&quot; ?join-key, (m/some &quot;a2&quot;) ?value})) (m/scan {(m/some &quot;a3&quot;) ?value}))]}"><y>#</y><d>2020-02-21</d><h>16:17</h><r>Jimmy Miller</r>The variables that are missing are in the ex-info. Not sure your setup, but I see them when I run your code:
<pre>{:env {:lvrs #{}, :mvrs #{}, :refs {}, :path []},
 :problems
 [{:pattern (m/scan {(m/some &quot;a3&quot;) ?value}), :absent #{?join-key}}],
 :syntax-trace
 [(m/or
   (m/and
    (m/scan {&quot;join&quot; ?join-key, (m/some &quot;a1&quot;) ?value})
    (m/scan {&quot;join&quot; ?join-key, (m/some &quot;a2&quot;) ?value}))
   (m/scan {(m/some &quot;a3&quot;) ?value}))]}</pre></z><z id="t1582301950" t="Jimmy Miller So, I think we could possibly make this work for rewrite/rewrites, but not match/search. Because we&apos;d have to know that on the rhs you don&apos;t use that logic variable and the right hand side of search/match are unanalyzed."><y>#</y><d>2020-02-21</d><h>16:19</h><r>Jimmy Miller</r>So, I think we could possibly make this work for rewrite/rewrites, but not match/search. Because we&apos;d have to know that on the rhs you don&apos;t use that logic variable and the right hand side of search/match are unanalyzed.</z><z id="t1582301988" t="markaddleman Ah, I didn&apos;t think to look in the ex-info. Thx"><y>#</y><d>2020-02-21</d><h>16:19</h><r>markaddleman</r>Ah, I didn&apos;t think to look in the ex-info.  Thx</z><z id="t1582302083" t="markaddleman That makes sense. Other than performance, is there a reason to prefer match/search over rewrite/rewrites?"><y>#</y><d>2020-02-21</d><h>16:21</h><r>markaddleman</r>That makes sense.  Other than performance, is there a reason to prefer match/search over rewrite/rewrites?</z><z id="t1582302768" t="Jimmy Miller Not sure you&apos;d see too much of a performance difference right now. Rewrite can eventually be faster because we can optimize more. Really it is just a question of if you want substitution on the right hand side (rewrite) or arbitrary clojure code (match)."><y>#</y><d>2020-02-21</d><h>16:32</h><r>Jimmy Miller</r>Not sure you&apos;d see too much of a performance difference right now. Rewrite can eventually be faster because we can optimize more. Really it is just a question of if you want substitution on the right hand side (rewrite) or arbitrary clojure code (match).</z><z id="t1582299236" t="simongray One more question before I head home for the weekend: say I want to match only the hiccup vector with an attr containing certain keys, e.g. {:data-ref ?ref :data-type ?type} The default in meander seems to be that any maps will match and the keys are solely used for capturing values. Is there no sugar for matching against a map containing certain keys?"><y>#</y><d>2020-02-21</d><h>15:33</h><w>simongray</w>One more question before I head home for the weekend: say I want to match only the hiccup vector with an attr containing certain keys, e.g.
<pre>{:data-ref ?ref :data-type ?type}</pre>
The default in meander seems to be that any maps will match and the keys are solely used for capturing values. Is there no sugar for matching against a map containing certain keys?</z><z id="t1582299500" t="Jimmy Miller {:data-ref (m/some ?ref) :data-type (m/some ?type)} If you don&apos;t actually care about capturing the values you can just use {:my-key (m/some)}"><y>#</y><d>2020-02-21</d><h>15:38</h><w>Jimmy Miller</w><pre>{:data-ref (m/some ?ref) :data-type (m/some ?type)}</pre>
If you don&apos;t actually care about capturing the values you can just use <code>{:my-key (m/some)}</code></z><z id="t1582299569" t="simongray I do care, though 😉"><y>#</y><d>2020-02-21</d><h>15:39</h><r>simongray</r>I do care, though <b>😉</b></z><z id="t1582299746" t="Jimmy Miller Yeah, so if you do care just use (m/some ?my-var) ."><y>#</y><d>2020-02-21</d><h>15:42</h><r>Jimmy Miller</r>Yeah, so if you do care just use <code>(m/some ?my-var)</code>.</z><z id="t1582299799" t="Jimmy Miller There you will only match maps will non-nil values for those keys."><y>#</y><d>2020-02-21</d><h>15:43</h><r>Jimmy Miller</r>There you will only match maps will non-nil values for those keys.</z><z id="t1582300110" t="simongray Thank you. Sorry for being a bit clueless. I only started usig meander a couple of hours ago (after rewatching your excellent strange loop talk)."><y>#</y><d>2020-02-21</d><h>15:48</h><r>simongray</r>Thank you. Sorry for being a bit clueless. I only started usig meander a couple of hours ago (after rewatching your  excellent strange loop talk).</z><z id="t1582300178" t="Jimmy Miller No worries at all. There is a lot to learn and I&apos;m always happy to help out. I&apos;m glad that you enjoyed the talk 🙂"><y>#</y><d>2020-02-21</d><h>15:49</h><r>Jimmy Miller</r>No worries at all. There is a lot to learn and I&apos;m always happy to help out. I&apos;m glad that you enjoyed the talk <b>🙂</b></z><z id="t1582739249" t="maxt Hi! Is there a good way to get from [{:name &quot;Alice&quot; :id 1} {:name &quot;Bob&quot; :id 2}] to {1 &quot;Alice&quot; 2 &quot;Bob&quot;} ? Match doesn&apos;t let me scan and search returns two maps (m/search [{:name &quot;Alice&quot; :id 1} {:name &quot;Bob&quot; :id 2}] (m/scan {:name ?name :id ?id}) {?name ?id})"><y>#</y><d>2020-02-26</d><h>17:47</h><w>maxt</w>Hi! Is there a good way to get from
<pre>[{:name &quot;Alice&quot; :id 1}
 {:name &quot;Bob&quot; :id 2}]</pre>
to
<pre>{1 &quot;Alice&quot;
 2 &quot;Bob&quot;}</pre>
?
Match doesn&apos;t let me scan and search returns two maps
<pre>(m/search [{:name &quot;Alice&quot; :id 1}
           {:name &quot;Bob&quot; :id 2}]
          (m/scan {:name ?name :id ?id})
          {?name ?id})</pre></z><z id="t1582742189" t="Jimmy Miller With rewrite you can do the following: (m/rewrite [{:name &quot;Alice&quot; :id 1} {:name &quot;Bob&quot; :id 2}] [{:name !names :id !ids} ...] {&amp; [[!names !ids] ...]}) I should probably put this example in the cookbook. Sadly with maps ... isn&apos;t straight forward. But the {&amp; [[x y] ...]} is a nice little idiom for building up maps. Also, just to mention the alternative possibility, if you really needed search you could use into. (into {} (m/search [{:name &quot;Alice&quot; :id 1} {:name &quot;Bob&quot; :id 2}] (m/scan {:name ?name :id ?id}) {?name ?id})) My recommendation is trying out rewrite for this."><y>#</y><d>2020-02-26</d><h>18:36</h><w>Jimmy Miller</w>With rewrite you can do the following:

<pre>(m/rewrite [{:name &quot;Alice&quot; :id 1}
            {:name &quot;Bob&quot; :id 2}]
  [{:name !names :id !ids} ...] 
  {&amp; [[!names !ids] ...]})</pre>
I should probably put this example in the cookbook. Sadly with maps <code>...</code> isn&apos;t straight forward. But the <code>{&amp; [[x y] ...]}</code> is a nice little idiom for building up maps.

Also, just to mention the alternative possibility, if you really needed search you could use into.

<pre>(into
 {}
 (m/search [{:name &quot;Alice&quot; :id 1}
            {:name &quot;Bob&quot; :id 2}]
   (m/scan {:name ?name :id ?id})
   {?name ?id}))</pre>
My recommendation is trying out rewrite for this.</z><z id="t1582742253" t="Jimmy Miller Just throw more ways out. You can do this with match and some pretty standard clojure. (m/match [{:name &quot;Alice&quot; :id 1} {:name &quot;Bob&quot; :id 2}] [{:name !names :id !ids} ...] (into {} (map vector !ids !names)))"><y>#</y><d>2020-02-26</d><h>18:37</h><r>Jimmy Miller</r>Just throw more ways out. You can do this with match and some pretty standard clojure.

<pre>(m/match [{:name &quot;Alice&quot; :id 1}
          {:name &quot;Bob&quot; :id 2}]
  [{:name !names :id !ids} ...] 
  (into {} (map vector !ids !names)))</pre></z><z id="t1582742388" t="maxt Thanks a lot for the rewrite suggestion, I wouldn&apos;t have come up with that one myself 🙂 It&apos;s of course easy to convert it with into, but how fun is that? Seriously it does loose some of the what you see is what you get-ness."><y>#</y><d>2020-02-26</d><h>18:39</h><r>maxt</r>Thanks a lot for the rewrite suggestion, I wouldn&apos;t have come up with that one myself <b>🙂</b>

It&apos;s of course easy to convert it with into, but how fun is that? Seriously it does loose some of the what you see is what you get-ness.</z><z id="t1582742785" t="Jimmy Miller Yeah, and the &amp; solution for maps isn&apos;t the most wysiwyg thing either. Sadly we couldn&apos;t think of a great way to do repeats since maps have to always have pairs and are un-ordered. A perennial topic that comes up is adding a map-of operator. But we&apos;ve yet to settle on an implementation. https://github.com/noprompt/meander/issues/74"><y>#</y><d>2020-02-26</d><h>18:46</h><r>Jimmy Miller</r>Yeah, and the <code>&amp;</code> solution for maps isn&apos;t the most wysiwyg thing either. Sadly we couldn&apos;t think of a great way to do repeats since maps have to always have pairs and are un-ordered.

A perennial topic that comes up is adding a map-of operator. But we&apos;ve yet to settle on an implementation. <a href="https://github.com/noprompt/meander/issues/74" target="_blank">https://github.com/noprompt/meander/issues/74</a></z><z id="t1582743028" t="maxt (m/match [{:name &quot;Alice&quot; :id 1} {:name &quot;Bob&quot; :id 2}] [{:name !names :id !ids} ...] (zipmap !names !ids)) "><y>#</y><d>2020-02-26</d><h>18:50</h><r>maxt</r><pre>(m/match [{:name &quot;Alice&quot; :id 1}
          {:name &quot;Bob&quot; :id 2}]
         [{:name !names :id !ids} ...]
         (zipmap !names !ids))</pre>
</z><z id="t1582743043" t="maxt yet another version"><y>#</y><d>2020-02-26</d><h>18:50</h><r>maxt</r>yet another version</z><z id="t1582768019" t="Daniel Hines Guys it&apos;s been a while since I&apos;ve been in Meander. I&apos;m trying to turn this: {&quot;users&quot; [{&quot;name&quot; &quot;Bob&quot; &quot;favoriteFood&quot; &quot;apple&quot;} ...] &quot;foodsByName&quot; {&quot;apple&quot; {&quot;category&quot; &quot;fruit&quot;} ...}} into this: [{&quot;name&quot; &quot;Bob&quot; &quot;favoriteFood&quot; &quot;apple&quot; &quot;category&quot; &quot;fruit&quot;} ...] But I&apos;m stuck at the first step 😛 (m/search data (m/scan {&quot;name&quot; ?name}) ?name) ;; =&gt; () What am I doing wrong here?"><y>#</y><d>2020-02-27</d><h>01:46</h><w>Daniel Hines</w>Guys it&apos;s been a while since I&apos;ve been in Meander. I&apos;m trying to turn this:
<pre>{&quot;users&quot; [{&quot;name&quot; &quot;Bob&quot; &quot;favoriteFood&quot; &quot;apple&quot;} ...]
 &quot;foodsByName&quot; {&quot;apple&quot; {&quot;category&quot; &quot;fruit&quot;} ...}}</pre>
into this:
<pre>[{&quot;name&quot; &quot;Bob&quot; &quot;favoriteFood&quot; &quot;apple&quot; &quot;category&quot; &quot;fruit&quot;} ...]</pre>
But I&apos;m stuck at the first step <b>😛</b>
<pre>(m/search data (m/scan {&quot;name&quot; ?name}) ?name) ;; =&gt; ()</pre>
What am I doing wrong here?</z><z id="t1582768097" t="Daniel Hines Duh. I&apos;m missing the &quot;users&quot; key."><y>#</y><d>2020-02-27</d><h>01:48</h><w>Daniel Hines</w>Duh. I&apos;m missing the <code>&quot;users&quot;</code> key.</z><z id="t1582768101" t="Daniel Hines facepalm"><y>#</y><d>2020-02-27</d><h>01:48</h><w>Daniel Hines</w><b>facepalm</b></z><z id="t1582802839" t="grounded_sage It would be cool to have something like this for Meander. https://borkdude.github.io/re-find.web/"><y>#</y><d>2020-02-27</d><h>11:27</h><w>grounded_sage</w>It would be cool to have something like this for Meander. <a href="https://borkdude.github.io/re-find.web/" target="_blank">https://borkdude.github.io/re-find.web/</a></z><z id="t1582820397" t="Jimmy Miller [:attrs {:href &quot;/_/_/users/U05095F2K&quot;}] So I mentioned this at the end of my meander talk. But I actually did implement something where you can hand in some input and output and it will spit out a rewrite for you. It is pretty limited and didn&apos;t handle anything with repeats or anything like that. I&apos;ve found those are the more common things. If someone wants to take a stab at making something like the above, I&apos;d definitely be happy to help out with that."><y>#</y><d>2020-02-27</d><h>16:19</h><w>Jimmy Miller</w><a>@grounded_sage</a> So I mentioned this at the end of my meander talk. But I actually did implement something where you can hand in some input and output and it will spit out a rewrite for you.

It is pretty limited and didn&apos;t handle anything with repeats or anything like that. I&apos;ve found those are the more common things.

If someone wants to take a stab at making something like the above, I&apos;d definitely be happy to help out with that.</z><z id="t1582821348" t="grounded_sage [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] ah. It’s been a while since I watched that talk. It would definitely be hard to handle the more complex cases and doing some reshaping before or after sometimes is a more ideal solution. But definitely the more simple use cases could be handled"><y>#</y><d>2020-02-27</d><h>16:35</h><w>grounded_sage</w><a>@jimmy</a> ah. It’s been a while since I watched that talk. It would definitely be hard to handle the more complex cases and doing some reshaping before or after sometimes is a more ideal solution. But definitely the more simple use cases could be handled</z><z id="t1582822352" t="grounded_sage As an aside. I’m at the Clojure Datascience Meetup here in Berlin. Lots of people are really interested in Meander and have shown people how I have been using it"><y>#</y><d>2020-02-27</d><h>16:52</h><w>grounded_sage</w>As an aside. I’m at the Clojure Datascience Meetup here in Berlin. Lots of people are really interested in Meander and have shown people how I have been using it</z><z id="t1582822835" t="noprompt That’s great! This year should see some big improvements to what you can do with it. In particular, I’m excited for the ability to aggregate during pattern matching and generate data from patterns."><y>#</y><d>2020-02-27</d><h>17:00</h><w>noprompt</w>That’s great! This year should see some big improvements to what you can do with it. In particular, I’m excited for the ability to aggregate during pattern matching and generate data from patterns.</z><z id="t1582822895" t="noprompt I think these new additions would be handy for data science."><y>#</y><d>2020-02-27</d><h>17:01</h><w>noprompt</w>I think these new additions would be handy for data science.</z><z id="t1582822935" t="noprompt Feedback good and bad would be appreciated. Let folks know we welcome criticism. 👍"><y>#</y><d>2020-02-27</d><h>17:02</h><w>noprompt</w>Feedback good and bad would be appreciated. Let folks know we welcome criticism. <b>👍</b></z><z id="t1582865141" t="yuhan (m/rewrite (range 100) (!a !b ...) {&amp; [[!a !b] ...]}) ;; =&gt; {0 1, 2 3, 4 5, 6 7, 8 9, 10 11, 12 13, 14 15} !!!"><y>#</y><d>2020-02-28</d><h>04:45</h><w>yuhan</w><pre>(m/rewrite (range 100)
  (!a !b ...)
  {&amp; [[!a !b] ...]})
;; =&gt; {0 1, 2 3, 4 5, 6 7, 8 9, 10 11, 12 13, 14 15}</pre>
!!!</z><z id="t1582865812" t="yuhan https://github.com/noprompt/meander/blob/f2697b581a757f5735d1f6cde94f1b1e9d9f57f8/src/meander/substitute/epsilon.cljc#L334"><y>#</y><d>2020-02-28</d><h>04:56</h><w>yuhan</w><a href="https://github.com/noprompt/meander/blob/f2697b581a757f5735d1f6cde94f1b1e9d9f57f8/src/meander/substitute/epsilon.cljc#L334" target="_blank">https://github.com/noprompt/meander/blob/f2697b581a757f5735d1f6cde94f1b1e9d9f57f8/src/meander/substitute/epsilon.cljc#L334</a></z><z id="t1582865833" t="yuhan this looks to be the problem.. transients aren&apos;t meant to be &quot;bashed in place&quot;"><y>#</y><d>2020-02-28</d><h>04:57</h><w>yuhan</w>this looks to be the problem.. transients aren&apos;t meant to be &quot;bashed in place&quot;</z><z id="t1582865883" t="yuhan (let [t (transient {})] (doseq [a (range 100)] (conj! t [a a])) (persistent! t)) ;; =&gt; {0 0, 1 1, 2 2, 3 3, 4 4, 5 5, 6 6, 7 7}"><y>#</y><d>2020-02-28</d><h>04:58</h><w>yuhan</w><pre>(let [t (transient {})]
  (doseq [a (range 100)]
    (conj! t [a a]))
  (persistent! t))
;; =&gt; {0 0, 1 1, 2 2, 3 3, 4 4, 5 5, 6 6, 7 7}</pre></z><z id="t1582866077" t="noprompt [:attrs {:href &quot;/_/_/users/UCPS050BV&quot;}] I’m confused… what is the problem?"><y>#</y><d>2020-02-28</d><h>05:01</h><w>noprompt</w><a>@qythium</a> I’m confused… what is the problem?</z><z id="t1582866153" t="yuhan I would expect the output to be a 50-element map"><y>#</y><d>2020-02-28</d><h>05:02</h><w>yuhan</w>I would expect the output to be a 50-element map</z><z id="t1582866182" t="noprompt Oh, oh, yes that is a problem."><y>#</y><d>2020-02-28</d><h>05:03</h><w>noprompt</w>Oh, oh, yes that is a problem.</z><z id="t1582866228" t="noprompt Do you have an idea of how to fix this? zeta already has a fix for this."><y>#</y><d>2020-02-28</d><h>05:03</h><w>noprompt</w>Do you have an idea of how to fix this? <code>zeta</code> already has a fix for this.</z><z id="t1582866310" t="yuhan I think by using a loop/recur with the transient collection as a loop variable"><y>#</y><d>2020-02-28</d><h>05:05</h><w>yuhan</w>I think by using a loop/recur with the transient collection as a loop variable</z><z id="t1582866518" t="noprompt Sounds good to me."><y>#</y><d>2020-02-28</d><h>05:08</h><w>noprompt</w>Sounds good to me.</z><z id="t1582866608" t="noprompt Would you like to patch it?"><y>#</y><d>2020-02-28</d><h>05:10</h><w>noprompt</w>Would you like to patch it?</z><z id="t1582866968" t="noprompt I learned something new about transient s today."><y>#</y><d>2020-02-28</d><h>05:16</h><w>noprompt</w>I learned something new about <code>transient</code>s today.</z><z id="t1582867208" t="noprompt I still don’t know what the hell the Clojure page on transients means by “Don’t bash in place” :man-shrugging:"><y>#</y><d>2020-02-28</d><h>05:20</h><w>noprompt</w>I still don’t know what the hell the Clojure page on transients means by “Don’t bash in place” <b>:man-shrugging:</b></z><z id="t1582867253" t="yuhan I think basically it means don&apos;t treat it like a mutable collection"><y>#</y><d>2020-02-28</d><h>05:20</h><w>yuhan</w>I think basically it means don&apos;t treat it like a mutable collection</z><z id="t1582867308" t="yuhan the conj! , assoc! etc. functions aren&apos;t like imperative statements in other languages"><y>#</y><d>2020-02-28</d><h>05:21</h><w>yuhan</w>the conj! , assoc! etc. functions aren&apos;t like imperative statements in other languages</z><z id="t1582867332" t="noprompt Yeah I just found some blog post talking about that…"><y>#</y><d>2020-02-28</d><h>05:22</h><w>noprompt</w>Yeah I just found some blog post talking about that…</z><z id="t1582867339" t="noprompt Geeze… talk about a hot stove."><y>#</y><d>2020-02-28</d><h>05:22</h><w>noprompt</w>Geeze… talk about a hot stove.</z><z id="t1582867370" t="yuhan yeah, I made a similar mistake when first learning about transients"><y>#</y><d>2020-02-28</d><h>05:22</h><w>yuhan</w>yeah, I made a similar mistake when first learning about transients</z><z id="t1582867418" t="yuhan Okay, I changed the compile* multimethod for :rp* which fixed the above problem"><y>#</y><d>2020-02-28</d><h>05:23</h><w>yuhan</w>Okay, I changed the compile* multimethod for :rp* which fixed the above problem</z><z id="t1582867472" t="noprompt Awesome."><y>#</y><d>2020-02-28</d><h>05:24</h><w>noprompt</w>Awesome.</z><z id="t1582867485" t="yuhan although I have no idea what any of the internals work and how to run tests?"><y>#</y><d>2020-02-28</d><h>05:24</h><w>yuhan</w>although  I have no idea what any of the internals work and how to run tests?</z><z id="t1582867497" t="yuhan and there seem to be a few more uses of transient in the project"><y>#</y><d>2020-02-28</d><h>05:24</h><w>yuhan</w>and there seem to be a few more uses of transient in the project</z><z id="t1582867558" t="noprompt A few of those are in those pseudo rewrite rules."><y>#</y><d>2020-02-28</d><h>05:25</h><w>noprompt</w>A few of those are in those pseudo rewrite rules.</z><z id="t1582867588" t="noprompt Looks like :rp+ is probably busted too."><y>#</y><d>2020-02-28</d><h>05:26</h><w>noprompt</w>Looks like <code>:rp+</code> is probably busted too.</z><z id="t1582867641" t="noprompt LOL and you just replace let with loop and it fixes it! 😂"><y>#</y><d>2020-02-28</d><h>05:27</h><w>noprompt</w>LOL and you just replace <code>let</code> with <code>loop</code> and it fixes it! <b>😂</b></z><z id="t1582867724" t="yuhan yup, just opened a PR"><y>#</y><d>2020-02-28</d><h>05:28</h><w>yuhan</w>yup, just opened a PR</z><z id="t1582867739" t="noprompt Cool. Those rewrite rules can probably be toasted."><y>#</y><d>2020-02-28</d><h>05:28</h><w>noprompt</w>Cool. Those rewrite rules can probably be toasted.</z><z id="t1582867778" t="noprompt Nice work!"><y>#</y><d>2020-02-28</d><h>05:29</h><w>noprompt</w>Nice work!</z><z id="t1582867792" t="noprompt I’ll just take the example you gave and make that the test."><y>#</y><d>2020-02-28</d><h>05:29</h><w>noprompt</w>I’ll just take the example you gave and make that the test.</z><z id="t1582867799" t="noprompt New release in just a moment…"><y>#</y><d>2020-02-28</d><h>05:29</h><w>noprompt</w>New release in just a moment…</z><z id="t1582867833" t="yuhan give me a minute, rewriting :rp+ as well"><y>#</y><d>2020-02-28</d><h>05:30</h><w>yuhan</w>give me a minute, rewriting :rp+ as well</z><z id="t1582867843" t="yuhan ah, that was fast"><y>#</y><d>2020-02-28</d><h>05:30</h><w>yuhan</w>ah, that was fast</z><z id="t1582868678" t="noprompt I got rpm and rpl while I was in there."><y>#</y><d>2020-02-28</d><h>05:44</h><w>noprompt</w>I got rpm and rpl while I was in there.</z><z id="t1582868697" t="noprompt rp+ too."><y>#</y><d>2020-02-28</d><h>05:44</h><w>noprompt</w>rp+ too.</z><z id="t1582868734" t="noprompt As I’m working on zeta I use epsilon from :local/root"><y>#</y><d>2020-02-28</d><h>05:45</h><w>noprompt</w>As I’m working on <code>zeta</code> I use <code>epsilon</code> from <code>:local/root</code></z><z id="t1582868778" t="noprompt So if I find bugs with epsilon (which I’m using to build zeta ) I can patch them as I come up. Lately, I’m relying more on others to help catch/fix bugs. 🙂"><y>#</y><d>2020-02-28</d><h>05:46</h><w>noprompt</w>So if I find bugs with <code>epsilon</code> (which I’m using to build <code>zeta</code> ) I can patch them as I come up. Lately, I’m relying more on others to help catch/fix bugs. <b>🙂</b></z><z id="t1582869092" t="noprompt [:attrs {:href &quot;/_/_/users/UCPS050BV&quot;}] The new version should be up any moment now. [meander/epsilon 0.0.397] Fantastic stuff! Thanks much. 👍"><y>#</y><d>2020-02-28</d><h>05:51</h><w>noprompt</w><a>@qythium</a> The new version should be up any moment now.
<pre>[meander/epsilon 0.0.397]</pre>
Fantastic stuff! Thanks much. <b>👍</b></z><z id="t1582869356" t="yuhan awesome 🙂 looking forward to zeta!"><y>#</y><d>2020-02-28</d><h>05:55</h><w>yuhan</w>awesome <b>🙂</b> looking forward to zeta!</z><z id="t1582869429" t="noprompt Few months 🤞"><y>#</y><d>2020-02-28</d><h>05:57</h><w>noprompt</w>Few months <b>🤞</b></z><z id="t1582869494" t="noprompt The things I’m most exited for are bit/byte/string matching, aggregation, and data generation."><y>#</y><d>2020-02-28</d><h>05:58</h><w>noprompt</w>The things I’m most exited for are bit/byte/string matching, aggregation, and data generation.</z><z id="t1582869508" t="yuhan I&apos;m not sure if your changes to rp+ etc. are technically correct - still looks like in-place modification"><y>#</y><d>2020-02-28</d><h>05:58</h><w>yuhan</w>I&apos;m not sure if your changes to rp+ etc. are technically correct - still looks like in-place modification</z><z id="t1582869653" t="yuhan the way I see it is, treat conj! exactly like you would use conj"><y>#</y><d>2020-02-28</d><h>06:00</h><w>yuhan</w>the way I see it is, treat <code>conj!</code> exactly like you would use <code>conj</code></z><z id="t1582869728" t="noprompt Hmm… (t/is (= (r/rewrite (range 20) (!a !b ...) {&amp; [[!a !b] ..20]}) {nil nil, 0 1, 4 5, 6 7, 12 13, 2 3, 14 15, 16 17, 10 11, 18 19, 8 9})) is passing. If you’re concerned though and have doubts about the implementation, I’d be happy to merge another patch."><y>#</y><d>2020-02-28</d><h>06:02</h><w>noprompt</w>Hmm…
<pre>(t/is (= (r/rewrite (range 20)
             (!a !b ...)
             {&amp; [[!a !b] ..20]})
           {nil nil, 0 1, 4 5, 6 7, 12 13, 2 3, 14 15, 16 17, 10 11, 18 19, 8 9}))</pre>
is passing. If you’re concerned though and have doubts about the implementation, I’d be happy to merge another patch.</z><z id="t1582869743" t="noprompt I have zero problems with that. 🙂"><y>#</y><d>2020-02-28</d><h>06:02</h><w>noprompt</w>I have zero problems with that. <b>🙂</b></z><z id="t1582869845" t="noprompt Oh I think I see what you mean."><y>#</y><d>2020-02-28</d><h>06:04</h><w>noprompt</w>Oh I think I see what you mean.</z><z id="t1582869857" t="yuhan I don&apos;t know if there is a counterexample for those cases, it might just happen to be working due to &quot;undefined behavior&quot;"><y>#</y><d>2020-02-28</d><h>06:04</h><w>yuhan</w>I don&apos;t know if there is a counterexample for those cases, it might just happen to be working due to &quot;undefined behavior&quot;</z><z id="t1582869875" t="noprompt Instead of (conj! ,,,) (conj! ,,,) ,,, you’re suggesting (conj! (conj! ,,,)) yes?"><y>#</y><d>2020-02-28</d><h>06:04</h><w>noprompt</w>Instead of
<pre>(conj! ,,,)
(conj! ,,,)
,,,</pre>
you’re suggesting
<pre>(conj! (conj! ,,,))</pre>
yes?</z><z id="t1582869895" t="yuhan yep"><y>#</y><d>2020-02-28</d><h>06:04</h><w>yuhan</w>yep</z><z id="t1582869910" t="noprompt Got it."><y>#</y><d>2020-02-28</d><h>06:05</h><w>noprompt</w>Got it.</z><z id="t1582869929" t="yuhan pass an accumulator in a reduce instead of (do (map... ))"><y>#</y><d>2020-02-28</d><h>06:05</h><w>yuhan</w>pass an accumulator in a <code>reduce</code> instead of (do (map... ))</z><z id="t1582869940" t="noprompt Okay that just amounts to changing the map in to a reduce"><y>#</y><d>2020-02-28</d><h>06:05</h><w>noprompt</w>Okay that just amounts to changing the map in to a reduce</z><z id="t1582869944" t="noprompt Yah."><y>#</y><d>2020-02-28</d><h>06:05</h><w>noprompt</w>Yah.</z><z id="t1582869948" t="noprompt 🙂"><y>#</y><d>2020-02-28</d><h>06:05</h><w>noprompt</w><b>🙂</b></z><z id="t1582870048" t="noprompt I do need to hop off here for a bit and can bang on it when I’m back which should be in a hour or so. If you wanna hack on it thats cool too. 👍"><y>#</y><d>2020-02-28</d><h>06:07</h><w>noprompt</w>I do need to hop off here for a bit and can bang on it when I’m back which should be in a hour or so. If you wanna hack on it thats cool too. <b>👍</b></z><z id="t1582922058" t="niclasnilsson Hi everyone! I’m trying to reshape a map with lists in it using meander, but haven’t found a way. Can this be done using only meander constructions? (def data {:first-name &quot;Jimi&quot; :last-name &quot;Hendrix&quot; :guitars [{:brand &quot;Fender&quot; :model &quot;Stratocaster&quot; :year 1963} {:brand &quot;Fender&quot; :model &quot;Stratocaster&quot; :year 1965} {:brand &quot;Gibson&quot; :model &quot;Les Paul Custom&quot; :year 1955}]}) (m/search data {:first-name ?first-name :last-name ?last-name :guitars (m/scan {:brand ?brand})} {:firstname ?first-name :surname ?last-name :make ?brand}) ;; Result ({:firstname &quot;Jimi&quot;, :make &quot;Fender&quot;, :surname &quot;Hendrix&quot;} {:firstname &quot;Jimi&quot;, :make &quot;Fender&quot;, :surname &quot;Hendrix&quot;} {:firstname &quot;Jimi&quot;, :make &quot;Gibson&quot;, :surname &quot;Hendrix&quot;}) ;; Result I would like to have. But how? {:firstname &quot;Jimi&quot; :surname &quot;Hendrix&quot; :guitars [{:make &quot;Fender&quot;} {:make &quot;Fender&quot;} {:make &quot;Gibson&quot;}]} "><y>#</y><d>2020-02-28</d><h>20:34</h><w>niclasnilsson</w>Hi everyone! I’m trying to reshape a map with lists in it using meander, but haven’t found a way. Can this be done using only meander constructions?

<pre>(def data
  {:first-name &quot;Jimi&quot;
   :last-name &quot;Hendrix&quot;
   :guitars
    [{:brand &quot;Fender&quot;
      :model &quot;Stratocaster&quot;
      :year 1963}
     {:brand &quot;Fender&quot;
      :model &quot;Stratocaster&quot;
      :year 1965}
     {:brand &quot;Gibson&quot;
      :model &quot;Les Paul Custom&quot;
      :year 1955}]})

(m/search 
  data
  {:first-name ?first-name
   :last-name ?last-name
   :guitars (m/scan {:brand ?brand})}

  {:firstname ?first-name
   :surname ?last-name
   :make ?brand})

;; Result
({:firstname &quot;Jimi&quot;, :make &quot;Fender&quot;, :surname &quot;Hendrix&quot;}
 {:firstname &quot;Jimi&quot;, :make &quot;Fender&quot;, :surname &quot;Hendrix&quot;}
 {:firstname &quot;Jimi&quot;, :make &quot;Gibson&quot;, :surname &quot;Hendrix&quot;})

;; Result I would like to have. But how?
{:firstname &quot;Jimi&quot;
 :surname &quot;Hendrix&quot;
 :guitars
  [{:make &quot;Fender&quot;}
   {:make &quot;Fender&quot;}
   {:make &quot;Gibson&quot;}]}</pre>
</z><z id="t1582922191" t="Jimmy Miller You can use rewrite to do this. (m/rewrite data {:first-name ?first-name :last-name ?last-name :guitars [{:brand !brands} ...]} {:firstname ?first-name :surname ?last-name :guitars [{:make !brands} ...]}) "><y>#</y><d>2020-02-28</d><h>20:36</h><w>Jimmy Miller</w>You can use rewrite to do this.

<pre>(m/rewrite
  data
  {:first-name ?first-name
   :last-name ?last-name
   :guitars [{:brand !brands} ...]}
  {:firstname ?first-name
   :surname ?last-name
   :guitars [{:make !brands} ...]})</pre>
</z><z id="t1582922216" t="Jimmy Miller Search is going to give you back multiple possible results. If you just want one result match/rewrite is the thing you are looking for."><y>#</y><d>2020-02-28</d><h>20:36</h><w>Jimmy Miller</w>Search is going to give you back multiple possible results. If you just want one result match/rewrite is the thing you are looking for.</z><z id="t1582922286" t="noprompt I think the only difference between what I posted and deleted was the use of m/gather to grab the brands."><y>#</y><d>2020-02-28</d><h>20:38</h><w>noprompt</w>I think the only difference between what I posted and deleted was the use of <code>m/gather</code> to grab the brands.</z><z id="t1582922377" t="noprompt This is what I love about this though… converging on an otherwise identical solution quickly instead of figuring out what functional programming combo is better than another. 😂"><y>#</y><d>2020-02-28</d><h>20:39</h><w>noprompt</w>This is what I love about this though… converging on an otherwise identical solution quickly instead of figuring out what functional programming combo is better than another. <b>😂</b></z><z id="t1582922619" t="niclasnilsson Awesome, thanks [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] and [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] !"><y>#</y><d>2020-02-28</d><h>20:43</h><w>niclasnilsson</w>Awesome, thanks <a>@jimmy</a> and <a>@noprompt</a>!</z><z id="t1582922696" t="noprompt Any time!"><y>#</y><d>2020-02-28</d><h>20:44</h><w>noprompt</w>Any time!</z><z id="t1582924996" t="niclasnilsson A followup question, can the gathering be done in several “levels”? ;;; ;;; Map with lists with maps with lists. ;;; (def data {:first-name &quot;Jimi&quot; :last-name &quot;Hendrix&quot; :guitars [{:brand &quot;Fender&quot; :model &quot;Stratocaster&quot; :details [{:year 1963 :origin &quot;USA&quot;} {:year 1965 :origin &quot;Mexico&quot;}]} {:brand &quot;Gibson&quot; :model &quot;Les Paul Custom&quot; :details [{:year 1955 :origin &quot;USA&quot;}]}]}) (m/rewrite data {:first-name ?first-name :last-name ?last-name :guitars [{:brand !brands :model !models :details [{:year !years :origin !origin} ...]} ...]} {:firstname ?first-name :surname ?last-name :guitars [{:make !brands :model !models :manifactured [{:year !years :country !origin} ...]} ...]}) ;; What I get {:firstname &quot;Jimi&quot;, :surname &quot;Hendrix&quot; :guitars [{:make &quot;Fender&quot;, :model &quot;Stratocaster&quot;}], :manifactured [{:country &quot;USA&quot;, :year 1963} {:country &quot;Mexico&quot;, :year 1965} {:country &quot;USA&quot;, :year 1955}],} ;; What I&apos;m aiming for {:firstname &quot;Jimi&quot; :surname &quot;Hendrix&quot; :guitars [{:make &quot;Fender&quot; :model &quot;Stratocaster&quot; :manifactured [{:year 1963 :country &quot;USA&quot;} {:year 1965 :country &quot;Mexico&quot;}]} {:brand &quot;Gibson&quot; :model &quot;Les Paul Custom&quot; :manifactured [{:year 1955 :origin &quot;USA&quot;}]}]} "><y>#</y><d>2020-02-28</d><h>21:23</h><w>niclasnilsson</w>A followup question, can the gathering be done in several “levels”?

<pre>;;;
;;; Map with lists with maps with lists.
;;; 

(def data
  {:first-name &quot;Jimi&quot;
   :last-name &quot;Hendrix&quot;
   :guitars
    [{:brand &quot;Fender&quot;
      :model &quot;Stratocaster&quot;
      :details [{:year 1963 :origin &quot;USA&quot;}
                {:year 1965 :origin &quot;Mexico&quot;}]}
     {:brand &quot;Gibson&quot;
      :model &quot;Les Paul Custom&quot;
      :details [{:year  1955 :origin &quot;USA&quot;}]}]})

(m/rewrite
  data
  {:first-name ?first-name
   :last-name ?last-name
   :guitars [{:brand !brands 
              :model !models 
              :details
              [{:year !years
                :origin !origin} 
               ...]}
             ...]}

  {:firstname ?first-name
   :surname ?last-name
   :guitars [{:make !brands 
              :model !models 
              :manifactured
              [{:year !years
                :country !origin}
               ...]}
             ...]})


;; What I get

{:firstname &quot;Jimi&quot;,
 :surname &quot;Hendrix&quot;
 :guitars [{:make &quot;Fender&quot;,
            :model &quot;Stratocaster&quot;}],
            :manifactured [{:country &quot;USA&quot;, :year 1963}
                           {:country &quot;Mexico&quot;, :year 1965}
                           {:country &quot;USA&quot;, :year 1955}],}

;; What I&apos;m aiming for

{:firstname &quot;Jimi&quot;
 :surname &quot;Hendrix&quot;
 :guitars
  [{:make &quot;Fender&quot;
    :model &quot;Stratocaster&quot;
    :manifactured [{:year 1963 :country &quot;USA&quot;}
                   {:year 1965 :country &quot;Mexico&quot;}]}
   {:brand &quot;Gibson&quot;
    :model &quot;Les Paul Custom&quot;
    :manifactured [{:year  1955 :origin &quot;USA&quot;}]}]}</pre>
</z><z id="t1582926390" t="niclasnilsson I managed to solve it using (m/app). Is this the best/ideomatic way or is there a smarter/cleaner way? (def data {:first-name &quot;Jimi&quot; :last-name &quot;Hendrix&quot; :guitars [{:brand &quot;Fender&quot; :model &quot;Stratocaster&quot; :details [{:year 1963 :origin &quot;USA&quot;} {:year 1965 :origin &quot;Mexico&quot;}]} {:brand &quot;Gibson&quot; :model &quot;Les Paul Custom&quot; :details [{:year 1955 :origin &quot;USA&quot;}]}]}) (defn rewrite-guitar-details [guitar-details] (m/rewrite guitar-details {:year ?year :origin ?origin} {:year ?year :country ?origin})) (defn rewrite-guitar [guitar] (m/rewrite guitar {:brand ?brand :model ?model :details [!details ...]} {:brand ?brand :model ?model :details [(m/app rewrite-guitar-details !details) ...]})) (m/rewrite data {:first-name ?first-name :last-name ?last-name :guitars [!guitars ...]} {:firstname ?first-name :surname ?last-name :guitars [(m/app rewrite-guitar !guitars) ...]})"><y>#</y><d>2020-02-28</d><h>21:46</h><w>niclasnilsson</w>I managed to solve it using (m/app). Is this the best/ideomatic way or is there a smarter/cleaner way?

<pre>(def data
  {:first-name &quot;Jimi&quot;
   :last-name &quot;Hendrix&quot;
   :guitars
    [{:brand &quot;Fender&quot;
      :model &quot;Stratocaster&quot;
      :details [{:year 1963 :origin &quot;USA&quot;}
                {:year 1965 :origin &quot;Mexico&quot;}]}
     {:brand &quot;Gibson&quot;
      :model &quot;Les Paul Custom&quot;
      :details [{:year  1955 :origin &quot;USA&quot;}]}]})

(defn rewrite-guitar-details [guitar-details]
  (m/rewrite 
    guitar-details
    {:year ?year
     :origin ?origin}

    {:year ?year
     :country ?origin}))

(defn rewrite-guitar [guitar]
  (m/rewrite 
    guitar
    {:brand ?brand
     :model ?model
     :details [!details ...]}

    {:brand ?brand
     :model ?model
     :details [(m/app rewrite-guitar-details !details) ...]}))

(m/rewrite
  data
  {:first-name ?first-name
   :last-name ?last-name
   :guitars [!guitars ...]} 

  {:firstname ?first-name
   :surname ?last-name
   :guitars [(m/app rewrite-guitar !guitars) ...]})</pre></z><z id="t1582926824" t="Jimmy Miller (m/rewrite data {:first-name ?first-name :last-name ?last-name :guitars [{:brand !brands :model !models :details [{:year !years :origin !origin} ..!n]} ..!m]} {:firstname ?first-name :surname ?last-name :guitars [{:make !brands :model !models :manifactured [{:year !years :country !origin} ..!n]} ..!m]}) By default ... in substitution is going to put out all values. You can control how many it does by using ..!n or ..?n . https://cljdoc.org/d/meander/epsilon/0.0.397/doc/operator-overview#repeating-with-varxiables"><y>#</y><d>2020-02-28</d><h>21:53</h><w>Jimmy Miller</w><pre>(m/rewrite
  data
  {:first-name ?first-name
   :last-name ?last-name
   :guitars [{:brand !brands 
              :model !models 
              :details
              [{:year !years
                :origin !origin} 
               ..!n]}
             ..!m]}
  {:firstname ?first-name
   :surname ?last-name
   :guitars [{:make !brands 
              :model !models 
              :manifactured
              [{:year !years
                :country !origin}
               ..!n]}
             ..!m]})</pre>
By default <code>...</code> in substitution is going to put out all values. You can control how many it does by using <code>..!n</code> or <code>..?n</code>.

<a href="https://cljdoc.org/d/meander/epsilon/0.0.397/doc/operator-overview#repeating-with-varxiables" target="_blank">https://cljdoc.org/d/meander/epsilon/0.0.397/doc/operator-overview#repeating-with-varxiables</a></z><z id="t1582926842" t="Jimmy Miller [:attrs {:href &quot;/_/_/users/U48DE3SHM&quot;}]"><y>#</y><d>2020-02-28</d><h>21:54</h><w>Jimmy Miller</w><a>@niclasnilsson</a></z><z id="t1582926911" t="Jimmy Miller (also you have a typo with manifactured)"><y>#</y><d>2020-02-28</d><h>21:55</h><w>Jimmy Miller</w>(also you have a typo with manifactured)</z><z id="t1582927039" t="niclasnilsson Great, will try that! Thanks again [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] !"><y>#</y><d>2020-02-28</d><h>21:57</h><w>niclasnilsson</w>Great, will try that! Thanks again <a>@jimmy</a>!</z><z id="t1582927131" t="niclasnilsson And it works!"><y>#</y><d>2020-02-28</d><h>21:58</h><w>niclasnilsson</w>And it works!</z><z id="t1582927134" t="niclasnilsson Meander is freaking awesome!"><y>#</y><d>2020-02-28</d><h>21:58</h><w>niclasnilsson</w>Meander is freaking awesome!</z><z id="t1582998752" t="timothypratley (m/and ?parameters (m/let [?required-parameters (get-required-params ?parameters) ?optional-parameters (get-optional-params ?parameters)])) ^^ is this the “right” way to introduce bindings? seems a bit weird using m/and + I’m never sure exactly where to “put” the let"><y>#</y><d>2020-02-29</d><h>17:52</h><w>timothypratley</w><pre>(m/and ?parameters (m/let [?required-parameters (get-required-params ?parameters)
                           ?optional-parameters (get-optional-params ?parameters)]))</pre>
^^ is this the “right” way to introduce bindings? seems a bit weird using <code>m/and</code> + I’m never sure exactly where to “put” the <code>let</code></z><z id="t1582999352" t="timothypratley Oh this is pretty sick: {:parameters [(m/or {:required true :as !required-parameters} {:as !optional-parameters}) ... :as ?parameters]}"><y>#</y><d>2020-02-29</d><h>18:02</h><r>timothypratley</r>Oh this is pretty sick:
<pre>{:parameters [(m/or {:required true :as !required-parameters}
                                   {:as !optional-parameters}) ...
                             :as ?parameters]}</pre></z><z id="t1582999460" t="timothypratley Seems like there is often a way to avoid using let bindings altogether."><y>#</y><d>2020-02-29</d><h>18:04</h><r>timothypratley</r>Seems like there is often a way to avoid using let bindings altogether.</z><z id="t1583003282" t="Jimmy Miller To answer the first question. That is a pretty common idiom we’ve used for introducing bindings. It does feel a little weird. Many times the let body is just empty. Maybe we should think of a better syntax for that."><y>#</y><d>2020-02-29</d><h>19:08</h><r>Jimmy Miller</r>To answer the first question. That is a pretty common idiom we’ve used for introducing bindings. It does feel a little weird. Many times the let body is just empty. Maybe we should think of a better syntax for that.</z><z id="t1583001441" t="timothypratley Hmmm something that occurred to me, and I’m sure you’ve already considered about error messages: Currently things like match can take multiple patterns, but I often use them with 1 pattern. In the 1 pattern case; it makes sense when meander encounters “FAIL” to return “FAIL”, what was expected, what was actually there, and where the fail occurred. In the general multiple pattern case that information should be discarded."><y>#</y><d>2020-02-29</d><h>18:37</h><w>timothypratley</w>Hmmm something that occurred to me, and I’m sure you’ve already considered about error messages:
Currently things like <code>match</code> can take multiple patterns, but I often use them with 1 pattern.
In the 1 pattern case; it makes sense when meander encounters “FAIL” to return “FAIL”, what was expected, what was actually there, and where the fail occurred.
In the general multiple pattern case that information should be discarded.</z><z id="t1583003367" t="Jimmy Miller Yeah, I definitely want there to be better error messages. Sometimes it can get tricky with the optimizations we do to surface good information there. But we can definitely easily do better than what we currently do."><y>#</y><d>2020-02-29</d><h>19:09</h><w>Jimmy Miller</w>Yeah, I definitely want there to be better error messages. Sometimes it can get tricky with the optimizations we do to surface good information there. But we can definitely easily do better than what we currently do.</z><z id="t1583005964" t="timothypratley 🤯 wow strategies compose great with m/app even for multi-arg scenarios if you pass vectors: (def extract-resources (s/rewrite (m/with [%resource {:methods {&amp; (m/seqable [_ !methods] ...)} :resources {&amp; (m/seqable [_ %resource] ...)}}] [?baseUrl {&amp; (m/seqable [_ %resource] ...)}]) ;;=&gt; [(m/app extract-method&apos; [?baseUrl !methods]) ...])) (def build-methods&apos; (s/rewrite {:baseUrl ?baseUrl :resources {&amp; (m/seqable [!resource-names !resources] ...)} :name ?name :version ?version} ;;=&gt; [[!resource-names (m/app extract-resources [?baseUrl !resources])] ...])) ^^ no lambdas required o_O 🙂"><y>#</y><d>2020-02-29</d><h>19:52</h><w>timothypratley</w><b>🤯</b> wow <code>strategies</code> compose great with <code>m/app</code> even for multi-arg scenarios if you pass vectors:
<pre>(def extract-resources
  (s/rewrite
    (m/with [%resource {:methods {&amp; (m/seqable [_ !methods] ...)}
                        :resources {&amp; (m/seqable [_ %resource] ...)}}]
            [?baseUrl {&amp; (m/seqable [_ %resource] ...)}])
    ;;=&gt;
    [(m/app extract-method&apos; [?baseUrl !methods]) ...]))

(def build-methods&apos;
  (s/rewrite
    {:baseUrl ?baseUrl
     :resources {&amp; (m/seqable [!resource-names !resources] ...)}
     :name ?name
     :version ?version}
    ;;=&gt;
    [[!resource-names (m/app extract-resources [?baseUrl !resources])] ...]))</pre>
^^ no lambdas required o_O <b>🙂</b></z><z id="t1583008321" t="aisamu From the cookbook: (m/match {1 2 3 4 5 6} {&amp; (m/seqable [!ks !vs] ...)} [!ks !vs]) ;; =&gt; [[1 3 5] [2 4 6]] ;; But if we remove the map from the pattern, it returns the same: (m/match {1 2 3 4 5 6} (m/seqable [!ks !vs] ...) [!ks !vs]) ;; =&gt; [[1 3 5] [2 4 6]] Is that expected?"><y>#</y><d>2020-02-29</d><h>20:32</h><w>aisamu</w>From the cookbook:
<pre>(m/match {1 2 3 4 5 6}
  {&amp; (m/seqable [!ks !vs] ...)}
  [!ks !vs])
;; =&gt; [[1 3 5] [2 4 6]]

;; But if we remove the map from the pattern, it returns the same: 
(m/match {1 2 3 4 5 6}
  (m/seqable [!ks !vs] ...)
  [!ks !vs])
;; =&gt; [[1 3 5] [2 4 6]]</pre>
Is that expected?</z><z id="t1583008553" t="Jimmy Miller Yeah in that example the map wouldn&apos;t make any difference whatsoever. Maps are seqable afterall."><y>#</y><d>2020-02-29</d><h>20:35</h><w>Jimmy Miller</w>Yeah in that example the map wouldn&apos;t make any difference whatsoever. Maps are seqable afterall.</z><z id="t1583008594" t="Jimmy Miller Well technically not true"><y>#</y><d>2020-02-29</d><h>20:36</h><w>Jimmy Miller</w>Well technically not true</z><z id="t1583008608" t="Jimmy Miller If you passed the first one something that was not a map it would fail."><y>#</y><d>2020-02-29</d><h>20:36</h><w>Jimmy Miller</w>If you passed the first one something that was not a map it would fail.</z><z id="t1583008634" t="Jimmy Miller The second one will match on any seqable."><y>#</y><d>2020-02-29</d><h>20:37</h><w>Jimmy Miller</w>The second one will match on any seqable.</z><z id="t1583010369" t="aisamu I can&apos;t seem to explain the behaviour of the third case: ;; &quot;Please match everything&quot; - works as expected (m/rewrite [1 2 1 3 1 4] [!xs ...] [!xs ...]) ;; =&gt; [1 2 1 3 1 4] ;; &quot;Please don&apos;t match 1&apos;s&quot; - works as expected (m/rewrite [1 2 1 3 1 4] [(m/or 1 !xs) ...] [!xs ...]) ;; =&gt; [2 3 4] ;; &quot;Please don&apos;t match 1&apos;s nor 3&apos;s&quot; - ??? (m/rewrite [1 2 1 3 1 4] [(m/or 1 3 !xs) ...] [!xs ...]) ;; =&gt; [1 1 3 1] m/or is suddenly its inverse! What am I missing?"><y>#</y><d>2020-02-29</d><h>21:06</h><w>aisamu</w>I can&apos;t seem to explain the behaviour of the third case:
<pre>;; &quot;Please match everything&quot; - works as expected
(m/rewrite [1 2 1 3 1 4]
  [!xs ...]
  [!xs ...])
;; =&gt; [1 2 1 3 1 4]

;; &quot;Please don&apos;t match 1&apos;s&quot; - works as expected
(m/rewrite [1 2 1 3 1 4]
  [(m/or 1 !xs) ...]
  [!xs ...])
;; =&gt; [2 3 4]

;; &quot;Please don&apos;t match 1&apos;s nor 3&apos;s&quot; - ???
(m/rewrite [1 2 1 3 1 4]
  [(m/or 1 3 !xs) ...]
  [!xs ...])
;; =&gt; [1 1 3 1]</pre>
<code>m/or</code> is suddenly its inverse!
What am I missing?</z><z id="t1583018505" t="Jimmy Miller I&apos;m surprised by this. I will look into it tonight if someone else doesn&apos;t first."><y>#</y><d>2020-02-29</d><h>23:21</h><r>Jimmy Miller</r>I&apos;m surprised by this. I will look into it tonight if someone else doesn&apos;t first.</z><z id="t1583039727" t="Jimmy Miller This is a bug not 100% sure the correct fix for this. But should have a fix tomorrow or monday."><y>#</y><d>2020-03-01</d><h>05:15</h><r>Jimmy Miller</r>This is a bug not 100% sure the correct fix for this. But should have a fix tomorrow or monday.</z><z id="t1583087778" t="aisamu Oh, thanks!"><y>#</y><d>2020-03-01</d><h>18:36</h><r>aisamu</r>Oh, thanks!</z><z id="t1583018299" t="nlessa Hi! Why !(m/rewrite [::a ::b] [!enums ...] ( !enums ...)) is OK and (m/rewrite [::a ::b] [!enums ...] #{ !enums ...}) is not? # has some special behaviour inside meander?"><y>#</y><d>2020-02-29</d><h>23:18</h><w>nlessa</w>Hi!
Why <code>!(m/rewrite [::a ::b]</code>
           <code>[!enums ...] ( !enums ...))</code> is OK and
<code>(m/rewrite [::a ::b]</code>
           <code>[!enums ...] #{ !enums ...})</code> is not?
# has some special behaviour inside meander?</z><z id="t1583018591" t="Jimmy Miller Sets aren&apos;t ordered collections so we can&apos;t make ... Work consistently. Can&apos;t think off the top of my head the right option there. On my phone will get back to you tonight."><y>#</y><d>2020-02-29</d><h>23:23</h><r>Jimmy Miller</r>Sets aren&apos;t ordered collections so we can&apos;t make ... Work consistently. Can&apos;t think off the top of my head the right option there. On my phone will get back to you tonight.</z><z id="t1583019081" t="nlessa Thanks, Jimmy!"><y>#</y><d>2020-02-29</d><h>23:31</h><r>nlessa</r>Thanks, Jimmy!</z><z id="t1583019435" t="timothypratley (m/rewrite [1 2 3 4 5 6] [!x ...] #{^&amp; (!x ...)}) ;;=&gt; #{1 4 6 3 2 5} "><y>#</y><d>2020-02-29</d><h>23:37</h><r>timothypratley</r><pre>(m/rewrite [1 2 3 4 5 6]
  [!x ...]
  #{^&amp; (!x ...)})
;;=&gt; #{1 4 6 3 2 5}</pre>
</z><z id="t1583019446" t="timothypratley You can use metadata trick"><y>#</y><d>2020-02-29</d><h>23:37</h><r>timothypratley</r>You can use metadata trick</z><z id="t1583019513" t="timothypratley (m/rewrite [::a ::b] [!enums ...] #{^&amp; (!enums ...)}) =&gt; #{:happy.beaver/a :happy.beaver/b} "><y>#</y><d>2020-02-29</d><h>23:38</h><r>timothypratley</r><pre>(m/rewrite [::a ::b]
  [!enums ...] #{^&amp; (!enums ...)})
=&gt; #{:happy.beaver/a :happy.beaver/b}</pre>
</z><z id="t1583019557" t="timothypratley Because metadata is on the set item 🙂"><y>#</y><d>2020-02-29</d><h>23:39</h><r>timothypratley</r>Because metadata is on the set item <b>🙂</b></z><z id="t1583024929" t="nlessa thanks Timothy! Nice trick!"><y>#</y><d>2020-03-01</d><h>01:08</h><r>nlessa</r>thanks Timothy! Nice trick!</z><z id="t1583019081" t="nlessa Thanks, Jimmy!"><y>#</y><d>2020-02-29</d><h>23:31</h><w>nlessa</w>Thanks, Jimmy!</z><z id="t1583028938" t="timothypratley (m/match {:a 1 :b 2} {:a !v &amp; (m/or {:b !v} {})} !v) ^^ is this the “right” way to do optional keys?"><y>#</y><d>2020-03-01</d><h>02:15</h><w>timothypratley</w><pre>(m/match
  {:a 1
   :b 2}
  {:a !v
   &amp; (m/or {:b !v}
           {})}
  !v)</pre>
^^ is this the “right” way to do optional keys?</z><z id="t1583029188" t="Jimmy Miller Any reason not to do just (m/or nil !v)?"><y>#</y><d>2020-03-01</d><h>02:19</h><r>Jimmy Miller</r>Any reason not to do just (m/or nil !v)?</z><z id="t1583033123" t="timothypratley I’m not following :thinking_face: I’m matching something like {:methods [1 2 3] :resources {:methods [4 5 6]}} where a resource has methods and optionally a sub resource with methods etc and am using this: (def extract-resource-methods (s/rewrite (m/with [%resource {:methods {&amp; (m/seqable [_ !methods] ...)} &amp; (m/or {:resources {&amp; (m/seqable [_ %resource] ...)}} {})}] [?baseUrl %resource]) ;;=&gt; [[?baseUrl !methods] ...])) to represent that :resources may or may not be present… it just seems a little wierd like I’m over complicating it."><y>#</y><d>2020-03-01</d><h>03:25</h><r>timothypratley</r>I’m not following <b>:thinking_face:</b>
I’m matching something like <code>{:methods [1 2 3] :resources {:methods [4 5 6]}}</code> where a resource has methods and optionally a sub resource with methods etc and am using this:
<pre>(def extract-resource-methods
  (s/rewrite
    (m/with [%resource {:methods {&amp; (m/seqable [_ !methods] ...)}
                        &amp; (m/or {:resources {&amp; (m/seqable [_ %resource] ...)}}
                                {})}]
      [?baseUrl %resource])
    ;;=&gt;
    [[?baseUrl !methods] ...]))</pre>
to represent that <code>:resources</code> may or may not be present… it just seems a little wierd like I’m over complicating it.</z><z id="t1583044400" t="timothypratley I guess more importantly I don’t see a way to do many optional keys"><y>#</y><d>2020-03-01</d><h>06:33</h><r>timothypratley</r>I guess more importantly I don’t see a way to do many optional keys</z><z id="t1583046679" t="timothypratley oh I think I see… (m/match {:a 1} {:a ?a :b ?b} [?a ?b]) =&gt; [1 nil] ^^ I didn’t realize that meander matches patterns even if not all keys are present hmmm. :thinking_face: I guess then everything is optional unless I do a pred or guard. 🙂"><y>#</y><d>2020-03-01</d><h>07:11</h><r>timothypratley</r>oh I think I see…
<pre>(m/match
  {:a 1}
  {:a ?a
   :b ?b}
  [?a ?b])
=&gt; [1 nil]</pre>
^^ I didn’t realize that meander matches patterns even if not all keys are present hmmm. <b>:thinking_face:</b> I guess then everything is optional unless I do a pred or guard. <b>🙂</b></z><z id="t1583073597" t="Jimmy Miller Yes everything is optional by default. my answer was assuming you just didn&apos;t want the nil to be in your memory variable. Technically it isn&apos;t just guard or pred. If you put a vector pattern for example that means you are asserting that there is some non nil vector there."><y>#</y><d>2020-03-01</d><h>14:39</h><r>Jimmy Miller</r>Yes everything is optional by default. my answer was assuming you just didn&apos;t want the nil to be in your memory variable. 

Technically it isn&apos;t just guard or pred. If you put a vector pattern for example that means you are asserting that there is some non nil vector there.</z><z id="t1583097012" t="noprompt [meander/epsilon &quot;0.0.401&quot;] • Fixes some issues with or pattern compilation • Fixes uses of transients in substitution code"><y>#</y><d>2020-03-01</d><h>21:10</h><w>noprompt</w><pre>[meander/epsilon &quot;0.0.401&quot;]</pre>
• Fixes some issues with <code>or</code> pattern compilation
• Fixes uses of transients in substitution code</z><z id="t1583097058" t="noprompt Thanks [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] , [:attrs {:href &quot;/_/_/users/U1UQEM078&quot;}] , [:attrs {:href &quot;/_/_/users/UCPS050BV&quot;}]"><y>#</y><d>2020-03-01</d><h>21:10</h><w>noprompt</w>Thanks <a>@jimmy</a>, <a>@aisamu</a>, <a>@qythium</a></z><z id="t1583102152" t="Jimmy Miller The or stuff didn&apos;t actually land in this release. But we will cut a new one soon with the or fix."><y>#</y><d>2020-03-01</d><h>22:35</h><w>Jimmy Miller</w>The or stuff didn&apos;t actually land in this release. But we will cut a new one soon with the or fix.</z><z id="t1583123485" t="noprompt [meander/epsilon &quot;0.0.402&quot;] "><y>#</y><d>2020-03-02</d><h>04:31</h><w>noprompt</w><pre>[meander/epsilon &quot;0.0.402&quot;]</pre>
</z><z id="t1583189004" t="aisamu Thanks!"><y>#</y><d>2020-03-02</d><h>22:43</h><r>aisamu</r>Thanks!</z><z id="t1583172076" t="grounded_sage So I have meandered on over to tech.ml.dataset for processing the columnwise data that is csv. Sorely missing the clarity of Meander patterns. "><y>#</y><d>2020-03-02</d><h>18:01</h><w>grounded_sage</w>So I have meandered on over to tech.ml.dataset for processing the columnwise data that is csv. Sorely missing the clarity of Meander patterns. </z><z id="t1583172247" t="noprompt I’m sorry. 🙂"><y>#</y><d>2020-03-02</d><h>18:04</h><w>noprompt</w>I’m sorry. <b>🙂</b></z><z id="t1583174006" t="grounded_sage As someone with a 10,000 foot view and little idea around internals. I’m wondering if there is a new ns there for Meander to handle large column data. Or like a Meander-csv that could leverage the codebase inside of tech.ml.dataset. "><y>#</y><d>2020-03-02</d><h>18:33</h><w>grounded_sage</w>As someone with a 10,000 foot view and little idea around internals. I’m wondering if there is a new ns there for Meander to handle large column data. Or like a Meander-csv that could leverage the codebase inside of tech.ml.dataset. </z><z id="t1583182187" t="noprompt I’m hoping that zeta will have the ground work for doing that being able to deal with bytes, etc. and then building more sophisticated matching on top."><y>#</y><d>2020-03-02</d><h>20:49</h><r>noprompt</r>I’m hoping that <code>zeta</code> will have the ground work for doing that being able to deal with bytes, etc. and then building more sophisticated matching on top.</z><z id="t1583187863" t="grounded_sage Cool. At present I’m dealing with two CSV’s. One with 1.5m rows and another with 300k. The dataset library handles it extremely well. It’s just a little more low level than I would like to be working at having seen how nice things can be :)"><y>#</y><d>2020-03-02</d><h>22:24</h><r>grounded_sage</r>Cool. At present I’m dealing with two CSV’s. One with 1.5m rows and another with 300k. The dataset library handles it extremely well. It’s just a little more low level than I would like to be working at having seen how nice things can be :)</z><z id="t1583191064" t="noprompt The goal (for me) is to be able to achieve low level performance but from the comfort of a high level. I believe we can get there via the right pattern matching primitives and pattern aliases (`defsyntax`). So, what I’m saying is, this case is motivating for me too. 🙂"><y>#</y><d>2020-03-02</d><h>23:17</h><r>noprompt</r>The goal (for me) is to be able to achieve low level performance but from the comfort of a high level. I believe we can get there via the right pattern matching primitives and pattern aliases (`defsyntax`). So, what I’m saying is, this case is motivating for me too. <b>🙂</b></z><z id="t1583249878" t="timothypratley Hi! Just so I can understand the desire here I’ll attempt to rephrase as: I wish meander sequence patterns like (!xs ...) used transducers instead of memory variables. ^^ is this accurate? i.e.: The issue is that very long sequences don’t fit in memory? Or is it a different problem?"><y>#</y><d>2020-03-03</d><h>15:37</h><r>timothypratley</r>Hi! Just so I can understand the desire here I’ll attempt to rephrase as:
<pre>I wish meander sequence patterns like (!xs ...) used transducers instead of memory variables.</pre>
^^ is this accurate?
i.e.: The issue is that very long sequences don’t fit in memory? Or is it a different problem?</z><z id="t1583250596" t="timothypratley (defn unarchived&apos; [stories] (remove (fn [{:keys [archived completed]}] (and archived (not completed))) stories)) (def unarchived (s/rewrite ((m/or {:archived true :completed false} !stories) ...) ;;&gt; (!stories ...))) ^^ for a really big CSV !stories needs to be a sequence, not an array. Conversely when do we need an array not a sequence?"><y>#</y><d>2020-03-03</d><h>15:49</h><r>timothypratley</r><pre>(defn unarchived&apos; [stories]
  (remove (fn [{:keys [archived completed]}]
            (and archived (not completed)))
          stories))

(def unarchived
  (s/rewrite
    ((m/or {:archived  true
            :completed false}
           !stories) ...)
    ;;&gt;
    (!stories ...)))</pre>
^^ for a really big CSV <code>!stories</code> needs to be a sequence, not an array.
Conversely when do we need an array not a sequence?</z><z id="t1583254535" t="grounded_sage I’m still new to all of this so having some trouble keeping up. Though I am willing to dive in and contribute to this problem with a bit of guidance :)"><y>#</y><d>2020-03-03</d><h>16:55</h><r>grounded_sage</r>I’m still new to all of this so having some trouble keeping up. Though I am willing to dive in and contribute to this problem with a bit of guidance :)</z><z id="t1583270038" t="noprompt (keep (fn [value] (me/rewrite value {:archived false, :completed true :as ?it} ?it)) &apos;({:archived true, :completed true} {:archived false, :completed true} {:archived true, :completed false} {:archived false, :completed false})) ;; =&gt; ({:archived false, :completed true}) would be decent."><y>#</y><d>2020-03-03</d><h>21:13</h><r>noprompt</r><pre>(keep
 (fn [value]
   (me/rewrite value
     {:archived false, :completed true :as ?it}
     ?it))
 &apos;({:archived true, :completed true}
   {:archived false, :completed true}
   {:archived true, :completed false}
   {:archived false, :completed false}))
;; =&gt; 
({:archived false, :completed true})</pre>
would be decent.</z><z id="t1583270179" t="noprompt This also works (me/rewrites &apos;({:archived true, :completed true} {:archived false, :completed true} {:archived true, :completed false} {:archived false, :completed false}) (me/scan {:archived false, :completed true :as ?it}) ?it) ;; =&gt; ({:archived false, :completed true}) but rewrites doesn’t support cata FYI."><y>#</y><d>2020-03-03</d><h>21:16</h><r>noprompt</r>This also works
<pre>(me/rewrites &apos;({:archived true, :completed true}
               {:archived false, :completed true}
               {:archived true, :completed false}
               {:archived false, :completed false})
  (me/scan {:archived false, :completed true :as ?it})
  ?it)
;; =&gt; 
({:archived false, :completed true})</pre>
but <code>rewrites</code> doesn’t support <code>cata</code> FYI.</z><z id="t1583272996" t="timothypratley oh good thinking."><y>#</y><d>2020-03-03</d><h>22:03</h><r>timothypratley</r>oh good thinking.</z><z id="t1583273011" t="timothypratley Does that help with the original question of “Meander to handle large column data”?"><y>#</y><d>2020-03-03</d><h>22:03</h><r>timothypratley</r>Does that help with the original question of “Meander to handle large column data”?</z><z id="t1583273699" t="noprompt It can. It just depends on what you are using. If you use a single … in a pattern, Meander has to apply pattern matching to everything in the collection in question. If you can rephrase the pattern in such a way that search becomes applicable its nice to go that way."><y>#</y><d>2020-03-03</d><h>22:14</h><r>noprompt</r>It can. It just depends on what you are using. If you use a single <code>…</code> in a pattern, Meander has to apply pattern matching to everything in the collection in question. If you can rephrase the pattern in such a way that <code>search</code> becomes applicable its nice to go that way.</z><z id="t1583318354" t="grounded_sage Yea all of the interesting transformations and where meander has value for me is when I use …"><y>#</y><d>2020-03-04</d><h>10:39</h><r>grounded_sage</r>Yea all of the interesting transformations and where meander has value for me is when I use <code>…</code></z><z id="t1583325712" t="grounded_sage Still have problems around joining the large datasets. Put the first transformation step side by side and meander simply blows the other option away."><y>#</y><d>2020-03-04</d><h>12:41</h><w>grounded_sage</w>Still have problems around joining the large datasets. Put the first transformation step side by side and meander simply blows the other option away.</z><z id="t1583386525" t="timothypratley Anything you can share as an example? Sounds interesting 🙂"><y>#</y><d>2020-03-05</d><h>05:35</h><r>timothypratley</r>Anything you can share as an example? Sounds interesting <b>🙂</b></z><z id="t1583405230" t="grounded_sage There is a slight error in the dataset one as I typed it out purely to see what the difference was side by side."><y>#</y><d>2020-03-05</d><h>10:47</h><r>grounded_sage</r>There is a slight error in the dataset one as I typed it out purely to see what the difference was side by side.</z><z id="t1583405305" t="grounded_sage With respect to code size, clarity and ability to change Meander is definitely my choice."><y>#</y><d>2020-03-05</d><h>10:48</h><r>grounded_sage</r>With respect to code size, clarity and ability to change Meander is definitely my choice.</z><z id="t1583421234" t="Jimmy Miller If you ever want to pair on joining up some datasets I&apos;d be happy to do that. Even if you can&apos;t share your stuff. I&apos;m sure we could make some mock data and try things out."><y>#</y><d>2020-03-05</d><h>15:13</h><r>Jimmy Miller</r>If you ever want to pair on joining up some datasets I&apos;d be happy to do that. Even if you can&apos;t share your stuff. I&apos;m sure we could make some mock data and try things out.</z><z id="t1583869862" t="grounded_sage Really appreciate it [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] . At the moment I am in datahike land as the datasets are too large to be done in memory with Meander. I also broke Tech.ml.dataset haha"><y>#</y><d>2020-03-10</d><h>19:51</h><r>grounded_sage</r>Really appreciate it <a>@U5K8NTHEZ</a>. At the moment I am in datahike land as the datasets are too large to be done in memory with Meander. I also broke Tech.ml.dataset haha</z><z id="t1583869900" t="grounded_sage Though they are arguably still moderate in size. &lt;500mb for the largest."><y>#</y><d>2020-03-10</d><h>19:51</h><r>grounded_sage</r>Though they are arguably still moderate in size. &lt;500mb for the largest.</z><z id="t1583885649" t="timothypratley Hmmm FWIW it looks like the code on the right just needs to be changed slightly… IMO you should be doing something like: (for [x (aws/get-data)] (m/match x ~~~~ ~~~~~))"><y>#</y><d>2020-03-11</d><h>00:14</h><r>timothypratley</r>Hmmm FWIW it looks like the code on the right just needs to be changed slightly… IMO you should be doing something like:
<pre>(for [x (aws/get-data)]
  (m/match x ~~~~ ~~~~~))</pre></z><z id="t1583885793" t="timothypratley search is intended for finding multiple logical matches (not sequential processing) I think! 🙂"><y>#</y><d>2020-03-11</d><h>00:16</h><r>timothypratley</r><code>search</code> is intended for finding multiple logical matches (not sequential processing) I think! <b>🙂</b></z><z id="t1583915285" t="grounded_sage I’ve had search fail on me for some reason when I am doing a simple match. I think it might be due to m/pred or m/app. I’ll revisit at some point for now I just flatten the results"><y>#</y><d>2020-03-11</d><h>08:28</h><r>grounded_sage</r>I’ve had search fail on me for some reason when I am doing a simple match. I think it might be due to m/pred or m/app. I’ll revisit at some point for now I just flatten the results</z><z id="t1583386387" t="timothypratley ((s/rewrite (m/with [%resource {:methods (m/seqable [_ !methods] ...) :resources (m/seqable [_ %resource] ...)}] %resource) ;;&gt; ~!methods) {:methods {:c &quot;z&quot;} :resources {:methods {:a &quot;method1&quot;} :resources {:methods {:b &quot;method2&quot;}}}}) =&gt; [&quot;z&quot; &quot;method2&quot;]"><y>#</y><d>2020-03-05</d><h>05:33</h><w>timothypratley</w><pre>((s/rewrite
   (m/with [%resource {:methods   (m/seqable [_ !methods] ...)
                       :resources (m/seqable [_ %resource] ...)}]
     %resource)
   ;;&gt;
   ~!methods)
 {:methods {:c &quot;z&quot;}
  :resources {:methods {:a &quot;method1&quot;}
              :resources {:methods {:b &quot;method2&quot;}}}})</pre>
<code>=&gt; [&quot;z&quot; &quot;method2&quot;]</code></z><z id="t1583386397" t="timothypratley doesn’t seem quite right?"><y>#</y><d>2020-03-05</d><h>05:33</h><r>timothypratley</r>doesn’t seem quite right?</z><z id="t1583386443" t="timothypratley I expected “method1” to get collected."><y>#</y><d>2020-03-05</d><h>05:34</h><r>timothypratley</r>I expected “method1” to get collected.</z><z id="t1583394353" t="timothypratley (m/rewrite {:m {1 2} :r {:m {3 4} :r {:m {5 6} :r {:m {7 8} :r {:m {9 10}}}}}} (m/with [%r {:m !m :r (m/seqable [_ %r] ...)}] %r) ;;&gt; ~!m) =&gt; [{1 2} nil {5 6} nil {9 10}]"><y>#</y><d>2020-03-05</d><h>07:45</h><r>timothypratley</r><pre>(m/rewrite
  {:m {1 2}
   :r {:m {3 4}
       :r {:m {5 6}
           :r {:m {7 8}
               :r {:m {9 10}}}}}}
  (m/with [%r {:m   !m
               :r (m/seqable [_ %r] ...)}]
    %r)
  ;;&gt;
  ~!m)
=&gt; [{1 2} nil {5 6} nil {9 10}]</pre></z><z id="t1583394423" t="timothypratley what in the world?"><y>#</y><d>2020-03-05</d><h>07:47</h><r>timothypratley</r>what in the world?</z><z id="t1583420458" t="Jimmy Miller I left a comment on the issue you made. https://github.com/noprompt/meander/issues/115#issuecomment-595273451"><y>#</y><d>2020-03-05</d><h>15:00</h><r>Jimmy Miller</r>I left a comment on the issue you made.<a href="https://github.com/noprompt/meander/issues/115#issuecomment-595273451" target="_blank">https://github.com/noprompt/meander/issues/115#issuecomment-595273451</a></z><z id="t1583436255" t="timothypratley Thank you 🙂 facepalm Hahaha I can’t believe I messed that up but thanks for setting me right 🙂"><y>#</y><d>2020-03-05</d><h>19:24</h><r>timothypratley</r>Thank you <b>🙂</b> <b>facepalm</b> Hahaha I can’t believe I messed that up but thanks for setting me right <b>🙂</b></z><z id="t1583405102" t="grounded_sage (r/pipe !begin-time (format-time &quot;hhmm&quot;)) I just tried this but it doesn’t seem to work. (m/app (format-time &quot;hhmm&quot;) !begin-time) This is what I have at the moment. Using a HOF"><y>#</y><d>2020-03-05</d><h>10:45</h><w>grounded_sage</w><code>(r/pipe !begin-time (format-time &quot;hhmm&quot;))</code> I just tried this but it doesn’t seem to work.
<code>(m/app (format-time &quot;hhmm&quot;) !begin-time)</code> This is what I have at the moment. Using a HOF</z><z id="t1583421164" t="Jimmy Miller pipe doesn&apos;t do what you are thinking it does here. app would I think be the right answer."><y>#</y><d>2020-03-05</d><h>15:12</h><r>Jimmy Miller</r><code>pipe</code> doesn&apos;t do what you are thinking it does here. <code>app</code> would I think be the right answer.</z><z id="t1583465664" t="timothypratley Any suggestions meander for test expression matching? (is (m/match x (a b c) true _ nil)) works but is a bit unsatisfying because if it doesn’t match doesn’t print out x"><y>#</y><d>2020-03-06</d><h>03:34</h><w>timothypratley</w>Any suggestions meander for test expression matching?
<code>(is (m/match x (a b c) true _ nil))</code> works but is a bit unsatisfying because if it doesn’t match doesn’t print out x</z><z id="t1583465743" t="timothypratley Inverting to (is (not (m/match method (a b c) false _ method))))) Gives a better error message, but has double negative output which is a bit confusing )"><y>#</y><d>2020-03-06</d><h>03:35</h><r>timothypratley</r>Inverting to
<pre>(is (not (m/match method (a b c) false _ method)))))</pre>
Gives a better error message, but has double negative output which is a bit confusing )</z><z id="t1583466012" t="timothypratley (is (= :match (m/match method (a b c) :match _ method))) ^^ this isn’t bad 🙂"><y>#</y><d>2020-03-06</d><h>03:40</h><r>timothypratley</r><pre>(is (= :match (m/match method (a b c) :match _ method)))</pre>
^^ this isn’t bad <b>🙂</b></z><z id="t1583466585" t="timothypratley (defmacro is-match? [x pattern] `(is (= (m/match ~x ~pattern :match ~&apos;_else ~x) :match))) o_O"><y>#</y><d>2020-03-06</d><h>03:49</h><r>timothypratley</r><pre>(defmacro is-match? [x pattern]
  `(is (= (m/match ~x ~pattern :match ~&apos;_else ~x) :match)))</pre>
o_O</z><z id="t1583466601" t="timothypratley (is-match? method (a b c)) "><y>#</y><d>2020-03-06</d><h>03:50</h><r>timothypratley</r><pre>(is-match? method (a b c))</pre>
</z><z id="t1583466899" t="timothypratley (is-match? method (defn (m/pred symbol? ?fn-name) (m/pred string? ?doc-string) &amp; _)) "><y>#</y><d>2020-03-06</d><h>03:54</h><r>timothypratley</r><pre>(is-match? method (defn (m/pred symbol? ?fn-name) (m/pred string? ?doc-string) &amp; _))</pre>
</z><z id="t1583467086" t="noprompt [:attrs {:href &quot;/_/_/users/U06S1EJPL&quot;}] Shared a cool idea: https://github.com/noprompt/meander/issues/116 I’d be interested in hearing what others think."><y>#</y><d>2020-03-06</d><h>03:58</h><w>noprompt</w><a>@timothypratley</a> Shared a cool idea: <a href="https://github.com/noprompt/meander/issues/116" target="_blank">https://github.com/noprompt/meander/issues/116</a>

I’d be interested in hearing what others think.</z><z id="t1583474029" t="timothypratley https://github.com/timothypratley/happygapi/blob/master/dev/happy/beaver.clj &lt;-- some heavy meandering going on in here 😉"><y>#</y><d>2020-03-06</d><h>05:53</h><w>timothypratley</w><a href="https://github.com/timothypratley/happygapi/blob/master/dev/happy/beaver.clj" target="_blank">https://github.com/timothypratley/happygapi/blob/master/dev/happy/beaver.clj</a> &lt;-- some heavy meandering going on in here <b>😉</b></z><z id="t1583475218" t="noprompt I love that I can actually read most of this code and see whats going without actually knowing what its purpose is. 🙂"><y>#</y><d>2020-03-06</d><h>06:13</h><r>noprompt</r>I love that I can actually read most of this code and see whats going without actually knowing what its purpose is. <b>🙂</b></z><z id="t1583475295" t="noprompt Also, I think you’ll be really happy to know that in zeta you’ll be able to pattern matching and substitute strings too so you won’t need to do ~(str ,,,) ."><y>#</y><d>2020-03-06</d><h>06:14</h><r>noprompt</r>Also, I think you’ll be really happy to know that in <code>zeta</code> you’ll be able to pattern matching and substitute strings too so you won’t need to do <code>~(str ,,,)</code>.</z><z id="t1583475412" t="noprompt Oh and you’ll be able to m/let on the RHS. 🙂"><y>#</y><d>2020-03-06</d><h>06:16</h><r>noprompt</r>Oh and you’ll be able to <code>m/let</code> on the RHS. <b>🙂</b></z><z id="t1583512450" t="timothypratley oooo nice 🙂"><y>#</y><d>2020-03-06</d><h>16:34</h><r>timothypratley</r>oooo nice <b>🙂</b></z><z id="t1583837942" t="jeremys Hey! I am struggling to express a pattern. For instance we could have 1 even number followed by 0 or more odd numbers, this pattern repeating in a sequence like in [2 3 5 4 3 2] . The goal would be to get in this example something like [[2 [3 5]] [4 [3]] [2[]]] Any ideas ?"><y>#</y><d>2020-03-10</d><h>10:59</h><w>jeremys</w>Hey! I am struggling to express a pattern. For instance we could have 1 even number followed by 0 or more odd numbers, this pattern repeating in a sequence like in <code>[2 3 5 4 3 2]</code>. The goal would be to get  in this example something like <code>[[2 [3 5]] [4 [3]] [2[]]]</code> Any ideas ?</z><z id="t1583875724" t="noprompt There is a partial solution to this problem but, actually, what we really need to do this properly is a greedy version of … (basically Kleene star which … is not that). I would use vanilla Clojure for this in the interim."><y>#</y><d>2020-03-10</d><h>21:28</h><r>noprompt</r>There is a partial solution to this problem but, actually, what we really need to do this properly is a greedy version of <code>…</code> (basically Kleene star which <code>…</code> is not that). I would use vanilla Clojure for this in the interim.</z><z id="t1583878247" t="jeremys Ok thanks, I gathered the pattern It has a regex feel to it, it might be expressed by (ab*)* . I had a partial solution that identify the first pattern, something like (-&gt; [2 3 5 4 5 3 6] (m/search (m/seqable (m/pred even? ?e) . (m/pred odd? !os) ... &amp; (m/and ?rest (m/or (m/seqable) (m/seqable (m/pred even?) . (m/pred (constantly true)) ...)))) {:e ?e :os !os :rest ?rest})) wondering if I could have use some catamorphism magic on ?rest but I am not used to meander yet and some operator are a little mind bending at first. Plus my solution feels a bit cumbersome compared to the regex. Now I know I can’t really express it. Thanks a lot!"><y>#</y><d>2020-03-10</d><h>22:10</h><r>jeremys</r>Ok thanks, I gathered the pattern It has a regex feel to it, it might be expressed by <code>(ab*)*</code>. I had a partial solution that identify the first pattern, something like
<pre>(-&gt; [2 3 5 4 5 3 6]
    (m/search
      (m/seqable (m/pred even? ?e) .
                 (m/pred odd? !os) ...
                 &amp; (m/and ?rest
                          (m/or
                            (m/seqable)
                            (m/seqable (m/pred even?) .
                                       (m/pred (constantly true)) ...))))
      {:e ?e
       :os !os
       :rest ?rest}))</pre>
wondering if I could have use some catamorphism magic on ?rest but I am not used to meander yet and some operator are a little mind bending at first. Plus my solution feels a bit cumbersome compared to the regex. Now I know I can’t really express it. Thanks a lot!</z><z id="t1583881965" t="noprompt So the partial solution uses rewrite and cata but due to not having a greedy star or grouping it, and the way rewrite works presently I can’t, in honesty, recommend it. (m/rewrite [2 3 5 4 3 2] [] [] [(m/pred even? ?even) . (m/pred odd? !odds) ..!ns &amp; ?rest] [[?even [!odds ...]] &amp; (m/cata ?rest)]) ;; =&gt; [[2 [3 5]] [4 [3]] [2 []]] (It could use seqable here.) The zeta branch will have both grouping and greedy star. I think I can bring greedy star to epsilon but I’m not sure about grouping."><y>#</y><d>2020-03-10</d><h>23:12</h><r>noprompt</r>So the partial solution uses <code>rewrite</code> and <code>cata</code> but due to not having a greedy star or grouping it, and the way <code>rewrite</code> works presently I can’t, in honesty, recommend it.
<pre>(m/rewrite [2 3 5 4 3 2]
  [] []
  [(m/pred even? ?even) . (m/pred odd? !odds) ..!ns &amp; ?rest]
  [[?even [!odds ...]] &amp; (m/cata ?rest)])
;; =&gt; 
[[2 [3 5]] [4 [3]] [2 []]]</pre>
(It could use <code>seqable</code> here.)

The <code>zeta</code> branch will have both grouping and greedy star. I think I can bring greedy star to <code>epsilon</code> but I’m not sure about grouping.</z><z id="t1583882092" t="noprompt FWIW, I’m spending time working on zeta and less time on epsilon because its easier to build a better, less buggy implementation that reflects the breadth and depth of knowledge that I acquired while working on epsilon . In the spirit of transparency, I’m learning 🙂"><y>#</y><d>2020-03-10</d><h>23:14</h><r>noprompt</r>FWIW, I’m spending time working on <code>zeta</code> and less time on <code>epsilon</code> because its easier to build a better, less buggy implementation that reflects the breadth and depth of knowledge that I acquired while working on <code>epsilon</code>. In the spirit of transparency, I’m learning <b>🙂</b></z><z id="t1583882140" t="timothypratley True story I made this before seeing your cata: (m/rewrite [2 3 5 4 3 2] (m/with [%p (m/or [(m/pred even? !x) . (m/pred odd? !y) ..!n &amp; %p] [])] %p) [[!x [!y ..!n]] ...]) "><y>#</y><d>2020-03-10</d><h>23:15</h><r>timothypratley</r>True story I made this before seeing your cata:
<pre>(m/rewrite [2 3 5 4 3 2]
  (m/with [%p (m/or [(m/pred even? !x) . (m/pred odd? !y) ..!n &amp; %p]
                    [])]
    %p)
  [[!x [!y ..!n]] ...])</pre>
</z><z id="t1583882274" t="timothypratley oh damn, my verison drops the last thing though =&gt; [[2 [3 5]] [4 [3]]]"><y>#</y><d>2020-03-10</d><h>23:17</h><r>timothypratley</r>oh damn, my verison drops the last thing though
<code>=&gt; [[2 [3 5]] [4 [3]]]</code></z><z id="t1583882683" t="timothypratley [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] when you say “I can’t recommend it” about your m/cata solution…. why not? seems good to me???"><y>#</y><d>2020-03-10</d><h>23:24</h><r>timothypratley</r><a>@U06MDAPTP</a> when you say “I can’t recommend it” about your <code>m/cata</code> solution…. why not? seems good to me???</z><z id="t1583882929" t="timothypratley Is it that “greedy Kleene” would be more efficient? concise? (Maybe I should just wait and see 🙂 )"><y>#</y><d>2020-03-10</d><h>23:28</h><r>timothypratley</r>Is it that “greedy Kleene” would be more efficient? concise? (Maybe I should just wait and see <b>🙂</b>)</z><z id="t1583883317" t="noprompt [:attrs {:href &quot;/_/_/users/U06S1EJPL&quot;}] … is not greedy. You can think of … as a gradient from the least to most amount of greed with respect to context. So its really designed for ambiguity when two or more … patterns are next to each other."><y>#</y><d>2020-03-10</d><h>23:35</h><r>noprompt</r><a>@U06S1EJPL</a> <code>…</code> is not greedy. You can think of <code>…</code> as a gradient from the least to most amount of greed with respect to context. So its really designed for ambiguity when two or more <code>…</code> patterns are next to each other.</z><z id="t1583883371" t="noprompt Greed is really about how much to consume and not so much about efficiency or concision."><y>#</y><d>2020-03-10</d><h>23:36</h><r>noprompt</r>Greed is really about how much to consume and not so much about efficiency or concision.</z><z id="t1583883436" t="noprompt For example ;; Using infix * to demo [!xs * !ys ...] ;; or [!xs * !ys *] should always starve !ys by consuming everything because the semantics of * are greedy."><y>#</y><d>2020-03-10</d><h>23:37</h><r>noprompt</r>For example
<pre>;; Using infix * to demo
[!xs * !ys ...]
;; or
[!xs * !ys *]</pre>
should always starve <code>!ys</code> by consuming everything because the semantics of <code>*</code> are greedy.</z><z id="t1583883504" t="noprompt The same would apply to + by comparison to ..1 . These are not expressing the same idea, at least to my mind they aren’t."><y>#</y><d>2020-03-10</d><h>23:38</h><r>noprompt</r>The same would apply to <code>+</code> by comparison to <code>..1</code> . These are not expressing the same idea, at least to my mind they aren’t.</z><z id="t1583883605" t="noprompt * /`+` are for when you don’t want ambiguity while … /`..N` would be."><y>#</y><d>2020-03-10</d><h>23:40</h><r>noprompt</r><code>*</code>/`+` are for when you don’t want ambiguity while <code>…</code> /`..N` would be.</z><z id="t1583883648" t="noprompt I must apologize to everyone on the face of the earth for not recognizing this subtle difference sooner. 🙂"><y>#</y><d>2020-03-10</d><h>23:40</h><r>noprompt</r>I must apologize to everyone on the face of the earth for not recognizing this subtle difference sooner. <b>🙂</b></z><z id="t1583883933" t="timothypratley Ah well I don’t disagree with you… but I’m not seeing how it affects expression of this particular problem. In this case it seems like greediness isn’t a factor as there is only one solution."><y>#</y><d>2020-03-10</d><h>23:45</h><r>timothypratley</r>Ah well I don’t disagree with you… but I’m not seeing how it affects expression of this particular problem. In this case it seems like greediness isn’t a factor as there is only one solution.</z><z id="t1583883989" t="timothypratley Don’t get me wrong; I love regexs and like the sound of what you are saying, I just don’t get it 😄"><y>#</y><d>2020-03-10</d><h>23:46</h><r>timothypratley</r>Don’t get me wrong; I love regexs and like the sound of what you are saying, I just don’t get it <b>😄</b></z><z id="t1583884003" t="noprompt There isn’t one solution to this [(m/pred odd? !odds) ... &amp; ?rest] "><y>#</y><d>2020-03-10</d><h>23:46</h><r>noprompt</r>There isn’t one solution to this
<pre>[(m/pred odd? !odds) ... &amp; ?rest]</pre>
</z><z id="t1583884033" t="noprompt Hence the need for an explicit distinction of greediness."><y>#</y><d>2020-03-10</d><h>23:47</h><r>noprompt</r>Hence the need for an explicit distinction of greediness.</z><z id="t1583884045" t="timothypratley Oh I think I see what you mean now"><y>#</y><d>2020-03-10</d><h>23:47</h><r>timothypratley</r>Oh I think I see what you mean now</z><z id="t1583884053" t="noprompt What we really want here is CONSUME ALL THE ODDS DAMMIT!!! 😂"><y>#</y><d>2020-03-10</d><h>23:47</h><r>noprompt</r>What we really want here is CONSUME ALL THE ODDS DAMMIT!!! <b>😂</b></z><z id="t1583884069" t="noprompt But because its ambiguous… hahah yeah. 😛"><y>#</y><d>2020-03-10</d><h>23:47</h><r>noprompt</r>But because its ambiguous… hahah yeah. <b>😛</b></z><z id="t1583884153" t="timothypratley is there a situation where you really want non-greedy? I guess for search maybe?"><y>#</y><d>2020-03-10</d><h>23:49</h><r>timothypratley</r>is there a situation where you really want non-greedy? I guess for <code>search</code> maybe?</z><z id="t1583884358" t="noprompt Yep. 🙂 And find too."><y>#</y><d>2020-03-10</d><h>23:52</h><r>noprompt</r>Yep. <b>🙂</b> And <code>find</code> too.</z><z id="t1583884405" t="noprompt Hence my apology for not noticing the subtlety"><y>#</y><d>2020-03-10</d><h>23:53</h><r>noprompt</r>Hence my apology for not noticing the subtlety</z><z id="t1583884466" t="timothypratley I guess somewhat ironically … in match means non-greedy but … in search means greedy if you have enough constraints o_O I know it doesn’t really mean greedy but you can make it behave like that obviously as per example."><y>#</y><d>2020-03-10</d><h>23:54</h><r>timothypratley</r>I guess somewhat ironically <code>…</code> in match means non-greedy but <code>…</code> in search means greedy if you have enough constraints o_O I know it doesn’t really mean greedy but you can make it behave like that obviously as per example.</z><z id="t1583882380" t="noprompt FYI someone asked about having Mathematica’s Longest and we will have that in the form of greedy Kleene start both on epsilon and zeta ."><y>#</y><d>2020-03-10</d><h>23:19</h><w>noprompt</w>FYI someone asked about having Mathematica’s <code>Longest</code> and we will have that in the form of greedy Kleene start both on <code>epsilon</code> and <code>zeta</code>.</z><z id="t1583882429" t="noprompt In fact, zeta will basically have as much or all of regex as humanly possible."><y>#</y><d>2020-03-10</d><h>23:20</h><w>noprompt</w>In fact, <code>zeta</code> will basically have as much or all of regex as humanly possible.</z><z id="t1583884100" t="noprompt I also want to thank everyone, again, for the millionth time for supporting the project and suffering lows. 🙂"><y>#</y><d>2020-03-10</d><h>23:48</h><w>noprompt</w>I also want to thank everyone, again, for the millionth time for supporting the project and suffering lows. <b>🙂</b></z><z id="t1583884118" t="noprompt And sharing the highs. 😉"><y>#</y><d>2020-03-10</d><h>23:48</h><w>noprompt</w>And sharing the highs. <b>😉</b></z><z id="t1583884324" t="Ethan Miller Hey I’m wondering if it’s possible to extract the structures that one passes to the match function. Eg.. I tried something like this: (def match `{:a ?a :b ?b}) (def target `{:a ?b :b ?a}) (m/match {:a 1 :2} ~match ~target}"><y>#</y><d>2020-03-10</d><h>23:52</h><w>Ethan Miller</w>Hey I’m wondering if it’s possible to extract the structures that one passes to the <code>match</code> function.

Eg.. I tried something like this:

<pre>(def match `{:a ?a :b ?b})
(def target `{:a ?b :b ?a})
(m/match {:a 1 :2} ~match ~target}</pre></z><z id="t1583884369" t="Ethan Miller This produced an error:"><y>#</y><d>2020-03-10</d><h>23:52</h><w>Ethan Miller</w>This produced an error:</z><z id="t1583884371" t="Ethan Miller &gt; non exhaustive pattern match"><y>#</y><d>2020-03-10</d><h>23:52</h><w>Ethan Miller</w>&gt;     non exhaustive pattern match</z><z id="t1583884522" t="timothypratley defsyntax 🙂"><y>#</y><d>2020-03-10</d><h>23:55</h><r>timothypratley</r>defsyntax <b>🙂</b></z><z id="t1583884695" t="timothypratley (m/defsyntax m [] &apos;{:a ?a :b ?b}) =&gt; #&apos;happy.beaver/m (m/defsyntax t [] &apos;{:a ?b :b ?a}) =&gt; #&apos;happy.beaver/t (m/match {:a 1 :b 2} (m) (t)) =&gt; {:a ?b, :b ?a} "><y>#</y><d>2020-03-10</d><h>23:58</h><r>timothypratley</r><pre>(m/defsyntax m [] &apos;{:a ?a :b ?b})
=&gt; #&apos;happy.beaver/m
(m/defsyntax t [] &apos;{:a ?b :b ?a})
=&gt; #&apos;happy.beaver/t
(m/match {:a 1 :b 2}
  (m)
  (t))
=&gt; {:a ?b, :b ?a}</pre>
</z><z id="t1583884881" t="Ethan Miller Hmmm I was wondering about this. Thanks [:attrs {:href &quot;/_/_/users/U06S1EJPL&quot;}]"><y>#</y><d>2020-03-11</d><h>00:01</h><r>Ethan Miller</r>Hmmm I was wondering about this. Thanks <a>@U06S1EJPL</a></z><z id="t1583884544" t="noprompt Hi [:attrs {:href &quot;/_/_/users/U3RGL6XNF&quot;}] 👋 Someone opened a ticket with a similar structure a while back and the tl;dr to this is “no” and the reason why is that ~expr is an equality check against the match target with respect to the result of expr . Its not for splicing patterns."><y>#</y><d>2020-03-10</d><h>23:55</h><w>noprompt</w>Hi <a>@ezmiller77</a> <b>👋</b> Someone opened a ticket with a similar structure a while back and the tl;dr to this is “no” and the reason why is that <code>~expr</code> is an equality check against the match target with respect to the result of <code>expr</code> . Its not for splicing patterns.</z><z id="t1583884592" t="noprompt (m/match [20 30] [~(* 10 2) ~(* 10 3)] :yes) ;; =&gt; :yes "><y>#</y><d>2020-03-10</d><h>23:56</h><w>noprompt</w><pre>(m/match [20 30]
  [~(* 10 2) ~(* 10 3)]
  :yes)
;; =&gt; :yes</pre>
</z><z id="t1583884694" t="noprompt There is work on going in the subsequent branch of the project, zeta , which will allow for this kind of programatic thing."><y>#</y><d>2020-03-10</d><h>23:58</h><w>noprompt</w>There is work on going in the subsequent branch of the project, <code>zeta</code>, which will allow for this kind of programatic thing.</z><z id="t1583884727" t="Ethan Miller I see. So basically my use-case here has to do with keeping code readable. So maybe I can just pack the expression inside another fn."><y>#</y><d>2020-03-10</d><h>23:58</h><w>Ethan Miller</w>I see. So basically my use-case here has to do with keeping code readable. So maybe I can just pack the expression inside another fn.</z><z id="t1583884776" t="Ethan Miller I’m basically trying to use meander to do a large-scale remap of keys on a map, where I’m also adding a bunch of other keys with nil values."><y>#</y><d>2020-03-10</d><h>23:59</h><w>Ethan Miller</w>I’m basically trying to use meander to do a large-scale remap of keys on a map, where I’m also adding a bunch of other keys with <code>nil</code> values.</z><z id="t1583884797" t="Ethan Miller So both the lhs and rhs expressions are gonna be quite large."><y>#</y><d>2020-03-10</d><h>23:59</h><w>Ethan Miller</w>So both the lhs and rhs expressions are gonna be quite large.</z><z id="t1583884836" t="noprompt Ah, yeah, readability is kind of hard to address because folks have different notions of what that means. However, I would argue that having a large LHS and RHS is maybe not so bad."><y>#</y><d>2020-03-11</d><h>00:00</h><w>noprompt</w>Ah, yeah, readability is kind of hard to address because folks have different notions of what that means. However, I would argue that having a large LHS and RHS is maybe not so bad.</z><z id="t1583884847" t="timothypratley FWIW I’ve had good success with defsyntax (see original thread for example), and with using (m/app) to do futher transformations."><y>#</y><d>2020-03-11</d><h>00:00</h><w>timothypratley</w>FWIW I’ve had good success with <code>defsyntax</code> (see original thread for example), and with using <code>(m/app)</code>  to do futher transformations.</z><z id="t1583884853" t="noprompt But, again, that perspective is context sensitive."><y>#</y><d>2020-03-11</d><h>00:00</h><w>noprompt</w>But, again, that perspective is context sensitive.</z><z id="t1583884865" t="noprompt Oh, yeah, thats a nice way to do it."><y>#</y><d>2020-03-11</d><h>00:01</h><w>noprompt</w>Oh, yeah, thats a nice way to do it.</z><z id="t1583884880" t="noprompt Actually, I recently used defsyntax for just that purpose"><y>#</y><d>2020-03-11</d><h>00:01</h><w>noprompt</w>Actually, I recently used <code>defsyntax</code> for just that purpose</z><z id="t1583884907" t="Ethan Miller I see what you mean. It is subjective indeed."><y>#</y><d>2020-03-11</d><h>00:01</h><w>Ethan Miller</w>I see what you mean. It is subjective indeed.</z><z id="t1583884912" t="noprompt (defsyntax cool-thing [?a ?b] {:a ?a :b ?b}) Would give you the ability to match and substitute with cool-thing ."><y>#</y><d>2020-03-11</d><h>00:01</h><w>noprompt</w><pre>(defsyntax cool-thing [?a ?b]
  {:a ?a :b ?b})</pre>
Would give you the ability to match and substitute with <code>cool-thing</code>.</z><z id="t1583884967" t="Ethan Miller Why do you here use those arguments [?a ?b] ?"><y>#</y><d>2020-03-11</d><h>00:02</h><w>Ethan Miller</w>Why do you here use those arguments <code>[?a ?b]</code>?</z><z id="t1583885005" t="noprompt Out of habit. 🙂"><y>#</y><d>2020-03-11</d><h>00:03</h><r>noprompt</r>Out of habit. <b>🙂</b></z><z id="t1583884980" t="noprompt (m/defsyntax cool-thing [?a ?b] {:a ?a :b ?b}) (m/match {:a 1 :b 2} (cool-thing 1 ?b) ?b) ;; =&gt; 2 (m/rewrite {:a 1 :b 2} (cool-thing ?a ?b) (cool-thing [?a ?a] [?b ?b])) ;; =&gt; {:a [1 1], :b [2 2]} "><y>#</y><d>2020-03-11</d><h>00:03</h><w>noprompt</w><pre>(m/defsyntax cool-thing [?a ?b]
  {:a ?a :b ?b})

(m/match {:a 1 :b 2}
  (cool-thing 1 ?b)
  ?b)
;; =&gt; 2

(m/rewrite {:a 1 :b 2}
  (cool-thing ?a ?b)
  (cool-thing [?a ?a] [?b ?b]))
;; =&gt; {:a [1 1], :b [2 2]}</pre>
</z><z id="t1583885063" t="Ethan Miller Nice"><y>#</y><d>2020-03-11</d><h>00:04</h><w>Ethan Miller</w>Nice</z><z id="t1583885072" t="Ethan Miller Gonna give this a try."><y>#</y><d>2020-03-11</d><h>00:04</h><w>Ethan Miller</w>Gonna give this a try.</z><z id="t1583885107" t="noprompt [:attrs {:href &quot;/_/_/users/U3RGL6XNF&quot;}] Checkout https://github.com/noprompt/meander/blob/epsilon/doc/defsyntax.md"><y>#</y><d>2020-03-11</d><h>00:05</h><w>noprompt</w><a>@ezmiller77</a> Checkout <a href="https://github.com/noprompt/meander/blob/epsilon/doc/defsyntax.md" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/defsyntax.md</a></z><z id="t1583885156" t="noprompt If anything isn’t clear in the docs or if you want to improve them etc. open a ticket, pull request, or chat here. 🙂"><y>#</y><d>2020-03-11</d><h>00:05</h><w>noprompt</w>If anything isn’t clear in the docs or if you want to improve them etc. open a ticket, pull request, or chat here. <b>🙂</b></z><z id="t1583885218" t="timothypratley Here’s an example of what I mean by m/app https://github.com/timothypratley/happygapi/blob/master/dev/happy/beaver.clj#L154 which can be handy if you have deeply nested stuff that you just don’t want to think about 🙂 i.e. defsyntax is great for breaking up patterns but at some point you still have to put them back together somehow so if the putting togeter and pulling apart are colocated I think m/app wins in those cases /shrug"><y>#</y><d>2020-03-11</d><h>00:06</h><w>timothypratley</w>Here’s an example of what I mean by <code>m/app</code><a href="https://github.com/timothypratley/happygapi/blob/master/dev/happy/beaver.clj#L154" target="_blank">https://github.com/timothypratley/happygapi/blob/master/dev/happy/beaver.clj#L154</a> which can be handy if you have deeply nested stuff that you just don’t want to think about <b>🙂</b> i.e. defsyntax is great for breaking up patterns but at some point you still have to put them back together somehow so if the <code>putting togeter</code> and <code>pulling apart</code> are colocated I think <code>m/app</code> wins in those cases /shrug</z><z id="t1583885317" t="Ethan Miller Thanks to you both for the quick responses. Gonna study these links."><y>#</y><d>2020-03-11</d><h>00:08</h><w>Ethan Miller</w>Thanks to you both for the quick responses. Gonna study these links.</z><z id="t1583885411" t="noprompt Definitely! I think you will find folks here to be helpful. Its rare that a question gets left on the stack without a response."><y>#</y><d>2020-03-11</d><h>00:10</h><w>noprompt</w>Definitely! I think you will find folks here to be helpful. Its rare that a question gets left on the stack without a response.</z><z id="t1583885522" t="noprompt Coincidentally, I do need to step away for a moment. 🙂"><y>#</y><d>2020-03-11</d><h>00:12</h><w>noprompt</w>Coincidentally, I do need to step away for a moment. <b>🙂</b></z><z id="t1583904923" t="noprompt https://github.com/noprompt/meander/pull/117"><y>#</y><d>2020-03-11</d><h>05:35</h><w>noprompt</w><a href="https://github.com/noprompt/meander/pull/117" target="_blank">https://github.com/noprompt/meander/pull/117</a></z><z id="t1583905047" t="noprompt Normally I might commit this and release, but there were other folks involved in the previous discussions and I want to give them (and others) a chance to share any thoughts before I merge. Tim, I’m looking at you. 🙂"><y>#</y><d>2020-03-11</d><h>05:37</h><w>noprompt</w>Normally I might commit this and release, but there were other folks involved in the previous discussions and I want to give them (and others) a chance to share any thoughts before I merge. Tim, I’m looking at you. <b>🙂</b></z><z id="t1583932508" t="timothypratley I’ll play around with it tonight"><y>#</y><d>2020-03-11</d><h>13:15</h><r>timothypratley</r>I’ll play around with it tonight</z><z id="t1583977571" t="timothypratley works as advertised :thumbsup:"><y>#</y><d>2020-03-12</d><h>01:46</h><r>timothypratley</r>works as advertised <b>:thumbsup:</b></z><z id="t1584004295" t="yuhan I was thinking a little about the proposed fold operator in zeta, something doesn&apos;t feel right about the mutable variable"><y>#</y><d>2020-03-12</d><h>09:11</h><w>yuhan</w>I was thinking a little about the proposed <code>fold</code> operator in zeta, something doesn&apos;t feel right about the mutable variable</z><z id="t1584004398" t="yuhan Shouldn&apos;t the process of folding be an implementation detail that&apos;s hidden from the user? I can&apos;t think of any case where the intermediate values of the accumulator would want to be referred /outside/ of the fold"><y>#</y><d>2020-03-12</d><h>09:13</h><w>yuhan</w>Shouldn&apos;t the process of folding be an implementation detail that&apos;s hidden from the user? I can&apos;t think of any case where the intermediate values of the accumulator would want to be referred /outside/ of the fold</z><z id="t1584004747" t="yuhan It seems more natural for the (fold ...) form to match the entire sequence to be reduced, and bind its argument as a general pattern to the result of the reduction"><y>#</y><d>2020-03-12</d><h>09:19</h><w>yuhan</w>It seems more natural for the <code>(fold ...)</code> form to match the entire sequence to be reduced, and bind its argument as a general pattern to the result of the reduction</z><z id="t1584004832" t="yuhan something like: (m/match [1 8 9 -1 10 30 3] (m/fold ?result 0 clojure.core/min) ?result) ;; =&gt; -1 "><y>#</y><d>2020-03-12</d><h>09:20</h><w>yuhan</w>something like:
<pre>(m/match [1 8 9 -1 10 30 3]
  (m/fold ?result 0 clojure.core/min)
  ?result)
;; =&gt; -1</pre>
</z><z id="t1584006006" t="yuhan if anything, there could be a 5-arity of the operator (fold result init acc elem fn-return) where everything except fn-return is a pattern"><y>#</y><d>2020-03-12</d><h>09:40</h><w>yuhan</w>if anything, there could be a 5-arity of the operator <code>(fold result init acc elem fn-return)</code> where everything except fn-return is a pattern</z><z id="t1584006224" t="yuhan {:total-score ?total :bonus ?bonus :games (m/fold [?total ?min-score] ?bonus [*t *min] {:score *s} [(+ *t *s) (min *min *s)])}"><y>#</y><d>2020-03-12</d><h>09:43</h><w>yuhan</w><pre>{:total-score ?total
 :bonus ?bonus
 :games (m/fold [?total ?min-score] ?bonus
          [*t *min] {:score *s} [(+ *t *s) (min *min *s)])}</pre></z><z id="t1584006358" t="yuhan just throwing out ideas here, I have no clue what the implementation dififculties are like 😅"><y>#</y><d>2020-03-12</d><h>09:45</h><w>yuhan</w>just throwing out ideas here, I have no clue what the implementation dififculties are like <b>😅</b></z><z id="t1584028679" t="jlmr Hi, I’m trying to decide if meander is the right tool to use. I’ve never used it before, so I have some trouble deciding on its applicability. I have a sequence of maps like this: (def data [{:a 1 :b 0 :c 0 :score 0.0123} {:a 0 :b 1 :c 0 :score 0.0123} {:a 1 :b 0 :c 1 :score 0.0123} ...]) Right now I’m trying to create different groupings of these maps using code like this: (defn has-kvs? [m subset] (let [create-predicate (fn [[k v]] (fn [x] (v (get x k)))) pred (apply every-pred (map create-predicate subset))] (pred m))) (let [preds {&quot;Pred 1&quot; #(or (has-kvs? % {:a pos? :b zero? :c zero?}) (has-kvs? % {:b zero? :c zero?}))} &quot;Pred2&quot; #(or (has-kvs? % {:a zero? :b pos?}) (has-kvs? % {:a zero? :c pos?}))] (for [[title pred] preds] {:title title :values (-&gt;&gt; data (filter pred) (map :score))})) It could be that this minimal example doesn’t make complete sense, but in the full code it works, although it is quite cumbersome writing the predicate combinations. Could meander help with that in some way?"><y>#</y><d>2020-03-12</d><h>15:57</h><w>jlmr</w>Hi, I’m trying to decide if meander is the right tool to use. I’ve never used it before, so I have some trouble deciding on its applicability.

I have a sequence of maps like this:
<pre>(def data
  [{:a 1 :b 0 :c 0 :score 0.0123}
   {:a 0 :b 1 :c 0 :score 0.0123}
   {:a 1 :b 0 :c 1 :score 0.0123} ...])</pre>
Right now I’m trying to create different groupings of these maps using code like this:
<pre>(defn has-kvs?
  [m subset]
  (let [create-predicate (fn [[k v]] (fn [x] (v (get x k))))
        pred (apply every-pred (map create-predicate subset))]
    (pred m)))

(let [preds {&quot;Pred 1&quot; #(or (has-kvs? % {:a pos?
                                        :b zero?
                                        :c zero?})
                           (has-kvs? % {:b zero?
                                        :c zero?}))}

            &quot;Pred2&quot; #(or (has-kvs? % {:a zero?
                                      :b pos?})
                         (has-kvs? % {:a zero?
                                      :c pos?}))]

    (for [[title pred] preds]
      {:title title :values (-&gt;&gt; data
                                 (filter pred)
                                 (map :score))}))</pre>
It could be that this minimal example doesn’t make complete sense, but in the full code it works, although it is quite cumbersome writing the predicate combinations. Could meander help with that in some way?</z><z id="t1584030110" t="noprompt We can give it a shot. Given your input data what are you thinking you would like your output to look like?"><y>#</y><d>2020-03-12</d><h>16:21</h><r>noprompt</r>We can give it a shot. Given your input <code>data</code> what are you thinking you would like your output to look like?</z><z id="t1584030271" t="jlmr Hm, maybe something like: [{:title &quot;group name 1&quot; :scores [0.0123 0.0123]} {:title &quot;group name 2&quot; :scores [0.0123 0.0123]}] And somewhere else should be defined when a score belongs to a group name"><y>#</y><d>2020-03-12</d><h>16:24</h><r>jlmr</r>Hm, maybe something like:
<pre>[{:title &quot;group name 1&quot; :scores [0.0123 0.0123]}
 {:title &quot;group name 2&quot; :scores [0.0123 0.0123]}]</pre>
And somewhere else should be defined when a score belongs to a group name</z><z id="t1584030278" t="jlmr Does that make sense?"><y>#</y><d>2020-03-12</d><h>16:24</h><r>jlmr</r>Does that make sense?</z><z id="t1584030604" t="noprompt The first thing I might suggest would be to write something which matches your records and does the bucketing. Maybe something like this (match x {:a 1 :b _ :c _ :score ?score} [&quot;one-in-column-a&quot; ?score] {:a _ :b 1 :c _ :score ?score} [&quot;one-in-column-b&quot; ?score] ,,,)"><y>#</y><d>2020-03-12</d><h>16:30</h><r>noprompt</r>The first thing I might suggest would be to write something which matches your records and does the bucketing. Maybe something like this
<pre>(match x
  {:a 1 :b _ :c _ :score ?score}
  [&quot;one-in-column-a&quot; ?score]

  {:a _ :b 1 :c _ :score ?score}
  [&quot;one-in-column-b&quot; ?score]

  ,,,)</pre></z><z id="t1584030732" t="jlmr interesting"><y>#</y><d>2020-03-12</d><h>16:32</h><r>jlmr</r>interesting</z><z id="t1584030736" t="jlmr will try it out"><y>#</y><d>2020-03-12</d><h>16:32</h><r>jlmr</r>will try it out</z><z id="t1584031125" t="noprompt [:attrs {:href &quot;/_/_/users/U56R03VNW&quot;}] Here’s something that connects more with the problem you described (defn record-buckets [record] (m/search record (m/or {:a (m/pred pos?) :b 0 :c 0} {:b 0 :c 0}) [&quot;Pred 1&quot; record] (m/or {:a 0 :b (m/pred pos?)} {:a 0 :c (m/pred pos?)}) [&quot;Pred 2&quot; record])) (mapcat record-buckets [{:a 1 :b 0 :c 0 :score 0.0123} {:a 0 :b 1 :c 0 :score 0.0123} {:a 1 :b 0 :c 1 :score 0.0123}]) ;; =&gt; ([&quot;Pred 1&quot; {:a 1, :b 0, :c 0, :score 0.0123}] [&quot;Pred 1&quot; {:a 1, :b 0, :c 0, :score 0.0123}] [&quot;Pred 2&quot; {:a 0, :b 1, :c 0, :score 0.0123}]) "><y>#</y><d>2020-03-12</d><h>16:38</h><r>noprompt</r><a>@U56R03VNW</a> Here’s something that connects more with the problem you described
<pre>(defn record-buckets [record]
  (m/search record
    (m/or {:a (m/pred pos?) :b 0 :c 0}
          {:b 0 :c 0})
    [&quot;Pred 1&quot; record]

    (m/or {:a 0 :b (m/pred pos?)}
          {:a 0 :c (m/pred pos?)})
    [&quot;Pred 2&quot; record]))

(mapcat record-buckets [{:a 1 :b 0 :c 0 :score 0.0123}
                        {:a 0 :b 1 :c 0 :score 0.0123}
                        {:a 1 :b 0 :c 1 :score 0.0123}])
;; =&gt;
([&quot;Pred 1&quot; {:a 1, :b 0, :c 0, :score 0.0123}]
 [&quot;Pred 1&quot; {:a 1, :b 0, :c 0, :score 0.0123}]
 [&quot;Pred 2&quot; {:a 0, :b 1, :c 0, :score 0.0123}])</pre>
</z><z id="t1584031369" t="noprompt search works to find all the possible solutions that match your input. If you want only the first match you would switch to m/find and use map instead of mapcat ."><y>#</y><d>2020-03-12</d><h>16:42</h><r>noprompt</r><code>search</code> works to find all the possible solutions that match your input. If you want only the first match you would switch to <code>m/find</code> and use <code>map</code> instead of <code>mapcat</code>.</z><z id="t1584029791" t="noprompt [:attrs {:href &quot;/_/_/users/UCPS050BV&quot;}] On zeta they are not that hard and, in fact, there is already a working implementation of the fold idea. Having the match happen at the “end” of the match presents a bit of a challenge but its an interesting suggestion. I’ll think about it. Another form I had considered was (fold *var init clauses ,,,) where clauses would be shaped liked [current input] output The other thing I should let you in on, which might give you more context, is that fold has a dual on the RHS which is that it “unfolds”. (Note that I used the word “dual” and not inverse.) In the unfold scenario we work from the current value of *var down to init by using the dual of the reducing function."><y>#</y><d>2020-03-12</d><h>16:16</h><w>noprompt</w><a>@qythium</a> On <code>zeta</code> they are not that hard and, in fact, there is already a working implementation of the <code>fold</code> idea. Having the match happen at the “end” of the match presents a bit of a challenge but its an interesting suggestion. I’ll think about it.

Another form I had considered was
<pre>(fold *var init clauses ,,,)</pre>
where clauses would be shaped liked
<pre>[current input] output</pre>
The other thing I should let you in on, which might give you more context, is that <code>fold</code> has a dual on the RHS which is that it “unfolds”. (Note that I used the word “dual” and not inverse.) In the unfold scenario we work from the current value of <code>*var</code> down to <code>init</code> by using the dual of the reducing function.</z><z id="t1584029996" t="noprompt The “main idea” for zeta is to have the LHS and RHS be duals of each other in everyway. All of the primitives like and , or , let , etc. will work on the RHS."><y>#</y><d>2020-03-12</d><h>16:19</h><w>noprompt</w>The “main idea” for <code>zeta</code> is to have the LHS and RHS be duals of each other in everyway. All of the primitives like <code>and</code>, <code>or</code>, <code>let</code>, etc. will work on the RHS.</z><z id="t1584031408" t="yuhan I went back to look at the given example : (m/find [1 8 9 -1 10 30 3] (m/with [%min (m/fold *min 0 clojure.core/min)] [%min ...]) *min) ;; =&gt; -1 and it just occured that the fold form is supposed to take the role of &quot;reducing step&quot; (?) , hence the use of with etc."><y>#</y><d>2020-03-12</d><h>16:43</h><w>yuhan</w>I went back to look at the given example :
<pre>(m/find [1 8 9 -1 10 30 3]
  (m/with [%min (m/fold *min 0 clojure.core/min)]
    [%min ...])
   *min)
;; =&gt; -1</pre>
and it just occured that the <code>fold</code> form is supposed to take the role of &quot;reducing step&quot; (?) , hence the use of <code>with</code> etc.</z><z id="t1584031552" t="yuhan It&apos;s still quite unintuitive how that&apos;s supposed to work... maybe I need to set up a zeta scratchpad to try things out"><y>#</y><d>2020-03-12</d><h>16:45</h><w>yuhan</w>It&apos;s still quite unintuitive how that&apos;s supposed to work... maybe I need to set up a zeta scratchpad to try things out</z><z id="t1584031697" t="noprompt Yes. fold is a primitive which, in essence, manages the binding. Theres a couple of smaller pieces missing on zeta but once they are there you could just them to derive logic and memory variables from the same structure."><y>#</y><d>2020-03-12</d><h>16:48</h><w>noprompt</w>Yes. <code>fold</code> is a primitive which, in essence, manages the binding. Theres a couple of smaller pieces missing on <code>zeta</code> but once they are there you could just them to derive logic and memory variables from the same structure.</z><z id="t1584031782" t="noprompt The name fold might also be inappropriate."><y>#</y><d>2020-03-12</d><h>16:49</h><w>noprompt</w>The name <code>fold</code> might also be inappropriate.</z><z id="t1584032025" t="yuhan That might be partly it, based on the name I was expecting a pattern which stood in place of a collection to be folded"><y>#</y><d>2020-03-12</d><h>16:53</h><w>yuhan</w>That might be partly it, based on the name I was expecting a pattern which stood in place of a collection to be folded</z><z id="t1584032121" t="yuhan Also my category theory knowledge is a little shaky but does it somehow correspond to catamorphisms on the LHS and anamorphisms on the RHS?"><y>#</y><d>2020-03-12</d><h>16:55</h><w>yuhan</w>Also my category theory knowledge is a little shaky but does it somehow correspond to catamorphisms on the LHS and  anamorphisms on the RHS?</z><z id="t1584032337" t="noprompt Yes, but I’ll be honest I don’t have enough CT skills to go in depth on it. Though I can say there’s this cool thing: http://conal.net/talks/folds-and-unfolds.pdf 🙂"><y>#</y><d>2020-03-12</d><h>16:58</h><w>noprompt</w>Yes, but I’ll be honest I don’t have enough CT skills to go in depth on it. Though I can say there’s this cool thing: <a href="http://conal.net/talks/folds-and-unfolds.pdf" target="_blank">http://conal.net/talks/folds-and-unfolds.pdf</a> <b>🙂</b></z><z id="t1584032506" t="noprompt I should have some time soon to fill in some of the meander.zeta namespace for folks to play around with."><y>#</y><d>2020-03-12</d><h>17:01</h><w>noprompt</w>I should have some time soon to fill in some of the <code>meander.zeta</code> namespace for folks to play around with.</z><z id="t1584032604" t="noprompt All of the work that is being done on zeta is happening in dev/meander/ and src/meander/runtime"><y>#</y><d>2020-03-12</d><h>17:03</h><w>noprompt</w>All of the work that is being done on <code>zeta</code> is happening in <code>dev/meander/</code> and <code>src/meander/runtime</code></z><z id="t1584032845" t="noprompt Its worth mentioning that Clojure’s reduce has a very specific implementation: its driven by seqable things only."><y>#</y><d>2020-03-12</d><h>17:07</h><w>noprompt</w>Its worth mentioning that Clojure’s <code>reduce</code> has a very specific implementation: its driven by seqable things only.</z><z id="t1584032880" t="noprompt But the heart of reduce is the actual reducing function."><y>#</y><d>2020-03-12</d><h>17:08</h><w>noprompt</w>But the heart of <code>reduce</code> is the actual reducing function.</z><z id="t1584033342" t="noprompt [:attrs {:href &quot;/_/_/users/UCPS050BV&quot;}] If you decide to play with zeta let me know if you have questions. 👍"><y>#</y><d>2020-03-12</d><h>17:15</h><w>noprompt</w><a>@qythium</a> If you decide to play with <code>zeta</code> let me know if you have questions. <b>👍</b></z><z id="t1584033478" t="Jimmy Miller I definitely think the current fold we are playing around with is a bit lower level than people will need to actually use. Being able to match on the result of a fold with a logic variable definitely makes sense. I think the fold we currently have is the primitive that will power that sort of thing. For example, we could actually implement memory variables in terms of fold, the really are just syntatic sugar for a fold with empty vector and conj."><y>#</y><d>2020-03-12</d><h>17:17</h><w>Jimmy Miller</w>I definitely think the current fold we are playing around with is a bit lower level than people will need to actually use. Being able to match on the result of a fold with a logic variable definitely makes sense. I think the fold we currently have is the primitive that will power that sort of thing. 

For example, we could actually implement memory variables in terms of fold, the really are just syntatic sugar for a fold with empty vector and conj.</z><z id="t1584033601" t="Jimmy Miller Really the mutable variable in fold doesn&apos;t even need to be exposed. (mutable is really a misnomer for this imo)"><y>#</y><d>2020-03-12</d><h>17:20</h><w>Jimmy Miller</w>Really the mutable variable in fold doesn&apos;t even need to be exposed. (mutable is really a misnomer for this imo)</z><z id="t1584033949" t="yuhan that&apos;s great to hear 🙂 I wonder if the current cata operator is somewhat of a misnomer too"><y>#</y><d>2020-03-12</d><h>17:25</h><w>yuhan</w>that&apos;s great to hear <b>🙂</b> I wonder if the current <code>cata</code> operator is somewhat of a misnomer too</z><z id="t1584033999" t="Jimmy Miller Cata on the lhs I think is cata. Cata in rhs is really recur. (Had it backwards originally)"><y>#</y><d>2020-03-12</d><h>17:26</h><w>Jimmy Miller</w>Cata on the lhs I think is cata. Cata in rhs is really recur. (Had it backwards originally)</z><z id="t1584034411" t="yuhan Any hints on how to use zeta in its current state? I checked out the branch and started a repl clj -A:dev but the namespaces are doing weird things when loaded"><y>#</y><d>2020-03-12</d><h>17:33</h><w>yuhan</w>Any hints on how to use zeta in its current state? I checked out the branch and started a repl <code>clj -A:dev</code>  but the namespaces are doing weird things when loaded</z><z id="t1584034540" t="yuhan overwriting the compiled/*.clj files and throwing &quot;unmatched delimiter&quot; errors"><y>#</y><d>2020-03-12</d><h>17:35</h><w>yuhan</w>overwriting the compiled/*.clj files and throwing &quot;unmatched delimiter&quot; errors</z><z id="t1584034616" t="yuhan lots of advanced macrology going on 😵"><y>#</y><d>2020-03-12</d><h>17:36</h><w>yuhan</w>lots of advanced macrology going on <b>😵</b></z><z id="t1584034899" t="Jimmy Miller [:attrs {:href &quot;/_/_/users/UCPS050BV&quot;}] Don’t know your setup. But I just pulled down the latest. Loaded up cider with the -A:dev and evaluated the meander.dev.zeta namespace"><y>#</y><d>2020-03-12</d><h>17:41</h><w>Jimmy Miller</w><a>@qythium</a> Don’t know your setup. But I just pulled down the latest. Loaded up cider with the -A:dev and evaluated the <code>meander.dev.zeta</code> namespace</z><z id="t1584034917" t="Jimmy Miller Everything worked for me doing a simple (rewrite 1 ?x ?x)"><y>#</y><d>2020-03-12</d><h>17:41</h><w>Jimmy Miller</w>Everything worked for me doing a simple <code>(rewrite 1 ?x ?x)</code></z><z id="t1584035156" t="Jimmy Miller There is definitely a lot of weird stuff going on. But I will say, so far working with the meander.zeta compiler is so much better. I am going to have a blog post coming out soon sketching the idea. Not full details, but showing how to make your own meander lite compiler using meander."><y>#</y><d>2020-03-12</d><h>17:45</h><w>Jimmy Miller</w>There is definitely a lot of weird stuff going on. But I will say, so far working with the meander.zeta compiler is so much better. I am going to have a blog post coming out soon sketching the idea. Not full details, but showing how to make your own meander lite compiler using meander.</z><z id="t1584035561" t="yuhan That&apos;s really strange, it works in a plain clj repl in the terminal but not when I use Cider"><y>#</y><d>2020-03-12</d><h>17:52</h><w>yuhan</w>That&apos;s really strange, it works in a plain <code>clj</code> repl in the terminal but not when I use Cider</z></g><g id="s1"><z id="t1584035715" t="yuhan it&apos;s alright, I&apos;ll figure it out later - probably something to do with my Emacs config"><y>#</y><d>2020-03-12</d><h>17:55</h><w>yuhan</w>it&apos;s alright, I&apos;ll figure it out later - probably something to do with my Emacs config</z><z id="t1584036152" t="yuhan aha, it was due to my *print-length* settings, the compiled output got truncated"><y>#</y><d>2020-03-12</d><h>18:02</h><w>yuhan</w>aha, it was due to my <code>*print-length*</code> settings, the compiled output got truncated</z><z id="t1584037050" t="noprompt Thats good to know. That means we should probably rebind it in the defmodule source."><y>#</y><d>2020-03-12</d><h>18:17</h><w>noprompt</w>Thats good to know. That means we should probably rebind it in the <code>defmodule</code> source.</z><z id="t1584037185" t="noprompt defmodule is basically meander.epsilon/rewrite where the result of its macro expansion is rewritten to use the zeta runtime and the source is dumped to a file where it is defn ed."><y>#</y><d>2020-03-12</d><h>18:19</h><w>noprompt</w><code>defmodule</code> is basically <code>meander.epsilon/rewrite</code> where the result of its macro expansion is rewritten to use the <code>zeta</code> runtime and the source is dumped to a file where it is <code>defn</code>ed.</z><z id="t1584037283" t="noprompt The subst compilation emits to code which uses only the runtime, match compilation is somewhere in between."><y>#</y><d>2020-03-12</d><h>18:21</h><w>noprompt</w>The subst compilation emits to code which uses only the runtime, match compilation is somewhere in between.</z><z id="t1584037316" t="noprompt If something doesn’t work its probably not implemented."><y>#</y><d>2020-03-12</d><h>18:21</h><w>noprompt</w>If something doesn’t work its probably not implemented.</z><z id="t1584037425" t="noprompt The last time I was in there I was starting to work on m/string and that ultimately caused me to realize that we’re missing greedy star/plus."><y>#</y><d>2020-03-12</d><h>18:23</h><w>noprompt</w>The last time I was in there I was starting to work on <code>m/string</code> and that ultimately caused me to realize that we’re missing greedy star/plus.</z><z id="t1584042602" t="Jimmy Miller This setup definitely seems strange. But there are lots of reasons we went down this route. One being that meander.zeta will eventually be bootstrapped so our optimization effort will yield both faster generated code and a faster compiler at the same time."><y>#</y><d>2020-03-12</d><h>19:50</h><w>Jimmy Miller</w>This setup definitely seems strange. But there are lots of reasons we went down this route. One being that meander.zeta will eventually be bootstrapped so our optimization effort will yield both faster generated code and a faster compiler at the same time.</z><z id="t1584043181" t="noprompt Its also, like, 10,000 times easier to work on the parser."><y>#</y><d>2020-03-12</d><h>19:59</h><w>noprompt</w>Its also, like, 10,000 times easier to work on the parser.</z><z id="t1584043323" t="noprompt Its been a breeze to work on the parser and, really, the other components too."><y>#</y><d>2020-03-12</d><h>20:02</h><w>noprompt</w>Its been a breeze to work on the parser and, really, the other components too.</z><z id="t1584043369" t="noprompt Well, for me anyway."><y>#</y><d>2020-03-12</d><h>20:02</h><w>noprompt</w>Well, for me anyway.</z><z id="t1584043473" t="noprompt A reason for that is due to not having to manage a bunch of functions or deal with the hassle of doing things manually with Clojure. Using recursive rewrite rules is just so much simpler and easier to me because I only have to think of shapes. Pretty much the value proposition of rewrite ."><y>#</y><d>2020-03-12</d><h>20:04</h><w>noprompt</w>A reason for that is due to not having to manage a bunch of functions or deal with the hassle of doing things manually with Clojure. Using recursive rewrite rules is just so much simpler and easier to me because I only have to think of shapes. Pretty much the value proposition of <code>rewrite</code>.</z><z id="t1584043706" t="noprompt To put it in perspective, I spent several weekends writing the zeta parser in Clojure before dumping it because it was frustrating to change and debug. I rewrote it with rewrite and had a working, bug free implementation in less than a day, really about a few hours."><y>#</y><d>2020-03-12</d><h>20:08</h><w>noprompt</w>To put it in perspective, I spent several weekends writing the <code>zeta</code> parser in Clojure before dumping it because it was frustrating to change and debug. I rewrote it with <code>rewrite</code> and had a working, bug free implementation in less than a day, really about a few hours.</z><z id="t1584043835" t="noprompt Now, because Jimmy and I have been the only ones to be working on zeta there isn’t much in the way of commentary explaining how things got to the point they are at on zeta , however, I am (and I’m sure Jimmy is too) very happy to discuss and collaborate on any of it. 🙂"><y>#</y><d>2020-03-12</d><h>20:10</h><w>noprompt</w>Now, because Jimmy and I have been the only ones to be working on <code>zeta</code> there isn’t much in the way of commentary explaining how things got to the point they are at on <code>zeta</code>, however, I am (and I’m sure Jimmy is too) very happy to discuss and collaborate on any of it. <b>🙂</b></z><z id="t1584043972" t="noprompt One of the biggest advantages to this approach, in general — again, to me — is the very minimal amount of scope. In day-to-day programming in most every language theres just this deluge of scope."><y>#</y><d>2020-03-12</d><h>20:12</h><w>noprompt</w>One of the biggest advantages to this approach, in general — again, to me — is the very minimal amount of scope. In day-to-day programming in most every language theres just this deluge of scope.</z><z id="t1584138174" t="timothypratley Any recommendations on good “term rewriting” literature?"><y>#</y><d>2020-03-13</d><h>22:22</h><w>timothypratley</w>Any recommendations on good “term rewriting” literature?</z><z id="t1584138218" t="Jimmy Miller Honestly I personally have found most of it to be super opaque. But &quot;term rewriting and all that&quot; is the big one."><y>#</y><d>2020-03-13</d><h>22:23</h><w>Jimmy Miller</w>Honestly I personally have found most of it to be super opaque. But &quot;term rewriting and all that&quot; is the big one.</z><z id="t1584138249" t="timothypratley thanks! 🙂"><y>#</y><d>2020-03-13</d><h>22:24</h><r>timothypratley</r>thanks! <b>🙂</b></z><z id="t1584138335" t="noprompt I’ve read that one and Jimmy’s assessment is accurate. It’s dense. Most TR is heavily focused on building TRSs that terminate too which narrows the focus out of the realm of practicality oftentimes."><y>#</y><d>2020-03-13</d><h>22:25</h><r>noprompt</r>I’ve read that one and Jimmy’s assessment is accurate. It’s dense.

Most TR is heavily focused on building TRSs that terminate too which narrows the focus out of the realm of practicality oftentimes.</z><z id="t1584138372" t="noprompt The Handbook of Automated Reasoning has a good article in it."><y>#</y><d>2020-03-13</d><h>22:26</h><r>noprompt</r>The Handbook of Automated Reasoning has a good article in it.</z><z id="t1584138411" t="noprompt Look at the languages TXL, Stratego XT, and Maude."><y>#</y><d>2020-03-13</d><h>22:26</h><r>noprompt</r>Look at the languages TXL, Stratego XT, and Maude.</z><z id="t1584138664" t="Jimmy Miller Also [:attrs {:href &quot;/_/_/users/U053S2W0V&quot;}] &apos;s talk is really good. https://vimeo.com/155448425"><y>#</y><d>2020-03-13</d><h>22:31</h><r>Jimmy Miller</r>Also <a>@U053S2W0V</a>&apos;s talk is really good. <a href="https://vimeo.com/155448425" target="_blank">https://vimeo.com/155448425</a></z><z id="t1584372921" t="timothypratley (m/match 1 ^String ?s ?s) ^^ I’d like this to not match… i.e. I’d like Meander to treat type hints as special predicates… thoughts?"><y>#</y><d>2020-03-16</d><h>15:35</h><w>timothypratley</w><pre>(m/match 1 ^String ?s ?s)</pre>
^^ I’d like this to not match… i.e. I’d like Meander to treat type hints as special predicates… thoughts?</z><z id="t1584373072" t="timothypratley The motivation being that I have a lot of (m/pred string? ?s) and I’d argue that it obscures the structure of what I’m matching, where as ^String doesn’t change the structure."><y>#</y><d>2020-03-16</d><h>15:37</h><w>timothypratley</w>The motivation being that I have a lot of <code>(m/pred string? ?s)</code> and I’d argue that it obscures the structure of what I’m matching, where as <code>^String</code> doesn’t change the structure.</z><z id="t1584373172" t="timothypratley ^String being the way to type hint in Clojure makes it somewhat intuitive that if I type hint a pattern, I’d like it to conform to the type."><y>#</y><d>2020-03-16</d><h>15:39</h><r>timothypratley</r><code>^String</code> being the way to type hint in Clojure makes it somewhat intuitive that if I type hint a pattern, I’d like it to conform to the type.</z><z id="t1584381074" t="Jimmy Miller Why meta over just a string operator? (string ?d)"><y>#</y><d>2020-03-16</d><h>17:51</h><r>Jimmy Miller</r>Why meta over just a string operator? <code>(string ?d)</code></z><z id="t1584382746" t="timothypratley FWIW I get a little confused whenever I see (anything) ;; is that going to match a list or a thing? Well, it depends on what anything is naturally 🙂 Conversely I like when I can write [] or {} and know that it will only match a vector or map. So type hints feel like a more familiar way to say this thing is an X … (m/pred string? ?s) is in my view not any worse than (string ?s) so given those options, I’d probably stick with m/pred just because it’s more obvious when reading."><y>#</y><d>2020-03-16</d><h>18:19</h><r>timothypratley</r>FWIW I get a little confused whenever I see <code>(anything)</code>;; is that going to match a list or a thing? Well, it depends on what <code>anything</code> is naturally <b>🙂</b> Conversely I like when I can write <code>[]</code> or <code>{}</code> and know that it will only match a vector or map. So type hints feel like a more familiar way to say <code>this thing is an X</code> … <code>(m/pred string? ?s)</code> is in my view not any worse than <code>(string ?s)</code> so given those options, I’d probably stick with <code>m/pred</code> just because it’s more obvious when reading.</z><z id="t1584380960" t="timothypratley (defn chain [x [c &amp; chains]] (if c (recur (list &apos;. x c) chains) x)) (defn chain [xs] (m/rewrite xs [?x ()] ?x [?x ((!chain ...) &amp; ?more-chains)] (m/cata [(&apos;. ?x . !chain ...) ?more-chains]))) (chain [&apos;(new List) &apos;((push_back 1) (push_back 2) (push_back 3))])"><y>#</y><d>2020-03-16</d><h>17:49</h><w>timothypratley</w><pre>(defn chain [x [c &amp; chains]]
  (if c
    (recur (list &apos;. x c) chains)
    x))

(defn chain [xs]
  (m/rewrite xs
    [?x ()] ?x
    [?x ((!chain ...) &amp; ?more-chains)]
    (m/cata [(&apos;. ?x . !chain ...) ?more-chains])))

(chain [&apos;(new List) &apos;((push_back 1)
                      (push_back 2)
                      (push_back 3))])</pre></z><z id="t1584381328" t="timothypratley 1. It seems wierd to me that I can use the meander version of rewrite with m/cata but not the strategy version. There is probably a good reason though. 2. m/cata seems like the dual of m/with 3. Is the meander version better? I think so but am having trouble justifying it.."><y>#</y><d>2020-03-16</d><h>17:55</h><r>timothypratley</r>1. It seems wierd to me that I can use the <code>meander</code> version of rewrite with <code>m/cata</code> but not the <code>strategy</code> version. There is probably a good reason though.
2. <code>m/cata</code> seems like the dual of <code>m/with</code> 
3. Is the meander version better? I think so but am having trouble justifying it..</z><z id="t1584383366" t="Jimmy Miller I can&apos;t really speak to why strategies doesn&apos;t have cata. I will say that we are hoping with zeta that strategies will not need to be separate and will not be function combinator based. Not 100% sure what that looks like yet though."><y>#</y><d>2020-03-16</d><h>18:29</h><r>Jimmy Miller</r>I can&apos;t really speak to why strategies doesn&apos;t have cata. I will say that we are hoping with zeta that strategies will not need to be separate and will not be function combinator based. Not 100% sure what that looks like yet though.</z><z id="t1584394457" t="noprompt Strategy rewrite could have cata. The only thing that doesn’t have cata is rewrites because the current state of the compiler on epsilon would require some heavy rework to make of feasible."><y>#</y><d>2020-03-16</d><h>21:34</h><r>noprompt</r>Strategy rewrite could have cata. The only thing that doesn’t have cata is rewrites because the current state of the compiler on epsilon would require some heavy rework to make of feasible.</z><z id="t1584458953" t="timothypratley roger roger; was just curious, not requesting 🙂 thanks for clarifying."><y>#</y><d>2020-03-17</d><h>15:29</h><r>timothypratley</r>roger roger; was just curious, not requesting <b>🙂</b> thanks for clarifying.</z><z id="t1584390467" t="timothypratley (m/rewrite [1 [&quot;a&quot; 2] &quot;b&quot; 3 &quot;c&quot;] (m/$ ?replace (m/pred string? !s)) ~(?replace (map keyword !s))) ^^ Doesn’t work (perhaps unsurprisingly) =&gt; [1 [(:a) 2] &quot;b&quot; 3 &quot;c&quot;] What I’m trying to do is convert all the strings to keywords… Well what I’m really trying to do is more complicated than that but this is a minimal example 🙂 TLDR it would be awesome if $ could substitute transformations (not just values)"><y>#</y><d>2020-03-16</d><h>20:27</h><w>timothypratley</w><pre>(m/rewrite [1 [&quot;a&quot; 2] &quot;b&quot; 3 &quot;c&quot;]
  (m/$ ?replace (m/pred string? !s))
  ~(?replace (map keyword !s)))</pre>
^^ Doesn’t work (perhaps unsurprisingly) <code>=&gt; [1 [(:a) 2] &quot;b&quot; 3 &quot;c&quot;]</code>
What I’m trying to do is convert all the strings to keywords… Well what I’m really trying to do is more complicated than that but this is a minimal example <b>🙂</b>
TLDR it would be awesome if <code>$</code> could substitute transformations (not just values)</z><z id="t1584391462" t="timothypratley Also I wish it replaced all occurences 🙂"><y>#</y><d>2020-03-16</d><h>20:44</h><r>timothypratley</r>Also I wish it replaced all occurences <b>🙂</b></z><z id="t1584391742" t="timothypratley what does $* do ???? o_O"><y>#</y><d>2020-03-16</d><h>20:49</h><r>timothypratley</r>what does <code>$*</code> do ???? o_O</z><z id="t1584392444" t="timothypratley I claim $* is broken on epsilon"><y>#</y><d>2020-03-16</d><h>21:00</h><r>timothypratley</r>I claim <code>$*</code> is broken on epsilon</z><z id="t1584393250" t="timothypratley (m/rewrite [1 [&quot;a&quot; 2] &quot;b&quot; 3 &quot;c&quot;] (m/$ ?replace (m/pred string? ?s)) (m/cata ~(?replace (keyword ?s))) ?x ?x) ^^ This works but is kinda gross because it will restart the tree walk over from scratch each time.."><y>#</y><d>2020-03-16</d><h>21:14</h><r>timothypratley</r><pre>(m/rewrite [1 [&quot;a&quot; 2] &quot;b&quot; 3 &quot;c&quot;]
  (m/$ ?replace (m/pred string? ?s))
  (m/cata ~(?replace (keyword ?s)))
  ?x ?x)</pre>
^^ This works but is kinda gross because it will restart the tree walk over from scratch each time..</z><z id="t1584397108" t="noprompt (me/rewrite [1 [&quot;a&quot; 2] &quot;b&quot; 3 &quot;c&quot;] (me/$ ?replace (me/pred string? ?s)) (me/cata (me/$ ?replace (me/keyword nil ?s))) ?x ?x) "><y>#</y><d>2020-03-16</d><h>22:18</h><r>noprompt</r><pre>(me/rewrite [1 [&quot;a&quot; 2] &quot;b&quot; 3 &quot;c&quot;]
  (me/$ ?replace (me/pred string? ?s))
  (me/cata (me/$ ?replace (me/keyword nil ?s)))

  ?x ?x)</pre>
</z><z id="t1584397137" t="noprompt But, yes, you are right it is gross that it has to rewalk."><y>#</y><d>2020-03-16</d><h>22:18</h><r>noprompt</r>But, yes, you are right it is gross that it has to rewalk.</z><z id="t1584397203" t="noprompt This is something I want to address in the near feature with a tree thing for describing these kinds of things."><y>#</y><d>2020-03-16</d><h>22:20</h><r>noprompt</r>This is something I want to address in the near feature with a <code>tree</code> thing for describing these kinds of things.</z><z id="t1584397216" t="noprompt You could use top-down or bottom-up"><y>#</y><d>2020-03-16</d><h>22:20</h><r>noprompt</r>You could use <code>top-down</code> or <code>bottom-up</code></z><z id="t1584405880" t="timothypratley (def p (s/top-down (s/match (m/pred string? ?s) (keyword ?s) ?x ?x))) (p [1 [&quot;a&quot; 2] &quot;b&quot; 3 &quot;c&quot;]) =&gt; [1 [:a 2] :b 3 :c] "><y>#</y><d>2020-03-17</d><h>00:44</h><r>timothypratley</r><pre>(def p
  (s/top-down
    (s/match
      (m/pred string? ?s) (keyword ?s)
      ?x ?x)))

(p [1 [&quot;a&quot; 2] &quot;b&quot; 3 &quot;c&quot;])
=&gt; [1 [:a 2] :b 3 :c]</pre>
</z><z id="t1584396537" t="noprompt Hey folks I’m going to pull the explicit dependency on ClojureScript out of the project. [:attrs {:href &quot;/_/_/users/U083D6HK9&quot;}] had made a patch for this and then I merged it but walked back the ClojureScript dependency."><y>#</y><d>2020-03-16</d><h>22:08</h><w>noprompt</w>Hey folks I’m going to pull the explicit dependency on ClojureScript out of the project. <a>@kenny</a> had made a patch for this and then I merged it but walked back the ClojureScript dependency.</z><z id="t1584396581" t="noprompt So now I’m going to remove the dependency, put in some conditional logic to load the required CLJS stuff."><y>#</y><d>2020-03-16</d><h>22:09</h><w>noprompt</w>So now I’m going to remove the dependency, put in some conditional logic to load the required CLJS stuff.</z><z id="t1584499417" t="markaddleman I&apos;m working through the meander examples at https://cljdoc.org/d/meander/epsilon/0.0.402/doc/understand-meander-s-pattern-matching-macros#rewrite I&apos;d like to change the example a bit to return something like clojure.core&apos;s group-by. For example, I have a collection [{:name &quot;entity1&quot; :vals [{:value 1} {:value 2}]} {:name &quot;entity1&quot; :vals [{:value 3} {:value 4} {:value 5}]}] I&apos;d like a meander expression to return [{:name &quot;entity1&quot; :vals [1 2 3 4 5]} The following works: (m/rewrite [{:name &quot;entity1&quot; :vals [{:value 1} {:value 2}]} {:name &quot;entity1&quot; :vals [{:value 3} {:value 4} {:value 5}]}] [{:name !name :vals [{:value !values} ...]} ...] [{:name !name :value [!values ...]} ...]) But fails to extend to multiple entity names (eg &quot;entity2&quot; with some vals). What&apos;s the secret sauce that I&apos;m missing?"><y>#</y><d>2020-03-18</d><h>02:43</h><w>markaddleman</w>I&apos;m working through the meander examples at <a href="https://cljdoc.org/d/meander/epsilon/0.0.402/doc/understand-meander-s-pattern-matching-macros#rewrite" target="_blank">https://cljdoc.org/d/meander/epsilon/0.0.402/doc/understand-meander-s-pattern-matching-macros#rewrite</a>

I&apos;d like to change the example a bit to return something like clojure.core&apos;s group-by.  For example, I have a collection
<pre>[{:name    &quot;entity1&quot;
               :vals  [{:value 1} {:value 2}]}
              {:name &quot;entity1&quot;
               :vals [{:value 3} {:value 4} {:value 5}]}]</pre>
I&apos;d like a meander expression to return
<pre>[{:name &quot;entity1&quot; :vals [1 2 3 4 5]}</pre>
The following works:
<pre>(m/rewrite [{:name    &quot;entity1&quot;
               :vals  [{:value 1} {:value 2}]}
              {:name &quot;entity1&quot;
               :vals [{:value 3} {:value 4} {:value 5}]}]
             [{:name    !name
               :vals [{:value !values} ...]} ...]
             [{:name   !name
               :value  [!values ...]} ...])</pre>
But fails to extend to multiple entity names (eg &quot;entity2&quot; with some vals).

What&apos;s the secret sauce that I&apos;m missing?</z><z id="t1584500802" t="noprompt [:attrs {:href &quot;/_/_/users/UAMEU7QV7&quot;}] at the moment we typically recommend group-by 🙂"><y>#</y><d>2020-03-18</d><h>03:06</h><w>noprompt</w><a>@mark340</a> at the moment we typically recommend <code>group-by</code> <b>🙂</b></z><z id="t1584500928" t="noprompt We are working on something which will help with reduction kinds of problems like group-by but in a robust and general way."><y>#</y><d>2020-03-18</d><h>03:08</h><w>noprompt</w>We are working on something which will help with reduction kinds of problems like <code>group-by</code> but in a robust and general way.</z><z id="t1584505344" t="markaddleman You know, I think you told me that before but I forgot. It seems such a natural thing to do in meander. Looking forward to zeta 🙂"><y>#</y><d>2020-03-18</d><h>04:22</h><r>markaddleman</r>You know, I think you told me that before but I forgot.  It seems such a natural thing to do in meander.  Looking forward to zeta <b>🙂</b></z><z id="t1584505552" t="noprompt Thanks. I want things to go more quickly but life has been more demanding than usual. 😅"><y>#</y><d>2020-03-18</d><h>04:25</h><r>noprompt</r>Thanks. I want things to go more quickly but life has been more demanding than usual. <b>😅</b></z><z id="t1584506183" t="markaddleman For everyone. Stay safe; stay healthy!"><y>#</y><d>2020-03-18</d><h>04:36</h><r>markaddleman</r>For everyone.  Stay safe; stay healthy!</z><z id="t1584501171" t="noprompt You can do reductions with rewrite though, depending on the task, it might not be what you want."><y>#</y><d>2020-03-18</d><h>03:12</h><w>noprompt</w>You can do reductions with rewrite though, depending on the task, it might not be what you want.</z><z id="t1584501397" t="noprompt (let [es [{:name &quot;entity1&quot; :vals [{:value 1} {:value 2}]} {:name&quot;entity1&quot; :vals [{:value 3} {:value 4} {:value 5}]}]] (me/rewrite [{} es] [?state []] ?state [{?name [!values ...] &amp; ?state} [{:name ?name :vals [{:value !values} ...]} &amp; ?rest]] (me/cata [{?name [!values ...] &amp; ?state} ?rest]) [?state [{:name ?name :vals [{:value !values} ...]} &amp; ?rest]] (me/cata [{?name [!values ...] &amp; ?state} ?rest])) ;; Semantically equivalent too (reduce (fn [state e] (me/rewrite [state e] [{?name [!values ...] &amp; ?state} {:name ?name :vals [{:value !values} ...]}] {?name [!values ...] &amp; ?state} [?state {:name ?name :vals [{:value !values} ...]}] {?name [!values ...] &amp; ?state})) {} es)) ;; =&gt; (let [es [{:name &quot;entity1&quot; :vals [{:value 1} {:value 2}]} {:name&quot;entity1&quot; :vals [{:value 3} {:value 4} {:value 5}]}]] (me/rewrite [{} es] [?state []] ?state [{?name [!values ...] &amp; ?state} [{:name ?name :vals [{:value !values} ...]} &amp; ?rest]] (me/cata [{?name [!values ...] &amp; ?state} ?rest]) [?state [{:name ?name :vals [{:value !values} ...]} &amp; ?rest]] (me/cata [{?name [!values ...] &amp; ?state} ?rest])) ;; Semantically equivalent too (reduce (fn [state e] (me/rewrite [state e] [{?name [!values ...] &amp; ?state} {:name ?name :vals [{:value !values} ...]}] {?name [!values ...] &amp; ?state} [?state {:name ?name :vals [{:value !values} ...]}] {?name [!values ...] &amp; ?state})) {} es)) ;; =&gt; {&quot;entity1&quot; [1 2 3 4 5]} "><y>#</y><d>2020-03-18</d><h>03:16</h><r>noprompt</r><pre>(let [es [{:name &quot;entity1&quot;
           :vals  [{:value 1} {:value 2}]}
          {:name&quot;entity1&quot;
           :vals [{:value 3} {:value 4} {:value 5}]}]]
  (me/rewrite [{} es]
    [?state []]
    ?state

    [{?name [!values ...] &amp; ?state} [{:name ?name :vals [{:value !values} ...]} &amp; ?rest]]
    (me/cata [{?name [!values ...] &amp; ?state} ?rest])

    [?state [{:name ?name :vals [{:value !values} ...]} &amp; ?rest]]
    (me/cata [{?name [!values ...] &amp; ?state} ?rest]))
  ;; Semantically equivalent too
  (reduce
   (fn [state e]
     (me/rewrite [state e]
       [{?name [!values ...] &amp; ?state} {:name ?name :vals [{:value !values} ...]}]
       {?name [!values ...] &amp; ?state}

       [?state {:name ?name :vals [{:value !values} ...]}]
       {?name [!values ...] &amp; ?state}))
   {}
   es))
;; =&gt; (let [es [{:name &quot;entity1&quot;
           :vals  [{:value 1} {:value 2}]}
          {:name&quot;entity1&quot;
           :vals [{:value 3} {:value 4} {:value 5}]}]]
  (me/rewrite [{} es]
    [?state []]
    ?state

    [{?name [!values ...] &amp; ?state} [{:name ?name :vals [{:value !values} ...]} &amp; ?rest]]
    (me/cata [{?name [!values ...] &amp; ?state} ?rest])

    [?state [{:name ?name :vals [{:value !values} ...]} &amp; ?rest]]
    (me/cata [{?name [!values ...] &amp; ?state} ?rest]))
  ;; Semantically equivalent too
  (reduce
   (fn [state e]
     (me/rewrite [state e]
       [{?name [!values ...] &amp; ?state} {:name ?name :vals [{:value !values} ...]}]
       {?name [!values ...] &amp; ?state}

       [?state {:name ?name :vals [{:value !values} ...]}]
       {?name [!values ...] &amp; ?state}))
   {}
   es))
;; =&gt;
{&quot;entity1&quot; [1 2 3 4 5]}</pre>
</z><z id="t1584501809" t="noprompt This, for example, is gross."><y>#</y><d>2020-03-18</d><h>03:23</h><r>noprompt</r>This, for example, is gross.</z><z id="t1584509485" t="noprompt https://github.com/noprompt/meander/pull/120"><y>#</y><d>2020-03-18</d><h>05:31</h><w>noprompt</w><a href="https://github.com/noprompt/meander/pull/120" target="_blank">https://github.com/noprompt/meander/pull/120</a></z><z id="t1584509544" t="noprompt ☝️ I’ll leave this open for the next day or so in case anyone wants to say something."><y>#</y><d>2020-03-18</d><h>05:32</h><w>noprompt</w><b>☝️</b> I’ll leave this open for the next day or so in case anyone wants to say something.</z><z id="t1584525791" t="magnusdk Hey, I’ve started using Meander more and more and it’s great! I have started getting some weird compiler exceptions however when running tests using lein kaocha --watch that occurs when reloading namespaces containing Meander code. /t"><y>#</y><d>2020-03-18</d><h>10:03</h><w>magnusdk</w>Hey, I’ve started using Meander more and more and it’s great!
I have started getting some weird compiler exceptions however when running tests using <code>lein kaocha --watch</code> that occurs when reloading namespaces containing Meander code. /t</z><z id="t1584525796" t="magnusdk The exception is clojure.lang.Compiler$CompilerException: Syntax error macroexpanding m/rewrites at (...) . Caused by: clojure.lang.ExceptionInfo: Call to #&apos;meander.syntax.epsilon/resolve-expander did not conform to spec: epsilon.cljc:308 -- Spec failed -------------------- Return value meander.epsilon/eval13971/expander--auto-- should satisfy (fn [%] (or (nil? %) (sequential? %))) ------------------------- Detected 1 error {:clojure.spec.alpha/problems [{:path [:ret], :pred (clojure.core/fn [%] (clojure.core/or (clojure.core/nil? %) (clojure.core/sequential? %))), :val #object[meander.epsilon$eval13971$expander__9593__auto____13972 0x7abb82d6 &quot;meander.epsilon$eval13971$expander__9593__auto____13972@7abb82d6&quot;], :via [], :in []}], :clojure.spec.alpha/spec #object[clojure.spec.alpha$regex_spec_impl$reify__2509 0x1a0fd147 &quot;clojure.spec.alpha$regex_spec_impl$reify__2509@1a0fd147&quot;], :clojure.spec.alpha/value #object[meander.epsilon$eval13971$expander__9593__auto____13972 0x7abb82d6 &quot;meander.epsilon$eval13971$expander__9593__auto____13972@7abb82d6&quot;], :clojure.spec.alpha/ret #object[meander.epsilon$eval13971$expander__9593__auto____13972 0x7abb82d6 &quot;meander.epsilon$eval13971$expander__9593__auto____13972@7abb82d6&quot;], :clojure.spec.alpha/failure :instrument, :orchestra.spec.test/caller {:file &quot;epsilon.cljc&quot;, :line 308, :var-scope meander.syntax.epsilon/expand-form}} Has anyone else experienced a similar problem?"><y>#</y><d>2020-03-18</d><h>10:03</h><r>magnusdk</r>The exception is <code>clojure.lang.Compiler$CompilerException: Syntax error macroexpanding m/rewrites at (...)</code>.
<pre>Caused by: clojure.lang.ExceptionInfo: Call to #&apos;meander.syntax.epsilon/resolve-expander did not conform to spec:
epsilon.cljc:308
-- Spec failed --------------------
Return value
  meander.epsilon/eval13971/expander--auto--
should satisfy
  (fn
   [%]
   (or (nil? %) (sequential? %)))
-------------------------
Detected 1 error
{:clojure.spec.alpha/problems [{:path [:ret], :pred (clojure.core/fn [%] (clojure.core/or (clojure.core/nil? %) (clojure.core/sequential? %))), :val #object[meander.epsilon$eval13971$expander__9593__auto____13972 0x7abb82d6 &quot;meander.epsilon$eval13971$expander__9593__auto____13972@7abb82d6&quot;], :via [], :in []}], :clojure.spec.alpha/spec #object[clojure.spec.alpha$regex_spec_impl$reify__2509 0x1a0fd147 &quot;clojure.spec.alpha$regex_spec_impl$reify__2509@1a0fd147&quot;], :clojure.spec.alpha/value #object[meander.epsilon$eval13971$expander__9593__auto____13972 0x7abb82d6 &quot;meander.epsilon$eval13971$expander__9593__auto____13972@7abb82d6&quot;], :clojure.spec.alpha/ret #object[meander.epsilon$eval13971$expander__9593__auto____13972 0x7abb82d6 &quot;meander.epsilon$eval13971$expander__9593__auto____13972@7abb82d6&quot;], :clojure.spec.alpha/failure :instrument, :orchestra.spec.test/caller {:file &quot;epsilon.cljc&quot;, :line 308, :var-scope meander.syntax.epsilon/expand-form}}</pre>
Has anyone else experienced a similar problem?</z><z id="t1584537876" t="magnusdk This is a minimal (I think) case where CompilerException is thrown (meander/match nil (meander/seqable) nil) It might have something to do with use of defsyntax as scan and separated causes the same issue"><y>#</y><d>2020-03-18</d><h>13:24</h><r>magnusdk</r>This is a minimal (I think) case where CompilerException is thrown
<pre>(meander/match nil
  (meander/seqable)
  nil)</pre>
It might have something to do with use of <code>defsyntax</code> as <code>scan</code> and <code>separated</code> causes the same issue</z><z id="t1584548266" t="Jimmy Miller I can definitely look into this. I&apos;m guessing these tests are instrumenting all specs?"><y>#</y><d>2020-03-18</d><h>16:17</h><r>Jimmy Miller</r>I can definitely look into this. I&apos;m guessing these tests are instrumenting all specs?</z><z id="t1584552500" t="Jimmy Miller I just tried recreating this. I instrumented every thing and tried running the code above and it ran with no issues. Do you have a project that is open with the issue? Can you share your deps? Any information for recreating would be great."><y>#</y><d>2020-03-18</d><h>17:28</h><r>Jimmy Miller</r>I just tried recreating this. I instrumented every thing and tried running the code above and it ran with no issues. Do you have a project that is open with the issue? Can you share your deps? Any information for recreating would be great.</z><z id="t1584559644" t="magnusdk Thank you for checking it out :) Yes, the tests are instrumented using https://github.com/jeaye/orchestra . Sorry for leaving out details, I’ll try my best to recreate it in a fresh, open project. I’ll get back to you"><y>#</y><d>2020-03-18</d><h>19:27</h><r>magnusdk</r>Thank you for checking it out :) Yes, the tests are instrumented using <a href="https://github.com/jeaye/orchestra" target="_blank">https://github.com/jeaye/orchestra</a>. Sorry for leaving out details, I’ll try my best to recreate it in a fresh, open project. I’ll get back to you</z><z id="t1584559708" t="Jimmy Miller Orchestra would explain the difference."><y>#</y><d>2020-03-18</d><h>19:28</h><r>Jimmy Miller</r>Orchestra would explain the difference.</z><z id="t1584559751" t="Jimmy Miller Hopefully have some time today to try that out and track down the issue."><y>#</y><d>2020-03-18</d><h>19:29</h><r>Jimmy Miller</r>Hopefully have some time today to try that out and track down the issue.</z><z id="t1584559945" t="magnusdk I’ve recreated the issue in a new project now. I can share it on github"><y>#</y><d>2020-03-18</d><h>19:32</h><r>magnusdk</r>I’ve recreated the issue in a new project now. I can share it on github</z><z id="t1584560487" t="Jimmy Miller I was able to do it with orchestra. Thanks, that was the missing piece"><y>#</y><d>2020-03-18</d><h>19:41</h><r>Jimmy Miller</r>I was able to do it with orchestra. Thanks, that was the missing piece</z><z id="t1584560592" t="magnusdk Awesome! I also uploaded my project here incase it’s still relevant https://github.com/magnusdk/meander-orchestra-kaocha-issue"><y>#</y><d>2020-03-18</d><h>19:43</h><r>magnusdk</r>Awesome! I also uploaded my project here incase it’s still relevant <a href="https://github.com/magnusdk/meander-orchestra-kaocha-issue" target="_blank">https://github.com/magnusdk/meander-orchestra-kaocha-issue</a></z><z id="t1584561728" t="Jimmy Miller Found the issue. Should have a fix today. There is nothing actually broken going on just a bad spec."><y>#</y><d>2020-03-18</d><h>20:02</h><r>Jimmy Miller</r>Found the issue. Should have a fix today. There is nothing actually broken going on just a bad spec.</z><z id="t1584562156" t="magnusdk That is fantastic! parrot Thank you for your time 🙂 This is great"><y>#</y><d>2020-03-18</d><h>20:09</h><r>magnusdk</r>That is fantastic! <b>parrot</b> Thank you for your time <b>🙂</b> This is great</z><z id="t1584565657" t="noprompt Just FYI, we’re probably not going to be using spec going forward. Its been a pain for a number of users and myself."><y>#</y><d>2020-03-18</d><h>21:07</h><r>noprompt</r>Just FYI, we’re probably not going to be using <code>spec</code> going forward. Its been a pain for a number of users and myself.</z><z id="t1584592059" t="Jimmy Miller Pushed a fix, will cut a release tomorrow."><y>#</y><d>2020-03-19</d><h>04:27</h><r>Jimmy Miller</r>Pushed a fix, will cut a release tomorrow.</z><z id="t1584649747" t="Jimmy Miller This has now been fixed in “0.0.408”"><y>#</y><d>2020-03-19</d><h>20:29</h><r>Jimmy Miller</r>This has now been fixed in “0.0.408”</z><z id="t1584649786" t="Jimmy Miller Let us know if you run into any other issues using orchestra."><y>#</y><d>2020-03-19</d><h>20:29</h><r>Jimmy Miller</r>Let us know if you run into any other issues using orchestra.</z><z id="t1584657846" t="magnusdk Thank you 😊"><y>#</y><d>2020-03-19</d><h>22:44</h><r>magnusdk</r>Thank you <b>😊</b></z><z id="t1584544634" t="markaddleman What are your thoughts around pluggable optimization strategies? I have a set of documents that, right now, are stored in plain Clojure sequences and yields plenty good enough performance. I have a somewhat complex meander pattern that encodes the business logic to find the right data within those documents. Over time, however, I expect the set of documents to grow perhaps to the point where sequence performance is not good enough. Much like adding an index in an RDBMS, I&apos;d love to swap out my sequences of data for something else but not change the declarative search strategy encoding in Meander. In practice, the next performance step would be storing the data in Datascript. I can almost imagine providing Meander some hints to access the data using index seqs. Thoughts?"><y>#</y><d>2020-03-18</d><h>15:17</h><w>markaddleman</w>What are your thoughts around pluggable optimization strategies?  I have a set of documents that, right now, are stored in plain Clojure sequences and yields plenty good enough performance.  I have a somewhat complex meander pattern that encodes the business logic to find the right data within those documents.

Over time, however, I expect the set of documents to grow perhaps to the point where sequence performance is not good enough.  Much like adding an index in an RDBMS, I&apos;d love to swap out my sequences of data for something else but not change the declarative search strategy encoding in Meander.  In practice, the next performance step would be storing the data in Datascript.  I can almost imagine providing Meander some hints to access the data using index seqs.

Thoughts?</z><z id="t1584552672" t="Jimmy Miller We don&apos;t have any plans right now for going that route. I do think having indexes and looking up by thing is a good thing to do if you have large datasets and are looking for performance. But I&apos;d personally recommend just making those indexes and passing them to your match. In my view, that would be the same as giving us a hint. Just give us the actual index and make your pattern match on that index."><y>#</y><d>2020-03-18</d><h>17:31</h><r>Jimmy Miller</r>We don&apos;t have any plans right now for going that route. I do think having indexes and looking up by thing is a good thing to do if you have large datasets and are looking for performance.

But I&apos;d personally recommend just making those indexes and passing them to your match. In my view, that would be the same as giving us a hint. Just give us the actual index and make your pattern match on that index.</z><z id="t1584632705" t="rfhayashi Hi! Is there a way in Meander to transform: {:items {:item1 {:value 1} :item2 {:value 2}}} into: {:values {:item1 1 :item2 2}} ? I tried: (m/search {:items {:item1 {:value 1} :item2 {:value 2}}} {:items {?item {:value ?value}}} {:values {?item ?value}}) But I get: ({:values {:item2 2}} {:values {:item1 1}}) I also tried match (which complains of logic variables in the key position) and rewrite, but could not figure out a way. I know I can do a merge-with on top of the result, but curious if there is a way to do this directly with Meander. Thanks!"><y>#</y><d>2020-03-19</d><h>15:45</h><w>rfhayashi</w>Hi! Is there a way in Meander to transform:
<pre>{:items {:item1 {:value 1}
         :item2 {:value 2}}}</pre>
into:
<pre>{:values {:item1 1
          :item2 2}}</pre>
? I tried:
<pre>(m/search
 {:items {:item1 {:value 1}
          :item2 {:value 2}}}
 {:items {?item {:value ?value}}}
 {:values {?item ?value}})</pre>
But I get:
<pre>({:values {:item2 2}} {:values {:item1 1}})</pre>
I also tried match (which complains of logic variables in the key position) and rewrite, but could not figure out a way. I know I can do a merge-with on top of the result, but curious if there is a way to do this directly with Meander. Thanks!</z><z id="t1584633400" t="magnusdk I came up with this: (m/match {:items {:item1 {:value 1} :item2 {:value 2} :item3 {:value 3}}} {:items (m/seqable [!item {:value !value}] ...)} {:values (zipmap !item !value)}) but I’m still new to Meander so I can’t tell if this is the most idiomatic way or not :man-shrugging:"><y>#</y><d>2020-03-19</d><h>15:56</h><r>magnusdk</r>I came up with this:
<pre>(m/match
  {:items {:item1 {:value 1}
           :item2 {:value 2}
           :item3 {:value 3}}}
  {:items (m/seqable [!item {:value !value}] ...)}
  {:values (zipmap !item !value)})</pre>
but I’m still new to Meander so I can’t tell if this is the most idiomatic way or not <b>:man-shrugging:</b></z><z id="t1584633945" t="Jimmy Miller Repeats in maps is a little ugly right now. That will be fixed with https://github.com/noprompt/meander/pull/117 But in the mean time you can do this (m/rewrite {:items {:item1 {:value 1} :item2 {:value 2}}} {:items {&amp; (m/seqable [!ks {:value !vs}] ...)}} {:values {&amp; [[!ks !vs] ...]}}) I can explain this in more detail later."><y>#</y><d>2020-03-19</d><h>16:05</h><r>Jimmy Miller</r>Repeats in maps is a little ugly right now. That will be fixed with <a href="https://github.com/noprompt/meander/pull/117" target="_blank">https://github.com/noprompt/meander/pull/117</a>


But in the mean time you can do this

<pre>(m/rewrite {:items {:item1 {:value 1}
                    :item2 {:value 2}}}
  {:items {&amp; (m/seqable [!ks {:value !vs}] ...)}}
  {:values {&amp; [[!ks !vs] ...]}})</pre>
I can explain this in more detail later.</z><z id="t1584634706" t="Jimmy Miller Once this lands all you&apos;d have to do is. (m/rewrite {:items {:item1 {:value 1} :item2 {:value 2}}} {:items (m/map-of !ks {:value !vs})} {:values (m/map-of !ks !vs)})"><y>#</y><d>2020-03-19</d><h>16:18</h><r>Jimmy Miller</r>Once this lands all you&apos;d have to do is.

<pre>(m/rewrite {:items {:item1 {:value 1}
                    :item2 {:value 2}}}
  {:items (m/map-of !ks {:value !vs})}
  {:values (m/map-of !ks !vs)})</pre></z><z id="t1584649730" t="Jimmy Miller This has now been merged if you update your meander to “0.0.408” you can now use map-of"><y>#</y><d>2020-03-19</d><h>20:28</h><r>Jimmy Miller</r>This has now been merged if you update your meander to “0.0.408” you can now use map-of</z><z id="t1584651852" t="rfhayashi 🆒 Thank you for the help!"><y>#</y><d>2020-03-19</d><h>21:04</h><r>rfhayashi</r><b>🆒</b> Thank you for the help!</z><z id="t1584649930" t="Jimmy Miller New version: meander/epsilon {:mvn/version &quot;0.0.408&quot;} * Adds map-of operator. * Removes clojurescript dependency * Fixes a bug in a :ret spec."><y>#</y><d>2020-03-19</d><h>20:32</h><w>Jimmy Miller</w>New version: <code>meander/epsilon {:mvn/version &quot;0.0.408&quot;}</code>

* Adds map-of operator.
* Removes clojurescript dependency
* Fixes a bug in a :ret spec.</z><z id="t1584712339" t="grounded_sage Is it possible to take a map as input and selectively transform the values of some keys without specifying the entirety of the map."><y>#</y><d>2020-03-20</d><h>13:52</h><w>grounded_sage</w>Is it possible to take a map as input and selectively transform the values of some keys without specifying the entirety of the map.</z><z id="t1584712515" t="grounded_sage (m/match {:one 1 :two &quot;2&quot; :thre 3} {... :two (m/app Integer. ?two) ...} {... :two ?two ...} Obviously the dots not doing what they normally do in meander lol"><y>#</y><d>2020-03-20</d><h>13:55</h><w>grounded_sage</w><pre>(m/match {:one 1
          :two &quot;2&quot;
          :thre 3}
  {...
   :two (m/app Integer. ?two)
   ...}
  {...
   :two ?two
   ...}</pre>
Obviously the dots not doing what they normally do in meander lol</z><z id="t1584712558" t="Jimmy Miller On my phone so can&apos;t give a full example. But you can use {&amp; ?rest} to capture the rest of a map. So just put all the rest of your matches above that and use rewrite."><y>#</y><d>2020-03-20</d><h>13:55</h><w>Jimmy Miller</w>On my phone so can&apos;t give a full example. But you can use <code>{&amp; ?rest}</code> to capture the rest of a map. So just put all the rest of your matches above that and use rewrite.</z><z id="t1584716044" t="grounded_sage How do I apply this in a rewrite (apply str (interpose &quot;,&quot; [?desc_1 ?desc_2 ?desc_3]))"><y>#</y><d>2020-03-20</d><h>14:54</h><w>grounded_sage</w>How do I apply this in a rewrite <code>(apply str (interpose &quot;,&quot; [?desc_1 ?desc_2 ?desc_3]))</code></z><z id="t1584717715" t="timothypratley You can either use ~(f ?x) to force evaluation or (m/app f ?x) to use substitutive evaluation"><y>#</y><d>2020-03-20</d><h>15:21</h><r>timothypratley</r>You can either use <code>~(f ?x)</code> to force evaluation or <code>(m/app f ?x)</code> to use substitutive evaluation</z><z id="t1584723198" t="Jimmy Miller But also you don&apos;t have the use rewrite for the map stuff above if you don&apos;t want to. You can still use {patterns &amp; ?rest} on the left hand side and then something like (merge {:x (m/app ?x} ?rest) on the right hand side. I think rewrite is super useful, but it isn&apos;t required."><y>#</y><d>2020-03-20</d><h>16:53</h><r>Jimmy Miller</r>But also you don&apos;t have the use rewrite for the map stuff above if you don&apos;t want to. You can still use <code>{patterns &amp; ?rest}</code> on the left hand side and then something like <code>(merge {:x (m/app ?x} ?rest)</code> on the right hand side.

I think rewrite is super useful, but it isn&apos;t required.</z><z id="t1584724383" t="noprompt The question was how to do it. 🙂 (me/rewrite [1 2 3] [&amp; _ :as ?xs] (me/app interpose &quot; &quot; ?xs)) ;; =&gt; (1 &quot; &quot; 2 &quot; &quot; 3) On the RHS me/app will apply substitution to all the arguments after the function."><y>#</y><d>2020-03-20</d><h>17:13</h><r>noprompt</r>The question was how to do it. <b>🙂</b>
<pre>(me/rewrite [1 2 3]
  [&amp; _ :as ?xs]
  (me/app interpose &quot; &quot; ?xs))
;; =&gt;
(1 &quot; &quot; 2 &quot; &quot; 3)</pre>
On the RHS <code>me/app</code> will apply substitution to all the arguments after the function.</z><z id="t1584724514" t="Jimmy Miller I&apos;m guessing the confusing part was the apply str and the multiple logic variables. You can always wrap functions up in a lambda or make them a defn if you want though."><y>#</y><d>2020-03-20</d><h>17:15</h><r>Jimmy Miller</r>I&apos;m guessing the confusing part was the apply str and the multiple logic variables. You can always wrap functions up in a lambda or make them a defn if you want though.</z><z id="t1584724561" t="noprompt (me/rewrite [&quot;, &quot; [1 2 3] [:a ::c]] [?sep [!xs ...] [!ys ...]] (me/app clojure.string/join (me/app interpose ?sep [!xs !ys ...]))) ;; =&gt; &quot;1, :a, 2, :b, 3, :c&quot; "><y>#</y><d>2020-03-20</d><h>17:16</h><r>noprompt</r><pre>(me/rewrite [&quot;, &quot; [1 2 3] [:a ::c]]
  [?sep [!xs ...] [!ys ...]]
  (me/app clojure.string/join (me/app interpose ?sep [!xs !ys ...])))
;; =&gt;
&quot;1, :a, 2, :b, 3, :c&quot;</pre>
</z><z id="t1584724623" t="noprompt This works but its the gross sort of thing we should be able to avoid in zeta when have all of the byte /`string` stuff off the ground."><y>#</y><d>2020-03-20</d><h>17:17</h><r>noprompt</r>This works but its the gross sort of thing we should be able to avoid in <code>zeta</code> when have all of the <code>byte</code>/`string` stuff off the ground.</z><z id="t1584778004" t="grounded_sage Thanks for the tips. It is somewhat tricky finding a nice clean solution. I did forget about string join though! Haha"><y>#</y><d>2020-03-21</d><h>08:06</h><r>grounded_sage</r>Thanks for the tips. It is somewhat tricky finding a nice clean solution. I did forget about string join though! Haha</z><z id="t1584819342" t="noprompt It’s short for apply str with no separator"><y>#</y><d>2020-03-21</d><h>19:35</h><r>noprompt</r>It’s short for <code>apply str</code> with no separator</z><z id="t1584914718" t="dominicm I may have missed this in the docs, but does m/match have different performance characteristics to m/find?"><y>#</y><d>2020-03-22</d><h>22:05</h><w>dominicm</w>I may have missed this in the docs, but does m/match have different performance characteristics to m/find?</z><z id="t1584914826" t="noprompt It shouldn’t for where they overlap."><y>#</y><d>2020-03-22</d><h>22:07</h><w>noprompt</w>It shouldn’t for where they overlap.</z><z id="t1584914873" t="dominicm (I&apos;m not seeing anything, just planning)"><y>#</y><d>2020-03-22</d><h>22:07</h><w>dominicm</w>(I&apos;m not seeing anything, just planning)</z><z id="t1584914915" t="noprompt They both use most of the same compiler stuff. Find just allows for patterns with ambiguity and picks the first."><y>#</y><d>2020-03-22</d><h>22:08</h><w>noprompt</w>They both use most of the same compiler stuff. Find just allows for patterns with ambiguity and picks the first.</z><z id="t1584914967" t="noprompt But it uses reduce or loop or whatever instead of pulling the first from a mapcat or something."><y>#</y><d>2020-03-22</d><h>22:09</h><w>noprompt</w>But it uses reduce or loop or whatever instead of pulling the first from a mapcat or something.</z><z id="t1584982528" t="grounded_sage How would you tackle this transform (m/rewrite {:Data {:FirstName &quot;Bob&quot; :CommunicationChannels [{:ChannelType {:Name &quot;EMail&quot;} :Content &quot; Such that the result is. {:first_name &quot;Bob&quot; :email &quot;"><y>#</y><d>2020-03-23</d><h>16:55</h><w>grounded_sage</w>How would you tackle this transform
<pre>(m/rewrite  {:Data
               {:FirstName &quot;Bob&quot;
                :CommunicationChannels [{:ChannelType {:Name &quot;EMail&quot;}
                                         :Content &quot;</pre>
Such that the result is.
<pre>{:first_name &quot;Bob&quot;
 :email &quot;</pre></z><z id="t1584982712" t="Jimmy Miller Is it just up to two emails and phones or n emails and phones?"><y>#</y><d>2020-03-23</d><h>16:58</h><w>Jimmy Miller</w>Is it just up to two emails and phones or n emails and phones?</z><z id="t1584982903" t="grounded_sage That is the annoying part. I am shaping it to a flat structure which goes into SQL and CSV. Perhaps a solution which has up to 2 and one that can have variable would be good."><y>#</y><d>2020-03-23</d><h>17:01</h><w>grounded_sage</w>That is the annoying part. I am shaping it to a flat structure which goes into SQL and CSV.
Perhaps a solution which has up to 2 and one that can have variable would be good.</z><z id="t1584983032" t="grounded_sage This is what exists in the db actually. phone_number, phone_number_2, mobile_number, mobile_number_2, email, email_2,"><y>#</y><d>2020-03-23</d><h>17:03</h><w>grounded_sage</w>This is what exists in the db actually.
<pre>phone_number,
   phone_number_2,
   mobile_number,
   mobile_number_2,
   email,
   email_2,</pre></z><z id="t1584983234" t="grounded_sage At present I’m not 100% sure where placement of nil values will occur. Process is. Folder full of JSON files -&gt; Meander to get values of interest -&gt; Turn into single or multiple CSV’s from that JSON -&gt; Generate db tables from CSVs -&gt; Query them with SQl and perform secondary transform with Meander if necessary."><y>#</y><d>2020-03-23</d><h>17:07</h><w>grounded_sage</w>At present I’m not 100% sure where placement of nil values will occur.
Process is.
 Folder full of JSON files
-&gt; Meander to get values of interest
-&gt; Turn into single or multiple CSV’s from that JSON
-&gt; Generate db tables from CSVs
-&gt; Query them with SQl and perform secondary transform with Meander if necessary.</z><z id="t1584983275" t="Jimmy Miller That makes it a lot easier. I won&apos;t be able to write up a solution right now. There will be a tiny complication with map ordering. But other than that I think it shouldn&apos;t be two bad. My recommendation for a first stab at it is to use or to capture the different types in different memory variables."><y>#</y><d>2020-03-23</d><h>17:07</h><w>Jimmy Miller</w>That makes it a lot easier. I won&apos;t be able to write up a solution right now. There will be a tiny complication with map ordering. But other than that I think it shouldn&apos;t be two bad. My recommendation for a first stab at it is to use or to capture the different types in different memory variables.</z><z id="t1584983596" t="grounded_sage So first Meander step is flattening JSON files and splitting up the data so it fits with the rest of our CSV etl workflow."><y>#</y><d>2020-03-23</d><h>17:13</h><w>grounded_sage</w>So first Meander step is flattening JSON files and splitting up the data so it fits with the rest of our CSV etl workflow.</z><z id="t1584983633" t="grounded_sage [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] no rush 😄"><y>#</y><d>2020-03-23</d><h>17:13</h><w>grounded_sage</w><a>@jimmy</a> no rush <b>😄</b></z><z id="t1584983731" t="grounded_sage I have a lot of other very nested JSON files so I am hoping when I see a solution it enlightens me as to how I can do the rest."><y>#</y><d>2020-03-23</d><h>17:15</h><w>grounded_sage</w>I have a lot of other very nested JSON files so I am hoping when I see a solution it enlightens me as to how I can do the rest.</z><z id="t1584991932" t="Jimmy Miller [:attrs {:href &quot;/_/_/users/U05095F2K&quot;}] (m/rewrite {:Data {:FirstName &quot;Bob&quot; :CommunicationChannels [{:ChannelType {:Name &quot;EMail&quot;} :Content &quot;"><y>#</y><d>2020-03-23</d><h>19:32</h><w>Jimmy Miller</w><a>@grounded_sage</a>
<pre>(m/rewrite {:Data
            {:FirstName &quot;Bob&quot;
             :CommunicationChannels [{:ChannelType {:Name &quot;EMail&quot;}
                                      :Content &quot;</pre></z><z id="t1585040001" t="grounded_sage Is there a reason for the vector pairs here?"><y>#</y><d>2020-03-24</d><h>08:53</h><r>grounded_sage</r>Is there a reason for the vector pairs here?</z><z id="t1585040029" t="grounded_sage As I just tried {&amp; {:first_name ?first-name, :email !emails, :email_2 !emails, :phone !phones, :phone_2 !phones}} and it appears to give the same result."><y>#</y><d>2020-03-24</d><h>08:53</h><r>grounded_sage</r>As I just tried
<pre>{&amp; {:first_name ?first-name, 
                 :email !emails, 
                 :email_2 !emails, 
                 :phone !phones, 
                 :phone_2 !phones}}</pre>
and it appears to give the same result.</z><z id="t1585058280" t="Jimmy Miller Yes because as your map grows it will be parsed out of order and the memory variables will be in the wrong place. I think it is 8 elements when that happens?"><y>#</y><d>2020-03-24</d><h>13:58</h><r>Jimmy Miller</r>Yes because as your map grows it will be parsed out of order and the memory variables will be in the wrong place. I think it is 8 elements when that happens?</z><z id="t1585075670" t="grounded_sage Ah I see."><y>#</y><d>2020-03-24</d><h>18:47</h><r>grounded_sage</r>Ah I see.</z><z id="t1584996032" t="niclasnilsson Hi! A little bit of an odd example (it’s been minimized from a much larger example). Isn’t m/app called from the action part of a match? (defn -&gt;h [v] (case v 1 {:info &quot;some info&quot;} 2 {:extra &quot;something else&quot;})) (defn foo [data] (m/match data {:a ?a :b ?b} {:foo (m/app str ?a merge {} (m/app -&gt;h ?a) (m/app -&gt;h ?b))})) (foo {:a 1 :b 2}) ;; expected ;; {:foo {:info &quot;some info&quot; :extra &quot;something else&quot;}} "><y>#</y><d>2020-03-23</d><h>20:40</h><w>niclasnilsson</w>Hi! A little bit of an odd example (it’s been minimized from a much larger example). Isn’t <code>m/app</code> called from the action part of a match?
<pre>(defn -&gt;h [v]
  (case v
    1 {:info &quot;some info&quot;}
    2 {:extra &quot;something else&quot;}))

(defn foo [data]
  (m/match
    data

    {:a ?a
     :b ?b}

    {:foo
     (m/app str ?a
       merge
       {}
       (m/app -&gt;h ?a)
       (m/app -&gt;h ?b))}))

(foo {:a 1 :b 2})

;; expected
;; {:foo {:info &quot;some info&quot; :extra &quot;something else&quot;}}</pre>
</z><z id="t1584996138" t="niclasnilsson The use case is that I have a value in the pattern part (like ?a and ?b) that I need to merge (after some transformation) in the action."><y>#</y><d>2020-03-23</d><h>20:42</h><w>niclasnilsson</w>The use case is that I have a value in the pattern part (like ?a and ?b) that I need to merge (after some transformation) in the action.</z><z id="t1584997117" t="niclasnilsson Never mind, solved it with m/rewrite !"><y>#</y><d>2020-03-23</d><h>20:58</h><w>niclasnilsson</w>Never mind, solved it with <code>m/rewrite</code>!</z><z id="t1584997329" t="niclasnilsson And then realized that it could be used with m/match using just merge , mot m/app ."><y>#</y><d>2020-03-23</d><h>21:02</h><w>niclasnilsson</w>And then realized that it could be used with <code>m/match</code> using just <code>merge</code>, mot <code>m/app</code>.</z><z id="t1584997415" t="Jimmy Miller Yeah for match the right hand side is just normal clojure code. With rewrite it is a substitution."><y>#</y><d>2020-03-23</d><h>21:03</h><w>Jimmy Miller</w>Yeah for match the right hand side is just normal clojure code. With rewrite it is a substitution.</z><z id="t1585003842" t="noprompt Just wanted to share something fun from progress being made on the zeta branch showing a properly greedy * and the concept of the fold (which is still a work in progress). (solve &apos;[1 8 2 -5 3 4] (mz/with [%min (mz/fold *min 0 clojure.core/min) %max (mz/fold *max 0 clojure.core/max)] [(mz/* (mz/and %min %max)) . !zs ...])) ;; =&gt; ({#meander.runtime.zeta/fold-variable [*min ,,,] -5, #meander.runtime.zeta/fold-variable [*max ,,,] 8, #meander.runtime.zeta/memory-variable !zs []}) "><y>#</y><d>2020-03-23</d><h>22:50</h><w>noprompt</w>Just wanted to share something fun from progress being made on the <code>zeta</code> branch showing a properly greedy <code>*</code> and the concept of the <code>fold</code> (which is still a work in progress).
<pre>(solve &apos;[1 8 2 -5 3 4]
       (mz/with [%min (mz/fold *min 0 clojure.core/min)
                 %max (mz/fold *max 0 clojure.core/max)]
         [(mz/* (mz/and %min %max)) . !zs ...]))
;; =&gt;
({#meander.runtime.zeta/fold-variable [*min ,,,] -5,
  #meander.runtime.zeta/fold-variable [*max ,,,] 8,
  #meander.runtime.zeta/memory-variable !zs []})</pre>
</z><z id="t1585003902" t="noprompt *min is -5 , *max is 8 , and !zs is empty because the greedy star ate its lunch. 🙂"><y>#</y><d>2020-03-23</d><h>22:51</h><w>noprompt</w><code>*min</code> is <code>-5</code>, <code>*max</code> is <code>8</code>, and <code>!zs</code> is empty because the greedy star ate its lunch. <b>🙂</b></z><z id="t1585084619" t="niclasnilsson The … and lists are kind of apparent, but I don’t get how to use something similar with maps. If I have an input like {:properties {:a {:type :int} :b {:type :string}} and want the result {:properties [{:name :a :type :int} {:name :b :type :string}]} What would be idiomatic meander way of doing that? The … is not apparent to me how to use in the map case. Using search, we’d get one {:properties [ . . .] } structure per property, instead of a map."><y>#</y><d>2020-03-24</d><h>21:16</h><w>niclasnilsson</w>The … and lists are kind of apparent, but I don’t get how to use something similar with maps. If I have an input like

<pre>{:properties {:a {:type :int} :b {:type :string}}</pre>
and want the result
<pre>{:properties 
 [{:name :a :type :int} {:name :b :type :string}]}</pre>
What would be idiomatic meander way of doing that? The … is not apparent to me how to use in the map case. Using search, we’d get one {:properties [ . . .] } structure per property, instead of a map.</z><z id="t1585085568" t="noprompt We just added map-of and sub map-of operators but you can also use seqable if you’re not in a situation to have multiple solutions"><y>#</y><d>2020-03-24</d><h>21:32</h><w>noprompt</w>We just added map-of and sub map-of operators but you can also use seqable if you’re not in a situation to have multiple solutions</z><z id="t1585085910" t="noprompt (m/rewrite {:properties {:a {:type :int} :b {:type :string}}} {:properties (m/map-of !name {:type !type})} {:properties [{:name !name, :type !type} ...]}) ;; =&gt; {:properties [{:name :a, :type :int} {:name :b, :type :string}]} "><y>#</y><d>2020-03-24</d><h>21:38</h><w>noprompt</w><pre>(m/rewrite {:properties {:a {:type :int} :b {:type :string}}}
  {:properties (m/map-of !name {:type !type})}
  {:properties [{:name !name, :type !type} ...]})
;; =&gt;
{:properties [{:name :a, :type :int} {:name :b, :type :string}]}</pre>
</z><z id="t1585085986" t="noprompt (m/rewrite {:properties {:a {:type :int} :b {:type :string}}} {:properties (m/seqable [!name {:type !type}] ...)} {:properties [{:name !name, :type !type} ...]}) ;; =&gt; {:properties [{:name :a, :type :int} {:name :b, :type :string}]} "><y>#</y><d>2020-03-24</d><h>21:39</h><w>noprompt</w><pre>(m/rewrite {:properties {:a {:type :int} :b {:type :string}}}
  {:properties (m/seqable [!name {:type !type}] ...)}
  {:properties [{:name !name, :type !type} ...]})
;; =&gt;
{:properties [{:name :a, :type :int} {:name :b, :type :string}]}</pre>
</z><z id="t1585086162" t="noprompt One thing we haven’t gotten around to doing is making the {&amp; [[k v] ...]} syntax work for pattern matching. It works for substitution due to the fact that &amp; is works like into"><y>#</y><d>2020-03-24</d><h>21:42</h><w>noprompt</w>One thing we haven’t gotten around to doing is making the
<pre>{&amp; [[k v] ...]}</pre>
syntax work for pattern matching. It works for substitution due to the fact that <code>&amp;</code> is works like <code>into</code></z><z id="t1585087344" t="niclasnilsson Thanks, that was much, much nicer that what we had. Will try this on deeper nested maps as well."><y>#</y><d>2020-03-24</d><h>22:02</h><w>niclasnilsson</w>Thanks, that was much, much nicer that what we had. Will try this on deeper nested maps as well.</z><z id="t1585087663" t="noprompt No problem. I’m here to help if I can. 🙂"><y>#</y><d>2020-03-24</d><h>22:07</h><w>noprompt</w>No problem. I’m here to help if I can. <b>🙂</b></z><z id="t1585133996" t="grounded_sage I keep working on the assumption that [{:key ?value} …] is the same as (m/scan {:key ?value}) Sometimes it works and sometimes it doesn’t. What am I not getting? lol"><y>#</y><d>2020-03-25</d><h>10:59</h><w>grounded_sage</w>I keep working on the assumption that <code>[{:key ?value} …]</code> is the same as <code>(m/scan {:key ?value})</code>
Sometimes it works and sometimes it doesn’t. What am I not getting? lol</z><z id="t1585142490" t="Jimmy Miller If you look at the docstring of scan you will see it is equal to [_ ... pattern . _ ...] . So unlike a simple repeat scan can skip over elements."><y>#</y><d>2020-03-25</d><h>13:21</h><r>Jimmy Miller</r>If you look at the docstring of scan you will see it is equal to <code>[_ ... pattern . _ ...]</code>. So unlike a simple repeat scan can skip over elements.</z><z id="t1585153026" t="grounded_sage Ah I see."><y>#</y><d>2020-03-25</d><h>16:17</h><r>grounded_sage</r>Ah I see.</z><z id="t1585153083" t="grounded_sage I’m starting to grok how this works. With respect to when I read the code lol. Ignore, repeat ignore, match pattern, stop point for next repeats, ignore, repeat ignore."><y>#</y><d>2020-03-25</d><h>16:18</h><r>grounded_sage</r>I’m starting to grok how this works. With respect to when I read the code lol.
Ignore, repeat ignore, match pattern, stop point for next repeats, ignore, repeat ignore.</z><z id="t1585188901" t="noprompt There’s also map-of and submap-of which will kinda sorta work like scan ."><y>#</y><d>2020-03-26</d><h>02:15</h><r>noprompt</r>There’s also <code>map-of</code> and <code>submap-of</code> which will kinda sorta work like <code>scan</code>.</z><z id="t1585195850" t="Jimmy Miller And gather which is like filter. I think many places people are using scan they could use gather and not use search."><y>#</y><d>2020-03-26</d><h>04:10</h><r>Jimmy Miller</r>And <code>gather</code> which is like filter. I think many places people are using <code>scan</code> they could use <code>gather</code> and not use search.</z><z id="t1585213616" t="grounded_sage I use cljdoc to look at documentation. Those ones are not in there. Could be due to it failing the build. [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}]"><y>#</y><d>2020-03-26</d><h>09:06</h><r>grounded_sage</r>I use cljdoc to look at documentation. Those ones are not in there. Could be due to it failing the build. <a>@U06MDAPTP</a> <a>@U5K8NTHEZ</a></z><z id="t1585230692" t="Jimmy Miller I&apos;ll fix that today. Sorry about that. You can go back one version to look at them."><y>#</y><d>2020-03-26</d><h>13:51</h><r>Jimmy Miller</r>I&apos;ll fix that today. Sorry about that. You can go back one version to look at them.</z><z id="t1585236981" t="grounded_sage All good! Appreciate all the work you guys are doing! I couldn’t imagine writing this 120 line meander function for transforming deeply nested json any other way"><y>#</y><d>2020-03-26</d><h>15:36</h><r>grounded_sage</r>All good! Appreciate all the work you guys are doing!
I couldn’t imagine writing this 120 line meander function for transforming deeply nested json any other way</z><z id="t1585238255" t="Jimmy Miller All fixed"><y>#</y><d>2020-03-26</d><h>15:57</h><r>Jimmy Miller</r>All fixed</z><z id="t1585239702" t="noprompt They’re also available in the doc folder in the repo. 🙂"><y>#</y><d>2020-03-26</d><h>16:21</h><r>noprompt</r>They’re also available in the doc folder in the repo. <b>🙂</b></z><z id="t1585243554" t="Jimmy Miller The only problem was the API docs from the doc strings."><y>#</y><d>2020-03-26</d><h>17:25</h><r>Jimmy Miller</r>The only problem was the API docs from the doc strings.</z><z id="t1585253510" t="grounded_sage I think I was also using it a bit wrong on cljdoc. Also my bad :p"><y>#</y><d>2020-03-26</d><h>20:11</h><r>grounded_sage</r>I think I was also using it a bit wrong on cljdoc. Also my bad :p</z><z id="t1585185448" t="Ethan Miller Can anyone help me understand what the error “non exhaustive pattern match” means?"><y>#</y><d>2020-03-26</d><h>01:17</h><w>Ethan Miller</w>Can anyone help me understand what the error “non exhaustive pattern match” means?</z><z id="t1585188952" t="noprompt &gt; Like `clojure.core/case`, if no patterns match an exception will be thrown. https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#match"><y>#</y><d>2020-03-26</d><h>02:15</h><r>noprompt</r>&gt; Like `clojure.core/case`, if no patterns match an exception will be thrown.
<a href="https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#match" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#match</a></z><z id="t1585194131" t="Ethan Miller Thanks!"><y>#</y><d>2020-03-26</d><h>03:42</h><r>Ethan Miller</r>Thanks!</z><z id="t1585185784" t="Jimmy Miller It means your pattern didn&apos;t match. If you copy your data and code here we can help"><y>#</y><d>2020-03-26</d><h>01:23</h><w>Jimmy Miller</w>It means your pattern didn&apos;t match. If you copy your data and code here we can help</z><z id="t1585205908" t="yuhan (m/rewrite [1 2 3] [?v ...] [?v ...]) Weird, this throws a &quot;non-exhaustive pattern match&quot; compile error"><y>#</y><d>2020-03-26</d><h>06:58</h><w>yuhan</w><pre>(m/rewrite [1 2 3]
  [?v ...]
  [?v ...])</pre>
Weird, this throws a &quot;non-exhaustive pattern match&quot; compile error</z><z id="t1585206018" t="yuhan versus the error given by m/match: (m/match [1 2 3] [?v ...] :ok) =&gt; Zero or more patterns may not have references to unbound logic variables. {:unbound #{?v}, :syntax-trace [(?v ...) [?v ...]]} (which isn&apos;t that informative either)"><y>#</y><d>2020-03-26</d><h>07:00</h><w>yuhan</w>versus the error given by m/match:
<pre>(m/match [1 2 3]
  [?v ...]
  :ok)</pre>
=&gt;
<pre>Zero or more patterns may not have references to unbound logic variables.
   {:unbound #{?v}, :syntax-trace [(?v ...) [?v ...]]}</pre>
(which isn&apos;t that informative either)</z><z id="t1585233815" t="yuhan Huh, just realised that syntax errors like (m/rewrite 1 ?a) also produce &quot;non-exhaustive pattern match&quot; errors instead of complaining about a missing subst-pattern argument. I don&apos;t recall it behaving like this before?"><y>#</y><d>2020-03-26</d><h>14:43</h><r>yuhan</r>Huh, just realised that syntax errors like
<pre>(m/rewrite 1 ?a) </pre>
also produce &quot;non-exhaustive pattern match&quot; errors instead of complaining about a missing subst-pattern argument.  I don&apos;t recall it behaving like this before?</z><z id="t1585270839" t="noprompt Hmm… yeah something seems off about that."><y>#</y><d>2020-03-27</d><h>01:00</h><r>noprompt</r>Hmm… yeah something seems off about that.</z><z id="t1585270859" t="noprompt I’ll look into it."><y>#</y><d>2020-03-27</d><h>01:00</h><r>noprompt</r>I’ll look into it.</z><z id="t1585271228" t="noprompt K"><y>#</y><d>2020-03-27</d><h>01:07</h><r>noprompt</r>K</z><z id="t1585272386" t="noprompt I figured out the cause of the bug and will release a patch shortly. The patch will resolve both of the problems you mentioned."><y>#</y><d>2020-03-27</d><h>01:26</h><r>noprompt</r>I figured out the cause of the bug and will release a patch shortly. The patch will resolve both of the problems you mentioned.</z><z id="t1585214140" t="grounded_sage What would you say is best practice for picking apart a large deeply nested json (with quite a bvit of data on the first level) transform where the end result is multiple CSV’s with id’s to relate to one another. To give context my pattern and action is a total of 138 lines in a single rewrite transform. Options layed out in front of me are. • Do a single pass with rewrite, then pass that result to some matches and searches • Do one big search where the first level data is needlessly repeated in the output.. • Do the matches and searches without using rewrite • Or do all the work in the rewrite I’m leaning towards the first or last one"><y>#</y><d>2020-03-26</d><h>09:15</h><w>grounded_sage</w>What would you say is best practice for picking apart a large deeply nested json (with quite a bvit of data on the first level) transform where the end result is multiple CSV’s with id’s to relate to one another.
To give context my pattern and action is a total of 138 lines in a single rewrite transform.

Options layed out in front of me are.
• Do a single pass with rewrite, then pass that result to some matches and searches
• Do one big search where the first level data is needlessly repeated in the output..
• Do the matches and searches without using rewrite
• Or do all the work in the rewrite
I’m leaning towards the first or last one</z><z id="t1585217004" t="grounded_sage Oh I just thought of a neat feature that would be nice. If not already in Meander.. haha. Use my pattern as my action. For quick inspection of the result."><y>#</y><d>2020-03-26</d><h>10:03</h><w>grounded_sage</w>Oh I just thought of a neat feature that would be nice. If not already in Meander.. haha.
Use my pattern as my action. For quick inspection of the result.</z><z id="t1585238361" t="Jimmy Miller Sadly not everything the exists on the left-hand-side works on the right-hand-side. So this would only work for something things."><y>#</y><d>2020-03-26</d><h>15:59</h><r>Jimmy Miller</r>Sadly not everything the exists on the left-hand-side works on the right-hand-side. So this would only work for something things.</z><z id="t1585238397" t="Jimmy Miller But in zeta we actually do have ability to generate data based on a pattern. So you can actually supply a pattern and have data automatically generated for you"><y>#</y><d>2020-03-26</d><h>15:59</h><r>Jimmy Miller</r>But in zeta we actually do have ability to generate data based on a pattern. So you can actually supply a pattern and have data automatically generated for you</z><z id="t1585238445" t="Jimmy Miller I do think we need nice inspection tools for what you’ve matched though."><y>#</y><d>2020-03-26</d><h>16:00</h><r>Jimmy Miller</r>I do think we need nice inspection tools for what you’ve matched though.</z><z id="t1585253438" t="grounded_sage Cool. Yea those things you just described sound great :)"><y>#</y><d>2020-03-26</d><h>20:10</h><r>grounded_sage</r>Cool. Yea those things you just described sound great :)</z><z id="t1585217068" t="grounded_sage I often copy paste my pattern to my action to see what the result is before I work on more custom outputs."><y>#</y><d>2020-03-26</d><h>10:04</h><w>grounded_sage</w>I often copy paste my pattern to my action to see what the result is before I work on more custom outputs.</z><z id="t1585223627" t="grounded_sage How do I go about flattening this. (m/rewrite {:Sales {:Overall {:TicketCount ?sales-ticket-count :Amount ?sales-amount} :ByCategory [{:Name !category-name :TicketCount !ticket-counts :Amount !amounts :ByReduction [{:Name !reduction-name :TicketCount !ticket-count :Amount !amount} ..!sale-reductions]} ..!sale-categories]}} {:sales-by-category [{:Name !category-name :TicketCount !ticket-counts :Amount !amounts &amp; [{:reduction-name !reduction-name :reduction-ticket-count !ticket-count :reduction-amount !amount} ..!sale-reductions]} ..!sale-categories]})"><y>#</y><d>2020-03-26</d><h>11:53</h><w>grounded_sage</w>How do I go about flattening this.
<pre>(m/rewrite
   {:Sales {:Overall {:TicketCount ?sales-ticket-count
                      :Amount ?sales-amount}
            :ByCategory [{:Name !category-name
                          :TicketCount !ticket-counts
                          :Amount !amounts
                          :ByReduction [{:Name !reduction-name
                                         :TicketCount !ticket-count
                                         :Amount !amount}
                                        ..!sale-reductions]}
                         ..!sale-categories]}}
   
   {:sales-by-category [{:Name !category-name
                         :TicketCount !ticket-counts
                         :Amount !amounts
                         &amp; [{:reduction-name !reduction-name
                             :reduction-ticket-count !ticket-count
                             :reduction-amount !amount} ..!sale-reductions]}
                        ..!sale-categories]})</pre></z><z id="t1585223645" t="grounded_sage Such that the result looks like this. {:sales-by-category [{:Name &quot;category-1&quot; :TicketCount &quot;10&quot; :Amount &quot;100&quot; :reduction-name &quot;student&quot; :reduction-ticket-count &quot;7&quot; :reduction-amount &quot;70&quot;} {:Name &quot;category-1&quot; :TicketCount &quot;10&quot; :Amount &quot;100&quot; :reduction-name &quot;senior&quot; :reduction-ticket-count &quot;3&quot; :reduction-amount &quot;30&quot;} {:Name &quot;category-2&quot; :TicketCount &quot;20&quot; :Amount &quot;200&quot; :reduction-name &quot;student&quot; :reduction-ticket-count &quot;20&quot; :reduction-amount &quot;10&quot;} ..!sale-categories]}"><y>#</y><d>2020-03-26</d><h>11:54</h><w>grounded_sage</w>Such that the result looks like this.
<pre>{:sales-by-category [{:Name &quot;category-1&quot;
                        :TicketCount &quot;10&quot;
                        :Amount &quot;100&quot;
                        :reduction-name &quot;student&quot;
                        :reduction-ticket-count &quot;7&quot;
                        :reduction-amount &quot;70&quot;}
                       {:Name &quot;category-1&quot;
                        :TicketCount &quot;10&quot;
                        :Amount &quot;100&quot;
                        :reduction-name &quot;senior&quot;
                        :reduction-ticket-count &quot;3&quot;
                        :reduction-amount &quot;30&quot;}
                       {:Name &quot;category-2&quot;
                        :TicketCount &quot;20&quot;
                        :Amount &quot;200&quot;
                        :reduction-name &quot;student&quot;
                        :reduction-ticket-count &quot;20&quot;
                        :reduction-amount &quot;10&quot;}
                       ..!sale-categories]}</pre></z><z id="t1585238575" t="Jimmy Miller If you can provide some input data as well I can more easily give you an example."><y>#</y><d>2020-03-26</d><h>16:02</h><r>Jimmy Miller</r>If you can provide some input data as well I can more easily give you an example.</z><z id="t1585238701" t="Jimmy Miller Although as I’m looking at your example it might be tricky. Not sure till I play with it."><y>#</y><d>2020-03-26</d><h>16:05</h><r>Jimmy Miller</r>Although as I’m looking at your example it might be tricky. Not sure till I play with it.</z><z id="t1585240162" t="grounded_sage Sorry. That’s my normal go to. Providing something that can be done at the repl."><y>#</y><d>2020-03-26</d><h>16:29</h><r>grounded_sage</r>Sorry. That’s my normal go to. Providing something that can be done at the repl.</z><z id="t1585240757" t="grounded_sage Here is one you can plug straight into the repl. (m/rewrite {:Sales {:Overall {:TicketCount 500 :Amount 20000} :ByCategory [{:Name &quot;Frontrow&quot; :TicketCount 200 :Amount 8000 :ByReduction [{:Name &quot;Student&quot; :TicketCount 20 :Amount 100} {:Name &quot;Senior&quot; :TicketCount 100 :Amount 289}]} {:Name &quot;Middle&quot; :TicketCount 240 :Amount 8890 :ByReduction [{:Name &quot;Student&quot; :TicketCount 220 :Amount 103} {:Name &quot;Senior&quot; :TicketCount 105 :Amount 289}]}]}} {:Sales {:Overall {:TicketCount ?sales-ticket-count :Amount ?sales-amount} :ByCategory [{:Name !category-name :TicketCount !ticket-counts :Amount !amounts :ByReduction [{:Name !reduction-name :TicketCount !ticket-count :Amount !amount} ..!sale-reductions]} ..!sale-categories]}} {:sales {:ticket-count ?sales-ticket-count :amount ?sales-amount} :sales-by-category [{:Name !category-name :TicketCount !ticket-counts :Amount !amounts &amp; [{:reduction-name !reduction-name :reduction-ticket-count !ticket-count :reduction-amount !amount}]} ..!sale-categories]})"><y>#</y><d>2020-03-26</d><h>16:39</h><r>grounded_sage</r>Here is one you can plug straight into the repl.
<pre>(m/rewrite {:Sales {:Overall {:TicketCount 500
                                :Amount 20000}
                      :ByCategory [{:Name &quot;Frontrow&quot;
                                    :TicketCount 200
                                    :Amount 8000
                                    :ByReduction [{:Name &quot;Student&quot;
                                                   :TicketCount 20
                                                   :Amount 100}
                                                  {:Name &quot;Senior&quot;
                                                   :TicketCount 100
                                                   :Amount 289}]}
                                   {:Name &quot;Middle&quot;
                                    :TicketCount 240
                                    :Amount 8890
                                    :ByReduction [{:Name &quot;Student&quot;
                                                   :TicketCount 220
                                                   :Amount 103}
                                                  {:Name &quot;Senior&quot;
                                                   :TicketCount 105
                                                   :Amount 289}]}]}}
             {:Sales {:Overall {:TicketCount ?sales-ticket-count
                                :Amount ?sales-amount}
                      :ByCategory [{:Name !category-name
                                    :TicketCount !ticket-counts
                                    :Amount !amounts
                                    :ByReduction [{:Name !reduction-name
                                                   :TicketCount !ticket-count
                                                   :Amount !amount}
                                                  ..!sale-reductions]}
                                   ..!sale-categories]}}
             
             {:sales {:ticket-count ?sales-ticket-count
                      :amount ?sales-amount}
              :sales-by-category [{:Name !category-name
                                   :TicketCount !ticket-counts
                                   :Amount !amounts
                                   &amp; [{:reduction-name !reduction-name
                                       :reduction-ticket-count !ticket-count
                                       :reduction-amount !amount}]}
                                  ..!sale-categories]})</pre></z><z id="t1585240820" t="grounded_sage I could also be approaching this entirely the wrong way and maybe that could be handled by doing another meander transform on a subset of the data."><y>#</y><d>2020-03-26</d><h>16:40</h><r>grounded_sage</r>I could also be approaching this entirely the wrong way and maybe that could be handled by doing another meander transform on a subset of the data.</z><z id="t1585247578" t="Jimmy Miller (m/rewrite data {:Name ?category-name :TicketCount ?ticket-counts :Amount ?amounts :ByReduction [{:Name !reduction-name :TicketCount !ticket-count :Amount !amount} ...]} [{:Name ?category-name :TicketCount ?ticket-counts :Amount ?amounts :reduction-name !reduction-name :reduction-ticket-count !ticket-count :reduction-amount !amount} ...] {:Sales {:Overall {:TicketCount ?sales-ticket-count :Amount ?sales-amount} :ByCategory [(m/cata [!categories ...]) ...]}} {:sales {:ticket-count ?sales-ticket-count :amount ?sales-amount} :sales-by-category [!categories ...]})"><y>#</y><d>2020-03-26</d><h>18:32</h><r>Jimmy Miller</r><pre>(m/rewrite data

  {:Name ?category-name
   :TicketCount ?ticket-counts
   :Amount ?amounts
   :ByReduction [{:Name !reduction-name
                  :TicketCount !ticket-count
                  :Amount !amount}
                 ...]}

  [{:Name ?category-name
    :TicketCount ?ticket-counts
    :Amount ?amounts
    :reduction-name !reduction-name
    :reduction-ticket-count !ticket-count
    :reduction-amount !amount}
   ...]

  {:Sales {:Overall {:TicketCount ?sales-ticket-count
                     :Amount ?sales-amount}
           :ByCategory [(m/cata [!categories ...]) ...]}}
  {:sales {:ticket-count ?sales-ticket-count
           :amount ?sales-amount}
   :sales-by-category [!categories ...]})</pre></z><z id="t1585247635" t="Jimmy Miller I couldn&apos;t think of a way of doing this without using cata."><y>#</y><d>2020-03-26</d><h>18:33</h><r>Jimmy Miller</r>I couldn&apos;t think of a way of doing this without using cata.</z><z id="t1585247688" t="Jimmy Miller Well, of course you can break it up into multiple matches. But since you want the categories to repeat, we need them not to be in memory variables. This is a good way to do that."><y>#</y><d>2020-03-26</d><h>18:34</h><r>Jimmy Miller</r>Well, of course you can break it up into multiple matches. But since you want the categories to repeat, we need them not to be in memory variables. This is a good way to do that.</z><z id="t1585247800" t="noprompt [:attrs {:href &quot;/_/_/users/U05095F2K&quot;}] How about this? https://gist.github.com/noprompt/d94e99ba0deb980d64522dba6a61600f"><y>#</y><d>2020-03-26</d><h>18:36</h><r>noprompt</r><a>@U05095F2K</a> How about this? <a href="https://gist.github.com/noprompt/d94e99ba0deb980d64522dba6a61600f" target="_blank">https://gist.github.com/noprompt/d94e99ba0deb980d64522dba6a61600f</a></z><z id="t1585247970" t="noprompt The trick here is to use cata on each item in the :ByReduction sequence to do the rewriting of those items before dumping their contents into :sales-by-category"><y>#</y><d>2020-03-26</d><h>18:39</h><r>noprompt</r>The trick here is to use <code>cata</code> on each item in the <code>:ByReduction</code> sequence to do the rewriting of those items before dumping their contents into  <code>:sales-by-category</code></z><z id="t1585248086" t="Jimmy Miller [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] lol"><y>#</y><d>2020-03-26</d><h>18:41</h><r>Jimmy Miller</r><a>@U06MDAPTP</a> lol</z><z id="t1585248451" t="noprompt OMG I just noticed Jimmy posted the same answer. 😂"><y>#</y><d>2020-03-26</d><h>18:47</h><r>noprompt</r>OMG I just noticed Jimmy posted the same answer. <b>😂</b></z><z id="t1585248895" t="grounded_sage I see. So it also doesn’t matter about the order?"><y>#</y><d>2020-03-26</d><h>18:54</h><r>grounded_sage</r>I see. So it also doesn’t matter about the order?</z><z id="t1585248958" t="noprompt In terms of the rule ordering?"><y>#</y><d>2020-03-26</d><h>18:55</h><r>noprompt</r>In terms of the rule ordering?</z><z id="t1585248999" t="grounded_sage In Jimmy’s answer he put the !categories transformations above the main pattern and action. You have it after."><y>#</y><d>2020-03-26</d><h>18:56</h><r>grounded_sage</r>In Jimmy’s answer he put the !categories transformations above the main pattern and action. You have it after.</z><z id="t1585249557" t="noprompt Oh, no, at least not in this case."><y>#</y><d>2020-03-26</d><h>19:05</h><r>noprompt</r>Oh, no, at least not in this case.</z><z id="t1585249590" t="grounded_sage I figured it out after looking at it for long enough and the reference one in the docs."><y>#</y><d>2020-03-26</d><h>19:06</h><r>grounded_sage</r>I figured it out after looking at it for long enough and the reference one in the docs.</z><z id="t1585249618" t="grounded_sage I was confused as to how it determined what datastructure is the output. But it’s the one making use of the variables of course 🙂"><y>#</y><d>2020-03-26</d><h>19:06</h><r>grounded_sage</r>I was confused as to how it determined what datastructure is the output. But it’s the one making use of the variables of course <b>🙂</b></z><z id="t1585249684" t="grounded_sage Slowly getting there lol"><y>#</y><d>2020-03-26</d><h>19:08</h><r>grounded_sage</r>Slowly getting there lol</z><z id="t1585249735" t="noprompt Awesome! 🙂"><y>#</y><d>2020-03-26</d><h>19:08</h><r>noprompt</r>Awesome! <b>🙂</b></z><z id="t1585250061" t="Jimmy Miller Yeah, in this case it doesn&apos;t matter, but it could if the patterns were overlapping. Then there are tricks to differentiate them. We use some of those tricks in zeta."><y>#</y><d>2020-03-26</d><h>19:14</h><r>Jimmy Miller</r>Yeah, in this case it doesn&apos;t matter, but it could if the patterns were overlapping. Then there are tricks to differentiate them. We use some of those tricks in zeta.</z><z id="t1585252581" t="grounded_sage Side question. What is cata short for?"><y>#</y><d>2020-03-26</d><h>19:56</h><r>grounded_sage</r>Side question. What is cata short for?</z><z id="t1585254010" t="Jimmy Miller catamorphism"><y>#</y><d>2020-03-26</d><h>20:20</h><r>Jimmy Miller</r>catamorphism</z><z id="t1585254056" t="Jimmy Miller Basically think of it like &quot;pretend I already did recursion and match on that&quot;. That is what we are doing here."><y>#</y><d>2020-03-26</d><h>20:20</h><r>Jimmy Miller</r>Basically think of it like &quot;pretend I already did recursion and match on that&quot;. That is what we are doing here.</z><z id="t1585286579" t="noprompt [meander/epsilon &quot;0.0.410&quot;] • Fixes match failure during analysis of rewrite and rewrites • Updates docstrings and argument lists for match , search , breadth-first-search , find , rewrite , and rewrites "><y>#</y><d>2020-03-27</d><h>05:22</h><w>noprompt</w><pre>[meander/epsilon &quot;0.0.410&quot;]</pre>
• Fixes match failure during analysis of <code>rewrite</code> and <code>rewrites</code>
• Updates docstrings and argument lists for <code>match</code>, <code>search</code>, <code>breadth-first-search</code>, <code>find</code>, <code>rewrite</code>, and <code>rewrites</code> </z><z id="t1585286596" t="noprompt [:attrs {:href &quot;/_/_/users/UCPS050BV&quot;}] ☝️"><y>#</y><d>2020-03-27</d><h>05:23</h><w>noprompt</w><a>@qythium</a> <b>☝️</b></z><z id="t1585286650" t="noprompt (m/rewrite [1 2 3] [?v ...] [?v ...]) ;; =&gt; ;; Zero or more patterns may not have references to unbound logic ;; variables. ;; {:unbound #{?v}, :syntax-trace [(?v ...) [?v ...]]} The errors are back. 🙂"><y>#</y><d>2020-03-27</d><h>05:24</h><w>noprompt</w><pre>(m/rewrite [1 2 3]
  [?v ...]
  [?v ...])
;; =&gt;
;; Zero or more patterns may not have references to unbound logic
;; variables.
;; {:unbound #{?v}, :syntax-trace [(?v ...) [?v ...]]}</pre>
The errors are back. <b>🙂</b></z><z id="t1585437972" t="JAtkins Can I join across sibling data? I&apos;m trying to reach the same type of data transform that I can with group-by . Short example of where I am now:"><y>#</y><d>2020-03-28</d><h>23:26</h><w>JAtkins</w>Can I join across sibling data? I&apos;m trying to reach the same type of data transform that I can with <code>group-by</code>. Short example of where I am now:</z><z id="t1585437993" t="JAtkins https://gist.github.com/JJ-Atkinson/87f7b7edcd4157af3364297bbab4c880"><y>#</y><d>2020-03-28</d><h>23:26</h><w>JAtkins</w><a href="https://gist.github.com/JJ-Atkinson/87f7b7edcd4157af3364297bbab4c880" target="_blank">https://gist.github.com/JJ-Atkinson/87f7b7edcd4157af3364297bbab4c880</a></z><z id="t1585440175" t="noprompt In this case the usual recommendation is to do the group-by first and then your processing after. (let [data [{:class :a, :numbers [10], :count? true} {:class :b :numbers [3], :count? true} {:class :a, :numbers [88], :count? true}]] (m/find (group-by :class data) {?class [(m/or {:numbers [!nums ...] :count? true} _) ...] &amp; (m/cata ?rest)} (cons {:class ?class :numbers (reduce + !nums) :count? true} ?rest) {} ())) ;; =&gt; ({:class :a, :numbers 98, :count? true} {:class :b, :numbers 3, :count? true})"><y>#</y><d>2020-03-29</d><h>00:02</h><w>noprompt</w>In this case the usual recommendation is to do the <code>group-by</code> first and then your processing after.
<pre>(let [data [{:class :a, :numbers [10], :count? true} 
            {:class :b :numbers [3], :count? true} 
            {:class :a, :numbers [88], :count? true}]]
  (m/find (group-by :class data)
    {?class [(m/or {:numbers [!nums ...] :count? true} _) ...] &amp; (m/cata ?rest)}
    (cons {:class ?class :numbers (reduce + !nums) :count? true} ?rest)

    {}
    ()))
;; =&gt;
({:class :a, :numbers 98, :count? true}
 {:class :b, :numbers 3, :count? true})</pre></z><z id="t1585440320" t="noprompt Aggregation is something that comes up a lot and we will have something specifically for it available by summer (along with other things)."><y>#</y><d>2020-03-29</d><h>00:05</h><w>noprompt</w>Aggregation is something that comes up a lot and we will have something specifically for it available by summer (along with other things).</z><z id="t1585448775" t="JAtkins Thanks for the tip!"><y>#</y><d>2020-03-29</d><h>02:26</h><w>JAtkins</w>Thanks for the tip!</z><z id="t1585482722" t="yuhan I spent some time tracking down a bug last week that turned out to be due to my use of the (and !memvar1 !memvar2) method from the cookbook for re-using a memvar in two different places in the output pattern, coupled with the ..!n syntax"><y>#</y><d>2020-03-29</d><h>11:52</h><w>yuhan</w>I spent some time tracking down a bug last week that turned out to be due to my use of the <code>(and !memvar1 !memvar2)</code>  method from the cookbook for re-using a memvar in two different places in the output pattern, coupled with the <code>..!n</code> syntax</z><z id="t1585482878" t="yuhan something like [(m/and !m1 !m2) ..!n] -&gt; {:a [!m1 ..!n] :b [!m2 ..!n]} , except nested in a much more complicated pattern"><y>#</y><d>2020-03-29</d><h>11:54</h><w>yuhan</w>something like <code>[(m/and !m1 !m2) ..!n]</code> -&gt; <code>{:a [!m1 ..!n] :b [!m2 ..!n]}</code> , except nested in a much more complicated pattern</z><z id="t1585483134" t="yuhan The bug was pretty obvious once discovered but it occured to me that such constructs can be pretty hard to reason about in subtle ways.. with an imperative flavour of pushing and popping from arrays and keeping track of indices"><y>#</y><d>2020-03-29</d><h>11:58</h><w>yuhan</w>The bug was pretty obvious once discovered but it occured to me that such constructs can be pretty hard to reason about in subtle ways.. with an imperative flavour of pushing and popping from arrays and keeping track of indices</z><z id="t1585492388" t="yuhan The next logical step is asking whether there exists some sort of ..(and !n1 !n2) syntax , but that just seems like a further step in the wrong direction.."><y>#</y><d>2020-03-29</d><h>14:33</h><w>yuhan</w>The next logical step is asking whether there exists some sort of  <code>..(and !n1 !n2)</code>  syntax , but that just seems like a further step in the wrong direction..</z><z id="t1585492528" t="yuhan really the [[!x ..!n] ...] syntax is a way of fitting multidimensional data into a linear memory variable, I wonder if there could be a less clunky way of encoding this"><y>#</y><d>2020-03-29</d><h>14:35</h><w>yuhan</w>really the <code>[[!x ..!n] ...]</code> syntax is a way of fitting multidimensional data into a linear memory variable, I wonder if there could be a less clunky way of encoding this</z><z id="t1585499686" t="Jimmy Miller With fold and unfold we will have more power to implement better ways of doing these things. But my recommendation is also to dream up your ideal way and share it. Maybe it will be implemented or maybe it will spark other with more ideas."><y>#</y><d>2020-03-29</d><h>16:34</h><w>Jimmy Miller</w>With fold and unfold we will have more power to implement better ways of doing these things. But my recommendation is also to dream up your ideal way and share it. Maybe it will be implemented or maybe it will spark other with more ideas.</z><z id="t1585500257" t="noprompt Ideas are absolutely welcome."><y>#</y><d>2020-03-29</d><h>16:44</h><w>noprompt</w>Ideas are absolutely welcome.</z><z id="t1585502433" t="niclasnilsson Question about variable number of forms: ;; This works: (def data &apos;((path &quot;/a&quot; (PUT &quot;Updates A&quot;)) (path &quot;/b&quot; (GET &quot;Gets a B&quot;)))) (m/rewrite data ((path !path (!method !desc)) ..!paths) [{:path !path :routes {:method !method :desc !desc}} ..!paths]) ;; But this was harder, when adding more routes to a path: (def data &apos;((path &quot;/a&quot; (PUT &quot;Updates A&quot;)) (path &quot;/b&quot; (PUT &quot;Gets a B&quot;) (PUT &quot;Updates B&quot;)))) ;; Desired output [{:path &quot;/a&quot; :routes [{:method &apos;PUT :desc &quot;Updates A&quot;}]} {:path &quot;/b&quot; :routes [{:method &apos;GET :desc &quot;Gets a B&quot;} {:method &apos;PUT :desc &quot;Updates B&quot;}]}] I’ve tried to make it seqable and some other things, but can’t find the way to make this work. What am I missing?"><y>#</y><d>2020-03-29</d><h>17:20</h><w>niclasnilsson</w>Question about variable number of forms:

<pre>;; This works:
(def data
  &apos;((path &quot;/a&quot; 
          (PUT &quot;Updates A&quot;))
    (path &quot;/b&quot; 
          (GET &quot;Gets a B&quot;))))

(m/rewrite 
  data
  ((path !path (!method !desc)) ..!paths)
  [{:path !path
    :routes 
    {:method !method
     :desc !desc}} ..!paths])
  
;; But this was harder, when adding more routes to a path:
(def data
  &apos;((path &quot;/a&quot; 
          (PUT &quot;Updates A&quot;))
    (path &quot;/b&quot; 
          (PUT &quot;Gets a B&quot;)
          (PUT &quot;Updates B&quot;))))

;; Desired output
[{:path &quot;/a&quot; :routes [{:method &apos;PUT :desc &quot;Updates A&quot;}]}
 {:path &quot;/b&quot; :routes [{:method &apos;GET :desc &quot;Gets a B&quot;}
                      {:method &apos;PUT :desc &quot;Updates B&quot;}]}] </pre>
I’ve tried to make it seqable and some other things, but can’t find the way to make this work. What am I missing?</z><z id="t1585505745" t="noprompt [:attrs {:href &quot;/_/_/users/U48DE3SHM&quot;}] (let [data &apos;((path &quot;/a&quot; (PUT &quot;Updates A&quot;)) (path &quot;/b&quot; (PUT &quot;Gets a B&quot;) (PUT &quot;Updates B&quot;)))] (m/rewrite data ((path !path . (!method !desc) ..!routes) ..!paths) [{:path !path :routes [{:method !method :desc !desc} ..!routes]} ..!paths])) ;; =&gt; [{:path &quot;/a&quot;, :routes [{:method PUT, :desc &quot;Updates A&quot;}]} {:path &quot;/b&quot;, :routes [{:method PUT, :desc &quot;Gets a B&quot;} {:method PUT, :desc &quot;Updates B&quot;}]}] "><y>#</y><d>2020-03-29</d><h>18:15</h><w>noprompt</w><a>@niclasnilsson</a>
<pre>(let [data
      &apos;((path &quot;/a&quot; 
              (PUT &quot;Updates A&quot;))
        (path &quot;/b&quot; 
              (PUT &quot;Gets a B&quot;)
              (PUT &quot;Updates B&quot;)))]
  (m/rewrite 
    data
    ((path !path . (!method !desc) ..!routes) ..!paths)
    [{:path !path
      :routes [{:method !method
                :desc !desc} ..!routes]} ..!paths]))
;; =&gt;
[{:path &quot;/a&quot;,
  :routes [{:method PUT, :desc &quot;Updates A&quot;}]}
 {:path &quot;/b&quot;,
  :routes [{:method PUT, :desc &quot;Gets a B&quot;}
           {:method PUT, :desc &quot;Updates B&quot;}]}]</pre>
</z><z id="t1585506456" t="noprompt Keep in mind you can always use cata to do nested transforms with separate rules rather than all in one shot."><y>#</y><d>2020-03-29</d><h>18:27</h><w>noprompt</w>Keep in mind you can always use <code>cata</code> to do nested transforms with separate rules rather than all in one shot.</z><z id="t1585507459" t="niclasnilsson Ah… I was more or less in dot from finding the solution then! Close, but no cigar! 🙂 Thank you very much, [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] !"><y>#</y><d>2020-03-29</d><h>18:44</h><w>niclasnilsson</w>Ah… I was more or less in dot from finding the solution then! Close, but no cigar! <b>🙂</b> Thank you very much, <a>@noprompt</a>!</z><z id="t1585620139" t="yuhan Is this a bug? (m/rewrite {} {:k (m/seqable !x ..!n)} {:k [!x ..!n]}) ;; =&gt; {:k []} (m/rewrite [{}] [{:k (m/seqable !x ..!n)} ...] [{:k [!x ..!n]} ...]) ;; =&gt; []"><y>#</y><d>2020-03-31</d><h>02:02</h><w>yuhan</w>Is this a bug?
<pre>(m/rewrite {}
  {:k (m/seqable !x ..!n)}
  {:k [!x ..!n]})
;; =&gt; {:k []}

(m/rewrite [{}]
  [{:k (m/seqable !x ..!n)} ...]
  [{:k [!x ..!n]} ...])
;; =&gt; []</pre></z><z id="t1585685274" t="timothypratley [:attrs {:href &quot;/_/_/users/UCPS050BV&quot;}] [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] FWIW just wanted to add my 2c that I’ve encountered this and found that using named collectors is usually the ticket in my usage: (m/rewrite [{}] [{:k (m/seqable !x ..!n)} ...] [{:k [!x ..!n]} ...]) =&gt; [] (m/rewrite [{}] [{:k (m/seqable !x ..!n)} ..!m] [{:k [!x ..!n]} ..!m]) =&gt; [{:k []}] To me this seemed logical because I think of … as disperse everything without context. /shrug"><y>#</y><d>2020-03-31</d><h>20:07</h><r>timothypratley</r><a>@qythium</a> <a>@U06MDAPTP</a> FWIW just wanted to add my 2c that I’ve encountered this and found that using named collectors is usually the ticket in my usage:
<pre>(m/rewrite [{}]
         [{:k (m/seqable !x ..!n)} ...]
         [{:k [!x ..!n]} ...])
=&gt; []
(m/rewrite [{}]
         [{:k (m/seqable !x ..!n)} ..!m]
         [{:k [!x ..!n]} ..!m])
=&gt; [{:k []}]</pre>
To me this seemed logical because I think of <code>…</code> as disperse everything without context. /shrug</z><z id="t1585620198" t="yuhan Based on the first result I would expect the second to produce [{:k []}]"><y>#</y><d>2020-03-31</d><h>02:03</h><w>yuhan</w>Based on the first result I would expect the second to produce <code>[{:k []}]</code></z><z id="t1585624130" t="noprompt [:attrs {:href &quot;/_/_/users/UCPS050BV&quot;}] I think so. This probably has something to do with how … compiles."><y>#</y><d>2020-03-31</d><h>03:08</h><w>noprompt</w><a>@qythium</a> I think so. This probably has something to do with how <code>…</code> compiles.</z><z id="t1585624301" t="noprompt This is the line: https://github.com/noprompt/meander/blob/epsilon/src/meander/substitute/epsilon.cljc#L334"><y>#</y><d>2020-03-31</d><h>03:11</h><w>noprompt</w>This is the line: <a href="https://github.com/noprompt/meander/blob/epsilon/src/meander/substitute/epsilon.cljc#L334" target="_blank">https://github.com/noprompt/meander/blob/epsilon/src/meander/substitute/epsilon.cljc#L334</a></z><z id="t1585624328" t="noprompt There’s a runtime check to see if the memory variables have been exhausted."><y>#</y><d>2020-03-31</d><h>03:12</h><w>noprompt</w>There’s a runtime check to see if the memory variables have been exhausted.</z><z id="t1585624363" t="yuhan I think I&apos;ll just avoid the ..!n construct entirely for now... it seemed so useful at first but it&apos;s just been a source of bugs and headaches 😕"><y>#</y><d>2020-03-31</d><h>03:12</h><w>yuhan</w>I think I&apos;ll just avoid the <code>..!n</code>  construct entirely for now... it seemed so useful at first but it&apos;s just been a source of bugs and headaches <b>😕</b></z><z id="t1585624436" t="noprompt I’m sorry about that and I agree with you."><y>#</y><d>2020-03-31</d><h>03:13</h><w>noprompt</w>I’m sorry about that and I agree with you.</z><z id="t1585624555" t="noprompt FWIW I’m working to make these problems go away."><y>#</y><d>2020-03-31</d><h>03:15</h><w>noprompt</w>FWIW I’m working to make these problems go away.</z><z id="t1585624607" t="noprompt But in this case its not the ..!n that is the problem its actually the … in this case."><y>#</y><d>2020-03-31</d><h>03:16</h><w>noprompt</w>But in this case its not the <code>..!n</code> that is the problem its actually the <code>…</code> in this case.</z><z id="t1585624626" t="yuhan no discouragement intended!"><y>#</y><d>2020-03-31</d><h>03:17</h><w>yuhan</w>no discouragement intended!</z><z id="t1585624627" t="noprompt Memory variables do not have this problem on zeta ."><y>#</y><d>2020-03-31</d><h>03:17</h><w>noprompt</w>Memory variables do not have this problem on <code>zeta</code>.</z><z id="t1585624646" t="noprompt Nor does … ."><y>#</y><d>2020-03-31</d><h>03:17</h><w>noprompt</w>Nor does <code>…</code>.</z><z id="t1585624682" t="noprompt I think the mistake I made in epsilon down is trying to bind everything in Clojure."><y>#</y><d>2020-03-31</d><h>03:18</h><w>noprompt</w>I think the mistake I made in <code>epsilon</code> down is trying to bind everything in Clojure.</z><z id="t1585624718" t="noprompt The code comes out fast but its also been harder to debug."><y>#</y><d>2020-03-31</d><h>03:18</h><w>noprompt</w>The code comes out fast but its also been harder to debug.</z><z id="t1585624756" t="noprompt In zeta I decided to manage the bindings at runtime with a map."><y>#</y><d>2020-03-31</d><h>03:19</h><w>noprompt</w>In <code>zeta</code> I decided to manage the bindings at runtime with a map.</z><z id="t1585624816" t="noprompt Its slightly slower to execute a zeta pattern match but its also much easier to manage and iteratively improve than starting at the lowest level first."><y>#</y><d>2020-03-31</d><h>03:20</h><w>noprompt</w>Its slightly slower to execute a <code>zeta</code> pattern match but its also much easier to manage and iteratively improve than starting at the lowest level first.</z><z id="t1585624959" t="yuhan What slightly worries me about Zeta&apos;s bootstrapping is that if there are still correctness issues with the epsilon logic that&apos;s used to compile it, will that mean that it&apos;s all going to be a black box built on a uncertain foundation?"><y>#</y><d>2020-03-31</d><h>03:22</h><w>yuhan</w>What slightly worries me about Zeta&apos;s bootstrapping is that if there are still correctness issues with the epsilon logic that&apos;s used to compile it, will that mean that it&apos;s all going to be a black box built on a uncertain foundation?</z><z id="t1585625114" t="noprompt I think thats a valid concern and thats why I patch epsilon ."><y>#</y><d>2020-03-31</d><h>03:25</h><w>noprompt</w>I think thats a valid concern and thats why I patch <code>epsilon</code>.</z><z id="t1585625183" t="noprompt There’s little use of ..!n at the moment."><y>#</y><d>2020-03-31</d><h>03:26</h><w>noprompt</w>There’s little use of <code>..!n</code> at the moment.</z><z id="t1585625299" t="noprompt 90% of the parser/compiler stuff is built with logic variables. I do use a handful of memory variables but there’s no nesting."><y>#</y><d>2020-03-31</d><h>03:28</h><w>noprompt</w>90% of the parser/compiler stuff is built with logic variables. I do use a handful of memory variables but there’s no nesting.</z><z id="t1585625344" t="noprompt I’ll think about the best way to fix that bug in epsilon ."><y>#</y><d>2020-03-31</d><h>03:29</h><w>noprompt</w>I’ll think about the best way to fix that bug in <code>epsilon</code>.</z><z id="t1585625358" t="noprompt If you have an idea for a patch that’d be good."><y>#</y><d>2020-03-31</d><h>03:29</h><w>noprompt</w>If you have an idea for a patch that’d be good.</z><z id="t1585625371" t="noprompt I’m not sure if swapping out an or would be safe or not."><y>#</y><d>2020-03-31</d><h>03:29</h><w>noprompt</w>I’m not sure if swapping out an <code>or</code> would be safe or not.</z><z id="t1585625504" t="yuhan Thanks! I probably can&apos;t help here, don&apos;t know much about the internals"><y>#</y><d>2020-03-31</d><h>03:31</h><w>yuhan</w>Thanks! I probably can&apos;t help here, don&apos;t know much about the internals</z><z id="t1585625597" t="noprompt Thats fine. But I hope it gives you confidence know that I’m not trying to cut corners."><y>#</y><d>2020-03-31</d><h>03:33</h><w>noprompt</w>Thats fine. But I hope it gives you confidence know that I’m not trying to cut corners.</z><z id="t1585625650" t="noprompt The logic makes sense as: If epsilon has a bug And zeta uses epsilon to build zeta Then epsilon should be patched 🙂"><y>#</y><d>2020-03-31</d><h>03:34</h><w>noprompt</w>The logic makes sense as:

If <code>epsilon</code> has a bug
And <code>zeta</code> uses <code>epsilon</code> to build <code>zeta</code>
Then <code>epsilon</code> should be patched

<b>🙂</b></z><z id="t1585625661" t="noprompt QED"><y>#</y><d>2020-03-31</d><h>03:34</h><w>noprompt</w>QED</z><z id="t1585625663" t="noprompt 😛"><y>#</y><d>2020-03-31</d><h>03:34</h><w>noprompt</w><b>😛</b></z><z id="t1585625696" t="noprompt And, also, I kind of depend on bug reports."><y>#</y><d>2020-03-31</d><h>03:34</h><w>noprompt</w>And, also, I kind of depend on bug reports.</z><z id="t1585625745" t="yuhan will provide as many as I can 🙂"><y>#</y><d>2020-03-31</d><h>03:35</h><w>yuhan</w>will provide as many as I can <b>🙂</b></z><z id="t1585625872" t="yuhan unrelated question, what&apos;s the best way of providing &quot;default&quot; values for variables? (m/rewrite {} {:k ?v} {:k ~(or ?v :default)}) "><y>#</y><d>2020-03-31</d><h>03:37</h><w>yuhan</w>unrelated question, what&apos;s the best way of providing &quot;default&quot; values for variables?
<pre>(m/rewrite {}
  {:k ?v}
  {:k ~(or ?v :default)})</pre>
</z><z id="t1585625904" t="yuhan this works for logic vars but gives an error on (m/rewrite [{}] [{:k !v} ...] [{:k ~(or !v :default)} ...])"><y>#</y><d>2020-03-31</d><h>03:38</h><w>yuhan</w>this works for logic vars but gives an error on
<pre>(m/rewrite [{}]
  [{:k !v} ...]
  [{:k ~(or !v :default)} ...])</pre></z><z id="t1585626709" t="noprompt There’s always (m/or pattern-containing-?x (m/let [?x :default])) "><y>#</y><d>2020-03-31</d><h>03:51</h><w>noprompt</w>There’s always
<pre>(m/or pattern-containing-?x (m/let [?x :default]))</pre>
</z><z id="t1585626780" t="noprompt Or {:k (m/or (m/and nil (m/let [?x :default])) ?x} "><y>#</y><d>2020-03-31</d><h>03:53</h><w>noprompt</w>Or
<pre>{:k (m/or (m/and nil (m/let [?x :default]))
          ?x}</pre>
</z><z id="t1585626833" t="yuhan That doesn&apos;t seem to work for mem vars as well?"><y>#</y><d>2020-03-31</d><h>03:53</h><w>yuhan</w>That doesn&apos;t seem to work for mem vars as well?</z><z id="t1585626852" t="yuhan (m/rewrite [{}] [{:k (m/or !v (m/let [!v :default]))} ...] [{:k !v} ...]) ;; =&gt; [{:k nil}]"><y>#</y><d>2020-03-31</d><h>03:54</h><w>yuhan</w><pre>(m/rewrite [{}]
  [{:k (m/or !v (m/let [!v :default]))} ...]
  [{:k !v} ...])
;; =&gt; [{:k nil}]</pre></z><z id="t1585626927" t="noprompt (me/rewrite [{}] [{:k (me/or (me/let [!v :default]) !v)} ...] [{:k !v} ...]) ;; =&gt; [{:k :default}] "><y>#</y><d>2020-03-31</d><h>03:55</h><w>noprompt</w><pre>(me/rewrite [{}]
  [{:k (me/or (me/let [!v :default]) !v)} ...]
  [{:k !v} ...])
;; =&gt;
[{:k :default}]</pre>
</z><z id="t1585626985" t="noprompt !v is [nil] in your example cause !v is matched against (get m :k)"><y>#</y><d>2020-03-31</d><h>03:56</h><w>noprompt</w><code>!v</code> is <code>[nil]</code> in your example cause <code>!v</code> is matched against <code>(get m :k)</code></z><z id="t1585626992" t="yuhan but that binds all !v to :default"><y>#</y><d>2020-03-31</d><h>03:56</h><w>yuhan</w>but that binds all <code>!v</code> to :default</z><z id="t1585627008" t="yuhan (m/rewrite [{:k :exists} {}] [{:k (m/or (m/let [!v :default]) !v)} ...] [{:k !v} ...]) ;; =&gt; [{:k :default} {:k :default}]"><y>#</y><d>2020-03-31</d><h>03:56</h><w>yuhan</w><pre>(m/rewrite [{:k :exists} {}]
  [{:k (m/or (m/let [!v :default]) !v)} ...]
  [{:k !v} ...])
;; =&gt; [{:k :default} {:k :default}]</pre></z><z id="t1585627032" t="noprompt You want something like the example I gave (m/or (m/and nil (m/let [!v :default])) !v) "><y>#</y><d>2020-03-31</d><h>03:57</h><w>noprompt</w>You want something like the example I gave
<pre>(m/or (m/and nil (m/let [!v :default]))
      !v)</pre>
</z><z id="t1585627065" t="noprompt (me/rewrite [{} {:k &quot;i have a value&quot;}] [{:k (me/or (me/and nil (me/let [!v :default])) !v)} ...] [{:k !v} ...]) ;; =&gt; [{:k :default} {:k &quot;i have a value&quot;}] "><y>#</y><d>2020-03-31</d><h>03:57</h><w>noprompt</w><pre>(me/rewrite [{} {:k &quot;i have a value&quot;}]
  [{:k (me/or (me/and nil (me/let [!v :default])) !v)} ...]
  [{:k !v} ...])
;; =&gt;
[{:k :default} {:k &quot;i have a value&quot;}]</pre>
</z><z id="t1585627108" t="noprompt You could do (me/defsyntax default [match p clojure-expr] `(me/or (me/and ~match (me/let [~p ~clojure-expr])) ~p)) with maybe better name."><y>#</y><d>2020-03-31</d><h>03:58</h><w>noprompt</w>You could do
<pre>(me/defsyntax default [match p clojure-expr]
  `(me/or (me/and ~match (me/let [~p ~clojure-expr])) ~p))</pre>
with maybe  better name.</z><z id="t1585627164" t="noprompt (default nil ?x :default) If the value matches nil pattern match ?x against :default otherwise pattern match with ?x ."><y>#</y><d>2020-03-31</d><h>03:59</h><w>noprompt</w><pre>(default nil ?x :default)</pre>
If the value matches <code>nil</code> pattern match <code>?x</code> against <code>:default</code> otherwise pattern match with <code>?x</code>.</z><z id="t1585627323" t="yuhan nice, thanks!"><y>#</y><d>2020-03-31</d><h>04:02</h><w>yuhan</w>nice, thanks!</z><z id="t1585628803" t="noprompt Just noticed I wrote (or (or ,,,) ,,,) when I meant (or (and ,,,) ,,,)"><y>#</y><d>2020-03-31</d><h>04:26</h><w>noprompt</w>Just noticed I wrote <code>(or (or ,,,) ,,,)</code> when I meant <code>(or (and ,,,) ,,,)</code></z><z id="t1585629707" t="noprompt [:attrs {:href &quot;/_/_/users/UCPS050BV&quot;}] by switching that and to an or in the substitution compiler I get (rewrite [{}] [{:k (seqable !x ..!n)} ...] [{:k [!x ..!n]} ...]) ;; =&gt; [{:k []}] "><y>#</y><d>2020-03-31</d><h>04:41</h><w>noprompt</w><a>@qythium</a> by switching that <code>and</code> to an <code>or</code> in the substitution compiler I get
<pre>(rewrite [{}]
  [{:k (seqable !x ..!n)} ...]
  [{:k [!x ..!n]} ...])
;; =&gt;
[{:k []}]</pre>
</z><z id="t1585629731" t="noprompt And (rewrite {} {:k (seqable !x ..!n)} {:k [!x ..!n]}) ;; =&gt; {:k []} "><y>#</y><d>2020-03-31</d><h>04:42</h><w>noprompt</w>And
<pre>(rewrite {}
  {:k (seqable !x ..!n)}
  {:k [!x ..!n]})
;; =&gt;
{:k []}</pre>
</z><z id="t1585629869" t="noprompt There are two failures though FAIL in meander.epsilon-test/subst-mvr-rp*-test (epsilon_test.cljc:2023) expected: [[1 :a] [2 :b]] actual: [[1 :a] [2 :b] [3 nil]] diff: + [nil nil [3 nil]] FAIL in meander.epsilon-test/subst-mvr-rp*-test (epsilon_test.cljc:2025) expected: [[:a 1] [:b 2]] actual: [[:a 1] [:b 2] [nil 3]] diff: + [nil nil [nil 3]] from these tests (let [!1s [1 2 3] !2s [:a :b]] ,,, (t/is (= [[1 :a] [2 :b]] (r/subst [[!1s !2s] ...]))) (t/is (= [[:a 1] [:b 2]] (r/subst [[!2s !1s] ...]))) "><y>#</y><d>2020-03-31</d><h>04:44</h><w>noprompt</w>There are two failures though
<pre>FAIL in meander.epsilon-test/subst-mvr-rp*-test (epsilon_test.cljc:2023)
expected: [[1 :a] [2 :b]]
  actual: [[1 :a] [2 :b] [3 nil]]
    diff: + [nil nil [3 nil]]

FAIL in meander.epsilon-test/subst-mvr-rp*-test (epsilon_test.cljc:2025)
expected: [[:a 1] [:b 2]]
  actual: [[:a 1] [:b 2] [nil 3]]
    diff: + [nil nil [nil 3]]</pre>
from these tests
<pre>(let [!1s [1 2 3]
      !2s [:a :b]]
  ,,,
  (t/is (= [[1 :a] [2 :b]]
           (r/subst [[!1s !2s] ...])))
  (t/is (= [[:a 1] [:b 2]]
           (r/subst [[!2s !1s] ...])))</pre>
</z><z id="t1585630006" t="noprompt Maybe the check should only be looking at memory variables that are top-level to the …"><y>#</y><d>2020-03-31</d><h>04:46</h><w>noprompt</w>Maybe the check should only be looking at memory variables that are top-level to the <code>…</code></z><z id="t1585630283" t="noprompt Eh, but actually, I don’t think thats right either."><y>#</y><d>2020-03-31</d><h>04:51</h><w>noprompt</w>Eh, but actually, I don’t think thats right either.</z><z id="t1585682468" t="noprompt Would m/recur be a better name than m/cata ?"><y>#</y><d>2020-03-31</d><h>19:21</h><w>noprompt</w>Would <code>m/recur</code> be a better name than <code>m/cata</code>?</z><z id="t1585683600" t="markaddleman I vote yes"><y>#</y><d>2020-03-31</d><h>19:40</h><r>markaddleman</r>I vote yes</z><z id="t1585684889" t="timothypratley +1"><y>#</y><d>2020-03-31</d><h>20:01</h><r>timothypratley</r>+1</z><z id="t1585966315" t="markaddleman Trying to up my meander game.: (m/rewrite {:g1 [{:k :a :v 1} {:k :b :v 2}] :g2 [{:k :b :v 2} {:k :a :v 1}]} (m/and {:g1 (m/seqable {:k !k :v !v1} ...) :g2 (m/seqable {:k !k :v !v2} ...)}) [!k (m/app + !v1 !v2) ...]) I&apos;d like the result to be [:a 2 :b 4 but meander is walking the two seqs independently. How do I get a join on :k ?"><y>#</y><d>2020-04-04</d><h>02:11</h><w>markaddleman</w>Trying to up my meander game.:
<pre>(m/rewrite {:g1 [{:k :a :v 1} {:k :b :v 2}]
              :g2 [{:k :b :v 2} {:k :a :v 1}]}

             (m/and
               {:g1 (m/seqable {:k !k :v !v1} ...)
                :g2 (m/seqable {:k !k :v !v2} ...)})
             [!k (m/app + !v1 !v2) ...])</pre>
I&apos;d like the result  to be <code>[:a 2 :b 4</code>  but meander is walking the two seqs independently.   How do I get a join on :k ?</z><z id="t1586028753" t="noprompt (m/rewrite {:g1 [{:k :a :v 1} {:k :b :v 2}] :g2 [{:k :b :v 2} {:k :a :v 1} {:k :b :v 3}]} {:g1 (m/seqable !g1s ...) :g2 (m/seqable !g2s ...)} (m/cata [!g1s ... !g2s ...]) [] [] (m/with [%m {:k ?k :v !v}] [%m . (m/or %m !not-m) ...]) [?k ~(reduce + !v) &amp; (m/cata [!not-m ...])]) ;; =&gt; [:a 2 :b 7]"><y>#</y><d>2020-04-04</d><h>19:32</h><r>noprompt</r><pre>(m/rewrite {:g1 [{:k :a :v 1} {:k :b :v 2}]
            :g2 [{:k :b :v 2} {:k :a :v 1} {:k :b :v 3}]}
  {:g1 (m/seqable !g1s ...)
   :g2 (m/seqable !g2s ...)}
  (m/cata [!g1s ... !g2s ...])

  [] []

  (m/with [%m {:k ?k
                :v !v}]
    [%m . (m/or %m !not-m) ...])
  [?k ~(reduce + !v) &amp; (m/cata [!not-m ...])])
;; =&gt;
[:a 2 :b 7]</pre></z><z id="t1586028819" t="noprompt There are probably few other ways to do this."><y>#</y><d>2020-04-04</d><h>19:33</h><r>noprompt</r>There are probably few other ways to do this.</z><z id="t1586029076" t="noprompt Again, this is another place where the zeta fold will come in handy."><y>#</y><d>2020-04-04</d><h>19:37</h><r>noprompt</r>Again, this is another place where the  <code>zeta</code>  fold will come in handy.</z><z id="t1586034924" t="markaddleman Thanks!"><y>#</y><d>2020-04-04</d><h>21:15</h><r>markaddleman</r>Thanks!</z><z id="t1586116988" t="noprompt (defn indexed* [coll] (map-indexed vector coll)) (me/defsyntax indexed [&amp; patterns] `(me/and (me/pred seqable?) (me/app indexed* (~@patterns)))) Has anyone done something similar to this? ☝️"><y>#</y><d>2020-04-05</d><h>20:03</h><w>noprompt</w><pre>(defn indexed* [coll]
  (map-indexed vector coll))

(me/defsyntax indexed [&amp; patterns]
  `(me/and (me/pred seqable?)
           (me/app indexed* (~@patterns))))</pre>
Has anyone done something similar to this? <b>☝️</b></z><z id="t1586117184" t="noprompt I think someone had asked about how to do something like this before."><y>#</y><d>2020-04-05</d><h>20:06</h><w>noprompt</w>I think someone had asked about how to do something like this before.</z><z id="t1586182157" t="grounded_sage How would I rewrite a single vector in an arbitrarily nested vector? I want to add some properties to a Malli schema."><y>#</y><d>2020-04-06</d><h>14:09</h><w>grounded_sage</w>How would I rewrite a single vector in an arbitrarily nested vector? I want to add some properties to a Malli schema.</z><z id="t1586190404" t="noprompt You can do it with $"><y>#</y><d>2020-04-06</d><h>16:26</h><r>noprompt</r>You can do it with <code>$</code></z><z id="t1586190407" t="noprompt (me/rewrite &apos;[:A [:B [:C 1 2] [:C 3 [:D 4 5]]] [:B [:C 6 7] [:C 8 [:D 9 10]]]] (me/$ ?loc [:D 4 5 :as ?D]) (me/$ ?loc [:D YOU WIN])) ;; =&gt; [:A [:B [:C 1 2] [:C 3 [:D YOU WIN]]] [:B [:C 6 7] [:C 8 [:D 9 10]]]] "><y>#</y><d>2020-04-06</d><h>16:26</h><r>noprompt</r><pre>(me/rewrite &apos;[:A
              [:B [:C 1 2] [:C 3 [:D 4 5]]]
              [:B [:C 6 7] [:C 8 [:D 9 10]]]]
  (me/$ ?loc [:D 4 5 :as ?D])
  (me/$ ?loc [:D YOU WIN]))
;; =&gt;
[:A
 [:B [:C 1 2] [:C 3 [:D YOU WIN]]]
 [:B [:C 6 7] [:C 8 [:D 9 10]]]]</pre>
</z><z id="t1586190440" t="noprompt Or like [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] said, you can use strategies."><y>#</y><d>2020-04-06</d><h>16:27</h><r>noprompt</r>Or like <a>@U5K8NTHEZ</a> said, you can use strategies.</z><z id="t1586196663" t="grounded_sage I found out that there is an updating function built in so I went with that in the end."><y>#</y><d>2020-04-06</d><h>18:11</h><r>grounded_sage</r>I found out that there is an updating function built in so I went with that in the end.</z><z id="t1586190365" t="Jimmy Miller Strategies are the best thing we have for this right now."><y>#</y><d>2020-04-06</d><h>16:26</h><w>Jimmy Miller</w>Strategies are the best thing we have for this right now.</z><z id="t1586631881" t="nlessa Hi! Is there a restrinction using with operator in a defsyntax ? I tried something like this: (me/defsyntax g1 [] `(me/with [%e-entidade (me/or (= e (me/pred unificador? ?e)) (= (me/pred unificador? ?e) e)) %a-atributo (me/or (= a (me/pred keyword? ?a)) (= (me/pred keyword? ?a) a))] [%e-entidade %a-atributo])) And using in (def test (ms/rewrite (g1) [?e ?a] I get an Syntax error macroexpanding meander.match.epsilon/find with binding form must be a simple symbol the name of which begins with &quot;%&quot; But if copy-paste tge code of g1 runs fine (def test-2 (ms/rewrite (me/with [%e-entidade (me/or (= e (me/pred unificador? ?e)) (= (me/pred unificador? ?e) e)) %a-atributo (me/or (= a (me/pred keyword? ?a)) (= (me/pred keyword? ?a) a))] [%e-entidade %a-atributo]) [?e ?a])) Is it a restriction of defsyntax using with or am I making a mistake?"><y>#</y><d>2020-04-11</d><h>19:04</h><w>nlessa</w>Hi! Is there a restrinction using <code>with</code> operator in a <code>defsyntax</code>?
I tried something like this:
<pre>(me/defsyntax g1 [] `(me/with [%e-entidade (me/or (= e (me/pred unificador? ?e))
                                                  (= (me/pred unificador? ?e) e))
                               %a-atributo (me/or (= a (me/pred keyword? ?a))
                                                  (= (me/pred keyword? ?a) a))]
                              [%e-entidade %a-atributo]))</pre>
And using in

<pre>(def test
  (ms/rewrite
    (g1) [?e ?a]</pre>
I get an
<pre>Syntax error macroexpanding meander.match.epsilon/find 
with binding form must be a simple symbol the name of which begins with &quot;%&quot;</pre>
But if copy-paste tge code of g1 runs fine
<pre>(def test-2
  (ms/rewrite
   (me/with [%e-entidade (me/or (= e (me/pred unificador? ?e))
                                (= (me/pred unificador? ?e) e))
             %a-atributo (me/or (= a (me/pred keyword? ?a))
                                (= (me/pred keyword? ?a) a))]
            [%e-entidade %a-atributo]) [?e ?a]))</pre>
 Is it a restriction of <code>defsyntax</code> using <code>with</code> or am I making a mistake?</z><z id="t1586641618" t="noprompt [:attrs {:href &quot;/_/_/users/U1ERECYRE&quot;}] This is because of the back tick: (meander.epsilon/with [meander.dev.zeta/%e-entidade (meander.epsilon/or ,,,) ;; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ] ,,,) To make this work you will need to use # suffixed symbol names like this `(me/with [%e-entidade# (me/or ,,,) ,,,] ,,,)) ;; =&gt; (meander.epsilon/with [%e-entidade__25097__auto__ (meander.epsilon/or ,,,)] ,,,) "><y>#</y><d>2020-04-11</d><h>21:46</h><w>noprompt</w><a>@nlessa</a> This is because of the back tick:
<pre>(meander.epsilon/with [meander.dev.zeta/%e-entidade (meander.epsilon/or ,,,)
                    ;; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                       ]
  ,,,)</pre>
To make this work you will need to use <code>#</code> suffixed symbol names like this
<pre>`(me/with [%e-entidade# (me/or ,,,)
           ,,,]
   ,,,))
;; =&gt;
(meander.epsilon/with [%e-entidade__25097__auto__ (meander.epsilon/or ,,,)]
  ,,,)</pre>
</z><z id="t1586641879" t="noprompt (me/defsyntax foo [x] `(me/with [%foo ~x] ;; &lt;-- Broken, %foo needs to be %foo# %foo)) (me/rewrite 1 (foo ?x) ?x) ;; =&gt; ;; with binding form must be a simple symbol the name of which begins ;; with &quot;%&quot; ;; {:invalid-binding meander.dev.zeta/%foo, ;; :form (meander.epsilon/with [meander.dev.zeta/%foo ?x] ;; meander.dev.zeta/%foo)} (me/defsyntax foo [x] `(me/with [%foo# ~x] ;; &lt;-- Fixed %foo#)) (me/rewrite 1 (foo ?x) ?x) ;; =&gt; 1 "><y>#</y><d>2020-04-11</d><h>21:51</h><w>noprompt</w><pre>(me/defsyntax foo [x]
  `(me/with [%foo ~x] ;; &lt;-- Broken, %foo needs to be %foo#
     %foo))

(me/rewrite 1 (foo ?x) ?x)
;; =&gt;
;; with binding form must be a simple symbol the name of which begins
;; with &quot;%&quot;
;; {:invalid-binding meander.dev.zeta/%foo,
;;  :form (meander.epsilon/with [meander.dev.zeta/%foo ?x]
;;          meander.dev.zeta/%foo)}

(me/defsyntax foo [x]
  `(me/with [%foo# ~x] ;; &lt;-- Fixed
     %foo#))

(me/rewrite 1 (foo ?x) ?x)
;; =&gt; 1</pre>
</z><z id="t1586642063" t="noprompt The ex-info for this error should probably have a :syntax-trace and maybe a hint or something which offers a little guidance."><y>#</y><d>2020-04-11</d><h>21:54</h><w>noprompt</w>The <code>ex-info</code> for this error should probably have a <code>:syntax-trace</code> and maybe a hint or something which offers a little guidance.</z><z id="t1586642403" t="noprompt I do have something for Unable to resolve symbol: ?y in this context sorts of errors that occasionally come up when using rewrite . A rule like (:foo ?x) (:bar ?y) will produce a error like There are variables on the right which do not appear on the left. {:vars-missing-on-left #{?y}, :left-form (:foo ?x), :left-meta {:line 1295, :column 3}, :right-form (:bar ?y), :right-meta {:line 1296, :column 3}} "><y>#</y><d>2020-04-11</d><h>22:00</h><w>noprompt</w>I do have something for
<pre>Unable to resolve symbol: ?y in this context</pre>
sorts of errors that occasionally come up when using <code>rewrite</code>. A rule like
<pre>(:foo ?x)
  (:bar ?y)</pre>
will produce a error like
<pre>There are variables on the right which do not appear on the left.
   {:vars-missing-on-left #{?y},
    :left-form (:foo ?x),
    :left-meta {:line 1295, :column 3},
    :right-form (:bar ?y),
    :right-meta {:line 1296, :column 3}}</pre>
</z><z id="t1586705123" t="nlessa Thank you very much! It&apos;s all working! Really amazed with Meander."><y>#</y><d>2020-04-12</d><h>15:25</h><r>nlessa</r>Thank you very much! It&apos;s all working! Really amazed with Meander.</z><z id="t1587137771" t="markaddleman Hey - Just checking in with you. The channel has been quiet the past several days. Hoping everything is alright with you guys"><y>#</y><d>2020-04-17</d><h>15:36</h><w>markaddleman</w>Hey - Just checking in with you.  The channel has been quiet the past several days.  Hoping everything is alright with you guys</z><z id="t1587138412" t="Jimmy Miller I&apos;m doing alright. Haven&apos;t been quite as productive as I&apos;d like to be lately. But overall not too bad. Starting to adjust to the new (temporary) normal."><y>#</y><d>2020-04-17</d><h>15:46</h><w>Jimmy Miller</w>I&apos;m doing alright. Haven&apos;t been quite as productive as I&apos;d like to be lately. But overall not too bad. Starting to adjust to the new (temporary) normal.</z><z id="t1587147181" t="noprompt I’m also doing alright. Just trying to stay sane with my three kids home 24/7. 🙂"><y>#</y><d>2020-04-17</d><h>18:13</h><w>noprompt</w>I’m also doing alright. Just trying to stay sane with my three kids home 24/7. <b>🙂</b></z><z id="t1587147224" t="noprompt How are you doing?"><y>#</y><d>2020-04-17</d><h>18:13</h><w>noprompt</w>How are you doing?</z><z id="t1587303409" t="markaddleman 🙂 Doing well, thanks."><y>#</y><d>2020-04-19</d><h>13:36</h><w>markaddleman</w><b>🙂</b>  Doing well, thanks.</z><z id="t1587303505" t="markaddleman Enjoying the heck out of meander. Trying to do some graph walking but I&apos;m not quite getting something about with . I&apos;m going to beat my head against it for another hour or so before I cry uncle and ask for some help"><y>#</y><d>2020-04-19</d><h>13:38</h><w>markaddleman</w>Enjoying the heck out of meander.  Trying to do some graph walking but I&apos;m not quite getting something about <code>with</code>.  I&apos;m going to beat my head against it for another hour or so before I cry uncle and ask for some help</z><z id="t1587307053" t="markaddleman Alright, I&apos;m crying uncle... I&apos;m trying to walk a graph that looks like {:a :b, :b :c, :c :d} to obtain parents and their children/grandchildren/... {:a [:b :c :d], :b [:c :d], :c [:d], :d []}"><y>#</y><d>2020-04-19</d><h>14:37</h><w>markaddleman</w>Alright, I&apos;m crying uncle...  I&apos;m trying to walk a graph that looks like
<pre>{:a :b, :b :c, :c :d}</pre>
to obtain parents and their children/grandchildren/...
<pre>{:a [:b :c :d], :b [:c :d], :c [:d], :d []}</pre></z><z id="t1587660481" t="Jimmy Miller No idea how I&apos;d do this. Definitely not trivial"><y>#</y><d>2020-04-23</d><h>16:48</h><r>Jimmy Miller</r>No idea how I&apos;d do this. Definitely not trivial</z><z id="t1587669446" t="markaddleman No worries 🙂 It&apos;s good to know where the boundaries are. Hope things are well with you"><y>#</y><d>2020-04-23</d><h>19:17</h><r>markaddleman</r>No worries <b>🙂</b>  It&apos;s good to know where the boundaries are.  Hope things are well with you</z><z id="t1587307132" t="markaddleman I&apos;m having trouble expressing a recursively constrained pattern."><y>#</y><d>2020-04-19</d><h>14:38</h><w>markaddleman</w>I&apos;m having trouble expressing a recursively constrained pattern.</z><z id="t1587406222" t="noprompt [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] Sorry for the lag in reply, my weekends can be impossible."><y>#</y><d>2020-04-20</d><h>18:10</h><w>noprompt</w><a>@markaddleman</a> Sorry for the lag in reply, my weekends can be impossible.</z><z id="t1587406260" t="markaddleman No worries. I&apos;m mostly in the mode of exercising my meander chops."><y>#</y><d>2020-04-20</d><h>18:11</h><r>markaddleman</r>No worries.  I&apos;m mostly in the mode of exercising my meander chops.</z><z id="t1587653041" t="grounded_sage How do I do this where :Price is an optional key. I have certain JSON files where say :Price or perhaps :Name inside of :Price is missing. I want to still match on the file and offer a default value (defn data-transform [data] (m/search data {:Data {:Tickets (m/scan {:Seat ?seat :Eventname ?event-name :Price {:Name ?price-name :Amount ?price-amount}})}} {:seat ?seat :ticket-category (or ?price-name nil) :price (or ?price-amount nil)}))"><y>#</y><d>2020-04-23</d><h>14:44</h><w>grounded_sage</w>How do I do this where <code>:Price</code> is an optional key. I have certain JSON files where say <code>:Price</code> or perhaps <code>:Name</code> inside of <code>:Price</code> is missing. I want to still match on the file and offer a default value
<pre>(defn data-transform
  [data]
  (m/search data
            {:Data {:Tickets (m/scan {:Seat ?seat
                                      :Eventname ?event-name
                                      :Price {:Name ?price-name
                                              :Amount ?price-amount}})}}
            {:seat ?seat
             :ticket-category (or ?price-name nil)
             :price (or ?price-amount nil)}))</pre></z><z id="t1587659894" t="Jimmy Miller Do you actually need search semantics for some bigger part of this. Or are you okay with it being a match?"><y>#</y><d>2020-04-23</d><h>16:38</h><r>Jimmy Miller</r>Do you actually need search semantics for some bigger part of this. Or are you okay with it being a match?</z><z id="t1587660002" t="Jimmy Miller Actually I can make it work with search. (m/search data {:Data {:Tickets (m/scan {:Seat ?seat :Eventname ?event-name :Price (m/or {:Name ?price-name :Amount ?price-amount} (m/let [?price-name &quot;default-name&quot; ?price-amount &quot;default-price&quot;] nil))})}} {:seat ?seat :ticket-category ?price-name :price ?price-amount})"><y>#</y><d>2020-04-23</d><h>16:40</h><r>Jimmy Miller</r>Actually I can make it work with search.

<pre>(m/search data
          {:Data {:Tickets (m/scan {:Seat ?seat
                                    :Eventname ?event-name
                                    :Price (m/or
                                            {:Name ?price-name
                                             :Amount ?price-amount}
                                            (m/let [?price-name &quot;default-name&quot;
                                                    ?price-amount &quot;default-price&quot;]
                                              nil))})}}
  {:seat ?seat
   :ticket-category ?price-name
   :price ?price-amount})</pre></z><z id="t1587661712" t="grounded_sage I’m having some internet troubles atm so have to reply on phone. What would you do if :Price itself is missing? "><y>#</y><d>2020-04-23</d><h>17:08</h><r>grounded_sage</r>I’m having some internet troubles atm so have  to reply on phone. What would you do if :Price itself is missing? </z><z id="t1587661835" t="noprompt The answer [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] gave accounts for that :Price , (m/or {,,,} (m/let [,,,]))"><y>#</y><d>2020-04-23</d><h>17:10</h><r>noprompt</r>The answer <a>@U5K8NTHEZ</a> gave accounts for that <code>:Price</code> , <code>(m/or {,,,} (m/let [,,,]))</code></z><z id="t1587661870" t="noprompt So either :Price is a map and you bind the values, or you m/let them out."><y>#</y><d>2020-04-23</d><h>17:11</h><r>noprompt</r>So either <code>:Price</code> is a map and you bind the values, or you <code>m/let</code> them out.</z><z id="t1587664676" t="grounded_sage I actually think the solution you gave me will be sufficient. But I am curious as to how one would handle missing data like I described"><y>#</y><d>2020-04-23</d><h>17:57</h><r>grounded_sage</r>I actually think the solution you gave me will be sufficient. But I am curious as to how one would handle missing data like I described</z><z id="t1587665443" t="Jimmy Miller Yeah sorry I missed all the other ones. I will try to write that up as well."><y>#</y><d>2020-04-23</d><h>18:10</h><r>Jimmy Miller</r>Yeah sorry I missed all the other ones. I will try to write that up as well.</z><z id="t1587670694" t="Jimmy Miller I should explain the steps on how I got here, but I already wasted too much time playing with this 🙂 (m/defsyntax with-defaults [bindings body] (m/rewrite bindings [!binding (m/and !lvar1 !lvar2) !default ...] (&apos;m/with [!binding (&apos;m/or (&apos;m/some !lvar1) (&apos;m/let [!lvar2 !default] nil)) ...] ~body) )) (m/search data (with-defaults [%name ?name &quot;name&quot; %amount ?amount 0] {:Data {:Tickets (m/scan {:Seat ?seat :Eventname ?event-name :Price (m/or {:Name %name :Amount %amount} (m/and nil %name %amount))})}}) {:seat ?seat :ticket-category ?name :price ?amount}) Doing it all inline was getting too verbose. So I made my own little defsyntax thing."><y>#</y><d>2020-04-23</d><h>19:38</h><r>Jimmy Miller</r>I should explain the steps on how I got here, but I already wasted too much time playing with this <b>🙂</b>

<pre>(m/defsyntax with-defaults [bindings body]
  (m/rewrite bindings
    [!binding (m/and !lvar1 !lvar2) !default ...]
    (&apos;m/with [!binding (&apos;m/or (&apos;m/some !lvar1)
                        (&apos;m/let [!lvar2 !default] nil))
              ...]
     ~body)
    ))

(m/search data
  (with-defaults [%name ?name &quot;name&quot;
                  %amount ?amount 0]
    {:Data {:Tickets (m/scan {:Seat ?seat
                              :Eventname ?event-name
                              :Price (m/or
                                      {:Name %name
                                       :Amount %amount}
                                      (m/and nil
                                             %name
                                             %amount))})}})
  {:seat ?seat
   :ticket-category ?name
   :price ?amount})</pre>
Doing it all inline was getting too verbose. So I made my own little defsyntax thing.</z><z id="t1588091329" t="nlessa Hi! I am not understanding why something like this works (ms/rewrite (me/with [%e-entidade (me/or (= e (me/pred symbol? ?e)) (= (me/pred symbol? ?e) e)) %a-atributo (me/or (= a (me/pred keyword? ?a)) (= (me/pred keyword? ?a) a)) %v-valor (me/or (= v (me/pred symbol? ?v)) (= (me/pred symbol? ?v) v)) %v-args (me/or (me/pred symbol? ?v)) %v-teste-unario ((me/pred function? !funcao-unaria) !param-function-unaria) %operador-binario (me/pred #{&apos;&lt; &apos;&gt; &apos;&lt;= &apos;&gt;= &apos;not=} !funcao-binaria) %v-teste-binario (%operador-binario %v-args !param-function-binaria) %v-teste-funcao (me/or %v-teste-unario %v-teste-binario) %v-expression (me/or %v-valor %v-teste-unario %v-teste-binario)] [%e-entidade %a-atributo %v-valor . %v-teste-funcao ..1]) :ok) but if I add any other params in the the (me/or of %v-args, eg, %v-args (me/or (me/pred symbol? ?v) a-symbol) I get an Unable to resolve symbol: ?v in this context What am I missing? Thanks in advance!"><y>#</y><d>2020-04-28</d><h>16:28</h><w>nlessa</w>Hi!
I am not understanding why something like this works
<pre>(ms/rewrite
  (me/with [%e-entidade (me/or (= e (me/pred symbol? ?e))
                               (= (me/pred symbol? ?e) e))
            %a-atributo (me/or (= a (me/pred keyword? ?a))
                               (= (me/pred keyword? ?a) a))
            %v-valor (me/or (= v (me/pred symbol? ?v))
                            (= (me/pred symbol? ?v) v))
            %v-args (me/or (me/pred symbol? ?v)) 
            %v-teste-unario ((me/pred function? !funcao-unaria) !param-function-unaria)
            %operador-binario (me/pred #{&apos;&lt; &apos;&gt; &apos;&lt;= &apos;&gt;= &apos;not=} !funcao-binaria)
            %v-teste-binario (%operador-binario %v-args !param-function-binaria)
            %v-teste-funcao (me/or %v-teste-unario %v-teste-binario)
            %v-expression (me/or %v-valor %v-teste-unario %v-teste-binario)]
           [%e-entidade %a-atributo %v-valor . %v-teste-funcao ..1]) :ok)</pre>
but if I add any other params in the the (me/or of %v-args, eg,
<pre>%v-args (me/or (me/pred symbol? ?v) a-symbol) </pre>
I get an Unable to resolve symbol: ?v in this context

What am I missing?
Thanks in advance!</z><z id="t1588093111" t="Jimmy Miller [:attrs {:href &quot;/_/_/users/U1ERECYRE&quot;}] Definitely looks like a bug. Will try to find some time today to dig into it."><y>#</y><d>2020-04-28</d><h>16:58</h><w>Jimmy Miller</w><a>@nlessa</a> Definitely looks like a bug. Will try to find some time today to dig into it.</z></g><g id="s2"><z id="t1588093276" t="Jimmy Miller I am a little confused as to what you are trying to accomplish though. Do you have an example of the data your are matching on?"><y>#</y><d>2020-04-28</d><h>17:01</h><w>Jimmy Miller</w>I am a little confused as to what you are trying to accomplish though. Do you have an example of the data your are matching on?</z><z id="t1588093296" t="Jimmy Miller Those = signs are not going to be doing what I think you want them to do."><y>#</y><d>2020-04-28</d><h>17:01</h><w>Jimmy Miller</w>Those = signs are not going to be doing what I think you want them to do.</z><z id="t1588093315" t="Jimmy Miller So while I might be able to find the bug, I want to make sure you can accomplish your task as well."><y>#</y><d>2020-04-28</d><h>17:01</h><w>Jimmy Miller</w>So while I might be able to find the bug, I want to make sure you can accomplish your task as well.</z><z id="t1588094328" t="nlessa Thanks, [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] ! The symbols = appears in the grammar that is being rewrited. It&apos;s been working fine, only with this little problem with the me/or. The use case I am working is a transformation from rules expressed in Clara Rules to datalog clauses. Meander worked very well! I faced only this and another strange problem (but with workaround) . I will post later here the other problem I found."><y>#</y><d>2020-04-28</d><h>17:18</h><w>nlessa</w>Thanks, <a>@jimmy</a>!
The symbols = appears in the grammar that is being rewrited. It&apos;s been working fine, only with this little problem with the me/or.

The use case I am working is a transformation from rules expressed in Clara Rules to datalog clauses. Meander worked very well! I faced only this and another strange problem (but with workaround) . I will post later here  the other problem I found.</z><z id="t1588094384" t="Jimmy Miller Okay, cool. Just wanted to make sure that the = signs were meant to be literals."><y>#</y><d>2020-04-28</d><h>17:19</h><w>Jimmy Miller</w>Okay, cool. Just wanted to make sure that the <code>=</code> signs were meant to be literals.</z><z id="t1588094568" t="Jimmy Miller Also great to hear that it is working for you. Interesting to see a transformation from clara to datalog. Hopefully we can help fix those remaining issues."><y>#</y><d>2020-04-28</d><h>17:22</h><w>Jimmy Miller</w>Also great to hear that it is working for you. Interesting to see a transformation from clara to datalog. Hopefully we can help fix those remaining issues.</z><z id="t1588094716" t="Jimmy Miller Okay so the fact that you get the error you do is a bug. But for %v-args (me/or (me/pred symbol? ?v)) if you want something else in the or you need to make sure it has ?v in it."><y>#</y><d>2020-04-28</d><h>17:25</h><w>Jimmy Miller</w>Okay so the fact that you get the error you do is a bug.  But for <code>%v-args (me/or (me/pred symbol? ?v))</code> if you want something else in the <code>or</code> you need to make sure it has <code>?v</code> in it.</z><z id="t1588094746" t="Jimmy Miller If you add a pattern that includes ?v there you should be fine. We are clearly failing to detect that problem correctly though and so we generate bad code."><y>#</y><d>2020-04-28</d><h>17:25</h><w>Jimmy Miller</w>If you add a pattern that includes <code>?v</code> there you should be fine. We are clearly failing to detect that problem correctly though and so we generate bad code.</z><z id="t1588095187" t="nlessa Ah, ok, understood!"><y>#</y><d>2020-04-28</d><h>17:33</h><w>nlessa</w>Ah, ok, understood!</z><z id="t1588095782" t="Jimmy Miller [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] Just fyi. Looks like we consider ?v bound already because of %v-valor and so argument-lvrs is empty. https://github.com/noprompt/meander/blob/b2a6ab1135f3bf3be3abf2f113930c4ffec71f04/src/meander/match/check/epsilon.cljc#L154-L187"><y>#</y><d>2020-04-28</d><h>17:43</h><w>Jimmy Miller</w><a>@noprompt</a>  Just fyi. Looks like we consider <code>?v</code> bound already because of <code>%v-valor</code> and so argument-lvrs is empty. <a href="https://github.com/noprompt/meander/blob/b2a6ab1135f3bf3be3abf2f113930c4ffec71f04/src/meander/match/check/epsilon.cljc#L154-L187" target="_blank">https://github.com/noprompt/meander/blob/b2a6ab1135f3bf3be3abf2f113930c4ffec71f04/src/meander/match/check/epsilon.cljc#L154-L187</a></z><z id="t1588096352" t="noprompt [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] Thanks for taking a look. Do you have a patch in mind or did you want me to take it from here?"><y>#</y><d>2020-04-28</d><h>17:52</h><w>noprompt</w><a>@jimmy</a> Thanks for taking a look. Do you have a patch in mind or did you want me to take it from here?</z><z id="t1588096376" t="noprompt I’m sure fixing this will probably fix other instances of this problem."><y>#</y><d>2020-04-28</d><h>17:52</h><w>noprompt</w>I’m sure fixing this will probably fix other instances of this problem.</z><z id="t1588096400" t="noprompt (I’ve encountered it once in the last couple months but didn’t have a chance to properly look into it.)"><y>#</y><d>2020-04-28</d><h>17:53</h><w>noprompt</w>(I’ve encountered it once in the last couple months but didn’t have a chance to properly look into it.)</z><z id="t1588096417" t="Jimmy Miller I haven&apos;t had a chance to think of a fix. Need to familiarize myself with that code. Just wanted to dump the little bit I found here."><y>#</y><d>2020-04-28</d><h>17:53</h><w>Jimmy Miller</w>I haven&apos;t had a chance to think of a fix. Need to familiarize myself with that code. Just wanted to dump the little bit I found here.</z><z id="t1588096444" t="noprompt Okay, cool. This is perfect. It saves a ton of time. 🙂"><y>#</y><d>2020-04-28</d><h>17:54</h><w>noprompt</w>Okay, cool. This is perfect. It saves a ton of time. <b>🙂</b></z><z id="t1588283803" t="noprompt [:attrs {:href &quot;/_/_/users/U1ERECYRE&quot;}] I think I should be able to make a patch for the bug sometime tomorrow. Normally, I would be able to turn around patches more quickly but my kids have taken a lot of my extra energy. Homeschooling is exhausting!"><y>#</y><d>2020-04-30</d><h>21:56</h><w>noprompt</w><a>@nlessa</a> I think I should be able to make a patch for the bug sometime tomorrow. Normally, I would be able to turn around patches more quickly but my kids have taken a lot of my extra energy. Homeschooling is exhausting!</z><z id="t1588335661" t="nlessa Thanks a lot, Joel. Have a nice day and weekend!"><y>#</y><d>2020-05-01</d><h>12:21</h><r>nlessa</r>Thanks a lot, Joel. Have a nice day and weekend!</z><z id="t1588717210" t="noprompt Okay, so I wasn’t able to get around to it yet but I haven’t forgotten about the bug."><y>#</y><d>2020-05-05</d><h>22:20</h><r>noprompt</r>Okay, so I wasn’t able to get around to it yet but I haven’t forgotten about the bug.</z><z id="t1588342977" t="keesterbrugge Hi everybody, I&apos;m really excited by the potential of meander and I&apos;m trying to figure out if I can make my code more transparent by using meander for data science. I&apos;m getting data in the shape of [{:a [1 2]}] and I need to transform it such that it becomes [{:a 1 :idx-row 0 :idx-vec 0} {:a 2 :idx-row 0 :idx-vec 1}] which I can plot with vega-lite. So I need to unpack and index the elements of the vectors and add row indices (`:idx-row`). I&apos;ve written the unpack-and-index-vec-from-seq-of-map function to get it in the right shape, but I&apos;d like to do this with meander. (defn unpack-and-index-vec-from-seq-of-map [vec-key seq-of-maps] (-&gt;&gt; seq-of-maps (map-indexed (fn [idx-row m] (assoc m :idx-row idx-row))) (map (fn [row] (map-indexed (fn [idx-vec vec-element] (assoc row vec-key vec-element :idx-vec idx-vec)) (get row vec-key)))) (apply concat))) (def test-data [{:b 2 :a [2 3]} {:b 3 :a [4 5]}]) (unpack-and-index-vec-from-seq-of-map :a test-data) ;; =&gt; ;; ({:b 2, :a 2, :idx-row 0, :idx-vec 0} ;; {:b 2, :a 3, :idx-row 0, :idx-vec 1} ;; {:b 3, :a 4, :idx-row 1, :idx-vec 0} ;; {:b 3, :a 5, :idx-row 1, :idx-vec 1}) I&apos;m a bit overwhelmed with all the possibilities I have in meander. Can you help me figure out how this would work? cheers"><y>#</y><d>2020-05-01</d><h>14:22</h><w>keesterbrugge</w>Hi everybody, I&apos;m really excited by the potential of meander and I&apos;m trying to figure out if I can make my code more transparent by using meander for data science.

I&apos;m getting data in the shape of <code>[{:a [1 2]}]</code> and I need to transform it such that it becomes <code>[{:a 1 :idx-row 0 :idx-vec 0} {:a 2 :idx-row 0 :idx-vec 1}]</code>  which I can plot with vega-lite. So I need to unpack and index the elements of the vectors and add row indices (`:idx-row`).

I&apos;ve written the <code>unpack-and-index-vec-from-seq-of-map</code> function to get it in the right shape, but I&apos;d like to do this with meander.
<pre>(defn unpack-and-index-vec-from-seq-of-map [vec-key seq-of-maps]
  (-&gt;&gt; seq-of-maps
       (map-indexed (fn [idx-row m] (assoc m :idx-row idx-row)))
       (map (fn [row]
              (map-indexed
               (fn [idx-vec vec-element]
                 (assoc row vec-key vec-element :idx-vec idx-vec))
               (get row vec-key))))
       (apply concat)))

(def test-data [{:b 2 :a [2 3]} {:b 3 :a [4 5]}]) 

(unpack-and-index-vec-from-seq-of-map :a test-data)
;; =&gt;
;; ({:b 2, :a 2, :idx-row 0, :idx-vec 0}
;;  {:b 2, :a 3, :idx-row 0, :idx-vec 1}
;;  {:b 3, :a 4, :idx-row 1, :idx-vec 0}
;;  {:b 3, :a 5, :idx-row 1, :idx-vec 1})</pre>
I&apos;m a bit overwhelmed with all the possibilities I have in meander. Can you help me figure out how this would work?
cheers</z><z id="t1588371022" t="timothypratley Hi [:attrs {:href &quot;/_/_/users/U5309L9JP&quot;}] , Here is one way: (m/rewrite [{:b 2 :a [2 3]} {:b 3 :a [4 5]}] (m/and [{:a [!x !y] &amp; (m/and !m1 !m2)} ..?n] (m/let [((m/and !ns1 !ns2) ...) (range ?n)])) [{:a !x :idx-row !ns1 :idx-vec 0 &amp; !m1} {:a !y :idx-row !ns2 :idx-vec 1 &amp; !m2} ...]) =&gt; [{:b 2, :a 2, :idx-row 0, :idx-vec 0} {:b 2, :a 3, :idx-row 0, :idx-vec 1} {:b 3, :a 4, :idx-row 1, :idx-vec 0} {:b 3, :a 5, :idx-row 1, :idx-vec 1}]"><y>#</y><d>2020-05-01</d><h>22:10</h><r>timothypratley</r>Hi <a>@U5309L9JP</a>,
Here is one way:
<pre>(m/rewrite [{:b 2 :a [2 3]} {:b 3 :a [4 5]}]
  (m/and
    [{:a [!x !y] &amp; (m/and !m1 !m2)} ..?n]
    (m/let [((m/and !ns1 !ns2) ...) (range ?n)]))
  [{:a       !x
    :idx-row !ns1
    :idx-vec 0
    &amp;        !m1}
   {:a       !y
    :idx-row !ns2
    :idx-vec 1
    &amp;        !m2}
   ...])
=&gt;
[{:b 2, :a 2, :idx-row 0, :idx-vec 0}
 {:b 2, :a 3, :idx-row 0, :idx-vec 1}
 {:b 3, :a 4, :idx-row 1, :idx-vec 0}
 {:b 3, :a 5, :idx-row 1, :idx-vec 1}]</pre></z><z id="t1588371181" t="timothypratley Unfortunately there are two confusing bits about my solution: 1. I’m using an and trick to create 2 memory variables !m1 and !m2 because we intend to substitute them twice 2. Using let to create 2 index variables"><y>#</y><d>2020-05-01</d><h>22:13</h><r>timothypratley</r>Unfortunately there are two confusing bits about my solution:
1. I’m using an <code>and</code> trick to create 2 memory variables !m1 and !m2 because we intend to substitute them twice
2. Using <code>let</code> to create 2 index variables</z><z id="t1588770876" t="keesterbrugge hi [:attrs {:href &quot;/_/_/users/U06S1EJPL&quot;}] , Thanks for helping me out. Although I&apos;m happy to see it&apos;s possible with meander, I think this might not be a good use case for clarifying the transformation with meander. Especially so, since the real case actually has a vector of size n in each map with key :a , instead of size 2. Cheers"><y>#</y><d>2020-05-06</d><h>13:14</h><r>keesterbrugge</r>hi <a>@U06S1EJPL</a>, Thanks for helping me out. Although I&apos;m happy to see it&apos;s possible with meander, I think this might not be a good use case for clarifying the transformation with meander. Especially so, since the real case actually has a vector of size <code>n</code> in each map with key <code>:a</code>, instead of size 2.
Cheers</z><z id="t1588343788" t="nlessa Hi [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] ! Another case I am dealing and not understanding if I am missing some subtlety is one like below (I shortened the real use for easiness) ((ms/bottom-up (ms/attempt (ms/rewrite {:type (me/pred keyword? *acc) :constraints ?constraints :args *args} ?constraints {:accumulator *acc :result-binding *result-binding :from ?constraints-ac} ?constraints-ac))) &apos;({:type :some/keyword, :constraints [(= item ?item) (= tipo-contrato ?tipo-contrato) (= descontados ?descontados) (= mapa ?mapa)], :args [something]})) =&gt; ([(= item ?item) (= tipo-contrato ?tipo-contrato) (= descontados ?descontados) (= mapa ?mapa)]) But if I invert the order of the clauses ((ms/bottom-up (ms/attempt (ms/rewrite {:accumulator *acc :result-binding *result-binding :from ?constraints-ac} ?constraints-ac {:type (me/pred keyword? *acc) :constraints ?constraints :args *args} ?constraints))) &apos;({:type :some/keyword, :constraints [(= item ?item) (= tipo-contrato ?tipo-contrato) (= descontados ?descontados) (= mapa ?mapa)], :args [something]})) =&gt; (nil) What would be the reason for (nil) in the inversion of the order of the clauses?"><y>#</y><d>2020-05-01</d><h>14:36</h><w>nlessa</w>Hi <a>@noprompt</a>! Another case I am dealing and not understanding if I am missing some subtlety is one like below (I shortened the real use for easiness)
<code>((ms/bottom-up</code>
   <code>(ms/attempt</code>
     <code>(ms/rewrite</code>

       
       <code>{:type (me/pred keyword? *acc) :constraints ?constraints :args *args}</code>
       <code>?constraints</code>
       <code>{:accumulator *acc :result-binding *result-binding :from ?constraints-ac} ?constraints-ac)))</code>
 <code>&apos;({:type :some/keyword,</code>
    <code>:constraints [(= item ?item) (= tipo-contrato ?tipo-contrato) (= descontados ?descontados) (= mapa ?mapa)],</code>
    <code>:args [something]}))</code>
<code>=&gt; ([(= item ?item) (= tipo-contrato ?tipo-contrato) (= descontados ?descontados) (= mapa ?mapa)])</code>
But if I invert the order of the clauses

<pre>((ms/bottom-up
   (ms/attempt
     (ms/rewrite

       {:accumulator *acc :result-binding *result-binding :from ?constraints-ac} ?constraints-ac
       {:type (me/pred keyword? *acc) :constraints ?constraints :args *args}
       ?constraints)))
      
 &apos;({:type :some/keyword,
    :constraints [(= item ?item) (= tipo-contrato ?tipo-contrato) (= descontados ?descontados) (= mapa ?mapa)],
    :args [something]}))
=&gt; (nil)</pre>
What would be the reason for (nil) in the inversion of the order of the clauses?</z><z id="t1588347431" t="Jimmy Miller {:accumulator *acc :result-binding *result-binding :from ?constraints-ac} will match any map even if it doesn&apos;t have those keys. You can use (m/some ?constraints-ac) to make sure the key really exists."><y>#</y><d>2020-05-01</d><h>15:37</h><r>Jimmy Miller</r><code>{:accumulator *acc :result-binding *result-binding :from ?constraints-ac}</code>

will match any map even if it doesn&apos;t have those keys. You can use <code>(m/some  ?constraints-ac)</code> to make sure the key really exists.</z><z id="t1588390326" t="noprompt See also: https://github.com/noprompt/meander/issues/122#issuecomment-620983655"><y>#</y><d>2020-05-02</d><h>03:32</h><r>noprompt</r>See also: <a href="https://github.com/noprompt/meander/issues/122#issuecomment-620983655" target="_blank">https://github.com/noprompt/meander/issues/122#issuecomment-620983655</a></z><z id="t1588372124" t="timothypratley Let the record state that today I tried to write a meander expression to match something with metadata 😛"><y>#</y><d>2020-05-01</d><h>22:28</h><w>timothypratley</w>Let the record state that today I tried to write a meander expression to match something with metadata <b>😛</b></z><z id="t1588372340" t="timothypratley and that it worked find by doing (m/and ?thing (m/app meta ?meta))"><y>#</y><d>2020-05-01</d><h>22:32</h><r>timothypratley</r>and that it worked find by doing <code>(m/and ?thing (m/app meta ?meta))</code></z><z id="t1588377355" t="noprompt I’ve done this often enough myself and its come up before… maybe we should add it to the meander.epsilon ?"><y>#</y><d>2020-05-01</d><h>23:55</h><r>noprompt</r>I’ve done this often enough myself and its come up before… maybe we should add it to the <code>meander.epsilon</code>?</z><z id="t1588377830" t="timothypratley do you mean automatically try to match metadata? I guess there is an existing feature for sets which needs to be considered: ^{&amp; ?rest-set} #{} but that seems like a pretty low collision chance! 🙂"><y>#</y><d>2020-05-02</d><h>00:03</h><r>timothypratley</r>do you mean automatically try to match metadata? I guess there is an existing feature for sets which needs to be considered:
<code>^{&amp; ?rest-set} #{}</code> but that seems like a pretty low collision chance! <b>🙂</b></z><z id="t1588377981" t="timothypratley Argument for: Seems convenient, Argument against: Metadata is not considered in equality (is that important??? I don’t think so)"><y>#</y><d>2020-05-02</d><h>00:06</h><r>timothypratley</r>Argument for: Seems convenient,
Argument against: Metadata is not considered in equality (is that important??? I don’t think so)</z><z id="t1588377355" t="noprompt I’ve done this often enough myself and its come up before… maybe we should add it to the meander.epsilon ?"><y>#</y><d>2020-05-01</d><h>23:55</h><w>noprompt</w>I’ve done this often enough myself and its come up before… maybe we should add it to the <code>meander.epsilon</code>?</z><z id="t1588401952" t="pbaille Hello! I&apos;m playing with meander and am really impressed by it. I was wondering what would be the meander way to parse a regular clojure fn or defn form ? (i&apos;m struggling a bit in order to express elements that could be there or not (like the name of the lambda or the metadata map in the `defn for instance). thank you in advance."><y>#</y><d>2020-05-02</d><h>06:45</h><w>pbaille</w>Hello! I&apos;m playing with meander and am really impressed by it. I was wondering what would be the meander way to parse a regular clojure <code>fn or </code>defn form ? (i&apos;m struggling a bit in order to express elements that could be there or not (like the name of the lambda or the metadata map in the `defn for instance). thank you in advance.</z><z id="t1588607630" t="Jimmy Miller Sorry for the late reply. I will hopefully be able to answer this thoroughly today. It is actually something that comes up quite often so, I plan on adding some examples to the cookbook. Optionality is a little difficult just because it is context sensitive. The easiest (but often times not scalable) answer is to make multiple patterns that match with or with out it. Like I said, I should have an example later today."><y>#</y><d>2020-05-04</d><h>15:53</h><r>Jimmy Miller</r>Sorry for the late reply. I will hopefully be able to answer this thoroughly today. It is actually something that comes up quite often so, I plan on adding some examples to the cookbook.

Optionality is a little difficult just because it is context sensitive. The easiest (but often times not scalable) answer is to make multiple patterns that match with or with out it.

Like I said, I should have an example later today.</z><z id="t1588621448" t="timothypratley [:attrs {:href &quot;/_/_/users/U0A7SU3FS&quot;}] Here is one way: https://github.com/timothypratley/justice/blob/master/src/justice/defn.cljc"><y>#</y><d>2020-05-04</d><h>19:44</h><r>timothypratley</r><a>@U0A7SU3FS</a> Here is one way: <a href="https://github.com/timothypratley/justice/blob/master/src/justice/defn.cljc" target="_blank">https://github.com/timothypratley/justice/blob/master/src/justice/defn.cljc</a></z><z id="t1588621489" t="timothypratley FWIW If you compare it with the “spec driven approach” linked in the comment I think Meander is way more expressive 🙂"><y>#</y><d>2020-05-04</d><h>19:44</h><r>timothypratley</r>FWIW If you compare it with the “spec driven approach” linked in the comment I think Meander is way more expressive <b>🙂</b></z><z id="t1588621537" t="timothypratley note that the way I emulated “optional” was to use a memory variable constrained to contain 1 or 0 elements"><y>#</y><d>2020-05-04</d><h>19:45</h><r>timothypratley</r>note that the way I emulated “optional” was to use a memory variable constrained to contain 1 or 0 elements</z><z id="t1588621554" t="timothypratley I wish Meander had a built in operator for optional (hint hint [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] )"><y>#</y><d>2020-05-04</d><h>19:45</h><r>timothypratley</r>I wish Meander had a built in operator for optional (hint hint <a>@U06MDAPTP</a>)</z><z id="t1588621707" t="noprompt [:attrs {:href &quot;/_/_/users/U06S1EJPL&quot;}] The memory variable trick works too. I didn’t use it in the example. 🙂"><y>#</y><d>2020-05-04</d><h>19:48</h><r>noprompt</r><a>@U06S1EJPL</a> The memory variable trick works too. I didn’t use it in the example. <b>🙂</b></z><z id="t1588621733" t="Jimmy Miller I tried to hack on in one time. But the compiler depends on the length of a pattern quite often to be able to do things intelligently. I found myself running into trouble because of that."><y>#</y><d>2020-05-04</d><h>19:48</h><r>Jimmy Miller</r>I tried to hack on in one time. But the compiler depends on the length of a pattern quite often to be able to do things intelligently. I found myself running into trouble because of that.</z><z id="t1588621928" t="timothypratley Also as a side topic; you can use tools analyzer to parse/emit normalized versions then match with meander to remove most optionality (happy to share examples on that too if interesting)."><y>#</y><d>2020-05-04</d><h>19:52</h><r>timothypratley</r>Also as a side topic; you can use tools analyzer to parse/emit normalized versions then match with meander to remove most optionality (happy to share examples on that too if interesting).</z><z id="t1588620643" t="noprompt [:attrs {:href &quot;/_/_/users/U0A7SU3FS&quot;}] Here’s an example: ;; [name doc-string? attr-map? [params*] prepost-map? body] ;; [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?] (defn parse-defn [form] (m/rewrite form (m/with [%doc-and-rest (m/or ((m/pred string? ?doc-string) &amp; %attr-map-and-rest) (m/let [?doc-string nil] %attr-map-and-rest)) %attr-map-and-rest (m/or ((m/pred map? ?attr-map) &amp; %fn-tail) (m/let [?attr-map nil] (&amp; %fn-tail))) %fn-tail (m/or %fn-tail-1 %fn-tail-n) %fn-tail-1 (m/and ([&amp; !params] &amp; _) (m/let [?tail-attr-map nil])) %fn-tail-n (%fn-tail-1 ... &amp; %tail-attr-map) %tail-attr-map (m/or {:as ?tail-attr-map} (m/let [?tail-attr-map nil] ()))] (`defn ?name &amp; %doc-and-rest)) {:name ?name :doc-string ?doc-string :attr-map ~(merge ?attr-map ?tail-attr-map) :fn-specs [{:params !params} ...]})) [&quot;no doc, no attr map, 1 arity&quot; (parse-defn &apos;(clojure.core/defn foo [x y] 42)) &quot;doc, no attr map, 1 arity&quot; (parse-defn &apos;(clojure.core/defn foo &quot;doc&quot; [x y] 42)) &quot;no doc, attr map, 1 arity&quot; (parse-defn &apos;(clojure.core/defn foo {:doc &quot;doc&quot;} [x y] 42)) &quot;doc, attr map, 1 arity&quot; (parse-defn &apos;(clojure.core/defn foo &quot;foo&quot; {:doc &quot;doc&quot;} [x y] 42)) &quot;no doc, no attr map, n arity&quot; (parse-defn &apos;(clojure.core/defn foo ([x] 41) ([x y] 42))) &quot;doc, no attr map, n arity&quot; (parse-defn &apos;(clojure.core/defn foo &quot;doc&quot; ([x] 41) ([x y] 42))) &quot;no doc, attr map, n arity&quot; (parse-defn &apos;(clojure.core/defn foo {:doc &quot;doc&quot;} ([x] 41) ([x y] 42))) &quot;doc, attr map, n arity&quot; (parse-defn &apos;(clojure.core/defn foo &quot;foo&quot; {:doc &quot;doc&quot;} ([x] 41) ([x y] 42)))] ;; =&gt; [&quot;no doc, no attr map, 1 arity&quot; {:name foo, :doc-string nil, :attr-map nil, :fn-specs [{:params [x y]}]} &quot;doc, no attr map, 1 arity&quot; {:name foo, :doc-string &quot;doc&quot;, :attr-map nil, :fn-specs [{:params [x y]}]} &quot;no doc, attr map, 1 arity&quot; {:name foo, :doc-string nil, :attr-map {:doc &quot;doc&quot;}, :fn-specs [{:params [x y]}]} &quot;doc, attr map, 1 arity&quot; {:name foo, :doc-string &quot;foo&quot;, :attr-map {:doc &quot;doc&quot;}, :fn-specs [{:params [x y]}]} &quot;no doc, no attr map, n arity&quot; {:name foo, :doc-string nil, :attr-map nil, :fn-specs [{:params [x]} {:params [x y]}]} &quot;doc, no attr map, n arity&quot; {:name foo, :doc-string &quot;doc&quot;, :attr-map nil, :fn-specs [{:params [x]} {:params [x y]}]} &quot;no doc, attr map, n arity&quot; {:name foo, :doc-string nil, :attr-map {:doc &quot;doc&quot;}, :fn-specs [{:params [x]} {:params [x y]}]} &quot;doc, attr map, n arity&quot; {:name foo, :doc-string &quot;foo&quot;, :attr-map {:doc &quot;doc&quot;}, :fn-specs [{:params [x]} {:params [x y]}]}] "><y>#</y><d>2020-05-04</d><h>19:30</h><w>noprompt</w><a>@pbaille</a> Here’s an example:
<pre>;; [name doc-string? attr-map? [params*] prepost-map? body]
;; [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?]
(defn parse-defn [form]
  (m/rewrite form
    (m/with [%doc-and-rest (m/or ((m/pred string? ?doc-string) &amp; %attr-map-and-rest)
                                 (m/let [?doc-string nil] %attr-map-and-rest))
             %attr-map-and-rest (m/or ((m/pred map? ?attr-map) &amp; %fn-tail)
                                      (m/let [?attr-map nil] (&amp; %fn-tail)))
             %fn-tail (m/or %fn-tail-1 %fn-tail-n)
             %fn-tail-1 (m/and ([&amp; !params] &amp; _) (m/let [?tail-attr-map nil]))
             %fn-tail-n (%fn-tail-1 ... &amp; %tail-attr-map)
             %tail-attr-map (m/or {:as ?tail-attr-map} (m/let [?tail-attr-map nil] ()))]
      (`defn ?name &amp; %doc-and-rest))
    {:name ?name
     :doc-string ?doc-string
     :attr-map ~(merge ?attr-map ?tail-attr-map)
     :fn-specs [{:params !params} ...]}))

[&quot;no doc, no attr map, 1 arity&quot;
 (parse-defn &apos;(clojure.core/defn foo [x y] 42))

 &quot;doc, no attr map, 1 arity&quot;
 (parse-defn &apos;(clojure.core/defn foo &quot;doc&quot; [x y] 42))

 &quot;no doc, attr map, 1 arity&quot;
 (parse-defn &apos;(clojure.core/defn foo {:doc &quot;doc&quot;} [x y] 42))

 &quot;doc, attr map, 1 arity&quot;
 (parse-defn &apos;(clojure.core/defn foo &quot;foo&quot; {:doc &quot;doc&quot;} [x y] 42))

 &quot;no doc, no attr map, n arity&quot;
 (parse-defn &apos;(clojure.core/defn foo ([x] 41) ([x y] 42)))

 &quot;doc, no attr map, n arity&quot;
 (parse-defn &apos;(clojure.core/defn foo &quot;doc&quot; ([x] 41) ([x y] 42)))

 &quot;no doc, attr map, n arity&quot;
 (parse-defn &apos;(clojure.core/defn foo {:doc &quot;doc&quot;} ([x] 41) ([x y] 42)))

 &quot;doc, attr map, n arity&quot;
 (parse-defn &apos;(clojure.core/defn foo &quot;foo&quot; {:doc &quot;doc&quot;} ([x] 41) ([x y] 42)))]
;; =&gt;
[&quot;no doc, no attr map, 1 arity&quot;
 {:name foo,
  :doc-string nil,
  :attr-map nil,
  :fn-specs [{:params [x y]}]}
 &quot;doc, no attr map, 1 arity&quot;
 {:name foo,
  :doc-string &quot;doc&quot;,
  :attr-map nil,
  :fn-specs [{:params [x y]}]}
 &quot;no doc, attr map, 1 arity&quot;
 {:name foo,
  :doc-string nil,
  :attr-map {:doc &quot;doc&quot;},
  :fn-specs [{:params [x y]}]}
 &quot;doc, attr map, 1 arity&quot;
 {:name foo,
  :doc-string &quot;foo&quot;,
  :attr-map {:doc &quot;doc&quot;},
  :fn-specs [{:params [x y]}]}
 &quot;no doc, no attr map, n arity&quot;
 {:name foo,
  :doc-string nil,
  :attr-map nil,
  :fn-specs [{:params [x]} {:params [x y]}]}
 &quot;doc, no attr map, n arity&quot;
 {:name foo,
  :doc-string &quot;doc&quot;,
  :attr-map nil,
  :fn-specs [{:params [x]} {:params [x y]}]}
 &quot;no doc, attr map, n arity&quot;
 {:name foo,
  :doc-string nil,
  :attr-map {:doc &quot;doc&quot;},
  :fn-specs [{:params [x]} {:params [x y]}]}
 &quot;doc, attr map, n arity&quot;
 {:name foo,
  :doc-string &quot;foo&quot;,
  :attr-map {:doc &quot;doc&quot;},
  :fn-specs [{:params [x]} {:params [x y]}]}]</pre>
</z><z id="t1588620701" t="noprompt The other way to write it is without with where you specify each case."><y>#</y><d>2020-05-04</d><h>19:31</h><w>noprompt</w>The other way to write it is without <code>with</code> where you specify each case.</z><z id="t1588620789" t="noprompt (defn parse-defn [form] (m/rewrite form (`defn ?name [&amp; ?params] &amp; ?body) {:name ?name :doc-string nil :attr-map nil :fn-specs [{:params ?params}]} ,,,)) "><y>#</y><d>2020-05-04</d><h>19:33</h><w>noprompt</w><pre>(defn parse-defn [form]
  (m/rewrite form
    (`defn ?name [&amp; ?params] &amp; ?body)
    {:name ?name
     :doc-string nil
     :attr-map nil
     :fn-specs [{:params ?params}]}

    ,,,))</pre>
</z><z id="t1588621063" t="noprompt TBH — and I know no one here is soliciting my opinion — this is why I’m not a big fan of optionality: it breeds a lot of complexity."><y>#</y><d>2020-05-04</d><h>19:37</h><w>noprompt</w>TBH — and I know no one here is soliciting my opinion — this is why I’m not a big fan of optionality: it breeds a lot of complexity.</z><z id="t1588621719" t="timothypratley sure but not all complexity is incidental 😛"><y>#</y><d>2020-05-04</d><h>19:48</h><r>timothypratley</r>sure but not all complexity is incidental <b>😛</b></z><z id="t1588622582" t="noprompt Just like all things, its probably worthwhile to use the word when e.g. When is complexity incidental? When you’re coding. When is it not? When you’re parsing. 🙂"><y>#</y><d>2020-05-04</d><h>20:03</h><r>noprompt</r>Just like all things, its probably worthwhile to use the word when e.g. When is complexity incidental? When you’re coding. When is it not? When you’re parsing. <b>🙂</b></z><z id="t1588626537" t="timothypratley :thumbsup:"><y>#</y><d>2020-05-04</d><h>21:08</h><r>timothypratley</r><b>:thumbsup:</b></z><z id="t1588621108" t="noprompt There are actually 16 possible ways to write defn ."><y>#</y><d>2020-05-04</d><h>19:38</h><w>noprompt</w>There are actually 16 possible ways to write <code>defn</code>.</z><z id="t1588621125" t="noprompt 16."><y>#</y><d>2020-05-04</d><h>19:38</h><w>noprompt</w>16.</z><z id="t1588659725" t="pbaille thank you for the exemple, it is nice, the with form is really powerful , I can honestly say that meander is the most exciting clojure lib i&apos;ve seen for a long time! I hope it will continue to grow 🙂 thank you a lot for the hard work."><y>#</y><d>2020-05-05</d><h>06:22</h><w>pbaille</w>thank you for the exemple, it is nice, the with form is really powerful , I can honestly say that meander is the most exciting clojure lib i&apos;ve seen for a long time! I hope it will continue to grow <b>🙂</b> thank you a lot for the hard work.</z><z id="t1588660363" t="pbaille Here how the https://github.com/cgrand/seqexp lib handle a similar thing (simplified). this is sweet I think: ;; match a defn-like body (including name, optional docstring, optional metadata ;; and multiple arities) =&gt; (def args+body (se/cat vector? (se/* se/_))) #&apos;playground/args+body =&gt; (se/exec (se/cat (se/as :name symbol?) (se/? (se/as :docstring string?)) (se/? (se/as :meta map?)) (se/| (se/as :body args+body) (se/as :bodies (se/+ (partial se/exec args+body))))) &apos;(fn-name &quot;some-doc&quot; {:meta :data} ([a] ...) ([a b] ...))) {:rest (), :match (fn-name &quot;some-doc&quot; {:meta :data} ([a] ...) ([a b] ...)), :bodies (([a] ...) ([a b] ...)), :name (fn-name), :docstring (&quot;some-doc&quot;), :meta ({:meta :data})} does the se/? (zero or one) can be abstracted via defsyntax ? I&apos;ve seen that in the implementation there is a possibility to set the maximal occurence count of a repeated pattern, could we use that to do so ? do you think that something like ..0-1 for expressing such thing makes sense ? (I didn&apos;t had time to hack it but I will certainly try someday)."><y>#</y><d>2020-05-05</d><h>06:32</h><w>pbaille</w>Here how the <a href="https://github.com/cgrand/seqexp" target="_blank">https://github.com/cgrand/seqexp</a> lib handle a similar thing (simplified). this is sweet I think:
<pre>;; match a defn-like body (including name, optional docstring, optional metadata
;; and multiple arities)
=&gt; (def args+body (se/cat vector? (se/* se/_)))

#&apos;playground/args+body

=&gt; (se/exec
     (se/cat
       (se/as :name symbol?)
       (se/? (se/as :docstring string?))
       (se/? (se/as :meta map?))
       (se/|
         (se/as :body args+body)
         (se/as :bodies
           (se/+ (partial se/exec args+body)))))
     &apos;(fn-name &quot;some-doc&quot; {:meta :data}
        ([a] ...)
        ([a b] ...)))

{:rest (), :match (fn-name &quot;some-doc&quot; {:meta :data} ([a] ...) ([a b] ...)),
 :bodies (([a] ...) ([a b] ...)),
 :name (fn-name),
 :docstring (&quot;some-doc&quot;),
 :meta ({:meta :data})}</pre>
does the <code>se/?</code>  (zero or one) can be abstracted via <code>defsyntax</code>?
I&apos;ve seen that in the implementation there is a possibility to set the maximal occurence count of a repeated pattern, could we use that to do so ?
do you think that something like <code>..0-1</code>  for expressing such thing makes sense ? (I didn&apos;t had time to hack it but I will certainly try someday).</z><z id="t1588712542" t="timothypratley I for one love the idea of something like ..0-1 can we brainstorm on it a bit? I think 0-1 is maybe a bit too range oriented, but maybe that’s perfect???"><y>#</y><d>2020-05-05</d><h>21:02</h><r>timothypratley</r>I for one love the idea of something like <code>..0-1</code> can we brainstorm on it a bit? I think <code>0-1</code> is maybe a bit too range oriented, but maybe that’s perfect???</z><z id="t1588712558" t="timothypratley ..?n-?m seems to make sense :thinking_face:"><y>#</y><d>2020-05-05</d><h>21:02</h><r>timothypratley</r><code>..?n-?m</code> seems to make sense <b>:thinking_face:</b></z><z id="t1588712800" t="timothypratley And it can express: ..0-1 and ..1-?n to follow regex ? and + rules…"><y>#</y><d>2020-05-05</d><h>21:06</h><r>timothypratley</r>And it can express:
<code>..0-1</code> and <code>..1-?n</code> to follow regex <code>?</code> and <code>+</code> rules…</z><z id="t1588712915" t="timothypratley Alternatively going straight to ..? and ..+ might be more direct, but less flexible (as you can’t say I want 3-5… or support both!!! everything 🙂"><y>#</y><d>2020-05-05</d><h>21:08</h><r>timothypratley</r>Alternatively going straight to <code>..?</code> and <code>..+</code> might be more direct, but less flexible (as you can’t say I want 3-5… or support both!!! everything <b>🙂</b></z><z id="t1588712966" t="timothypratley [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] any thoughts?"><y>#</y><d>2020-05-05</d><h>21:09</h><r>timothypratley</r><a>@U06MDAPTP</a> any thoughts?</z><z id="t1588712975" t="timothypratley [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] ^^"><y>#</y><d>2020-05-05</d><h>21:09</h><r>timothypratley</r><a>@U5K8NTHEZ</a> ^^</z><z id="t1588713055" t="noprompt I was planning to add a more verbose operator to zeta (m/repeated patterns ,,, :min &lt;min-pattern&gt; :max &lt;max-pattern&gt;) "><y>#</y><d>2020-05-05</d><h>21:10</h><r>noprompt</r>I was planning to add a more verbose operator to zeta
<pre>(m/repeated patterns ,,, :min &lt;min-pattern&gt; :max &lt;max-pattern&gt;)</pre>
</z><z id="t1588713209" t="noprompt If you did something like (m/repeated 1 :min ?n :max ?n) you get a greedy star (m/repeated 1 :min 0 :max ?n) you’d get an increasingly greed star"><y>#</y><d>2020-05-05</d><h>21:13</h><r>noprompt</r>If you did something like
<pre>(m/repeated 1 :min ?n :max ?n)</pre>
you get a greedy star
<pre>(m/repeated 1 :min 0 :max ?n)</pre>
you’d get an increasingly greed star</z><z id="t1588713387" t="Jimmy Miller Ignoring syntax for a second. I think this should be achievable in epsilon. You can see the various repeat length things defined here. Should be able to add a new type. https://github.com/noprompt/meander/blob/afc410d6d82f719cf8f39c4fedf5b1cdb761fb21/src/meander/syntax/epsilon.cljc#L1172-L1276"><y>#</y><d>2020-05-05</d><h>21:16</h><r>Jimmy Miller</r>Ignoring syntax for a second. I think this should be achievable in epsilon. You can see the various repeat length things defined here. Should be able to add a new type. <a href="https://github.com/noprompt/meander/blob/afc410d6d82f719cf8f39c4fedf5b1cdb761fb21/src/meander/syntax/epsilon.cljc#L1172-L1276" target="_blank">https://github.com/noprompt/meander/blob/afc410d6d82f719cf8f39c4fedf5b1cdb761fb21/src/meander/syntax/epsilon.cljc#L1172-L1276</a></z><z id="t1588713452" t="noprompt [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] You mean adding m/repeated ?"><y>#</y><d>2020-05-05</d><h>21:17</h><r>noprompt</r><a>@U5K8NTHEZ</a> You mean adding <code>m/repeated</code>?</z><z id="t1588713532" t="Jimmy Miller Maybe? At the very least some more flexible repeat operator, or covering some we don&apos;t have."><y>#</y><d>2020-05-05</d><h>21:18</h><r>Jimmy Miller</r>Maybe? At the very least some more flexible repeat operator, or covering some we don&apos;t have.</z><z id="t1588713669" t="timothypratley Oh sweet, I think you are saying: (if (integer? n) …) could be: if + return min-length 1 if ? return max-length 1"><y>#</y><d>2020-05-05</d><h>21:21</h><r>timothypratley</r>Oh sweet, I think you are saying:
(if (integer? n) …)
could be:
if + return min-length 1
if ? return max-length 1</z><z id="t1588713692" t="timothypratley that seems easy and powerful 🙂"><y>#</y><d>2020-05-05</d><h>21:21</h><r>timothypratley</r>that seems easy and powerful <b>🙂</b></z><z id="t1588713712" t="timothypratley for :rp+"><y>#</y><d>2020-05-05</d><h>21:21</h><r>timothypratley</r>for :rp+</z><z id="t1588714204" t="timothypratley Ahhh dumb question from me… what are :rp* and :rp+ ? 🙂"><y>#</y><d>2020-05-05</d><h>21:30</h><r>timothypratley</r>Ahhh dumb question from me… what are :rp* and :rp+ ? <b>🙂</b></z><z id="t1588714639" t="timothypratley it looks like :rp* is … and :rp+ is ..3 but I got confused because :rp+ returns max length Inf (which maybe doesn’t matter, I just thought it would be 3)"><y>#</y><d>2020-05-05</d><h>21:37</h><r>timothypratley</r>it looks like :rp* is <code>…</code> and :rp+ is <code>..3</code> but I got confused because :rp+ returns max length Inf (which maybe doesn’t matter, I just thought it would be 3)</z><z id="t1588715806" t="noprompt That’s 3 or more. But we really need a thing allows more control."><y>#</y><d>2020-05-05</d><h>21:56</h><r>noprompt</r>That’s 3 or more. But we really need a thing allows more control.</z><z id="t1588716001" t="timothypratley Oh well just to enumerate some options… ..2..5 might be swell 🙂"><y>#</y><d>2020-05-05</d><h>22:00</h><r>timothypratley</r>Oh well just to enumerate some options…
<code>..2..5</code> might be swell <b>🙂</b></z><z id="t1588716031" t="timothypratley ..2-5 is great but I worry that kebab variables might not make sense"><y>#</y><d>2020-05-05</d><h>22:00</h><r>timothypratley</r><code>..2-5</code> is great but I worry that kebab variables might not make sense</z><z id="t1588716080" t="timothypratley ..?a-?b for example seems ok, but ..?some-weird-name-?some-other-name seems ambiguous"><y>#</y><d>2020-05-05</d><h>22:01</h><r>timothypratley</r><code>..?a-?b</code> for example seems ok, but
<code>..?some-weird-name-?some-other-name</code> seems ambiguous</z><z id="t1588716118" t="timothypratley where ..?some-weird-name..?some-other-name is more obvious"><y>#</y><d>2020-05-05</d><h>22:01</h><r>timothypratley</r>where <code>..?some-weird-name..?some-other-name</code> is more obvious</z><z id="t1588716194" t="timothypratley In hindsight I wish ..3 meant exactly 3, and ..3.. meant 3 or more 😛"><y>#</y><d>2020-05-05</d><h>22:03</h><r>timothypratley</r>In hindsight I wish <code>..3</code> meant exactly 3, and <code>..3..</code> meant 3 or more <b>😛</b></z><z id="t1588716313" t="timothypratley FWIW I’m pretty sure just ..? is need, because ..1 is exactly ..+ anyhow"><y>#</y><d>2020-05-05</d><h>22:05</h><r>timothypratley</r>FWIW I’m pretty sure just <code>..?</code> is need, because <code>..1</code> is exactly <code>..+</code> anyhow</z><z id="t1588716376" t="timothypratley ..0..1 is more precise though"><y>#</y><d>2020-05-05</d><h>22:06</h><r>timothypratley</r><code>..0..1</code> is more precise though</z><z id="t1588716391" t="noprompt Yeah and that syntax is actually allowed by the reader."><y>#</y><d>2020-05-05</d><h>22:06</h><r>noprompt</r>Yeah and that syntax is actually allowed by the reader.</z><z id="t1588716497" t="noprompt Wouldn’t ..3..3 be exactly three?"><y>#</y><d>2020-05-05</d><h>22:08</h><r>noprompt</r>Wouldn’t <code>..3..3</code>  be exactly three?</z><z id="t1588716503" t="timothypratley yup"><y>#</y><d>2020-05-05</d><h>22:08</h><r>timothypratley</r>yup</z><z id="t1588716514" t="timothypratley :thumbsup:"><y>#</y><d>2020-05-05</d><h>22:08</h><r>timothypratley</r><b>:thumbsup:</b></z><z id="t1588716582" t="noprompt The thing I don’t have an answer for is in this regard is the greediness."><y>#</y><d>2020-05-05</d><h>22:09</h><r>noprompt</r>The thing I don’t have an answer for is in this regard is the greediness.</z><z id="t1588716622" t="noprompt Because ..?n..?m can have many solutions depending on the situation."><y>#</y><d>2020-05-05</d><h>22:10</h><r>noprompt</r>Because <code>..?n..?m</code> can have many solutions depending on the situation.</z><z id="t1588716655" t="noprompt Same goes for ..?n..?n"><y>#</y><d>2020-05-05</d><h>22:10</h><r>noprompt</r>Same goes for <code>..?n..?n</code></z><z id="t1588716659" t="timothypratley Hmmm isn’t it just a mechanical translation to the min/max multimethods though?"><y>#</y><d>2020-05-05</d><h>22:10</h><r>timothypratley</r>Hmmm isn’t it just a mechanical translation to the min/max multimethods though?</z><z id="t1588716665" t="timothypratley I’m not sure I follow"><y>#</y><d>2020-05-05</d><h>22:11</h><r>timothypratley</r>I’m not sure I follow</z><z id="t1588716736" t="timothypratley Like here: ;; 3 (nat-int? count-pattern) (clj/let [?n count-pattern ellipsis (clj/symbol (str &quot;..&quot; ?n))] `(and (seqable (or (and ~pattern !gather#) _gather#) ~ellipsis) (guard (&lt;= ~?n (count !gather#))))) Just needs to consider guarding the max as well?"><y>#</y><d>2020-05-05</d><h>22:12</h><r>timothypratley</r>Like here:
<pre>;; 3
       (nat-int? count-pattern)
       (clj/let [?n count-pattern
                 ellipsis (clj/symbol (str &quot;..&quot; ?n))]
         `(and (seqable (or (and ~pattern !gather#) _gather#) ~ellipsis)
               (guard (&lt;= ~?n (count !gather#)))))</pre>
Just needs to consider guarding the max as well?</z><z id="t1588716784" t="timothypratley oh if they are both unbound its a different case"><y>#</y><d>2020-05-05</d><h>22:13</h><r>timothypratley</r>oh if they are both unbound its a different case</z><z id="t1588716787" t="timothypratley got it"><y>#</y><d>2020-05-05</d><h>22:13</h><r>timothypratley</r>got it</z><z id="t1588716790" t="noprompt Even with min/max constraints you still need a way to specify greediness. The example would be something like [!xs * !ys ...] Where the * represents the greedy Kleene star. In this case !ys should never collect any values because of the greediness."><y>#</y><d>2020-05-05</d><h>22:13</h><r>noprompt</r>Even with min/max constraints you still need a way to specify greediness. The example would be something like
<pre>[!xs * !ys ...]</pre>
Where the <code>*</code> represents the greedy Kleene star. In this case <code>!ys</code> should never collect any values because of the greediness.</z><z id="t1588716819" t="timothypratley Well you know my preference is greedy everything 🙂"><y>#</y><d>2020-05-05</d><h>22:13</h><r>timothypratley</r>Well you know my preference is greedy everything <b>🙂</b></z><z id="t1588716836" t="noprompt Yah, and I suspect thats the case for many, but not all patterns."><y>#</y><d>2020-05-05</d><h>22:13</h><r>noprompt</r>Yah, and I suspect thats the case for many, but not all patterns.</z><z id="t1588716840" t="timothypratley But in the short term we could also just punt and say don’t support variables in both places"><y>#</y><d>2020-05-05</d><h>22:14</h><r>timothypratley</r>But in the short term we could also just punt and say don’t support variables in both places</z><z id="t1588716849" t="noprompt But this is way more important for subsitution."><y>#</y><d>2020-05-05</d><h>22:14</h><r>noprompt</r>But this is way more important for subsitution.</z><z id="t1588716864" t="timothypratley I think just supporting number (without variables) would already be a big step forward"><y>#</y><d>2020-05-05</d><h>22:14</h><r>timothypratley</r>I think just supporting number (without variables) would already be a big step forward</z><z id="t1588716962" t="noprompt On zeta the pattern [!xs ... !ys ...] on the RHS produces all possible ways to drain the !xs and !ys and though this is interesting and right in the eyes of searching/generation being categorical duals, its probably not what you want 99% of the time."><y>#</y><d>2020-05-05</d><h>22:16</h><r>noprompt</r>On <code>zeta</code> the pattern
<pre>[!xs ... !ys ...]</pre>
on the RHS produces all possible ways to drain the <code>!xs</code> and <code>!ys</code> and though this is interesting and right in the eyes of searching/generation being categorical duals, its probably not what you want 99% of the time.</z><z id="t1588716985" t="noprompt So greed becomes relevant."><y>#</y><d>2020-05-05</d><h>22:16</h><r>noprompt</r>So greed becomes relevant.</z><z id="t1588717006" t="noprompt Its not really a point of contention in traditional matches because ambiguity is excluded by design."><y>#</y><d>2020-05-05</d><h>22:16</h><r>noprompt</r>Its not really a point of contention in traditional matches because ambiguity is excluded by design.</z><z id="t1588717072" t="noprompt Meander is working from a different direction, especially on zeta , where the starting point is ambiguity; being able produce a full space of solutions by all possible ways to yield bindings on the LHS and generate data using those bindings on the RHS."><y>#</y><d>2020-05-05</d><h>22:17</h><r>noprompt</r>Meander is working from a different direction, especially on <code>zeta</code>, where the starting point is ambiguity; being able produce a full space of solutions by all possible ways to yield bindings on the LHS and generate data using those bindings on the RHS.</z><z id="t1588717116" t="noprompt &gt; I think just supporting number (without variables) would already be a big step forward"><y>#</y><d>2020-05-05</d><h>22:18</h><r>noprompt</r>&gt;  I think just supporting number (without variables) would already be a big step forward</z><z id="t1588717128" t="noprompt Do you just mean something like ..3..10 ?"><y>#</y><d>2020-05-05</d><h>22:18</h><r>noprompt</r>Do you just mean something like <code>..3..10</code> ?</z><z id="t1588717413" t="timothypratley yes 🙂"><y>#</y><d>2020-05-05</d><h>22:23</h><r>timothypratley</r>yes <b>🙂</b></z><z id="t1588717546" t="timothypratley The basic form solves 2 real and recurring case in my mind: 0 or 1 optional semantics, and exactly 50 matches. And also covers everything in between."><y>#</y><d>2020-05-05</d><h>22:25</h><r>timothypratley</r>The basic form solves 2 real and recurring case in my mind:
0 or 1 optional semantics,
and exactly 50 matches.
And also covers everything in between.</z><z id="t1589842417" t="noprompt Sorry for dropping the ball on this conversation, I’ve been on vacation. I’m open to updating the epsilon syntax to support this."><y>#</y><d>2020-05-18</d><h>22:53</h><r>noprompt</r>Sorry for dropping the ball on this conversation, I’ve been on vacation. I’m open to updating the epsilon syntax to support this.</z><z id="t1588693204" t="Jimmy Miller Yeah I personally am in favor of having an optional operator. But there are some complications because of meanders more advanced functionality."><y>#</y><d>2020-05-05</d><h>15:40</h><w>Jimmy Miller</w>Yeah I personally am in favor of having an optional operator. But there are some complications because of meanders more advanced functionality.</z><z id="t1588700777" t="noprompt The zeta version of the project will support the regex style ? operator with the caveat that logic variables must be handled."><y>#</y><d>2020-05-05</d><h>17:46</h><w>noprompt</w>The <code>zeta</code> version of the project will support the regex style <code>?</code> operator with the caveat that logic variables must be handled.</z><z id="t1588700789" t="noprompt You can do something like this, however, (m/defsyntax ? [pattern tail] `(m/with [%tail# ~tail] (m/seqable &amp; (m/or (m/seqable ~pattern &amp; %tail#) %tail#)))) (m/match &apos;(1 3 4) (?x &amp; (? 2 ?tail)) [?x ?tail]) ;; =&gt; [1 (3 4)] (m/match &apos;(1 2 3 4) (?x &amp; (? 2 ?tail)) [?x ?tail]) ;; =&gt; [1 (3 4)] "><y>#</y><d>2020-05-05</d><h>17:46</h><w>noprompt</w>You can do something like this, however,
<pre>(m/defsyntax ? [pattern tail]
  `(m/with [%tail# ~tail]
     (m/seqable &amp; (m/or (m/seqable ~pattern &amp; %tail#)
                        %tail#))))

(m/match &apos;(1 3 4)
  (?x &amp; (? 2 ?tail))
  [?x ?tail])
;; =&gt; [1 (3 4)]

(m/match &apos;(1 2 3 4)
  (?x &amp; (? 2 ?tail))
  [?x ?tail])
;; =&gt; [1 (3 4)]</pre>
</z><z id="t1588709953" t="timothypratley but can only appear at the end 😞"><y>#</y><d>2020-05-05</d><h>20:19</h><r>timothypratley</r>but can only appear at the end <b>😞</b></z><z id="t1588709986" t="timothypratley well… I guess you can nest expressions"><y>#</y><d>2020-05-05</d><h>20:19</h><r>timothypratley</r>well… I guess you can nest expressions</z><z id="t1588710015" t="timothypratley if you make ?tail be something more complicated."><y>#</y><d>2020-05-05</d><h>20:20</h><r>timothypratley</r>if you make ?tail be something more complicated.</z><z id="t1588710982" t="noprompt I’ve been considering a way to make extensible infix operators like ? or &amp; or whatever but I feel a lot of uncertainty about the implications."><y>#</y><d>2020-05-05</d><h>20:36</h><r>noprompt</r>I’ve been considering a way to make extensible infix operators like <code>?</code> or <code>&amp;</code> or whatever but I feel a lot of uncertainty about the implications.</z><z id="t1588711065" t="noprompt On the zeta branch, its possible to stack &amp; such that you can write (?x &amp; (? 2 ?tail) &amp; ?other-tail) "><y>#</y><d>2020-05-05</d><h>20:37</h><r>noprompt</r>On the <code>zeta</code> branch, its possible to stack <code>&amp;</code> such that you can write
<pre>(?x &amp; (? 2 ?tail) &amp; ?other-tail)</pre>
</z><z id="t1588711314" t="timothypratley (m/match [1 “this is fine” :foo] (?n &amp; (? ?s ((m/pred keyword? ?k)))) [?x ?s ?k]) Syntax error macroexpanding meander.match.epsilon/match at (scratch.clj:10:1). Every pattern of an or pattern must have references to the same unbound logic variables."><y>#</y><d>2020-05-05</d><h>20:41</h><r>timothypratley</r>(m/match [1 “this is fine” :foo]
  (?n &amp; (? ?s ((m/pred keyword? ?k))))
  [?x ?s ?k])
Syntax error macroexpanding meander.match.epsilon/match at (scratch.clj:10:1).
Every pattern of an or pattern must have references to the same unbound logic variables.</z><z id="t1588711382" t="timothypratley looks like optional things can’t be variables with this technique… a let would be required to make it nil"><y>#</y><d>2020-05-05</d><h>20:43</h><r>timothypratley</r>looks like optional things can’t be variables with this technique… a let would be required to make it nil</z><z id="t1588711406" t="timothypratley ie: to solve the original problem of maybe docstrings maybe meta"><y>#</y><d>2020-05-05</d><h>20:43</h><r>timothypratley</r>ie: to solve the original problem of maybe docstrings maybe meta</z><z id="t1588711496" t="timothypratley but this doesn’t work either: (m/match [1 “this is fine” :foo] (?n &amp; (? (m/or ?s (m/let [?s nil])) ((m/pred keyword? ?k)))) [?x ?s ?k]) Syntax error macroexpanding meander.match.epsilon/match at (scratch.clj:10:1). Every pattern of an or pattern must have references to the same unbound logic variables."><y>#</y><d>2020-05-05</d><h>20:44</h><r>timothypratley</r>but this doesn’t work either:
(m/match [1 “this is fine” :foo]
  (?n &amp; (? (m/or ?s (m/let [?s nil])) ((m/pred keyword? ?k))))
  [?x ?s ?k])
Syntax error macroexpanding meander.match.epsilon/match at (scratch.clj:10:1).
Every pattern of an or pattern must have references to the same unbound logic variables.</z><z id="t1588711513" t="timothypratley bah I guess I’m putting the or in the wrong spot"><y>#</y><d>2020-05-05</d><h>20:45</h><r>timothypratley</r>bah I guess I’m putting the or in the wrong spot</z><z id="t1588712036" t="timothypratley (m/match [1 &quot;this is fine&quot; :foo] [(m/pred number? ?n) &amp; (m/with [%tail [(m/pred keyword? ?k)]] (m/or [(m/pred string? ?s) &amp; %tail] (m/and (m/let [?s nil]) %tail)))] [?n ?s ?k]) ;; =&gt; [1 nil :foo] "><y>#</y><d>2020-05-05</d><h>20:53</h><r>timothypratley</r><pre>(m/match [1 &quot;this is fine&quot; :foo]
  [(m/pred number? ?n) &amp; (m/with [%tail [(m/pred keyword? ?k)]]
                           (m/or [(m/pred string? ?s) &amp; %tail]
                                 (m/and (m/let [?s nil])
                                        %tail)))]
  [?n ?s ?k])
;; =&gt; [1 nil :foo]</pre>
</z><z id="t1588712048" t="timothypratley ^^ but this can’t neatly be wrapped in a defsyntax"><y>#</y><d>2020-05-05</d><h>20:54</h><r>timothypratley</r>^^ but this can’t neatly be wrapped in a defsyntax</z><z id="t1588712370" t="timothypratley The thing I like about using a memory variable is that the semantics for substitution remain clear 😛"><y>#</y><d>2020-05-05</d><h>20:59</h><r>timothypratley</r>The thing I like about using a memory variable is that the semantics for substitution remain clear <b>😛</b></z><z id="t1588712379" t="timothypratley So I feel it’s a more symmetric approach."><y>#</y><d>2020-05-05</d><h>20:59</h><r>timothypratley</r>So I feel it’s a more symmetric approach.</z><z id="t1588712627" t="timothypratley n = 0|1 is just a subset of many constraints"><y>#</y><d>2020-05-05</d><h>21:03</h><r>timothypratley</r>n = 0|1 is just a subset of many constraints</z><z id="t1588712640" t="timothypratley like I want 1 or more (hint hint, regex +)"><y>#</y><d>2020-05-05</d><h>21:04</h><r>timothypratley</r>like I want 1 or more (hint hint, regex +)</z><z id="t1588712684" t="timothypratley in reality I only care about 0 or 1, and 1 or more though."><y>#</y><d>2020-05-05</d><h>21:04</h><r>timothypratley</r>in reality I only care about 0 or 1, and 1 or more though.</z><z id="t1588978063" t="timothypratley SoooooOooooo multimethods and protocols suck for interactive development and I think there is a better “meander” alternative which is… just write patterns for the polymorphic inputs! However I don’t want to be limited to making the patterns siblings…. what I’d like to do (I think) is def a bunch of strategies and then say try all these strategies and see if one passes."><y>#</y><d>2020-05-08</d><h>22:47</h><w>timothypratley</w>SoooooOooooo multimethods and protocols suck for interactive development and I think there is a better “meander” alternative which is… just write patterns for the polymorphic inputs! However I don’t want to be limited to making the patterns siblings…. what I’d like to do (I think) is def a bunch of strategies and then say try all these strategies and see if one passes.</z><z id="t1588978242" t="timothypratley Like: (ns a.a) (def a (s/rewrite [pattern] [output])) (ns b.b) (def b (s/rewrite [patternb] [outputb]) (ns x.core) (def POLYMORPHIC (s/try a/a b/b)) But I don’t think s/try exists"><y>#</y><d>2020-05-08</d><h>22:50</h><r>timothypratley</r>Like:
<pre>(ns a.a)
(def a (s/rewrite [pattern] [output]))

(ns b.b)
(def b (s/rewrite [patternb] [outputb])

(ns x.core)
(def POLYMORPHIC (s/try a/a b/b))</pre>
But I don’t think <code>s/try</code> exists</z><z id="t1588978272" t="timothypratley (Seems like something I should be able to do though)"><y>#</y><d>2020-05-08</d><h>22:51</h><r>timothypratley</r>(Seems like something I should be able to do though)</z><z id="t1588998962" t="noprompt I have some thoughts on this exact topic but am currently entering vacation mode. 😊"><y>#</y><d>2020-05-09</d><h>04:36</h><r>noprompt</r>I have some thoughts on this exact topic but am currently entering vacation mode. <b>😊</b></z><z id="t1589197599" t="jeroenvandijk I’m playing with Meander. It looks like a useful tool to transform arbitrary data. So now I’m trying to transform this JSON data with a deeply nested structure. There are many optional keys in the map. I wonder what’s the best way to describe this The following transforms the data recursively, but I don’t how to solve the optional keys. With &amp; I can catch the rest, but I probably need to use this to capture optional keys (require &apos;[meander.strategy.epsilon :as m*]) (def rewrite-child (m*/rewrite {&quot;title&quot;. !node-title &quot;create-time&quot; !create-time &quot;children&quot; !node-children &amp; !others } {:create/email !create-email :create/time !create-time :node/title !node-title :node/children !node-children &amp; }) (def rewrite-children (m*/bottom-up (m*/attempt rewrite-child))) Ideally I would like to have the following transformation: {&quot;create-time&quot; 1582030610649, &quot;title&quot; &quot;&quot;, &quot;children&quot; [{&quot;create-time&quot; 1582030610649, &quot;string&quot; &quot;&quot;}]} =&gt; {:create/time 1582030610649, :node/title &quot;&quot;, :node/children [{:create/time 1582030610649, :node/string &quot;&quot;}]} Now it becomes {:create/time 1582030610649, :node/title &quot;&quot;, :node/children [{:create/time 1582030610649, :node/title nil :node/childeren nil}]} I wonder if I can get rid of the nil’s somehow. There are also more complex cases where I basically need wildcards for keys. Any suggestion how I should approach this? Is there a particular syntax for maps? Thank you :)"><y>#</y><d>2020-05-11</d><h>11:46</h><w>jeroenvandijk</w>I’m playing with Meander. It looks like a useful tool to transform arbitrary data. So now I’m trying to transform this JSON data with a deeply nested structure. There are many optional keys in the map. I wonder what’s the best way to describe this

The following transforms the data recursively, but I don’t how to solve the optional keys. With <code>&amp;</code> I can catch the rest, but I probably need to use this to capture optional keys
<pre>(require &apos;[meander.strategy.epsilon :as m*])

(def rewrite-child
  (m*/rewrite 
    {&quot;title&quot;.      !node-title
     &quot;create-time&quot; !create-time
     &quot;children&quot; !node-children

     &amp; !others 
     }
    {:create/email !create-email
     :create/time !create-time
     :node/title !node-title
     :node/children !node-children
     
     &amp; 
     })

(def rewrite-children
      (m*/bottom-up
       (m*/attempt rewrite-child)))    </pre>
Ideally I would like to have the following transformation:
<pre>{&quot;create-time&quot; 1582030610649,
 &quot;title&quot; &quot;&quot;,
 &quot;children&quot; [{&quot;create-time&quot; 1582030610649,
              &quot;string&quot; &quot;&quot;}]}
=&gt; 
{:create/time 1582030610649,
 :node/title &quot;&quot;,
 :node/children [{:create/time 1582030610649,
                  :node/string &quot;&quot;}]}</pre>
Now it becomes
<pre>{:create/time 1582030610649,
 :node/title &quot;&quot;,
 :node/children [{:create/time 1582030610649,
                  :node/title nil
                  :node/childeren nil}]} </pre>
I wonder if I can get rid of the nil’s somehow. There are also more complex cases where I basically need wildcards for keys. Any suggestion how I should approach this? Is there a particular syntax for maps? Thank you :)</z><z id="t1589216910" t="Jimmy Miller I&apos;ll have to do some thinking about how I&apos;d do that. Are there certain keys that are optional and you don&apos;t want them if they aren&apos;t there? Or all the keys?"><y>#</y><d>2020-05-11</d><h>17:08</h><r>Jimmy Miller</r>I&apos;ll have to do some thinking about how I&apos;d do that. Are there certain keys that are optional and you don&apos;t want them if they aren&apos;t there? Or all the keys?</z><z id="t1589222901" t="noprompt Yah more detail would be helpful. I can also jump on later today and lend a hand. 👍"><y>#</y><d>2020-05-11</d><h>18:48</h><r>noprompt</r>Yah more detail would be helpful. I can also jump on later today and lend a hand. <b>👍</b></z><z id="t1589227636" t="jeroenvandijk Thanks! I’m trying to import a json file. The data structure in the file has an a recursive structure of variable depth. The first level has slightly different keys than the child levels. And there are some special childs with others fields. I guess I could write multiple rewrite rules. I’m wondering what the best way would be to compose that. I’ll add a snippet of the import file to give you an idea"><y>#</y><d>2020-05-11</d><h>20:07</h><r>jeroenvandijk</r>Thanks! I’m trying to import a json file. The data structure in the file has an a recursive structure of variable depth. The first level has slightly different keys than the child levels. And there are some special childs with others fields. I guess I could write multiple rewrite rules. I’m wondering what the best way would be to compose that. I’ll add a snippet of the import file to give you an idea</z><z id="t1589227754" t="jeroenvandijk This is the file. Eventually I’m trying to put it in a Datomic database by flattening the structure, but my first concern is mapping the right fields"><y>#</y><d>2020-05-11</d><h>20:09</h><r>jeroenvandijk</r>This is the file. Eventually I’m trying to put it in a Datomic database by flattening the structure, but my first concern is mapping the right fields</z><z id="t1589227853" t="jeroenvandijk So if I could combine at least 3 rewrite rules with attempt and bottom-up it could work I guess. Maybe attempt is composable? I’ll give it a try"><y>#</y><d>2020-05-11</d><h>20:10</h><r>jeroenvandijk</r>So if I could combine at least 3 rewrite rules with attempt and bottom-up it could work I guess. Maybe <code>attempt</code> is composable? I’ll give it a try</z><z id="t1589231371" t="jeroenvandijk I’m try rewrite with multiple rules now, one for each map type. But it seems the first one is always chosen. I had the understanding that ? would require the match to be non-nil. I’m probably missing something. Will try more"><y>#</y><d>2020-05-11</d><h>21:09</h><r>jeroenvandijk</r>I’m try rewrite with multiple rules now, one for each map type. But it seems the first one is always chosen. I had the understanding that <code>?</code> would require the match to be non-nil. I’m probably missing something. Will try more</z><z id="t1589231471" t="Jimmy Miller (m/some ?x) is what you want to use for requiring something to be non-nil. Will take a look at this later tonight. Sorry can&apos;t get to it earlier."><y>#</y><d>2020-05-11</d><h>21:11</h><r>Jimmy Miller</r>(m/some ?x) is what you want to use for requiring something to be non-nil. Will take a look at this later tonight. Sorry can&apos;t get to it earlier.</z><z id="t1589231562" t="jeroenvandijk np, thank you!"><y>#</y><d>2020-05-11</d><h>21:12</h><r>jeroenvandijk</r>np, thank you!</z><z id="t1589232723" t="jeroenvandijk Ok maybe multiple rewrite rules did work"><y>#</y><d>2020-05-11</d><h>21:32</h><r>jeroenvandijk</r>Ok maybe multiple rewrite rules did work</z><z id="t1589232838" t="jeroenvandijk Now I’m wondering if I can do transformation on values. E.g. I would like to change timestamps to an instant. I could do a postwalk over the data, but maybe this is something Meander can do as well, saving another data iteration"><y>#</y><d>2020-05-11</d><h>21:33</h><r>jeroenvandijk</r>Now I’m wondering if I can do transformation on values. E.g. I would like to change timestamps to an instant. I could do a postwalk over the data, but maybe this is something Meander can do as well, saving another data iteration</z><z id="t1589257399" t="Jimmy Miller You can use (m/app my-fn ?x) to apply functions to your data."><y>#</y><d>2020-05-12</d><h>04:23</h><r>Jimmy Miller</r>You can use <code>(m/app my-fn ?x)</code> to apply functions to your data.</z><z id="t1589257469" t="Jimmy Miller Glad that multiple rewrite rule worked for you. We are thinking more about if keys should match even if they don’t exist in the map in the next version of meander. It is a gotcha people often run into."><y>#</y><d>2020-05-12</d><h>04:24</h><r>Jimmy Miller</r>Glad that multiple rewrite rule worked for you. We are thinking more about if keys should match even if they don’t exist in the map in the next version of meander. It is a gotcha people often run into.</z><z id="t1589257494" t="Jimmy Miller I think multiple matches is probably the best answer for what you are looking to do."><y>#</y><d>2020-05-12</d><h>04:24</h><r>Jimmy Miller</r>I think multiple matches is probably the best answer for what you are looking to do.</z><z id="t1589267408" t="jeroenvandijk Thank you. If all goes well, I&apos;ll post a link to the result later :)"><y>#</y><d>2020-05-12</d><h>07:10</h><r>jeroenvandijk</r>Thank you. If all goes well, I&apos;ll post a link to the result later :)</z><z id="t1589280674" t="jeroenvandijk As follow up of yesterday, I’ve been able to create a pretty good mapping with your hints (`m/some` and m/app ). Now I’m running into the point that it is almost perfect, but not completely and I cannot easily find out. Mismatches are silently ignore. Not sure how to fix this. Here is my current mapping https://gist.github.com/jeroenvandijk/62e3a52550f3aef5b69e4f0e91b73d18#file-meander_import-clj-L19-L82 The original data is also linked in the gist if you are interested"><y>#</y><d>2020-05-12</d><h>10:51</h><w>jeroenvandijk</w>As follow up of yesterday, I’ve been able to create a pretty good mapping with your hints (`m/some` and <code>m/app</code>). Now I’m running into the point that it is almost perfect, but not completely and I cannot easily find out. Mismatches are silently ignore. Not sure how to fix this. Here is my current mapping <a href="https://gist.github.com/jeroenvandijk/62e3a52550f3aef5b69e4f0e91b73d18#file-meander_import-clj-L19-L82" target="_blank">https://gist.github.com/jeroenvandijk/62e3a52550f3aef5b69e4f0e91b73d18#file-meander_import-clj-L19-L82</a> The original data is also linked in the gist if you are interested</z><z id="t1589280748" t="jeroenvandijk Maybe I need to apply more strict mapping with m/some for all the fields that I know will be there for certain?"><y>#</y><d>2020-05-12</d><h>10:52</h><r>jeroenvandijk</r>Maybe I need to apply more strict mapping with <code>m/some</code> for all the fields that I know will be there for certain?</z><z id="t1589296483" t="Jimmy Miller m*/attempt is what is silently ignoring things. That is the point of attempt."><y>#</y><d>2020-05-12</d><h>15:14</h><r>Jimmy Miller</r><code>m*/attempt</code> is what is silently ignoring things. That is the point of attempt.</z><z id="t1589296531" t="Jimmy Miller I know you are doing that be because you are doing bottom-up which will match on things smaller than just maps."><y>#</y><d>2020-05-12</d><h>15:15</h><r>Jimmy Miller</r>I know you are doing that be because you are doing bottom-up which will match on things smaller than just maps.</z><z id="t1589296595" t="Jimmy Miller You could add a clause that was something like to the very end of your match: {&amp; ?data} [:this-fell-through ?data] To find out what maps are being ignored."><y>#</y><d>2020-05-12</d><h>15:16</h><r>Jimmy Miller</r>You could add a clause that was something like to the very end of your match:

<pre>{&amp; ?data} [:this-fell-through ?data]</pre>
To find out what maps are being ignored.</z><z id="t1589302189" t="jeroenvandijk I’m not really consciously using attempt 🙈 , but now you are mentioning it. It makes sense that it is silently ignoring things. Without attempt it cannot work i’m affraid, at least nog in the recursive manner?"><y>#</y><d>2020-05-12</d><h>16:49</h><r>jeroenvandijk</r>I’m not really consciously using attempt <b>🙈</b>, but now you are mentioning it. It makes sense that it is silently ignoring things. Without attempt it cannot work i’m affraid, at least nog in the recursive manner?</z><z id="t1589302219" t="jeroenvandijk Your trick doesn’t catch the missing items. I’m guessing the data is being eaten at other levels. Ok I’ll need to study this better I’m affraid"><y>#</y><d>2020-05-12</d><h>16:50</h><r>jeroenvandijk</r>Your trick doesn’t catch the missing items. I’m guessing the data is being eaten at other levels. Ok I’ll need to study this better I’m affraid</z><z id="t1589302909" t="jeroenvandijk But the trick does get me further when I disable other rules"><y>#</y><d>2020-05-12</d><h>17:01</h><r>jeroenvandijk</r>But the trick does get me further when I disable other rules</z><z id="t1589302919" t="jeroenvandijk Thanks for all the help!"><y>#</y><d>2020-05-12</d><h>17:01</h><r>jeroenvandijk</r>Thanks for all the help!</z><z id="t1589306709" t="Jimmy Miller Glad you got things working!"><y>#</y><d>2020-05-12</d><h>18:05</h><r>Jimmy Miller</r>Glad you got things working!</z><z id="t1589324012" t="noprompt I rarely use the strategy namespace for stuff like this; I’d recommend using rewrite and m/cata if possible because it allows for much more control and will probably result in a snappier transform. I took the gist you shared — which was awesome, thanks — and https://gist.github.com/jeroenvandijk/62e3a52550f3aef5b69e4f0e91b73d18#gistcomment-3301768 for you which seems to work out pretty well. Let me know if it does the trick. I noticed that you were using m/some on keys, use m/some on the values. Also, for the &quot;children&quot; key, use m/seqable and m/cata to recursively transform the values, this handles nil automatically and avoids the need for separate rules. It will also make your output consistent i.e. you will always have :node/children that at least will be an empty vector."><y>#</y><d>2020-05-12</d><h>22:53</h><r>noprompt</r>I rarely use the strategy namespace for stuff like this; I’d recommend using <code>rewrite</code> and <code>m/cata</code> if possible because it allows for much more control and will probably result in a snappier transform.

I took the gist you shared — which was awesome, thanks —  and <a href="https://gist.github.com/jeroenvandijk/62e3a52550f3aef5b69e4f0e91b73d18#gistcomment-3301768" target="_blank">https://gist.github.com/jeroenvandijk/62e3a52550f3aef5b69e4f0e91b73d18#gistcomment-3301768</a> for you which seems to work out pretty well. Let me know if it does the trick.

I noticed that you were using <code>m/some</code> on keys, use <code>m/some</code> on the values. Also, for the <code>&quot;children&quot;</code> key,  use <code>m/seqable</code> and <code>m/cata</code> to recursively transform the values, this handles <code>nil</code> automatically and avoids the need for separate rules. It will also make your output consistent i.e.  you will always have <code>:node/children</code> that at least will be an empty vector.</z><z id="t1589324169" t="noprompt If you want to have more control over how children are rewritten, I can show you another technique."><y>#</y><d>2020-05-12</d><h>22:56</h><r>noprompt</r>If you want to have more control over how children are rewritten, I can show you another technique.</z><z id="t1589353874" t="jeroenvandijk Great thank you! I managed to get it working (probably with the worst hacks, given your feedback), but I’ll incorporate your changes"><y>#</y><d>2020-05-13</d><h>07:11</h><r>jeroenvandijk</r>Great thank you! I managed to get it working (probably with the worst hacks, given your feedback), but I’ll incorporate your changes</z><z id="t1589353977" t="jeroenvandijk The next step i’m considering is flattening the datastructure. Eventually this data needs to be transacted in Datascript/Datomic db. I’m not sure if this is feasible, but given your Hiccup example I feel this might be possible. I’ll play around with this idea first"><y>#</y><d>2020-05-13</d><h>07:12</h><r>jeroenvandijk</r>The next step i’m considering is flattening the datastructure. Eventually this data needs to be transacted in Datascript/Datomic db. I’m not sure if this is feasible, but given your Hiccup example I feel this might be possible. I’ll play around with this idea first</z><z id="t1589384179" t="noprompt It’s easy to do something like that with search 👍"><y>#</y><d>2020-05-13</d><h>15:36</h><r>noprompt</r>It’s easy to do something like that with <code>search</code> <b>👍</b></z><z id="t1589842478" t="noprompt [:attrs {:href &quot;/_/_/users/U0FT7SRLP&quot;}] how’d things end up?"><y>#</y><d>2020-05-18</d><h>22:54</h><r>noprompt</r><a>@U0FT7SRLP</a> how’d things end up?</z><z id="t1589900424" t="dominicm Has anyone made a try+ meander yet?"><y>#</y><d>2020-05-19</d><h>15:00</h><w>dominicm</w>Has anyone made a try+ meander yet?</z><z id="t1589903511" t="noprompt try+?"><y>#</y><d>2020-05-19</d><h>15:51</h><w>noprompt</w>try+?</z><z id="t1589904555" t="dominicm Like slingshot."><y>#</y><d>2020-05-19</d><h>16:09</h><w>dominicm</w>Like slingshot.</z><z id="t1589904573" t="dominicm https://github.com/scgilardi/slingshot/"><y>#</y><d>2020-05-19</d><h>16:09</h><w>dominicm</w><a href="https://github.com/scgilardi/slingshot/" target="_blank">https://github.com/scgilardi/slingshot/</a></z><z id="t1589904683" t="dominicm I was thinking this would be pretty dope: (try+ (add-user! user) (catch {:type ::data.user/user-exists :id ?user-id} {:message (format &quot;Oh no, %s user exists!&quot; ?user-id)}) (catch {::anom/category :forbidden} {:message &quot;GO AWAY&quot;}) (catch SQLException e {:message &quot;Write better SQL, Idiot&quot;})) "><y>#</y><d>2020-05-19</d><h>16:11</h><w>dominicm</w>I was thinking this would be pretty dope:

<pre>(try+
  (add-user! user)
  (catch {:type ::data.user/user-exists :id ?user-id}
     {:message (format &quot;Oh no, %s user exists!&quot; ?user-id)})
  (catch {::anom/category :forbidden}
    {:message &quot;GO AWAY&quot;})
  (catch SQLException e
    {:message &quot;Write better SQL, Idiot&quot;}))
</pre></z><z id="t1589908034" t="dominicm What&apos;s the &quot;match anything&quot; or what&apos;s the &quot;else&quot; for m/match?"><y>#</y><d>2020-05-19</d><h>17:07</h><w>dominicm</w>What&apos;s the &quot;match anything&quot; or what&apos;s the &quot;else&quot; for m/match?</z><z id="t1589908144" t="dominicm Quite enjoying this, because I can write naively and optimize the macro output"><y>#</y><d>2020-05-19</d><h>17:09</h><w>dominicm</w>Quite enjoying this, because I can write naively and optimize the macro output</z><z id="t1589908599" t="Jimmy Miller Match anything is _"><y>#</y><d>2020-05-19</d><h>17:16</h><w>Jimmy Miller</w>Match anything is <code>_</code></z><z id="t1589908627" t="Jimmy Miller Or if you want to capture it, you can just do any any ?logic_variable ."><y>#</y><d>2020-05-19</d><h>17:17</h><w>Jimmy Miller</w>Or if you want to capture it, you can just do any any <code>?logic_variable</code>.</z><z id="t1589909658" t="noprompt LOL I need more messages like “Write better SQL, Idiot” in my life."><y>#</y><d>2020-05-19</d><h>17:34</h><w>noprompt</w>LOL I need more messages like “Write better SQL, Idiot” in my life.</z><z id="t1589909729" t="noprompt I can’t remember which command it is/was but it would complain about a “Cowardly attempt to…”"><y>#</y><d>2020-05-19</d><h>17:35</h><w>noprompt</w>I can’t remember which command it is/was but it would complain about a “Cowardly attempt to…”</z><z id="t1589914337" t="timothypratley For me its Cowardly refusing to create an empty archive from tar 🙂"><y>#</y><d>2020-05-19</d><h>18:52</h><r>timothypratley</r>For me its Cowardly refusing to create an empty archive from tar <b>🙂</b></z><z id="t1589915861" t="noprompt HAHAHA! Yeah! Thats the one! 😂"><y>#</y><d>2020-05-19</d><h>19:17</h><r>noprompt</r>HAHAHA! Yeah! Thats the one! <b>😂</b></z><z id="t1589915887" t="noprompt For some reason I remembered it as calling me the coward. 😛"><y>#</y><d>2020-05-19</d><h>19:18</h><r>noprompt</r>For some reason I remembered it as calling me the coward. <b>😛</b></z><z id="t1589909755" t="noprompt Just calling me out."><y>#</y><d>2020-05-19</d><h>17:35</h><w>noprompt</w>Just calling me out.</z><z id="t1589914956" t="dominicm Hmm.. (if (= (System/getenv &quot;USER&quot;) &quot;noprompt&quot;) (throw ...)) ..."><y>#</y><d>2020-05-19</d><h>19:02</h><w>dominicm</w>Hmm.. <code>(if (= (System/getenv &quot;USER&quot;) &quot;noprompt&quot;) (throw ...))</code>...</z><z id="t1589915938" t="noprompt Okay… I’m slowly getting my head out of the vacation clouds."><y>#</y><d>2020-05-19</d><h>19:18</h><w>noprompt</w>Okay… I’m slowly getting my head out of the vacation clouds.</z><z id="t1589917980" t="dominicm It&apos;s 70loc, but I have it..."><y>#</y><d>2020-05-19</d><h>19:53</h><w>dominicm</w>It&apos;s 70loc, but I have it...</z><z id="t1589918008" t="dominicm Something that&apos;s a little tricky is the fact you have to &quot;jump&quot; priorities a little bit."><y>#</y><d>2020-05-19</d><h>19:53</h><w>dominicm</w>Something that&apos;s a little tricky is the fact you have to &quot;jump&quot; priorities a little bit.</z><z id="t1589918022" t="dominicm This is fully functional though: (try+ (throw (ex-info &quot;Invalid&quot; {:type :pity :reason &quot;???&quot;})) (read (clojure.lang.LineNumberingPushbackReader. (java.io.StringReader. &quot;)&quot;))) (throw (ex-info &quot;Invalid&quot; {:type :invalid :reason &quot;I pity the fool&quot;})) (/ 1 0) (catch ArithmeticException _ ::infinity-stones) (catch clojure.lang.LispReader$ReaderException {:clojure.error/line ?line} (println &quot;Check line&quot; ?line)) (catch {:type :invalid :reason ?reason} (prn ?reason) nil) (catch {:type :pity :reason ?reason} (println &quot;PITYPITYPITY&quot; ?reason) nil) (catch clojure.lang.ExceptionInfo e (prn (ex-data e))) (finally (println &quot;Cleaning up&quot;))) "><y>#</y><d>2020-05-19</d><h>19:53</h><w>dominicm</w>This is fully functional though:

<pre>(try+
    (throw (ex-info &quot;Invalid&quot; {:type :pity :reason &quot;???&quot;}))
    (read (clojure.lang.LineNumberingPushbackReader. (java.io.StringReader. &quot;)&quot;)))
    (throw (ex-info &quot;Invalid&quot; {:type :invalid :reason &quot;I pity the fool&quot;}))
    (/ 1 0)
    (catch ArithmeticException _
      ::infinity-stones)
    (catch clojure.lang.LispReader$ReaderException {:clojure.error/line ?line}
      (println &quot;Check line&quot; ?line))
    (catch {:type :invalid :reason ?reason}
      (prn ?reason)
      nil)
    (catch {:type :pity :reason ?reason}
      (println &quot;PITYPITYPITY&quot; ?reason)
      nil)
    (catch clojure.lang.ExceptionInfo e
      (prn (ex-data e)))

    (finally (println &quot;Cleaning up&quot;)))
</pre></z><z id="t1589918711" t="noprompt Pulled it off with rewrite?"><y>#</y><d>2020-05-19</d><h>20:05</h><w>noprompt</w>Pulled it off with rewrite?</z><z id="t1589918794" t="dominicm Didn&apos;t need it at all in the end. Rewrite made it more complicated tbh, because you have to look ahead. I&apos;m sure you&apos;ll show me the one-liner in a sec though ;)"><y>#</y><d>2020-05-19</d><h>20:06</h><w>dominicm</w>Didn&apos;t need it at all in the end. Rewrite made it more complicated tbh, because you have to look ahead. I&apos;m sure you&apos;ll show me the one-liner in a sec though ;)</z><z id="t1589919301" t="dominicm https://git.sr.ht/~severeoverfl0w/workshop.try.meander"><y>#</y><d>2020-05-19</d><h>20:15</h><w>dominicm</w><a href="https://git.sr.ht/~severeoverfl0w/workshop.try.meander" target="_blank">https://git.sr.ht/~severeoverfl0w/workshop.try.meander</a></z><z id="t1589919336" t="dominicm I&apos;ll give it a real name later, but it seems like a neat idea &amp; works in the REPL."><y>#</y><d>2020-05-19</d><h>20:15</h><w>dominicm</w>I&apos;ll give it a real name later, but it seems like a neat idea &amp; works in the REPL.</z><z id="t1589919495" t="noprompt Nice. 🙂"><y>#</y><d>2020-05-19</d><h>20:18</h><w>noprompt</w>Nice. <b>🙂</b></z><z id="t1589919503" t="noprompt I kinda wanna mess around with this."><y>#</y><d>2020-05-19</d><h>20:18</h><w>noprompt</w>I kinda wanna mess around with this.</z><z id="t1589919556" t="dominicm Do it. I consider the idea primitive, so if you want to build on top of it, go to town. I don&apos;t feel any particular ownership."><y>#</y><d>2020-05-19</d><h>20:19</h><w>dominicm</w>Do it. I consider the idea primitive, so if you want to build on top of it, go to town. I don&apos;t feel any particular ownership.</z><z id="t1589920099" t="dominicm Meander has a great api for simple cases, like matching a few keys in a map on value. It makes this kind of lightweight thing really nice. The only real catch is that I need to specify that you need to use epsilon in order to interact with it, as it&apos;s incompatible with the other versions. But that&apos;s not a big deal really, eventually it&apos;ll be stable and I can &quot;meander&quot; rather than caveating"><y>#</y><d>2020-05-19</d><h>20:28</h><w>dominicm</w>Meander has a great api for simple cases, like matching a few keys in a map on value. It makes this kind of lightweight thing really nice.

The only real catch is that I need to specify that you need to use epsilon in order to interact with it, as it&apos;s incompatible with the other versions. But that&apos;s not a big deal really, eventually it&apos;ll be stable and I can &quot;meander&quot; rather than caveating</z><z id="t1590018361" t="tobias Newbie question: Is there an equivalent for assoc-in and update-in using meander? I&apos;m writing a re-frame app and started using m/match for db queries. I like how clear it is, and how it mirrors the db structure. Now I&apos;m wondering what the equivalent would be for updating the db."><y>#</y><d>2020-05-20</d><h>23:46</h><w>tobias</w>Newbie question: Is there an equivalent for <code>assoc-in</code> and <code>update-in</code> using meander? I&apos;m writing a re-frame app and started using <code>m/match</code> for db queries. I like how clear it is, and how it mirrors the db structure. Now I&apos;m wondering what the equivalent would be for updating the db.</z><z id="t1590020040" t="Jimmy Miller With match you can just use assoc or update. (m/match {:name &quot;jimmy&quot; :stuff 1} {:name ?name :as ?my-map} (assoc ?my-map :extra-name ?name)) But if you want to do something a little more meandery, you could use rewrite. (m/rewrite {:name &quot;jimmy&quot; :other-name &quot;Stuff&quot; :stuff 1} {:name ?name :other-name _ &amp; ?rest} {:name (m/app str &quot;hello &quot; ?name) :other-name &quot;thing&quot; &amp; ?rest}) "><y>#</y><d>2020-05-21</d><h>00:14</h><w>Jimmy Miller</w>With match you can just use assoc or update.

<pre>(m/match {:name &quot;jimmy&quot;
            :stuff 1}
  {:name ?name
   :as ?my-map}

  (assoc ?my-map :extra-name ?name))</pre>
But if you want to do something a little more meandery, you could use rewrite.

<pre>(m/rewrite {:name &quot;jimmy&quot;
            :other-name &quot;Stuff&quot;
            :stuff 1}
  {:name ?name
   :other-name _
   &amp; ?rest}

  {:name (m/app str &quot;hello &quot; ?name)
   :other-name &quot;thing&quot;
   &amp; ?rest})</pre>
</z><z id="t1590020977" t="tobias Thanks! I&apos;ll try those out"><y>#</y><d>2020-05-21</d><h>00:29</h><w>tobias</w>Thanks! I&apos;ll try those out</z><z id="t1590022786" t="tobias It seems like meander is great for querying a data structure or re-writing it in a different shape, but that if I want a straightforward assoc-in or update-in then it&apos;s just as clear and concise to use assoc-in and upate-in directly. Is that fair? I&apos;m still getting the hang of where it makes sense to use meander."><y>#</y><d>2020-05-21</d><h>00:59</h><w>tobias</w>It seems like meander is great for querying a data structure or re-writing it in a different shape, but that if I want a straightforward <code>assoc-in</code> or <code>update-in</code> then it&apos;s just as clear and concise to use <code>assoc-in</code> and <code>upate-in</code> directly. Is that fair? I&apos;m still getting the hang of where it makes sense to use meander.</z><z id="t1590024053" t="noprompt It all depends on the context and what you like. 🙂"><y>#</y><d>2020-05-21</d><h>01:20</h><w>noprompt</w>It all depends on the context and what you like. <b>🙂</b></z><z id="t1590025244" t="noprompt assoc-in and update-in are nice when their mix of semantics, convenience, etc. are more practical. rewrite is specifically designed for shape to shape transformation, not “in-place” transformation. That being said, you can still do nested transformations with rewrite by using the cata operator, this is my personal tendency."><y>#</y><d>2020-05-21</d><h>01:40</h><w>noprompt</w><code>assoc-in</code> and <code>update-in</code> are nice when their mix of semantics, convenience, etc. are more practical. <code>rewrite</code> is specifically designed for shape to shape transformation, not “in-place” transformation. That being said, you can still do nested transformations with <code>rewrite</code> by using the <code>cata</code> operator, this is my personal tendency.</z><z id="t1590025555" t="noprompt I’d love to hear your thoughts, good and bad, on how it works with your re-frame app."><y>#</y><d>2020-05-21</d><h>01:45</h><w>noprompt</w>I’d love to hear your thoughts, good and bad, on how it works with your re-frame app.</z><z id="t1590025652" t="noprompt I’ve wanted to mess around with something like that. 👍"><y>#</y><d>2020-05-21</d><h>01:47</h><w>noprompt</w>I’ve wanted to mess around with something like that. <b>👍</b></z><z id="t1590032424" t="noprompt [meander/epsilon &quot;0.0.421&quot;] is out which addresses the cases where bad Clojure code being generated would trigger a clojure.lang.Compiler$CompilerException due to symbols being unresolveable."><y>#</y><d>2020-05-21</d><h>03:40</h><w>noprompt</w><code>[meander/epsilon &quot;0.0.421&quot;]</code> is out which addresses the cases where bad Clojure code being generated would trigger a <code>clojure.lang.Compiler$CompilerException</code> due to symbols being unresolveable.</z><z id="t1590032662" t="noprompt [:attrs {:href &quot;/_/_/users/U1ERECYRE&quot;}] ☝️ that should patch your problem, I even used it as https://github.com/noprompt/meander/commit/3335fc72eae0e3c6d30c9ac6a265b3ccf790f3ce#diff-e7544f9bb8134fa6cdaaa573a3b2a601R2426 ."><y>#</y><d>2020-05-21</d><h>03:44</h><w>noprompt</w><a>@nlessa</a> <b>☝️</b> that should patch your problem, I even used it as <a href="https://github.com/noprompt/meander/commit/3335fc72eae0e3c6d30c9ac6a265b3ccf790f3ce#diff-e7544f9bb8134fa6cdaaa573a3b2a601R2426" target="_blank">https://github.com/noprompt/meander/commit/3335fc72eae0e3c6d30c9ac6a265b3ccf790f3ce#diff-e7544f9bb8134fa6cdaaa573a3b2a601R2426</a>.</z><z id="t1590032753" t="noprompt I’m sorry it took me so long to patch it. I was on vacation last week, busy before that, and couldn’t take a serious look until today."><y>#</y><d>2020-05-21</d><h>03:45</h><w>noprompt</w>I’m sorry it took me so long  to patch it. I was on vacation last week,  busy before that, and couldn’t take a serious  look until today.</z><z id="t1590068985" t="nlessa Thank you, Joel! No problem at all. And thanks a lot for your time and effort to create meander. It really opened new paths to develop some stuff I have been working with."><y>#</y><d>2020-05-21</d><h>13:49</h><r>nlessa</r>Thank you, Joel! No problem at all. And thanks a lot for your time and effort to create meander. It really opened new paths to develop some stuff I have been working with.</z><z id="t1590061165" t="tobias [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] I&apos;ll let you know how it goes with re-frame. I thought meander match might offer a clear way to write queries that involve joins, which seem to often come up when using the &quot; https://purelyfunctional.tv/guide/database-structure-in-re-frame/#Indexed-Entities-Pattern &quot; for db structure described by Eric Normand. So far so good :-)"><y>#</y><d>2020-05-21</d><h>11:39</h><w>tobias</w><a>@noprompt</a> I&apos;ll let you know how it goes with re-frame. I thought meander match might offer a clear way to write queries that involve joins, which seem to often come up when using the &quot;<a href="https://purelyfunctional.tv/guide/database-structure-in-re-frame/#Indexed-Entities-Pattern" target="_blank">https://purelyfunctional.tv/guide/database-structure-in-re-frame/#Indexed-Entities-Pattern</a>&quot; for db structure described by Eric Normand. So far so good :-)</z><z id="t1590405574" t="dabrazhe Hi, I came across Meander and it looks pretty cool. What are main user cases? Is it meant to be used with Spec?"><y>#</y><d>2020-05-25</d><h>11:19</h><w>dabrazhe</w>Hi, I came across Meander and it looks pretty cool. What are main user cases? Is it meant to be used with Spec?</z><z id="t1590440216" t="Jimmy Miller Hey [:attrs {:href &quot;/_/_/users/U96LS78UV&quot;}] welcome. People here have used meander for a number of different things. In general, I’d say meander excels when you are converting from one data format to different representation. Meander is a bit different from things like specter in that it doesn’t focus on arbitrarily nested transformations but in helping you solve to real data transformation problems we face all the time. As for spec, meander doesn’t have any particular opinion about people using spec or not. In the next version of meander (zeta) we hope to have some features that will let you do some of the things people use spec for."><y>#</y><d>2020-05-25</d><h>20:56</h><w>Jimmy Miller</w>Hey <a>@dennisa</a> welcome. People here have used meander for a number of different things. In general, I’d say meander excels when you are converting from one data format to different representation. Meander is a bit different from things like specter in that it doesn’t focus on arbitrarily nested transformations but in helping you solve to real data transformation problems we face all the time.

As for spec, meander doesn’t have any particular opinion about people using spec or not. In the next version of meander (zeta) we hope to have some features that will let you do some of the things people use spec for.</z><z id="t1591705863" t="dabrazhe Thanks for the detailed answer [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] I guess it&apos;s enough to stick with core.match for basic pattern matching, or for queries like this: (filter #(re-find timestamp %) seqq)"><y>#</y><d>2020-06-09</d><h>12:31</h><r>dabrazhe</r>Thanks for the detailed answer <a>@U5K8NTHEZ</a>
I guess it&apos;s enough to stick with core.match for basic pattern matching, or for queries like this:
<pre>(filter #(re-find timestamp %) seqq)</pre></z><z id="t1590490353" t="dominicm One think I think meander really differentiates on is being &quot;obvious&quot;. By that I mean that it&apos;s fairly clear what most of the basic transforms are doing, without learning a complicated pattern matching language. That&apos;s not quite as true when you get to advanced features like memory vars."><y>#</y><d>2020-05-26</d><h>10:52</h><w>dominicm</w>One think I think meander really differentiates on is being &quot;obvious&quot;.  By that I mean that it&apos;s fairly clear what most of the basic transforms are doing, without learning a complicated pattern matching language.

That&apos;s not quite as true when you get to advanced features like memory vars.</z><z id="t1590513580" t="noprompt I’m interested to know what it is about memory variables that make them less clear (apart from determinism related situations surrounding non inductive data)."><y>#</y><d>2020-05-26</d><h>17:19</h><w>noprompt</w>I’m interested to know what it is about memory variables that make them less clear (apart from determinism related situations surrounding non inductive data).</z><z id="t1590518655" t="dominicm Just that they&apos;re all mutable and such."><y>#</y><d>2020-05-26</d><h>18:44</h><r>dominicm</r>Just that they&apos;re all mutable and such.</z><z id="t1590523843" t="noprompt Reductions tend to have that quality. Memory variables are basically a named reduction of a specific kind."><y>#</y><d>2020-05-26</d><h>20:10</h><r>noprompt</r>Reductions tend to have that quality. Memory variables are basically a named reduction of a specific kind.</z><z id="t1590525106" t="dominicm Yeah, I don&apos;t think we could do better. But they&apos;re definitely less clear than plain bindings."><y>#</y><d>2020-05-26</d><h>20:31</h><r>dominicm</r>Yeah, I don&apos;t think we could do better. But they&apos;re definitely less clear than plain bindings.</z><z id="t1590525352" t="noprompt Totally agree on plain bindings."><y>#</y><d>2020-05-26</d><h>20:35</h><r>noprompt</r>Totally agree on plain bindings.</z><z id="t1590525538" t="noprompt I haven’t fully explored the utility and properties of the “fold variable” concept yet because I haven’t gotten off the ground yet, but I anticipate that it will have similar clarity drawbacks. Still, I think in most of those cases where I have the option, I prefer the mild clarity trade off over some more rules."><y>#</y><d>2020-05-26</d><h>20:38</h><r>noprompt</r>I haven’t fully explored the utility and properties of the “fold variable” concept yet because I haven’t gotten off the ground yet, but I anticipate that it will have similar clarity drawbacks. Still, I think in most of those cases where I have the option, I prefer the mild clarity trade off  over some more rules.</z><z id="t1590526587" t="dominicm Yeah. It&apos;s the best you can do to express this kind of thing in this model"><y>#</y><d>2020-05-26</d><h>20:56</h><r>dominicm</r>Yeah. It&apos;s the best you can do to express this kind of thing in this model</z><z id="t1590515739" t="noprompt [:attrs {:href &quot;/_/_/users/U96LS78UV&quot;}] mostly I designed/am designing it for symbolic manipulation/computation, and model checking (future). Many things fit into those spaces but some more easily than others. It’s great in situations where data is well defined/structured such as interpreters (which are virtually everywhere ie. dispatch)."><y>#</y><d>2020-05-26</d><h>17:55</h><w>noprompt</w><a>@dennisa</a> mostly I designed/am designing it for symbolic manipulation/computation, and model checking (future). Many things fit into those spaces but some more easily than others. It’s great in situations  where data is well defined/structured such as interpreters (which are virtually everywhere ie. dispatch).</z><z id="t1590670959" t="aisamu I saw this on #malli and thought it would be a great fit for rewrite, but the bit of meander-fu I had acquired has unfortunately dissipated 😕 [:map [:user map?] [:profile map?] [:nested [:map [:x [:tuple {:deleteMe true} string? string?]]]] [:token [string? {:deleteMe true}]]] ;; meander magic =&gt; [:map [:user map?] [:profile map?] [:nested :map]] I could pull it off with Mathematica (will put on the thread), but I can&apos;t seem to translate that to Meander."><y>#</y><d>2020-05-28</d><h>13:02</h><w>aisamu</w>I saw this on #malli and thought it would be a great fit for rewrite, but the bit of meander-fu I had acquired has unfortunately dissipated <b>😕</b>
<pre>[:map
 [:user map?]
 [:profile map?]
 [:nested [:map [:x [:tuple {:deleteMe true} string? string?]]]]
 [:token [string? {:deleteMe true}]]]

;; meander magic =&gt; [:map [:user map?] [:profile map?] [:nested :map]]</pre>
I could pull it off with Mathematica (will put on the thread), but I can&apos;t seem to translate that to Meander.</z><z id="t1590671054" t="aisamu original = {&quot;map&quot; , {&quot;user&quot;, OddQ}, {&quot;profile&quot;, EvenQ}, {&quot;nested&quot;, {&quot;map&quot;, {&quot;x&quot;, {&quot;tuple&quot;, &quot;DELETE-ME&quot;, StringQ, StringQ}}}}, {&quot;token&quot;, {StringQ, &quot;DELETE-ME&quot;}}}; ReplaceAll[original, {_, {_, &quot;DELETE-ME&quot;, ___}} :&gt; Nothing] {map,{user,OddQ},{profile,EvenQ},{nested,{map}}}"><y>#</y><d>2020-05-28</d><h>13:04</h><r>aisamu</r><pre>original = 
{&quot;map&quot; ,
 {&quot;user&quot;, OddQ}, 
 {&quot;profile&quot;, EvenQ}, 
 {&quot;nested&quot;, {&quot;map&quot;, {&quot;x&quot;, {&quot;tuple&quot;, &quot;DELETE-ME&quot;, StringQ, StringQ}}}},
 {&quot;token&quot;, {StringQ, &quot;DELETE-ME&quot;}}};

ReplaceAll[original, {_, {_, &quot;DELETE-ME&quot;, ___}} :&gt; Nothing]</pre>
<pre>{map,{user,OddQ},{profile,EvenQ},{nested,{map}}}</pre></z><z id="t1590671385" t="aisamu {} are lists (just to mess with us), _ is one of anything (regex . ), ___ is a list of anything or blank (regex .* ) :&gt; is a &quot;binding&quot;"><y>#</y><d>2020-05-28</d><h>13:09</h><r>aisamu</r><code>{}</code> are lists (just to mess with us),
<code>_</code> is one of anything (regex <code>.</code>),
<code>___</code> is a list of anything or blank (regex <code>.*</code>)
<code>:&gt;</code> is a &quot;binding&quot;</z><z id="t1590688037" t="noprompt I think it’d be good to turn something like this into an issue as well. Bringing in things from other established term rewriting systems is definitely a goal here. 👍"><y>#</y><d>2020-05-28</d><h>17:47</h><r>noprompt</r>I think it’d be good to turn something like this into an issue as well. Bringing in things from other established term rewriting systems is definitely a goal here. <b>👍</b></z><z id="t1590682980" t="eoliphant hi, is there a way to handle conditions in a single mapping? ; to get something like this {:foo/a &quot;...&quot; :foo/b &quot;...&quot; :foo/optional &quot;..&quot;} ; to {:a &quot;...&quot; :b &quot;...&quot;} ; or this if :foo/optional is present {:a &quot;...&quot; :b &quot;...&quot; :optional &quot;...&quot;} I see that I can do it with conditional matches as arguments to say find , but that seems like it could get repetitive in certain situations"><y>#</y><d>2020-05-28</d><h>16:23</h><w>eoliphant</w>hi, is there a way to handle conditions in a single mapping?
<pre>; to get something like this 
{:foo/a &quot;...&quot;
 :foo/b &quot;...&quot;
 :foo/optional &quot;..&quot;}

; to
{:a &quot;...&quot;
 :b &quot;...&quot;}
; or this if :foo/optional is present
 {:a &quot;...&quot;
  :b &quot;...&quot;
  :optional &quot;...&quot;}     </pre>
I see that I can do it with conditional matches as arguments to say <code>find</code>, but that seems like it could get repetitive in certain situations</z><z id="t1590688299" t="noprompt [:attrs {:href &quot;/_/_/users/U380J7PAQ&quot;}] In cases like these, search is what I use (m/search {:foo/a &quot;...&quot; :foo/b &quot;...&quot; :foo/optional &quot;..&quot;} {:foo/a (m/pred string? ?value)} [:a ?value] {:foo/b (m/pred string? ?value)} [:b ?value] {:foo/optional (m/pred string? ?value)} [:optional ?value]) ;; =&gt; ([:a &quot;...&quot;] [:b &quot;...&quot;] [:optional &quot;..&quot;]) "><y>#</y><d>2020-05-28</d><h>17:51</h><w>noprompt</w><a>@eoliphant</a> In cases like these, <code>search</code> is what I use
<pre>(m/search {:foo/a &quot;...&quot;
           :foo/b &quot;...&quot;
           :foo/optional &quot;..&quot;}
  {:foo/a (m/pred string? ?value)}
  [:a ?value]

  {:foo/b (m/pred string? ?value)}
  [:b ?value]

  {:foo/optional (m/pred string? ?value)}
  [:optional ?value])
;; =&gt;
([:a &quot;...&quot;] [:b &quot;...&quot;] [:optional &quot;..&quot;])</pre>
</z><z id="t1590688328" t="noprompt This yield k/v pairs."><y>#</y><d>2020-05-28</d><h>17:52</h><w>noprompt</w>This yield k/v pairs.</z><z id="t1590688338" t="eoliphant ah I see, then just jam those into a map"><y>#</y><d>2020-05-28</d><h>17:52</h><w>eoliphant</w>ah  I see, then just jam those into a map</z><z id="t1590688341" t="noprompt Yah"><y>#</y><d>2020-05-28</d><h>17:52</h><w>noprompt</w>Yah</z><z id="t1590688342" t="eoliphant that makes sense"><y>#</y><d>2020-05-28</d><h>17:52</h><w>eoliphant</w>that makes sense</z><z id="t1590688371" t="noprompt You can also use this “trick” to do validations e.g. where you search for the errors."><y>#</y><d>2020-05-28</d><h>17:52</h><w>noprompt</w>You can also use this “trick” to do validations e.g. where you search for the errors.</z><z id="t1590688376" t="eoliphant thanks. really great stuff by the way."><y>#</y><d>2020-05-28</d><h>17:52</h><w>eoliphant</w>thanks.  really great stuff by the way.</z><z id="t1590688401" t="noprompt Thanks. I appreciate the compliment. 👍"><y>#</y><d>2020-05-28</d><h>17:53</h><w>noprompt</w>Thanks. I appreciate the compliment. <b>👍</b></z><z id="t1590688415" t="eoliphant stuff like this and specter really take the clojure data-fu to the next level"><y>#</y><d>2020-05-28</d><h>17:53</h><w>eoliphant</w>stuff like this and specter really take the clojure data-fu to the next level</z><z id="t1590688486" t="noprompt It’s a work in progress but I hope its a worthy contribution. 🙂"><y>#</y><d>2020-05-28</d><h>17:54</h><w>noprompt</w>It’s a work in progress but I hope its a worthy contribution. <b>🙂</b></z><z id="t1590688522" t="eoliphant lol, I think it already is, but looking forward to what’s next"><y>#</y><d>2020-05-28</d><h>17:55</h><w>eoliphant</w>lol, I think it already is, but looking forward to what’s next</z><z id="t1590688570" t="noprompt Patience is whats next 😛"><y>#</y><d>2020-05-28</d><h>17:56</h><w>noprompt</w>Patience is whats next <b>😛</b></z><z id="t1590688690" t="noprompt The pandemic really punched my lights out. The lockdown has definitely put some things in to perspective."><y>#</y><d>2020-05-28</d><h>17:58</h><w>noprompt</w>The pandemic really punched my lights out. The lockdown has definitely put some things in to perspective.</z><z id="t1590688738" t="noprompt With my kids home all the time and not being able to hack as much, its given me a chance to take a moment and think about this open source thing."><y>#</y><d>2020-05-28</d><h>17:58</h><w>noprompt</w>With my kids home all the time and not being able to hack as much, its given me a chance to take a moment and think about this open source thing.</z><z id="t1590688781" t="noprompt Moral of the story: I need to take better care of myself."><y>#</y><d>2020-05-28</d><h>17:59</h><w>noprompt</w>Moral of the story: I need to take better care of myself.</z><z id="t1590688843" t="noprompt I had a ton of stuff planned to release this summer but like everything else there’s gonna be delays."><y>#</y><d>2020-05-28</d><h>18:00</h><w>noprompt</w>I had a ton of stuff planned to release this summer but like everything else there’s gonna be delays.</z><z id="t1590688896" t="noprompt But hopefully not too much delay."><y>#</y><d>2020-05-28</d><h>18:01</h><w>noprompt</w>But hopefully not too much delay.</z><z id="t1590688913" t="noprompt I want some better stuff too! 😄"><y>#</y><d>2020-05-28</d><h>18:01</h><w>noprompt</w>I want some better stuff too! <b>😄</b></z><z id="t1590689391" t="noprompt A road map of sorts would be: ensure the epsilon arm is in good shape, solid, and then release zeta sometime within the next year (`zeta` is built using epsilon )."><y>#</y><d>2020-05-28</d><h>18:09</h><w>noprompt</w>A road map of sorts would be: ensure the <code>epsilon</code> arm is in good shape, solid, and then release <code>zeta</code> sometime within the next year (`zeta` is built using <code>epsilon</code>).</z><z id="t1590691075" t="aisamu Pinging meander folks!"><y>#</y><d>2020-05-28</d><h>18:37</h><w>aisamu</w>Pinging meander folks!</z><z id="t1590691268" t="noprompt I have no idea! 🙂"><y>#</y><d>2020-05-28</d><h>18:41</h><w>noprompt</w>I have no idea! <b>🙂</b></z><z id="t1590691308" t="noprompt But, hey, we would love more contribution/help with that. I would love to learn more bytecode stuff."><y>#</y><d>2020-05-28</d><h>18:41</h><w>noprompt</w>But, hey, we would love more contribution/help with that. I would love to learn more bytecode stuff.</z><z id="t1590691764" t="Jimmy Miller I replied on there."><y>#</y><d>2020-05-28</d><h>18:49</h><w>Jimmy Miller</w>I replied on there.</z><z id="t1590693362" t="aisamu Thanks!"><y>#</y><d>2020-05-28</d><h>19:16</h><r>aisamu</r>Thanks!</z><z id="t1590704527" t="noprompt One small feature that will show up soon is the ability to turn on/off certain compiler features, etc."><y>#</y><d>2020-05-28</d><h>22:22</h><w>noprompt</w>One small feature that will show up soon is the ability to turn on/off certain compiler features, etc.</z><z id="t1590704637" t="noprompt The first iteration of this won’t be noticeable/immediately useful but after the foundation is set we can add support for alternative stuff like namespaced ::as patterns so that {:as ?as, :bs ?bs} will match/build {:as [1 2 3], :bs [1 2 3]} or whatever."><y>#</y><d>2020-05-28</d><h>22:23</h><w>noprompt</w>The first iteration of this won’t be noticeable/immediately useful but after the foundation is set we can add support for alternative stuff like namespaced <code>::as</code> patterns so that
<pre>{:as ?as, :bs ?bs}</pre>
will match/build
<pre>{:as [1 2 3], :bs [1 2 3]}</pre>
or whatever.</z><z id="t1590704745" t="noprompt If we play our cards right we can enable/try out new things, maybe even eliminate some bottlenecks/fix annoyances quickly."><y>#</y><d>2020-05-28</d><h>22:25</h><w>noprompt</w>If we play our cards right we can enable/try out new things, maybe even eliminate some bottlenecks/fix annoyances quickly.</z><z id="t1590704900" t="noprompt The idea will be that we can set these options via meta on the macro forms ^{::m/as-keyword ::m/as} (m/match {:as [1], :bs [2 3]} {:as ?as ::m/as ?it} [?as ?it]) ;; =&gt; [[1], {:as [1], :bs [2 3]}] "><y>#</y><d>2020-05-28</d><h>22:28</h><w>noprompt</w>The idea will be that we can set these options via meta on the macro forms
<pre>^{::m/as-keyword ::m/as}
(m/match {:as [1], :bs [2 3]}
  {:as ?as ::m/as ?it}
  [?as ?it])
;; =&gt; [[1], {:as [1], :bs [2 3]}] </pre>
</z><z id="t1590704969" t="noprompt The motivation to turn on/off compiler features is so that we can be sure that the semantics are preserved."><y>#</y><d>2020-05-28</d><h>22:29</h><w>noprompt</w>The motivation to turn on/off compiler features is so that we can be sure that the semantics are preserved.</z><z id="t1590705067" t="noprompt This was spurred on by a recent bug I discovered in an optimization and that made me paranoid. 🙂"><y>#</y><d>2020-05-28</d><h>22:31</h><w>noprompt</w>This was spurred on by a recent bug I discovered in an optimization and that made me paranoid. <b>🙂</b></z><z id="t1590705153" t="noprompt Hopefully this checks some confidence boxes for folks too. I know there was some concern about zeta being written with epsilon and epsilon having bugs. I feel the same concern and its why I’m doing this. 👍"><y>#</y><d>2020-05-28</d><h>22:32</h><w>noprompt</w>Hopefully this checks some confidence boxes for folks too. I know there was some concern about <code>zeta</code> being written with <code>epsilon</code> and <code>epsilon</code> having bugs. I feel the same concern and its why I’m doing this. <b>👍</b></z><z id="t1590705284" t="noprompt Transparency! 🙂"><y>#</y><d>2020-05-28</d><h>22:34</h><w>noprompt</w>Transparency! <b>🙂</b></z><z id="t1590705335" t="noprompt Also, I think by doing this I can tweak some implementation details in the compiler that might actually be slowing things down."><y>#</y><d>2020-05-28</d><h>22:35</h><w>noprompt</w>Also, I think by doing this I can tweak some implementation details in the compiler that might actually be slowing things down.</z><z id="t1590739300" t="delaguardo Hi there! I recently wrote a small library inspired by meander - https://github.com/xapix-io/matchete would like to know what you think about it main differences: • ~180 cloc • no macroses • recursive patterns"><y>#</y><d>2020-05-29</d><h>08:01</h><w>delaguardo</w>Hi there!
I recently wrote a small library inspired by meander - <a href="https://github.com/xapix-io/matchete" target="_blank">https://github.com/xapix-io/matchete</a>
would like to know what you think about it
main differences:
• ~180 cloc
• no macroses
• recursive patterns</z><z id="t1590765763" t="Jimmy Miller [:attrs {:href &quot;/_/_/users/U04V4KLKC&quot;}] That&apos;s awesome!"><y>#</y><d>2020-05-29</d><h>15:22</h><w>Jimmy Miller</w><a>@delaguardo</a> That&apos;s awesome!</z><z id="t1590765794" t="Jimmy Miller Definitely will be taking a closer look soon"><y>#</y><d>2020-05-29</d><h>15:23</h><w>Jimmy Miller</w>Definitely will be taking a closer look soon</z><z id="t1590770995" t="noprompt [:attrs {:href &quot;/_/_/users/U04V4KLKC&quot;}] Yah, nice work man! 🙂"><y>#</y><d>2020-05-29</d><h>16:49</h><w>noprompt</w><a>@delaguardo</a> Yah, nice work man! <b>🙂</b></z><z id="t1590771050" t="noprompt The code looks pretty clean and easy to follow."><y>#</y><d>2020-05-29</d><h>16:50</h><w>noprompt</w>The code looks pretty clean and easy to follow.</z><z id="t1590771080" t="noprompt Something fun to implement if you’re feeling adventurous is the pattern matcher from Egison: https://www.egison.org"><y>#</y><d>2020-05-29</d><h>16:51</h><w>noprompt</w>Something fun to implement if you’re feeling adventurous is the pattern matcher from Egison: <a href="https://www.egison.org" target="_blank">https://www.egison.org</a></z><z id="t1590929736" t="delaguardo https://github.com/xapix-io/matchete/blob/master/dev/example/graph.cljc one of egison’s examples implemented with matchete )"><y>#</y><d>2020-05-31</d><h>12:55</h><r>delaguardo</r><a href="https://github.com/xapix-io/matchete/blob/master/dev/example/graph.cljc" target="_blank">https://github.com/xapix-io/matchete/blob/master/dev/example/graph.cljc</a>
one of egison’s examples implemented with matchete )</z><z id="t1590771321" t="noprompt I’m definitely feeling like I need to export an interpreter."><y>#</y><d>2020-05-29</d><h>16:55</h><w>noprompt</w>I’m definitely feeling like I need to export an interpreter.</z><z id="t1590771326" t="delaguardo I wrote matchete because I’m currently working on toy programming language based on pattern matching + aggregates) thanks for the link! was not seeing it yet"><y>#</y><d>2020-05-29</d><h>16:55</h><w>delaguardo</w>I wrote matchete because I’m currently working on toy programming language based on pattern matching + aggregates)
thanks for the link! was not seeing it yet</z><z id="t1590771351" t="noprompt Thats fantastic. Please share that here. 🙂"><y>#</y><d>2020-05-29</d><h>16:55</h><w>noprompt</w>Thats fantastic. Please share that here. <b>🙂</b></z><z id="t1590771388" t="noprompt I suspect there are many PL nerds lurking here (I among them)."><y>#</y><d>2020-05-29</d><h>16:56</h><w>noprompt</w>I suspect there are many PL nerds lurking here (I among them).</z><z id="t1590771397" t="delaguardo it is far from beeing usable, but will do for sure"><y>#</y><d>2020-05-29</d><h>16:56</h><w>delaguardo</w>it is far from beeing usable, but will do for sure</z><z id="t1590771433" t="noprompt All good! Sometimes its just fun to share ideas."><y>#</y><d>2020-05-29</d><h>16:57</h><w>noprompt</w>All good! Sometimes its just fun to share ideas.</z><z id="t1590771451" t="noprompt I have several incomplete toy PLs. 😛"><y>#</y><d>2020-05-29</d><h>16:57</h><w>noprompt</w>I have several incomplete toy PLs. <b>😛</b></z><z id="t1590924662" t="dominicm https://clojurians.slack.com/archives/CHY97NXE2/p1590874589272100"><y>#</y><d>2020-05-31</d><h>11:31</h><w>dominicm</w><a href="https://clojurians.slack.com/archives/CHY97NXE2/p1590874589272100" target="_blank">https://clojurians.slack.com/archives/CHY97NXE2/p1590874589272100</a></z><z id="t1590924690" t="dominicm My idea was to scan the form for ?xxx and !xxx and bind them?"><y>#</y><d>2020-05-31</d><h>11:31</h><w>dominicm</w>My idea was to scan the form for ?xxx and !xxx and bind them?</z><z id="t1590925220" t="dominicm Wouldn&apos;t work, as they&apos;d flag as unused. So you&apos;d need to do something more complex."><y>#</y><d>2020-05-31</d><h>11:40</h><w>dominicm</w>Wouldn&apos;t work, as they&apos;d flag as unused. So you&apos;d need to do something more complex.</z><z id="t1591028848" t="noprompt [:attrs {:href &quot;/_/_/users/U09LZR36F&quot;}] Whats flagged unused?"><y>#</y><d>2020-06-01</d><h>16:27</h><w>noprompt</w><a>@dominicm</a> Whats flagged unused?</z><z id="t1591028921" t="dominicm [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] For something like: {:a ?a :b ?b} (+ ?b 10) ?a would be unused, but you&apos;re using it to ensure :a is present… Although maybe I&apos;m doing it wrong :)"><y>#</y><d>2020-06-01</d><h>16:28</h><w>dominicm</w><a>@noprompt</a> For something like:

<pre>{:a ?a :b ?b} (+ ?b 10)
</pre>

?a would be unused, but you&apos;re using it to ensure :a is present… Although maybe I&apos;m doing it wrong :)</z><z id="t1591029072" t="noprompt {:a (m/some) :b ?b} (+ ?b 10) "><y>#</y><d>2020-06-01</d><h>16:31</h><w>noprompt</w><pre>{:a (m/some) :b ?b} (+ ?b 10)</pre>
</z><z id="t1591029221" t="dominicm [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] Ah, so maybe my hack is sufficient then. If I get some energy I&apos;ll play around with it."><y>#</y><d>2020-06-01</d><h>16:33</h><w>dominicm</w><a>@noprompt</a> Ah, so maybe my hack is sufficient then.  If I get some energy I&apos;ll play around with it.</z><z id="t1591029226" t="dominicm Oh, hmm, that&apos;s not the same?"><y>#</y><d>2020-06-01</d><h>16:33</h><w>dominicm</w>Oh, hmm, that&apos;s not the same?</z><z id="t1591029236" t="dominicm {:a nil} should match {:a ?a}"><y>#</y><d>2020-06-01</d><h>16:33</h><w>dominicm</w><code>{:a nil}</code> should match <code>{:a ?a}</code></z><z id="t1591029253" t="noprompt It’ll also match {:no-a here}"><y>#</y><d>2020-06-01</d><h>16:34</h><w>noprompt</w>It’ll also match <code>{:no-a here}</code></z><z id="t1591029448" t="noprompt Going back and forth here on the most delicate way to express this but, eh, I can’t tactfully say it better: that macroexpand idea is a mixed bag."><y>#</y><d>2020-06-01</d><h>16:37</h><w>noprompt</w>Going back and forth here on the most delicate way to express this but, eh, I can’t tactfully say it better: that macroexpand idea is a mixed bag.</z><z id="t1591029496" t="dominicm It&apos;s a difficult set of constraints to balance. I&apos;m thinking that core.match and meander are probably the major use-cases for it."><y>#</y><d>2020-06-01</d><h>16:38</h><w>dominicm</w>It&apos;s a difficult set of constraints to balance.  I&apos;m thinking that core.match and meander are probably the major use-cases for it.</z><z id="t1591029520" t="noprompt I stopped using clj-kondo because of all the complaints about variables it didn’t understand in macros."><y>#</y><d>2020-06-01</d><h>16:38</h><w>noprompt</w>I stopped using clj-kondo because of all the complaints about variables it didn’t understand in macros.</z><z id="t1591029548" t="noprompt IMHO some kind of symbolic execution would probably be the best."><y>#</y><d>2020-06-01</d><h>16:39</h><w>noprompt</w>IMHO some kind of symbolic execution would probably be the best.</z><z id="t1591029564" t="noprompt But its a lot of work."><y>#</y><d>2020-06-01</d><h>16:39</h><w>noprompt</w>But its a lot of work.</z><z id="t1591029581" t="dominicm yeah, it is. I do wonder if sci could just run meander tbh."><y>#</y><d>2020-06-01</d><h>16:39</h><w>dominicm</w>yeah, it is. I do wonder  if sci could just run meander tbh.</z><z id="t1591029593" t="noprompt I was thinking that too."><y>#</y><d>2020-06-01</d><h>16:39</h><w>noprompt</w>I was thinking that too.</z><z id="t1591029622" t="dominicm matchete might make a good candidate also."><y>#</y><d>2020-06-01</d><h>16:40</h><w>dominicm</w>matchete might make a good candidate also.</z><z id="t1591029635" t="noprompt I made a thing for code search/replace about a year ago but I never made it into a solid stand alone thing."><y>#</y><d>2020-06-01</d><h>16:40</h><w>noprompt</w>I made a thing for code search/replace about a year ago but I never made it into a solid stand alone thing.</z><z id="t1591029651" t="dominicm Ultimately, whatever we would implement only need be &quot;good enough&quot; that 99% of my annoyances with meander linting go away :)"><y>#</y><d>2020-06-01</d><h>16:40</h><w>dominicm</w>Ultimately, whatever we would implement only need be &quot;good enough&quot; that 99% of my annoyances with meander linting go away :)</z><z id="t1591029655" t="snoe let me know if you figure it out, clojure-lsp has to keep expanding it&apos;s macro-defs for handling the problem 😞"><y>#</y><d>2020-06-01</d><h>16:40</h><w>snoe</w>let me know if you figure it out, clojure-lsp has to keep expanding it&apos;s macro-defs for handling the problem <b>😞</b></z><z id="t1591029656" t="noprompt We could export an interpreter pretty easily."><y>#</y><d>2020-06-01</d><h>16:40</h><w>noprompt</w>We could export an interpreter pretty easily.</z><z id="t1591029698" t="noprompt Its been an outstanding issue for a while."><y>#</y><d>2020-06-01</d><h>16:41</h><w>noprompt</w>Its been an outstanding issue for a while.</z><z id="t1591029759" t="noprompt [:attrs {:href &quot;/_/_/users/U0BUV7XSA&quot;}] I’m putting a sticky on my monitor to remind me to get familiar with clojure-lsp this week."><y>#</y><d>2020-06-01</d><h>16:42</h><w>noprompt</w><a>@snoe</a> I’m putting a sticky on my monitor to remind me to get familiar with clojure-lsp this week.</z><z id="t1591029834" t="noprompt [:attrs {:href &quot;/_/_/users/U09LZR36F&quot;}] Seems like clj-kondo would have an off switch."><y>#</y><d>2020-06-01</d><h>16:43</h><w>noprompt</w><a>@dominicm</a> Seems like clj-kondo would have an off switch.</z><z id="t1591029838" t="noprompt For specific forms."><y>#</y><d>2020-06-01</d><h>16:43</h><w>noprompt</w>For specific forms.</z><z id="t1591029857" t="noprompt Linters. 💣"><y>#</y><d>2020-06-01</d><h>16:44</h><w>noprompt</w>Linters. <b>💣</b></z><z id="t1591029900" t="dominicm [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] you can, yeah. But it&apos;s nice to get some feedback within those forms. Consider my try+, I&apos;d have to disable linting in the whole try+ macro, so it wouldn&apos;t catch this: (try+ (let [x] …)) "><y>#</y><d>2020-06-01</d><h>16:45</h><w>dominicm</w><a>@noprompt</a> you can, yeah.  But it&apos;s nice to get some feedback within those forms.  Consider my try+, I&apos;d have to disable linting in the whole try+ macro, so it wouldn&apos;t catch this:

<pre>(try+
  (let [x] …))
</pre></z><z id="t1591029945" t="dominicm To clarify, kondo already has the off-switch for specific forms :)"><y>#</y><d>2020-06-01</d><h>16:45</h><w>dominicm</w>To clarify, kondo already has the off-switch for specific forms :)</z><z id="t1591029953" t="noprompt This is one of the reasons I like the idea of “notation” over macros."><y>#</y><d>2020-06-01</d><h>16:45</h><w>noprompt</w>This is one of the reasons I like the idea of “notation” over macros.</z><z id="t1591029965" t="noprompt Because with notation its simply a symbolic transformation."><y>#</y><d>2020-06-01</d><h>16:46</h><w>noprompt</w>Because with notation its simply a symbolic transformation.</z><z id="t1591030024" t="dominicm notation?"><y>#</y><d>2020-06-01</d><h>16:47</h><w>dominicm</w>notation?</z><z id="t1591030033" t="noprompt Macros can have arbitrary code run which is super powerful but comes at the expense of increased analysis difficulty."><y>#</y><d>2020-06-01</d><h>16:47</h><w>noprompt</w>Macros can have arbitrary code run which is super powerful but comes at the expense of increased analysis difficulty.</z><z id="t1591030039" t="dominicm Right"><y>#</y><d>2020-06-01</d><h>16:47</h><w>dominicm</w>Right</z><z id="t1591030046" t="noprompt defsyntax has this problem."><y>#</y><d>2020-06-01</d><h>16:47</h><w>noprompt</w><code>defsyntax</code> has this problem.</z><z id="t1591030070" t="noprompt I wanted to add defnotation which would basically be a symbolic rewrite rule instead of one that executes code."><y>#</y><d>2020-06-01</d><h>16:47</h><w>noprompt</w>I wanted to add <code>defnotation</code> which would basically be a symbolic rewrite rule instead of one that executes code.</z><z id="t1591030099" t="noprompt The advantage is that there is no code which can interfere with determining the shape of data coming out of the transform."><y>#</y><d>2020-06-01</d><h>16:48</h><w>noprompt</w>The advantage is that there is no code which can interfere with determining the shape of data coming out of the transform.</z><z id="t1591030135" t="noprompt At the cost of the power to manipulate strings and do many evil things therein. 😛"><y>#</y><d>2020-06-01</d><h>16:48</h><w>noprompt</w>At the cost of the power to manipulate strings and do many evil things therein. <b>😛</b></z></g><g id="s3"><z id="t1591030168" t="noprompt Here’s the delta interpreter: https://gist.github.com/noprompt/085d100de4e85d7b643e438498e08b56"><y>#</y><d>2020-06-01</d><h>16:49</h><w>noprompt</w>Here’s the delta interpreter: <a href="https://gist.github.com/noprompt/085d100de4e85d7b643e438498e08b56" target="_blank">https://gist.github.com/noprompt/085d100de4e85d7b643e438498e08b56</a></z><z id="t1591030203" t="noprompt Basically, you would parse the form and then interpret the match."><y>#</y><d>2020-06-01</d><h>16:50</h><w>noprompt</w>Basically, you would <code>parse</code> the form and then interpret the match.</z><z id="t1591030265" t="noprompt zeta kinda works both ways where the macro compiler uses the interpreter API when it as to and more advanced compilation moves when it can."><y>#</y><d>2020-06-01</d><h>16:51</h><w>noprompt</w><code>zeta</code> kinda works both ways where the macro compiler uses the interpreter API when it as to and more advanced compilation moves when it can.</z><z id="t1591030298" t="dominicm Not at keyboard, but would {:a _} be the right form?"><y>#</y><d>2020-06-01</d><h>16:51</h><w>dominicm</w>Not at keyboard, but would <code>{:a _}</code> be the right form?</z><z id="t1591030305" t="noprompt epsilon probably should have been designed this way from the start but I started at “make a pattern matcher like core match that I maintain”"><y>#</y><d>2020-06-01</d><h>16:51</h><w>noprompt</w><code>epsilon</code> probably should have been designed this way from the start but I started at “make a pattern matcher like core match that I maintain”</z><z id="t1591030362" t="noprompt No, you have to use m/some ."><y>#</y><d>2020-06-01</d><h>16:52</h><w>noprompt</w>No, you have to use <code>m/some</code>.</z><z id="t1591030420" t="noprompt With the ability to configure the compiler/parser/etc soon we can indicate that a map is strict."><y>#</y><d>2020-06-01</d><h>16:53</h><w>noprompt</w>With the ability to configure the compiler/parser/etc soon we can indicate that a map is strict.</z><z id="t1591030471" t="dominicm But m/some wouldn&apos;t match a nil value. That makes the behavior different."><y>#</y><d>2020-06-01</d><h>16:54</h><w>dominicm</w>But m/some wouldn&apos;t match a nil value. That makes the behavior different.</z><z id="t1591030489" t="noprompt The decision to place the constraint on value is 99% due to the fact there is no operational/observable difference between (get {} :a) and (get {:a nil} :a) ."><y>#</y><d>2020-06-01</d><h>16:54</h><w>noprompt</w>The decision to place the constraint on value is 99% due to the fact there is no operational/observable difference between <code>(get {} :a)</code> and <code>(get {:a nil} :a)</code>.</z><z id="t1591030496" t="noprompt Yeah…"><y>#</y><d>2020-06-01</d><h>16:54</h><w>noprompt</w>Yeah…</z><z id="t1591030506" t="noprompt That’s the screwed up thing."><y>#</y><d>2020-06-01</d><h>16:55</h><w>noprompt</w>That’s the screwed up thing.</z><z id="t1591030553" t="dominicm (get {:a nil} :a :default)"><y>#</y><d>2020-06-01</d><h>16:55</h><w>dominicm</w><code>(get {:a nil} :a :default)</code></z><z id="t1591030584" t="noprompt This is why I like the pattern (if-some [[_ value] (find m :a)] ,,,) "><y>#</y><d>2020-06-01</d><h>16:56</h><w>noprompt</w>This is why I like the pattern
<pre>(if-some [[_ value] (find m :a)]
  ,,,)</pre>
</z><z id="t1591030638" t="dominicm Yeah, I sometimes use that too :)"><y>#</y><d>2020-06-01</d><h>16:57</h><w>dominicm</w>Yeah, I sometimes use that too :)</z><z id="t1591030650" t="dominicm I try to be conscious of allowing nil"><y>#</y><d>2020-06-01</d><h>16:57</h><w>dominicm</w>I try to be conscious of allowing nil</z><z id="t1591030706" t="noprompt Right. It was a decision I made early on. The tradeoff of matching on the result of get is this situation."><y>#</y><d>2020-06-01</d><h>16:58</h><w>noprompt</w>Right. It was a decision I made early on. The tradeoff of matching on the result of <code>get</code> is this situation.</z><z id="t1591030736" t="noprompt But if you have strict map matching with find it can get really annoying."><y>#</y><d>2020-06-01</d><h>16:58</h><w>noprompt</w>But if you have strict map matching with <code>find</code> it can get really annoying.</z><z id="t1591030850" t="noprompt Maybe something like ^:strict {:a nil} "><y>#</y><d>2020-06-01</d><h>17:00</h><w>noprompt</w>Maybe something like
<pre>^:strict {:a nil}</pre>
</z><z id="t1591031737" t="noprompt BTW, if folks have any thoughts/ideas for flags share them on this PR: https://github.com/noprompt/meander/pull/124"><y>#</y><d>2020-06-01</d><h>17:15</h><w>noprompt</w>BTW, if folks have any thoughts/ideas for flags share them on this PR: <a href="https://github.com/noprompt/meander/pull/124" target="_blank">https://github.com/noprompt/meander/pull/124</a></z><z id="t1591031848" t="noprompt My primary goal for this patch at the moment is to be able to completely move any AST manipulation out of the matrix compiler and into the match syntax namespace and then have flags to turn them on/off"><y>#</y><d>2020-06-01</d><h>17:17</h><w>noprompt</w>My primary goal for this patch at the moment is to be able to completely move any AST manipulation out of the matrix compiler and into the match syntax namespace and then have flags to turn them on/off</z><z id="t1591037908" t="dominicm I just realized we were talking past each other. https://cljdoc.org/d/meander/epsilon/0.0.421/doc/operator-overview#logic-variables title is optional in this example. I thought it was required."><y>#</y><d>2020-06-01</d><h>18:58</h><w>dominicm</w>I just realized we were talking past each other. <a href="https://cljdoc.org/d/meander/epsilon/0.0.421/doc/operator-overview#logic-variables" target="_blank">https://cljdoc.org/d/meander/epsilon/0.0.421/doc/operator-overview#logic-variables</a> title is optional in this example. I thought it was required.</z><z id="t1591270996" t="pithyless meander:epsilon:jar:0.0.421 seems to be missing on clojars"><y>#</y><d>2020-06-04</d><h>11:43</h><w>pithyless</w><code>meander:epsilon:jar:0.0.421</code> seems to be missing on clojars</z><z id="t1591286759" t="Jimmy Miller [:attrs {:href &quot;/_/_/users/U05476190&quot;}] It seems to be working for me. https://clojars.org/meander/epsilon I ran this as well and it seems to be working: clj -Sforce -Sdeps &apos;{:deps {meander/epsilon {:mvn/version &quot;0.0.421&quot;}}}&apos; Downloading: meander/epsilon/0.0.421/epsilon-0.0.421.pom from clojars Downloading: meander/epsilon/0.0.421/epsilon-0.0.421.jar from clojars Clojure 1.10.1 user=&gt; (require &apos;[meander.epsilon :as m]) nil user=&gt; Are you seeing some error on your end?"><y>#</y><d>2020-06-04</d><h>16:05</h><w>Jimmy Miller</w><a>@pithyless</a> It seems to be working for me. <a href="https://clojars.org/meander/epsilon" target="_blank">https://clojars.org/meander/epsilon</a>

I ran this as well and it seems to be working:

<pre>clj -Sforce -Sdeps &apos;{:deps {meander/epsilon {:mvn/version &quot;0.0.421&quot;}}}&apos;
Downloading: meander/epsilon/0.0.421/epsilon-0.0.421.pom from clojars
Downloading: meander/epsilon/0.0.421/epsilon-0.0.421.jar from clojars
Clojure 1.10.1
user=&gt;  (require &apos;[meander.epsilon :as m])
nil
user=&gt; </pre>
Are you seeing some error on your end?</z><z id="t1591290319" t="pithyless Yeah, that&apos;s really wierd: ❯ clj -Sforce -Sdeps &apos;{:deps {meander/epsilon {:mvn/version &quot;0.0.421&quot;}}}&apos; Error building classpath. Could not transfer artifact meander:epsilon:jar:0.0.421 from/to clojars (): Range Not Satisfiable (416)"><y>#</y><d>2020-06-04</d><h>17:05</h><w>pithyless</w>Yeah, that&apos;s really wierd:
<pre>❯ clj -Sforce -Sdeps &apos;{:deps {meander/epsilon {:mvn/version &quot;0.0.421&quot;}}}&apos;
Error building classpath. Could not transfer artifact meander:epsilon:jar:0.0.421 from/to clojars (): Range Not Satisfiable (416)</pre></z><z id="t1591290439" t="pithyless vs, say: ❯ clj -Sforce -Sdeps &apos;{:deps {meander/epsilon {:mvn/version &quot;0.0.411&quot;}}}&apos; Downloading: meander/epsilon/0.0.411/epsilon-0.0.411.pom from clojars"><y>#</y><d>2020-06-04</d><h>17:07</h><w>pithyless</w>vs, say:
<pre>❯ clj -Sforce -Sdeps &apos;{:deps {meander/epsilon {:mvn/version &quot;0.0.411&quot;}}}&apos;
Downloading: meander/epsilon/0.0.411/epsilon-0.0.411.pom from clojars</pre></z><z id="t1591291808" t="pithyless OK, the #clojars channel came to the rescue with a quick cache-busting fix. 🙂"><y>#</y><d>2020-06-04</d><h>17:30</h><w>pithyless</w>OK, the #clojars channel came to the rescue with a quick cache-busting fix. <b>🙂</b></z><z id="t1591291874" t="Jimmy Miller Nice. Glad you got that fixed."><y>#</y><d>2020-06-04</d><h>17:31</h><w>Jimmy Miller</w>Nice. Glad you got that fixed.</z><z id="t1591641281" t="Jimmy Miller Just published a new article called “Building Meander in Meander”. In it, I walk through a little toy version of meander, written using meander. We build a parser, then an interpreter. Then I show how meander makes it incredibly easy to turn an interpreter into a compiler. This is a simplified version of what we are doing in zeta, so I thought it might interesting to folks here. https://jimmyhmiller.github.io/building-meander-in-meander"><y>#</y><d>2020-06-08</d><h>18:34</h><w>Jimmy Miller</w>Just published a new article called “Building Meander in Meander”. In it, I walk through a little toy version of meander, written using meander. We build a parser, then an interpreter. Then I show how meander makes it incredibly easy to turn an interpreter into a compiler. This is a simplified version of what we are doing in zeta, so I thought it might interesting to folks here.

<a href="https://jimmyhmiller.github.io/building-meander-in-meander" target="_blank">https://jimmyhmiller.github.io/building-meander-in-meander</a></z><z id="t1591641522" t="noprompt It’s an outstanding article folks. It’s an honor to have someone like Jimmy in our community. 🙂"><y>#</y><d>2020-06-08</d><h>18:38</h><w>noprompt</w>It’s an outstanding article folks. It’s an honor to have someone like Jimmy in our community. <b>🙂</b></z><z id="t1591643576" t="markaddleman Great article!"><y>#</y><d>2020-06-08</d><h>19:12</h><w>markaddleman</w>Great article!</z><z id="t1591736842" t="markaddleman I&apos;d like to lodge a complaint: Because of meander&apos;s outstanding expressiveness and concision, I am forced to confront how slow I am at solving my real business problem."><y>#</y><d>2020-06-09</d><h>21:07</h><w>markaddleman</w>I&apos;d like to lodge a complaint:  Because of meander&apos;s outstanding expressiveness and concision, I am forced to confront how slow I am at solving my real business problem.</z><z id="t1591736986" t="markaddleman Of course, to a large degree, this is true of clojure in general. Meander (unfortunately for me), sharpens expressiveness to such a degree, I can no longer hide my inadequacies"><y>#</y><d>2020-06-09</d><h>21:09</h><r>markaddleman</r>Of course, to a large degree, this is true of clojure in general.  Meander (unfortunately for me), sharpens expressiveness to such a degree, I can no longer hide my inadequacies</z><z id="t1591745595" t="noprompt Ha! 🙂"><y>#</y><d>2020-06-09</d><h>23:33</h><w>noprompt</w>Ha! <b>🙂</b></z><z id="t1591745731" t="noprompt In my pursuit of putting compiler optimizations behind flags I’m also managing to fix other internal issues, really hacks."><y>#</y><d>2020-06-09</d><h>23:35</h><w>noprompt</w>In my pursuit of putting compiler optimizations behind flags I’m also managing to fix other internal issues, really hacks.</z><z id="t1591745905" t="noprompt Search space generation for certain classes of sets/map patterns will be improving."><y>#</y><d>2020-06-09</d><h>23:38</h><w>noprompt</w>Search space generation for certain classes of sets/map patterns will be improving.</z><z id="t1591745962" t="noprompt I think some day I should take a moment to slice out a some of the combinatorics stuff."><y>#</y><d>2020-06-09</d><h>23:39</h><w>noprompt</w>I think some day I should take a moment to slice out a some of the combinatorics stuff.</z><z id="t1591751771" t="Dustin Getz (def body2 [1 2 3 &apos;=&gt; nil 5 6 &apos;=&gt; nil 8 &apos;=&gt; nil]) (m/rewrite body2 (m/scan !xs ..!n &apos;=&gt; ?v) [[!xs ..!n] ?v]) ; [[1 2 3] nil] How do I make it return all the matches, not just one? I see rewrites but having trouble"><y>#</y><d>2020-06-10</d><h>01:16</h><w>Dustin Getz</w><pre>(def body2 [1 2 3 &apos;=&gt; nil
              5 6 &apos;=&gt; nil
              8 &apos;=&gt; nil])

(m/rewrite body2
  (m/scan !xs ..!n &apos;=&gt; ?v)
  [[!xs ..!n] ?v])

; [[1 2 3] nil]</pre>
How do I make it return all the matches, not just one? I see rewrites but having trouble</z><z id="t1591752254" t="Dustin Getz I got it with cata, but maybe there is a better way (m/rewrite body2 [] [] [!xs ... &apos;=&gt; ?v &amp; ?more] [[!xs ... ?v] &amp; (m/cata ?more)]) ; [[1 2 3 nil] [5 6 nil] [8 nil]]"><y>#</y><d>2020-06-10</d><h>01:24</h><w>Dustin Getz</w>I got it with cata, but maybe there is a better way
<pre>(m/rewrite body2
    [] []
    [!xs ... &apos;=&gt; ?v &amp; ?more]
    [[!xs ... ?v] &amp; (m/cata ?more)])

; [[1 2 3 nil] [5 6 nil] [8 nil]]</pre></z><z id="t1591756395" t="Jimmy Miller I think cata is the way I&apos;d recommend."><y>#</y><d>2020-06-10</d><h>02:33</h><w>Jimmy Miller</w>I think cata is the way I&apos;d recommend.</z><z id="t1591991487" t="noprompt https://gist.github.com/noprompt/56d73411ce1adb4130b8a2255beba793"><y>#</y><d>2020-06-12</d><h>19:51</h><w>noprompt</w><a href="https://gist.github.com/noprompt/56d73411ce1adb4130b8a2255beba793" target="_blank">https://gist.github.com/noprompt/56d73411ce1adb4130b8a2255beba793</a></z><z id="t1591991552" t="noprompt This is a start on a project.clj to deps.edn rewrite. Happy to include this in the examples/ folder, turn it into a script if anyone wants to dog pile on."><y>#</y><d>2020-06-12</d><h>19:52</h><w>noprompt</w>This is a start on a project.clj to deps.edn rewrite. Happy to include this in the <code>examples/</code> folder, turn it into a script if anyone wants to dog pile on.</z><z id="t1592270031" t="noprompt Some good news: The next release of Meander will be generally faster! The work I’ve been doing to put optimizations behind flags has lead me to address a number of related gaps in the current implementation. The match compiler (e.g. the macro expansion), and map and set pattern matching have received some much needed attention over the past few weeks. I’m really excited to get these updates out."><y>#</y><d>2020-06-16</d><h>01:13</h><w>noprompt</w>Some good news: The next release of Meander will be generally faster! The work I’ve been doing to put optimizations behind flags has lead me to address a number of related gaps in the current implementation. The match compiler (e.g. the macro expansion), and map and set pattern matching have received some much needed attention over the past few weeks. I’m really excited to get these updates out.</z><z id="t1592270205" t="noprompt To throw some numbers out, currently on my machine it takes somewhere between 900 and 1000ms to run the Clojure test suite. On the epsilon-compiler-flags branch the same test suite runs in between 580 and 650ms. Thats a significant improvement."><y>#</y><d>2020-06-16</d><h>01:16</h><w>noprompt</w>To throw some numbers out, currently on my machine it takes somewhere between 900 and 1000ms to run the Clojure test suite. On the <code>epsilon-compiler-flags</code> branch the same test suite runs in between 580 and 650ms. Thats a significant improvement.</z><z id="t1592270858" t="noprompt I think this is post compile e.g. post macro expansion but I don’t know for certain. If anyone knows let me know because I’m too lazy to look at the moment. 🙂"><y>#</y><d>2020-06-16</d><h>01:27</h><w>noprompt</w>I think this is post compile e.g. post macro expansion but I don’t know for certain. If anyone knows let me know because I’m too lazy to look at the moment. <b>🙂</b></z><z id="t1592330170" t="respatialized hi there! I have a question about some memory variable behavior that I find a little confusing. I&apos;m trying to pattern match by a predicate and then put all matches into a hiccup data structure. Here&apos;s a basic example, adapted from the documentation: (let [!s [&quot;a&quot; &quot;b&quot; &quot;c&quot;]] (m/subst [:ul . [:li !s] ...])) =&gt; [:ul [:li &quot;a&quot;] [:li &quot;b&quot;] [:li &quot;c&quot;]] However, when I try to extract the same memory variable as defined by m/scan , it behaves differently in the context of m/rewrites : (m/rewrites [1 2 &quot;a&quot; &quot;b&quot; &quot;c&quot;] (m/scan (m/pred string? !s)) [:ul . [:li !s] ...]) =&gt; ([:ul [:li &quot;a&quot;]] [:ul [:li &quot;b&quot;]] [:ul [:li &quot;c&quot;]]) I assume this is because m/rewrites always expects to return a sequential collection and thus ignores the head/tail delimiting with . and ... that works in the context of m/subst . m/rewrite doesn&apos;t work here because it only returns the first value of the memory variable. I&apos;m not quite sure how to proceed - what method should I be using instead? Any guidance is much appreciated!"><y>#</y><d>2020-06-16</d><h>17:56</h><w>respatialized</w>hi there! I have a question about some memory variable behavior that I find a little confusing. I&apos;m trying to pattern match by a predicate and then put all matches into a <code>hiccup</code> data structure. Here&apos;s a basic example, adapted from the documentation:
<pre>(let [!s [&quot;a&quot; &quot;b&quot; &quot;c&quot;]] (m/subst [:ul . [:li !s] ...]))
=&gt; [:ul [:li &quot;a&quot;] [:li &quot;b&quot;] [:li &quot;c&quot;]]</pre>
However, when I try to extract the same memory variable as defined by <code>m/scan</code> , it behaves differently in the context of <code>m/rewrites</code>:
<pre>(m/rewrites [1 2 &quot;a&quot; &quot;b&quot; &quot;c&quot;]  (m/scan (m/pred string? !s)) 
                                    [:ul . [:li !s] ...])
=&gt; ([:ul [:li &quot;a&quot;]] [:ul [:li &quot;b&quot;]] [:ul [:li &quot;c&quot;]])</pre>
I assume this is because <code>m/rewrites</code> always expects to return a sequential collection and thus ignores the head/tail delimiting with <code>.</code> and <code>...</code> that works in the context of <code>m/subst</code>. <code>m/rewrite</code> doesn&apos;t work here because it only returns the first value of the memory variable. I&apos;m not quite sure how to proceed - what method should I be using instead? Any guidance is much appreciated!</z><z id="t1592331160" t="noprompt [:attrs {:href &quot;/_/_/users/UFTRLDZEW&quot;}] is this the result you are looking for? (m/rewrites [1 2 &quot;a&quot; &quot;b&quot; &quot;c&quot;] (m/seqable (m/or (m/pred string? !s) _) ...) [:ul . [:li !s] ...]) ;; =&gt; ([:ul [:li &quot;a&quot;] [:li &quot;b&quot;] [:li &quot;c&quot;]] [:ul [:li &quot;a&quot;] [:li &quot;b&quot;]] [:ul [:li &quot;a&quot;] [:li &quot;c&quot;]] [:ul [:li &quot;a&quot;]] [:ul [:li &quot;b&quot;] [:li &quot;c&quot;]] [:ul [:li &quot;b&quot;]] [:ul [:li &quot;c&quot;]] [:ul]) "><y>#</y><d>2020-06-16</d><h>18:12</h><w>noprompt</w><a>@afoltzm</a> is this the result you are looking for?
<pre>(m/rewrites [1 2 &quot;a&quot; &quot;b&quot; &quot;c&quot;]
  (m/seqable (m/or (m/pred string? !s) _) ...) 
  [:ul . [:li !s] ...])
;; =&gt;
([:ul [:li &quot;a&quot;] [:li &quot;b&quot;] [:li &quot;c&quot;]]
 [:ul [:li &quot;a&quot;] [:li &quot;b&quot;]]
 [:ul [:li &quot;a&quot;] [:li &quot;c&quot;]]
 [:ul [:li &quot;a&quot;]]
 [:ul [:li &quot;b&quot;] [:li &quot;c&quot;]]
 [:ul [:li &quot;b&quot;]]
 [:ul [:li &quot;c&quot;]]
 [:ul])</pre>
</z><z id="t1592331236" t="noprompt In situations where you want to find all the possible ways to project some values into a memory variable you’ll want to use the (m/or pattern-with-mem-vars _) technique. Memory variables, unlike logic variables, are always initialized which is why you can use them like this."><y>#</y><d>2020-06-16</d><h>18:13</h><w>noprompt</w>In situations where you want to find all the possible ways to project some values into a memory variable you’ll want to use the <code>(m/or pattern-with-mem-vars _)</code> technique. Memory variables, unlike logic variables, are always initialized which is why you can use them like this.</z><z id="t1592331297" t="noprompt Note, you can replace m/seqable with [,,,] etc."><y>#</y><d>2020-06-16</d><h>18:14</h><w>noprompt</w>Note, you can replace <code>m/seqable</code> with <code>[,,,]</code> etc.</z><z id="t1592332942" t="respatialized this is what really made it click for me - remembering that I&apos;m rewriting a sequence and therefore I need to match a pattern within that sequence."><y>#</y><d>2020-06-16</d><h>18:42</h><r>respatialized</r>this is what really made it click for me - remembering that I&apos;m rewriting a sequence and therefore I need to match a pattern within that sequence.</z><z id="t1592331644" t="respatialized [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] I&apos;m only interested in the first result. is there a simpler way to express the case with the maximal set of results, or should I just take the first value? thanks for the quick response!"><y>#</y><d>2020-06-16</d><h>18:20</h><w>respatialized</w><a>@noprompt</a> I&apos;m only interested in the first result. is there a simpler way to express the case with the maximal set of results, or should I just take the first value? thanks for the quick response!</z><z id="t1592331692" t="noprompt Using rewrite in the above example will yield [:ul [:li &quot;a&quot;] [:li &quot;b&quot;] [:li &quot;c&quot;]] "><y>#</y><d>2020-06-16</d><h>18:21</h><w>noprompt</w>Using <code>rewrite</code> in the above example will yield
<pre>[:ul [:li &quot;a&quot;] [:li &quot;b&quot;] [:li &quot;c&quot;]]</pre>
</z><z id="t1592331831" t="noprompt We try and respond as quickly as we can here. 🙂"><y>#</y><d>2020-06-16</d><h>18:23</h><w>noprompt</w>We try and respond as quickly as we can here. <b>🙂</b></z><z id="t1592331956" t="respatialized I knew there had to be a way with m/rewrite even if I wasn&apos;t sure what it was. It&apos;s taken me a fair bit to wrap my head around term rewriting, but the old Alan Perlis quotation comes to mind as I work through the examples - &quot;A language that doesn&apos;t affect the way you think about programming, is not worth knowing.&quot; Thanks again."><y>#</y><d>2020-06-16</d><h>18:25</h><w>respatialized</w>I knew there had to be a way with <code>m/rewrite</code> even if I wasn&apos;t sure what it was. It&apos;s taken me a fair bit to wrap my head around term rewriting, but the old Alan Perlis quotation comes to mind as I work through the examples - &quot;A language that doesn&apos;t affect the way you think about programming, is not worth knowing.&quot; Thanks again.</z><z id="t1592332326" t="noprompt It definitely has that effect. Maude, TXL, and StrategoXT, to name a few, influenced me and fundamentally changed my thoughts on what program is and could be."><y>#</y><d>2020-06-16</d><h>18:32</h><w>noprompt</w>It definitely has that effect. Maude, TXL, and StrategoXT, to name a few, influenced me and fundamentally changed my thoughts on what program is and could be.</z><z id="t1592332386" t="noprompt Having Meander in Clojure has been personally interesting to me because it wasn’t until I was able to get it off the ground that I could start messing with the ideas in a different setting: the REPL."><y>#</y><d>2020-06-16</d><h>18:33</h><w>noprompt</w>Having Meander in Clojure has been personally interesting to me because it wasn’t until I was able to get it off the ground that I could start messing with the ideas in a different setting: the REPL.</z><z id="t1592332483" t="noprompt BTW, for anyone interested, have a look at those languages if you have the spare time to do so. Maude, in particular, was really interesting to me."><y>#</y><d>2020-06-16</d><h>18:34</h><w>noprompt</w>BTW, for anyone interested, have a look at those languages if you have the spare time to do so. Maude, in particular, was really interesting to me.</z><z id="t1592332532" t="noprompt I’m hoping that within the next year or so we can get zeta off the ground and have some of the power of model checking in Clojure."><y>#</y><d>2020-06-16</d><h>18:35</h><w>noprompt</w>I’m hoping that within the next year or so we can get <code>zeta</code> off the ground and have some of the power of model checking in Clojure.</z><z id="t1592332942" t="respatialized this is what really made it click for me - remembering that I&apos;m rewriting a sequence and therefore I need to match a pattern within that sequence."><y>#</y><d>2020-06-16</d><h>18:42</h><w>respatialized</w>this is what really made it click for me - remembering that I&apos;m rewriting a sequence and therefore I need to match a pattern within that sequence.</z><z id="t1592335102" t="respatialized One more question. I want to do the following: 1. For every item in a sequence: 2a. If that item matches a predicate with m/pred , split that item into a subsequence with m/app , collect the items in that subsequence into a memory variable !is , and then insert those values into the enclosing sequence in order. (e.g. something like (m/app #(clojure.string/split % #&quot;|&quot;) &quot;a|b|c&quot;) ) 2b. If that item doesn&apos;t match a predicate, leave it as-is in the same position."><y>#</y><d>2020-06-16</d><h>19:18</h><w>respatialized</w>One more question. I want to do the following:
1. For every item in a sequence: 
 2a. If that item matches a predicate with <code>m/pred</code>, split that item into a subsequence with <code>m/app</code>, collect the items in that subsequence into a memory variable <code>!is</code> , and then insert those values into the enclosing sequence in order. (e.g. something like <code>(m/app #(clojure.string/split % #&quot;|&quot;) &quot;a|b|c&quot;)</code> )
 2b. If that item doesn&apos;t match a predicate, leave it as-is in the same position.</z><z id="t1592335362" t="Jimmy Miller (m/rewrite [&quot;ad,sf&quot; 1 &quot;asd,fa,sdf&quot; 2 3] [(m/or (m/and (m/pred string?) (m/app #(clojure.string/split % #&quot;,&quot;) [!xs ...])) !xs) ...] [!xs ...]) ;; =&gt; [&quot;ad&quot; &quot;sf&quot; 1 &quot;asd&quot; &quot;fa&quot; &quot;sdf&quot; 2 3] [:attrs {:href &quot;/_/_/users/UFTRLDZEW&quot;}] Is this what you mean?"><y>#</y><d>2020-06-16</d><h>19:22</h><w>Jimmy Miller</w><pre>(m/rewrite [&quot;ad,sf&quot; 1 &quot;asd,fa,sdf&quot; 2 3]
  [(m/or 
    (m/and (m/pred string?) (m/app #(clojure.string/split % #&quot;,&quot;) [!xs ...]))
    !xs) ...]
  [!xs ...])

;; =&gt;

[&quot;ad&quot; &quot;sf&quot; 1 &quot;asd&quot; &quot;fa&quot; &quot;sdf&quot; 2 3]</pre>
<a>@afoltzm</a> Is this what you mean?</z><z id="t1592335402" t="respatialized [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] precisely!"><y>#</y><d>2020-06-16</d><h>19:23</h><w>respatialized</w><a>@jimmy</a> precisely!</z><z id="t1592335560" t="respatialized I guess I still don&apos;t fully understand how the combinators in meander work because I didn&apos;t realize you could use m/and to combine a predicate with a function application. Thanks for clarifying!"><y>#</y><d>2020-06-16</d><h>19:26</h><w>respatialized</w>I guess I still don&apos;t fully understand how the combinators in <code>meander</code> work because I didn&apos;t realize you could use <code>m/and</code> to combine a predicate with a function application. Thanks for clarifying!</z><z id="t1592335773" t="noprompt You can also do (m/pred string? (m/app ,,,)))"><y>#</y><d>2020-06-16</d><h>19:29</h><w>noprompt</w>You can also do <code>(m/pred string? (m/app ,,,)))</code></z><z id="t1592335872" t="Jimmy Miller All I did was do the little ‘and’ and ‘or’ trick to emulate an if statement. Used to have to do it all the time in complex (and terrible) sql stored procedures. and and or in meander work just like their logical counterparts. (map (fn [x] (or (and (string? x) (clojure.string/split x #&quot;,&quot;)) x)) [&quot;ad,sf&quot; 1 &quot;asd,fa,sdf&quot; 2 3])"><y>#</y><d>2020-06-16</d><h>19:31</h><w>Jimmy Miller</w>All I did was do the little ‘and’ and ‘or’ trick to emulate an if statement. Used to have to do it all the time in complex (and terrible) sql stored procedures.

<code>and</code> and <code>or</code> in meander work just like their logical counterparts.

<pre>(map (fn [x]
       (or
        (and (string? x) (clojure.string/split x #&quot;,&quot;))
        x))
     [&quot;ad,sf&quot; 1 &quot;asd,fa,sdf&quot; 2 3])</pre></z><z id="t1592494748" t="noprompt [meander/epsilon &quot;0.0.469&quot;] • Improve map/set performance • Improve not pattern code generation • Compiler environment flags can be passed via meta (needs documentation)"><y>#</y><d>2020-06-18</d><h>15:39</h><w>noprompt</w><pre>[meander/epsilon &quot;0.0.469&quot;]</pre>
• Improve map/set performance
• Improve not pattern code generation
• Compiler environment flags can be passed via meta (needs documentation)</z><z id="t1592515194" t="noprompt If anyone runs into any trouble with the new version please let me know. For the most part, things are mostly the same, however, there were some non trivial changes and even though we have a large suite of tests its always possible for something to get missed."><y>#</y><d>2020-06-18</d><h>21:19</h><w>noprompt</w>If anyone runs into any trouble with the new version please let me know. For the most part, things are mostly the same, however, there were some non trivial changes and even though we have a large suite of tests its always possible for something to get missed.</z><z id="t1592827865" t="pithyless Is there an idiomatic way in meander to match the ex-message and ex-data parts of an exception (not in try/catch, just as some data that&apos;s embedded in a map)?"><y>#</y><d>2020-06-22</d><h>12:11</h><w>pithyless</w>Is there an idiomatic way in meander to match the ex-message and ex-data parts of an exception (not in try/catch, just as some data that&apos;s embedded in a map)?</z><z id="t1592843266" t="noprompt Like (m/app ex-data {:error/type ?error-type}) kinda thing?"><y>#</y><d>2020-06-22</d><h>16:27</h><r>noprompt</r>Like
<pre>(m/app ex-data {:error/type ?error-type})</pre>
kinda thing?</z><z id="t1592859428" t="pithyless yeah, so I guess something like this is appropriate? (m/and (m/app ex-message &quot;Some Error&quot;) (m/app ex-data {:some :data}))"><y>#</y><d>2020-06-22</d><h>20:57</h><r>pithyless</r>yeah, so I guess something like this is appropriate?
<pre>(m/and (m/app ex-message &quot;Some Error&quot;)
       (m/app ex-data {:some :data}))</pre></z><z id="t1592867975" t="noprompt (m/defsyntax ex [message data] `(m/and (m/app ex-message ~message) (m/app ex-data ~data))) "><y>#</y><d>2020-06-22</d><h>23:19</h><r>noprompt</r><pre>(m/defsyntax ex [message data]
  `(m/and (m/app ex-message ~message)
          (m/app ex-data ~data)))</pre>
</z><z id="t1592867986" t="noprompt (If its common enough to warrant.)"><y>#</y><d>2020-06-22</d><h>23:19</h><r>noprompt</r>(If its common enough to warrant.)</z><z id="t1593100728" t="nlessa Hi! (me/match &apos;[?a :?a] [?e (me/app keyword ?e)] true) =&gt; fails What am I missing?"><y>#</y><d>2020-06-25</d><h>15:58</h><w>nlessa</w>Hi!
<code>(me/match &apos;[?a :?a]</code>
          <code>[?e (me/app keyword ?e)] true) =&gt; fails</code>
What am I missing?</z><z id="t1593106148" t="noprompt [:attrs {:href &quot;/_/_/users/U1ERECYRE&quot;}] I think because the pattern is backwards? (m/match &apos;[?a :?a] [(m/app keyword ?e) ?e] true) ;; =&gt; true "><y>#</y><d>2020-06-25</d><h>17:29</h><w>noprompt</w><a>@nlessa</a> I think because the pattern is backwards?

<pre>(m/match &apos;[?a :?a]
  [(m/app keyword ?e) ?e]
  true)
;; =&gt; true</pre>
</z><z id="t1593106313" t="noprompt In the example you shared keyword is being applied to :?a and then compared to &apos;?a (`?e`) and fails."><y>#</y><d>2020-06-25</d><h>17:31</h><w>noprompt</w>In the example you shared <code>keyword</code> is being applied to <code>:?a</code> and then compared to <code>&apos;?a</code> (`?e`) and fails.</z><z id="t1593264132" t="grounded_sage I remember seeing an example of using Meander on something like Javascript bytecode. Did you write that [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] or would you happen to know where i can find it?"><y>#</y><d>2020-06-27</d><h>13:22</h><w>grounded_sage</w>I remember seeing an example of using Meander on something like Javascript bytecode. Did you write that <a>@noprompt</a> or would you happen to know where i can find it?</z><z id="t1593374079" t="noprompt [:attrs {:href &quot;/_/_/users/U05095F2K&quot;}] You could do something wacky like this: https://gist.github.com/noprompt/205788065849051a604d5557d79210c1#file-js-clj-L115-L118"><y>#</y><d>2020-06-28</d><h>19:54</h><w>noprompt</w><a>@grounded_sage</a> You could do something wacky like this: <a href="https://gist.github.com/noprompt/205788065849051a604d5557d79210c1#file-js-clj-L115-L118" target="_blank">https://gist.github.com/noprompt/205788065849051a604d5557d79210c1#file-js-clj-L115-L118</a></z><z id="t1593374094" t="noprompt (js &apos;(. foo bar {&quot;blue&quot; true} 42)) ;; =&gt; &quot;foo.bar({\&quot;blue\&quot;:true},42)&quot; "><y>#</y><d>2020-06-28</d><h>19:54</h><w>noprompt</w><pre>(js &apos;(. foo bar {&quot;blue&quot; true} 42))
;; =&gt;
&quot;foo.bar({\&quot;blue\&quot;:true},42)&quot;</pre>
</z><z id="t1593374208" t="grounded_sage Hmm no it wasn’t that. Maybe I am imagining things haha."><y>#</y><d>2020-06-28</d><h>19:56</h><w>grounded_sage</w>Hmm no it wasn’t that. Maybe I am imagining things haha.</z><z id="t1593374252" t="noprompt Maybe someone else made the example… that would be really cool and I’d love to see it."><y>#</y><d>2020-06-28</d><h>19:57</h><w>noprompt</w>Maybe someone else made the example… that would be really cool and I’d love to see it.</z><z id="t1593593473" t="jlmr Hi, I’m hoping to use meander to extract the relevant information from some XML. I’ve used clojure.data.xml to parse the following XML. I would like to extract some fields for each of the :tag :record records. I don’t expect a fully formed pattern but it would be great if someone could point me in the right direction."><y>#</y><d>2020-07-01</d><h>08:51</h><w>jlmr</w>Hi, I’m hoping to use meander to extract the relevant information from some XML. I’ve used <code>clojure.data.xml</code> to parse the following XML. I would like to extract some fields for each of the <code>:tag :record</code> records. I don’t expect a fully formed pattern but it would be great if someone could point me in the right direction.</z><z id="t1593593869" t="noprompt You could start with m/$ which is kind of like jQuery: ;; Assuming `data` is the data you provided. (m/search data (m/$ {:tag :record :as ?data}) ?data) ;; =&gt; ({:attrs {}, :content ({:attrs {:status &quot;deleted&quot;}, :content ({:attrs {}, :content (&quot;l4l:oai:), :tag :identifier} {:attrs {}, :content (&quot;2019-03-30T00:07:07Z&quot;), :tag :datestamp} {:attrs {}, :content (&quot;l4l&quot;), :tag :setSpec}), :tag :header}), :tag :record} ,,,) This will find all the {:tag :record} maps. 👍"><y>#</y><d>2020-07-01</d><h>08:57</h><r>noprompt</r>You could start with <code>m/$</code> which is kind of like jQuery:
<pre>;; Assuming `data` is the data you provided.
(m/search data
  (m/$ {:tag :record :as ?data})
  ?data)
;; =&gt;
({:attrs {},
  :content
  ({:attrs {:status &quot;deleted&quot;},
    :content
    ({:attrs {},
      :content (&quot;l4l:oai:),
      :tag :identifier}
     {:attrs {}, :content (&quot;2019-03-30T00:07:07Z&quot;), :tag :datestamp}
     {:attrs {}, :content (&quot;l4l&quot;), :tag :setSpec}),
    :tag :header}),
  :tag :record}
 ,,,)</pre>
This will find all the <code>{:tag :record}</code> maps. <b>👍</b></z><z id="t1593594128" t="jlmr [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] thanks! But then I would want to dive deeper into the records to extract only the relevant fields and put them into a flat clojure map: {:title &lt;extracted title&gt; :description &lt;extracted description&gt; :more :fields :like :this} . How would I go about that?"><y>#</y><d>2020-07-01</d><h>09:02</h><r>jlmr</r><a>@U06MDAPTP</a> thanks! But then I would want to dive deeper into the records to extract only the relevant fields and put them into a flat clojure map: <code>{:title &lt;extracted title&gt; :description &lt;extracted description&gt; :more :fields :like :this}</code>. How would I go about that?</z><z id="t1593594191" t="jlmr I’ve gotten as far as: (m/search xml (m/$ {:tag :record :content (m/$ {:tag :title :content (m/$ {:tag :langstring :content (?title)})})}) {:title ?title})"><y>#</y><d>2020-07-01</d><h>09:03</h><r>jlmr</r>I’ve gotten as far as:
<pre>(m/search xml
    (m/$ {:tag :record
          :content (m/$ {:tag :title
                         :content (m/$ {:tag :langstring
                                        :content (?title)})})})
    {:title ?title})</pre></z><z id="t1593594219" t="jlmr Is this the best way to continue?"><y>#</y><d>2020-07-01</d><h>09:03</h><r>jlmr</r>Is this the best way to continue?</z><z id="t1593594376" t="noprompt You could do that as well. However, if you know the data you are interested in exists in a certain location in the :content you can simply draw that as a pattern: {:tag :record :content (m/scan {:tag :title :content (?title)})} "><y>#</y><d>2020-07-01</d><h>09:06</h><r>noprompt</r>You could do that as well. However, if you know the data you are interested in exists in a certain location in the <code>:content</code> you can simply draw that as a pattern:
<pre>{:tag :record 
 :content (m/scan {:tag :title :content (?title)})}</pre>
</z><z id="t1593594527" t="noprompt Judging from the data, I think I would recommend separating that out as separate step rather than do it all in the pattern match."><y>#</y><d>2020-07-01</d><h>09:08</h><r>noprompt</r>Judging from the data, I think I would recommend separating that out as separate step rather than do it all in the pattern match.</z><z id="t1593594647" t="jlmr Ok, I will play with it some more, thanks for the tips!"><y>#</y><d>2020-07-01</d><h>09:10</h><r>jlmr</r>Ok, I will play with it some more, thanks for the tips!</z><z id="t1593603350" t="jlmr [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] one more question if you have time: (defn record [record] (m/find record (m/separated {:tag :metadata :content (m/scan {:tag :lom :content (m/separated {:tag :general :content (m/separated {:tag :title :content (m/scan {:content ?title})} {:tag :description :content ?description})})})}) {:title ?title :description ?description})) This is how far I’ve gotten so far. It works mostly, but I would expect (m/scan {:content ?title}) to return a sequence of all the titles. The data for that particular would look like this: ({:attrs {:xml/lang &quot;en&quot;} :content (&quot;English title&quot;) :tag :langstring} {:attrs {:xml/lang &quot;nl&quot;} :content (&quot;Dutch title&quot;) :tag :langstring})"><y>#</y><d>2020-07-01</d><h>11:35</h><r>jlmr</r><a>@U06MDAPTP</a> one more question if you have time:

<pre>(defn record
  [record]
  (m/find record
    (m/separated {:tag :metadata
                  :content (m/scan {:tag :lom
                                    :content (m/separated {:tag :general
                                                           :content (m/separated {:tag :title
                                                                                  :content (m/scan {:content ?title})}
                                                                                 {:tag :description
                                                                                  :content ?description})})})})
    {:title ?title
     :description ?description}))</pre>
This is how far I’ve gotten so far. It works mostly, but I would expect <code>(m/scan {:content ?title})</code> to return a sequence of all the titles. The data for that particular would look like this:
<pre>({:attrs {:xml/lang &quot;en&quot;}
  :content (&quot;English title&quot;)
  :tag :langstring}
 {:attrs {:xml/lang &quot;nl&quot;}
  :content (&quot;Dutch title&quot;)
  :tag :langstring})</pre></z><z id="t1593626169" t="noprompt I think you want to switch from find to search to yield all the results."><y>#</y><d>2020-07-01</d><h>17:56</h><r>noprompt</r>I think you want to switch from <code>find</code> to <code>search</code> to yield all the results.</z><z id="t1593645199" t="markaddleman Is there a more idiomatic way to write (m/rewrite query {:source {:scope {:type &quot;apps&quot; :apps (m/some ?apps) &amp; ?scope-rest} &amp; ?source-rest} &amp; ?rest} {:source {:scope {:type &quot;apps&quot; :apps ?apps :segment-query {:where {:op &quot;in&quot; :args [{:path [&quot;event-attr&quot; &quot;appKey&quot;]} {:op &quot;UNNEST&quot; :args [{:op &quot;ARRAY&quot; :args ?apps}]}]}} &amp; ?scope-rest} &amp; ?source-rest} &amp; ?rest}) In deeply nested maps like this, it&apos;s mildly cumbersome to manage all of the &amp; xyz terms"><y>#</y><d>2020-07-01</d><h>23:13</h><w>markaddleman</w>Is there a more idiomatic way to write
<pre>(m/rewrite query
    {:source {:scope {:type &quot;apps&quot; :apps (m/some ?apps) &amp; ?scope-rest} &amp; ?source-rest} &amp; ?rest}
    {:source {:scope {:type          &quot;apps&quot;
                      :apps          ?apps
                      :segment-query {:where {:op   &quot;in&quot;
                                              :args [{:path [&quot;event-attr&quot; &quot;appKey&quot;]}
                                                     {:op &quot;UNNEST&quot; :args [{:op &quot;ARRAY&quot; :args ?apps}]}]}}
                      &amp;              ?scope-rest}
              &amp;      ?source-rest}
     &amp;       ?rest})</pre>
In deeply nested maps like this, it&apos;s mildly cumbersome to manage all of the <code>&amp; xyz</code> terms</z><z id="t1593645619" t="Jimmy Miller I don’t know of any different way to express that rewrite. But you can put the &amp; ?rest terms at the beginning if that helps you keep track of them better. (m/rewrite query {:source {:scope {:type &quot;apps&quot; :apps (m/some ?apps) &amp; ?scope-rest} &amp; ?source-rest} &amp; ?rest} {&amp; ?rest :source {&amp; ?source-rest :scope {&amp; ?scope-rest :type &quot;apps&quot; :apps ?apps :segment-query {:where {:op &quot;in&quot; :args [{:path [&quot;event-attr&quot; &quot;appKey&quot;]} {:op &quot;UNNEST&quot; :args [{:op &quot;ARRAY&quot; :args ?apps}]}]}}}}})"><y>#</y><d>2020-07-01</d><h>23:20</h><w>Jimmy Miller</w>I don’t know of any different way to express that rewrite. But you can put the <code>&amp; ?rest</code> terms at the beginning if that helps you keep track of them better.

<pre>(m/rewrite query
  {:source {:scope {:type &quot;apps&quot; :apps (m/some ?apps) &amp; ?scope-rest} &amp; ?source-rest} &amp; ?rest}
  {&amp; ?rest
   :source 
   {&amp; ?source-rest
    :scope 
    {&amp; ?scope-rest
     :type &quot;apps&quot;
     :apps ?apps
     :segment-query {:where {:op &quot;in&quot;
                             :args [{:path [&quot;event-attr&quot; &quot;appKey&quot;]}
                                    {:op &quot;UNNEST&quot; :args [{:op &quot;ARRAY&quot; :args ?apps}]}]}}}}})</pre></z><z id="t1593645703" t="Jimmy Miller Other than syntactic things though, I can’t think of anything I would do differently."><y>#</y><d>2020-07-01</d><h>23:21</h><w>Jimmy Miller</w>Other than syntactic things though, I can’t think of anything I would do differently.</z><z id="t1593645735" t="markaddleman Thanks. Yeah, reordering will help a bit."><y>#</y><d>2020-07-01</d><h>23:22</h><w>markaddleman</w>Thanks.  Yeah, reordering will help a bit.</z><z id="t1593645781" t="markaddleman My use case has a lot of this sort of thing. I was wondering if there is broad value for a special kind of rewrite - something like rewrite-merge where the syntax favors merging new information into the map"><y>#</y><d>2020-07-01</d><h>23:23</h><w>markaddleman</w>My use case has a lot of this sort of thing.  I was wondering if there is broad value for a special kind of <code>rewrite</code> - something like <code>rewrite-merge</code> where the syntax favors merging new information into the map</z><z id="t1593664566" t="noprompt This topic comes up every now and then; I’m still interested to hear what ideas, sketches, etc. that people have."><y>#</y><d>2020-07-02</d><h>04:36</h><w>noprompt</w>This topic comes up every now and then; I’m still interested to hear what ideas, sketches, etc. that people have.</z><z id="t1594066877" t="ikrimael absolutely love meander. meta question: is there a repo/resource of cookbook examples? if not, shouldn&apos;t there be? (no slack history == probably repeated asks)"><y>#</y><d>2020-07-06</d><h>20:21</h><w>ikrimael</w>absolutely love meander.
meta question: is there a repo/resource of cookbook examples? if not, shouldn&apos;t there be? (no slack history == probably repeated asks)</z><z id="t1594067319" t="Jimmy Miller [:attrs {:href &quot;/_/_/users/U014X1MN7MM&quot;}] We do indeed have a cookbook https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md and some examples https://github.com/noprompt/meander/tree/epsilon/examples We are super open to contributions to either of these. Glad you are enjoying meander 🙂"><y>#</y><d>2020-07-06</d><h>20:28</h><w>Jimmy Miller</w><a>@e749</a> We do indeed have a cookbook <a href="https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md</a>
and some examples <a href="https://github.com/noprompt/meander/tree/epsilon/examples" target="_blank">https://github.com/noprompt/meander/tree/epsilon/examples</a>

We are super open to contributions to either of these.

Glad you are enjoying meander <b>🙂</b></z><z id="t1594067485" t="ikrimael [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] they&apos;ve been super helpful! btw, your talk &amp; blog posts were big reasons to convince me to try clojure for my dsl compiler rewrite"><y>#</y><d>2020-07-06</d><h>20:31</h><w>ikrimael</w><a>@jimmy</a> they&apos;ve been super helpful!  btw, your talk  &amp; blog posts were big reasons to convince me to try clojure for my dsl compiler rewrite</z><z id="t1594067628" t="ikrimael i guess I was looking for more basic examples altho just realizing I have no context the target user for the lib (beg &lt;&gt; super experienced)"><y>#</y><d>2020-07-06</d><h>20:33</h><w>ikrimael</w>i guess I was looking for more basic examples altho just realizing I have no context the target user for the lib (beg &lt;&gt; super experienced)</z><z id="t1594067639" t="ikrimael (context: i&apos;m new to clojure (day 4), old to programming)"><y>#</y><d>2020-07-06</d><h>20:33</h><w>ikrimael</w>(context: i&apos;m new to clojure (day 4), old to programming)</z><z id="t1594067683" t="noprompt [:attrs {:href &quot;/_/_/users/U014X1MN7MM&quot;}] FYI we merge most cookbook contributions without hesitation if you want to chip in. 🙂"><y>#</y><d>2020-07-06</d><h>20:34</h><w>noprompt</w><a>@e749</a> FYI we merge most cookbook contributions without hesitation if you want to chip in. <b>🙂</b></z><z id="t1594067709" t="noprompt LOL and welcome! 😂"><y>#</y><d>2020-07-06</d><h>20:35</h><w>noprompt</w>LOL and welcome! <b>😂</b></z><z id="t1594067717" t="ikrimael also more context, the applicability to term rewriting was the part that was especially exciting"><y>#</y><d>2020-07-06</d><h>20:35</h><w>ikrimael</w>also more context, the applicability to term rewriting was the part that was especially exciting</z><z id="t1594067746" t="ikrimael [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] i&apos;d be happy to but i&apos;m not sure you want an extreme beginner submitting anythingg 😅"><y>#</y><d>2020-07-06</d><h>20:35</h><w>ikrimael</w><a>@noprompt</a> i&apos;d be happy to but i&apos;m not sure you want an extreme beginner submitting anythingg <b>😅</b></z><z id="t1594067778" t="ikrimael or if you&apos;re fine with &quot;above average effort in codereviewing&quot;, i&apos;m happy to"><y>#</y><d>2020-07-06</d><h>20:36</h><w>ikrimael</w>or if you&apos;re fine with &quot;above average effort in codereviewing&quot;, i&apos;m happy to</z><z id="t1594067779" t="noprompt On the contrary, examples from beginners are usually the best!"><y>#</y><d>2020-07-06</d><h>20:36</h><w>noprompt</w>On the contrary, examples from beginners are usually the best!</z><z id="t1594067806" t="noprompt And, I was only making the suggestion. :)"><y>#</y><d>2020-07-06</d><h>20:36</h><w>noprompt</w>And, I was only making the suggestion. :)</z><z id="t1594067874" t="ikrimael 👍 totally; just hyper sensitive with demands on other people&apos;s free time x {good for community but not intrinsically motivating activities}"><y>#</y><d>2020-07-06</d><h>20:37</h><w>ikrimael</w><b>👍</b> totally; just hyper sensitive with demands on other people&apos;s free time x {good for community but not intrinsically motivating activities}</z><z id="t1594067891" t="noprompt 100% agree with you there. 🙂"><y>#</y><d>2020-07-06</d><h>20:38</h><w>noprompt</w>100% agree with you there. <b>🙂</b></z><z id="t1594067997" t="noprompt Which is why I don’t feel bad about taking breaks from the project from time to time. (Learned that the hard way this year.)"><y>#</y><d>2020-07-06</d><h>20:39</h><w>noprompt</w>Which is why I don’t feel bad about taking breaks from the project from time to time. (Learned that the hard way this year.)</z><z id="t1594068019" t="ikrimael is there a preferred way to go about this? ex: i&apos;m basically just making a cookbook for myself as i&apos;m rewriting the compiler i usually do the functional variant and then attempt it in meander should I post here and then submit a PR?"><y>#</y><d>2020-07-06</d><h>20:40</h><w>ikrimael</w>is there a preferred way to go about this? ex: i&apos;m basically just making a cookbook for myself as i&apos;m rewriting the compiler
i usually do the functional variant and then attempt it in meander
should I post here and then submit a PR?</z><z id="t1594068045" t="ikrimael i imagine both the clojure code &amp; the meander will need &quot;tweaks&quot; 😂"><y>#</y><d>2020-07-06</d><h>20:40</h><w>ikrimael</w>i imagine both the clojure code &amp; the meander will need &quot;tweaks&quot; <b>😂</b></z><z id="t1594068059" t="Jimmy Miller I&apos;m always happy to hear things people are looking for. I will say, we probably skew a bit more on the experienced side for active users. But there isn&apos;t a particular skill level we are trying to reach. We really just want to help people express their problems more clearly."><y>#</y><d>2020-07-06</d><h>20:40</h><w>Jimmy Miller</w>I&apos;m always happy to hear things people are looking for. I will say, we probably skew a bit more on the experienced side for active users. But there isn&apos;t a particular skill level we are trying to reach. We really just want to help people express their problems more clearly.</z><z id="t1594068067" t="noprompt I think that’d be a good way to learn how to map one on to the other."><y>#</y><d>2020-07-06</d><h>20:41</h><w>noprompt</w>I think that’d be a good way to learn how to map one on to the other.</z><z id="t1594068089" t="noprompt &gt; We really just want to help people express their problems more clearly. This"><y>#</y><d>2020-07-06</d><h>20:41</h><w>noprompt</w>&gt;  We really just want to help people express their problems more clearly.
This</z><z id="t1594068183" t="ikrimael 👍 i&apos;ll do that then in a file and then link it/PR it so the example chunks can be reviewed in batch"><y>#</y><d>2020-07-06</d><h>20:43</h><w>ikrimael</w><b>👍</b> i&apos;ll do that then in a file and then link it/PR it so the example chunks can be reviewed in batch</z><z id="t1594068307" t="noprompt Sharing ideas/critique here is also welcome/appreciated."><y>#</y><d>2020-07-06</d><h>20:45</h><w>noprompt</w>Sharing ideas/critique here is also welcome/appreciated.</z><z id="t1594169648" t="ikrimael [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] I added my first example with questions: https://github.com/noprompt/meander/pull/125/commits/556320934a6059fbff8c5bb986a1e8eb431352b2?short_path=4b806e6#diff-4b806e6fe29c6781cf8d51d441d3b4a9"><y>#</y><d>2020-07-08</d><h>00:54</h><w>ikrimael</w><a>@noprompt</a> <a>@jimmy</a> I added my first example with questions: <a href="https://github.com/noprompt/meander/pull/125/commits/556320934a6059fbff8c5bb986a1e8eb431352b2?short_path=4b806e6#diff-4b806e6fe29c6781cf8d51d441d3b4a9" target="_blank">https://github.com/noprompt/meander/pull/125/commits/556320934a6059fbff8c5bb986a1e8eb431352b2?short_path=4b806e6#diff-4b806e6fe29c6781cf8d51d441d3b4a9</a></z><z id="t1594169687" t="ikrimael I marked questions/requests for feedback with QUESTION tag inline"><y>#</y><d>2020-07-08</d><h>00:54</h><w>ikrimael</w>I marked questions/requests for feedback with QUESTION tag inline</z><z id="t1594169743" t="noprompt I saw that. 🙂"><y>#</y><d>2020-07-08</d><h>00:55</h><w>noprompt</w>I saw that. <b>🙂</b></z><z id="t1594169760" t="noprompt This is great by the way. 👍"><y>#</y><d>2020-07-08</d><h>00:56</h><w>noprompt</w>This is great by the way. <b>👍</b></z><z id="t1594169790" t="ikrimael meta-question: ofc lmk if there&apos;s other changes to make it easier to review. I had a bunch of examples and scrapped them once I realized I could answer all of them by looking at the tests file"><y>#</y><d>2020-07-08</d><h>00:56</h><w>ikrimael</w>meta-question: ofc lmk if there&apos;s other changes to make it easier to review. I had a bunch of examples and scrapped them once I realized I could answer all of them by looking at the tests file</z><z id="t1594169818" t="ikrimael ofc, i&apos;ll be going back to add them; was just way off in that first attempt"><y>#</y><d>2020-07-08</d><h>00:56</h><w>ikrimael</w>ofc, i&apos;ll be going back to add them; was just way off in that first attempt</z><z id="t1594169858" t="noprompt Ha! It’s funny because I’ve often thought it might be more accessible/friendly to extract some of the test examples into the cookbook i.e. the fib-test stuff."><y>#</y><d>2020-07-08</d><h>00:57</h><w>noprompt</w>Ha! It’s funny because I’ve often thought it might be more accessible/friendly to extract some of the test examples into the cookbook i.e. the <code>fib-test</code> stuff.</z><z id="t1594169891" t="ikrimael heh, fwiw, they were super helpful! also made me realize the docs didn&apos;t include the full api"><y>#</y><d>2020-07-08</d><h>00:58</h><w>ikrimael</w>heh, fwiw, they were super helpful! also made me realize the docs didn&apos;t include the full api</z><z id="t1594169943" t="noprompt Yeah, there’s a lot there and I generally don’t follow implementation updates, etc. with doc updates (I should, I know)."><y>#</y><d>2020-07-08</d><h>00:59</h><w>noprompt</w>Yeah, there’s a lot there and I generally don’t follow implementation updates, etc. with doc updates (I should, I know).</z><z id="t1594170006" t="ikrimael meta-comment: i think also helpful is more philosophical comment/feedback of &quot;should meander even be used for this scenario?&quot;"><y>#</y><d>2020-07-08</d><h>01:00</h><w>ikrimael</w>meta-comment: i think also helpful is more philosophical comment/feedback of &quot;should meander even be used for this scenario?&quot;</z><z id="t1594170137" t="noprompt Definitely. Honestly, we have made a good faith effort to do that here."><y>#</y><d>2020-07-08</d><h>01:02</h><w>noprompt</w>Definitely. Honestly, we have made a good faith effort to do that here.</z><z id="t1594170138" t="ikrimael I often find myself looking at my meander rewrite and thinking I&apos;ve made it more obtuse. (Ofc as one who&apos;s learning both clojure + meander, I put weight = near 0 on my thoughts at this point)"><y>#</y><d>2020-07-08</d><h>01:02</h><w>ikrimael</w>I often find myself looking at my meander rewrite and thinking I&apos;ve made it more obtuse.
(Ofc as one who&apos;s learning both clojure + meander, I put weight = near 0 on my thoughts at this point)</z><z id="t1594170160" t="noprompt A meander group-by often comes up and the recommendation has always been to just use group-by ."><y>#</y><d>2020-07-08</d><h>01:02</h><w>noprompt</w>A meander <code>group-by</code> often comes up and the recommendation has always been to just use <code>group-by</code>.</z><z id="t1594170208" t="ikrimael ah interesting; i&apos;ll have to look that up"><y>#</y><d>2020-07-08</d><h>01:03</h><w>ikrimael</w>ah interesting; i&apos;ll have to look that up</z><z id="t1594170276" t="ikrimael i&apos;ve also opted to put the different iterations of my meander attempts in the cookbook (both for future me&apos;s sake and learning value); ofc feel free to scrub them or maybe move them to a tutorial"><y>#</y><d>2020-07-08</d><h>01:04</h><w>ikrimael</w>i&apos;ve also opted to put the different iterations of my meander attempts in the cookbook (both for future me&apos;s sake and learning value); ofc feel free to scrub them or maybe move them to a tutorial</z><z id="t1594170429" t="noprompt Jimmy does that to great effect in some of his posts and I think it’s a nice way to guide someone from one place to the next."><y>#</y><d>2020-07-08</d><h>01:07</h><w>noprompt</w>Jimmy does that to great effect in some of his posts and I think it’s a nice way to guide someone from one place to the next.</z><z id="t1594170471" t="noprompt With rewrite you can do the (m/app #(-&gt;OppathSeg :seg-attr %1) !seg) on the right side."><y>#</y><d>2020-07-08</d><h>01:07</h><w>noprompt</w>With <code>rewrite</code> you can do the <code>(m/app #(-&gt;OppathSeg :seg-attr %1) !seg)</code> on the right side.</z><z id="t1594170528" t="noprompt Someone I work with isn’t really a fan of m/app on the left side."><y>#</y><d>2020-07-08</d><h>01:08</h><w>noprompt</w>Someone I work with isn’t really a fan of <code>m/app</code> on the left side.</z><z id="t1594170593" t="noprompt If I can defer m/app to the right side, I do."><y>#</y><d>2020-07-08</d><h>01:09</h><w>noprompt</w>If I can defer <code>m/app</code> to the right side, I do.</z><z id="t1594170632" t="ikrimael i&apos;d say i&apos;m in that camp too; i couldn&apos;t figure out how to carry the &quot;patteern match state&quot; though to the right side"><y>#</y><d>2020-07-08</d><h>01:10</h><w>ikrimael</w>i&apos;d say i&apos;m in that camp too; i couldn&apos;t figure out how to carry the &quot;patteern match state&quot; though to the right side</z><z id="t1594170676" t="ikrimael i.e. I find myself wanting to do this alot token ::= (:arg-in|:arg-out) ?argname pseudocode-result:: (str (emit-in ?arg-attr)|emit-out :arg-attr) ?argname)"><y>#</y><d>2020-07-08</d><h>01:11</h><w>ikrimael</w>i.e. I find myself wanting to do this alot
<pre>token ::= (:arg-in|:arg-out) ?argname
    pseudocode-result:: (str (emit-in ?arg-attr)|emit-out :arg-attr) ?argname)</pre></z><z id="t1594170711" t="noprompt Strings are on the list of things match/build."><y>#</y><d>2020-07-08</d><h>01:11</h><w>noprompt</w>Strings are on the list of things match/build.</z><z id="t1594170764" t="noprompt I’ve been catching up on some research and experimenting with how to model, compile, interpret, etc."><y>#</y><d>2020-07-08</d><h>01:12</h><w>noprompt</w>I’ve been catching up on some research and experimenting with how to model, compile, interpret, etc.</z><z id="t1594170804" t="ikrimael sans strings, would it be possible to do that? I keep reaching basically for the rhs to apply different functions based on the pattern matched"><y>#</y><d>2020-07-08</d><h>01:13</h><w>ikrimael</w>sans strings, would it be possible to do that? I keep reaching basically for the rhs to apply different functions based on the pattern matched</z><z id="t1594170804" t="noprompt Another thing that’s on the list is a way to aggregate."><y>#</y><d>2020-07-08</d><h>01:13</h><w>noprompt</w>Another thing that’s on the list is a way to aggregate.</z><z id="t1594170824" t="noprompt Possible to pattern match on strings?"><y>#</y><d>2020-07-08</d><h>01:13</h><w>noprompt</w>Possible to pattern match on strings?</z><z id="t1594170857" t="ikrimael ah, i mean excluding the string case"><y>#</y><d>2020-07-08</d><h>01:14</h><w>ikrimael</w>ah, i mean excluding the string case</z><z id="t1594170901" t="noprompt Oh are you asking if the thing matches bind it to a variable?"><y>#</y><d>2020-07-08</d><h>01:15</h><w>noprompt</w>Oh are you asking if the thing matches bind it to a variable?</z><z id="t1594170931" t="ikrimael ie in my example, i pattern match an xpath segment (ignore that it&apos;s a string). I want to apply a transform to said xpath segment depending on the type of xpath segment"><y>#</y><d>2020-07-08</d><h>01:15</h><w>ikrimael</w>ie in my example, i pattern match an xpath segment (ignore that it&apos;s a string). I want to apply a transform to said xpath segment depending on the type of xpath segment</z><z id="t1594170969" t="noprompt Use two memory variables?"><y>#</y><d>2020-07-08</d><h>01:16</h><w>noprompt</w>Use two memory variables?</z><z id="t1594171004" t="noprompt !seg-attrs , !seg-chlds and then apply the transforms on the right."><y>#</y><d>2020-07-08</d><h>01:16</h><w>noprompt</w><code>!seg-attrs</code> , <code>!seg-chlds</code> and then apply the transforms on the right.</z><z id="t1594171006" t="ikrimael oh; can I use m/or on the rhs in substitutions?"><y>#</y><d>2020-07-08</d><h>01:16</h><w>ikrimael</w>oh; can I use <code>m/or</code>  on the rhs in substitutions?</z><z id="t1594171039" t="noprompt You can’t use m/or on the right side yet."><y>#</y><d>2020-07-08</d><h>01:17</h><w>noprompt</w>You can’t use <code>m/or</code> on the right side yet.</z><z id="t1594171052" t="noprompt But memory variables are always initialized to the empty vector at a minimum."><y>#</y><d>2020-07-08</d><h>01:17</h><w>noprompt</w>But memory variables are always initialized to the empty vector at a minimum.</z><z id="t1594171098" t="noprompt [(m/app f !seg-attrs) ... (m/app g !seg-chlds) ...] "><y>#</y><d>2020-07-08</d><h>01:18</h><w>noprompt</w><pre>[(m/app f !seg-attrs) ... (m/app g !seg-chlds) ...]</pre>
</z><z id="t1594171134" t="noprompt FYI I gotta step away for a bit. Should be back in a couple hours."><y>#</y><d>2020-07-08</d><h>01:18</h><w>noprompt</w>FYI I gotta step away for a bit. Should be back in a couple hours.</z><z id="t1594171145" t="ikrimael sure, np! let me play with that a little"><y>#</y><d>2020-07-08</d><h>01:19</h><w>ikrimael</w>sure, np!
let me play with that a little</z><z id="t1594172059" t="ikrimael ah couldn&apos;t get it to work still. Here&apos;s a simplified snippet showcasing actual vs desired output (defn f [xseg] {:kind :seg-attr :val xseg}) (defn g [xseg] {:kind :seg-chld :val xseg}) (m/rewrite [&quot;oppas&quot; &quot;obj1&quot; &quot;@attr1&quot; &quot;@attr2&quot; &quot;obj2&quot;] (m/with [%segattr (m/pred #(= (first %1) \@) !seg-attrs) %segobj (m/pred #(not= (first %1) \@) !seg-chlds)] [(m/re #&quot;obj|oppas|dc&quot; ?ns) . (m/or %segobj %segattr) ...]) {:ns (keyword ?ns) :xsegs [(m/app f !seg-attrs) ... (m/app g !seg-chlds) ...]} ) ;; INCORRECT: =&gt; {:ns (keyword &quot;oppas&quot;) :xsegs [{:kind :seg-attr, :val &quot;@attr1&quot;} {:kind :seg-attr, :val &quot;@attr2&quot;} {:kind :seg-chld, :val &quot;obj1&quot;} {:kind :seg-chld, :val &quot;obj2&quot;}]} ;; CORRECT =&gt; {:ns (keyword &quot;oppas&quot;) :xsegs [{:kind :seg-chld, :val &quot;obj1&quot;} {:kind :seg-attr, :val &quot;@attr1&quot;} {:kind :seg-attr, :val &quot;@attr2&quot;} {:kind :seg-chld, :val &quot;obj2&quot;}]}"><y>#</y><d>2020-07-08</d><h>01:34</h><w>ikrimael</w>ah couldn&apos;t get it to work still. Here&apos;s a simplified snippet showcasing actual vs desired output

<pre>(defn f [xseg] {:kind :seg-attr :val xseg})
(defn g [xseg] {:kind :seg-chld :val xseg})
(m/rewrite [&quot;oppas&quot; &quot;obj1&quot; &quot;@attr1&quot; &quot;@attr2&quot; &quot;obj2&quot;]
  (m/with [%segattr (m/pred #(= (first %1) \@)    !seg-attrs)
           %segobj  (m/pred #(not= (first %1) \@) !seg-chlds)]
          [(m/re #&quot;obj|oppas|dc&quot; ?ns) . (m/or %segobj %segattr) ...])
  {:ns    (keyword ?ns)
   :xsegs [(m/app f !seg-attrs) ... (m/app g !seg-chlds) ...]}
)
;; INCORRECT: =&gt; 
{:ns (keyword &quot;oppas&quot;)
 :xsegs
 [{:kind :seg-attr, :val &quot;@attr1&quot;}
  {:kind :seg-attr, :val &quot;@attr2&quot;}
  {:kind :seg-chld, :val &quot;obj1&quot;}
  {:kind :seg-chld, :val &quot;obj2&quot;}]}

;; CORRECT =&gt;
{:ns (keyword &quot;oppas&quot;)
 :xsegs
 [{:kind :seg-chld, :val &quot;obj1&quot;}
  {:kind :seg-attr, :val &quot;@attr1&quot;}
  {:kind :seg-attr, :val &quot;@attr2&quot;}
  {:kind :seg-chld, :val &quot;obj2&quot;}]}</pre></z><z id="t1594179443" t="noprompt Gotcha. There are two approaches you could apply here. The first one uses a helper to construct the xseg: (defn make-xseg [val] (m/rewrite val (m/re #&quot;@.*&quot; ?val) {:kind :seg-attr :val ?val} (m/re #&quot;[^@].*&quot; ?val) {:kind :seg-chld :val ?val} ?val {:kind :unknown :val ?val})) (m/rewrite [&quot;oppas&quot; &quot;obj1&quot; &quot;@attr1&quot; &quot;@attr2&quot; &quot;obj2&quot;] [(m/re #&quot;obj|oppas|dc&quot; ?ns) . !segs ...] {:ns (m/keyword ?ns) :xsegs [(m/app make-xseg !segs) ...]}) ;; =&gt; {:ns :oppas, :xsegs [{:kind :seg-chld, :val &quot;obj1&quot;} {:kind :seg-attr, :val &quot;@attr1&quot;} {:kind :seg-attr, :val &quot;@attr2&quot;} {:kind :seg-chld, :val &quot;obj2&quot;}]} The second uses m/cata on the left or right side: ;; Left side (m/rewrite [&quot;oppas&quot; &quot;obj1&quot; &quot;@attr1&quot; &quot;@attr2&quot; &quot;obj2&quot;] [(m/re #&quot;obj|oppas|dc&quot; ?ns) . (m/cata !segs) ...] {:ns (m/keyword ?ns) :xsegs [!segs ...]} (m/re #&quot;@.*&quot; ?val) {:kind :seg-attr :val ?val} (m/re #&quot;[^@].*&quot; ?val) {:kind :seg-chld :val ?val} ?val {:kind :unknown :val ?val}) ;; Right side (m/rewrite [&quot;oppas&quot; &quot;obj1&quot; &quot;@attr1&quot; &quot;@attr2&quot; &quot;obj2&quot;] [(m/re #&quot;obj|oppas|dc&quot; ?ns) . !segs ...] {:ns (m/keyword ?ns) :xsegs [(m/cata !segs) ...]} (m/re #&quot;@.*&quot; ?val) {:kind :seg-attr :val ?val} (m/re #&quot;[^@].*&quot; ?val) {:kind :seg-chld :val ?val} ?val {:kind :unknown :val ?val})"><y>#</y><d>2020-07-08</d><h>03:37</h><w>noprompt</w>Gotcha. There are two approaches you could apply here. The first one uses a helper to construct the xseg:
<pre>(defn make-xseg [val]
  (m/rewrite val
    (m/re #&quot;@.*&quot; ?val)
    {:kind :seg-attr :val ?val}

    (m/re #&quot;[^@].*&quot; ?val)
    {:kind :seg-chld :val ?val}

    ?val
    {:kind :unknown :val ?val}))


(m/rewrite [&quot;oppas&quot; &quot;obj1&quot; &quot;@attr1&quot; &quot;@attr2&quot; &quot;obj2&quot;]
  [(m/re #&quot;obj|oppas|dc&quot; ?ns) . !segs ...]
  {:ns (m/keyword ?ns)
   :xsegs [(m/app make-xseg !segs) ...]})
;; =&gt;
{:ns :oppas,
 :xsegs
 [{:kind :seg-chld, :val &quot;obj1&quot;}
  {:kind :seg-attr, :val &quot;@attr1&quot;}
  {:kind :seg-attr, :val &quot;@attr2&quot;}
  {:kind :seg-chld, :val &quot;obj2&quot;}]}</pre>
The second uses <code>m/cata</code> on the left or right side:
<pre>;; Left side
(m/rewrite [&quot;oppas&quot; &quot;obj1&quot; &quot;@attr1&quot; &quot;@attr2&quot; &quot;obj2&quot;]
  [(m/re #&quot;obj|oppas|dc&quot; ?ns) . (m/cata !segs) ...]
  {:ns (m/keyword ?ns)
   :xsegs [!segs ...]}

  (m/re #&quot;@.*&quot; ?val)
  {:kind :seg-attr :val ?val}

  (m/re #&quot;[^@].*&quot; ?val)
  {:kind :seg-chld :val ?val}

  ?val
  {:kind :unknown :val ?val})

;; Right side
(m/rewrite [&quot;oppas&quot; &quot;obj1&quot; &quot;@attr1&quot; &quot;@attr2&quot; &quot;obj2&quot;]
  [(m/re #&quot;obj|oppas|dc&quot; ?ns) . !segs ...]
  {:ns (m/keyword ?ns)
   :xsegs [(m/cata !segs) ...]}

  (m/re #&quot;@.*&quot; ?val)
  {:kind :seg-attr :val ?val}

  (m/re #&quot;[^@].*&quot; ?val)
  {:kind :seg-chld :val ?val}

  ?val
  {:kind :unknown :val ?val})</pre></z><z id="t1594181841" t="markaddleman I hadn&apos;t thought about using cata on the right side before. In this example, it doesn&apos;t look like there&apos;s much advantage. Offhand, can you think of a situation where cata on the rhs is meaningfully different/important?"><y>#</y><d>2020-07-08</d><h>04:17</h><w>markaddleman</w>I hadn&apos;t thought about using cata on the right side before.  In this example, it doesn&apos;t look like there&apos;s much advantage.  Offhand, can you think of a situation where cata on the rhs is meaningfully different/important?</z><z id="t1594183079" t="JAtkins [:attrs {:href &quot;/_/_/users/U014X1MN7MM&quot;}] Thank you for adding more examples! I have tried a couple times to pick up meander, always got stuck on something. Hoping to make a push in 2-3 weeks to start using it alot more. (should go without saying thanks to Jole and the other authors too though 🙂 )"><y>#</y><d>2020-07-08</d><h>04:37</h><w>JAtkins</w><a>@e749</a> Thank you for adding more examples! I have tried a couple times to pick up meander, always got stuck on something. Hoping to make a push in 2-3 weeks to start using it alot more. (should go without saying thanks to Jole and the other authors too though <b>🙂</b>)</z><z id="t1594183284" t="ikrimael sure np! feel free to add feedback to the draft PRs"><y>#</y><d>2020-07-08</d><h>04:41</h><r>ikrimael</r>sure np! feel free to add feedback to the draft PRs</z><z id="t1594183503" t="noprompt [:attrs {:href &quot;/_/_/users/U5P29DSUS&quot;}] Reach out when you get stuck. If I can help, I will. 🙂"><y>#</y><d>2020-07-08</d><h>04:45</h><r>noprompt</r><a>@U5P29DSUS</a> Reach out when you get stuck. If I can help, I will. <b>🙂</b></z><z id="t1594184044" t="JAtkins Thanks, I will probably end up doing so 🙂 . I&apos;m trying to set myself up for success in https://github.com/JJ-Atkinson/Fisher project, and I think meander might be quite helpful for sections."><y>#</y><d>2020-07-08</d><h>04:54</h><r>JAtkins</r>Thanks, I will probably end up doing so <b>🙂</b>. I&apos;m trying to set myself up for success in <a href="https://github.com/JJ-Atkinson/Fisher" target="_blank">https://github.com/JJ-Atkinson/Fisher</a> project, and I think meander might be quite helpful for sections.</z><z id="t1594184185" t="ikrimael [:attrs {:href &quot;/_/_/users/U5P29DSUS&quot;}] hah! exactly what i&apos;m using it (albeit targetted towards C/C++)"><y>#</y><d>2020-07-08</d><h>04:56</h><r>ikrimael</r><a>@U5P29DSUS</a> hah! exactly what i&apos;m using it (albeit targetted towards C/C++)</z><z id="t1594184252" t="JAtkins How so?"><y>#</y><d>2020-07-08</d><h>04:57</h><r>JAtkins</r>How so?</z><z id="t1594184416" t="ikrimael parse decorated c/c++ =&gt; highlevel IR =&gt; clojure does term rewriting/inline expansion/etc =&gt; codegen c/c++ &amp; UI bindings =&gt; JIT back into the app/editor"><y>#</y><d>2020-07-08</d><h>05:00</h><r>ikrimael</r>parse decorated c/c++ =&gt; highlevel IR =&gt; clojure does term rewriting/inline expansion/etc =&gt; codegen c/c++ &amp; UI bindings =&gt; JIT back into the app/editor</z><z id="t1594184467" t="ikrimael it&apos;s more or less the lighttable dream but with c/c++ target &amp; gamedev focus"><y>#</y><d>2020-07-08</d><h>05:01</h><r>ikrimael</r>it&apos;s more or less the lighttable dream but with c/c++ target &amp; gamedev focus</z><z id="t1594184586" t="JAtkins Gacha. Sounds neat. It is/was a great piece of software."><y>#</y><d>2020-07-08</d><h>05:03</h><r>JAtkins</r>Gacha. Sounds neat. It is/was a great piece of software.</z><z id="t1594183133" t="noprompt [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] Cata on the right side can be used to construct a value to be recursively rewritten. It’s the dual of the left."><y>#</y><d>2020-07-08</d><h>04:38</h><w>noprompt</w><a>@markaddleman</a> Cata on the right side can be used to construct a value to be recursively rewritten. It’s the dual of the left.</z><z id="t1594183176" t="markaddleman Ah, of course. Thanks"><y>#</y><d>2020-07-08</d><h>04:39</h><r>markaddleman</r>Ah, of course.  Thanks</z><z id="t1594183232" t="noprompt (m/rewrite [&quot;oppas&quot; &quot;obj1&quot; &quot;@attr1&quot; &quot;@attr2&quot; &quot;obj2&quot;] [(m/re #&quot;obj|oppas|dc&quot; ?ns) . !segs ...] {:ns (m/keyword ?ns) :xsegs [(m/cata ($EXAMPLE !segs)) ...]} ($EXAMPLE (m/re #&quot;@.*&quot; ?val)) {:kind :seg-attr :val ?val} ($EXAMPLE (m/re #&quot;[^@].*&quot; ?val)) {:kind :seg-chld :val ?val} ($EXAMPLE ?val) {:kind :unknown :val ?val}) ;; =&gt; {:ns :oppas, :xsegs [{:kind :seg-chld, :val &quot;obj1&quot;} {:kind :seg-attr, :val &quot;@attr1&quot;} {:kind :seg-attr, :val &quot;@attr2&quot;} {:kind :seg-chld, :val &quot;obj2&quot;}]}"><y>#</y><d>2020-07-08</d><h>04:40</h><r>noprompt</r><pre>(m/rewrite [&quot;oppas&quot; &quot;obj1&quot; &quot;@attr1&quot; &quot;@attr2&quot; &quot;obj2&quot;]
  [(m/re #&quot;obj|oppas|dc&quot; ?ns) . !segs ...]
  {:ns (m/keyword ?ns)
   :xsegs [(m/cata ($EXAMPLE !segs)) ...]}

  ($EXAMPLE (m/re #&quot;@.*&quot; ?val))
  {:kind :seg-attr :val ?val}

  ($EXAMPLE (m/re #&quot;[^@].*&quot; ?val))

  {:kind :seg-chld :val ?val}

  ($EXAMPLE ?val)
  {:kind :unknown :val ?val})
;; =&gt;
{:ns :oppas,
 :xsegs
 [{:kind :seg-chld, :val &quot;obj1&quot;}
  {:kind :seg-attr, :val &quot;@attr1&quot;}
  {:kind :seg-attr, :val &quot;@attr2&quot;}
  {:kind :seg-chld, :val &quot;obj2&quot;}]}</pre></z><z id="t1594183412" t="noprompt You can do some exotic/interesting kinds of things with this."><y>#</y><d>2020-07-08</d><h>04:43</h><r>noprompt</r>You can do some exotic/interesting kinds of things with this.</z><z id="t1594183355" t="ikrimael brilliant; both left side/right side with m/cata feel clean and easily grokkable for future me"><y>#</y><d>2020-07-08</d><h>04:42</h><w>ikrimael</w>brilliant; both left side/right side with <code>m/cata</code> feel clean and easily grokkable for future me</z><z id="t1594426955" t="ikrimael [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] added a new example: Split stream based on filter and project https://github.com/noprompt/meander/blob/e562f563c42adf3763919dc7fb9cbab3b9c19b24/doc/cookbook.md#transform slowly getting the hang of things "><y>#</y><d>2020-07-11</d><h>00:22</h><w>ikrimael</w><a>@noprompt</a> added a new example: Split stream based on filter and project 
<a href="https://github.com/noprompt/meander/blob/e562f563c42adf3763919dc7fb9cbab3b9c19b24/doc/cookbook.md#transform" target="_blank">https://github.com/noprompt/meander/blob/e562f563c42adf3763919dc7fb9cbab3b9c19b24/doc/cookbook.md#transform</a>
slowly getting the hang of things
</z><z id="t1594426997" t="ikrimael part i struggled with is applying an or predicate on a pattern that can match multiple times"><y>#</y><d>2020-07-11</d><h>00:23</h><w>ikrimael</w>part i struggled with is applying an or predicate on a pattern that can match multiple times</z><z id="t1594427053" t="ikrimael ie, i have an array of objects with a bitflag (possible values: EArgIn, EArgIn |EArgOut, EArgOut )"><y>#</y><d>2020-07-11</d><h>00:24</h><w>ikrimael</w>ie, i have an array of objects with a bitflag (possible values: <code>EArgIn, EArgIn |EArgOut, EArgOut</code> )</z><z id="t1594427087" t="ikrimael i want to split them into an arg array of inputs and outputs but fields that had ArgIn|ArgOut would only show up in one of the arrays"><y>#</y><d>2020-07-11</d><h>00:24</h><w>ikrimael</w>i want to split them into an arg array of inputs and outputs but fields that had <code>ArgIn|ArgOut</code>  would only show up in one of the arrays</z><z id="t1594427168" t="noprompt Are you still struggling with this?"><y>#</y><d>2020-07-11</d><h>00:26</h><w>noprompt</w>Are you still struggling with this?</z><z id="t1594427174" t="ikrimael heh, yeah. i finally gave up on it"><y>#</y><d>2020-07-11</d><h>00:26</h><w>ikrimael</w>heh, yeah. i finally gave up on it</z><z id="t1594427179" t="noprompt Ha!"><y>#</y><d>2020-07-11</d><h>00:26</h><w>noprompt</w>Ha!</z><z id="t1594427186" t="ikrimael and marked &quot;feature not supported&quot; 😛"><y>#</y><d>2020-07-11</d><h>00:26</h><w>ikrimael</w>and marked &quot;feature not supported&quot; <b>😛</b></z><z id="t1594427216" t="ikrimael (obvi jk, but i just let it be for now)"><y>#</y><d>2020-07-11</d><h>00:26</h><w>ikrimael</w>(obvi jk, but i just let it be for now)</z><z id="t1594427252" t="ikrimael (meta: i also have to say I absolutely love once I manage to get things in meander. everything is instantly grokkable days later)"><y>#</y><d>2020-07-11</d><h>00:27</h><w>ikrimael</w>(meta: i also have to say I absolutely love once I manage to get things in meander. everything is instantly grokkable days later)</z><z id="t1594427257" t="noprompt Sure, sure. If you have a vanilla Clojure implementation and I might be able to supply a pattern for it."><y>#</y><d>2020-07-11</d><h>00:27</h><w>noprompt</w>Sure, sure. If you have a vanilla Clojure implementation and I might be able to supply a pattern for it.</z><z id="t1594427299" t="noprompt I’m really excited about the stuff you’re playing around with e.g. the C++ stuff because, really, this was the kind of space I wanted Meander to fit in to i.e. AST transforms, etc."><y>#</y><d>2020-07-11</d><h>00:28</h><w>noprompt</w>I’m really excited about the stuff you’re playing around with e.g. the C++ stuff because, really, this was the kind of space I wanted Meander to fit in to i.e. AST transforms, etc.</z><z id="t1594427316" t="ikrimael yeah, it&apos;s literally the whole reason i&apos;m using it"><y>#</y><d>2020-07-11</d><h>00:28</h><w>ikrimael</w>yeah, it&apos;s literally the whole reason i&apos;m using it</z><z id="t1594427328" t="ikrimael i always hate how complicated term rewriting was for basic things"><y>#</y><d>2020-07-11</d><h>00:28</h><w>ikrimael</w>i always hate how complicated term rewriting was for basic things</z><z id="t1594427339" t="ikrimael re: code - sure, it&apos;s in the link. i tried to make it self contained so you can copy paste it"><y>#</y><d>2020-07-11</d><h>00:28</h><w>ikrimael</w>re: code - sure, it&apos;s in the link. i tried to make it self contained so you can copy paste it</z><z id="t1594427369" t="noprompt Gradually, I’m realizing that what I want is essentially a DCG sort of thing but ~richer~ a bit different from whats on offer in Prolog and integrated with Clojure."><y>#</y><d>2020-07-11</d><h>00:29</h><w>noprompt</w>Gradually, I’m realizing that what I want is essentially a DCG sort of thing but ~richer~ a bit different from whats on offer in Prolog and integrated with Clojure.</z><z id="t1594427414" t="ikrimael each variant is a different tactic i tried (i kept it in the doc bc it helps shows the difference between {search , match} x {memory vars, logic vars}"><y>#</y><d>2020-07-11</d><h>00:30</h><w>ikrimael</w>each variant is a different tactic i tried (i kept it in the doc bc it helps shows the difference between {search , match} x {memory vars, logic vars}</z><z id="t1594427542" t="noprompt I should have some more time over the weekend to review stuff, help with questions, etc."><y>#</y><d>2020-07-11</d><h>00:32</h><w>noprompt</w>I should have some more time over the weekend to review stuff, help with questions, etc.</z><z id="t1594427551" t="ikrimael sure, np"><y>#</y><d>2020-07-11</d><h>00:32</h><w>ikrimael</w>sure, np</z><z id="t1594427570" t="noprompt You’ve captured my attention. 🙂"><y>#</y><d>2020-07-11</d><h>00:32</h><w>noprompt</w>You’ve captured my attention. <b>🙂</b></z><z id="t1594427570" t="ikrimael and no rush; i basically just queue up everything and using that PR as a working draft"><y>#</y><d>2020-07-11</d><h>00:32</h><w>ikrimael</w>and no rush; i basically just queue up everything and using that PR as a working draft</z><z id="t1594427601" t="ikrimael my goal is once I finish writing this part of my dsl compiler in clojure to come back and edit the PR draft to final form"><y>#</y><d>2020-07-11</d><h>00:33</h><w>ikrimael</w>my goal is once I finish writing this part of my dsl compiler in clojure to come back and edit the PR draft to final form</z><z id="t1594427623" t="noprompt Sure. Just let me know what you need on that e.g. “Can you fill in this blank or that blank?” sort of thing."><y>#</y><d>2020-07-11</d><h>00:33</h><w>noprompt</w>Sure. Just let me know what you need on that e.g. “Can you fill in this blank or that blank?” sort of thing.</z><z id="t1594427630" t="ikrimael 👍"><y>#</y><d>2020-07-11</d><h>00:33</h><w>ikrimael</w><b>👍</b></z><z id="t1594427663" t="noprompt For stuff you’re stuck on, a Clojure implementation can help. If I can’t map it, I’ll be honest about that."><y>#</y><d>2020-07-11</d><h>00:34</h><w>noprompt</w>For stuff you’re stuck on, a Clojure implementation can help. If I can’t map it, I’ll be honest about that.</z><z id="t1594427721" t="ikrimael would you prefer a straight clojure implementation or is higher level pseudocode better?"><y>#</y><d>2020-07-11</d><h>00:35</h><w>ikrimael</w>would you prefer a straight clojure implementation or is higher level pseudocode better?</z><z id="t1594427773" t="ikrimael ex: I wrote this as what i was trying to do and then tried to figure out how to get meander to map it filter( (predA? x) =&gt; (projA x) :as !projAseq (predB? x) =&gt; (projB x) :as !projBseq ) "><y>#</y><d>2020-07-11</d><h>00:36</h><w>ikrimael</w>ex: I wrote this as what i was trying to do and then tried to figure out how to get meander to map it
<pre>filter(
  (predA? x) =&gt; (projA x) :as !projAseq
  (predB? x) =&gt; (projB x) :as !projBseq
)</pre>
</z><z id="t1594428029" t="noprompt So I think that is (m/or (m/pred predA? (m/app projA !projASeq)) (m/pred predB? (m/app projB !projBSeq))) "><y>#</y><d>2020-07-11</d><h>00:40</h><w>noprompt</w>So I think that is
<pre>(m/or (m/pred predA? (m/app projA !projASeq))
      (m/pred predB? (m/app projB !projBSeq)))</pre>
</z><z id="t1594428062" t="noprompt Either is fine though, if I’m confused I’ll ask. 🙂"><y>#</y><d>2020-07-11</d><h>00:41</h><w>noprompt</w>Either is fine though, if I’m confused I’ll ask. <b>🙂</b></z><z id="t1594428920" t="ikrimael hmm, still can&apos;t get it to work"><y>#</y><d>2020-07-11</d><h>00:55</h><w>ikrimael</w>hmm, still can&apos;t get it to work</z><z id="t1594428941" t="ikrimael Simplified snippet: (def arglist [{:name :inBoneTrk :argFlags #{:EArg-In}} {:name :inoutBoneTrk :argFlags #{:EArg-In :EArg-Out}} {:name :outBoneTrk :argFlags #{:EArg-Out}}]) (m/match arglist [(m/or (m/pred #(contains? %1 :EArg-In) (m/app :name !projASeq)) (m/pred #(contains? %1 :EArg-Out) (m/app :name !projBSeq))) ...] {:in-args !projASeq :out-args !projBSeq}) "><y>#</y><d>2020-07-11</d><h>00:55</h><w>ikrimael</w>Simplified snippet:
<pre>(def arglist [{:name :inBoneTrk    :argFlags #{:EArg-In}}
              {:name :inoutBoneTrk :argFlags #{:EArg-In :EArg-Out}}
              {:name :outBoneTrk   :argFlags #{:EArg-Out}}])
(m/match
 arglist
  [(m/or (m/pred #(contains? %1 :EArg-In) (m/app :name !projASeq))
         (m/pred #(contains? %1 :EArg-Out) (m/app :name !projBSeq)))
   ...]
  {:in-args !projASeq
   :out-args !projBSeq})</pre>
</z><z id="t1594429124" t="ikrimael Actual: Error: non exhaustive pattern match Expected: {:in-args [:inBoneTrk :inoutBoneTrk] :out-args [:outBoneTrk :inoutBoneTrk]}"><y>#</y><d>2020-07-11</d><h>00:58</h><w>ikrimael</w>Actual:  <code>Error: non exhaustive pattern match</code>
Expected:
<pre>{:in-args [:inBoneTrk :inoutBoneTrk]
 :out-args [:outBoneTrk :inoutBoneTrk]}</pre></z><z id="t1594433470" t="noprompt (let [arglist [{:name :inBoneTrk :argFlags #{:EArg-In}} {:name :inoutBoneTrk :argFlags #{:EArg-In :EArg-Out}} {:name :outBoneTrk :argFlags #{:EArg-Out}}]] (m/find arglist [(m/and (m/or {:argFlags #{:EArg-In} :name !projASeq} _) (m/or {:argFlags #{:EArg-Out} :name !projBSeq} _)) ...] {:in-args !projASeq :out-args !projBSeq})) ;; =&gt; {:in-args [:inBoneTrk :inoutBoneTrk], :out-args [:inoutBoneTrk :outBoneTrk]} "><y>#</y><d>2020-07-11</d><h>02:11</h><w>noprompt</w><pre>(let [arglist [{:name :inBoneTrk    :argFlags #{:EArg-In}}
               {:name :inoutBoneTrk :argFlags #{:EArg-In :EArg-Out}}
               {:name :outBoneTrk   :argFlags #{:EArg-Out}}]]
  (m/find arglist
    [(m/and (m/or {:argFlags #{:EArg-In} :name !projASeq} _)
            (m/or {:argFlags #{:EArg-Out} :name !projBSeq} _))
     ...]
    {:in-args !projASeq
     :out-args !projBSeq}))
;; =&gt;
{:in-args [:inBoneTrk :inoutBoneTrk],
 :out-args [:inoutBoneTrk :outBoneTrk]}</pre>
</z><z id="t1594433522" t="noprompt You could use match instead of find in this case if you want “blow up” semantics."><y>#</y><d>2020-07-11</d><h>02:12</h><w>noprompt</w>You could use <code>match</code> instead of <code>find</code> in this case if you want “blow up” semantics.</z><z id="t1594433814" t="noprompt Alternatively [(m/or {:argFlags #{:EArg-In :EArg-Out} :name (m/and !projASeq !projBSeq)} {:argFlags #{:EArg-In}, :name !projASeq} {:argFlags #{:EArg-Out}, :name !projBSeq}) ...] works."><y>#</y><d>2020-07-11</d><h>02:16</h><w>noprompt</w>Alternatively
<pre>[(m/or {:argFlags #{:EArg-In :EArg-Out} :name (m/and !projASeq !projBSeq)}
           {:argFlags #{:EArg-In}, :name !projASeq}
           {:argFlags #{:EArg-Out}, :name !projBSeq})
     ...]</pre>
works.</z><z id="t1594434480" t="ikrimael 👌"><y>#</y><d>2020-07-11</d><h>02:28</h><w>ikrimael</w><b>👌</b></z><z id="t1594859179" t="ikrimael [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] quick question (sorry, no complete snippet, rushed at the moment); is it possible to destructure while &quot;capturing&quot; something"><y>#</y><d>2020-07-16</d><h>00:26</h><w>ikrimael</w><a>@noprompt</a> quick question (sorry, no complete snippet, rushed at the moment); is it possible to destructure while &quot;capturing&quot; something</z><z id="t1594859191" t="ikrimael ex: [ {:op :ophirUseOpnDataLit :as !opdataLits} ...] "><y>#</y><d>2020-07-16</d><h>00:26</h><w>ikrimael</w>ex:
<pre>[ {:op :ophirUseOpnDataLit :as !opdataLits} ...]
</pre></z><z id="t1594859254" t="Jimmy Miller What you wrote there does work. Not sure what you are looking for."><y>#</y><d>2020-07-16</d><h>00:27</h><w>Jimmy Miller</w>What you wrote there does work. Not sure what you are looking for.</z><z id="t1594859305" t="ikrimael oops, [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] sorry pasted too soon"><y>#</y><d>2020-07-16</d><h>00:28</h><w>ikrimael</w>oops, <a>@jimmy</a> sorry pasted too soon</z><z id="t1594859309" t="ikrimael the array passed in is [{:op :ophirUseOpnDataLit, :name :datalit_smoothArgs, :ctypeUid {:op :ophirCuid, :cuidstr :SmoothingChop_PrmBlk_t}, :fldvalmap {:chSmplRate {:op :ophirConst, :ctypeUid :SmplRate_t, :val 1}, :chStartSmplNum {:op :ophirConst, :ctypeUid :SmplIdx_t, :val 1}}} {:op :ophirUseOpnode, :name :loPass, :opdefUid {:op :ophirOpuid, :opuidstr :smootherchop}, :oprmblkbnds {:op :ophirOprmblkBinds, :oprmbnds [{:op :ophirOprmbind, :prmname :smoothArgs, :prmbind {:op :ophirOprmPath, :pathstr &quot;opgrph:./opnodes/opgrphdata/smoothArgs1&quot;}} {:op :ophirOprmbind, :prmname :chIn, :prmbind {:op :ophirOprmPath, :pathstr &quot;opgrph:./oprms/inBoneTrk&quot;}}]}} {:op :ophirUseOpnode, :name :hiPass, :opdefUid {:op :ophirOpuid, :opuidstr :smootherchop}, :oprmblkbnds {:op :ophirOprmblkBinds, :oprmbnds [{:op :ophirOprmbind, :prmname :smoothArgs, :prmbind {:op :ophirOprmPath, :pathstr &quot;opgrph:/loPass/@smoothArgs&quot;}} {:op :ophirOprmbind, :prmname :chIn, :prmbind {:op :ophirOprmPath, :pathstr &quot;opgrph:/loPass/@chOut&quot;}}]}}] "><y>#</y><d>2020-07-16</d><h>00:28</h><w>ikrimael</w>the array passed in is 
<pre>[{:op :ophirUseOpnDataLit,
   :name :datalit_smoothArgs,
   :ctypeUid {:op :ophirCuid, :cuidstr :SmoothingChop_PrmBlk_t},
   :fldvalmap
   {:chSmplRate {:op :ophirConst, :ctypeUid :SmplRate_t, :val 1},
    :chStartSmplNum {:op :ophirConst, :ctypeUid :SmplIdx_t, :val 1}}}
  {:op :ophirUseOpnode,
   :name :loPass,
   :opdefUid {:op :ophirOpuid, :opuidstr :smootherchop},
   :oprmblkbnds
   {:op :ophirOprmblkBinds,
    :oprmbnds
    [{:op :ophirOprmbind,
      :prmname :smoothArgs,
      :prmbind {:op :ophirOprmPath, :pathstr &quot;opgrph:./opnodes/opgrphdata/smoothArgs1&quot;}}
     {:op :ophirOprmbind, :prmname :chIn, :prmbind {:op :ophirOprmPath, :pathstr &quot;opgrph:./oprms/inBoneTrk&quot;}}]}}
  {:op :ophirUseOpnode,
   :name :hiPass,
   :opdefUid {:op :ophirOpuid, :opuidstr :smootherchop},
   :oprmblkbnds
   {:op :ophirOprmblkBinds,
    :oprmbnds
    [{:op :ophirOprmbind, :prmname :smoothArgs, :prmbind {:op :ophirOprmPath, :pathstr &quot;opgrph:/loPass/@smoothArgs&quot;}}
     {:op :ophirOprmbind, :prmname :chIn, :prmbind {:op :ophirOprmPath, :pathstr &quot;opgrph:/loPass/@chOut&quot;}}]}}]
</pre></z><z id="t1594859341" t="Jimmy Miller And you want to get only the ones with a certain op?"><y>#</y><d>2020-07-16</d><h>00:29</h><w>Jimmy Miller</w>And you want to get only the ones with a certain op?</z><z id="t1594859355" t="ikrimael i want to extract out {:name :ctypeUid} from the meander filter (but only if it&apos;s :op == :ophirUseOpnDataLit)"><y>#</y><d>2020-07-16</d><h>00:29</h><w>ikrimael</w>i want to extract out {:name :ctypeUid} from the meander filter (but only if it&apos;s :op == :ophirUseOpnDataLit)</z><z id="t1594859380" t="Jimmy Miller You can use m/gather ."><y>#</y><d>2020-07-16</d><h>00:29</h><w>Jimmy Miller</w>You can use <code>m/gather</code>.</z><z id="t1594859391" t="ikrimael i can&apos;t figure out how to &quot;crack open&quot; the inner parts through a destructure while keeping a memory variable"><y>#</y><d>2020-07-16</d><h>00:29</h><w>ikrimael</w>i can&apos;t figure out how to &quot;crack open&quot; the inner parts through a destructure while keeping a memory variable</z><z id="t1594859398" t="Jimmy Miller It is like filter."><y>#</y><d>2020-07-16</d><h>00:29</h><w>Jimmy Miller</w>It is like filter.</z><z id="t1594859404" t="ikrimael ah brilliant; let me look that up"><y>#</y><d>2020-07-16</d><h>00:30</h><w>ikrimael</w>ah brilliant; let me look that up</z><z id="t1594859444" t="ikrimael thnx! will come back tonight and update the sample PR with it or ask questions if i stumble"><y>#</y><d>2020-07-16</d><h>00:30</h><w>ikrimael</w>thnx! will come back tonight and update the sample PR with it  or ask questions if i stumble</z><z id="t1594859464" t="ikrimael (trying to check something in in &lt;1hr 🤓 )"><y>#</y><d>2020-07-16</d><h>00:31</h><w>ikrimael</w>(trying to check something in in &lt;1hr <b>🤓</b> )</z><z id="t1594859531" t="Jimmy Miller Sounds good."><y>#</y><d>2020-07-16</d><h>00:32</h><w>Jimmy Miller</w>Sounds good.</z><z id="t1594867945" t="JAtkins I think I&apos;m being stupid here, but I&apos;m not sure how... I have seen this error several times now: Execution error at scratch.overcast-xml/eval19536$fn$fn (overcast_xml.clj:29). Can&apos;t remove struct key I&apos;ve solved it a few times now, but I&apos;m still not sure what the causal pattern it is. Here is my most recent example: (m/search file ; some xml, can provide a subset if needed (m/$ {:attrs {:xmlUrl (m/some ?rss-feed)} :content (m/scan {:tag :outline :attrs !attrs})}) {:rss ?rss-feed :attrs !attrs})"><y>#</y><d>2020-07-16</d><h>02:52</h><w>JAtkins</w>I think I&apos;m being stupid here, but I&apos;m not sure how... I have seen this error several times now:
<pre>Execution error at scratch.overcast-xml/eval19536$fn$fn (overcast_xml.clj:29).
Can&apos;t remove struct key</pre>
I&apos;ve solved it a few times now, but I&apos;m still not sure what the causal pattern it is. Here is my most recent example:
<pre>(m/search file ; some xml, can provide a subset if needed
    (m/$ {:attrs   {:xmlUrl (m/some ?rss-feed)}
          :content (m/scan {:tag   :outline
                            :attrs !attrs})})
    {:rss ?rss-feed  :attrs !attrs})</pre></z><z id="t1594872756" t="noprompt [:attrs {:href &quot;/_/_/users/U5P29DSUS&quot;}] There might be something up how Meander is interacting with the XML library. Do you have, perhaps, a deps.edn and a minimal example that triggers this problem? I’m happy to have a look at it."><y>#</y><d>2020-07-16</d><h>04:12</h><w>noprompt</w><a>@jatkin</a> There might be something up how Meander is interacting with the XML library. Do you have, perhaps, a <code>deps.edn</code> and a minimal example that triggers this problem? I’m happy to have a look at it.</z><z id="t1594873239" t="JAtkins Looks like the type is clojure.lang.PersistentStructMap, which maybe doesn&apos;t allow dissocing... Which would make sense... It&apos;s just clojure.xml"><y>#</y><d>2020-07-16</d><h>04:20</h><w>JAtkins</w>Looks like the type is clojure.lang.PersistentStructMap, which maybe doesn&apos;t allow dissocing... Which would make sense... It&apos;s just clojure.xml</z><z id="t1594873461" t="JAtkins Yup, that&apos;s it... Not meander 🙂 Thanks for bringing that up, would never have thought of that!"><y>#</y><d>2020-07-16</d><h>04:24</h><w>JAtkins</w>Yup, that&apos;s it... Not meander <b>🙂</b> Thanks for bringing that up, would never have thought of that!</z><z id="t1594932928" t="JAtkins So, another possible dumb question: can I unroll results? e.g. I have a match with a capture and a memory variable. can I unroll the result with the single capture reused while all the memory vars are used? My usage rn: (m/search xml-cleared-structs (m/$ {:attrs {:xmlUrl (m/some ?rss-feed)} :content (m/scan {:tag :outline :attrs {:progress (m/some !progress) :title (m/some !title)}} )}) {:rss ?rss-feed :progresses !progress :titles !title}) ;; =&gt; ({:rss &quot;&quot;, :progresses [&quot;3642&quot;], :titles [&quot;Why Functional Programming Matters&quot;]} {:rss &quot;&quot;, :progresses [&quot;2200&quot; &quot;3190&quot;], :titles [&quot;My response to Out of the Tar Pit&quot; &quot;Another Title&quot;]})"><y>#</y><d>2020-07-16</d><h>20:55</h><w>JAtkins</w>So, another possible dumb question: can I unroll results? e.g. I have a match with a capture and a memory variable. can I unroll the result with the single capture reused while all the memory vars are used?

My usage rn:
<pre>(m/search xml-cleared-structs
    (m/$ {:attrs   {:xmlUrl (m/some ?rss-feed)}
          :content (m/scan {:tag   :outline
                            :attrs {:progress (m/some !progress)
                                    :title    (m/some !title)}}
                     )})
    {:rss ?rss-feed :progresses !progress :titles !title})

;; =&gt; 

({:rss &quot;&quot;,
  :progresses [&quot;3642&quot;],
  :titles [&quot;Why Functional Programming Matters&quot;]}
 {:rss &quot;&quot;,
  :progresses [&quot;2200&quot; &quot;3190&quot;],
  :titles [&quot;My response to Out of the Tar Pit&quot; &quot;Another Title&quot;]})</pre></z><z id="t1594938185" t="noprompt Is the value on the right of the =&gt; the expected?"><y>#</y><d>2020-07-16</d><h>22:23</h><w>noprompt</w>Is the value on the right of the <code>=&gt;</code> the expected?</z><z id="t1594938574" t="JAtkins The actual"><y>#</y><d>2020-07-16</d><h>22:29</h><w>JAtkins</w>The actual</z><z id="t1594938637" t="JAtkins I got a bit closer with this: (m/search xml-cleared-structs (m/$ {:attrs {:xmlUrl (m/some ?rss-feed)} :content [_ ... {:tag :outline :attrs {:progress (m/some ?progress) :title (m/some ?title)}} ]}) {:rss ?rss-feed :progresses ?progress :titles ?title}) But it only matches the last element in the :content vector"><y>#</y><d>2020-07-16</d><h>22:30</h><w>JAtkins</w>I got a bit closer with this:
<pre>(m/search xml-cleared-structs
    (m/$ {:attrs   {:xmlUrl (m/some ?rss-feed)}
          :content [_ ... {:tag   :outline
                           :attrs {:progress (m/some ?progress)
                                   :title    (m/some ?title)}}
                    ]})
    {:rss ?rss-feed :progresses ?progress :titles ?title})</pre>
But it only matches the last element in the :content vector</z><z id="t1594938665" t="JAtkins Haven&apos;t figured out how to put the zero or more in the right place for this to match everything correctly"><y>#</y><d>2020-07-16</d><h>22:31</h><w>JAtkins</w>Haven&apos;t figured out how to put the zero or more in the right place for this to match everything correctly</z><z id="t1594945086" t="JAtkins I guess this is the source of my confusion. Why does the code following not return (1 2 3 4 5) , but instead throw an error? (m/search {:a [1 2 3 4 5]} {:a [?x ...]} ?x) ;; =&gt; actual Zero or more patterns may not have references to unbound logic variables. "><y>#</y><d>2020-07-17</d><h>00:18</h><w>JAtkins</w>I guess this is the source of my confusion. Why does the code following not return <code>(1 2 3 4 5)</code>, but instead throw an error?
<pre>(m/search {:a [1 2 3 4 5]}
  {:a [?x ...]}
  ?x)
;; =&gt; actual
Zero or more patterns may not have references to unbound logic variables.</pre>
</z><z id="t1594945440" t="JAtkins If I break my case down an actual usage example, this is what I have as input data: [{:context-tag :one-to-five :a [1 2 3 4 5]} {:context-tag :nine-to-five :a [9 8 7 6 5]}] and what I&apos;m trying to get is this: [[:one-to-five 1] [:one-to-five 2] [:one-to-five 3] [:one-to-five 4] [:one-to-five 5] [:nine-to-five 9] [:nine-to-five 8] [:nine-to-five 7] [:nine-to-five 6] [:nine-to-five 5]]"><y>#</y><d>2020-07-17</d><h>00:24</h><w>JAtkins</w>If I break my case down an actual usage example, this is what I have as input data:
<pre>[{:context-tag :one-to-five
  :a           [1 2 3 4 5]}
 {:context-tag :nine-to-five
  :a           [9 8 7 6 5]}]</pre>
and what I&apos;m trying to get is this:
<pre>[[:one-to-five 1]
 [:one-to-five 2]
 [:one-to-five 3]
 [:one-to-five 4]
 [:one-to-five 5]
 [:nine-to-five 9]
 [:nine-to-five 8]
 [:nine-to-five 7]
 [:nine-to-five 6]
 [:nine-to-five 5]]</pre></z><z id="t1594945462" t="JAtkins Basically unroll the relationship between the numbers and the context"><y>#</y><d>2020-07-17</d><h>00:24</h><w>JAtkins</w>Basically unroll the relationship between the numbers and the context</z><z id="t1594945702" t="Jimmy Miller [:attrs {:href &quot;/_/_/users/U5P29DSUS&quot;}] Thanks for giving an input and output case. I am sadly busy right now, but if someone else doesn&apos;t help you before then I can post an example tonight."><y>#</y><d>2020-07-17</d><h>00:28</h><w>Jimmy Miller</w><a>@jatkin</a> Thanks for giving an input and output case. I am sadly busy right now, but if someone else doesn&apos;t help you before then I can post an example tonight.</z><z id="t1594945762" t="JAtkins No problem, I just got off work myself."><y>#</y><d>2020-07-17</d><h>00:29</h><w>JAtkins</w>No problem, I just got off work myself.</z><z id="t1594946492" t="ikrimael [:attrs {:href &quot;/_/_/users/U5P29DSUS&quot;}] once you figure it out, would you mind adding your cases as examples to https://github.com/noprompt/meander/pull/125"><y>#</y><d>2020-07-17</d><h>00:41</h><w>ikrimael</w><a>@jatkin</a> once you figure it out, would you mind adding your cases as examples to <a href="https://github.com/noprompt/meander/pull/125" target="_blank">https://github.com/noprompt/meander/pull/125</a></z><z id="t1594948167" t="ikrimael @noprompt cleaned up/merged feedback for the examples from the chat"><y>#</y><d>2020-07-17</d><h>01:09</h><w>ikrimael</w>@noprompt cleaned up/merged feedback for the examples from the chat</z><z id="t1594973823" t="noprompt Merged it!"><y>#</y><d>2020-07-17</d><h>08:17</h><r>noprompt</r>Merged it!</z><z id="t1594948229" t="ikrimael figure it&apos;s enough of a chunk to submit; i&apos;ll start another PR for today onward"><y>#</y><d>2020-07-17</d><h>01:10</h><w>ikrimael</w>figure it&apos;s enough of a chunk to submit; i&apos;ll start another PR for today onward</z><z id="t1594949264" t="JAtkins Will do"><y>#</y><d>2020-07-17</d><h>01:27</h><w>JAtkins</w>Will do</z><z id="t1594949290" t="JAtkins Trying to read through the source and make out what should make this tick."><y>#</y><d>2020-07-17</d><h>01:28</h><w>JAtkins</w>Trying to read through the source and make out what should make this tick.</z><z id="t1594949711" t="JAtkins AH-HA! (m/search {:context-tag :one-to-five :k [:aa :bb :cc :dd :ee]} {:context-tag ?context :k [_ ... ?k . _ ...]} [?context ?k]) ; =&gt; ([:one-to-five :aa] [:one-to-five :bb] [:one-to-five :cc] [:one-to-five :dd] [:one-to-five :ee])"><y>#</y><d>2020-07-17</d><h>01:35</h><w>JAtkins</w>AH-HA!
<pre>(m/search {:context-tag :one-to-five
           :k           [:aa :bb :cc :dd :ee]}
  {:context-tag ?context
   :k           [_ ... ?k . _ ...]}
  [?context ?k])

; =&gt; 

([:one-to-five :aa] [:one-to-five :bb] [:one-to-five :cc] [:one-to-five :dd] [:one-to-five :ee])</pre></z><z id="t1594949749" t="JAtkins The docstring of scan was immensely helpful. But, if I might ask, why does this work but the other cases do not?"><y>#</y><d>2020-07-17</d><h>01:35</h><w>JAtkins</w>The docstring of <code>scan</code> was immensely helpful. But, if I might ask, why does this work but the other cases do not?</z><z id="t1594949862" t="JAtkins I&apos;m especially confused by the additional _ required. I would assume those would bind to :aa and :ee . I guess by &quot;match anything&quot; it means even match a blank space?"><y>#</y><d>2020-07-17</d><h>01:37</h><w>JAtkins</w>I&apos;m especially confused by the additional <code>_</code> required. I would assume those would bind to <code>:aa</code> and <code>:ee</code> . I guess by &quot;match anything&quot; it means even match a blank space?</z><z id="t1594963036" t="JAtkins I think I just had a breakthough... Holy freaking cow is this awesome! Just wrote in 2 lines something that would easily be 15 lines of regular mapping/filtering/reducing."><y>#</y><d>2020-07-17</d><h>05:17</h><w>JAtkins</w>I think I just had a breakthough... Holy freaking cow is this awesome! Just wrote in 2 lines something that would easily be 15 lines of regular mapping/filtering/reducing.</z><z id="t1595030696" t="ikrimael [:attrs {:href &quot;/_/_/users/U5P29DSUS&quot;}] care to share insight?"><y>#</y><d>2020-07-18</d><h>00:04</h><w>ikrimael</w><a>@jatkin</a> care to share insight?</z><z id="t1595030801" t="JAtkins Not much, just I now understand the syntax extensions. Made a pseudo xor which works well. "><y>#</y><d>2020-07-18</d><h>00:06</h><w>JAtkins</w>Not much, just I now understand the syntax extensions. Made a pseudo xor which works well. </z><z id="t1595030845" t="JAtkins Still confused about _ though. If there is a more detailed explanation I’d greatly appreciate it ;)"><y>#</y><d>2020-07-18</d><h>00:07</h><w>JAtkins</w>Still confused about _ though. If there is a more detailed explanation I’d greatly appreciate it ;)</z><z id="t1595030866" t="ikrimael probably would be useful to others still (maybe in the examples doc?) I find myself in the same pattern: struggling with the syntax and &quot;i get it&quot; nirvana when i figure it out"><y>#</y><d>2020-07-18</d><h>00:07</h><w>ikrimael</w>probably would be useful to others still (maybe in the examples doc?)
I find myself in the same pattern: struggling with the syntax and &quot;i get it&quot; nirvana when i figure it out</z><z id="t1595030874" t="Jimmy Miller I hope to find time to go back and make a thorough explanation of the things you&apos;ve run into. Just been a busy few days."><y>#</y><d>2020-07-18</d><h>00:07</h><w>Jimmy Miller</w>I hope to find time to go back and make a thorough explanation of the things you&apos;ve run into. Just been a busy few days.</z><z id="t1595030882" t="Jimmy Miller _ just matches anything."><y>#</y><d>2020-07-18</d><h>00:08</h><w>Jimmy Miller</w>_ just matches anything.</z><z id="t1595030893" t="JAtkins Even an empty space I guess?"><y>#</y><d>2020-07-18</d><h>00:08</h><w>JAtkins</w>Even an empty space I guess?</z><z id="t1595030907" t="Jimmy Miller _ ... Means zero or more of anything."><y>#</y><d>2020-07-18</d><h>00:08</h><w>Jimmy Miller</w>_ ... Means zero or more of anything.</z><z id="t1595030911" t="Jimmy Miller So that would include nothing."><y>#</y><d>2020-07-18</d><h>00:08</h><w>Jimmy Miller</w>So that would include nothing.</z><z id="t1595030934" t="Jimmy Miller That is also why your ?x ... Wasn&apos;t working. Because what can we bind ?x to when it matches nothingness?"><y>#</y><d>2020-07-18</d><h>00:08</h><w>Jimmy Miller</w>That is also why your ?x ... Wasn&apos;t working. Because what can we bind ?x to when it matches nothingness?</z><z id="t1595030940" t="JAtkins Huh. I would expect _ to bind to something at least. Good to know though. "><y>#</y><d>2020-07-18</d><h>00:09</h><w>JAtkins</w>Huh. I would expect _ to bind to something at least. Good to know though. </z><z id="t1595030973" t="Jimmy Miller It would, if you didn&apos;t say the ... It is like .* in regex"><y>#</y><d>2020-07-18</d><h>00:09</h><w>Jimmy Miller</w>It would, if you didn&apos;t say  the ...  It is like .* in regex</z><z id="t1595031009" t="Jimmy Miller You can say ..1 to do at least one element."><y>#</y><d>2020-07-18</d><h>00:10</h><w>Jimmy Miller</w>You can say ..1 to do at least one element.</z><z id="t1595031035" t="JAtkins Ah, I had a very bad misconception. I thought ... would match nothing. Instead it is a postfix modifier. "><y>#</y><d>2020-07-18</d><h>00:10</h><w>JAtkins</w>Ah, I had a very bad misconception. I thought ... would match nothing. Instead it is a postfix modifier. </z><z id="t1595031056" t="JAtkins [...] is invalid syntax. "><y>#</y><d>2020-07-18</d><h>00:10</h><w>JAtkins</w>[...] is invalid syntax. </z><z id="t1595031059" t="Jimmy Miller Yep exactly right."><y>#</y><d>2020-07-18</d><h>00:10</h><w>Jimmy Miller</w>Yep exactly right.</z><z id="t1595097960" t="JAtkins haha, I went to make a note about ... being a postfix operator, and it was already there. Not sure how I missed it the first time. I may have just skimmed that section initially since I thought &quot;of course I know what ... does, I use it all the time&quot; 🙂"><y>#</y><d>2020-07-18</d><h>18:46</h><r>JAtkins</r>haha, I went to make a note about <code>...</code> being a postfix operator, and it was already there. Not sure how I missed it the first time. I may have just skimmed that section initially since I thought &quot;of course I know what <code>...</code> does, I use it all the time&quot; <b>🙂</b></z><z id="t1595031077" t="JAtkins Bingo, thank you very much for that!"><y>#</y><d>2020-07-18</d><h>00:11</h><w>JAtkins</w>Bingo, thank you very much for that!</z><z id="t1595031127" t="Jimmy Miller It repeats everything till the end or until it hits a dot. [1 . 2 ...] would match a vector with just a one in it. Or a vector with a 1 followed by a bunch of 2s."><y>#</y><d>2020-07-18</d><h>00:12</h><w>Jimmy Miller</w>It repeats everything till the end or until it hits a dot. <code>[1 . 2 ...]</code> would match a vector with just a one in it. Or a vector with a 1 followed by a bunch of 2s.</z><z id="t1595031174" t="Jimmy Miller No problem. There is definitely some conceptualizing that has to go on. I struggled quite a bit with meander when Joel first introduced me to it."><y>#</y><d>2020-07-18</d><h>00:12</h><w>Jimmy Miller</w>No problem. There is definitely some conceptualizing that has to go on. I struggled quite a bit with meander when Joel first introduced me to it.</z><z id="t1595033426" t="noprompt If it’s worth anything I have mixed feelings about the syntax myself. I pulled inspiration from many places. The … I borrowed from Racket but I tweaked it a little bit."><y>#</y><d>2020-07-18</d><h>00:50</h><w>noprompt</w>If it’s worth anything I have mixed feelings about the syntax myself. I pulled inspiration from many places. The <code>…</code> I borrowed from Racket but I tweaked it a little bit.</z><z id="t1595033550" t="noprompt I’m close to having a search interpreter ready for folks to use."><y>#</y><d>2020-07-18</d><h>00:52</h><w>noprompt</w>I’m close to having a search interpreter ready for folks to use.</z><z id="t1595033692" t="noprompt (let [map-search (make-search-fn &apos;{?k ?v :as ?m &amp; ?rest})] (map-search {:a 1 :b 2 :c 3})) ;; =&gt; &apos;({?m {:a 1, :b 2, :c 3}, ?k :a, ?v 1, ?rest {:b 2, :c 3}} {?m {:a 1, :b 2, :c 3}, ?k :b, ?v 2, ?rest {:a 1, :c 3}} {?m {:a 1, :b 2, :c 3}, ?k :c, ?v 3, ?rest {:a 1, :b 2}}) "><y>#</y><d>2020-07-18</d><h>00:54</h><w>noprompt</w><pre>(let [map-search (make-search-fn &apos;{?k ?v :as ?m &amp; ?rest})]
  (map-search {:a 1 :b 2 :c 3}))
;; =&gt;
&apos;({?m {:a 1, :b 2, :c 3}, ?k :a, ?v 1, ?rest {:b 2, :c 3}}
  {?m {:a 1, :b 2, :c 3}, ?k :b, ?v 2, ?rest {:a 1, :c 3}}
  {?m {:a 1, :b 2, :c 3}, ?k :c, ?v 3, ?rest {:a 1, :b 2}})</pre>
</z><z id="t1595033738" t="noprompt This is one of the places where if you were attempting to construct a pattern involving ... it’d be unpleasant."><y>#</y><d>2020-07-18</d><h>00:55</h><w>noprompt</w>This is one of the places where if you were attempting to construct a pattern involving <code>...</code> it’d be unpleasant.</z><z id="t1595033916" t="noprompt But I think this is one of the last contributions I want to make to epsilon and then get back to zeta ."><y>#</y><d>2020-07-18</d><h>00:58</h><w>noprompt</w>But I think this is one of the last contributions I want to make to <code>epsilon</code> and then get back to <code>zeta</code>.</z><z id="t1595043892" t="ikrimael I think the challenge I&apos;m having is somewhat &quot;curse of its own success&quot;"><y>#</y><d>2020-07-18</d><h>03:44</h><w>ikrimael</w>I think the challenge I&apos;m having is somewhat &quot;curse of its own success&quot;</z><z id="t1595043941" t="ikrimael a lot of times, it looks like magic/i don&apos;t have a high level mental model of how it&apos;s implemented"><y>#</y><d>2020-07-18</d><h>03:45</h><w>ikrimael</w>a lot of times, it looks like magic/i don&apos;t have a high level mental model of how it&apos;s implemented</z><z id="t1595043971" t="ikrimael so finding myself resorting to rote memorization of syntax/grammar"><y>#</y><d>2020-07-18</d><h>03:46</h><w>ikrimael</w>so finding myself resorting to rote memorization of syntax/grammar</z><z id="t1595098192" t="JAtkins Yup. I have the same issue. I&apos;m starting to think I&apos;ll just need to read the source code to see why it does what it does. Right now all I can say is &quot;magic happens&quot; whenever one of these is compiled. Makes it very hard in more advanced use cases to back out what I should do to get the result I want."><y>#</y><d>2020-07-18</d><h>18:49</h><w>JAtkins</w>Yup. I have the same issue. I&apos;m starting to think I&apos;ll just need to read the source code to see why it does what it does. Right now all I can say is &quot;magic happens&quot; whenever one of these is compiled. Makes it very hard in more advanced use cases to back out what I should do to get the result I want.</z><z id="t1595106349" t="Jimmy Miller For me learning meander was more akin to learning functional programming than it was for learning aom clojure library. My recommendation is not try to think about what something does or how it compiles but think about what it means. For example a logic variable is bound to one and only one value. It cannot be rebound. It also must be bound for a match to be valid. Given this, if I see two mentions of the same logic variable, I know they are bound to the same value. So I can use logic variables to join. Same thing is true with the top level API of meander. Match accepts a singular deterministic pattern. Search allows for ambiguity and finds all values that satisfy the match. How all these things work isn&apos;t something that I thought about. Just like I never thought about how closures work, or how algebraic data types work. I just think about what they are. What properties they have."><y>#</y><d>2020-07-18</d><h>21:05</h><w>Jimmy Miller</w>For me learning meander was more akin to learning functional programming than it was for learning aom clojure library. My recommendation is not try to think about what something does or how it compiles but think about what it means.

For example a logic variable is bound to one and only one value. It cannot be rebound. It also must be bound for a match to be valid. Given this, if I see two mentions of the same logic variable, I know they are bound to the same value. So I can use logic variables to join. 

Same thing is true with the top level API of meander. Match accepts a singular deterministic pattern. Search allows for ambiguity and finds all values that satisfy the match. 

How all these things work isn&apos;t something that I thought about. Just like I never thought about how closures work, or how algebraic data types work. I just think about what they are. What properties they have.</z><z id="t1595106560" t="JAtkins Maybe that&apos;s up to learning differences? I typically do better using a tool if I can &quot;see&quot; under the hood. I use see loosely as a stand in for &quot;I kind of know how this works, and if I needed to I could write it&quot;. I&apos;ll definitely try approaching it as learning a top level thing first though. Understanding the code in meander would take quite a while 🙂"><y>#</y><d>2020-07-18</d><h>21:09</h><w>JAtkins</w>Maybe that&apos;s up to learning differences? I typically do better using a tool if I can &quot;see&quot; under the hood. I use see loosely as a stand in for &quot;I kind of know how this works, and if I needed to I could write it&quot;. I&apos;ll definitely try approaching it as learning a top level thing first though. Understanding the code in meander would take quite a while <b>🙂</b></z><z id="t1595106743" t="Jimmy Miller Yeah epsilon is not an easy codebase to understand because it was built while exploring the problem. But also because it just does a lot and is complicated. I did try to explain how we are making zeta. https://jimmyhmiller.github.io/building-meander-in-meander Understanding how meanders actual compiler works would probably not help many people. But I do think understanding a straw man interpreter can be very useful."><y>#</y><d>2020-07-18</d><h>21:12</h><w>Jimmy Miller</w>Yeah epsilon is not an easy codebase to understand because it was built while exploring the problem. But also because it just does a lot and is complicated. I did try to explain how we are making zeta. <a href="https://jimmyhmiller.github.io/building-meander-in-meander" target="_blank">https://jimmyhmiller.github.io/building-meander-in-meander</a>

Understanding how meanders actual compiler works would probably not help many people. But I do think understanding a straw man interpreter can be very useful.</z><z id="t1595165838" t="ikrimael Yeah, probably different learning styles (ex: I looked up how closures are implemented before using them) I think there&apos;s still probably utility in highlevel explanation (like the link and your description two paragraphs ago on logic/memory fvars)"><y>#</y><d>2020-07-19</d><h>13:37</h><w>ikrimael</w>Yeah, probably different learning styles (ex: I looked up how closures are implemented before using them)
I think there&apos;s still probably utility in highlevel explanation (like the link and your description two paragraphs ago on logic/memory fvars)</z><z id="t1595165993" t="ikrimael for me, the disconnect is mostly in the &quot;magical joins and constraint satisfiability&quot; and in turn, what governs if something will be emitted multiple times or if it will be used as a constraint"><y>#</y><d>2020-07-19</d><h>13:39</h><w>ikrimael</w>for me, the disconnect is mostly in the &quot;magical joins and constraint satisfiability&quot; and in turn, what governs if something will be emitted multiple times or if it will be used as a constraint</z><z id="t1595185667" t="noprompt I think the interpreter could be instrumental in helping someone understand one way the semantics can be implemented."><y>#</y><d>2020-07-19</d><h>19:07</h><w>noprompt</w>I think the interpreter could be instrumental in helping someone understand one way the semantics can be implemented.</z><z id="t1595185859" t="Jimmy Miller Yeah I guess that is more my point. The semantics really matter. An interpreter is definitely a decent way to learn those. But in my view the goal is to understand those semantics more than it is to have a good idea of how meander is working under the hood."><y>#</y><d>2020-07-19</d><h>19:10</h><w>Jimmy Miller</w>Yeah I guess that is more my point. The semantics really matter. An interpreter is definitely a decent way to learn those. But in my view the goal is to understand those semantics more than it is to have a good idea of how meander is working under the hood.</z><z id="t1595186014" t="noprompt And I think you know that I share that bias. Meaning is key."><y>#</y><d>2020-07-19</d><h>19:13</h><w>noprompt</w>And I think you know that I share that bias. Meaning is key.</z><z id="t1595186163" t="noprompt Another key thing is being able to map, structurally, implementation details."><y>#</y><d>2020-07-19</d><h>19:16</h><w>noprompt</w>Another key thing is being able to map, structurally, implementation details.</z><z id="t1595186244" t="noprompt But I’m dangerously close to rambling. 🙂"><y>#</y><d>2020-07-19</d><h>19:17</h><w>noprompt</w>But I’m dangerously close to rambling. <b>🙂</b></z><z id="t1595191587" t="ribelo I found a strange behavior that I can&apos;t understand"><y>#</y><d>2020-07-19</d><h>20:46</h><w>ribelo</w>I found a strange behavior that I can&apos;t understand</z><z id="t1595191644" t="ribelo [[:single-match (m/find {:a 1 :b 2} (m/map-of !k !v) :work!)] [:single-match-with-catch-all (m/find {:a 1 :b 2} (m/map-of !k !v) :work! _ :error)] [:multiple-match (m/find {:a 1 :b 2} (m/pred integer?) :_ (m/map-of (m/pred int?) (m/pred int?)) :_ (m/map-of !k !v) :work!)] [:multiple-match-with-catch-all (m/find {:a 1 :b 2} (m/pred integer?) :_ (m/map-of (m/pred int?) (m/pred int?)) :_ (m/and ?mfn (m/map-of !k !v)) :work! _ :error)]] ;; =&gt; [[:single-match :work!] ;; [:single-match-with-catch-all :work!] ;; [:multiple-match :work!] ;; [:multiple-match-with-catch-all :error]] "><y>#</y><d>2020-07-19</d><h>20:47</h><w>ribelo</w><pre>[[:single-match
  (m/find {:a 1 :b 2}
    (m/map-of !k !v) :work!)]
 [:single-match-with-catch-all
  (m/find {:a 1 :b 2}
    (m/map-of !k !v) :work!
    _ :error)]
 [:multiple-match
  (m/find {:a 1 :b 2}
    (m/pred integer?) :_
    (m/map-of (m/pred int?) (m/pred int?)) :_
    (m/map-of !k !v) :work!)]
 [:multiple-match-with-catch-all
  (m/find {:a 1 :b 2}
    (m/pred integer?) :_
    (m/map-of (m/pred int?) (m/pred int?)) :_
    (m/and ?mfn (m/map-of !k !v)) :work!
    _ :error)]]

;; =&gt; [[:single-match :work!]
;;     [:single-match-with-catch-all :work!]
;;     [:multiple-match :work!]
;;     [:multiple-match-with-catch-all :error]]</pre>
</z><z id="t1595191744" t="Jimmy Miller Just fyi doing wrapping the code in ` (no spaces escapes don&apos;t seem to work so I did that.) will help it format better. [[:single-match (m/find {:a 1 :b 2} (m/map-of !k !v) :work!)] [:single-match-with-catch-all (m/find {:a 1 :b 2} (m/map-of !k !v) :work! _ :error)] [:multiple-match (m/find {:a 1 :b 2} (m/pred integer?) :_ (m/map-of (m/pred int?) (m/pred int?)) :_ (m/map-of !k !v) :work!)] [:multiple-match-with-catch-all (m/find {:a 1 :b 2} (m/pred integer?) :_ (m/map-of (m/pred int?) (m/pred int?)) :_ (m/and ?mfn (m/map-of !k !v)) :work! _ :error)]] ;; =&gt; [[:single-match :work!] ;; [:single-match-with-catch-all :work!] ;; [:multiple-match :work!] ;; [:multiple-match-with-catch-all :error]] Let me take a look at what is going on, there is a lot here."><y>#</y><d>2020-07-19</d><h>20:49</h><r>Jimmy Miller</r>Just fyi doing wrapping the code in
<code> </code> ` (no spaces escapes don&apos;t seem to work so I did that.) will help it format better.




<pre>[[:single-match
  (m/find {:a 1 :b 2}
    (m/map-of !k !v) :work!)]
 [:single-match-with-catch-all
  (m/find {:a 1 :b 2}
    (m/map-of !k !v) :work!
    _ :error)]
 [:multiple-match
  (m/find {:a 1 :b 2}
    (m/pred integer?) :_
    (m/map-of (m/pred int?) (m/pred int?)) :_
    (m/map-of !k !v) :work!)]
 [:multiple-match-with-catch-all
  (m/find {:a 1 :b 2}
    (m/pred integer?) :_
    (m/map-of (m/pred int?) (m/pred int?)) :_
    (m/and ?mfn (m/map-of !k !v)) :work!
    _ :error)]]

;; =&gt; [[:single-match :work!]
;;     [:single-match-with-catch-all :work!]
;;     [:multiple-match :work!]
;;     [:multiple-match-with-catch-all :error]]</pre>
Let me take a look at what is going on, there is a lot here.</z><z id="t1595191889" t="Jimmy Miller What version of meander are you using?"><y>#</y><d>2020-07-19</d><h>20:51</h><w>Jimmy Miller</w>What version of meander are you using?</z><z id="t1595191910" t="ribelo meander/epsilon {:mvn/version &quot;0.0.469&quot;} "><y>#</y><d>2020-07-19</d><h>20:51</h><w>ribelo</w><pre>meander/epsilon      {:mvn/version &quot;0.0.469&quot;}</pre>
</z><z id="t1595191952" t="Jimmy Miller Seems like a regression to me. I had an old version open and it worked totally fine. Just tried with latest and it does have the error, which seems wrong to me."><y>#</y><d>2020-07-19</d><h>20:52</h><w>Jimmy Miller</w>Seems like a regression to me. I had an old version open and it worked totally fine. Just tried with latest and it does have the error, which seems wrong to me.</z><z id="t1595192072" t="ribelo : ("><y>#</y><d>2020-07-19</d><h>20:54</h><w>ribelo</w>: (</z><z id="t1595192213" t="Jimmy Miller Yeah, I&apos;m sorry about that bug. I am going to look at it a bit and see if I can uncover the problem. In &quot;0.0.421&quot; it worked fine for me."><y>#</y><d>2020-07-19</d><h>20:56</h><w>Jimmy Miller</w>Yeah, I&apos;m sorry about that bug. I am going to look at it a bit and see if I can uncover the problem. In &quot;0.0.421&quot; it worked fine for me.</z><z id="t1595192238" t="ribelo I&apos;m gonna add the dependency using the git and try again"><y>#</y><d>2020-07-19</d><h>20:57</h><w>ribelo</w>I&apos;m gonna add the dependency using the git and try again</z><z id="t1595192346" t="ribelo It&apos;s an amazing piece of code and I&apos;m having a lot of fun playing with it"><y>#</y><d>2020-07-19</d><h>20:59</h><w>ribelo</w>It&apos;s an amazing piece of code and I&apos;m having a lot of fun playing with it</z><z id="t1595192369" t="ribelo thanks for that"><y>#</y><d>2020-07-19</d><h>20:59</h><w>ribelo</w>thanks for that</z><z id="t1595192416" t="Jimmy Miller Yeah, it looks like search is finding an extra value that I don&apos;t think should be there. And if it should, it is in the wrong order. I&apos;m guessing it has to do with some recent changes to the search stuff. I probably won&apos;t be able to fix it right now, but glad you have work around for the time being. If you have time to make a github issue that would be great, if not I will do that soon."><y>#</y><d>2020-07-19</d><h>21:00</h><w>Jimmy Miller</w>Yeah, it looks like search is finding an extra value that I don&apos;t think should be there. And if it should, it is in the wrong order. I&apos;m guessing it has to do with some recent changes to the search stuff. I probably won&apos;t be able to fix it right now, but glad you have work around for the time being. If you have time to make a github issue that would be great, if not I will do that soon.</z><z id="t1595192444" t="Jimmy Miller Glad that you are enjoying it. Always sad when people discover bugs not caught by our test suite, but that gives us another case to add. Thanks"><y>#</y><d>2020-07-19</d><h>21:00</h><w>Jimmy Miller</w>Glad that you are enjoying it. Always sad when people discover bugs not caught by our test suite, but that gives us another case to add. Thanks</z><z id="t1595192577" t="ribelo I&apos;ll add in a minute"><y>#</y><d>2020-07-19</d><h>21:02</h><w>ribelo</w>I&apos;ll add in a minute</z><z id="t1595193312" t="ribelo https://github.com/noprompt/meander/issues/127"><y>#</y><d>2020-07-19</d><h>21:15</h><w>ribelo</w><a href="https://github.com/noprompt/meander/issues/127" target="_blank">https://github.com/noprompt/meander/issues/127</a></z><z id="t1595196152" t="noprompt I think I know what’s causing that bug."><y>#</y><d>2020-07-19</d><h>22:02</h><w>noprompt</w>I think I know what’s causing that bug.</z></g><g id="s4"><z id="t1595196328" t="noprompt When I have an opportunity, I’ll take a look at this."><y>#</y><d>2020-07-19</d><h>22:05</h><w>noprompt</w>When I have an opportunity, I’ll take a look at this.</z><z id="t1595228518" t="ikrimael re - understanding: yeah, i think we&apos;re in agreement. btw, the building meander in meander post was exactly what I was looking for. maybe add that to the reaadme as a link?"><y>#</y><d>2020-07-20</d><h>07:01</h><w>ikrimael</w>re - understanding: yeah, i think we&apos;re in agreement. 
btw, the building meander in meander post was exactly what I was looking for. 
maybe add that to the reaadme as a link?</z><z id="t1595325355" t="ikrimael is there a way to use m/cata but add &quot;context&quot; to each recursion?"><y>#</y><d>2020-07-21</d><h>09:55</h><w>ikrimael</w>is there a way to use m/cata but add &quot;context&quot; to each recursion?</z><z id="t1595325377" t="ikrimael ex: i&apos;m modifying the hiccup example from the cookbook"><y>#</y><d>2020-07-21</d><h>09:56</h><w>ikrimael</w>ex: i&apos;m modifying the hiccup example from the cookbook</z><z id="t1595325431" t="ikrimael for recursions into block tags, i want to increase the indent level"><y>#</y><d>2020-07-21</d><h>09:57</h><w>ikrimael</w>for recursions into block tags, i want to increase the indent level</z><z id="t1595335624" t="ikrimael ah, n/m, i realized i can use m/let and stuff it as an extra key into the root pattern"><y>#</y><d>2020-07-21</d><h>12:47</h><w>ikrimael</w>ah, n/m, i realized i can use m/let and stuff it as an extra key into the root pattern</z><z id="t1595393078" t="ikrimael i have to say getting to not having to lookup syntax with meander is chefs kiss"><y>#</y><d>2020-07-22</d><h>04:44</h><w>ikrimael</w>i have to say getting to not having to lookup syntax with meander  is chefs kiss</z><z id="t1595393113" t="ikrimael it&apos;s making datashaping and refactoring a lot less of a chore (both in writing complex nested joins/extractions and being able to read it 5 days later instantly)"><y>#</y><d>2020-07-22</d><h>04:45</h><w>ikrimael</w>it&apos;s making datashaping and refactoring a lot less of a chore (both in writing complex nested joins/extractions and being able to read it 5 days later instantly)</z><z id="t1595393276" t="ikrimael the current part i&apos;m trying to unravel is how the memory variables work, specifically in the context of joins"><y>#</y><d>2020-07-22</d><h>04:47</h><w>ikrimael</w>the current part i&apos;m trying to unravel is how the memory variables work, specifically in the context of joins</z><z id="t1595393345" t="ikrimael --------------------------------- for ex, how to convert this into meander:"><y>#</y><d>2020-07-22</d><h>04:49</h><w>ikrimael</w>---------------------------------
for ex, how to convert this into meander:</z><z id="t1595421817" t="Jimmy Miller At least for me, your example of what you want to convert does not show up here."><y>#</y><d>2020-07-22</d><h>12:43</h><r>Jimmy Miller</r>At least for me, your example of what you want to convert does not show up here.</z><z id="t1595484617" t="ikrimael oops; forgot to actually paste"><y>#</y><d>2020-07-23</d><h>06:10</h><r>ikrimael</r>oops; forgot to actually paste</z><z id="t1595484731" t="ikrimael sigh, now I forgot the exact context which I was asking around. let me circle back after I hit it again (won&apos;t be long since it&apos;s a top 3 pattern I keep hitting)"><y>#</y><d>2020-07-23</d><h>06:12</h><r>ikrimael</r>sigh, now I forgot the exact context which I was asking around. let me circle back after I hit it again (won&apos;t be long since it&apos;s a top 3 pattern I keep hitting)</z><z id="t1595491948" t="ikrimael (m/match [{:type &quot;Operator&quot; :fields [{:type &quot;int32&quot; :name &quot;age&quot; :meta [[:uiSlider 1 100] [:tooltip &quot;MyTool&quot;]]} {:type &quot;uid_t&quot; :name &quot;id&quot; :meta [[:hidden]]}]} {:type &quot;Graph&quot; :fields [{:type &quot;vec&lt;int32&gt;&quot; :name &quot;nodes&quot; :meta [[:hidden]]} {:type &quot;graphDesc&quot; :name &quot;meta&quot; :meta [[:hidden]]}]}] [[{:type !type :fields ?flds} ...]] (;; Can&apos;t use meander syntax to rewrite/pattern match inside of ?flds and have to resort to let destructurings ) [[{:type !type :fields [{:type !fldtype :name !fldname :meta !meta} ...]} ...]] (;; !fldtype,!fldname,!meta are no longer &quot;grouped&quot; together to the type they were in )) "><y>#</y><d>2020-07-23</d><h>08:12</h><r>ikrimael</r><pre>(m/match
 [{:type   &quot;Operator&quot;
   :fields [{:type &quot;int32&quot; :name &quot;age&quot; :meta [[:uiSlider 1 100] [:tooltip &quot;MyTool&quot;]]}
            {:type &quot;uid_t&quot; :name &quot;id&quot;  :meta [[:hidden]]}]}
  {:type   &quot;Graph&quot;
   :fields [{:type &quot;vec&lt;int32&gt;&quot; :name &quot;nodes&quot; :meta [[:hidden]]}
            {:type &quot;graphDesc&quot;  :name &quot;meta&quot;  :meta [[:hidden]]}]}]

  [[{:type !type :fields ?flds} ...]]
  (;; Can&apos;t use meander syntax to rewrite/pattern match inside of ?flds and have to resort to let destructurings
   )
  
 [[{:type !type :fields [{:type !fldtype :name !fldname :meta !meta}  ...]} ...]]
  (;; !fldtype,!fldname,!meta are no longer &quot;grouped&quot; together to the type they were in
   ))
</pre></z><z id="t1595491963" t="ikrimael so this is the problem distilled down"><y>#</y><d>2020-07-23</d><h>08:12</h><r>ikrimael</r>so this is the problem distilled down</z><z id="t1595492030" t="ikrimael what I &quot;discovered&quot; last night is using (m/cata) to recurse down and creating a pattern match term for each &quot;nesting level&quot;"><y>#</y><d>2020-07-23</d><h>08:13</h><r>ikrimael</r>what I &quot;discovered&quot; last night is using (m/cata) to recurse down and creating a pattern match term for each &quot;nesting level&quot;</z><z id="t1595492234" t="ikrimael it&apos;s a decent compromise but i&apos;m left wanting: - separating out to different terms erases context of which nested terms are allowed to appear where - found it harder to debug, both along user syntax errors and logic. What i&apos;d end up doing is replace each pattern match term one by one starting from the top until i found which nesting level had an issue, then proceed from there"><y>#</y><d>2020-07-23</d><h>08:17</h><r>ikrimael</r>it&apos;s a decent compromise but i&apos;m left wanting:
- separating out to different terms erases context of which nested terms are allowed to appear where
- found it harder to debug, both along user syntax errors and logic. What i&apos;d end up doing is replace each pattern match term one by one starting from the top until i found which nesting level had an issue, then proceed from there</z><z id="t1595492403" t="ikrimael some mitigations to issues above: - discovered datawalk which has been a godsend and made the above process a lot less painful - since the nesting match terms are all together, it&apos;s not that bad. instead of instant grokking of the code, maybe it&apos;s 5-10 mins as one mentally reconstructs which terms are allowed to go where"><y>#</y><d>2020-07-23</d><h>08:20</h><r>ikrimael</r>some mitigations to issues above:
 - discovered datawalk which has been a godsend and made the above process a lot less painful 
- since the nesting match terms are all together, it&apos;s not that bad. instead of instant grokking of the code, maybe it&apos;s 5-10 mins as one mentally reconstructs which terms are allowed to go where</z><z id="t1595492447" t="ikrimael as a real world ex: here&apos;s the code from last night: https://gist.github.com/ikrima/0353f3f1600a639797c63b2692c63334"><y>#</y><d>2020-07-23</d><h>08:20</h><r>ikrimael</r>as a real world ex: here&apos;s the code from last night: <a href="https://gist.github.com/ikrima/0353f3f1600a639797c63b2692c63334" target="_blank">https://gist.github.com/ikrima/0353f3f1600a639797c63b2692c63334</a></z><z id="t1595513142" t="Jimmy Miller I&apos;m not 100% sure I followed all of what is going on. I think from what I do understand that you are probably doing the right thing by using cata. That is how we often deal with complicated patterns that need a fresh context for nested matches."><y>#</y><d>2020-07-23</d><h>14:05</h><r>Jimmy Miller</r>I&apos;m not 100% sure I followed all of what is going on. I think from what I do understand that you are probably doing the right thing by using cata. That is how we often deal with complicated patterns that need a fresh context for nested matches.</z><z id="t1595618942" t="ikrimael ah, here&apos;s the simplified example with an addition of something along the lines of what i&apos;m reaching for (m/match [{:type &quot;Operator&quot; :fields [{:type &quot;int32&quot; :name &quot;age&quot; :meta [[:uiSlider 1 100] [:tooltip &quot;MyTool&quot;]]} {:type &quot;uid_t&quot; :name &quot;id&quot; :meta [[:hidden]]}]} {:type &quot;Graph&quot; :fields [{:type &quot;vec&lt;int32&gt;&quot; :name &quot;nodes&quot; :meta [[:hidden]]} {:type &quot;graphDesc&quot; :name &quot;meta&quot; :meta [[:hidden]]}]}] [[{:type !type :fields ?flds} ...]] (;; Can&apos;t use meander syntax to rewrite/pattern match inside of ?flds and have to resort to let destructurings ) [[{:type !type :fields [{:type !fldtype :name !fldname :meta !meta} ...]} ...]] (;; !fldtype,!fldname,!meta are no longer &quot;grouped&quot; together to the type they were in ) [[{:type !type :fields [{:type ?fldtype :name ?fldname :meta ?meta :as !fields} ...]} ...]] (;; natural grouping in a concise way ))"><y>#</y><d>2020-07-24</d><h>19:29</h><r>ikrimael</r>ah, here&apos;s the simplified example with an addition of something along the lines of what i&apos;m reaching for
<pre>(m/match
 [{:type   &quot;Operator&quot;
   :fields [{:type &quot;int32&quot; :name &quot;age&quot; :meta [[:uiSlider 1 100] [:tooltip &quot;MyTool&quot;]]}
            {:type &quot;uid_t&quot; :name &quot;id&quot;  :meta [[:hidden]]}]}
  {:type   &quot;Graph&quot;
   :fields [{:type &quot;vec&lt;int32&gt;&quot; :name &quot;nodes&quot; :meta [[:hidden]]}
            {:type &quot;graphDesc&quot;  :name &quot;meta&quot;  :meta [[:hidden]]}]}]

  [[{:type !type :fields ?flds} ...]]
  (;; Can&apos;t use meander syntax to rewrite/pattern match inside of ?flds and have to resort to let destructurings
   )

  [[{:type !type :fields [{:type !fldtype :name !fldname :meta !meta}  ...]} ...]]
  (;; !fldtype,!fldname,!meta are no longer &quot;grouped&quot; together to the type they were in
   )

  [[{:type !type :fields [{:type ?fldtype :name ?fldname :meta ?meta :as !fields}  ...]} ...]]
  (;; natural grouping in a concise way
   ))</pre></z><z id="t1595446333" t="noprompt That’s great experience report to hear [:attrs {:href &quot;/_/_/users/U014X1MN7MM&quot;}] 🙂"><y>#</y><d>2020-07-22</d><h>19:32</h><w>noprompt</w>That’s great experience report to hear <a>@e749</a> <b>🙂</b></z><z id="t1595446416" t="noprompt The 5 days later bit especially. In the early days when I was sketching out what I wanted to do that was one of the problems I wanted to address."><y>#</y><d>2020-07-22</d><h>19:33</h><w>noprompt</w>The 5 days later bit especially. In the early days when I was sketching out what I wanted to do that was one of the problems I wanted to address.</z><z id="t1595446527" t="noprompt Cause, you’re right, you often have to slow down, parse everything, and evaluate it in your mind when you come back to it. And it’s easy to end up with code like that when you’re in that “write only” mode, just trying to get an idea out of your head or some damn thing to work already."><y>#</y><d>2020-07-22</d><h>19:35</h><w>noprompt</w>Cause, you’re right, you often have to slow down, parse everything, and evaluate it in your mind when you come back to it. And it’s easy to end up with code like that when you’re in that “write only” mode, just trying to get an idea out of your head or some damn thing to work already.</z><z id="t1595618942" t="ikrimael ah, here&apos;s the simplified example with an addition of something along the lines of what i&apos;m reaching for (m/match [{:type &quot;Operator&quot; :fields [{:type &quot;int32&quot; :name &quot;age&quot; :meta [[:uiSlider 1 100] [:tooltip &quot;MyTool&quot;]]} {:type &quot;uid_t&quot; :name &quot;id&quot; :meta [[:hidden]]}]} {:type &quot;Graph&quot; :fields [{:type &quot;vec&lt;int32&gt;&quot; :name &quot;nodes&quot; :meta [[:hidden]]} {:type &quot;graphDesc&quot; :name &quot;meta&quot; :meta [[:hidden]]}]}] [[{:type !type :fields ?flds} ...]] (;; Can&apos;t use meander syntax to rewrite/pattern match inside of ?flds and have to resort to let destructurings ) [[{:type !type :fields [{:type !fldtype :name !fldname :meta !meta} ...]} ...]] (;; !fldtype,!fldname,!meta are no longer &quot;grouped&quot; together to the type they were in ) [[{:type !type :fields [{:type ?fldtype :name ?fldname :meta ?meta :as !fields} ...]} ...]] (;; natural grouping in a concise way ))"><y>#</y><d>2020-07-24</d><h>19:29</h><w>ikrimael</w>ah, here&apos;s the simplified example with an addition of something along the lines of what i&apos;m reaching for
<pre>(m/match
 [{:type   &quot;Operator&quot;
   :fields [{:type &quot;int32&quot; :name &quot;age&quot; :meta [[:uiSlider 1 100] [:tooltip &quot;MyTool&quot;]]}
            {:type &quot;uid_t&quot; :name &quot;id&quot;  :meta [[:hidden]]}]}
  {:type   &quot;Graph&quot;
   :fields [{:type &quot;vec&lt;int32&gt;&quot; :name &quot;nodes&quot; :meta [[:hidden]]}
            {:type &quot;graphDesc&quot;  :name &quot;meta&quot;  :meta [[:hidden]]}]}]

  [[{:type !type :fields ?flds} ...]]
  (;; Can&apos;t use meander syntax to rewrite/pattern match inside of ?flds and have to resort to let destructurings
   )

  [[{:type !type :fields [{:type !fldtype :name !fldname :meta !meta}  ...]} ...]]
  (;; !fldtype,!fldname,!meta are no longer &quot;grouped&quot; together to the type they were in
   )

  [[{:type !type :fields [{:type ?fldtype :name ?fldname :meta ?meta :as !fields}  ...]} ...]]
  (;; natural grouping in a concise way
   ))</pre></z><z id="t1595484912" t="ikrimael yeah. i&apos;m a big believer in &quot;stop forcing devs to play compiler/computer in their heads&quot;"><y>#</y><d>2020-07-23</d><h>06:15</h><w>ikrimael</w>yeah. i&apos;m a big believer in &quot;stop forcing devs to play compiler/computer in their heads&quot;</z><z id="t1595495918" t="murtaza52 Given the code below - (m/search [{:farm &quot;&quot;} {:farm &quot;a&quot;} {:farm &quot;&quot;}] (m/scan {:farm _ :as ?row}) (assoc ?row :farm &quot;b&quot;)) Is there a better way to rewrite it, I am basically trying to substitute the :farm value for a given collection of hash-maps."><y>#</y><d>2020-07-23</d><h>09:18</h><w>murtaza52</w>Given the code below -
<pre>(m/search [{:farm &quot;&quot;}
           {:farm &quot;a&quot;}
           {:farm &quot;&quot;}]
  (m/scan {:farm _ :as ?row})
  (assoc ?row :farm &quot;b&quot;))</pre>
Is there a better way to rewrite it, I am basically trying to substitute the :farm value for a given collection of hash-maps.</z><z id="t1595512824" t="Jimmy Miller Here are two other ways you could write this: (m/rewrite [{:farm &quot;&quot;} {:farm &quot;a&quot;} {:farm &quot;&quot;}] [{:farm _ &amp; !rest} ...] [{:farm &quot;b&quot; &amp; !rest} ...]) (m/rewrites [{:farm &quot;&quot;} {:farm &quot;a&quot;} {:farm &quot;&quot;}] (m/scan {:farm _ &amp; ?rest}) {:farm &quot;b&quot; &amp; ?rest})"><y>#</y><d>2020-07-23</d><h>14:00</h><r>Jimmy Miller</r>Here are two other ways you could write this:

<pre>(m/rewrite [{:farm &quot;&quot;}
            {:farm &quot;a&quot;}
            {:farm &quot;&quot;}]
  [{:farm _ &amp; !rest} ...]
  [{:farm &quot;b&quot; &amp; !rest} ...])


(m/rewrites [{:farm &quot;&quot;}
             {:farm &quot;a&quot;}
             {:farm &quot;&quot;}]
   (m/scan {:farm _ &amp; ?rest})
  {:farm &quot;b&quot; &amp; ?rest})</pre></z><z id="t1595514155" t="murtaza52 [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] thanks, let me try to wrap my head around rewrite/rewrites, when do I use it, it looks very similar to match/search ?"><y>#</y><d>2020-07-23</d><h>14:22</h><r>murtaza52</r><a>@U5K8NTHEZ</a> thanks, let me try to wrap my head around rewrite/rewrites, when do I use it, it looks very similar to match/search ?</z><z id="t1595514394" t="Jimmy Miller So both rewrite and rewrites use m/subst on the right hand side. If you think about pattern matching as deconstructing values, substitution is the constructing of values. Basically it extends many of meanders features for creating things as well as matching on them. To make it concrete, instead of rewrites I could have just said: (m/search [{:farm &quot;&quot;} {:farm &quot;a&quot;} {:farm &quot;&quot;}] (m/scan {:farm _ &amp; ?rest}) (m/subst {:farm &quot;b&quot; &amp; ?rest}))"><y>#</y><d>2020-07-23</d><h>14:26</h><r>Jimmy Miller</r>So both rewrite and rewrites use <code>m/subst</code> on the right hand side. If you think about pattern matching as deconstructing values, substitution is the constructing of values. Basically it extends many of meanders features for creating things as well as matching on them.

To make it concrete, instead of rewrites I could have just said:

<pre>(m/search [{:farm &quot;&quot;}
             {:farm &quot;a&quot;}
             {:farm &quot;&quot;}]
   (m/scan {:farm _ &amp; ?rest})
  (m/subst
    {:farm &quot;b&quot; &amp; ?rest}))</pre></z><z id="t1595514512" t="murtaza52 cool thanks"><y>#</y><d>2020-07-23</d><h>14:28</h><r>murtaza52</r>cool thanks</z><z id="t1595513593" t="murtaza52 (m/search [[{:a 1} {:c 3}] [{:b 2} {:d 5}]] (m/scan [{:as ?row}]) (assoc ?row :z 1)) the above snippet does not work. I have a collection of collections of maps. In each map I want to add a k/v, how do I write it ?"><y>#</y><d>2020-07-23</d><h>14:13</h><w>murtaza52</w><pre>(m/search [[{:a 1} {:c 3}] [{:b 2} {:d 5}]]
  (m/scan [{:as ?row}])
  (assoc ?row :z 1))</pre>
the above snippet does not work. I have a collection of collections of maps. In each map I want to add a k/v, how do I write it ?</z><z id="t1595514108" t="murtaza52 (m/rewrites [[{:a 1} {:c 3}] [{:b 2} {:d 5}]] (m/scan (m/scan {&amp; ?rest})) {:z 2 &amp; ?rest}) The above adds the k/v, but doesnt maintain the coll structure, it concats all the collections together."><y>#</y><d>2020-07-23</d><h>14:21</h><w>murtaza52</w><pre>(m/rewrites [[{:a 1} {:c 3}] [{:b 2} {:d 5}]]
  (m/scan (m/scan {&amp; ?rest}))
  {:z 2 &amp; ?rest})</pre>
The above adds the k/v, but doesnt maintain the coll structure, it concats all the collections together.</z><z id="t1595524045" t="noprompt (m/rewrite [[{:a 1} {:c 3}] [{:b 2} {:d 5}]] [(m/cata !xs) ...] [!xs ...] {:as ?it} {:z 2 &amp; ?it}) ;; =&gt; [[{:a 1, :z 2} {:c 3, :z 2}] [{:b 2, :z 2} {:d 5, :z 2}]] "><y>#</y><d>2020-07-23</d><h>17:07</h><w>noprompt</w><pre>(m/rewrite [[{:a 1} {:c 3}] [{:b 2} {:d 5}]]
  [(m/cata !xs) ...]
  [!xs ...]

  {:as ?it}
  {:z 2 &amp; ?it})
;; =&gt;
[[{:a 1, :z 2} {:c 3, :z 2}] [{:b 2, :z 2} {:d 5, :z 2}]]</pre>
</z><z id="t1595789627" t="murtaza52 [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] how do I make the above work if my input is [(...)(...)] ie a vector of seqs instead of a vector of vectors."><y>#</y><d>2020-07-26</d><h>18:53</h><r>murtaza52</r><a>@U06MDAPTP</a> how do I make the above work if my input is <code>[(...)(...)]</code> ie  a vector of seqs instead of a vector of vectors.</z><z id="t1595794652" t="noprompt [:attrs {:href &quot;/_/_/users/UMA62JW4W&quot;}] Switch to (m/seqable …)"><y>#</y><d>2020-07-26</d><h>20:17</h><r>noprompt</r><a>@murtaza52</a> Switch to <code>(m/seqable …)</code></z><z id="t1595794698" t="noprompt Actually, you may need to look at the implementation of that and create your own m/sequential because m/seqable looks for any seqable? thing and calls seq on it."><y>#</y><d>2020-07-26</d><h>20:18</h><r>noprompt</r>Actually, you may need to look at the implementation of that and create your own <code>m/sequential</code> because <code>m/seqable</code> looks for any <code>seqable?</code> thing and calls <code>seq</code> on it.</z><z id="t1595524147" t="noprompt [:attrs {:href &quot;/_/_/users/UMA62JW4W&quot;}] ☝️"><y>#</y><d>2020-07-23</d><h>17:09</h><w>noprompt</w><a>@murtaza52</a> <b>☝️</b></z><z id="t1595524347" t="noprompt One rule to rewrite vectors (recursively rewriting their members), and one to rewrite maps."><y>#</y><d>2020-07-23</d><h>17:12</h><w>noprompt</w>One rule to rewrite vectors (recursively rewriting their members), and one to rewrite maps.</z><z id="t1595524961" t="noprompt Meander has some built-in resistance to complex movements, in particular update “in place”. If you find yourself trying to figure out how to do a transform in one fell swoop, break it up in to more focused rules and use m/cata to drive the traversal, etc."><y>#</y><d>2020-07-23</d><h>17:22</h><w>noprompt</w>Meander has some built-in resistance to complex movements, in particular update “in place”. If you find yourself trying to figure out how to do a transform in one fell swoop, break it up in to more focused rules and use <code>m/cata</code> to drive the traversal, etc.</z><z id="t1595610868" t="murtaza52 [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] thanks ! had not used cata before, so that was a wow moment !"><y>#</y><d>2020-07-24</d><h>17:14</h><r>murtaza52</r><a>@U06MDAPTP</a> thanks ! had not used cata before, so that was a wow moment !</z><z id="t1595540223" t="noprompt Hey folks, I’ve pushed up the some work I’ve been doing to make it possible to dynamically create pattern search interpreters. https://github.com/noprompt/meander/pull/128"><y>#</y><d>2020-07-23</d><h>21:37</h><w>noprompt</w>Hey folks, I’ve pushed up the some work I’ve been doing to make it possible to dynamically create pattern search interpreters. <a href="https://github.com/noprompt/meander/pull/128" target="_blank">https://github.com/noprompt/meander/pull/128</a></z><z id="t1595540432" t="noprompt It’s not quite ready to merge. In the spirit of including the community to the extent I can, I’m welcoming feedback both here and on the PR."><y>#</y><d>2020-07-23</d><h>21:40</h><w>noprompt</w>It’s not quite ready to merge. In the spirit of including the community to the extent I can, I’m welcoming feedback both here and on the PR.</z><z id="t1595540561" t="noprompt It’ll at least be another couple weeks before this will get merged. In the mean time I plan to address the regression recently pointed out and smooth out any rough edges I see."><y>#</y><d>2020-07-23</d><h>21:42</h><w>noprompt</w>It’ll at least be another couple weeks before this will get merged. In the mean time I plan to address the regression recently pointed out and smooth out any rough edges I see.</z><z id="t1595540728" t="noprompt Questions are welcome. I know some have mentioned a desire to understand how the semantics are implemented in code and I said that I think an interpreter can help with that. If there’s still confusion, I’m happy to walk through it."><y>#</y><d>2020-07-23</d><h>21:45</h><w>noprompt</w>Questions are welcome. I know some have mentioned a desire to understand how the semantics are implemented in code and I said that I think an interpreter can help with that. If there’s still confusion, I’m happy to walk through it.</z><z id="t1595619157" t="ikrimael one thing I&apos;ve experimented with is adding extraneous semantic terms to the (m/cata) sub expressions"><y>#</y><d>2020-07-24</d><h>19:32</h><w>ikrimael</w>one thing I&apos;ve experimented with is adding extraneous semantic terms to the <code>(m/cata)</code> sub expressions</z><z id="t1595619308" t="ikrimael so that it&apos;s&apos; easy to demarcate which subexpression it&apos;s meant to recurse into"><y>#</y><d>2020-07-24</d><h>19:35</h><w>ikrimael</w>so that it&apos;s&apos; easy to demarcate which subexpression it&apos;s meant to recurse into</z><z id="t1595619448" t="ikrimael my general takeaway this week though is mixed; the syntax/form is concise that it doesn&apos;t feel like a chore but debugging the recursion patterns is quite frustrating"><y>#</y><d>2020-07-24</d><h>19:37</h><w>ikrimael</w>my general takeaway this week though is mixed; the syntax/form is concise that it doesn&apos;t feel like a chore but debugging the recursion patterns is quite frustrating</z><z id="t1595619509" t="ikrimael caveat: that might also be colored by basic clojure debugging knowledge gaps"><y>#</y><d>2020-07-24</d><h>19:38</h><w>ikrimael</w>caveat: that might also be colored by basic clojure debugging knowledge gaps</z><z id="t1595619568" t="ikrimael don&apos;t really have a solution/anything actionable; just sharing thoughts outloud"><y>#</y><d>2020-07-24</d><h>19:39</h><w>ikrimael</w>don&apos;t really have a solution/anything actionable; just sharing thoughts outloud</z><z id="t1595619596" t="ikrimael maybe if anything, next week i&apos;ll add some debugging walkthrough examples to the cookbook"><y>#</y><d>2020-07-24</d><h>19:39</h><w>ikrimael</w>maybe if anything, next week i&apos;ll add some debugging walkthrough examples to the cookbook</z><z id="t1595620728" t="Jimmy Miller &gt; one thing I&apos;ve experimented with is adding extraneous semantic terms to the (m/cata) sub expressions so that it&apos;s&apos; easy to demarcate which subexpression it&apos;s meant to recurse into There is a pattern that we&apos;ve used a few times to accomplish what you are talking about: (m/rewrite [[1 2] [3 4]] [?x ?y] [(m/cata (`vec-pattern-1 ?x)) (m/cata (`vec-pattern-2 ?y))] (`vec-pattern-1 [?a ?b]) {:vec1 [?a ?b]} (`vec-pattern-2 [?a ?b]) {:vec2 [?a ?b]}) Here I have two completely overlapping patterns, but I can decide which one I want to cata into. In zeta, we use this pretty extensively. Here is an old commit where you can see it directly at play, we have actually abstracted it out a bit in new versions because we used it so often. https://github.com/noprompt/meander/blob/0143dadb5aced8aef4bf48054ba4b74c1a91f3ab/dev/meander/dev/match/zeta.cl In the current version we call them meta function and have a macro that generates some defsyntax patterns for us. https://github.com/noprompt/meander/blob/e54e0f2ea1b4cbd305eb803370d1ac199cb67795/dev/meander/dev/match/zeta.clj#L13-L16"><y>#</y><d>2020-07-24</d><h>19:58</h><w>Jimmy Miller</w>&gt; one thing I&apos;ve experimented with is adding extraneous semantic terms to the (m/cata) sub expressions so that it&apos;s&apos; easy to demarcate which subexpression it&apos;s meant to recurse into
There is a pattern that we&apos;ve used a few times to accomplish what you are talking about:

<pre>(m/rewrite [[1 2] [3 4]]
  [?x ?y]
  [(m/cata (`vec-pattern-1 ?x)) (m/cata (`vec-pattern-2 ?y))]

  (`vec-pattern-1 [?a ?b])
  {:vec1 [?a ?b]}


  (`vec-pattern-2 [?a ?b])
  {:vec2 [?a ?b]})</pre>
Here I have two completely overlapping patterns, but I can decide which one I want to cata into. In zeta, we use this pretty extensively. Here is an old commit where you can see it directly at play, we have actually abstracted it out a bit in new versions because we used it so often. <a href="https://github.com/noprompt/meander/blob/0143dadb5aced8aef4bf48054ba4b74c1a91f3ab/dev/meander/dev/match/zeta.cl" target="_blank">https://github.com/noprompt/meander/blob/0143dadb5aced8aef4bf48054ba4b74c1a91f3ab/dev/meander/dev/match/zeta.cl</a>

In the current version we call them meta function and have a macro that generates some defsyntax patterns for us. <a href="https://github.com/noprompt/meander/blob/e54e0f2ea1b4cbd305eb803370d1ac199cb67795/dev/meander/dev/match/zeta.clj#L13-L16" target="_blank">https://github.com/noprompt/meander/blob/e54e0f2ea1b4cbd305eb803370d1ac199cb67795/dev/meander/dev/match/zeta.clj#L13-L16</a></z><z id="t1595621061" t="Jimmy Miller I trick I do for debugging these things is to add a catch all and intentionally misspell something. (m/rewrite [[1 2] [3 4]] [?x ?y] [(m/cata (`vec-pattern-1 ?x)) (m/cata (`vec-pattern-2 ?y))] (`vec-pattern-misspelled [?a ?b]) {:vec1 [?a ?b]} (`vec-pattern-2 [?a ?b]) {:vec2 [?a ?b]} ?x ?x) ;; =&gt; [(wander.core10/vec-pattern-1 [1 2]) {:vec2 [3 4]}] So now I can see exactly what was going to go down the vec-pattern-1 code path. I will admit this isn&apos;t ideal but pretty handy. We have talked about how if we had an interpreter we could maybe make debugging these things easier."><y>#</y><d>2020-07-24</d><h>20:04</h><r>Jimmy Miller</r>I trick I do for debugging these things is to add a catch all and intentionally misspell something.


<pre>(m/rewrite [[1 2] [3 4]]
  [?x ?y]
  [(m/cata (`vec-pattern-1 ?x)) (m/cata (`vec-pattern-2 ?y))]

  (`vec-pattern-misspelled [?a ?b])
  {:vec1 [?a ?b]}

  (`vec-pattern-2 [?a ?b])
  {:vec2 [?a ?b]}
  
  ?x ?x)

;; =&gt; 

[(wander.core10/vec-pattern-1 [1 2]) {:vec2 [3 4]}]</pre>
So now I can see exactly what was going to go down the vec-pattern-1 code path.

I will admit this isn&apos;t ideal but pretty handy. We have talked about how if we had an interpreter we could maybe make debugging these things easier.</z><z id="t1595622306" t="ikrimael ah this is pretty great"><y>#</y><d>2020-07-24</d><h>20:25</h><r>ikrimael</r>ah this is pretty great</z><z id="t1595622332" t="ikrimael i think i&apos;ll definitely walkthrough some debugging examples then in the cookbook"><y>#</y><d>2020-07-24</d><h>20:25</h><r>ikrimael</r>i think i&apos;ll definitely walkthrough some debugging examples then in the cookbook</z><z id="t1595622077" t="noprompt &gt; but debugging the recursion patterns is quite frustrating I have felt this one too once I’ve built up a large enough system. It’s a problem with a solution and it’s pretty close to the top of the todo list."><y>#</y><d>2020-07-24</d><h>20:21</h><w>noprompt</w>&gt; but debugging the recursion patterns is quite frustrating
I have felt this one too once I’ve built up a large enough system. It’s a problem with a solution and it’s pretty close to the top of the todo list.</z><z id="t1595622532" t="ikrimael somewhat related, i&apos;m having trouble determining when non-exhaustive matches trigger failures vs. not"><y>#</y><d>2020-07-24</d><h>20:28</h><w>ikrimael</w>somewhat related, i&apos;m having trouble determining when non-exhaustive matches trigger failures vs. not</z><z id="t1595622576" t="ikrimael e.g. i thought i had to add (m/some ) everywhere on my map expression matches but that doesn&apos;t seem to be the case"><y>#</y><d>2020-07-24</d><h>20:29</h><w>ikrimael</w>e.g. i thought i had to add <code>(m/some )</code> everywhere on my map expression matches but that doesn&apos;t seem to be the case</z><z id="t1595622726" t="ikrimael and last night I noticed for first time that non-exhaustive matches don&apos;t trigger errors sometimes? I&apos;ve been using (m/cata) &amp; (m/rewrite) a lot more if that adds more context"><y>#</y><d>2020-07-24</d><h>20:32</h><w>ikrimael</w>and last night I noticed for first time that non-exhaustive matches don&apos;t trigger errors sometimes? I&apos;ve been using (m/cata) &amp; (m/rewrite) a lot more if that adds more context</z><z id="t1595622784" t="noprompt Only match complains about exhaustion."><y>#</y><d>2020-07-24</d><h>20:33</h><w>noprompt</w>Only <code>match</code> complains about exhaustion.</z><z id="t1595622844" t="noprompt Normally what I do for rewrite is to make my final clause look something like (m/rewrite _ ,,, ?x [:MISTAKE ?x]) "><y>#</y><d>2020-07-24</d><h>20:34</h><w>noprompt</w>Normally what I do for <code>rewrite</code> is to make my final clause look something like
<pre>(m/rewrite _
  ,,,
  ?x
  [:MISTAKE ?x])</pre>
</z><z id="t1595622848" t="ikrimael that would explain it!"><y>#</y><d>2020-07-24</d><h>20:34</h><w>ikrimael</w>that would explain it!</z><z id="t1595622957" t="noprompt And this isn’t immutable behavior, we can support complaining about exhaustion in rewrite ."><y>#</y><d>2020-07-24</d><h>20:35</h><w>noprompt</w>And this isn’t immutable behavior, we can support complaining about exhaustion in <code>rewrite</code>.</z><z id="t1595623006" t="noprompt I suppose to that extent we could also do so for find ."><y>#</y><d>2020-07-24</d><h>20:36</h><w>noprompt</w>I suppose to that extent we could also do so for <code>find</code>.</z><z id="t1595623034" t="ikrimael oh? i was going to leave that convo thread for another day but now that you bring it up.. :)"><y>#</y><d>2020-07-24</d><h>20:37</h><w>ikrimael</w>oh? i was going to leave that convo thread for another day but now that you bring it up.. :)</z><z id="t1595623118" t="noprompt Ha! Yeah, by all means share your thoughts. I mean, if people don’t share their struggles and other people don’t run into them personally, we can’t help."><y>#</y><d>2020-07-24</d><h>20:38</h><w>noprompt</w>Ha! Yeah, by all means share your thoughts. I mean, if people don’t share their struggles and other people don’t run into them personally, we can’t help.</z><z id="t1595623201" t="ikrimael the meta questions i had were: what are the motivating reasons for said behavior? and assuming it wasn&apos;t unintuitive &quot;here be dragons&quot;, if it&apos;s possible to change the default behavior: - auto complain on exhaustion - force {:key val} to match without using (m/some)"><y>#</y><d>2020-07-24</d><h>20:40</h><w>ikrimael</w>the meta questions i had were: what are the motivating reasons for said behavior?
and assuming it wasn&apos;t unintuitive &quot;here be dragons&quot;, if it&apos;s possible to change the default behavior:
 - auto complain on exhaustion
 - force <code>{:key val}</code> to match without using (m/some)</z><z id="t1595623275" t="ikrimael my reasons: i&apos;d rather default to &quot;strict mode&quot; with having to put extra effort to accomodate slop; i prefer immediate failfast =&gt; easier to debug"><y>#</y><d>2020-07-24</d><h>20:41</h><w>ikrimael</w>my reasons: i&apos;d rather default to &quot;strict mode&quot; with having to put extra effort to accomodate slop; i prefer immediate failfast =&gt; easier to debug</z><z id="t1595623361" t="noprompt The behavior, I think fell out of history and not really a particular design choice. I started with match , search , and substitute first and then created find , and then based rewrite on top of find and substitute ."><y>#</y><d>2020-07-24</d><h>20:42</h><w>noprompt</w>The behavior, I think fell out of history and not really a particular design choice. I started with <code>match</code>, <code>search</code>, and <code>substitute</code> first and then created <code>find</code>, and then based <code>rewrite</code> on top of <code>find</code>  and <code>substitute</code>.</z><z id="t1595623370" t="noprompt Yeah, and I’m inclined to support an option to make that possible."><y>#</y><d>2020-07-24</d><h>20:42</h><w>noprompt</w>Yeah, and I’m inclined to support an option to make that possible.</z><z id="t1595623421" t="noprompt I’ve just gotten in the habit of jotting down a catch all “mistake” rule at the bottom of the system when I start."><y>#</y><d>2020-07-24</d><h>20:43</h><w>noprompt</w>I’ve just gotten in the habit of jotting down a catch all “mistake” rule at the bottom of the system when I start.</z><z id="t1595623479" t="ikrimael yeah makes sense and honestly, it might be a moot point/aesthetic thing"><y>#</y><d>2020-07-24</d><h>20:44</h><w>ikrimael</w>yeah makes sense and honestly, it might be a moot point/aesthetic thing</z><z id="t1595623495" t="ikrimael bc that&apos;s the first thing i do as soon as i hit a bug"><y>#</y><d>2020-07-24</d><h>20:44</h><w>ikrimael</w>bc that&apos;s the first thing i do as soon as i hit a bug</z><z id="t1595623521" t="ikrimael i think at this point all my meander matches have a catchall that throws an exception with stacktrace"><y>#</y><d>2020-07-24</d><h>20:45</h><w>ikrimael</w>i think at this point all my meander matches have a catchall that throws an exception with stacktrace</z><z id="t1595623646" t="ikrimael what do you &amp; [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] put in those clauses? (subtext: a. wonder if there&apos;s some nice tricks in there b. is it something you do all the time/common =&gt; maybe a case for makingg it a default?)"><y>#</y><d>2020-07-24</d><h>20:47</h><w>ikrimael</w>what do you &amp; <a>@jimmy</a> put in those clauses? 
(subtext: 
a. wonder if there&apos;s some nice tricks in there 
b. is it something you do all the time/common =&gt; maybe a case for makingg it a default?)</z><z id="t1595623822" t="Jimmy Miller Mine typically looks like what [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] mentioned above. Something that stands out like [:INCOMPLETE ?x] . That way if I’m doing a recursive pattern I can see where in my recursion I am stopping."><y>#</y><d>2020-07-24</d><h>20:50</h><r>Jimmy Miller</r>Mine typically looks like what <a>@noprompt</a> mentioned above. Something that stands out like <code>[:INCOMPLETE ?x]</code>. That way if I’m doing a recursive pattern I can see where in my recursion I am stopping.</z><z id="t1595623665" t="noprompt So something like ^::m/flag-to-throw (m/find ,,,) "><y>#</y><d>2020-07-24</d><h>20:47</h><w>noprompt</w>So something like
<pre>^::m/flag-to-throw (m/find ,,,)</pre>
</z><z id="t1595623987" t="noprompt [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] will probably do a better job explaining this than I will but the idea behind the rules like (`name ?x) {:name ?x} [!xs ...] [(m/cata (`name !xs)) ...] is that you’re emulating a function call."><y>#</y><d>2020-07-24</d><h>20:53</h><w>noprompt</w><a>@jimmy</a> will probably do a better job explaining this than I will but the idea behind the rules like
<pre>(`name ?x)
{:name ?x}

[!xs ...]
[(m/cata (`name !xs)) ...]</pre>
is that you’re emulating a function call.</z><z id="t1595624150" t="noprompt It’s a way to give you control."><y>#</y><d>2020-07-24</d><h>20:55</h><w>noprompt</w>It’s a way to give you control.</z><z id="t1595624212" t="noprompt It’s also extremely intoxicating. 🙂"><y>#</y><d>2020-07-24</d><h>20:56</h><w>noprompt</w>It’s also extremely intoxicating. <b>🙂</b></z><z id="t1595624254" t="ikrimael haha; yeah, it really is"><y>#</y><d>2020-07-24</d><h>20:57</h><w>ikrimael</w>haha; yeah, it really is</z><z id="t1595624274" t="noprompt But a case and point for needing explanations when shit doesn’t work."><y>#</y><d>2020-07-24</d><h>20:57</h><w>noprompt</w>But a case and point for needing explanations when shit doesn’t work.</z><z id="t1595624278" t="ikrimael i have to admit, it was pretty amazing the first part of the week; unfortunately the debugging aspect of it was the only bummer but i thinkn that can be solved"><y>#</y><d>2020-07-24</d><h>20:57</h><w>ikrimael</w>i have to admit, it was pretty amazing the first part of the week; unfortunately the debugging aspect of it was the only bummer but i thinkn that can be solved</z><z id="t1595624378" t="noprompt I think it’s really cool when people get to the point you’re at though because in terms of experience I’m more or less where you are and at this point we can just trade techniques."><y>#</y><d>2020-07-24</d><h>20:59</h><w>noprompt</w>I think it’s really cool when people get to the point you’re at though because in terms of experience I’m more or less where you are and at this point we can just trade techniques.</z><z id="t1595624463" t="ikrimael yeah; it&apos;s really making very complex term rewriting or graph optimizations really tractable"><y>#</y><d>2020-07-24</d><h>21:01</h><w>ikrimael</w>yeah; it&apos;s really making very complex term rewriting or graph optimizations really tractable</z><z id="t1595624505" t="ikrimael or rather, i&apos;ve been able to quickly do simple term rewriting and constant folding passes"><y>#</y><d>2020-07-24</d><h>21:01</h><w>ikrimael</w>or rather, i&apos;ve been able to quickly do simple term rewriting and constant folding passes</z><z id="t1595624555" t="ikrimael that i normally would&apos;ve relegated to a whole separate pass with work building up necessary &quot;infrastructure&quot;"><y>#</y><d>2020-07-24</d><h>21:02</h><w>ikrimael</w>that i normally would&apos;ve relegated to a whole separate pass with work building up necessary &quot;infrastructure&quot;</z><z id="t1595624577" t="ikrimael (unrelated but btw, [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] since i saw you on futureofcoding, all of this is for implementing something similar to gibber or s-ol&apos;s alv demo but for C/hlsl)"><y>#</y><d>2020-07-24</d><h>21:02</h><w>ikrimael</w>(unrelated but  btw, <a>@jimmy</a> since i saw you on futureofcoding, all of this is for implementing something similar to gibber or s-ol&apos;s alv demo but for C/hlsl)</z><z id="t1595624601" t="noprompt This is kind of the best situation I could hope for. It confirms a point I’ve made about regular expression elsewhere which is that because the semantics of the symbols don’t change from context to context, you no longer need context to talk about a particular program."><y>#</y><d>2020-07-24</d><h>21:03</h><w>noprompt</w>This is kind of the best situation I could hope for. It confirms a point I’ve made about regular expression elsewhere which is that because the semantics of the symbols don’t change from context to context, you no longer need context to talk about a particular program.</z><z id="t1595624648" t="ikrimael yup. it&apos;s also really easy to read the transformation after the fact"><y>#</y><d>2020-07-24</d><h>21:04</h><w>ikrimael</w>yup. it&apos;s also really easy to read the transformation after the fact</z><z id="t1595624685" t="ikrimael and also made me realize how much &quot;unnecessary&quot; work I do that goes into just changing shape of data"><y>#</y><d>2020-07-24</d><h>21:04</h><w>ikrimael</w>and also made me realize how much &quot;unnecessary&quot; work I do that goes into just changing shape of data</z><z id="t1595624695" t="noprompt Slightly off topic, are you familiar with the nano pass stuff?"><y>#</y><d>2020-07-24</d><h>21:04</h><w>noprompt</w>Slightly off topic, are you familiar with the nano pass stuff?</z><z id="t1595624697" t="ikrimael especially in exploratory/design phase"><y>#</y><d>2020-07-24</d><h>21:04</h><w>ikrimael</w>especially in exploratory/design phase</z><z id="t1595624705" t="noprompt Right?!"><y>#</y><d>2020-07-24</d><h>21:05</h><w>noprompt</w>Right?!</z><z id="t1595624712" t="ikrimael no not at all. what&apos;s that?"><y>#</y><d>2020-07-24</d><h>21:05</h><w>ikrimael</w>no not at all. what&apos;s that?</z><z id="t1595624759" t="noprompt Basically the idea is that you build a compiler out of all these little passes that do one thing after another to an AST, etc."><y>#</y><d>2020-07-24</d><h>21:05</h><w>noprompt</w>Basically the idea is that you build a compiler out of all these little passes that do one thing after another to an AST, etc.</z><z id="t1595624786" t="ikrimael haha oh my god i&apos;m going to hate cry laugh if it&apos;s what i think it is"><y>#</y><d>2020-07-24</d><h>21:06</h><w>ikrimael</w>haha oh my god i&apos;m going to hate cry laugh if it&apos;s what i think it is</z><z id="t1595624793" t="noprompt Anyway, there’s a paper about it and that’s where cata came from."><y>#</y><d>2020-07-24</d><h>21:06</h><w>noprompt</w>Anyway, there’s a paper about it and that’s where <code>cata</code> came from.</z><z id="t1595624811" t="ikrimael ah no shit. thanks for the link, i&apos;ll definitely read into it tonight"><y>#</y><d>2020-07-24</d><h>21:06</h><w>ikrimael</w>ah no shit. thanks for the link, i&apos;ll definitely read into it tonight</z><z id="t1595624818" t="noprompt But it’s only on the match side."><y>#</y><d>2020-07-24</d><h>21:06</h><w>noprompt</w>But it’s only on the match side.</z><z id="t1595624854" t="ikrimael i definitely which there was way more tooling/infra for creating DSLs but I couldn&apos;t find much when I started all of this"><y>#</y><d>2020-07-24</d><h>21:07</h><w>ikrimael</w>i definitely which there was way more tooling/infra for creating DSLs but I couldn&apos;t find much when I started all of this</z><z id="t1595624918" t="noprompt cata on the substitution side was a like a light year leap for rewrite . It made it possible to do a bunch of stuff that was really awkward to do before it."><y>#</y><d>2020-07-24</d><h>21:08</h><w>noprompt</w><code>cata</code> on the substitution side was a like a light year leap for <code>rewrite</code>. It made it possible to do a bunch of stuff that was really awkward to do before it.</z><z id="t1595624979" t="noprompt Totally. And we have really fantastic stuff like instparse in Clojure but doing anything remotely interesting with those ASTs using stock Clojure is tedious."><y>#</y><d>2020-07-24</d><h>21:09</h><w>noprompt</w>Totally. And we have really fantastic stuff like instparse in Clojure but doing anything remotely interesting with those ASTs using stock Clojure is tedious.</z><z id="t1595625065" t="noprompt Because there are commonly complex relationships between siblings, grandnodes, etc that are painful to code up."><y>#</y><d>2020-07-24</d><h>21:11</h><w>noprompt</w>Because there are commonly complex relationships between siblings, grandnodes, etc that are painful to code up.</z><z id="t1595625110" t="ikrimael imagine trying to do that in C++ 😅 &lt;=== wrestling with templates at 3 am, I heard the &quot;it was at this moment that he knew he fucked up&quot; and started looking into nim + clojure the next day"><y>#</y><d>2020-07-24</d><h>21:11</h><w>ikrimael</w>imagine trying to do that in C++ <b>😅</b>
&lt;=== wrestling with templates at 3 am, I heard the &quot;it was at this moment that he knew he fucked up&quot; and started looking into nim + clojure the next day</z><z id="t1595625135" t="noprompt Maintaining a pattern, to press the Clojure vocabulary buttons, is simple and easy."><y>#</y><d>2020-07-24</d><h>21:12</h><w>noprompt</w>Maintaining a pattern, to press the Clojure vocabulary buttons, is simple and easy.</z><z id="t1595625158" t="ikrimael (btw, anything else you&apos;d recommend in the line of nanopass? the only other thing i&apos;ve seen in that space is the MLIR effort by llvm i&apos;m mostly a low level graphics guy so only 3 months into knowing about compilers/prog. langs. or the space)"><y>#</y><d>2020-07-24</d><h>21:12</h><w>ikrimael</w>(btw, anything else you&apos;d recommend in the line of nanopass? the only other thing i&apos;ve seen in that space is the MLIR effort by llvm
i&apos;m mostly a low level graphics guy so only 3 months into knowing about compilers/prog. langs. or the space)</z><z id="t1595625168" t="noprompt Yeah, this is why I’m really excited about what you’re hacking on by the way."><y>#</y><d>2020-07-24</d><h>21:12</h><w>noprompt</w>Yeah, this is why I’m really excited about what you’re hacking on by the way.</z><z id="t1595625262" t="ikrimael (*ah i should say, i also learned a lot looking at nasser&apos;s mage compiler; that approach seemed really good)"><y>#</y><d>2020-07-24</d><h>21:14</h><w>ikrimael</w>(*ah i should say, i also learned a lot looking at nasser&apos;s mage compiler; that approach seemed really good)</z><z id="t1595625263" t="noprompt I dunno, there’s so much stuff to recommend but normally I don’t unless it’s about a particular topic. I heard about the nano pass framework a few years ago, forgot about it, and then someone here mentioned the cata thing and brought that back to my attention."><y>#</y><d>2020-07-24</d><h>21:14</h><w>noprompt</w>I dunno, there’s so much stuff to recommend but normally I don’t unless it’s about a particular topic. I heard about the nano pass framework a few years ago, forgot about it, and then someone here mentioned the <code>cata</code> thing and brought that back to my attention.</z><z id="t1595625275" t="noprompt Yes!"><y>#</y><d>2020-07-24</d><h>21:14</h><w>noprompt</w>Yes!</z><z id="t1595625316" t="noprompt This stuff makes me wonder “why the hell aren’t we being encouraged to exploit :inline and :inline-arities ?”"><y>#</y><d>2020-07-24</d><h>21:15</h><w>noprompt</w>This stuff makes me wonder “why the hell aren’t we being encouraged to exploit <code>:inline</code> and <code>:inline-arities</code>?”</z><z id="t1595632332" t="ikrimael [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] i&apos;m watching the nanopass talks and it&apos;s fantastic ; if nothing else, highlighting some interesting ways could architect the dsl compiler I&apos;m missing the link to meander though?"><y>#</y><d>2020-07-24</d><h>23:12</h><w>ikrimael</w><a>@noprompt</a> i&apos;m watching the nanopass talks and it&apos;s fantastic ; if nothing else, highlighting some interesting ways could architect the dsl compiler
I&apos;m missing the link to meander though?</z><z id="t1595632456" t="noprompt The link was to the dissertation: http://www.andykeep.com/pubs/dissertation.pdf"><y>#</y><d>2020-07-24</d><h>23:14</h><w>noprompt</w>The link was to the dissertation: <a href="http://www.andykeep.com/pubs/dissertation.pdf" target="_blank">http://www.andykeep.com/pubs/dissertation.pdf</a></z><z id="t1595632490" t="noprompt It’s mentioned on pages 4 - 5."><y>#</y><d>2020-07-24</d><h>23:14</h><w>noprompt</w>It’s mentioned on pages 4 - 5.</z><z id="t1595632657" t="noprompt &gt; The match form also supports catamorphisms [68] to recur through the sub-expressions of the input forms. A catamorphism, for our purposes, recurs through sub-forms in the language until a terminal case, such as x or (quote d) , is found. The simplify pattern can be rewritten to use catamorphisms as follows: (define simplify (lambda (x) (match x [,x (guard (symbol? x)) x] [(quote ,d) `(quote ,d)] [(if ,[e0] ,[e1]) `(if ,e0 ,e1 (void))] [(if ,[e0] ,[e1] ,[e2]) `(if ,e0 ,e1 ,e2)] [(begin ,[e*] ... ,[e]) (make-begin e* e)] [(lambda (,x* ...) ,[body*] ... ,[body]) `(lambda (,x* ...) ,(make-begin body* body))] [(letrec ([,x* ,[e*]] ...) ,[body*] ... ,[body]) `(letrec ([,x* ,e*] ...) ,(make-begin body* body))] [(,[e] ,[e*] ...) `(,e ,e* ...))]))) &gt; Here, the square brackets (`[ ]`) in the syntax ,[e0] indicate that a catamorphism should be applied."><y>#</y><d>2020-07-24</d><h>23:17</h><w>noprompt</w>&gt; The match form also supports catamorphisms [68] to recur through the sub-expressions of the input forms. A catamorphism, for our purposes, recurs through sub-forms in the language until a terminal case, such as <code>x</code> or <code>(quote d)</code>, is found. The <code>simplify</code> pattern can be rewritten to use catamorphisms as follows:
<pre>(define simplify
  (lambda (x)
    (match x
      [,x (guard (symbol? x)) x]
      [(quote ,d) `(quote ,d)]
      [(if ,[e0] ,[e1]) `(if ,e0 ,e1 (void))]
      [(if ,[e0] ,[e1] ,[e2]) `(if ,e0 ,e1 ,e2)]
      [(begin ,[e*] ... ,[e]) (make-begin e* e)]
      [(lambda (,x* ...) ,[body*] ... ,[body])
       `(lambda (,x* ...) ,(make-begin body* body))]
      [(letrec ([,x* ,[e*]] ...) ,[body*] ... ,[body])
       `(letrec ([,x* ,e*] ...) ,(make-begin body* body))]
      [(,[e] ,[e*] ...) `(,e ,e* ...))])))</pre>
&gt; Here, the square brackets (`[ ]`) in the syntax <code>,[e0]</code> indicate that a catamorphism should be applied.</z><z id="t1595632711" t="ikrimael aah gotcha"><y>#</y><d>2020-07-24</d><h>23:18</h><w>ikrimael</w>aah gotcha</z><z id="t1595632731" t="noprompt I really would love to have something as lightweight as [ ] instead of cata ."><y>#</y><d>2020-07-24</d><h>23:18</h><w>noprompt</w>I really would love to have something as lightweight as <code>[ ]</code> instead of <code>cata</code>.</z><z id="t1595632816" t="ikrimael this is really exciting though; i&apos;ve been fumbling around trying to architect the compiler and it&apos;s various passes in an extensible way"><y>#</y><d>2020-07-24</d><h>23:20</h><w>ikrimael</w>this is really exciting though; i&apos;ve been fumbling around trying to architect the compiler and it&apos;s various passes in an extensible way</z><z id="t1595632843" t="ikrimael and at least from what i&apos;ve seen so far, this approach is very mappable to how i&apos;m trying to use meander"><y>#</y><d>2020-07-24</d><h>23:20</h><w>ikrimael</w>and at least from what i&apos;ve seen so far, this approach is very mappable to how i&apos;m trying to use meander</z><z id="t1595633023" t="ikrimael *rather, the entire compiler chain can be done this way vs. i&apos;m just using it for front end/medium end"><y>#</y><d>2020-07-24</d><h>23:23</h><w>ikrimael</w>*rather, the entire compiler chain can be done this way vs. i&apos;m just using it for front end/medium end</z><z id="t1595633264" t="noprompt It’s certainly a sane way to do it."><y>#</y><d>2020-07-24</d><h>23:27</h><w>noprompt</w>It’s certainly a sane way to do it.</z><z id="t1595666134" t="noprompt [meander/epsilon &quot;0.0.479&quot;] This release fixes the regression pointed out recently."><y>#</y><d>2020-07-25</d><h>08:35</h><w>noprompt</w><pre>[meander/epsilon &quot;0.0.479&quot;]</pre>
This release fixes the regression pointed out recently.</z><z id="t1595702174" t="noprompt Do upgrade folks."><y>#</y><d>2020-07-25</d><h>18:36</h><w>noprompt</w>Do upgrade folks.</z><z id="t1595707141" t="JAtkins So, I got another question -- is there any way to force some type of grouping? (m/search [{:a :whatever :b [{:n 1} {:n 2} {:n 1}]} {:a :goes :b [{:n 1} {:n 2} {:n 4}]} {:a :here :b [{:n 2} {:n 2} {:n 3}]}] (m/scan {:a ?a :b (m/scan {:n !n})}) {:a ?a :n !n}) ;; =&gt; currently returns ({:a :whatever, :n [1]} {:a :whatever, :n [2]} {:a :whatever, :n [1]} {:a :goes, :n [1]} {:a :goes, :n [2]} {:a :goes, :n [4]} {:a :here, :n [2]} {:a :here, :n [2]} {:a :here, :n [3]}) ;; =&gt; what I&apos;m going for [{:a :whatever :b [1 2 1]} {:a :goes :b [1 2 4]} {:a :here :b [2 2 3]}]"><y>#</y><d>2020-07-25</d><h>19:59</h><w>JAtkins</w>So, I got another question -- is there any way to force some type of grouping?

<pre>(m/search [{:a :whatever :b [{:n 1} {:n 2} {:n 1}]}
             {:a :goes :b [{:n 1} {:n 2} {:n 4}]}
             {:a :here :b [{:n 2} {:n 2} {:n 3}]}]
    (m/scan {:a ?a :b (m/scan {:n !n})})
    {:a ?a :n !n})

;; =&gt; currently returns

({:a :whatever, :n [1]}
 {:a :whatever, :n [2]}
 {:a :whatever, :n [1]}
 {:a :goes, :n [1]}
 {:a :goes, :n [2]}
 {:a :goes, :n [4]}
 {:a :here, :n [2]}
 {:a :here, :n [2]}
 {:a :here, :n [3]})

;; =&gt; what I&apos;m going for

[{:a :whatever :b [1 2 1]}
 {:a :goes :b [1 2 4]}
 {:a :here :b [2 2 3]}]</pre></z><z id="t1595707154" t="JAtkins Is there any way to reach this grouping?"><y>#</y><d>2020-07-25</d><h>19:59</h><w>JAtkins</w>Is there any way to reach this grouping?</z><z id="t1595707474" t="JAtkins m/gather is really close - just found it"><y>#</y><d>2020-07-25</d><h>20:04</h><w>JAtkins</w>m/gather is really close - just found it</z><z id="t1595707597" t="noprompt Not yet. At the moment the recommendation is to use group-by — cool, if gather helps you accomplish what you’re after, by all means, use that. If you really need group-by use that. The plan is to have a primitive for this called a “fold” which is essentially a variable that uses a reduction when it binds."><y>#</y><d>2020-07-25</d><h>20:06</h><w>noprompt</w>Not yet. At the moment the recommendation is to use <code>group-by</code> — cool, if <code>gather</code> helps you accomplish what you’re after, by all means, use that. If you really need <code>group-by</code> use that.

The plan is to have a primitive for this called a “fold” which is essentially a variable that uses a reduction when it binds.</z><z id="t1595707651" t="JAtkins Gacha"><y>#</y><d>2020-07-25</d><h>20:07</h><w>JAtkins</w>Gacha</z><z id="t1595707654" t="noprompt Folds will allow computing min or max , grouping, etc."><y>#</y><d>2020-07-25</d><h>20:07</h><w>noprompt</w>Folds will allow computing <code>min</code> or <code>max</code>, grouping, etc.</z><z id="t1595707698" t="JAtkins I&apos;ll use group-by for now. Thanks for the tip!"><y>#</y><d>2020-07-25</d><h>20:08</h><w>JAtkins</w>I&apos;ll use group-by for now. Thanks for the tip!</z><z id="t1595707703" t="noprompt These are in the works. I’ve had to take a bit of time away from focusing on how they will work because epsilon has required a lot of my attention lately."><y>#</y><d>2020-07-25</d><h>20:08</h><w>noprompt</w>These are in the works. I’ve had to take a bit of time away from focusing on how they will work because <code>epsilon</code> has required a lot of my attention lately.</z><z id="t1595707705" t="noprompt Sure thing!"><y>#</y><d>2020-07-25</d><h>20:08</h><w>noprompt</w>Sure thing!</z><z id="t1595779133" t="ikrimael +1 on group by; [:attrs {:href &quot;/_/_/users/U5P29DSUS&quot;}] how&apos;re you using m/gather? i couldn&apos;t get it to work the way i thought it would (i.e. with maps)"><y>#</y><d>2020-07-26</d><h>15:58</h><w>ikrimael</w>+1 on group by; <a>@jatkin</a> how&apos;re you using m/gather? i couldn&apos;t get it to work the way i thought it would (i.e. with maps)</z><z id="t1595779204" t="JAtkins (m/search [{:a :whatever :b [{:n 1} {:n 2} {:n 1}]} {:a :goes :b [{:n 1} {:n 2} {:n 4}]} {:a :here :b [{:n 2} {:n 2} {:n 3}]}] (m/scan {:a ?a :b (m/gather {:n !n})}) {:a ?a :n !n}) This did an ordered powerset of n"><y>#</y><d>2020-07-26</d><h>16:00</h><w>JAtkins</w><pre>(m/search [{:a :whatever :b [{:n 1} {:n 2} {:n 1}]}
             {:a :goes :b [{:n 1} {:n 2} {:n 4}]}
             {:a :here :b [{:n 2} {:n 2} {:n 3}]}]
    (m/scan {:a ?a :b (m/gather {:n !n})})
    {:a ?a :n !n})</pre>
This did an ordered powerset of n</z><z id="t1595779265" t="ikrimael imho, that&apos;s a great candidate to go into the cookbook"><y>#</y><d>2020-07-26</d><h>16:01</h><w>ikrimael</w>imho, that&apos;s a great candidate to go into the cookbook</z><z id="t1595779296" t="JAtkins Sure - only thing is I don&apos;t fully grok why this did what it did"><y>#</y><d>2020-07-26</d><h>16:01</h><w>JAtkins</w>Sure - only thing is I don&apos;t fully grok why this did what it did</z><z id="t1595779311" t="ikrimael haha, neither do I. i&apos;m playing with it right now"><y>#</y><d>2020-07-26</d><h>16:01</h><w>ikrimael</w>haha, neither do I. i&apos;m playing with it right now</z><z id="t1595779528" t="Jimmy Miller The gather there wouldn&apos;t be necessary. On my phone but you should be able to do [pattern ...]"><y>#</y><d>2020-07-26</d><h>16:05</h><w>Jimmy Miller</w>The gather there wouldn&apos;t be necessary. On my phone but you should be able to do [pattern ...]</z><z id="t1595779663" t="JAtkins Yup, you are right"><y>#</y><d>2020-07-26</d><h>16:07</h><w>JAtkins</w>Yup, you are right</z><z id="t1595779680" t="Jimmy Miller Gather is filter for pattern matching. Given a pattern it will go through a sequence and find all the elements that match ignoring the others."><y>#</y><d>2020-07-26</d><h>16:08</h><w>Jimmy Miller</w>Gather is filter for pattern matching. Given a pattern it will go through a sequence and find all the elements that match ignoring the others.</z><z id="t1595779949" t="ikrimael can you elucidate on how this is different than the &quot;normal&quot; way? ex: [ (m/app bla) ...] or [pattern ...] also is it meant to be used with maps?"><y>#</y><d>2020-07-26</d><h>16:12</h><r>ikrimael</r>can you elucidate on how this is different than the &quot;normal&quot; way?
ex: <code>[ (m/app bla) ...]</code> or <code>[pattern ...]</code>
also is it meant to be used with maps?</z><z id="t1595780221" t="Jimmy Miller It is used on seqables. Gather is often used with pred. So you could use gather with (m/pred even?) To gather up all the even numbers. Where as doing it with ... would require everything to be an even number."><y>#</y><d>2020-07-26</d><h>16:17</h><r>Jimmy Miller</r>It is used on seqables. Gather is often used with pred. So you could use gather with (m/pred even?) To gather up all the even numbers. Where as doing it with ... would require everything to be an even number.</z><z id="t1595780801" t="Jimmy Miller Gather has a (m/or pattern _) inside it. It does a little bit more than that though to handle more advanced repeat cases."><y>#</y><d>2020-07-26</d><h>16:26</h><r>Jimmy Miller</r>Gather has a <code>(m/or pattern _)</code> inside it. It does a little bit more than that though to handle more advanced repeat cases.</z><z id="t1595780884" t="ikrimael i think i&apos;m missing something bc i&apos;m still seeing it as (gather (pred even?) == syntactic sugar for [(pred even?) ...] ?"><y>#</y><d>2020-07-26</d><h>16:28</h><r>ikrimael</r>i think i&apos;m missing something bc i&apos;m still seeing it as <code>(gather (pred even?)</code> == syntactic sugar for  <code>[(pred even?) ...]</code> ?</z><z id="t1595780928" t="ikrimael except with the latter, that form also allows for dealing with maps"><y>#</y><d>2020-07-26</d><h>16:28</h><r>ikrimael</r>except with the latter, that form also allows for dealing with maps</z><z id="t1595781186" t="Jimmy Miller Imagine the sequence were [1 2 3]. The former expression would match. The latter would not because they are not all even numbers."><y>#</y><d>2020-07-26</d><h>16:33</h><r>Jimmy Miller</r>Imagine the sequence were [1 2 3]. The former expression would match. The latter would not because they are not all even numbers.</z><z id="t1595781238" t="Jimmy Miller Gather has nothing to do with maps. It is just matching on seqables using m/seqable"><y>#</y><d>2020-07-26</d><h>16:33</h><r>Jimmy Miller</r>Gather has nothing to do with maps. It is just matching on seqables using m/seqable</z><z id="t1595781334" t="Jimmy Miller Gather is almost syntatic sugar for (seqable (or pattern _) ...)"><y>#</y><d>2020-07-26</d><h>16:35</h><r>Jimmy Miller</r>Gather is almost syntatic sugar for <code>(seqable (or pattern _) ...)</code></z><z id="t1595783525" t="ikrimael 👍 ah right right. i keep blurring when things are exhaustive matches vs. not"><y>#</y><d>2020-07-26</d><h>17:12</h><r>ikrimael</r><b>👍</b>
ah right right. i keep blurring when things are exhaustive matches vs. not</z><z id="t1595783590" t="ikrimael i think i&apos;ve hit [(pred even?) ...] =&gt; not doing what i just thought it did and then replacing it with scan and changing match to find or search until something works 😛"><y>#</y><d>2020-07-26</d><h>17:13</h><r>ikrimael</r>i think i&apos;ve hit <code>[(pred even?) ...]</code> =&gt; not doing what i just thought it did
and then replacing it with <code>scan</code> and changing match to find or search until something works <b>😛</b></z><z id="t1595783661" t="ikrimael caveat: i just recently discover m/map-of and m/submap-of which (correct me if i&apos;m wrong) are the map equivalents for gather"><y>#</y><d>2020-07-26</d><h>17:14</h><r>ikrimael</r>caveat: i just recently discover <code>m/map-of and m/submap-of</code> which  (correct me if i&apos;m wrong) are the map equivalents for <code>gather</code></z><z id="t1595783664" t="Jimmy Miller Yep. That is why I came up with gather. I found myself doing the same thing and realized most of the time I wanted a simple filter."><y>#</y><d>2020-07-26</d><h>17:14</h><r>Jimmy Miller</r>Yep. That is why I came up with gather. I found myself doing the same thing and realized most of the time I wanted a simple filter.</z><z id="t1595783759" t="ikrimael (btw, i&apos;ve added all this info to the cookbook so it&apos;ll be in a PR in a week or so)"><y>#</y><d>2020-07-26</d><h>17:15</h><r>ikrimael</r>(btw, i&apos;ve added all this info to the cookbook so it&apos;ll be in a PR in a week or so)</z><z id="t1595779699" t="JAtkins Oh --- and that&apos;s how I got a powerset"><y>#</y><d>2020-07-26</d><h>16:08</h><w>JAtkins</w>Oh --- and that&apos;s how I got a powerset</z><z id="t1595779722" t="JAtkins well, got 2 things to add now"><y>#</y><d>2020-07-26</d><h>16:08</h><w>JAtkins</w>well, got 2 things to add now</z><z id="t1595779785" t="ikrimael some thoughts from weekend code sesh where i ended up rewriting a lot of meander matching: handwavy/food for thought: - cata is really powerful especially on the right hand side. - i can almost write shape morphing functions fluently which is a joy (i.e. don&apos;t need to lookup syntax and I can write it in one go) - but debugging is such a pita when i get something wrong that i found myself psychologically building stuff out much slower and more methodically. just odd irrational human behavior so only verbalizing it as food for thought - not really sure what&apos;s actionable here bc highlighting cata more upfront would probably showcase value earlier on but that&apos;s me looking at it with the &quot;curse of knowledge&quot; bias in that i understand the syntax enough. more concrete thoughts: - i find myself wanting to construct or extract a key out of a map alot with m/rerwrite but doing it inside of meander is frictive enough that i end up cheating and adding (let [helperfn .....]) "><y>#</y><d>2020-07-26</d><h>16:09</h><w>ikrimael</w>some thoughts from weekend code sesh where i ended up rewriting a lot of meander matching:
handwavy/food for thought:
- <code>cata</code> is really powerful especially on the right hand side.
- i can almost write shape morphing functions fluently which is a joy (i.e. don&apos;t need to lookup syntax and I can write it in one go)
- but debugging is such a pita when i get something wrong that i found myself psychologically building stuff out much slower and more methodically. just odd irrational human behavior so only verbalizing it as food for thought
- not really sure what&apos;s actionable here bc highlighting cata more upfront would probably showcase value earlier on but that&apos;s me looking at it with the &quot;curse of knowledge&quot; bias in that i understand the syntax enough.

more concrete thoughts:
- i find myself wanting to construct or extract a key out of a map alot with m/rerwrite but doing it inside of meander is frictive enough that i end up cheating and adding <code>(let [helperfn .....]) </code></z><z id="t1595795020" t="Jimmy Miller &gt; i find myself wanting to construct or extract a key out of a map alot with m/rerwrite but doing it inside of meander is frictive enough that i end up cheating and adding `(let [helperfn .....]) Got an example of this? Really curious to understand more."><y>#</y><d>2020-07-26</d><h>20:23</h><r>Jimmy Miller</r>&gt;  i find myself wanting to construct or extract a key out of a map alot with m/rerwrite but doing it inside of meander is frictive enough that i end up cheating and adding `(let [helperfn .....])
Got an example of this? Really curious to understand more.</z><z id="t1595796535" t="ikrimael sure (heads up, picked this bc its more convoluted than it needs to be but is a real snippet where I just &quot;gave up in frustration&quot; after wrestling with it for a couple hours)"><y>#</y><d>2020-07-26</d><h>20:48</h><r>ikrimael</r>sure (heads up, picked this bc its more convoluted than it needs to be but is a real snippet where I just &quot;gave up in frustration&quot; after wrestling with it for a couple hours)</z><z id="t1595796584" t="ikrimael https://gist.github.com/ikrima/c114ebf0450a56073ad0431716135530"><y>#</y><d>2020-07-26</d><h>20:49</h><r>ikrimael</r><a href="https://gist.github.com/ikrima/c114ebf0450a56073ad0431716135530" target="_blank">https://gist.github.com/ikrima/c114ebf0450a56073ad0431716135530</a></z><z id="t1595796751" t="ikrimael really the important bits:"><y>#</y><d>2020-07-26</d><h>20:52</h><r>ikrimael</r>really the important bits:</z><z id="t1595796899" t="ikrimael i have a feeling most of these issues are a symptom of lack of &quot;gather&quot; for maps (cx - the submap-of thread) And I run into it more bc i&apos;m using rewrite and thus using meander syntax to create vs. normal clojuree"><y>#</y><d>2020-07-26</d><h>20:54</h><r>ikrimael</r>i have a feeling most of these issues are a symptom of lack of &quot;gather&quot; for maps (cx - the <code>submap-of</code>thread)
And I run into it more bc i&apos;m using rewrite and thus using meander syntax to create vs. normal clojuree</z><z id="t1595797726" t="ikrimael ----------------- oops, forgot to add what i wanted the code to do: (xfm ;; Operator Type Decl {:in {:fldname {:name ?name :ctype ?ctype :initval ?dlftval } ...} :out {:fldname {:name ?name :ctype ?ctype :initval ?dlftval } ...}} ;; Map of Init Values {:fldname ?fldinitval } ;; Result =&gt; {:prmin {{:prmName ?name :prmType ?ctype :prmBind (or ?fldinitval ?dlftval :prmBindNone) }} :prmout {{:prmName ?name :prmType ?ctype :prmBind (or ?fldinitval ?dlftval :prmBindNone)}}} ) ----- highlevel: it&apos;s usually around map construction on the right hand side e.g. - merge mapA mapB - update mapA&apos;s values from mapB - variations of &quot;cartesian/relational&quot; operations ie canonical sql join/filter/etc"><y>#</y><d>2020-07-26</d><h>21:08</h><r>ikrimael</r>-----------------
oops, forgot to add what i wanted the code to do:
<pre>(xfm 
;; Operator Type Decl
{:in  {:fldname {:name ?name :ctype ?ctype :initval ?dlftval } ...} 
 :out {:fldname {:name ?name :ctype ?ctype :initval ?dlftval } ...}}
;; Map of Init Values
{:fldname ?fldinitval }
;; Result =&gt;
{:prmin  {{:prmName ?name :prmType ?ctype :prmBind (or ?fldinitval ?dlftval :prmBindNone) }}
 :prmout {{:prmName ?name :prmType ?ctype :prmBind (or ?fldinitval ?dlftval :prmBindNone)}}} 
)</pre>
-----
highlevel: it&apos;s usually around map construction on the right hand side e.g.
- merge mapA mapB
- update mapA&apos;s values from mapB
- variations of &quot;cartesian/relational&quot; operations ie canonical sql join/filter/etc</z><z id="t1595822335" t="Jimmy Miller Here are at least two things you can do to make this a tad bit more percise. First you can just use get directly, rather than binding a function. (defn oprmbinds-mk [a_arg] (m/rewrite a_arg (:makeparmbinds ?valmap [{(m/or :name :fldname) (m/and !prmn1 !prmn2 !prmn3) :ctype {:ctuid !prmctuid}} ...]) (m/map-of !prmn1 {:prmName !prmn2 :prmCtuid !prmctuid :prmBind (m/app get ?valmap !prmn3 :prmbnd-none)}))) But technically, you don’t even need the get, maps are functions themselves. (defn oprmbinds-mk [a_arg] (m/rewrite a_arg (:makeparmbinds ?valmap [{(m/or :name :fldname) (m/and !prmn1 !prmn2 !prmn3) :ctype {:ctuid !prmctuid}} ...]) (m/map-of !prmn1 {:prmName !prmn2 :prmCtuid !prmctuid :prmBind (m/app ?valmap !prmn3 :prmbnd-none)}))) I tried doing this with rewrites, and there is definitely a way, but I still ended up using the same little app trick. As for joins and stuff, those work fairly well with search/rewrites unless you want to do things like a default value if something doesn’t exist (like you are doing here). I played with trying to make it work with an explicit join and sadly came up a bit short. Through the m/app trick above would work, I was sad I couldn’t express it more directly. (into {} (m/rewrites a_arg (:makeparmbinds {?param ?val} (m/scan {(m/or :name :fldname) ?param :ctype {:ctuid ?prmctuid}})) [?param {:prmName ?param :prmCtuid ?prmctuid :prmBind ?val}]))"><y>#</y><d>2020-07-27</d><h>03:58</h><r>Jimmy Miller</r>Here are at least two things you can do to make this a tad bit more percise.

First you can just use get directly, rather than binding a function.
<pre>(defn oprmbinds-mk [a_arg]
  (m/rewrite a_arg
    (:makeparmbinds ?valmap [{(m/or :name :fldname) (m/and !prmn1 !prmn2 !prmn3)
                              :ctype                {:ctuid !prmctuid}} ...])

    (m/map-of !prmn1  {:prmName  !prmn2
                       :prmCtuid !prmctuid
                       :prmBind  (m/app get ?valmap !prmn3 :prmbnd-none)})))</pre>
But technically, you don’t even need the get, maps are functions themselves.

<pre>(defn oprmbinds-mk [a_arg]
  (m/rewrite a_arg
    (:makeparmbinds ?valmap [{(m/or :name :fldname) (m/and !prmn1 !prmn2 !prmn3)
                              :ctype                {:ctuid !prmctuid}} ...])

    (m/map-of !prmn1  {:prmName  !prmn2
                       :prmCtuid !prmctuid
                       :prmBind  (m/app ?valmap !prmn3 :prmbnd-none)})))</pre>
I tried doing this with rewrites, and there is definitely a way, but I still ended up using the same little app trick.


As for joins and stuff, those work fairly well with search/rewrites unless you want to do things like a default value if something doesn’t exist (like you are doing here). I played with trying to make it work with an explicit join and sadly came up a bit short. Through the <code>m/app</code> trick above would work, I was sad I couldn’t express it more directly.

<pre>(into {}
      (m/rewrites a_arg

        (:makeparmbinds {?param ?val} 
                        (m/scan {(m/or :name :fldname) ?param 
                                 :ctype {:ctuid ?prmctuid}}))
        [?param {:prmName ?param
                 :prmCtuid ?prmctuid
                 :prmBind ?val}]))</pre></z><z id="t1595789407" t="ikrimael ------------------ ah, also one more addition: i think it&apos;d be great if there was a m/gather for maps e.g. if m/submap-of can be used with :as to capture the result of the submap filter"><y>#</y><d>2020-07-26</d><h>18:50</h><w>ikrimael</w>------------------
ah, also one more addition: i think it&apos;d be great if there was a <code>m/gather</code> for maps
e.g. if  <code>m/submap-of</code> can be used with <code>:as</code> to capture the result of the submap filter</z><z id="t1595794392" t="noprompt At the time map-of /`submap-of` was added, the inverse of this was suggested e.g. a way to capture the part of that map that didn’t match. I think both are useful and supportable. From my point of view this is yet more support for the idea that “folds”, as I have discussed them, are primitive and relevant i.e. these two problems are symptoms of the same underlying condition which is that we do not have a way to bind with reduction. Binding, in theory sense, is a sort of reduction operation that can fail. Logic variables bind values when they are unbound and fail when an attempt is made to bind them to a logically inequivalent value. Memory and mutable variables always bind. It makes sense [to me] that reduction be exposed to allow for binding to be rich and powerful."><y>#</y><d>2020-07-26</d><h>20:13</h><r>noprompt</r>At the time <code>map-of</code>/`submap-of` was added, the inverse of this was suggested e.g. a way to capture the part of that map that didn’t match. I think both are useful and supportable.

From my point of view this is yet more support for the idea that “folds”, as I have discussed them, are primitive and relevant i.e. these two problems are symptoms of the same underlying condition which is that we do not have a way to bind with reduction.

Binding, in theory sense, is a sort of reduction operation that can fail. Logic variables bind values when they are unbound and fail when an attempt is made to bind them to a logically inequivalent value. Memory and mutable variables always bind. It makes sense [to me] that reduction be exposed to allow for binding to be rich and powerful.</z><z id="t1595843899" t="dominicm (into {} (m/search {:a nil :b 10 :c 20 :d nil} {?k (m/some ?v)} {?k ?v})) ;; {:b 10, :c 20} I feel like there&apos;s going to be a neater solution to this?"><y>#</y><d>2020-07-27</d><h>09:58</h><w>dominicm</w><pre>(into {} (m/search {:a nil :b 10 :c 20 :d nil}
                   {?k (m/some ?v)} {?k ?v})) ;; {:b 10, :c 20}</pre>
I feel like there&apos;s going to be a neater solution to this?</z><z id="t1595860726" t="Jimmy Miller (m/rewrite {:a nil :b 10 :c 20 :d nil} (m/gather [!k (m/some !v)]) {&amp; [[!k !v] ...]}) There&apos;s another way of doing it."><y>#</y><d>2020-07-27</d><h>14:38</h><r>Jimmy Miller</r><pre>(m/rewrite {:a nil :b 10 :c 20 :d nil}
  (m/gather [!k (m/some !v)])
  {&amp; [[!k !v] ...]})</pre>
There&apos;s another way of doing it.</z><z id="t1595860757" t="Jimmy Miller Oh wait, forgot about map-of (m/rewrite {:a nil :b 10 :c 20 :d nil} (m/gather [!k (m/some !v)]) (m/map-of !k !v))"><y>#</y><d>2020-07-27</d><h>14:39</h><r>Jimmy Miller</r>Oh wait, forgot about map-of

<pre>(m/rewrite {:a nil :b 10 :c 20 :d nil}
  (m/gather [!k (m/some !v)])
  (m/map-of !k !v))</pre></z><z id="t1595868458" t="dominicm ah, so gather is the proper way to collect the keys such that I can then map-of with them. I tried map-of a lot and got nowhere."><y>#</y><d>2020-07-27</d><h>16:47</h><r>dominicm</r>ah, so gather is the proper way to collect the keys such that I can then map-of with them.  I tried map-of a lot and got nowhere.</z><z id="t1595868474" t="dominicm I&apos;m guessing gather actually iterates, whereas search is going pair-by-pair?"><y>#</y><d>2020-07-27</d><h>16:47</h><r>dominicm</r>I&apos;m guessing gather actually iterates, whereas search is going pair-by-pair?</z><z id="t1595875318" t="Jimmy Miller Yeah in this case gather is equivalent to (m/rewrite {:a nil :b 10 :c 20 :d nil} (m/seqable (m/or [!k (m/some !v)] _) ...) (m/map-of !k !v))"><y>#</y><d>2020-07-27</d><h>18:41</h><r>Jimmy Miller</r>Yeah in this case gather is equivalent to

<pre>(m/rewrite {:a nil :b 10 :c 20 :d nil}
  (m/seqable (m/or [!k (m/some !v)] _) ...)
  (m/map-of !k !v))</pre></z><z id="t1595940087" t="magnusdk Hi, the following expression causes a ClassCastException (`clojure.lang.PersistentList cannot be cast to clojure.lang.Named`): (m/match ((partial inc) 0)  ?a  ?a) Bug/known?"><y>#</y><d>2020-07-28</d><h>12:41</h><w>magnusdk</w>Hi, the following expression causes a ClassCastException (`clojure.lang.PersistentList cannot be cast to clojure.lang.Named`):
<pre>(m/match ((partial inc) 0)
   ?a
   ?a)</pre>
Bug/known?</z><z id="t1595940254" t="magnusdk The first arg for match is specced as any? so I’d assume this would work :thinking_face: An obvious workaround is to write: (let [res ((partial inc) 0)] (m/match res ?a ?a))"><y>#</y><d>2020-07-28</d><h>12:44</h><r>magnusdk</r>The first arg for <code>match</code> is specced as <code>any?</code> so I’d assume this would work <b>:thinking_face:</b>

An obvious workaround is to write:
<pre>(let [res ((partial inc) 0)]
  (m/match res
    ?a
    ?a))</pre></z><z id="t1595940665" t="magnusdk I stumbled across it after writing something akin to this: (def *some-slow-to-init-fn (delay inc)) (-&gt; (@*some-slow-to-init-fn 0) (m/match ?a ?a))"><y>#</y><d>2020-07-28</d><h>12:51</h><r>magnusdk</r>I stumbled across it after writing something akin to this:
<pre>(def *some-slow-to-init-fn (delay inc))
(-&gt; (@*some-slow-to-init-fn 0)
    (m/match ?a ?a))</pre></z><z id="t1595942290" t="Jimmy Miller I didn&apos;t know about this issue. But I have a good guess as to what is causing it. Will try to get a fix out asap."><y>#</y><d>2020-07-28</d><h>13:18</h><r>Jimmy Miller</r>I didn&apos;t know about this issue. But I have a good guess as to what is causing it. Will try to get a fix out asap.</z><z id="t1595942628" t="magnusdk Alright, cool 👍 It’s not stopping us in any way, so no need to rush for our sake 🙂 Thanks, and have a nice day!"><y>#</y><d>2020-07-28</d><h>13:23</h><r>magnusdk</r>Alright, cool <b>👍</b> It’s not stopping us in any way, so no need to rush for our sake <b>🙂</b> Thanks, and have a nice day!</z><z id="t1595953329" t="noprompt Fixed, will deploy a new release shortly."><y>#</y><d>2020-07-28</d><h>16:22</h><r>noprompt</r>Fixed, will deploy a new release shortly.</z><z id="t1595960827" t="Jimmy Miller Thanks [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] 🙂"><y>#</y><d>2020-07-28</d><h>18:27</h><r>Jimmy Miller</r>Thanks <a>@U06MDAPTP</a> <b>🙂</b></z><z id="t1595956367" t="noprompt [meander/epsilon &quot;0.0.480&quot;] • Fixes that bug"><y>#</y><d>2020-07-28</d><h>17:12</h><w>noprompt</w><pre>[meander/epsilon &quot;0.0.480&quot;]</pre>
• Fixes that bug</z><z id="t1596148699" t="ikrimael [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] this isn&apos;t necessarily in the scope of meander but saw some of your comments on specter but curious your thoughts on how you&apos;d express something like creating lenses in clojure"><y>#</y><d>2020-07-30</d><h>22:38</h><w>ikrimael</w><a>@noprompt</a> this isn&apos;t necessarily in the scope of meander but saw some of your comments on specter
but curious your thoughts on how you&apos;d express something like creating lenses in clojure</z><z id="t1596155823" t="noprompt It depends on what you mean by creating. I’m not sure what comments you saw in particular but I’m sure, whatever they are, my sentiment is probably the same regarding them — negative. Even in a statically typed setting where you can avoid the sort of bugs that come up in Clojure, they’re unappealing to me. Personally, I think the cognitive expense is too high. You have to learn how they work and then learn how they are used in practice."><y>#</y><d>2020-07-31</d><h>00:37</h><r>noprompt</r>It depends on what you mean by creating. I’m not sure what comments you saw in particular but I’m sure, whatever they are, my sentiment is probably the same regarding them — negative. Even in a statically typed setting where you can avoid the sort of bugs that come up in Clojure, they’re unappealing to me. Personally, I think the cognitive expense is too high. You have to learn how they work and then learn how they are used in practice.</z><z id="t1596158317" t="ikrimael tend to agree hence conflicted/searching for a better answer. the only other alternative i&apos;ve found (and my current approach) is a boilerplate heavy conversion layer"><y>#</y><d>2020-07-31</d><h>01:18</h><r>ikrimael</r>tend to agree hence conflicted/searching for a better answer. the only other alternative i&apos;ve found (and my current approach) is a boilerplate heavy conversion layer</z><z id="t1596158483" t="ikrimael for clarity: core problem is going from &quot;unknown shape&quot; =&gt; &quot;known shape&quot; =&gt; known shape modifications =&gt; &quot;unknown shape&quot;"><y>#</y><d>2020-07-31</d><h>01:21</h><r>ikrimael</r>for clarity: core problem is going from &quot;unknown shape&quot; =&gt; &quot;known shape&quot; =&gt; known shape modifications =&gt; &quot;unknown shape&quot;</z><z id="t1596158657" t="ikrimael &quot;known shape&quot; =&gt; &quot;known shape modifications : where meander shines projecting the data modifications back out to the unknown shape =&gt; challenge"><y>#</y><d>2020-07-31</d><h>01:24</h><r>ikrimael</r><code>&quot;known shape&quot; =&gt; &quot;known shape modifications</code>: where meander shines
<code>projecting the data modifications back out to the unknown shape</code> =&gt; challenge</z><z id="t1596158963" t="ikrimael ~one thing i&apos;m gonna try is just to see if in practice, i can switch the left/write clauses in meander and see if that automagically gives me the ~ lol, well that failed quickly. c&apos;est la vie, battle to fight for another day"><y>#</y><d>2020-07-31</d><h>01:29</h><r>ikrimael</r>~one thing i&apos;m gonna try is just to see if in practice, i can switch the left/write clauses in meander and see if that automagically gives me the ~
lol, well that failed quickly. c&apos;est la vie, battle to fight for another day</z><z id="t1596148782" t="ikrimael context: my shallow mental model of specter == lenses/cursors"><y>#</y><d>2020-07-30</d><h>22:39</h><w>ikrimael</w>context: my shallow mental model of specter == lenses/cursors</z><z id="t1596148859" t="ikrimael problem space: UI databinding - some bound data =&gt; change shape to match expected shape =&gt; apply widget_render() function"><y>#</y><d>2020-07-30</d><h>22:40</h><w>ikrimael</w>problem space: UI databinding - some bound data =&gt; change shape to match expected shape  =&gt; apply widget_render() function</z><z id="t1596148973" t="ikrimael the challenge lying in making it bidirectional, specifically in the inverse, and in turn making it composable"><y>#</y><d>2020-07-30</d><h>22:42</h><w>ikrimael</w>the challenge lying in making it bidirectional, specifically in the inverse, and in turn making it composable</z><z id="t1596149203" t="ikrimael ex: a listview widget Change src shape: [{:name &quot;foo&quot; :addr &quot;123 bar&quot;} {:name &quot;baz&quot; :addr &quot;456 baz&quot;}] =&gt; [{:header &quot;foo&quot; :title &quot;123 bar&quot;} {:header &quot;baz&quot; :title &quot;456baz&quot;}]"><y>#</y><d>2020-07-30</d><h>22:46</h><w>ikrimael</w>ex: a listview widget
Change src shape:
<code>[{:name &quot;foo&quot; :addr &quot;123 bar&quot;} {:name &quot;baz&quot; :addr &quot;456 baz&quot;}] =&gt; [{:header &quot;foo&quot; :title &quot;123 bar&quot;} {:header &quot;baz&quot; :title &quot;456baz&quot;}]</code></z><z id="t1596149324" t="ikrimael but then being able to reflect this change: [{:header &quot;new foo&quot; :title &quot;123 bar&quot;} {:header &quot;baz&quot; :title &quot;new address&quot;}] =&gt; [{:name &quot;new foo&quot; :addr &quot;123 bar&quot;} {:name &quot;baz&quot; :addr &quot;new address&quot;}]"><y>#</y><d>2020-07-30</d><h>22:48</h><w>ikrimael</w>but then being able to reflect this change:
<code>[{:header &quot;new foo&quot; :title &quot;123 bar&quot;} {:header &quot;baz&quot; :title &quot;new address&quot;}] =&gt; [{:name &quot;new foo&quot; :addr &quot;123 bar&quot;} {:name &quot;baz&quot; :addr &quot;new address&quot;}]</code></z><z id="t1596149844" t="ikrimael note: i think this feels like a different enough problem domain that&apos;s orthogonal to meander. also concede to the fp folks that lenses do address this but i still find them &quot;high cognitive load&quot; (debugging, groking code weeks later, etc)"><y>#</y><d>2020-07-30</d><h>22:57</h><w>ikrimael</w>note: i think this feels like a different enough problem domain that&apos;s orthogonal to meander.
also concede to the fp folks that lenses do address this but i still find them &quot;high cognitive load&quot; (debugging, groking code weeks later, etc)</z><z id="t1596150057" t="ikrimael mostly curious if others have traversed this problem space before experimenting myself (current thought is using macros and m/rewrite to create that inverse mapping automatically from meander)"><y>#</y><d>2020-07-30</d><h>23:00</h><w>ikrimael</w>mostly curious if others have traversed this problem space before experimenting myself (current thought is using macros and m/rewrite to create that inverse mapping automatically from meander)</z><z id="t1596169827" t="chucklehead hello all, I suspect I shouldn&apos;t be using scan here, but not sure what the right operator would be. The goal is to pull out multiple nested values/attrs from the sequence in the :content of the trackInformation element. When I uncomment the latitude element below, the search stops matching, but works if I e.g. comment out speed/altitude and only scan for latitude. (-&gt; ( &quot;./corpus/example.xml&quot;) (clojure.data.xml/parse :skip-whitespace true) (m/search (m/$ {:tag ::fdm/fltdMessage :attrs {:msgType &quot;trackInformation&quot; :flightRef ?flight-ref :acid ?aircraft-id :airline ?airline :depArpt ?departure-airport :arrArpt ?arrival-airport :sourceTimeStamp ?source-ts} :content ({:tag ::fdm/trackInformation :content (m/scan (m/$ {:tag ::nxcm/speed :content (?speed)}) (m/$ {:tag ::nxce/simpleAltitude :content (?altitude)}) #_(m/$ {:tag ::nxce/latitudeDMS :attrs ?latitude-dms}))})}) {:message/source-ts (read-instant-timestamp ?source-ts) :flight/ref (Integer/parseInt ?flight-ref) :flight/aircraft-id ?aircraft-id :track/speed (Integer/parseInt ?speed) :track/altitude ?altitude})) A trimmed down sample of the actual data is https://gist.github.com/casselc/09b1ed46a86b500cabd2e14ada1a3719 ."><y>#</y><d>2020-07-31</d><h>04:30</h><w>chucklehead</w>hello all, I suspect I shouldn&apos;t be using <code>scan</code> here, but not sure what the right operator would be. The goal is to pull out multiple nested values/attrs from the sequence in the <code>:content</code> of the <code>trackInformation</code> element. When I uncomment the latitude element below, the search stops matching, but works if I e.g. comment out speed/altitude and only scan for latitude.
<pre>(-&gt; ( &quot;./corpus/example.xml&quot;)
    (clojure.data.xml/parse :skip-whitespace true)
    (m/search
     (m/$ {:tag ::fdm/fltdMessage
           :attrs {:msgType &quot;trackInformation&quot;
                   :flightRef ?flight-ref
                   :acid ?aircraft-id
                   :airline ?airline
                   :depArpt ?departure-airport
                   :arrArpt ?arrival-airport
                   :sourceTimeStamp ?source-ts}
           :content ({:tag ::fdm/trackInformation
                      :content (m/scan
                                (m/$ {:tag ::nxcm/speed
                                      :content (?speed)})
                                (m/$ {:tag ::nxce/simpleAltitude
                                      :content (?altitude)})
                                #_(m/$ {:tag ::nxce/latitudeDMS
                                        :attrs ?latitude-dms}))})})
     {:message/source-ts (read-instant-timestamp ?source-ts)
      :flight/ref (Integer/parseInt ?flight-ref)
      :flight/aircraft-id ?aircraft-id
      :track/speed (Integer/parseInt ?speed)
      :track/altitude ?altitude}))</pre>
A trimmed down sample of the actual data is <a href="https://gist.github.com/casselc/09b1ed46a86b500cabd2e14ada1a3719" target="_blank">https://gist.github.com/casselc/09b1ed46a86b500cabd2e14ada1a3719</a>.</z><z id="t1596209329" t="Jimmy Miller So I played with this a bit but couldn&apos;t get it directly working. The reason scan doesn&apos;t work here is that it assumes all its elements are sequential. (m/search [1 2 3 4 5 6] (m/scan 3 4 ?x) ?x) ;; =&gt; 5 (m/search [1 2 3 4 5 6] (m/separated 3 4 ?x) ?x) ;; =&gt; 5 6 But separated doesn&apos;t work either. Maybe something weird is happening with the nested $? I will try a bit later."><y>#</y><d>2020-07-31</d><h>15:28</h><r>Jimmy Miller</r>So I played with this a bit but couldn&apos;t get it directly working.

The reason scan doesn&apos;t work here is that it assumes all its elements are sequential.

<pre>(m/search [1 2 3 4 5 6]
  (m/scan 3 4 ?x)
  ?x)

;; =&gt;

5

(m/search [1 2 3 4 5 6]
  (m/separated 3 4 ?x)
  ?x)

;; =&gt; 

5 6</pre>
But separated doesn&apos;t work either. Maybe something weird is happening with the nested $? I will try a bit later.</z><z id="t1596283330" t="chucklehead thanks, I think I understand scan a little better now. Played around a bit more and ended up with: "><y>#</y><d>2020-08-01</d><h>12:02</h><r>chucklehead</r>thanks, I think I understand <code>scan</code> a little better now. Played around a bit more and ended up with:
</z><z id="t1596283330" t="chucklehead (defn xml-&gt;tracks [xml] (m/search xml {:tag ::tx/tfmDataService :content ({:tag ::tx/fltdOutput :content (m/scan {:tag ::fdm/fltdMessage :attrs {:msgType &quot;trackInformation&quot; :flightRef ?flight-ref :acid ?aircraft-id :airline ?airline :depArpt ?departure-airport :arrArpt ?arrival-airport :sourceTimeStamp ?message-ts} :content ({:tag ::fdm/trackInformation :content (m/scan {:tag ::nxcm/qualifiedAircraftId} {:tag ::nxcm/speed :content (?speed)} {:tag ::nxcm/reportedAltitude :content ({:tag ::nxce/assignedAltitude :content ((m/or {:tag ::nxce/simpleAltitude :content (?altitude)} {:tag ::nxce/blockedAltitude :attrs {:min (?altitude)}} {:tag ::nxce/visualFlightRules :attrs {:altitude ?altitude}} {:tag ::nxce/altitudeFixAltitude :attrs {:preFixAltitude ?altitude}}))})} {:tag ::nxcm/position :content (m/scan {:tag ::nxce/latitude :content ({:tag ::nxce/latitudeDMS :attrs ?latitude-dms})} {:tag ::nxce/longitude :content ({:tag ::nxce/longitudeDMS :attrs ?longitude-dms})})} {:tag ::nxcm/timeAtPosition :content (?track-ts)} . (m/or {:tag ::nxcm/ncsmTrackData :content (m/seqable . (m/or {:tag ::nxcm/nextEvent :attrs {:latitudeDecimal ?next-lat :longitudeDecimal ?next-long}} (m/let [?next-lat nil ?next-long nil])) ..1)} {:tag ::nxcm/ncsmRouteData :content (m/scan {:tag ::nxcm/nextPosition :attrs {:latitudeDecimal ?next-lat :longitudeDecimal ?next-long}})}))})})})} (merge {:flight/ref (Long/parseLong ?flight-ref) :flight/aircraft-id ?aircraft-id :flight/airline ?airline :flight/arrival-airport ?arrival-airport :flight/departure-airport ?departure-airport :track/speed (Integer/parseInt ?speed)} (when (and ?next-lat ?next-long) {:track/next-latitude (Double/parseDouble ?next-lat) :track/next-longitude (Double/parseDouble ?next-long)}))))"><y>#</y><d>2020-08-01</d><h>12:02</h><r>chucklehead</r><pre>(defn xml-&gt;tracks
  [xml]
  (m/search
   xml
   {:tag ::tx/tfmDataService
    :content ({:tag ::tx/fltdOutput
               :content (m/scan
                         {:tag ::fdm/fltdMessage
                          :attrs {:msgType &quot;trackInformation&quot;
                                  :flightRef ?flight-ref
                                  :acid ?aircraft-id
                                  :airline ?airline
                                  :depArpt ?departure-airport
                                  :arrArpt ?arrival-airport
                                  :sourceTimeStamp ?message-ts}
                          :content ({:tag ::fdm/trackInformation
                                     :content (m/scan
                                               {:tag ::nxcm/qualifiedAircraftId}
                                               {:tag ::nxcm/speed
                                                :content (?speed)}
                                               {:tag ::nxcm/reportedAltitude
                                                :content ({:tag ::nxce/assignedAltitude
                                                           :content ((m/or
                                                                      {:tag ::nxce/simpleAltitude
                                                                       :content (?altitude)}
                                                                      {:tag ::nxce/blockedAltitude
                                                                       :attrs {:min (?altitude)}}
                                                                      {:tag ::nxce/visualFlightRules
                                                                       :attrs {:altitude ?altitude}}
                                                                      {:tag ::nxce/altitudeFixAltitude
                                                                       :attrs {:preFixAltitude ?altitude}}))})}
                                               {:tag ::nxcm/position
                                                :content (m/scan
                                                          {:tag ::nxce/latitude
                                                           :content ({:tag ::nxce/latitudeDMS
                                                                      :attrs ?latitude-dms})}
                                                          {:tag ::nxce/longitude
                                                           :content ({:tag ::nxce/longitudeDMS
                                                                      :attrs ?longitude-dms})})}
                                               {:tag ::nxcm/timeAtPosition
                                                :content (?track-ts)}
                                               .
                                               (m/or
                                                {:tag ::nxcm/ncsmTrackData
                                                 :content (m/seqable
                                                           .
                                                           (m/or
                                                            {:tag ::nxcm/nextEvent
                                                             :attrs {:latitudeDecimal ?next-lat
                                                                     :longitudeDecimal ?next-long}}
                                                            (m/let [?next-lat nil ?next-long nil]))
                                                           ..1)}
                                                {:tag ::nxcm/ncsmRouteData
                                                 :content (m/scan
                                                           {:tag ::nxcm/nextPosition
                                                            :attrs {:latitudeDecimal ?next-lat
                                                                    :longitudeDecimal ?next-long}})}))})})})}
   (merge {:flight/ref (Long/parseLong ?flight-ref)
           :flight/aircraft-id ?aircraft-id
           :flight/airline ?airline
           :flight/arrival-airport ?arrival-airport
           :flight/departure-airport ?departure-airport
           :track/speed (Integer/parseInt ?speed)}
          (when (and ?next-lat ?next-long)
            {:track/next-latitude (Double/parseDouble ?next-lat)
             :track/next-longitude (Double/parseDouble ?next-long)}))))</pre></z><z id="t1596283330" t="chucklehead Not especially happy with the last bit, but haven&apos;t been able to figure out a better way that doesn&apos;t generate &apos;extra&apos; entries. What I&apos;m trying to express is that the element after timeAtPosition will be either a ncsmTrackData or ncsmRouteData tag, but if it&apos;s a ncsmTrackData it may or may not contain a nextEvent with a lat/long."><y>#</y><d>2020-08-01</d><h>12:02</h><r>chucklehead</r>Not especially happy with the last bit, but haven&apos;t been able to figure out a better way that doesn&apos;t generate &apos;extra&apos; entries. What I&apos;m trying to express is that the element after <code>timeAtPosition</code> will be either a <code>ncsmTrackData</code> or <code>ncsmRouteData</code>  tag, but if it&apos;s a <code>ncsmTrackData</code> it may or may not contain a <code>nextEvent</code> with a lat/long.</z><z id="t1596566111" t="noprompt [:attrs {:href &quot;/_/_/users/U015879P2F8&quot;}] I’m gonna take a swing at this. 🙂"><y>#</y><d>2020-08-04</d><h>18:35</h><r>noprompt</r><a>@U015879P2F8</a> I’m gonna take a swing at this. <b>🙂</b></z><z id="t1596566363" t="chucklehead if you haven&apos;t already I&apos;d really appreciate a review of where I&apos;ve gotten since then to see if it makes sense or there&apos;s a better/more efficient/performant/etc way to go about it. I just updated the https://gist.github.com/casselc/09b1ed46a86b500cabd2e14ada1a3719 with a copy/paste from my ns where I&apos;ve been playing around with the data"><y>#</y><d>2020-08-04</d><h>18:39</h><r>chucklehead</r>if you haven&apos;t already I&apos;d really appreciate a review of where I&apos;ve gotten since then to see if it makes sense or there&apos;s a better/more efficient/performant/etc way to go about it. I just updated the <a href="https://gist.github.com/casselc/09b1ed46a86b500cabd2e14ada1a3719" target="_blank">https://gist.github.com/casselc/09b1ed46a86b500cabd2e14ada1a3719</a> with a copy/paste from my ns where I&apos;ve been playing around with the data</z><z id="t1596566441" t="chucklehead thanks for taking a look"><y>#</y><d>2020-08-04</d><h>18:40</h><r>chucklehead</r>thanks for taking a look</z><z id="t1596566685" t="noprompt Do you have a deps.edn to go along with this?"><y>#</y><d>2020-08-04</d><h>18:44</h><r>noprompt</r>Do you have a deps.edn to go along with this?</z><z id="t1596566730" t="noprompt I’m pulling together the deps myself."><y>#</y><d>2020-08-04</d><h>18:45</h><r>noprompt</r>I’m pulling together the deps myself.</z><z id="t1596566841" t="chucklehead {:paths [&quot;src&quot; &quot;resources&quot;] :deps {org.clojure/clojure {:mvn/version &quot;1.10.1&quot;} org.clojure/data.xml {:mvn/version &quot;0.2.0-alpha6&quot;} org.clojure/core.async {:mvn/version &quot;1.3.610&quot;} environ {:mvn/version &quot;1.2.0&quot;} com.solacesystems/sol-jcsmp {:mvn/version &quot;10.9.0&quot;} meander/epsilon {:mvn/version &quot;0.0.480&quot;} datascript {:mvn/version &quot;1.0.0&quot;} clojure.java-time {:mvn/version &quot;0.3.2&quot;} } }"><y>#</y><d>2020-08-04</d><h>18:47</h><r>chucklehead</r><pre>{:paths [&quot;src&quot; &quot;resources&quot;]
 :deps {org.clojure/clojure {:mvn/version &quot;1.10.1&quot;}
        org.clojure/data.xml {:mvn/version &quot;0.2.0-alpha6&quot;}
        org.clojure/core.async {:mvn/version &quot;1.3.610&quot;}
        environ {:mvn/version &quot;1.2.0&quot;}
        com.solacesystems/sol-jcsmp {:mvn/version &quot;10.9.0&quot;}
        meander/epsilon {:mvn/version &quot;0.0.480&quot;}
        datascript {:mvn/version &quot;1.0.0&quot;}
        clojure.java-time {:mvn/version &quot;0.3.2&quot;}
        }
 }</pre></z><z id="t1596568425" t="noprompt This is actually pretty incredible, I must admit."><y>#</y><d>2020-08-04</d><h>19:13</h><r>noprompt</r>This is actually pretty incredible, I must admit.</z><z id="t1596568447" t="noprompt I think this is the first time I’ve seen someone use defsyntax this way."><y>#</y><d>2020-08-04</d><h>19:14</h><r>noprompt</r>I think this is the first time I’ve seen someone use <code>defsyntax</code> this way.</z><z id="t1596568489" t="chucklehead that can&apos;t be good"><y>#</y><d>2020-08-04</d><h>19:14</h><r>chucklehead</r>that can&apos;t be good</z><z id="t1596568508" t="noprompt No it’s great actually."><y>#</y><d>2020-08-04</d><h>19:15</h><r>noprompt</r>No it’s great actually.</z><z id="t1596568524" t="noprompt I’m just now realizing that it I need to expose something for expanding a pattern conveniently."><y>#</y><d>2020-08-04</d><h>19:15</h><r>noprompt</r>I’m just now realizing that it I need to expose something for expanding a pattern conveniently.</z><z id="t1596568731" t="chucklehead I initially built it up as one giant find just trying to basically transliterate the patterns from the xml until it all sort ofworked, and then wanted some way to break up the individual pieces"><y>#</y><d>2020-08-04</d><h>19:18</h><r>chucklehead</r>I initially built it up as one giant find just trying to basically transliterate the patterns from the xml until it all sort ofworked, and then wanted some way to break up the individual pieces</z><z id="t1596568750" t="noprompt That makes perfect sense."><y>#</y><d>2020-08-04</d><h>19:19</h><r>noprompt</r>That makes perfect sense.</z><z id="t1596568755" t="chucklehead eventually I&apos;ll want to do some other message types and certain elements are reused"><y>#</y><d>2020-08-04</d><h>19:19</h><r>chucklehead</r>eventually I&apos;ll want to do some other message types and certain elements are reused</z><z id="t1596568778" t="noprompt Yah, and that’s a totally valid use case. I’m glad you’re messing with this."><y>#</y><d>2020-08-04</d><h>19:19</h><r>noprompt</r>Yah, and that’s a totally valid use case. I’m glad you’re messing with this.</z><z id="t1596568781" t="chucklehead I actually have good xsd for all of this so there&apos;s probably some way to meander that into exactly what I want"><y>#</y><d>2020-08-04</d><h>19:19</h><r>chucklehead</r>I actually have good xsd for all of this so there&apos;s probably some way to meander that into exactly what I want</z><z id="t1596568837" t="chucklehead I&apos;m fairly new to clojure altogether and have just been wrangling around with this data as a way to experiment/learn with something concrete"><y>#</y><d>2020-08-04</d><h>19:20</h><r>chucklehead</r>I&apos;m fairly new to clojure altogether and have just been wrangling around with this data as a way to experiment/learn with something concrete</z><z id="t1596568915" t="noprompt Nice. Actually, I think you’d be the second person to join the channel in as many weeks who is both new to Clojure and to Meander. I couldn’t ask for better perspectives. 🙂"><y>#</y><d>2020-08-04</d><h>19:21</h><r>noprompt</r>Nice. Actually, I think you’d be the second person to join the channel in as many weeks who is both new to Clojure and to Meander. I couldn’t ask for better perspectives. <b>🙂</b></z><z id="t1596568921" t="chucklehead so far meander&apos;s describe the shape you have and the shape you want approach is my favorite clojure thing I&apos;ve found"><y>#</y><d>2020-08-04</d><h>19:22</h><r>chucklehead</r>so far meander&apos;s describe the shape you have and the shape you want approach is my favorite clojure thing I&apos;ve found</z><z id="t1596568931" t="noprompt I’m really happy to hear that."><y>#</y><d>2020-08-04</d><h>19:22</h><r>noprompt</r>I’m really happy to hear that.</z><z id="t1596569001" t="noprompt This example is pretty interesting. I’m going to toy around with it a little bit. I think it’s exposed some opportunities for improvement too."><y>#</y><d>2020-08-04</d><h>19:23</h><r>noprompt</r>This example is pretty interesting. I’m going to toy around with it a little bit. I think it’s exposed some opportunities for improvement too.</z><z id="t1596569193" t="chucklehead what I&apos;d like to make is something where I could essentially write the matching/extracting patterns in a less verbose/hiccup-style syntax and expand that into the actual xml pattern prior to matching"><y>#</y><d>2020-08-04</d><h>19:26</h><r>chucklehead</r>what I&apos;d like to make is something where I could essentially write the matching/extracting patterns in a less verbose/hiccup-style syntax and expand that into the actual xml pattern prior to matching</z><z id="t1596569228" t="chucklehead but wasn&apos;t quite sure how to get there from here and started working on something else"><y>#</y><d>2020-08-04</d><h>19:27</h><r>chucklehead</r>but wasn&apos;t quite sure how to get there from here and started working on something else</z><z id="t1596570132" t="noprompt Do you have a sketch of what’s in your mind?"><y>#</y><d>2020-08-04</d><h>19:42</h><r>noprompt</r>Do you have a sketch of what’s in your mind?</z><z id="t1596572864" t="chucklehead I guess I&apos;d like to be able to write a pattern something like this to match that data: [::fdm/fltdMessage {:msgType &quot;trackInformation&quot; :flightRef (m/app Long/parseLong ?flight-ref)} [::fdm/trackInformation ; implicit separated(?) of content :start-of-seq ;made-up notation to anchor start of seq [::nxcm/qualifiedAircraftId] [::nxcm/speed (m/app Integer/parseInt ~speed)] [::nxcm/position [::nxcm/latitude [::nxcm/latitudeDMS {m/app dms-&gt;decimal ?latitude}]]] (m/or [::nxcm/ncsmTrackData ?some-data] [::nxcm/ncsmRouteData ?some-data]) :? ; made-up notation for 0 or 1 of the preceding element. Implicit nil for bound vars? :end-of-seq]] "><y>#</y><d>2020-08-04</d><h>20:27</h><r>chucklehead</r>I guess I&apos;d like to be able to write a pattern something like this to match that data:
<pre>[::fdm/fltdMessage {:msgType &quot;trackInformation&quot;
                    :flightRef (m/app Long/parseLong ?flight-ref)}
 [::fdm/trackInformation ; implicit separated(?) of content
  :start-of-seq ;made-up notation to anchor start of seq
  [::nxcm/qualifiedAircraftId]
  [::nxcm/speed (m/app Integer/parseInt ~speed)]
  [::nxcm/position
   [::nxcm/latitude
    [::nxcm/latitudeDMS {m/app dms-&gt;decimal ?latitude}]]]
  (m/or
   [::nxcm/ncsmTrackData ?some-data]
   [::nxcm/ncsmRouteData ?some-data])
  :? ; made-up notation for 0 or 1 of the preceding element. Implicit nil for bound vars?
  :end-of-seq]]</pre>
</z><z id="t1596572974" t="chucklehead that conflates a few things I&apos;ve been bumping into, but hopefully gets the idea across"><y>#</y><d>2020-08-04</d><h>20:29</h><r>chucklehead</r>that conflates a few things I&apos;ve been bumping into, but hopefully gets the idea across</z><z id="t1596573515" t="chucklehead I struggled (I still struggle, but I used to, too) quite a bit with really grokking the semantics of the sequence operators/notation and optionality. With next lat/long for instance, trying to express that if it was present it would be in one of two mutually exclusive elements, but might not be there at all."><y>#</y><d>2020-08-04</d><h>20:38</h><r>chucklehead</r>I struggled (I still struggle, but I used to, too) quite a bit with really grokking the semantics of the sequence operators/notation and optionality. With next lat/long for instance, trying to express that if it was present it would be in one of two mutually exclusive elements, but might not be there at all.</z><z id="t1596573603" t="chucklehead Eventually I scrolled far enough in the cookbook to see the optional value stuff and felt less alone at least"><y>#</y><d>2020-08-04</d><h>20:40</h><r>chucklehead</r>Eventually I scrolled far enough in the cookbook to see the optional value stuff and felt less alone at least</z><z id="t1596580395" t="noprompt (m/rewrite xml-edn {:tag ?tag, :attrs ?attrs, :content (m/seqable (m/cata !xs) ...)} [?tag ?attrs . !xs ...] ?x ?x) "><y>#</y><d>2020-08-04</d><h>22:33</h><r>noprompt</r><pre>(m/rewrite xml-edn
  {:tag ?tag, :attrs ?attrs, :content (m/seqable (m/cata !xs) ...)}
  [?tag ?attrs . !xs ...]

  ?x
  ?x)</pre>
</z><z id="t1596828214" t="chucklehead Thanks, sorry to take so long to get back, hadn&apos;t had a chance to work on this project... Hopefully I&apos;m not being obtuse about this. I was hoping to use the hiccup syntax as a sort of DSL to write the matching/capturing patterns. I was thinking I&apos;d wrap the hiccup in some helper function/macro and use that wrapped form directly in the match pattern position for find/search/rewrite/etc and the helper would transform my hiccup-syntax pattern into it&apos;s map representation while preserving any logic variables, memory variables, or other operators in the pattern). i.e. I&apos;d write something like: (m/find example (from-hiccup-pattern [:message {:type &quot;X&quot;} [:detail {:field ?y} [:first (m/app Float/parseFloat ?content)] (m/$ [:second-nested {:q ?q}])]]) {:y-val ?y :q-val ?q :parsed-content ?content}) and it would essentially expand to: (m/find example {:tag :message :attrs {:type &quot;X&quot;} :content (m/seqable {:tag :detail :attrs {:field ?y} :content (m/seqable {:tag :first :content (m/seqable (m/app Float/parseFloat ?content))} (m/$ {:tag :second-nested :attrs {:q ?q}}))})} {:y-val ?y :q-val ?q :parsed-content ?content}) I can see how I could use your rewrite to transform my input to a hiccup format that I could then match against (possibly as another step within the same rewrite?) . In my head I&apos;d envisioned going about it the other way so that the hiccup to xml pattern expansion would happen at compile-time rather than xml to hiccup at parse time. I haven&apos;t used cata or memory variables yet, and not really all that familiar with macros/quoting so I suspect I&apos;m overlooking a trivial way to do what I want, or possibly the distinction I&apos;m worried about isn&apos;t accurate/doesn&apos;t matter with the way meander works."><y>#</y><d>2020-08-07</d><h>19:23</h><r>chucklehead</r>Thanks, sorry to take so long to get back, hadn&apos;t had a chance to work on this project...

Hopefully I&apos;m not being obtuse about this. I was hoping to use the hiccup syntax as a sort of DSL to write the matching/capturing patterns. I was thinking I&apos;d wrap the hiccup in some helper function/macro and use that wrapped form directly in the match pattern position for find/search/rewrite/etc and the helper would transform my hiccup-syntax pattern into it&apos;s map representation while preserving any logic variables, memory variables, or other operators in the pattern).

i.e. I&apos;d write something like:
<pre>(m/find example
          (from-hiccup-pattern
           [:message {:type &quot;X&quot;}
            [:detail {:field ?y}
             [:first (m/app Float/parseFloat ?content)]
             (m/$ [:second-nested {:q ?q}])]])
          {:y-val ?y
           :q-val ?q
           :parsed-content ?content})</pre>
and it would essentially expand to:
<pre>(m/find example
        {:tag :message
         :attrs {:type &quot;X&quot;}
         :content (m/seqable {:tag :detail
                              :attrs {:field ?y}
                              :content (m/seqable
                                        {:tag :first
                                         :content (m/seqable
                                                   (m/app Float/parseFloat ?content))}
                                        (m/$ {:tag :second-nested
                                              :attrs {:q ?q}}))})}
        {:y-val ?y
         :q-val ?q
         :parsed-content ?content})</pre>
I can see how I could use your rewrite to transform my input to a hiccup format that I could then match against (possibly as another step within the same rewrite?) . In my head I&apos;d envisioned going about it the other way so that the hiccup to xml pattern expansion would happen at compile-time rather than xml to hiccup at parse time. I haven&apos;t used cata or memory variables yet, and not really all that familiar with macros/quoting so I suspect I&apos;m overlooking a trivial way to do what I want, or possibly the distinction I&apos;m worried about isn&apos;t accurate/doesn&apos;t matter with the way meander works.</z><z id="t1596655701" t="markaddleman I needed a simple template system. I think this fits the bill for both simple and easy: (m/rewrite {:keys #{::name ::state} :template [&quot;here is some data for&quot; ::name {:name ::name :state ::state}] :values {::name &quot;Mark&quot; ::state &quot;California&quot;}} {:keys ?keys :values ?values :template (m/$ ?ctx (m/pred (partial contains? ?keys) ?key))} (m/cata {:keys ?keys, :values ?values :template (m/app ?ctx (m/app ?values ?key))}) {:template ?result} ?result)"><y>#</y><d>2020-08-05</d><h>19:28</h><w>markaddleman</w>I needed a simple template system.  I think this fits the bill for both simple and easy:
<pre>(m/rewrite {:keys     #{::name ::state}
              :template [&quot;here is some data for&quot; ::name
                         {:name  ::name
                          :state ::state}]
              :values   {::name  &quot;Mark&quot;
                         ::state &quot;California&quot;}}
    {:keys     ?keys
     :values   ?values
     :template (m/$ ?ctx (m/pred (partial contains? ?keys) ?key))}
    (m/cata {:keys     ?keys, :values ?values
             :template (m/app ?ctx (m/app ?values ?key))})

    {:template ?result} ?result)</pre></z><z id="t1596733120" t="noprompt Another tool you can use for this (not Meander) is clojure.walk/prewalk-replace : (let [bindings {::name &quot;Mark&quot; ::state &quot;California&quot;} template [&quot;here is some data for&quot; ::name {:name ::name :state ::state}]] (clojure.walk/prewalk-replace bindings template)) ;; =&gt; [&quot;here is some data for&quot; &quot;Mark&quot; {:name &quot;Mark&quot;, :state &quot;California&quot;}] "><y>#</y><d>2020-08-06</d><h>16:58</h><r>noprompt</r>Another tool you can use for this (not Meander) is <code>clojure.walk/prewalk-replace</code>:
<pre>(let [bindings {::name &quot;Mark&quot;
                ::state &quot;California&quot;}
      template [&quot;here is some data for&quot;
                ::name
                {:name  ::name
                 :state ::state}]]
  (clojure.walk/prewalk-replace bindings template))
;; =&gt;
[&quot;here is some data for&quot; &quot;Mark&quot; {:name &quot;Mark&quot;, :state &quot;California&quot;}]</pre>
</z><z id="t1596733407" t="noprompt Of course, if you don’t want something as blunt as prewalk-replace you can accomplish the same thing with Meander and your own custom rules for more control: (let [bindings {::name &quot;Mark&quot; ::state &quot;California&quot;} template [&quot;here is some data for&quot; ::name {:name ::name :state ::state}]] (m/rewrite [template bindings] [[!xs ...] ?bindings] [(m/cata [!xs ?bindings]) ...] [{?k ?v &amp; ?rest} ?bindings] {(m/cata [?k ?bindings]) (m/cata [?v ?bindings]) &amp; (m/cata [?rest ?bindings])} [?x {?x ?v :as ?bindings}] (m/cata [?v ?bindings]) ?x ?x)) ;; =&gt; [&quot;here is some data for&quot; &quot;Mark&quot; {:state &quot;California&quot;, :name &quot;Mark&quot;}] "><y>#</y><d>2020-08-06</d><h>17:03</h><r>noprompt</r>Of course, if you don’t want something as blunt as <code>prewalk-replace</code> you can accomplish the same thing with Meander and your own custom rules for more control:
<pre>(let [bindings {::name &quot;Mark&quot;
                ::state &quot;California&quot;}
      template [&quot;here is some data for&quot;
                ::name
                {:name  ::name
                 :state ::state}]]
  (m/rewrite [template bindings]
    [[!xs ...] ?bindings]
    [(m/cata [!xs ?bindings]) ...]

    [{?k ?v &amp; ?rest} ?bindings]
    {(m/cata [?k ?bindings]) (m/cata [?v ?bindings]) &amp; (m/cata [?rest ?bindings])}

    [?x {?x ?v :as ?bindings}]
    (m/cata [?v ?bindings])
    
    ?x
    ?x))
;; =&gt;
[&quot;here is some data for&quot; &quot;Mark&quot; {:state &quot;California&quot;, :name &quot;Mark&quot;}]</pre>
</z><z id="t1597690388" t="noprompt Everyone: the school year for my children has begun and, for the foreseeable future, due to the pandemic and having to home school my children, that will mean I may be much slower to respond in this channel, bug reports, etc."><y>#</y><d>2020-08-17</d><h>18:53</h><w>noprompt</w>Everyone: the school year for my children has begun and, for the foreseeable future, due to the pandemic and having to home school my children, that will mean I may be much slower to respond in this channel, bug reports, etc.</z><z id="t1597691047" t="Jimmy Miller I will try to respond as much as I can. Feel free to ping me if no one responds 🙂"><y>#</y><d>2020-08-17</d><h>19:04</h><w>Jimmy Miller</w>I will try to respond as much as I can. Feel free to ping me if no one responds <b>🙂</b></z><z id="t1598002353" t="gabor.veres Dear all, I&apos;ve been playing around with Meander Epsilon a bit, and I&apos;ve stumbled upon a problem that feels like trivially solvable but I just couldn&apos;t break it. So, noobie question. I&apos;m looking to do kinda like a join, and flatten thing on a vector in a nested map... any help would be highly appreciated! (def db {:items [{:id 1 :labels [1 2 3]} {:id 2 :labels [2]} {:id 3 :labels []} {:id 4 :labels nil} {:id 5 }] :labels [{:id 1 :name &quot;one&quot;} {:id 2 :name &quot;two&quot;} {:id 3 :name &quot;three&quot;} {:id 4 :name &quot;four&quot;}]}) (defn flatten-labels [db] ???) ;; =&gt; ;; {:items ;; [{:id 1 :labels [&quot;one&quot; &quot;two&quot; &quot;three&quot;]} ;; {:id 2 :labels [&quot;two&quot;]} ;; {:id 3 :labels []} ;; {:id 4 :labels []} ;; {:id 5 :labels []}]}"><y>#</y><d>2020-08-21</d><h>09:32</h><w>gabor.veres</w>Dear all, I&apos;ve been playing around with Meander Epsilon a bit, and I&apos;ve stumbled upon a problem that feels like trivially solvable but I just couldn&apos;t break it. So, noobie question. I&apos;m looking to do kinda like a join, and flatten thing on a vector in a nested map... any help would be highly appreciated!

<code>(def db {:items  [{:id 1 :labels [1 2 3]}</code>
                  <code>{:id 2 :labels [2]}</code>
                  <code>{:id 3 :labels []}</code>
                  <code>{:id 4 :labels nil}</code>
                  <code>{:id 5 }]</code>
         <code>:labels [{:id 1 :name &quot;one&quot;}</code>
                  <code>{:id 2 :name &quot;two&quot;}</code>
                  <code>{:id 3 :name &quot;three&quot;}</code>
                  <code>{:id 4 :name &quot;four&quot;}]})</code>


<code>(defn flatten-labels [db]</code>
  <code>???)</code>

<code>;; =&gt;</code>
<code>;; {:items</code>
<code>;; [{:id 1 :labels [&quot;one&quot; &quot;two&quot; &quot;three&quot;]}</code>
<code>;;  {:id 2 :labels [&quot;two&quot;]}</code>
<code>;;  {:id 3 :labels []}</code>
<code>;;  {:id 4 :labels []}</code>
<code>;;  {:id 5 :labels []}]}</code></z><z id="t1598025204" t="Jimmy Miller I&apos;m in a meeting now and going to be grabbing lunch. But will hopefully have some time to play with this after that."><y>#</y><d>2020-08-21</d><h>15:53</h><r>Jimmy Miller</r>I&apos;m in a meeting now and going to be grabbing lunch. But will hopefully have some time to play with this after that.</z><z id="t1598037414" t="Jimmy Miller (m/rewrite db {:labels ?labels :items [{:id !id :labels (m/or nil [!xs ..!n])} ..?m]} {:items [{:id !id :labels [(m/cata [!xs ?labels]) ..!n]} ..?m]} [?id (m/gather {:id ?id :name !label})] !label) There is a lot going on here. First we have nested repeating going on. So in order to capture that I used our capturing repeats [!xs ..!n] and ..?m . Then we have to deal with nil, so I used an m/or . But the big thing here is the cata . If you haven&apos;t seen cata, it is like recur. So now we have two patterns. We pass back a vector with the id we want to find and then use gather to search for it. I&apos;d recommend changing your labels to be a map of id to string value. But maybe you want to have the possibility of duplicates? If so you could change this to handle this pretty easily too. I know that was a pretty quick description, so feel free to ask and I can describe things in more detail."><y>#</y><d>2020-08-21</d><h>19:16</h><r>Jimmy Miller</r><pre>(m/rewrite db
  {:labels ?labels
   :items [{:id !id :labels (m/or nil [!xs ..!n])} ..?m]}
  {:items [{:id !id :labels [(m/cata [!xs ?labels]) ..!n]} ..?m]}
  
  [?id (m/gather {:id ?id :name !label})] !label)</pre>
There is a lot going on here. First we have nested repeating going on. So in order to capture that I used   our capturing repeats <code>[!xs ..!n]</code> and <code>..?m</code>. Then we have to deal with nil, so I used an <code>m/or</code>.

But the big thing here is the <code>cata</code>. If you haven&apos;t seen cata, it is like recur. So now we have two patterns. We pass back a vector with the id  we want to find and then use gather to search for it.

I&apos;d recommend changing your labels to be a map of id to string value. But maybe you want to have the possibility of duplicates? If so you could change this to handle this pretty easily too.

I know that was a pretty quick description, so feel free to ask and I can describe things in more detail.</z><z id="t1598037616" t="Jimmy Miller There could maybe be a more direct way of doing this, but I definitely can&apos;t think of one given the nested repeats going on."><y>#</y><d>2020-08-21</d><h>19:20</h><r>Jimmy Miller</r>There could maybe be a more direct way of doing this, but I definitely can&apos;t think of one given the nested repeats going on.</z><z id="t1598043343" t="gabor.veres Thanks [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] , appreciated! I&apos;ll work my way through this and might get back if I&apos;d get lost... 😉"><y>#</y><d>2020-08-21</d><h>20:55</h><r>gabor.veres</r>Thanks <a>@U5K8NTHEZ</a>, appreciated! I&apos;ll work my way through this and might get back if I&apos;d get lost... <b>😉</b></z><z id="t1598122240" t="timothypratley Many of the problems I find difficult and “ugly” to write in meander boil down to 2 core reasons: The 1st one is “correspondence” (the gap between ?x and !x). I’ve written up what I mean by this here: https://github.com/noprompt/meander/issues/129 and would appreciate any feedback."><y>#</y><d>2020-08-22</d><h>18:50</h><w>timothypratley</w>Many of the problems I find difficult and “ugly” to write in meander boil down to 2 core reasons:
The 1st one is “correspondence” (the gap between ?x and !x). I’ve written up what I mean by this here: <a href="https://github.com/noprompt/meander/issues/129" target="_blank">https://github.com/noprompt/meander/issues/129</a> and would appreciate any feedback.</z><z id="t1598125227" t="timothypratley The 2nd one is the “unspecified keys” syntactical disadvantage: https://github.com/noprompt/meander/issues/130"><y>#</y><d>2020-08-22</d><h>19:40</h><w>timothypratley</w>The 2nd one is the “unspecified keys” syntactical disadvantage: <a href="https://github.com/noprompt/meander/issues/130" target="_blank">https://github.com/noprompt/meander/issues/130</a></z><z id="t1598132060" t="noprompt Thanks [:attrs {:href &quot;/_/_/users/U06S1EJPL&quot;}] I’ll take a look as soon as I can."><y>#</y><d>2020-08-22</d><h>21:34</h><w>noprompt</w>Thanks <a>@timothypratley</a> I’ll take a look as soon as I can.</z><z id="t1598239085" t="noprompt I just had a chance to read over the issues you posted [:attrs {:href &quot;/_/_/users/U06S1EJPL&quot;}] . I need some time to process the ideas before I respond."><y>#</y><d>2020-08-24</d><h>03:18</h><w>noprompt</w>I just had a chance to read over the issues you posted <a>@timothypratley</a>. I need some time to process the ideas before I respond.</z><z id="t1598239241" t="timothypratley no rush! 🙂 was just trying to write stuff down while it was clear in my head from wrestling with a bunch of expression problems."><y>#</y><d>2020-08-24</d><h>03:20</h><r>timothypratley</r>no rush! <b>🙂</b> was just trying to write stuff down while it was clear in my head from wrestling with a bunch of expression problems.</z><z id="t1598333342" t="yuhan I haven&apos;t used Meander for a while now (deemed too experimental for work use), but wouldn&apos;t the &quot;unspecified keys&quot; proposal conflict with the use of ?logic vars as lookup keys in a map?"><y>#</y><d>2020-08-25</d><h>05:29</h><w>yuhan</w>I haven&apos;t used Meander for a while now (deemed too experimental for work use), but wouldn&apos;t the &quot;unspecified keys&quot; proposal conflict with the use of ?logic vars as lookup keys in a map?</z><z id="t1598370441" t="noprompt Yes."><y>#</y><d>2020-08-25</d><h>15:47</h><r>noprompt</r>Yes.</z><z id="t1598333939" t="yuhan (let [db {:user-db {&quot;Alice&quot; {:id 123} &quot;Bob&quot; {:id 124}} :info-db {122 {:favorite-food &quot;nachos&quot;} 123 {:favorite-food &quot;noodles&quot;} 124 {:favorite-food &quot;nutella&quot;}}}] (m/match db ;; query: what is Alice&apos;s favorite food? {:user-db {&quot;Alice&quot; {:id ?id}} :info-db {?id {:favorite-food ?food}}} ?food)) ;; =&gt; &quot;noodles&quot;"><y>#</y><d>2020-08-25</d><h>05:38</h><w>yuhan</w><pre>(let [db {:user-db {&quot;Alice&quot; {:id 123}
                    &quot;Bob&quot;   {:id 124}}
          :info-db {122 {:favorite-food &quot;nachos&quot;}
                    123 {:favorite-food &quot;noodles&quot;}
                    124 {:favorite-food &quot;nutella&quot;}}}]
  (m/match db
    ;; query: what is Alice&apos;s favorite food?
    {:user-db {&quot;Alice&quot; {:id ?id}}
     :info-db {?id {:favorite-food ?food}}}
    ?food))
;; =&gt; &quot;noodles&quot;</pre></z><z id="t1598334570" t="yuhan can&apos;t construct a version with !memory vars at the moment, but it sounds bad for the semantics to be different depending of the type of var"><y>#</y><d>2020-08-25</d><h>05:49</h><w>yuhan</w>can&apos;t construct a version with !memory vars at the moment, but it sounds bad for the semantics to be different depending of the type of var</z><z id="t1598370035" t="noprompt &gt; deemed too experimental for work use Ha! 🙂"><y>#</y><d>2020-08-25</d><h>15:40</h><w>noprompt</w>&gt; deemed too experimental for work use
Ha! <b>🙂</b></z><z id="t1598392926" t="nlessa I have being using Meander extensively in production systems and I am very happy with it."><y>#</y><d>2020-08-25</d><h>22:02</h><r>nlessa</r>I have being using Meander extensively in production systems and I am very happy with it.</z><z id="t1598370575" t="noprompt I see ticket #130 more or less as an invitation to think about how we can improve the visual parts of map/set patterns for the reasons mentioned in that ticket."><y>#</y><d>2020-08-25</d><h>15:49</h><w>noprompt</w>I see ticket #130 more or less as an invitation to think about how we can improve the visual parts of map/set patterns for the reasons mentioned in that ticket.</z><z id="t1598371004" t="noprompt One thing we could do is provide a way to hook into the parser via protocols."><y>#</y><d>2020-08-25</d><h>15:56</h><w>noprompt</w>One thing we could do is provide a way to hook into the parser via protocols.</z><z id="t1598371137" t="noprompt Clojure doesn’t respect the namespace aliases of tagged literals though which makes doing something like #my.custom.MapPattern {!k !v} really gnarly."><y>#</y><d>2020-08-25</d><h>15:58</h><w>noprompt</w>Clojure doesn’t respect the namespace aliases of tagged literals though which makes doing something like
<pre>#my.custom.MapPattern {!k !v}</pre>
really gnarly.</z><z id="t1598371217" t="noprompt The other possibility is making syntax extensions a bit more interesting."><y>#</y><d>2020-08-25</d><h>16:00</h><w>noprompt</w>The other possibility is making syntax extensions a bit more interesting.</z><z id="t1598371253" t="noprompt There’s also the road of flags."><y>#</y><d>2020-08-25</d><h>16:00</h><w>noprompt</w>There’s also the road of flags.</z><z id="t1598371767" t="timothypratley FWIW I’d happily accept the different behavior based on type of var to regain the structure of my expressions 🙂 I have tried to think of ways to explicitly differentiate and unfortunately they all bloat the structure a lot. I really do think it boils down to treating memory variables differently in maps and sets… and that there is significant value in doing so."><y>#</y><d>2020-08-25</d><h>16:09</h><w>timothypratley</w>FWIW I’d happily accept the different behavior based on type of var to regain the structure of my expressions <b>🙂</b> I have tried to think of ways to explicitly differentiate and unfortunately they all bloat the structure a lot.  I really do think it boils down to treating memory variables differently in maps and sets… and that there is significant value in doing so.</z><z id="t1598372321" t="noprompt I think there is significant value in achieving what you’re after in #130, however, the culprit is the search space the container represents not the variable."><y>#</y><d>2020-08-25</d><h>16:18</h><w>noprompt</w>I think there is significant value in achieving what you’re after in #130, however, the culprit is the search space the container represents not the variable.</z><z id="t1598372495" t="noprompt I think it has been mentioned before but would you agree with {&amp; ([!k !v] ...)} on the match side as a compromise for the moment pending further investigation?"><y>#</y><d>2020-08-25</d><h>16:21</h><w>noprompt</w>I think it has been mentioned before but would you agree with
<pre>{&amp; ([!k !v] ...)}</pre>
on the match side as a compromise for the moment pending further investigation?</z><z id="t1598373055" t="timothypratley I’d rather just stick with map-of or {&amp; (m/sequable than make that change!!! 😛 FWIW I think that violates the structure rules"><y>#</y><d>2020-08-25</d><h>16:30</h><w>timothypratley</w>I’d rather just stick with <code>map-of</code> or <code>{&amp; (m/sequable</code> than make that change!!! <b>😛</b> FWIW I think that violates the structure rules</z><z id="t1598373077" t="timothypratley Can you explain more what “the culprit is the search space the container represents not the variable” means?"><y>#</y><d>2020-08-25</d><h>16:31</h><w>timothypratley</w>Can you explain more what “the culprit is the search space the container represents not the variable” means?</z><z id="t1598373428" t="timothypratley Maybe an example 🙂"><y>#</y><d>2020-08-25</d><h>16:37</h><w>timothypratley</w>Maybe an example <b>🙂</b></z><z id="t1598373686" t="timothypratley I think you mean… what is does this mean? {:a 1, !k !v} To which I say it should logically match {:a 1, :c 3} and that !k should be bound as [:a :c] order is arbitrary but matches !v [1 3]"><y>#</y><d>2020-08-25</d><h>16:41</h><w>timothypratley</w>I think you mean… what is does this mean? <code>{:a 1, !k !v}</code>
To which I say it should logically match <code>{:a 1, :c 3}</code> and that !k should be bound as <code>[:a :c]</code> order is arbitrary but matches !v <code>[1 3]</code></z><z id="t1598373737" t="timothypratley Notably if you wanted to you can also write {:a 1, &amp; {!k !v}} and instead have !k/!v only match the remaining map conveniently"><y>#</y><d>2020-08-25</d><h>16:42</h><w>timothypratley</w>Notably if you wanted to you can also write <code>{:a 1, &amp; {!k !v}}</code> and instead have !k/!v only match the remaining map conveniently</z><z id="t1598374447" t="noprompt {p1 p2} represents a submap of the match target of 1 entry. The entry has a key that matches p1 , and value that matches p2 . The search space is all of the values which can be yield from the target which have the potential to match. So if the target were {:a 1 :b 2} the search space would be ([:a 1] [:b 2]) where one element in the space matches :a and 1 against p1 and p2 respectively, and :b and 2 against p1 and p2 respectively."><y>#</y><d>2020-08-25</d><h>16:54</h><w>noprompt</w><pre>{p1 p2}</pre>
represents a submap of the match target of 1 entry. The entry has a key that matches <code>p1</code> , and value that matches <code>p2</code>. The search space  is all of the values which can be yield from the target which have the potential to match. So if the target were
<pre>{:a 1 :b 2}</pre>
the search space would be
<pre>([:a 1] [:b 2])</pre>
where one element in the space matches <code>:a</code> and <code>1</code> against <code>p1</code> and <code>p2</code> respectively, and <code>:b</code> and <code>2</code> against <code>p1</code> and <code>p2</code> respectively.</z><z id="t1598374540" t="noprompt The search space for a map is actually a bit more complex than this but I’m choosing the simplest case for illustration."><y>#</y><d>2020-08-25</d><h>16:55</h><w>noprompt</w>The search space for a map is actually a bit more complex than this but I’m choosing the simplest case for illustration.</z><z id="t1598374783" t="noprompt Why is this important? Well if you want the variables to bind differently, you need to change the search space or change the pattern."><y>#</y><d>2020-08-25</d><h>16:59</h><w>noprompt</w>Why is this important? Well if you want the variables to bind differently, you need to change the search space or change the pattern.</z><z id="t1598375148" t="noprompt The syntax extensions exist to change patterns which can affect how search spaces are yield."><y>#</y><d>2020-08-25</d><h>17:05</h><w>noprompt</w>The syntax extensions exist to change patterns which can affect how search spaces are yield.</z><z id="t1598375163" t="noprompt However, visually they are not satisfactory."><y>#</y><d>2020-08-25</d><h>17:06</h><w>noprompt</w>However, visually they are not satisfactory.</z><z id="t1598375253" t="noprompt We don’t have complete control over how to view a structure in a given context beyond wrapping it in a (symbol p) kind of pattern where symbol has been defined as a syntax extension."><y>#</y><d>2020-08-25</d><h>17:07</h><w>noprompt</w>We don’t have complete control over how to view a structure in a given context beyond wrapping it in a <code>(symbol p)</code> kind of pattern where <code>symbol</code> has been defined as a syntax extension.</z><z id="t1598375347" t="noprompt What would be nice is to be able to say something like (notation {!k !v} (m/map-of !k !v)) "><y>#</y><d>2020-08-25</d><h>17:09</h><w>noprompt</w>What would be nice is to be able to say something like
<pre>(notation {!k !v} (m/map-of !k !v))</pre>
</z><z id="t1598375446" t="noprompt So instead of making the interpretation of an arbitrary pattern context sensitive with respect to the container it happens to appear in you say instead that here we say that a pattern which looks like this should be replace with a pattern that looks like this."><y>#</y><d>2020-08-25</d><h>17:10</h><w>noprompt</w>So instead of making the interpretation of an arbitrary pattern context sensitive with respect to the container it happens to appear in you say instead that here we say that a pattern which looks like this should be replace with a pattern that looks like this.</z><z id="t1598375607" t="noprompt So, for this example, you could write {:a 1 &amp; {!keys !vals}} and have it expand to {:a 1 &amp; (map/of !keys !vals)} "><y>#</y><d>2020-08-25</d><h>17:13</h><w>noprompt</w>So, for this example, you could write
<pre>{:a 1 &amp; {!keys !vals}}</pre>
and have it expand to
<pre>{:a 1 &amp; (map/of !keys !vals)}</pre>
</z><z id="t1598375958" t="yuhan [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] that sounds like a pretty dangerous proposal..! I wouldn&apos;t trust myself with such large amount of control over the semantics of an expression"><y>#</y><d>2020-08-25</d><h>17:19</h><w>yuhan</w><a>@noprompt</a> that sounds like a pretty dangerous proposal..! I wouldn&apos;t trust myself with such large amount of control over the semantics of an expression</z><z id="t1598376087" t="yuhan currently I can look up where each Meander operator is defined and what it does, with arbitrary notation transforms I won&apos;t even be able to tell at a glance what&apos;s being transformed and where it&apos;s defined"><y>#</y><d>2020-08-25</d><h>17:21</h><w>yuhan</w>currently I can look up where each Meander operator is defined and what it does, with arbitrary notation transforms I won&apos;t even be able to tell at a glance what&apos;s being transformed and where it&apos;s defined</z><z id="t1598376121" t="timothypratley I’m not really able to follow the “search space” argument; maybe you can simplify for me … observing that maps are sets of key-values … lets just talk about sets, and not use any pre-existing variables like ?k or !k : let’s just talk about #{-k} a magical new thing that will allow me to match a set and substitute its values, is this impossible for some reason? I’m explicitly not including find in this description."><y>#</y><d>2020-08-25</d><h>17:22</h><w>timothypratley</w>I’m not really able to follow the “search space” argument; maybe you can simplify for me … observing that maps are sets of key-values … lets just talk about sets, and not use any pre-existing variables like <code>?k</code> or <code>!k</code>: let’s just talk about <code>#{-k}</code> a magical new thing that will allow me to <code>match</code> a set and <code>substitute</code> its values, is this impossible for some reason? I’m explicitly not including <code>find</code> in this description.</z><z id="t1598376588" t="yuhan so this -k is bound to all the values in the set?"><y>#</y><d>2020-08-25</d><h>17:29</h><r>yuhan</r>so this <code>-k</code> is bound to all the values in the set?</z><z id="t1598376926" t="timothypratley I’m trying to be abstract and just specify that I’d like (m/rewrite #{1 2 3} #{-k} #{-k}) ;;=&gt; #{1 2 3} as a user feature 🙂 I do think that means -k gets bound to all values in the set, which implies why not just do: (m/rewrite #{1 2 3} (m/and #{} ?xs) ?xs) So I need a slightly more motivating example 🙂"><y>#</y><d>2020-08-25</d><h>17:35</h><r>timothypratley</r>I’m trying to be abstract and just specify that I’d like
<pre>(m/rewrite #{1 2 3}
  #{-k}
  #{-k})
;;=&gt; #{1 2 3}</pre>
as a user feature <b>🙂</b>
I do think that means -k gets bound to all values in the set, which implies why not just do:
<pre>(m/rewrite #{1 2 3}
  (m/and #{} ?xs)
  ?xs)</pre>
So I need a slightly more motivating example <b>🙂</b></z><z id="t1598377375" t="timothypratley (m/rewrite #{1 2 3} #{-k} #{(m/app inc -k)}) ;;=&gt; #{2 3 4}"><y>#</y><d>2020-08-25</d><h>17:42</h><r>timothypratley</r><pre>(m/rewrite #{1 2 3}
  #{-k}
  #{(m/app inc -k)})
;;=&gt; #{2 3 4}</pre></z><z id="t1598376636" t="timothypratley I know what you are going to say… oh but -k could have matched any element! Greed is evil! To which I reply this is why I need greed."><y>#</y><d>2020-08-25</d><h>17:30</h><w>timothypratley</w>I know what you are going to say… oh but <code>-k</code> could have matched any element! Greed is evil! To which I reply this is why I need greed.</z><z id="t1598377499" t="noprompt Greed is certainly not evil."><y>#</y><d>2020-08-25</d><h>17:44</h><w>noprompt</w>Greed is certainly not evil.</z><z id="t1598377605" t="noprompt What is evil is a that a pattern could have different semantics in different contexts: precisely your point about {&amp; ([!k !v] …)} ."><y>#</y><d>2020-08-25</d><h>17:46</h><w>noprompt</w>What is evil is a that a pattern could have different semantics in different contexts: precisely your point about <code>{&amp; ([!k !v] …)}</code> .</z><z id="t1598377735" t="timothypratley can you give an example of how #{-k} would have different meanings?"><y>#</y><d>2020-08-25</d><h>17:48</h><w>timothypratley</w>can you give an example of how <code>#{-k}</code> would have different meanings?</z><z id="t1598377745" t="noprompt No because it only has one meaning."><y>#</y><d>2020-08-25</d><h>17:49</h><w>noprompt</w>No because it only has one meaning.</z><z id="t1598377749" t="timothypratley lol"><y>#</y><d>2020-08-25</d><h>17:49</h><w>timothypratley</w>lol</z><z id="t1598377751" t="noprompt 🙂"><y>#</y><d>2020-08-25</d><h>17:49</h><w>noprompt</w><b>🙂</b></z><z id="t1598377775" t="timothypratley I’m so confused 😕 sorry if I’m dense"><y>#</y><d>2020-08-25</d><h>17:49</h><w>timothypratley</w>I’m so confused <b>😕</b> sorry if I’m dense</z><z id="t1598377786" t="noprompt The search space yielded by the container determines what values it’s contents will be matched against."><y>#</y><d>2020-08-25</d><h>17:49</h><w>noprompt</w>The search space yielded by the container determines what values it’s contents will be matched against.</z><z id="t1598377795" t="noprompt Tim, you are not dense. 🙂"><y>#</y><d>2020-08-25</d><h>17:49</h><w>noprompt</w>Tim, you are not dense. <b>🙂</b></z><z id="t1598377833" t="noprompt I’ve known you for, what, something like 6 years or something? Dense isn’t even on the map. ❤️"><y>#</y><d>2020-08-25</d><h>17:50</h><w>noprompt</w>I’ve known you for, what, something like 6 years or something? Dense isn’t even on the map. <b>❤️</b></z><z id="t1598377860" t="timothypratley Is it that #{?k} and #{-k} have different meanings and that’s bad?"><y>#</y><d>2020-08-25</d><h>17:51</h><w>timothypratley</w>Is it that <code>#{?k}</code> and <code>#{-k}</code> have different meanings and that’s bad?</z><z id="t1598377869" t="noprompt And, fwiw, these conversations are really important."><y>#</y><d>2020-08-25</d><h>17:51</h><w>noprompt</w>And, fwiw, these conversations are really important.</z><z id="t1598378019" t="noprompt It is that, in general, for all patterns p the semantics of #{p} do not change."><y>#</y><d>2020-08-25</d><h>17:53</h><w>noprompt</w>It is that, in general, for all patterns p the semantics of <code>#{p}</code> do not change.</z><z id="t1598387346" t="timothypratley actually I think this is already broken: #{^&amp; ?rest}"><y>#</y><d>2020-08-25</d><h>20:29</h><r>timothypratley</r>actually I think this is already broken:
<code>#{^&amp; ?rest}</code></z><z id="t1598387423" t="noprompt It is?"><y>#</y><d>2020-08-25</d><h>20:30</h><r>noprompt</r>It is?</z><z id="t1598387631" t="noprompt (let [s #{1 2 3}] (m/match s #{^&amp; ?rest} ?rest)) ;; =&gt; #{1 3 2} (let [s #{1 2 3}] (m/find s #{^&amp; ?rest} ?rest)) ;; =&gt; #{1 3 2} (let [s #{1 2 3}] (m/search s #{^&amp; ?rest} ?rest)) ;; =&gt; (#{1 3 2}) (let [s #{1 2 3}] (m/rewrite s #{^&amp; ?rest} #{4 5 6 ^&amp; ?rest})) ;; =&gt; #{1 4 6 3 2 5} "><y>#</y><d>2020-08-25</d><h>20:33</h><r>noprompt</r><pre>(let [s #{1 2 3}]
  (m/match s
    #{^&amp; ?rest}
    ?rest))
;; =&gt; #{1 3 2}

(let [s #{1 2 3}]
  (m/find s
    #{^&amp; ?rest}
    ?rest))
;; =&gt; #{1 3 2}

(let [s #{1 2 3}]
  (m/search s
    #{^&amp; ?rest}
    ?rest))
;; =&gt; (#{1 3 2})

(let [s #{1 2 3}]
  (m/rewrite s
    #{^&amp; ?rest}
    #{4 5 6 ^&amp; ?rest}))
;; =&gt; #{1 4 6 3 2 5}</pre>
</z><z id="t1598415798" t="timothypratley Ah right, I meant that the notion that for all patterns p the semantics do not change …. #{^&amp; ?rest} is arguably already breaking that (in an expected way) or is it ok because the metadata makes it different? In which case is #{^… !k} ok? Is {^... !k !v} ok?"><y>#</y><d>2020-08-26</d><h>04:23</h><r>timothypratley</r>Ah right, I meant that the notion that for all patterns p the semantics do not change …. <code>#{^&amp; ?rest}</code> is arguably already breaking that (in an expected way) or is it ok because the metadata makes it different? In which case is <code>#{^… !k}</code> ok?
Is <code>{^... !k !v}</code> ok?</z><z id="t1598416454" t="timothypratley I kinda like {^… !k !v} to be honest… o_O"><y>#</y><d>2020-08-26</d><h>04:34</h><r>timothypratley</r>I kinda like <code>{^… !k !v}</code> to be honest… o_O</z><z id="t1598378059" t="timothypratley gotcha"><y>#</y><d>2020-08-25</d><h>17:54</h><w>timothypratley</w>gotcha</z><z id="t1598378094" t="noprompt This is why I was lamenting the fact that tagged literals could be so bulky."><y>#</y><d>2020-08-25</d><h>17:54</h><w>noprompt</w>This is why I was lamenting the fact that tagged literals could be so bulky.</z><z id="t1598378122" t="timothypratley ^-k #{} &lt;-- is this ok?"><y>#</y><d>2020-08-25</d><h>17:55</h><w>timothypratley</w><code>^-k #{}</code> &lt;-- is this ok?</z><z id="t1598378552" t="noprompt At the moment, no, BUT the plan is to allow for custom binding semantics. I have a gist where I’ve been playing with this. So when -k binds you could have the definition (fn [current value] (if (seqable? value) (into current value) UNBOUND)) where current is assumed to be a vector, and UNBOUND represents binding failure."><y>#</y><d>2020-08-25</d><h>18:02</h><r>noprompt</r>At the moment, no, BUT the plan is to allow for custom binding semantics. I have a gist where I’ve been playing with this. So when <code>-k</code> binds you could have the definition
<pre>(fn [current value]
  (if (seqable? value)
    (into current value)
    UNBOUND))</pre>
where current is assumed to be a vector, and <code>UNBOUND</code> represents binding failure.</z></g><g id="s5"><z id="t1598378620" t="noprompt So in this way you could say something like #{^:as -k} "><y>#</y><d>2020-08-25</d><h>18:03</h><r>noprompt</r>So in this way you could say something like
<pre>#{^:as -k}</pre>
</z><z id="t1598378261" t="noprompt But I wouldn’t want to get in the way of something like #mine #{!k} where perhaps #mine maps to (defn mine [value] (reify m.protocols/IExpandSyntax (-expand-syntax [this] ,,,))) "><y>#</y><d>2020-08-25</d><h>17:57</h><w>noprompt</w>But I wouldn’t want to get in the way of something like <code>#mine #{!k}</code> where perhaps <code>#mine</code> maps to
<pre>(defn mine [value]
  (reify
    m.protocols/IExpandSyntax
    (-expand-syntax [this]
      ,,,)))</pre>
</z><z id="t1598378552" t="noprompt At the moment, no, BUT the plan is to allow for custom binding semantics. I have a gist where I’ve been playing with this. So when -k binds you could have the definition (fn [current value] (if (seqable? value) (into current value) UNBOUND)) where current is assumed to be a vector, and UNBOUND represents binding failure."><y>#</y><d>2020-08-25</d><h>18:02</h><w>noprompt</w>At the moment, no, BUT the plan is to allow for custom binding semantics. I have a gist where I’ve been playing with this. So when <code>-k</code> binds you could have the definition
<pre>(fn [current value]
  (if (seqable? value)
    (into current value)
    UNBOUND))</pre>
where current is assumed to be a vector, and <code>UNBOUND</code> represents binding failure.</z><z id="t1598378620" t="noprompt So in this way you could say something like #{^:as -k} "><y>#</y><d>2020-08-25</d><h>18:03</h><w>noprompt</w>So in this way you could say something like
<pre>#{^:as -k}</pre>
</z><z id="t1598378628" t="timothypratley is here a more direct solution here where I write my own custom tag that translates {!k !v} to (map-of !k !v) and stop complaining?"><y>#</y><d>2020-08-25</d><h>18:03</h><w>timothypratley</w>is here a more direct solution here where I write my own custom tag that translates <code>{!k !v}</code> to <code>(map-of !k !v)</code> and stop complaining?</z><z id="t1598379053" t="noprompt That would be the notation idea. I’ve been on the fence about it because, like [:attrs {:href &quot;/_/_/users/UCPS050BV&quot;}] pointed out, it’s crazy powerful and could be bad. That being said [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] has somewhat convinced me that isn’t necessarily a good reason to dismiss the idea on the grounds that we can’t stop people from obfuscation. defsyntax can easily obfuscate. Going the route of notation should involve a commitment to tooling that enables makes it easier to expand patterns as you would a macro."><y>#</y><d>2020-08-25</d><h>18:10</h><w>noprompt</w>That would be the <code>notation</code> idea. I’ve been on the fence about it because, like <a>@qythium</a> pointed out, it’s crazy powerful and could be bad. That being said <a>@jimmy</a> has somewhat convinced me that isn’t necessarily a good reason to dismiss the idea on the grounds that we can’t stop people from obfuscation. <code>defsyntax</code> can easily obfuscate. Going the route of <code>notation</code> should involve a commitment to tooling that enables makes it easier to expand patterns as you would a macro.</z><z id="t1598387456" t="timothypratley I’m not sure notation is needed at all… as a user I can write a macro that translates my patterns"><y>#</y><d>2020-08-25</d><h>20:30</h><r>timothypratley</r>I’m not sure <code>notation</code> is needed at all… as a user I can write a macro that translates my patterns</z><z id="t1598387496" t="timothypratley I mean maybe it solves some other problem 🙂"><y>#</y><d>2020-08-25</d><h>20:31</h><r>timothypratley</r>I mean maybe it solves some other problem <b>🙂</b></z><z id="t1598387498" t="timothypratley and that’s great."><y>#</y><d>2020-08-25</d><h>20:31</h><r>timothypratley</r>and that’s great.</z><z id="t1598387569" t="Jimmy Miller We could also expose an ast transformation level if we really wanted to. Not saying we should, but it would solve the problem and also let us experiment with optimizations in an extendable way."><y>#</y><d>2020-08-25</d><h>20:32</h><r>Jimmy Miller</r>We could also expose an ast transformation level if we really wanted to. Not saying we should, but it would solve the problem and also let us experiment with optimizations in an extendable way.</z><z id="t1598379306" t="yuhan yeah, the last time I played around with defsyntax I found myself really wishing for a way to macroexpand sub-patterns"><y>#</y><d>2020-08-25</d><h>18:15</h><w>yuhan</w>yeah, the last time I played around with defsyntax I found myself really wishing for a way to macroexpand sub-patterns</z><z id="t1598379317" t="yuhan not sure if that&apos;s already possible or meaningful"><y>#</y><d>2020-08-25</d><h>18:15</h><w>yuhan</w>not sure if that&apos;s already possible or meaningful</z><z id="t1598379458" t="noprompt It is meaningful."><y>#</y><d>2020-08-25</d><h>18:17</h><w>noprompt</w>It is meaningful.</z><z id="t1598379497" t="yuhan that&apos;s a relief to hear!"><y>#</y><d>2020-08-25</d><h>18:18</h><w>yuhan</w>that&apos;s a relief to hear!</z><z id="t1598379558" t="yuhan One really nice property I like about Meander is that all the special vars and things are drop-in replacements for literal matches"><y>#</y><d>2020-08-25</d><h>18:19</h><w>yuhan</w>One really nice property I like about Meander is that all the special vars and things are drop-in replacements for literal matches</z><z id="t1598379643" t="yuhan there&apos;s probably a better way of putting this but it makes a lot of sense in a easy refactoring / referential transparency mindset"><y>#</y><d>2020-08-25</d><h>18:20</h><w>yuhan</w>there&apos;s probably a better way of putting this but it makes a lot of sense in a easy refactoring / referential transparency mindset</z><z id="t1598379726" t="yuhan so having !k !v be context dependent would complect the whole situation IMO"><y>#</y><d>2020-08-25</d><h>18:22</h><w>yuhan</w>so having !k !v be context dependent would complect the whole situation IMO</z><z id="t1598379803" t="noprompt Currently, I’m a huge bottle neck with respect to the project. I’ve got work related requirements and my kids at home 24/7 (two of which are being home schooled now). What I really want to figure out is how to get others involved in a maximally collaborative but minimally pressured way."><y>#</y><d>2020-08-25</d><h>18:23</h><w>noprompt</w>Currently, I’m a huge bottle neck with respect to the project. I’ve got work related requirements and my kids at home 24/7 (two of which are being home schooled now). What I really want to figure out is how to get others involved in a maximally collaborative but minimally pressured way.</z><z id="t1598379979" t="noprompt I have a model for zeta that I think is mostly sound in terms of the primitives and assumptions. The interpreted model has explainability built in like spec and it works both for matching and substitution. But I need others to think about it too."><y>#</y><d>2020-08-25</d><h>18:26</h><w>noprompt</w>I have a model for <code>zeta</code> that I think is mostly sound in terms of the primitives and assumptions. The interpreted model has explainability built in like spec and it works both for matching and substitution. But I need others to think about it too.</z><z id="t1598380037" t="noprompt Compilation can be built on top of that model which can fall back to run time interpretation if needed."><y>#</y><d>2020-08-25</d><h>18:27</h><w>noprompt</w>Compilation can be built on top of that model which can fall back to run time interpretation if needed.</z><z id="t1598380168" t="noprompt https://gist.github.com/noprompt/387c7aa2b02b2de1330687a9bef0f469#file-two-clj-L679-L707"><y>#</y><d>2020-08-25</d><h>18:29</h><w>noprompt</w><a href="https://gist.github.com/noprompt/387c7aa2b02b2de1330687a9bef0f469#file-two-clj-L679-L707" target="_blank">https://gist.github.com/noprompt/387c7aa2b02b2de1330687a9bef0f469#file-two-clj-L679-L707</a></z><z id="t1598380194" t="noprompt (let [?x (logic-cell) x-&gt; (lifo-cell) x&lt;- (fifo-cell) pattern (pair (&amp;&amp; (in [1 2 3]) x&lt;- x-&gt;) (&amp;&amp; (in [4 5 6]) x&lt;- x-&gt;)) extract-bindings (fn [result] (let [bindings (get result :bindings-out)] {&apos;x-&gt; (get bindings x-&gt;) &apos;x&lt;- (get bindings x&lt;-)}))] [;; Query the pair [2 6] against the pattern and pull out the ;; passing bindings. (map extract-bindings (filter pass? (query pattern [2 6] {}))) ;; Attempt to generate 20 solutions and pull out the passing value ;; and binding.s (map (juxt :value extract-bindings) (filter pass? (take 30 (yield pattern {}))))]) ;; =&gt; #_ [({x-&gt; (6 2), x&lt;- [2 6]}) ([[1 4] {x-&gt; (4 1), x&lt;- [1 4]}] [[1 5] {x-&gt; (5 1), x&lt;- [1 5]}] [[1 6] {x-&gt; (6 1), x&lt;- [1 6]}] [[2 4] {x-&gt; (4 2), x&lt;- [2 4]}] [[2 5] {x-&gt; (5 2), x&lt;- [2 5]}] [[2 6] {x-&gt; (6 2), x&lt;- [2 6]}])]"><y>#</y><d>2020-08-25</d><h>18:29</h><w>noprompt</w><pre>(let [?x (logic-cell)
      x-&gt; (lifo-cell)
      x&lt;- (fifo-cell)
      pattern (pair (&amp;&amp; (in [1 2 3]) x&lt;- x-&gt;)
                    (&amp;&amp; (in [4 5 6]) x&lt;- x-&gt;))
      extract-bindings (fn [result]
                         (let [bindings (get result :bindings-out)]
                           {&apos;x-&gt; (get bindings x-&gt;)
                            &apos;x&lt;- (get bindings x&lt;-)}))]
  [;; Query the pair [2 6] against the pattern and pull out the
   ;; passing bindings.
   (map extract-bindings
        (filter pass? (query pattern [2 6] {})))
   ;; Attempt to generate 20 solutions and pull out the passing value
   ;; and binding.s
   (map (juxt :value extract-bindings)
        (filter pass? (take 30 (yield pattern {}))))])
;; =&gt;
#_
[({x-&gt; (6 2), x&lt;- [2 6]})
 ([[1 4] {x-&gt; (4 1), x&lt;- [1 4]}]
  [[1 5] {x-&gt; (5 1), x&lt;- [1 5]}]
  [[1 6] {x-&gt; (6 1), x&lt;- [1 6]}]
  [[2 4] {x-&gt; (4 2), x&lt;- [2 4]}]
  [[2 5] {x-&gt; (5 2), x&lt;- [2 5]}]
  [[2 6] {x-&gt; (6 2), x&lt;- [2 6]}])]</pre></z><z id="t1598380807" t="noprompt “Two” is what I call the underlying framework. It thinks of variables similar to how Clojure thinks of them in that names point to things but the things are cells which specify how their content is accumulated (fold) and it is dispersed (unfolded)."><y>#</y><d>2020-08-25</d><h>18:40</h><w>noprompt</w>“Two” is what I call the underlying framework. It thinks of variables similar to how Clojure thinks of them in that names point to things but the things are cells which specify how their content is accumulated (fold) and it is dispersed (unfolded).</z><z id="t1598380933" t="noprompt At a more general level, patterns of which variables are subset, are objects which define what it means to be queried and also what it means for them to yield their instances."><y>#</y><d>2020-08-25</d><h>18:42</h><w>noprompt</w>At a more general level, patterns of which variables are subset, are objects which define what it means to be queried and also what it means for them to yield their instances.</z><z id="t1598380984" t="noprompt IOW, patterns represent elements of sets."><y>#</y><d>2020-08-25</d><h>18:43</h><w>noprompt</w>IOW, patterns represent elements of sets.</z><z id="t1598381156" t="noprompt query asks if a value is a member of those sets and produces bindings. yield asks if a value can be produced given bindings and if so produce those values."><y>#</y><d>2020-08-25</d><h>18:45</h><w>noprompt</w><code>query</code> asks if a value is a member of those sets and produces bindings. <code>yield</code> asks if a value can be produced given bindings and if so produce those values.</z><z id="t1598381284" t="noprompt This is deliberately not unification."><y>#</y><d>2020-08-25</d><h>18:48</h><w>noprompt</w>This is deliberately not unification.</z><z id="t1598381312" t="timothypratley [:attrs {:href &quot;/_/_/users/UCPS050BV&quot;}]  could you expand on what “all the special vars and things are drop-in replacements for literal matches” means?"><y>#</y><d>2020-08-25</d><h>18:48</h><w>timothypratley</w><a>@qythium</a>  could you expand on what “all the special vars and things are drop-in replacements for literal matches” means?</z><z id="t1598381916" t="yuhan I think of the &quot;base case&quot; for patterns as matching on a pattern made entirely of literals (m/match [1 2 [3]] [1 2 [3]] :ok) Then you can iteratively replace subexpressions of the pattern with more complicated concepts like logic vars (m/match [1 2 [3]] [1 2 ?x] ?x) knowing that the spot where the ?x goes &quot;resolves&quot; to what could be a base pattern"><y>#</y><d>2020-08-25</d><h>18:58</h><r>yuhan</r>I think of the &quot;base case&quot; for patterns as matching on a pattern made entirely of literals
<pre>(m/match [1 2 [3]] [1 2 [3]] :ok)</pre>
Then you can iteratively replace subexpressions of the pattern with more complicated concepts like logic vars
<pre>(m/match [1 2 [3]] [1 2 ?x] ?x)</pre>
knowing that the spot where the ?x goes &quot;resolves&quot; to what could be a base pattern</z><z id="t1598382063" t="timothypratley :thumbsup:"><y>#</y><d>2020-08-25</d><h>19:01</h><r>timothypratley</r><b>:thumbsup:</b></z><z id="t1598382098" t="yuhan I don&apos;t know if that&apos;s always true eg. cata seems to be context dependent, but I find it a useful mental model"><y>#</y><d>2020-08-25</d><h>19:01</h><r>yuhan</r>I don&apos;t know if that&apos;s always true eg. <code>cata</code> seems to be context dependent, but I find it a useful mental model</z><z id="t1598382851" t="noprompt cata isn’t context sensitive in the sense that its semantics are the same wherever it appears. It is context sensitive in the sense of what the target value is recursively matched against in terms of the system it appears within."><y>#</y><d>2020-08-25</d><h>19:14</h><r>noprompt</r><code>cata</code> isn’t context sensitive in the sense that its semantics are the same wherever it appears. It is context sensitive in the sense of what the target value is recursively matched against in terms of the system it appears within.</z><z id="t1598382818" t="yuhan [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] That was quite a bit to digest but really interesting! So fifo-cells are Meander&apos;s memory variables?"><y>#</y><d>2020-08-25</d><h>19:13</h><w>yuhan</w><a>@noprompt</a> That was quite a bit to digest but really interesting! So fifo-cells are Meander&apos;s memory variables?</z><z id="t1598383411" t="noprompt Yep. I didn’t chuck in the use of ?x there but it works as you’d expect."><y>#</y><d>2020-08-25</d><h>19:23</h><w>noprompt</w>Yep. I didn’t chuck in the use of <code>?x</code> there but it works as you’d expect.</z><z id="t1598383495" t="noprompt Keep in mind this is a model for interpretation. This means, at a minimum, we have a non-macro version of search/yield."><y>#</y><d>2020-08-25</d><h>19:24</h><w>noprompt</w>Keep in mind this is a model for interpretation. This means, at a minimum, we have a non-macro version of search/yield.</z><z id="t1598383555" t="noprompt There is some other interesting stuff going on in there too if you’ll notice the use of SplittableRandom and seed ."><y>#</y><d>2020-08-25</d><h>19:25</h><w>noprompt</w>There is some other interesting stuff going on in there too if you’ll notice the use of <code>SplittableRandom</code> and <code>seed</code>.</z><z id="t1598383613" t="noprompt The idea here is not only to allow for concepts of matching elements from infinite sets but also producing them."><y>#</y><d>2020-08-25</d><h>19:26</h><w>noprompt</w>The idea here is not only to allow for concepts of matching elements from infinite sets but also producing them.</z><z id="t1598383744" t="noprompt This is interesting for something like (sum ?x 3) where the query means find all ?x + 3 = TARGET and yield means all values that give you a value which can match ?x + 3 and, if you want, the bindings that makes that true."><y>#</y><d>2020-08-25</d><h>19:29</h><w>noprompt</w>This is interesting for something like <code>(sum ?x 3)</code> where the query means find all <code>?x + 3 = TARGET</code> and yield means all values that give you a value which can match <code>?x + 3</code> and, if you want, the bindings that makes that true.</z><z id="t1598383794" t="noprompt The streams of data produced by the way include failures unlike previous versions."><y>#</y><d>2020-08-25</d><h>19:29</h><w>noprompt</w>The streams of data produced by the way include failures unlike previous versions.</z><z id="t1598383887" t="noprompt This means that it’s possible to have a model that allows one to explain failures in either case, and, importantly, prevent divergence."><y>#</y><d>2020-08-25</d><h>19:31</h><w>noprompt</w>This means that it’s possible to have a model that allows one to explain failures in either case, and, importantly, prevent divergence.</z><z id="t1598384128" t="noprompt There’s also a rough sketch of group-by-cell in there."><y>#</y><d>2020-08-25</d><h>19:35</h><w>noprompt</w>There’s also a rough sketch of  <code>group-by-cell</code> in there.</z><z id="t1598384176" t="yuhan This sounds a lot like unification, from the vague familiarity I have with both areas"><y>#</y><d>2020-08-25</d><h>19:36</h><w>yuhan</w>This sounds a lot like unification, from the vague familiarity I have with both areas</z><z id="t1598384341" t="yuhan ah scratch that, my thinking is too muddled for that to be a coherent question"><y>#</y><d>2020-08-25</d><h>19:39</h><w>yuhan</w>ah scratch that, my thinking is too muddled for that to be a coherent question</z><z id="t1598384441" t="yuhan I&apos;d love to dive into this in my spare time too and contribute! It&apos;s just a little daunting how high-level the concepts seem to be from scanning through the Meander codebase"><y>#</y><d>2020-08-25</d><h>19:40</h><w>yuhan</w>I&apos;d love to dive into this in my spare time too and contribute! It&apos;s just a little daunting how high-level the concepts seem to be from scanning through the Meander codebase</z><z id="t1598384551" t="yuhan Also just throwing out a random thought I had before - seeing as how Meander&apos;s vars use different sigils that are compiled into some underlying representation, could this be made into an extendable notation?"><y>#</y><d>2020-08-25</d><h>19:42</h><w>yuhan</w>Also just throwing out a random thought I had before - seeing as how Meander&apos;s vars use different sigils that are compiled into some underlying representation, could this be made into an extendable notation?</z><z id="t1598384561" t="noprompt I need write down what I wrote down here on that file, eh? 🙂"><y>#</y><d>2020-08-25</d><h>19:42</h><w>noprompt</w>I need write down what I wrote down here on that file, eh? <b>🙂</b></z><z id="t1598384595" t="noprompt I think the sigils are valuable for the macro version for at least things like logic variables."><y>#</y><d>2020-08-25</d><h>19:43</h><w>noprompt</w>I think the sigils are valuable for the macro version for at least things like logic variables.</z><z id="t1598384598" t="yuhan (defsigil © &quot;docstring&quot; [sym &lt;other necessary args&gt;] &lt;implementation, compiler/interpreter hooks etc.&gt;) where the sigil symbols have to come from the corresponding Unicode punctuation/symbol blocks like Haskell operators"><y>#</y><d>2020-08-25</d><h>19:43</h><w>yuhan</w><pre>(defsigil © 
  &quot;docstring&quot; 
  [sym &lt;other necessary args&gt;] 
  &lt;implementation, compiler/interpreter hooks etc.&gt;) </pre>
where the sigil symbols have to come from the corresponding Unicode punctuation/symbol blocks like Haskell operators</z><z id="t1598384623" t="yuhan then you can go around using ©x in patterns with your own user defined semantics"><y>#</y><d>2020-08-25</d><h>19:43</h><w>yuhan</w>then you can go around using <code>©x</code>  in patterns with your own user defined semantics</z><z id="t1598384634" t="noprompt Yeah. This is something I’ve been thinking about also."><y>#</y><d>2020-08-25</d><h>19:43</h><w>noprompt</w>Yeah. This is something I’ve been thinking about also.</z><z id="t1598384740" t="noprompt I think the smallest thing would be declaring variables somehow (m/declare [$x ([m/unbound 0] 0 _ m/unbound)] ,,,) you get the idea."><y>#</y><d>2020-08-25</d><h>19:45</h><w>noprompt</w>I think the smallest thing would be declaring variables somehow
<pre>(m/declare [$x ([m/unbound 0] 0 _ m/unbound)]
  ,,,)</pre>
you get the idea.</z><z id="t1598384786" t="noprompt Or maybe [$x ~rewrite-rules] to keep plain functions in the mix."><y>#</y><d>2020-08-25</d><h>19:46</h><w>noprompt</w>Or maybe <code>[$x ~rewrite-rules]</code> to keep plain functions in the mix.</z><z id="t1598384837" t="noprompt Damn you covid-19!"><y>#</y><d>2020-08-25</d><h>19:47</h><w>noprompt</w>Damn you covid-19!</z><z id="t1598384912" t="noprompt Oh, before I forget, I should plug #asami as a project to keep an eye on. 🙂"><y>#</y><d>2020-08-25</d><h>19:48</h><w>noprompt</w>Oh, before I forget, I should plug #asami as a project to keep an eye on. <b>🙂</b></z><z id="t1598384943" t="noprompt I am on the same team as the original author and am gradually becoming a contributor."><y>#</y><d>2020-08-25</d><h>19:49</h><w>noprompt</w>I am on the same team as the original author and am gradually becoming a contributor.</z><z id="t1598385950" t="timothypratley I’m really looking forward to the logic-cell stuff as it sounds like a general solution for aggregation/reduce!"><y>#</y><d>2020-08-25</d><h>20:05</h><w>timothypratley</w>I’m really looking forward to the <code>logic-cell</code> stuff as it sounds like a general solution for aggregation/reduce!</z><z id="t1598386501" t="timothypratley I’ve attached the “macro solution” of replacing {!k !v} with {&amp; (map-of !k !v)} to issue #130 based on the suggestions here mainly to record it… I can go ahead and start using the macro in my projects and learn the hard way where it will bite me later."><y>#</y><d>2020-08-25</d><h>20:15</h><w>timothypratley</w>I’ve attached the “macro solution” of replacing <code>{!k !v}</code> with <code>{&amp; (map-of !k !v)}</code> to issue #130 based on the suggestions here mainly to record it… I can go ahead and start using the macro in my projects and learn the hard way where it will bite me later.</z><z id="t1598392926" t="nlessa I have being using Meander extensively in production systems and I am very happy with it."><y>#</y><d>2020-08-25</d><h>22:02</h><w>nlessa</w>I have being using Meander extensively in production systems and I am very happy with it.</z><z id="t1598418929" t="yuhan [:attrs {:href &quot;/_/_/users/U06S1EJPL&quot;}] Another idea for #130: extend the familiar &amp; syntax: {&amp;... [!k !v]} ;; desugars intuitively to {&amp; (m/seqable [!k !v] ...)} ;; or {&amp;!k !v} ;; implicitly includes !v in the repeating pattern ;; or {&amp;!k &amp;!v} ;; over-specification? There is already precedence in ..?n for splitting a symbol up into components to bind ?n"><y>#</y><d>2020-08-26</d><h>05:15</h><w>yuhan</w><a>@timothypratley</a> Another idea for #130: extend the familiar <code>&amp;</code> syntax:

<pre>{&amp;... [!k !v]}
;; desugars intuitively to 
{&amp; (m/seqable [!k !v] ...)}

;; or

{&amp;!k !v} ;; implicitly includes !v in the repeating pattern

;; or 

{&amp;!k &amp;!v} ;; over-specification? </pre>
There is already precedence in <code>..?n</code> for splitting a symbol up into components to bind <code>?n</code></z><z id="t1598447798" t="timothypratley I agree and I like the {&amp;!k !v} notation! That seems very intuitive to me and I like that it doesn’t use metadata. I think this would be really cool and work well!"><y>#</y><d>2020-08-26</d><h>13:16</h><r>timothypratley</r>I agree and I like the  <code>{&amp;!k !v}</code> notation! That seems very intuitive to me and I like that it doesn’t use metadata. I think this would be really cool and work well!</z><z id="t1598419130" t="yuhan This would also apply to sets: #{ &amp;!x } looks better to me than using metadata #{ ^&amp; !x }"><y>#</y><d>2020-08-26</d><h>05:18</h><w>yuhan</w>This would also apply to sets: <code>#{ &amp;!x }</code> looks better to me than using metadata <code>#{ ^&amp; !x }</code></z><z id="t1598448346" t="timothypratley +1 I think this looks way better than the metadata and I find it clearer about the structure (metadata is always weird because it looks like another element). I think this works still for expression: #{(m/pred int? &amp;!x) &amp;?more} seems possible and very cool 🙂"><y>#</y><d>2020-08-26</d><h>13:25</h><r>timothypratley</r>+1 I think this looks way better than the metadata and I find it clearer about the structure (metadata is always weird because it looks like another element). I think this works still for expression: <code>#{(m/pred int? &amp;!x) &amp;?more}</code> seems possible and very cool <b>🙂</b></z><z id="t1598471849" t="scarrucciu All, just getting started with meander, and trying to match against a pattern of keys within a map to return in a search. For example (defn testm [input] (m/search input (m/scan {(m/re #&quot;LX&quot;) ?result}) {:result ?result})) (testm {&quot;LX-1&quot; &quot;a&quot; &quot;LX-2&quot; &quot;b&quot;})"><y>#</y><d>2020-08-26</d><h>19:57</h><w>scarrucciu</w>All, just getting started with meander, and trying to match against a pattern of keys within a map to return in a search. For example
<pre>(defn testm [input]
  (m/search input
    (m/scan {(m/re #&quot;LX&quot;) ?result})
    {:result ?result}))

(testm {&quot;LX-1&quot; &quot;a&quot; &quot;LX-2&quot; &quot;b&quot;})</pre></z><z id="t1598471959" t="scarrucciu where I would want to result to be ({:result &quot;a&quot;} {:result &quot;b&quot;}) is this possible?"><y>#</y><d>2020-08-26</d><h>19:59</h><r>scarrucciu</r>where I would want to result to be
<pre>({:result &quot;a&quot;} {:result &quot;b&quot;})</pre>
is this possible?</z><z id="t1598472615" t="chucklehead I think this will do what you want: (defn testm [input] (m/search input {(m/re #&quot;LX.*&quot;) ?result} {:result ?result}))"><y>#</y><d>2020-08-26</d><h>20:10</h><r>chucklehead</r>I think this will do what you want:
<pre>(defn testm [input]
  (m/search input
            {(m/re #&quot;LX.*&quot;) ?result}
            {:result ?result}))</pre></z><z id="t1598474187" t="scarrucciu Thank you, if I wanted to nest that part in a broader transformation (say there were other keys that I was applying a transformation to), would you recommend apply different m/search’s and then composing the results?"><y>#</y><d>2020-08-26</d><h>20:36</h><r>scarrucciu</r>Thank you, if I wanted to nest that part in a broader transformation (say there were other keys that I was applying a transformation to), would you recommend apply different m/search’s and then composing the results?</z><z id="t1598474432" t="Jimmy Miller It all depends on what you are wanting to accomplish. You can do other keys as well inside the same search. There is no limitation on that. For example: (m/search {&quot;LX-1&quot; &quot;a&quot; &quot;LX-2&quot; &quot;b&quot; :x 1 :y 2} {(m/re #&quot;LX.*&quot;) ?result :x ?x :y ?y} {:result ?result :x (even? ?x) :y (even? ?y)}) "><y>#</y><d>2020-08-26</d><h>20:40</h><r>Jimmy Miller</r>It all depends on what you are wanting to accomplish. You can do other keys as well inside the same search. There is no limitation on that.

For example:
<pre>(m/search {&quot;LX-1&quot; &quot;a&quot; &quot;LX-2&quot; &quot;b&quot; :x 1 :y 2}
  {(m/re #&quot;LX.*&quot;) ?result
   :x ?x
   :y ?y}
  {:result ?result
   :x (even? ?x)
   :y (even? ?y)})</pre>
</z><z id="t1598474463" t="chucklehead I&apos;m fairly new to meander myself, so take anything I say with a grain of salt, but most of what I have been doing is matching/transforming nested maps and I rarely have to use more than one top-level rewrite/search/etc."><y>#</y><d>2020-08-26</d><h>20:41</h><r>chucklehead</r>I&apos;m fairly new to meander myself, so take anything I say with a grain of salt, but most of what I have been doing is matching/transforming nested maps and I rarely have to use more than one top-level rewrite/search/etc.</z><z id="t1598484374" t="scarrucciu thank you, that is really helpful, attempting to translate a bunch of custom transformation base clojure to meander, so very much in the easy stages of understanding what it can do."><y>#</y><d>2020-08-26</d><h>23:26</h><r>scarrucciu</r>thank you, that is really helpful, attempting to translate a bunch of custom transformation base clojure to meander, so very much in the easy stages of understanding what it can do.</z><z id="t1598624220" t="jeremys Hello, I have a noob question if you don’t mind. I have some code like this: (def example {:a {:ret :int} :b {:ret :int} :c {:ret :bool}}) (reduce (fn [acc [k v]] (update acc k (fnil conj []) v)) {} (m/search example {?v {:ret ?k}} [?k ?v])) Which is a inversion of a map, sort of. I am wondering, is there some way to express this as a rewrite?"><y>#</y><d>2020-08-28</d><h>14:17</h><w>jeremys</w>Hello, I have a  noob question if you don’t mind. I have some code like this:
<pre>(def example {:a {:ret :int}
              :b {:ret :int}
              :c {:ret :bool}})
(reduce (fn [acc [k v]]
          (update acc k (fnil conj []) v))
        {}
        (m/search example
          {?v {:ret ?k}}
          [?k ?v]))</pre>
Which is a inversion of a map, sort of. I am wondering, is there some way to express this as a rewrite?</z><z id="t1598638537" t="noprompt Use group-by for this. 🙂 (let [example {:a {:ret :int} :b {:ret :int} :c {:ret :bool}}] (group-by first (m/search example {?v {:ret ?k}} [?k ?v]))) "><y>#</y><d>2020-08-28</d><h>18:15</h><w>noprompt</w>Use <code>group-by</code> for this. <b>🙂</b>
<pre>(let [example {:a {:ret :int}
               :b {:ret :int}
               :c {:ret :bool}}]
  (group-by first (m/search example {?v {:ret ?k}} [?k ?v])))</pre>
</z><z id="t1598639207" t="Jimmy Miller Looks like those aren&apos;t quite equivalent. Going to take a look more at what is intended"><y>#</y><d>2020-08-28</d><h>18:26</h><r>Jimmy Miller</r>Looks like those aren&apos;t quite equivalent. Going to take a look more at what is intended</z><z id="t1598639361" t="noprompt Oops, yep you’re right (let [example {:a {:ret :int} :b {:ret :int} :c {:ret :bool}}] (m/rewrite [example {}] [{?v {:ret ?k} &amp; ?rest} ?out] (m/cata [?rest (m/cata (`append ?out ?k ?v))]) (`append {?k [!vs ...] :as ?out} ?k ?v) {?k [!vs ... ?v] &amp; ?out} (`append ?out ?k ?v) {?k [?v] &amp; ?out} [_ ?out] ?out)) ;; =&gt; {:int [:a :b], :bool [:c]}"><y>#</y><d>2020-08-28</d><h>18:29</h><r>noprompt</r>Oops, yep you’re right

<pre>(let [example {:a {:ret :int}
               :b {:ret :int}
               :c {:ret :bool}}]
  (m/rewrite [example {}]
    [{?v {:ret ?k} &amp; ?rest} ?out]
    (m/cata [?rest (m/cata (`append ?out ?k ?v))])

    (`append {?k [!vs ...] :as ?out} ?k ?v)
    {?k [!vs ... ?v] &amp; ?out}

    (`append ?out ?k ?v)
    {?k [?v] &amp; ?out}

    [_ ?out]
    ?out))
;; =&gt;
{:int [:a :b], :bool [:c]}</pre></z><z id="t1598640991" t="jeremys Thank you for the answer! It’s funny squinting at it, it looks like logic programming to me. I don’t know the cata operator yet besides the vague idea of recursion. Now I see a bit better how it works and the trick building the append` list to recur is neat. Wouldn’t have found it myself that’s for sure. Thanks"><y>#</y><d>2020-08-28</d><h>18:56</h><r>jeremys</r>Thank you for the answer! It’s funny squinting at it, it looks like logic programming to me. I don’t know the <code>cata</code> operator yet besides the vague idea of recursion. Now I see a bit better how it works and the trick building the <code></code>append` list to recur is neat. Wouldn’t have found it myself that’s for sure. Thanks</z><z id="t1598639361" t="noprompt Oops, yep you’re right (let [example {:a {:ret :int} :b {:ret :int} :c {:ret :bool}}] (m/rewrite [example {}] [{?v {:ret ?k} &amp; ?rest} ?out] (m/cata [?rest (m/cata (`append ?out ?k ?v))]) (`append {?k [!vs ...] :as ?out} ?k ?v) {?k [!vs ... ?v] &amp; ?out} (`append ?out ?k ?v) {?k [?v] &amp; ?out} [_ ?out] ?out)) ;; =&gt; {:int [:a :b], :bool [:c]}"><y>#</y><d>2020-08-28</d><h>18:29</h><w>noprompt</w>Oops, yep you’re right

<pre>(let [example {:a {:ret :int}
               :b {:ret :int}
               :c {:ret :bool}}]
  (m/rewrite [example {}]
    [{?v {:ret ?k} &amp; ?rest} ?out]
    (m/cata [?rest (m/cata (`append ?out ?k ?v))])

    (`append {?k [!vs ...] :as ?out} ?k ?v)
    {?k [!vs ... ?v] &amp; ?out}

    (`append ?out ?k ?v)
    {?k [?v] &amp; ?out}

    [_ ?out]
    ?out))
;; =&gt;
{:int [:a :b], :bool [:c]}</pre></z><z id="t1598639758" t="Jimmy Miller [:attrs {:href &quot;/_/_/users/U0FR867U1&quot;}] In general, right now in meander if you want to group things, the general answer is to use clojures means of grouping."><y>#</y><d>2020-08-28</d><h>18:35</h><w>Jimmy Miller</w><a>@jeremys</a> In general, right now in meander if you want to group things, the general answer is to use clojures means of grouping.</z><z id="t1598639769" t="Jimmy Miller We hope to have a better answer in the future."><y>#</y><d>2020-08-28</d><h>18:36</h><w>Jimmy Miller</w>We hope to have a better answer in the future.</z><z id="t1598641152" t="jeremys [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] Thank you, I’ll keep looking out to see what goodies you guys come up with. This project tends to dead/live lock processes in my brain but I find it very cool."><y>#</y><d>2020-08-28</d><h>18:59</h><w>jeremys</w><a>@jimmy</a> Thank you, I’ll keep looking out to see what goodies you guys come up with. This project tends to dead/live lock processes in my brain but I find it very cool.</z><z id="t1598893504" t="noprompt meander/epsilon &quot;0.0.488&quot; is now https://clojars.org/meander/epsilon . • Add set-of like map-of • seqable can be used in substitutions "><y>#</y><d>2020-08-31</d><h>17:05</h><w>noprompt</w><code>meander/epsilon &quot;0.0.488&quot;</code> is now <a href="https://clojars.org/meander/epsilon" target="_blank">https://clojars.org/meander/epsilon</a>.
• Add <code>set-of</code> like <code>map-of</code>
• <code>seqable</code> can be used in substitutions
</z><z id="t1599006086" t="nicklawls Hey folks! Wanted to share my first meander (and incidentally first clojure) project: a teeny lambda calculus typechecker and evaluator. it was a ton of fun 😄 https://github.com/xilnocas/dang If anyone can spare some time to review the code, I&apos;d appreciate it 🙏"><y>#</y><d>2020-09-02</d><h>00:21</h><w>nicklawls</w>Hey folks! Wanted to share my first meander (and incidentally first clojure) project: a teeny lambda calculus typechecker and evaluator. it was a ton of fun <b>😄</b>
<a href="https://github.com/xilnocas/dang" target="_blank">https://github.com/xilnocas/dang</a>

If anyone can spare some time to review the code, I&apos;d appreciate it <b>🙏</b></z><z id="t1599016619" t="noprompt Nice!"><y>#</y><d>2020-09-02</d><h>03:16</h><w>noprompt</w>Nice!</z><z id="t1599056097" t="timothypratley Just a heads up if you are a Cursive user, Colin recently added “Resolve as None” to avoid doing incorrect symbol warnings for Meander macros. To use it, click rewrite choose “context actions” -&gt; “resolve as” -&gt; “None” … looks much nicer! https://groups.google.com/g/cursive/c/Wjt9Zv64faA/m/Vdde7q1JCQAJ"><y>#</y><d>2020-09-02</d><h>14:14</h><w>timothypratley</w>Just a heads up if you are a Cursive user, Colin recently added “Resolve as None” to avoid doing incorrect symbol warnings for Meander macros. To use it, click <code>rewrite</code> choose “context actions” -&gt; “resolve as” -&gt; “None” … looks much nicer! <a href="https://groups.google.com/g/cursive/c/Wjt9Zv64faA/m/Vdde7q1JCQAJ" target="_blank">https://groups.google.com/g/cursive/c/Wjt9Zv64faA/m/Vdde7q1JCQAJ</a></z><z id="t1599409732" t="dregre Hello Meanderites! Been banging my head against the wall for this one; let&apos;s say I wanted to replace all the keys&apos; namespaces in a map with a given namespace, how could I go about doing that?"><y>#</y><d>2020-09-06</d><h>16:28</h><w>dregre</w>Hello Meanderites!
Been banging my head against the wall for this one; let&apos;s say I wanted to replace all the keys&apos; namespaces in a map with a given namespace, how could I go about doing that?</z><z id="t1599409740" t="dregre Total noob to Meander here."><y>#</y><d>2020-09-06</d><h>16:29</h><w>dregre</w>Total noob to Meander here.</z><z id="t1599410421" t="dregre Here&apos;s a contrived example. Say I have data shaped like this more or less: {:foo 1 :boo [{:abc true}]} I&apos;d like the root keys to be namespaced bar and the keys in the :boo maps to be namespaced far , so: {:bar/foo 1 :bar/boo [{:far/abc true}]}"><y>#</y><d>2020-09-06</d><h>16:40</h><w>dregre</w>Here&apos;s a contrived example.  Say I have data shaped like this more or less:

<pre>{:foo 1
 :boo [{:abc true}]}</pre>
I&apos;d like the root keys to be namespaced <code>bar</code>  and the keys in the <code>:boo</code>  maps to be namespaced <code>far</code> , so:

<pre>{:bar/foo 1
 :bar/boo [{:far/abc true}]}</pre></z><z id="t1599411494" t="Jimmy Miller Hey [:attrs {:href &quot;/_/_/users/UAYUERYQ5&quot;}] welcome 🙂 While there are definitely ways to solve your problem using meander, this is definitely not the sort of problem meander is focused on. Meander is focused more on concrete transformations and less on generic ones, that is one way it differs from things like specter. That said, by leveraging clojure’s facilities for dealing with arbitrarily nested things, we can definitely tackle this problem. First we can start with the non-nested case (m/rewrite {:foo 1 :boo 3} (m/map-of (m/keyword !ks) !vs) (m/map-of (m/keyword &quot;bar&quot; !ks) !vs)) Then we can use clojure.walk with this solution to make it work on arbitrary nested levels. (require &apos;[clojure.walk :as walk]) (walk/postwalk (fn [x] (m/rewrite x (m/map-of (m/keyword !ks) !vs) (m/map-of (m/keyword &quot;bar&quot; !ks) !vs) ;; catch all for all non-map values ?x ?x)) {:foo 1 :boo [{:abc true}]}) Of course, this could have been accomplished without meander in not too different of a way. But hopefully that helps"><y>#</y><d>2020-09-06</d><h>16:58</h><r>Jimmy Miller</r>Hey <a>@UAYUERYQ5</a> welcome <b>🙂</b>

While there are definitely ways to solve your problem using meander, this is definitely not the sort of problem meander is focused on. Meander is focused more on concrete transformations and less on generic ones, that is one way it differs from things like specter. That said, by leveraging clojure’s facilities for dealing with arbitrarily nested things, we can definitely tackle this problem.

First we can start with the non-nested case
<pre>(m/rewrite {:foo 1 :boo 3}
  (m/map-of (m/keyword !ks) !vs)
  (m/map-of (m/keyword &quot;bar&quot; !ks) !vs))</pre>
Then we can use clojure.walk with this solution to make it work on arbitrary nested levels.

<pre>(require &apos;[clojure.walk :as walk])

(walk/postwalk 
 (fn [x]
   (m/rewrite x
     (m/map-of (m/keyword !ks) !vs)
     (m/map-of (m/keyword &quot;bar&quot; !ks) !vs)
     
     ;; catch all for all non-map values
     ?x ?x))
 {:foo 1
  :boo [{:abc true}]})</pre>
Of course, this could have been accomplished without meander in not too different of a way. But hopefully that helps</z><z id="t1599416704" t="dregre Ah, many thanks! I think I understand Meander&apos;s purpose a bit more now"><y>#</y><d>2020-09-06</d><h>18:25</h><r>dregre</r>Ah, many thanks!  I think I understand Meander&apos;s purpose a bit more now</z><z id="t1599425321" t="Jimmy Miller Glad that helped. I definitely should have mentioned the pure meander solution though. (require &apos;[meander.strategy.epsilon :as r]) ((r/top-down (r/rewrite (m/map-of (m/keyword !ks) !vs) (m/map-of (m/keyword &quot;bar&quot; !ks) !vs) ?x ?x)) {:foo 1 :boo [{:abc true}]}) Strategies definitely let you achieve a lot of things for arbitrarily nested collections. But top down is like clojure.walk in many ways. In general though, I think meander shines most when you have particular transformations you want to do, rather than generic ones."><y>#</y><d>2020-09-06</d><h>20:48</h><r>Jimmy Miller</r>Glad that helped. I definitely should have mentioned the pure meander solution though.

<pre>(require &apos;[meander.strategy.epsilon :as r])

((r/top-down
  (r/rewrite 
   (m/map-of (m/keyword !ks) !vs)
   (m/map-of (m/keyword &quot;bar&quot; !ks) !vs)
   ?x ?x))

 {:foo 1
  :boo [{:abc true}]})</pre>
Strategies definitely let you achieve a lot of things for arbitrarily nested collections. But top down is like clojure.walk in many ways. In general though, I think meander shines most when you have particular transformations you want to do, rather than generic ones.</z><z id="t1599431459" t="dregre Ah, that’s not too bad!"><y>#</y><d>2020-09-06</d><h>22:30</h><r>dregre</r>Ah, that’s not too bad!</z><z id="t1599431750" t="dregre My problem, you see, is only partially generic. I’m trying to specify namespaces for nested entities (the namespace at each level of nesting is specific). I tried specter first then came upon Meander on HN. Specter’s API felt a bit clunky, and Meander’s logic style programming immediately appealed to me — but I realize my problem is not a perfect fit."><y>#</y><d>2020-09-06</d><h>22:35</h><r>dregre</r>My problem, you see, is only partially generic.
I’m trying to specify namespaces for nested entities (the namespace at each level of nesting is specific).  I tried specter first then came upon Meander on HN.  Specter’s API felt a bit clunky, and Meander’s logic style programming immediately appealed to me — but I realize my problem is not a perfect fit.</z><z id="t1599432571" t="Jimmy Miller How do you know at what level of nesting you should use what namespace? Is there any predictability to the structure?"><y>#</y><d>2020-09-06</d><h>22:49</h><r>Jimmy Miller</r>How do you know at what level of nesting you should use what namespace? Is there any predictability to the structure?</z><z id="t1599432605" t="Jimmy Miller If you give your full real problem, there might be an good answer. Or at least I would know if there wasn’t."><y>#</y><d>2020-09-06</d><h>22:50</h><r>Jimmy Miller</r>If you give your full real problem, there might be an good answer. Or at least I would know if there wasn’t.</z><z id="t1599432931" t="Jimmy Miller Like for example, if there is some :type key that tells you the namespace and it was all just maps you could do something like this: (def example {:type &quot;thing&quot; :stuff {:type &quot;stuff&quot; :a 3 :foo {:type &quot;foo&quot; :c 5}} :b 3}) (m/rewrite example {:type ?type &amp; (m/map-of (m/keyword !ks) !vs)} {:type ?type &amp; (m/map-of (m/keyword ?type !ks) (m/cata !vs))} ?x ?x) I could probably figure out a way to make it a bit more flexible than just maps, would probably just take some thinking."><y>#</y><d>2020-09-06</d><h>22:55</h><r>Jimmy Miller</r>Like for example, if there is some <code>:type</code> key that tells you the namespace and it was all just maps you could do something like this:

<pre>(def example 
  {:type &quot;thing&quot;
   :stuff {:type &quot;stuff&quot;
           :a 3
           :foo {:type &quot;foo&quot;
                 :c 5}}
   :b 3})

(m/rewrite example
  {:type ?type
   &amp; (m/map-of (m/keyword !ks) !vs)}
  {:type ?type
   &amp; (m/map-of (m/keyword ?type !ks) (m/cata !vs))}

  ?x ?x)</pre>
I could probably figure out a way to make it a bit more flexible than just maps, would probably just take some thinking.</z><z id="t1599443876" t="dregre Unfortunately, nothing like that. In specter terms, the namespace is determined by the path. Here&apos;s a real-ish example. Input:"><y>#</y><d>2020-09-07</d><h>01:57</h><r>dregre</r>Unfortunately, nothing like that.  In specter terms, the namespace is determined by the path.  Here&apos;s a real-ish example.

Input:</z><z id="t1599443883" t="dregre {:name &quot;Joe&quot; :addresses [{:street-name &quot;Test St.&quot; :city &quot;Olympia&quot; :state &quot;NJ&quot;}] :identifications [{:type :license :issuer {:name &quot;DMV&quot; :entries [{:code &quot;DLSDLKDSK&quot; :algo &quot;akkak&quot;}]}}]}"><y>#</y><d>2020-09-07</d><h>01:58</h><r>dregre</r><pre>{:name &quot;Joe&quot;

 :addresses
 [{:street-name &quot;Test St.&quot;
   :city &quot;Olympia&quot;
   :state &quot;NJ&quot;}]

 :identifications
 [{:type :license
   :issuer
   {:name &quot;DMV&quot;
    :entries
    [{:code &quot;DLSDLKDSK&quot;
      :algo &quot;akkak&quot;}]}}]}</pre></z><z id="t1599443893" t="dregre Output"><y>#</y><d>2020-09-07</d><h>01:58</h><r>dregre</r>Output</z><z id="t1599443899" t="dregre {:person/name &quot;Joe&quot; :person/addresses [{:address/street-name &quot;Test St.&quot; :address/city &quot;Olympia&quot; :address/state &quot;NJ&quot;}] :person/identifications [{:identification/type :license :identification/issuer {:issuer/name &quot;DMV&quot; :issuer/entries [{:entry/code &quot;DLSDLKDSK&quot; :entry/algo &quot;akkak&quot;}]}}]}"><y>#</y><d>2020-09-07</d><h>01:58</h><r>dregre</r><pre>{:person/name &quot;Joe&quot;
 
 :person/addresses
 [{:address/street-name &quot;Test St.&quot;
   :address/city &quot;Olympia&quot;
   :address/state &quot;NJ&quot;}]

 :person/identifications
 [{:identification/type :license
   :identification/issuer
   {:issuer/name &quot;DMV&quot;
    :issuer/entries
    [{:entry/code &quot;DLSDLKDSK&quot;
      :entry/algo &quot;akkak&quot;}]}}]}</pre></z><z id="t1599444058" t="dregre And this is how I solved it in specter (but it&apos;s horrendous — if I keep the specter I&apos;ll break this apart a bit):"><y>#</y><d>2020-09-07</d><h>02:00</h><r>dregre</r>And this is how I solved it in specter (but it&apos;s horrendous — if I keep the specter I&apos;ll break this apart a bit):</z><z id="t1599444107" t="dregre"><y>#</y><d>2020-09-07</d><h>02:01</h><r>dregre</r></z><z id="t1599495243" t="Jimmy Miller Here is the example directly. (m/rewrite example {:addresses [(m/map-of (m/keyword !address-k) !address-v) ..!addresses] :identifications [{:issuer {:entries [(m/map-of (m/keyword !entry-k) !entry-v) ..!entries] &amp; (m/map-of (m/keyword !issuer-k) !issuer-v)} &amp; (m/map-of (m/keyword !id-k) !id-v)} ..!ids] &amp; (m/map-of (m/keyword !person-v) !person-k)} {:person/addresses [(m/map-of (m/keyword &quot;address&quot; !address-k) !address-v) ..!addresses] :person/identifications [{:identification/issuer {:issuer/entries [(m/map-of (m/keyword &quot;entry&quot; !entry-k) !entry-v) ..!entries] &amp; (m/map-of (m/keyword &quot;issuer&quot; !issuer-k) !issuer-v)} &amp; (m/map-of (m/keyword &quot;identification&quot; !id-k) !id-v)} ..!ids] &amp; (m/map-of (m/keyword &quot;person&quot; !person-v) !person-k)}) Here it is with some bits factored out. (m/rewrite example [?namespace (m/map-of (m/keyword !k) !v)] (m/map-of (m/keyword ?namespace !k) !v) {:addresses [!addresses ...] :identifications [{:issuer {:entries [!entry ..!entries] &amp; !issuer} &amp; !id} ..!ids] &amp; ?person} {:person/addresses [(m/cata [&quot;address&quot; !addresses]) ...] :person/identifications [{:identification/issuer {:issuer/entries [(m/cata [&quot;entry&quot; !entry]) ..!entries] &amp; (m/cata [&quot;issuer&quot; !issuer])} &amp; (m/cata [&quot;identification&quot; !id])} ..!ids] &amp; (m/cata [&quot;person&quot; ?person])}) You could probably use defsyntax to get an even cleaner representation"><y>#</y><d>2020-09-07</d><h>16:14</h><r>Jimmy Miller</r>Here is the example directly.

<pre>(m/rewrite example
    

  {:addresses [(m/map-of (m/keyword !address-k) !address-v) ..!addresses]
   :identifications [{:issuer 
                      {:entries [(m/map-of (m/keyword !entry-k) !entry-v) ..!entries]
                       &amp; (m/map-of (m/keyword !issuer-k) !issuer-v)} 
                      &amp; (m/map-of (m/keyword !id-k) !id-v)}
                     ..!ids]
   &amp; (m/map-of (m/keyword !person-v) !person-k)}


  {:person/addresses [(m/map-of (m/keyword &quot;address&quot; !address-k) !address-v) ..!addresses]
   :person/identifications [{:identification/issuer 
                             {:issuer/entries [(m/map-of (m/keyword &quot;entry&quot; !entry-k) !entry-v) ..!entries]
                              &amp; (m/map-of (m/keyword &quot;issuer&quot; !issuer-k) !issuer-v)} 
                             &amp; (m/map-of (m/keyword &quot;identification&quot; !id-k) !id-v)}
                            ..!ids]
   &amp; (m/map-of (m/keyword &quot;person&quot; !person-v) !person-k)})</pre>
Here it is with some bits factored out.

<pre>(m/rewrite example
  [?namespace (m/map-of (m/keyword !k) !v)]
  (m/map-of (m/keyword ?namespace !k) !v)


  {:addresses [!addresses ...]
   :identifications [{:issuer 
                      {:entries [!entry ..!entries]
                       &amp; !issuer} 
                      &amp; !id} ..!ids]
   &amp; ?person}

  {:person/addresses [(m/cata [&quot;address&quot; !addresses]) ...]
   :person/identifications [{:identification/issuer 
                             {:issuer/entries [(m/cata [&quot;entry&quot; !entry]) ..!entries]
                              &amp; (m/cata [&quot;issuer&quot; !issuer])}
                             &amp; (m/cata [&quot;identification&quot; !id])}
                            ..!ids]
   &amp; (m/cata [&quot;person&quot; ?person])})</pre>
You could probably use defsyntax to get an even cleaner representation</z><z id="t1599506569" t="dregre Ah, very cool, much obliged! Sorry for all the work! Feel free to use this if you think it merits being added as an example to the docs!"><y>#</y><d>2020-09-07</d><h>19:22</h><r>dregre</r>Ah, very cool, much obliged!  Sorry for all the work!  Feel free to use this if you think it merits being added as an example to the docs!</z><z id="t1599410466" t="dregre And I&apos;d like to have arbitrarily many keys at each level."><y>#</y><d>2020-09-06</d><h>16:41</h><w>dregre</w>And I&apos;d like to have arbitrarily many keys at each level.</z><z id="t1600013922" t="jeremys Hi, quick question, is it possible to use the value of a memory var twice? In something like: (m/rewrite [:a :b] [!x ...] (m/map-of ????)) ;=&gt; {:a :a :b :b}"><y>#</y><d>2020-09-13</d><h>16:18</h><w>jeremys</w>Hi, quick question, is it possible to use the value of a memory var twice? In something like:
<pre>(m/rewrite [:a :b]
  [!x  ...]
  (m/map-of ????))
;=&gt; {:a :a :b :b}</pre></z><z id="t1600014007" t="Jimmy Miller You can make two memory variables using and. https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#use-the-same-value-from-a-memory-variable-twice"><y>#</y><d>2020-09-13</d><h>16:20</h><r>Jimmy Miller</r>You can make two memory variables using and. <a href="https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#use-the-same-value-from-a-memory-variable-twice" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#use-the-same-value-from-a-memory-variable-twice</a></z><z id="t1600014391" t="jeremys [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] Thanks! I thoght about that trick and must have screwed it up when I tried..."><y>#</y><d>2020-09-13</d><h>16:26</h><r>jeremys</r><a>@U5K8NTHEZ</a> Thanks! I thoght about that trick and must have screwed it up when I tried...</z><z id="t1600014735" t="jeremys as an aside I read your post about rewriting meander with meander. Pretty cool stuff!"><y>#</y><d>2020-09-13</d><h>16:32</h><r>jeremys</r>as an aside I read your post about rewriting meander with meander. Pretty cool stuff!</z><z id="t1600015080" t="Jimmy Miller Glad you liked it :)"><y>#</y><d>2020-09-13</d><h>16:38</h><r>Jimmy Miller</r>Glad you liked it :)</z><z id="t1600938611" t="Lucy Wang Hey channel, I worked on it for a while, but failed to find a solution. How could I achieve this with meander: ;; original (def data {:people [{:name :john :age 10} {:name :jen :age 11} {:name :jack :age 12}] :bonus [{:name :john :amount 100} {:name :jack :amount 200}]}) ;; wanted {:people [{:name :john :bonus-amount 100 :age 10} {:name :jen :age 11} {:name :jack :bonus-amount 200 :age 12}] :bonus [{:name :john :amount 100} {:name :jack :amount 200}]} It&apos;s very like a join of two tables."><y>#</y><d>2020-09-24</d><h>09:10</h><w>Lucy Wang</w>Hey channel, I worked on it for a while, but failed to find a solution. How could I achieve this with meander:
<pre>;; original
(def data
  {:people [{:name :john
             :age  10}
            {:name :jen
             :age  11}
            {:name :jack
             :age  12}]
   :bonus  [{:name   :john
             :amount 100}
            {:name   :jack
             :amount 200}]})

;; wanted
{:people [{:name         :john
           :bonus-amount 100
           :age          10}
          {:name :jen
           :age  11}
          {:name         :jack
           :bonus-amount 200
           :age          12}]
 :bonus  [{:name   :john
           :amount 100}
          {:name   :jack
           :amount 200}]}</pre>
It&apos;s very like a join of two tables.</z><z id="t1600938979" t="Lucy Wang one version is this, but it returns a flattened list (me/search data {:people (me/scan {:name ?name :as ?person}) :bonus (me/scan {:name ?name :amount ?amount})} {:people (assoc ?person :bonus-amount ?amount)}) ;; =&gt; ({:people {:name :john, :age 10, :bonus-amount 100}} ;; {:people {:name :jack, :age 12, :bonus-amount 200}})"><y>#</y><d>2020-09-24</d><h>09:16</h><w>Lucy Wang</w>one version is this, but it returns a flattened list
<pre>(me/search data
  {:people (me/scan {:name ?name :as ?person})
   :bonus (me/scan {:name ?name :amount ?amount})}
  
  {:people (assoc ?person :bonus-amount ?amount)})
;; =&gt; ({:people {:name :john, :age 10, :bonus-amount 100}}
;;     {:people {:name :jack, :age 12, :bonus-amount 200}})</pre></z><z id="t1600939807" t="Lucy Wang And a closer but incorrect version using memory variables (me/rewrite data {:people [{:name !name :as !person} ...] :bonus [{:name !name :amount !amount} ...]} {:people [{:bonus-amount !amount &amp; !person} ...]}) ;; =&gt; {:people ;; [{:name :john, :age 10, :bonus-amount 100} ;; {:name :jen, :age 11, :bonus-amount 200}]}"><y>#</y><d>2020-09-24</d><h>09:30</h><w>Lucy Wang</w>And a closer but incorrect version using memory variables
<pre>(me/rewrite data
  {:people [{:name !name :as !person} ...]
   :bonus [{:name !name :amount !amount} ...]}
  
  {:people [{:bonus-amount !amount &amp; !person} ...]})
;; =&gt; {:people
;;     [{:name :john, :age 10, :bonus-amount 100}
;;      {:name :jen, :age 11, :bonus-amount 200}]}</pre></z><z id="t1600940912" t="Lucy Wang ok, an ugly solution of a combo of search+match, but it works (-&gt; (me/search data {:people (me/scan {:name ?name :as ?person}) :bonus (me/scan {:name ?name :amount ?amount})} {:people (assoc ?person :bonus-amount ?amount)}) (me/match ({:people !people} ...) {:people !people :bonus (:bonus data)})) ;; =&gt; {:people ;; [{:name :john, :age 10, :bonus-amount 100} ;; {:name :jack, :age 12, :bonus-amount 200}], ;; :bonus [{:name :john, :amount 100} {:name :jack, :amount 200}]} "><y>#</y><d>2020-09-24</d><h>09:48</h><w>Lucy Wang</w>ok, an ugly solution of a combo of search+match, but it works
<pre>(-&gt; (me/search data
       {:people (me/scan {:name ?name :as ?person})
        :bonus (me/scan {:name ?name :amount ?amount})}
  
       {:people (assoc ?person :bonus-amount ?amount)})
     (me/match 
       ({:people !people} ...)
       {:people !people
        :bonus (:bonus data)}))
;; =&gt; {:people
;;     [{:name :john, :age 10, :bonus-amount 100}
;;      {:name :jack, :age 12, :bonus-amount 200}],
;;     :bonus [{:name :john, :amount 100} {:name :jack, :amount 200}]}</pre>
</z><z id="t1600941904" t="Lucy Wang created an issue in GH: https://github.com/noprompt/meander/issues/137"><y>#</y><d>2020-09-24</d><h>10:05</h><w>Lucy Wang</w>created an issue in GH: <a href="https://github.com/noprompt/meander/issues/137" target="_blank">https://github.com/noprompt/meander/issues/137</a></z><z id="t1600954636" t="Jimmy Miller Hey lucy. Will get back later today on this one. Sorry have been a bit busy lately"><y>#</y><d>2020-09-24</d><h>13:37</h><r>Jimmy Miller</r>Hey lucy. Will get back later today on this one. Sorry have been a bit busy lately</z><z id="t1600954662" t="Lucy Wang Thanks [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] !"><y>#</y><d>2020-09-24</d><h>13:37</h><r>Lucy Wang</r>Thanks <a>@jimmy</a>!</z><z id="t1600976776" t="Jimmy Miller Replied on the card. Hopefully there is something helpful in there."><y>#</y><d>2020-09-24</d><h>19:46</h><r>Jimmy Miller</r>Replied on the card. Hopefully there is something helpful in there.</z><z id="t1600953772" t="Lone Ranger Struggling to understand this behavior: (m/match [3 4 5 6 7 8] [3 4 . !xs !ys ...] [!xs !ys]) ;; =&gt; [[5 7] [6 8]] my intuition tells me this should be =&gt; [5, [6, 7, 8]] "><y>#</y><d>2020-09-24</d><h>13:22</h><w>Lone Ranger</w>Struggling to understand this behavior:
<pre>(m/match [3 4 5 6 7 8]
  [3 4 . !xs !ys ...]
  [!xs !ys])
;; =&gt;
[[5 7] [6 8]]</pre>
my intuition tells me this should be
<pre>=&gt; [5, [6, 7, 8]]</pre>
</z><z id="t1600953817" t="Lone Ranger ah except maybe that would be for [3 4 . ?xs !ys ...] instead"><y>#</y><d>2020-09-24</d><h>13:23</h><w>Lone Ranger</w>ah except maybe that would be for <code>[3 4 . ?xs !ys ...]</code> instead</z><z id="t1600953847" t="Lone Ranger I think it&apos;s the behavior of !xs !ys that works on every other number that is confusing."><y>#</y><d>2020-09-24</d><h>13:24</h><w>Lone Ranger</w>I think it&apos;s the behavior of <code>!xs !ys</code> that works on every other number that is confusing.</z><z id="t1600954790" t="Jimmy Miller The dot there is telling it where to stop the repeating. So you are asking it to repeat !xs !ys over and over again. That is why it is giving you pairs. If you moved the dot like this [3 4 !xs . !ys ...] now only the !ys are repeating and you&apos;d get [[5], [6, 7, 8]]"><y>#</y><d>2020-09-24</d><h>13:39</h><w>Jimmy Miller</w>The dot there is telling it where to stop the repeating. So you are asking it to repeat <code>!xs !ys</code> over and over again. That is why it is giving you pairs. If you moved the dot like this <code>[3 4 !xs . !ys ...]</code> now only the !ys are repeating and you&apos;d get <code>[[5], [6, 7, 8]]</code></z><z id="t1600954984" t="Lucy Wang yeah, my understanding is that ... looks to its left until it sees either a dot or the start of the current list/vector, and repeats everything in between"><y>#</y><d>2020-09-24</d><h>13:43</h><w>Lucy Wang</w>yeah, my understanding is that <code>...</code> looks to its left until it sees either a dot or the start of the current list/vector, and repeats everything in between</z><z id="t1600955012" t="Lone Ranger ok that makes sense. But why does it do the sliding window like that? i.e. why not [[5 6] [7 8]] ? Ah, is it because it scans two by two?"><y>#</y><d>2020-09-24</d><h>13:43</h><w>Lone Ranger</w>ok that makes sense.  But why does it do the sliding window like that?  i.e. why not <code>[[5 6] [7 8]]</code>?  Ah, is it because it scans two by two?</z><z id="t1600955163" t="Lucy Wang yeah, it&apos;s &quot;interleaving&quot;, so [1 !xs ...] matches [1 2 1 3 1 :foo 1 :bar]"><y>#</y><d>2020-09-24</d><h>13:46</h><w>Lucy Wang</w>yeah, it&apos;s &quot;interleaving&quot;, so <code>[1 !xs ...]</code> matches  <code>[1 2 1 3 1 :foo 1 :bar]</code></z><z id="t1600955270" t="Lone Ranger 😮 fascinating! so it&apos;s kind of like a flattened cross product. And [1 !xs] would be [[1 2] [1 3] [1 :foo] [1 :bar]] ?"><y>#</y><d>2020-09-24</d><h>13:47</h><w>Lone Ranger</w><b>😮</b> fascinating! so it&apos;s kind of like a flattened cross product.  And <code>[1 !xs]</code> would be <code>[[1 2] [1 3] [1 :foo] [1 :bar]]</code>?</z><z id="t1600955304" t="Lucy Wang in the RHS, !xs would be [2 3 :foo :bar]"><y>#</y><d>2020-09-24</d><h>13:48</h><r>Lucy Wang</r>in the RHS, !xs would be [2 3 :foo :bar]</z><z id="t1600955354" t="Lucy Wang but you can also use [1 !xs ...] on the RHS to expand it to [1 2 1 3 1 :foo 1 :bar] , but not [[1 2] [1 3] [1 :foo] [1 :bar]]"><y>#</y><d>2020-09-24</d><h>13:49</h><r>Lucy Wang</r>but you can also use <code>[1 !xs ...]</code> on the RHS to expand it to <code>[1 2 1 3 1 :foo 1 :bar]</code>, but not <code>[[1 2] [1 3] [1 :foo] [1 :bar]]</code></z><z id="t1600955277" t="Lucy Wang speaking in a regex way, it&apos;s like (1.)*"><y>#</y><d>2020-09-24</d><h>13:47</h><w>Lucy Wang</w>speaking in a regex way, it&apos;s like <code>(1.)*</code></z><z id="t1600955309" t="Lone Ranger ahhh and with re-search"><y>#</y><d>2020-09-24</d><h>13:48</h><w>Lone Ranger</w>ahhh and with <code>re-search</code></z><z id="t1600955330" t="Lone Ranger or perhaps re-find"><y>#</y><d>2020-09-24</d><h>13:48</h><w>Lone Ranger</w>or perhaps <code>re-find</code></z><z id="t1600955369" t="Jimmy Miller Yeah, !xs capture one value, the !ys capture one value, so on and so forth. So you are seeing what is in the !xs and the !ys. Using rewrite you can get the back out in the same order. (m/rewrite [3 4 5 6 7 8] [3 4 . !xs !ys ...] [!xs !ys ...]) ;; =&gt; [5 6 7 8]"><y>#</y><d>2020-09-24</d><h>13:49</h><w>Jimmy Miller</w>Yeah, !xs capture one value, the !ys capture one value, so on and so forth. So you are seeing what is in the !xs and the !ys. Using rewrite you can get the back out in the same order.

<pre>(m/rewrite [3 4 5 6 7 8]
  [3 4 . !xs !ys ...]
  [!xs !ys ...])
;; =&gt;
[5 6 7 8]</pre></z><z id="t1600955578" t="Lone Ranger sweet! 🤓 thanks for clarifying"><y>#</y><d>2020-09-24</d><h>13:52</h><w>Lone Ranger</w>sweet! <b>🤓</b> thanks for clarifying</z><z id="t1600965015" t="noprompt https://clojars.org/meander/epsilon/versions/0.0.492"><y>#</y><d>2020-09-24</d><h>16:30</h><w>noprompt</w><a href="https://clojars.org/meander/epsilon/versions/0.0.492" target="_blank">https://clojars.org/meander/epsilon/versions/0.0.492</a></z><z id="t1600965063" t="noprompt This new release improves performance for scan-like patterns such as _ … p1 ,,, pN . _ … ."><y>#</y><d>2020-09-24</d><h>16:31</h><w>noprompt</w>This new release improves performance for scan-like patterns such as <code>_ … p1 ,,, pN . _ …</code>.</z><z id="t1600965074" t="noprompt Significantly."><y>#</y><d>2020-09-24</d><h>16:31</h><w>noprompt</w>Significantly.</z><z id="t1600965585" t="noprompt I think it would be nice to have an “unsafe” notation which tells the compiler to assume the type is known. I’m not sure what it should look like, however. Maybe something like ^::m/unsafe {:assumed-to-be-a-map? true} "><y>#</y><d>2020-09-24</d><h>16:39</h><w>noprompt</w>I think it would be nice to have an “unsafe” notation which tells the compiler to assume the type is known. I’m not sure what it should look like, however. Maybe something like

<pre>^::m/unsafe {:assumed-to-be-a-map? true}</pre>
</z><z id="t1600970348" t="Jimmy Miller Might be nice to just have an elide-collection-type-checks all together as well."><y>#</y><d>2020-09-24</d><h>17:59</h><r>Jimmy Miller</r>Might be nice to just have an elide-collection-type-checks all together as well.</z><z id="t1600965675" t="noprompt You can the motivation for this idea here toward the bottom of my reply: https://github.com/noprompt/meander/issues/135#issuecomment-698215991"><y>#</y><d>2020-09-24</d><h>16:41</h><w>noprompt</w>You can the motivation for this idea here toward the bottom of my reply: <a href="https://github.com/noprompt/meander/issues/135#issuecomment-698215991" target="_blank">https://github.com/noprompt/meander/issues/135#issuecomment-698215991</a></z><z id="t1600969602" t="Lone Ranger I&apos;m new to this whole thing but my leaning would be towards assuming it&apos;s a map by default based on the notation? Or at least supports the associative abstraction"><y>#</y><d>2020-09-24</d><h>17:46</h><w>Lone Ranger</w>I&apos;m new to this whole thing but my leaning would be towards assuming it&apos;s a map by default based on the notation?  Or at least supports the associative abstraction</z><z id="t1600969706" t="Lone Ranger we&apos;re talking about this case, right? (m/find data {:people (m/scan {:name ?name :id ?id :inactive true}) :addresses (m/scan {:person-id ?id :as ?address})} {:name ?name :found 1 :address ?address}))"><y>#</y><d>2020-09-24</d><h>17:48</h><w>Lone Ranger</w>we&apos;re talking about this case, right?
<pre>(m/find data
     {:people (m/scan {:name ?name :id ?id :inactive true})
      :addresses (m/scan {:person-id ?id :as ?address})}
     {:name ?name
      :found 1
      :address ?address}))</pre></z><z id="t1600969828" t="Jimmy Miller The idea here is that right now the generated code explicitly checks if the data you pass in is passes the map? predicate. If it did not check this and you pass something other than a map, it could error or give weird results. But sometimes you want that extra speed and know for sure you are giving us a map."><y>#</y><d>2020-09-24</d><h>17:50</h><w>Jimmy Miller</w>The idea here is that right now the generated code explicitly checks if the data you pass in is passes the map? predicate. If it did not check this and you pass something other than a map, it could error or give weird results. But sometimes you want that extra speed and know for sure you are giving us a map.</z><z id="t1600969926" t="Lone Ranger yep -- just trying to imagine a scenario (besides a GI/GO situation) where someone would pass in something besides an associative abstraction and expect valid results without specifying the type"><y>#</y><d>2020-09-24</d><h>17:52</h><w>Lone Ranger</w>yep -- just trying to imagine a scenario (besides a GI/GO situation) where someone would pass in something besides an associative abstraction and expect valid results without specifying the type</z><z id="t1600970013" t="Jimmy Miller You might have some heterogeneous set of data and the whole thing you are doing with meander is trying to find the bits that actually match the shape you specify."><y>#</y><d>2020-09-24</d><h>17:53</h><w>Jimmy Miller</w>You might have some heterogeneous set of data and the whole thing you are doing with meander is trying to find the bits that actually match the shape you specify.</z><z id="t1600970146" t="Lone Ranger hmmm"><y>#</y><d>2020-09-24</d><h>17:55</h><w>Lone Ranger</w>hmmm</z><z id="t1600970229" t="Lone Ranger two thoughts on that... and maybe I&apos;m overly hostile, but first I would wonder if want to go that route is try/catch cheaper than (if (map? ...) ...) , and the second perhaps overly hostile perspective would be, isn&apos;t it on the user to make sure the sequence is full of things that support the associative abstraction?"><y>#</y><d>2020-09-24</d><h>17:57</h><w>Lone Ranger</w>two thoughts on that... and maybe I&apos;m overly hostile, but first I would wonder if want to go that route is try/catch cheaper than <code>(if (map? ...) ...)</code> , and the second perhaps overly hostile perspective would be, isn&apos;t it on the user to make sure the sequence is full of things that support the associative abstraction?</z><z id="t1600970229" t="Jimmy Miller But also we like to have safety by default. And changing that default would be a breaking change which we don&apos;t do."><y>#</y><d>2020-09-24</d><h>17:57</h><w>Jimmy Miller</w>But also we like to have safety by default. And changing that default would be a breaking change which we don&apos;t do.</z><z id="t1600970236" t="Lone Ranger aha"><y>#</y><d>2020-09-24</d><h>17:57</h><w>Lone Ranger</w>aha</z><z id="t1600970242" t="Lone Ranger that&apos;s a fair point"><y>#</y><d>2020-09-24</d><h>17:57</h><w>Lone Ranger</w>that&apos;s a fair point</z><z id="t1600970573" t="Jimmy Miller One of the benefits of pattern matching is that you get some of the benefits of static types without some of the downsides. In dynamic languages you can accidentally do some operation on the wrong type of thing and get weird results. (like contains? On a vec in clojure). Meander let&apos;s you be clear about those types through the data literals. If we didn&apos;t check the types what the code does now becomes unclear. But at the same time, we want people to be able to opt-in to more performant code when needed."><y>#</y><d>2020-09-24</d><h>18:02</h><w>Jimmy Miller</w>One of the benefits of pattern matching is that you get some of the benefits of static types without some of the downsides. In dynamic languages you can accidentally do some operation on the wrong type of thing and get weird results. (like contains? On a vec in clojure). Meander let&apos;s you be clear about those types through the data literals. If we didn&apos;t check the types what the code does now becomes unclear. But at the same time, we want people to be able to opt-in to more performant code when needed.</z><z id="t1600970681" t="Lone Ranger From an API perspective, I might think having an &quot;unsafe&quot; set of namespaces would be preferable to cluttering up notation with the type hinting"><y>#</y><d>2020-09-24</d><h>18:04</h><w>Lone Ranger</w>From an API perspective, I might think having an &quot;unsafe&quot; set of namespaces would be preferable to cluttering up notation with the type hinting</z><z id="t1600970797" t="Lone Ranger (that&apos;s without having a clue about the challenge of implementing that... yet!)"><y>#</y><d>2020-09-24</d><h>18:06</h><w>Lone Ranger</w>(that&apos;s without having a clue about the challenge of implementing that... yet!)</z><z id="t1600970802" t="Jimmy Miller Well sense we use data literals you&apos;d then have to opt-out of all safety or forgo the data literals syntax instead of being able to do it piecemeal with an existing match. Maybe you want the vector check but not the map one. We should support both."><y>#</y><d>2020-09-24</d><h>18:06</h><w>Jimmy Miller</w>Well sense we use data literals you&apos;d then have to opt-out of all safety or forgo the data literals syntax instead of being able to do it piecemeal with an existing match. Maybe you want the vector check but not the map one. We should support both.</z><z id="t1600970874" t="Jimmy Miller Improving the performance of your code should not require you to go require something else. Just modify your code in place."><y>#</y><d>2020-09-24</d><h>18:07</h><w>Jimmy Miller</w>Improving the performance of your code should not require you to go require something else. Just modify your code in place.</z><z id="t1600971474" t="Lone Ranger totally get it. In my mind I&apos;d opt out of all safety if that were an option b/c that&apos;s just what I&apos;m used to -- if I feed in the wrong spec it&apos;s my fault. But not sure that&apos;s a healthy attitude haha. I mean, if I had to trade safety for clean notation and speed, that would be my vote"><y>#</y><d>2020-09-24</d><h>18:17</h><w>Lone Ranger</w>totally get it.  In my mind I&apos;d opt out of all safety if that were an option b/c that&apos;s just what I&apos;m used to -- if I feed in the wrong spec it&apos;s my fault.  But not sure that&apos;s a healthy attitude haha.  I mean, if I had to trade safety for clean notation and speed, that would be my vote</z><z id="t1600971534" t="Lone Ranger but maybe that&apos;s cause I come from a crazy Python/cljs background where that&apos;s always the case"><y>#</y><d>2020-09-24</d><h>18:18</h><w>Lone Ranger</w>but maybe that&apos;s cause I come from a crazy Python/cljs background where that&apos;s always the case</z><z id="t1600971579" t="noprompt It’s primarily unhealthy when the assumptions unchecked code makes are broken by code changes upstream."><y>#</y><d>2020-09-24</d><h>18:19</h><w>noprompt</w>It’s primarily unhealthy when the assumptions unchecked code makes are broken by code changes upstream.</z><z id="t1600971601" t="Lone Ranger yes, agree -- need to maintain backwards compatibility"><y>#</y><d>2020-09-24</d><h>18:20</h><w>Lone Ranger</w>yes, agree -- need to maintain backwards compatibility</z><z id="t1600971645" t="noprompt So, from this perspective, Meander aims to be safe by default."><y>#</y><d>2020-09-24</d><h>18:20</h><w>noprompt</w>So, from this perspective, Meander aims to be safe by default.</z><z id="t1600971677" t="Lone Ranger yep... 100% understand that, I thought we were discussing unsafe options"><y>#</y><d>2020-09-24</d><h>18:21</h><w>Lone Ranger</w>yep... 100% understand that, I thought we were discussing unsafe options</z><z id="t1600971710" t="noprompt But as I point out in the issue there’s a huge performance savings to be had if you know there is virtually zero risk in eliding the check."><y>#</y><d>2020-09-24</d><h>18:21</h><w>noprompt</w>But as I point out in the issue there’s a huge performance savings to be had if you know there is virtually zero risk in eliding the check.</z><z id="t1600971985" t="Lone Ranger mhm. What I&apos;m advocating for is that for a user like me, I&apos;d be putting {:unsafe ...} next to EVERYTHING"><y>#</y><d>2020-09-24</d><h>18:26</h><w>Lone Ranger</w>mhm.  What I&apos;m advocating for is that for a user like me, I&apos;d be putting <code>{:unsafe ...}</code> next to EVERYTHING</z><z id="t1600972002" t="noprompt Oh, well, no one wants that. 🙂"><y>#</y><d>2020-09-24</d><h>18:26</h><w>noprompt</w>Oh, well, no one wants that. <b>🙂</b></z><z id="t1600972033" t="noprompt But to get to where we don’t have to do that, we actually have to start from that position where we do."><y>#</y><d>2020-09-24</d><h>18:27</h><w>noprompt</w>But to get to where we don’t have to do that, we actually have to start from that position where we do.</z><z id="t1600972045" t="Lone Ranger ahh excellent point"><y>#</y><d>2020-09-24</d><h>18:27</h><w>Lone Ranger</w>ahh excellent point</z><z id="t1600972075" t="noprompt Verbosity is the first step toward abstraction."><y>#</y><d>2020-09-24</d><h>18:27</h><w>noprompt</w>Verbosity is the first step toward abstraction.</z><z id="t1600972087" t="Lone Ranger !!!"><y>#</y><d>2020-09-24</d><h>18:28</h><w>Lone Ranger</w>!!!</z><z id="t1600972092" t="Lone Ranger I need to meditate on that one"><y>#</y><d>2020-09-24</d><h>18:28</h><w>Lone Ranger</w>I need to meditate on that one</z><z id="t1600972845" t="Lone Ranger Does meander have transducer/xfn variations of the m/* series yet? Would that be a welcome contribution?"><y>#</y><d>2020-09-24</d><h>18:40</h><w>Lone Ranger</w>Does meander have transducer/xfn variations of the <code>m/*</code> series yet?  Would that be a welcome contribution?</z><z id="t1600972945" t="noprompt I think m/search could possibly return a transducer instead of results. I’ve looked into this and requires a bit of work."><y>#</y><d>2020-09-24</d><h>18:42</h><w>noprompt</w>I think <code>m/search</code> could possibly return a transducer instead of results. I’ve looked into this and requires a bit of work.</z><z id="t1600972994" t="Lone Ranger It would probably just be sugar on top of something like... (comp (map (fn [data] (m/search ...)) cat) or the like."><y>#</y><d>2020-09-24</d><h>18:43</h><w>Lone Ranger</w>It would probably just be sugar on top of something like...
<pre>(comp 
  (map (fn [data] (m/search ...))
  cat)</pre>
or the like.</z><z id="t1600972998" t="noprompt The transducer version of mapcat throws a bit of wrench into the mix."><y>#</y><d>2020-09-24</d><h>18:43</h><w>noprompt</w>The transducer version of <code>mapcat</code> throws a bit of wrench into the mix.</z><z id="t1600973260" t="Lone Ranger is that b/c of possible thrown exceptions?"><y>#</y><d>2020-09-24</d><h>18:47</h><w>Lone Ranger</w>is that b/c of possible thrown exceptions?</z><z id="t1600974297" t="noprompt No. It’s because an infinitely deep search space can prevent the transducer from ever returning anything."><y>#</y><d>2020-09-24</d><h>19:04</h><w>noprompt</w>No. It’s because an infinitely deep search space can prevent the transducer from ever returning anything.</z><z id="t1600974563" t="noprompt It’s a solvable problem. Just like the last patch, it probably will involve a way of indicating that a something has a particular property that is salient and compilation can be adjusted accordingly i.e. (let [[min max] (search-space-depth-range pattern environment)] (infinite? max)) "><y>#</y><d>2020-09-24</d><h>19:09</h><w>noprompt</w>It’s a solvable problem. Just like the last patch, it probably will involve a way of indicating that a something has a particular property that is salient and compilation can be adjusted accordingly i.e.
<pre>(let [[min max] (search-space-depth-range pattern environment)]
  (infinite? max))</pre>
</z><z id="t1600974883" t="Lone Ranger aha"><y>#</y><d>2020-09-24</d><h>19:14</h><w>Lone Ranger</w>aha</z><z id="t1600974916" t="Lone Ranger m/search itself could be infinite depending on the pattern?"><y>#</y><d>2020-09-24</d><h>19:15</h><w>Lone Ranger</w><code>m/search</code> itself could be infinite depending on the pattern?</z><z id="t1600975454" t="noprompt Yes. At the moment, I don’t think this is really an issue but in the future there will be several patterns that have infinite spaces. For example, (m/sum ?a ?b) finds all possible values ?a and ?b such that (+ ?a ?b) equals the target."><y>#</y><d>2020-09-24</d><h>19:24</h><w>noprompt</w>Yes. At the moment, I don’t think this is really an issue but in the future there will be several patterns that have infinite spaces. For example,
<pre>(m/sum ?a ?b)</pre>
finds all possible values <code>?a</code> and <code>?b</code> such that <code>(+ ?a ?b)</code> equals the target.</z><z id="t1600975469" t="Lone Ranger ohhhhh nice! I didn&apos;t know that was a thing"><y>#</y><d>2020-09-24</d><h>19:24</h><w>Lone Ranger</w>ohhhhh nice! I didn&apos;t know that was a thing</z><z id="t1600975474" t="noprompt It isn’t yet."><y>#</y><d>2020-09-24</d><h>19:24</h><w>noprompt</w>It isn’t yet.</z><z id="t1600975497" t="noprompt I’ve been hacking on it on the side though and it will appear in the next version of the library."><y>#</y><d>2020-09-24</d><h>19:24</h><w>noprompt</w>I’ve been hacking on it on the side though and it will appear in the next version of the library.</z><z id="t1600975591" t="Lone Ranger that&apos;s fascinating -- I&apos;ve been thinking about the synergy between meander and core.logic"><y>#</y><d>2020-09-24</d><h>19:26</h><w>Lone Ranger</w>that&apos;s fascinating -- I&apos;ve been thinking about the synergy between meander and <code>core.logic</code></z><z id="t1600975620" t="noprompt Along with things like (long ?min ?max) which matches a long between ?min and ?max , and binds ?min and ?max . Also, this pattern can yield long values in the range of ?min and ?max ."><y>#</y><d>2020-09-24</d><h>19:27</h><w>noprompt</w>Along with things like
<pre>(long ?min ?max)</pre>
which matches a <code>long</code> between <code>?min</code> and <code>?max</code>, and binds <code>?min</code> and <code>?max</code> . Also, this pattern can yield long values in the range of <code>?min</code> and <code>?max</code>.</z><z id="t1600975652" t="Lone Ranger mhm. Without looking at internals, I suppose converting that to a lazy sequence would be quite difficult?"><y>#</y><d>2020-09-24</d><h>19:27</h><w>Lone Ranger</w>mhm.  Without looking at internals, I suppose converting that to a lazy sequence would be quite difficult?</z><z id="t1600975665" t="Lone Ranger because then an infinite sequence is no problem"><y>#</y><d>2020-09-24</d><h>19:27</h><w>Lone Ranger</w>because then an infinite sequence is no problem</z><z id="t1600975781" t="noprompt Not especially. If we know either or both of ?min and ?max matching is pretty easy. If we know neither it’s also not so bad: we simply produce the space which is all possible combinations of long values such that (&lt;= ?min TARGET ?max) where TARGET is the value being matched."><y>#</y><d>2020-09-24</d><h>19:29</h><w>noprompt</w>Not especially. If we know either or both of <code>?min</code> and <code>?max</code> matching is pretty easy. If we know neither it’s also not so bad: we simply produce the space which is all possible combinations of long values such that <code>(&lt;= ?min TARGET ?max)</code> where <code>TARGET</code> is the value being matched.</z><z id="t1600975900" t="Lone Ranger Well that&apos;s certainly an acceptable option as well"><y>#</y><d>2020-09-24</d><h>19:31</h><w>Lone Ranger</w>Well that&apos;s certainly an acceptable option as well</z><z id="t1600975906" t="noprompt The concepts Meander is based on are very similar to the ones found in something like core.logic but not quite."><y>#</y><d>2020-09-24</d><h>19:31</h><w>noprompt</w>The concepts Meander is based on are very similar to the ones found in something like <code>core.logic</code> but not quite.</z><z id="t1600975962" t="noprompt Essentially, matching/searching is unification with the exclusions that variables cannot be unified. IOW, variables must always be unified against a ground value."><y>#</y><d>2020-09-24</d><h>19:32</h><w>noprompt</w>Essentially, matching/searching is unification with the exclusions that variables cannot be unified. IOW, variables must always be unified against a ground value.</z><z id="t1600975964" t="Lone Ranger It&apos;s all some dark magic to me 😄 I&apos;m still reworking through the end of SICP section 4 where they wire up that stuff from scratch"><y>#</y><d>2020-09-24</d><h>19:32</h><w>Lone Ranger</w>It&apos;s all some dark magic to me <b>😄</b> I&apos;m still reworking through the end of SICP section 4 where they wire up that stuff from scratch</z><z id="t1600976059" t="Lone Ranger What I&apos;m not understanding is (and possible it&apos;s just b/c lacking theory) how is it possible to stop at an arbitrary number and not pause/continue the computation to make it lazy"><y>#</y><d>2020-09-24</d><h>19:34</h><w>Lone Ranger</w>What I&apos;m not understanding is (and possible it&apos;s just b/c lacking theory) how is it possible to stop at an arbitrary number and not pause/continue the computation to make it lazy</z><z id="t1600976061" t="noprompt Another difference, is that Meander has been evolving (I think) a very different concept of a variable that is much more like a Clojure var than how LP normally thinks of them."><y>#</y><d>2020-09-24</d><h>19:34</h><w>noprompt</w>Another difference, is that Meander has been evolving (I think) a very different concept of a variable that is much more like a Clojure <code>var</code>  than how LP normally thinks of them.</z><z id="t1600976257" t="noprompt The idea is that binding is essentially a reduction which can fail."><y>#</y><d>2020-09-24</d><h>19:37</h><w>noprompt</w>The idea is that binding is essentially a reduction which can fail.</z><z id="t1600976280" t="noprompt And unbinding or yielding is unfolding which can also fail."><y>#</y><d>2020-09-24</d><h>19:38</h><w>noprompt</w>And unbinding or yielding is unfolding which can also fail.</z><z id="t1600976348" t="noprompt This process is independent from whatever it’s name happens to be."><y>#</y><d>2020-09-24</d><h>19:39</h><w>noprompt</w>This process is independent from whatever it’s name happens to be.</z><z id="t1600976391" t="Lone Ranger Interesting... I have much to learn. Well I think an easy low hanging fruit would be to target things that for sure terminate, like m/match"><y>#</y><d>2020-09-24</d><h>19:39</h><w>Lone Ranger</w>Interesting... I have much to learn.  Well I think an easy low hanging fruit would be to target things that for sure terminate, like <code>m/match</code></z><z id="t1600976432" t="noprompt It’s too bad this is the free Slack. I’m sure many of the long time members in this channel are like, “yeah, we’ve heard this before…” 😛"><y>#</y><d>2020-09-24</d><h>19:40</h><w>noprompt</w>It’s too bad this is the free Slack. I’m sure many of the long time members in this channel are like, “yeah, we’ve heard this before…” <b>😛</b></z><z id="t1600976442" t="Lone Ranger :rolling_on_the_floor_laughing:"><y>#</y><d>2020-09-24</d><h>19:40</h><w>Lone Ranger</w><b>:rolling_on_the_floor_laughing:</b></z><z id="t1600976457" t="noprompt But, I’m always happy to share my thoughts if helps/confuses/inspires. 🙂"><y>#</y><d>2020-09-24</d><h>19:40</h><w>noprompt</w>But, I’m always happy to share my thoughts if helps/confuses/inspires. <b>🙂</b></z><z id="t1600976478" t="Lone Ranger Super inspired! I love being the new guy haha."><y>#</y><d>2020-09-24</d><h>19:41</h><w>Lone Ranger</w>Super inspired!  I love being the new guy haha.</z><z id="t1600976514" t="Lone Ranger Where did you get the idea for this, anyway? I can&apos;t find a single precedent like it. Closest I can see is datalog and core.logic"><y>#</y><d>2020-09-24</d><h>19:41</h><w>Lone Ranger</w>Where did you get the idea for this, anyway?  I can&apos;t find a single precedent like it.  Closest I can see is datalog and core.logic</z><z id="t1600976598" t="Lone Ranger I mean I&apos;ve seen other data transformation languages but none with the declarative/data-literal syntax"><y>#</y><d>2020-09-24</d><h>19:43</h><w>Lone Ranger</w>I mean I&apos;ve seen other data transformation languages but none with the declarative/data-literal syntax</z><z id="t1600976944" t="noprompt A couple things pushed me in this direction: • Pattern matchers • Logic Programming • Math notation • Data literals • Regular expression But I think the biggest one was noticing a lot of asymmetry in how we manipulate data. We take data apart differently from how we put it together."><y>#</y><d>2020-09-24</d><h>19:49</h><w>noprompt</w>A couple things pushed me in this direction:
• Pattern matchers
• Logic Programming
• Math notation
• Data literals
• Regular expression
But I think the biggest one was noticing a lot of asymmetry in how we manipulate data. We take data apart differently from how we put it together.</z><z id="t1600977105" t="noprompt I thought it would be cool to see if I could make something that really emphasized symmetry and played to our mutual strengths to recognize patterns."><y>#</y><d>2020-09-24</d><h>19:51</h><w>noprompt</w>I thought it would be cool to see if I could make something that really emphasized symmetry and played to our mutual strengths to recognize patterns.</z><z id="t1600977327" t="noprompt The other thing I noticed is that, after programming in Clojure for almost 10 years, I’m not getting better at reading arbitrary Clojure programs. I still have to slow down and mentally unpack even modestly complex code."><y>#</y><d>2020-09-24</d><h>19:55</h><w>noprompt</w>The other thing I noticed is that, after programming in Clojure for almost 10 years, I’m not getting better at reading arbitrary Clojure programs. I still have to slow down and mentally unpack even modestly complex code.</z><z id="t1600977391" t="noprompt So, yeah, I sort of feel like I’m always haunted by this question of “shouldn’t we be able to skip all this these days and more or less draw a picture of what we want?”"><y>#</y><d>2020-09-24</d><h>19:56</h><w>noprompt</w>So, yeah, I sort of feel like I’m always haunted by this question of “shouldn’t we be able to skip all this these days and more or less draw a picture of what we want?”</z><z id="t1600977392" t="Lone Ranger I saw [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] ’s talk and it made me realize I&apos;m not getting better at it either. The only thing that&apos;s increased is my code reading &quot;pain tolerance&quot; hahaha"><y>#</y><d>2020-09-24</d><h>19:56</h><w>Lone Ranger</w>I saw <a>@jimmy</a>’s talk and it made me realize I&apos;m not getting better at it either.  The only thing that&apos;s increased is my code reading &quot;pain tolerance&quot; hahaha</z><z id="t1600977404" t="noprompt It’s true!"><y>#</y><d>2020-09-24</d><h>19:56</h><w>noprompt</w>It’s true!</z><z id="t1600977457" t="Lone Ranger the data literal syntax is very powerful because it plugs into our visual cortex system, which is infinitely more powerful than whatever systems process functional abstractions"><y>#</y><d>2020-09-24</d><h>19:57</h><w>Lone Ranger</w>the data literal syntax is very powerful because it plugs into our visual cortex system, which is infinitely more powerful than whatever systems process functional abstractions</z><z id="t1600977484" t="Lone Ranger I was actually really surprised that I didn&apos;t find a fully defined language based on this"><y>#</y><d>2020-09-24</d><h>19:58</h><w>Lone Ranger</w>I was actually really surprised that I didn&apos;t find a fully defined language based on this</z><z id="t1600977529" t="Lone Ranger Pattern matching, yes... but data transformation, no"><y>#</y><d>2020-09-24</d><h>19:58</h><w>Lone Ranger</w>Pattern matching, yes... but data transformation, no</z><z id="t1600977565" t="Lone Ranger I actually think there is a lot of excellent opportunity for serious academic work here, too"><y>#</y><d>2020-09-24</d><h>19:59</h><w>Lone Ranger</w>I actually think there is a lot of excellent opportunity for serious academic work here, too</z><z id="t1600977595" t="noprompt I always use regular expression as a point here. If you master the language, you often do not have the problem of wondering what an arbitrary regular expression means. So I’m emphasizing semantics here. I’m not saying there aren’t exceptions to this point but, in general, I think it’s fare to say regular expression has this property of remarkably clear semantics."><y>#</y><d>2020-09-24</d><h>19:59</h><w>noprompt</w>I always use regular expression as a point here. If you master the language, you often do not have the problem of wondering what an arbitrary regular expression means. So I’m emphasizing semantics here. I’m not saying there aren’t exceptions to this point but, in general, I think it’s fare to say regular expression has this property of remarkably clear semantics.</z><z id="t1600977667" t="noprompt We do have this trouble with code. And this makes sense because code is meant to encode semantics in a general way."><y>#</y><d>2020-09-24</d><h>20:01</h><w>noprompt</w>We do have this trouble with code. And this makes sense because code is meant to encode semantics in a general way.</z><z id="t1600977690" t="Lone Ranger think, for instance, matrix operations. Trying to find a single matrix that is equivalent, for instance, to the multiplication of three matrices."><y>#</y><d>2020-09-24</d><h>20:01</h><w>Lone Ranger</w>think, for instance, matrix operations.  Trying to find a single matrix that is equivalent, for instance, to the multiplication of three matrices.</z><z id="t1600977712" t="noprompt Actually, there is a really cool Python matcher that can do that. ☝️"><y>#</y><d>2020-09-24</d><h>20:01</h><w>noprompt</w>Actually, there is a really cool Python matcher that can do that. <b>☝️</b></z><z id="t1600977790" t="Lone Ranger what are you referring to? I can help steal/translate 🙂"><y>#</y><d>2020-09-24</d><h>20:03</h><r>Lone Ranger</r>what are you referring to?  I can help steal/translate <b>🙂</b></z><z id="t1600978102" t="noprompt https://github.com/HPAC/matchpy"><y>#</y><d>2020-09-24</d><h>20:08</h><r>noprompt</r><a href="https://github.com/HPAC/matchpy" target="_blank">https://github.com/HPAC/matchpy</a></z><z id="t1600985457" t="Lone Ranger Awesome. Just need a clojure transliteration?"><y>#</y><d>2020-09-24</d><h>22:10</h><r>Lone Ranger</r>Awesome.  Just need a clojure transliteration?</z><z id="t1600977722" t="noprompt I would love to steal that technology."><y>#</y><d>2020-09-24</d><h>20:02</h><w>noprompt</w>I would love to steal that technology.</z><z id="t1600977760" t="Lone Ranger The same analogy could be extended to meander transformations. What single meander pattern could be compiled from 3 meander patterns?"><y>#</y><d>2020-09-24</d><h>20:02</h><w>Lone Ranger</w>The same analogy could be extended to meander transformations.  What single meander pattern could be compiled from 3 meander patterns?</z><z id="t1600977769" t="Lone Ranger seems like a pretty interesting study to me"><y>#</y><d>2020-09-24</d><h>20:02</h><w>Lone Ranger</w>seems like a pretty interesting study to me</z><z id="t1600978510" t="Lone Ranger Do you have a contributor doc anywhere?"><y>#</y><d>2020-09-24</d><h>20:15</h><w>Lone Ranger</w>Do you have a contributor doc anywhere?</z><z id="t1600979241" t="noprompt I do not. Mostly that is due to the fact I have to make compromises about my time."><y>#</y><d>2020-09-24</d><h>20:27</h><w>noprompt</w>I do not. Mostly that is due to the fact I have to make compromises about my time.</z><z id="t1600979305" t="noprompt But, also, if anyone wants to contribute I’m much better at an organic conversation that tells someone where everything is than I am translating that into a document."><y>#</y><d>2020-09-24</d><h>20:28</h><w>noprompt</w>But, also, if anyone wants to contribute I’m much better at an organic conversation that tells someone where everything is than I am translating that into a document.</z><z id="t1600979320" t="noprompt I need a spirit medium like [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] for that sort of thing. 🙂"><y>#</y><d>2020-09-24</d><h>20:28</h><w>noprompt</w>I need a spirit medium like <a>@jimmy</a> for that sort of thing. <b>🙂</b></z><z id="t1600979347" t="Lone Ranger Fine by me! I&apos;m thinking as a rough mockup of a match-xfn something like this: ;; psuedocode (defpsuedomacro matcher [{ex-handler :ex-handler alt-nil :alt-nil :as opts} prop-list] (comp (map (fn [x] (try (m/match x ~@plist) (catch Exception e (if (some? ex-handler) (or (ex-handler e) alt-nil) alt-nil ))))) cat (remove #{alt-nil}))) "><y>#</y><d>2020-09-24</d><h>20:29</h><w>Lone Ranger</w>Fine by me!

I&apos;m thinking as a rough mockup of a <code>match-xfn</code> something like this:

<pre>;; psuedocode
(defpsuedomacro matcher [{ex-handler :ex-handler alt-nil :alt-nil :as opts} prop-list]
 (comp 
   (map (fn [x]
          (try
            (m/match x ~@plist)
            (catch Exception e
              (if (some? ex-handler)
                (or (ex-handler e) alt-nil)
                alt-nil
                )))))
   cat
   (remove #{alt-nil})))</pre>
</z><z id="t1600979492" t="noprompt I think the best thing to do if you have ideas is to share them on Github. [:attrs {:href &quot;/_/_/users/U06S1EJPL&quot;}] and others have shared some fantastic ideas there."><y>#</y><d>2020-09-24</d><h>20:31</h><w>noprompt</w>I think the best thing to do if you have ideas is to share them on Github. <a>@timothypratley</a> and others have shared some fantastic ideas there.</z><z id="t1600979502" t="Lone Ranger Sweet! Will do"><y>#</y><d>2020-09-24</d><h>20:31</h><w>Lone Ranger</w>Sweet!  Will do</z><z id="t1600979537" t="noprompt Ideas generally take a lot of thinking about and it’s nice having several on the table to see if there are common threads among them to be addressed with a unifying solution."><y>#</y><d>2020-09-24</d><h>20:32</h><w>noprompt</w>Ideas generally take a lot of thinking about and it’s nice having several on the table to see if there are common threads among them to be addressed with a unifying solution.</z><z id="t1600979578" t="noprompt For example, we’ve had a lot back and forth about aggregation and that has led to the model of binding I mentioned earlier."><y>#</y><d>2020-09-24</d><h>20:32</h><w>noprompt</w>For example, we’ve had a lot back and forth about aggregation and that has led to the model of binding I mentioned earlier.</z><z id="t1600979605" t="noprompt It’s not ready yet but I think it would have taken longer to come up with a solution without people sharing their ideas."><y>#</y><d>2020-09-24</d><h>20:33</h><w>noprompt</w>It’s not ready yet but I think it would have taken longer to come up with a solution without people sharing their ideas.</z><z id="t1600979673" t="noprompt I think that’s is one of the things I’m most proud of being a member in this channel is the encouragement for people to discuss their ideas, criticisms, etc."><y>#</y><d>2020-09-24</d><h>20:34</h><w>noprompt</w>I think that’s is one of the things I’m most proud of being a member in this channel is the encouragement for people to discuss their ideas, criticisms, etc.</z><z id="t1600988436" t="Lucy Wang Am I misusing it, or it&apos;s cata doesn&apos;t work with &amp; ?rest on a map? (me/match {:a 1 :b 2} {:a ?a &amp; (me/cata ?rest)} {:aa ?a :rest ?rest} {:b ?b} {:bb ?b}) ;; =&gt; stackoverflow! "><y>#</y><d>2020-09-24</d><h>23:00</h><w>Lucy Wang</w>Am I misusing it, or it&apos;s <code>cata</code> doesn&apos;t work with <code>&amp; ?rest</code> on a map?
<pre>(me/match {:a 1 :b 2}
  {:a ?a &amp; (me/cata ?rest)}
  {:aa ?a :rest ?rest}

  {:b ?b}
  {:bb ?b}) ;; =&gt; stackoverflow!</pre>
</z><z id="t1600988492" t="Jimmy Miller Change it to (me/some ?a)"><y>#</y><d>2020-09-24</d><h>23:01</h><w>Jimmy Miller</w>Change it to (me/some ?a)</z><z id="t1600988498" t="Lucy Wang aaah!!"><y>#</y><d>2020-09-24</d><h>23:01</h><w>Lucy Wang</w>aaah!!</z><z id="t1600988532" t="Lucy Wang it works bananadance"><y>#</y><d>2020-09-24</d><h>23:02</h><w>Lucy Wang</w>it works <b>bananadance</b></z><z id="t1600988536" t="Jimmy Miller It will still match with nil even if the key doesn&apos;t exist. This is based on some of clojures behavior and something we have considered changing in zeta."><y>#</y><d>2020-09-24</d><h>23:02</h><w>Jimmy Miller</w>It will still match with nil even if the key doesn&apos;t exist. This is based on some of clojures behavior and something we have considered changing in zeta.</z><z id="t1600988608" t="Jimmy Miller We also have thought about detecting things like this in some sort of linting like mode to help people diagnose these problems."><y>#</y><d>2020-09-24</d><h>23:03</h><w>Jimmy Miller</w>We also have thought about detecting things like this in some sort of linting like mode to help people diagnose these problems.</z><z id="t1600988615" t="Lucy Wang is it worth to contribute this case to the doc? I think it&apos;s a pretty common"><y>#</y><d>2020-09-24</d><h>23:03</h><w>Lucy Wang</w>is it worth to contribute this case to the doc? I think it&apos;s a pretty common</z><z id="t1600988681" t="Jimmy Miller Definitely :)"><y>#</y><d>2020-09-24</d><h>23:04</h><w>Jimmy Miller</w>Definitely :)</z><z id="t1600988702" t="Jimmy Miller I&apos;ve also found keeping my base case as the first match helps prevent me from doing this."><y>#</y><d>2020-09-24</d><h>23:05</h><w>Jimmy Miller</w>I&apos;ve also found keeping my base case as the first match helps prevent me from doing this.</z><z id="t1600988816" t="Lucy Wang emm ... maybe not, in my example above if I reorder the two clauses, the result would be short circuited by the {:b ?b} match and never gets to the other one"><y>#</y><d>2020-09-24</d><h>23:06</h><w>Lucy Wang</w>emm ... maybe not, in my example above if I reorder the two clauses, the result would be short circuited by the <code>{:b ?b}</code> match and never gets to the other one</z><z id="t1600988916" t="Jimmy Miller Yeah not always the case. Just a general rule of thumb. In this case you definitely can&apos;t do it."><y>#</y><d>2020-09-24</d><h>23:08</h><w>Jimmy Miller</w>Yeah not always the case. Just a general rule of thumb. In this case you definitely can&apos;t do it.</z><z id="t1600989810" t="Jimmy Miller In this case it does avoid the stack overflow and hints at the fact that the patterns are completely overlapping."><y>#</y><d>2020-09-24</d><h>23:23</h><r>Jimmy Miller</r>In this case it does avoid the stack overflow and hints at the fact that the patterns are completely overlapping.</z><z id="t1600989003" t="Lucy Wang sgtm!"><y>#</y><d>2020-09-24</d><h>23:10</h><w>Lucy Wang</w>sgtm!</z><z id="t1601028960" t="Lucy Wang how meander is better than specter when restructuring data https://github.com/redplanetlabs/specter/issues/277#issuecomment-698847230"><y>#</y><d>2020-09-25</d><h>10:16</h><w>Lucy Wang</w>how meander is better than specter when restructuring data <a href="https://github.com/redplanetlabs/specter/issues/277#issuecomment-698847230" target="_blank">https://github.com/redplanetlabs/specter/issues/277#issuecomment-698847230</a></z><z id="t1601052382" t="Jimmy Miller Really love all the comparisons you are doing here. Thanks for doing this :)"><y>#</y><d>2020-09-25</d><h>16:46</h><r>Jimmy Miller</r>Really love all the comparisons you are doing here. Thanks for doing this :)</z><z id="t1601033662" t="Lucy Wang https://www.reddit.com/r/Clojure/comments/izh9o4/specter_vs_meander_vs_handcrafted_code_when/"><y>#</y><d>2020-09-25</d><h>11:34</h><w>Lucy Wang</w><a href="https://www.reddit.com/r/Clojure/comments/izh9o4/specter_vs_meander_vs_handcrafted_code_when/" target="_blank">https://www.reddit.com/r/Clojure/comments/izh9o4/specter_vs_meander_vs_handcrafted_code_when/</a></z><z id="t1601044144" t="Lone Ranger I&apos;m not sure if the manual version there is charitable..."><y>#</y><d>2020-09-25</d><h>14:29</h><w>Lone Ranger</w>I&apos;m not sure if the manual version there is charitable...</z><z id="t1601044321" t="Lucy Wang by charitable you mean ..?"><y>#</y><d>2020-09-25</d><h>14:32</h><w>Lucy Wang</w>by charitable you mean ..?</z><z id="t1601044588" t="Lone Ranger Well I mean without any sort of let or letfn I would think something like this would make a little more sense: (transduce (map (juxt :id #(select-keys % [:pick-me/b :pick-me/c]))) (completing (fn [res [id m]] (assoc res id (into {} (map (fn [[k v]] [(-&gt; k name keyword ) v])) (seq m))))) {} data) "><y>#</y><d>2020-09-25</d><h>14:36</h><w>Lone Ranger</w>Well I mean without any sort of <code>let</code> or <code>letfn</code> I would think something like this would make a little more sense:
<pre>(transduce
 (map (juxt :id #(select-keys % [:pick-me/b :pick-me/c])))
 (completing
  (fn [res [id m]]
    (assoc res id (into {} (map (fn [[k v]] [(-&gt; k name keyword ) v])) (seq m)))))
 {}
 data)</pre>
</z><z id="t1601044845" t="Lucy Wang there may be others like pick-me/d in addition to pick-me/b and pick-me/c , so you can not assume there are only these two such keys"><y>#</y><d>2020-09-25</d><h>14:40</h><w>Lucy Wang</w>there may be others like pick-me/d in addition to pick-me/b and pick-me/c , so you can not assume there are only these two such keys</z><z id="t1601044916" t="Lucy Wang but the point is not how to best implement the handwritten version, but that no hand written version could be as expressive as using meander"><y>#</y><d>2020-09-25</d><h>14:41</h><w>Lucy Wang</w>but the point is not how to best implement the handwritten version, but that no hand written version could be as expressive as using meander</z><z id="t1601044951" t="Lone Ranger Oh for sure. But if you want to make a strong point, you need to pick the strongest possible counterargument"><y>#</y><d>2020-09-25</d><h>14:42</h><w>Lone Ranger</w>Oh for sure.  But if you want to make a strong point, you need to pick the strongest possible counterargument</z><z id="t1601045067" t="Lone Ranger No doubt the meander is more elegant. ~But I would just fear that someone might think the example was constructed to make vanilla clojure seem more inelegant than it is~ (Edit: I&apos;m an idiot, disregard)"><y>#</y><d>2020-09-25</d><h>14:44</h><w>Lone Ranger</w>No doubt the meander is more elegant.  ~But I would just fear that someone might think the example was constructed to make vanilla clojure seem more inelegant than it is~ (Edit: I&apos;m an idiot, disregard)</z><z id="t1601045132" t="Lucy Wang tbh the hand-crafted code is almost the best version I could write .."><y>#</y><d>2020-09-25</d><h>14:45</h><w>Lucy Wang</w>tbh the hand-crafted code is almost the best version I could write ..</z><z id="t1601045255" t="Lone Ranger 😬 I&apos;m sorry, I&apos;m an asshole, I didn&apos;t realize you wrote that"><y>#</y><d>2020-09-25</d><h>14:47</h><w>Lone Ranger</w><b>😬</b> I&apos;m sorry, I&apos;m an asshole, I didn&apos;t realize you wrote that</z><z id="t1601045294" t="Lucy Wang nvm 😄"><y>#</y><d>2020-09-25</d><h>14:48</h><w>Lucy Wang</w>nvm <b>😄</b></z><z id="t1601045299" t="Lone Ranger Well I can&apos;t use specter at all so maybe I was just trying to make myself feel better, I didn&apos;t mean for it to come across like that 🙏"><y>#</y><d>2020-09-25</d><h>14:48</h><w>Lone Ranger</w>Well I can&apos;t use specter at all so maybe I was just trying to make myself feel better, I didn&apos;t mean for it to come across like that <b>🙏</b></z><z id="t1601045422" t="Lone Ranger 🙇"><y>#</y><d>2020-09-25</d><h>14:50</h><w>Lone Ranger</w><b>🙇</b></z><z id="t1601049441" t="ribelo I&apos;m trying to copy the functionality and syntax of metosin/malli using meander. However, I came across behavior that I don&apos;t understand. I probably don&apos;t know how macros work, but I can&apos;t figure it out myself; ("><y>#</y><d>2020-09-25</d><h>15:57</h><w>ribelo</w>I&apos;m trying to copy the functionality and syntax of <code>metosin/malli</code> using meander. However, I came across behavior that I don&apos;t understand.

I probably don&apos;t know how macros work, but I can&apos;t figure it out myself; (</z><z id="t1601049525" t="ribelo (require &apos;[meander.epsilon :as r]) (require &apos;[taoensso.encore :as e]) (r/defsyntax -&gt;schema [schema] (r/match schema [:map . (r/cata !x) ...] (r/subst {&amp; [!x ...]}) [(r/or (r/pred keyword? ?k) (r/pred string? ?k)) (r/cata ?v)] {?k ?v} ?f `(r/pred ~?f))) (r/match {:a 1.0 :b 1.0} (-&gt;schema [:map [:a double?] [:b double?]]) true _ false) ;; =&gt; true (def x [:map [:a double?] [:b double?]]) (e/caught-error-data (r/match {:a 1.0 :b 1.0} (-&gt;schema x) true _ false)) ;; =&gt; {:err-type java.lang.IllegalArgumentException, ;; :err-msg &quot;Key must be integer&quot;, ;; :err-cause nil}"><y>#</y><d>2020-09-25</d><h>15:58</h><w>ribelo</w><pre>(require &apos;[meander.epsilon :as r])
(require &apos;[taoensso.encore :as e])

(r/defsyntax -&gt;schema [schema]
  (r/match schema
    [:map . (r/cata !x) ...] (r/subst {&amp; [!x ...]})
    [(r/or (r/pred keyword? ?k)
           (r/pred string? ?k))
     (r/cata ?v)] {?k ?v}

    ?f `(r/pred ~?f)))

(r/match {:a 1.0 :b 1.0}
  (-&gt;schema [:map [:a double?] [:b double?]]) true
  _                                           false)
;; =&gt; true

(def x [:map [:a double?] [:b double?]])

(e/caught-error-data
  (r/match {:a 1.0 :b 1.0}
    (-&gt;schema x)  true
    _             false))
;; =&gt; {:err-type  java.lang.IllegalArgumentException,
;;     :err-msg   &quot;Key must be integer&quot;,
;;     :err-cause nil}</pre></z><z id="t1601051771" t="Jimmy Miller So I&apos;m not sure how to solve this problem. I&apos;m trying to play around with it. But what is happening is that the x there is actually just the symbol x . It isn&apos;t the value sliced in. That is what is causing the error. Trying to think about how you would do that, not really sure."><y>#</y><d>2020-09-25</d><h>16:36</h><r>Jimmy Miller</r>So I&apos;m not sure how to solve this problem. I&apos;m trying to play around with it. But what is happening is that the <code>x</code> there is actually just the symbol <code>x</code>. It isn&apos;t the value sliced in. That is what is causing the error. Trying to think about how you would do that, not really sure.</z><z id="t1601051890" t="noprompt The trouble here is that the value x in (-&gt;schema x) is not passed to the -&gt;schema syntax extension function, the symbol x is. So what happens is that the extension expands to (x {:a 1.0 ,,,}) or ([:map [:a double?] [:b double?]] {:a 1.0 ,,,}) and thats why you get the error. If you want the extension to get the value you’ll need to use eval ."><y>#</y><d>2020-09-25</d><h>16:38</h><r>noprompt</r>The trouble here is that the value <code>x</code> in
<pre>(-&gt;schema x)</pre>
is not passed to the <code>-&gt;schema</code> syntax extension function, the symbol <code>x</code> is. So what happens is that the extension expands to <code>(x {:a 1.0 ,,,})</code> or

<pre>([:map [:a double?] [:b double?]] {:a 1.0 ,,,})</pre>
and thats why you get the error. If you want the extension to get the value you’ll need to use <code>eval</code>.</z><z id="t1601051931" t="Jimmy Miller (m/match {:a 1.0 :b 1.0} (-&gt;schema #&apos;x) true _ false) Seems to work."><y>#</y><d>2020-09-25</d><h>16:38</h><r>Jimmy Miller</r><pre>(m/match {:a 1.0 :b 1.0}
  (-&gt;schema #&apos;x)  true
  _             false)</pre>
Seems to work.</z><z id="t1601052774" t="ribelo [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] I don&apos;t know why, but it doesn&apos;t work for me. Exactly the same error."><y>#</y><d>2020-09-25</d><h>16:52</h><r>ribelo</r><a>@U5K8NTHEZ</a> I don&apos;t know why, but it doesn&apos;t work for me. Exactly the same error.</z><z id="t1601052832" t="ribelo [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] I don&apos;t know where to use eval , could you give an example? EDIT: Already found, it works, thanks! EDIT: ... and it&apos;s incredibly slow. It&apos;s a pity."><y>#</y><d>2020-09-25</d><h>16:53</h><r>ribelo</r><a>@U06MDAPTP</a> I don&apos;t know where to use <code>eval</code>, could you give an example?

EDIT:
Already found, it works, thanks!

EDIT:
... and it&apos;s incredibly slow. It&apos;s a pity.</z><z id="t1601053457" t="Jimmy Miller Sorry, bad repl state"><y>#</y><d>2020-09-25</d><h>17:04</h><r>Jimmy Miller</r>Sorry, bad repl state</z><z id="t1601053569" t="Jimmy Miller What did you end up doing? What performance are you getting? What would you expect it to be?"><y>#</y><d>2020-09-25</d><h>17:06</h><r>Jimmy Miller</r>What did you end up doing? What performance are you getting? What would you expect it to be?</z><z id="t1601053885" t="ribelo Meander is amazing and I play without any purpose. I check how little code is needed to get functionality of other libraries."><y>#</y><d>2020-09-25</d><h>17:11</h><r>ribelo</r>Meander is amazing and I play without any purpose. I check how little code is needed to get functionality of other libraries.</z><z id="t1601053917" t="ribelo When I say it&apos;s incredibly slow, I meant eval"><y>#</y><d>2020-09-25</d><h>17:11</h><r>ribelo</r>When I say it&apos;s incredibly slow, I meant <code>eval</code></z><z id="t1601054143" t="Jimmy Miller Glad to hear 🙂 Just always on the look out for potential performance issues. Once jit kicks in, I get the exact same performance of these two (m/defsyntax -&gt;schema [schema] (m/match (eval schema) [:map . (m/cata !x) ...] (m/subst {&amp; [!x ...]}) [(m/or (m/pred keyword? ?k) (m/pred string? ?k)) (m/cata ?v)] {?k ?v} ?f `(m/pred ~?f))) (def x [:map [:a double?] [:b double?]]) (defn validate-1 [data] (and (map? data) (double? (:a data)) (double? (:b data)))) (defn validate-2 [data] (m/match {:a 1.0 :b 1.0} (-&gt;schema x) true _ false))"><y>#</y><d>2020-09-25</d><h>17:15</h><r>Jimmy Miller</r>Glad to hear <b>🙂</b> Just always on the look out for potential performance issues.

Once jit kicks in, I get the exact same performance of these two

<pre>(m/defsyntax -&gt;schema [schema]
  (m/match (eval schema)
    [:map . (m/cata !x) ...] (m/subst {&amp; [!x ...]})
    [(m/or (m/pred keyword? ?k)
           (m/pred string? ?k))
     (m/cata ?v)] {?k ?v}
    ?f `(m/pred ~?f)))

(def x [:map [:a double?] [:b double?]])

(defn validate-1 [data]
   (and (map? data)
        (double? (:a data))
        (double? (:b data))))

(defn validate-2 [data]
  (m/match {:a 1.0 :b 1.0}
    (-&gt;schema x)  true
    _             false))</pre></z><z id="t1601054430" t="ribelo So it seems that I used eval not in the right place. ; )"><y>#</y><d>2020-09-25</d><h>17:20</h><r>ribelo</r>So it seems that I used <code>eval</code> not in the right place. ; )</z><z id="t1601055945" t="ribelo However, it seems that a more generic function cannot be done. An exception Can&apos;t eval locals is thrown."><y>#</y><d>2020-09-25</d><h>17:45</h><r>ribelo</r>However, it seems that a more generic function cannot be done. An exception <code>Can&apos;t eval locals</code> is thrown.</z><z id="t1601055963" t="ribelo (r/defsyntax -&gt;schema [schema] (r/match (eval schema) [:map . (r/cata !x) ...] (r/subst {&amp; [!x ...]}) [(r/or (r/pred keyword? ?k) (r/pred string? ?k)) (r/cata ?v)] {?k ?v} ?f `(r/pred ~?f))) (defn valid? [schema data] (r/match data (-&gt;schema schema) true _ false))"><y>#</y><d>2020-09-25</d><h>17:46</h><r>ribelo</r><pre>(r/defsyntax -&gt;schema [schema]
  (r/match (eval schema)
    [:map . (r/cata !x) ...] (r/subst {&amp; [!x ...]})
    [(r/or (r/pred keyword? ?k)
           (r/pred string? ?k))
     (r/cata ?v)] {?k ?v}
    ?f `(r/pred ~?f)))

(defn valid? [schema data]
  (r/match data
    (-&gt;schema schema) true
    _ false))</pre></z><z id="t1601056071" t="Jimmy Miller Yeah. -&gt;schema is being expanded at compile time. And schema isn&apos;t known at that point."><y>#</y><d>2020-09-25</d><h>17:47</h><r>Jimmy Miller</r>Yeah. -&gt;schema is being expanded at compile time. And schema isn&apos;t known at that point.</z><z id="t1601056103" t="Jimmy Miller We have plans for an interpreter that would allow more dynamic things. But obviously that would be slower."><y>#</y><d>2020-09-25</d><h>17:48</h><r>Jimmy Miller</r>We have plans for an interpreter that would allow more dynamic things. But obviously that would be slower.</z><z id="t1601056238" t="ribelo It is still awesome"><y>#</y><d>2020-09-25</d><h>17:50</h><r>ribelo</r>It is still awesome</z><z id="t1601050927" t="noprompt [:attrs {:href &quot;/_/_/users/UP90Q48J3&quot;}] FYI there is m/keyword for pattern matching on keywords. 🙂 (m/rewrite data [{:id !id (m/keyword &quot;pick-me&quot; !k) (m/some !v)} ...] {&amp; ([!id {!k !v}] ...)}) "><y>#</y><d>2020-09-25</d><h>16:22</h><w>noprompt</w><a>@wxitb2017</a> FYI there is <code>m/keyword</code> for pattern matching on keywords. <b>🙂</b>

<pre>(m/rewrite data
  [{:id !id (m/keyword &quot;pick-me&quot; !k) (m/some !v)} ...]
  {&amp; ([!id {!k !v}] ...)})</pre>
</z><z id="t1601052209" t="Jimmy Miller You do have to add m/keyword around the !k to get the same output, just fyi. (m/rewrite data [{:id !id (m/keyword &quot;pick-me&quot; !k) (m/some !v)} ...] {&amp; ([!id {(m/keyword !k) !v}] ...)})"><y>#</y><d>2020-09-25</d><h>16:43</h><r>Jimmy Miller</r>You do have to add m/keyword around the !k to get the same output, just fyi.

<pre>(m/rewrite data
  [{:id !id (m/keyword &quot;pick-me&quot; !k) (m/some !v)} ...]
  {&amp; ([!id {(m/keyword !k) !v}] ...)})</pre></z><z id="t1601082312" t="Lucy Wang Thanks! I have updated the code in the posts with this better approach."><y>#</y><d>2020-09-26</d><h>01:05</h><r>Lucy Wang</r>Thanks! I have updated the code in the posts with this better approach.</z><z id="t1601160382" t="ikrimael fluff: meander has made jumping back to a side project painless after 2+ months of being away"><y>#</y><d>2020-09-26</d><h>22:46</h><w>ikrimael</w>fluff: meander has made jumping back to a side project painless after 2+ months of being away</z><z id="t1601160418" t="ikrimael the only downside is the painful reminder of what i&apos;m missing in C++ 😛"><y>#</y><d>2020-09-26</d><h>22:46</h><w>ikrimael</w>the only downside is the painful reminder of what i&apos;m missing in C++ <b>😛</b></z><z id="t1601160438" t="ikrimael is there a &quot;changelog&quot; somewhere i can skim to see what the new versions changed?"><y>#</y><d>2020-09-26</d><h>22:47</h><w>ikrimael</w>is there a &quot;changelog&quot; somewhere i can skim to see what the new versions changed?</z><z id="t1601160669" t="ikrimael (or if there&apos;s a way to access this channel&apos;s history, i can go back and read. vaguely recall other slacks figuring out a way to archive)"><y>#</y><d>2020-09-26</d><h>22:51</h><w>ikrimael</w>(or if there&apos;s a way to access this channel&apos;s history, i can go back and read. vaguely recall other slacks figuring out a way to archive)</z><z id="t1601160896" t="Jimmy Miller I sadly don&apos;t think we have either. There haven&apos;t been a ton of changes. Taking a look at recent prs should give you a decent picture of what has changed."><y>#</y><d>2020-09-26</d><h>22:54</h><w>Jimmy Miller</w>I sadly don&apos;t think we have either. There haven&apos;t been a ton of changes. Taking a look at recent prs should give you a decent picture of what has changed.</z><z id="t1601168737" t="Lucy Wang [:attrs {:href &quot;/_/_/users/U014X1MN7MM&quot;}] there are two ways to access the chat logs: 1. use the archive site, e.g. https://clojurians-log.clojureverse.org/meander/2020-03-18 2. use the slack acrhive stream on zulip: https://clojurians.zulipchat.com/#narrow/stream/180378-slack-archive/topic/meander"><y>#</y><d>2020-09-27</d><h>01:05</h><w>Lucy Wang</w><a>@e749</a> there are two ways to access the chat logs:
1. use the archive site, e.g. <a href="https://clojurians-log.clojureverse.org/meander/2020-03-18" target="_blank">https://clojurians-log.clojureverse.org/meander/2020-03-18</a>
2. use the slack acrhive stream on zulip: <a href="https://clojurians.zulipchat.com/#narrow/stream/180378-slack-archive/topic/meander" target="_blank">https://clojurians.zulipchat.com/#narrow/stream/180378-slack-archive/topic/meander</a></z><z id="t1601302202" t="Lucy Wang the beauty of extracting JIRA api response with meander, really ❤️ it (defn format-issues [issues] (me/search issues (me/scan {:fields {:summary ?summary :assignee {:displayName ?assignee} :status {:name ?status}}}) {:summary ?summary :assignee ?assignee :status ?status}))"><y>#</y><d>2020-09-28</d><h>14:10</h><w>Lucy Wang</w>the beauty of extracting JIRA api response with meander, really <b>❤️</b> it
<pre>(defn format-issues [issues]
  (me/search issues
    (me/scan {:fields {:summary ?summary
                       :assignee {:displayName ?assignee}
                       :status {:name ?status}}})
    {:summary ?summary
     :assignee ?assignee
     :status ?status}))</pre></z><z id="t1601304898" t="Lucy Wang and now I have too handle some nils ... (defn format-issues [issues] (me/search issues (me/scan {:fields {:summary ?summary :assignee (me/or (me/let [?assignee nil] nil) {:displayName ?assignee}) :status {:name ?status}}}) {:summary ?summary :assignee ?assignee :status ?status}))"><y>#</y><d>2020-09-28</d><h>14:54</h><w>Lucy Wang</w>and now I have too handle some nils ...
<pre>(defn format-issues [issues]
  (me/search issues
    (me/scan {:fields {:summary ?summary
                       :assignee (me/or (me/let [?assignee nil]
                                          nil)
                                        {:displayName ?assignee})
                       :status {:name ?status}}})
    {:summary ?summary
     :assignee ?assignee
     :status ?status}))</pre></z><z id="t1601307180" t="Jimmy Miller I know you got a nice little defsyntax for this. Just wanted to point out this little and idiom. (defn format-issues [issues] (m/search issues (m/scan {:fields {:summary ?summary :assignee (m/or (m/and nil ?assignee) {:displayName ?assignee}) :status {:name ?status}}}) {:summary ?summary :assignee ?assignee :status ?status}))"><y>#</y><d>2020-09-28</d><h>15:33</h><r>Jimmy Miller</r>I know you got a nice little defsyntax for this. Just wanted to point out this little <code>and</code> idiom.

<pre>(defn format-issues [issues]
  (m/search issues
    (m/scan {:fields {:summary ?summary
                      :assignee (m/or (m/and nil ?assignee)
                                      {:displayName ?assignee})
                      :status {:name ?status}}})
             {:summary ?summary
              :assignee ?assignee
              :status ?status}))</pre></z><z id="t1601341707" t="Lucy Wang TIL +1! Thanks Jimmy!"><y>#</y><d>2020-09-29</d><h>01:08</h><r>Lucy Wang</r>TIL +1! Thanks Jimmy!</z><z id="t1601305519" t="Lucy Wang time for some defsyntax! (defn logic-variable? [x] (and (symbol? x) (str/starts-with? (name x) &quot;?&quot;))) ;; (logic-variable? &apos;?x) ;; =&gt; true (defn extract-logic-variables [m] (sp/select (sp/walker logic-variable?) m)) ;; (extract-logic-variables &apos;{:a ?a :b ?b :c &quot;?c&quot; :d :?d}) ;; =&gt; [?a ?b] (me/defsyntax maybe-map [m] (if (me/match-syntax? &amp;env) `(me/or (me/let ~(-&gt; (extract-logic-variables m) (interleave (repeat nil)) vec) nil) ~m) &amp;form)) (defn format-issues [issues] (me/search issues (me/scan {:fields {:summary ?summary :assignee (maybe-map {:displayName ?assignee}) :status {:name ?status}}}) {:summary ?summary :assignee ?assignee :status ?status}))"><y>#</y><d>2020-09-28</d><h>15:05</h><w>Lucy Wang</w>time for some defsyntax!
<pre>(defn logic-variable? [x]
  (and (symbol? x)
       (str/starts-with? (name x) &quot;?&quot;)))

;; (logic-variable? &apos;?x)
;; =&gt; true

(defn extract-logic-variables [m]
  (sp/select (sp/walker logic-variable?) m))

;; (extract-logic-variables &apos;{:a ?a :b ?b :c &quot;?c&quot; :d :?d})
;; =&gt; [?a ?b]

(me/defsyntax maybe-map
  [m]
  (if (me/match-syntax? &amp;env)
    `(me/or
       (me/let ~(-&gt;
                 (extract-logic-variables m)
                 (interleave (repeat nil))
                 vec)
         nil)
       ~m)
    &amp;form))

(defn format-issues [issues]
  (me/search issues
    (me/scan {:fields {:summary ?summary
                       :assignee (maybe-map {:displayName ?assignee})
                       :status {:name ?status}}})
    {:summary ?summary
     :assignee ?assignee
     :status ?status}))</pre></z><z id="t1601308143" t="Lone Ranger I&apos;m curious, has anyone put any thought into a symbolic syntax for Meanderlang?"><y>#</y><d>2020-09-28</d><h>15:49</h><w>Lone Ranger</w>I&apos;m curious, has anyone put any thought into a symbolic syntax for Meanderlang?</z><z id="t1601308291" t="Lone Ranger The two closest cousins I can find are Dyalog APL and the mathematical field of topology"><y>#</y><d>2020-09-28</d><h>15:51</h><w>Lone Ranger</w>The two closest cousins I can find are Dyalog APL and the mathematical field of topology</z><z id="t1601308361" t="Lone Ranger Or maybe those things like me/scan macroexpand into a more verbose data literal syntax?"><y>#</y><d>2020-09-28</d><h>15:52</h><w>Lone Ranger</w>Or maybe those things like <code>me/scan</code> macroexpand into a more verbose data literal syntax?</z><z id="t1601327618" t="noprompt [:attrs {:href &quot;/_/_/users/U3BALC2HH&quot;}] Yes. me/scan essentially expands to (m/seqable _ … p1 ,,, pN . _ ...) which expands to (m/pred seqable? (m/app seq (_ ... p1 ,,, pN . _ ...)) "><y>#</y><d>2020-09-28</d><h>21:13</h><r>noprompt</r><a>@U3BALC2HH</a> Yes. <code>me/scan</code> essentially expands to
<pre>(m/seqable _ … p1 ,,, pN . _ ...)</pre>
which expands to
<pre>(m/pred seqable? (m/app seq (_ ... p1 ,,, pN . _ ...))</pre>
</z><z id="t1601327704" t="noprompt Originally, me/scan expanded to (m/or (_ ... p1 ,,, pN . _ ...) [_ ... p1 ,,, pN . _ ...)) but this expansion could result in large code explosions which is a problem which still needs to be addressed."><y>#</y><d>2020-09-28</d><h>21:15</h><r>noprompt</r>Originally, <code>me/scan</code> expanded to
<pre>(m/or (_ ... p1 ,,, pN . _ ...)
      [_ ... p1 ,,, pN . _ ...))</pre>
but this expansion could result in large code explosions which is a problem which still needs to be addressed.</z><z id="t1601361870" t="Lucy Wang Took me really a long time, but still could not figure out the problem https://github.com/noprompt/meander/issues/141"><y>#</y><d>2020-09-29</d><h>06:44</h><w>Lucy Wang</w>Took me really a long time, but still could not figure out the problem <a href="https://github.com/noprompt/meander/issues/141" target="_blank">https://github.com/noprompt/meander/issues/141</a></z><z id="t1601395457" t="noprompt [:attrs {:href &quot;/_/_/users/UP90Q48J3&quot;}] It’s perfectly fine to cross post here and on Github. 👍"><y>#</y><d>2020-09-29</d><h>16:04</h><w>noprompt</w><a>@wxitb2017</a> It’s perfectly fine to cross post here and on Github. <b>👍</b></z><z id="t1601401040" t="dominicm ./github noprompt/meander"><y>#</y><d>2020-09-29</d><h>17:37</h><w>dominicm</w>./github noprompt/meander</z><z id="t1601401050" t="dominicm (It&apos;s on this slack)"><y>#</y><d>2020-09-29</d><h>17:37</h><w>dominicm</w>(It&apos;s on this slack)</z><z id="t1601403857" t="noprompt [:attrs {:href &quot;/_/_/users/U06S1EJPL&quot;}] I think that issue may be similar to the one you posted. I’m taking a look (finally)."><y>#</y><d>2020-09-29</d><h>18:24</h><w>noprompt</w><a>@timothypratley</a> I think that issue may be similar to the one you posted. I’m taking a look (finally).</z></g><g id="s6"><z id="t1601403908" t="noprompt It would be great if the Github desktop app showed issues too."><y>#</y><d>2020-09-29</d><h>18:25</h><w>noprompt</w>It would be great if the Github desktop app showed issues too.</z><z id="t1601407617" t="chucklehead I think I hit this as well with a few of the approaches I tried when processing parsed xml with meander, e.g. trying to extract an optional attribute from an optional element or nil. "><y>#</y><d>2020-09-29</d><h>19:26</h><w>chucklehead</w>I think I hit this as well with a few of the approaches I tried when processing parsed xml with meander, e.g. trying to extract an optional attribute from an optional element or nil. </z><z id="t1601408296" t="Jimmy Miller I was trying to multi-task and added some confusing comments on the issue. I actually can&apos;t get this to stackoverflow, so it may be related to the compiling issue with a smaller stack amount."><y>#</y><d>2020-09-29</d><h>19:38</h><w>Jimmy Miller</w>I was trying to multi-task and added some confusing comments on the issue. I actually can&apos;t get this to stackoverflow, so it may be related to the compiling issue with a smaller stack amount.</z><z id="t1601411256" t="noprompt [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] Yeah, on the [:attrs {:href &quot;/_/_/users/U06S1EJPL&quot;}] issue reducing the stack size produced the SO. I’m getting the SO with Lucys example without any modifications to my stack size."><y>#</y><d>2020-09-29</d><h>20:27</h><w>noprompt</w><a>@jimmy</a> Yeah, on the <a>@timothypratley</a> issue reducing the stack size produced the SO. I’m getting the SO with Lucys example without any modifications to my stack size.</z><z id="t1601411291" t="Jimmy Miller How are you running the code? I don&apos;t think I&apos;ve modified my stack size and I have no problem."><y>#</y><d>2020-09-29</d><h>20:28</h><w>Jimmy Miller</w>How are you running the code? I don&apos;t think I&apos;ve modified my stack size and I have no problem.</z><z id="t1601411301" t="noprompt Let me know if you figure anything out, I’m going back and forth between parenting and looking at it. 😐"><y>#</y><d>2020-09-29</d><h>20:28</h><w>noprompt</w>Let me know if you figure anything out, I’m going back and forth between parenting and looking at it. <b>😐</b></z><z id="t1601411392" t="Jimmy Miller Nevermind if I run it in a fresh clj thing I do get the stackoverflow. Must have increase by stack size in cider."><y>#</y><d>2020-09-29</d><h>20:29</h><w>Jimmy Miller</w>Nevermind if I run it in a fresh clj thing I do get the stackoverflow. Must have increase by stack size in cider.</z><z id="t1601411543" t="noprompt I just copy/pasted her example and tweaked the pattern to be (m/scan (m/or (m/and ?b1 ?b2) (m/and ?b1 (m/or _ ?b2)))) "><y>#</y><d>2020-09-29</d><h>20:32</h><w>noprompt</w>I just copy/pasted her example and tweaked the pattern to be
<pre>(m/scan (m/or (m/and ?b1 ?b2)
               (m/and ?b1 (m/or _ ?b2))))</pre>
</z><z id="t1601411637" t="noprompt It seems like has something to do with the new subsequence node."><y>#</y><d>2020-09-29</d><h>20:33</h><w>noprompt</w>It seems like has something to do with the new subsequence node.</z><z id="t1601412135" t="noprompt Nope."><y>#</y><d>2020-09-29</d><h>20:42</h><w>noprompt</w>Nope.</z><z id="t1601412156" t="noprompt (_ ... (m/or (?b1 (m/or _))) . _ ...) This is the smallest example I have so far."><y>#</y><d>2020-09-29</d><h>20:42</h><w>noprompt</w><pre>(_ ... (m/or (?b1 (m/or _))) . _ ...)</pre>
This is the smallest example I have so far.</z><z id="t1601413541" t="noprompt OK… I think it did have something to do with the new subsequence node."><y>#</y><d>2020-09-29</d><h>21:05</h><w>noprompt</w>OK… I think it did have something to do with the new subsequence node.</z><z id="t1601413716" t="noprompt It didn’t implement meander.syntax.epsilon/walk ."><y>#</y><d>2020-09-29</d><h>21:08</h><w>noprompt</w>It didn’t implement <code>meander.syntax.epsilon/walk</code>.</z><z id="t1601413842" t="Jimmy Miller We have a non-recur tail recursion in meander epsilon compile. Can&apos;t play with it right now. But that is some low hanging fruit to fix."><y>#</y><d>2020-09-29</d><h>21:10</h><w>Jimmy Miller</w>We have a non-recur tail recursion in meander epsilon compile. Can&apos;t play with it right now. But that is some low hanging fruit to fix.</z><z id="t1601438724" t="noprompt I missed this earlier. Yeah, if you can pick that fruit that’d be great."><y>#</y><d>2020-09-30</d><h>04:05</h><r>noprompt</r>I missed this earlier. Yeah, if you can pick that fruit that’d be great.</z><z id="t1601414432" t="noprompt Is anyone able to try bin/test on the branch corresponding to this PR? https://github.com/noprompt/meander/pull/142"><y>#</y><d>2020-09-29</d><h>21:20</h><w>noprompt</w>Is anyone able to try <code>bin/test</code> on the branch corresponding to this PR? <a href="https://github.com/noprompt/meander/pull/142" target="_blank">https://github.com/noprompt/meander/pull/142</a></z><z id="t1601414470" t="noprompt CI says it passes but my local machine is failing on the cljs tests."><y>#</y><d>2020-09-29</d><h>21:21</h><w>noprompt</w>CI says it passes but my local machine is failing on the cljs tests.</z><z id="t1601433391" t="Lucy Wang Both CLJ &amp; CLJS tests of GH-141 branch passes on my dev machine."><y>#</y><d>2020-09-30</d><h>02:36</h><w>Lucy Wang</w>Both CLJ &amp; CLJS tests of GH-141 branch passes on my dev machine.</z><z id="t1601438105" t="noprompt Thanks Lucy. I’m going to add one more test and then I will merge the branch once it passes CI."><y>#</y><d>2020-09-30</d><h>03:55</h><w>noprompt</w>Thanks Lucy. I’m going to add one more test and then I will merge the branch once it passes CI.</z><z id="t1601438156" t="noprompt Tim, I haven’t had a chance to run this against the case you have an open ticket for. I’m hoping I’ll have a chance tonight."><y>#</y><d>2020-09-30</d><h>03:55</h><w>noprompt</w>Tim, I haven’t had a chance to run this against the case you have an open ticket for. I’m hoping I’ll have a chance tonight.</z><z id="t1601445819" t="noprompt https://clojars.org/meander/epsilon/versions/0.0.502"><y>#</y><d>2020-09-30</d><h>06:03</h><w>noprompt</w><a href="https://clojars.org/meander/epsilon/versions/0.0.502" target="_blank">https://clojars.org/meander/epsilon/versions/0.0.502</a></z><z id="t1601445886" t="noprompt ☝️ Fixes the SO from GH-141"><y>#</y><d>2020-09-30</d><h>06:04</h><w>noprompt</w><b>☝️</b> Fixes the SO from GH-141</z><z id="t1601445899" t="noprompt I don’t think this fixes the other SO ticket but I haven’t checked yet."><y>#</y><d>2020-09-30</d><h>06:04</h><w>noprompt</w>I don’t think this fixes the other SO ticket but I haven’t checked yet.</z><z id="t1601446005" t="noprompt Looks like, no, it doesn’t."><y>#</y><d>2020-09-30</d><h>06:06</h><w>noprompt</w>Looks like, no, it doesn’t.</z><z id="t1601446024" t="noprompt I’ll start investigating it tomorrow."><y>#</y><d>2020-09-30</d><h>06:07</h><w>noprompt</w>I’ll start investigating it tomorrow.</z><z id="t1601484164" t="Jimmy Miller Just pushed the tail recursive non-recur and now the other one doesn&apos;t stack overflow with a stack of 512k. clj -J-Xss512k -Sdeps &apos;{:deps {meander/epsilon {:local/root &quot;.&quot;}}}&apos; -e &quot;(require &apos;[meander.epsilon :as m]) (defn z [] (m/rewrite {} (loop* [?seq (clojure.core/seq ?xs) ?chunk nil ?chunkn 0 ?i 0] (if (clojure.lang.Numbers/lt ?i ?chunkn) (let* [(m/and ?sym (m/app always-meta {:tag ?tag :type ?type})) (.nth ?chunk ?i)] (do ?body (recur ?seq ?chunk ?chunkn (clojure.lang.Numbers/unchecked_inc ?i)))) (let* [?as (clojure.core/seq ?seq)] (if ?as (let* [?bs ?as] (if (clojure.core/chunked-seq? ?bs) (let* [?cs (clojure.core/chunk-first ?bs)] (recur (clojure.core/chunk-rest ?bs) ?cs (clojure.lang.RT/intCast (clojure.lang.RT/count ?cs)) (clojure.lang.RT/intCast 0))) (let* [?sym (clojure.core/first ?bs)] (do ?body (recur (clojure.core/next ?bs) nil 0 0))))))))) (foreach ~(or ?type ?tag) ?sym ?xs (m/app inner-form ?body))))&quot; If you have lastest meander locally you can run this from its root. I actually tested and with this change 511k is the smallest you can go and still compile it. Any lower it stack overflows."><y>#</y><d>2020-09-30</d><h>16:42</h><r>Jimmy Miller</r>Just pushed the tail recursive non-recur and now the other one doesn&apos;t stack overflow with a stack of 512k.

<pre>clj -J-Xss512k -Sdeps &apos;{:deps {meander/epsilon {:local/root &quot;.&quot;}}}&apos; -e &quot;(require &apos;[meander.epsilon :as m])  (defn z [] (m/rewrite {} (loop* [?seq (clojure.core/seq ?xs) ?chunk nil ?chunkn 0 ?i 0] (if (clojure.lang.Numbers/lt ?i ?chunkn) (let* [(m/and ?sym (m/app always-meta {:tag  ?tag :type ?type})) (.nth ?chunk ?i)] (do ?body (recur ?seq ?chunk ?chunkn (clojure.lang.Numbers/unchecked_inc ?i)))) (let* [?as (clojure.core/seq ?seq)] (if ?as (let* [?bs ?as] (if (clojure.core/chunked-seq? ?bs) (let* [?cs (clojure.core/chunk-first ?bs)] (recur (clojure.core/chunk-rest ?bs) ?cs (clojure.lang.RT/intCast (clojure.lang.RT/count ?cs)) (clojure.lang.RT/intCast 0))) (let* [?sym (clojure.core/first ?bs)] (do ?body (recur (clojure.core/next ?bs) nil 0 0))))))))) (foreach ~(or ?type ?tag) ?sym ?xs (m/app inner-form ?body))))&quot;</pre>
If you have lastest meander locally you can run this from its root.

I actually tested and with this change 511k is the smallest you can go and still compile it. Any lower it stack overflows.</z><z id="t1601484219" t="Jimmy Miller I was hoping something like kondo would give a warning about this. But it doesn&apos;t. If anyone knows a tool that can lint non-recur tail recursion, that would be great to find."><y>#</y><d>2020-09-30</d><h>16:43</h><r>Jimmy Miller</r>I was hoping something like kondo would give a warning about this. But it doesn&apos;t. If anyone knows a tool that can lint non-recur tail recursion, that would be great to find.</z><z id="t1601485239" t="Jimmy Miller We could probably trampoline walk/prewalk/postwalk and get our stack size much smaller. Obviously with a macroexpansion performance hit."><y>#</y><d>2020-09-30</d><h>17:00</h><r>Jimmy Miller</r>We could probably trampoline walk/prewalk/postwalk and get our stack size much smaller. Obviously with a macroexpansion performance hit.</z><z id="t1601487005" t="Jimmy Miller As I&apos;m looking at things, walk seems to be the thing that grows our stack most often. So if we want to reduce it, making some walk that didn&apos;t grow the stack would definitely be the approach we should take. Just fyi, default stack of 32bit is 320k default for 64bit is 1024k."><y>#</y><d>2020-09-30</d><h>17:30</h><r>Jimmy Miller</r>As I&apos;m looking at things, walk seems to be the thing that grows our stack most often. So if we want to reduce it, making some walk that didn&apos;t grow the stack would definitely be the approach we should take.

Just fyi, default stack of 32bit is 320k default for 64bit is 1024k.</z><z id="t1601489988" t="noprompt Thanks for looking at this!"><y>#</y><d>2020-09-30</d><h>18:19</h><r>noprompt</r>Thanks for looking at this!</z><z id="t1601490257" t="noprompt We could trade stack for heap and use a zipper approach but that implies filling in blanks for the usual zipper stuff."><y>#</y><d>2020-09-30</d><h>18:24</h><r>noprompt</r>We could trade stack for heap and use a zipper approach but that implies filling in blanks for the usual zipper stuff.</z><z id="t1601490382" t="noprompt I think ref substitution is where we end up eating the most stack."><y>#</y><d>2020-09-30</d><h>18:26</h><r>noprompt</r>I think ref substitution is where we end up eating the most stack.</z><z id="t1601728458" t="Lucy Wang https://github.com/noprompt/meander/pull/144/files"><y>#</y><d>2020-10-03</d><h>12:34</h><w>Lucy Wang</w><a href="https://github.com/noprompt/meander/pull/144/files" target="_blank">https://github.com/noprompt/meander/pull/144/files</a></z><z id="t1601728471" t="Lucy Wang doc about the &quot;maybe&quot; pattern"><y>#</y><d>2020-10-03</d><h>12:34</h><w>Lucy Wang</w>doc about the &quot;maybe&quot; pattern</z><z id="t1601737544" t="Lucy Wang Another caveat that taught me a lesson, with the cost of half an hour debugging https://github.com/noprompt/meander/issues/145"><y>#</y><d>2020-10-03</d><h>15:05</h><w>Lucy Wang</w>Another caveat that taught me a lesson, with the cost of half an hour debugging <a href="https://github.com/noprompt/meander/issues/145" target="_blank">https://github.com/noprompt/meander/issues/145</a></z><z id="t1601943501" t="noprompt This has been fixed in the newest release"><y>#</y><d>2020-10-06</d><h>00:18</h><r>noprompt</r>This has been fixed in the newest release</z><z id="t1601742922" t="noprompt https://clojars.org/meander/epsilon/versions/0.0.508"><y>#</y><d>2020-10-03</d><h>16:35</h><w>noprompt</w><a href="https://clojars.org/meander/epsilon/versions/0.0.508" target="_blank">https://clojars.org/meander/epsilon/versions/0.0.508</a></z><z id="t1601742942" t="noprompt ☝️ This fixes a bug with set patterns I came across last night."><y>#</y><d>2020-10-03</d><h>16:35</h><w>noprompt</w><b>☝️</b> This fixes a bug with set patterns I came across last night.</z><z id="t1601943444" t="noprompt https://clojars.org/meander/epsilon/versions/0.0.512"><y>#</y><d>2020-10-06</d><h>00:17</h><w>noprompt</w><a href="https://clojars.org/meander/epsilon/versions/0.0.512" target="_blank">https://clojars.org/meander/epsilon/versions/0.0.512</a></z><z id="t1601943469" t="noprompt ☝️ This fixes the aforementioned symbol resolution problem with syntax extensions"><y>#</y><d>2020-10-06</d><h>00:17</h><w>noprompt</w><b>☝️</b> This fixes the aforementioned symbol resolution problem with syntax extensions</z><z id="t1602146481" t="Lucy Wang https://www.reddit.com/r/Clojure/comments/j79imz/a_little_syntax_sugar_for_malli_using_meander/"><y>#</y><d>2020-10-08</d><h>08:41</h><w>Lucy Wang</w><a href="https://www.reddit.com/r/Clojure/comments/j79imz/a_little_syntax_sugar_for_malli_using_meander/" target="_blank">https://www.reddit.com/r/Clojure/comments/j79imz/a_little_syntax_sugar_for_malli_using_meander/</a></z><z id="t1602157630" t="mac Hey all. Very impressed my meander. I am currently using $ to find matching submaps. In that connection I would like to be able to capture the &quot;path&quot; to the matching maps, path in this case being not only the keys but the complete &quot;super&quot; maps of the match. Any recommendations on how to achieve this?"><y>#</y><d>2020-10-08</d><h>11:47</h><w>mac</w>Hey all. Very impressed my meander. I am currently using $ to find matching submaps. In that connection I would like to be able to capture the &quot;path&quot; to the matching maps, path in this case being not only the keys but the complete &quot;super&quot; maps of the match. Any recommendations on how to achieve this?</z><z id="t1602158538" t="Lucy Wang maybe with m/cata? (m/search {:user {:name {:first &quot;Jack&quot; :second &quot;Lee&quot;}}} {:first (m/some ?first) :as ?full} ?full {?k (m/and ?v (m/cata ?vv))} [?k ?v ?vv]) ;; =&gt; ([:user ;; {:name {:first &quot;Jack&quot;, :second &quot;Lee&quot;}} ;; [:name {:first &quot;Jack&quot;, :second &quot;Lee&quot;} {:first &quot;Jack&quot;, :second &quot;Lee&quot;}]])"><y>#</y><d>2020-10-08</d><h>12:02</h><w>Lucy Wang</w>maybe with m/cata?
<pre>(m/search {:user {:name {:first &quot;Jack&quot; :second &quot;Lee&quot;}}}
  {:first (m/some ?first) :as ?full}
  ?full

  {?k (m/and ?v (m/cata ?vv))}
  [?k ?v ?vv])
;; =&gt; ([:user
;;      {:name {:first &quot;Jack&quot;, :second &quot;Lee&quot;}}
;;      [:name {:first &quot;Jack&quot;, :second &quot;Lee&quot;} {:first &quot;Jack&quot;, :second &quot;Lee&quot;}]])</pre></z><z id="t1602162655" t="mac [:attrs {:href &quot;/_/_/users/UP90Q48J3&quot;}] Thanks a lot, I will give that a look."><y>#</y><d>2020-10-08</d><h>13:10</h><w>mac</w><a>@wxitb2017</a> Thanks a lot, I will give that a look.</z><z id="t1602167093" t="mac [:attrs {:href &quot;/_/_/users/UP90Q48J3&quot;}] I think I understand how this works. Some of my maps have sequences of maps as values. I tried the below to accommodate for this, but it does not appear to work. (me/search {:user {:name {:first &quot;Jack&quot; :second &quot;Lee&quot; :addresses [{:main &quot;test&quot;} {:secondary &quot;test1&quot;}]}}} {:main (me/some ?main) :as ?full} ?full (me/scan {?k (me/and ?v (me/cata ?vv))}) [?k ?v ?vv] {?k (me/and ?v (me/cata ?vv))} [?k ?v ?vv])"><y>#</y><d>2020-10-08</d><h>14:24</h><w>mac</w><a>@wxitb2017</a> I think I understand how this works. Some of my maps have sequences of maps as values. I tried the below to accommodate for this, but it does not appear to work.

<pre>(me/search
     {:user {:name {:first &quot;Jack&quot; :second &quot;Lee&quot; :addresses [{:main &quot;test&quot;} {:secondary &quot;test1&quot;}]}}}
     {:main (me/some ?main) :as ?full}
     ?full
     (me/scan {?k (me/and ?v (me/cata ?vv))})
     [?k ?v ?vv]
     {?k (me/and ?v (me/cata ?vv))}
     [?k ?v ?vv])</pre></z><z id="t1602181512" t="noprompt m/$ uses a zipper when context-pattern is passed (m/$ ?context-fn ?pattern) I suppose we could “unshift” another arity for capturing the path when matching an, pending a sensible definition, ignore it during substitution. (m/$ ?path ?context-fn ?pattern) "><y>#</y><d>2020-10-08</d><h>18:25</h><w>noprompt</w><code>m/$</code> uses a zipper when <code>context-pattern</code> is passed
<pre>(m/$ ?context-fn ?pattern)</pre>
I suppose we could “unshift” another arity for capturing the path when matching an, pending a sensible definition, ignore it during substitution.
<pre>(m/$ ?path ?context-fn ?pattern)</pre>
</z><z id="t1602181704" t="noprompt Alternatively, the ?path parameter could be “pushed” (m/$ ?context-fn ?pattern ?path) or, if it makes sense, we could accept and parse keyword arguments (m/$ ?context-fn ?pattern :path ?path :left ?left :right ?right) "><y>#</y><d>2020-10-08</d><h>18:28</h><w>noprompt</w>Alternatively, the <code>?path</code> parameter could be “pushed”
<pre>(m/$ ?context-fn ?pattern ?path)</pre>
or, if it makes sense, we could accept and parse keyword arguments
<pre>(m/$ ?context-fn ?pattern :path ?path :left ?left :right ?right)</pre>
</z><z id="t1602181904" t="noprompt Of course, we would ensure the getting the values/locations would be a safe operation."><y>#</y><d>2020-10-08</d><h>18:31</h><w>noprompt</w>Of course, we would ensure the getting the values/locations would be a safe operation.</z><z id="t1602182057" t="noprompt In terms of flexibility/maintainability, keyword arguments are the most appealing because we can incrementally add all this functionality."><y>#</y><d>2020-10-08</d><h>18:34</h><w>noprompt</w>In terms of flexibility/maintainability, keyword arguments are the most appealing because we can incrementally add all this functionality.</z><z id="t1602182299" t="noprompt m/$ is meant for situations where you don’t know where something is so I think adding a way to capture more contextual information would be useful."><y>#</y><d>2020-10-08</d><h>18:38</h><w>noprompt</w><code>m/$</code> is meant for situations where you don’t know where something is so I think adding a way to capture more contextual information would be useful.</z><z id="t1602182653" t="noprompt I think if we can come up with a sensible semantic for substitution with these additional parameters, we’d have a powerfully succinct but blunt force way of getting common tree rewrites off the ground."><y>#</y><d>2020-10-08</d><h>18:44</h><w>noprompt</w>I think if we can come up with a sensible semantic for substitution with these additional parameters, we’d have a powerfully succinct but blunt force way of getting common tree rewrites off the ground.</z><z id="t1602182889" t="noprompt What do y’all think?"><y>#</y><d>2020-10-08</d><h>18:48</h><w>noprompt</w>What do y’all think?</z><z id="t1602185419" t="mac [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] I am an absolute newb when it comes to meander, but it sounds good to me."><y>#</y><d>2020-10-08</d><h>19:30</h><w>mac</w><a>@noprompt</a> I am an absolute newb when it comes to meander, but it sounds good to me.</z><z id="t1602187319" t="noprompt [:attrs {:href &quot;/_/_/users/U09UV3WP6&quot;}] Newbies tend to have the most affect and influence on the project. 🙂"><y>#</y><d>2020-10-08</d><h>20:01</h><w>noprompt</w><a>@mac</a> Newbies tend to have the most affect and influence on the project. <b>🙂</b></z><z id="t1602187366" t="noprompt Not to say we don’t value veterans. 😉"><y>#</y><d>2020-10-08</d><h>20:02</h><w>noprompt</w>Not to say we don’t value veterans. <b>😉</b></z><z id="t1602228798" t="nivekuil I&apos;d like to a group-by on a vec of vecs where the group key gets removed, like if I group by index 0 I should get [[1 2] [1 3]] =&gt; [{1 [2 3]}] . I know I can do this pretty well with xforms, curious how meander compares"><y>#</y><d>2020-10-09</d><h>07:33</h><w>nivekuil</w>I&apos;d like to a <code>group-by</code> on a vec of vecs where the group key gets removed, like if I group by index 0 I should get <code>[[1 2] [1 3]] =&gt; [{1 [2 3]}]</code>. I know I can do this pretty well with xforms, curious how meander compares</z><z id="t1602261880" t="noprompt There is a new primitive planned for zeta (and experimentally demonstrated in code) which generalizes variable storage as a reduction that can be user defined. This ends up allowing for variables which automatically group-by , max , etc. Progress on zeta has been slow due to personal time constraints imposed on me by homeschooling and work at the moment."><y>#</y><d>2020-10-09</d><h>16:44</h><r>noprompt</r>There is a new primitive planned for <code>zeta</code> (and experimentally demonstrated in code) which generalizes variable storage as a reduction that can be user defined. This ends up allowing for variables which automatically <code>group-by</code>, <code>max</code>, etc.

Progress on <code>zeta</code> has been slow due to personal time constraints imposed on me by homeschooling and work at the moment.</z><z id="t1602315685" t="nivekuil ok, here&apos;s another one that I think is doable, but can&apos;t figure out: find an elt in vec that is a map with the key :a , and wrap it with a list with something arbitrary added like: [1 2 {:a 1} {:d 4}] =&gt; [1 2 ({:a 1} 99) {:d 4}]"><y>#</y><d>2020-10-10</d><h>07:41</h><w>nivekuil</w>ok, here&apos;s another one that I think is doable, but can&apos;t figure out: find an elt in vec that is a map with the key <code>:a</code>, and wrap it with a list with something arbitrary added like: <code>[1 2 {:a 1} {:d 4}]</code> =&gt; <code>[1 2 ({:a 1} 99) {:d 4}]</code></z><z id="t1602315912" t="Lucy Wang use the subtree search operator m/$ (m/match [1 2 {:a 1} {:d 4}] (m/$ ?context {:a ?a}) (?context (list {:a ?a} 99))) ;; =&gt; [1 2 ({:a 1} 99) {:d 4}]"><y>#</y><d>2020-10-10</d><h>07:45</h><w>Lucy Wang</w>use the subtree search operator <code>m/$</code>
<pre>(m/match [1 2 {:a 1} {:d 4}]
  (m/$ ?context {:a ?a})
  (?context (list {:a ?a} 99)))
;; =&gt; [1 2 ({:a 1} 99) {:d 4}]</pre></z><z id="t1602316004" t="nivekuil aha, so that&apos;s what that does. I was confused as to how you get the whole map, but looks like that&apos;s what ?context is for. thanks"><y>#</y><d>2020-10-10</d><h>07:46</h><w>nivekuil</w>aha, so that&apos;s what that does. I was confused as to how you get the whole map, but looks like that&apos;s what <code>?context</code> is for. thanks</z><z id="t1602316102" t="Lucy Wang Yeah, FYI https://github.com/noprompt/meander/blob/74d8aa4832b0c33e567eb996e7dd7b509c865ba5/doc/operator-overview.md#toc22"><y>#</y><d>2020-10-10</d><h>07:48</h><w>Lucy Wang</w>Yeah, FYI <a href="https://github.com/noprompt/meander/blob/74d8aa4832b0c33e567eb996e7dd7b509c865ba5/doc/operator-overview.md#toc22" target="_blank">https://github.com/noprompt/meander/blob/74d8aa4832b0c33e567eb996e7dd7b509c865ba5/doc/operator-overview.md#toc22</a></z><z id="t1602316909" t="nivekuil I saw it, but my brain is too slow at this time to understand it :) I am also too slow to understand why it only seems to match the first map, so it wouldn&apos;t work if I wanted to match on`:d`: (m/match [1 2 {:a 1} {:d 4}] (m/$ ?context {:d ?d}) (?context (list {:d ?d} 99))) =&gt; [1 2 ({:d nil} 99) {:d 4}]"><y>#</y><d>2020-10-10</d><h>08:01</h><w>nivekuil</w>I saw it, but my brain is too slow at this time to understand it :) I am also too slow to understand why it only seems to match the first map, so it wouldn&apos;t work if I wanted to match on`:d`:
<pre>(m/match [1 2 {:a 1} {:d 4}]   
 (m/$ ?context {:d ?d})
 (?context (list {:d ?d} 99)))  
 =&gt; [1 2 ({:d nil} 99) {:d 4}]</pre></z><z id="t1602472188" t="JAtkins I must say, this is perhaps the coolest thing I&apos;ve done with meander 😉 (m/match &apos;(let [b 2 c b a (+ b 4)] (a) b) (let [!var (m/cata !val) ...] . !outs ...) (concat `(let ~(vec (interleave !var (map (fn [val-statement] `(capture ~(uuid) ~val-statement)) !val)))) !outs) (?function-or-macro . (m/cata !args) ...) (concat `(~?function-or-macro) !args) (m/pred symbol? ?x) `(capture ~(uuid) ~?x) ?x ?x) I&apos;m playing around to see how hard it would be to get debux like info from macros with rewriting provided by meander. Looks promising so far 🙂"><y>#</y><d>2020-10-12</d><h>03:09</h><w>JAtkins</w>I must say, this is perhaps the coolest thing I&apos;ve done with meander <b>😉</b>
<pre>(m/match &apos;(let [b 2
                  c b
                  a (+ b 4)]
              (a)
              b)
    (let [!var (m/cata !val) ...]
      .
      !outs ...)
    (concat
      `(let ~(vec (interleave
                   !var
                   (map (fn [val-statement]
                          `(capture ~(uuid) ~val-statement))
                     !val))))
      !outs)
    
    (?function-or-macro . (m/cata !args) ...)
    (concat `(~?function-or-macro)
      !args)

    (m/pred symbol? ?x)
    `(capture ~(uuid) ~?x)
    
    ?x ?x)</pre>
I&apos;m playing around to see how hard it would be to get debux like info from macros with rewriting provided by meander. Looks promising so far <b>🙂</b></z><z id="t1602474202" t="Lucy Wang [:attrs {:href &quot;/_/_/users/U5P29DSUS&quot;}] Interesting! Debux is already pretty good for me, which part of it doesn&apos;t satisfy you?"><y>#</y><d>2020-10-12</d><h>03:43</h><w>Lucy Wang</w><a>@jatkin</a> Interesting! Debux is already pretty good for me, which part of it doesn&apos;t satisfy you?</z><z id="t1602506675" t="JAtkins I’m experimenting with some ui front ends for debux/data exploring. I’m sure I can use the backend of debux, but it occurred to me that I could use meander so I had to try it at least :)"><y>#</y><d>2020-10-12</d><h>12:44</h><r>JAtkins</r>I’m experimenting with some ui front ends for debux/data exploring. I’m sure I can use the backend of debux, but it occurred to me that I could use meander so I had to try it at least :)</z><z id="t1602476977" t="Lone Ranger ??"><y>#</y><d>2020-10-12</d><h>04:29</h><w>Lone Ranger</w>??</z><z id="t1602483873" t="Lucy Wang sorry, wrong @ ... Your ID is &quot;James Tolton&quot;, which sorts close to &quot;Jarrett Atkinson&quot; ..."><y>#</y><d>2020-10-12</d><h>06:24</h><r>Lucy Wang</r>sorry, wrong @ ... Your ID is &quot;James Tolton&quot;, which sorts close to &quot;Jarrett Atkinson&quot; ...</z><z id="t1602860033" t="schmee I finally have a real use-case for Meander! 🎉"><y>#</y><d>2020-10-16</d><h>14:53</h><w>schmee</w>I finally have a real use-case for Meander! <b>🎉</b></z><z id="t1602860050" t="schmee I’ve already managed to do what I want, which is great, but is there any way to remove the duplication in this rewrite?"><y>#</y><d>2020-10-16</d><h>14:54</h><w>schmee</w>I’ve already managed to do what I want, which is great, but is there any way to remove the duplication in this rewrite?</z><z id="t1602860052" t="schmee (m*/rewrite [:and [!as ...]] [:and . !as ...] [:or [!as ...]] [:or . !as ...]))"><y>#</y><d>2020-10-16</d><h>14:54</h><w>schmee</w><pre>(m*/rewrite
    [:and [!as ...]] [:and . !as ...]
    [:or [!as ...]] [:or . !as ...]))</pre></z><z id="t1602860101" t="schmee basically, :and and :or are both operators, so the pattern should be, “if the first element is an operator…”"><y>#</y><d>2020-10-16</d><h>14:55</h><w>schmee</w>basically, <code>:and</code> and <code>:or</code> are both operators, so the pattern should be, “if the first element is an operator…”</z><z id="t1602860247" t="Jimmy Miller Do you have a defined set of operators you want to match on?"><y>#</y><d>2020-10-16</d><h>14:57</h><r>Jimmy Miller</r>Do you have a defined set of operators you want to match on?</z><z id="t1602860292" t="schmee yes, the set of operators is fixed!"><y>#</y><d>2020-10-16</d><h>14:58</h><r>schmee</r>yes, the set of operators is fixed!</z><z id="t1602860444" t="Jimmy Miller On my phone, but you should be able to do (m/pred #{:and :or} ?op)"><y>#</y><d>2020-10-16</d><h>15:00</h><r>Jimmy Miller</r>On my phone, but you should be able to do <code>(m/pred #{:and :or} ?op)</code></z><z id="t1602860978" t="schmee worked like a charm, thanks! 🚀"><y>#</y><d>2020-10-16</d><h>15:09</h><r>schmee</r>worked like a charm, thanks! <b>🚀</b></z><z id="t1602861100" t="schmee follow-up: is there any way to bind this pattern to a name so I can re-use it in all the rules without re-typing it?"><y>#</y><d>2020-10-16</d><h>15:11</h><r>schmee</r>follow-up: is there any way to bind this pattern to a name so I can re-use it in all the rules without re-typing it?</z><z id="t1602861127" t="schmee I tried m/let but at least on my first attempt it didn’t do the trick"><y>#</y><d>2020-10-16</d><h>15:12</h><r>schmee</r>I tried <code>m/let</code> but at least on my first attempt it didn’t do the trick</z><z id="t1602861391" t="Jimmy Miller You can use with https://cljdoc.org/d/meander/epsilon/0.0.512/doc/operator-overview#with"><y>#</y><d>2020-10-16</d><h>15:16</h><r>Jimmy Miller</r>You can use with <a href="https://cljdoc.org/d/meander/epsilon/0.0.512/doc/operator-overview#with" target="_blank">https://cljdoc.org/d/meander/epsilon/0.0.512/doc/operator-overview#with</a></z><z id="t1604407306" t="borkdude I guess meander can be used on conformed output from clojure.spec right?"><y>#</y><d>2020-11-03</d><h>12:41</h><w>borkdude</w>I guess meander can be used on conformed output from clojure.spec right?</z><z id="t1604407324" t="borkdude It occurred to me that this might be useful for grasp ( https://github.com/borkdude/grasp )"><y>#</y><d>2020-11-03</d><h>12:42</h><w>borkdude</w>It occurred to me that this might be useful for grasp (<a href="https://github.com/borkdude/grasp" target="_blank">https://github.com/borkdude/grasp</a>)</z><z id="t1604415165" t="borkdude https://github.com/borkdude/grasp#Meander"><y>#</y><d>2020-11-03</d><h>14:52</h><w>borkdude</w><a href="https://github.com/borkdude/grasp#Meander" target="_blank">https://github.com/borkdude/grasp#Meander</a></z><z id="t1604415376" t="Jimmy Miller [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] That was my first thought when I saw grasp. Was hoping to play with it soon. Glad to see you beat me to it."><y>#</y><d>2020-11-03</d><h>14:56</h><w>Jimmy Miller</w><a>@borkdude</a> That was my first thought when I saw grasp. Was hoping to play with it soon. Glad to see you beat me to it.</z><z id="t1604415449" t="borkdude [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] now that you&apos;re here anyway: is it possible to define a pattern outside of a call to m/find ? like: (def pattern ...) (m/find thing pattern out) ?"><y>#</y><d>2020-11-03</d><h>14:57</h><w>borkdude</w><a>@jimmy</a> now that you&apos;re here anyway: is it possible to define a pattern outside of a call to <code>m/find</code>?
like:
<pre>(def pattern ...)
(m/find thing pattern out)</pre>
?</z><z id="t1604415489" t="Jimmy Miller You can use defsyntax. But other than that not currently."><y>#</y><d>2020-11-03</d><h>14:58</h><w>Jimmy Miller</w>You can use defsyntax. But other than that not currently.</z><z id="t1604415505" t="borkdude [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] One idea might be to support unquote. I&apos;ve been doing this in the babashka.process $ macro: ($ ls -la ~file) "><y>#</y><d>2020-11-03</d><h>14:58</h><w>borkdude</w><a>@jimmy</a> One idea might be to support unquote. I&apos;ve been doing this in the babashka.process <code>$</code> macro:
<pre>($ ls -la ~file)</pre>
</z><z id="t1604415520" t="borkdude (m/find thing ~pattern out)"><y>#</y><d>2020-11-03</d><h>14:58</h><w>borkdude</w><pre>(m/find thing ~pattern out)</pre></z><z id="t1604415549" t="Jimmy Miller We have unquote for slicing in values. But not patterns. (If I recall correctly)"><y>#</y><d>2020-11-03</d><h>14:59</h><w>Jimmy Miller</w>We have unquote for slicing in values. But not patterns. (If I recall correctly)</z><z id="t1604415656" t="borkdude or maybe expose functional equivalents to the macros? (m/findf thing &apos;{:my ?pattern} ...) "><y>#</y><d>2020-11-03</d><h>15:00</h><w>borkdude</w>or maybe expose functional equivalents to the macros?

<pre>(m/findf thing &apos;{:my ?pattern} ...)</pre>
</z><z id="t1604415779" t="Jimmy Miller Yeah, we do have plans around doing exactly that."><y>#</y><d>2020-11-03</d><h>15:02</h><w>Jimmy Miller</w>Yeah, we do have plans around doing exactly that.</z><z id="t1604415827" t="borkdude great!"><y>#</y><d>2020-11-03</d><h>15:03</h><w>borkdude</w>great!</z><z id="t1604428039" t="noprompt [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] There is this PR: https://github.com/noprompt/meander/pull/128"><y>#</y><d>2020-11-03</d><h>18:27</h><w>noprompt</w><a>@borkdude</a> There is this PR: <a href="https://github.com/noprompt/meander/pull/128" target="_blank">https://github.com/noprompt/meander/pull/128</a></z><z id="t1604428094" t="noprompt I think it’s probably safe to merge at this point. I left it open for a while to give folks (primarily [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] and others who know the most about the project) a chance to chime in."><y>#</y><d>2020-11-03</d><h>18:28</h><w>noprompt</w>I think it’s probably safe to merge at this point. I left it open for a while to give folks (primarily <a>@jimmy</a> and others who know the most about the project) a chance to chime in.</z><z id="t1604428183" t="noprompt zeta which is in the works and hopefully available early next year, is being redesigned to place the interpreter API at the bottom with the compilation on top."><y>#</y><d>2020-11-03</d><h>18:29</h><w>noprompt</w><code>zeta</code> which is in the works and hopefully available early next year, is being redesigned to place the interpreter API at the bottom with the compilation on top.</z><z id="t1604428269" t="noprompt Normally, that would have been the road I would have taken first, however, from a strategic point of view as a maintainer, and not knowing exactly what I was building, starting from the macro gave me the most leverage and control starting out."><y>#</y><d>2020-11-03</d><h>18:31</h><w>noprompt</w>Normally, that would have been the road I would have taken first, however, from a strategic point of view as a maintainer, and not knowing exactly what I was building, starting from the macro gave me the most leverage and control starting out.</z><z id="t1604428407" t="noprompt [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] I’m keen on having that interpreter in your hands if you’ll make use of it."><y>#</y><d>2020-11-03</d><h>18:33</h><w>noprompt</w><a>@borkdude</a> I’m keen on having that interpreter in your hands if you’ll make use of it.</z><z id="t1604428440" t="noprompt All that I ask is that you complain here or on GH if you have issues with it."><y>#</y><d>2020-11-03</d><h>18:34</h><w>noprompt</w>All that I ask is that you complain here or on GH if you have issues with it.</z><z id="t1604428443" t="noprompt 🙂"><y>#</y><d>2020-11-03</d><h>18:34</h><w>noprompt</w><b>🙂</b></z><z id="t1604428474" t="noprompt Bugs and complaints are prized items in this channel."><y>#</y><d>2020-11-03</d><h>18:34</h><w>noprompt</w>Bugs and complaints are prized items in this channel.</z><z id="t1604429477" t="noprompt Eh, I’ll try and see if I can push that out today. I’m working on some #asami stuff at the moment and once I wrap up what I’m doing I’ll move on that PR."><y>#</y><d>2020-11-03</d><h>18:51</h><w>noprompt</w>Eh, I’ll try and see if I can push that out today. I’m working on some #asami stuff at the moment and once I wrap up what I’m doing I’ll move on that PR.</z><z id="t1604511468" t="noprompt Gonna try again today. 🙂"><y>#</y><d>2020-11-04</d><h>17:37</h><w>noprompt</w>Gonna try again today. <b>🙂</b></z><z id="t1604511502" t="noprompt Numbers in JS are… interesting. 😛"><y>#</y><d>2020-11-04</d><h>17:38</h><w>noprompt</w>Numbers in JS are… interesting. <b>😛</b></z><z id="t1605175469" t="tobias An old version of the meander docs describes m/$ for recursive pattern matching ( https://cljdoc.org/d/meander/epsilon/0.0.287/doc/pattern-matching ). Is this still a supported feature? It still seems to work with [meander/epsilon &quot;0.0.512&quot;] but I can&apos;t see anything in the most recent docs about it, so I&apos;m wondering if it&apos;s deprecated."><y>#</y><d>2020-11-12</d><h>10:04</h><w>tobias</w>An old version of the meander docs describes <code>m/$</code> for recursive pattern matching (<a href="https://cljdoc.org/d/meander/epsilon/0.0.287/doc/pattern-matching" target="_blank">https://cljdoc.org/d/meander/epsilon/0.0.287/doc/pattern-matching</a>). Is this still a supported feature? It still seems to work with <code>[meander/epsilon &quot;0.0.512&quot;]</code>  but I can&apos;t see anything in the most recent docs about it, so I&apos;m wondering if it&apos;s deprecated.</z><z id="t1605175643" t="tobias Never mind, I was just being blind!"><y>#</y><d>2020-11-12</d><h>10:07</h><r>tobias</r>Never mind, I was just being blind!</z><z id="t1605175686" t="tobias The examples had just moved to a different place https://cljdoc.org/d/meander/epsilon/0.0.512/doc/cookbook https://cljdoc.org/d/meander/epsilon/0.0.512/api/meander.epsilon"><y>#</y><d>2020-11-12</d><h>10:08</h><r>tobias</r>The examples had just moved to a different place
<a href="https://cljdoc.org/d/meander/epsilon/0.0.512/doc/cookbook" target="_blank">https://cljdoc.org/d/meander/epsilon/0.0.512/doc/cookbook</a>
<a href="https://cljdoc.org/d/meander/epsilon/0.0.512/api/meander.epsilon" target="_blank">https://cljdoc.org/d/meander/epsilon/0.0.512/api/meander.epsilon</a></z><z id="t1605548393" t="rfhayashi Does meander work with babashka? Has anyone tried?"><y>#</y><d>2020-11-16</d><h>17:39</h><w>rfhayashi</w>Does meander work with babashka? Has anyone tried?</z><z id="t1605548942" t="Jimmy Miller I haven&apos;t tried personally."><y>#</y><d>2020-11-16</d><h>17:49</h><r>Jimmy Miller</r>I haven&apos;t tried personally.</z><z id="t1605549974" t="borkdude [:attrs {:href &quot;/_/_/users/U0HLDF4PL&quot;}] I think I ran into something, but I can&apos;t remember what from the top of my head. I do know that this one works: https://github.com/xapix-io/matchete It&apos;s a bit of a more basic meander with emphasis on fns instead of macros"><y>#</y><d>2020-11-16</d><h>18:06</h><r>borkdude</r><a>@U0HLDF4PL</a> I think I ran into something, but I can&apos;t remember what from the top of my head.
I do know that this one works:
<a href="https://github.com/xapix-io/matchete" target="_blank">https://github.com/xapix-io/matchete</a>
It&apos;s a bit of a more basic meander with emphasis on fns instead of macros</z><z id="t1605551010" t="noprompt &gt; emphasis on fns instead of macros This is only temporary as I mentioned. 🙂"><y>#</y><d>2020-11-16</d><h>18:23</h><r>noprompt</r>&gt; emphasis on fns instead of macros
This is only temporary as I mentioned. <b>🙂</b></z><z id="t1605551037" t="borkdude Ah right, this was the first thing I ran into: user=&gt; (require &apos;[meander.epsilon]) Could not resolve symbol: clojure.lang.Compiler/demunge [at clojure/spec/alpha.clj:128:16] user=&gt;"><y>#</y><d>2020-11-16</d><h>18:23</h><r>borkdude</r>Ah right, this was the first thing I ran into:
<pre>user=&gt; (require &apos;[meander.epsilon])
Could not resolve symbol: clojure.lang.Compiler/demunge [at clojure/spec/alpha.clj:128:16]
user=&gt;</pre></z><z id="t1605551038" t="noprompt [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] If you remember what it was do post an issue."><y>#</y><d>2020-11-16</d><h>18:23</h><r>noprompt</r><a>@U04V15CAJ</a> If you remember what it was do post an issue.</z><z id="t1605551059" t="noprompt Gah, spec! 😭"><y>#</y><d>2020-11-16</d><h>18:24</h><r>noprompt</r>Gah, spec! <b>😭</b></z><z id="t1605551062" t="borkdude hmm, meander loads spec ?"><y>#</y><d>2020-11-16</d><h>18:24</h><r>borkdude</r>hmm, meander loads spec ?</z><z id="t1605551158" t="noprompt Yes, in a couple namespaces, however, those namespaces don’t use it so we can stop doing that."><y>#</y><d>2020-11-16</d><h>18:25</h><r>noprompt</r>Yes, in a couple namespaces, however, those namespaces don’t use it so we can stop doing that.</z><z id="t1605551184" t="borkdude user=&gt; (binding [clojure.core/*loading-verbosely* true] (require &apos;[meander.epsilon])) (clojure.core/load &quot;/meander/epsilon&quot;) (clojure.core/load &quot;/clojure/core&quot;) (clojure.core/in-ns &apos;meander.epsilon) (clojure.core/alias &apos;clj &apos;clojure.core) (clojure.core/load &quot;/meander/match/epsilon&quot;) (clojure.core/in-ns &apos;meander.match.epsilon) (clojure.core/alias &apos;clojure &apos;clojure.core) (clojure.core/in-ns &apos;meander.match.epsilon) (clojure.core/alias &apos;pprint &apos;clojure.pprint) (clojure.core/load &quot;/clojure/set&quot;) (clojure.core/in-ns &apos;meander.match.epsilon) (clojure.core/alias &apos;set &apos;clojure.set) (clojure.core/in-ns &apos;meander.match.epsilon) (clojure.core/alias &apos;s &apos;clojure.spec.alpha)"><y>#</y><d>2020-11-16</d><h>18:26</h><r>borkdude</r><pre>user=&gt; (binding [clojure.core/*loading-verbosely* true] (require &apos;[meander.epsilon]))
(clojure.core/load &quot;/meander/epsilon&quot;)
(clojure.core/load &quot;/clojure/core&quot;)
(clojure.core/in-ns &apos;meander.epsilon)
(clojure.core/alias &apos;clj &apos;clojure.core)
(clojure.core/load &quot;/meander/match/epsilon&quot;)
(clojure.core/in-ns &apos;meander.match.epsilon)
(clojure.core/alias &apos;clojure &apos;clojure.core)
(clojure.core/in-ns &apos;meander.match.epsilon)
(clojure.core/alias &apos;pprint &apos;clojure.pprint)
(clojure.core/load &quot;/clojure/set&quot;)
(clojure.core/in-ns &apos;meander.match.epsilon)
(clojure.core/alias &apos;set &apos;clojure.set)
(clojure.core/in-ns &apos;meander.match.epsilon)
(clojure.core/alias &apos;s &apos;clojure.spec.alpha)</pre></z><z id="t1605551241" t="noprompt Nuking"><y>#</y><d>2020-11-16</d><h>18:27</h><r>noprompt</r>Nuking</z><z id="t1605551292" t="noprompt Alrighty, I’m on it."><y>#</y><d>2020-11-16</d><h>18:28</h><r>noprompt</r>Alrighty, I’m on it.</z><z id="t1605551330" t="borkdude This one&apos;s also causing trouble: https://github.com/noprompt/meander/blob/a96e3766a0b342f60952acf1c732a82b831b82fc/src/meander/substitute/syntax/epsilon.cljc#L7 (core.specs.alpha) I do intend to support spec in babashka at one point, but not with the .alpha suffix"><y>#</y><d>2020-11-16</d><h>18:28</h><r>borkdude</r>This one&apos;s also causing trouble:
<a href="https://github.com/noprompt/meander/blob/a96e3766a0b342f60952acf1c732a82b831b82fc/src/meander/substitute/syntax/epsilon.cljc#L7" target="_blank">https://github.com/noprompt/meander/blob/a96e3766a0b342f60952acf1c732a82b831b82fc/src/meander/substitute/syntax/epsilon.cljc#L7</a>
(core.specs.alpha)
I do intend to support spec in babashka at one point, but not with the .alpha suffix</z><z id="t1605551345" t="noprompt Thanks!"><y>#</y><d>2020-11-16</d><h>18:29</h><r>noprompt</r>Thanks!</z><z id="t1605551412" t="noprompt I’m going to fully move the fdefs etc to separate namespaces and drop the requires."><y>#</y><d>2020-11-16</d><h>18:30</h><r>noprompt</r>I’m going to fully move the fdefs etc to separate namespaces and drop the requires.</z><z id="t1605551443" t="noprompt This actually one, for the most part, nice property of specs global, public registry approach."><y>#</y><d>2020-11-16</d><h>18:30</h><r>noprompt</r>This actually one, for the most part, nice property of specs global, public registry approach.</z><z id="t1605551456" t="borkdude Nice."><y>#</y><d>2020-11-16</d><h>18:30</h><r>borkdude</r>Nice.</z><z id="t1605551939" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] The next issue: Unable to resolve classname: clojure.lang.Var [at meander/util/epsilon.cljc] I think this: https://github.com/noprompt/meander/blob/a96e3766a0b342f60952acf1c732a82b831b82fc/src/meander/util/epsilon.cljc#L585 can be written as (:ns (meta var))"><y>#</y><d>2020-11-16</d><h>18:38</h><r>borkdude</r><a>@U06MDAPTP</a> The next issue:
Unable to resolve classname: clojure.lang.Var [at meander/util/epsilon.cljc]
I think this:
<a href="https://github.com/noprompt/meander/blob/a96e3766a0b342f60952acf1c732a82b831b82fc/src/meander/util/epsilon.cljc#L585" target="_blank">https://github.com/noprompt/meander/blob/a96e3766a0b342f60952acf1c732a82b831b82fc/src/meander/util/epsilon.cljc#L585</a>
can be written as <code>(:ns (meta var))</code></z><z id="t1605562135" t="noprompt [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] Thanks again! I’m nearly done with the spec surgery."><y>#</y><d>2020-11-16</d><h>21:28</h><r>noprompt</r><a>@U04V15CAJ</a> Thanks again! I’m nearly done with the spec surgery.</z><z id="t1605579329" t="markaddleman It looks like applying context loses the record. The result is {:v :b} rather than #T{:v :b}"><y>#</y><d>2020-11-17</d><h>02:15</h><w>markaddleman</w>It looks like applying context loses the record.   The result is <code>{:v :b}</code> rather than <code>#T{:v :b}</code></z><z id="t1605579336" t="markaddleman Is this expected?"><y>#</y><d>2020-11-17</d><h>02:15</h><w>markaddleman</w>Is this expected?</z><z id="t1605579528" t="markaddleman More importantly, is there a convenient workaround? I&apos;m doing a lot rewriting of HoneySQL data structures. The library relies on a few records but they are pretty integral"><y>#</y><d>2020-11-17</d><h>02:18</h><w>markaddleman</w>More importantly, is there a convenient workaround?  I&apos;m doing a lot rewriting of HoneySQL data structures.  The library relies on a few records but they are pretty integral</z><z id="t1605582614" t="noprompt [:attrs {:href &quot;/_/_/users/UAMEU7QV7&quot;}] No. That is not right but also it’s a problem with a solution. 🙂 I should be able to patch that today/tomorrow."><y>#</y><d>2020-11-17</d><h>03:10</h><w>noprompt</w><a>@mark340</a> No. That is not right but also it’s a problem with a solution. <b>🙂</b> I should be able to patch that today/tomorrow.</z><z id="t1605683173" t="noprompt OK I’ve fixed the spec issue, the Var issue, and the record issue."><y>#</y><d>2020-11-18</d><h>07:06</h><w>noprompt</w>OK I’ve fixed the spec issue, the Var issue, and the record issue.</z><z id="t1605683198" t="noprompt Everything is currently on epsilon I’ll create a release tomorrow."><y>#</y><d>2020-11-18</d><h>07:06</h><w>noprompt</w>Everything is currently on <code>epsilon</code> I’ll create a release tomorrow.</z><z id="t1605720914" t="noprompt https://clojars.org/meander/epsilon"><y>#</y><d>2020-11-18</d><h>17:35</h><w>noprompt</w><a href="https://clojars.org/meander/epsilon" target="_blank">https://clojars.org/meander/epsilon</a></z><z id="t1605720966" t="noprompt [:attrs {:href &quot;/_/_/users/U0HLDF4PL&quot;}] [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] Lemme know if this works with babashka [:attrs {:href &quot;/_/_/users/UAMEU7QV7&quot;}] The record problem has been fixed."><y>#</y><d>2020-11-18</d><h>17:36</h><w>noprompt</w><a>@rfhayashi</a> <a>@borkdude</a> Lemme know if this works with babashka
<a>@mark340</a> The record problem has been fixed.</z><z id="t1605722392" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] I&apos;ll take a look later today, thanks for reminding me."><y>#</y><d>2020-11-18</d><h>17:59</h><w>borkdude</w><a>@noprompt</a> I&apos;ll take a look later today, thanks for reminding me.</z><z id="t1605725109" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] Is it necessary that the FAIL sentinel is seqable? https://github.com/noprompt/meander/blob/f4b1a90c75a8428e77f59feb0e152216e0460a82/src/meander/match/runtime/epsilon.cljc#L20"><y>#</y><d>2020-11-18</d><h>18:45</h><r>borkdude</r><a>@noprompt</a> Is it necessary that the FAIL sentinel is seqable?
<a href="https://github.com/noprompt/meander/blob/f4b1a90c75a8428e77f59feb0e152216e0460a82/src/meander/match/runtime/epsilon.cljc#L20" target="_blank">https://github.com/noprompt/meander/blob/f4b1a90c75a8428e77f59feb0e152216e0460a82/src/meander/match/runtime/epsilon.cljc#L20</a></z><z id="t1605725203" t="noprompt I’ll double check. At one point it was, however, that may no longer be case."><y>#</y><d>2020-11-18</d><h>18:46</h><r>noprompt</r>I’ll double check. At one point it was, however, that may no longer be case.</z><z id="t1605725351" t="borkdude Ok, if not, could make it just an Object (identical? (js/Object.) (js/Object.)) ;;=&gt; false I could support this (reify of ISeqable) in bb but if I don&apos;t have to .. :)"><y>#</y><d>2020-11-18</d><h>18:49</h><r>borkdude</r>Ok, if not,  could make it just an Object
<pre>(identical? (js/Object.) (js/Object.)) ;;=&gt; false</pre>
I could support this (reify of ISeqable) in bb but if I don&apos;t have to .. :)</z><z id="t1605725396" t="borkdude Don&apos;t worry about releasing, I can test with git dep"><y>#</y><d>2020-11-18</d><h>18:49</h><r>borkdude</r>Don&apos;t worry about releasing, I can test with git dep</z><z id="t1605725412" t="borkdude Branch also works for me"><y>#</y><d>2020-11-18</d><h>18:50</h><r>borkdude</r>Branch also works for me</z><z id="t1605725701" t="noprompt Cool. I tend to prefer (reify) in the place of Object and js/Object ."><y>#</y><d>2020-11-18</d><h>18:55</h><r>noprompt</r>Cool. I tend to prefer <code>(reify)</code> in the place of <code>Object</code> and <code>js/Object</code>.</z><z id="t1605725752" t="noprompt Actually, sorry, what’s the issue? 🙂"><y>#</y><d>2020-11-18</d><h>18:55</h><r>noprompt</r>Actually, sorry, what’s the issue? <b>🙂</b></z><z id="t1605726029" t="borkdude (reify ISeqable ...) doesn&apos;t work. Since FAIL is just some unique value to indicate failure, I wondered if this was really necessary to be a seqable. You could also just make it ::whatever or Object"><y>#</y><d>2020-11-18</d><h>19:00</h><r>borkdude</r><pre>(reify ISeqable ...)</pre>
doesn&apos;t work. Since <code>FAIL</code> is just some unique value to indicate failure, I wondered if this was really necessary to be a seqable. You could also just make it <code>::whatever</code> or <code>Object</code></z><z id="t1605726089" t="borkdude reify does work for some cases, but I have to make explicit support for it on a class by class basis :/"><y>#</y><d>2020-11-18</d><h>19:01</h><r>borkdude</r>reify does work for some cases, but I have to make explicit support for it on a class by class basis :/</z><z id="t1605726129" t="borkdude Since it&apos;s .cljc you could also consider a :bb branch with (Object.)"><y>#</y><d>2020-11-18</d><h>19:02</h><r>borkdude</r>Since it&apos;s .cljc you could also consider a <code>:bb</code> branch with <code>(Object.)</code></z><z id="t1605727629" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] Hmm, did you mean (reify) as in without args? That works: $ bb -e &apos;(identical? (reify) (reify))&apos; false"><y>#</y><d>2020-11-18</d><h>19:27</h><r>borkdude</r><a>@noprompt</a> Hmm, did you mean <code>(reify)</code> as in without args? That works:
<pre>$ bb -e &apos;(identical? (reify) (reify))&apos;
false</pre></z><z id="t1605727684" t="borkdude TIL"><y>#</y><d>2020-11-18</d><h>19:28</h><r>borkdude</r>TIL</z><z id="t1605727780" t="noprompt Hehe. So what I should have said is “if removing the seqable stuff works then just leave it as (def FAIL (reify)) .”"><y>#</y><d>2020-11-18</d><h>19:29</h><r>noprompt</r>Hehe. So what I should have said is “if removing the seqable stuff works then just leave it as <code>(def FAIL (reify))</code>.”</z><z id="t1605728008" t="borkdude yes, that would work for CLJ, CLJS and bb"><y>#</y><d>2020-11-18</d><h>19:33</h><r>borkdude</r>yes, that would work for CLJ, CLJS and bb</z><z id="t1605728418" t="noprompt The seqable stuff is not removable it appears, however, I’m happy to support a :bb clause."><y>#</y><d>2020-11-18</d><h>19:40</h><r>noprompt</r>The seqable stuff is not removable it appears, however, I’m happy to support a <code>:bb</code> clause.</z><z id="t1605728634" t="borkdude This works as well: user=&gt; (identical? (String. &quot;FAIL&quot;) (String. &quot;FAIL&quot;)) false cljs.user=&gt; (identical? (js/String. &quot;FAIL&quot;) (js/String. &quot;FAIL&quot;)) false The string object is unique and seqable."><y>#</y><d>2020-11-18</d><h>19:43</h><r>borkdude</r>This works as well:
<pre>user=&gt; (identical? (String. &quot;FAIL&quot;) (String. &quot;FAIL&quot;))
false</pre>
<pre>cljs.user=&gt; (identical? (js/String. &quot;FAIL&quot;) (js/String. &quot;FAIL&quot;))
false</pre>
The string object is unique and seqable.</z><z id="t1605728667" t="borkdude unless you need the seqable to return nil on seq"><y>#</y><d>2020-11-18</d><h>19:44</h><r>borkdude</r>unless you need the seqable to return nil on seq</z><z id="t1605728805" t="noprompt I have an idea…"><y>#</y><d>2020-11-18</d><h>19:46</h><r>noprompt</r>I have an idea…</z><z id="t1605728812" t="borkdude oh wait: (seq &quot;&quot;) ;;=&gt; nil that works too. So: cljs.user=&gt; (identical? (js/String. &quot;&quot;) (js/String. &quot;&quot;)) false fits the bill in all cases."><y>#</y><d>2020-11-18</d><h>19:46</h><r>borkdude</r>oh wait:
<pre>(seq &quot;&quot;)
;;=&gt; nil</pre>
that works too.
So:
<pre>cljs.user=&gt; (identical? (js/String. &quot;&quot;) (js/String. &quot;&quot;))
false</pre>
fits the bill in all cases.</z><z id="t1605728879" t="noprompt user=&gt; (identical? (list) (list)) true user=&gt; (identical? (with-meta (list) {}) (list)) false user=&gt; (identical? (with-meta (list) {}) (with-meta (list) {})) false "><y>#</y><d>2020-11-18</d><h>19:47</h><r>noprompt</r><pre>user=&gt; (identical? (list) (list))
true
user=&gt; (identical? (with-meta (list) {}) (list))
false
user=&gt; (identical? (with-meta (list) {}) (with-meta (list) {}))
false</pre>
</z><z id="t1605728881" t="noprompt 😛"><y>#</y><d>2020-11-18</d><h>19:48</h><r>noprompt</r><b>😛</b></z><z id="t1605728948" t="borkdude That works too :) You can even put some nice info in that metadata ;)"><y>#</y><d>2020-11-18</d><h>19:49</h><r>borkdude</r>That works too :) You can even put some nice info in that metadata ;)</z><z id="t1605728979" t="noprompt Like {:lol-is-this-a-hack? &apos;yes}"><y>#</y><d>2020-11-18</d><h>19:49</h><r>noprompt</r>Like <code>{:lol-is-this-a-hack? &apos;yes}</code></z><z id="t1605728999" t="noprompt 😂"><y>#</y><d>2020-11-18</d><h>19:49</h><r>noprompt</r><b>😂</b></z><z id="t1605729007" t="borkdude :lol.impl.dont-look-here true"><y>#</y><d>2020-11-18</d><h>19:50</h><r>borkdude</r><code>:lol.impl.dont-look-here true</code></z><z id="t1605729094" t="noprompt Random aside: I wonder if anyone has ever Xibit style put meta on their meta."><y>#</y><d>2020-11-18</d><h>19:51</h><r>noprompt</r>Random aside: I wonder if anyone has ever Xibit style put meta on their meta.</z><z id="t1605729135" t="noprompt (with-meta x (with-meta ,,,)) "><y>#</y><d>2020-11-18</d><h>19:52</h><r>noprompt</r><pre>(with-meta x (with-meta ,,,))</pre>
</z><z id="t1605729163" t="borkdude I think there are metadata values with metadata. E.g. when you datafy something, the original value is stored as metadata"><y>#</y><d>2020-11-18</d><h>19:52</h><r>borkdude</r>I think there are metadata values with metadata. E.g. when you datafy something, the original value is stored as metadata</z><z id="t1605729193" t="noprompt Meta linked list. 🙂"><y>#</y><d>2020-11-18</d><h>19:53</h><r>noprompt</r>Meta linked list. <b>🙂</b></z><z id="t1605729228" t="noprompt So, yah, the list bit does the trick."><y>#</y><d>2020-11-18</d><h>19:53</h><r>noprompt</r>So, yah, the list bit does the trick.</z><z id="t1605729236" t="noprompt Tests are passing."><y>#</y><d>2020-11-18</d><h>19:53</h><r>noprompt</r>Tests are passing.</z><z id="t1605729305" t="noprompt OK I’ve pushed it up. Wanna try it?"><y>#</y><d>2020-11-18</d><h>19:55</h><r>noprompt</r>OK I’ve pushed it up. Wanna try it?</z><z id="t1605729331" t="noprompt Aren’t semantics fun?! 😄"><y>#</y><d>2020-11-18</d><h>19:55</h><r>noprompt</r>Aren’t semantics fun?! <b>😄</b></z><z id="t1605729554" t="borkdude I&apos;m now running into another Seqable reference: user=&gt; (require &apos;[meander.epsilon] :reload) Could not resolve symbol: clojure.lang.Seqable [at /Users/borkdude/.gitlibs/libs/meander/epsilon/7ed07ce8766aa5fbf7d457bdeffe39e2e1323f73/src/meander/match/ir/epsilon.cljc:851:31] Maybe I&apos;ll just have to bite the bullet and add it to bb"><y>#</y><d>2020-11-18</d><h>19:59</h><r>borkdude</r>I&apos;m now running into another Seqable reference:
<pre>user=&gt; (require &apos;[meander.epsilon] :reload)
Could not resolve symbol: clojure.lang.Seqable [at /Users/borkdude/.gitlibs/libs/meander/epsilon/7ed07ce8766aa5fbf7d457bdeffe39e2e1323f73/src/meander/match/ir/epsilon.cljc:851:31]</pre>
Maybe I&apos;ll just have to bite the bullet and add it to bb</z><z id="t1605729580" t="borkdude The code gets rid of predicates - why?"><y>#</y><d>2020-11-18</d><h>19:59</h><r>borkdude</r>The code gets rid of predicates - why?</z><z id="t1605729584" t="borkdude perf?"><y>#</y><d>2020-11-18</d><h>19:59</h><r>borkdude</r>perf?</z><z id="t1605730036" t="noprompt Yes."><y>#</y><d>2020-11-18</d><h>20:07</h><r>noprompt</r>Yes.</z><z id="t1605730067" t="noprompt Shaving those checks off can save a lot of time."><y>#</y><d>2020-11-18</d><h>20:07</h><r>noprompt</r>Shaving those checks off can save a lot of time.</z><z id="t1605730335" t="borkdude This isn&apos;t exactly the same though: #&apos;clojure.core/seqable? clojure.lang.Seqable E.g. strings are seqable, but they are not clojure.lang.Seqable set? checks for IPersistentHashSet but you map it to PersistentHashSet"><y>#</y><d>2020-11-18</d><h>20:12</h><r>borkdude</r>This isn&apos;t exactly the same though:
<pre>#&apos;clojure.core/seqable? clojure.lang.Seqable</pre>
E.g. strings are seqable, but they are not clojure.lang.Seqable
set? checks for IPersistentHashSet but you map it to PersistentHashSet</z><z id="t1605730415" t="borkdude I support clojure.lang.IPersistentSet already in bb. I&apos;ll add support for checking Seqable as well"><y>#</y><d>2020-11-18</d><h>20:13</h><r>borkdude</r>I support <code>clojure.lang.IPersistentSet</code> already in bb. I&apos;ll add support for checking <code>Seqable</code> as well</z><z id="t1605730422" t="noprompt The set? one looks like an oversight"><y>#</y><d>2020-11-18</d><h>20:13</h><r>noprompt</r>The <code>set?</code> one looks like an oversight</z><z id="t1605730523" t="borkdude Yeah, you already have SetInterface"><y>#</y><d>2020-11-18</d><h>20:15</h><r>borkdude</r>Yeah, you already have <code>SetInterface</code></z><z id="t1605730589" t="noprompt We should probably tag [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] on this bit too. 🙂"><y>#</y><d>2020-11-18</d><h>20:16</h><r>noprompt</r>We should probably tag <a>@U5K8NTHEZ</a> on this bit too. <b>🙂</b></z><z id="t1605730707" t="Jimmy Miller Will take a look at fixing those discrepancies"><y>#</y><d>2020-11-18</d><h>20:18</h><r>Jimmy Miller</r>Will take a look at fixing those discrepancies</z><z id="t1605730745" t="noprompt [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] No pressure. I’m hacking away at them as [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] brings stuff up. I just wanted to tag you on the thread."><y>#</y><d>2020-11-18</d><h>20:19</h><r>noprompt</r><a>@U5K8NTHEZ</a> No pressure. I’m hacking away at them as <a>@borkdude</a> brings stuff up. I just wanted to tag you on the thread.</z><z id="t1605730889" t="borkdude The next thing I&apos;m running into: user=&gt; (require &apos;[meander.epsilon] :reload) Could not resolve symbol: clojure.lang.RT/iter [at /Users/borkdude/.gitlibs/libs/meander/epsilon/7ed07ce8766aa5fbf7d457bdeffe39e2e1323f73/src/meander/substitute/runtime/epsilon.cljc:11:12] Don&apos;t know what the normal Clojure function is for this, but you might want to add a :bb branch for this. Note that :bb branches have to go before :clj branches, else bb will take the :clj branch :)"><y>#</y><d>2020-11-18</d><h>20:21</h><r>borkdude</r>The next thing I&apos;m running into:
<pre>user=&gt; (require &apos;[meander.epsilon] :reload)
Could not resolve symbol: clojure.lang.RT/iter [at /Users/borkdude/.gitlibs/libs/meander/epsilon/7ed07ce8766aa5fbf7d457bdeffe39e2e1323f73/src/meander/substitute/runtime/epsilon.cljc:11:12]</pre>
Don&apos;t know what the normal Clojure function is for this, but you might want to add a :bb branch for this. Note that :bb branches have to go before :clj branches, else bb will take the :clj branch :)</z><z id="t1605731975" t="noprompt I don’t think there is a clean mapping to core clojure."><y>#</y><d>2020-11-18</d><h>20:39</h><r>noprompt</r>I don’t think there is a clean mapping to core clojure.</z><z id="t1605732181" t="noprompt Basically the goal is to make a java.lang.Iterator and this was the easiest way to do that without porting the RT code."><y>#</y><d>2020-11-18</d><h>20:43</h><r>noprompt</r>Basically the goal is to make a <code>java.lang.Iterator</code> and this was the easiest way to do that without porting the RT code.</z><z id="t1605732303" t="borkdude isn&apos;t this iterator-seq maybe?"><y>#</y><d>2020-11-18</d><h>20:45</h><r>borkdude</r>isn&apos;t this <code>iterator-seq</code> maybe?</z><z id="t1605732380" t="noprompt No that’s a different thing."><y>#</y><d>2020-11-18</d><h>20:46</h><r>noprompt</r>No that’s a different thing.</z><z id="t1605732483" t="noprompt It might be safe to just call .iterator there."><y>#</y><d>2020-11-18</d><h>20:48</h><r>noprompt</r>It might be safe to just call <code>.iterator</code> there.</z><z id="t1605732543" t="noprompt Eh, no, cause there’s special sauce for strings, etc."><y>#</y><d>2020-11-18</d><h>20:49</h><r>noprompt</r>Eh, no, cause there’s special sauce for strings, etc.</z><z id="t1605732584" t="noprompt I can port it"><y>#</y><d>2020-11-18</d><h>20:49</h><r>noprompt</r>I can port it</z><z id="t1605732943" t="borkdude I think that would be useful regardless of babashka, as to not rely on Clojure internals too much"><y>#</y><d>2020-11-18</d><h>20:55</h><r>borkdude</r>I think that would be useful regardless of babashka, as to not rely on Clojure internals too much</z><z id="t1605732970" t="borkdude After your port I will check if it works and make necessary changes to bb if needed"><y>#</y><d>2020-11-18</d><h>20:56</h><r>borkdude</r>After your port I will check if it works and make necessary changes to bb if needed</z><z id="t1605733022" t="noprompt Done"><y>#</y><d>2020-11-18</d><h>20:57</h><r>noprompt</r>Done</z><z id="t1605733035" t="noprompt Basically wrote (if (instance? java.lang.Iterable coll) (.iterator ^java.lang.Iterable coll) (.iterator (seq coll))) "><y>#</y><d>2020-11-18</d><h>20:57</h><r>noprompt</r>Basically wrote
<pre>(if (instance? java.lang.Iterable coll)
  (.iterator ^java.lang.Iterable coll)
  (.iterator (seq coll)))</pre>
</z><z id="t1605733268" t="borkdude Feedback: (set! *warn-on-reflection* true) (defn iter [coll] (if (instance? java.lang.Iterable coll) (.iterator ^java.lang.Iterable coll) (.iterator ^java.lang.Iterable (seq coll)))) (prn (iter [])) (prn (iter &quot;x&quot;)) ;; needs type hint on seq (prn (iter nil)) ;; needs fixing"><y>#</y><d>2020-11-18</d><h>21:01</h><r>borkdude</r>Feedback:
<pre>(set! *warn-on-reflection* true)

(defn iter [coll]
  (if (instance? java.lang.Iterable coll)
    (.iterator ^java.lang.Iterable coll)
    (.iterator ^java.lang.Iterable (seq coll))))

(prn (iter []))
(prn (iter &quot;x&quot;)) ;; needs type hint on seq
(prn (iter nil)) ;; needs fixing</pre></z><z id="t1605733315" t="borkdude Maybe return (iter []) for (iter nil) ?"><y>#</y><d>2020-11-18</d><h>21:01</h><r>borkdude</r>Maybe return <code>(iter [])</code> for <code>(iter nil)</code> ?</z><z id="t1605733329" t="noprompt Oh duh"><y>#</y><d>2020-11-18</d><h>21:02</h><r>noprompt</r>Oh duh</z><z id="t1605733444" t="borkdude You still need a type hint here: https://github.com/noprompt/meander/commit/6f7b8265e5102ae98eb304719b884a73aef53fe3#diff-cdb266462b83e64b48c052f2f26fca6ea027e9663cce3ff64b08fc81b840e69bR16"><y>#</y><d>2020-11-18</d><h>21:04</h><r>borkdude</r>You still need a type hint here:
<a href="https://github.com/noprompt/meander/commit/6f7b8265e5102ae98eb304719b884a73aef53fe3#diff-cdb266462b83e64b48c052f2f26fca6ea027e9663cce3ff64b08fc81b840e69bR16" target="_blank">https://github.com/noprompt/meander/commit/6f7b8265e5102ae98eb304719b884a73aef53fe3#diff-cdb266462b83e64b48c052f2f26fca6ea027e9663cce3ff64b08fc81b840e69bR16</a></z><z id="t1605733761" t="noprompt Got it"><y>#</y><d>2020-11-18</d><h>21:09</h><r>noprompt</r>Got it</z><z id="t1605734362" t="noprompt I’m still trying to figure out the Seqable thing."><y>#</y><d>2020-11-18</d><h>21:19</h><r>noprompt</r>I’m still trying to figure out the <code>Seqable</code> thing.</z><z id="t1605734479" t="noprompt Installed bb … looks like it doesn’t like java.lang.Iterable either?"><y>#</y><d>2020-11-18</d><h>21:21</h><r>noprompt</r>Installed <code>bb</code>… looks like it doesn’t like <code>java.lang.Iterable</code> either?</z><z id="t1605734520" t="borkdude That&apos;s easy to fix. Let me get back to you after I finish another (unrelated) refactor"><y>#</y><d>2020-11-18</d><h>21:22</h><r>borkdude</r>That&apos;s easy to fix. Let me get back to you after I finish another (unrelated) refactor</z><z id="t1605735737" t="noprompt https://github.com/noprompt/meander/pull/154"><y>#</y><d>2020-11-18</d><h>21:42</h><r>noprompt</r><a href="https://github.com/noprompt/meander/pull/154" target="_blank">https://github.com/noprompt/meander/pull/154</a></z><z id="t1605735769" t="noprompt The test script, however, doesn’t account for babashka yet"><y>#</y><d>2020-11-18</d><h>21:42</h><r>noprompt</r>The test script, however, doesn’t account for babashka yet</z><z id="t1605735927" t="noprompt You can bang on that branch if you want. I’ve gotta take my hands off of it for a bit."><y>#</y><d>2020-11-18</d><h>21:45</h><r>noprompt</r>You can bang on that branch if you want. I’ve gotta take my hands off of it for a bit.</z><z id="t1605735985" t="borkdude This is a better way to write it for bb: (defn iter [coll] (if (instance? java.lang.Iterable coll) (.iterator ^java.lang.Iterable coll) (.iterator ^java.lang.Iterable (seq coll)))) since it actually uses the type hint"><y>#</y><d>2020-11-18</d><h>21:46</h><r>borkdude</r>This is a better way to write it for bb:
<pre>(defn iter [coll]
  (if (instance? java.lang.Iterable coll)
    (.iterator ^java.lang.Iterable coll)
    (.iterator ^java.lang.Iterable (seq coll))))</pre>
since it actually uses the type hint</z><z id="t1605735993" t="borkdude else I&apos;m afraid it won&apos;t even work :)"><y>#</y><d>2020-11-18</d><h>21:46</h><r>borkdude</r>else I&apos;m afraid it won&apos;t even work :)</z><z id="t1605736007" t="borkdude I&apos;m almost ready here, let me then push Iterable"><y>#</y><d>2020-11-18</d><h>21:46</h><r>borkdude</r>I&apos;m almost ready here, let me then push Iterable</z><z id="t1605736049" t="noprompt I just added a :bb clause without type hints. Feel free to adjust it."><y>#</y><d>2020-11-18</d><h>21:47</h><r>noprompt</r>I just added a <code>:bb</code> clause without type hints. Feel free to adjust it.</z><z id="t1605736053" t="noprompt https://github.com/noprompt/meander/pull/154/files#diff-cdb266462b83e64b48c052f2f26fca6ea027e9663cce3ff64b08fc81b840e69bR11"><y>#</y><d>2020-11-18</d><h>21:47</h><r>noprompt</r><a href="https://github.com/noprompt/meander/pull/154/files#diff-cdb266462b83e64b48c052f2f26fca6ea027e9663cce3ff64b08fc81b840e69bR11" target="_blank">https://github.com/noprompt/meander/pull/154/files#diff-cdb266462b83e64b48c052f2f26fca6ea027e9663cce3ff64b08fc81b840e69bR11</a></z><z id="t1605736438" t="borkdude I now pushed a commit to bb master where this should work: (defn iter [coll] (if (instance? java.lang.Iterable coll) (.iterator ^java.lang.Iterable coll) (let [s (or (seq coll) [])] (.iterator ^java.lang.Iterable s)))) Also added a unit test for it: (= [1 2 3] (iterator-seq (iter [1 2 3])))"><y>#</y><d>2020-11-18</d><h>21:53</h><r>borkdude</r>I now pushed a commit to bb master where this should work:

<pre>(defn iter [coll]
  (if (instance? java.lang.Iterable coll)
    (.iterator ^java.lang.Iterable coll)
    (let [s (or (seq coll) [])]
      (.iterator ^java.lang.Iterable s))))</pre>
Also added a unit test for it:
<pre>(= [1 2 3] (iterator-seq (iter [1 2 3])))</pre></z><z id="t1605736469" t="borkdude I&apos;ll download your branch"><y>#</y><d>2020-11-18</d><h>21:54</h><r>borkdude</r>I&apos;ll download your branch</z><z id="t1605737154" t="borkdude iter is fixed now on babashka master. Note that you can download binaries from #babashka_circleci_builds or simply from the builds on Github, if you want to try the binary version. The next issue I&apos;ll just mention on Github"><y>#</y><d>2020-11-18</d><h>22:05</h><r>borkdude</r><code>iter</code> is fixed now on babashka master. Note that you can download binaries from #babashka_circleci_builds or simply from the builds on Github, if you want to try the binary version.
The next issue I&apos;ll just mention on Github</z><z id="t1605737373" t="borkdude The next issue is the 2 arg version of resolve. I&apos;ll have to fix that in sci (the interpreter backing babashka)."><y>#</y><d>2020-11-18</d><h>22:09</h><r>borkdude</r>The next issue is the 2 arg version of resolve. I&apos;ll have to fix that in sci (the interpreter backing babashka).</z><z id="t1605737382" t="borkdude I&apos;ll get back to this, getting late now."><y>#</y><d>2020-11-18</d><h>22:09</h><r>borkdude</r>I&apos;ll get back to this, getting late now.</z><z id="t1605779087" t="borkdude I fixed a couple of issues. The latest issue I&apos;m running into: https://github.com/noprompt/meander/issues/153"><y>#</y><d>2020-11-19</d><h>09:44</h><r>borkdude</r>I fixed a couple of issues. The latest issue I&apos;m running into:

<a href="https://github.com/noprompt/meander/issues/153" target="_blank">https://github.com/noprompt/meander/issues/153</a></z><z id="t1605779263" t="borkdude Also made this comment: https://github.com/noprompt/meander/issues/153#issuecomment-730255519"><y>#</y><d>2020-11-19</d><h>09:47</h><r>borkdude</r>Also made this comment:

<a href="https://github.com/noprompt/meander/issues/153#issuecomment-730255519" target="_blank">https://github.com/noprompt/meander/issues/153#issuecomment-730255519</a></z><z id="t1605728088" t="mac I have this function in plain Clojure. Out of curiosity, what would be the meander equivalent? I feel it should be straight forward, but I have not found a concise solution using meander. (defn replace-value [data] (clojure.walk/prewalk #(if (:a %) (assoc % :a (:b %)) %) data)) "><y>#</y><d>2020-11-18</d><h>19:34</h><w>mac</w>I have this function in plain Clojure. Out of curiosity, what would be the meander equivalent? I feel it should be straight forward, but I have not found a concise solution using meander.

<pre>(defn replace-value [data]
  (clojure.walk/prewalk
   #(if (:a %)
      (assoc % :a (:b %))
      %) data))</pre>
</z><z id="t1605728244" t="noprompt You could use the strategy namespace combining top-down and rewrite . (m*/top-down (m*/rewrite {:a (m/or false nil), :b ?b &amp; ?m} {:a ?b &amp; ?m})) but, honestly, what you have is probably fine."><y>#</y><d>2020-11-18</d><h>19:37</h><w>noprompt</w>You could use the strategy namespace combining <code>top-down</code> and <code>rewrite</code>.
<pre>(m*/top-down
  (m*/rewrite
   {:a (m/or false nil), :b ?b &amp; ?m}
   {:a ?b &amp; ?m}))</pre>
but, honestly, what you have is probably fine.</z><z id="t1605728359" t="noprompt The meander version will likely be slower."><y>#</y><d>2020-11-18</d><h>19:39</h><w>noprompt</w>The meander version will likely be slower.</z><z id="t1605728744" t="noprompt If you need it to be quicker, you’ll need to ditch both prewalk and avoid top-down . These traversals indiscriminately hit everything and 99% of that’s a waste."><y>#</y><d>2020-11-18</d><h>19:45</h><w>noprompt</w>If you need it to be quicker, you’ll need to ditch both <code>prewalk</code> and avoid <code>top-down</code> . These traversals indiscriminately hit everything and 99% of that’s a waste.</z><z id="t1605733297" t="mac [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] Thanks."><y>#</y><d>2020-11-18</d><h>21:01</h><w>mac</w><a>@noprompt</a> Thanks.</z><z id="t1605735987" t="noprompt [:attrs {:href &quot;/_/_/users/U0HLDF4PL&quot;}] We’re ( [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] and I) have been working back and forth on supporting bb . There’s an issue and PR in the works."><y>#</y><d>2020-11-18</d><h>21:46</h><w>noprompt</w><a>@rfhayashi</a> We’re (<a>@borkdude</a> and I) have been working back and forth on supporting <code>bb</code>. There’s an issue and PR in the works.</z><z id="t1605736085" t="rfhayashi Thank you both so much for that 🙂 I&apos;ll try to give it a go tomorrow."><y>#</y><d>2020-11-18</d><h>21:48</h><r>rfhayashi</r>Thank you both so much for that <b>🙂</b> I&apos;ll try to give it a go tomorrow.</z><z id="t1605779474" t="borkdude https://github.com/noprompt/meander/issues/153#issuecomment-730255519"><y>#</y><d>2020-11-19</d><h>09:51</h><r>borkdude</r><a href="https://github.com/noprompt/meander/issues/153#issuecomment-730255519" target="_blank">https://github.com/noprompt/meander/issues/153#issuecomment-730255519</a></z><z id="t1605783289" t="jose Very interesting work to support babahska. Related to that, what is the current status of compiling a meander application with graalvm? It would be nice to use meander in a clojure compiled app. I didn&apos;t test it, but I suspect that currently, a clojure app will fail to compile if it depends on meander. But I also suspect that the changes to support babashka will help in compiling meander with graalvm."><y>#</y><d>2020-11-19</d><h>10:54</h><w>jose</w>Very interesting work to support babahska. Related to that, what is the current status of compiling a meander application with graalvm? It would be nice to use meander in a clojure compiled app.
I didn&apos;t test it, but I suspect that currently, a clojure app will fail to compile if it depends on meander. But I also suspect that the changes to support babashka will help in compiling meander with graalvm.</z><z id="t1605783414" t="borkdude [:attrs {:href &quot;/_/_/users/U4NGX0FHN&quot;}] I&apos;m not sure why it would fail in GraalVM, I don&apos;t see any obstacles"><y>#</y><d>2020-11-19</d><h>10:56</h><w>borkdude</w><a>@jlle</a> I&apos;m not sure why it would fail in GraalVM, I don&apos;t see any obstacles</z><z id="t1605783440" t="borkdude I haven&apos;t tried and I&apos;m not deeply familiar with the code."><y>#</y><d>2020-11-19</d><h>10:57</h><w>borkdude</w>I haven&apos;t tried and I&apos;m not deeply familiar with the code.</z><z id="t1605783543" t="borkdude It&apos;s not hard to try it out though. Here is a small CLI: https://github.com/borkdude/puget-cli which should easily be changed to run a meander example."><y>#</y><d>2020-11-19</d><h>10:59</h><w>borkdude</w>It&apos;s not hard to try it out though. Here is a small CLI: <a href="https://github.com/borkdude/puget-cli" target="_blank">https://github.com/borkdude/puget-cli</a> which should easily be changed to run a meander example.</z><z id="t1605783743" t="jose [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] maybe not, I didn&apos;t try myself neither. I supposed that if it fails with babashka, the compilation with graalvm will fail too, but I can easily be wrong"><y>#</y><d>2020-11-19</d><h>11:02</h><w>jose</w><a>@borkdude</a> maybe not, I didn&apos;t try myself neither. I supposed that if it fails with babashka, the compilation with graalvm will fail too, but I can easily be wrong</z><z id="t1605783772" t="jose Thanks for the suggestion, I don&apos;t have the time right now, but definitely I&apos;ll try to compile meander"><y>#</y><d>2020-11-19</d><h>11:02</h><w>jose</w>Thanks for the suggestion, I don&apos;t have the time right now, but definitely I&apos;ll try to compile meander</z><z id="t1605783934" t="borkdude Babashka uses sci which is a Clojure interpreter which you can compile with GraalVM. Running code through sci is not the same as directly compiling it with GraalVM. Some things are support in one and not in the other and vice versa."><y>#</y><d>2020-11-19</d><h>11:05</h><w>borkdude</w>Babashka uses sci which is a Clojure interpreter which you can compile with GraalVM. Running code through sci is not the same as directly compiling it with GraalVM. Some things are support in one and not in the other and vice versa.</z><z id="t1605784102" t="jose I see, good to know, I assumed that if some code runs in babashka, it will compile with graalvm"><y>#</y><d>2020-11-19</d><h>11:08</h><r>jose</r>I see, good to know, I assumed that if some code runs in babashka, it will compile with graalvm</z><z id="t1605784142" t="borkdude One example: you cannot execute functions that use clojure.core/eval with graalvm, because eval needs compilation."><y>#</y><d>2020-11-19</d><h>11:09</h><r>borkdude</r>One example: you cannot execute functions that use clojure.core/eval with graalvm, because eval needs compilation.</z><z id="t1605784150" t="borkdude But you can do this with sci."><y>#</y><d>2020-11-19</d><h>11:09</h><r>borkdude</r>But you can do this with sci.</z><z id="t1605784171" t="borkdude But some things like deftype, etc are not support in sci."><y>#</y><d>2020-11-19</d><h>11:09</h><r>borkdude</r>But some things like deftype, etc are not support in sci.</z><z id="t1605811086" t="dominicm Obviously term rewriting is good for direct optimizations. But if I had a constraint on size, and had to prevent certain things from nesting, I&apos;m guessing that&apos;s out of bounds for term rewriting?"><y>#</y><d>2020-11-19</d><h>18:38</h><w>dominicm</w>Obviously term rewriting is good for direct optimizations. But if I had a constraint on size, and had to prevent certain things from nesting, I&apos;m guessing that&apos;s out of bounds for term rewriting?</z><z id="t1605812473" t="noprompt [:attrs {:href &quot;/_/_/users/U09LZR36F&quot;}] I don’t think that is necessarily true but maybe a little more context?"><y>#</y><d>2020-11-19</d><h>19:01</h><w>noprompt</w><a>@dominicm</a> I don’t think that is necessarily true but maybe a little more context?</z><z id="t1605812531" t="dominicm [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] I&apos;m thinking of writing a clojure minifier, because reasons."><y>#</y><d>2020-11-19</d><h>19:02</h><w>dominicm</w><a>@noprompt</a> I&apos;m thinking of writing a clojure minifier, because reasons.</z><z id="t1605812908" t="borkdude What&apos;s the use case and what are some of things you are thinking about?"><y>#</y><d>2020-11-19</d><h>19:08</h><r>borkdude</r>What&apos;s the use case and what are some of things you are thinking about?</z><z id="t1605812976" t="dominicm Fun :)"><y>#</y><d>2020-11-19</d><h>19:09</h><r>dominicm</r>Fun :)</z><z id="t1605813096" t="borkdude There is an open issue for clj-kondo that would help LSP find locals for renaming. This could also be used for renaming locals to minify code"><y>#</y><d>2020-11-19</d><h>19:11</h><r>borkdude</r>There is an open issue for clj-kondo that would help LSP find locals for renaming. This could also be used for renaming locals to minify code</z><z id="t1605813106" t="borkdude e.g. rename foobar to F"><y>#</y><d>2020-11-19</d><h>19:11</h><r>borkdude</r>e.g. rename foobar to F</z><z id="t1605813152" t="noprompt I need to find the time to look into these cool things. Long time fan of LSP though I’ve never made the time to put it to use in Emacs."><y>#</y><d>2020-11-19</d><h>19:12</h><r>noprompt</r>I need to find the time to look into these cool things. Long time fan of LSP though I’ve never made the time to put it to use in Emacs.</z><z id="t1605813190" t="noprompt Good place to stick rewriting."><y>#</y><d>2020-11-19</d><h>19:13</h><r>noprompt</r>Good place to stick rewriting.</z><z id="t1605813191" t="borkdude https://github.com/borkdude/clj-kondo/issues/982"><y>#</y><d>2020-11-19</d><h>19:13</h><r>borkdude</r><a href="https://github.com/borkdude/clj-kondo/issues/982" target="_blank">https://github.com/borkdude/clj-kondo/issues/982</a></z><z id="t1605813251" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] Also check out https://github.com/borkdude/carve for deleting unused vars."><y>#</y><d>2020-11-19</d><h>19:14</h><r>borkdude</r><a>@noprompt</a> Also check out <a href="https://github.com/borkdude/carve" target="_blank">https://github.com/borkdude/carve</a> for deleting unused vars.</z><z id="t1605812557" t="dominicm So can&apos;t nest #(#()) for example."><y>#</y><d>2020-11-19</d><h>19:02</h><w>dominicm</w>So can&apos;t nest #(#()) for example.</z><z id="t1605812585" t="borkdude [:attrs {:href &quot;/_/_/users/U09LZR36F&quot;}] I&apos;m working on extracting the uberscript functionality from babashka so it also works for JVM. Together with carve (cut out unused vars) this is also a kind of minifier."><y>#</y><d>2020-11-19</d><h>19:03</h><w>borkdude</w><a>@dominicm</a> I&apos;m working on extracting the uberscript functionality from babashka so it also works for JVM. Together with carve (cut out unused vars) this is also a kind of minifier.</z><z id="t1605812596" t="noprompt I’m thinking, for example, a pair of a peano number indicating the depth and the term [0 ?term] = ?term [(s ?nat) ?term] = (recur [?nat ?term*]) "><y>#</y><d>2020-11-19</d><h>19:03</h><w>noprompt</w>I’m thinking, for example, a pair of a peano number indicating the depth and the term
<pre>[0 ?term] = ?term
[(s ?nat) ?term] = (recur [?nat ?term*])</pre>
</z><z id="t1605812640" t="noprompt &gt; because reasons [:attrs {:href &quot;/_/_/users/U09LZR36F&quot;}] sounds like how I arrived 🙂"><y>#</y><d>2020-11-19</d><h>19:04</h><w>noprompt</w>&gt; because reasons

<a>@dominicm</a> sounds like how I arrived <b>🙂</b></z><z id="t1605812963" t="dominicm I&apos;m thinking of building a code golfer, and this feels like a fair addition. Maybe it&apos;s not though. But it&apos;s no fun to be beaten by your colleague who strategically added #() after seeing your solution."><y>#</y><d>2020-11-19</d><h>19:09</h><r>dominicm</r>I&apos;m thinking of building a code golfer, and this feels like a fair addition.  Maybe it&apos;s not though. But it&apos;s no fun to be beaten by your colleague who strategically added #() after seeing your solution.</z><z id="t1605813067" t="noprompt Code golf is a young mans game. 😛"><y>#</y><d>2020-11-19</d><h>19:11</h><r>noprompt</r>Code golf is a young mans game. <b>😛</b></z><z id="t1605812701" t="noprompt [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] I’m trying to grind out this interpreter code patch as fast as I can to try out."><y>#</y><d>2020-11-19</d><h>19:05</h><w>noprompt</w><a>@borkdude</a> I’m trying to grind out this interpreter code patch as fast as I can to try out.</z><z id="t1605812748" t="noprompt TBH, I could probably remove a lot of the internal use of match which is one part suck and another part not."><y>#</y><d>2020-11-19</d><h>19:05</h><w>noprompt</w>TBH, I could probably remove a lot of the internal use of <code>match</code> which is one part suck and another part not.</z><z id="t1605812768" t="borkdude sounds exciting :)"><y>#</y><d>2020-11-19</d><h>19:06</h><w>borkdude</w>sounds exciting :)</z><z id="t1605812780" t="noprompt It would definitely improve the load time for every one."><y>#</y><d>2020-11-19</d><h>19:06</h><w>noprompt</w>It would definitely improve the load time for every one.</z><z id="t1605812967" t="noprompt I’ve tried to speed up the compilation of the macros but at some point I’m comfortable with prioritizing the speed of the runtime code over the compiler speed. At the point is where the interpreter should fit in."><y>#</y><d>2020-11-19</d><h>19:09</h><w>noprompt</w>I’ve tried to speed up the compilation of the macros but at some point I’m comfortable with prioritizing the speed of the runtime code over the compiler speed. At the point is where the interpreter should fit in.</z><z id="t1605812977" t="noprompt I am quite interesting Graal FWIW."><y>#</y><d>2020-11-19</d><h>19:09</h><w>noprompt</w>I am quite interesting Graal FWIW.</z><z id="t1605813036" t="noprompt I’m interested to see how well the interpreter runs once the partial evaluation magic kicks in."><y>#</y><d>2020-11-19</d><h>19:10</h><w>noprompt</w>I’m interested to see how well the interpreter runs once the partial evaluation magic kicks in.</z><z id="t1605813125" t="markaddleman Tangentially related to this discussion: I often use cata as a subroutine of sorts. When I do this, I&apos;ve adopted an idiom along the lines of (m/rewrite something ?n (m/cata {::number !n}) [!n ...] [(m/cata {::number !n}) ...] {::number (m/pred number? ?n)} blah-blah) I vaguely remember a conversation in this channel saying that this is a pretty common idiom and that meander might adopt first-class support for it. I&apos;m just curious to follow up on that"><y>#</y><d>2020-11-19</d><h>19:12</h><w>markaddleman</w>Tangentially related to this discussion:  I often use <code>cata</code> as a subroutine of sorts.  When I do this, I&apos;ve adopted an idiom along the lines of
<pre>(m/rewrite something
   ?n
   (m/cata {::number !n})

   [!n ...]
   [(m/cata {::number !n}) ...]

   {::number (m/pred number? ?n)}
   blah-blah)</pre>
I vaguely remember a conversation in this channel saying that this is a pretty common idiom and that meander might adopt first-class support for it.  I&apos;m just curious to follow up on that</z><z id="t1605813598" t="noprompt Do you remember what was connected to that? I vaguely remember that but my memory these days, eh, is bad."><y>#</y><d>2020-11-19</d><h>19:19</h><r>noprompt</r>Do you remember what was connected to that? I vaguely remember that but my memory these days, eh, is bad.</z><z id="t1605814125" t="markaddleman heh I sympathize"><y>#</y><d>2020-11-19</d><h>19:28</h><r>markaddleman</r>heh I sympathize</z><z id="t1605814135" t="markaddleman No, I don&apos;t recall much else about the conversation."><y>#</y><d>2020-11-19</d><h>19:28</h><r>markaddleman</r>No, I don&apos;t recall much else about the conversation.</z><z id="t1605814158" t="markaddleman It is not a big issue for me."><y>#</y><d>2020-11-19</d><h>19:29</h><r>markaddleman</r>It is not a big issue for me.</z><z id="t1605814249" t="markaddleman I imagine that direct support could yield better runtime performance but my use case is not performance sensitive"><y>#</y><d>2020-11-19</d><h>19:30</h><r>markaddleman</r>I imagine that direct support could yield better runtime performance but my use case is not performance sensitive</z><z id="t1605814740" t="noprompt cata compilation will get better in time. I’m just barely starting to get time in my life back for hacking on Meander."><y>#</y><d>2020-11-19</d><h>19:39</h><r>noprompt</r><code>cata</code> compilation will get better in time. I’m just barely starting to get time in my life back for hacking on Meander.</z><z id="t1605814756" t="noprompt The paste few months have been hard on me."><y>#</y><d>2020-11-19</d><h>19:39</h><r>noprompt</r>The paste few months have been hard on me.</z><z id="t1605815164" t="markaddleman I&apos;m sorry. I hope you don&apos;t take my comments as critical. Meander has been a HUGE boon to my productivity and I appreciate all your efforts"><y>#</y><d>2020-11-19</d><h>19:46</h><r>markaddleman</r>I&apos;m sorry.  I hope you don&apos;t take my comments as critical.  Meander has been a HUGE boon to my productivity and I appreciate all your efforts</z><z id="t1605815398" t="noprompt &gt; I hope you don’t take my comments as critical Not at all! 🙂"><y>#</y><d>2020-11-19</d><h>19:49</h><r>noprompt</r>&gt; I hope you don’t take my comments as critical
Not at all! <b>🙂</b></z><z id="t1605815455" t="noprompt I love this project, this channel, and the little community of we’ve established here around this stuff. I like making people happy and get sad when I can’t. 🙂"><y>#</y><d>2020-11-19</d><h>19:50</h><r>noprompt</r>I love this project, this channel, and the little community of we’ve established here around this stuff. I like making people happy and get sad when I can’t. <b>🙂</b></z><z id="t1605815595" t="markaddleman In general, the Clojure community is very friendly. Meander community is even more so 🙂"><y>#</y><d>2020-11-19</d><h>19:53</h><r>markaddleman</r>In general, the Clojure community is very friendly.  Meander community is even more so <b>🙂</b></z><z id="t1605819879" t="noprompt OK I’m like 80% done with an initial interpreter worthy of kicking around."><y>#</y><d>2020-11-19</d><h>21:04</h><w>noprompt</w>OK I’m like 80% done with an initial interpreter worthy of kicking around.</z><z id="t1605819966" t="dominicm So just 80% left to go? :)"><y>#</y><d>2020-11-19</d><h>21:06</h><w>dominicm</w>So just 80% left to go? :)</z><z id="t1605820009" t="noprompt LOL"><y>#</y><d>2020-11-19</d><h>21:06</h><w>noprompt</w>LOL</z><z id="t1605820066" t="noprompt I just meant that I have a rough draft that is sturdy enough to use at your own risk. 🙂"><y>#</y><d>2020-11-19</d><h>21:07</h><w>noprompt</w>I just meant that I have a rough draft that is sturdy enough to use at your own risk. <b>🙂</b></z><z id="t1605820089" t="noprompt I’m trying to minimize the at your own risk part as a courtesy, however. 😂"><y>#</y><d>2020-11-19</d><h>21:08</h><w>noprompt</w>I’m trying to minimize the at your own risk part as a courtesy, however. <b>😂</b></z><z id="t1605823730" t="noprompt (ns scratch (:require [meander.interpreter.epsilon :as m])) (def search-a (m/searcher &apos;(m/re #&quot;(.)(.)(.)&quot; (m/and [?0 ?1 ?2 ?2] [!0 ...])) (fn [{:syms [?0 !0]}] [?0 !0]) &apos;(m/re #&quot;f(.*)&quot; [!0 ?0 . !0 ...]) (fn [{:syms [?0 !0]}] [?0 !0]))) (search-a &quot;foo&quot;) ;; =&gt; ([&quot;foo&quot; [&quot;foo&quot; &quot;f&quot; &quot;o&quot; &quot;o&quot;]] [&quot;oo&quot; [&quot;foo&quot;]]) (search-a &quot;foe&quot;) ;; =&gt; ([&quot;oe&quot; [&quot;foe&quot;]]) "><y>#</y><d>2020-11-19</d><h>22:08</h><w>noprompt</w><pre>(ns scratch
  (:require [meander.interpreter.epsilon :as m]))

(def search-a
  (m/searcher
   &apos;(m/re #&quot;(.)(.)(.)&quot; (m/and [?0 ?1 ?2 ?2] [!0 ...]))
   (fn [{:syms [?0 !0]}]
     [?0 !0])

   &apos;(m/re #&quot;f(.*)&quot; [!0 ?0 . !0 ...])
   (fn [{:syms [?0 !0]}]
     [?0 !0])))
  
(search-a &quot;foo&quot;)
;; =&gt; ([&quot;foo&quot; [&quot;foo&quot; &quot;f&quot; &quot;o&quot; &quot;o&quot;]] [&quot;oo&quot; [&quot;foo&quot;]])
(search-a &quot;foe&quot;)
;; =&gt; ([&quot;oe&quot; [&quot;foe&quot;]])</pre>
</z><z id="t1605823745" t="noprompt Seems like this could work"><y>#</y><d>2020-11-19</d><h>22:09</h><w>noprompt</w>Seems like this could work</z><z id="t1605823756" t="noprompt What do y’all think?"><y>#</y><d>2020-11-19</d><h>22:09</h><w>noprompt</w>What do y’all think?</z><z id="t1605829246" t="noprompt JHOLDBRO-M-C65T.jholdbro=&gt; rlwrap bb --classpath src Babashka v0.2.3 REPL. Use :repl/quit or :repl/exit to quit the REPL. Clojure rocks, Bash reaches. user=&gt; (require &apos;[meander.interpreter.epsilon :as m]) nil user=&gt; (def s1 (m/searcher &apos;(m/re #&quot;f(.)(.)&quot; [_ ?x ?x]) #(get % &apos;?x))) #&apos;user/s1 user=&gt; (s1 &quot;foo&quot;) (&quot;o&quot;) user=&gt; (s1 &quot;faa&quot;) (&quot;a&quot;) user=&gt; (s1 &quot;f11&quot;) (&quot;1&quot;) [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] works"><y>#</y><d>2020-11-19</d><h>23:40</h><w>noprompt</w><pre>JHOLDBRO-M-C65T.jholdbro=&gt; rlwrap bb --classpath src
Babashka v0.2.3 REPL.
Use :repl/quit or :repl/exit to quit the REPL.
Clojure rocks, Bash reaches.

user=&gt; (require &apos;[meander.interpreter.epsilon :as m])
nil
user=&gt; (def s1 (m/searcher &apos;(m/re #&quot;f(.)(.)&quot; [_ ?x ?x]) #(get % &apos;?x)))
#&apos;user/s1
user=&gt; (s1 &quot;foo&quot;)
(&quot;o&quot;)
user=&gt; (s1 &quot;faa&quot;)
(&quot;a&quot;)
user=&gt; (s1 &quot;f11&quot;)
(&quot;1&quot;)</pre>
<a>@borkdude</a> works</z><z id="t1605829348" t="noprompt It appears to be very fast."><y>#</y><d>2020-11-19</d><h>23:42</h><w>noprompt</w>It appears to be very fast.</z><z id="t1605829512" t="noprompt Well, sort of."><y>#</y><d>2020-11-19</d><h>23:45</h><w>noprompt</w>Well, sort of.</z><z id="t1605829547" t="noprompt ;; Clojure (with-out-str (time (dotimes [_ 10000] (doall (search-a &quot;foe&quot;))))) &quot;\&quot;Elapsed time: 253.965799 msecs\&quot;\n&quot; ;; Babashka (with-out-str (time (dotimes [_ 10000] (doall (search-a &quot;foe&quot;))))) &quot;\&quot;Elapsed time: 3284.494238 msecs\&quot;\n"><y>#</y><d>2020-11-19</d><h>23:45</h><w>noprompt</w><pre>;; Clojure
(with-out-str (time (dotimes [_ 10000] (doall (search-a &quot;foe&quot;)))))
&quot;\&quot;Elapsed time: 253.965799 msecs\&quot;\n&quot;
;; Babashka
(with-out-str (time (dotimes [_ 10000] (doall (search-a &quot;foe&quot;)))))
&quot;\&quot;Elapsed time: 3284.494238 msecs\&quot;\n</pre></z><z id="t1605829562" t="noprompt Not sure what’s going on here."><y>#</y><d>2020-11-19</d><h>23:46</h><w>noprompt</w>Not sure what’s going on here.</z><z id="t1605829633" t="noprompt ;; Clojure (with-out-str (time (doall (search-a &quot;foe&quot;)))) &quot;\&quot;Elapsed time: 0.012454 msecs\&quot;\n&quot; ;; Babashka (with-out-str (time (doall (search-a &quot;foe&quot;)))) &quot;\&quot;Elapsed time: 0.814953 msecs\&quot;\n&quot; "><y>#</y><d>2020-11-19</d><h>23:47</h><w>noprompt</w><pre>;; Clojure
(with-out-str (time (doall (search-a &quot;foe&quot;))))
&quot;\&quot;Elapsed time: 0.012454 msecs\&quot;\n&quot;
;; Babashka
(with-out-str (time (doall (search-a &quot;foe&quot;))))
&quot;\&quot;Elapsed time: 0.814953 msecs\&quot;\n&quot;</pre>
</z><z id="t1605830108" t="noprompt In terms of performance, for this example, interpretation is going to be slower over all, however, it’s also going to be more flexible. (defn search-b [s] (me/search s (me/re #&quot;(.)(.)(.)&quot; (me/and [?0 ?1 ?2 ?2] [!0 ...])) [?0 !0] (me/re #&quot;f(.*)&quot; [!0 ?0 . !0 ...]) [?0 !0])) [(with-out-str (time (dotimes [_ 10000] (doall (search-a &quot;foe&quot;))))) (with-out-str (time (dotimes [_ 10000] (doall (search-b &quot;foe&quot;)))))] ;;=&gt; [&quot;\&quot;Elapsed time: 120.945113 msecs\&quot;\n&quot; &quot;\&quot;Elapsed time: 15.265521 msecs\&quot;\n&quot;] "><y>#</y><d>2020-11-19</d><h>23:55</h><w>noprompt</w>In terms of performance, for this example, interpretation is going to be slower over all, however, it’s also going to be more flexible.
<pre>(defn search-b [s]
  (me/search s
    (me/re #&quot;(.)(.)(.)&quot; (me/and [?0 ?1 ?2 ?2] [!0 ...]))
    [?0 !0]

    (me/re #&quot;f(.*)&quot; [!0 ?0 . !0 ...])
    [?0 !0]))

[(with-out-str (time (dotimes [_ 10000] (doall (search-a &quot;foe&quot;)))))
 (with-out-str (time (dotimes [_ 10000] (doall (search-b &quot;foe&quot;)))))]
;;=&gt;
[&quot;\&quot;Elapsed time: 120.945113 msecs\&quot;\n&quot;
 &quot;\&quot;Elapsed time: 15.265521 msecs\&quot;\n&quot;]</pre>
</z><z id="t1605830169" t="noprompt It’s likely possible to close that gap on this a bit using, say, an approach similar to Egison."><y>#</y><d>2020-11-19</d><h>23:56</h><w>noprompt</w>It’s likely possible to close that gap on this a bit using, say, an approach similar to Egison.</z><z id="t1605830262" t="noprompt Or using ye olde matrix style pattern matching compilation but, of course, to functions instead of code."><y>#</y><d>2020-11-19</d><h>23:57</h><w>noprompt</w>Or using ye olde matrix style pattern matching compilation but, of course, to functions instead of code.</z><z id="t1605830351" t="noprompt Variables would need to have their names changed to protect the innocent."><y>#</y><d>2020-11-19</d><h>23:59</h><w>noprompt</w>Variables would need to have their names changed to protect the innocent.</z><z id="t1605830524" t="noprompt I really would like to spend my time on getting zeta off the ground once this is sorted out."><y>#</y><d>2020-11-20</d><h>00:02</h><w>noprompt</w>I really would like to spend my time on getting <code>zeta</code> off the ground once this is sorted out.</z><z id="t1605830612" t="noprompt Because there — and I really need to push up what I have on disk — the core API is based on combinators which are backed by objects, with protocols, etc."><y>#</y><d>2020-11-20</d><h>00:03</h><w>noprompt</w>Because there — and I really need to push up what I have on disk — the core API is based on combinators which are backed by objects, with protocols, etc.</z><z id="t1605830653" t="noprompt There are protocols for both interpretation and compilation."><y>#</y><d>2020-11-20</d><h>00:04</h><w>noprompt</w>There are protocols for both interpretation and compilation.</z><z id="t1605830732" t="noprompt OT bb makes me think of Death Stranding every time I type it. 🙂"><y>#</y><d>2020-11-20</d><h>00:05</h><w>noprompt</w>OT <code>bb</code> makes me think of Death Stranding every time I type it. <b>🙂</b></z><z id="t1605843032" t="markaddleman fyi - the docs on the latest build have failed: https://cljdoc.org/d/meander/epsilon/0.0.533"><y>#</y><d>2020-11-20</d><h>03:30</h><w>markaddleman</w>fyi - the docs on the latest build have failed: <a href="https://cljdoc.org/d/meander/epsilon/0.0.533" target="_blank">https://cljdoc.org/d/meander/epsilon/0.0.533</a></z><z id="t1605861955" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] This is awesome! How you can best compare bb to JVM Clojure is usage in short-lived scripts that you invoke from the command line. E.g. $ cat /tmp/meander.clj (time (require &apos;[meander.interpreter.epsilon :as m])) (def s1 (m/searcher &apos;(m/re #&quot;f(.)(.)&quot; [_ ?x ?x]) #(get % &apos;?x))) (time (prn (s1 &quot;foo&quot;))) $ time bb -cp src -f /tmp/meander.clj &quot;Elapsed time: 113.051096 msecs&quot; (&quot;o&quot;) &quot;Elapsed time: 1.556163 msecs&quot; bb -cp src -f /tmp/meander.clj 0.10s user 0.04s system 95% cpu 0.145 total vs $ time clojure -M /tmp/meander.clj &quot;Elapsed time: 726.401638 msecs&quot; (&quot;o&quot;) &quot;Elapsed time: 5.592018 msecs&quot; clojure -M /tmp/meander.clj 3.57s user 0.20s system 221% cpu 1.697 total "><y>#</y><d>2020-11-20</d><h>08:45</h><w>borkdude</w><a>@noprompt</a> This is awesome!
How you can best compare bb to JVM Clojure is usage in short-lived scripts that you invoke from the command line.
E.g.
<pre>$ cat /tmp/meander.clj
(time (require &apos;[meander.interpreter.epsilon :as m]))
(def s1 (m/searcher &apos;(m/re #&quot;f(.)(.)&quot; [_ ?x ?x]) #(get % &apos;?x)))
(time (prn (s1 &quot;foo&quot;)))

$ time bb -cp src -f /tmp/meander.clj
&quot;Elapsed time: 113.051096 msecs&quot;
(&quot;o&quot;)
&quot;Elapsed time: 1.556163 msecs&quot;
bb -cp src -f /tmp/meander.clj  0.10s user 0.04s system 95% cpu 0.145 total</pre>
vs
<pre>$ time clojure -M /tmp/meander.clj
&quot;Elapsed time: 726.401638 msecs&quot;
(&quot;o&quot;)
&quot;Elapsed time: 5.592018 msecs&quot;
clojure -M /tmp/meander.clj  3.57s user 0.20s system 221% cpu 1.697 total</pre>
</z><z id="t1605862055" t="borkdude Babashka doesn&apos;t have the JIT of the JVM and also loops are much more costly in babashka. So for dotimes 10000 examples the JVM will always be much faster. But the above use case is really where bb shines."><y>#</y><d>2020-11-20</d><h>08:47</h><w>borkdude</w>Babashka doesn&apos;t have the JIT of the JVM and also loops are much more costly in babashka. So for dotimes 10000 examples the JVM will always be much faster. But the above use case is really where bb shines.</z><z id="t1605865162" t="borkdude There&apos;s probably a thing or two that can be optimized in babashka itself. I welcome ideas and contributions :)"><y>#</y><d>2020-11-20</d><h>09:39</h><w>borkdude</w>There&apos;s probably a thing or two that can be optimized in babashka itself. I welcome ideas and contributions :)</z><z id="t1605892341" t="noprompt [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] Thanks for clearing that up!"><y>#</y><d>2020-11-20</d><h>17:12</h><w>noprompt</w><a>@borkdude</a> Thanks for clearing that up!</z><z id="t1605892413" t="borkdude I hope to do many optimizations in years to come. It&apos;s nice to have a side project where you can probably spend years on improving it ;)"><y>#</y><d>2020-11-20</d><h>17:13</h><w>borkdude</w>I hope to do many optimizations in years to come. It&apos;s nice to have a side project where you can probably spend years on improving it ;)</z><z id="t1605892497" t="noprompt Totally. It’s also nice to have a great community of folks supplying you with a steady stream of praise and critique. 🙂"><y>#</y><d>2020-11-20</d><h>17:14</h><w>noprompt</w>Totally. It’s also nice to have a great community of folks supplying you with a steady stream of praise and critique. <b>🙂</b></z><z id="t1605892509" t="noprompt This benefits everyone."><y>#</y><d>2020-11-20</d><h>17:15</h><w>noprompt</w>This benefits everyone.</z><z id="t1605892599" t="noprompt What was cool here is that this sort of forced me to take a look at something — babashka — which I have wanted to test out but hadn’t made the time yet."><y>#</y><d>2020-11-20</d><h>17:16</h><w>noprompt</w>What was cool here is that this sort of forced me to take a look at something — babashka — which I have wanted to test out but hadn’t made the time yet.</z><z id="t1605892659" t="noprompt Someone cough [:attrs {:href &quot;/_/_/users/U0BUV7XSA&quot;}] cough should flag an annoyance that forces my hand into the LSP space. 😛"><y>#</y><d>2020-11-20</d><h>17:17</h><w>noprompt</w>Someone cough <a>@snoe</a> cough should flag an annoyance that forces my hand into the LSP space. <b>😛</b></z><z id="t1605892715" t="noprompt Now that I have bb installed I can whip up some fun command line data slice and dice."><y>#</y><d>2020-11-20</d><h>17:18</h><w>noprompt</w>Now that I have <code>bb</code> installed I can whip up some fun command line data slice and dice.</z></g><g id="s7"><z id="t1605892839" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] Let me know when you release the interpreter bits. I&apos;ll make a mention at - https://github.com/borkdude/babashka/blob/master/doc/news.md - https://github.com/borkdude/babashka/blob/master/doc/libraries.md"><y>#</y><d>2020-11-20</d><h>17:20</h><w>borkdude</w><a>@noprompt</a> Let me know when you release the interpreter bits. I&apos;ll make a mention at
- <a href="https://github.com/borkdude/babashka/blob/master/doc/news.md" target="_blank">https://github.com/borkdude/babashka/blob/master/doc/news.md</a>
- <a href="https://github.com/borkdude/babashka/blob/master/doc/libraries.md" target="_blank">https://github.com/borkdude/babashka/blob/master/doc/libraries.md</a></z><z id="t1605892874" t="noprompt [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] I would probably like hacking on babashka but I have this project, Asami at work that I’m helping with, and other work/family responsibilities."><y>#</y><d>2020-11-20</d><h>17:21</h><w>noprompt</w><a>@borkdude</a> I would probably like hacking on babashka but I have this project, Asami at work that I’m helping with, and other work/family responsibilities.</z><z id="t1605892895" t="noprompt Maybe next year I’ll have some time."><y>#</y><d>2020-11-20</d><h>17:21</h><w>noprompt</w>Maybe next year I’ll have some time.</z><z id="t1605892926" t="noprompt The situation with Covid really hit me hard. My 3 kids are home 90% of the time."><y>#</y><d>2020-11-20</d><h>17:22</h><w>noprompt</w>The situation with Covid really hit me hard. My 3 kids are home 90% of the time.</z><z id="t1605892963" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] The interpreter powering bb is https://github.com/borkdude/sci You can use this to create your own CLIs that have Clojure interpretation. There could be a meander CLI. I&apos;ve recently made a CLI that uses clojure.spec: https://github.com/borkdude/grasp#binary"><y>#</y><d>2020-11-20</d><h>17:22</h><w>borkdude</w><a>@noprompt</a> The interpreter powering bb is <a href="https://github.com/borkdude/sci" target="_blank">https://github.com/borkdude/sci</a>
You can use this to create your own CLIs that have Clojure interpretation. There could be a meander CLI.
I&apos;ve recently made a CLI that uses clojure.spec: <a href="https://github.com/borkdude/grasp#binary" target="_blank">https://github.com/borkdude/grasp#binary</a></z><z id="t1605893041" t="borkdude echo &lt;some edn&gt; | meander -e &quot;....&quot;"><y>#</y><d>2020-11-20</d><h>17:24</h><w>borkdude</w>echo &lt;some edn&gt; | meander -e &quot;....&quot;</z><z id="t1605893245" t="borkdude &gt; The situation with Covid really hit me hard. My 3 kids are home 90% of the time. Oof, wish you the best in these hard times!"><y>#</y><d>2020-11-20</d><h>17:27</h><w>borkdude</w>&gt; The situation with Covid really hit me hard. My 3 kids are home 90% of the time.
Oof, wish you the best in these hard times!</z><z id="t1605893372" t="noprompt Yeah, two things I’ve wanted to experiment with but have since put on the back burner are partially evaluated, and small step interpreted Clojure. If I were cool enough, I’d try gluing the two together."><y>#</y><d>2020-11-20</d><h>17:29</h><w>noprompt</w>Yeah, two things I’ve wanted to experiment with but have since put on the back burner are partially evaluated, and small step interpreted Clojure. If I were cool enough, I’d try gluing the two together.</z><z id="t1605893428" t="noprompt Somehow I learned about term rewriting during my initial experiments and here I am."><y>#</y><d>2020-11-20</d><h>17:30</h><w>noprompt</w>Somehow I learned about term rewriting during my initial experiments and here I am.</z><z id="t1605893562" t="noprompt I’ll make a test suite for the interpreter, cut a release, and then we can add a test suite for bb"><y>#</y><d>2020-11-20</d><h>17:32</h><w>noprompt</w>I’ll make a test suite for the interpreter, cut a release, and then we can add a test suite for <code>bb</code></z><z id="t1605893939" t="noprompt [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] One of the ideas I have — and maybe we can mutually inspire each other on this one — is to create an interactive search and replace experience based on rewriting. I’m imaging something integrated into an editor where you have input area for the search, an optional one for the replacement, and an output area which display the search results and, optionally, their transformation based on the rewrite rule."><y>#</y><d>2020-11-20</d><h>17:38</h><w>noprompt</w><a>@borkdude</a> One of the ideas I have — and maybe we can mutually inspire each other on this one — is to create an interactive search and replace experience based on rewriting. I’m imaging something integrated into an editor where you have input area for the search, an optional one for the replacement, and an output area which display the search results and, optionally, their transformation based on the rewrite rule.</z><z id="t1605893995" t="noprompt You could even imagine this operating at a “meta syntax” level where in the rewrite rules are operating on the AST instead of the form directly, etc."><y>#</y><d>2020-11-20</d><h>17:39</h><w>noprompt</w>You could even imagine this operating at a “meta syntax” level where in the rewrite rules are operating on the AST instead of the form directly, etc.</z><z id="t1605894057" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] This could be useful for clj-kondo hooks as well maybe. As a higher level DSL. https://github.com/borkdude/clj-kondo/blob/master/doc/hooks.md clj-kondo hooks are functions that do rewriting of rewrite-clj nodes to teach clj-kondo about custom macros"><y>#</y><d>2020-11-20</d><h>17:40</h><w>borkdude</w><a>@noprompt</a> This could be useful for clj-kondo hooks as well maybe. As a higher level DSL.
<a href="https://github.com/borkdude/clj-kondo/blob/master/doc/hooks.md" target="_blank">https://github.com/borkdude/clj-kondo/blob/master/doc/hooks.md</a>
clj-kondo hooks are functions that do rewriting of rewrite-clj nodes to teach clj-kondo about custom macros</z><z id="t1605894091" t="noprompt Often what I do with meander when I want to edit code in this way, is copy a form, quote it, and then start hammering on it with m/rewrite and C-c C-f in Emacs until I get the desired result. Then I copy, paste, format."><y>#</y><d>2020-11-20</d><h>17:41</h><w>noprompt</w>Often what I do with meander when I want to edit code in this way, is copy a form, quote it, and then start hammering on it with <code>m/rewrite</code> and <code>C-c C-f</code> in Emacs until I get the desired result. Then I copy, paste, format.</z><z id="t1605894553" t="noprompt [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] I could probably answer this myself but I’m lazy so, does sci use it’s own reader?"><y>#</y><d>2020-11-20</d><h>17:49</h><w>noprompt</w><a>@borkdude</a> I could probably answer this myself but I’m lazy so, does sci use it’s own reader?</z><z id="t1605894670" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] it uses https://github.com/borkdude/edamame"><y>#</y><d>2020-11-20</d><h>17:51</h><w>borkdude</w><a>@noprompt</a> it uses <a href="https://github.com/borkdude/edamame" target="_blank">https://github.com/borkdude/edamame</a></z><z id="t1605990642" t="markaddleman I&apos;m having some trouble understanding how map-of works. How would I use it to produce a map of keys to a vector of odd numbers? (m/rewrite {:a [1 2 3] :b [4 5 6]} (m/map-of !ks ___) (m/map-of !ks !vector-of-odds)) "><y>#</y><d>2020-11-21</d><h>20:30</h><w>markaddleman</w>I&apos;m having some trouble understanding how <code>map-of</code>  works.  How would I use it to produce a map of keys to a vector of odd numbers?
<pre>(m/rewrite {:a [1 2 3]
              :b [4 5 6]}
    (m/map-of !ks ___)
    (m/map-of !ks !vector-of-odds))</pre>
</z><z id="t1605991248" t="noprompt map-of matches all entries with the key and value pattern respectively, for substitution it builds a map from the key and value patterns respectively."><y>#</y><d>2020-11-21</d><h>20:40</h><r>noprompt</r><code>map-of</code> matches all entries with the key and value pattern respectively, for substitution it builds a map from the key and value patterns respectively.</z><z id="t1605991263" t="noprompt (me/rewrite {:a [1 2 3] :b [4 5 6]} (me/map-of !ks (me/gather (me/pred odd? !odds))) (me/map-of !ks !odds)) ;; =&gt; {:a 1, :b 3} "><y>#</y><d>2020-11-21</d><h>20:41</h><r>noprompt</r><pre>(me/rewrite {:a [1 2 3]
             :b [4 5 6]}
  (me/map-of !ks (me/gather (me/pred odd? !odds)))
  (me/map-of !ks !odds))
;; =&gt;
{:a 1, :b 3}</pre>
</z><z id="t1605991352" t="noprompt If you’re interested in mapping the keys to their respective odd numbers that would require a bit more effort."><y>#</y><d>2020-11-21</d><h>20:42</h><r>noprompt</r>If you’re interested in mapping the keys to their respective odd numbers that would require a bit more effort.</z><z id="t1605991435" t="noprompt (me/rewrite {:a [1 2 3] :b [4 5 6]} {?k (me/gather (me/pred odd? !odds)) &amp; ?rest-map} {?k [!odds ...] &amp; (me/cata ?rest-map)} ?x ?x) ;; =&gt; {:b [5], :a [1 3]} "><y>#</y><d>2020-11-21</d><h>20:43</h><r>noprompt</r><pre>(me/rewrite {:a [1 2 3]
             :b [4 5 6]}
  {?k (me/gather (me/pred odd? !odds)) &amp; ?rest-map}
  {?k [!odds ...] &amp; (me/cata ?rest-map)}

  ?x
  ?x)
;; =&gt;
{:b [5], :a [1 3]}</pre>
</z><z id="t1605992624" t="markaddleman Thanks, I was thinking about the second case"><y>#</y><d>2020-11-21</d><h>21:03</h><r>markaddleman</r>Thanks, I was thinking about the second case</z><z id="t1605992675" t="markaddleman I see that map-of was the wrong direction to go"><y>#</y><d>2020-11-21</d><h>21:04</h><r>markaddleman</r>I see that map-of was the wrong direction to go</z><z id="t1605992882" t="noprompt Glad I could help. 🙂"><y>#</y><d>2020-11-21</d><h>21:08</h><r>noprompt</r>Glad I could help. <b>🙂</b></z><z id="t1606153344" t="noprompt FYI I’ve been working on getting the interpreter at place where you can choose match/find/search semantics. Almost done."><y>#</y><d>2020-11-23</d><h>17:42</h><w>noprompt</w>FYI I’ve been working on getting the interpreter at place where you can choose match/find/search semantics. Almost done.</z><z id="t1606153377" t="noprompt I spent some time on Friday figuring out to make that workable."><y>#</y><d>2020-11-23</d><h>17:42</h><w>noprompt</w>I spent some time on Friday figuring out to make that workable.</z><z id="t1606244106" t="noprompt ((finder &apos;{?k ?v} identity) {:a 1 :b 2}) ;; =&gt; {?k :a, ?v 1} ((searcher &apos;{?k ?v} identity) {:a 1 :b 2}) ;; =&gt; ({?k :a, ?v 1} {?k :b, ?v 2}) "><y>#</y><d>2020-11-24</d><h>18:55</h><w>noprompt</w><pre>((finder &apos;{?k ?v} identity) {:a 1 :b 2})
;; =&gt;
{?k :a, ?v 1}

((searcher &apos;{?k ?v} identity) {:a 1 :b 2})
;; =&gt;
({?k :a, ?v 1} {?k :b, ?v 2})</pre>
</z><z id="t1606244153" t="noprompt https://github.com/noprompt/meander/blob/7a401dd2176f56bfdc7c6325f416adfc91c1b198/src/meander/interpreter/epsilon.cljc"><y>#</y><d>2020-11-24</d><h>18:55</h><w>noprompt</w><a href="https://github.com/noprompt/meander/blob/7a401dd2176f56bfdc7c6325f416adfc91c1b198/src/meander/interpreter/epsilon.cljc" target="_blank">https://github.com/noprompt/meander/blob/7a401dd2176f56bfdc7c6325f416adfc91c1b198/src/meander/interpreter/epsilon.cljc</a></z><z id="t1606244231" t="noprompt There are details about the implementation in the comments but the gist here is that there is a framework for building up pattern matchers functionally. For now, this framework is largely private and only REPL tested and approved."><y>#</y><d>2020-11-24</d><h>18:57</h><w>noprompt</w>There are details about the implementation in the comments but the gist here is that there is a framework for building up pattern matchers functionally. For now, this framework is largely private and only REPL tested and approved.</z><z id="t1606244356" t="noprompt The reason it is private is because 1. there are no unit tests, 2. there is no interpretation for substitution, and 3. pending the substitution interpretation I may want to move things around."><y>#</y><d>2020-11-24</d><h>18:59</h><w>noprompt</w>The reason it is private is because
1. there are no unit tests,
2. there is no interpretation for substitution, and
3. pending the substitution interpretation I may want to move things around.</z><z id="t1606244607" t="noprompt What is nice, however, is that this model is pretty flexible and once the second items is taken care of and things can be made public, more interesting runtimes can be developed."><y>#</y><d>2020-11-24</d><h>19:03</h><w>noprompt</w>What is nice, however, is that this model is pretty flexible and once the second items is taken care of and things can be made public, more interesting runtimes can be developed.</z><z id="t1606244879" t="noprompt $ bb --classpath src Babashka v0.2.3 REPL. Use :repl/quit or :repl/exit to quit the REPL. Clojure rocks, Bash reaches. user=&gt; (require &apos;[meander.interpreter.epsilon :as m]) nil user=&gt; (m/searcher &apos;{?k ?v} identity) #object[sci.impl.fns$eval_fn$fn__12966 0x5212d6ab &quot;sci.impl.fns$eval_fn$fn__12966@11052c160&quot;] user=&gt; (*1 {:a 1 :b 2 :c 3}) ({?k :c, ?v 3} {?k :b, ?v 2} {?k :a, ?v 1}) user=&gt; (m/finder &apos;{?k ?v} identity) #object[sci.impl.fns$eval_fn$fn__12966 0x62700f6 &quot;sci.impl.fns$eval_fn$fn__12966@1109c9048&quot;] user=&gt; (*1 {:a 1 :b 2 :c 3}) {?k :c, ?v 3} "><y>#</y><d>2020-11-24</d><h>19:07</h><w>noprompt</w><pre>$ bb --classpath src
Babashka v0.2.3 REPL.
Use :repl/quit or :repl/exit to quit the REPL.
Clojure rocks, Bash reaches.

user=&gt; (require &apos;[meander.interpreter.epsilon :as m])
nil
user=&gt; (m/searcher &apos;{?k ?v} identity)
#object[sci.impl.fns$eval_fn$fn__12966 0x5212d6ab &quot;sci.impl.fns$eval_fn$fn__12966@11052c160&quot;]
user=&gt; (*1 {:a 1 :b 2 :c 3})
({?k :c, ?v 3} {?k :b, ?v 2} {?k :a, ?v 1})
user=&gt; (m/finder &apos;{?k ?v} identity)
#object[sci.impl.fns$eval_fn$fn__12966 0x62700f6 &quot;sci.impl.fns$eval_fn$fn__12966@1109c9048&quot;]
user=&gt; (*1 {:a 1 :b 2 :c 3})
{?k :c, ?v 3}</pre>
</z><z id="t1606244976" t="noprompt The runtime bit is nice. Both searcher and finder use the same factory functions to build up an über factory which takes a runtime and produces a implementation specific matching function."><y>#</y><d>2020-11-24</d><h>19:09</h><w>noprompt</w>The runtime bit is nice. Both <code>searcher</code> and <code>finder</code> use the same factory functions to build up an über factory which takes a runtime and produces a implementation specific matching function.</z><z id="t1606245017" t="noprompt In the case of searcher it produces a sequence of results; with finder it reduces the space down to the first one it finds. The details are in the runtime."><y>#</y><d>2020-11-24</d><h>19:10</h><w>noprompt</w>In the case of <code>searcher</code> it produces a sequence of results; with <code>finder</code> it reduces the space down to the first one it finds. The details are in the runtime.</z><z id="t1606259592" t="noprompt Before I merge, cut, and release, I need to add some unit tests for the interpreter namespace."><y>#</y><d>2020-11-24</d><h>23:13</h><w>noprompt</w>Before I merge, cut, and release, I need to add some unit tests for the interpreter namespace.</z><z id="t1606575388" t="markaddleman This seems odd: (m/search [{:a &quot;a&quot;} :b] [(m/$ {:a (m/some ?a)}) ?b] [?a ?b]) =&gt; ([&quot;a&quot; nil]) while (m/search [{:a &quot;a&quot;} :b] [(m/$ _ {:a (m/some ?a)}) ?b] [?a ?b]) =&gt; ([&quot;a&quot; :b]) The only difference between the two is the second m/$ operation includes an anonymous context binding"><y>#</y><d>2020-11-28</d><h>14:56</h><w>markaddleman</w>This seems odd:
<pre>(m/search [{:a &quot;a&quot;} :b]
    [(m/$ {:a (m/some ?a)}) ?b]
    [?a ?b]) =&gt; ([&quot;a&quot; nil])</pre>
while
<pre>(m/search [{:a &quot;a&quot;} :b]
    [(m/$ _ {:a (m/some ?a)}) ?b]
    [?a ?b]) =&gt; ([&quot;a&quot; :b])</pre>
The only difference between the two is the second <code>m/$</code> operation includes an anonymous context binding</z><z id="t1606754372" t="noprompt Fixed the bug. Just waiting for the build…"><y>#</y><d>2020-11-30</d><h>16:39</h><r>noprompt</r>Fixed the bug. Just waiting for the build…</z><z id="t1606754372" t="noprompt Fixed the bug. Just waiting for the build…"><y>#</y><d>2020-11-30</d><h>16:39</h><w>noprompt</w>Fixed the bug. Just waiting for the build…</z><z id="t1606752393" t="noprompt [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] Looks like a bug. Will fix."><y>#</y><d>2020-11-30</d><h>16:06</h><w>noprompt</w><a>@markaddleman</a> Looks like a bug. Will fix.</z><z id="t1606756997" t="noprompt https://clojars.org/meander/epsilon/versions/0.0.543"><y>#</y><d>2020-11-30</d><h>17:23</h><w>noprompt</w><a href="https://clojars.org/meander/epsilon/versions/0.0.543" target="_blank">https://clojars.org/meander/epsilon/versions/0.0.543</a></z><z id="t1606757011" t="noprompt [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] This should fix it!"><y>#</y><d>2020-11-30</d><h>17:23</h><w>noprompt</w><a>@markaddleman</a> This should fix it!</z><z id="t1606757050" t="markaddleman Thanks! I&apos;ll pull it into my project later today"><y>#</y><d>2020-11-30</d><h>17:24</h><r>markaddleman</r>Thanks!  I&apos;ll pull it into my project later today</z><z id="t1606757656" t="noprompt Should also fix the broken documentation build."><y>#</y><d>2020-11-30</d><h>17:34</h><w>noprompt</w>Should also fix the broken documentation build.</z><z id="t1606785914" t="noprompt Meant to post this earlier: https://www.youtube.com/watch?v=yJWUar1yyOc"><y>#</y><d>2020-12-01</d><h>01:25</h><w>noprompt</w>Meant to post this earlier: <a href="https://www.youtube.com/watch?v=yJWUar1yyOc" target="_blank">https://www.youtube.com/watch?v=yJWUar1yyOc</a></z><z id="t1606785942" t="noprompt This is how I’m feeling at the moment. 🙂"><y>#</y><d>2020-12-01</d><h>01:25</h><w>noprompt</w>This is how I’m feeling at the moment. <b>🙂</b></z><z id="t1606786110" t="noprompt The little song at the beginning. Not the whole video. 😂"><y>#</y><d>2020-12-01</d><h>01:28</h><w>noprompt</w>The little song at the beginning. Not the whole video. <b>😂</b></z><z id="t1606815250" t="dominicm Oh, is that Richard Ayoade"><y>#</y><d>2020-12-01</d><h>09:34</h><w>dominicm</w>Oh, is that Richard Ayoade</z><z id="t1606842392" t="noprompt I’m not sure? But my kids and I love this show."><y>#</y><d>2020-12-01</d><h>17:06</h><w>noprompt</w>I’m not sure? But my kids and I love this show.</z><z id="t1606842417" t="Jimmy Miller It is. That was the first thing I noticed as well."><y>#</y><d>2020-12-01</d><h>17:06</h><w>Jimmy Miller</w>It is. That was the first thing I noticed as well.</z><z id="t1606843379" t="noprompt Does anyone know this person? https://reclojure.org/2020-speakers/paulo-feodrippe.html"><y>#</y><d>2020-12-01</d><h>17:22</h><w>noprompt</w>Does anyone know this person? <a href="https://reclojure.org/2020-speakers/paulo-feodrippe.html" target="_blank">https://reclojure.org/2020-speakers/paulo-feodrippe.html</a></z><z id="t1606843439" t="noprompt I’m interested in model checking and how it can be leveraged in Clojure."><y>#</y><d>2020-12-01</d><h>17:23</h><w>noprompt</w>I’m interested in model checking and how it can be leveraged in Clojure.</z><z id="t1606843972" t="borkdude [:attrs {:href &quot;/_/_/users/U5R6XUARE&quot;}] seems to be on Slack"><y>#</y><d>2020-12-01</d><h>17:32</h><w>borkdude</w><a>@pfeodrippe</a> seems to be on Slack</z><z id="t1606844293" t="noprompt BTW [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] thanks to the babashka pressure and the work on the epsilon interpreter, I made a breakthrough that will accelerate zeta to the point of having something tangible but not fully optimized in the near future."><y>#</y><d>2020-12-01</d><h>17:38</h><w>noprompt</w>BTW <a>@borkdude</a> thanks to the babashka pressure and the work on the <code>epsilon</code> interpreter, I made a breakthrough that will accelerate <code>zeta</code> to the point of having something tangible but not fully optimized in the near future.</z><z id="t1606844334" t="noprompt I’ve almost got the substitution half of the interpreter ready which I’ll be pushing soon."><y>#</y><d>2020-12-01</d><h>17:38</h><w>noprompt</w>I’ve almost got the substitution half of the interpreter ready which I’ll be pushing soon.</z><z id="t1606844345" t="borkdude bananadance Sounds great! If you&apos;re interested, I&apos;m doing a babashka / sci internals presentation in about an hour here: https://www.meetup.com/London-Clojurians/events/274014078/"><y>#</y><d>2020-12-01</d><h>17:39</h><w>borkdude</w><b>bananadance</b> Sounds great! If you&apos;re interested, I&apos;m doing a babashka / sci internals presentation in about an hour here: <a href="https://www.meetup.com/London-Clojurians/events/274014078/" target="_blank">https://www.meetup.com/London-Clojurians/events/274014078/</a></z><z id="t1606844390" t="noprompt After that, I can pretty much take almost all of that code and fit it in to the zeta model I’ve been tinkering with."><y>#</y><d>2020-12-01</d><h>17:39</h><w>noprompt</w>After that, I can pretty much take almost all of that code and fit it in to the <code>zeta</code> model I’ve been tinkering with.</z><z id="t1606844433" t="noprompt [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] Are you in London ATM?"><y>#</y><d>2020-12-01</d><h>17:40</h><w>noprompt</w><a>@borkdude</a> Are you in London ATM?</z><z id="t1606844452" t="borkdude no, The Netherlands"><y>#</y><d>2020-12-01</d><h>17:40</h><w>borkdude</w>no, The Netherlands</z><z id="t1606844454" t="noprompt Slack says it’s 18:40 where you are and I’m a lazy American."><y>#</y><d>2020-12-01</d><h>17:40</h><w>noprompt</w>Slack says it’s 18:40 where you are and I’m a lazy American.</z><z id="t1606844456" t="noprompt Ah."><y>#</y><d>2020-12-01</d><h>17:40</h><w>noprompt</w>Ah.</z><z id="t1606844468" t="borkdude The meetup happens from London originally though"><y>#</y><d>2020-12-01</d><h>17:41</h><w>borkdude</w>The meetup happens from London originally though</z><z id="t1606844487" t="borkdude I&apos;m a visiting speaker. They have invited half the Clojure community to do talks there it seems ;)"><y>#</y><d>2020-12-01</d><h>17:41</h><w>borkdude</w>I&apos;m a visiting speaker. They have invited half the Clojure community to do talks there it seems ;)</z><z id="t1606844505" t="noprompt That might be a little bit early for me but I could always tune in later if it’s on YouTube or something."><y>#</y><d>2020-12-01</d><h>17:41</h><w>noprompt</w>That might be a little bit early for me but I could always tune in later if it’s on YouTube or something.</z><z id="t1606844526" t="noprompt Half the Clojure community, that’s like what, 20 people or something? 😛"><y>#</y><d>2020-12-01</d><h>17:42</h><w>noprompt</w>Half the Clojure community, that’s like what, 20 people or something? <b>😛</b></z><z id="t1606844623" t="noprompt Gah, sometimes I wish my family and I could pick up and move to Europe. I lived in Spain for 5 years in when I was teenager and loved everywhere I went. Never got a chance to visit the Netherlands though. 😞"><y>#</y><d>2020-12-01</d><h>17:43</h><w>noprompt</w>Gah, sometimes I wish my family and I could pick up and move to Europe. I lived in Spain for 5 years in when I was teenager and loved everywhere I went. Never got a chance to visit the Netherlands though. <b>😞</b></z><z id="t1606845561" t="pfeodrippe Thanks, [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] ! Hi [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] o/ We can chat whenever you want :) I&apos;m learning about it too"><y>#</y><d>2020-12-01</d><h>17:59</h><w>pfeodrippe</w>Thanks, <a>@borkdude</a>! Hi <a>@noprompt</a> o/

We can chat whenever you want :) I&apos;m learning about it too</z><z id="t1606846688" t="noprompt Sweet! Perhaps after your talk? I’m excited to learn about what you’re working on."><y>#</y><d>2020-12-01</d><h>18:18</h><w>noprompt</w>Sweet! Perhaps after your talk? I’m excited to learn about what you’re working on.</z><z id="t1606905212" t="pfeodrippe Yes, sure :D. We will also have a QA after the talk, but I&apos;m not expert myself, I&apos;m doing this for a more practical purposes. I would like to see what you have in mind for it o/"><y>#</y><d>2020-12-02</d><h>10:33</h><r>pfeodrippe</r>Yes, sure :D. We will also have a QA after the talk, but I&apos;m not expert myself, I&apos;m doing this for a more practical purposes. I would like to see what you have in mind for it o/</z><z id="t1606929519" t="noprompt Practical purposes is where I’m coming from as well with Meander. I’m trying to bring some of the ideas from term rewriting that I think are useful in day to day programming. Where model checking is interesting to me is being able to take a rewrite system and ask it questions such as • what are your inputs? • what are your outputs (normal forms)? • what are the paths between and inputs and an outputs? With answers to these questions we can assert whether or not claims about those systems are true, etc."><y>#</y><d>2020-12-02</d><h>17:18</h><r>noprompt</r>Practical purposes is where I’m coming from as well with Meander. I’m trying to bring some of the ideas from term rewriting that I think are useful in day to day programming.

Where model checking is interesting to me is being able to take a rewrite system and ask it questions such as
• what are your inputs?
• what are your outputs (normal forms)?
• what are the paths between and inputs and an outputs?
With answers to these questions we can assert whether or not claims about those systems are true, etc.</z><z id="t1606961368" t="pfeodrippe Got it! I am aiming to use it more to try to understand a system with little or no regard to the code implementation. More high level view of everything, but I see thay you want to use it on other ways, right? Tell me more if you can, I would like to learn, man :D"><y>#</y><d>2020-12-03</d><h>02:09</h><r>pfeodrippe</r>Got it! I am aiming to use it more to try to understand a system with little or no regard to the code implementation. 

More high level view of everything, but I see thay you want to use it on other ways, right? 

Tell me more if you can, I would like to learn, man :D</z><z id="t1606846849" t="noprompt My knowledge of model checking is limited. I have a copy of “Principles of Model Checking” but I haven’t dedicated time to reading it."><y>#</y><d>2020-12-01</d><h>18:20</h><w>noprompt</w>My knowledge of model checking is limited. I have a copy of “Principles of Model Checking” but I haven’t dedicated time to reading it.</z><z id="t1606846879" t="noprompt My exposure to model checking has been primarily through Maude."><y>#</y><d>2020-12-01</d><h>18:21</h><w>noprompt</w>My exposure to model checking has been primarily through Maude.</z><z id="t1606846935" t="noprompt BTW, for folks who do not know about Maude: http://maude.cs.illinois.edu/w/index.php?title=The_Maude_System"><y>#</y><d>2020-12-01</d><h>18:22</h><w>noprompt</w>BTW, for folks who do not know about Maude: <a href="http://maude.cs.illinois.edu/w/index.php?title=The_Maude_System" target="_blank">http://maude.cs.illinois.edu/w/index.php?title=The_Maude_System</a></z><z id="t1606866313" t="noprompt The interpreter namespace is coming together. I pushed up the new protocol based pattern match/substitution factory stuff. Just a bit more to do."><y>#</y><d>2020-12-01</d><h>23:45</h><w>noprompt</w>The interpreter namespace is coming together. I pushed up the new protocol based pattern match/substitution factory stuff. Just a bit more to do.</z><z id="t1606866349" t="noprompt Probably a couple more days of work to go."><y>#</y><d>2020-12-01</d><h>23:45</h><w>noprompt</w>Probably a couple more days of work to go.</z><z id="t1606936033" t="noprompt (let [sf (rewriter &apos;{?k1 ?v1, ?k2 ?v2} ;; or on the right! &apos;(meander.epsilon/or {?v1 ?k1} {?v2 ?k2})) ;; Makes a system like `meander.epsilon/rewrite` s_find (sf find-runtime) ;; Makes a system like `meander.epsilon/rewrites` s_search (sf depth-first-search-runtime) target {:a 1 :b 2 :c 3}] [(s_find target) (s_search target)]) ;; =&gt; [{1 :a} ;; ({1 :a} ;; {2 :b} ;; {1 :a} ;; {3 :c} ;; {2 :b} ;; {1 :a} ;; {2 :b} ;; {3 :c} ;; {3 :c} ;; {1 :a} ;; {3 :c} ;; {2 :b})] "><y>#</y><d>2020-12-02</d><h>19:07</h><w>noprompt</w><pre>(let [sf (rewriter
          &apos;{?k1 ?v1, ?k2 ?v2}
          ;; or on the right!
          &apos;(meander.epsilon/or {?v1 ?k1} {?v2 ?k2}))
      ;; Makes a system like `meander.epsilon/rewrite`
      s_find (sf find-runtime)
      ;; Makes a system like  `meander.epsilon/rewrites`
      s_search (sf depth-first-search-runtime)
      target {:a 1 :b 2 :c 3}]
  [(s_find target)
   (s_search target)])
;; =&gt; [{1 :a}
;;     ({1 :a}
;;      {2 :b}
;;      {1 :a}
;;      {3 :c}
;;      {2 :b}
;;      {1 :a}
;;      {2 :b}
;;      {3 :c}
;;      {3 :c}
;;      {1 :a}
;;      {3 :c}
;;      {2 :b})]</pre>
</z><z id="t1606936050" t="noprompt This is on the epsilon-interpreter branch (almost there!)."><y>#</y><d>2020-12-02</d><h>19:07</h><w>noprompt</w>This is on the <code>epsilon-interpreter</code> branch (almost there!).</z><z id="t1606936099" t="noprompt Don’t tell anyone this but you can use and , or , and let on the right. 😉"><y>#</y><d>2020-12-02</d><h>19:08</h><w>noprompt</w>Don’t tell anyone this but you can use <code>and</code>, <code>or</code>, and <code>let</code> on the right. <b>😉</b></z><z id="t1606936376" t="noprompt After this is merged, I think beyond bug fixes, I really need to stop working on the epsilon arm of the project and continue this work on zeta ."><y>#</y><d>2020-12-02</d><h>19:12</h><w>noprompt</w>After this is merged, I think beyond bug fixes, I really need to stop working on the <code>epsilon</code> arm of the project and continue this work on <code>zeta</code>.</z><z id="t1606936520" t="noprompt I think the foundation here is good enough to stand on though. I haven’t tried it yet, but I think this model could be extended to support explainability by rolling a custom runtime."><y>#</y><d>2020-12-02</d><h>19:15</h><w>noprompt</w>I think the foundation here is good enough to stand on though. I haven’t tried it yet, but I think this model could be extended to support explainability by rolling a custom runtime.</z><z id="t1606936531" t="noprompt The only exception might be cata ."><y>#</y><d>2020-12-02</d><h>19:15</h><w>noprompt</w>The only exception might be <code>cata</code>.</z><z id="t1606936546" t="noprompt But that may not be the case."><y>#</y><d>2020-12-02</d><h>19:15</h><w>noprompt</w>But that may not be the case.</z><z id="t1607461484" t="mac I am trying to pass patterns into a function that applies these using search but I am doing something wrong. Example which works when I hardcode the patterns into the function. I have troed unquoting the pattern inside apply-rule, but that makes no difference: (def global-counter (java.util.concurrent.atomic.AtomicInteger. 0)) (defn next-id [] (.getAndIncrement global-counter)) (defn apply-rule [graph rule] (let [[pattern out] rule] (map vec (partition 2 (flatten (me/search graph (me/scan pattern) out)))))) (let [g [[(next-id) (next-id)]]] (apply-rule g &apos;[[?x ?y] [[(next-id) ?y] [?y ?x]]]))"><y>#</y><d>2020-12-08</d><h>21:04</h><w>mac</w>I am trying to pass patterns into a function that applies these using <code>search</code>  but I am doing something wrong. Example which works when I hardcode the patterns into the function. I have troed unquoting the pattern inside apply-rule, but that makes no difference:

<pre>(def global-counter (java.util.concurrent.atomic.AtomicInteger. 0))
(defn next-id [] (.getAndIncrement global-counter))

(defn apply-rule [graph rule]
  (let [[pattern out] rule]
      (map vec
       (partition
        2
        (flatten
         (me/search
           graph
           (me/scan pattern)
           out))))))

(let [g [[(next-id) (next-id)]]]
  (apply-rule g &apos;[[?x ?y] [[(next-id) ?y] [?y ?x]]]))</pre></z><z id="t1607464425" t="Jimmy Miller Right now this isn’t possible because meander works by compiling patterns. This makes these dynamic things not work. We are actively working on an interpreter though https://github.com/noprompt/meander/pull/155 If you are doing this for some other reason than wanting dynamic patterns, we can definitely help with that too if you explain a bit more about your motivation. In the example you gave it is hard for me to tell if you really need things to be dynamic."><y>#</y><d>2020-12-08</d><h>21:53</h><r>Jimmy Miller</r>Right now this isn’t possible because meander works by compiling patterns. This makes these dynamic things not work.

We are actively working on an interpreter though <a href="https://github.com/noprompt/meander/pull/155" target="_blank">https://github.com/noprompt/meander/pull/155</a>

If you are doing this for some other reason than wanting dynamic patterns, we can definitely help with that too if you explain a bit more about your motivation.

In the example you gave it is hard for me to tell if you really need things to be dynamic.</z><z id="t1607464614" t="mac I was looking to pass the patterns to have a concise way to let the user play around with different patterns."><y>#</y><d>2020-12-08</d><h>21:56</h><r>mac</r>I was looking to pass the patterns to have a concise way to let the user play around with different patterns.</z><z id="t1607465195" t="Jimmy Miller Yeah right now the only way do things dynamically like that would be to eval stuff."><y>#</y><d>2020-12-08</d><h>22:06</h><r>Jimmy Miller</r>Yeah right now the only way do things dynamically like that would be to eval stuff.</z><z id="t1607465326" t="mac How would I use eval to achieve this? I am confused."><y>#</y><d>2020-12-08</d><h>22:08</h><r>mac</r>How would I use eval to achieve this? I am confused.</z><z id="t1607466105" t="Jimmy Miller On my phone sadly. Can post later tonight. But if you are accepting user input, eval is not safe."><y>#</y><d>2020-12-08</d><h>22:21</h><r>Jimmy Miller</r>On my phone sadly. Can post later tonight. But if you are accepting user input, eval is not safe.</z><z id="t1607466749" t="mac By user input, I meant just to let the user of the library pass quoted patterns into the function. Happy to wait for input."><y>#</y><d>2020-12-08</d><h>22:32</h><r>mac</r>By user input, I meant just to let the user of the library pass quoted patterns into the function. Happy to wait for input.</z><z id="t1607469967" t="noprompt [:attrs {:href &quot;/_/_/users/U09UV3WP6&quot;}] It sounds like you want interpretation which the PR [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] linked earlier will provide support once it is merged. I have been actively working on it and expect to have it merged soon. I have shared a couple of examples demonstrating it https://clojurians.slack.com/archives/CFFTD7R6Z/p1606244106396700 and https://clojurians.slack.com/archives/CFFTD7R6Z/p1606936033435400 . I’m currently trying to round a few more rough edges and going as quickly as I can. I know this is a feature folks want (including myself) and it’s my number one priority right now."><y>#</y><d>2020-12-08</d><h>23:26</h><r>noprompt</r><a>@U09UV3WP6</a> It sounds like you want interpretation which the PR <a>@U5K8NTHEZ</a> linked earlier will provide support once it is merged. I have been actively working on it and expect to have it merged soon. I have shared a couple of examples demonstrating it <a href="https://clojurians.slack.com/archives/CFFTD7R6Z/p1606244106396700" target="_blank">https://clojurians.slack.com/archives/CFFTD7R6Z/p1606244106396700</a> and <a href="https://clojurians.slack.com/archives/CFFTD7R6Z/p1606936033435400" target="_blank">https://clojurians.slack.com/archives/CFFTD7R6Z/p1606936033435400</a>. I’m currently trying to round a few more rough edges and going as quickly as I can. I know this is a feature folks want (including myself) and it’s my number one priority right now.</z><z id="t1607470064" t="mac OK, that&apos;s cool. I will use hard coded patterns for now."><y>#</y><d>2020-12-08</d><h>23:27</h><r>mac</r>OK, that&apos;s cool. I will use hard coded patterns for now.</z><z id="t1607526367" t="Jimmy Miller Sorry for taking so long to reply. I definitely don’t recommend doing this. But just wanted to reply with the eval version. (def global-counter (java.util.concurrent.atomic.AtomicInteger. 0)) (defn next-id [] (.getAndIncrement global-counter)) (defn apply-rule [graph rule] (let [[pattern out] rule] (map vec (partition 2 (flatten (eval `(m/search ~graph (m/scan ~pattern) ~out))))))) This will be rather slow as you would be compiling the expression every single time."><y>#</y><d>2020-12-09</d><h>15:06</h><r>Jimmy Miller</r>Sorry for taking so long to reply. I definitely don’t recommend doing this. But just wanted to reply with the eval version.

<pre>(def global-counter (java.util.concurrent.atomic.AtomicInteger. 0))
(defn next-id [] (.getAndIncrement global-counter))
(defn apply-rule [graph rule]
  (let [[pattern out] rule]
    (map vec
         (partition
          2
          (flatten
           (eval
            `(m/search
               ~graph
               (m/scan ~pattern)
               ~out)))))))</pre>
This will be rather slow as you would be compiling the expression every single time.</z><z id="t1607629239" t="noprompt I have a busy day today but I anticipate being able to devote some more time to wrapping up interpreter things tomorrow."><y>#</y><d>2020-12-10</d><h>19:40</h><w>noprompt</w>I have a busy day today but I anticipate being able to devote some more time to wrapping up interpreter things tomorrow.</z><z id="t1607699706" t="markaddleman I&apos;m curious what you guys think about enhancing the m/$ operator to avoid subtrees matching a pattern. I have a tree that contains information at one semantic level that I&apos;d like to use to rewrite all the nodes at that same semantic level. It would be convenient to use m/$ to match all the nodes at that level but it traverses into lower levels and, thus, ends up matching too much."><y>#</y><d>2020-12-11</d><h>15:15</h><w>markaddleman</w>I&apos;m curious what you guys think about enhancing the <code>m/$</code> operator to avoid subtrees matching a pattern.  I have a tree that contains information at one semantic level that I&apos;d like to use to rewrite all the nodes at that same semantic level.  It would be convenient to use <code>m/$</code> to match all the nodes at that level but it traverses into lower levels and, thus, ends up matching too much.</z><z id="t1607704926" t="Jimmy Miller Could you share a simplified example? (or the real one if you want)"><y>#</y><d>2020-12-11</d><h>16:42</h><r>Jimmy Miller</r>Could you share a simplified example? (or the real one if you want)</z><z id="t1607718262" t="noprompt An example would be great but, to summarize, are you asking if the operator can do a top down traversal and stop once a match has been made?"><y>#</y><d>2020-12-11</d><h>20:24</h><r>noprompt</r>An example would be great but, to summarize, are you asking if the operator can do a top down traversal and stop once a match has been made?</z><z id="t1607719544" t="markaddleman Yep. That&apos;s exactly what I&apos;m looking for."><y>#</y><d>2020-12-11</d><h>20:45</h><r>markaddleman</r>Yep.  That&apos;s exactly what I&apos;m looking for.</z><z id="t1607719569" t="markaddleman I can provide an example of what I&apos;m trying to do this weekend"><y>#</y><d>2020-12-11</d><h>20:46</h><r>markaddleman</r>I can provide an example of what I&apos;m trying to do this weekend</z><z id="t1607719623" t="markaddleman [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] I&apos;m not entirely sure we&apos;re on the same page. I&apos;d like the operator to do a top traversal matching everything for p1 and stop when it reaches p2"><y>#</y><d>2020-12-11</d><h>20:47</h><r>markaddleman</r><a>@U06MDAPTP</a> I&apos;m not entirely sure we&apos;re on the same page.  I&apos;d like the operator to do a top traversal matching everything for <code>p1</code> and stop when it reaches <code>p2</code></z><z id="t1607719821" t="noprompt (top-down match_p stop_p) "><y>#</y><d>2020-12-11</d><h>20:50</h><r>noprompt</r><pre>(top-down match_p stop_p)</pre>
</z><z id="t1607719999" t="noprompt I need to think about this a bit more because I would like to have this model work in both directions e.g. the dual of this, I think, would be to construct a tree."><y>#</y><d>2020-12-11</d><h>20:53</h><r>noprompt</r>I need to think about this a bit more because I would like to have this model work in both directions e.g. the dual of this, I think, would be to construct a tree.</z><z id="t1607720046" t="markaddleman that would be pretty cool"><y>#</y><d>2020-12-11</d><h>20:54</h><r>markaddleman</r>that would be pretty cool</z><z id="t1607720050" t="noprompt In the mean time I know we can fill in the blanks with something that does what you’re looking for. There are a few thing ahead in the queue though."><y>#</y><d>2020-12-11</d><h>20:54</h><r>noprompt</r>In the mean time I know we can fill in the blanks with something that does what you’re looking for. There are a few thing ahead in the queue though.</z><z id="t1607720052" t="noprompt Yes."><y>#</y><d>2020-12-11</d><h>20:54</h><r>noprompt</r>Yes.</z><z id="t1607720194" t="markaddleman I&apos;m using meander to parse honeysql and rewrite it. Currently, I&apos;m avoiding generating an AST. But, eventually, I&apos;m going to need to convert between an AST and honeysql. Your dual top-down operator could be very handy for this, I imagine"><y>#</y><d>2020-12-11</d><h>20:56</h><r>markaddleman</r>I&apos;m using meander to parse honeysql and rewrite it.  Currently, I&apos;m avoiding generating an AST.  But, eventually, I&apos;m going to need to convert between an AST and honeysql.  Your dual <code>top-down</code> operator could be very handy for this, I imagine</z><z id="t1607720197" t="noprompt It seems like the dual would be grow a tree with the node pattern until it matches the stop pattern, however, there needs to be a notion of where the children go."><y>#</y><d>2020-12-11</d><h>20:56</h><r>noprompt</r>It seems like the dual would be grow a tree with the node pattern until it matches the stop pattern, however, there needs to be a notion of where the children go.</z><z id="t1607720282" t="noprompt This is something that needs thought anyway, it was bound to come up."><y>#</y><d>2020-12-11</d><h>20:58</h><r>noprompt</r>This is something that needs thought anyway, it was bound to come up.</z><z id="t1607720301" t="noprompt Are you able to use the strategy combinators in the mean time?"><y>#</y><d>2020-12-11</d><h>20:58</h><r>noprompt</r>Are you able to use the strategy combinators in the mean time?</z><z id="t1607720310" t="noprompt There is m*/top-down-while"><y>#</y><d>2020-12-11</d><h>20:58</h><r>noprompt</r>There is <code>m*/top-down-while</code></z><z id="t1607720338" t="markaddleman I haven&apos;t touched the strategy stuff yet. That&apos;s a this weekend project 🙂"><y>#</y><d>2020-12-11</d><h>20:58</h><r>markaddleman</r>I haven&apos;t touched the strategy stuff yet.  That&apos;s a this weekend project <b>🙂</b></z><z id="t1607720402" t="noprompt Sure. My hope is that, eventually, what is in the main namespace, the interpreter work, and the strategies can all be joined together in a super nova of fun times 😛"><y>#</y><d>2020-12-11</d><h>21:00</h><r>noprompt</r>Sure. My hope is that, eventually, what is in the main namespace, the interpreter work, and the strategies can all be joined together in a super nova of fun times <b>😛</b></z><z id="t1607720430" t="markaddleman 😄"><y>#</y><d>2020-12-11</d><h>21:00</h><r>markaddleman</r><b>😄</b></z><z id="t1607720531" t="noprompt This is my immortality project. 🙂"><y>#</y><d>2020-12-11</d><h>21:02</h><r>noprompt</r>This is my immortality project. <b>🙂</b></z><z id="t1607720581" t="markaddleman I have to say, meander has been a game changer for me. The bulk of my application code is generating SQL statements from fragments of SQL that know how to project various bits of data. SQL is a bear to compose but meander has given me a way of taming it without completely losing my mind."><y>#</y><d>2020-12-11</d><h>21:03</h><r>markaddleman</r>I have to say, meander has been a game changer for me.  The bulk of my application code is generating SQL statements from fragments of SQL that know how to project various bits of data.  SQL is a bear to compose but meander has given me a way of taming it without completely losing my mind.</z><z id="t1607720898" t="noprompt That’s really great to hear. If you’re ever open to it — and there is zero pressure when I say this — you could always drop some snippets of what you’re doing the in the cookbook etc."><y>#</y><d>2020-12-11</d><h>21:08</h><r>noprompt</r>That’s really great to hear. If you’re ever open to it — and there is zero pressure when I say this — you could always drop some snippets of what you’re doing the in the cookbook etc.</z><z id="t1607720915" t="noprompt That’s a space for anyone and everyone."><y>#</y><d>2020-12-11</d><h>21:08</h><r>noprompt</r>That’s a space for anyone and everyone.</z><z id="t1607723401" t="markaddleman Yep. That&apos;s on my to-do list"><y>#</y><d>2020-12-11</d><h>21:50</h><r>markaddleman</r>Yep.  That&apos;s on my to-do list</z><z id="t1607977296" t="noprompt OK folks I think I’m going to merge the interpreter stuff soon under the banner of “experimental”. There are some annoying nuances of clojure.test that are causing the test suite to fail on the command line but not from the REPL. There is a small issue with babashka that I’m looking at with [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] at the moment so it usable from there."><y>#</y><d>2020-12-14</d><h>20:21</h><w>noprompt</w>OK folks I think I’m going to merge the interpreter stuff soon under the banner of “experimental”. There are some annoying nuances of <code>clojure.test</code> that are causing the test suite to fail on the command line but not from the REPL.

There is a small issue with babashka that I’m looking at with <a>@borkdude</a> at the moment so it usable from there.</z><z id="t1607995437" t="noprompt Some other things on the way that I will follow up with after the interpreter code • fresh which allows for fresh variables in the usual logic programming sense • project which allows for the current state of variables to be queried (actually way cooler than this) Example of fresh : (m/match [1 2] [(m/fresh [?x] ?x) ?x] ?x) ;; =&gt; 2 Example of project : ;; (m/project &lt;yield-pattern&gt; &lt;query-pattern&gt; &lt;value-pattern&gt;) ;; ;; Attempts to yield an object described by yield-pattern using the ;; current bindings and match that object with query-pattern. If ;; successful, attempts to match the target object with value-pattern ;; if querying, or yield the object if yielding. Global bindings are ;; not altered when yielding the yield-pattern object. (m/search 10 ;; Capture two 10 in !x ;; Bindings: {!x [10 10]} ;; Project the vector [!x !x] e.g. [10 10] ;; Match against [?x ?y] ;; Bindings: {!x [10 10], ?x 10, ?y 10} ;; Match 10 against ?x (m/and !x !x (m/project [!x !x] [?x ?y] ?x)) {:!x !x, :?x ?x, :?y ?y}) ;; =&gt; ({:!x [10 10], :?x 10, :?y 10}) "><y>#</y><d>2020-12-15</d><h>01:23</h><w>noprompt</w>Some other things on the way that I will follow up with after the interpreter code
• <code>fresh</code> which allows for fresh variables in the usual logic programming sense
• <code>project</code> which allows for the current state of variables to be queried (actually way cooler than this)
Example of <code>fresh</code>:
<pre>(m/match [1 2]
  [(m/fresh [?x]
     ?x)
   ?x]
  ?x)
;; =&gt; 2</pre>
Example of <code>project</code>:
<pre>;; (m/project &lt;yield-pattern&gt; &lt;query-pattern&gt; &lt;value-pattern&gt;)
;;
;; Attempts to yield an object described by yield-pattern using the
;; current bindings and match that object with query-pattern. If
;; successful, attempts to match the target object with value-pattern
;; if querying, or yield the object if yielding. Global bindings are
;; not altered when yielding the yield-pattern object.
(m/search 10
  ;; Capture two 10 in !x
  ;;   Bindings: {!x [10 10]}
  ;; Project the vector [!x !x] e.g. [10 10]
  ;; Match against [?x ?y]
  ;;   Bindings: {!x [10 10], ?x 10, ?y 10}
  ;; Match 10 against ?x
  (m/and !x !x (m/project [!x !x] [?x ?y] ?x))
  {:!x !x, :?x ?x, :?y ?y})
;; =&gt; ({:!x [10 10], :?x 10, :?y 10})</pre>
</z><z id="t1608040832" t="Lucy Wang So fresh is like a block scope, in that case would m/scoped be slightly better than m/fresh ?"><y>#</y><d>2020-12-15</d><h>14:00</h><r>Lucy Wang</r>So fresh is like a block scope, in that case would <code>m/scoped</code> be slightly better than <code>m/fresh</code> ?</z><z id="t1608048772" t="noprompt I had a similar thought myself. 🙂 I’ve also been considering some other vocabulary words such as “local”, “ephemeral”, etc. to more accurately reflect the spirit. I will give this some more consideration!"><y>#</y><d>2020-12-15</d><h>16:12</h><r>noprompt</r>I had a similar thought myself. <b>🙂</b> I’ve also been considering some other vocabulary words such as  “local”, “ephemeral”, etc. to more accurately reflect the spirit. I will give this some more consideration!</z><z id="t1608061501" t="Jimmy Miller I love the idea of not going with fresh. Always confused me. I think scoped, but local makes the most sense to me."><y>#</y><d>2020-12-15</d><h>19:45</h><r>Jimmy Miller</r>I love the idea of not going with fresh. Always confused me. I think scoped, but local makes the most sense to me.</z><z id="t1608062032" t="noprompt Lucy, what do you think of local ? Also, sending to channel for feedback."><y>#</y><d>2020-12-15</d><h>19:53</h><r>noprompt</r>Lucy, what do you think of <code>local</code>? Also, sending to channel for feedback.</z><z id="t1608283568" t="Lucy Wang +1 for local, even better than scoped !"><y>#</y><d>2020-12-18</d><h>09:26</h><r>Lucy Wang</r>+1 for local, even better than <code>scoped</code>!</z><z id="t1607995480" t="noprompt Both of these will be usable on both sides."><y>#</y><d>2020-12-15</d><h>01:24</h><w>noprompt</w>Both of these will be usable on both sides.</z><z id="t1608062064" t="noprompt https://clojurians.slack.com/archives/CFFTD7R6Z/p1608062032462800"><y>#</y><d>2020-12-15</d><h>19:54</h><w>noprompt</w><a href="https://clojurians.slack.com/archives/CFFTD7R6Z/p1608062032462800" target="_blank">https://clojurians.slack.com/archives/CFFTD7R6Z/p1608062032462800</a></z><z id="t1608071092" t="dgr I’m working on editing the Meander documentation. Can somebody give me more background on the differences between match and find ? I understand the difference between match and search , but the only difference between match and find seems to be that I can use some pattern operations like scan in find , but not in match . Is that it? If so, why not just use find everywhere and do away with match ? I assume that there is some sort of performance difference between the two, but it isn’t really mentioned. Is there anything else that find can do that match can’t, or vice versa?"><y>#</y><d>2020-12-15</d><h>22:24</h><w>dgr</w>I’m working on editing the Meander documentation. Can somebody give me more background on the differences between <code>match</code> and <code>find</code>? I understand the difference between <code>match</code> and <code>search</code>, but the only difference between <code>match</code> and <code>find</code>seems to be that I can use some pattern operations like <code>scan</code> in <code>find</code>, but not in <code>match</code>. Is that it? If so, why not just use <code>find</code> everywhere and do away with <code>match</code>? I assume that there is some sort of performance difference between the two, but it isn’t really mentioned. Is there anything else that <code>find</code> can do that <code>match</code> can’t, or vice versa?</z><z id="t1608071408" t="Jimmy Miller Match is unambiguous. We aren’t searching to find a way to satisfy the pattern. We are just matching very directly what was given. Given that we aren’t searching, match does have in general better performance characteristics. Find can do anything match can do. But match can’t use things that require searching to satisfy the pattern. Another way of putting it is that match allows there to only be exactly one match. Find allows there to be more than one, but selects the first."><y>#</y><d>2020-12-15</d><h>22:30</h><r>Jimmy Miller</r>Match is unambiguous. We aren’t searching to find a way to satisfy the pattern. We are just matching very directly what was given.  Given that we aren’t searching, match does have in general better performance characteristics.

Find can do anything match can do. But match can’t use things that require searching to satisfy the pattern.

Another way of putting it is that match allows there to only be exactly one match. Find allows there to be more than one, but selects the first.</z><z id="t1608071437" t="Jimmy Miller Also, thanks for any edits you are doing. Always wonderful to have people help out with that 🙂"><y>#</y><d>2020-12-15</d><h>22:30</h><r>Jimmy Miller</r>Also, thanks for any edits you are doing. Always wonderful to have people help out with that <b>🙂</b></z><z id="t1608071452" t="noprompt LOL just backspaced a bunch."><y>#</y><d>2020-12-15</d><h>22:30</h><r>noprompt</r>LOL just backspaced a bunch.</z><z id="t1608071530" t="noprompt The semantics of find are basically (first (search ,,,)) but compiles to code specifically designed to find the first solution more efficiently."><y>#</y><d>2020-12-15</d><h>22:32</h><r>noprompt</r>The semantics of <code>find</code> are basically <code>(first (search ,,,))</code> but compiles to code specifically designed to find the first solution more efficiently.</z><z id="t1608071534" t="dgr So, define “searching” in the way that Meander uses the concept. How is what match does not searching while what search /`find` do is searching."><y>#</y><d>2020-12-15</d><h>22:32</h><r>dgr</r>So, define “searching” in the way that Meander uses the concept. How is what <code>match</code> does not searching while what <code>search</code>/`find` do is searching.</z><z id="t1608071550" t="dgr Yes, I get the diff between search and find . Totally makes sense."><y>#</y><d>2020-12-15</d><h>22:32</h><r>dgr</r>Yes, I get the diff between <code>search</code> and <code>find</code>. Totally makes sense.</z><z id="t1608071604" t="dgr It’s the diff between match and find (and search ) that has me scratching my head."><y>#</y><d>2020-12-15</d><h>22:33</h><r>dgr</r>It’s the diff between <code>match</code> and <code>find</code> (and <code>search</code>) that has me scratching my head.</z><z id="t1608071612" t="noprompt match is searching in the traditional sense of pattern matching found in virtually every language that has it. Patterns must be unambiguous and match throws when there is no default and no match; pretty much core.match style."><y>#</y><d>2020-12-15</d><h>22:33</h><r>noprompt</r><code>match</code> is searching in the traditional sense of pattern matching found in virtually every language that has it. Patterns must be unambiguous and <code>match</code> throws when there is no default and no match; pretty much <code>core.match</code> style.</z><z id="t1608071638" t="noprompt Both search and find allow for ambiguous patterns and neither complain when there is no solution found."><y>#</y><d>2020-12-15</d><h>22:33</h><r>noprompt</r>Both <code>search</code> and <code>find</code> allow for ambiguous patterns and neither complain when there is no solution found.</z><z id="t1608071658" t="dgr What does “ambiguous” mean? Just that more than one pattern matches?"><y>#</y><d>2020-12-15</d><h>22:34</h><r>dgr</r>What does “ambiguous” mean? Just that more than one pattern matches?</z><z id="t1608071688" t="dgr OK, good point that neither search or find complain about nothing found. That’s important."><y>#</y><d>2020-12-15</d><h>22:34</h><r>dgr</r>OK, good point that neither <code>search</code> or <code>find</code> complain about nothing found. That’s important.</z><z id="t1608071696" t="noprompt An example of an ambiguous pattern would be {?k ?v} or {?k ?v, ?v ?k} because there is no one solution given a satisfactory map of the right shape."><y>#</y><d>2020-12-15</d><h>22:34</h><r>noprompt</r>An example of an ambiguous pattern would be <code>{?k ?v}</code> or <code>{?k ?v, ?v ?k}</code> because there is no one solution given a satisfactory map of the right shape.</z><z id="t1608071752" t="dgr Hm. So how does it deal with {?k ?v} ? What are the variables bound to?"><y>#</y><d>2020-12-15</d><h>22:35</h><r>dgr</r>Hm. So how does it deal with <code>{?k ?v}</code>? What are the variables bound to?</z><z id="t1608071769" t="noprompt So a map like {:x 1 :y 1} in the first example could bind ?k to either :x or :y ."><y>#</y><d>2020-12-15</d><h>22:36</h><r>noprompt</r>So a map like <code>{:x 1 :y 1}</code> in the first example could bind <code>?k</code> to either <code>:x</code> or <code>:y</code>.</z><z id="t1608071790" t="dgr Got it. So does it just choose one?"><y>#</y><d>2020-12-15</d><h>22:36</h><r>dgr</r>Got it. So does it just choose one?</z><z id="t1608071798" t="dgr The first?"><y>#</y><d>2020-12-15</d><h>22:36</h><r>dgr</r>The first?</z><z id="t1608071807" t="noprompt find does, search returns both answers."><y>#</y><d>2020-12-15</d><h>22:36</h><r>noprompt</r><code>find</code> does, <code>search</code> returns both answers.</z><z id="t1608071819" t="noprompt find just picks the first one blindly."><y>#</y><d>2020-12-15</d><h>22:36</h><r>noprompt</r><code>find</code> just picks the first one blindly.</z><z id="t1608071831" t="noprompt Depth first."><y>#</y><d>2020-12-15</d><h>22:37</h><r>noprompt</r>Depth first.</z><z id="t1608071844" t="dgr OK, make sense. search returns both and find returns whatever search would find first."><y>#</y><d>2020-12-15</d><h>22:37</h><r>dgr</r>OK, make sense. <code>search</code> returns both and <code>find</code> returns whatever <code>search</code> would find first.</z><z id="t1608071879" t="noprompt Another example would be [_ … ?x . _ …] aka (m/scan ?x) . Some ?x is in there."><y>#</y><d>2020-12-15</d><h>22:37</h><r>noprompt</r>Another example would be <code>[_ … ?x . _ …]</code> aka <code>(m/scan ?x)</code>. Some <code>?x</code> is in there.</z><z id="t1608071885" t="noprompt Right."><y>#</y><d>2020-12-15</d><h>22:38</h><r>noprompt</r>Right.</z><z id="t1608071953" t="noprompt But you don’t want to call first on search because and prefer find because find avoids making collections etc."><y>#</y><d>2020-12-15</d><h>22:39</h><r>noprompt</r>But you don’t want to call <code>first</code> on <code>search</code> because and prefer <code>find</code> because <code>find</code> avoids making collections etc.</z><z id="t1608071968" t="noprompt Or, at least, it tries to avoid them as often as possible."><y>#</y><d>2020-12-15</d><h>22:39</h><r>noprompt</r>Or, at least, it tries to avoid them as often as possible.</z><z id="t1608071990" t="dgr OK, got it. So basically, match wants things to have a single possibility. search is willing to have multiple possibilities, which it can deal with because it returns all of them. And find is effectively an optimized version of (first (search …)) ."><y>#</y><d>2020-12-15</d><h>22:39</h><r>dgr</r>OK, got it. So basically, <code>match</code> wants things to have a single possibility. <code>search</code> is willing to have multiple possibilities, which it can deal with because it returns all of them. And <code>find</code> is effectively an optimized version of <code>(first (search …))</code>.</z><z id="t1608072058" t="dgr Thanks for the help. Another question so another thread. It seems like search (and find ) are almost Prolog-like in how they accomplish the search. It seems it’s performing backtracking in some sort of search tree across the whole pattern(s). Is that a good way to think about it?"><y>#</y><d>2020-12-15</d><h>22:40</h><w>dgr</w>Thanks for the help. Another question so another thread. It seems like <code>search</code> (and <code>find</code>) are almost Prolog-like in how they accomplish the search. It seems it’s performing backtracking in some sort of search tree across the whole pattern(s). Is that a good way to think about it?</z><z id="t1608072928" t="dgr Does Meander return all results from search in a list instead of a lazy seq? In other words, does one ever have to worry about laziness, or is that a non-issue?"><y>#</y><d>2020-12-15</d><h>22:55</h><w>dgr</w>Does Meander return all results from <code>search</code> in a list instead of a lazy seq? In other words, does one ever have to worry about laziness, or is that a non-issue?</z><z id="t1608072953" t="noprompt It’s lazy."><y>#</y><d>2020-12-15</d><h>22:55</h><w>noprompt</w>It’s lazy.</z><z id="t1608072963" t="noprompt So, don’t wrap it in binding 🙂"><y>#</y><d>2020-12-15</d><h>22:56</h><w>noprompt</w>So, don’t wrap it in <code>binding</code> <b>🙂</b></z><z id="t1608073004" t="noprompt find and match are, OTOH, eager."><y>#</y><d>2020-12-15</d><h>22:56</h><w>noprompt</w><code>find</code> and <code>match</code> are, OTOH, eager.</z><z id="t1608073020" t="dgr Is it? I see: (class (m/search 1 1 :one)) ;; =&gt; clojure.lang.PersistentList"><y>#</y><d>2020-12-15</d><h>22:57</h><w>dgr</w>Is it? I see:
<code>(class (m/search 1 1 :one))</code>
<code>;; =&gt; clojure.lang.PersistentList</code></z><z id="t1608073033" t="noprompt That is probably not reliable."><y>#</y><d>2020-12-15</d><h>22:57</h><w>noprompt</w>That is probably not reliable.</z><z id="t1608073108" t="noprompt (let [x {:a 1 :b 2 1 :a :d 4}] (class (m/search x {?k ?v ?v ?k} x))) ;; =&gt; clojure.lang.LazySeq "><y>#</y><d>2020-12-15</d><h>22:58</h><w>noprompt</w><pre>(let [x {:a 1 :b 2 1 :a :d 4}]
  (class
   (m/search x
     {?k ?v ?v ?k}
     x)))
;; =&gt; clojure.lang.LazySeq</pre>
</z><z id="t1608073109" t="dgr Yep: (class (m/search [1 2 3 4] (m/scan ?x) ?x)) ;; =&gt; clojure.lang.LazySeq"><y>#</y><d>2020-12-15</d><h>22:58</h><w>dgr</w>Yep:
<code>(class (m/search [1 2 3 4] (m/scan ?x) ?x))</code>
<code>;; =&gt; clojure.lang.LazySeq</code></z><z id="t1608073156" t="dgr So, what can we say about the return type? It conforms to sequential? ??"><y>#</y><d>2020-12-15</d><h>22:59</h><w>dgr</w>So, what can we say about the return type? It conforms to <code>sequential?</code> ??</z><z id="t1608073318" t="noprompt Yeah, I guess. Or that it matches the pattern (_ …) ."><y>#</y><d>2020-12-15</d><h>23:01</h><w>noprompt</w>Yeah, I guess. Or that it matches the pattern <code>(_ …)</code>.</z><z id="t1608073400" t="noprompt This the spec (s/fdef meander.match.epsilon/search :args (s/cat :expr any? :clauses :meander.match.epsilon.match/clauses) :ret (s/coll-of any? :kind sequential?)) "><y>#</y><d>2020-12-15</d><h>23:03</h><w>noprompt</w>This the spec
<pre>(s/fdef meander.match.epsilon/search
  :args (s/cat :expr any?
               :clauses :meander.match.epsilon.match/clauses)
  :ret (s/coll-of any? :kind sequential?))</pre>
</z><z id="t1608073405" t="dgr Seems like it returns: nil (no match), PersistentList, and LazySeq, depending on the case."><y>#</y><d>2020-12-15</d><h>23:03</h><w>dgr</w>Seems like it returns: nil (no match), PersistentList, and LazySeq, depending on the case.</z><z id="t1608073414" t="noprompt From meander.match.specs.epsilon"><y>#</y><d>2020-12-15</d><h>23:03</h><w>noprompt</w>From <code>meander.match.specs.epsilon</code></z><z id="t1608073428" t="dgr OK, so it’s basically a sequential? ."><y>#</y><d>2020-12-15</d><h>23:03</h><w>dgr</w>OK, so it’s basically a <code>sequential?</code>.</z><z id="t1608073433" t="noprompt Yeah."><y>#</y><d>2020-12-15</d><h>23:03</h><w>noprompt</w>Yeah.</z><z id="t1608073455" t="noprompt BTW, specs are mostly in these “private” namespaces."><y>#</y><d>2020-12-15</d><h>23:04</h><w>noprompt</w>BTW, specs are mostly in these “private” namespaces.</z><z id="t1608073466" t="dgr Should it return () for no match, instead of nil ?"><y>#</y><d>2020-12-15</d><h>23:04</h><w>dgr</w>Should it return <code>()</code> for no match, instead of <code>nil</code>?</z><z id="t1608073474" t="noprompt Yes."><y>#</y><d>2020-12-15</d><h>23:04</h><w>noprompt</w>Yes.</z><z id="t1608073476" t="dgr OK, I can take a look at the specs."><y>#</y><d>2020-12-15</d><h>23:04</h><w>dgr</w>OK, I can take a look at the specs.</z><z id="t1608073536" t="dgr (m/search 0 1 :one) ;; =&gt; nil"><y>#</y><d>2020-12-15</d><h>23:05</h><w>dgr</w><code>(m/search 0 1 :one)</code>
<code>;; =&gt; nil</code></z><z id="t1608073553" t="dgr not ()"><y>#</y><d>2020-12-15</d><h>23:05</h><w>dgr</w>not <code>()</code></z><z id="t1608073594" t="dgr and (sequential? nil) is false"><y>#</y><d>2020-12-15</d><h>23:06</h><w>dgr</w>and <code>(sequential? nil)</code> is <code>false</code></z><z id="t1608073619" t="noprompt Ah, well I guess then the spec is wrong. 🙂"><y>#</y><d>2020-12-15</d><h>23:06</h><w>noprompt</w>Ah, well I guess then the spec is wrong. <b>🙂</b></z><z id="t1608073633" t="dgr LOL. 🙂 I just gave you another unit test."><y>#</y><d>2020-12-15</d><h>23:07</h><w>dgr</w>LOL. <b>🙂</b> I just gave you another unit test.</z><z id="t1608073641" t="noprompt Eh, no."><y>#</y><d>2020-12-15</d><h>23:07</h><w>noprompt</w>Eh, no.</z><z id="t1608073655" t="noprompt But, yeah, sure."><y>#</y><d>2020-12-15</d><h>23:07</h><w>noprompt</w>But, yeah, sure.</z><z id="t1608073699" t="noprompt Heh, I’m pretty sure would could figure out why its not a list because, I would actually agree there is merit to it having a () output at minimum."><y>#</y><d>2020-12-15</d><h>23:08</h><w>noprompt</w>Heh, I’m pretty sure would could figure out why its not a list because, I would actually agree there is merit to it having a <code>()</code> output at minimum.</z><z id="t1608073769" t="Jimmy Miller Yeah, but it is also a breaking change. Just imagine it in a when"><y>#</y><d>2020-12-15</d><h>23:09</h><r>Jimmy Miller</r>Yeah, but it is also a breaking change. Just imagine it in a when</z><z id="t1608073997" t="dgr Yep"><y>#</y><d>2020-12-15</d><h>23:13</h><r>dgr</r>Yep</z><z id="t1608074695" t="noprompt Good point [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] !"><y>#</y><d>2020-12-15</d><h>23:24</h><r>noprompt</r>Good point <a>@U5K8NTHEZ</a>!</z><z id="t1608073700" t="Jimmy Miller nil seems fine. And probably best not to change it now."><y>#</y><d>2020-12-15</d><h>23:08</h><w>Jimmy Miller</w>nil seems fine. And probably best not to change it now.</z><z id="t1608073726" t="Jimmy Miller We can fix the spec though"><y>#</y><d>2020-12-15</d><h>23:08</h><w>Jimmy Miller</w>We can fix the spec though</z><z id="t1608073730" t="dgr You want me to file a low priority bug? I don’t know that it would cause a problem very often, but it seems like empty list is better than nil."><y>#</y><d>2020-12-15</d><h>23:08</h><w>dgr</w>You want me to file a low priority bug? I don’t know that it would cause a problem very often, but it seems like empty list is better than nil.</z><z id="t1608073788" t="noprompt I agree. Yes you can file the ticket but here’s the thing: I really want to stop working on epsilon"><y>#</y><d>2020-12-15</d><h>23:09</h><w>noprompt</w>I agree. Yes you can file the ticket but here’s the thing: I really want to stop working on <code>epsilon</code></z><z id="t1608073792" t="dgr Basically, a user should be checking for no result with (empty? (m/search …) , right?"><y>#</y><d>2020-12-15</d><h>23:09</h><w>dgr</w>Basically, a user should be checking for no result with <code>(empty? (m/search …)</code>, right?</z><z id="t1608073810" t="dgr Understood. Do you have a way to tag it for zeta?"><y>#</y><d>2020-12-15</d><h>23:10</h><w>dgr</w>Understood. Do you have a way to tag it for zeta?</z><z id="t1608073836" t="noprompt In fact, I would like to personally stop working on epsilon , take the stuff that I like to zeta , integrate it and start building there."><y>#</y><d>2020-12-15</d><h>23:10</h><w>noprompt</w>In fact, I would like to personally stop working on <code>epsilon</code>, take the stuff that I like to <code>zeta</code>, integrate it and start building there.</z><z id="t1608073845" t="noprompt You can tag it as both."><y>#</y><d>2020-12-15</d><h>23:10</h><w>noprompt</w>You can tag it as both.</z><z id="t1608073856" t="noprompt Because I think it should be fixed."><y>#</y><d>2020-12-15</d><h>23:10</h><w>noprompt</w>Because I think it should be fixed.</z><z id="t1608073864" t="noprompt I agree with your position. 🙂"><y>#</y><d>2020-12-15</d><h>23:11</h><w>noprompt</w>I agree with your position. <b>🙂</b></z><z id="t1608073866" t="dgr OK, I’ll file it."><y>#</y><d>2020-12-15</d><h>23:11</h><w>dgr</w>OK, I’ll file it.</z><z id="t1608073892" t="noprompt Pointing out these flaws keeps me motivated."><y>#</y><d>2020-12-15</d><h>23:11</h><w>noprompt</w>Pointing out these flaws keeps me motivated.</z><z id="t1608073895" t="dgr Corner cases. Gotta love ’em. :face_with_rolling_eyes:"><y>#</y><d>2020-12-15</d><h>23:11</h><w>dgr</w>Corner cases. Gotta love ’em. <b>:face_with_rolling_eyes:</b></z><z id="t1608073900" t="noprompt Yah."><y>#</y><d>2020-12-15</d><h>23:11</h><w>noprompt</w>Yah.</z><z id="t1608073919" t="dgr I’m a product manager for my day job, but I should have been a tester."><y>#</y><d>2020-12-15</d><h>23:11</h><w>dgr</w>I’m a product manager for my day job, but I should have been a tester.</z><z id="t1608073932" t="noprompt Seriously the best way to see commits on the project is to come here and point out a thing or two 😅"><y>#</y><d>2020-12-15</d><h>23:12</h><w>noprompt</w>Seriously the best way to see commits on the project is to come here and point out a thing or two <b>😅</b></z><z id="t1608073940" t="noprompt Semantics are important!"><y>#</y><d>2020-12-15</d><h>23:12</h><w>noprompt</w>Semantics are important!</z><z id="t1608073949" t="dgr BTW, did you see my question about Meander search being sort of Prolog like? Did that make sense?"><y>#</y><d>2020-12-15</d><h>23:12</h><w>dgr</w>BTW, did you see my question about Meander <code>search</code> being sort of Prolog like? Did that make sense?</z><z id="t1608073986" t="noprompt Yes it does. search is basically like unify with a ground term."><y>#</y><d>2020-12-15</d><h>23:13</h><w>noprompt</w>Yes it does. <code>search</code> is basically like <code>unify</code> with a ground term.</z><z id="t1608074025" t="dgr OK, cool. Then it wasn’t my imagination. 🙂"><y>#</y><d>2020-12-15</d><h>23:13</h><w>dgr</w>OK, cool. Then it wasn’t my imagination. <b>🙂</b></z><z id="t1608074060" t="noprompt It’s kinda like conde 😎"><y>#</y><d>2020-12-15</d><h>23:14</h><w>noprompt</w>It’s kinda like <code>conde</code> <b>😎</b></z><z id="t1608074061" t="dgr And scan is something close to member/3 in Prolog."><y>#</y><d>2020-12-15</d><h>23:14</h><w>dgr</w>And <code>scan</code> is something close to <code>member/3</code> in Prolog.</z><z id="t1608074071" t="dgr Right"><y>#</y><d>2020-12-15</d><h>23:14</h><w>dgr</w>Right</z><z id="t1608074073" t="noprompt Lemme check"><y>#</y><d>2020-12-15</d><h>23:14</h><w>noprompt</w>Lemme check</z><z id="t1608074139" t="noprompt Not member/2 ? I just did a quick search and that’s all I see from the SWI docs."><y>#</y><d>2020-12-15</d><h>23:15</h><w>noprompt</w>Not <code>member/2</code>? I just did a quick search and that’s all I see from the SWI docs.</z><z id="t1608074156" t="dgr Sorry, yea, member/2 ."><y>#</y><d>2020-12-15</d><h>23:15</h><w>dgr</w>Sorry, yea, <code>member/2</code>.</z><z id="t1608074174" t="noprompt Yes but it’s more like searching for a subsequence."><y>#</y><d>2020-12-15</d><h>23:16</h><w>noprompt</w>Yes but it’s more like searching for a subsequence.</z><z id="t1608074198" t="noprompt (m/scan ?x ?y ?z) ~= [_ ... ?x ?y ?z . _ ...] "><y>#</y><d>2020-12-15</d><h>23:16</h><w>noprompt</w><pre>(m/scan ?x ?y ?z) ~= [_ ... ?x ?y ?z . _ ...]</pre>
</z><z id="t1608074206" t="dgr Right. It’s the backtracking that got me. So, even if you only have one pattern, you’re doing backtracking within that pattern if you’re using scan ."><y>#</y><d>2020-12-15</d><h>23:16</h><w>dgr</w>Right. It’s the backtracking that got me. So, even if you only have one pattern, you’re doing backtracking within that pattern if you’re using <code>scan</code>.</z><z id="t1608074213" t="noprompt Or rather particular elements of a subsequence."><y>#</y><d>2020-12-15</d><h>23:16</h><w>noprompt</w>Or rather particular elements of a subsequence.</z><z id="t1608074225" t="noprompt Yep."><y>#</y><d>2020-12-15</d><h>23:17</h><w>noprompt</w>Yep.</z><z id="t1608074246" t="dgr And you’re calling the expression every time. Backtracking. Rebinding logic vars. Then calling the expression. And so on."><y>#</y><d>2020-12-15</d><h>23:17</h><w>dgr</w>And you’re calling the expression every time. Backtracking. Rebinding logic vars. Then calling the expression. And so on.</z><z id="t1608074267" t="noprompt Of course, we try to find the best way to create the smallest search space to minimize that by exploiting what we know."><y>#</y><d>2020-12-15</d><h>23:17</h><w>noprompt</w>Of course, we try to find the best way to create the smallest search space to minimize that by exploiting what we know.</z><z id="t1608074304" t="dgr BTW, I found something else while I was cooking up more examples for the docs."><y>#</y><d>2020-12-15</d><h>23:18</h><w>dgr</w>BTW, I found something else while I was cooking up more examples for the docs.</z><z id="t1608074307" t="noprompt Yes, but again, we try to minimize that."><y>#</y><d>2020-12-15</d><h>23:18</h><w>noprompt</w>Yes, but again, we try to minimize that.</z><z id="t1608074326" t="noprompt Share away"><y>#</y><d>2020-12-15</d><h>23:18</h><w>noprompt</w>Share away</z><z id="t1608074347" t="dgr (m/search {:a [1 2] :z [:x :y]} {:a (m/scan ?a) :z (m/scan ?z)} [?a ?z]) ;; =&gt; ([1 :x] [1 :y] [2 :x] [2 :y]) (m/search {:a [1 2] :b 2 :c 3 :d 4 :e 5 :f 6 :g 7 :h 8 :i 9 :j 10 :z [:x :y]} {:a (m/scan ?a) :b 2 :c 3 :d 4 :e 5 :f 6 :g 7 :h 8 :i 9 :j 10 :z (m/scan ?z)} [?a ?z]) ;; =&gt; ([1 :x] [2 :x] [1 :y] [2 :y])"><y>#</y><d>2020-12-15</d><h>23:19</h><w>dgr</w><code>(m/search {:a [1 2] :z [:x :y]}</code>
  <code>{:a (m/scan ?a) :z (m/scan ?z)}</code>
  <code>[?a ?z])</code>
<code>;; =&gt; ([1 :x] [1 :y] [2 :x] [2 :y])</code>

<code>(m/search {:a [1 2] :b 2 :c 3 :d 4 :e 5 :f 6 :g 7 :h 8 :i 9 :j 10 :z [:x :y]}</code>
  <code>{:a (m/scan ?a) :b 2 :c 3 :d 4 :e 5 :f 6 :g 7 :h 8 :i 9 :j 10 :z (m/scan ?z)}</code>
  <code>[?a ?z])</code>
<code>;; =&gt; ([1 :x] [2 :x] [1 :y] [2 :y])</code></z><z id="t1608074377" t="noprompt Yes"><y>#</y><d>2020-12-15</d><h>23:19</h><w>noprompt</w>Yes</z><z id="t1608074432" t="noprompt Both patterns are looking for all possible combinations of ?a in [1 2] at :a and ?z in [:x :y] at :z ."><y>#</y><d>2020-12-15</d><h>23:20</h><w>noprompt</w>Both patterns are looking for all possible combinations of <code>?a</code> in <code>[1 2]</code> at <code>:a</code> and <code>?z</code> in <code>[:x :y]</code> at <code>:z</code>.</z><z id="t1608074432" t="dgr Depending on the number of items in a map literal, Clojure will either put them in a PersistentArrayMap or a PersistentHashMap. If it chooses an array map, then the order is as the user writes them. If hash map, then it’s whatever the hash order is."><y>#</y><d>2020-12-15</d><h>23:20</h><w>dgr</w>Depending on the number of items in a map literal, Clojure will either put them in a PersistentArrayMap or a PersistentHashMap. If it chooses an array map, then the order is as the user writes them. If hash map, then it’s whatever the hash order is.</z><z id="t1608074448" t="noprompt And there is no way around that unfortunately."><y>#</y><d>2020-12-15</d><h>23:20</h><w>noprompt</w>And there is no way around that unfortunately.</z><z id="t1608074453" t="dgr That changes the order that Meander does the search and changes the order of the output."><y>#</y><d>2020-12-15</d><h>23:20</h><w>dgr</w>That changes the order that Meander does the search and changes the order of the output.</z><z id="t1608074459" t="dgr It’s not a problem."><y>#</y><d>2020-12-15</d><h>23:20</h><w>dgr</w>It’s not a problem.</z><z id="t1608074461" t="noprompt It can, yes,"><y>#</y><d>2020-12-15</d><h>23:21</h><w>noprompt</w>It can, yes,</z><z id="t1608074469" t="noprompt However, I have been thinking that is actually biased."><y>#</y><d>2020-12-15</d><h>23:21</h><w>noprompt</w>However, I have been thinking that is actually biased.</z><z id="t1608074473" t="dgr I just point that out in the (new) docs as something to be aware of."><y>#</y><d>2020-12-15</d><h>23:21</h><w>dgr</w>I just point that out in the (new) docs as something to be aware of.</z><z id="t1608074480" t="dgr It will affect find , for instance."><y>#</y><d>2020-12-15</d><h>23:21</h><w>dgr</w>It will affect <code>find</code>, for instance.</z><z id="t1608074482" t="noprompt We have ticket for the problem"><y>#</y><d>2020-12-15</d><h>23:21</h><w>noprompt</w>We have ticket for the problem</z><z id="t1608074489" t="noprompt No solution yet."><y>#</y><d>2020-12-15</d><h>23:21</h><w>noprompt</w>No solution yet.</z><z id="t1608074505" t="dgr Oh, you already have a ticket. Cool. No worries then."><y>#</y><d>2020-12-15</d><h>23:21</h><w>dgr</w>Oh, you already have a ticket. Cool. No worries then.</z><z id="t1608074513" t="noprompt But I’ve been thinking a way to solve it would be to have a method of being able to tell the interpreter/compiler how to produce the space."><y>#</y><d>2020-12-15</d><h>23:21</h><w>noprompt</w>But I’ve been thinking a way to solve it would be to have a method of being able to tell the interpreter/compiler how to produce the space.</z><z id="t1608074562" t="dgr Most of the time it shouldn’t matter. And as long as it’s documented, I think it should be OK. I added a short section to the docs that shows the issue and basically says “Don’t rely on the ordering.”"><y>#</y><d>2020-12-15</d><h>23:22</h><w>dgr</w>Most of the time it shouldn’t matter. And as long as it’s documented, I think it should be OK. I added a short section to the docs that shows the issue and basically says “Don’t rely on the ordering.”</z><z id="t1608074606" t="dgr I gotta run and get dinner on the table for my kids. TTYL. Thanks for the help. That was great. I’ll file the bug shortly and I’ll submit a PR with doc updates in a bit."><y>#</y><d>2020-12-15</d><h>23:23</h><w>dgr</w>I gotta run and get dinner on the table for my kids. TTYL. Thanks for the help. That was great. I’ll file the bug shortly and I’ll submit a PR with doc updates in a bit.</z><z id="t1608074651" t="noprompt [:attrs {:href &quot;/_/_/users/U7BEY9U10&quot;}] Thank you 🙏"><y>#</y><d>2020-12-15</d><h>23:24</h><w>noprompt</w><a>@droberts3</a> Thank you <b>🙏</b></z><z id="t1608079804" t="dgr [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] My pleasure."><y>#</y><d>2020-12-16</d><h>00:50</h><w>dgr</w><a>@noprompt</a> My pleasure.</z><z id="t1608081015" t="dgr [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] , OK, I filed the issue about nil vs. () . I don’t seem to have a way to tag the issue with anything, so I think you’ll have to do that."><y>#</y><d>2020-12-16</d><h>01:10</h><w>dgr</w><a>@noprompt</a>, OK, I filed the issue about <code>nil</code> vs. <code>()</code>. I don’t seem to have a way to tag the issue with anything, so I think you’ll have to do that.</z><z id="t1608083179" t="noprompt Got it"><y>#</y><d>2020-12-16</d><h>01:46</h><w>noprompt</w>Got it</z><z id="t1608155155" t="noprompt I merged the interpreter work. It’s light on the docs and on the tests. There are some things about CLJS that need to mentioning but it’s working and we can tweak that later."><y>#</y><d>2020-12-16</d><h>21:45</h><w>noprompt</w>I merged the interpreter work. It’s light on the docs and on the tests. There are some things about CLJS that need to mentioning but it’s working and we can tweak that later.</z><z id="t1608155173" t="noprompt Again, I would call this experimental."><y>#</y><d>2020-12-16</d><h>21:46</h><w>noprompt</w>Again, I would call this experimental.</z><z id="t1608155219" t="noprompt There’s some sci symbol resolution that needs to be fixed to have this work in babashka but it works well enough."><y>#</y><d>2020-12-16</d><h>21:46</h><w>noprompt</w>There’s some sci symbol resolution that needs to be fixed to have this work in babashka but it works well enough.</z><z id="t1608155231" t="noprompt Well, once that problem is fixed."><y>#</y><d>2020-12-16</d><h>21:47</h><w>noprompt</w>Well, once that problem is fixed.</z><z id="t1608155288" t="noprompt [:attrs {:href &quot;/_/_/users/U7BEY9U10&quot;}] I’m going to merge your doc patch. It’s outstanding. Thank you for that."><y>#</y><d>2020-12-16</d><h>21:48</h><w>noprompt</w><a>@droberts3</a> I’m going to merge your doc patch. It’s outstanding. Thank you for that.</z><z id="t1608155317" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] I&apos;m currently refactoring some code in sci where I&apos;m also hitting that code. So maybe I&apos;ll just fix it if you don&apos;t mind"><y>#</y><d>2020-12-16</d><h>21:48</h><w>borkdude</w><a>@noprompt</a> I&apos;m currently refactoring some code in sci where I&apos;m also hitting that code. So maybe I&apos;ll just fix it if you don&apos;t mind</z><z id="t1608155368" t="noprompt [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] Ah, that would be great. Actually, I was planning on trying to make it a bit more declarative and surprise you but that might take longer than you just getting it done. 🙂"><y>#</y><d>2020-12-16</d><h>21:49</h><w>noprompt</w><a>@borkdude</a> Ah, that would be great. Actually, I was planning on trying to make it a bit more declarative and surprise you but that might take longer than you just getting it done. <b>🙂</b></z><z id="t1608155482" t="noprompt I’m looking forward to that because I think with bb and the direction the code is now going in, there’s going to be an opportunity to make some fun data shredding/querying stuff on the CLI."><y>#</y><d>2020-12-16</d><h>21:51</h><w>noprompt</w>I’m looking forward to that because I think with <code>bb</code> and the direction the code is now going in, there’s going to be an opportunity to make some fun data shredding/querying stuff on the CLI.</z><z id="t1608155583" t="borkdude bb also got a new feature last weekend to add deps directly in a script: https://book.babashka.org/#_add_deps so it will be very easy to try out meander with bb"><y>#</y><d>2020-12-16</d><h>21:53</h><w>borkdude</w>bb also got a new feature last weekend to add deps directly in a script:

<a href="https://book.babashka.org/#_add_deps" target="_blank">https://book.babashka.org/#_add_deps</a>

so it will be very easy to try out meander with bb</z><z id="t1608155722" t="noprompt Kick ass!"><y>#</y><d>2020-12-16</d><h>21:55</h><r>noprompt</r>Kick ass!</z><z id="t1608155769" t="noprompt Yeah, that’s really sweet."><y>#</y><d>2020-12-16</d><h>21:56</h><r>noprompt</r>Yeah, that’s really sweet.</z><z id="t1608157824" t="borkdude just pushed the fix to sci and bb"><y>#</y><d>2020-12-16</d><h>22:30</h><r>borkdude</r>just pushed the fix to sci and bb</z><z id="t1608157864" t="noprompt You’re the bomb [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] 🙂"><y>#</y><d>2020-12-16</d><h>22:31</h><r>noprompt</r>You’re the bomb <a>@borkdude</a> <b>🙂</b></z><z id="t1608155687" t="noprompt [:attrs {:href &quot;/_/_/users/U7BEY9U10&quot;}] I’ve extended an opportunity for you to work on branches connected to the main project, etc. Take advantage of it if it reduces friction in the contribution process for you. All that I ask is that you continue to open PRs and have them reviewed before pressing the merge button. 🙂"><y>#</y><d>2020-12-16</d><h>21:54</h><w>noprompt</w><a>@droberts3</a> I’ve extended an opportunity for you to work on branches connected to the main project, etc. Take advantage of it if it reduces friction in the contribution process for you. All that I ask is that you continue to open PRs and have them reviewed before pressing the merge button. <b>🙂</b></z><z id="t1608155775" t="dgr [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] , OK. I’ll just continue to submit PRs unless I find a strong reason otherwise."><y>#</y><d>2020-12-16</d><h>21:56</h><w>dgr</w><a>@noprompt</a>, OK. I’ll just continue to submit PRs unless I find a strong reason otherwise.</z><z id="t1608155812" t="noprompt Heh, we’re gonna need to figure out how to make one of these cool new markdown books that seem to be en vogue these days."><y>#</y><d>2020-12-16</d><h>21:56</h><w>noprompt</w>Heh, we’re gonna need to figure out how to make one of these cool new markdown books that seem to be en vogue these days.</z><z id="t1608155850" t="noprompt The docs look pretty nice on clj-doc I gotta say."><y>#</y><d>2020-12-16</d><h>21:57</h><w>noprompt</w>The docs look pretty nice on clj-doc I gotta say.</z><z id="t1608155852" t="dgr I was actually going to suggest perhaps looking at adoc. It’s also supported by github and CIDER is using it."><y>#</y><d>2020-12-16</d><h>21:57</h><w>dgr</w>I was actually going to suggest perhaps looking at adoc. It’s also supported by github and CIDER is using it.</z><z id="t1608155868" t="dgr I don’t know if clj-doc supports it."><y>#</y><d>2020-12-16</d><h>21:57</h><w>dgr</w>I don’t know if clj-doc supports it.</z><z id="t1608155891" t="dgr It has some nicer support for doing examples"><y>#</y><d>2020-12-16</d><h>21:58</h><w>dgr</w>It has some nicer support for doing examples</z><z id="t1608155939" t="noprompt IIRC adoc came up previously. If clj-doc supports it and that is a better format then I’d be open to checking that out."><y>#</y><d>2020-12-16</d><h>21:58</h><w>noprompt</w>IIRC adoc came up previously. If clj-doc supports it and that is a better format then I’d be open to checking that out.</z><z id="t1608155962" t="noprompt If not, I’d prefer we stick to what they support for now pending a script or something to roll into the build process."><y>#</y><d>2020-12-16</d><h>21:59</h><w>noprompt</w>If not, I’d prefer we stick to what they support for now pending a script or something to roll into the build process.</z><z id="t1608156005" t="dgr Yep. I can take a look and we could trial a conversion of one of the docs to see how it looks. We could also convert incrementally."><y>#</y><d>2020-12-16</d><h>22:00</h><w>dgr</w>Yep. I can take a look and we could trial a conversion of one of the docs to see how it looks. We could also convert incrementally.</z><z id="t1608156006" t="noprompt There is a bin/build-release script and we can wire in that compilation to markdown if need be."><y>#</y><d>2020-12-16</d><h>22:00</h><w>noprompt</w>There is a <code>bin/build-release</code> script and we can wire in that compilation to markdown if need be.</z><z id="t1608156017" t="dgr Ultimately adoc is a lot more powerful than Markdown."><y>#</y><d>2020-12-16</d><h>22:00</h><w>dgr</w>Ultimately adoc is a lot more powerful than Markdown.</z><z id="t1608156019" t="noprompt Alrighty, yeah, have at it. 🙂"><y>#</y><d>2020-12-16</d><h>22:00</h><w>noprompt</w>Alrighty, yeah, have at it. <b>🙂</b></z><z id="t1608156054" t="noprompt I suck at docs so this an area where I can use all the help I can get."><y>#</y><d>2020-12-16</d><h>22:00</h><w>noprompt</w>I suck at docs so this an area where I can use all the help I can get.</z><z id="t1608156112" t="noprompt With the big asterisks “no pressure, family first, etc.” attached."><y>#</y><d>2020-12-16</d><h>22:01</h><w>noprompt</w>With the big asterisks “no pressure, family first, etc.” attached.</z><z id="t1608156230" t="dgr Cool. I’ll focus on content for now. I think the priority should be on the matching macros, patterns, and then substitutions. Once we have those well-documented, that will be huge."><y>#</y><d>2020-12-16</d><h>22:03</h><w>dgr</w>Cool. I’ll focus on content for now. I think the priority should be on the matching macros, patterns, and then substitutions. Once we have those well-documented, that will be huge.</z><z id="t1608156287" t="dgr I also want to pull over some of the ideas in some of [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] ’s blogs. I was reading through those a couple days ago and there’s some really great content there. The Meander in Meander post was very thought-provoking."><y>#</y><d>2020-12-16</d><h>22:04</h><w>dgr</w>I also want to pull over some of the ideas in some of <a>@jimmy</a>’s blogs. I was reading through those a couple days ago and there’s some really great content there. The Meander in Meander post was very thought-provoking.</z><z id="t1608156352" t="noprompt Awesome. I’ll continue to loop folks here in on what is coming down the line. The most significant changes are going to come with local and project and dissolving the differences between the left and right sides such that any pattern can be used on either side."><y>#</y><d>2020-12-16</d><h>22:05</h><w>noprompt</w>Awesome. I’ll continue to loop folks here in on what is coming down the line. The most significant changes are going to come with <code>local</code> and <code>project</code> and dissolving the differences between the left and right sides such that any pattern can be used on either side.</z><z id="t1608156381" t="noprompt I enjoyed that post too."><y>#</y><d>2020-12-16</d><h>22:06</h><w>noprompt</w>I enjoyed that post too.</z><z id="t1608156497" t="noprompt We’ll definitely be applying some of those techniques in zeta however. With the functional API established, we can use that internally for all sorts of things like parsing and compiling."><y>#</y><d>2020-12-16</d><h>22:08</h><w>noprompt</w>We’ll definitely be applying some of those techniques in <code>zeta</code> however. With the functional API established, we can use that internally for all sorts of things like parsing and compiling.</z><z id="t1608156565" t="noprompt I really wanted to write zeta with epsilon but, yeah, it’s just not there yet, however, it does get really close."><y>#</y><d>2020-12-16</d><h>22:09</h><w>noprompt</w>I really wanted to write <code>zeta</code> with <code>epsilon</code> but, yeah, it’s just not there yet, however, it does get really close.</z><z id="t1608156616" t="noprompt Another thing is, I would like the ground floor to be inclusive of folks existing Clojure chops."><y>#</y><d>2020-12-16</d><h>22:10</h><w>noprompt</w>Another thing is, I would like the ground floor to be inclusive of folks existing Clojure chops.</z><z id="t1608156644" t="dgr Yea, certainly."><y>#</y><d>2020-12-16</d><h>22:10</h><w>dgr</w>Yea, certainly.</z><z id="t1608156664" t="dgr We want to educate folks, not scare the crap out of them with the advanced class right out of the gate."><y>#</y><d>2020-12-16</d><h>22:11</h><w>dgr</w>We want to educate folks, not scare the crap out of them with the advanced class right out of the gate.</z><z id="t1608156671" t="noprompt Starting at Meander and working up might having a chilling effect on folks looking to contribute."><y>#</y><d>2020-12-16</d><h>22:11</h><w>noprompt</w>Starting at Meander and working up might having a chilling effect on folks looking to contribute.</z><z id="t1608156683" t="noprompt Hahaha, yes. 🙂"><y>#</y><d>2020-12-16</d><h>22:11</h><w>noprompt</w>Hahaha, yes. <b>🙂</b></z><z id="t1608156732" t="dgr But I think nothing would show the power of Meander than writing Meander in Meander. Not to mention the meta-recursion points you’d earn. 🙂"><y>#</y><d>2020-12-16</d><h>22:12</h><w>dgr</w>But I think nothing would show the power of Meander than writing Meander in Meander. Not to mention the meta-recursion points you’d earn. <b>🙂</b></z><z id="t1608156789" t="noprompt Here’s the parser: https://github.com/noprompt/meander/blob/zeta/dev/meander/dev/parse/zeta.clj#L59"><y>#</y><d>2020-12-16</d><h>22:13</h><w>noprompt</w>Here’s the parser: <a href="https://github.com/noprompt/meander/blob/zeta/dev/meander/dev/parse/zeta.clj#L59" target="_blank">https://github.com/noprompt/meander/blob/zeta/dev/meander/dev/parse/zeta.clj#L59</a></z><z id="t1608156813" t="noprompt And the match compiler: https://github.com/noprompt/meander/blob/zeta/dev/meander/dev/match/zeta.clj#L18"><y>#</y><d>2020-12-16</d><h>22:13</h><w>noprompt</w>And the match compiler: <a href="https://github.com/noprompt/meander/blob/zeta/dev/meander/dev/match/zeta.clj#L18" target="_blank">https://github.com/noprompt/meander/blob/zeta/dev/meander/dev/match/zeta.clj#L18</a></z><z id="t1608156845" t="noprompt And operating those things: https://github.com/noprompt/meander/blob/zeta/dev/meander/dev/zeta.clj"><y>#</y><d>2020-12-16</d><h>22:14</h><w>noprompt</w>And operating those things: <a href="https://github.com/noprompt/meander/blob/zeta/dev/meander/dev/zeta.clj" target="_blank">https://github.com/noprompt/meander/blob/zeta/dev/meander/dev/zeta.clj</a></z><z id="t1608156905" t="noprompt This is informative stuff, it works, and it performs decently, but there are some developer creature comforts missing."><y>#</y><d>2020-12-16</d><h>22:15</h><w>noprompt</w>This is informative stuff, it works, and it performs decently, but there are some developer creature comforts missing.</z><z id="t1608156971" t="noprompt In previous discussions with [:attrs {:href &quot;/_/_/users/U014X1MN7MM&quot;}] a big issue with large systems like this is that you don’t have a good way of diagnosing what is happening."><y>#</y><d>2020-12-16</d><h>22:16</h><w>noprompt</w>In previous discussions with <a>@e749</a> a big issue with large systems like this is that you don’t have a good way of diagnosing what is happening.</z><z id="t1608157056" t="noprompt However, this problem should mostly be solved now by the approach taken by factory code: building up a pattern factory and using dependency injection to pass in how it should operate at runtime."><y>#</y><d>2020-12-16</d><h>22:17</h><w>noprompt</w>However, this problem should mostly be solved now by the approach taken by factory code: building up a pattern factory and using dependency injection to pass in how it should operate at runtime.</z><z id="t1608157113" t="noprompt You can pass a runtime that prints or collects information about rewriting/matching/etc."><y>#</y><d>2020-12-16</d><h>22:18</h><w>noprompt</w>You can pass a runtime that prints or collects information about rewriting/matching/etc.</z><z id="t1608157143" t="dgr Yea, deep macrology is always awesome. Right until it blows up. And then you’re wading through 10,000 lines of macroexpansion and wondering how expensive it is just to write it all from scratch."><y>#</y><d>2020-12-16</d><h>22:19</h><w>dgr</w>Yea, deep macrology is always awesome. Right until it blows up. And then you’re wading through 10,000 lines of macroexpansion and wondering how expensive it is just to write it all from scratch.</z><z id="t1608157192" t="noprompt True."><y>#</y><d>2020-12-16</d><h>22:19</h><w>noprompt</w>True.</z><z id="t1608157262" t="noprompt My hope though is that with explainability, composability, interpretability, compilability, and being able to mix and match those things both at runtime and compile time it’ll solve those problems."><y>#</y><d>2020-12-16</d><h>22:21</h><w>noprompt</w>My hope though is that with explainability, composability, interpretability, compilability, and being able to mix and match those things both at runtime and compile time it’ll solve those problems.</z><z id="t1608157294" t="noprompt The goal is to have something like spec style explainability and conform without the terrible performance."><y>#</y><d>2020-12-16</d><h>22:21</h><w>noprompt</w>The goal is to have something like spec style explainability and <code>conform</code> without the terrible performance.</z><z id="t1608157318" t="dgr Makes sense."><y>#</y><d>2020-12-16</d><h>22:21</h><w>dgr</w>Makes sense.</z><z id="t1608157344" t="noprompt But also, I don’t want to necessarily need to use clojure.test.check either and have my specs and code be separted."><y>#</y><d>2020-12-16</d><h>22:22</h><w>noprompt</w>But also, I don’t want to necessarily need to use <code>clojure.test.check</code> either and have my specs and code be separted.</z><z id="t1608157378" t="noprompt I should be able to define a pattern and use it aggressively at every level."><y>#</y><d>2020-12-16</d><h>22:22</h><w>noprompt</w>I should be able to define a pattern and use it aggressively at every level.</z><z id="t1608157399" t="noprompt Now I’m just rambling."><y>#</y><d>2020-12-16</d><h>22:23</h><w>noprompt</w>Now I’m just rambling.</z><z id="t1608157404" t="noprompt I probably need to eat. 🙂"><y>#</y><d>2020-12-16</d><h>22:23</h><w>noprompt</w>I probably need to eat. <b>🙂</b></z><z id="t1608157409" t="dgr LOL"><y>#</y><d>2020-12-16</d><h>22:23</h><w>dgr</w>LOL</z><z id="t1608157476" t="noprompt So, soon you’ll be able to say (yield &lt;pattern&gt; [bindings]) and have it spit out a stream of all the ways to construct pattern from those bindings ."><y>#</y><d>2020-12-16</d><h>22:24</h><w>noprompt</w>So, soon you’ll be able to say <code>(yield &lt;pattern&gt; [bindings])</code> and have it spit out a stream of all the ways to construct <code>pattern</code> from those <code>bindings</code>.</z><z id="t1608157511" t="dgr Interesting. That would be cool."><y>#</y><d>2020-12-16</d><h>22:25</h><w>dgr</w>Interesting. That would be cool.</z><z id="t1608157531" t="noprompt I think 3 to 6 weeks from now depending on how much hacking I do during the upcoming winter break."><y>#</y><d>2020-12-16</d><h>22:25</h><w>noprompt</w>I think 3 to 6 weeks from now depending on how much hacking I do during the upcoming winter break.</z></g><g id="s8"><z id="t1608157566" t="dgr Meander is a weird love child of a term rewriting system, a logic programming language, and Lisp."><y>#</y><d>2020-12-16</d><h>22:26</h><w>dgr</w>Meander is a weird love child of a term rewriting system, a logic programming language, and Lisp.</z><z id="t1608157578" t="noprompt It is easy to find excuses to play games when you have a Geforce 3080 😛"><y>#</y><d>2020-12-16</d><h>22:26</h><w>noprompt</w>It is easy to find excuses to play games when you have a Geforce 3080 <b>😛</b></z><z id="t1608157590" t="noprompt Yes!"><y>#</y><d>2020-12-16</d><h>22:26</h><w>noprompt</w>Yes!</z><z id="t1608157762" t="noprompt And that’s kind of where I want it. Term rewriting is awesome but many devs will start dropping packets the moment you start talking to them about it. Logic programming is also great but its hard to ignore that devs also have to invest a lot of their own time to learn new tricks, something that’s not always appealing without and obvious pot of gold on the other end. Lisp is close enough to “normal” programming that you can sneak devs in with stuff they know."><y>#</y><d>2020-12-16</d><h>22:29</h><w>noprompt</w>And that’s kind of where I want it. Term rewriting is awesome but many devs will start dropping packets the moment you start talking to them about it. Logic programming is also great but its hard to ignore that devs also have to invest a lot of their own time to learn new tricks, something that’s not always appealing without and obvious pot of gold on the other end. Lisp is close enough to “normal” programming that you can sneak devs in with stuff they know.</z><z id="t1608157789" t="noprompt One thing we all understand is data literals."><y>#</y><d>2020-12-16</d><h>22:29</h><w>noprompt</w>One thing we all understand is data literals.</z><z id="t1608157832" t="dgr Yes, agreed. See, I love all those “old” technologies. Everybody else has basically forgotten about them, but there are a ton of really, really useful ideas lurking in those old CS papers."><y>#</y><d>2020-12-16</d><h>22:30</h><w>dgr</w>Yes, agreed. See, I love all those “old” technologies. Everybody else has basically forgotten about them, but there are a ton of really, really useful ideas lurking in those old CS papers.</z><z id="t1608157835" t="noprompt So how can we leverage the things that are easy to grok for everyone?"><y>#</y><d>2020-12-16</d><h>22:30</h><w>noprompt</w>So how can we leverage the things that are easy to grok for everyone?</z><z id="t1608157847" t="noprompt Yes, yes."><y>#</y><d>2020-12-16</d><h>22:30</h><w>noprompt</w>Yes, yes.</z><z id="t1608157944" t="noprompt Logic variables and data literals are easy to understand. Pattern matching is also pretty easy for people to pick up because it is often a subtle tweak on what they already know about those two things."><y>#</y><d>2020-12-16</d><h>22:32</h><w>noprompt</w>Logic variables and data literals are easy to understand. Pattern matching is also pretty easy for people to pick up because it is often a subtle tweak on what they already know about those two things.</z><z id="t1608157951" t="dgr One reason I like Meander, I think, is that it doesn’t try to be more than it needs to be. For instance, I would probably hate to write a large program in nothing by Prolog. But I’d love a great logic engine embedded in Clojure that you can call out too (unfortunately, core.logic has too many limitations and seems almost abandoned at this point)."><y>#</y><d>2020-12-16</d><h>22:32</h><w>dgr</w>One reason I like Meander, I think, is that it doesn’t try to be more than it needs to be. For instance, I would probably hate to write a large program in nothing by Prolog. But I’d love a great logic engine embedded in Clojure that you can call out too (unfortunately, core.logic has too many limitations and seems almost abandoned at this point).</z><z id="t1608157973" t="noprompt It’s funny you mention that."><y>#</y><d>2020-12-16</d><h>22:32</h><w>noprompt</w>It’s funny you mention that.</z><z id="t1608157979" t="dgr Ditto with a term rewriting system."><y>#</y><d>2020-12-16</d><h>22:32</h><w>dgr</w>Ditto with a term rewriting system.</z><z id="t1608158033" t="dgr I want to be “in Clojure” and be able to say, “Here’s a logic problem that I need solved. Solve it.” Or “Here’s a data structure I need rewritten. Rewrite it.”"><y>#</y><d>2020-12-16</d><h>22:33</h><w>dgr</w>I want to be “in Clojure” and be able to say, “Here’s a logic problem that I need solved. Solve it.” Or “Here’s a data structure I need rewritten. Rewrite it.”</z><z id="t1608158058" t="dgr Then, take the answer and slam it into Hiccup or whatever."><y>#</y><d>2020-12-16</d><h>22:34</h><w>dgr</w>Then, take the answer and slam it into Hiccup or whatever.</z><z id="t1608158061" t="noprompt Maps alone, which arguably are the bread and butter structure of most Clojure programs, are just flat out annoying to work with in stock core logic. And that’s not say something bad about core logic; it’s just the case."><y>#</y><d>2020-12-16</d><h>22:34</h><w>noprompt</w>Maps alone, which arguably are the bread and butter structure of most Clojure programs, are just flat out annoying to work with in stock core logic. And that’s not say something bad about core logic; it’s just the case.</z><z id="t1608158073" t="dgr Yep."><y>#</y><d>2020-12-16</d><h>22:34</h><w>dgr</w>Yep.</z><z id="t1608158080" t="noprompt Right. Stuff can be very blunt and very forward."><y>#</y><d>2020-12-16</d><h>22:34</h><w>noprompt</w>Right. Stuff can be very blunt and very forward.</z><z id="t1608158141" t="noprompt Which, arguably, you can see in Prolog and even Haskell or ML style language in the pattern matching oriented parts fo the language."><y>#</y><d>2020-12-16</d><h>22:35</h><w>noprompt</w>Which, arguably, you can see in Prolog and even Haskell or ML style language in the pattern matching oriented parts fo the language.</z><z id="t1608158142" t="dgr Well, and core.logic doesn’t have some good things that Prolog has (notably missing are things like findall , bagof and setof ."><y>#</y><d>2020-12-16</d><h>22:35</h><w>dgr</w>Well, and core.logic doesn’t have some good things that Prolog has (notably missing are things like <code>findall</code>, <code>bagof</code> and <code>setof</code>.</z><z id="t1608158233" t="dgr I think Mark Engelberg did a great job with his Rolling Stones library, wrapping sat4j up. I’ve used that as a nice way to incorporate a SAT solver."><y>#</y><d>2020-12-16</d><h>22:37</h><w>dgr</w>I think Mark Engelberg did a great job with his Rolling Stones library, wrapping sat4j up. I’ve used that as a nice way to incorporate a SAT solver.</z><z id="t1608158251" t="noprompt I should check that out."><y>#</y><d>2020-12-16</d><h>22:37</h><w>noprompt</w>I should check that out.</z><z id="t1608158301" t="dgr Yea, it’s nice. It’s all data driven, so, you could actually describe your problem in another data format and then use Meander to (help?) construct the SAT problem."><y>#</y><d>2020-12-16</d><h>22:38</h><w>dgr</w>Yea, it’s nice. It’s all data driven, so, you could actually describe your problem in another data format and then use Meander to (help?) construct the SAT problem.</z><z id="t1608158337" t="noprompt Ah, man, that sounds cool."><y>#</y><d>2020-12-16</d><h>22:38</h><w>noprompt</w>Ah, man, that sounds cool.</z><z id="t1608158337" t="dgr Then throw the SAT problem at Rolling Stones, which then translates it into Java objects for sat4j."><y>#</y><d>2020-12-16</d><h>22:38</h><w>dgr</w>Then throw the SAT problem at Rolling Stones, which then translates it into Java objects for sat4j.</z><z id="t1608158349" t="noprompt Interesting. Putting that on the todo list."><y>#</y><d>2020-12-16</d><h>22:39</h><w>noprompt</w>Interesting. Putting that on the todo list.</z><z id="t1608158378" t="dgr Dude, you have a GeForce 3080. Where are you going to find the time? 😛"><y>#</y><d>2020-12-16</d><h>22:39</h><w>dgr</w>Dude, you have a GeForce 3080. Where are you going to find the time? <b>😛</b></z><z id="t1608158445" t="noprompt Hahaha yeah."><y>#</y><d>2020-12-16</d><h>22:40</h><w>noprompt</w>Hahaha yeah.</z><z id="t1608158456" t="noprompt But I’m paranoid all the time now."><y>#</y><d>2020-12-16</d><h>22:40</h><w>noprompt</w>But I’m paranoid all the time now.</z><z id="t1608158476" t="noprompt I’m afraid somehow water is going to magically get poured on top of my case and ruin it."><y>#</y><d>2020-12-16</d><h>22:41</h><w>noprompt</w>I’m afraid somehow water is going to magically get poured on top of my case and ruin it.</z><z id="t1608158503" t="noprompt And mostly because everything next-gen is sold out everywhere."><y>#</y><d>2020-12-16</d><h>22:41</h><w>noprompt</w>And mostly because everything next-gen is sold out everywhere.</z><z id="t1608158513" t="noprompt 2020 in spades."><y>#</y><d>2020-12-16</d><h>22:41</h><w>noprompt</w>2020 in spades.</z><z id="t1608158539" t="dgr Yea, well, 2020 just needs to die right now. Here’s to 2021."><y>#</y><d>2020-12-16</d><h>22:42</h><w>dgr</w>Yea, well, 2020 just needs to die right now. Here’s to 2021.</z><z id="t1608158548" t="noprompt Cheers to that."><y>#</y><d>2020-12-16</d><h>22:42</h><w>noprompt</w>Cheers to that.</z><z id="t1608158562" t="dgr Seriously, things like TRS, Logic Programming, SAT, etc. are power tools. And today’s coders are worried about the latest Javascript framework. :face_with_rolling_eyes:"><y>#</y><d>2020-12-16</d><h>22:42</h><w>dgr</w>Seriously, things like TRS, Logic Programming, SAT, etc. are power tools. And today’s coders are worried about the latest Javascript framework. <b>:face_with_rolling_eyes:</b></z><z id="t1608158608" t="noprompt Yes. We need to have LP catch on the way FP has in recent times."><y>#</y><d>2020-12-16</d><h>22:43</h><w>noprompt</w>Yes. We need to have LP catch on the way FP has in recent times.</z><z id="t1608158685" t="noprompt I’ve been thinking that I would be neat to take the direction Meander is going in, emphasizing the forward concepts with an LP slant, mix in some data flow and call it a prototype language."><y>#</y><d>2020-12-16</d><h>22:44</h><w>noprompt</w>I’ve been thinking that I would be neat to take the direction Meander is going in, emphasizing the forward concepts with an LP slant, mix in some data flow and call it a prototype language.</z><z id="t1608158731" t="noprompt But, in general, it would be nice to see more of LP catching on. I think it will."><y>#</y><d>2020-12-16</d><h>22:45</h><w>noprompt</w>But, in general, it would be nice to see more of LP catching on. I think it will.</z><z id="t1608158872" t="dgr Yea, agreed. One of the hardest parts is to (re)train yourself to think in those ways, however. Honestly, it’s like coming from imperative OOP to functional, but worse."><y>#</y><d>2020-12-16</d><h>22:47</h><w>dgr</w>Yea, agreed. One of the hardest parts is to (re)train yourself to think in those ways, however. Honestly, it’s like coming from imperative OOP to functional, but worse.</z><z id="t1608165971" t="noprompt https://clojars.org/meander/epsilon/versions/0.0.588"><y>#</y><d>2020-12-17</d><h>00:46</h><w>noprompt</w><a href="https://clojars.org/meander/epsilon/versions/0.0.588" target="_blank">https://clojars.org/meander/epsilon/versions/0.0.588</a></z><z id="t1608165988" t="noprompt [:attrs {:href &quot;/_/_/users/U09UV3WP6&quot;}] You should be able to try out quoted patterns now."><y>#</y><d>2020-12-17</d><h>00:46</h><w>noprompt</w><a>@mac</a> You should be able to try out quoted patterns now.</z><z id="t1608166047" t="noprompt (require &apos;[meander.epsilon.interpreter :as mi]) ((mi/finder &apos;[?x ?y] identity) [1 2])) ;; =&gt; {?x 1, ?y 2} "><y>#</y><d>2020-12-17</d><h>00:47</h><w>noprompt</w><pre>(require &apos;[meander.epsilon.interpreter :as mi])

((mi/finder &apos;[?x ?y] identity) [1 2]))
;; =&gt; {?x 1, ?y 2}</pre>
</z><z id="t1608166703" t="noprompt Please report any issues you encounter."><y>#</y><d>2020-12-17</d><h>00:58</h><w>noprompt</w>Please report any issues you encounter.</z><z id="t1608193614" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] $ cat /tmp/meander.clj (ns private.tmp.meander) (require &apos;[babashka.deps :as deps]) (deps/add-deps &apos;{:deps {meander/epsilon {:mvn/version &quot;0.0.588&quot;}}}) (require &apos;[meander.epsilon.interpreter :as mi]) ((mi/finder &apos;[?x ?y] identity) [1 2]) $ bb /tmp/meander.clj Downloading: meander/epsilon/0.0.588/epsilon-0.0.588.pom from clojars Downloading: meander/epsilon/0.0.588/epsilon-0.0.588.jar from clojars ----- Error -------------------------------------------------------------------- Type: java.lang.Exception Message: Could not find namespace: meander.epsilon.interpreter. Location: /tmp/meander.clj:5:1"><y>#</y><d>2020-12-17</d><h>08:26</h><w>borkdude</w><a>@noprompt</a>
<pre>$ cat /tmp/meander.clj
(ns private.tmp.meander)

(require &apos;[babashka.deps :as deps])
(deps/add-deps &apos;{:deps {meander/epsilon {:mvn/version &quot;0.0.588&quot;}}})
(require &apos;[meander.epsilon.interpreter :as mi])
((mi/finder &apos;[?x ?y] identity) [1 2])</pre>
<pre>$ bb /tmp/meander.clj
Downloading: meander/epsilon/0.0.588/epsilon-0.0.588.pom from clojars
Downloading: meander/epsilon/0.0.588/epsilon-0.0.588.jar from clojars
----- Error --------------------------------------------------------------------
Type:     java.lang.Exception
Message:  Could not find namespace: meander.epsilon.interpreter.
Location: /tmp/meander.clj:5:1</pre></z><z id="t1608193777" t="borkdude Ah, the namespace segments should be reversed: meander.interpreter.epsilon"><y>#</y><d>2020-12-17</d><h>08:29</h><w>borkdude</w>Ah, the namespace segments should be reversed: <code>meander.interpreter.epsilon</code></z><z id="t1608196303" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] on clojure and bb I&apos;m getting: {:meander.interpreter.epsilon/cata #object[meander.interpreter.epsilon$match_system_factory$fn__3238$f__3241 0x4863c8ac &quot;meander.interpreter.epsilon$match_system_factory$fn__3238$f__3241@4863c8ac&quot;], ?x 1, ?y 2}"><y>#</y><d>2020-12-17</d><h>09:11</h><w>borkdude</w><a>@noprompt</a> on clojure and bb I&apos;m getting:
<pre>{:meander.interpreter.epsilon/cata #object[meander.interpreter.epsilon$match_system_factory$fn__3238$f__3241 0x4863c8ac &quot;meander.interpreter.epsilon$match_system_factory$fn__3238$f__3241@4863c8ac&quot;], ?x 1, ?y 2}</pre></z><z id="t1608229499" t="noprompt [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] Yes. I elided that key in the other examples for demonstration purposes and probably should have added a ,,, or something to denote the presence of “other stuff”."><y>#</y><d>2020-12-17</d><h>18:24</h><w>noprompt</w><a>@borkdude</a> Yes. I elided that key in the other examples for demonstration purposes and probably should have added a <code>,,,</code> or something to denote the presence of “other stuff”.</z><z id="t1608229568" t="noprompt The cata function is put in the map so that the cata pattern can work properly."><y>#</y><d>2020-12-17</d><h>18:26</h><w>noprompt</w>The cata function is put in the map so that the <code>cata</code> pattern can work properly.</z><z id="t1608229748" t="noprompt I could have put it in meta data or something but the cost of calling with-meta in pretty much every in location where bindings are being manipulated is expensive."><y>#</y><d>2020-12-17</d><h>18:29</h><w>noprompt</w>I could have put it in meta data or something but the cost of calling <code>with-meta</code> in pretty much every in location where bindings are being manipulated is expensive.</z><z id="t1608229811" t="noprompt Another thing we can do is dissoc it, but that’s also extra work that doesn’t technically need to go down."><y>#</y><d>2020-12-17</d><h>18:30</h><w>noprompt</w>Another thing we can do is <code>dissoc</code> it, but that’s also extra work that doesn’t technically need to go down.</z><z id="t1608239040" t="Jimmy Miller I&apos;d say dissocing makes sense. It is just going to confuse people and probably not provide any value."><y>#</y><d>2020-12-17</d><h>21:04</h><r>Jimmy Miller</r>I&apos;d say dissocing makes sense. It is just going to confuse people and probably not provide any value.</z><z id="t1608250107" t="noprompt OK. I’m good with that."><y>#</y><d>2020-12-18</d><h>00:08</h><r>noprompt</r>OK. I’m good with that.</z><z id="t1608229837" t="noprompt For find style stuff, probably not a big deal, and it may not even be a big deal for search either."><y>#</y><d>2020-12-17</d><h>18:30</h><w>noprompt</w>For <code>find</code> style stuff, probably not a big deal, and it may not even be a big deal for <code>search</code> either.</z><z id="t1608230230" t="borkdude this is fine"><y>#</y><d>2020-12-17</d><h>18:37</h><w>borkdude</w>this is fine</z><z id="t1608230539" t="noprompt I’m a big push over though. If it’s annoying people, I have no problem with blasting it from space."><y>#</y><d>2020-12-17</d><h>18:42</h><w>noprompt</w>I’m a big push over though. If it’s annoying people, I have no problem with blasting it from space.</z><z id="t1608682984" t="noprompt I should probably let folks know: this week will be a bit challenging for me to hack with Christmas just around the corner. After the holiday should be easier."><y>#</y><d>2020-12-23</d><h>00:23</h><w>noprompt</w>I should probably let folks know: this week will be a bit challenging for me to hack with Christmas just around the corner. After the holiday should be easier.</z><z id="t1608759944" t="ribelo I have a question, ?z should be nil in that case? (m/find [:a {:b [:x :y]}] [?x {_ _ :as (m/cata ?z)}] ?z (m/app #(doto % prn) ?z) ?z) "><y>#</y><d>2020-12-23</d><h>21:45</h><w>ribelo</w>I have a question, <code>?z</code> should be <code>nil</code> in that case?
<pre>(m/find [:a {:b [:x :y]}]
  [?x {_ _ :as (m/cata ?z)}] ?z

  (m/app #(doto % prn) ?z) ?z)</pre>
</z><z id="t1608836723" t="Jimmy Miller I’m honestly not sure. It is consistent with the results of this (m/search {:b 2} {:as (m/cata ?z)} ?z ?z ?z) But I’m not sure if that is correct or not. Maybe n.oprompt can weigh in after the holiday."><y>#</y><d>2020-12-24</d><h>19:05</h><r>Jimmy Miller</r>I’m honestly not sure. It is consistent with the results of this

<pre>(m/search {:b 2}
  {:as (m/cata ?z)}
  ?z
  ?z ?z)</pre>
But I’m not sure if that is correct or not. Maybe n.oprompt can weigh in after the holiday.</z><z id="t1609529226" t="tothda Hi! I&apos;m trying to join two set of maps together. Basically the problem is exactly what is described in this SO question: https://stackoverflow.com/questions/63520565/a-declarative-way-of-reshaping-joining-flattening-data-in-nested-maps Is there a solution for it with meander? Thanks! I copy the relevant part here. ;; my input data (def db {:items [{:id 1 :labels [1 2 3]} {:id 2 :labels [2]} {:id 3 :labels []} {:id 4 :labels nil} {:id 5 }] :labels [{:id 1 :name &quot;one&quot;} {:id 2 :name &quot;two&quot;} {:id 3 :name &quot;three&quot;} {:id 4 :name &quot;four&quot;}]}) ;; what to do here (defn flatten-labels [d] ???) ;; so that I get this (flatten-labels db) ;; =&gt; ;; {:items ;; [{:id 1 :labels [&quot;one&quot; &quot;two&quot; &quot;three&quot;]} ;; {:id 2 :labels [&quot;two&quot;]} ;; {:id 3 :labels []} ;; {:id 4 :labels []} ;; {:id 5 :labels []}]}"><y>#</y><d>2021-01-01</d><h>19:27</h><w>tothda</w>Hi! I&apos;m trying to join two set of maps together. Basically the problem is exactly what is described in this SO question: <a href="https://stackoverflow.com/questions/63520565/a-declarative-way-of-reshaping-joining-flattening-data-in-nested-maps" target="_blank">https://stackoverflow.com/questions/63520565/a-declarative-way-of-reshaping-joining-flattening-data-in-nested-maps</a>

Is there a solution for it with meander? Thanks!

I copy the relevant part here.
<pre>;; my input data
(def db {:items  [{:id 1 :labels [1 2 3]}
                  {:id 2 :labels [2]}
                  {:id 3 :labels []}
                  {:id 4 :labels nil}
                  {:id 5 }]
         :labels [{:id 1 :name &quot;one&quot;}
                  {:id 2 :name &quot;two&quot;}
                  {:id 3 :name &quot;three&quot;}
                  {:id 4 :name &quot;four&quot;}]})

;; what to do here
(defn flatten-labels [d]
  ???)

;; so that I get this
(flatten-labels db)
;; =&gt;
;; {:items
;; [{:id 1 :labels [&quot;one&quot; &quot;two&quot; &quot;three&quot;]}
;;  {:id 2 :labels [&quot;two&quot;]}
;;  {:id 3 :labels []}
;;  {:id 4 :labels []}
;;  {:id 5 :labels []}]}</pre></z><z id="t1609605736" t="markaddleman [:attrs {:href &quot;/_/_/users/U0521UMNA&quot;}] Does this do what you want? (m/rewrite db {:items [!item ...] :labels ?labels} {:items [(m/cata {::item !item ::labels ?labels}) ...]} {::item {:id ?id :labels [!label ...]} ::labels ?labels} {:id ?id :labels [(m/cata {::lookup-label [!label ?labels]}) ...]} {::item {:id ?id :labels []}} {:id ?id :labels []} {::item {:id ?id}} {:id ?id :labels []} {::lookup-label [?label (m/scan {:id ?label :name ?name})]} ?name) "><y>#</y><d>2021-01-02</d><h>16:42</h><w>markaddleman</w><a>@tothda</a> Does this do what you want?
<pre>(m/rewrite
            db
            {:items [!item ...] :labels ?labels}
            {:items [(m/cata {::item !item ::labels ?labels}) ...]}

            {::item   {:id ?id :labels [!label ...]}
             ::labels ?labels}
            {:id ?id :labels [(m/cata {::lookup-label [!label ?labels]}) ...]}

            {::item {:id ?id :labels []}}
            {:id ?id :labels []}

            {::item {:id ?id}}
            {:id ?id :labels []}

            {::lookup-label [?label (m/scan {:id ?label :name ?name})]}
            ?name)</pre>
</z><z id="t1609629559" t="tothda [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] Yes! Thank you. I was not aware of (m/cata ...) , and now with this approach I was able to replace a lot of ad-hoc data manipulation code. Amazing!"><y>#</y><d>2021-01-02</d><h>23:19</h><w>tothda</w><a>@markaddleman</a> Yes! Thank you. I was not aware of <code>(m/cata ...)</code> , and now with this approach I was able to replace a lot of ad-hoc data manipulation code. Amazing!</z><z id="t1609702522" t="Jimmy Miller I’ll throw out another solution just in case anyone is interested. (m/rewrite db {:items [{:id !ids :labels (m/or [!labels ..!n] (m/let [!n 0]))} ..!m] :labels ?labels} {:items [{:id !ids :labels [(m/cata [!labels ?labels]) ..!n]} ..!m]} [?label (m/scan {:id ?label :name ?name})] ?name)"><y>#</y><d>2021-01-03</d><h>19:35</h><w>Jimmy Miller</w>I’ll throw out another solution just in case anyone is interested.

<pre>(m/rewrite db
  {:items [{:id !ids :labels (m/or [!labels ..!n]
                                   (m/let [!n 0]))} ..!m]
   :labels ?labels}
  {:items
   [{:id !ids :labels [(m/cata [!labels ?labels]) ..!n]} ..!m]}

  [?label (m/scan {:id ?label :name ?name})]
  ?name)</pre></z><z id="t1609710244" t="tothda Thank you!"><y>#</y><d>2021-01-03</d><h>21:44</h><r>tothda</r>Thank you!</z><z id="t1609710331" t="tothda Would be useful to post this to the original stackoverflow question too."><y>#</y><d>2021-01-03</d><h>21:45</h><r>tothda</r>Would be useful to post this to the original stackoverflow question too.</z><z id="t1609780126" t="noprompt Hey folks, I’ve been out on vacation for the past two weeks. I’ll gradually be catching up on the day to day as I get the do nothing out of my system. 🙂"><y>#</y><d>2021-01-04</d><h>17:08</h><w>noprompt</w>Hey folks, I’ve been out on vacation for the past two weeks. I’ll gradually be catching up on the day to day as I get the do nothing out of my system. <b>🙂</b></z><z id="t1609842846" t="ribelo Is it possible to do such a thing? (m/rewrite [1 2 3 4] [!xs ...] (reduce + [(m/cata !xs) ...]) (m/pred number? ?x) ?x) "><y>#</y><d>2021-01-05</d><h>10:34</h><w>ribelo</w>Is it possible to do such a thing?
<pre>(m/rewrite [1 2 3 4]
  [!xs ...]
  (reduce + [(m/cata !xs) ...])
  (m/pred number? ?x) ?x)</pre>
</z><z id="t1609864347" t="noprompt (me/rewrite [1 2 3 4] [] 0 [?x] ?x [?x ?y] (me/app + ?x ?y) [?x ?y &amp; ?more] (me/cata [(me/app + ?x ?y) &amp; ?more])) ;; =&gt; 10 "><y>#</y><d>2021-01-05</d><h>16:32</h><w>noprompt</w><pre>(me/rewrite [1 2 3 4]
  [] 0

  [?x] ?x

  [?x ?y]
  (me/app + ?x ?y)

  [?x ?y &amp; ?more]
  (me/cata [(me/app + ?x ?y) &amp; ?more]))
;; =&gt;
10</pre>
</z><z id="t1609864695" t="markaddleman another method, if you don&apos;t want to give up on reduce : (m/rewrite [1 2 3 4] [!x ...] (m/app (partial reduce +) [(m/cata !x) ...]) (m/pred number? ?x) ?x) "><y>#</y><d>2021-01-05</d><h>16:38</h><w>markaddleman</w>another method, if you don&apos;t want to give up on <code>reduce</code> :
<pre>(m/rewrite [1 2 3 4]
    [!x ...]
    (m/app (partial reduce +) [(m/cata !x) ...])

    (m/pred number? ?x) ?x)</pre>
</z><z id="t1609864797" t="markaddleman Here, we separate out things that meander is great at (manipulating each unit of data) and the things clojure is great at: reducing"><y>#</y><d>2021-01-05</d><h>16:39</h><w>markaddleman</w>Here, we separate out things that meander is great at (manipulating each unit of data) and the things clojure is great at: reducing</z><z id="t1609872808" t="Jimmy Miller One thing we are looking to add in zeta is a notion of reduction. So potentially you could write this much more directly."><y>#</y><d>2021-01-05</d><h>18:53</h><w>Jimmy Miller</w>One thing we are looking to add in zeta is a notion of reduction. So potentially you could write this much more directly.</z><z id="t1609874822" t="markaddleman Because I needed an excuse to procrastinate, I did a little benchmarking using the reduce example above as inspiration: (comment (time (reduce + (range 100000000))) &quot;Elapsed time: 575.223994 msecs&quot; (time (m/rewrite (range 100000000) (m/seqable !x ...) (m/app (partial reduce +) (m/seqable !x ...)))) &quot;Elapsed time: 4946.887344 msecs&quot; (time (m/rewrite (range 100000000) (m/seqable !x ...) (m/app (partial reduce +) (m/seqable (m/cata !x) ...)) (m/pred number? ?x) ?x)) &quot;Elapsed time: 19892.358578 msecs&quot; (time (m/rewrite (range 100000000) (m/pred number? ?x) ?x (m/seqable !x ...) (m/app (partial reduce +) (m/seqable (m/cata !x) ...)))) &quot;Elapsed time: 14362.69424 msecs&quot; ) I was a little surprised by the large improvement just from reordering the clauses between the third and fourth case"><y>#</y><d>2021-01-05</d><h>19:27</h><w>markaddleman</w>Because I needed an excuse to procrastinate, I did a little benchmarking using the reduce example above as inspiration:
<pre>(comment
  (time (reduce + (range 100000000)))
  &quot;Elapsed time: 575.223994 msecs&quot;

  (time (m/rewrite (range 100000000)
          (m/seqable !x ...)
          (m/app (partial reduce +) (m/seqable !x ...))))
  &quot;Elapsed time: 4946.887344 msecs&quot;


  (time (m/rewrite (range 100000000)
          (m/seqable !x ...)
          (m/app (partial reduce +) (m/seqable (m/cata !x) ...))

          (m/pred number? ?x) ?x))
  &quot;Elapsed time: 19892.358578 msecs&quot;


  (time (m/rewrite (range 100000000)
          (m/pred number? ?x) ?x

          (m/seqable !x ...)
          (m/app (partial reduce +) (m/seqable (m/cata !x) ...))))
  &quot;Elapsed time: 14362.69424 msecs&quot;
  )</pre>
I was a little surprised by the large improvement just from reordering the clauses between the third and fourth case</z><z id="t1609874845" t="markaddleman Having said and done this, I want to point out that I don&apos;t care much about the runtime performance of meander since the programmer performance improvement is massive"><y>#</y><d>2021-01-05</d><h>19:27</h><w>markaddleman</w>Having said and done this, I want to point out that I don&apos;t care much about the runtime performance of meander since the programmer performance improvement is massive</z><z id="t1609874919" t="markaddleman One more example that is nice to see: (time (m/rewrite (range 100000000) ?xs (m/app (partial reduce +) ?xs))) &quot;Elapsed time: 591.632803 msecs&quot; "><y>#</y><d>2021-01-05</d><h>19:28</h><w>markaddleman</w>One more example that is nice to see:
<pre>(time (m/rewrite (range 100000000)
          ?xs
          (m/app (partial reduce +) ?xs)))
  &quot;Elapsed time: 591.632803 msecs&quot;</pre>
</z><z id="t1609877273" t="ribelo Reduce was just an example. I wanted to ask if it is possible to use cata inside a clojure function; )"><y>#</y><d>2021-01-05</d><h>20:07</h><w>ribelo</w>Reduce was just an example. I wanted to ask if it is possible to use <code>cata</code> inside a clojure function; )</z><z id="t1609884346" t="noprompt One thing this reminded me of is that Meander should use loop /`recur` when possible. I just tried (?x ?y &amp; ?rest) (m/cata ((m/app + ?x ?y) &amp; ?rest)) on the above and ran out of memory."><y>#</y><d>2021-01-05</d><h>22:05</h><w>noprompt</w>One thing this reminded me of is that Meander should use <code>loop</code>/`recur` when possible. I just tried
<pre>(?x ?y &amp; ?rest)
(m/cata ((m/app + ?x ?y) &amp; ?rest))</pre>
on the above and ran out of memory.</z><z id="t1609937725" t="ribelo As part of the fun, I&apos;m trying to write something similar to pull-syntax with a meander Let&apos;s say I have db in this form. {:ivan {:db/id :ivan, :name &quot;Ivan&quot; :last-name &quot;Ivanov&quot; :friend :petr} :petr {:db/id :petr, :name &quot;Petr&quot; :last-name &quot;Petrov&quot; :friend :smith} ... ?id {:db/id ?id ?k ?v}} (pull db [:name {:friend [:name]}] :ivan) could be presented in this way (m/find db {?id {:name ?name :friend ?friend} ?friend {:name ?friend-name}} {:name ?name :friend {:name ?friend-name}}) But how to make a function that would translate pull-syntax to a meander&apos;s query? For now I have something like that, but I can&apos;t do it any simpler and more elegant. (def eid? (some-fn string? keyword? int?)) (defn pull [db selector entity] (m/match selector {:as ?q} (reduce-kv (fn [acc k v] (m/match v (m/pred vector?) (assoc acc k (pull db v (get entity k))))) {} ?q) [!ks ...] (reduce (fn [acc elem] (m/match elem (m/pred eid?) (assoc acc elem (get-in db [entity elem])) {} (let [entity&apos; (get-in db [entity])] (merge acc (pull db elem entity&apos;))))) {} !ks)))"><y>#</y><d>2021-01-06</d><h>12:55</h><w>ribelo</w>As part of the fun, I&apos;m trying to write something similar to <code>pull-syntax</code> with a meander

Let&apos;s say I have <code>db</code> in this form.

<pre>{:ivan {:db/id :ivan, :name &quot;Ivan&quot; :last-name &quot;Ivanov&quot; :friend :petr}
 :petr {:db/id :petr, :name &quot;Petr&quot; :last-name &quot;Petrov&quot; :friend :smith}
 ...
 ?id   {:db/id ?id
        ?k     ?v}}</pre>
<pre>(pull db [:name {:friend [:name]}] :ivan)</pre>
could be presented in this way

<pre>(m/find db
  {?id     {:name   ?name
            :friend ?friend}
   ?friend {:name ?friend-name}}
  {:name   ?name
   :friend {:name ?friend-name}})</pre>
But how to make a function that would translate <code>pull-syntax</code> to a meander&apos;s query?

For now I have something like that, but I can&apos;t do it any simpler and more elegant.

<pre>(def eid? (some-fn string? keyword? int?))

(defn pull [db selector entity]
  (m/match selector
    {:as ?q}
    (reduce-kv
     (fn [acc k v]
       (m/match v
         (m/pred vector?)
         (assoc acc k (pull db v (get entity k)))))
     {}
     ?q)
    [!ks ...]
    (reduce
     (fn [acc elem]
       (m/match elem
         (m/pred eid?)
         (assoc acc elem (get-in db [entity elem]))
         {}
         (let [entity&apos; (get-in db [entity])]
           (merge acc (pull db elem entity&apos;)))))
     {}
     !ks)))</pre></z><z id="t1610043273" t="noprompt You might be able to rewrite the pull query as a quoted pattern and then build an interpreter with it."><y>#</y><d>2021-01-07</d><h>18:14</h><w>noprompt</w>You might be able to rewrite the pull query as a quoted pattern and then build an interpreter with it.</z><z id="t1610043347" t="noprompt Using the meander.interpreter.epsilon namespace. I can sort of imagine how to do it but I’m a bit in the weeds with some other things."><y>#</y><d>2021-01-07</d><h>18:15</h><w>noprompt</w>Using the <code>meander.interpreter.epsilon</code> namespace. I can sort of imagine how to do it but I’m a bit in the weeds with some other things.</z><z id="t1610045101" t="noprompt On a separate topic, I’m interested in potentially slightly tweaking m/app in zeta (which I’m now making progress on based off existing work and the interpreter). (m/apply fn-pattern args-pattern ret-pattern) ;; Query semantics ;; --------------- ;; ;; Target is applied to a function yielded by `fn-pattern` and ;; `args-pattern` without modifying bindings. The return value is ;; queried against `ret-pattern`. ;; ;; Example ;; ------- ;; ;; (m/find 1 (m/apply ~clojure.core/+ [2 3] 6) true) ;; ;; =&gt; true ;; ;; Yield semantics ;; --------------- ;; ;; Yields the result of applying a funtion yielded by `fn-pattern` to ;; arguments yielded by `args-pattern` if the result successfully ;; queries against `ret-pattern`. ;; ;; Example ;; ------- ;; ;; (m/generate (m/apply ~clojure.core/+ [2 3] _)) ;; ;; =&gt; 5 "><y>#</y><d>2021-01-07</d><h>18:45</h><w>noprompt</w>On a separate topic, I’m interested in potentially slightly tweaking <code>m/app</code> in <code>zeta</code> (which I’m now making progress on based off existing work and the interpreter).
<pre>(m/apply fn-pattern args-pattern ret-pattern)
;; Query semantics
;; ---------------
;;
;; Target is applied to a function yielded by `fn-pattern` and
;; `args-pattern` without modifying bindings. The return value is
;; queried against `ret-pattern`.
;;
;; Example
;; -------
;;
;; (m/find 1 (m/apply ~clojure.core/+ [2 3] 6) true)
;; ;; =&gt; true
;;
;; Yield semantics
;; ---------------
;;
;; Yields the result of applying a funtion yielded by `fn-pattern` to
;; arguments yielded by `args-pattern` if the result successfully
;; queries against `ret-pattern`.
;;
;; Example
;; -------
;;
;; (m/generate (m/apply ~clojure.core/+ [2 3] _))
;; ;; =&gt; 5</pre>
</z><z id="t1610045207" t="noprompt Part of the reason I’m moving in the direction of using ~ like this is make it explicit where Clojure interop happens."><y>#</y><d>2021-01-07</d><h>18:46</h><w>noprompt</w>Part of the reason I’m moving in the direction of using <code>~</code> like this is make it explicit where Clojure interop happens.</z><z id="t1610045499" t="noprompt This has some similar motivations as project to do things a bit more safely than ~ is hackishly used for today. (m/find [2 3 5] [?x ?y (m/apply ~clojure.core/+ [?x ?y] _)] true) Instead of (m/find [2 3 5] [?x ?y ~(+ ?x ?y)] true) "><y>#</y><d>2021-01-07</d><h>18:51</h><w>noprompt</w>This has some similar motivations as <code>project</code> to do things a bit more safely than <code>~</code> is hackishly used for today.
<pre>(m/find [2 3 5]
  [?x ?y (m/apply ~clojure.core/+ [?x ?y] _)]
  true)</pre>
Instead of
<pre>(m/find [2 3 5]
  [?x ?y ~(+ ?x ?y)]
  true)</pre>
</z><z id="t1610046507" t="markaddleman fwiw, I like the general approach"><y>#</y><d>2021-01-07</d><h>19:08</h><w>markaddleman</w>fwiw, I like the general approach</z><z id="t1610047469" t="markaddleman does this mean that fns with multiple args will always get invoked through clojure.core/apply ?"><y>#</y><d>2021-01-07</d><h>19:24</h><w>markaddleman</w>does this mean that fns with multiple args will always get invoked through clojure.core/apply ?</z><z id="t1610054701" t="noprompt For m/apply this would be the semantic. Separately, I was thinking we could have (m/invoke fn-pattern arg-pattern* ret-pattern) for the case where you don’t want to use clojure.core/apply ."><y>#</y><d>2021-01-07</d><h>21:25</h><w>noprompt</w>For <code>m/apply</code> this would be the semantic. Separately, I was thinking we could have
<pre>(m/invoke fn-pattern arg-pattern* ret-pattern)</pre>
for the case where you don’t want to use <code>clojure.core/apply</code>.</z><z id="t1610054725" t="noprompt But, I’m still thinking about the semantics of these things."><y>#</y><d>2021-01-07</d><h>21:25</h><w>noprompt</w>But, I’m still thinking about the semantics of these things.</z><z id="t1610054778" t="noprompt My thoughts about using ~ are really the most important ones."><y>#</y><d>2021-01-07</d><h>21:26</h><w>noprompt</w>My thoughts about using <code>~</code> are really the most important ones.</z><z id="t1610054782" t="noprompt (To me.)"><y>#</y><d>2021-01-07</d><h>21:26</h><w>noprompt</w>(To me.)</z><z id="t1610054838" t="noprompt (m/invoke ~(partial apply some-fn) ?x) could be just fine."><y>#</y><d>2021-01-07</d><h>21:27</h><w>noprompt</w><code>(m/invoke ~(partial apply some-fn) ?x)</code> could be just fine.</z><z id="t1610054886" t="noprompt I was noticing that I’m not really happy with (m/app (partial apply +) [!xs ...]) on the right."><y>#</y><d>2021-01-07</d><h>21:28</h><w>noprompt</w>I was noticing that I’m not really happy with
<pre>(m/app (partial apply +) [!xs ...])</pre>
on the right.</z><z id="t1610066756" t="markaddleman I agree with using ~ to denote escaping to clojure land. fwiw, I use the pattern (m/app (partial f &lt;something&gt;) ?x ?y) quite often"><y>#</y><d>2021-01-08</d><h>00:45</h><w>markaddleman</w>I agree with using ~ to denote escaping to clojure land.  fwiw, I use the pattern <code>(m/app (partial f &lt;something&gt;) ?x ?y)</code> quite often</z><z id="t1610281499" t="mac Are there any examples of how to use finder , searcher and rewriter ? I looked at the tests but I wasn&apos;t able to glean much from that. I am looking for a way to pass a data structure, and two patterns (input and rewrite) to a function and have them applied to the data structure. I believe this should be possible now, right?"><y>#</y><d>2021-01-10</d><h>12:24</h><w>mac</w>Are there any examples of how to use <code>finder</code> , <code>searcher</code> and <code>rewriter</code> ? I looked at the tests but I wasn&apos;t able to glean much from that. I am looking for a way to pass a data structure, and two patterns (input and rewrite) to a function and have them applied to the data structure. I believe this should be possible now, right?</z><z id="t1610301549" t="ribelo [:attrs {:href &quot;/_/_/users/U09UV3WP6&quot;}] (let [q {:x &apos;?x} f (mi/finder q &apos;?x)] (f {:x 1})) ;; =&gt; 1"><y>#</y><d>2021-01-10</d><h>17:59</h><w>ribelo</w><a>@mac</a>
<pre>(let [q {:x &apos;?x}
      f (mi/finder
         q &apos;?x)]
  (f {:x 1}))
;; =&gt; 1</pre></z><z id="t1610308460" t="mac [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] Cool, that looks straightforward."><y>#</y><d>2021-01-10</d><h>19:54</h><w>mac</w><a>@huxley</a> Cool, that looks straightforward.</z><z id="t1610365842" t="mac Why would the below fail with Execution error (IllegalArgumentException) at meander.interpreter.epsilon/match-clause-factory$fn$fn$fn (epsilon.cljc:490). Key must be integer : (let [q [&apos;?y &apos;?x] f (mi/searcher q [&apos;?x])] (f [:x 1]))"><y>#</y><d>2021-01-11</d><h>11:50</h><w>mac</w>Why would the below fail with <code>Execution error (IllegalArgumentException) at meander.interpreter.epsilon/match-clause-factory$fn$fn$fn (epsilon.cljc:490). Key must be integer</code> :

<pre>(let [q [&apos;?y &apos;?x]
      f (mi/searcher
         q [&apos;?x])]
  (f [:x 1]))</pre></z><z id="t1610382709" t="ribelo [:attrs {:href &quot;/_/_/users/U09UV3WP6&quot;}] (defn project &quot;Helper which extracts the values of vars (keys) out a map in the order they are given. Example: (let [f (mi/finder &apos;[?x ?y] (project &apos;[?y ?x ?y]))] (f [1 2])) ;; =&gt; [2 1 2]&quot; [vars] (fn [bindings] (mapv bindings vars))) (let [q &apos;[?y ?x] f (mi/searcher q (project [&apos;?x]))] (f [:x 1])) ;; =&gt; [1]"><y>#</y><d>2021-01-11</d><h>16:31</h><w>ribelo</w><a>@mac</a>
<pre>(defn project
  &quot;Helper which extracts the values of vars (keys) out a map in the
  order they are given.
  Example:
    (let [f (mi/finder &apos;[?x ?y] (project &apos;[?y ?x ?y]))]
      (f [1 2]))
    ;; =&gt; [2 1 2]&quot;
  [vars]
  (fn [bindings] (mapv bindings vars)))

(let [q &apos;[?y ?x]
      f (mi/searcher
         q (project [&apos;?x]))]
  (f [:x 1]))
;; =&gt; [1]</pre></z><z id="t1610383077" t="ribelo (defn debug [vars] (fn [bindings] {:vars vars :bindings bindings})) (let [q &apos;[?y ?x] f (mi/finder q (debug &apos;?x))] (f [:x 1])) ;; =&gt; ;; {:vars ?x, ;; :bindings {:meander.interpreter.epsilon/cata #function ;; [meander.interpreter.epsilon/match-system-factory/fn--23289/f--23292] , ;; ?y :x, ;; ?x 1}} "><y>#</y><d>2021-01-11</d><h>16:37</h><w>ribelo</w><pre>(defn debug
  [vars]
  (fn [bindings]
    {:vars vars
     :bindings bindings}))

(let [q &apos;[?y ?x]
      f (mi/finder
         q (debug &apos;?x))]
  (f [:x 1]))
;; =&gt;
;; {:vars ?x,
;;  :bindings {:meander.interpreter.epsilon/cata #function
;;             [meander.interpreter.epsilon/match-system-factory/fn--23289/f--23292] ,
;;             ?y :x,
;;             ?x 1}}</pre>
</z><z id="t1610383957" t="ribelo I suspect that if the data being thrown into the function returned by the intrepreter is a vector, it unfolds to something similar (let [date [:x 1]) l [&apos;?y &apos;?x] r &apos;?x] (let [idx (.indexOf l r)] (.get data idx)))"><y>#</y><d>2021-01-11</d><h>16:52</h><w>ribelo</w>I suspect that if the data being thrown into the function returned by the intrepreter is a vector, it unfolds to something similar

<pre>(let [date [:x 1])
      l [&apos;?y &apos;?x]
      r &apos;?x]
  (let [idx (.indexOf l r)]
    (.get data idx)))</pre></z><z id="t1610384163" t="ribelo I guess this is a bug, because if idx is nil , the rest of the function should not be continued."><y>#</y><d>2021-01-11</d><h>16:56</h><w>ribelo</w>I guess this is a bug, because if idx is <code>nil</code>, the rest of the function should not be continued.</z><z id="t1610384244" t="ribelo If you want to do something a bit more complicated then you should create a function that takes a query and that returns a function that takes a hasmap with the bindings."><y>#</y><d>2021-01-11</d><h>16:57</h><w>ribelo</w>If you want to do something a bit more complicated then you should create a function that takes a query and that returns a function that takes a hasmap with the bindings.</z><z id="t1610384867" t="ribelo (let [q &apos;[?y ?x] f (mi/finder q {:a &apos;?x})] (f [:x 1])) ;; =&gt; nil (let [q &apos;[?y ?x] f (mi/finder q ((fn [x] (fn [bindings] {:a (get bindings x)})) &apos;?x))] (f [:x 1])) ;; =&gt; {:a 1} "><y>#</y><d>2021-01-11</d><h>17:07</h><w>ribelo</w><pre>(let [q &apos;[?y ?x]
      f (mi/finder
         q {:a &apos;?x})]
  (f [:x 1]))
;; =&gt; nil

(let [q &apos;[?y ?x]
      f (mi/finder
         q ((fn [x] (fn [bindings] {:a (get bindings x)})) &apos;?x))]
  (f [:x 1]))
;; =&gt; {:a 1}</pre>
</z><z id="t1610384943" t="ribelo Although IMHO does not make sense, it is better to build the collection that we need after obtaining the value"><y>#</y><d>2021-01-11</d><h>17:09</h><w>ribelo</w>Although IMHO does not make sense, it is better to build the collection that we need after obtaining the value</z><z id="t1610384981" t="ribelo (let [q &apos;[?y ?x] f (mi/finder q &apos;?x)] {:a (f [:x 1])}) "><y>#</y><d>2021-01-11</d><h>17:09</h><w>ribelo</w><pre>(let [q &apos;[?y ?x]
      f (mi/finder
         q &apos;?x)]
  {:a (f [:x 1])})</pre>
</z><z id="t1610385361" t="Jimmy Miller Will take a look at this later today is someone else doesn&apos;t get to it first."><y>#</y><d>2021-01-11</d><h>17:16</h><w>Jimmy Miller</w>Will take a look at this later today is someone else doesn&apos;t get to it first.</z><z id="t1610387458" t="noprompt Yeah, the interpreter stuff likely has rough edges. Please also report these on Github too if you don’t mind. 🙂"><y>#</y><d>2021-01-11</d><h>17:50</h><w>noprompt</w>Yeah, the interpreter stuff likely has rough edges. Please also report these on Github too if you don’t mind. <b>🙂</b></z><z id="t1610478727" t="mac [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] Thanks, guys."><y>#</y><d>2021-01-12</d><h>19:12</h><w>mac</w><a>@noprompt</a> <a>@jimmy</a> Thanks, guys.</z><z id="t1610509675" t="chucklehead would appreciate any suggestions on simplifying or otherwise improving this rewrite, first time really trying to do anything with cata and memory variables: https://github.com/casselc/dmarc/blob/4ce96be48367381d8983b2082174213ebf848725/src/casselc/dmarc.clj#L30"><y>#</y><d>2021-01-13</d><h>03:47</h><w>chucklehead</w>would appreciate any suggestions on simplifying or otherwise improving this rewrite, first time really trying to do anything with <code>cata</code> and memory variables: <a href="https://github.com/casselc/dmarc/blob/4ce96be48367381d8983b2082174213ebf848725/src/casselc/dmarc.clj#L30" target="_blank">https://github.com/casselc/dmarc/blob/4ce96be48367381d8983b2082174213ebf848725/src/casselc/dmarc.clj#L30</a></z><z id="t1610513952" t="Jimmy Miller Overall things look pretty good. Are there any things you are running into trouble with? A couple things I’d change from my quick glance. 1. Instead of (m/app merge map1 (m/cata !record)) you can do {:my-keys :my-vals &amp; (m/cata !record)} 2. Sprinkle in some (m/some) . Meander doesn’t actually check that keys exist in maps by default. (m/rewrite {:a 2} {:record _ :as !record} [!record ...]) ;; =&gt; [{:a 2}] (m/rewrite {:a 2} {:record (m/some) :as !record} [!record ...]) ;; =&gt; nil If there is anything that isn’t working how you expect, definitely let us know and we can help."><y>#</y><d>2021-01-13</d><h>04:59</h><r>Jimmy Miller</r>Overall things look pretty good. Are there any things you are running into trouble  with?

A couple things I’d change from my quick glance.

1. Instead of <code>(m/app merge map1 (m/cata !record))</code> you can do <code>{:my-keys :my-vals &amp; (m/cata !record)}</code>

2. Sprinkle in some <code>(m/some)</code>. Meander doesn’t actually check that keys exist in maps by default.

<pre>(m/rewrite {:a 2}
  {:record _ :as !record}
  [!record ...])

;; =&gt; [{:a 2}]

(m/rewrite {:a 2}
  {:record (m/some) :as !record}
  [!record ...])
;; =&gt;  nil</pre>
If there is anything that isn’t working how you expect, definitely let us know and we can help.</z><z id="t1610515303" t="chucklehead thanks, the merge was making my eye twitch a little:slightly_smiling_face: - as best I can tell it&apos;s working correctly at the moment, although it took longer than I care to admit to get to this point. I mostly wanted to make sure I wasn&apos;t overly complicating anything or doing something boneheaded (like you pointed out with some )"><y>#</y><d>2021-01-13</d><h>05:21</h><r>chucklehead</r>thanks, the <code>merge</code> was making my eye twitch a little:slightly_smiling_face: - as best I can tell it&apos;s working correctly at the moment, although it took longer than I care to admit to get to this point. I mostly wanted to make sure I wasn&apos;t overly complicating anything or doing something boneheaded (like you pointed out with <code>some</code> )</z><z id="t1610518390" t="chucklehead I think missing m/some may have been why I couldn&apos;t get the {:spf} pattern variants to work as memory variables instead of using cata when I tried previously."><y>#</y><d>2021-01-13</d><h>06:13</h><r>chucklehead</r>I think missing <code>m/some</code>  may have been why I couldn&apos;t get the <code>{:spf}</code>pattern variants to work as memory variables instead of using <code>cata</code> when I tried previously.</z><z id="t1610518590" t="chucklehead Also adding some uncovered an issue where some providers are sending fields in a different order than the schema specifies and I was just silently ignoring some of the data, so thanks again."><y>#</y><d>2021-01-13</d><h>06:16</h><r>chucklehead</r>Also adding <code>some</code> uncovered an issue where some providers are sending fields in a different order than the schema specifies and I was just silently ignoring some of the data, so thanks again.</z><z id="t1611103549" t="dgr Am I going insane or is this not acting right. (Sorry for the large splat of code with probably horrible indentation.) xyz.core&gt; x {:class :org.commonmark.node.Document, :children ({:class :org.commonmark.ext.front.matter.YamlFrontMatterBlock, :children ({:children (), :key &quot;Title&quot;, :values [&quot;Meta title&quot;], :class :org.commonmark.ext.front.matter.YamlFrontMatterNode})})} xyz.core&gt; (meander/find x {:class :org.commonmark.node.Document :children (_ ... {:class :org.commonmark.ext.front.matter.YamlFrontMatterBlock :children (_ ... . {:class :org.commonmark.ext.front.matter.YamlFrontMatterNode :key &quot;Title&quot; :values [!title ...] } . _ ...)} . _ ...)} [:html [:head [:title !title]]]) nil xyz.core&gt; (meander/find x {:class :org.commonmark.node.Document :children (_ ... {:class :org.commonmark.ext.front.matter.YamlFrontMatterBlock :children (_ ... . {:class :org.commonmark.ext.front.matter.YamlFrontMatterNode :key &quot;Title&quot; :values !title } . _ ...)} . _ ...)} [:html [:head [:title !title]]]) [:html [:head [:title [[&quot;Meta title&quot;]]]]]"><y>#</y><d>2021-01-20</d><h>00:45</h><w>dgr</w>Am I going insane or is this not acting right. (Sorry for the large splat of code with probably horrible indentation.)
<code>xyz.core&gt; x</code>
<code>{:class :org.commonmark.node.Document,</code>
 <code>:children</code>
 <code>({:class :org.commonmark.ext.front.matter.YamlFrontMatterBlock,</code>
   <code>:children</code>
   <code>({:children (),</code>
     <code>:key &quot;Title&quot;,</code>
     <code>:values [&quot;Meta title&quot;],</code>
     <code>:class :org.commonmark.ext.front.matter.YamlFrontMatterNode})})}</code>
<code>xyz.core&gt; (meander/find x</code>
                      <code>{:class :org.commonmark.node.Document</code>
                       <code>:children (_ ... {:class :org.commonmark.ext.front.matter.YamlFrontMatterBlock</code>
                                         <code>:children (_ ... . {:class :org.commonmark.ext.front.matter.YamlFrontMatterNode</code>
                                                             <code>:key &quot;Title&quot;</code>
                                                             <code>:values [!title ...]</code>
                                                             <code>} . _ ...)} . _ ...)}</code>
                      <code>[:html [:head [:title !title]]])</code>
<code>nil</code>
<code>xyz.core&gt; (meander/find x</code>
                      <code>{:class :org.commonmark.node.Document</code>
                       <code>:children (_ ... {:class :org.commonmark.ext.front.matter.YamlFrontMatterBlock</code>
                                         <code>:children (_ ... . {:class :org.commonmark.ext.front.matter.YamlFrontMatterNode</code>
                                                             <code>:key &quot;Title&quot;</code>
                                                             <code>:values !title</code>
                                                             <code>} . _ ...)} . _ ...)}</code>
                      <code>[:html [:head [:title !title]]])</code>
<code>[:html [:head [:title [[&quot;Meta title&quot;]]]]]</code></z><z id="t1611103634" t="dgr Look at the :values piece of the pattern. For some reason, [!title …] doesn’t match a vector of strings and pick up each string, but !title does match the whole vector. Is that right? What am I missing?"><y>#</y><d>2021-01-20</d><h>00:47</h><w>dgr</w>Look at the <code>:values</code> piece of the pattern. For some reason, <code>[!title …]</code> doesn’t match a vector of strings and pick up each string, but <code>!title</code> does match the whole vector. Is that right? What am I missing?</z><z id="t1611103793" t="dgr But this works as expected in the small: xyz.core&gt; (meander/find {:values [&quot;Meta title&quot;]} {:values [!title ...]} !title) [&quot;Meta title&quot;]"><y>#</y><d>2021-01-20</d><h>00:49</h><w>dgr</w>But this works as expected in the small:
<code>xyz.core&gt; (meander/find {:values [&quot;Meta title&quot;]}</code>
                                 <code>{:values [!title ...]} !title)</code>
<code>[&quot;Meta title&quot;]</code></z><z id="t1611103898" t="dgr Literally, the only difference between the first two cases, above, is the :values [!title …] vs. :values !title ."><y>#</y><d>2021-01-20</d><h>00:51</h><w>dgr</w>Literally, the only difference between the first two cases, above, is the <code>:values [!title …]</code> vs. <code>:values !title</code>.</z><z id="t1611106103" t="noprompt Taking a look"><y>#</y><d>2021-01-20</d><h>01:28</h><w>noprompt</w>Taking a look</z><z id="t1611106570" t="noprompt Hmm… I’m curious that you get nil because when I tried this at the REPL I get (let [x &apos;{:class :org.commonmark.node.Document, :children ({:class :org.commonmark.ext.front.matter.YamlFrontMatterBlock, :children ({:children (), :key &quot;Title&quot;, :values [&quot;Meta title&quot;], :class :org.commonmark.ext.front.matter.YamlFrontMatterNode})})}] (me/find x {:class :org.commonmark.node.Document :children (_ ... {:class :org.commonmark.ext.front.matter.YamlFrontMatterBlock :children (_ ... . {:class :org.commonmark.ext.front.matter.YamlFrontMatterNode :key &quot;Title&quot; :values [!title ...]} . _ ...)} . _ ...)} [:html [:head [:title !title]]])) ;; =&gt; [:html [:head [:title [&quot;Meta title&quot;]]]] "><y>#</y><d>2021-01-20</d><h>01:36</h><w>noprompt</w>Hmm… I’m curious that you get <code>nil</code> because when I tried this at the REPL  I get
<pre>(let [x &apos;{:class :org.commonmark.node.Document,
          :children
          ({:class :org.commonmark.ext.front.matter.YamlFrontMatterBlock,
            :children
            ({:children (),
              :key &quot;Title&quot;,
              :values [&quot;Meta title&quot;],
              :class :org.commonmark.ext.front.matter.YamlFrontMatterNode})})}]
  (me/find x
    {:class :org.commonmark.node.Document
     :children (_ ... {:class :org.commonmark.ext.front.matter.YamlFrontMatterBlock
                       :children (_ ... . {:class :org.commonmark.ext.front.matter.YamlFrontMatterNode
                                           :key &quot;Title&quot;
                                           :values [!title ...]}
                                    . _ ...)}
                  . _ ...)}
    [:html [:head [:title !title]]]))
;; =&gt;
[:html [:head [:title [&quot;Meta title&quot;]]]]</pre>
</z><z id="t1611106627" t="dgr Yea, I don’t get it either."><y>#</y><d>2021-01-20</d><h>01:37</h><w>dgr</w>Yea, I don’t get it either.</z><z id="t1611106703" t="Jimmy Miller Is it actually a vector? Or some other type?"><y>#</y><d>2021-01-20</d><h>01:38</h><w>Jimmy Miller</w>Is it actually a vector? Or some other type?</z><z id="t1611106706" t="noprompt So something that could also be going on here is the the value at :values is not a vector?"><y>#</y><d>2021-01-20</d><h>01:38</h><w>noprompt</w>So something that could also be going on here is the the value at <code>:values</code> is not a vector?</z><z id="t1611106710" t="noprompt Hahah"><y>#</y><d>2021-01-20</d><h>01:38</h><w>noprompt</w>Hahah</z><z id="t1611106711" t="dgr OK, that works as expected in my REPL, too. I just cut/pasted your text"><y>#</y><d>2021-01-20</d><h>01:38</h><w>dgr</w>OK, that works as expected in my REPL, too. I just cut/pasted your text</z><z id="t1611106783" t="noprompt (I’m laughing because Jimmy and I have the tendency to simulreply with pretty much the same answers/suspicions.)"><y>#</y><d>2021-01-20</d><h>01:39</h><w>noprompt</w>(I’m laughing because Jimmy and I have the tendency to simulreply with pretty much the same answers/suspicions.)</z><z id="t1611106799" t="noprompt I’m gonna let him type. 🙂"><y>#</y><d>2021-01-20</d><h>01:39</h><w>noprompt</w>I’m gonna let him type. <b>🙂</b></z><z id="t1611106810" t="Jimmy Miller Maybe put in an (m/app type !titles) and see."><y>#</y><d>2021-01-20</d><h>01:40</h><w>Jimmy Miller</w>Maybe put in an <code>(m/app type !titles)</code> and see.</z><z id="t1611106810" t="dgr Ah. Nope, it’s a java.util.ArrayList"><y>#</y><d>2021-01-20</d><h>01:40</h><w>dgr</w>Ah. Nope, it’s a java.util.ArrayList</z><z id="t1611106821" t="dgr But it prints as a vector. Grrrrr…"><y>#</y><d>2021-01-20</d><h>01:40</h><w>dgr</w>But it prints as a vector. Grrrrr…</z><z id="t1611106827" t="noprompt You could use m/seqable there."><y>#</y><d>2021-01-20</d><h>01:40</h><w>noprompt</w>You could use <code>m/seqable</code> there.</z><z id="t1611106835" t="noprompt Yeah. It is very annoying the printer does that."><y>#</y><d>2021-01-20</d><h>01:40</h><w>noprompt</w>Yeah. It is very annoying the printer does that.</z><z id="t1611106842" t="dgr OK, so this is a key thing for the documentation."><y>#</y><d>2021-01-20</d><h>01:40</h><w>dgr</w>OK, so this is a key thing for the documentation.</z><z id="t1611106856" t="dgr You still need to get back to me about m/seqable and whether we’re documenting it or not. 🙂"><y>#</y><d>2021-01-20</d><h>01:40</h><w>dgr</w>You still need to get back to me about <code>m/seqable</code> and whether we’re documenting it or not. <b>🙂</b></z><z id="t1611106895" t="noprompt Ah, yeah, sorry I’ve been just busy. Maybe just hit me/the channel with question about it daily or something?"><y>#</y><d>2021-01-20</d><h>01:41</h><w>noprompt</w>Ah, yeah, sorry I’ve been just busy. Maybe just hit me/the channel with question about it daily or something?</z><z id="t1611106903" t="noprompt But yes, m/seqable should have a docstring."><y>#</y><d>2021-01-20</d><h>01:41</h><w>noprompt</w>But yes, <code>m/seqable</code> should have a docstring.</z><z id="t1611106918" t="dgr What does it do?"><y>#</y><d>2021-01-20</d><h>01:41</h><w>dgr</w>What does it do?</z><z id="t1611106940" t="noprompt Or be documented. Essentially it matches the any seqable? thing with the remaining arguments being the same as those you would stick between [] or () ."><y>#</y><d>2021-01-20</d><h>01:42</h><w>noprompt</w>Or be documented. Essentially it matches the any <code>seqable?</code> thing with the remaining arguments being the same as those you would stick between <code>[]</code> or <code>()</code>.</z><z id="t1611106984" t="noprompt Example (m/or [1 2 3 . !x !y ...] (1 2 3 . !x !y ...)) ;; (m/seqable 1 2 3 . !x !y ...) "><y>#</y><d>2021-01-20</d><h>01:43</h><w>noprompt</w>Example
<pre>(m/or [1 2 3 . !x !y ...] (1 2 3 . !x !y ...))
;;
(m/seqable 1 2 3 . !x !y ...)</pre>
</z><z id="t1611107001" t="dgr Both. It needs a docstring for docs at the REPL. But also it needs more expansive coverage in the manual."><y>#</y><d>2021-01-20</d><h>01:43</h><w>dgr</w>Both. It needs a docstring for docs at the REPL. But also it needs more expansive coverage in the manual.</z><z id="t1611107025" t="dgr OK, gotcha."><y>#</y><d>2021-01-20</d><h>01:43</h><w>dgr</w>OK, gotcha.</z><z id="t1611107067" t="noprompt Cool. Just turn my gibberish into something that makes sense to the general population. 😛"><y>#</y><d>2021-01-20</d><h>01:44</h><w>noprompt</w>Cool. Just turn my gibberish into something that makes sense to the general population. <b>😛</b></z><z id="t1611107115" t="dgr Ha!"><y>#</y><d>2021-01-20</d><h>01:45</h><w>dgr</w>Ha!</z><z id="t1611107138" t="dgr Alright, I get it."><y>#</y><d>2021-01-20</d><h>01:45</h><w>dgr</w>Alright, I get it.</z><z id="t1611107146" t="dgr This is actually good, exploring some of the corner cases."><y>#</y><d>2021-01-20</d><h>01:45</h><w>dgr</w>This is actually good, exploring some of the corner cases.</z><z id="t1611107169" t="dgr I just used m/seqable and it worked great."><y>#</y><d>2021-01-20</d><h>01:46</h><w>dgr</w>I just used <code>m/seqable</code> and it worked great.</z><z id="t1611107233" t="dgr I’ve had a similar issue before, using [] in the pattern when I was matching a seq/list, and didn’t realize. It’s definitely one of those fine points."><y>#</y><d>2021-01-20</d><h>01:47</h><w>dgr</w>I’ve had a similar issue before, using <code>[]</code> in the pattern when I was matching a seq/list, and didn’t realize. It’s definitely one of those fine points.</z><z id="t1611107278" t="noprompt It’s the big difference in philosophy from, say, core.match ."><y>#</y><d>2021-01-20</d><h>01:47</h><w>noprompt</w>It’s the big difference in philosophy from, say, <code>core.match</code>.</z><z id="t1611107306" t="noprompt I never liked [x y z :seq] or whatever the grossness was."><y>#</y><d>2021-01-20</d><h>01:48</h><w>noprompt</w>I never liked <code>[x y z :seq]</code> or whatever the grossness was.</z><z id="t1611107351" t="dgr Yea, I’m OK with how it works in Meander. Just need to get it documented so that it doesn’t trip up others."><y>#</y><d>2021-01-20</d><h>01:49</h><w>dgr</w>Yea, I’m OK with how it works in Meander. Just need to get it documented so that it doesn’t trip up others.</z><z id="t1611107375" t="dgr I was pulling my hair out for about 45 minutes before I posted here."><y>#</y><d>2021-01-20</d><h>01:49</h><w>dgr</w>I was pulling my hair out for about 45 minutes before I posted here.</z><z id="t1611107382" t="noprompt I do think we’ve been up front about that in particular. That () means seq? [] means vector? etc."><y>#</y><d>2021-01-20</d><h>01:49</h><w>noprompt</w>I do think we’ve been up front about that in particular. That <code>()</code> means <code>seq?</code> <code>[]</code> means <code>vector?</code> etc.</z><z id="t1611107403" t="noprompt Ah, bummer! 😞"><y>#</y><d>2021-01-20</d><h>01:50</h><w>noprompt</w>Ah, bummer! <b>😞</b></z><z id="t1611107452" t="dgr Yea, no biggie. It’s just a key point that needs to be hammered home."><y>#</y><d>2021-01-20</d><h>01:50</h><w>dgr</w>Yea, no biggie. It’s just a key point that needs to be hammered home.</z><z id="t1611107469" t="dgr I’ll make sure it receives some coverage in the manual."><y>#</y><d>2021-01-20</d><h>01:51</h><w>dgr</w>I’ll make sure it receives some coverage in the manual.</z><z id="t1611107508" t="noprompt Well, definitely yelp for help next time and keep your hair. 🙂"><y>#</y><d>2021-01-20</d><h>01:51</h><w>noprompt</w>Well, definitely yelp for help next time and keep your hair. <b>🙂</b></z><z id="t1611107527" t="dgr Also, this wasn’t Meander’s issue. It’s really an issue with the Clojure printer sort of glossing over the difference between vectors and Clojure arrays."><y>#</y><d>2021-01-20</d><h>01:52</h><w>dgr</w>Also, this wasn’t Meander’s issue. It’s really an issue with the Clojure printer sort of glossing over the difference between vectors and Clojure arrays.</z><z id="t1611107545" t="noprompt If it something definitely seems like it should work and it doesn’t it’s either a bug or something else is going on."><y>#</y><d>2021-01-20</d><h>01:52</h><w>noprompt</w>If it something definitely seems like it should work and it doesn’t it’s either a bug or something else is going on.</z><z id="t1611107561" t="noprompt Yeah. I had this problem dealing with XML stuff before."><y>#</y><d>2021-01-20</d><h>01:52</h><w>noprompt</w>Yeah. I had this problem dealing with XML stuff before.</z><z id="t1611107612" t="dgr @jimmy gets the award for the day."><y>#</y><d>2021-01-20</d><h>01:53</h><w>dgr</w>@jimmy gets the award for the day.</z><z id="t1611107638" t="noprompt He’s an award winning guy. 😄"><y>#</y><d>2021-01-20</d><h>01:53</h><w>noprompt</w>He’s an award winning guy. <b>😄</b></z><z id="t1611107666" t="dgr He beat you by 3 seconds."><y>#</y><d>2021-01-20</d><h>01:54</h><w>dgr</w>He beat you by 3 seconds.</z><z id="t1611107685" t="noprompt And he did teach me a new trick today. I would have lol done it by hand in Clojure. Pretty nifty trick."><y>#</y><d>2021-01-20</d><h>01:54</h><w>noprompt</w>And he did teach me a new trick today. I would have lol done it by hand in Clojure. Pretty nifty trick.</z><z id="t1611107759" t="noprompt I gotta get up and start making dinner. BBL"><y>#</y><d>2021-01-20</d><h>01:55</h><w>noprompt</w>I gotta get up and start making dinner. BBL</z><z id="t1611107787" t="dgr Yea, exactly. I was starting to write it by hand in Clojure with multimethods, which would have been fine, but I say, “Wait a second, Meander rocks at term rewriting. I should use that! And it’ll help me with my Meander fu.” And then I spent a whole bunch of time messing with it and trying to get it to work. Doh!"><y>#</y><d>2021-01-20</d><h>01:56</h><w>dgr</w>Yea, exactly. I was starting to write it by hand in Clojure with multimethods, which would have been fine, but I say, “Wait a second, Meander rocks at term rewriting. I should use that! And it’ll help me with my Meander fu.” And then I spent a whole bunch of time messing with it and trying to get it to work. Doh!</z><z id="t1611681066" t="nlessa Hi! I have a map with a key that is a 6 elements vector. The difference between the keys is that they must differ in the first two elements of the vector. I tried this to match : {[?eid1 ?eid2 ?eid3 ?eid4 ?eid5 ?eid6] ?val1, [(me/not ?eid1) (me/not ?eid2) ?eid3 ?eid4 ?eid5 ?eid6] ?val2} but getting a map patterns may not contain variables in their keys that would make it so there is more than one match possible. How could I expresse this?"><y>#</y><d>2021-01-26</d><h>17:11</h><w>nlessa</w>Hi! I have a map with a key that is a 6 elements vector. The difference between the keys is that they must differ in the first two elements of the vector.
I tried this to match :
<pre>{[?eid1 ?eid2 ?eid3 ?eid4 ?eid5 ?eid6] ?val1,
 [(me/not ?eid1) (me/not ?eid2) ?eid3 ?eid4 ?eid5 ?eid6] ?val2}</pre>
but getting a <code>map patterns may not contain variables in their keys that would make it so there is more than one match possible.</code>

How could I expresse this?</z><z id="t1611681758" t="noprompt [:attrs {:href &quot;/_/_/users/U1ERECYRE&quot;}] The error happens when you use match so you’ll want to switch to find . match doesn’t allow for ambiguity and a map with a variable key is ambiguous thus the message."><y>#</y><d>2021-01-26</d><h>17:22</h><w>noprompt</w><a>@nlessa</a> The error happens when you use <code>match</code> so you’ll want to switch to <code>find</code>. <code>match</code> doesn’t allow for ambiguity and a map with a variable key is ambiguous thus the message.</z><z id="t1611681786" t="noprompt If you want an error, add the clause _ (throw (ex-info &quot;...&quot; {,,,}) below the one you have above."><y>#</y><d>2021-01-26</d><h>17:23</h><w>noprompt</w>If you want an error, add the clause
<pre>_ (throw (ex-info &quot;...&quot; {,,,})</pre>
below the one you have above.</z><z id="t1611682840" t="nlessa Thanks, Joel [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] !"><y>#</y><d>2021-01-26</d><h>17:40</h><r>nlessa</r>Thanks, Joel <a>@U06MDAPTP</a>!</z><z id="t1612123691" t="ribelo How can this be simplified? (defn test [id] (m/search [@cache_ id] [{:fns {?k {:input (m/scan ?in)}} :resolvers {?id (m/scan ?k)} :as ?m} ?id] [?in (test ?in)])) I tried to use cata or with , but failed."><y>#</y><d>2021-01-31</d><h>20:08</h><w>ribelo</w>How can this be simplified?

<pre>(defn test [id]
  (m/search [@cache_ id]
    [{:fns       {?k {:input (m/scan ?in)}}
      :resolvers {?id (m/scan ?k)}
      :as ?m}
     ?id]
    [?in (test ?in)]))</pre>
I tried to use <code>cata</code> or <code>with</code>, but failed.</z><z id="t1612123781" t="ribelo I also don&apos;t know how to return a flat collection without rewrite."><y>#</y><d>2021-01-31</d><h>20:09</h><w>ribelo</w>I also don&apos;t know how to return a flat collection without rewrite.</z><z id="t1612124345" t="ribelo this also unfortunately doesn&apos;t work because !in is used before it gets to cata (m/rewrite [@cache_ id] [{:fns {?k {:input [!in ...]}} :resolvers {?id (m/scan ?k)} :as ?m} ?id] [!in ... (m/cata [?m !in]) ...] [_ ?k] ?k)"><y>#</y><d>2021-01-31</d><h>20:19</h><w>ribelo</w>this also unfortunately doesn&apos;t work because <code>!in</code> is used before it gets to <code>cata</code>
<pre>(m/rewrite [@cache_ id]
    [{:fns       {?k {:input [!in ...]}}
      :resolvers {?id (m/scan ?k)}
      :as        ?m}
     ?id]
    [!in ... (m/cata [?m !in]) ...]
    [_ ?k] ?k)</pre></z><z id="t1612124908" t="ribelo let&apos;s say i did it, but how do i make a flat sequence out of it now? (m/rewrite [@cache_ id] [{:fns {?k {:input [!in ...]}} :resolvers {?id (m/scan ?k)} :as ?m} ?id] [(m/cata [?m !in]) ... ?id] [_ ?k] ?k) ;; =&gt; [[:db/id :person/name] [:db/id :person/last-name] :person/email]"><y>#</y><d>2021-01-31</d><h>20:28</h><w>ribelo</w>let&apos;s say i did it, but how do i make a flat sequence out of it now?
<pre>(m/rewrite [@cache_ id]
    [{:fns       {?k {:input [!in ...]}}
      :resolvers {?id (m/scan ?k)}
      :as        ?m}
     ?id]
    [(m/cata [?m !in]) ... ?id]
    [_ ?k] ?k)
;; =&gt; [[:db/id :person/name] [:db/id :person/last-name] :person/email]</pre></z><z id="t1612125334" t="Jimmy Miller On my phone right now so can&apos;t dive in. But did you try rewrites? That&apos;s the search version of rewrite. You can also use (m/and !x1 !x2) on the left hand side to copy a memory variable. If you can provide some test data I should have sometime to look at this later."><y>#</y><d>2021-01-31</d><h>20:35</h><w>Jimmy Miller</w>On my phone right now so can&apos;t dive in. But did you try rewrites? That&apos;s the search version of rewrite. 

You can also use (m/and !x1 !x2) on the left hand side to copy a memory variable.

If you can provide some test data I should have sometime to look at this later.</z><z id="t1612127211" t="ribelo [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] http://ix.io/2NSV here is the link in case you get bored and have too much time 😉"><y>#</y><d>2021-01-31</d><h>21:06</h><w>ribelo</w><a>@jimmy</a> <a href="http://ix.io/2NSV" target="_blank">http://ix.io/2NSV</a> here is the link in case you get bored and have too much time <b>😉</b></z><z id="t1612131774" t="Jimmy Miller (defn walk-inputs [cache id] (m/rewrite {:id id :cache cache} {:id (m/some ?id) :cache {:fns {?fn {:input [!inputs ...]}} :resolvers {?id (m/scan ?fn)}}} (m/cata [(m/cata {:id !inputs :cache ~cache}) ... ?id]) {:id (m/some ?id)} ?id [(m/or [!xs ...] !xs) ...] [!xs ...])) Here’s one solution. Or you could do the more mind bendy one (defn walk-inputs [cache id] (m/rewrite {:id id :cache cache} (m/and {:id (m/some ?id) :cache {:fns {?fn {:input [!inputs ...]}} :resolvers {?id (m/scan ?fn)}}} (m/let [[(m/cata (m/or [!paths ...] !paths)) ...] (m/subst [{:id !inputs :cache ~cache} ...])])) [!paths ... ?id] {:id (m/some ?id)} ?id))"><y>#</y><d>2021-01-31</d><h>22:22</h><r>Jimmy Miller</r><pre>(defn walk-inputs [cache id]
  (m/rewrite {:id id 
              :cache cache}

    {:id (m/some ?id)
     :cache {:fns       {?fn {:input [!inputs ...]}}
             :resolvers {?id (m/scan ?fn)}}}

    (m/cata [(m/cata {:id !inputs 
                      :cache ~cache}) ... ?id])

    {:id (m/some ?id)} ?id

    [(m/or [!xs ...] !xs) ...]  [!xs ...]))</pre>
Here’s one solution.

Or you could do the more mind bendy one

<pre>(defn walk-inputs [cache id]
  (m/rewrite {:id id 
              :cache cache}
    (m/and
     {:id (m/some ?id)
      :cache {:fns       {?fn {:input [!inputs ...]}}
              :resolvers {?id (m/scan ?fn)}}}
     (m/let [[(m/cata (m/or [!paths ...] !paths)) ...] (m/subst [{:id !inputs :cache ~cache} ...])]))
    
    [!paths ... ?id]

    {:id (m/some ?id)} ?id))</pre></z><z id="t1612132333" t="ribelo i finally did something similar to the first example"><y>#</y><d>2021-01-31</d><h>22:32</h><r>ribelo</r>i finally did something similar to the first example</z><z id="t1612132366" t="ribelo the second example I have to write down somehow, my mind does not comprehend it 😉"><y>#</y><d>2021-01-31</d><h>22:32</h><r>ribelo</r>the second example I have to write down somehow,  my mind does not comprehend it <b>😉</b></z><z id="t1612132383" t="ribelo thanks!"><y>#</y><d>2021-01-31</d><h>22:33</h><r>ribelo</r>thanks!</z><z id="t1612311106" t="ribelo How do I get something like this? [:a 1 2 3 :b 4 5 :c 6 7 8 9 ...] ;; =&gt; {:a [1 2 3] :b [4 5] :c [6 7 8 9] ...} "><y>#</y><d>2021-02-03</d><h>00:11</h><w>ribelo</w>How do I get something like this?
<pre>[:a 1 2 3 :b 4 5 :c 6 7 8 9 ...]
;; =&gt; {:a [1 2 3] :b [4 5] :c [6 7 8 9] ...}</pre>
</z><z id="t1612324095" t="Jimmy Miller This one in the cookbook is pretty easy to modify to give you want you what you are looking for. https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#multiple-variable-length-sub-sequences (m/rewrite [:a 1 2 3 :b 4 5 :c 6 7 8 9] [] [] ; The base case for no values left [(m/pred keyword? ?x) . (m/pred int? !ys) ... &amp; ?more] {&amp; [[?x [!ys ...]] &amp; (m/cata ?more)]})"><y>#</y><d>2021-02-03</d><h>03:48</h><w>Jimmy Miller</w>This one in the cookbook is pretty easy to modify to give you want you what you are looking for.
<a href="https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#multiple-variable-length-sub-sequences" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#multiple-variable-length-sub-sequences</a>


<pre>(m/rewrite [:a 1 2 3 :b 4 5 :c 6 7 8 9]
  [] [] ; The base case for no values left
  [(m/pred keyword? ?x) . (m/pred int? !ys) ... &amp; ?more]
  {&amp; [[?x [!ys ...]] &amp; (m/cata ?more)]})</pre></z><z id="t1612335927" t="ribelo I looked at this but I still have trouble bending my mind around cata &amp; recursion"><y>#</y><d>2021-02-03</d><h>07:05</h><w>ribelo</w>I looked at this but I still have trouble bending my mind around cata &amp; recursion</z><z id="t1612335942" t="ribelo Thanks as always!"><y>#</y><d>2021-02-03</d><h>07:05</h><w>ribelo</w>Thanks as always!</z><z id="t1612381441" t="ribelo How to check if a map does not have a given key? (m/rewrite {:m {:a 1 :b 2 :c 3} :selector :c} {:m {?s ?k} :selector ?s} true) ;; =&gt; true (m/rewrite {:m {:a 1 :b 2} :selector :c} {:m {?s nil} :selector ?s} true) ;; =&gt; nil (m/rewrite {:m {:a 1 :b 2} :selector :c} {:m (m/not {?s ?k}) :selector ?s} true) ;; =&gt; nil "><y>#</y><d>2021-02-03</d><h>19:44</h><w>ribelo</w>How to check if a map does not have a given key?
<pre>(m/rewrite {:m        {:a 1 :b 2 :c 3}
            :selector :c}
  {:m        {?s ?k}
   :selector ?s} true)
;; =&gt; true

(m/rewrite {:m        {:a 1 :b 2}
            :selector :c}
  {:m        {?s nil}
   :selector ?s} true)
;; =&gt; nil

(m/rewrite {:m        {:a 1 :b 2}
            :selector :c}
  {:m        (m/not {?s ?k})
   :selector ?s} true)
;; =&gt; nil</pre>
</z><z id="t1612383336" t="Jimmy Miller (m/rewrite {:m {:a 1 :b 2} :selector :d} {:selector ?s :m (m/not {?s (m/some)})} true) Just need to use a some here. Meander will match for keys that don’t exist. Changing this behavior is on my personal wish list for zeta."><y>#</y><d>2021-02-03</d><h>20:15</h><r>Jimmy Miller</r><pre>(m/rewrite {:m {:a 1 :b 2}
            :selector :d}

  {:selector ?s
   :m (m/not {?s (m/some)})}

  true)</pre>
Just need to use a some here. Meander will match for keys that don’t exist. Changing this behavior is on my personal wish list for zeta.</z><z id="t1612383840" t="ribelo I was close!"><y>#</y><d>2021-02-03</d><h>20:24</h><r>ribelo</r>I was close!</z><z id="t1612655635" t="ribelo I don&apos;t know if this is a bug, but gather does not work in conjunction with map-of"><y>#</y><d>2021-02-06</d><h>23:53</h><w>ribelo</w>I don&apos;t know if this is a bug, but <code>gather</code> does not work in conjunction with <code>map-of</code></z><z id="t1612655751" t="ribelo (m/rewrite {:a 1 :b 2} (m/map-of (m/pred keyword? !ks) _) [!ks ...]) ;; =&gt; [:a :b] (m/rewrite {:a 1 :b 2} (m/map-of (m/gather (m/pred keyword? !ks)) _) [!ks ...]) ;; =&gt; nil (m/rewrite [:a :b :c 1] (m/gather (m/pred keyword? !ks) _) [!ks ...]) ;; =&gt; [:a :b :c] "><y>#</y><d>2021-02-06</d><h>23:55</h><w>ribelo</w><pre>(m/rewrite {:a 1 :b 2}
  (m/map-of (m/pred keyword? !ks) _) [!ks ...])
;; =&gt; [:a :b]
(m/rewrite {:a 1 :b 2}
  (m/map-of (m/gather (m/pred keyword? !ks)) _) [!ks ...])
;; =&gt; nil
(m/rewrite [:a :b :c 1]
  (m/gather (m/pred keyword? !ks) _) [!ks ...])
;; =&gt; [:a :b :c]</pre>
</z><z id="t1612662398" t="Jimmy Miller I think there is a misunderstanding of what gather is for. Gather matches seqables. So you could combine gather with map-of like this. (m/rewrite {[:a :b 2 :c] 1 [:b :c :d 4 :e] 2} (m/map-of (m/gather (m/pred keyword? !ks)) _) [!ks ...]) Seems like a rather unlikely thing to be doing. Maybe you were trying to gather up things on a map? Something like this? (m/rewrite {:a 1 :b 3 &quot;stuff&quot; 5} {&amp; (m/gather [(m/pred keyword? !k) !v])} (m/map-of !k !v)) ;; =&gt; {:a 1 :b 3}"><y>#</y><d>2021-02-07</d><h>01:46</h><r>Jimmy Miller</r>I think there is a misunderstanding of what gather is for. Gather matches seqables. So you could combine gather with map-of like this.

<pre>(m/rewrite {[:a :b 2 :c] 1 [:b :c :d 4 :e] 2}
  (m/map-of (m/gather (m/pred keyword? !ks)) _) [!ks ...])</pre>
Seems like a rather unlikely thing to be doing. Maybe you were trying to gather up things on a map? Something like this?

<pre>(m/rewrite {:a 1 :b 3 &quot;stuff&quot; 5}
  {&amp; (m/gather [(m/pred keyword? !k) !v])}
  (m/map-of !k !v))
;; =&gt; {:a 1 :b 3}</pre></z><z id="t1612732588" t="ribelo 👍"><y>#</y><d>2021-02-07</d><h>21:16</h><r>ribelo</r><b>👍</b></z><z id="t1613061699" t="markaddleman Picking up a dropped thread: I&apos;m using meander to parse and rewrite HoneySQL (well, something close to HoneySQL). One of the things I need to do is &quot;fully qualify&quot; column names by finding the table name from the from clause and threading it through column references in the rest of the query. For example: {:select [{:type :col :col :a}] :from [{:type :table :table :t}] should be rewritten as {:select [{:type :col :col :a :table-ref :t}] :from [{:type :table :table :t}] Things get complicated when I have to deal with subqueries. For example {:select [{:type :col :col :a} {:select [{:type :col :col :b}] :from [:sub-t]} :from [:t]} should be rewritten as {:select [{:type :col :col :a :table-ref :t} {:select [{:type :col :col :b :table-ref :sub-t}] :from [{:type :table :table :sub-t}]} :from [{:type :table :table :t}]} In this example, you can see that I want to match the :from clause that is nearest in the tree to the column. Because columns can exist in several places within a query, I&apos;d like to use the $ operator to find the column references. The problem is that I need to attach some boundary conditions to $ so it find a :from clause from an sub-query. Any ideas?"><y>#</y><d>2021-02-11</d><h>16:41</h><w>markaddleman</w>Picking up a dropped thread:  I&apos;m using meander to parse and rewrite HoneySQL (well, something close to HoneySQL).  One of the things I need to do is &quot;fully qualify&quot; column names by finding the table name from the from clause and threading it through column references in the rest of the query.  For example: <code>{:select [{:type :col :col :a}] :from [{:type :table :table :t}]</code> should be rewritten as <code>{:select [{:type :col :col :a :table-ref :t}] :from [{:type :table :table :t}]</code> 

Things get complicated when I have to deal with subqueries.  For example <code>{:select [{:type :col :col :a} {:select [{:type :col :col :b}] :from [:sub-t]} :from [:t]}</code> should be rewritten as <code>{:select [{:type :col :col :a :table-ref :t} {:select [{:type :col :col :b :table-ref :sub-t}] :from [{:type :table :table :sub-t}]} :from [{:type :table :table :t}]}</code> In this example, you can see that I want to match the <code>:from</code>  clause that is nearest in the tree to the column.

Because columns can exist in several places within a query, I&apos;d like to use the <code>$</code> operator to find the column references.  The problem is that I need to attach some boundary conditions to <code>$</code> so it find a <code>:from</code>  clause from an sub-query.

Any ideas?</z><z id="t1613062362" t="noprompt What should this do when there is more in :from ?"><y>#</y><d>2021-02-11</d><h>16:52</h><w>noprompt</w>What should this do when there is more in <code>:from</code>?</z><z id="t1613062415" t="noprompt (m/let [table-ref (keyword (gensym &quot;T__&quot;))] {:from &lt;what-goes-here&gt; :select [(m/or {:type :col :as !column} !not-column) ...]}) {:from [{:type :table :table ?table-ref} ...] :select [{:table-ref ?table-ref &amp; !column} ... !not-column ...]} "><y>#</y><d>2021-02-11</d><h>16:53</h><w>noprompt</w><pre>(m/let [table-ref (keyword (gensym &quot;T__&quot;))]
  {:from &lt;what-goes-here&gt;
   :select [(m/or {:type :col :as !column}
                  !not-column)
            ...]})
{:from [{:type :table :table ?table-ref} ...]
 :select [{:table-ref ?table-ref &amp; !column} ...
          !not-column ...]}</pre>
</z><z id="t1613062591" t="markaddleman I knew I should have discussed that 🙂 In my case, if there is more than one from, the columns are guaranteed to be fully qualified from the start so this qualification rewrite is, essentially, a nop"><y>#</y><d>2021-02-11</d><h>16:56</h><w>markaddleman</w>I knew I should have discussed that <b>🙂</b>  In my case, if there is more than one from, the columns are guaranteed to be fully qualified from the start so this qualification rewrite is, essentially, a nop</z><z id="t1613063189" t="noprompt You may want to consider using m/cata for on the right side like so {:select [!selection ...] :from (m/and [{:type :table :table ?table}] ?from)} {:select [(m/cata [::qualify-selection !selection ?table])] :from ?from} ;; Rewrite [::qualify-selection ,,,] [::qualify-selection {:type :col :table-ref nil :as ?col} ?table] {:table-ref ?table &amp; ?col} "><y>#</y><d>2021-02-11</d><h>17:06</h><w>noprompt</w>You may want to consider using <code>m/cata</code> for on the right side like so
<pre>{:select [!selection ...]
 :from (m/and [{:type :table :table ?table}]
              ?from)}
{:select [(m/cata [::qualify-selection !selection ?table])]
 :from ?from}

;; Rewrite [::qualify-selection ,,,]
[::qualify-selection {:type :col :table-ref nil :as ?col} ?table]
{:table-ref ?table &amp; ?col}</pre>
</z><z id="t1613063231" t="noprompt Then just make a rule for [::qualify-selection ,,,] that stops or rewrites as needed."><y>#</y><d>2021-02-11</d><h>17:07</h><w>noprompt</w>Then just make a rule for <code>[::qualify-selection ,,,]</code> that stops or rewrites as needed.</z><z id="t1613063324" t="markaddleman Yes, that&apos;s my current approach. Unfortunately, it gets to be verbose because columns can exist in the select clause, where clause, group-by, function calls.... I am looking for a more terse solution but it may not exist"><y>#</y><d>2021-02-11</d><h>17:08</h><w>markaddleman</w>Yes, that&apos;s my current approach.  Unfortunately, it gets to be verbose because columns can exist in the select clause, where clause, group-by, function calls....  I am looking for a more terse solution but it may not exist</z><z id="t1613064246" t="noprompt Normally qualification tends to a top down approach and for this sort of qualification you will necessarily have a few cases."><y>#</y><d>2021-02-11</d><h>17:24</h><w>noprompt</w>Normally qualification tends to a top down approach and for this sort of qualification you will necessarily have a few cases.</z><z id="t1613064289" t="noprompt e.g. you’ll be calling (qualify-selection x table) or something like this."><y>#</y><d>2021-02-11</d><h>17:24</h><w>noprompt</w>e.g. you’ll be calling <code>(qualify-selection x table)</code> or something like this.</z><z id="t1613064367" t="noprompt Dealing with SQL, and especially HoneySQL, is going to require some code."><y>#</y><d>2021-02-11</d><h>17:26</h><w>noprompt</w>Dealing with SQL, and especially HoneySQL, is going to require some code.</z><z id="t1613066487" t="markaddleman Yeah. I think I found a solution that uses a meander pattern to locate and rewrite the deepest subquery. Outside of meander, I can loop over rewrites until I find a stable result"><y>#</y><d>2021-02-11</d><h>18:01</h><w>markaddleman</w>Yeah.  I think I found a solution that uses a meander pattern to locate and rewrite the deepest subquery.  Outside of meander, I can loop over rewrites until I find a stable result</z><z id="t1613068811" t="noprompt Ye olde fix ?"><y>#</y><d>2021-02-11</d><h>18:40</h><w>noprompt</w>Ye olde <code>fix</code> ?</z><z id="t1613068863" t="noprompt (defn fix [f] (fn [x] (let [x* (f x)] (if (= x x*) x (recur x*)))) "><y>#</y><d>2021-02-11</d><h>18:41</h><w>noprompt</w><pre>(defn fix [f]
  (fn [x]
    (let [x* (f x)]
      (if (= x x*)
        x
        (recur x*))))</pre>
</z><z id="t1613069055" t="markaddleman Yup 🙂 I&apos;m not using a meander strategy for this but I probably should"><y>#</y><d>2021-02-11</d><h>18:44</h><w>markaddleman</w>Yup <b>🙂</b>  I&apos;m not using a meander strategy for this but I probably should</z><z id="t1613069261" t="noprompt I’ve been debating whether or not to keep those around going forward."><y>#</y><d>2021-02-11</d><h>18:47</h><w>noprompt</w>I’ve been debating whether or not to keep those around going forward.</z><z id="t1613070172" t="markaddleman Strategies?"><y>#</y><d>2021-02-11</d><h>19:02</h><w>markaddleman</w>Strategies?</z><z id="t1613070233" t="markaddleman I haven&apos;t used them so it&apos;s hard for me to say but I remember thinking that the most recent epsilon stuff around functions seemed very powerful. I don&apos;t recall the specifics right now"><y>#</y><d>2021-02-11</d><h>19:03</h><w>markaddleman</w>I haven&apos;t used them so it&apos;s hard for me to say but I remember thinking that the most recent epsilon stuff around functions seemed very powerful.  I don&apos;t recall the specifics right now</z><z id="t1613515307" t="ribelo I just started testing meander in cljs"><y>#</y><d>2021-02-16</d><h>22:41</h><w>ribelo</w>I just started testing meander in cljs</z><z id="t1613515324" t="ribelo Are there any restrictions?"><y>#</y><d>2021-02-16</d><h>22:42</h><w>ribelo</w>Are there any restrictions?</z><z id="t1613515359" t="ribelo have a problem using cata in rhs, it throws an error"><y>#</y><d>2021-02-16</d><h>22:42</h><w>ribelo</w>have a problem using cata in rhs, it throws an error</z><z id="t1613515418" t="ribelo Resource: &lt;eval&gt;:1:1 Use of undeclared Var ribelo.meander-playground/java"><y>#</y><d>2021-02-16</d><h>22:43</h><w>ribelo</w><pre>Resource: &lt;eval&gt;:1:1
Use of undeclared Var ribelo.meander-playground/java</pre></z><z id="t1613515851" t="ribelo I see that cata is used in tests like this"><y>#</y><d>2021-02-16</d><h>22:50</h><w>ribelo</w>I see that cata is used in tests like this</z><z id="t1613515856" t="ribelo https://github.com/noprompt/meander/blob/epsilon/test/meander/epsilon_test.cljc#L846"><y>#</y><d>2021-02-16</d><h>22:50</h><w>ribelo</w><a href="https://github.com/noprompt/meander/blob/epsilon/test/meander/epsilon_test.cljc#L846" target="_blank">https://github.com/noprompt/meander/blob/epsilon/test/meander/epsilon_test.cljc#L846</a></z><z id="t1613515897" t="ribelo so either there&apos;s a regression, or more likely I have a shadow-cljs problem somewhere"><y>#</y><d>2021-02-16</d><h>22:51</h><w>ribelo</w>so either there&apos;s a regression, or more likely I have a shadow-cljs problem somewhere</z><z id="t1613515942" t="Jimmy Miller Could you post your code that is throwing that error?"><y>#</y><d>2021-02-16</d><h>22:52</h><w>Jimmy Miller</w>Could you post your code that is throwing that error?</z><z id="t1613515966" t="ribelo (m/rewrite [1 2 3] [!ks ...] [(m/cata !ks) ...] ?x ?x) "><y>#</y><d>2021-02-16</d><h>22:52</h><w>ribelo</w><pre>(m/rewrite [1 2 3]
  [!ks ...]
  [(m/cata !ks) ...]
  ?x ?x)</pre>
</z><z id="t1613516055" t="ribelo anything using cata on the right side causes an exception as above"><y>#</y><d>2021-02-16</d><h>22:54</h><w>ribelo</w>anything using cata on the right side causes an exception as above</z><z id="t1613516172" t="Jimmy Miller I’m not getting that error in a bare clojurescript repl (the code just works). I doubt I would get it in shadow-cljs. It looks very unrelated to meander. Are you sure you don’t have some error elsewhere in your code?"><y>#</y><d>2021-02-16</d><h>22:56</h><w>Jimmy Miller</w>I’m not getting that error in a bare clojurescript repl (the code just works). I doubt I would get it in shadow-cljs. It looks very unrelated to meander. Are you sure you don’t have some error elsewhere in your code?</z><z id="t1613516248" t="Jimmy Miller The error seems to think you are referring to something called java that doesn’t exist."><y>#</y><d>2021-02-16</d><h>22:57</h><w>Jimmy Miller</w>The error seems to think you are referring to something called <code>java</code> that doesn’t exist.</z><z id="t1613516256" t="ribelo I will create a new completely empty project folder and check again."><y>#</y><d>2021-02-16</d><h>22:57</h><w>ribelo</w>I will create a new completely empty project folder and check again.</z><z id="t1613516676" t="ribelo there&apos;s definitely a problem with shadow-cljs"><y>#</y><d>2021-02-16</d><h>23:04</h><w>ribelo</w>there&apos;s definitely a problem with shadow-cljs</z><z id="t1613516691" t="ribelo on an empty project I get the same error"><y>#</y><d>2021-02-16</d><h>23:04</h><w>ribelo</w>on an empty project I get the same error</z><z id="t1613516871" t="Jimmy Miller Can&apos;t look right now. But if you can push that project to github I can definitely take a look later tonight"><y>#</y><d>2021-02-16</d><h>23:07</h><w>Jimmy Miller</w>Can&apos;t look right now. But if you can push that project to github I can definitely take a look later tonight</z><z id="t1613516985" t="ribelo sure, but first I&apos;ll just check if it worked on the previous version of shadow"><y>#</y><d>2021-02-16</d><h>23:09</h><w>ribelo</w>sure, but first I&apos;ll just check if it worked on the previous version of shadow</z><z id="t1613518800" t="ribelo [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] https://github.com/ribelo/shadow-meander-test"><y>#</y><d>2021-02-16</d><h>23:40</h><w>ribelo</w><a>@jimmy</a> <a href="https://github.com/ribelo/shadow-meander-test" target="_blank">https://github.com/ribelo/shadow-meander-test</a></z><z id="t1613569295" t="huxley @theller has checked the repo and thinks the problem must be somewhere on the meander side"><y>#</y><d>2021-02-17</d><h>13:41</h><w>huxley</w>@theller has checked the repo and thinks the problem must be somewhere on the meander side</z><z id="t1613569333" t="huxley"><y>#</y><d>2021-02-17</d><h>13:42</h><w>huxley</w></z><z id="t1613569394" t="Jimmy Miller Sorry I didn&apos;t get a chance to check this last night. Will today."><y>#</y><d>2021-02-17</d><h>13:43</h><w>Jimmy Miller</w>Sorry I didn&apos;t get a chance to check this last night. Will today.</z><z id="t1613569604" t="huxley It&apos;s nothing urgent mate"><y>#</y><d>2021-02-17</d><h>13:46</h><w>huxley</w>It&apos;s nothing urgent mate</z><z id="t1613569632" t="huxley I&apos;m just messing around for fun"><y>#</y><d>2021-02-17</d><h>13:47</h><w>huxley</w>I&apos;m just messing around for fun</z><z id="t1613570596" t="huxley [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}]"><y>#</y><d>2021-02-17</d><h>14:03</h><w>huxley</w><a>@jimmy</a></z><z id="t1613573206" t="ribelo if I had to guess, it&apos;s probably this place."><y>#</y><d>2021-02-17</d><h>14:46</h><w>ribelo</w>if I had to guess, it&apos;s probably this place.</z><z id="t1613573229" t="ribelo https://github.com/noprompt/meander/blob/fc5a3c6e0c2f5593a0656a96b644f8c521a53105/src/meander/epsilon.clj#L163"><y>#</y><d>2021-02-17</d><h>14:47</h><w>ribelo</w><a href="https://github.com/noprompt/meander/blob/fc5a3c6e0c2f5593a0656a96b644f8c521a53105/src/meander/epsilon.clj#L163" target="_blank">https://github.com/noprompt/meander/blob/fc5a3c6e0c2f5593a0656a96b644f8c521a53105/src/meander/epsilon.clj#L163</a></z><z id="t1613580581" t="noprompt Thats in a clj file."><y>#</y><d>2021-02-17</d><h>16:49</h><w>noprompt</w>Thats in a clj file.</z><z id="t1613580665" t="noprompt But src/meander/substitute/epsilon.cljc 676: (catch Exception e# "><y>#</y><d>2021-02-17</d><h>16:51</h><w>noprompt</w>But
<pre>src/meander/substitute/epsilon.cljc
676:                         (catch Exception e#</pre>
</z><z id="t1613580930" t="noprompt K I just pushed a patch for this but not a new release"><y>#</y><d>2021-02-17</d><h>16:55</h><w>noprompt</w>K I just pushed a patch for this but not a new release</z><z id="t1613583352" t="noprompt If what is on epsilon works lemme know."><y>#</y><d>2021-02-17</d><h>17:35</h><w>noprompt</w>If what is on epsilon works lemme know.</z><z id="t1613583357" t="noprompt I can make a release later today."><y>#</y><d>2021-02-17</d><h>17:35</h><w>noprompt</w>I can make a release later today.</z><z id="t1613584166" t="noprompt Everyone, eventually this message will vanish but apart from bug fixes that people mention, I’m no longer working on epsilon anymore. I’m only working on zeta from here on out and have been in this mode for a little while. So far, things are looking good on the zeta branch. There is a new design at work which has, overall, lead to reduction pretty big reduction in code. There is still a lot to do and test, however."><y>#</y><d>2021-02-17</d><h>17:49</h><w>noprompt</w>Everyone, eventually this message will vanish but apart from bug fixes that people mention, I’m no longer working on <code>epsilon</code> anymore. I’m only working on <code>zeta</code> from here on out and have been in this mode for a little while.

So far, things are looking good on the <code>zeta</code> branch. There is a new design at work which has, overall, lead to reduction pretty big reduction in code. There is still a lot to do and test, however.</z><z id="t1613586424" t="ribelo Is zeta usable like epsilon?"><y>#</y><d>2021-02-17</d><h>18:27</h><w>ribelo</w>Is zeta usable like epsilon?</z><z id="t1613586444" t="Jimmy Miller Not yet"><y>#</y><d>2021-02-17</d><h>18:27</h><w>Jimmy Miller</w>Not yet</z><z id="t1613586529" t="ribelo then I&apos;ll just keep my fingers crossed"><y>#</y><d>2021-02-17</d><h>18:28</h><w>ribelo</w>then I&apos;ll just keep my fingers crossed</z><z id="t1613587920" t="noprompt A lot of progress has been made. Essentially, the whole thing has been rewritten to accommodate the things people have asked for such as explanations, being able to interpret matching/rewriting, as well as a few things I’ve wanted."><y>#</y><d>2021-02-17</d><h>18:52</h><w>noprompt</w>A lot of progress has been made. Essentially, the whole thing has been rewritten to accommodate the things people have asked for such as explanations, being able to interpret matching/rewriting, as well as a few things I’ve wanted.</z><z id="t1613587995" t="noprompt What I did was abstract the overlapping parts of compilation and interpretation such that the code which builds an interpreter for a pattern can also build a compiler for it."><y>#</y><d>2021-02-17</d><h>18:53</h><w>noprompt</w>What I did was abstract the overlapping parts of compilation and interpretation such that the code which builds an interpreter for a pattern can also build a compiler for it.</z><z id="t1613588084" t="noprompt The abstraction also handles returning one or many results e.g. find or search."><y>#</y><d>2021-02-17</d><h>18:54</h><w>noprompt</w>The abstraction also handles returning one or many results e.g. find or search.</z><z id="t1613588161" t="noprompt Also, both sides of rewriting use the same abstraction which means that both interpreters and compilers can make more aggressive optimizations."><y>#</y><d>2021-02-17</d><h>18:56</h><w>noprompt</w>Also, both sides of rewriting use the same abstraction which means that both interpreters and compilers can make more aggressive optimizations.</z><z id="t1613588184" t="ribelo Can I read something about the decisions and the idea behind the meander? Key words will suffice, I can google myself if I know what to look for"><y>#</y><d>2021-02-17</d><h>18:56</h><w>ribelo</w>Can I read something about the decisions and the idea behind the meander? Key words will suffice, I can google myself if I know what to look for</z><z id="t1613588211" t="noprompt Partial evaluation, abstract interpretation?"><y>#</y><d>2021-02-17</d><h>18:56</h><w>noprompt</w>Partial evaluation, abstract interpretation?</z><z id="t1613588217" t="ribelo meander is probably the most interesting and best thing since sliced bread"><y>#</y><d>2021-02-17</d><h>18:56</h><w>ribelo</w>meander is probably the most interesting and best thing since sliced bread</z><z id="t1613588225" t="noprompt Well thanks! 🙂"><y>#</y><d>2021-02-17</d><h>18:57</h><w>noprompt</w>Well thanks! <b>🙂</b></z><z id="t1613588249" t="noprompt Finally, the idea of a variable is somewhat different internally."><y>#</y><d>2021-02-17</d><h>18:57</h><w>noprompt</w>Finally, the idea of a variable is somewhat different internally.</z><z id="t1613588301" t="ribelo you&apos;re welcome"><y>#</y><d>2021-02-17</d><h>18:58</h><w>ribelo</w>you&apos;re welcome</z><z id="t1613588335" t="noprompt A variable is, essentially, I think, both a fold (reduction) and unfold (disperse)."><y>#</y><d>2021-02-17</d><h>18:58</h><w>noprompt</w>A variable is, essentially, I think, both a fold (reduction) and unfold (disperse).</z><z id="t1613588370" t="ribelo I&apos;m too weak for most ingenius things, but meander combines cool solutions with really simple use"><y>#</y><d>2021-02-17</d><h>18:59</h><w>ribelo</w>I&apos;m too weak for most ingenius things, but meander combines cool solutions with really simple use</z><z id="t1613588396" t="noprompt This is absolutely the intention."><y>#</y><d>2021-02-17</d><h>18:59</h><w>noprompt</w>This is absolutely the intention.</z><z id="t1613588502" t="noprompt I’m by no means a genius. I have to look stuff up all the time. I can’t remember anything. And I certainly won’t be solving any deep mathematical problems before I die."><y>#</y><d>2021-02-17</d><h>19:01</h><w>noprompt</w>I’m by no means a genius. I have to look stuff up all the time. I can’t remember anything. And I certainly won’t be solving any deep mathematical problems before I die.</z><z id="t1613588568" t="ribelo To a dog, all humans are magicians because they can open doors. As I read [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] &apos;s blog, this is how I felt"><y>#</y><d>2021-02-17</d><h>19:02</h><w>ribelo</w>To a dog, all humans are magicians because they can open doors. As I read <a>@jimmy</a>&apos;s blog, this is how I felt</z><z id="t1613588585" t="noprompt But I think programming in most of its currently formulations hinders interesting creative efforts, experimentation, and creates social problems."><y>#</y><d>2021-02-17</d><h>19:03</h><w>noprompt</w>But I think programming in most of its currently formulations hinders interesting creative efforts, experimentation, and creates social problems.</z><z id="t1613588589" t="noprompt LOL"><y>#</y><d>2021-02-17</d><h>19:03</h><w>noprompt</w>LOL</z><z id="t1613588638" t="noprompt And I don’t mean to besmirch modern PLs. This is just my observation/opinion."><y>#</y><d>2021-02-17</d><h>19:03</h><w>noprompt</w>And I don’t mean to besmirch modern PLs. This is just my observation/opinion.</z><z id="t1613588804" t="Jimmy Miller There’s definitely a lot of different things coming together in meander. A big one is term rewriting. https://vimeo.com/155448425 Lot’s of stuff borrowed from Racket, particularly their pattern matching https://docs.racket-lang.org/reference/match.html There are a bunch of different influences that [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] synthesized together and made something fairly unique. But those should be some good jumping off points."><y>#</y><d>2021-02-17</d><h>19:06</h><w>Jimmy Miller</w>There’s definitely a lot of different things coming together in meander. A big one is term rewriting. <a href="https://vimeo.com/155448425" target="_blank">https://vimeo.com/155448425</a>

Lot’s of stuff borrowed from Racket, particularly their pattern matching <a href="https://docs.racket-lang.org/reference/match.html" target="_blank">https://docs.racket-lang.org/reference/match.html</a>

There are a bunch of different influences that <a>@noprompt</a> synthesized together and made something fairly unique. But those should be some good jumping off points.</z><z id="t1613588829" t="ribelo thx"><y>#</y><d>2021-02-17</d><h>19:07</h><w>ribelo</w>thx</z><z id="t1613588897" t="ribelo usually the hardest part is synthesizing the knowledge. everyone has the same elements, but not everyone can make something unique out of it"><y>#</y><d>2021-02-17</d><h>19:08</h><w>ribelo</w>usually the hardest part is synthesizing the knowledge. everyone has the same elements, but not everyone can make something unique out of it</z><z id="t1613589150" t="noprompt Some of my biggest influences are • TXL https://en.wikipedia.org/wiki/TXL_(programming_language) • Maude https://en.wikipedia.org/wiki/Maude_system • Datalog • miniKanren • Regular Expression • Definite Clause Grammars https://en.wikipedia.org/wiki/Definite_clause_grammar • Operational semantics https://en.wikipedia.org/wiki/Operational_semantics"><y>#</y><d>2021-02-17</d><h>19:12</h><w>noprompt</w>Some of my biggest influences are
• TXL <a href="https://en.wikipedia.org/wiki/TXL_(programming_language)" target="_blank">https://en.wikipedia.org/wiki/TXL_(programming_language)</a>
• Maude <a href="https://en.wikipedia.org/wiki/Maude_system" target="_blank">https://en.wikipedia.org/wiki/Maude_system</a>
• Datalog
• miniKanren
• Regular Expression
• Definite Clause Grammars <a href="https://en.wikipedia.org/wiki/Definite_clause_grammar" target="_blank">https://en.wikipedia.org/wiki/Definite_clause_grammar</a>
• Operational semantics <a href="https://en.wikipedia.org/wiki/Operational_semantics" target="_blank">https://en.wikipedia.org/wiki/Operational_semantics</a></z><z id="t1613589201" t="noprompt Data flow would probably be another thing to chip in here."><y>#</y><d>2021-02-17</d><h>19:13</h><w>noprompt</w>Data flow would probably be another thing to chip in here.</z><z id="t1613589213" t="noprompt But that’s somewhat outside the scope."><y>#</y><d>2021-02-17</d><h>19:13</h><w>noprompt</w>But that’s somewhat outside the scope.</z><z id="t1613589287" t="ribelo I will definitely try to read if I can understand"><y>#</y><d>2021-02-17</d><h>19:14</h><w>ribelo</w>I will definitely try to read if I can understand</z><z id="t1613589323" t="noprompt I will let people know when I feel comfortable with them playing with the zeta branch the first moment I get that feeling."><y>#</y><d>2021-02-17</d><h>19:15</h><w>noprompt</w>I will let people know when I feel comfortable with them playing with the <code>zeta</code> branch the first moment I get that feeling.</z><z id="t1613589351" t="noprompt Mostly, I want to suffer through the testing and debugging so others don’t have to."><y>#</y><d>2021-02-17</d><h>19:15</h><w>noprompt</w>Mostly, I want to suffer through the testing and debugging so others don’t have to.</z><z id="t1613589436" t="noprompt The most important thing for me on this branch is making sure the experience is smooth and performant. And when it is not I would like it to be very convenient for people to either solve their own problems or report issues with the explanation feature."><y>#</y><d>2021-02-17</d><h>19:17</h><w>noprompt</w>The most important thing for me on this branch is making sure the experience is smooth and performant. And when it is not I would like it to be very convenient for people to either solve their own problems or report issues with the explanation feature.</z><z id="t1613589495" t="noprompt Personally, I would prefer not to roll out a Cyberpunk 2077."><y>#</y><d>2021-02-17</d><h>19:18</h><w>noprompt</w>Personally, I would prefer not to roll out a Cyberpunk 2077.</z><z id="t1613589583" t="noprompt I don’t want it to be a “Have they fixed the AI yet?” sort of thing. 🙂"><y>#</y><d>2021-02-17</d><h>19:19</h><w>noprompt</w>I don’t want it to be a “Have they fixed the AI yet?” sort of thing. <b>🙂</b></z><z id="t1613589669" t="ribelo that means zeta is supposed to be faster than epsilon?"><y>#</y><d>2021-02-17</d><h>19:21</h><w>ribelo</w>that means zeta is supposed to be faster than epsilon?</z><z id="t1613589920" t="noprompt I want to be at least as fast."><y>#</y><d>2021-02-17</d><h>19:25</h><w>noprompt</w>I want to be at least as fast.</z><z id="t1613589988" t="noprompt The compiler I’ve been chipping away can make very aggressive optimizations."><y>#</y><d>2021-02-17</d><h>19:26</h><w>noprompt</w>The compiler I’ve been chipping away can make very aggressive optimizations.</z><z id="t1613590061" t="noprompt It already avoids duplicate logic checks, binding something more than once, etc."><y>#</y><d>2021-02-17</d><h>19:27</h><w>noprompt</w>It already avoids duplicate logic checks, binding  something more than once, etc.</z><z id="t1613590101" t="noprompt Pretty soon it will generate code that ensures thats calls to functions are made exactly once."><y>#</y><d>2021-02-17</d><h>19:28</h><w>noprompt</w>Pretty soon it will generate code that ensures thats calls to functions are made exactly once.</z><z id="t1613590117" t="noprompt These things add up."><y>#</y><d>2021-02-17</d><h>19:28</h><w>noprompt</w>These things add up.</z><z id="t1613590293" t="ribelo as of today, meander can successfully replace datascript. pull without reverse lookup is 50 loc and is faster ~10x, q is 40 loc and we have working datalog, which even looks identical. For simple queries it is slower ~5x, but for longer ones it is faster ~2x."><y>#</y><d>2021-02-17</d><h>19:31</h><w>ribelo</w>as of today, meander can successfully replace datascript. pull without reverse lookup is 50 loc and is faster ~10x, q is 40 loc and we have working datalog, which even looks identical. For simple queries it is slower ~5x, but for longer ones it is faster ~2x.</z><z id="t1613590361" t="ribelo If zeta is faster, it will be the perfect tool for the frontend"><y>#</y><d>2021-02-17</d><h>19:32</h><w>ribelo</w>If zeta is faster, it will be the perfect tool for the frontend</z><z id="t1613590417" t="ribelo In fact, it already is, because this speed is more than enough."><y>#</y><d>2021-02-17</d><h>19:33</h><w>ribelo</w>In fact, it already is, because this speed is more than enough.</z><z id="t1613591582" t="noprompt Oh that is a very interesting finding. Have you had a look at #asami?"><y>#</y><d>2021-02-17</d><h>19:53</h><w>noprompt</w>Oh that is a very interesting finding. Have you had a look at #asami?</z><z id="t1613591645" t="noprompt Asami is very fast. AFAIK sure it is faster than datascript and most certainly would be faster than Meander for its particular niche."><y>#</y><d>2021-02-17</d><h>19:54</h><w>noprompt</w>Asami is very fast. AFAIK sure it is faster than datascript and most certainly would be faster than Meander for its particular niche.</z><z id="t1613591657" t="noprompt Part of the reason for that is that Asami does query planning."><y>#</y><d>2021-02-17</d><h>19:54</h><w>noprompt</w>Part of the reason for that is that Asami does query planning.</z><z id="t1613591717" t="noprompt But also, Paula Gearon, is an expert in the space. She’s on our team at Cisco and we use Asami heavily."><y>#</y><d>2021-02-17</d><h>19:55</h><w>noprompt</w>But also, Paula Gearon, is an expert in the space. She’s on our team at Cisco and we use Asami heavily.</z><z id="t1613653253" t="Lucy Wang [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] May I ask do your team mainly use asami in the backend or in the frontend? I have been heard of asami for a long time but haven&apos;t yet evaluated it."><y>#</y><d>2021-02-18</d><h>13:00</h><r>Lucy Wang</r><a>@noprompt</a> May I ask do your team mainly use asami in the backend or in the frontend? I have been heard of asami for a long time but haven&apos;t yet evaluated it.</z><z id="t1613663186" t="noprompt Both, however, we use indirectly on the frontend."><y>#</y><d>2021-02-18</d><h>15:46</h><r>noprompt</r>Both, however, we use indirectly on the frontend.</z><z id="t1613711627" t="Lucy Wang What does &quot;indirectly&quot; mean 🙂 ?"><y>#</y><d>2021-02-19</d><h>05:13</h><r>Lucy Wang</r>What does &quot;indirectly&quot; mean <b>🙂</b> ?</z><z id="t1613760086" t="noprompt Indirectly means that, on the front end, our consumers not using directly but, rather, going through an API."><y>#</y><d>2021-02-19</d><h>18:41</h><r>noprompt</r>Indirectly means that, on the front end, our consumers not using directly but, rather, going through an API.</z><z id="t1613760115" t="noprompt So they will send an asami query with a string which will then be parsed, etc."><y>#</y><d>2021-02-19</d><h>18:41</h><r>noprompt</r>So they will send an asami query with a string which will then be parsed, etc.</z><z id="t1613760791" t="ribelo If it&apos;s not a secret, what do you use on the front end? CLJS? TS? JS? If CLJS, then reagent? re-frame? fulcro?"><y>#</y><d>2021-02-19</d><h>18:53</h><r>ribelo</r>If it&apos;s not a secret, what do you use on the front end? CLJS? TS? JS? If CLJS, then reagent? re-frame? fulcro?</z><z id="t1613761122" t="noprompt Our consumers use TS, JS, and we’re messing with using CLJS with re-frame."><y>#</y><d>2021-02-19</d><h>18:58</h><r>noprompt</r>Our consumers use TS, JS, and we’re messing with using CLJS with re-frame.</z><z id="t1613762980" t="ribelo don&apos;t you suffer from map fatigue?"><y>#</y><d>2021-02-19</d><h>19:29</h><r>ribelo</r>don&apos;t you suffer from map fatigue?</z><z id="t1613766672" t="noprompt On our team, not especially. We work with a data model that is well defined and that gets loaded pretty quickly into asami. In some places we use meander, and in others, when nothing seems to work well, we turn to algorithms."><y>#</y><d>2021-02-19</d><h>20:31</h><r>noprompt</r>On our team, not especially. We work with a data model that is well defined and that gets loaded pretty quickly into asami. In some places we use meander, and in others, when nothing seems to work well, we turn to algorithms.</z><z id="t1613822484" t="Lucy Wang Ah, so you guys use asami in the backend server kinda like a graph database, cool."><y>#</y><d>2021-02-20</d><h>12:01</h><r>Lucy Wang</r>Ah, so you guys use asami in the backend server kinda like a graph database, cool.</z><z id="t1613591738" t="noprompt IOW there’s pressure to make it go faster and she’s more than happy to accommodate us. 🙂"><y>#</y><d>2021-02-17</d><h>19:55</h><w>noprompt</w>IOW there’s pressure to make it go faster and she’s more than happy to accommodate us. <b>🙂</b></z><z id="t1613592552" t="ribelo asami looks great, but I think it works poorly in combination with reagent and re-frame"><y>#</y><d>2021-02-17</d><h>20:09</h><w>ribelo</w>asami looks great, but I think it works poorly in combination with reagent and re-frame</z><z id="t1613592625" t="ribelo I haven&apos;t checked, but I suspect that, it has a significant impact on buildsize"><y>#</y><d>2021-02-17</d><h>20:10</h><w>ribelo</w>I haven&apos;t checked, but I suspect that, it has a significant impact on buildsize</z><z id="t1613592817" t="ribelo This is an idea that has been on my mind, but the language barrier doesn&apos;t seem to help me convey it"><y>#</y><d>2021-02-17</d><h>20:13</h><w>ribelo</w>This is an idea that has been on my mind, but the language barrier doesn&apos;t seem to help me convey it</z><z id="t1613592871" t="ribelo when I finish it and I think it&apos;s not a junk, I&apos;ll probably post it as one of the uses of meander"><y>#</y><d>2021-02-17</d><h>20:14</h><w>ribelo</w>when I finish it and I think it&apos;s not a junk, I&apos;ll probably post it as one of the uses of meander</z><z id="t1613593153" t="noprompt I merge 100% of patches to doc/ and examples/ 🙂"><y>#</y><d>2021-02-17</d><h>20:19</h><w>noprompt</w>I merge 100% of patches to <code>doc/</code>  and <code>examples/</code> <b>🙂</b></z><z id="t1613593207" t="ribelo : &gt;"><y>#</y><d>2021-02-17</d><h>20:20</h><w>ribelo</w>: &gt;</z><z id="t1613599764" t="ribelo https://github.com/noprompt/meander/pull/167"><y>#</y><d>2021-02-17</d><h>22:09</h><w>ribelo</w><a href="https://github.com/noprompt/meander/pull/167" target="_blank">https://github.com/noprompt/meander/pull/167</a></z><z id="t1613600034" t="noprompt Merged 🙂"><y>#</y><d>2021-02-17</d><h>22:13</h><w>noprompt</w>Merged <b>🙂</b></z><z id="t1613600124" t="ribelo thx"><y>#</y><d>2021-02-17</d><h>22:15</h><w>ribelo</w>thx</z></g><g id="s9"><z id="t1613653253" t="Lucy Wang [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] May I ask do your team mainly use asami in the backend or in the frontend? I have been heard of asami for a long time but haven&apos;t yet evaluated it."><y>#</y><d>2021-02-18</d><h>13:00</h><w>Lucy Wang</w><a>@noprompt</a> May I ask do your team mainly use asami in the backend or in the frontend? I have been heard of asami for a long time but haven&apos;t yet evaluated it.</z><z id="t1613819704" t="ribelo [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] https://github.com/noprompt/meander/commit/a4947bd96b055becf03aa28aaed6d5c0dd715379 doesn&apos;t work."><y>#</y><d>2021-02-20</d><h>11:15</h><w>ribelo</w><a>@noprompt</a> <a href="https://github.com/noprompt/meander/commit/a4947bd96b055becf03aa28aaed6d5c0dd715379" target="_blank">https://github.com/noprompt/meander/commit/a4947bd96b055becf03aa28aaed6d5c0dd715379</a> doesn&apos;t work.</z><z id="t1613819749" t="ribelo macro expands to clojure.lang.ExceptionInfo ."><y>#</y><d>2021-02-20</d><h>11:15</h><w>ribelo</w>macro expands to <code>clojure.lang.ExceptionInfo</code>.</z><z id="t1613940862" t="noprompt Hmm okay, well, I’ll revert it back to the way you had it."><y>#</y><d>2021-02-21</d><h>20:54</h><w>noprompt</w>Hmm okay, well, I’ll revert it back to the way you had it.</z><z id="t1613942577" t="noprompt [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] I pushed up another release"><y>#</y><d>2021-02-21</d><h>21:22</h><w>noprompt</w><a>@huxley</a> I pushed up another release</z><z id="t1613942778" t="ribelo I&apos;m guessing that won&apos;t work, because my way as it turned out didn&apos;t work either."><y>#</y><d>2021-02-21</d><h>21:26</h><w>ribelo</w>I&apos;m guessing that won&apos;t work, because my way as it turned out didn&apos;t work either.</z><z id="t1613942782" t="ribelo ; )"><y>#</y><d>2021-02-21</d><h>21:26</h><w>ribelo</w>; )</z><z id="t1613942800" t="ribelo but I&apos;ll check right now"><y>#</y><d>2021-02-21</d><h>21:26</h><w>ribelo</w>but I&apos;ll check right now</z><z id="t1613942871" t="noprompt This is start to feel like its not a Meander problem"><y>#</y><d>2021-02-21</d><h>21:27</h><w>noprompt</w>This is start to feel like its not a Meander problem</z><z id="t1613942927" t="ribelo https://github.com/ribelo/meander/commit/1bcdd1d34a6d841900ba6a6e2aac85c745232b75"><y>#</y><d>2021-02-21</d><h>21:28</h><w>ribelo</w><a href="https://github.com/ribelo/meander/commit/1bcdd1d34a6d841900ba6a6e2aac85c745232b75" target="_blank">https://github.com/ribelo/meander/commit/1bcdd1d34a6d841900ba6a6e2aac85c745232b75</a></z><z id="t1613942932" t="noprompt But if it works then I stand corrected"><y>#</y><d>2021-02-21</d><h>21:28</h><w>noprompt</w>But if it works then I stand corrected</z><z id="t1613942957" t="noprompt That definitely should not work."><y>#</y><d>2021-02-21</d><h>21:29</h><w>noprompt</w>That definitely should not work.</z><z id="t1613942977" t="noprompt Because those are the instances of the classes themselves."><y>#</y><d>2021-02-21</d><h>21:29</h><w>noprompt</w>Because those are the instances of the classes themselves.</z><z id="t1613943064" t="ribelo Done by trial and error, but it works."><y>#</y><d>2021-02-21</d><h>21:31</h><w>ribelo</w>Done by trial and error, but it works.</z><z id="t1613943069" t="noprompt BTW there is meander.util.epsilon/cljs-env?"><y>#</y><d>2021-02-21</d><h>21:31</h><w>noprompt</w>BTW there is <code>meander.util.epsilon/cljs-env?</code></z><z id="t1613943085" t="noprompt And we can use that here."><y>#</y><d>2021-02-21</d><h>21:31</h><w>noprompt</w>And we can use that here.</z><z id="t1613943106" t="noprompt It seems very odd that this works."><y>#</y><d>2021-02-21</d><h>21:31</h><w>noprompt</w>It seems very odd that this works.</z><z id="t1613943206" t="ribelo Everything after backtick develops in the ns currently in use. When I used full qualified names after it, I had to import ExceptionInfo in my ns."><y>#</y><d>2021-02-21</d><h>21:33</h><w>ribelo</w>Everything after backtick develops in the ns currently in use. When I used full qualified names after it, I had to import ExceptionInfo in my ns.</z><z id="t1613943253" t="noprompt What happens if you try ~&apos;ExceptionInfo "><y>#</y><d>2021-02-21</d><h>21:34</h><w>noprompt</w>What happens if you try
<pre>~&apos;ExceptionInfo</pre>
</z><z id="t1613943265" t="ribelo I don&apos;t know if I&apos;m explaining clearly because it&apos;s too much for my language level ; P"><y>#</y><d>2021-02-21</d><h>21:34</h><w>ribelo</w>I don&apos;t know if I&apos;m explaining clearly because it&apos;s too much for my language level ; P</z><z id="t1613943290" t="noprompt You’re fine 🙂"><y>#</y><d>2021-02-21</d><h>21:34</h><w>noprompt</w>You’re fine <b>🙂</b></z><z id="t1613943297" t="ribelo just starting emacs"><y>#</y><d>2021-02-21</d><h>21:34</h><w>ribelo</w>just starting emacs</z><z id="t1613943411" t="noprompt If ~&apos;ExceptionInfo works, great. If not, go ahead and submit your patch (use meander.util.epsilon/cljs-env? ), I’ll merge it, and cut another release."><y>#</y><d>2021-02-21</d><h>21:36</h><w>noprompt</w>If <code>~&apos;ExceptionInfo</code> works, great. If not, go ahead and submit your patch (use <code>meander.util.epsilon/cljs-env?</code>), I’ll merge it, and cut another release.</z><z id="t1613943953" t="ribelo Surprisingly it works as it is now."><y>#</y><d>2021-02-21</d><h>21:45</h><w>ribelo</w>Surprisingly it works as it is now.</z><z id="t1613943973" t="ribelo I was sure I had tried it that way, but no."><y>#</y><d>2021-02-21</d><h>21:46</h><w>ribelo</w>I was sure I had tried it that way, but no.</z><z id="t1613944024" t="ribelo thx!"><y>#</y><d>2021-02-21</d><h>21:47</h><w>ribelo</w>thx!</z><z id="t1614009644" t="zalky Hi all, just reading through the meander docs, and wondering if anyone could shed light on what the difference is between the scan and [ ...] formulations? For example: {:user {:name ?name :favorite-foods (m/scan {:name ?food})}} {:user {:name ?name :favorite-foods [{:name !food} ...]}}"><y>#</y><d>2021-02-22</d><h>16:00</h><w>zalky</w>Hi all, just reading through the meander docs, and wondering if anyone could shed light on what the difference is between the <code>scan</code> and <code>[  ...]</code> formulations? For example:

<pre>{:user
 {:name ?name
  :favorite-foods (m/scan {:name ?food})}}

{:user
 {:name ?name
  :favorite-foods [{:name !food} ...]}}</pre></z><z id="t1614013013" t="noprompt (m/scan p1 ,,, pn) is similar to [_ ... p1 ,,, pn &amp; _] or (_ ... p1 ,,, pn &amp; _) but operates on seqable? things in general."><y>#</y><d>2021-02-22</d><h>16:56</h><r>noprompt</r><code>(m/scan p1 ,,, pn)</code> is similar to
<pre>[_ ... p1 ,,, pn &amp; _]</pre>
or
<pre>(_ ... p1 ,,, pn &amp; _)</pre>
but operates on <code>seqable?</code> things in general.</z><z id="t1614020489" t="Jimmy Miller To explain the difference a bit more concretely, scan lets there be gaps in the data, where as ... requires all elements to make the pattern. You can see that in the difference between these two. (m/search [1 2 3 4 5 6] (m/scan (m/pred even? ?xs)) ?xs) ;; =&gt; [2 4 6] (m/find [1 2 3 4 5 6] [(m/pred even? !xs) ...] !xs) ;; =&gt; nil"><y>#</y><d>2021-02-22</d><h>19:01</h><r>Jimmy Miller</r>To explain the difference a bit more concretely, scan lets there be gaps in the data, where as <code>...</code> requires all elements to make the pattern. You can see that in the difference between these two.


<pre>(m/search [1 2 3 4 5 6]
  (m/scan (m/pred even? ?xs))
  ?xs)

;; =&gt; [2 4 6]

(m/find [1 2 3 4 5 6]
  [(m/pred even? !xs) ...]
  !xs)

;; =&gt; nil</pre></z><z id="t1614019808" t="Carlo (m/match #{{:id 1} {:id 2}} #{{:id 1}} :yes) works, but: (m/match #{{:id 1} {:id 2}} #{{:id ?id}} :yes) says that Set patterns may not contain variables . Does that mean that I can&apos;t check that a pattern is a subset of my data if it has logical variables, or is there a better way of expressing something like this?"><y>#</y><d>2021-02-22</d><h>18:50</h><w>Carlo</w><pre>(m/match #{{:id 1} {:id 2}} #{{:id 1}} :yes)</pre>
works, but:
<pre>(m/match #{{:id 1} {:id 2}} #{{:id ?id}} :yes)</pre>
says that <code>Set patterns may not contain variables</code> . Does that mean that I can&apos;t check that a pattern is a subset of my data if it has logical variables, or is there a better way of expressing something like this?</z><z id="t1614020218" t="Jimmy Miller Match requires things to be unambigious. But that isn’t the case here. So you can use m/search to get all the answers, or m/find to get the first. (m/search #{{:id 1} {:id 2}} #{{:id ?id}} [?id :yes]) ;; =&gt; ([2 :yes] [1 :yes])"><y>#</y><d>2021-02-22</d><h>18:56</h><r>Jimmy Miller</r>Match requires things to be unambigious. But that isn’t the case here. So you can use <code>m/search</code> to get all the answers, or <code>m/find</code> to get the first.

<pre>(m/search #{{:id 1} {:id 2}} 
  #{{:id ?id}}
  [?id :yes])

;; =&gt;
([2 :yes] [1 :yes])</pre></z><z id="t1614022782" t="Carlo thanks for the answer [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] , that&apos;s exactly what I needed! Amazing library!"><y>#</y><d>2021-02-22</d><h>19:39</h><r>Carlo</r>thanks for the answer <a>@U5K8NTHEZ</a>, that&apos;s exactly what I needed! Amazing library!</z><z id="t1614033692" t="Carlo I&apos;m observing a weird behaviour that I think could be a bug. I&apos;m in a cljs file: if I do (m/search example-2 a-pattern an-action) where example-2 is an actual binding in my file, all is good. But if I try to import the same binding from another file, writing: (m/search workspace/example-2 a-pattern an-action) then i get a spec error: Syntax error macroexpanding cljs.core/fn. Call to cljs.core/fn did not conform to spec. -- Spec failed -------------------- ([workspace/example-2_T__] ...) ^^^^^^^^^^^^^^^^^^^^^^^ has extra input or should satisfy vector? -- Relevant specs ------- :shadow.cljs.devtools.cljs-specs/param-list: (clojure.spec.alpha/and clojure.core/vector? (clojure.spec.alpha/cat :params (clojure.spec.alpha/* :shadow.cljs.devtools.cljs-specs/binding-form) :var-params (clojure.spec.alpha/? (clojure.spec.alpha/cat :ampersand #{&apos;&amp;} :var-form :shadow.cljs.devtools.cljs-specs/binding-form)))) :shadow.cljs.devtools.cljs-specs/params+body: (clojure.spec.alpha/cat :params :shadow.cljs.devtools.cljs-specs/param-list :body (clojure.spec.alpha/alt :prepost+body (clojure.spec.alpha/cat :prepost clojure.core/map? :body (clojure.spec.alpha/+ clojure.core/any?)) :body (clojure.spec.alpha/* clojure.core/any?)))"><y>#</y><d>2021-02-22</d><h>22:41</h><w>Carlo</w>I&apos;m observing a weird behaviour that I think could be a bug. I&apos;m in a cljs file: if I do
<pre>(m/search example-2 a-pattern an-action)</pre>
where example-2 is an actual binding in my file, all is good. But if I try to import the same binding from another file, writing:
<pre>(m/search workspace/example-2 a-pattern an-action)</pre>
then i get a spec error:
<pre>Syntax error macroexpanding cljs.core/fn.
Call to cljs.core/fn did not conform to spec.
-- Spec failed --------------------

  ([workspace/example-2_T__] ...)
    ^^^^^^^^^^^^^^^^^^^^^^^

has extra input

or

should satisfy

  vector?

-- Relevant specs -------

:shadow.cljs.devtools.cljs-specs/param-list:
  (clojure.spec.alpha/and
   clojure.core/vector?
   (clojure.spec.alpha/cat
    :params
    (clojure.spec.alpha/* :shadow.cljs.devtools.cljs-specs/binding-form)
    :var-params
    (clojure.spec.alpha/?
     (clojure.spec.alpha/cat
      :ampersand
      #{&apos;&amp;}
      :var-form
      :shadow.cljs.devtools.cljs-specs/binding-form))))
:shadow.cljs.devtools.cljs-specs/params+body:
  (clojure.spec.alpha/cat
   :params
   :shadow.cljs.devtools.cljs-specs/param-list
   :body
   (clojure.spec.alpha/alt
    :prepost+body
    (clojure.spec.alpha/cat
     :prepost
     clojure.core/map?
     :body
     (clojure.spec.alpha/+ clojure.core/any?))
    :body
    (clojure.spec.alpha/* clojure.core/any?)))</pre></z><z id="t1614033883" t="Jimmy Miller Sounds like a bug. If you let bins workspace/example-2 to a local variable does it work? Can&apos;t look at this right now. But will try to recreate tonight."><y>#</y><d>2021-02-22</d><h>22:44</h><r>Jimmy Miller</r>Sounds like a bug. If you let bins workspace/example-2 to a local variable does it work? Can&apos;t look at this right now. But will try to recreate tonight.</z><z id="t1614034104" t="Carlo yes, either a variable in the same file or a variable in a let binding works: (let [example-2 ...] (m/search example-2 a-pattern an-action)) Thank you!"><y>#</y><d>2021-02-22</d><h>22:48</h><r>Carlo</r>yes, either a variable in the same file or a variable in a let binding works:
<pre>(let [example-2 ...]
  (m/search example-2 a-pattern an-action))</pre>
Thank you!</z><z id="t1614034144" t="Jimmy Miller Cool should be an easy fix."><y>#</y><d>2021-02-22</d><h>22:49</h><r>Jimmy Miller</r>Cool should be an easy fix.</z><z id="t1614034163" t="Carlo and of course this works too: (let [example-2 workspace/example-2] ...)"><y>#</y><d>2021-02-22</d><h>22:49</h><r>Carlo</r>and of course this works too:
<pre>(let [example-2 workspace/example-2] ...)</pre></z><z id="t1614038430" t="Carlo When you come back to this (no pressure), I&apos;d like to understand better what&apos;s happening. Here are the macro expansions: (let* [R__59579 (clojure.core/case workspace/example-2 (:a-pattern) (clojure.core/list :an-action) meander.match.runtime.epsilon/FAIL)] (if (meander.match.runtime.epsilon/fail? R__59579) nil R__59579)) (let* [R__59582 (clojure.core/case example-2 (:a-pattern) (clojure.core/list :an-action) meander.match.runtime.epsilon/FAIL)] (if (meander.match.runtime.epsilon/fail? R__59582) nil R__59582)) it seems to me that both of them should work :thinking_face:"><y>#</y><d>2021-02-23</d><h>00:00</h><r>Carlo</r>When you come back to this (no pressure), I&apos;d like to understand better what&apos;s happening. Here are the macro expansions:
<pre>(let*
 [R__59579
  (clojure.core/case
   workspace/example-2
   (:a-pattern)
   (clojure.core/list :an-action)
   meander.match.runtime.epsilon/FAIL)]
 (if (meander.match.runtime.epsilon/fail? R__59579) nil R__59579)) 

(let*
 [R__59582
  (clojure.core/case
   example-2
   (:a-pattern)
   (clojure.core/list :an-action)
   meander.match.runtime.epsilon/FAIL)]
 (if (meander.match.runtime.epsilon/fail? R__59582) nil R__59582))</pre>
it seems to me that both of them should work <b>:thinking_face:</b></z><z id="t1614046256" t="Jimmy Miller So haven&apos;t had a chance to look into it. But judging from the first error, if you pass us a symbol as the first arg, we consider that the &quot;target&quot;. Then as a way to make debugging easier, we often use the target name to derive new variables (using gensym or some other safe way). In this case, it looks like we did that in some local function, but since the symbol is not a simple symbol, that broke in the function definition. I don&apos;t see that in your macroexpansion. But definitely see it in the spec error you sent."><y>#</y><d>2021-02-23</d><h>02:10</h><r>Jimmy Miller</r>So haven&apos;t had a chance to look into it. But judging from the first error, if you pass us a symbol as the first arg, we consider that the &quot;target&quot;. Then as a way to make debugging easier, we often use the target name to derive new variables (using gensym or some other safe way).   In this case, it looks like we did that in some local function, but since the symbol is not a simple symbol, that broke in the function definition. 

I don&apos;t see that in your macroexpansion. But definitely see it in the spec error you sent.</z><z id="t1614051012" t="Jimmy Miller Yep, it was exactly as I suspected. https://github.com/noprompt/meander/pull/169"><y>#</y><d>2021-02-23</d><h>03:30</h><r>Jimmy Miller</r>Yep, it was exactly as I suspected. <a href="https://github.com/noprompt/meander/pull/169" target="_blank">https://github.com/noprompt/meander/pull/169</a></z><z id="t1614210344" t="Jimmy Miller This has been fixed in the new release"><y>#</y><d>2021-02-24</d><h>23:45</h><r>Jimmy Miller</r>This has been fixed in the new release</z><z id="t1614178794" t="prnc Hi! I’m just having quite pleasant first encounter with meander and I was wondering what’s the best way of searching through a tree shaped structures, e.g. {:name ,,, :id ,,, :age ,,, :children [{:name ,,, :id ,,, :age ,,, :children ,,,} ,,,]} Say I’m using match defining my transformation for the top level and want to recurse on optional children ."><y>#</y><d>2021-02-24</d><h>14:59</h><w>prnc</w>Hi! I’m just having quite pleasant first encounter with meander and I was wondering what’s the best way of searching through a tree shaped structures, e.g.


<pre>{:name ,,,
   :id ,,,
   :age ,,,
   :children [{:name ,,, :id ,,, :age ,,, :children ,,,} ,,,]}
  </pre>
  Say I’m using <code>match</code> defining my transformation for the top level and want to recurse on optional <code>children</code>.</z><z id="t1614183074" t="Jimmy Miller For tree structures it really depends on what you are trying to do more concretely. Cata is a super useful tool here (think of it like the recur of meander). (m/rewrite {:name &quot;jimmy&quot; :id 11 :age 29 :children [{:name &quot;lemon&quot; :age 4 :type :dog}]} {:name ?name :children (m/some ?children)} {:name ?name :kids (m/cata ?children)} {:name ?name} {:name ?name} [!xs ...] [(m/cata !xs) ...]) ;; =&gt; {:name &quot;jimmy&quot;, :kids [{:name &quot;lemon&quot;}]} (m/rewrite {:name &quot;jimmy&quot; :id 11 :age 29 :children [{:name &quot;lemon&quot; :age 4 :type :dog}]} {:name !names :children (m/or [(m/cata [!names ...]) ...] nil)} [!names ...]) ;; =&gt; [&quot;jimmy&quot; &quot;lemon&quot;] Strategies are also useful. WIth can help. But also don’t be afraid to just start with a clojure.walk and add meander into that."><y>#</y><d>2021-02-24</d><h>16:11</h><r>Jimmy Miller</r>For tree structures it really depends on what you are trying to do more concretely. Cata is a super useful tool here (think of it like the recur of meander).

<pre>(m/rewrite 
  {:name &quot;jimmy&quot;
   :id 11
   :age 29
   :children [{:name &quot;lemon&quot; :age 4 :type :dog}]}

  
  {:name ?name
   :children (m/some ?children)}

  {:name ?name
   :kids (m/cata ?children)}

  {:name ?name}
  {:name ?name}

  [!xs ...]
  [(m/cata !xs) ...])

;; =&gt; {:name &quot;jimmy&quot;, :kids [{:name &quot;lemon&quot;}]}



(m/rewrite 
  {:name &quot;jimmy&quot;
   :id 11
   :age 29
   :children [{:name &quot;lemon&quot; :age 4 :type :dog}]}

  {:name !names
   :children (m/or [(m/cata [!names ...]) ...] nil)}
  [!names ...])

;; =&gt; [&quot;jimmy&quot; &quot;lemon&quot;]</pre>
Strategies are also useful. WIth can help. But also don’t be afraid to just start with a clojure.walk and add meander into that.</z><z id="t1614184635" t="prnc Nice! thanks! I was looking at cata but wasn’t sure cause it feels that I need to specify the case for with children and without children separately? Even though it’s the same case i.e. they would have everything in common except for that one thing (missing/optional :children key), so I would be repeating “the same” transformation twice? Not sure if this description makes sense to you, need to dive deeper into the lingo around this, to ask better questions 😜"><y>#</y><d>2021-02-24</d><h>16:37</h><r>prnc</r>Nice! thanks! I was looking at <code>cata</code> but wasn’t sure cause it feels that I need to specify the case for with children and without children separately? Even though it’s the same case i.e. they would have everything in common except for that one thing (missing/optional :children key), so I would be repeating “the same” transformation twice? Not sure if this description makes sense to you, need to dive deeper into the lingo around this, to ask better questions <b>😜</b></z><z id="t1614184789" t="Jimmy Miller Yeah, sometimes you have to repeat the same transformation twice. Sometimes you can use or. You can also pull out some of that using with if it becomes too repetitive. But in general, we have found being explicit in handling those cases separately can be nice."><y>#</y><d>2021-02-24</d><h>16:39</h><r>Jimmy Miller</r>Yeah, sometimes you have to repeat the same transformation twice. Sometimes you can use or. You can also pull out some of that using <code>with</code> if it becomes too repetitive. But in general, we have found being explicit in handling those cases separately can be nice.</z><z id="t1614185008" t="prnc alright! thanks again 🙂 need to play around a bit more to potentially come back with more (better) questions 🙂"><y>#</y><d>2021-02-24</d><h>16:43</h><r>prnc</r>alright! thanks again <b>🙂</b> need to play around a bit more to potentially come back with more (better) questions <b>🙂</b></z><z id="t1614182058" t="prnc also is using memory variables making keys in a map non-optional? as in (playing w/ twitter api) … (m/match tweet {::id ?id ::author-id ?aid ::text ?text ::entities {::mentions [!ms ...] ::annotations [!as ...]}} &lt;do stuff&gt;) if some of the tweets don’t have entities they won’t match?"><y>#</y><d>2021-02-24</d><h>15:54</h><w>prnc</w>also is using memory variables making keys in a map non-optional? as in (playing w/ twitter api) …
<pre>(m/match tweet
     {::id ?id
      ::author-id ?aid
      ::text ?text
      ::entities {::mentions    [!ms ...]
                  ::annotations [!as ...]}}
&lt;do stuff&gt;)</pre>
if some of the tweets don’t have entities they won’t match?</z><z id="t1614183129" t="Jimmy Miller Keys in maps are always non-optional. (I am voting to change this behavior in zeta). But you can make them required by doing (m/some ?id) ."><y>#</y><d>2021-02-24</d><h>16:12</h><r>Jimmy Miller</r>Keys in maps are always non-optional. (I am voting to change this behavior in zeta). But you can make them required by doing <code>(m/some ?id)</code>.</z><z id="t1614183353" t="prnc Thanks! So there is for example no way for the pattern above to match both tweets with ::entities and with them?"><y>#</y><d>2021-02-24</d><h>16:15</h><r>prnc</r>Thanks! So there is for example no way for the pattern above to match both tweets with <code>::entities</code> and with them?</z><z id="t1614183379" t="prnc The behaviour seems to be different between: (m/match {:foo &apos;bar} {:foo ?f :this [!t ...]} {:f ?f :t !t}) (m/match {:foo &apos;bar} {:foo ?f :this ?t} {:f ?f :t ?t}) "><y>#</y><d>2021-02-24</d><h>16:16</h><r>prnc</r>The behaviour seems to be different between:
<pre>(m/match {:foo &apos;bar}
    {:foo ?f
     :this [!t ...]}
    {:f ?f
     :t !t})

  (m/match {:foo &apos;bar}
    {:foo ?f
     :this ?t}
    {:f ?f
     :t ?t})</pre>
</z><z id="t1614183418" t="prnc first snippet with memory variable !t throws: non exhaustive…"><y>#</y><d>2021-02-24</d><h>16:16</h><r>prnc</r>first snippet with memory variable <code>!t</code> throws: <code>non exhaustive…</code></z><z id="t1614183436" t="prnc second returns {:f bar, :t nil}"><y>#</y><d>2021-02-24</d><h>16:17</h><r>prnc</r>second returns <code>{:f bar, :t nil}</code></z><z id="t1614184266" t="prnc looks like I can just use m/or here? (m/match {:foo &apos;bar} {:foo ?f :this (m/or [!t ...] nil)} {:f ?f :t !t})"><y>#</y><d>2021-02-24</d><h>16:31</h><r>prnc</r>looks like I can just use <code>m/or</code>  here?
<pre>(m/match {:foo &apos;bar}
    {:foo ?f
     :this (m/or [!t ...] nil)}
    {:f ?f
     :t !t})</pre></z><z id="t1614184275" t="prnc nice thanks!"><y>#</y><d>2021-02-24</d><h>16:31</h><r>prnc</r>nice thanks!</z><z id="t1614184577" t="Jimmy Miller Yep, or is the answer"><y>#</y><d>2021-02-24</d><h>16:36</h><r>Jimmy Miller</r>Yep, or is the answer</z><z id="t1614202936" t="phronmophobic I&apos;m using meander for the first time and it&apos;s working great 😄 . Most things have been pretty straightforward, but there&apos;s one example where I was wondering if there was a more idiomatic approach. I&apos;m parsing a hairy xml response that essentially returns an unordered list of tagged elements. I&apos;m using m/app to turn the list into a map so that I can grab any subset of items that match. Is there a better way? Simplified example below: (m/find [{:type :foo :a 1} {:type :baz :c 3} {:type :bar :b 2} ] (m/app #(zipmap (range) %) {_c {:type :baz :c ?c} _a {:type :foo :a ?a} _b {:type :bar :b ?b} }) [?a ?b ?c]) ;; [1 2 3]"><y>#</y><d>2021-02-24</d><h>21:42</h><w>phronmophobic</w>I&apos;m using meander for the first time and it&apos;s working great <b>😄</b>. Most things have been pretty straightforward, but there&apos;s one example where I was wondering if there was a more idiomatic approach.

I&apos;m parsing a hairy xml response that essentially returns an unordered list of tagged elements. I&apos;m using <code>m/app</code> to turn the list into a map so that I can grab any subset of items that match. Is there a better way?
Simplified example below:

<pre>(m/find [{:type :foo
          :a 1}
         {:type :baz
          :c 3}
         {:type :bar
          :b 2}
         ]
  (m/app #(zipmap (range) %)
         {_c {:type :baz
              :c ?c}
          _a {:type :foo
              :a ?a}
          _b {:type :bar
              :b ?b}
          })
  [?a ?b ?c])
;; [1 2 3]</pre></z><z id="t1614205560" t="noprompt You could also try (m/app set #{{:type :baz, :c ?c} {:type :foo, :a ?a} {:type :bar, :b ?b}}) "><y>#</y><d>2021-02-24</d><h>22:26</h><r>noprompt</r>You could also try
<pre>(m/app set
  #{{:type :baz, :c ?c}
    {:type :foo, :a ?a}
    {:type :bar, :b ?b}})</pre>
</z><z id="t1614206010" t="phronmophobic ok, that works"><y>#</y><d>2021-02-24</d><h>22:33</h><r>phronmophobic</r>ok, that works</z><z id="t1614206095" t="noprompt LMK if you run into any problems."><y>#</y><d>2021-02-24</d><h>22:34</h><r>noprompt</r>LMK if you run into any problems.</z><z id="t1614209552" t="noprompt https://clojars.org/meander/epsilon"><y>#</y><d>2021-02-24</d><h>23:32</h><w>noprompt</w><a href="https://clojars.org/meander/epsilon" target="_blank">https://clojars.org/meander/epsilon</a></z><z id="t1614209561" t="noprompt New release available folks."><y>#</y><d>2021-02-24</d><h>23:32</h><w>noprompt</w>New release available folks.</z><z id="t1614209655" t="noprompt This one fixes a compilation bug where qualified symbols were being used for let bindings (thanks [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] ) and another one with map compilation (thanks [:attrs {:href &quot;/_/_/users/UHKNWKY57&quot;}] and [:attrs {:href &quot;/_/_/users/U06B55FV2&quot;}] for the report)."><y>#</y><d>2021-02-24</d><h>23:34</h><w>noprompt</w>This one fixes a compilation bug where qualified symbols were being used for let bindings (thanks <a>@jimmy</a>) and another one with map compilation (thanks <a>@ericgierach</a> and <a>@mdp</a> for the report).</z><z id="t1614215394" t="phronmophobic I keep wanting to write patterns with different sets of unbound logic variables in m/or statements. Is that an anti pattern? Is there a workaround? My previous example was one of those cases, but another is similar to core.match: (let [v [[1 2]]] (match [v] [[[3 1]]] :a0 [[([1 a] :as b)]] [:a1 a b])) ;=&gt; [:a1 2 [1 2]]"><y>#</y><d>2021-02-25</d><h>01:09</h><w>phronmophobic</w>I keep wanting to write patterns with different sets of unbound logic variables in <code>m/or</code> statements. Is that an anti pattern? Is there a workaround? My previous example was one of those cases, but another is similar to core.match:
<pre>(let [v [[1 2]]]
  (match [v]
    [[[3 1]]] :a0
    [[([1 a] :as b)]] [:a1 a b]))
;=&gt; [:a1 2 [1 2]]</pre></z><z id="t1614215511" t="phronmophobic Does meander expose a way to detect unbound logic variables in a pattern? If so, I could also write a macro that finds the superset of logic variables for each pattern and wraps each pattern with (m/let [v1? nil v2? nil] so that each pattern has the same set of unbound logic variables"><y>#</y><d>2021-02-25</d><h>01:11</h><w>phronmophobic</w>Does meander expose a way to detect unbound logic variables in a pattern? If so, I could also write a macro that finds the superset of logic variables for each pattern and wraps each pattern with <code>(m/let [v1? nil v2? nil]</code>   so that each pattern has the same set of unbound logic variables</z><z id="t1614216628" t="Carlo I&apos;m also very interested in having disjoint sets of logical variables in a m/or clause, or at least understanding better why that&apos;s not possible"><y>#</y><d>2021-02-25</d><h>01:30</h><r>Carlo</r>I&apos;m also very interested in having disjoint sets of logical variables in a m/or clause, or at least understanding better why that&apos;s not possible</z><z id="t1614218148" t="phronmophobic this seems to work: (m/defsyntax mor [&amp; patterns] (let [vars (into [] (comp (map r.syntax/parse) (map r.syntax/logic-variables) (map #(map r.syntax/unparse %)) (map set)) patterns) all-vars (into #{} cat vars)] `(m/or ~@(for [[pvars pattern] (map vector vars patterns) :let [missing (clojure.set/difference all-vars pvars)]] (if (seq missing) (let [bindings (into [] cat (for [v missing] [v nil]))] `(m/let ~bindings ~pattern)) pattern))))) ;; usage (m/find {:b 2} (mor {:a (m/some ?a)} {:b (m/some ?b)}) [?a ?b]) ;; [nil 2] (m/find {:a &quot;A&quot;} (mor {:a (m/some ?a)} {:b (m/some ?b)}) [?a ?b]) ;; [&quot;A&quot; nil]"><y>#</y><d>2021-02-25</d><h>01:55</h><r>phronmophobic</r>this seems to work:
<pre>(m/defsyntax mor [&amp; patterns]
  (let [vars
        (into []
              (comp
               (map r.syntax/parse)
               (map r.syntax/logic-variables)
               (map #(map r.syntax/unparse %))
               (map set))
              patterns)
        all-vars (into #{} cat vars)]
    `(m/or
      ~@(for [[pvars pattern] (map vector vars patterns)
              :let [missing (clojure.set/difference all-vars pvars)]]
          (if (seq missing)
            (let [bindings
                  (into []
                        cat
                        (for [v missing]
                          [v nil]))]
              `(m/let ~bindings
                 ~pattern))
            pattern)))))

;; usage
(m/find
  {:b 2}
  (mor {:a (m/some ?a)}
       {:b (m/some ?b)})
  [?a ?b])
;; [nil 2]

(m/find
  {:a &quot;A&quot;}
  (mor {:a (m/some ?a)}
       {:b (m/some ?b)})
  [?a ?b])
;; [&quot;A&quot; nil]</pre></z><z id="t1614218170" t="phronmophobic not sure if this is a good idea or not"><y>#</y><d>2021-02-25</d><h>01:56</h><r>phronmophobic</r>not sure if this is a good idea or not</z><z id="t1614235885" t="noprompt The reason meander doesn’t allow for disjoint unbound logic variables in an or are for the following reasons: 1. For match , find , and search I don’t have an answer to the question “what do I bind these to?” Perhaps, a special unbound value? In other words, there is no semantic. There could be a semantic but I don’t know what it should be. In the case of rewrite I think relaxing this restriction is fine because a semantic can be defined for using an unbound logic variable on the right hand side: it fails. In fact, this is the semantic zeta will use where you can also use or on the right side making this actually useful. 2. Meander borrowed a lot of ideas from existing pattern matchers. Racket’s match is one of them and, in particular, I borrowed the or semantics from them."><y>#</y><d>2021-02-25</d><h>06:51</h><w>noprompt</w>The reason meander doesn’t allow for disjoint unbound logic variables in an <code>or</code> are for the following reasons:
1. For <code>match</code>, <code>find</code>, and <code>search</code> I don’t have an answer to the question “what do I bind these to?” Perhaps, a special <code>unbound</code> value? In other words, there is no semantic. There could be a semantic but I don’t know what it should be. In the case of <code>rewrite</code> I think relaxing this restriction is fine because a semantic can be defined for using an unbound logic variable on the right hand side: it fails. In fact, this is the semantic <code>zeta</code> will use where you can also use <code>or</code> on the right side making this actually useful.
2. Meander borrowed a lot of ideas from existing pattern matchers. Racket’s <code>match</code> is one of them and, in particular, I borrowed the <code>or</code> semantics from them.</z><z id="t1614236437" t="noprompt I wouldn’t say wanting different sets of unbound logic variables is an “anti pattern” but I surmise that the problem is with the data. If the model has lots of ambiguity in it, so will your code. Typically, I will try to eliminate the ambiguity prior to doing heavy transforms."><y>#</y><d>2021-02-25</d><h>07:00</h><w>noprompt</w>I wouldn’t say wanting different sets of unbound logic variables is an “anti pattern” but I surmise that the problem is with the data. If the model has lots of ambiguity in it, so will your code. Typically, I will try to eliminate the ambiguity prior to doing heavy transforms.</z><z id="t1614236801" t="noprompt I’m up for relaxing variable restrictions use or provided a semantics or an idea for an implementation. We can use meta on the macro forms as well to pass options. ^{::m/disjoint-variables {:unbound nil}} (m/find ,,,) "><y>#</y><d>2021-02-25</d><h>07:06</h><w>noprompt</w>I’m up for relaxing variable restrictions use <code>or</code> provided a semantics or an idea for an implementation. We can use meta on the macro forms as well to pass options.
<pre>^{::m/disjoint-variables {:unbound nil}} (m/find ,,,)</pre>
</z><z id="t1614236850" t="phronmophobic did you see the syntax I tried at https://clojurians.slack.com/archives/CFFTD7R6Z/p1614218148034200?thread_ts=1614215511.033800&amp;amp;cid=CFFTD7R6Z ?"><y>#</y><d>2021-02-25</d><h>07:07</h><w>phronmophobic</w>did you see the syntax I tried at <a href="https://clojurians.slack.com/archives/CFFTD7R6Z/p1614218148034200?thread_ts=1614215511.033800&amp;amp;cid=CFFTD7R6Z" target="_blank">https://clojurians.slack.com/archives/CFFTD7R6Z/p1614218148034200?thread_ts=1614215511.033800&amp;amp;cid=CFFTD7R6Z</a> ?</z><z id="t1614236850" t="noprompt But I won’t automatically default to nil myself because I think that’s rude. 🙂"><y>#</y><d>2021-02-25</d><h>07:07</h><w>noprompt</w>But I won’t automatically default to <code>nil</code> myself because I think that’s rude. <b>🙂</b></z><z id="t1614236870" t="noprompt Yes, I saw that. This topic has come up before."><y>#</y><d>2021-02-25</d><h>07:07</h><w>noprompt</w>Yes, I saw that. This topic has come up before.</z><z id="t1614236882" t="phronmophobic yea, totally makes sense for the default to disallow it"><y>#</y><d>2021-02-25</d><h>07:08</h><w>phronmophobic</w>yea, totally makes sense for the default to disallow it</z><z id="t1614236926" t="phronmophobic In my case, I&apos;m using it to extract data from an API, so I can&apos;t really change the API"><y>#</y><d>2021-02-25</d><h>07:08</h><w>phronmophobic</w>In my case, I&apos;m using it to extract data from an API, so I can&apos;t really change the API</z><z id="t1614236958" t="phronmophobic It&apos;s possible that I&apos;m missing using meander and should be using something like core.match"><y>#</y><d>2021-02-25</d><h>07:09</h><w>phronmophobic</w>It&apos;s possible that I&apos;m missing using meander and should be using something like core.match</z><z id="t1614236965" t="noprompt Ah, yeah, many APIs have this great feature “optional data”. Its really cool…"><y>#</y><d>2021-02-25</d><h>07:09</h><w>noprompt</w>Ah, yeah, many APIs have this great feature “optional data”. Its really cool…</z><z id="t1614237023" t="noprompt You’re not misusing the library."><y>#</y><d>2021-02-25</d><h>07:10</h><w>noprompt</w>You’re not misusing the library.</z><z id="t1614237070" t="noprompt One of the reasons I started this project was because I did not like core.match ."><y>#</y><d>2021-02-25</d><h>07:11</h><w>noprompt</w>One of the reasons I started this project was because I did not like <code>core.match</code>.</z><z id="t1614237127" t="noprompt Let’s solve this problem. There’s at least 2 other people that want a solution."><y>#</y><d>2021-02-25</d><h>07:12</h><w>noprompt</w>Let’s solve this problem. There’s at least 2 other people that want a solution.</z><z id="t1614237186" t="phronmophobic more or less, I&apos;m trying to find a way to idiomatically deal width a values like results where either you have 1. a success, something like {:type result :val {:a :some-value}} 2. a failure, something like {:type :err :msg &quot;You&apos;re did it wrong!&quot;}"><y>#</y><d>2021-02-25</d><h>07:13</h><w>phronmophobic</w>more or less, I&apos;m trying to find a way to idiomatically deal width a values like results where either you have
1. a success, something like <code>{:type result :val {:a :some-value}}</code>
2. a failure, something like <code>{:type :err :msg &quot;You&apos;re did it wrong!&quot;}</code></z><z id="t1614237233" t="noprompt My best shot is enabling this via meta data on the form. It is probably the easiest to achieve (for me) without spending too much time. You’re new here but I’ve really been trying to focus on zeta , only fixing bugs, etc."><y>#</y><d>2021-02-25</d><h>07:13</h><w>noprompt</w>My best shot is enabling this via meta data on the form. It is probably the easiest to achieve (for me) without spending too much time. You’re new here but I’ve really been trying to focus on <code>zeta</code> , only fixing bugs, etc.</z><z id="t1614237244" t="phronmophobic or some equivalent to https://clojure.org/guides/spec#_multi_spec"><y>#</y><d>2021-02-25</d><h>07:14</h><w>phronmophobic</w>or some equivalent to <a href="https://clojure.org/guides/spec#_multi_spec" target="_blank">https://clojure.org/guides/spec#_multi_spec</a></z><z id="t1614237293" t="noprompt Is there something off putting about having two clauses?"><y>#</y><d>2021-02-25</d><h>07:14</h><w>noprompt</w>Is there something off putting about having two clauses?</z><z id="t1614237343" t="noprompt (m/match M {:type :result ,,,} A {:type :err ,,,} B) "><y>#</y><d>2021-02-25</d><h>07:15</h><w>noprompt</w><pre>(m/match M
  {:type :result ,,,}
  A

  {:type :err ,,,}
  B)</pre>
</z><z id="t1614237367" t="noprompt I’m guessing theres more to the story?"><y>#</y><d>2021-02-25</d><h>07:16</h><w>noprompt</w>I’m guessing theres more to the story?</z><z id="t1614237438" t="phronmophobic well, in my case, the return value is surrounded by a bunch of boilerplate that I&apos;m also extracting values from, but it&apos;s easy enough to split it up into two matches (ie. two steps)"><y>#</y><d>2021-02-25</d><h>07:17</h><w>phronmophobic</w>well, in my case, the return value is surrounded by a bunch of boilerplate that I&apos;m also extracting values from, but it&apos;s easy enough to split it up into two matches (ie. two steps)</z><z id="t1614237494" t="phronmophobic My use case is currently already solved well by meander, I was just wondering if there was an already existing approach that was more idiomatic"><y>#</y><d>2021-02-25</d><h>07:18</h><w>phronmophobic</w>My use case is currently already solved well by meander, I was just wondering if there was an already existing approach that was more idiomatic</z><z id="t1614237523" t="noprompt FWIW another “trick” you can apply is to grab all the other stuff as usual and process the inner stuff with m/cata ."><y>#</y><d>2021-02-25</d><h>07:18</h><w>noprompt</w>FWIW another “trick” you can apply is to grab all the other stuff as usual and process the inner stuff with <code>m/cata</code>.</z><z id="t1614237585" t="noprompt {:other ?stuff :around {:in ?here} :random-junk [(m/cata !xs) ...] {:stuff ?stuff, :here ?here, :no-longer-junk !xs} "><y>#</y><d>2021-02-25</d><h>07:19</h><w>noprompt</w><pre>{:other ?stuff
 :around {:in ?here}
 :random-junk [(m/cata !xs) ...]
{:stuff ?stuff, :here ?here, :no-longer-junk !xs}</pre>
</z><z id="t1614237633" t="noprompt m/cata is like recur but over the whole system and how you transform nested stuff using the same set of rules."><y>#</y><d>2021-02-25</d><h>07:20</h><w>noprompt</w><code>m/cata</code> is like <code>recur</code> but over the whole system and how you transform nested stuff using the same set of rules.</z><z id="t1614237689" t="phronmophobic very cool. I&apos;ve been using meander to extract data from some verbose xml and it&apos;s been great."><y>#</y><d>2021-02-25</d><h>07:21</h><w>phronmophobic</w>very cool. I&apos;ve been using meander to extract data from some verbose xml and it&apos;s been great.</z><z id="t1614237713" t="phronmophobic Once I figured out how to match on unordered lists, it worked like a charm"><y>#</y><d>2021-02-25</d><h>07:21</h><w>phronmophobic</w>Once I figured out how to match on unordered lists, it worked like a charm</z><z id="t1614237768" t="phronmophobic the question about m/or is because now I just want to use meander to improve other parts of the code"><y>#</y><d>2021-02-25</d><h>07:22</h><w>phronmophobic</w>the question about <code>m/or</code> is because now I just want to use meander to improve other parts of the code</z><z id="t1614237798" t="noprompt Take a look at m/cata . I think there’s some documentation that explains it. It can be very effective at solving icky problems like these. Also, I think would like to make people happy and solve the disjoint variable problem. If the meta thing will work, I’ll make a patch soon. If there’s a better idea, I’m open to it."><y>#</y><d>2021-02-25</d><h>07:23</h><w>noprompt</w>Take a look at <code>m/cata</code>. I think there’s some documentation that explains it. It can be very effective at solving icky problems like these.

Also, I think would like to make people happy and solve the disjoint variable problem. If the meta thing will work, I’ll make a patch soon. If there’s a better idea, I’m open to it.</z><z id="t1614237836" t="noprompt I’m glad you’re enjoying it and it is helping you. 🙂"><y>#</y><d>2021-02-25</d><h>07:23</h><w>noprompt</w>I’m glad you’re enjoying it and it is helping you. <b>🙂</b></z><z id="t1614237917" t="noprompt I do need to sign off for the night but I’m down to chat more about this tomorrow; get input from others."><y>#</y><d>2021-02-25</d><h>07:25</h><w>noprompt</w>I do need to sign off for the night but I’m down to chat more about this tomorrow; get input from others.</z><z id="t1614237940" t="phronmophobic Thanks for your help. Have a great night!"><y>#</y><d>2021-02-25</d><h>07:25</h><w>phronmophobic</w>Thanks for your help. Have a great night!</z><z id="t1614237952" t="noprompt Likewise!"><y>#</y><d>2021-02-25</d><h>07:25</h><w>noprompt</w>Likewise!</z><z id="t1615140291" t="markaddleman I&apos;m trying epsilon interpreter for the first time. I&apos;m trying to create a searcher function that mimics the behavior of the m/search expression. What am I doing wrong?"><y>#</y><d>2021-03-07</d><h>18:04</h><w>markaddleman</w>I&apos;m trying epsilon interpreter for the first time.  I&apos;m trying to create a searcher function that mimics the behavior of the <code>m/search</code> expression.  What am I doing wrong?</z><z id="t1615140620" t="markaddleman After doing a bit of source spelunking... Is scan not supported in interpreter?"><y>#</y><d>2021-03-07</d><h>18:10</h><r>markaddleman</r>After doing a bit of source spelunking...  Is <code>scan</code> not supported in interpreter?</z><z id="t1615141483" t="ribelo you should use the functions available in ns meander.epsilon.interpreter not meander.epsilon"><y>#</y><d>2021-03-07</d><h>18:24</h><r>ribelo</r>you should use the functions available in ns <code>meander.epsilon.interpreter</code> not <code>meander.epsilon</code></z><z id="t1615141522" t="ribelo here is the declaration https://github.com/noprompt/meander/blob/epsilon/src/meander/interpreter/epsilon.cljc#L10"><y>#</y><d>2021-03-07</d><h>18:25</h><r>ribelo</r>here is the declaration
<a href="https://github.com/noprompt/meander/blob/epsilon/src/meander/interpreter/epsilon.cljc#L10" target="_blank">https://github.com/noprompt/meander/blob/epsilon/src/meander/interpreter/epsilon.cljc#L10</a></z><z id="t1615141622" t="ribelo i would also recommend looking at the test file"><y>#</y><d>2021-03-07</d><h>18:27</h><r>ribelo</r>i would also recommend looking at the test file</z><z id="t1615141627" t="ribelo https://github.com/noprompt/meander/blob/epsilon/test/meander/interpreter/epsilon_test.cljc"><y>#</y><d>2021-03-07</d><h>18:27</h><r>ribelo</r><a href="https://github.com/noprompt/meander/blob/epsilon/test/meander/interpreter/epsilon_test.cljc" target="_blank">https://github.com/noprompt/meander/blob/epsilon/test/meander/interpreter/epsilon_test.cljc</a></z><z id="t1615141682" t="ribelo meander develops faster than the documentation is completed"><y>#</y><d>2021-03-07</d><h>18:28</h><r>ribelo</r>meander develops faster than the documentation is completed</z><z id="t1615141714" t="ribelo but the tests are always up to date and cover 100% of what the meander can do"><y>#</y><d>2021-03-07</d><h>18:28</h><r>ribelo</r>but the tests are always up to date and cover 100% of what the meander can do</z><z id="t1615143230" t="Jimmy Miller So I’m not sure I’d go as far as to say that the tests cover 100%. We try our best, but testing and documentation are definitely lacking. There are a few things going on here. First the second argument to searcher is actually function that receives an environment. So you probably want rewriter. ((mi/rewriter &apos;[_ ... ?a . _ ...] &apos;?a) [1]) Second, it looks like scan is having an issue. Seems that pred is the root cause. I think I have a fix for it, but the area I know the least in meander, so will have to check with joel before I commit anything. Hopefully can get the fix up on github today."><y>#</y><d>2021-03-07</d><h>18:53</h><r>Jimmy Miller</r>So I’m not sure I’d go as far as to say that the tests cover 100%. We try our best, but testing and documentation are definitely lacking.

There are a few things going on here.

First the second argument to searcher is actually function that receives an environment. So you probably want rewriter.

<pre>((mi/rewriter &apos;[_ ... ?a . _ ...] &apos;?a) [1])</pre>
Second, it looks like <code>scan</code> is having an issue. Seems that <code>pred</code> is the root cause. I think I have a fix for it, but the area I know the least in meander, so will have to check with joel before I commit anything.

Hopefully can get the fix up on github today.</z><z id="t1615212460" t="Jimmy Miller Didn&apos;t get a chance to meet up with Joel on this. Will make what I think is the fix today and put a PR out."><y>#</y><d>2021-03-08</d><h>14:07</h><r>Jimmy Miller</r>Didn&apos;t get a chance to meet up with Joel on this. Will make what I think is the fix today and put a PR out.</z><z id="t1615230444" t="markaddleman Thanks!"><y>#</y><d>2021-03-08</d><h>19:07</h><r>markaddleman</r>Thanks!</z><z id="t1615265000" t="Jimmy Miller Pushed up the fix. Should work in the next release."><y>#</y><d>2021-03-09</d><h>04:43</h><r>Jimmy Miller</r>Pushed up the fix. Should work in the next release.</z><z id="t1615291086" t="markaddleman Thanks!"><y>#</y><d>2021-03-09</d><h>11:58</h><r>markaddleman</r>Thanks!</z><z id="t1615300750" t="markaddleman Thanks!"><y>#</y><d>2021-03-09</d><h>14:39</h><r>markaddleman</r>Thanks!</z><z id="t1615212422" t="jjttjj Hi I&apos;m trying to implement an advanced &quot;pub/sub&quot; for core.async. I have an incoming stream of data. I&apos;d like to be able to subscribe to &quot;queries&quot;. Basically, for each message that comes in, check which of the registered subscriptions matches. But I&apos;d like it to be done efficiently, so if multiple subscriptions share a match condition, this would only be applied once to the incoming message. I have an almost working example here: https://gist.github.com/jjttjj/ad9c6355d8b6741b43f23e90c7c77442 But I&apos;m wondering if I could use meander here, though I haven&apos;t fully wrapped my head around how that would look. (sub pub {:venue ?venue :type (me/or :done :open) :price (me/pred #(&lt; % 100000) ?price)} ch) if I have something like this, is there a way to compile that data such that i just get a set of all bindings and match conditions in a way that they can be appended to a larger set of match conditions? And then apply the whole set of conditions to some incoming data, and then get back a set of matching conditions that could be compared for equality to the conditions in the &quot;subscription&quot; match query?"><y>#</y><d>2021-03-08</d><h>14:07</h><w>jjttjj</w>Hi
I&apos;m trying to implement an advanced &quot;pub/sub&quot; for core.async.
I have an incoming stream of data.
I&apos;d like to be able to subscribe to &quot;queries&quot;. Basically, for each message that comes in, check which of the registered subscriptions matches. But I&apos;d like it to be done efficiently, so if multiple subscriptions share a match condition, this would only be applied once to the incoming message.
I have an almost working example here: <a href="https://gist.github.com/jjttjj/ad9c6355d8b6741b43f23e90c7c77442" target="_blank">https://gist.github.com/jjttjj/ad9c6355d8b6741b43f23e90c7c77442</a>
But I&apos;m wondering if I could use meander here, though I haven&apos;t fully wrapped my head around how that would look.
<pre>(sub pub
  {:venue ?venue
   :type (me/or :done :open)
   :price (me/pred #(&lt; % 100000) ?price)}
  ch)</pre>
if I have something like this, is there a way to compile that data such that i just get a set of all bindings and match conditions in a way that they can be appended to a larger set of match conditions? And then apply the whole set of conditions to some incoming data, and then get back a set of matching conditions that could be compared for equality to the conditions in the &quot;subscription&quot; match query?</z><z id="t1615221204" t="jjttjj After learning a bit more meander, I think a more direct question might just be, is it possible to m/search based from a map of pattern-&gt;clauses? (def pattern-&gt;clause (atom {})) (swap! pattern-&gt;clause assoc &apos;[?x 1] :x) (swap! pattern-&gt;clause assoc &apos;{:a ?a} &apos;?a) Then do something like: (let [x (mapcat identity @pattern-&gt;id)] (eval `(me/search {:a 1} ~@x))) ~which currently doesn&apos;t seem to be working~ edit: ok this does work sometimes, maybe not with dynamic clauses?"><y>#</y><d>2021-03-08</d><h>16:33</h><r>jjttjj</r>After learning a bit more meander, I think a more direct question might just be, is it possible to <code>m/search</code> based from a map of pattern-&gt;clauses?
<pre>(def pattern-&gt;clause (atom {}))
(swap! pattern-&gt;clause assoc &apos;[?x 1] :x)
(swap! pattern-&gt;clause assoc &apos;{:a ?a} &apos;?a)</pre>
Then do something like:
<pre>(let [x (mapcat identity @pattern-&gt;id)]
  (eval `(me/search
           {:a 1}
           ~@x)))</pre>
~which currently doesn&apos;t seem to be working~ edit: ok this does work sometimes, maybe not with dynamic clauses?</z><z id="t1615222870" t="Jimmy Miller So I didn’t get to process all of this yet. For dynamic things we just started exposing an interpreter. But It is definitely not something we have focused on for performance. And it is no where near as battle tested as the non-interpreted version."><y>#</y><d>2021-03-08</d><h>17:01</h><r>Jimmy Miller</r>So I didn’t get to process all of this yet. For dynamic things we just started exposing an interpreter. But It is definitely not something we have focused on for performance. And it is no where near as battle tested as the non-interpreted version.</z><z id="t1615222945" t="Jimmy Miller In fact, I just pushed up a fix for pred that someone discovered. If you are looking for efficiency as your primary attribute, I’m not sure it if is the right answer for you. But also, if you are looking for efficiency, you might want to think about how dynamic you want to be."><y>#</y><d>2021-03-08</d><h>17:02</h><r>Jimmy Miller</r>In fact, I just pushed up a fix for pred that someone discovered. If you are looking for efficiency as your primary attribute, I’m not sure it if is the right answer for you. But also, if you are looking for efficiency, you might want to think about how dynamic you want to be.</z><z id="t1615223099" t="jjttjj Thanks! I&apos;ll look into the interpreter stuff a bit. And I still have a bit more thinking about my problem to do, and learning how meander works."><y>#</y><d>2021-03-08</d><h>17:04</h><r>jjttjj</r>Thanks! I&apos;ll look into the interpreter stuff a bit. And I still have a bit more thinking about my problem to do, and learning how meander works.</z><z id="t1615214533" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] Could any of you explain why you need an iterator function in meander, here: https://ask.clojure.org/index.php/10303/interop-clojure-pattern-clojure-consider-adding-iter-clojure?show=10305#a10305 I&apos;m trying to convince that clojure.core should expose an iter function like CLJS does."><y>#</y><d>2021-03-08</d><h>14:42</h><w>borkdude</w><a>@noprompt</a> <a>@jimmy</a> Could any of you explain why you need an <code>iterator</code> function in meander, here:

<a href="https://ask.clojure.org/index.php/10303/interop-clojure-pattern-clojure-consider-adding-iter-clojure?show=10305#a10305" target="_blank">https://ask.clojure.org/index.php/10303/interop-clojure-pattern-clojure-consider-adding-iter-clojure?show=10305#a10305</a>

I&apos;m trying to convince that clojure.core should expose an <code>iter</code> function like CLJS does.</z><z id="t1615220821" t="noprompt Its used for memory variables. Two things: 1. I don’t like this 🙂 2. I think Clojure should expose iter as CLJS does. 🙂"><y>#</y><d>2021-03-08</d><h>16:27</h><r>noprompt</r>Its used for memory variables. Two things:
1. I don’t like this <b>🙂</b>
2. I think Clojure should expose <code>iter</code> as CLJS does. <b>🙂</b></z><z id="t1615222105" t="borkdude Can you explain in the issue to Alex Miller instead of me? He is the one that needs this data"><y>#</y><d>2021-03-08</d><h>16:48</h><r>borkdude</r>Can you explain in the issue to Alex Miller instead of me? He is the one that needs this data</z><z id="t1615223043" t="Jimmy Miller If [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] can’t find the time, I will try to explain. Though I will have to learn why myself 🙂 . Any advice on the angle to explain it? I can’t imagine the core team will found the meander case very compelling. I’d imagine they would just suggest not doing it the way we do it."><y>#</y><d>2021-03-08</d><h>17:04</h><r>Jimmy Miller</r>If <a>@noprompt</a> can’t find the time, I will try to explain. Though I will have to learn why myself <b>🙂</b>. Any advice on the angle to explain it? I can’t imagine the core team will found the meander case very compelling. I’d imagine they would just suggest not doing it the way we do it.</z><z id="t1615223271" t="borkdude My angle is: not have to include clojure.lang.RT in babashka but still enable people to use meander in babashka"><y>#</y><d>2021-03-08</d><h>17:07</h><r>borkdude</r>My angle is: not have to include clojure.lang.RT in babashka but still enable people to use meander in babashka</z><z id="t1615223277" t="noprompt &gt; I can’t imagine the core team will found the meander case very compelling. I’d imagine they would just suggest not doing it the way we do it. I agree and, on top of that, I don’t even want to be using iterator this way."><y>#</y><d>2021-03-08</d><h>17:07</h><r>noprompt</r>&gt; I can’t imagine the core team will found the meander case very compelling. I’d imagine they would just suggest not doing it the way we do it.
I agree and, on top of that, I don’t even want to be using iterator this way.</z><z id="t1615223307" t="borkdude In meander this got fixed, but now I came across the same issue with pathom(3)"><y>#</y><d>2021-03-08</d><h>17:08</h><r>borkdude</r>In meander this got fixed, but now I came across the same issue with pathom(3)</z><z id="t1615223389" t="noprompt There is a larger problem though in that Clojure and ClojureScript have no core library “standard” of any kind between the two of them."><y>#</y><d>2021-03-08</d><h>17:09</h><r>noprompt</r>There is a larger problem though in that Clojure and ClojureScript have no core library “standard” of any kind between the two of them.</z><z id="t1615223402" t="noprompt “Not very clojure-ry” is a really poor argument."><y>#</y><d>2021-03-08</d><h>17:10</h><r>noprompt</r>“Not very clojure-ry” is a really poor argument.</z><z id="t1615223422" t="borkdude agreed"><y>#</y><d>2021-03-08</d><h>17:10</h><r>borkdude</r>agreed</z><z id="t1615223469" t="noprompt &gt; They are stateful and generally not concurrency friendly. However, neither are arrays and yet make-array , etc."><y>#</y><d>2021-03-08</d><h>17:11</h><r>noprompt</r>&gt;  They are stateful and generally not concurrency friendly.
However, neither are arrays and yet <code>make-array</code>, etc.</z><z id="t1615223503" t="borkdude The same argument was given for index-of : this will force a linear scan. Yes, so will filter ..."><y>#</y><d>2021-03-08</d><h>17:11</h><r>borkdude</r>The same argument was given for <code>index-of</code>: this will force a linear scan. Yes, so will <code>filter</code> ...</z><z id="t1615223590" t="noprompt And I have wanted index-of myself ( https://github.com/noprompt/meander/blob/epsilon/src/meander/match/epsilon.cljc#L246 )"><y>#</y><d>2021-03-08</d><h>17:13</h><r>noprompt</r>And I have wanted <code>index-of</code> myself (<a href="https://github.com/noprompt/meander/blob/epsilon/src/meander/match/epsilon.cljc#L246" target="_blank">https://github.com/noprompt/meander/blob/epsilon/src/meander/match/epsilon.cljc#L246</a>)</z><z id="t1615223652" t="borkdude then please upvote and/or leave comment: https://ask.clojure.org/index.php/10295/consider-index-of-core-function-in-favor-of-interop-calls"><y>#</y><d>2021-03-08</d><h>17:14</h><r>borkdude</r>then please upvote and/or leave comment: <a href="https://ask.clojure.org/index.php/10295/consider-index-of-core-function-in-favor-of-interop-calls" target="_blank">https://ask.clojure.org/index.php/10295/consider-index-of-core-function-in-favor-of-interop-calls</a></z><z id="t1615223711" t="noprompt &gt; It’s not in core to promote better suited data types This is also a really shitty argument."><y>#</y><d>2021-03-08</d><h>17:15</h><r>noprompt</r>&gt; It’s not in core to promote better suited data types
This is also a really shitty argument.</z><z id="t1615223770" t="borkdude Maybe I should just release a babashka.utils lib that has all of this and you can also run it on the jvm ;)"><y>#</y><d>2021-03-08</d><h>17:16</h><r>borkdude</r>Maybe I should just release a babashka.utils lib that has all of this and you can also run it on the jvm ;)</z><z id="t1615223815" t="noprompt It, in fact, doesn’t address the actual argument which is “I have a vector and I don’t want to call .indexOf ; I would like cross platform support for this perfectly useful thing that exists that has these measurable performance characteristics.”"><y>#</y><d>2021-03-08</d><h>17:16</h><r>noprompt</r>It, in fact, doesn’t address the actual argument which is “I have a vector and I don’t want to call <code>.indexOf</code>; I would like cross platform support for this perfectly useful thing that exists that has these measurable performance characteristics.”</z><z id="t1615223961" t="borkdude https://clojurians.slack.com/archives/C07UQ678E/p1615223936083600"><y>#</y><d>2021-03-08</d><h>17:19</h><r>borkdude</r><a href="https://clojurians.slack.com/archives/C07UQ678E/p1615223936083600" target="_blank">https://clojurians.slack.com/archives/C07UQ678E/p1615223936083600</a></z><z id="t1615224530" t="noprompt Theres a history with CLJS being treated more as a dialect of CLJ rather than a CLJ for JS which has caused many of these problems. I think what has become clear over time is that host specific functions probably should be placed in their own namespace if there is ever going to be a day where core is platform agonistic."><y>#</y><d>2021-03-08</d><h>17:28</h><r>noprompt</r>Theres a history with CLJS being treated more as a dialect of CLJ rather than a CLJ for JS which has caused many of these problems. I think what has become clear over time is that host specific functions probably should be placed in their own namespace if there is ever going to be a day where core is platform agonistic.</z><z id="t1615224843" t="noprompt I think the argument for iter is that it is practical when you need to do interop which requires an iterable instance, is probably one of the best."><y>#</y><d>2021-03-08</d><h>17:34</h><r>noprompt</r>I think the argument for <code>iter</code> is that it is practical when you need to do interop which requires an iterable instance, is probably one of the best.</z><z id="t1615252412" t="noprompt [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] I replied about iter as diplomatically as possible. Mostly, I would like Alex to be clear for the sake of conversation. If he’s going to say it’s not a good idea to add iter but that the cases where iter has been implemented independently are “perfectly fine”, then I think he should also explain to the rest of the audience what criteria iter would need to meet such that it should be a core function."><y>#</y><d>2021-03-09</d><h>01:13</h><r>noprompt</r><a>@U04V15CAJ</a> I replied about <code>iter</code> as diplomatically as possible. Mostly, I would like Alex to be clear for the sake of conversation. If he’s going to say it’s not a good idea to add <code>iter</code> but that the cases where <code>iter</code> has been implemented independently are “perfectly fine”, then I think he should also explain to the rest of the audience what criteria <code>iter</code> would need to meet such that it should be a core function.</z><z id="t1616035995" t="Panel Is there a native way to avoid including a key in a map when the value would match nil ?"><y>#</y><d>2021-03-18</d><h>02:53</h><w>Panel</w>Is there a native way to avoid including a key in a map when the value would match nil ?</z><z id="t1616039645" t="Jimmy Miller Not exactly sure what you mean. Here’s how you can make sure that a value is non-nil. (m/match {:a 2} {:a (m/some ?a)} ?a) ;; =&gt; 2 (m/match {:b nil} {:a (m/some ?a) :b nil} ?a) ;; =&gt; non exhaustive pattern match"><y>#</y><d>2021-03-18</d><h>03:54</h><r>Jimmy Miller</r>Not exactly sure what you mean. Here’s how you can make sure that a value is non-nil.


<pre>(m/match {:a 2}
  {:a (m/some ?a)}

  ?a)

;; =&gt; 2

(m/match {:b nil}
  {:a (m/some ?a)
   :b nil}

  ?a)

;; =&gt;  non exhaustive pattern match</pre></z><z id="t1616039737" t="Jimmy Miller Did you want to do that or did you want to check for a key that is explicitly nil?"><y>#</y><d>2021-03-18</d><h>03:55</h><r>Jimmy Miller</r>Did you want to do that or did you want to check for a key that is explicitly nil?</z><z id="t1616039880" t="Jimmy Miller If so, I think the best I can think of is this. Maybe there is a better way? (m/match {:b nil} (m/and (m/pred #(contains? % :b)) {}) :yep)"><y>#</y><d>2021-03-18</d><h>03:58</h><r>Jimmy Miller</r>If so, I think the best I can think of is this. Maybe there is a better way?

<pre>(m/match {:b nil}
  (m/and
   (m/pred #(contains? % :b))
   {})

 :yep)</pre></z><z id="t1616039913" t="Jimmy Miller (If neither of these are right feel free to give some examples)"><y>#</y><d>2021-03-18</d><h>03:58</h><r>Jimmy Miller</r>(If neither of these are right feel free to give some examples)</z><z id="t1616043727" t="Panel Thanks for the answer (m/match{:a nil :b 2} {:a ?a :b ?b} {&quot;a&quot; ?a &quot;b&quot; ?b}) ;; =&gt; {&quot;a&quot; nil, &quot;b&quot; 2}"><y>#</y><d>2021-03-18</d><h>05:02</h><r>Panel</r>Thanks for the answer
(m/match{:a nil
          :b 2}
  {:a ?a
   :b ?b}
  {&quot;a&quot; ?a
   &quot;b&quot; ?b})
;; =&gt; {&quot;a&quot; nil, &quot;b&quot; 2}</z><z id="t1616043786" t="Panel What I&apos;m looking for is a way to instead return this : ;; =&gt; {&quot;b&quot; 2}"><y>#</y><d>2021-03-18</d><h>05:03</h><r>Panel</r>What I&apos;m looking for is a way to instead return this :
;; =&gt; {&quot;b&quot; 2}</z><z id="t1616043847" t="Panel I found this answer in the chat log: (m/search {:foo/a &quot;...&quot; :foo/b &quot;...&quot; :foo/optional nil } {:foo/a (m/pred string? ?value)} [:a ?value] {:foo/b (m/pred string? ?value)} [:b ?value] {:foo/optional (m/pred string? ?value)} [:optional ?value])"><y>#</y><d>2021-03-18</d><h>05:04</h><r>Panel</r>I found this answer in the chat log:
(m/search {:foo/a &quot;...&quot;
           :foo/b &quot;...&quot;
           :foo/optional nil }
  {:foo/a (m/pred string? ?value)}
  [:a ?value]

  {:foo/b (m/pred string? ?value)}
  [:b ?value]

  {:foo/optional (m/pred string? ?value)}
  [:optional ?value])</z><z id="t1616043886" t="Panel But then we are losing the idea of keeping the shape of the output data."><y>#</y><d>2021-03-18</d><h>05:04</h><r>Panel</r>But then we are losing the idea of keeping the shape of the output data.</z><z id="t1616083966" t="noprompt Are you searching for a submap m such that for all k (string? (get m k)) ?"><y>#</y><d>2021-03-18</d><h>16:12</h><r>noprompt</r>Are you searching for a submap <code>m</code> such that for all <code>k</code> <code>(string? (get m k))</code>?</z><z id="t1616084075" t="noprompt If so you can use (m/rewrite {,,,} (m/submap-of !key (m/pred string? !value)) (m/map-of !key !value)) "><y>#</y><d>2021-03-18</d><h>16:14</h><r>noprompt</r>If so you can use

<pre>(m/rewrite {,,,}
  (m/submap-of !key (m/pred string? !value))
  (m/map-of !key !value))</pre>
</z><z id="t1616107051" t="Panel For my use case the killer feature is realy to keep the shape of the data because I need to rename the keys . What I am after is a way to not include the key value in the output if the value is nil. (m/match {:a nil :b 2} {:a ?a :b ?b} {&quot;a&quot; ?a &quot;b&quot; ?b}) =&gt; {&quot;b&quot; 2}"><y>#</y><d>2021-03-18</d><h>22:37</h><r>Panel</r>For my use case the killer feature is realy to keep the shape of the data because I need to rename the keys .
What I am after is a way to not include the key value in the output if the value is nil.
<pre>(m/match
  {:a nil
   :b 2}
  {:a ?a
   :b ?b}
  {&quot;a&quot; ?a
   &quot;b&quot; ?b})
=&gt; {&quot;b&quot; 2}</pre></z><z id="t1616107260" t="Panel The key &quot;b&quot; was omitted from the output because ?b match a nil."><y>#</y><d>2021-03-18</d><h>22:41</h><r>Panel</r>The key &quot;b&quot; was omitted from the output because ?b match a nil.</z><z id="t1616107430" t="noprompt (fn f [m] (m/find m {(m/keyword ?name) (m/some ?x) &amp; ?rest} (merge {?name ?x} (f ?rest)) {_ _ &amp; ?rest} (f ?rest) _ {}))"><y>#</y><d>2021-03-18</d><h>22:43</h><r>noprompt</r><pre>(fn f [m]
  (m/find m
    {(m/keyword ?name) (m/some ?x) &amp; ?rest}
    (merge {?name ?x} (f ?rest))

    {_ _ &amp; ?rest}
    (f ?rest)

    _
    {}))</pre></z><z id="t1616107553" t="noprompt Using rewrite : (m/rewrite m {(m/keyword ?name) (m/some ?x) &amp; (m/cata ?rest)} {?name ?x &amp; ?rest} {_ _ &amp; (m/cata ?rest)} ?rest _ {}) "><y>#</y><d>2021-03-18</d><h>22:45</h><r>noprompt</r>Using <code>rewrite</code> :

<pre>(m/rewrite m
  {(m/keyword ?name) (m/some ?x) &amp; (m/cata ?rest)}
  {?name ?x &amp; ?rest}

  {_ _ &amp; (m/cata ?rest)}
  ?rest

  _ {})</pre>
</z><z id="t1616107572" t="Jimmy Miller I will just say you can also just do a post process step. (On my phone) Something like (into {} (filter second) my-data-after-meanderized))"><y>#</y><d>2021-03-18</d><h>22:46</h><r>Jimmy Miller</r>I will just say you can also just do a post process step. (On my phone) Something like

<code>(into {} (filter second) my-data-after-meanderized))</code></z><z id="t1616151457" t="Panel Thanks you both, I read thru the chat log of the past few months and the support you are providing is exceptional."><y>#</y><d>2021-03-19</d><h>10:57</h><r>Panel</r>Thanks you both,  I read thru the chat log of the past few months and the support you are providing is exceptional.</z><z id="t1616178225" t="mac Hej all, I am matching on a rather large datastructure using search and $. I would like to try to optimize this a bit. Is there a way to short circuit sub structures under for instance specific keys that I know are not relevant?"><y>#</y><d>2021-03-19</d><h>18:23</h><w>mac</w>Hej all, I am matching on a rather large datastructure using search and $. I would like to try to optimize this a bit. Is there a way to short circuit sub structures under for instance specific keys that I know are not relevant?</z><z id="t1616180843" t="noprompt Not at the moment one thing you could try is (keep (fn [x] (m/find x ,,,)) (tree-seq branch? children root)) "><y>#</y><d>2021-03-19</d><h>19:07</h><r>noprompt</r>Not at the moment one thing you could try is
<pre>(keep (fn [x] (m/find x ,,,))
      (tree-seq branch? children root))</pre>
</z><z id="t1616181215" t="mac Thanks. Will be messy do to the heterogeneity of the structure."><y>#</y><d>2021-03-19</d><h>19:13</h><r>mac</r>Thanks. Will be messy do to the heterogeneity of the structure.</z><z id="t1616282509" t="wilkerlucio hello, I have a case that I&apos;m trying to figure if meander can solve, I have data that can come in the following formats: ; contains rental prices and sales price {:pricingInfos [{:rentalInfo {:period &quot;MONTHLY&quot;, :warranties [], :monthlyRentalTotalPrice &quot;4520&quot;}, :yearlyIptu &quot;278&quot;, :price &quot;3690&quot;, :businessType &quot;RENTAL&quot;, :monthlyCondoFee &quot;830&quot;} {:yearlyIptu &quot;278&quot;, :price &quot;990000&quot;, :businessType &quot;SALE&quot;, :monthlyCondoFee &quot;830&quot;}]} ; contains only sales price {:pricingInfos [{:yearlyIptu &quot;278&quot;, :price &quot;990000&quot;, :businessType &quot;SALE&quot;, :monthlyCondoFee &quot;830&quot;}]} and I like to match on the sales price only, I tried: (m/match {:pricingInfos [{:rentalInfo {:period &quot;MONTHLY&quot;, :warranties [], :monthlyRentalTotalPrice &quot;4520&quot;}, :yearlyIptu &quot;278&quot;, :price &quot;3690&quot;, :businessType &quot;RENTAL&quot;, :monthlyCondoFee &quot;830&quot;} {:yearlyIptu &quot;278&quot;, :price &quot;990000&quot;, :businessType &quot;SALE&quot;, :monthlyCondoFee &quot;830&quot;}]} {:pricingInfos [{:price ?price :businessType &quot;SALE&quot;}]} {:sales-price ?price}) but that triggers an error of non exhaustive pattern match , is there a way to do a match like this with meander? (that kinda &quot;finds&quot; the matching item from a list)"><y>#</y><d>2021-03-20</d><h>23:21</h><w>wilkerlucio</w>hello, I have a case that I&apos;m trying to figure if meander can solve, I have data that can come in the following formats:

<pre>; contains rental prices and sales price
{:pricingInfos [{:rentalInfo      {:period                  &quot;MONTHLY&quot;,
                                   :warranties              [],
                                   :monthlyRentalTotalPrice &quot;4520&quot;},
                 :yearlyIptu      &quot;278&quot;,
                 :price           &quot;3690&quot;,
                 :businessType    &quot;RENTAL&quot;,
                 :monthlyCondoFee &quot;830&quot;}
                {:yearlyIptu      &quot;278&quot;,
                 :price           &quot;990000&quot;,
                 :businessType    &quot;SALE&quot;,
                 :monthlyCondoFee &quot;830&quot;}]}

; contains only sales price
{:pricingInfos [{:yearlyIptu      &quot;278&quot;,
                 :price           &quot;990000&quot;,
                 :businessType    &quot;SALE&quot;,
                 :monthlyCondoFee &quot;830&quot;}]}</pre>
and I like to match on the sales price only, I tried:

<pre>(m/match {:pricingInfos [{:rentalInfo      {:period                  &quot;MONTHLY&quot;,
                                            :warranties              [],
                                            :monthlyRentalTotalPrice &quot;4520&quot;},
                          :yearlyIptu      &quot;278&quot;,
                          :price           &quot;3690&quot;,
                          :businessType    &quot;RENTAL&quot;,
                          :monthlyCondoFee &quot;830&quot;}
                         {:yearlyIptu      &quot;278&quot;,
                          :price           &quot;990000&quot;,
                          :businessType    &quot;SALE&quot;,
                          :monthlyCondoFee &quot;830&quot;}]}
  {:pricingInfos [{:price        ?price
                   :businessType &quot;SALE&quot;}]}
  {:sales-price ?price})</pre>
but that triggers an error of <code>non exhaustive pattern match</code>, is there a way to do a match like this with meander? (that kinda &quot;finds&quot; the matching item from a list)</z><z id="t1616282804" t="phronmophobic I think m/find with m/scan will do what you want: &gt; (m/find {:pricingInfos [{:rentalInfo {:period &quot;MONTHLY&quot;, :warranties [], :monthlyRentalTotalPrice &quot;4520&quot;}, :yearlyIptu &quot;278&quot;, :price &quot;3690&quot;, :businessType &quot;RENTAL&quot;, :monthlyCondoFee &quot;830&quot;} {:yearlyIptu &quot;278&quot;, :price &quot;990000&quot;, :businessType &quot;SALE&quot;, :monthlyCondoFee &quot;830&quot;}]} {:pricingInfos (m/scan {:price ?price :businessType &quot;SALE&quot;})} {:sales-price ?price}) ;;{:sales-price &quot;990000&quot;}"><y>#</y><d>2021-03-20</d><h>23:26</h><r>phronmophobic</r>I think <code>m/find</code> with <code>m/scan</code> will do what you want:
<pre>&gt; (m/find {:pricingInfos [{:rentalInfo      {:period                  &quot;MONTHLY&quot;,
                                           :warranties              [],
                                           :monthlyRentalTotalPrice &quot;4520&quot;},
                         :yearlyIptu      &quot;278&quot;,
                         :price           &quot;3690&quot;,
                         :businessType    &quot;RENTAL&quot;,
                         :monthlyCondoFee &quot;830&quot;}
                        {:yearlyIptu      &quot;278&quot;,
                         :price           &quot;990000&quot;,
                         :businessType    &quot;SALE&quot;,
                         :monthlyCondoFee &quot;830&quot;}]}
  {:pricingInfos (m/scan
                  {:price        ?price
                   :businessType &quot;SALE&quot;})}
  {:sales-price ?price})

;;{:sales-price &quot;990000&quot;}</pre></z><z id="t1616282888" t="wilkerlucio work as a charm, thanks!"><y>#</y><d>2021-03-20</d><h>23:28</h><r>wilkerlucio</r>work as a charm, thanks!</z><z id="t1616282923" t="phronmophobic if you want to find multiple items, you can use m/search in place of m/find"><y>#</y><d>2021-03-20</d><h>23:28</h><r>phronmophobic</r>if you want to find multiple items, you can use <code>m/search</code> in place of <code>m/find</code></z><z id="t1616283850" t="wilkerlucio cool, what if I like to optionally matching also the rental price (which sometimes may not be there), what is the way to go?"><y>#</y><d>2021-03-20</d><h>23:44</h><r>wilkerlucio</r>cool, what if I like to optionally matching also the rental price (which sometimes may not be there), what is the way to go?</z><z id="t1616283877" t="wilkerlucio I was able to match here when both are available, but the same pattern returns nil in case I remove the rental data"><y>#</y><d>2021-03-20</d><h>23:44</h><r>wilkerlucio</r>I was able to match here when both are available, but the same pattern returns <code>nil</code> in case I remove the rental data</z><z id="t1616284439" t="phronmophobic not sure I understand the question. do you have an example?"><y>#</y><d>2021-03-20</d><h>23:53</h><r>phronmophobic</r>not sure I understand the question. do you have an example?</z><z id="t1616284914" t="wilkerlucio sure"><y>#</y><d>2021-03-21</d><h>00:01</h><r>wilkerlucio</r>sure</z><z id="t1616284922" t="wilkerlucio this works as expected: (m/find {:pricingInfos [{:rentalInfo {:period &quot;MONTHLY&quot;, :warranties [], :monthlyRentalTotalPrice &quot;4520&quot;}, :yearlyIptu &quot;278&quot;, :price &quot;3690&quot;, :businessType &quot;RENTAL&quot;, :monthlyCondoFee &quot;830&quot;} {:yearlyIptu &quot;278&quot;, :price &quot;990000&quot;, :businessType &quot;SALE&quot;, :monthlyCondoFee &quot;830&quot;}]} {:pricingInfos (m/scan {:price ?rental-price :businessType &quot;RENTAL&quot;} {:price ?price :businessType &quot;SALE&quot;})} {:sales-price (Integer/parseInt ?price) :rental-price (Integer/parseInt ?rental-price)}) =&gt; {:sales-price 990000, :rental-price 3690}"><y>#</y><d>2021-03-21</d><h>00:02</h><r>wilkerlucio</r>this works as expected:
<pre>(m/find {:pricingInfos [{:rentalInfo      {:period                  &quot;MONTHLY&quot;,
                                             :warranties              [],
                                             :monthlyRentalTotalPrice &quot;4520&quot;},
                           :yearlyIptu      &quot;278&quot;,
                           :price           &quot;3690&quot;,
                           :businessType    &quot;RENTAL&quot;,
                           :monthlyCondoFee &quot;830&quot;}
                          {:yearlyIptu      &quot;278&quot;,
                           :price           &quot;990000&quot;,
                           :businessType    &quot;SALE&quot;,
                           :monthlyCondoFee &quot;830&quot;}]}
    {:pricingInfos (m/scan
                     {:price        ?rental-price
                      :businessType &quot;RENTAL&quot;}
                     {:price        ?price
                      :businessType &quot;SALE&quot;})}
    {:sales-price  (Integer/parseInt ?price)
     :rental-price (Integer/parseInt ?rental-price)})
=&gt; {:sales-price 990000, :rental-price 3690}</pre></z><z id="t1616284940" t="wilkerlucio but in case the rental goes missing, it fails completly: (m/find {:pricingInfos [{:yearlyIptu &quot;278&quot;, :price &quot;990000&quot;, :businessType &quot;SALE&quot;, :monthlyCondoFee &quot;830&quot;}]} {:pricingInfos (m/scan {:price ?rental-price :businessType &quot;RENTAL&quot;} {:price ?price :businessType &quot;SALE&quot;})} {:sales-price (Integer/parseInt ?price) :rental-price (Integer/parseInt ?rental-price)}) =&gt; nil"><y>#</y><d>2021-03-21</d><h>00:02</h><r>wilkerlucio</r>but in case the rental goes missing, it fails completly:
<pre>(m/find {:pricingInfos [{:yearlyIptu      &quot;278&quot;,
                           :price           &quot;990000&quot;,
                           :businessType    &quot;SALE&quot;,
                           :monthlyCondoFee &quot;830&quot;}]}
    {:pricingInfos (m/scan
                     {:price        ?rental-price
                      :businessType &quot;RENTAL&quot;}
                     {:price        ?price
                      :businessType &quot;SALE&quot;})}
    {:sales-price  (Integer/parseInt ?price)
     :rental-price (Integer/parseInt ?rental-price)})
=&gt; nil</pre></z><z id="t1616284959" t="wilkerlucio I would like to every match to be optional, and fill with nil in case the option isn&apos;t present"><y>#</y><d>2021-03-21</d><h>00:02</h><r>wilkerlucio</r>I would like to every match to be optional, and fill with <code>nil</code> in case the option isn&apos;t present</z><z id="t1616285207" t="phronmophobic I&apos;ve been using something like: (m/find {:pricingInfos [{:rentalInfo {:period &quot;MONTHLY&quot;, :warranties [], :monthlyRentalTotalPrice &quot;4520&quot;}, :yearlyIptu &quot;278&quot;, :price &quot;3690&quot;, :businessType &quot;RENTAL&quot;, :monthlyCondoFee &quot;830&quot;} {:yearlyIptu &quot;278&quot;, :price &quot;990000&quot;, :businessType &quot;SALE&quot;, :monthlyCondoFee &quot;830&quot;} ]} {:pricingInfos (unordered {:price ?sales-price :businessType &quot;SALE&quot;} {:price ?rental-price :businessType &quot;RENTAL&quot;})} {:sales-price ?sales-price :rental-price ?rental-price})"><y>#</y><d>2021-03-21</d><h>00:06</h><r>phronmophobic</r>I&apos;ve been using something like:
<pre>(m/find {:pricingInfos [{:rentalInfo      {:period                  &quot;MONTHLY&quot;,
                                           :warranties              [],
                                           :monthlyRentalTotalPrice &quot;4520&quot;},
                         :yearlyIptu      &quot;278&quot;,
                         :price           &quot;3690&quot;,
                         :businessType    &quot;RENTAL&quot;,
                         :monthlyCondoFee &quot;830&quot;}
                        {:yearlyIptu      &quot;278&quot;,
                         :price           &quot;990000&quot;,
                         :businessType    &quot;SALE&quot;,
                         :monthlyCondoFee &quot;830&quot;}
                          ]}
  {:pricingInfos (unordered
                  {:price ?sales-price
                   :businessType &quot;SALE&quot;}
                  {:price ?rental-price
                   :businessType &quot;RENTAL&quot;})}
  {:sales-price ?sales-price
   :rental-price ?rental-price})</pre></z><z id="t1616285226" t="phronmophobic with unordered defined as: (m/defsyntax unordered [&amp; patterns] `(m/app set ~(set patterns)))"><y>#</y><d>2021-03-21</d><h>00:07</h><r>phronmophobic</r>with <code>unordered</code> defined as:
<pre>(m/defsyntax unordered [&amp; patterns]
  `(m/app set
          ~(set patterns)))</pre></z><z id="t1616285367" t="phronmophobic oh wait, that doesn&apos;t work if one is missing"><y>#</y><d>2021-03-21</d><h>00:09</h><r>phronmophobic</r>oh wait, that doesn&apos;t work if one is missing</z><z id="t1616285909" t="phronmophobic There&apos;s probably a way to do the exact transformation in one go, but I would probably just use something like (m/search {:pricingInfos [{:rentalInfo {:period &quot;MONTHLY&quot;, :warranties [], :monthlyRentalTotalPrice &quot;4520&quot;}, :yearlyIptu &quot;278&quot;, :price &quot;3690&quot;, :businessType &quot;RENTAL&quot;, :monthlyCondoFee &quot;830&quot;} {:yearlyIptu &quot;278&quot;, :price &quot;990000&quot;, :businessType &quot;SALE&quot;, :monthlyCondoFee &quot;830&quot;} ]} {:pricingInfos (m/scan {:price ?price :businessType ?type})} {:price ?price :type ?type}) ;; ({:price &quot;3690&quot;, :type &quot;RENTAL&quot;} {:price &quot;990000&quot;, :type &quot;SALE&quot;})"><y>#</y><d>2021-03-21</d><h>00:18</h><r>phronmophobic</r>There&apos;s probably a way to do the exact transformation in one go, but I would probably just use something like
<pre>(m/search {:pricingInfos [{:rentalInfo      {:period                  &quot;MONTHLY&quot;,
                                             :warranties              [],
                                             :monthlyRentalTotalPrice &quot;4520&quot;},
                           :yearlyIptu      &quot;278&quot;,
                           :price           &quot;3690&quot;,
                           :businessType    &quot;RENTAL&quot;,
                           :monthlyCondoFee &quot;830&quot;}
                          {:yearlyIptu      &quot;278&quot;,
                           :price           &quot;990000&quot;,
                             :businessType    &quot;SALE&quot;,
                             :monthlyCondoFee &quot;830&quot;}
                          ]}
  {:pricingInfos (m/scan
                  {:price ?price
                   :businessType ?type})}
  
  {:price ?price
   :type ?type})
;; ({:price &quot;3690&quot;, :type &quot;RENTAL&quot;} {:price &quot;990000&quot;, :type &quot;SALE&quot;})</pre></z><z id="t1616286126" t="wilkerlucio thanks, I really love to see a way to do that in one go, because I have a lot of cases like this ,and being able to break the categories in a match like that somehow would be great"><y>#</y><d>2021-03-21</d><h>00:22</h><r>wilkerlucio</r>thanks, I really love to see a way to do that in one go, because I have a lot of cases like this ,and being able to break the categories in a match like that somehow would be great</z><z id="t1616287059" t="phronmophobic this is a little verbose, but seems to work: (m/find {:pricingInfos [{:rentalInfo {:period &quot;MONTHLY&quot;, :warranties [], :monthlyRentalTotalPrice &quot;4520&quot;}, :yearlyIptu &quot;278&quot;, :price &quot;3690&quot;, :businessType &quot;RENTAL&quot;, :monthlyCondoFee &quot;830&quot;} {:yearlyIptu &quot;278&quot;, :price &quot;990000&quot;, :businessType &quot;SALE&quot;, :monthlyCondoFee &quot;830&quot;} ]} {:pricingInfos (m/or (unordered {:price ?sales-price :businessType &quot;SALE&quot;} {:price ?rental-price :businessType &quot;RENTAL&quot;}) (m/let [?sales-price nil] (unordered {:price ?rental-price :businessType &quot;RENTAL&quot;})) (m/let [?rental-price nil] (unordered {:price ?sales-price :businessType &quot;SALE&quot;})) (m/let [?rental-price nil ?sales-price nil] _))} {:sales-price ?sales-price :rental-price ?rental-price})"><y>#</y><d>2021-03-21</d><h>00:37</h><r>phronmophobic</r>this is a little verbose, but seems to work:
<pre>(m/find {:pricingInfos [{:rentalInfo      {:period                  &quot;MONTHLY&quot;,
                                           :warranties              [],
                                           :monthlyRentalTotalPrice &quot;4520&quot;},
                         :yearlyIptu      &quot;278&quot;,
                         :price           &quot;3690&quot;,
                         :businessType    &quot;RENTAL&quot;,
                         :monthlyCondoFee &quot;830&quot;}
                        {:yearlyIptu      &quot;278&quot;,
                         :price           &quot;990000&quot;,
                         :businessType    &quot;SALE&quot;,
                         :monthlyCondoFee &quot;830&quot;}
                        ]}
  {:pricingInfos (m/or
                  (unordered
                   {:price ?sales-price
                    :businessType &quot;SALE&quot;}
                   {:price ?rental-price
                    :businessType &quot;RENTAL&quot;})
                  (m/let [?sales-price nil]
                    (unordered
                     {:price ?rental-price
                      :businessType &quot;RENTAL&quot;}))
                  (m/let [?rental-price nil]
                    (unordered
                     {:price ?sales-price
                      :businessType &quot;SALE&quot;}))
                  (m/let [?rental-price nil
                          ?sales-price nil] _))}
  {:sales-price ?sales-price
   :rental-price ?rental-price})</pre></z><z id="t1616287111" t="phronmophobic there&apos;s probably a way to simplify it, possibly with m/app or m/defsyntax"><y>#</y><d>2021-03-21</d><h>00:38</h><r>phronmophobic</r>there&apos;s probably a way to simplify it, possibly with <code>m/app</code> or <code>m/defsyntax</code></z><z id="t1616299643" t="wilkerlucio hello, I tried to run it now, but always getting nils"><y>#</y><d>2021-03-21</d><h>04:07</h><r>wilkerlucio</r>hello, I tried to run it now, but always getting nils</z><z id="t1616299644" t="wilkerlucio (m/find {:pricingInfos [{:rentalInfo {:period &quot;MONTHLY&quot;, :warranties [], :monthlyRentalTotalPrice &quot;4520&quot;}, :yearlyIptu &quot;278&quot;, :price &quot;3690&quot;, :businessType &quot;RENTAL&quot;, :monthlyCondoFee &quot;830&quot;} {:yearlyIptu &quot;278&quot;, :price &quot;990000&quot;, :businessType &quot;SALE&quot;, :monthlyCondoFee &quot;830&quot;}]} {:pricingInfos (m/or (unordered {:price ?sales-price :businessType &quot;SALE&quot;} {:price ?rental-price :businessType &quot;RENTAL&quot;}) (m/let [?sales-price nil] (unordered {:price ?rental-price :businessType &quot;RENTAL&quot;})) (m/let [?rental-price nil] (unordered {:price ?sales-price :businessType &quot;SALE&quot;})) (m/let [?rental-price nil ?sales-price nil] _))} {:sales-price ?sales-price :rental-price ?rental-price}) =&gt; {:sales-price nil, :rental-price nil}"><y>#</y><d>2021-03-21</d><h>04:07</h><r>wilkerlucio</r><pre>(m/find {:pricingInfos [{:rentalInfo      {:period                  &quot;MONTHLY&quot;,
                                           :warranties              [],
                                           :monthlyRentalTotalPrice &quot;4520&quot;},
                         :yearlyIptu      &quot;278&quot;,
                         :price           &quot;3690&quot;,
                         :businessType    &quot;RENTAL&quot;,
                         :monthlyCondoFee &quot;830&quot;}
                        {:yearlyIptu      &quot;278&quot;,
                         :price           &quot;990000&quot;,
                         :businessType    &quot;SALE&quot;,
                         :monthlyCondoFee &quot;830&quot;}]}
  {:pricingInfos (m/or
                   (unordered
                     {:price ?sales-price
                      :businessType &quot;SALE&quot;}
                     {:price ?rental-price
                      :businessType &quot;RENTAL&quot;})
                   (m/let [?sales-price nil]
                     (unordered
                       {:price ?rental-price
                        :businessType &quot;RENTAL&quot;}))
                   (m/let [?rental-price nil]
                     (unordered
                       {:price ?sales-price
                        :businessType &quot;SALE&quot;}))
                   (m/let [?rental-price nil
                           ?sales-price nil] _))}
  {:sales-price  ?sales-price
   :rental-price ?rental-price})
=&gt; {:sales-price nil, :rental-price nil}</pre></z><z id="t1616300730" t="phronmophobic weird. I just copy and pasted the code from your message into my repl and it gave: {:sales-price &quot;990000&quot;, :rental-price &quot;3690&quot;} I did just upgrade meander to meander/epsilon {:mvn/version &quot;0.0.602&quot;} . what version are you using?"><y>#</y><d>2021-03-21</d><h>04:25</h><r>phronmophobic</r>weird. I just copy and pasted the code from your message into my repl and it gave:
<pre>{:sales-price &quot;990000&quot;, :rental-price &quot;3690&quot;}</pre>
I did just upgrade meander to <code>meander/epsilon {:mvn/version &quot;0.0.602&quot;}</code> . what version are you using?</z><z id="t1616301897" t="wilkerlucio this same, 0.0.602 , on MacOS"><y>#</y><d>2021-03-21</d><h>04:44</h><r>wilkerlucio</r>this same, <code>0.0.602</code>, on MacOS</z><z id="t1616301980" t="phronmophobic and you have: (m/defsyntax unordered [&amp; patterns] `(m/app set ~(set patterns))) to define unordered ?"><y>#</y><d>2021-03-21</d><h>04:46</h><r>phronmophobic</r>and you have:
<pre>(m/defsyntax unordered [&amp; patterns]
  `(m/app set
          ~(set patterns)))</pre>
to define <code>unordered</code>?</z><z id="t1616302011" t="phronmophobic I&apos;m on MacOS as well"><y>#</y><d>2021-03-21</d><h>04:46</h><r>phronmophobic</r>I&apos;m on MacOS as well</z><z id="t1616302083" t="wilkerlucio ah, I dont"><y>#</y><d>2021-03-21</d><h>04:48</h><r>wilkerlucio</r>ah, I dont</z><z id="t1616302095" t="wilkerlucio and I just found another way to do it, with less verbosity 🙂"><y>#</y><d>2021-03-21</d><h>04:48</h><r>wilkerlucio</r>and I just found another way to do it, with less verbosity <b>🙂</b></z><z id="t1616302097" t="wilkerlucio (m/find {:pricingInfos [{:rentalInfo {:period &quot;MONTHLY&quot;, :warranties [], :monthlyRentalTotalPrice &quot;4520&quot;}, :yearlyIptu &quot;278&quot;, :price &quot;3690&quot;, :businessType &quot;RENTAL&quot;, :monthlyCondoFee &quot;830&quot;} {:yearlyIptu &quot;278&quot;, :price &quot;990000&quot;, :businessType &quot;SALE&quot;, :monthlyCondoFee &quot;830&quot;}]} {:pricingInfos (m/and (m/or (m/scan {:price ?rental-price :businessType &quot;RENTAL&quot;}) (m/let [?rental-price nil])) (m/or (m/scan {:price ?price :businessType &quot;SALE&quot;}) (m/let [?price nil])))} {:sales-price ?price :rental-price ?rental-price}) =&gt; {:sales-price &quot;990000&quot;, :rental-price &quot;3690&quot;}"><y>#</y><d>2021-03-21</d><h>04:48</h><r>wilkerlucio</r><pre>(m/find {:pricingInfos [{:rentalInfo      {:period                  &quot;MONTHLY&quot;,
                                             :warranties              [],
                                             :monthlyRentalTotalPrice &quot;4520&quot;},
                           :yearlyIptu      &quot;278&quot;,
                           :price           &quot;3690&quot;,
                           :businessType    &quot;RENTAL&quot;,
                           :monthlyCondoFee &quot;830&quot;}
                          {:yearlyIptu      &quot;278&quot;,
                           :price           &quot;990000&quot;,
                           :businessType    &quot;SALE&quot;,
                           :monthlyCondoFee &quot;830&quot;}]}
    {:pricingInfos (m/and
                     (m/or (m/scan
                             {:price        ?rental-price
                              :businessType &quot;RENTAL&quot;})
                       (m/let [?rental-price nil]))
                     (m/or
                       (m/scan
                         {:price        ?price
                          :businessType &quot;SALE&quot;})
                       (m/let [?price nil])))}
    {:sales-price  ?price
     :rental-price ?rental-price})
=&gt; {:sales-price &quot;990000&quot;, :rental-price &quot;3690&quot;}</pre></z><z id="t1616302113" t="wilkerlucio that covers all cases, and including new cases can be done with 1 new addition"><y>#</y><d>2021-03-21</d><h>04:48</h><r>wilkerlucio</r>that covers all cases, and including new cases can be done with 1 new addition</z><z id="t1616302167" t="wilkerlucio that unordered trick is cool, I&apos;m very excited with Meander 🙂"><y>#</y><d>2021-03-21</d><h>04:49</h><r>wilkerlucio</r>that <code>unordered</code> trick is cool, I&apos;m very excited with Meander <b>🙂</b></z><z id="t1616302211" t="phronmophobic the m/and is a neat trick too"><y>#</y><d>2021-03-21</d><h>04:50</h><r>phronmophobic</r>the <code>m/and</code> is a neat trick too</z><z id="t1616302230" t="wilkerlucio next is learn how to abstract that in some defsyntax"><y>#</y><d>2021-03-21</d><h>04:50</h><r>wilkerlucio</r>next is learn how to abstract that in some <code>defsyntax</code></z><z id="t1616302262" t="phronmophobic yea, was just going to say that it should be possible to add syntax to make it as short as the original attempt"><y>#</y><d>2021-03-21</d><h>04:51</h><r>phronmophobic</r>yea, was just going to say that it should be possible to add syntax to make it as short as the original attempt</z><z id="t1616302279" t="wilkerlucio yeah, my wishful syntax looks like this: (m/find {:pricingInfos [{:rentalInfo {:period &quot;MONTHLY&quot;, :warranties [], :monthlyRentalTotalPrice &quot;4520&quot;}, :yearlyIptu &quot;278&quot;, :price &quot;3690&quot;, :businessType &quot;RENTAL&quot;, :monthlyCondoFee &quot;830&quot;} {:yearlyIptu &quot;278&quot;, :price &quot;990000&quot;, :businessType &quot;SALE&quot;, :monthlyCondoFee &quot;830&quot;}]} {:pricingInfos (list-pick {:price ?rental-price :businessType &quot;RENTAL&quot;} {:price ?price :businessType &quot;SALE&quot;})} {:sales-price ?price :rental-price ?rental-price})"><y>#</y><d>2021-03-21</d><h>04:51</h><r>wilkerlucio</r>yeah, my wishful syntax looks like this:
<pre>(m/find {:pricingInfos [{:rentalInfo      {:period                  &quot;MONTHLY&quot;,
                                             :warranties              [],
                                             :monthlyRentalTotalPrice &quot;4520&quot;},
                           :yearlyIptu      &quot;278&quot;,
                           :price           &quot;3690&quot;,
                           :businessType    &quot;RENTAL&quot;,
                           :monthlyCondoFee &quot;830&quot;}
                          {:yearlyIptu      &quot;278&quot;,
                           :price           &quot;990000&quot;,
                           :businessType    &quot;SALE&quot;,
                           :monthlyCondoFee &quot;830&quot;}]}
    {:pricingInfos (list-pick
                     {:price        ?rental-price
                      :businessType &quot;RENTAL&quot;}
                     {:price        ?price
                      :businessType &quot;SALE&quot;})}
    {:sales-price  ?price
     :rental-price ?rental-price})</pre></z><z id="t1616302335" t="phronmophobic there&apos;s probably also a way set defaults for unbound logic variables. maybe it&apos;s worth filing an issue. I think it comes up regularly in the chat"><y>#</y><d>2021-03-21</d><h>04:52</h><r>phronmophobic</r>there&apos;s probably also a way set defaults for unbound logic variables. maybe it&apos;s worth filing an issue. I think it comes up regularly in the chat</z><z id="t1616302495" t="phronmophobic my wishful syntax is like: (m/find {:pricingInfos [{:rentalInfo {:period &quot;MONTHLY&quot;, :warranties [], :monthlyRentalTotalPrice &quot;4520&quot;}, :yearlyIptu &quot;278&quot;, :price &quot;3690&quot;, :businessType &quot;RENTAL&quot;, :monthlyCondoFee &quot;830&quot;} {:yearlyIptu &quot;278&quot;, :price &quot;990000&quot;, :businessType &quot;SALE&quot;, :monthlyCondoFee &quot;830&quot;}]} {:pricingInfos (with-defaults [?rental-price nil ?price nil] (unordered {:price ?rental-price :businessType &quot;RENTAL&quot;} {:price ?price :businessType &quot;SALE&quot;}))} {:sales-price ?price :rental-price ?rental-price}) and it only scans through the list once"><y>#</y><d>2021-03-21</d><h>04:54</h><r>phronmophobic</r>my wishful syntax is like:
<pre>(m/find {:pricingInfos [{:rentalInfo      {:period                  &quot;MONTHLY&quot;,
                                           :warranties              [],
                                           :monthlyRentalTotalPrice &quot;4520&quot;},
                         :yearlyIptu      &quot;278&quot;,
                         :price           &quot;3690&quot;,
                         :businessType    &quot;RENTAL&quot;,
                         :monthlyCondoFee &quot;830&quot;}
                        {:yearlyIptu      &quot;278&quot;,
                         :price           &quot;990000&quot;,
                         :businessType    &quot;SALE&quot;,
                         :monthlyCondoFee &quot;830&quot;}]}
  {:pricingInfos (with-defaults [?rental-price nil
                                 ?price nil]
                   (unordered
                    {:price        ?rental-price
                     :businessType &quot;RENTAL&quot;}
                    {:price        ?price
                     :businessType &quot;SALE&quot;}))}
  {:sales-price  ?price
   :rental-price ?rental-price})</pre>
and it only scans through the list once</z><z id="t1616303117" t="wilkerlucio got the list-pick working 😄"><y>#</y><d>2021-03-21</d><h>05:05</h><r>wilkerlucio</r>got the <code>list-pick</code> working <b>😄</b></z><z id="t1616303119" t="wilkerlucio (defn collect-variables [pattern] (let [vars* (volatile! #{})] (walk/postwalk (fn [x] (if (and (symbol? x) (str/starts-with? (name x) &quot;?&quot;)) (vswap! vars* conj x)) x) pattern) @vars*)) (m/defsyntax list-pick [&amp; patterns] `(m/and ~@(map (fn [pattern] (let [vars (collect-variables pattern) defaults (vec (interleave vars (repeat nil)))] `(m/or (m/scan ~pattern) (m/let ~defaults)))) patterns)))"><y>#</y><d>2021-03-21</d><h>05:05</h><r>wilkerlucio</r><pre>(defn collect-variables [pattern]
  (let [vars* (volatile! #{})]
    (walk/postwalk
      (fn [x]
        (if (and (symbol? x)
                 (str/starts-with? (name x) &quot;?&quot;))
          (vswap! vars* conj x))
        x)
      pattern)
    @vars*))

(m/defsyntax list-pick [&amp; patterns]
  `(m/and
     ~@(map
         (fn [pattern]
           (let [vars (collect-variables pattern)
                 defaults (vec (interleave vars (repeat nil)))]
             `(m/or
                (m/scan ~pattern)
                (m/let ~defaults))))
         patterns)))</pre></z><z id="t1616303160" t="wilkerlucio still many scans, but in my case these lists rarely go over 5 items"><y>#</y><d>2021-03-21</d><h>05:06</h><r>wilkerlucio</r>still many scans, but in my case these lists rarely go over 5 items</z><z id="t1616303527" t="phronmophobic the collect-variables works. there&apos;s also a builtin function that finds all the logic variables. For example: (m/defsyntax mor &quot;work around for &apos;Every pattern of an or pattern must have references to the same unbound logic variables.&apos;&quot; [&amp; patterns] (let [vars (into [] (comp (map r.syntax/parse) (map r.syntax/variables) (map #(map r.syntax/unparse %)) (map set)) patterns) all-vars (into #{} cat vars)] `(m/or ~@(for [[pvars pattern] (map vector vars patterns) :let [missing (clojure.set/difference all-vars pvars)]] (if (seq missing) (let [bindings (into [] cat (for [v missing] [v nil]))] `(m/let ~bindings ~pattern)) pattern)))))"><y>#</y><d>2021-03-21</d><h>05:12</h><r>phronmophobic</r>the <code>collect-variables</code> works. there&apos;s also a builtin function that finds all the logic variables. For example:
<pre>(m/defsyntax mor
  &quot;work around for &apos;Every pattern of an or pattern must have references to the same unbound logic variables.&apos;&quot;
  [&amp; patterns]
  (let [vars
        (into []
              (comp
               (map r.syntax/parse)
               (map r.syntax/variables)
               (map #(map r.syntax/unparse %))
               (map set))
              patterns)
        all-vars (into #{} cat vars)]
    `(m/or
      ~@(for [[pvars pattern] (map vector vars patterns)
              :let [missing (clojure.set/difference all-vars pvars)]]
          (if (seq missing)
            (let [bindings
                  (into []
                        cat
                        (for [v missing]
                          [v nil]))]
              `(m/let ~bindings
                 ~pattern))
            pattern)))))</pre></z><z id="t1616303581" t="phronmophobic you can also use r.syntax/logic-variables if instead of r.syntax/variables if you only care about ?variables and not !variables"><y>#</y><d>2021-03-21</d><h>05:13</h><r>phronmophobic</r>you can also use <code>r.syntax/logic-variables</code> if instead of <code>r.syntax/variables</code> if you only care about <code>?variables</code> and not <code>!variables</code></z><z id="t1616304028" t="wilkerlucio cool"><y>#</y><d>2021-03-21</d><h>05:20</h><r>wilkerlucio</r>cool</z><z id="t1616304064" t="wilkerlucio my next challenged is how to deal when a binding is shared between cases, but may be blank (due to the OR binding when the item isn&apos;t there)"><y>#</y><d>2021-03-21</d><h>05:21</h><r>wilkerlucio</r>my next challenged is how to deal when a binding is shared between cases, but may be blank (due to the OR binding when the item isn&apos;t there)</z><z id="t1616304066" t="wilkerlucio (m/find {:pricingInfos [{:rentalInfo {:period &quot;MONTHLY&quot;, :warranties [], :monthlyRentalTotalPrice &quot;4520&quot;}, :yearlyIptu &quot;278&quot;, :price &quot;3690&quot;, :businessType &quot;RENTAL&quot;, :monthlyCondoFee &quot;830&quot;} {:yearlyIptu &quot;278&quot;, :price &quot;990000&quot;, :businessType &quot;SALE&quot;, :monthlyCondoFee &quot;830&quot;}]} {:pricingInfos (wm/list-pick {:rentalInfo {:period ?rental-pay-period :monthlyRentalTotalPrice ?rental-price-total} :price ?rental-price :yearlyIptu ?iptu :monthlyCondoFee ?fee :businessType &quot;RENTAL&quot;} {:price ?sales-price :yearlyIptu ?iptu :monthlyCondoFee ?fee :businessType &quot;SALE&quot;})} {:sales-price ?sales-price :rental-price ?rental-price :iptu ?iptu :condo-fee ?fee})"><y>#</y><d>2021-03-21</d><h>05:21</h><r>wilkerlucio</r><pre>(m/find {:pricingInfos [{:rentalInfo      {:period                  &quot;MONTHLY&quot;,
                                             :warranties              [],
                                             :monthlyRentalTotalPrice &quot;4520&quot;},
                           :yearlyIptu      &quot;278&quot;,
                           :price           &quot;3690&quot;,
                           :businessType    &quot;RENTAL&quot;,
                           :monthlyCondoFee &quot;830&quot;}
                          {:yearlyIptu      &quot;278&quot;,
                           :price           &quot;990000&quot;,
                           :businessType    &quot;SALE&quot;,
                           :monthlyCondoFee &quot;830&quot;}]}
    {:pricingInfos (wm/list-pick
                     {:rentalInfo      {:period                  ?rental-pay-period
                                        :monthlyRentalTotalPrice ?rental-price-total}
                      :price           ?rental-price
                      :yearlyIptu      ?iptu
                      :monthlyCondoFee ?fee
                      :businessType    &quot;RENTAL&quot;}
                     {:price           ?sales-price
                      :yearlyIptu      ?iptu
                      :monthlyCondoFee ?fee
                      :businessType    &quot;SALE&quot;})}
    {:sales-price  ?sales-price
     :rental-price ?rental-price
     :iptu ?iptu
     :condo-fee ?fee})</pre></z><z id="t1616304099" t="wilkerlucio in this case, ?iptu and ?fee are the same, when present, but if there is no rental for example, then it would fail because it would be set to nil in rental, but with a value in sale"><y>#</y><d>2021-03-21</d><h>05:21</h><r>wilkerlucio</r>in this case, <code>?iptu</code> and <code>?fee</code> are the same, when present, but if there is no rental for example, then it would fail because it would be set to <code>nil</code> in rental, but with a value in sale</z><z id="t1616304159" t="wilkerlucio I guess the defaults you wished for could make this easier"><y>#</y><d>2021-03-21</d><h>05:22</h><r>wilkerlucio</r>I guess the defaults you wished for could make this easier</z><z id="t1616304768" t="phronmophobic I also just remembered the return expression is just a normal expression which means you can do stuff like: (m/find {:pricingInfos [{:rentalInfo {:period &quot;MONTHLY&quot;, :warranties [], :monthlyRentalTotalPrice &quot;4520&quot;}, :yearlyIptu &quot;278&quot;, :price &quot;3690&quot;, :businessType &quot;RENTAL&quot;, :monthlyCondoFee &quot;830&quot;} {:yearlyIptu &quot;278&quot;, :price &quot;990000&quot;, :businessType &quot;SALE&quot;, :monthlyCondoFee &quot;830&quot;}]} {:pricingInfos (list-pick {:yearlyIptu !iptu :businessType &quot;RENTAL&quot;} {:price !rental-price :businessType &quot;RENTAL&quot;} {:price !sales-price :businessType &quot;SALE&quot;} {:monthlyCondoFee !fee} {:yearlyIptu !iptu :businessType &quot;SALE&quot;})} {:iptu (some identity !iptu) :rental-price (some identity !rental-price) :condo-fee (some identity !fee) :sales-price (some identity !sales-price) })"><y>#</y><d>2021-03-21</d><h>05:32</h><r>phronmophobic</r>I also just remembered the return expression is just a normal expression which means you can do stuff like:
<pre>(m/find {:pricingInfos [{:rentalInfo      {:period                  &quot;MONTHLY&quot;,
                                           :warranties              [],
                                           :monthlyRentalTotalPrice &quot;4520&quot;},
                         :yearlyIptu      &quot;278&quot;,
                         :price           &quot;3690&quot;,
                         :businessType    &quot;RENTAL&quot;,
                         :monthlyCondoFee &quot;830&quot;}
                        {:yearlyIptu      &quot;278&quot;,
                         :price           &quot;990000&quot;,
                         :businessType    &quot;SALE&quot;,
                         :monthlyCondoFee &quot;830&quot;}]}
  {:pricingInfos (list-pick
                  {:yearlyIptu      !iptu
                   :businessType    &quot;RENTAL&quot;}

                  {:price      !rental-price
                   :businessType    &quot;RENTAL&quot;}
                  {:price      !sales-price
                   :businessType    &quot;SALE&quot;}

                  {:monthlyCondoFee !fee}
                  {:yearlyIptu      !iptu
                   :businessType    &quot;SALE&quot;})}
  {:iptu (some identity !iptu)
   :rental-price (some identity !rental-price)
   :condo-fee (some identity !fee)
   :sales-price (some identity !sales-price)
   })</pre></z><z id="t1616304996" t="wilkerlucio yup, funny enough, that&apos;s exactly the direction I&apos;m trying to automate"><y>#</y><d>2021-03-21</d><h>05:36</h><r>wilkerlucio</r>yup, funny enough, that&apos;s exactly the direction I&apos;m trying to automate</z><z id="t1616305003" t="wilkerlucio but I&apos;m hiding the accumulators on the syntax itself"><y>#</y><d>2021-03-21</d><h>05:36</h><r>wilkerlucio</r>but I&apos;m hiding the accumulators on the syntax itself</z><z id="t1616305011" t="wilkerlucio (trying to at least)"><y>#</y><d>2021-03-21</d><h>05:36</h><r>wilkerlucio</r>(trying to at least)</z><z id="t1616305055" t="phronmophobic that would be cool"><y>#</y><d>2021-03-21</d><h>05:37</h><r>phronmophobic</r>that would be cool</z><z id="t1616305419" t="phronmophobic one of the other tools that is less documented, but powerful is m/cata which can let you do some really interesting stuff"><y>#</y><d>2021-03-21</d><h>05:43</h><r>phronmophobic</r>one of the other tools that is less documented, but powerful is <code>m/cata</code> which can let you do some really interesting stuff</z><z id="t1616305928" t="wilkerlucio got it!"><y>#</y><d>2021-03-21</d><h>05:52</h><r>wilkerlucio</r>got it!</z><z id="t1616305940" t="wilkerlucio (defn logic-&gt;mutable [var] (symbol (str &quot;!&quot; (name var)))) (defn collect-variables [pattern] (let [vars* (volatile! #{}) pattern&apos; (walk/postwalk (fn [x] (if (and (symbol? x) (str/starts-with? (name x) &quot;?&quot;)) (do (vswap! vars* conj x) (logic-&gt;mutable x)) x)) pattern)] [@vars* pattern&apos;])) (m/defsyntax list-pick [&amp; patterns] (let [all-vars (into #{} (mapcat (comp first collect-variables)) patterns) all-let (vec (interleave all-vars (map (fn [v] (let [new-name (logic-&gt;mutable v)] `(some identity ~new-name))) all-vars)))] `(m/and ~@(map (fn [pattern] (let [[vars pattern] (collect-variables pattern) vars-set (vec (interleave (map logic-&gt;mutable vars) (repeat nil)))] `(m/or (m/scan ~pattern) (m/let ~vars-set)))) patterns) (m/let ~all-let))))"><y>#</y><d>2021-03-21</d><h>05:52</h><r>wilkerlucio</r><pre>(defn logic-&gt;mutable [var]
  (symbol (str &quot;!&quot; (name var))))

(defn collect-variables [pattern]
  (let [vars*    (volatile! #{})
        pattern&apos; (walk/postwalk
                   (fn [x]
                     (if (and (symbol? x)
                              (str/starts-with? (name x) &quot;?&quot;))
                       (do
                         (vswap! vars* conj x)
                         (logic-&gt;mutable x))
                       x))
                   pattern)]
    [@vars* pattern&apos;]))

(m/defsyntax list-pick [&amp; patterns]
  (let [all-vars (into #{} (mapcat (comp first collect-variables)) patterns)
        all-let  (vec (interleave all-vars
                        (map
                          (fn [v]
                            (let [new-name (logic-&gt;mutable v)]
                              `(some identity ~new-name)))
                          all-vars)))]
    `(m/and
       ~@(map
           (fn [pattern]
             (let [[vars pattern] (collect-variables pattern)
                   vars-set (vec (interleave (map logic-&gt;mutable vars) (repeat nil)))]
               `(m/or
                  (m/scan ~pattern)
                  (m/let ~vars-set))))
           patterns)
       (m/let ~all-let))))</pre></z><z id="t1616306318" t="phronmophobic ok. I think I&apos;m starting to figure it out. That&apos;s neat!"><y>#</y><d>2021-03-21</d><h>05:58</h><r>phronmophobic</r>ok. I think I&apos;m starting to figure it out. That&apos;s neat!</z><z id="t1616306610" t="phronmophobic I didn&apos;t realize you could use m/let with m/and to just bind variables at the end. That&apos;s a useful technique."><y>#</y><d>2021-03-21</d><h>06:03</h><r>phronmophobic</r>I didn&apos;t realize you could use <code>m/let</code> with <code>m/and</code> to just bind variables at the end. That&apos;s a useful technique.</z><z id="t1616306685" t="wilkerlucio yeah, was a guess, glad it worked 🙂"><y>#</y><d>2021-03-21</d><h>06:04</h><r>wilkerlucio</r>yeah, was a guess, glad it worked <b>🙂</b></z><z id="t1616328770" t="ribelo (m/rewrite [[&quot;00:00&quot; &quot;01:00&quot;] [&quot;02:00&quot; &quot;03:00&quot;]] (m/or [(m/pred string?) ... :as !time] [[(m/pred string?) ... :as !time] ...] (m/let [!time [&quot;00:00&quot; &quot;23:59&quot;]])) [!time ...]) shouldn&apos;t it return [[&quot;00:00&quot; &quot;01:00&quot;] [&quot;02:00&quot; &quot;03:00&quot;]] ?"><y>#</y><d>2021-03-21</d><h>12:12</h><w>ribelo</w><pre>(m/rewrite [[&quot;00:00&quot; &quot;01:00&quot;] [&quot;02:00&quot; &quot;03:00&quot;]]
  (m/or [(m/pred string?) ... :as !time]
        [[(m/pred string?) ... :as !time] ...]
        (m/let [!time [&quot;00:00&quot; &quot;23:59&quot;]]))
  [!time ...])</pre>
shouldn&apos;t it return <code>[[&quot;00:00&quot; &quot;01:00&quot;] [&quot;02:00&quot; &quot;03:00&quot;]]</code> ?</z><z id="t1616427324" t="noprompt Yes."><y>#</y><d>2021-03-22</d><h>15:35</h><r>noprompt</r>Yes.</z><z id="t1616427706" t="noprompt It looks like theres something up with m/or ; I’ll take a look soon. For now (and I’m sure you’ve probably figured a work around) you can use (me/rewrite [[&quot;00:00&quot; &quot;01:00&quot;] [&quot;02:00&quot; &quot;03:00&quot;]] (me/or [(me/pred string?) ..1 :as !time] [[(me/pred string?) ... :as !time] ..1]) [!time ...] _ [[&quot;00:00&quot; &quot;23:59&quot;]]) "><y>#</y><d>2021-03-22</d><h>15:41</h><r>noprompt</r>It looks like theres something up with <code>m/or</code> ; I’ll take a look soon. For now (and I’m sure you’ve probably figured a work around) you can use

<pre>(me/rewrite [[&quot;00:00&quot; &quot;01:00&quot;] [&quot;02:00&quot; &quot;03:00&quot;]]
  (me/or [(me/pred string?) ..1 :as !time]
         [[(me/pred string?) ... :as !time] ..1])
  [!time ...]

  _
  [[&quot;00:00&quot; &quot;23:59&quot;]])</pre>
</z><z id="t1616434655" t="ribelo thx"><y>#</y><d>2021-03-22</d><h>17:37</h><r>ribelo</r>thx</z><z id="t1617201842" t="Michael Nardell I am using Meander to build up nested data structures rather than using it to query nested data. I am able to do roughly what I want with Meander, and it seems like an elegant way to express how I both retrieve the data and build a result. The problem is that I get a result that needs to be merged subsequently. For example I have normalized data from my schools student information system that expresses course, section, meeting and enrollment data (users are associated with courses, courses with sections, and sections with meetings)."><y>#</y><d>2021-03-31</d><h>14:44</h><w>Michael Nardell</w>I am using Meander to build up nested data structures rather than using it to query nested data. I am able to do roughly what I want with Meander, and it seems like an elegant way to express how I both retrieve the data and build a result. The problem is that I get a result that needs to be merged subsequently. For example I have normalized data from my schools student information system that expresses course, section, meeting and enrollment data (users are associated with courses, courses with sections, and sections with meetings).</z><z id="t1617202950" t="Michael Nardell (defn retrieve-data-for-user [courses-lookup sections-lookup meetings-lookup user] (m/search {:user user :courses-lookup courses-lookup ;; Look up course by user-id :sections-lookup sections-lookup ;; Look up section by course-id :meetings-lookup meetings-lookup } ;; Look up meetings by section-id ;; Input------------------------------------------------------ {:user {&quot;user_id&quot; ?user-id &quot;last_name&quot; ?last-name} :courses-lookup {?user-id (m/scan {&quot;course_id&quot; ?course-id &quot;status&quot; ?status})} :sections-lookup {?course-id (m/scan {&quot;section_id&quot; ?section-id &quot;name&quot; ?section-name})} :meetings-lookup {?section-id (m/scan {&quot;Meeting ID&quot; ?meeting-id})} } ;; Output ---- build nested data structure of the form --- ;; {:user :courses [{:sections [{:meetings } ...] }...] } {:user {:last-name ?last-name} :courses [{:course-id ?course-id :status ?status :sections [{:section-name ?section-name :section-id ?section-id :meetings [{:meeting-id ?meeting-id}] } ]} ]})) With the above code I get the data I want, however each the data is not fully nested - I get"><y>#</y><d>2021-03-31</d><h>15:02</h><w>Michael Nardell</w><pre>(defn retrieve-data-for-user [courses-lookup sections-lookup meetings-lookup  user]
  (m/search {:user user 
             :courses-lookup courses-lookup   ;; Look up course by user-id
             :sections-lookup sections-lookup ;; Look up section by course-id
             :meetings-lookup meetings-lookup } ;; Look up meetings by section-id
      ;; Input------------------------------------------------------
      {:user 
         {&quot;user_id&quot; ?user-id &quot;last_name&quot; ?last-name}
       :courses-lookup 
       {?user-id  (m/scan {&quot;course_id&quot; ?course-id &quot;status&quot; ?status})}
       :sections-lookup
       {?course-id (m/scan {&quot;section_id&quot; ?section-id &quot;name&quot; ?section-name})}
        :meetings-lookup
       {?section-id (m/scan {&quot;Meeting ID&quot; ?meeting-id})}
       }
      
      ;; Output ---- build nested data structure of the form --- 
      ;; {:user :courses [{:sections [{:meetings } ...] }...] }
      {:user 
         {:last-name ?last-name} 
       :courses [{:course-id ?course-id :status ?status 
                     :sections [{:section-name ?section-name
                                 :section-id ?section-id
                                  :meetings [{:meeting-id ?meeting-id}] 
                                 } ]} ]}))</pre>
With the above code I get the data I want, however each the data is not fully nested - I get</z><z id="t1617203187" t="Michael Nardell ({:user {:last-name &quot;Name&quot;}, :courses [{:course-id &quot;2208-022...&quot;, :sections [{:section-name &quot;Senior Research&quot;, :meetings [{:meeting-id &quot;2...}]}]}]} {:user {:last-name &quot;Name&quot;}, :courses [{:course-id &quot;2208-02288...&quot;, :sections [{:section-name &quot;Syntax I-22917&quot;, :meetings [{:meeting-id &quot;... &quot;}]}]}]} {:user {:last-name &quot;Name&quot;}, :courses [{:course-id &quot;2208-11&quot;, :sections [{:section-name &quot;Ellipsis-24042&quot;, :meetings [{:meeting-id &quot;2208-116&quot;}]}]}]})"><y>#</y><d>2021-03-31</d><h>15:06</h><w>Michael Nardell</w><pre>({:user {:last-name &quot;Name&quot;},
  :courses
  [{:course-id &quot;2208-022...&quot;,
    :sections
    [{:section-name &quot;Senior Research&quot;,
      :meetings [{:meeting-id &quot;2...}]}]}]}
 {:user {:last-name &quot;Name&quot;},
  :courses
  [{:course-id &quot;2208-02288...&quot;,
    :sections
    [{:section-name &quot;Syntax I-22917&quot;,
      :meetings [{:meeting-id &quot;... &quot;}]}]}]}
 {:user {:last-name &quot;Name&quot;},
  :courses
  [{:course-id &quot;2208-11&quot;,
    :sections
    [{:section-name &quot;Ellipsis-24042&quot;,
      :meetings [{:meeting-id &quot;2208-116&quot;}]}]}]})</pre></z><z id="t1617234798" t="Jimmy Miller Sorry I haven&apos;t been able to look at this. Will try to find time tonight."><y>#</y><d>2021-03-31</d><h>23:53</h><w>Jimmy Miller</w>Sorry I haven&apos;t been able to look at this. Will try to find time tonight.</z><z id="t1617283702" t="Michael Nardell [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] Thanks, it is entirely possible I am using Meander in fundamentally the wrong way. I want to build up a data graph from different sources. Also, I should have mentioned that I elided many of the data fields from the actual out put I showed."><y>#</y><d>2021-04-01</d><h>13:28</h><w>Michael Nardell</w><a>@jimmy</a> Thanks, it is entirely possible I am using Meander in fundamentally the wrong way. I want to build up a data graph from different sources.  Also, I should have mentioned that I elided many of the data fields from the actual out put I showed.</z><z id="t1617284017" t="Jimmy Miller Yeah sorry I didn&apos;t find time last night. Today is my non-busy evening. So I can definitely get to it at some point to day. I will say as a general thing, if you want to keep the nesting structure, I’d recommend rewrite with some memory variables instead of search. Search is going to give you all possible matches of your data as a seq. Rewrite with memory variables will let you control the exact output. If you can give a desired input output pair, that would be super useful."><y>#</y><d>2021-04-01</d><h>13:33</h><w>Jimmy Miller</w>Yeah sorry I didn&apos;t find time last night. Today is my non-busy evening. So I can definitely get to it at some point to day. I will say as a general thing, if you want to keep the nesting structure, I’d recommend rewrite with some memory variables instead of search. Search is going to give you all possible matches of your data as a seq. Rewrite with memory variables will let you control the exact output.

If you can give a desired input output pair, that would be super useful.</z><z id="t1617294021" t="Michael Nardell [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] Yeah, I figured I need get into memory variables. I will start paying closer attention that topic in your documentation. Thanks!"><y>#</y><d>2021-04-01</d><h>16:20</h><w>Michael Nardell</w><a>@jimmy</a> Yeah, I figured I need get into memory variables.  I will start paying closer attention that topic in your documentation. Thanks!</z><z id="t1617400108" t="ribelo Is there any way to do it faster and better? Better in the sense that search when adding or returns all possible combinations (m/search dx100k {_ {_ {:db/id ?e :name &quot;Ivan&quot;}}} ?e) such a thing works, but for more elements it throws a stackoverflow (m/rewrite dx100k (m/map-of _ (m/map-of _ {:db/id !e :name &quot;Ivan&quot;})) [!e ...])"><y>#</y><d>2021-04-02</d><h>21:48</h><w>ribelo</w>Is there any way to do it faster and better? Better in the sense that <code>search</code> when adding <code>or</code> returns all possible combinations
<pre>(m/search dx100k
       {_ {_ {:db/id ?e
              :name  &quot;Ivan&quot;}}} ?e)</pre>
such a thing works, but for more elements it throws a stackoverflow
<pre>(m/rewrite dx100k
       (m/map-of _ (m/map-of _ {:db/id !e :name &quot;Ivan&quot;}))
       [!e ...])</pre></z><z id="t1617408259" t="Jimmy Miller Definitely seems with filing an issue for. If you could include the stacktrace we can look into and see if it is easy to fix or not. Will try to look at the error message soon to understand the root cause."><y>#</y><d>2021-04-03</d><h>00:04</h><r>Jimmy Miller</r>Definitely seems with filing an issue for. If you could include the stacktrace we can look into and see if it is easy to fix or not. Will try to look at the error message soon to understand the root cause.</z><z id="t1617409689" t="ribelo [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] http://ix.io/2URI"><y>#</y><d>2021-04-03</d><h>00:28</h><r>ribelo</r><a>@U5K8NTHEZ</a> <a href="http://ix.io/2URI" target="_blank">http://ix.io/2URI</a></z><z id="t1617409756" t="ribelo and stacktrace"><y>#</y><d>2021-04-03</d><h>00:29</h><r>ribelo</r>and stacktrace</z><z id="t1617409757" t="ribelo http://ix.io/2URJ"><y>#</y><d>2021-04-03</d><h>00:29</h><r>ribelo</r><a href="http://ix.io/2URJ" target="_blank">http://ix.io/2URJ</a></z><z id="t1617642529" t="Jimmy Miller So I see the ultimate problem. But I’m really not sure if there is a straight forward fix here. Basically we generate some mutually recursive functions that blow the stack. We could definitely be smarter about this. A github issue would be nice if you have the time. (If not I can) Maybe [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] has some idea of a good fix for this. But there is a chance we might just hold off on this till zeta. (Unless someone else wants to help fix it which is of course always welcome)."><y>#</y><d>2021-04-05</d><h>17:08</h><r>Jimmy Miller</r>So I see the ultimate problem. But I’m really not sure if there is a straight forward fix here. Basically we generate some mutually recursive functions that blow the stack. We could definitely be smarter about this. A github issue would be nice if you have the time. (If not I can)

Maybe <a>@U06MDAPTP</a> has some idea of a good fix for this. But there is a chance we might just hold off on this till zeta. (Unless someone else wants to help fix it which is of course always welcome).</z><z id="t1617696662" t="ribelo https://github.com/noprompt/meander/issues/175"><y>#</y><d>2021-04-06</d><h>08:11</h><r>ribelo</r><a href="https://github.com/noprompt/meander/issues/175" target="_blank">https://github.com/noprompt/meander/issues/175</a></z><z id="t1617733166" t="noprompt Thanks for opening the ticket!"><y>#</y><d>2021-04-06</d><h>18:19</h><r>noprompt</r>Thanks for opening the ticket!</z><z id="t1617402199" t="telekid Jimmy – I’m assuming you’ve come across this in your studies, but just in case you haven’t, you may find it interesting: https://egraphs-good.github.io/"><y>#</y><d>2021-04-02</d><h>22:23</h><w>telekid</w>Jimmy – I’m assuming you’ve come across this in your studies, but just in case you haven’t, you may find it interesting: <a href="https://egraphs-good.github.io/" target="_blank">https://egraphs-good.github.io/</a></z><z id="t1617408128" t="Jimmy Miller I has not seen that! Looks awesome. [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] This was a great introduction. Seems definitely worth exploring. https://docs.rs/egg/0.6.0/egg/tutorials/_01_background/index.html"><y>#</y><d>2021-04-03</d><h>00:02</h><w>Jimmy Miller</w>I has not seen that! Looks awesome. <a>@noprompt</a> This was a great introduction. Seems definitely worth exploring. <a href="https://docs.rs/egg/0.6.0/egg/tutorials/_01_background/index.html" target="_blank">https://docs.rs/egg/0.6.0/egg/tutorials/_01_background/index.html</a></z><z id="t1617444639" t="borkdude"><y>#</y><d>2021-04-03</d><h>10:10</h><w>borkdude</w></z><z id="t1617472935" t="noprompt In case anyone can’t tell from that video, I’m really out of my element. Something about being recorded turns my brain in to squash. 🙂"><y>#</y><d>2021-04-03</d><h>18:02</h><r>noprompt</r>In case anyone can’t tell from that video, I’m really out of my element. Something about being recorded turns my brain in to squash. <b>🙂</b></z><z id="t1617457389" t="raspasov Meander is pretty neat… It just inspired me to write a poor man’s version 🙂 I can’t believe I didn’t write this sooner! It’s an awesome REPL helper; never destructure 95% of map cases by hand again: https://github.com/raspasov/alexandria-clj/blob/main/src/ax/auto_let/core.cljc"><y>#</y><d>2021-04-03</d><h>13:43</h><w>raspasov</w>Meander is pretty neat…  It just inspired me to write a poor man’s version <b>🙂</b> I can’t believe I didn’t write this sooner!

It’s an awesome REPL helper; never destructure 95% of map cases by hand again:

<a href="https://github.com/raspasov/alexandria-clj/blob/main/src/ax/auto_let/core.cljc" target="_blank">https://github.com/raspasov/alexandria-clj/blob/main/src/ax/auto_let/core.cljc</a></z><z id="t1617467463" t="jjttjj That&apos;s pretty cool. Also check out https://github.com/xapix-io/matchete for another &quot;lesser meander&quot;"><y>#</y><d>2021-04-03</d><h>16:31</h><r>jjttjj</r>That&apos;s pretty cool. Also check out <a href="https://github.com/xapix-io/matchete" target="_blank">https://github.com/xapix-io/matchete</a> for another &quot;lesser meander&quot;</z><z id="t1617457447" t="raspasov (auto-destructure {:name :alice :favorite {:music [{:genre :rock} {:genre :trance}] :friends #{:bob :clara}}}) ;=&gt; [{:keys [name favorite]} m {:keys [music friends]} favorite [{:keys [genre]}] music]"><y>#</y><d>2021-04-03</d><h>13:44</h><w>raspasov</w><code>(auto-destructure</code>
      <code>{:name     :alice</code>
       <code>:favorite {:music   [{:genre :rock}</code>
                            <code>{:genre :trance}]</code>
                  <code>:friends #{:bob :clara}}})</code>
   ;=&gt;
   <code>[{:keys [name favorite]} m</code>
    <code>{:keys [music friends]} favorite</code>
    <code>[{:keys [genre]}] music]</code></z><z id="t1617472549" t="noprompt Hey folks, I’ve been on vacation which is why I haven’t replied to any messages recently. I will be more responsive starting Monday. 🙂"><y>#</y><d>2021-04-03</d><h>17:55</h><w>noprompt</w>Hey folks, I’ve been on vacation which is why I haven’t replied to any messages recently. I will be more responsive starting Monday. <b>🙂</b></z><z id="t1617579642" t="markaddleman I have a meander puzzler: Use rewrite to efficiently fully qualify column references in a honeysql data structure. For example: {:select [:a] :from [:t]} should be converted into {:select [:t.a] :from [:t]} There are many complicating factors including identifying column references. In my case, all column references are a special type so, the above example is more properly: {:select [#ColRef[:a]] :from [#TableRef[:t]]} converted to {:select [#ColRef[:t :a]] :from [#TableRef[:t]]} There are additional complications that are not as easy to handle including subqueries. For example: {:select [#ColRef[:a] {:select #call[&quot;MAX&quot; :a] :from [#TableRef[:s]]}] :from [#TableRef[:t]]} Another complication is that some column references are already fully qualified and, thus, should not be rewritten: {:select [#colRef[:a]] :from [#TableRef[:t]] :where #call[&quot;IN&quot; #ColRef[:b] {:select [#ColRef[:b]] :from [#TableRef[:s]] :where #Call[&quot;=&quot; #ColRef[:t :a] #ColRef[:s :a]]}}"><y>#</y><d>2021-04-04</d><h>23:40</h><w>markaddleman</w>I have a meander puzzler:  Use <code>rewrite</code> to efficiently fully qualify column references in a honeysql data structure.   For example:
<pre>{:select [:a] :from [:t]} </pre>
should be converted into
<pre>{:select [:t.a] :from [:t]}</pre>
There are many complicating factors including identifying column references.  In my case, all column references are a special type so, the above example is more properly:
<pre>{:select [#ColRef[:a]] :from [#TableRef[:t]]}</pre>
converted to
<pre>{:select [#ColRef[:t :a]] :from [#TableRef[:t]]}</pre>
There are additional complications that are not as easy to handle including subqueries.  For example:
<pre>{:select [#ColRef[:a] {:select #call[&quot;MAX&quot; :a] :from [#TableRef[:s]]}] :from [#TableRef[:t]]}</pre>
Another complication is that some column references are already fully qualified and, thus, should not be rewritten:
<pre>{:select [#colRef[:a]] :from [#TableRef[:t]] :where #call[&quot;IN&quot; #ColRef[:b] {:select [#ColRef[:b]] :from [#TableRef[:s]] :where #Call[&quot;=&quot; #ColRef[:t :a] #ColRef[:s :a]]}}</pre></z><z id="t1617579728" t="markaddleman I have a meander program that performs the correct rewriting but pretty slow on large honeysql data structures because (I believe) an overuse of m/$ to search for queries and column references. I don&apos;t know how to convert it to a more efficient meander program and would love some ideas"><y>#</y><d>2021-04-04</d><h>23:42</h><w>markaddleman</w>I have a meander program that performs the correct rewriting but pretty slow on large honeysql data structures because (I believe) an overuse of <code>m/$</code> to search for queries and column references.  I don&apos;t know how to convert it to a more efficient meander program and would love some ideas</z><z id="t1617639958" t="noprompt [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] Would you be comfortable with collaborating on this with a gist or repo?"><y>#</y><d>2021-04-05</d><h>16:25</h><w>noprompt</w><a>@markaddleman</a> Would you be comfortable with collaborating on this with a gist or repo?</z><z id="t1617641069" t="markaddleman Absolutely. I&apos;ll provide a gist of my current code and a few test cases later this evening."><y>#</y><d>2021-04-05</d><h>16:44</h><r>markaddleman</r>Absolutely.  I&apos;ll provide a gist of my current code and a few test cases later this evening.</z><z id="t1617643691" t="noprompt Fantastic. My schedule is often unpredictable and I want to help with these things but I tend to forget when Slack eats the message history. A repo is easier for me to track in a browser tab etc."><y>#</y><d>2021-04-05</d><h>17:28</h><r>noprompt</r>Fantastic. My schedule is often unpredictable and I want to help with these things but I tend to forget when Slack eats the message history. A repo is easier for me to track in a browser tab etc.</z><z id="t1617756115" t="markaddleman fyi - I have been pulled away from this but it&apos;s still on my list. I&apos;m hoping to providing the gists this weekend"><y>#</y><d>2021-04-07</d><h>00:41</h><r>markaddleman</r>fyi - I have been pulled away from this but it&apos;s still on my list.  I&apos;m hoping to providing the gists this weekend</z><z id="t1617816046" t="noprompt Not a problem. Life is real. 😉"><y>#</y><d>2021-04-07</d><h>17:20</h><r>noprompt</r>Not a problem. Life is real. <b>😉</b></z><z id="t1617640010" t="noprompt The limitations of Slack and all."><y>#</y><d>2021-04-05</d><h>16:26</h><w>noprompt</w>The limitations of Slack and all.</z><z id="t1617701502" t="ribelo is there any way to use recur inside match / rewrite ?"><y>#</y><d>2021-04-06</d><h>09:31</h><w>ribelo</w>is there any way to use <code>recur</code> inside <code>match</code> / <code>rewrite</code> ?</z><z id="t1617701564" t="ribelo i would like to use a meander inside loop"><y>#</y><d>2021-04-06</d><h>09:32</h><w>ribelo</w>i would like to use a meander inside <code>loop</code></z><z id="t1617714182" t="Jimmy Miller In rewrite m/cata is basically recur. On the rhs it acts just like recur. On the left hand side you can match on the result of recurring. Which is a little trippy."><y>#</y><d>2021-04-06</d><h>13:03</h><w>Jimmy Miller</w>In rewrite <code>m/cata</code> is basically recur. On the rhs it acts just like recur. On the left hand side you can match on the result of recurring. Which is a little trippy.</z><z id="t1617725777" t="noprompt (loop [,,,] (match x (recur ,,,)) Does not work at the moment due to the way matches are compiled. If you’re able to, use reduce . This is a solvable problem for match /`find` but I cannot prioritize it."><y>#</y><d>2021-04-06</d><h>16:16</h><w>noprompt</w><pre>(loop [,,,]
  (match x (recur ,,,))</pre>
Does not work at the moment due to the way matches are compiled. If you’re able to, use <code>reduce</code>. This is a solvable problem for <code>match</code>/`find` but I cannot prioritize it.</z><z id="t1617835943" t="ribelo Is it possible to remove one key from map with meander?"><y>#</y><d>2021-04-07</d><h>22:52</h><w>ribelo</w>Is it possible to remove one key from map with meander?</z><z id="t1617835984" t="ribelo I know I can rewrite all keys except one, but with a large number of keys this doesn&apos;t sound like a good solution"><y>#</y><d>2021-04-07</d><h>22:53</h><w>ribelo</w>I know I can rewrite all keys except one, but with a large number of keys this doesn&apos;t sound like a good solution</z><z id="t1617836122" t="noprompt (m/rewrite {:a 1 :b 2 :c 3} {:a _ &amp; ?rest} ?rest) ;; =&gt; {:b 2, :c 3} Like this?"><y>#</y><d>2021-04-07</d><h>22:55</h><w>noprompt</w><pre>(m/rewrite {:a 1 :b 2 :c 3}
  {:a _ &amp; ?rest}
  ?rest)
;; =&gt; 
{:b 2, :c 3}</pre>
Like this?</z><z id="t1617836176" t="noprompt This almost compiles to (dissoc m :a)"><y>#</y><d>2021-04-07</d><h>22:56</h><w>noprompt</w>This almost compiles to <code>(dissoc m :a)</code></z><z id="t1617836203" t="ribelo Looks cool, but also doesn&apos;t seem to scale well for more operations"><y>#</y><d>2021-04-07</d><h>22:56</h><w>ribelo</w>Looks cool, but also doesn&apos;t seem to scale well for more operations</z><z id="t1617836231" t="noprompt In what way? Maybe I can help."><y>#</y><d>2021-04-07</d><h>22:57</h><w>noprompt</w>In what way? Maybe I can help.</z><z id="t1617836256" t="ribelo I will give you an example, 1s"><y>#</y><d>2021-04-07</d><h>22:57</h><w>ribelo</w>I will give you an example, 1s</z><z id="t1617836265" t="noprompt I’ve been staring at something else all day and I want an excuse to look at something else. 🙂"><y>#</y><d>2021-04-07</d><h>22:57</h><w>noprompt</w>I’ve been staring at something else all day and I want an excuse to look at something else. <b>🙂</b></z><z id="t1617836292" t="noprompt Errr, that was redundant but I think you know what I’m saying."><y>#</y><d>2021-04-07</d><h>22:58</h><w>noprompt</w>Errr, that was redundant but I think you know what I’m saying.</z><z id="t1617836390" t="noprompt 1s?"><y>#</y><d>2021-04-07</d><h>22:59</h><w>noprompt</w>1s?</z><z id="t1617836419" t="noprompt OH. YOU MEAN ONE SECOND."><y>#</y><d>2021-04-07</d><h>23:00</h><w>noprompt</w>OH. YOU MEAN ONE SECOND.</z><z id="t1617836423" t="noprompt 😂"><y>#</y><d>2021-04-07</d><h>23:00</h><w>noprompt</w><b>😂</b></z><z id="t1617836423" t="ribelo (m/rewrite {:a 1 :b 2 :c 3 :d 4 :e 5} {:a ?a :b ?b :c ?c :d ?d :as ?m} {&amp; ?m :a ~(+ ?a ?b) :b :swap/dissoc :c ~(+ ?c ?d) :d :swap/dissoc :e :swap/dissoc}) ;; =&gt; {:a 3, :c 7} "><y>#</y><d>2021-04-07</d><h>23:00</h><w>ribelo</w><pre>(m/rewrite {:a 1 :b 2 :c 3 :d 4 :e 5}
  {:a ?a :b ?b :c ?c :d ?d :as ?m}
  {&amp; ?m
   :a ~(+ ?a ?b)
   :b :swap/dissoc
   :c ~(+ ?c ?d)
   :d :swap/dissoc
   :e :swap/dissoc})
;; =&gt; {:a 3, :c 7}</pre>
</z><z id="t1617836462" t="ribelo let&apos;s say I want to remove the keys from :swap/dissoc"><y>#</y><d>2021-04-07</d><h>23:01</h><w>ribelo</w>let&apos;s say I want to remove the keys from <code>:swap/dissoc</code></z><z id="t1617836661" t="noprompt By “scale” you mean in terms what you must write?"><y>#</y><d>2021-04-07</d><h>23:04</h><w>noprompt</w>By “scale” you mean in terms what you must write?</z><z id="t1617836667" t="ribelo yes"><y>#</y><d>2021-04-07</d><h>23:04</h><w>ribelo</w>yes</z><z id="t1617836678" t="noprompt Gotcha"><y>#</y><d>2021-04-07</d><h>23:04</h><w>noprompt</w>Gotcha</z><z id="t1617836721" t="ribelo there is a NONE in the specter that can be used to remove keys or other items and overall it useful"><y>#</y><d>2021-04-07</d><h>23:05</h><w>ribelo</w>there is a <code>NONE</code> in the specter that can be used to remove keys or other items and overall it useful</z><z id="t1617836749" t="noprompt I guess I would have written it as (m/rewrite {:a 1 :b 2 :c 3 :d 4 :e 5} {:a ?a :b ?b :c ?c :d ?d :e _ &amp; ?m} {:a ~(+ ?a ?b) :c ~(+ ?c ?d) &amp; ?m}) ;; =&gt; {:a 3, :c 7} (grabbing the :e ) but I see what you mean."><y>#</y><d>2021-04-07</d><h>23:05</h><w>noprompt</w>I guess I would have written it as
<pre>(m/rewrite {:a 1 :b 2 :c 3 :d 4 :e 5}
  {:a ?a :b ?b :c ?c :d ?d :e _ &amp; ?m}
  {:a ~(+ ?a ?b)
   :c ~(+ ?c ?d)
   &amp; ?m})
;; =&gt; {:a 3, :c 7}</pre>
(grabbing the <code>:e</code>) but I see what you mean.</z><z id="t1617836825" t="noprompt Note I’m using &amp; on the left not :as ."><y>#</y><d>2021-04-07</d><h>23:07</h><w>noprompt</w>Note I’m using <code>&amp;</code> on the left not <code>:as</code>.</z><z id="t1617836857" t="noprompt But maybe there is a reason you’re using :as and not &amp; ?"><y>#</y><d>2021-04-07</d><h>23:07</h><w>noprompt</w>But maybe there is a reason you’re using <code>:as</code> and not <code>&amp;</code> ?</z><z id="t1617837051" t="ribelo actually there&apos;s no reason, that&apos;s the way I used to write, but I&apos;m about to check what&apos;s faster and to what code it expands"><y>#</y><d>2021-04-07</d><h>23:10</h><w>ribelo</w>actually there&apos;s no reason, that&apos;s the way I used to write, but I&apos;m about to check what&apos;s faster and to what code it expands</z><z id="t1617837092" t="noprompt Cleaning up all the nested let s its roughly (let [R__37813 (let [TARGET__37806 {:a 1, :b 2, :c 3, :d 4, :e 5} T__37811 (.valAt TARGET__37806 :e) T__37810 (.valAt TARGET__37806 :d) T__37809 (.valAt TARGET__37806 :c) T__37808 (.valAt TARGET__37806 :b) T__37807 (.valAt TARGET__37806 :a) ?a T__37807 ?b T__37808 ?c T__37809 ?d T__37810 T__37812 (dissoc TARGET__37806 :a :b :c :d :e) ?m T__37812 form__28292__auto__ {:a (+ ?a ?b), :c (+ ?c ?d)}] (merge (into {} ?m) form__28292__auto__))] (if (meander.match.runtime.epsilon/fail? R__37813) nil R__37813)) "><y>#</y><d>2021-04-07</d><h>23:11</h><w>noprompt</w>Cleaning up all the nested <code>let</code>s its roughly
<pre>(let [R__37813 (let [TARGET__37806 {:a 1, :b 2, :c 3, :d 4, :e 5}
                     T__37811 (.valAt TARGET__37806 :e)
                     T__37810 (.valAt TARGET__37806 :d)
                     T__37809 (.valAt TARGET__37806 :c)
                     T__37808 (.valAt TARGET__37806 :b)
                     T__37807 (.valAt TARGET__37806 :a)
                     ?a T__37807
                     ?b T__37808
                     ?c T__37809
                     ?d T__37810
                     T__37812 (dissoc TARGET__37806 :a :b :c :d :e)
                     ?m T__37812
                     form__28292__auto__ {:a (+ ?a ?b), :c (+ ?c ?d)}]
                 (merge (into {} ?m) form__28292__auto__))]
  (if (meander.match.runtime.epsilon/fail? R__37813) nil R__37813))</pre>
</z><z id="t1617837170" t="noprompt The into bit there is slightly annoying because the epsilon compiler isn’t smart enough to know ?m is a map."><y>#</y><d>2021-04-07</d><h>23:12</h><w>noprompt</w>The <code>into</code> bit there is slightly annoying because the epsilon compiler isn’t smart enough to know <code>?m</code> is a map.</z><z id="t1617837217" t="ribelo Thanks for the advice, your way is indeed much faster, which after a bit of thought is pretty much obvious."><y>#</y><d>2021-04-07</d><h>23:13</h><w>ribelo</w>Thanks for the advice, your way is indeed much faster, which after a bit of thought is pretty much obvious.</z><z id="t1617837218" t="noprompt I’ve been thinking that what might satisfy people is to allow map keys to be extensible."><y>#</y><d>2021-04-07</d><h>23:13</h><w>noprompt</w>I’ve been thinking that what might satisfy people is to allow map keys to be extensible.</z><z id="t1617837285" t="noprompt I know that concision is important to people."><y>#</y><d>2021-04-07</d><h>23:14</h><w>noprompt</w>I know that concision is important to people.</z><z id="t1617837333" t="ribelo it&apos;s still awesome"><y>#</y><d>2021-04-07</d><h>23:15</h><w>ribelo</w>it&apos;s still awesome</z><z id="t1617837397" t="noprompt I feel a little bad because I’ve been hacking on zeta . If I don’t do it though, I’ll never release it."><y>#</y><d>2021-04-07</d><h>23:16</h><w>noprompt</w>I feel a little bad because I’ve been hacking on <code>zeta</code> . If I don’t do it though, I’ll never release it.</z><z id="t1617837457" t="ribelo specter never clicked in my head, using meander is much easier and more enjoyable"><y>#</y><d>2021-04-07</d><h>23:17</h><w>ribelo</w>specter never clicked in my head, using meander is much easier and more enjoyable</z><z id="t1617837490" t="noprompt Ah, thanks. That kind of support keeps me motivated to work on it. 🙂"><y>#</y><d>2021-04-07</d><h>23:18</h><w>noprompt</w>Ah, thanks. That kind of support keeps me motivated to work on it. <b>🙂</b></z><z id="t1617837490" t="ribelo I am waiting for the zeta impatiently and with flushed face"><y>#</y><d>2021-04-07</d><h>23:18</h><w>ribelo</w>I am waiting for the zeta impatiently and with flushed face</z><z id="t1617837613" t="noprompt Well hopefully it doesn’t take much longer. I spent a lot of time experimenting working to come up with something that could address all of the things people have asked for in terms of programmability and explainability."><y>#</y><d>2021-04-07</d><h>23:20</h><w>noprompt</w>Well hopefully it doesn’t take much longer. I spent a lot of time experimenting working to come up with something that could address all of the things people have asked for in terms of programmability and explainability.</z><z id="t1617837653" t="noprompt The past month has been mostly on writing a lot of tests and organizing the project."><y>#</y><d>2021-04-07</d><h>23:20</h><w>noprompt</w>The past month has been mostly on writing a lot of tests and organizing the project.</z><z id="t1617837693" t="ribelo the nice thing about meander is that it doesn&apos;t so much describe individual actions, in which we can get lost, but it describes exactly the structure you have and the one we want, this allows you to figure out what the code is doing in a blink of an eye even after a long time"><y>#</y><d>2021-04-07</d><h>23:21</h><w>ribelo</w>the nice thing about meander is that it doesn&apos;t so much describe individual actions, in which we can get lost, but it describes exactly the structure you have and the one we want, this allows you to figure out what the code is doing in a blink of an eye even after a long time</z><z id="t1617837726" t="noprompt 100% the intended result and it makes me happy that I’ve heard this from many people."><y>#</y><d>2021-04-07</d><h>23:22</h><w>noprompt</w>100% the intended result and it makes me happy that I’ve heard this from many people.</z><z id="t1617837750" t="noprompt Hell, I enjoy seeing what people make with it and noticing the same thing!"><y>#</y><d>2021-04-07</d><h>23:22</h><w>noprompt</w>Hell, I enjoy seeing what people make with it and noticing the same thing!</z><z id="t1617837788" t="ribelo This is basically the opposite of all the automatic ways, which after some time become completely incomprehensible and we don&apos;t know what they really do and what the author had in mind."><y>#</y><d>2021-04-07</d><h>23:23</h><w>ribelo</w>This is basically the opposite of all the automatic ways, which after some time become completely incomprehensible and we don&apos;t know what they really do and what the author had in mind.</z><z id="t1617837800" t="noprompt I think having explanations will be a game changer for the library. 🤞"><y>#</y><d>2021-04-07</d><h>23:23</h><w>noprompt</w>I think having explanations will be a game changer for the library. <b>🤞</b></z><z id="t1617837819" t="noprompt Haha! Yes!"><y>#</y><d>2021-04-07</d><h>23:23</h><w>noprompt</w>Haha! Yes!</z><z id="t1617837825" t="noprompt That happens to me. 😐"><y>#</y><d>2021-04-07</d><h>23:23</h><w>noprompt</w>That happens to me. <b>😐</b></z><z id="t1617837912" t="ribelo what do you mean by having explanations ?"><y>#</y><d>2021-04-07</d><h>23:25</h><w>ribelo</w>what do you mean by <code>having explanations</code>?</z><z id="t1617838077" t="ribelo Anyway, I&apos;m keeping my fingers crossed for zeta , but I have to go"><y>#</y><d>2021-04-07</d><h>23:27</h><w>ribelo</w>Anyway, I&apos;m keeping my fingers crossed for <code>zeta</code>, but I have to go</z><z id="t1617838093" t="ribelo thanks again for the tip"><y>#</y><d>2021-04-07</d><h>23:28</h><w>ribelo</w>thanks again for the tip</z><z id="t1617839068" t="noprompt I mean that it will be possible to get an explanation for why a rewrite failed."><y>#</y><d>2021-04-07</d><h>23:44</h><w>noprompt</w>I mean that it will be possible to get an explanation for why a rewrite failed.</z><z id="t1617839223" t="noprompt This is useful for even small systems but becomes much more valuable as the system grows especially when cata is involved."><y>#</y><d>2021-04-07</d><h>23:47</h><w>noprompt</w>This is useful for even small systems but becomes much more valuable as the system grows especially when <code>cata</code> is involved.</z></g><g id="s10"><z id="t1617839458" t="ribelo cider debugger is an invaluable help, especially when it comes to cata"><y>#</y><d>2021-04-07</d><h>23:50</h><w>ribelo</w>cider debugger is an invaluable help, especially when it comes to <code>cata</code></z><z id="t1617903107" t="noprompt Hmm… I hadn’t thought of trying that. I’ve had mixed results using some of the cider tooling but most of that is due to printing."><y>#</y><d>2021-04-08</d><h>17:31</h><w>noprompt</w>Hmm… I hadn’t thought of trying that. I’ve had mixed results using some of the cider tooling but most of that is due to printing.</z><z id="t1617904015" t="ribelo it really works quite well, sometimes it jumps around in an incomprehensible way, but it is still a very useful tool"><y>#</y><d>2021-04-08</d><h>17:46</h><w>ribelo</w>it really works quite well, sometimes it jumps around in an incomprehensible way, but it is still a very useful tool</z><z id="t1617904033" t="noprompt I’ll have to try that out!"><y>#</y><d>2021-04-08</d><h>17:47</h><w>noprompt</w>I’ll have to try that out!</z><z id="t1617904070" t="ribelo you can also check what data is currently stored in variables, which also helps"><y>#</y><d>2021-04-08</d><h>17:47</h><w>ribelo</w>you can also check what data is currently stored in variables, which also helps</z><z id="t1617904098" t="ribelo I mean, you probably know anyway, but for someone who is just figuring out how it works, this should help"><y>#</y><d>2021-04-08</d><h>17:48</h><w>ribelo</w>I mean, you probably know anyway, but for someone who is just figuring out how it works, this should help</z><z id="t1617904190" t="noprompt Interesting. I’m going to give this a shot."><y>#</y><d>2021-04-08</d><h>17:49</h><w>noprompt</w>Interesting. I’m going to give this a shot.</z><z id="t1617922219" t="markaddleman (m/rewrite [[:a 1] [:b 2]] (m/seqable (m/$ !ctx (m/pred number? !n)) ...) (m/seqable (m/app !ctx (m/app inc !n)) ...)) Should something like this be allowed? The use case is something like, I don&apos;t care where a number is a data structure, I want to inc it"><y>#</y><d>2021-04-08</d><h>22:50</h><w>markaddleman</w><pre>(m/rewrite [[:a 1] [:b 2]]
    (m/seqable (m/$ !ctx (m/pred number? !n)) ...)
    (m/seqable (m/app !ctx (m/app inc !n)) ...))</pre>
Should something like this be allowed?

The use case is something like, I don&apos;t care where a number is a data structure, I want to <code>inc</code> it</z><z id="t1617983879" t="noprompt $* is supposed to this kinda thing but I just looked at it and noticed it wasn’t working."><y>#</y><d>2021-04-09</d><h>15:57</h><w>noprompt</w><code>$*</code> is supposed to this kinda thing but I just looked at it and noticed it wasn’t working.</z><z id="t1617983892" t="noprompt Which is annoying because I thought there were tests for it."><y>#</y><d>2021-04-09</d><h>15:58</h><w>noprompt</w>Which is annoying because I thought there were tests for it.</z><z id="t1617983916" t="noprompt I’ll fix that and then make a new release today."><y>#</y><d>2021-04-09</d><h>15:58</h><w>noprompt</w>I’ll fix that and then make a new release today.</z><z id="t1618007337" t="ribelo Is it possible to add a key to a map only if the value assigned to it is other than nil?"><y>#</y><d>2021-04-09</d><h>22:28</h><w>ribelo</w>Is it possible to add a key to a map only if the value assigned to it is other than nil?</z><z id="t1618007426" t="ribelo simple stupid example (m/rewrite {:a 1 :b 2} {:a ?a :b ?b :c ?c} {:a ?a :b ?b :c (if-not-nil ?c)}) ;; =&gt; {:a 1, :b 2} "><y>#</y><d>2021-04-09</d><h>22:30</h><w>ribelo</w>simple stupid example
<pre>(m/rewrite {:a 1 :b 2}
  {:a ?a :b ?b :c ?c}
  {:a ?a :b ?b :c (if-not-nil ?c)})
;; =&gt; {:a 1, :b 2}</pre>
</z><z id="t1618007522" t="ribelo I actually found this, but maybe there is an easier way? (m/rewrite {:a 1 :b 2} {:a ?a :b ?b :c ?c} {:a ?a :b ?b &amp; ~(when ?c [[:c ?c]])}) "><y>#</y><d>2021-04-09</d><h>22:32</h><w>ribelo</w>I actually found this, but maybe there is an easier way?
<pre>(m/rewrite {:a 1 :b 2}
  {:a ?a :b ?b :c ?c}
  {:a ?a :b ?b &amp; ~(when ?c [[:c ?c]])})</pre>
</z><z id="t1618250329" t="noprompt This is something that zeta will support, being able to use m/or on the right. epsilon could be retrofitted to do it but I’m not sure how long it would take in terms of implementation, testing, and supporting."><y>#</y><d>2021-04-12</d><h>17:58</h><w>noprompt</w>This is something that <code>zeta</code> will support, being able to use <code>m/or</code> on the right. <code>epsilon</code> could be retrofitted to do it but I’m not sure how long it would take in terms of implementation, testing, and supporting.</z><z id="t1618250488" t="noprompt (m/rewrite {:a 1 :b 2} {:a ?a :b ?b :c ?c} {:a ?a :b ?b &amp; (m/or (m/project ?c nil {}) {:c ?c})}) ;; =&gt; {:a 1, :b 2} (m/rewrite {:a 1 :b 2 :c 34} {:a ?a :b ?b :c ?c} {:a ?a :b ?b &amp; (m/or (m/project ?c nil {}) {:c ?c})}) ;; =&gt; {:a 1, :b 2, :c 34} "><y>#</y><d>2021-04-12</d><h>18:01</h><w>noprompt</w><pre>(m/rewrite {:a 1 :b 2}
  {:a ?a :b ?b :c ?c}
  {:a ?a :b ?b &amp; (m/or (m/project ?c nil {}) {:c ?c})})
;; =&gt; {:a 1, :b 2}
(m/rewrite {:a 1 :b 2 :c 34}
  {:a ?a :b ?b :c ?c}
  {:a ?a :b ?b &amp; (m/or (m/project ?c nil {}) {:c ?c})})
;; =&gt; {:a 1, :b 2, :c 34}</pre>
</z><z id="t1618250835" t="noprompt Also, I didn’t get a chance on Friday to look at the $* and wasn’t feeling well over the weekend so I’m going to try and find time this week."><y>#</y><d>2021-04-12</d><h>18:07</h><w>noprompt</w>Also, I didn’t get a chance on Friday to look at the <code>$*</code> and wasn’t feeling well over the weekend so I’m going to try and find time this week.</z><z id="t1618278687" t="wilkerlucio if I have a structure of data that has a bunch of attributes that are optional, what’s the best way to express this in the current meander epsilon?"><y>#</y><d>2021-04-13</d><h>01:51</h><w>wilkerlucio</w>if I have a structure of data that has a bunch of attributes that are optional, what’s the best way to express this in the current meander epsilon?</z><z id="t1618278696" t="wilkerlucio this is my example: {:address {:zipCode ?zipcode :city ?city :stateAcronym ?state-abbr :state ?state :streetNumber ?street-number :street ?street :complement ?address-complement :point {:lon ?lon :lat ?lat} :confidence ?address-confidence :neighborhood ?neighborhood :country ?country-abbr}}"><y>#</y><d>2021-04-13</d><h>01:51</h><r>wilkerlucio</r>this is my example:
<pre>{:address {:zipCode      ?zipcode
           :city         ?city
           :stateAcronym ?state-abbr
           :state        ?state
           :streetNumber ?street-number
           :street       ?street
           :complement   ?address-complement
           :point        {:lon ?lon
                          :lat ?lat}
           :confidence   ?address-confidence
           :neighborhood ?neighborhood
           :country      ?country-abbr}}</pre></z><z id="t1618278719" t="wilkerlucio right side: {:listing/zipcode ?zipcode :listing/city ?city :listing/state-abbr ?state-abbr :listing/state ?state :listing/street-number ?street-number :listing/street ?street :listing/address-complement ?address-complement :geo.point/lon ?lon :geo.point/lat ?lat}"><y>#</y><d>2021-04-13</d><h>01:51</h><r>wilkerlucio</r>right side:
<pre>{:listing/zipcode            ?zipcode
 :listing/city               ?city
 :listing/state-abbr         ?state-abbr
 :listing/state              ?state
 :listing/street-number      ?street-number
 :listing/street             ?street
 :listing/address-complement ?address-complement
 :geo.point/lon              ?lon
 :geo.point/lat              ?lat}</pre></z><z id="t1618278799" t="wilkerlucio in my case, every attribute match there is optional, is this an applicable usage? and if so, how should I do it?"><y>#</y><d>2021-04-13</d><h>01:53</h><r>wilkerlucio</r>in my case, every attribute match there is optional, is this an applicable usage? and if so, how should I do it?</z><z id="t1618280609" t="noprompt Without being too assumptive about your goals, I will say that for a situation like this, if you’re used to the destructure first ask questions later approach, then it’ll feel frustrating."><y>#</y><d>2021-04-13</d><h>02:23</h><r>noprompt</r>Without being too assumptive about your goals, I will say that for a situation like this, if you’re used to the destructure first ask questions later approach, then it’ll feel frustrating.</z><z id="t1618280841" t="noprompt Probably the best tool for situations like this would be m/search where each clause addresses a particular concern."><y>#</y><d>2021-04-13</d><h>02:27</h><r>noprompt</r>Probably the best tool for situations like this would be <code>m/search</code> where each clause addresses a particular concern.</z><z id="t1618280841" t="wilkerlucio the goal is to extract the information I can find, if my assumption is right that meander is caring a lot about matching all, these would be the opposite, a more relaxed way to do “match whatever you can”, and them nullify everything else (that can’t be matched), makes sense?"><y>#</y><d>2021-04-13</d><h>02:27</h><r>wilkerlucio</r>the goal is to extract the information I can find, if my assumption is right that meander is caring a lot about matching all, these would be the opposite, a more relaxed way to do “match whatever you can”, and them nullify everything else (that can’t be matched), makes sense?</z><z id="t1618280889" t="noprompt Yes, for this situation, I recommend using m/search where each clause can be as strict or as loose as you want."><y>#</y><d>2021-04-13</d><h>02:28</h><r>noprompt</r>Yes, for this situation, I recommend using <code>m/search</code> where each clause can be as strict or as loose as you want.</z><z id="t1618280992" t="wilkerlucio I think I don’t understand m/search well enough, can you show me what it looks like? (with my address template for example)"><y>#</y><d>2021-04-13</d><h>02:29</h><r>wilkerlucio</r>I think I don’t understand m/search well enough, can you show me what it looks like? (with my address template for example)</z><z id="t1618281061" t="noprompt Yeah. I’ll make a quick example but then I have to drop and take care of my kids. If my example doesn’t help, you can leave me some more requirements and I will try and reply in a couple hours. One second."><y>#</y><d>2021-04-13</d><h>02:31</h><r>noprompt</r>Yeah. I’ll make a quick example but then I have to drop and take care of my kids. If my example doesn’t help, you can leave me some more requirements and I will try and reply in a couple hours. One second.</z><z id="t1618281082" t="wilkerlucio (from the docs I understand search returns many outputs, in my case I still want a single map on the output)"><y>#</y><d>2021-04-13</d><h>02:31</h><r>wilkerlucio</r>(from the docs I understand search returns many outputs, in my case I still want a single map on the output)</z><z id="t1618281094" t="wilkerlucio no worries, whenever you have the time, thanks 👍"><y>#</y><d>2021-04-13</d><h>02:31</h><r>wilkerlucio</r>no worries, whenever you have the time, thanks <b>👍</b></z><z id="t1618281487" t="wilkerlucio I’m playing with search to try it out, this looks good: (m/search {:a 1} {:a ?a :b ?b :c ?c} [?a ?b ?c]) =&gt; ([1 nil nil])"><y>#</y><d>2021-04-13</d><h>02:38</h><r>wilkerlucio</r>I’m playing with search to try it out, this looks good:

<pre>(m/search {:a 1}
    {:a ?a :b ?b :c ?c}
    [?a ?b ?c])
=&gt; ([1 nil nil])</pre></z><z id="t1618281536" t="wilkerlucio but if the query goes a bit deeper like: (m/search {:a 1} {:a ?a :b [?b] :c ?c} [?a ?b ?c]) =&gt; nil Then I got just nil"><y>#</y><d>2021-04-13</d><h>02:38</h><r>wilkerlucio</r>but if the query goes a bit deeper like:
<pre>(m/search {:a 1}
    {:a ?a :b [?b]  :c ?c}
    [?a ?b ?c])
=&gt; nil</pre>
Then I got just <code>nil</code></z><z id="t1618281602" t="wilkerlucio similar to matching nested maps, if the parent is there its ok (even if the map is only partially matched): (m/search {:a 1 :c {:d &quot;d&quot;}} {:a ?a :b ?b :c {:d ?d :e ?e}} [?a ?b ?d ?e]) =&gt; ([1 nil &quot;d&quot; nil])"><y>#</y><d>2021-04-13</d><h>02:40</h><r>wilkerlucio</r>similar to matching nested maps, if the parent is there its ok (even if the map is only partially matched):

<pre>(m/search {:a 1 :c {:d &quot;d&quot;}}
    {:a ?a :b ?b :c {:d ?d :e ?e}}
    [?a ?b ?d ?e])
=&gt; ([1 nil &quot;d&quot; nil])</pre></z><z id="t1618281630" t="wilkerlucio but goes nil if :c is out: (m/search {:a 1} {:a ?a :b ?b :c {:d ?d :e ?e}} [?a ?b ?d ?e]) =&gt; nil"><y>#</y><d>2021-04-13</d><h>02:40</h><r>wilkerlucio</r>but goes <code>nil</code> if <code>:c</code> is out:

<pre>(m/search {:a 1}
    {:a ?a :b ?b :c {:d ?d :e ?e}}
    [?a ?b ?d ?e])
=&gt; nil</pre></z><z id="t1618281682" t="wilkerlucio I can totally understand if my case is out of scope, but what I’m looking for is something that can just ignore everything that can’t be matched, and just return whatever was possible to match, hope these examples can help to understand the situation 🙏"><y>#</y><d>2021-04-13</d><h>02:41</h><r>wilkerlucio</r>I can totally understand if my case is out of scope, but what I’m looking for is something that can just ignore everything that can’t be matched, and just return whatever was possible to match, hope these examples can help to understand the situation <b>🙏</b></z><z id="t1618281802" t="noprompt Sorry, I keep getting interrupted by kids but here’s a silly example of what I meant. (let [address {:zipCode &quot;12345&quot;}] (into {:point? false :zip-code? false} (me/search address {:point {:lon _, :lat _}} [:coordinates? true] {:zipCode (me/pred string? ?zip)} [:zip-code? true]))) ;; =&gt; {:point? false, :zip-code? true} (I’m using me as the my alias instead of m ). But the idea is to search for what you’re looking and if you’re making a map then the right sides return pairs."><y>#</y><d>2021-04-13</d><h>02:43</h><r>noprompt</r>Sorry, I keep getting interrupted by kids but here’s a silly example of what I meant.
<pre>(let [address {:zipCode &quot;12345&quot;}]
  (into {:point? false
         :zip-code? false}
        (me/search address
          {:point {:lon _, :lat _}}
          [:coordinates? true]

          {:zipCode (me/pred string? ?zip)}
          [:zip-code? true])))
;; =&gt;
{:point? false, :zip-code? true}</pre>
(I’m using <code>me</code> as the my alias instead of <code>m</code>).

But the idea is to search for what you’re looking and if you’re making a map then the right sides return pairs.</z><z id="t1618281828" t="wilkerlucio I just got to this code here too 🙂 (m/search {:a 1 :b [3]} {:a ?a} {:aa ?a} {:b [?b]} {:bb ?b} {:c {:d ?d :e ?e}} {:dd ?d :ee ?e})"><y>#</y><d>2021-04-13</d><h>02:43</h><r>wilkerlucio</r>I just got to this code here too <b>🙂</b>
<pre>(m/search {:a 1 :b [3]}
    {:a ?a} {:aa ?a}

    {:b [?b]} {:bb ?b}
    
    {:c {:d ?d :e ?e}} {:dd ?d :ee ?e})</pre></z><z id="t1618281855" t="wilkerlucio cool, I think makes sense"><y>#</y><d>2021-04-13</d><h>02:44</h><r>wilkerlucio</r>cool, I think makes sense</z><z id="t1618281871" t="wilkerlucio thanks!"><y>#</y><d>2021-04-13</d><h>02:44</h><r>wilkerlucio</r>thanks!</z><z id="t1618281916" t="noprompt NP. This would probably be a good thing to stick in the cookbook."><y>#</y><d>2021-04-13</d><h>02:45</h><r>noprompt</r>NP. This would probably be a good thing to stick in the cookbook.</z><z id="t1618282068" t="noprompt You can use this approach in different ways, validation is one example where you can return a sequence of errors, etc."><y>#</y><d>2021-04-13</d><h>02:47</h><r>noprompt</r>You can use this approach in different ways, validation is one example where you can return a sequence of errors, etc.</z><z id="t1618282196" t="noprompt Anyway, if you have more questions ask them here or in the main channel. Also, I’m keen to hear your frustrations as well. I’ve been working on the next version of the library and I’m trying to address all of the negative feedback, pain, and suffering I’ve gotten over the years. 🙂"><y>#</y><d>2021-04-13</d><h>02:49</h><r>noprompt</r>Anyway, if you have more questions ask them here or in the main channel. Also, I’m keen to hear your frustrations as well. I’ve been working on the next version of the library and I’m trying to address all of the negative feedback, pain, and suffering I’ve gotten over the years. <b>🙂</b></z><z id="t1618282248" t="wilkerlucio no worries, I found meander one of the most amazing things to data transformation, really great job here!"><y>#</y><d>2021-04-13</d><h>02:50</h><r>wilkerlucio</r>no worries, I found meander one of the most amazing things to data transformation, really great job here!</z><z id="t1618282290" t="wilkerlucio I love the clarity of being able to look at the source and target structures in a simple way, and excited for the next gen that’s is coming 🙂"><y>#</y><d>2021-04-13</d><h>02:51</h><r>wilkerlucio</r>I love the clarity of being able to look at the source and target structures in a simple way, and excited for the next gen that’s is coming <b>🙂</b></z><z id="t1618282495" t="noprompt Me too! 😅 The support from folks in this channel has been inspiring."><y>#</y><d>2021-04-13</d><h>02:54</h><r>noprompt</r>Me too! <b>😅</b> The support from folks in this channel has been inspiring.</z><z id="t1618282600" t="wilkerlucio I believe you saw you saying something about allowing (m/or) in the right side for the next version, I guess with that I would be able to just put m/or in each output option to solve this case, did I get it right?"><y>#</y><d>2021-04-13</d><h>02:56</h><r>wilkerlucio</r>I believe you saw you saying something about allowing <code>(m/or)</code> in the right side for the next version, I guess with that I would be able to just put <code>m/or</code> in each output option to solve this case, did I get it right?</z><z id="t1618347841" t="noprompt Yes. The reason epsilon and prior versions have never had m/or on the right side was because I did not have a notion of “substitution failure”. In the near future, for rewriting, it will be legal to use m/or on the right and relax restrictions on variables needing to be bound. If you use a variable on the right side which is was not bound then that will fail. (m/rewrite [1] [?x &amp; (m/or [?y ?z] _)] [?x (m/or ?y 2) (m/or ?z 3)]) ;; =&gt; [1 2 3] "><y>#</y><d>2021-04-13</d><h>21:04</h><r>noprompt</r>Yes. The reason <code>epsilon</code> and prior versions have never had <code>m/or</code> on the right side was because I did not have a notion of “substitution failure”. In the near future, for rewriting, it will be legal to use <code>m/or</code> on the right and relax restrictions on variables needing to be bound. If you use a variable on the right side which is was not bound then that will fail.

<pre>(m/rewrite [1]
  [?x &amp; (m/or [?y ?z] _)]
  [?x (m/or ?y 2) (m/or ?z 3)])
;; =&gt;
[1 2 3]</pre>
</z><z id="t1618347941" t="noprompt To me, this makes sense because, in practice, the time we actually care about a variable being unbound is when we need to “use” it."><y>#</y><d>2021-04-13</d><h>21:05</h><r>noprompt</r>To me, this makes sense because, in practice, the time we actually care about a variable being unbound is when we need to “use” it.</z><z id="t1618347977" t="noprompt And people sort of do this kind of thing all the time with nil except the semantics of failure is rather ad-hoc."><y>#</y><d>2021-04-13</d><h>21:06</h><r>noprompt</r>And people sort of do this kind of thing all the time with <code>nil</code> except the semantics of failure is rather ad-hoc.</z><z id="t1618348585" t="noprompt So here we get something that feels both dynamic and static. Dynamic in the sense that we can build things we accept and return different shapes of data, and static in the sense that these constraints provide some very nice properties in exchange for giving up some control."><y>#</y><d>2021-04-13</d><h>21:16</h><r>noprompt</r>So here we get something that feels both dynamic and static. Dynamic in the sense that we can build things we accept and return different shapes of data, and static in the sense that these constraints provide some very nice properties in exchange for giving up some control.</z><z id="t1618348707" t="noprompt I’m inspired by Haskell and Peyton Jones: steadily growing the language to accept more and more programs without compromising on core value propositions."><y>#</y><d>2021-04-13</d><h>21:18</h><r>noprompt</r>I’m inspired by Haskell and Peyton Jones: steadily growing the language to accept more and more programs without compromising on core value propositions.</z><z id="t1618349254" t="wilkerlucio sounds great, looking forward to it 👍"><y>#</y><d>2021-04-13</d><h>21:27</h><r>wilkerlucio</r>sounds great, looking forward to it <b>👍</b></z><z id="t1618679944" t="ribelo a simple db that copies the functionality of datascript, using meander as a query tool https://github.com/ribelo/doxa/"><y>#</y><d>2021-04-17</d><h>17:19</h><w>ribelo</w>a simple db that copies the functionality of datascript, using meander as a query tool
<a href="https://github.com/ribelo/doxa/" target="_blank">https://github.com/ribelo/doxa/</a></z><z id="t1618759881" t="Carlo Hey, I have a question on some code I wrote to do parsing for an advent of code problem: (meander/defsyntax keywordize [a b] `(meander/app #(keyword (str %1 &quot;-&quot; %2)) ~a ~b)) (meander/defsyntax to-map [a] `(meander/app (partial apply hash-map) ~a)) (meander/defsyntax parse-int [str] `(meander/app #(Integer/parseInt %) ~str)) (defn parse-description [description] (meander/rewrite (str/split description #&quot; &quot;) [?adj ?col _ &quot;contain&quot; . !ns !adjs !cols _ ...] {(keywordize ?adj ?col) (to-map [(keywordize !adjs !cols) (parse-int !ns) ...])})) (def example &quot;plaid magenta bags contain 2 clear lavender bags, 3 clear teal bags, 4 vibrant gold bags.&quot;) (parse-description example) ;; {:plaid-magenta {:clear-lavender 2, :vibrant-gold 4, :clear-teal 3}} The solution is beautifully concise, but there&apos;s a bit more verbosity in the third argument of meander/rewrite because I want to slightly transform the output (unifying two memory variables in a keyboard, get the parse of another, etc. This brings me to define all those defsyntax rule. Is there a way to accomplish this with less ceremony and more clarity? (ps meander is beautiful)"><y>#</y><d>2021-04-18</d><h>15:31</h><w>Carlo</w>Hey, I have a question on some code I wrote to do parsing for an advent of code problem:
<pre>(meander/defsyntax keywordize [a b]
  `(meander/app #(keyword (str %1 &quot;-&quot; %2)) ~a ~b))

(meander/defsyntax to-map [a]
  `(meander/app (partial apply hash-map) ~a))

(meander/defsyntax parse-int [str]
  `(meander/app #(Integer/parseInt %) ~str))

(defn parse-description [description]
  (meander/rewrite
   (str/split description #&quot; &quot;)
   [?adj ?col _ &quot;contain&quot; . !ns !adjs !cols _ ...]
   {(keywordize ?adj ?col) (to-map [(keywordize !adjs !cols) (parse-int !ns) ...])}))

(def example
  &quot;plaid magenta bags contain 2 clear lavender bags, 3 clear teal bags, 4 vibrant gold bags.&quot;)

(parse-description example)
;; {:plaid-magenta {:clear-lavender 2, :vibrant-gold 4, :clear-teal 3}}</pre>
The solution is beautifully concise, but there&apos;s a bit more verbosity in the third argument of <code>meander/rewrite</code> because I want to slightly transform the output (unifying two memory variables in a keyboard, get the parse of another, etc. This brings me to define all those <code>defsyntax</code> rule. Is there a way to accomplish this with less ceremony and more clarity? (ps meander is beautiful)</z><z id="t1618762365" t="Carlo reading the code, I discovered meander/map-of with which I can slightly clean the code and get rid of my to-map . The other two definitions still stand though, I&apos;d really like to at least turn them in inline constructs"><y>#</y><d>2021-04-18</d><h>16:12</h><r>Carlo</r>reading the code, I discovered <code>meander/map-of</code> with which I can slightly clean the code and get rid of my <code>to-map</code>. The other two definitions still stand though, I&apos;d really like to at least turn them in inline constructs</z><z id="t1618763032" t="Carlo Ok, this is the version I&apos;m happy with ❤️"><y>#</y><d>2021-04-18</d><h>16:23</h><r>Carlo</r>Ok, this is the version I&apos;m happy with <b>❤️</b></z><z id="t1618769390" t="Jimmy Miller Looks pretty great to me! Glad you were able to figure things out"><y>#</y><d>2021-04-18</d><h>18:09</h><r>Jimmy Miller</r>Looks pretty great to me! Glad you were able to figure things out</z><z id="t1618800426" t="Richie Hey, I’m trying to get started with meander. (let [data {:a {:b &quot;hi&quot;}}] (let [?x (m/match data {:a {:b ?x}} ?x)] (m/subst {:a {:b ?x}}))) This works fine but I don’t want to repeat the shape that I’m matching against. (let [data {:a {:b &quot;hi&quot;}}] (let [shape &apos;{:a {:b ?x}} ?x (m/match data ~shape ?x)] (m/subst ~shape))) How do I pull the shape out?"><y>#</y><d>2021-04-19</d><h>02:47</h><w>Richie</w>Hey, I’m trying to get started with meander.
<pre>(let [data {:a {:b &quot;hi&quot;}}]
  (let [?x (m/match data
                    {:a {:b ?x}}
                    ?x)]
   (m/subst {:a {:b ?x}})))</pre>
This works fine but I don’t want to repeat the shape that I’m matching against.
<pre>(let [data {:a {:b &quot;hi&quot;}}]
  (let [shape &apos;{:a {:b ?x}}
        ?x (m/match data
                    ~shape
                    ?x)]
    (m/subst ~shape)))</pre>
How do I pull the shape out?</z><z id="t1618800748" t="Richie More context for what I’m trying to accomplish: I want to get data out, apply a function, and then put the data back. I started with lenses but that got messy fast. (lens/over (lens/in [:a :b]) reverse {:a {:b &quot;hi&quot;}}) ;; {:a {:b (&quot;i&quot; &quot;h&quot;)}} "><y>#</y><d>2021-04-19</d><h>02:52</h><w>Richie</w>More context for what I’m trying to accomplish: I want to get data out, apply a function, and then put the data back. I started with lenses but that got messy fast.
<pre>(lens/over
 (lens/in [:a :b])
 reverse
 {:a {:b &quot;hi&quot;}}) ;; {:a {:b (&quot;i&quot; &quot;h&quot;)}}</pre>
</z><z id="t1618801140" t="Jimmy Miller So for meander, if you find yourself quoting things to try and make things more concise, you are probably not going to have a great time. We do have an interpreter for more dynamic things. But, in general, we value clarity over concision. So, you might repeat yourself a couple times, but we think it pays off. Here are two examples that might help with the sorts of things you are looking to do. (m/match {:a {:b &quot;hi&quot;}} {:a {:b ?x}} {:a {:b (string/reverse ?x)}}) (m/rewrite {:a {:b [&quot;things&quot; &quot;here&quot;]}} {:a {:b [!xs ...]}} {:a {:b [(m/app string/reverse !xs) ...]}})"><y>#</y><d>2021-04-19</d><h>02:59</h><w>Jimmy Miller</w>So for meander, if you find yourself quoting things to try and make things more concise, you are probably not going to have a great time. We do have an interpreter for more dynamic things. But, in general, we value clarity over concision. So, you might repeat yourself a couple times, but we think it pays off. Here are two examples that might help with the sorts of things you are looking to do.

<pre>(m/match {:a {:b &quot;hi&quot;}}
  {:a {:b ?x}}
  {:a {:b (string/reverse ?x)}})


(m/rewrite {:a {:b [&quot;things&quot; &quot;here&quot;]}}
  {:a {:b [!xs ...]}}
  {:a {:b [(m/app string/reverse !xs) ...]}})</pre></z><z id="t1618834985" t="Richie Ok, thank you."><y>#</y><d>2021-04-19</d><h>12:23</h><w>Richie</w>Ok, thank you.</z><z id="t1618931410" t="euccastro suppose I have a map like {:id 1 :label &quot;the gizmo label&quot; :type.id 5 :type.label &quot;the type label&quot; :owner.id 8 :owner.name &quot;John Shutt&quot;}"><y>#</y><d>2021-04-20</d><h>15:10</h><w>euccastro</w>suppose I have a map like
<pre>{:id 1
   :label &quot;the gizmo label&quot;
   :type.id 5
   :type.label &quot;the type label&quot;
   :owner.id 8
   :owner.name &quot;John Shutt&quot;}</pre></z><z id="t1618931441" t="euccastro and I want to convert it to this format: {:id 1 :label &quot;the gizmo label&quot; :type {:id 5 :label &quot;the type label&quot;} :owner {:id 8 :name &quot;John Shutt&quot;}}"><y>#</y><d>2021-04-20</d><h>15:10</h><w>euccastro</w>and I want to convert it to this format:
<pre>{:id 1
   :label &quot;the gizmo label&quot;
   :type {:id 5 :label &quot;the type label&quot;}
   :owner {:id 8 :name &quot;John Shutt&quot;}}</pre></z><z id="t1618931488" t="euccastro (i.e., a dot in the keys causes nesting, and I don&apos;t know any key names statically)"><y>#</y><d>2021-04-20</d><h>15:11</h><w>euccastro</w>(i.e., a dot in the keys causes nesting, and I don&apos;t know any key names statically)</z><z id="t1618931519" t="euccastro I have a few questions. first one: how do you accumulate into a map?"><y>#</y><d>2021-04-20</d><h>15:11</h><w>euccastro</w>I have a few questions.  first one: how do you accumulate into a map?</z><z id="t1618933758" t="euccastro in plain Clojure this transformation would be: (defn nest-dots [m] (reduce-kv (fn [m&apos; k v] (assoc-in m&apos; (map keyword (string/split (name k) #&quot;\.&quot;)) v)) {} m)) (with possibly nested dots, which is not really a requirement) do you think there&apos;s a more understandable/transparent meander implementation?"><y>#</y><d>2021-04-20</d><h>15:49</h><w>euccastro</w>in plain Clojure this transformation would be:
<pre>(defn nest-dots
  [m]
  (reduce-kv
   (fn [m&apos; k v]
     (assoc-in m&apos;
               (map keyword (string/split (name k) #&quot;\.&quot;))
               v))
   {}
   m))</pre>
(with possibly nested dots, which is not really a requirement)

do you think there&apos;s a more understandable/transparent meander implementation?</z><z id="t1618935247" t="noprompt (me/rewrite m {:id ?id :label ?label :type.id ?type-id :type.label ?type-label :owner.id ?owner-id :owner.name ?owner-name} {:id ?id :label ?label :type {:id ?type-id :label ?type-label} :owner {:id ?owner-id :name ?owner-name}}) "><y>#</y><d>2021-04-20</d><h>16:14</h><w>noprompt</w><pre>(me/rewrite m
  {:id ?id
   :label ?label
   :type.id ?type-id
   :type.label ?type-label
   :owner.id ?owner-id
   :owner.name ?owner-name}
  {:id ?id
   :label ?label
   :type {:id ?type-id
          :label ?type-label}
   :owner {:id ?owner-id
           :name ?owner-name}})</pre>
</z><z id="t1618935959" t="noprompt It is possible to do something more generic like splitting on the dot etc. but the transformation language hasn’t matured enough to accommodate a clean way to do this."><y>#</y><d>2021-04-20</d><h>16:25</h><w>noprompt</w>It is possible to do something more generic like splitting on the dot etc. but the transformation language hasn’t matured enough to accommodate a clean way to do this.</z><z id="t1618936070" t="euccastro thanks! yes, my use case would be definitely about splitting on the dot, since the transformation would have to handle keys not known statically"><y>#</y><d>2021-04-20</d><h>16:27</h><w>euccastro</w>thanks!  yes, my use case would be definitely about splitting on the dot, since the transformation would have to handle keys not known statically</z><z id="t1618936078" t="noprompt Accumulation/Aggregation is something that is planned for the next version of the library which I’ve been working on and hope to release sometime this year. The approach I’ve decided to take for the next version is completely different from the previous versions and is a complete rewrite of the library. Anyway, each of the variable types present in the current version can be seen as a type of memory with semantics for storage and retrieval. The plan is turn this observation into support for user defined types of variables."><y>#</y><d>2021-04-20</d><h>16:27</h><w>noprompt</w>Accumulation/Aggregation is something that is planned for the next version of the library which I’ve been working on and hope to release sometime this year. The approach I’ve decided to take for the next version is completely different from the previous versions and is a complete rewrite of the library.

Anyway, each of the variable types present in the current version can be seen as a type of memory with semantics for storage and retrieval. The plan is turn this observation into support for user defined types of variables.</z><z id="t1618936117" t="noprompt If the number dotted keys you have is small and known, I would recommend to simply stick them in the pattern match."><y>#</y><d>2021-04-20</d><h>16:28</h><w>noprompt</w>If the number dotted keys you have is small and known, I would recommend to simply stick them in the pattern match.</z><z id="t1618936339" t="noprompt In general, I often recommend this approach even if you’re not using Meander because it is obvious and almost always going to be faster."><y>#</y><d>2021-04-20</d><h>16:32</h><w>noprompt</w>In general, I often recommend this approach even if you’re not using Meander because it is obvious and almost always going to be faster.</z><z id="t1618937771" t="noprompt To give folks a brief update on where things are at with zeta most of my time is still being split between 1. compilation, 2. testing, and 3. parsing. Compilation and testing are occupying the most time because, well, compilation is a faceted problem. At the moment, compilation speed has been my focus. Originally, the plan was, for compilation, to have a three step process: build the intermediate representation, optimize it, then turn it in to Clojure. Even though I was able to generate good code this way, the performance was poor due to the size of the trees being optimized. Now what I am doing is optimizing as the tree as it is being constructed to avoid this problem."><y>#</y><d>2021-04-20</d><h>16:56</h><w>noprompt</w>To give folks a brief update on where things are at with <code>zeta</code> most of my time is still being split between
1. compilation,
2. testing, and
3. parsing.
Compilation and testing are occupying the most time because, well, compilation is a faceted problem. At the moment, compilation speed has been my focus. Originally, the plan was, for compilation, to have a three step process: build the intermediate representation, optimize it, then turn it in to Clojure. Even though I was able to generate good code this way, the performance was poor due to the size of the trees being optimized. Now what I am doing is optimizing as the tree as it is being constructed to avoid this problem.</z><z id="t1618937922" t="noprompt When I get the time later this year, I hope to write down a detailed explanation of how the internals are designed with the hope of being able to get more help from the community."><y>#</y><d>2021-04-20</d><h>16:58</h><w>noprompt</w>When I get the time later this year, I hope to write down a detailed explanation of how the internals are designed with the hope of being able to get more help from the community.</z><z id="t1618938002" t="noprompt Once I’m confident that zeta meets the mark, I really want to starting spending more of my time using it rather than working on it."><y>#</y><d>2021-04-20</d><h>17:00</h><w>noprompt</w>Once I’m confident that <code>zeta</code> meets the mark, I really want to starting spending more of my time using it rather than working on it.</z><z id="t1618938029" t="noprompt I’ve long wanted to get back into tinkering with L-Systems and learning more about algorithmic botony."><y>#</y><d>2021-04-20</d><h>17:00</h><w>noprompt</w>I’ve long wanted to get back into tinkering with L-Systems and learning more about algorithmic botony.</z><z id="t1619023739" t="noprompt I forgot to mention it yesterday, but zeta uses its own core to implement the parser. This has forced me to develop, I think, a more robust test suite than in previous versions. At times this can be frustrating but I’m hoping that it ultimately translates to fewer bugs. It’s also made me think a lot about the ergonomics of the core library which I intend for people to use at some point."><y>#</y><d>2021-04-21</d><h>16:48</h><w>noprompt</w>I forgot to mention it yesterday, but <code>zeta</code> uses its own core to implement the parser. This has forced me to develop, I think, a more robust test suite than in previous versions. At times this can be frustrating but I’m hoping that it ultimately translates to fewer bugs. It’s also made me think a lot about the ergonomics of the core library which I intend for people to use at some point.</z><z id="t1619023814" t="noprompt I would like to continue to drop these updates on the progress of zeta and, hopefully, it won’t annoy anyone."><y>#</y><d>2021-04-21</d><h>16:50</h><w>noprompt</w>I would like to continue to drop these updates on the progress of <code>zeta</code> and, hopefully, it won’t annoy anyone.</z><z id="t1619103825" t="Carlo Hey I have a question on the design of Meander for which I would like to know your take, [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] . It&apos;s not a suggestion on my part, it&apos;s more understanding why things work in a certain way. Let&apos;s take as a starting point an example I had last time:"><y>#</y><d>2021-04-22</d><h>15:03</h><w>Carlo</w>Hey I have a question on the design of Meander for which I would like to know your take, <a>@noprompt</a>. It&apos;s not a suggestion on my part, it&apos;s more understanding why things work in a certain way. Let&apos;s take as a starting point an example I had last time:</z><z id="t1619104076" t="Carlo You can see that, in the part that does the construction of the new pattern, I have to call meander/app to signify my intent of applying the function, because (function args) would have been read literally, as data. My question would be, why is meander/app not the default meaning for applications in the RHS? You could still quote things explicitly when you want a list, and it seems to me that&apos;s the most common case. But I know from your interview on youtube that you thought about semantics quite a bit, hence my curiosity 🙂"><y>#</y><d>2021-04-22</d><h>15:07</h><w>Carlo</w>You can see that, in the part that does the construction of the new pattern, I have to call <code>meander/app</code> to signify my intent of applying the function, because <code>(function args)</code> would have been read literally, as data. My question would be, why is <code>meander/app</code> not the default meaning for applications in the RHS? You could still quote things explicitly when you want a list, and it seems to me that&apos;s the most common case. But I know from your interview on youtube that you thought about semantics quite a bit, hence my curiosity <b>🙂</b></z><z id="t1619116195" t="noprompt [:attrs {:href &quot;/_/_/users/UA7E6DU04&quot;}] m/app is not the default on the RHS because the goal for substitution patterns is to be the dual of matching patterns and share the same syntax with them (though for epsilon this is currently not the case but for zeta it is). So if, for substitution, (p_fn &amp; p_args) is to mean apply substitution to p_fn and p_args to get f and args , then clojure.core/apply f to args , there would need to be a suitable dual semantic for matching. I think there is one that could make “sense” and I’m going to ramble on about how m/app works in zeta , point out that m/app in epsilon is a little janky, some other thoughts on the topic, and hope for the best. In zeta , (m/app p_fn p_args p_object) matching means yield objects of the pattern p_fn and objects of the pattern p_args to get fn and args respectively, then apply fn to the object being matched and args the return of which is matched against p_object . ;; epsilon (m/match 1 (m/app vector [?x]) ?x) ;; ❶ ❷ ;; =&gt; 1 ;; ❶ Function is a host expression without ~ ;; ❷ Additional arguments must be supplied in host expression ;; zeta (m/match 1 (m/app ~vector [] [?x])) ;; ❶ ❷ ;; =&gt; 1 ;; ❶ Function is a pattern ;; ❷ Additional arguments can be supplied with patterns (m/app p_fn p_args p_object) for substitution means yield objects of the pattern p_fn and objects of the pattern p_args to get fn and args respectively, then apply fn to args to get the object being yielded which must match the pattern p_object . ;; epsilon (let [?x 1] (m/subst (m/app vector ?x ?x))) ;; ❸ ❶ ❷ ❷ ;; =&gt; [1 1] ;; ❶ Function is a host expression without ~ ;; ❷ Remaining pattern arguments assumed to the arguments to the ;; function which is completely different from match ;; where the remaining arguments are semantically equivalent to ;; `m/and` ;; ❸ Not possible to constrain return with a pattern ;; zeta (m/subst (m/app ~vector [?x ?x] _) {&apos;?x 1}) ;; ❶ ❷ ❸ ;; =&gt; [1 1] ;; ❶ Function is a pattern ;; ❷ Explicit arguments ;; ❸ Possible to constrain return with a pattern As you can see from these examples, the syntax and semantics m/app in epsilon is a trashfire as it assumes the function is a host expression, arguments are passed to the function in different ways, and substitution lacks the ability to constrain the return. zeta on the other hand has consistent syntax and the only semantic difference is that of matching/substitution. Going back to your original question, I think it would be possible to have an m/app everywhere style where patterns are of the form (p_fn p_args p_return) retaining some of the primitive operators and desugaring to m/app . (m/rewrite (list 1 2 3) (m/and (~sequential? [] true) (~vec [] [?x ?y ?z])) (~+ [?x ?y ?z] _)) ;; =&gt; 6 Alternatively, if you have as primitives patterns which represent the duals of construction and deconstruction for each of the primitive data types which exist, you would have something that could serve this purpose for many things. (m/rewrite (list 1 2 3) (m/cons ?x (m/cata ?y)) (m/conj ?y ?x) _ []) ;; =&gt; [3 2 1] (m/rewrite [1 2 3] (m/conj (m/cata ?x) ?y) (m/cons ?y ?x) _ ()) ;; =&gt; (3 2 1)"><y>#</y><d>2021-04-22</d><h>18:29</h><w>noprompt</w><a>@meditans</a> <code>m/app</code> is not the default on the RHS because the goal for substitution patterns is to be the dual of matching patterns and share the same syntax with them (though for <code>epsilon</code> this is currently not the case but for <code>zeta</code> it is). So if, for substitution, <code>(p_fn &amp; p_args)</code> is to mean apply substitution to <code>p_fn</code> and <code>p_args</code> to get <code>f</code> and <code>args</code>, then <code>clojure.core/apply</code> <code>f</code> to <code>args</code>, there would need to be a suitable dual semantic for matching. I think there is one that could make “sense” and I’m  going to ramble on about how <code>m/app</code> works in <code>zeta</code>, point out that <code>m/app</code> in <code>epsilon</code> is a little janky, some other thoughts on the topic, and hope for the best.

In <code>zeta</code>, <code>(m/app p_fn p_args p_object)</code> matching means yield objects of the pattern <code>p_fn</code> and objects of the pattern <code>p_args</code> to get <code>fn</code> and <code>args</code> respectively, then apply <code>fn</code> to the object being matched and <code>args</code> the return of which is matched against <code>p_object</code>.

<pre>;; epsilon
(m/match 1 (m/app vector [?x]) ?x)
;;                ❶    ❷
;; =&gt; 1
;; ❶ Function is a host expression without ~
;; ❷ Additional arguments must be supplied in host expression

;; zeta
(m/match 1 (m/app ~vector [] [?x]))
;;                ❶      ❷
;; =&gt; 1
;; ❶ Function is a pattern
;; ❷ Additional arguments can be supplied with patterns</pre>
<code>(m/app p_fn p_args p_object)</code> for substitution means yield objects of the pattern <code>p_fn</code> and objects of the pattern <code>p_args</code> to get <code>fn</code> and <code>args</code> respectively, then apply <code>fn</code> to <code>args</code> to get the object being yielded which must match the pattern <code>p_object</code>.

<pre>;; epsilon
(let [?x 1]
  (m/subst (m/app vector ?x ?x)))
;;         ❸     ❶      ❷ ❷
;; =&gt; [1 1]
;; ❶ Function is a host expression without ~
;; ❷ Remaining pattern arguments assumed to the arguments to the
;;   function which is completely different from match
;;   where the remaining arguments are semantically equivalent to
;;   `m/and`
;; ❸ Not possible to constrain return with a pattern

;; zeta
(m/subst (m/app ~vector [?x ?x] _) {&apos;?x 1})
;;              ❶      ❷      ❸
;; =&gt; [1 1]
;; ❶ Function is a pattern
;; ❷ Explicit arguments
;; ❸ Possible to constrain return with a pattern</pre>
As you can see from these examples, the syntax and semantics <code>m/app</code> in <code>epsilon</code> is a trashfire as it assumes the function is a host expression, arguments are passed to the function in different ways, and substitution lacks the ability to constrain the return. <code>zeta</code> on the other hand has consistent syntax and the only semantic difference is that of matching/substitution.

Going back to your original question, I think it would be possible to have an <code>m/app</code> everywhere style where patterns are of the form <code>(p_fn p_args p_return)</code> retaining some of the primitive operators and desugaring to <code>m/app</code>.

<pre>(m/rewrite (list 1 2 3)
  (m/and (~sequential? [] true)
         (~vec [] [?x ?y ?z]))
  (~+ [?x ?y ?z] _))
;; =&gt; 6</pre>
Alternatively, if you have as primitives patterns which represent the duals of construction and deconstruction for each of the primitive data types which exist, you would have something that could serve this purpose for many things.
<pre>(m/rewrite (list 1 2 3)
  (m/cons ?x (m/cata ?y))
  (m/conj ?y ?x)

  _ [])
;; =&gt; [3 2 1]

(m/rewrite [1 2 3]
  (m/conj (m/cata ?x) ?y)
  (m/cons ?y ?x)

  _ ())
;; =&gt; (3 2 1)</pre></z><z id="t1619195945" t="Carlo thanks for the very detailed explanation [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] , can&apos;t wait to see zeta!"><y>#</y><d>2021-04-23</d><h>16:39</h><r>Carlo</r>thanks for the very detailed explanation <a>@noprompt</a>, can&apos;t wait to see zeta!</z><z id="t1619116531" t="noprompt Remind me never to write a long reply in my editor then paste it into Slack thinking it’ll work out. 😂"><y>#</y><d>2021-04-22</d><h>18:35</h><w>noprompt</w>Remind me never to write a long reply in my editor then paste it into Slack thinking it’ll work out. <b>😂</b></z><z id="t1619151166" t="wilkerlucio hello, I’m trying to understand how to use m/re to match something, but I always get nil, example: (m/find &quot;csa sa R$ 231,52 casa&quot; (m/re #&quot;\d{3},\d{2}&quot; ?0) ?0) is this intended to be used to match like this?"><y>#</y><d>2021-04-23</d><h>04:12</h><w>wilkerlucio</w>hello, I’m trying to understand how to use <code>m/re</code> to match something, but I always get nil, example:
<pre>(m/find &quot;csa sa R$ 231,52 casa&quot;
    (m/re #&quot;\d{3},\d{2}&quot; ?0)
    ?0)</pre>
is this intended to be used to match like this?</z><z id="t1619181102" t="Jimmy Miller On my phone. But from the doc string re uses re-matches. Which matches the whole string. So my guess is you need a pattern that matches the entire string, not just part of it."><y>#</y><d>2021-04-23</d><h>12:31</h><r>Jimmy Miller</r>On my phone. But from the doc string re uses re-matches. Which matches the whole string. So my guess is you need a pattern that matches the entire string, not just part of it.</z><z id="t1619183395" t="wilkerlucio humm, is there a way to use with re-find ? in my case I have these long strings, and just wanna match a small portion of it, and extract it in the process"><y>#</y><d>2021-04-23</d><h>13:09</h><r>wilkerlucio</r>humm, is there a way to use with <code>re-find</code>? in my case I have these long strings, and just wanna match a small portion of it, and extract it in the process</z><z id="t1619183436" t="wilkerlucio I’m getting around using (m/pred #(re-find ...)) , but that forces me to run the regex twice (to extract the content later), and look ugly, the syntax on m/re is just perfect, but having problems to match the small string in a long text"><y>#</y><d>2021-04-23</d><h>13:10</h><r>wilkerlucio</r>I’m getting around using <code>(m/pred #(re-find ...))</code>, but that forces me to run the regex twice (to extract the content later), and look ugly, the syntax on <code>m/re</code> is just perfect, but having problems to match the small string in a long text</z><z id="t1619183576" t="Jimmy Miller Would changing you regex to this and grabbing group 1 not work? .**(\d{3},\d{2}).**"><y>#</y><d>2021-04-23</d><h>13:12</h><r>Jimmy Miller</r>Would changing you regex to this and grabbing group 1 not work? <code>.**(\d{3},\d{2}).**</code></z><z id="t1619183602" t="Jimmy Miller Or are you looking for multiple matches?"><y>#</y><d>2021-04-23</d><h>13:13</h><r>Jimmy Miller</r>Or are you looking for multiple matches?</z><z id="t1619183622" t="Jimmy Miller If so, I can look at this later when not on my phone."><y>#</y><d>2021-04-23</d><h>13:13</h><r>Jimmy Miller</r>If so, I can look at this later when not on my phone.</z><z id="t1619183652" t="wilkerlucio no, a single match, I got it work with #&quot;(?s).*(\d+,\d{2}).*&quot; 🙂"><y>#</y><d>2021-04-23</d><h>13:14</h><r>wilkerlucio</r>no, a single match, I got it work with <code>#&quot;(?s).*(\d+,\d{2}).*&quot;</code> <b>🙂</b></z><z id="t1619183719" t="wilkerlucio humm, kind of"><y>#</y><d>2021-04-23</d><h>13:15</h><r>wilkerlucio</r>humm, kind of</z><z id="t1619183735" t="wilkerlucio it matches, but now it matches the last occurence, while I need the first"><y>#</y><d>2021-04-23</d><h>13:15</h><r>wilkerlucio</r>it matches, but now it matches the last occurence, while I need the first</z><z id="t1619183741" t="wilkerlucio I guess having one to match all would be nice"><y>#</y><d>2021-04-23</d><h>13:15</h><r>wilkerlucio</r>I guess having one to match all would be nice</z><z id="t1619183789" t="Jimmy Miller Just change the first to non-greedy star .*?"><y>#</y><d>2021-04-23</d><h>13:16</h><r>Jimmy Miller</r>Just change the first to non-greedy star .*?</z><z id="t1619183848" t="wilkerlucio sorry, was my bad, its matching the right thing 🙂"><y>#</y><d>2021-04-23</d><h>13:17</h><r>wilkerlucio</r>sorry, was my bad, its matching the right thing <b>🙂</b></z><z id="t1619183855" t="wilkerlucio and yes, non-greedy should solve if that was the case"><y>#</y><d>2021-04-23</d><h>13:17</h><r>wilkerlucio</r>and yes, non-greedy should solve if that was the case</z><z id="t1619184583" t="wilkerlucio all working nice now, thanks [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] !"><y>#</y><d>2021-04-23</d><h>13:29</h><r>wilkerlucio</r>all working nice now, thanks <a>@U5K8NTHEZ</a>!</z><z id="t1619184599" t="Jimmy Miller No problem :). Glad it is working."><y>#</y><d>2021-04-23</d><h>13:29</h><r>Jimmy Miller</r>No problem :). Glad it is working.</z><z id="t1619318262" t="wilkerlucio is Meander appropriated to write a tokenizer (start from a single string and break tokens), and if it is, what would a base for that looks like?"><y>#</y><d>2021-04-25</d><h>02:37</h><w>wilkerlucio</w>is Meander appropriated to write a tokenizer (start from a single string and break tokens), and if it is, what would a base for that looks like?</z><z id="t1619554647" t="Jimmy Miller Sorry meant to reply to this. We haven&apos;t focused much on text so I&apos;m not sure if there would be a lot of benefit in using meander for this. Might be possible though."><y>#</y><d>2021-04-27</d><h>20:17</h><r>Jimmy Miller</r>Sorry meant to reply to this. We haven&apos;t focused much on text so I&apos;m not sure if there would be a lot of benefit in using meander for this. Might be possible though.</z><z id="t1619554841" t="JAtkins Hard to say without looking at what you are doing, but I’d first look at Instaparse and maybe pair it with meander."><y>#</y><d>2021-04-27</d><h>20:20</h><r>JAtkins</r>Hard to say without looking at what you are doing, but I’d first look at Instaparse and maybe pair it with meander.</z><z id="t1619555201" t="Jimmy Miller Yeah, that is a pretty good combination."><y>#</y><d>2021-04-27</d><h>20:26</h><r>Jimmy Miller</r>Yeah, that is a pretty good combination.</z><z id="t1619560077" t="wilkerlucio thanks guys, I find instaparse a bit too bulky for what I’m doing, because its not much a syntax, its more like a text email that I’m trying to extract data from. I’ve been doing ok using just meander and regex so far. one trick I did that made my life easier was to pre-parse the text and transform it in a “hiccup like” syntax, where there is one entry for each line. This makes easier to match on specific line numbers (when they make sense) and also avoid dealing with line breaks (defn text-&gt;hiccup [text] (into [] (map-indexed #(vector (keyword (str &quot;l&quot; %)) %2)) (-&gt; text (str/split-lines)))) them I can match like this: (-&gt; (m/search hiccup (m/scan [:l0 ?store]) {:riviera-delivery.order/store ?store} (m/scan [:l2 (m/re #&quot;Pedido número: #(\d+)&quot; [_ ?id])]) {:riviera-delivery.order/id ?id} (m/scan [_ (m/re #&quot;.*Total Geral: R\$(\d+,\d+).*&quot; [_ ?total])]) {:riviera-delivery.order/total (u/parse-br-money ?total)} (m/scan [_ (m/re #&quot;.*(\d+) x \.\.\.\.\.\. (.+?) \.\.\.\.\.\. R\$(\d+,\d+).*&quot; [_ ?q ?n ?p])]) {:riviera-delivery.order/items [{:riviera-delivery.item/quantity ?q :riviera-delivery.item/price (u/parse-br-money ?p) :riviera-delivery.item/name ?n}]}) (-&gt;&gt; (apply merge-with into)))"><y>#</y><d>2021-04-27</d><h>21:47</h><r>wilkerlucio</r>thanks guys, I find instaparse a bit too bulky for what I’m doing, because its not much a syntax, its more like a text email that I’m trying to extract data from. I’ve been doing ok using just meander and regex so far. one trick I did that made my life easier was to pre-parse the text and transform it in a “hiccup like” syntax, where there is one entry for each line. This makes easier to match on specific line numbers (when they make sense) and also avoid dealing with line breaks
<pre>(defn text-&gt;hiccup [text]
  (into []
        (map-indexed
          #(vector (keyword (str &quot;l&quot; %)) %2))
        (-&gt; text
            (str/split-lines))))</pre>
them I can match like this:

<pre>(-&gt; (m/search hiccup
      (m/scan [:l0 ?store])
      {:riviera-delivery.order/store ?store}
      
      (m/scan [:l2 (m/re #&quot;Pedido número: #(\d+)&quot; [_ ?id])])
      {:riviera-delivery.order/id ?id}
      
      (m/scan [_ (m/re #&quot;.*Total Geral: R\$(\d+,\d+).*&quot; [_ ?total])])
      {:riviera-delivery.order/total (u/parse-br-money ?total)}

      (m/scan [_ (m/re #&quot;.*(\d+) x \.\.\.\.\.\. (.+?) \.\.\.\.\.\. R\$(\d+,\d+).*&quot; [_ ?q ?n ?p])])
      {:riviera-delivery.order/items
       [{:riviera-delivery.item/quantity ?q
         :riviera-delivery.item/price    (u/parse-br-money ?p)
         :riviera-delivery.item/name     ?n}]})
    (-&gt;&gt; (apply merge-with into)))</pre></z><z id="t1619560259" t="wilkerlucio example text that I’m matching against: Padaria Bella Riviera Pedido número: #1619127436602 Status: Pedido Entregue Wilker, você será notificado (a) à cada nova alteração de status. _______________________________________________________________________________________________________ Produtos: 3 x ...... Pão Francês (1unid) ...... R$1,10 1 x ...... Pão Ciabata (1unid) ...... R$5,50"><y>#</y><d>2021-04-27</d><h>21:50</h><r>wilkerlucio</r>example text that I’m matching against:
<pre>Padaria Bella Riviera

Pedido número: #1619127436602

Status: Pedido Entregue

Wilker, você será notificado (a) à cada nova alteração de status.

_______________________________________________________________________________________________________

Produtos:


3 x ...... Pão Francês (1unid) ...... R$1,10

1 x ...... Pão Ciabata (1unid) ...... R$5,50</pre></z><z id="t1619648488" t="noprompt I’m planning to add m/str eventually for the purpose of matching/yielding strings (along with m/bytes ) but I’m focused on hitting the zeta compiler goals I mentioned previously."><y>#</y><d>2021-04-28</d><h>22:21</h><r>noprompt</r>I’m planning to add <code>m/str</code> eventually for the purpose of matching/yielding strings (along with <code>m/bytes</code>) but I’m focused on hitting the <code>zeta</code> compiler goals I mentioned previously.</z><z id="t1619648504" t="noprompt But you could try something like this: (me/rewrite &quot;def foo { bar }&quot; (me/re #&quot;^\s*([{}])\s*(.*)&quot; [_ ?brace ?tail]) ([:brace ?brace] &amp; (me/cata ?tail)) (me/re #&quot;^\s*def\s(.*)&quot; [_ ?tail]) ([:def] &amp; (me/cata ?tail)) (me/re #&quot;^\s*([a-zA-Z]+)\s*(.+)&quot; [_ ?identifier ?tail]) ([:identifier ?identifier] &amp; (me/cata ?tail)) (me/re #&quot;\s*&quot;) () ?unknown ([:unknown ?unknown])) ;; =&gt; ([:def] [:identifier &quot;foo&quot;] [:brace &quot;{&quot;] [:identifier &quot;bar&quot;] [:brace &quot;}&quot;])"><y>#</y><d>2021-04-28</d><h>22:21</h><r>noprompt</r>But you could try something like this:

<pre>(me/rewrite &quot;def foo { bar }&quot;
  (me/re #&quot;^\s*([{}])\s*(.*)&quot; [_ ?brace ?tail])
  ([:brace ?brace] &amp; (me/cata ?tail))

  (me/re #&quot;^\s*def\s(.*)&quot; [_ ?tail])
  ([:def] &amp; (me/cata ?tail))

  (me/re #&quot;^\s*([a-zA-Z]+)\s*(.+)&quot; [_ ?identifier ?tail])
  ([:identifier ?identifier] &amp; (me/cata ?tail))

  (me/re #&quot;\s*&quot;)
  ()

  ?unknown
  ([:unknown ?unknown]))
;; =&gt;
([:def]
 [:identifier &quot;foo&quot;]
 [:brace &quot;{&quot;]
 [:identifier &quot;bar&quot;]
 [:brace &quot;}&quot;])</pre></z><z id="t1619649976" t="wilkerlucio thanks for the snippet, I can see a parser from it 🙂"><y>#</y><d>2021-04-28</d><h>22:46</h><r>wilkerlucio</r>thanks for the snippet, I can see a parser from it <b>🙂</b></z><z id="t1619648504" t="noprompt But you could try something like this: (me/rewrite &quot;def foo { bar }&quot; (me/re #&quot;^\s*([{}])\s*(.*)&quot; [_ ?brace ?tail]) ([:brace ?brace] &amp; (me/cata ?tail)) (me/re #&quot;^\s*def\s(.*)&quot; [_ ?tail]) ([:def] &amp; (me/cata ?tail)) (me/re #&quot;^\s*([a-zA-Z]+)\s*(.+)&quot; [_ ?identifier ?tail]) ([:identifier ?identifier] &amp; (me/cata ?tail)) (me/re #&quot;\s*&quot;) () ?unknown ([:unknown ?unknown])) ;; =&gt; ([:def] [:identifier &quot;foo&quot;] [:brace &quot;{&quot;] [:identifier &quot;bar&quot;] [:brace &quot;}&quot;])"><y>#</y><d>2021-04-28</d><h>22:21</h><w>noprompt</w>But you could try something like this:

<pre>(me/rewrite &quot;def foo { bar }&quot;
  (me/re #&quot;^\s*([{}])\s*(.*)&quot; [_ ?brace ?tail])
  ([:brace ?brace] &amp; (me/cata ?tail))

  (me/re #&quot;^\s*def\s(.*)&quot; [_ ?tail])
  ([:def] &amp; (me/cata ?tail))

  (me/re #&quot;^\s*([a-zA-Z]+)\s*(.+)&quot; [_ ?identifier ?tail])
  ([:identifier ?identifier] &amp; (me/cata ?tail))

  (me/re #&quot;\s*&quot;)
  ()

  ?unknown
  ([:unknown ?unknown]))
;; =&gt;
([:def]
 [:identifier &quot;foo&quot;]
 [:brace &quot;{&quot;]
 [:identifier &quot;bar&quot;]
 [:brace &quot;}&quot;])</pre></z><z id="t1619547949" t="Ben Sless Hello, I&apos;m playing around with meader trying to replicate destructuring, and I can&apos;t figure out the correct accumulator syntax This naive rewrite works: (let [s (m*/rewrite [[!b &apos;&amp; ?bs] [!x &amp; ?xs]] [!b !x ?bs ?xs])] (s &apos;[[x &amp; xs] [1 2 3]])) But anything I&apos;ve tried with accumulators turned out wrong. Any ideas?"><y>#</y><d>2021-04-27</d><h>18:25</h><w>Ben Sless</w>Hello, I&apos;m playing around with meader trying to replicate destructuring, and I can&apos;t figure out the correct accumulator syntax
This naive rewrite works:
<pre>(let [s
      (m*/rewrite
       [[!b &apos;&amp; ?bs] [!x &amp; ?xs]]
       [!b !x
        ?bs ?xs])]

  (s &apos;[[x &amp; xs] [1 2 3]]))</pre>
But anything I&apos;ve tried with accumulators turned out wrong.
Any ideas?</z><z id="t1619554834" t="Jimmy Miller A couple things. Not 100% sure what you mean by accumulators. I&apos;m also guessing you are using strategies. Any reason? Finally an example of what isn&apos;t working would be super helpful for knowing how we can help. Not sure if someone has reimplemented drstructuring already using meander, but should definitely be possible."><y>#</y><d>2021-04-27</d><h>20:20</h><r>Jimmy Miller</r>A couple things. Not 100% sure what you mean by accumulators. I&apos;m also guessing you are using strategies. Any reason? 

Finally an example of what isn&apos;t working would be super helpful for knowing how we can help. Not sure if someone has reimplemented drstructuring already using meander, but should definitely be possible.</z><z id="t1619582543" t="Ben Sless Thank you Here&apos;s an example where the final pattern fails (let [s (m*/rewrite [[!b ..?n &apos;&amp; ?bs] [!x ..?n &amp; ?xs]] [!b !x ..?n ?bs ?xs])] [(s &apos;[[x &amp; xs] [1 2 3]]) (s &apos;[[x y &amp; xs] [1 2 3]]) (s &apos;[[x y z &amp; xs] [1 2 3]]) (s &apos;[[x y z &amp; xs] [1 2]])]) "><y>#</y><d>2021-04-28</d><h>04:02</h><r>Ben Sless</r>Thank you
Here&apos;s an example where the final pattern fails
<pre>(let [s
      (m*/rewrite
       [[!b ..?n &apos;&amp; ?bs] [!x ..?n &amp; ?xs]]
       [!b !x ..?n
        ?bs ?xs])]

  [(s &apos;[[x &amp; xs] [1 2 3]])
   (s &apos;[[x y &amp; xs] [1 2 3]])
   (s &apos;[[x y z &amp; xs] [1 2 3]])
   (s &apos;[[x y z &amp; xs] [1 2]])])</pre>
</z><z id="t1619618762" t="Jimmy Miller Yeah, that fails because you are saying that the repeats for both vectors should be the same. That is what using ?n twice does. So on that last example, there are 3 elements before the &amp; and there are only two on the right hand side. So they don’t match."><y>#</y><d>2021-04-28</d><h>14:06</h><r>Jimmy Miller</r>Yeah, that fails because you are saying that the repeats for both vectors should be the same. That is what using <code>?n</code> twice does. So on that last example, there are 3 elements before the <code>&amp;</code> and there are only two on the right hand side. So they don’t match.</z><z id="t1619619262" t="Ben Sless Well, it&apos;s pretty clear they don&apos;t match, I just provided some examples of stuff I tired. I&apos;m not sure what would work correctly, though :thinking_face:"><y>#</y><d>2021-04-28</d><h>14:14</h><r>Ben Sless</r>Well, it&apos;s pretty clear they don&apos;t match, I just provided some examples of stuff I tired. I&apos;m not sure what would work correctly, though <b>:thinking_face:</b></z><z id="t1619620158" t="Jimmy Miller Well, it depends on what you want. I’m guessing you want to assign z to nil and xs to nil in that least example? If so, you can do something like this (let [s (m*/rewrite [[!b ..?n &apos;&amp; ?bs] [!x ..?n &amp; ?xs]] [!b !x ..?n ?bs ?xs] [[!b ..?n &apos;&amp; ?bs] [!x ...]] [!b !x ..?n ?bs nil])] [(s &apos;[[x &amp; xs] [1 2 3]]) (s &apos;[[x y &amp; xs] [1 2 3]]) (s &apos;[[x y z &amp; xs] [1 2 3]]) (s &apos;[[x y z &amp; xs] [1 2]])])"><y>#</y><d>2021-04-28</d><h>14:29</h><r>Jimmy Miller</r>Well, it depends on what you want. I’m guessing you want to assign z to nil and xs to nil in that least example? If so, you can do something like this


<pre>(let [s
      (m*/rewrite
       [[!b ..?n &apos;&amp; ?bs] [!x ..?n &amp; ?xs]]
       [!b !x ..?n
        ?bs ?xs]

       [[!b ..?n &apos;&amp; ?bs] [!x ...]]
       [!b !x ..?n
        ?bs nil])]
  [(s &apos;[[x &amp; xs] [1 2 3]])
   (s &apos;[[x y &amp; xs] [1 2 3]])
   (s &apos;[[x y z &amp; xs] [1 2 3]])
   (s &apos;[[x y z &amp; xs] [1 2]])])</pre></z><z id="t1619621939" t="Ben Sless Ah, the second pattern is for when the first doesn&apos;t match then it all gets accumulated to !x ?"><y>#</y><d>2021-04-28</d><h>14:58</h><r>Ben Sless</r>Ah, the second pattern is for when the first doesn&apos;t match then it all gets accumulated to <code>!x</code>?</z><z id="t1619623063" t="Jimmy Miller Yep exactly right."><y>#</y><d>2021-04-28</d><h>15:17</h><r>Jimmy Miller</r>Yep exactly right.</z><z id="t1619821956" t="ribelo what is the fastest way to scan a collection? there is something faster than a m/scan ? (require &apos;[taoensso.encore :as enc]) (require &apos;[meander.epsilon :as m]) (def data (vec (repeatedly 1000000 (fn [] {:a (* (rand-int 100) (if (enc/chance 0.5) 1 -1)) :b (* (rand-int 100) (if (enc/chance 0.5) 1 -1)) :c (* (rand-int 100) (if (enc/chance 0.5) 1 -1))})))) (enc/qb 1 (doall (m/search data (m/scan {:a 1 :b 1 :c 1 :as ?m}) ?m)) (-&gt;&gt; data (filterv (fn [m] (m/find m {:a 1 :b 1 :c 1 :as ?m} ?m))))) ;; =&gt; [127.33 60.28] - in ms"><y>#</y><d>2021-04-30</d><h>22:32</h><w>ribelo</w>what is the fastest way to scan a collection? there is something faster than a <code>m/scan</code>?
<pre>(require &apos;[taoensso.encore :as enc])
(require &apos;[meander.epsilon :as m])

(def data (vec (repeatedly 1000000 (fn [] {:a (* (rand-int 100) (if (enc/chance 0.5) 1 -1))
                                           :b (* (rand-int 100) (if (enc/chance 0.5) 1 -1))
                                           :c (* (rand-int 100) (if (enc/chance 0.5) 1 -1))}))))

(enc/qb 1

  (doall
   (m/search data
     (m/scan {:a 1 :b 1 :c 1 :as ?m}) ?m))
  
  (-&gt;&gt; data
       (filterv
        (fn [m]
          (m/find m
            {:a 1 :b 1 :c 1 :as ?m} ?m)))))
;; =&gt; [127.33 60.28] - in ms</pre></z><z id="t1619822435" t="noprompt How fast is (m/find data [(m/or {:a 1 :b 1 :c 1 :as !m} _) ...] !m) "><y>#</y><d>2021-04-30</d><h>22:40</h><w>noprompt</w>How fast is
<pre>(m/find data [(m/or {:a 1 :b 1 :c 1 :as !m} _) ...] !m)</pre>
</z><z id="t1619823738" t="ribelo (enc/qb 1 (doall (m/search data (m/scan {:a 1 :b 1 :c 1 :as ?m}) ?m)) (m/find data [(m/or {:a 1 :b 1 :c 1 :as !m} _) ...] !m) (-&gt;&gt; data (filterv (fn [m] (m/find m {:a 1 :b 1 :c 1 :as ?m} ?m))))) ;; =&gt; [125.22 85.2 55.35]"><y>#</y><d>2021-04-30</d><h>23:02</h><w>ribelo</w><pre>(enc/qb 1
  (doall
   (m/search data
     (m/scan {:a 1 :b 1 :c 1 :as ?m}) ?m))
  
  (m/find data [(m/or {:a 1 :b 1 :c 1 :as !m} _) ...] !m)
  
  (-&gt;&gt; data
       (filterv
        (fn [m]
          (m/find m
            {:a 1 :b 1 :c 1 :as ?m} ?m)))))
;; =&gt; [125.22 85.2 55.35]</pre></z><z id="t1619823761" t="ribelo is definitely faster"><y>#</y><d>2021-04-30</d><h>23:02</h><w>ribelo</w>is definitely faster</z><z id="t1619824553" t="noprompt The first two are going to have some overhead at the moment."><y>#</y><d>2021-04-30</d><h>23:15</h><w>noprompt</w>The first two are going to have some overhead at the moment.</z><z id="t1619824777" t="noprompt You could always make a macro that uses filter and find together the way you have them."><y>#</y><d>2021-04-30</d><h>23:19</h><w>noprompt</w>You could always make a macro that uses <code>filter</code> and <code>find</code> together the way you have them.</z><z id="t1619827532" t="ribelo I&apos;m working on something like this, I&apos;ll definitely post a link to the gh here as soon as I&apos;m finished"><y>#</y><d>2021-05-01</d><h>00:05</h><w>ribelo</w>I&apos;m working on something like this, I&apos;ll definitely post a link to the gh here as soon as I&apos;m finished</z><z id="t1619827608" t="ribelo using macros I want to generate meander code that return transducers xD"><y>#</y><d>2021-05-01</d><h>00:06</h><w>ribelo</w>using macros I want to generate meander code that return transducers xD</z><z id="t1619836385" t="noprompt This is something I want to. 🙂"><y>#</y><d>2021-05-01</d><h>02:33</h><r>noprompt</r>This is something I want to. <b>🙂</b></z><z id="t1619877940" t="ribelo why not write macros that write (macro based) meander code that would generate transducers functions? https://github.com/ribelo/danzig"><y>#</y><d>2021-05-01</d><h>14:05</h><w>ribelo</w>why not write macros that write (macro based) meander code that would generate transducers functions?
<a href="https://github.com/ribelo/danzig" target="_blank">https://github.com/ribelo/danzig</a></z><z id="t1620071839" t="noprompt Cool stuff man. 🙂"><y>#</y><d>2021-05-03</d><h>19:57</h><r>noprompt</r>Cool stuff man. <b>🙂</b></z><z id="t1620076784" t="ribelo thx"><y>#</y><d>2021-05-03</d><h>21:19</h><r>ribelo</r>thx</z><z id="t1619888818" t="ribelo (let [db {:db/id {:ivan {:name &quot;Ivan&quot; :friend [:db/id :petr]} :petr {:name &quot;Petr&quot; :friend [[:db/id :smith] [:db/id :ivan]]} :smith {:name &quot;Smith&quot; :friend [:db/id :petr]}}}] (m/search db {_ {?e {:name &quot;Ivan&quot; :friend (m/or (m/scan [?t ?f]) [?t ?f])} ?f {:name ?name}}} [?t ?f ?name])) ;; =&gt; ([:db/id :petr &quot;Petr&quot;] [:db/id :smith &quot;Smith&quot;]) shouldn&apos;t the returned result be [:db/id :petr &quot;Petr&quot;] ?"><y>#</y><d>2021-05-01</d><h>17:06</h><w>ribelo</w><pre>(let [db {:db/id {:ivan  {:name   &quot;Ivan&quot;
                          :friend [:db/id :petr]}
                  :petr  {:name   &quot;Petr&quot;
                          :friend [[:db/id :smith] [:db/id :ivan]]}
                  :smith {:name   &quot;Smith&quot;
                          :friend [:db/id :petr]}}}]

  (m/search db
    {_ {?e {:name &quot;Ivan&quot;
            :friend (m/or (m/scan [?t ?f]) [?t ?f])}
        ?f {:name ?name}}}
    [?t ?f ?name]))
;; =&gt; ([:db/id :petr &quot;Petr&quot;] [:db/id :smith &quot;Smith&quot;])</pre>
shouldn&apos;t the returned result be <code>[:db/id :petr &quot;Petr&quot;]</code>?</z><z id="t1620071695" t="noprompt This is a bug. I’ve figured out what is going on and will make a patch."><y>#</y><d>2021-05-03</d><h>19:54</h><r>noprompt</r>This is a bug. I’ve figured out what is going on and will make a patch.</z><z id="t1620062100" t="noprompt I will take a look ASAP"><y>#</y><d>2021-05-03</d><h>17:15</h><w>noprompt</w>I will take a look ASAP</z><z id="t1620145443" t="noprompt [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] I have fixed the issue and it is currently on the epsilon branch."><y>#</y><d>2021-05-04</d><h>16:24</h><w>noprompt</w><a>@huxley</a> I have fixed the issue and it is currently on the <code>epsilon</code> branch.</z><z id="t1620145483" t="ribelo 👌"><y>#</y><d>2021-05-04</d><h>16:24</h><w>ribelo</w><b>👌</b></z><z id="t1620145525" t="noprompt There was an issue with one of the compiler features and I have disabled it"><y>#</y><d>2021-05-04</d><h>16:25</h><w>noprompt</w>There was an issue with one of the compiler features and I have disabled it</z><z id="t1620146008" t="ribelo what exactly, I&apos;m curious"><y>#</y><d>2021-05-04</d><h>16:33</h><w>ribelo</w>what exactly, I&apos;m curious</z><z id="t1620146302" t="noprompt A step called “with consolidation” which collects all with nodes in the AST of a parsed pattern and combines them in one massive with that wraps the whole pattern."><y>#</y><d>2021-05-04</d><h>16:38</h><w>noprompt</w>A step called “with consolidation” which collects all <code>with</code> nodes in the AST of a parsed pattern and combines them in one massive <code>with</code> that wraps the whole pattern.</z><z id="t1620146428" t="noprompt The real issue is a lack of test coverage — this is my fault — assuming the REPL and high level tests were enough."><y>#</y><d>2021-05-04</d><h>16:40</h><w>noprompt</w>The real issue is a lack of test coverage — this is my fault — assuming the REPL and high level tests were enough.</z><z id="t1620146498" t="noprompt IMHO, for a project like this, I think a combination of TDD, heavy testing, and RDD (REPL driven development) is the most effective."><y>#</y><d>2021-05-04</d><h>16:41</h><w>noprompt</w>IMHO, for a project like this, I think a combination of TDD, heavy testing, and RDD (REPL driven development) is the most effective.</z><z id="t1620147000" t="wilkerlucio also some generative testing, they are hard to get right, but pay off big time"><y>#</y><d>2021-05-04</d><h>16:50</h><r>wilkerlucio</r>also some generative testing, they are hard to get right, but pay off big time</z><z id="t1620149308" t="noprompt Indeed. They are uncommon though because, I think, there isn’t a lot of emphasis on properties (in particular algebraic ones) in the Clojure community, and, on top of developers not being sure when to use them, it can be cumbersome to write generators. Contrast this with, say, the Haskell community where reliance on algebra is commonplace and they have the luxury of the type system helping to automatically derive generators (that don’t suck by the way!)."><y>#</y><d>2021-05-04</d><h>17:28</h><r>noprompt</r>Indeed. They are uncommon though because, I think, there isn’t a lot of emphasis on properties (in particular algebraic ones) in the Clojure community, and, on top of developers not being sure when to use them, it can be cumbersome to write generators. Contrast this with, say, the Haskell community where reliance on algebra is commonplace and they have the luxury of the type system helping to automatically derive generators (that don’t suck by the way!).</z><z id="t1620146521" t="noprompt At least, this is what I’ve discovered in the process of working on zeta ."><y>#</y><d>2021-05-04</d><h>16:42</h><w>noprompt</w>At least, this is what I’ve discovered in the process of working on <code>zeta</code>.</z><z id="t1620146730" t="ribelo I am currently pushing meander into all my private projects, so perhaps I can help and catch some bugs"><y>#</y><d>2021-05-04</d><h>16:45</h><w>ribelo</w>I am currently pushing <code>meander</code> into all my private projects, so perhaps I can help and catch some bugs</z><z id="t1620147041" t="noprompt Finding bugs is helpful. I don’t know how to grow the contributor base though. It’s difficult to balance work, personal life, epsilon, and zeta when I don’t pace myself."><y>#</y><d>2021-05-04</d><h>16:50</h><w>noprompt</w>Finding bugs is helpful. I don’t know how to grow the contributor base though. It’s difficult to balance work, personal life, epsilon, and zeta when I don’t pace myself.</z><z id="t1620147150" t="noprompt I may have mentioned it here, but last year sometime after being lockdown for awhile I found myself feeling burned out and then feeling guilty for “allowing” myself to play a video game. That was the moment I realized I was unhealthy."><y>#</y><d>2021-05-04</d><h>16:52</h><w>noprompt</w>I may have mentioned it here, but last year sometime after being lockdown for awhile I found myself feeling burned out and then feeling guilty for “allowing” myself to play a video game. That was the moment I realized I was unhealthy.</z><z id="t1620147218" t="noprompt I will continue to work on and support the project but I would like to find members of the community who would be willing to contribute some time here or there."><y>#</y><d>2021-05-04</d><h>16:53</h><w>noprompt</w>I will continue to work on and support the project but I would like to find members of the community who would be willing to contribute some time here or there.</z><z id="t1620147301" t="noprompt There’s this idea going around that, well, we can just throw money at developers for their OSS and call that “support”. The reality is, there is much more to support than that."><y>#</y><d>2021-05-04</d><h>16:55</h><w>noprompt</w>There’s this idea going around that, well, we can just throw money at developers for their OSS and call that “support”. The reality is, there is much more to support than that.</z><z id="t1620147516" t="noprompt Me saying this isn’t meant to be a guilt trip to anyone here who uses the project but doesn’t contribute to it. Let me be clear: everyone here that has used the project, reported a bug, helped another person, etc. has absolutely contributed to the success of the project."><y>#</y><d>2021-05-04</d><h>16:58</h><w>noprompt</w>Me saying this isn’t meant to be a guilt trip to anyone here who uses the project but doesn’t contribute to it. Let me be clear: everyone here that has used the project, reported a bug, helped another person, etc. has absolutely contributed to the success of the project.</z><z id="t1620147534" t="ribelo work life balance is hard"><y>#</y><d>2021-05-04</d><h>16:58</h><w>ribelo</w>work life balance is hard</z><z id="t1620147565" t="noprompt What I’m saying is I could use a hand and would happily provide support, direction, etc. free from pressure should anyone wish to lend one."><y>#</y><d>2021-05-04</d><h>16:59</h><w>noprompt</w>What I’m saying is I could use a hand and would happily provide support, direction, etc. free from pressure should anyone wish to lend one.</z><z id="t1620147588" t="noprompt Put another way: I’m a bottleneck! 🙂"><y>#</y><d>2021-05-04</d><h>16:59</h><w>noprompt</w>Put another way: I’m a bottleneck! <b>🙂</b></z><z id="t1620148965" t="ribelo unfortunately, I would like to enter into a conversation, but the language barrier makes me a little uncomfortable"><y>#</y><d>2021-05-04</d><h>17:22</h><w>ribelo</w>unfortunately, I would like to enter into a conversation, but the language barrier makes me a little uncomfortable</z><z id="t1620149063" t="ribelo I would not want you to think that I have not read, I just can&apos;t answer sensibly"><y>#</y><d>2021-05-04</d><h>17:24</h><w>ribelo</w>I would not want you to think that I have not read, I just can&apos;t answer sensibly</z><z id="t1620149417" t="noprompt What language do you speak?"><y>#</y><d>2021-05-04</d><h>17:30</h><w>noprompt</w>What language do you speak?</z><z id="t1620149808" t="ribelo Polish"><y>#</y><d>2021-05-04</d><h>17:36</h><w>ribelo</w>Polish</z><z id="t1620150062" t="ribelo I have no problem with contextual understanding, I can read a book or documentation, but writing and especially speaking is a disaster."><y>#</y><d>2021-05-04</d><h>17:41</h><w>ribelo</w>I have no problem with contextual understanding, I can read a book or documentation, but writing and especially speaking is a disaster.</z><z id="t1620150312" t="noprompt Ah, the closest I’ve gotten to Poland is Marek Grechuta’s first 4 albums and a couple Stanislav Szukalski books. 🙂"><y>#</y><d>2021-05-04</d><h>17:45</h><w>noprompt</w>Ah, the closest I’ve gotten to Poland is Marek Grechuta’s first 4 albums and a couple Stanislav Szukalski books. <b>🙂</b></z><z id="t1620150374" t="noprompt (I don’t count CDPR games.)"><y>#</y><d>2021-05-04</d><h>17:46</h><w>noprompt</w>(I don’t count CDPR games.)</z><z id="t1620150523" t="ribelo I would expect anything but Grechuta"><y>#</y><d>2021-05-04</d><h>17:48</h><w>ribelo</w>I would expect anything but Grechuta</z><z id="t1620150570" t="ribelo I know him, I like him and I appreciate him, but the younger generation in Poland has no idea who he is"><y>#</y><d>2021-05-04</d><h>17:49</h><w>ribelo</w>I know him, I like him and I appreciate him, but the younger generation in Poland has no idea who he is</z><z id="t1620153548" t="noprompt His first four albums are among some of my favorite records. I don’t understand Polish but I can appreciate great music. Also, I think it he is one of few artists who I can name as putting out such a long streak of great (in my opinion) records."><y>#</y><d>2021-05-04</d><h>18:39</h><w>noprompt</w>His first four albums are among some of my favorite records. I don’t understand Polish but I can appreciate great music. Also, I think it he is one of few artists who I can name as putting out such a long streak of great (in my opinion) records.</z><z id="t1620159964" t="ribelo many of the lyrics are classic Polish poems"><y>#</y><d>2021-05-04</d><h>20:26</h><w>ribelo</w>many of the lyrics are classic Polish poems</z><z id="t1620160038" t="ribelo from the first album 7/10"><y>#</y><d>2021-05-04</d><h>20:27</h><w>ribelo</w>from the first album 7/10</z><z id="t1620160184" t="ribelo life is amazing, I didn&apos;t expect to be on clojure slack writing with a foreigner about a fairly niche polish musician who recorded 50 years ago"><y>#</y><d>2021-05-04</d><h>20:29</h><w>ribelo</w>life is amazing, I didn&apos;t expect to be on clojure slack writing with a foreigner about a fairly niche polish musician who recorded 50 years ago</z><z id="t1620160193" t="ribelo 🙃"><y>#</y><d>2021-05-04</d><h>20:29</h><w>ribelo</w><b>🙃</b></z><z id="t1620160631" t="noprompt https://www.youtube.com/watch?v=Og9sQgce5kg"><y>#</y><d>2021-05-04</d><h>20:37</h><w>noprompt</w><a href="https://www.youtube.com/watch?v=Og9sQgce5kg" target="_blank">https://www.youtube.com/watch?v=Og9sQgce5kg</a></z><z id="t1620160675" t="noprompt ☝️ This is the song the pulled me to his music upon first contact. 🙂"><y>#</y><d>2021-05-04</d><h>20:37</h><w>noprompt</w><b>☝️</b> This is the song the pulled me to his music upon first contact. <b>🙂</b></z><z id="t1620160692" t="noprompt The construction is top notch."><y>#</y><d>2021-05-04</d><h>20:38</h><w>noprompt</w>The construction is top notch.</z><z id="t1620160721" t="noprompt (Audio is a little rough at the beginning, the track on the album sounds better.)"><y>#</y><d>2021-05-04</d><h>20:38</h><w>noprompt</w>(Audio is a little rough at the beginning, the track on the album sounds better.)</z><z id="t1620160832" t="markaddleman Thanks for sharing! :)"><y>#</y><d>2021-05-04</d><h>20:40</h><w>markaddleman</w>Thanks for sharing! :)</z><z id="t1620160915" t="noprompt FWIW that song is from his early stuff. His subsequent albums might be classified, today, as “psych folk”."><y>#</y><d>2021-05-04</d><h>20:41</h><w>noprompt</w>FWIW that song is from his early stuff. His subsequent albums might be classified, today, as “psych folk”.</z><z id="t1620162917" t="ribelo [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] do you know Czesław Niemen?"><y>#</y><d>2021-05-04</d><h>21:15</h><w>ribelo</w><a>@noprompt</a> do you know Czesław Niemen?</z><z id="t1620162942" t="ribelo rather different music, but the same period"><y>#</y><d>2021-05-04</d><h>21:15</h><w>ribelo</w>rather different music, but the same period</z><z id="t1620162996" t="ribelo https://www.youtube.com/watch?v=Fq7Zo3guNJs"><y>#</y><d>2021-05-04</d><h>21:16</h><w>ribelo</w><a href="https://www.youtube.com/watch?v=Fq7Zo3guNJs" target="_blank">https://www.youtube.com/watch?v=Fq7Zo3guNJs</a></z><z id="t1620164307" t="noprompt I had not encountered this artist before. Ah, the organ. What happened to it? 🙂"><y>#</y><d>2021-05-04</d><h>21:38</h><w>noprompt</w>I had not encountered this artist before. Ah, the organ. What happened to it? <b>🙂</b></z><z id="t1620342405" t="pithyless continuing this OT 🙂 probably Czesław Niemen&apos;s most famous song is &quot;Dziwny jest ten świat&quot; (1967) - this month it was even voted #5 polish song of all times at Radio 357. https://www.youtube.com/watch?v=kVp0BB6J-HI"><y>#</y><d>2021-05-06</d><h>23:06</h><w>pithyless</w>continuing this OT <b>🙂</b> probably Czesław Niemen&apos;s most famous song is &quot;Dziwny jest ten świat&quot; (1967) - this month it was even voted #5 polish song of all times at Radio 357.
<a href="https://www.youtube.com/watch?v=kVp0BB6J-HI" target="_blank">https://www.youtube.com/watch?v=kVp0BB6J-HI</a></z><z id="t1620342673" t="pithyless"><y>#</y><d>2021-05-06</d><h>23:11</h><w>pithyless</w></z><z id="t1620420844" t="noprompt This is great. Pattern matching and 60/70s Polish music. 🙂"><y>#</y><d>2021-05-07</d><h>20:54</h><w>noprompt</w>This is great. Pattern matching and 60/70s Polish music. <b>🙂</b></z><z id="t1620420861" t="noprompt Thanks for sharing!"><y>#</y><d>2021-05-07</d><h>20:54</h><w>noprompt</w>Thanks for sharing!</z><z id="t1620420867" t="ribelo 🙃"><y>#</y><d>2021-05-07</d><h>20:54</h><w>ribelo</w><b>🙃</b></z><z id="t1620765791" t="ribelo what is the simplest way to use the same value several times?"><y>#</y><d>2021-05-11</d><h>20:43</h><w>ribelo</w>what is the simplest way to use the same value several times?</z><z id="t1620765902" t="ribelo (m/rewrite [:a :b :c :d] ;; something I don&apos;t know ;; ) ;; =&gt; ;; [{:key1 :a :key2 :a :key3 :b} {:key1 :c key2 :c :key3 d}]"><y>#</y><d>2021-05-11</d><h>20:45</h><w>ribelo</w><pre>(m/rewrite [:a :b :c :d]
  ;; something I don&apos;t know
  ;;
  )
;; =&gt;
;; [{:key1 :a :key2 :a :key3 :b} {:key1 :c key2 :c :key3 d}]</pre></z><z id="t1620766129" t="ribelo Okay, I got it 😉"><y>#</y><d>2021-05-11</d><h>20:48</h><w>ribelo</w>Okay, I got it <b>😉</b></z><z id="t1620766160" t="wilkerlucio I&apos;m curious, can you send the solution?"><y>#</y><d>2021-05-11</d><h>20:49</h><r>wilkerlucio</r>I&apos;m curious, can you send the solution?</z><z id="t1620766761" t="ribelo (m/rewrite [:a :b :c :d] [?x ?y &amp; ?more] [{:k1 ?x :k2 ?x :k3 ?y} &amp; (m/cata ?more)] ?x nil) ;; =&gt; [{:k1 :a, :k2 :a, :k3 :b} {:k1 :c, :k2 :c, :k3 :d}] [:attrs {:href &quot;/_/_/users/U066U8JQJ&quot;}]"><y>#</y><d>2021-05-11</d><h>20:59</h><r>ribelo</r><pre>(m/rewrite [:a :b :c :d]
  [?x ?y &amp; ?more]
  [{:k1 ?x :k2 ?x :k3 ?y} &amp; (m/cata ?more)]
  ?x nil)
;; =&gt; [{:k1 :a, :k2 :a, :k3 :b} {:k1 :c, :k2 :c, :k3 :d}]</pre>
<a>@U066U8JQJ</a></z><z id="t1620767108" t="wilkerlucio cool, thanks"><y>#</y><d>2021-05-11</d><h>21:05</h><r>wilkerlucio</r>cool, thanks</z><z id="t1620786984" t="Max Apologies if this has come up before, I’m new to meander. Something that struck me as I read through the meander docs was how in some ways, meander could be seen as a generalization of validation tools like malli or spec, in that it can do transformation in addition to validation. in other words, meander is (could be?) a data parser. Has anyone tried using meander as a validator in a role that would normally be reserved for spec or malli?? If so, how did it go? Are there any tools out work with meander patterns as data similar to how you would for malli or spec, such as generating JSON schemas or producing example data fitting the pattern a la spec-gen?"><y>#</y><d>2021-05-12</d><h>02:36</h><w>Max</w>Apologies if this has come up before, I’m new to meander. Something that struck me as I read through the meander docs was how in some ways, meander could be seen as a generalization of validation tools like malli or spec, in that it can do transformation in addition to validation. in other words, meander is (could be?) a data parser.

Has anyone tried using meander as a validator in a role that would normally be reserved for spec or malli?? If so, how did it go? Are there any tools out work with meander patterns as data similar to how you would for malli or spec, such as generating JSON schemas or producing example data fitting the pattern a la spec-gen?</z><z id="t1620789271" t="noprompt &gt; meander could be seen as a generalization of validation tools like malli or spec Almost! At the moment, I would say that it could be used where one might use s/conform e.g. where one wishes to parse something. &gt; meander as a validator I have done this with m/search with good results. Where left side of each rule represents the shape of a particular error, and the right side builds and error object i.e. {:type :error ,,,} , (ex-info &quot;BAD&quot; ,,,) , etc."><y>#</y><d>2021-05-12</d><h>03:14</h><r>noprompt</r>&gt; meander could be seen as a generalization of validation tools like malli or spec
Almost! At the moment, I would say that it could be used where one might use <code>s/conform</code> e.g. where one wishes to parse something.
&gt; meander as a validator
I have done this with <code>m/search</code> with good results. Where left side of each rule represents the shape of a particular error, and the right side builds and error object i.e. <code>{:type :error ,,,}</code>, <code>(ex-info &quot;BAD&quot; ,,,)</code>, etc.</z><z id="t1620789367" t="noprompt The future holds two important things for the library which I’ve been working on and hope to release by the end of the year: data generation, and an API for programming."><y>#</y><d>2021-05-12</d><h>03:16</h><r>noprompt</r>The future holds two important things for the library which I’ve been working on and hope to release by the end of the year: data generation, and an API for programming.</z><z id="t1620792245" t="Max That sounds awesome! I’m glad to see we’re on the same wavelength 〰️"><y>#</y><d>2021-05-12</d><h>04:04</h><r>Max</r>That sounds awesome! I’m glad to see we’re on the same wavelength <b>〰️</b></z><z id="t1620792723" t="Max Where I work we use spec and spec-tools to parse incoming requests and it’s never felt like a great fit. Spec coercion is really limited, and as a Haskell refugee, it trips my https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/ spidey sense. I’ve been thinking for a while on how in Haskell there are special-purpose data parsers (e.g. aeson), but Clojure really needs more of a general-purpose data parser since it has stronger built-in data types. I tried playing around with an aeson-like model a bit, but Clojure really isn’t amenable to applicative-style parsing. Meander seems like it accomplishes most of that goal, so I’m excited to see where it goes!"><y>#</y><d>2021-05-12</d><h>04:12</h><r>Max</r>Where I work we use spec and spec-tools to parse incoming requests and it’s never felt like a great fit. Spec coercion is really limited, and as a Haskell refugee, it trips my <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/" target="_blank">https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/</a> spidey sense. I’ve been thinking for a while on how in Haskell there are special-purpose data parsers (e.g. aeson), but Clojure really needs more of a general-purpose data parser since it has stronger built-in data types. I tried playing around with an aeson-like model a bit, but Clojure really isn’t amenable to applicative-style parsing. Meander seems like it accomplishes most of that goal, so I’m excited to see where it goes!</z><z id="t1621867279" t="eoliphant Hi, I’m trying to process some clojure.xml output and i’m obviously doing something wrong ;). I need to recursively walk through the seqs on the :`content` key, and have mappings that differ based on the :tag value. My example is complicated, so will just use the example from data.xml ;; #clojure.data.xml.Element{:tag :foo, :attrs {}, :content (#clojure.data.xml.Element{:tag :bar, :attrs {}, :content (#clojure.data.xml.Element{:tag :baz, :attrs {}, :content (&quot;The baz value&quot;)})})} ; based on the recursive strategy example, tried a few variants of the following (def convert-log4j-tag (m*/rewrite {:tag (m/pred #(= % :foo) ?tag) :content [(m/cata !content) ...]} {:tag (m/app (comp str/capitalize name) ?tag) :content [!content ...]} {:tag (m/pred #(= % :bar) ?tag) :content [(m/cata !content) ...]} {:tag (m/app (comp str/capitalize name) ?tag) :content [!content ...]} ..."><y>#</y><d>2021-05-24</d><h>14:41</h><w>eoliphant</w>Hi, I’m trying to process some clojure.xml output and i’m obviously doing something wrong ;).
I need to recursively walk through the seqs on the :`content` key, and have mappings that differ based on the <code>:tag</code> value. My example is complicated, so will just use the example from data.xml
<pre>;; 
#clojure.data.xml.Element{:tag :foo,
                          :attrs {},
                          :content (#clojure.data.xml.Element{:tag :bar,
                                                              :attrs {},
                                                              :content (#clojure.data.xml.Element{:tag :baz,
                                                                                                  :attrs {},
                                                                                                  :content (&quot;The baz value&quot;)})})}

; based on the recursive strategy example, tried a few variants of the following
(def convert-log4j-tag
    (m*/rewrite
      {:tag     (m/pred #(= % :foo) ?tag)
       :content [(m/cata !content) ...]}
      {:tag     (m/app (comp str/capitalize name) ?tag)
       :content [!content ...]}

      {:tag     (m/pred #(= % :bar) ?tag)
       :content [(m/cata !content) ...]}
      {:tag     (m/app (comp str/capitalize name) ?tag)
       :content [!content ...]}
...</pre></z><z id="t1621872658" t="noprompt It looks like you need to add a “catch all” clause for non map objects. If the m/cata fails, so will the whole clause. Add ?x ?x at the end."><y>#</y><d>2021-05-24</d><h>16:10</h><r>noprompt</r>It looks like you need to add a “catch all” clause for non map objects. If the <code>m/cata</code> fails, so will the whole clause. Add
<pre>?x ?x</pre>
at the end.</z><z id="t1621872689" t="noprompt Also, you can write (m/and :foo ?tag) instead of (m/pred #(= % :foo) ?tag) "><y>#</y><d>2021-05-24</d><h>16:11</h><r>noprompt</r>Also, you can write
<pre>(m/and :foo ?tag)</pre>
instead of
<pre>(m/pred #(= % :foo) ?tag)</pre>
</z><z id="t1621880706" t="eoliphant ah sweet, let me give this a try. still figuring stuff out, but this is really cool s@#$ lol."><y>#</y><d>2021-05-24</d><h>18:25</h><r>eoliphant</r>ah sweet, let me give this a try.  still figuring stuff out, but this is really cool s@#$ lol.</z><z id="t1621881726" t="eoliphant ok, ugh, that didn’t work. it seems to just return the input unchanged (def x (xml/parse-str &quot;&lt;foo&gt;&lt;bar&gt;&lt;baz&gt;The baz value&lt;/baz&gt;&lt;/bar&gt;&lt;/foo&gt;&quot;)) (def convert-foobar (m*/rewrite {:tag (m/and :foo ?tag) :attrs ?attrs :content [(m/cata !content) ...]} {:tag (m/app (comp str/capitalize name) ?tag) :attrs ?attrs :content [!content ...]} {:tag (m/and :bar ?tag) :attrs ?attrs :content [(m/cata !content) ...]} {:tag (m/app (comp str/capitalize name) ?tag) :attrs ?attrs :content [!content ...]} {:tag (m/and :baz ?tag) :attrs ?attrs :content [(m/cata !content) ...]} {:tag (m/app (comp str/capitalize name) ?tag) :attrs ?attrs :content [!content ...]} ?x ?x)) (def convert-foobars (m*/bottom-up ; tried top-down, etc as well (m*/attempt convert-foobar))) (convert-foobars x)"><y>#</y><d>2021-05-24</d><h>18:42</h><r>eoliphant</r>ok, ugh, that didn’t work.   it seems to just return the input unchanged
<pre>(def x (xml/parse-str &quot;&lt;foo&gt;&lt;bar&gt;&lt;baz&gt;The baz value&lt;/baz&gt;&lt;/bar&gt;&lt;/foo&gt;&quot;))
  (def convert-foobar
    (m*/rewrite
      {:tag     (m/and :foo ?tag)
       :attrs    ?attrs
       :content [(m/cata !content) ...]}
      {:tag     (m/app (comp str/capitalize name) ?tag)
       :attrs    ?attrs
       :content [!content ...]}

      {:tag     (m/and :bar ?tag)
       :attrs    ?attrs
       :content [(m/cata !content) ...]}
      {:tag     (m/app (comp str/capitalize name) ?tag)
       :attrs    ?attrs
       :content [!content ...]}

      {:tag     (m/and :baz ?tag)
       :attrs    ?attrs
       :content [(m/cata !content) ...]}
      {:tag     (m/app (comp str/capitalize name) ?tag)
       :attrs    ?attrs
       :content [!content ...]}

      ?x ?x))

  (def convert-foobars
    (m*/bottom-up ; tried top-down, etc as well
      (m*/attempt convert-foobar)))

  (convert-foobars x)</pre></z><z id="t1621891018" t="noprompt [:attrs {:href &quot;/_/_/users/U380J7PAQ&quot;}] I took a minute to try this out on my local machine and would able to get it to work. The reason it was not rewriting was due to the :content [,,,] portion of the match, namely the [,,,] . Meander treats [,,,] and (,,,) as representing vectors and seqs respectively. In this case the value of :content is a seq so we have two options: use the (,,,) notation or use (m/seqable ,,,) . In this case I might suggest using the latter: (def convert-foobar (m*/rewrite {:tag (m/and :foo ?tag) :attrs ?attrs :content (m/seqable (m/cata !content) ...)} {:tag (m/app (comp str/capitalize name) ?tag) :attrs ?attrs :content (m/seqable !content ...)} {:tag (m/and :bar ?tag) :attrs ?attrs :content (m/seqable (m/cata !content) ...)} {:tag (m/app (comp str/capitalize name) ?tag) :attrs ?attrs :content (m/seqable !content ...)} {:tag (m/and :baz ?tag) :attrs ?attrs :content (m/seqable (m/cata !content) ...)} {:tag (m/app (comp str/capitalize name) ?tag) :attrs ?attrs :content (m/seqable !content ...)} ?x ?x)) "><y>#</y><d>2021-05-24</d><h>21:16</h><r>noprompt</r><a>@U380J7PAQ</a> I took a minute to try this out on my local machine and would able to get it to work. The reason it was not rewriting was due to the <code>:content [,,,]</code> portion of the match, namely the <code>[,,,]</code>. Meander treats <code>[,,,]</code> and <code>(,,,)</code> as representing vectors and seqs respectively. In this case the value of <code>:content</code> is a seq so we have two options: use the <code>(,,,)</code> notation or use <code>(m/seqable ,,,)</code>. In this case I might suggest using the latter:

<pre>(def convert-foobar
  (m*/rewrite
   {:tag     (m/and :foo ?tag)
    :attrs    ?attrs
    :content (m/seqable (m/cata !content) ...)}
   {:tag     (m/app (comp str/capitalize name) ?tag)
    :attrs    ?attrs
    :content (m/seqable !content ...)}

   {:tag     (m/and :bar ?tag)
    :attrs    ?attrs
    :content (m/seqable (m/cata !content) ...)}
   {:tag     (m/app (comp str/capitalize name) ?tag)
    :attrs    ?attrs
    :content (m/seqable !content ...)}

   {:tag     (m/and :baz ?tag)
    :attrs    ?attrs
    :content (m/seqable (m/cata !content) ...)}
   {:tag     (m/app (comp str/capitalize name) ?tag)
    :attrs    ?attrs
    :content (m/seqable !content ...)}

   ?x ?x))</pre>
</z><z id="t1621891258" t="noprompt Using your example input I was able get the output {:tag &quot;Foo&quot;, :attrs {}, :content ({:tag :bar, :attrs {}, :content ({:tag &quot;Baz&quot;, :attrs {}, :content (&quot;The baz value&quot;)})})} "><y>#</y><d>2021-05-24</d><h>21:20</h><r>noprompt</r>Using your example input I was able get the output
<pre>{:tag &quot;Foo&quot;,
 :attrs {},
 :content
 ({:tag :bar,
   :attrs {},
   :content ({:tag &quot;Baz&quot;, :attrs {}, :content (&quot;The baz value&quot;)})})}</pre>
</z><z id="t1621891296" t="noprompt Note you do not have to use m/seqable on the right, you can use the vector notation, etc."><y>#</y><d>2021-05-24</d><h>21:21</h><r>noprompt</r>Note you do not have to use <code>m/seqable</code> on the right, you can use the vector notation, etc.</z><z id="t1621954967" t="eoliphant ah hell it was just that? lol ok great thanks!"><y>#</y><d>2021-05-25</d><h>15:02</h><r>eoliphant</r>ah hell it was just that? lol ok great thanks!</z><z id="t1622040210" t="eoliphant so another question on this. in my actual code, for some parent tags, there are possibly some children on the :content key, whose data I want to pull into the parent. and in those cases, I don’t want those children in the output so just in xml: &lt;foo&gt; &lt;param name=&quot;a&quot; value=&quot;b&quot;/&gt; &lt;bar&gt;...&lt;/bar&gt; ... ; converts to &lt;Foo a=&quot;b&quot;&gt; &lt;Bar&gt;...&lt;Bar&gt; About to start playing with it but any tips would be appreciated 😉"><y>#</y><d>2021-05-26</d><h>14:43</h><r>eoliphant</r>so another question on this. in my actual code, for some parent tags, there are possibly some children on the :content key, whose data I want to pull into the parent.  and in those cases, I don’t want those children in the output so just in xml:
<pre>&lt;foo&gt;
   &lt;param name=&quot;a&quot; value=&quot;b&quot;/&gt;
   &lt;bar&gt;...&lt;/bar&gt;
...
; converts to
&lt;Foo a=&quot;b&quot;&gt;
   &lt;Bar&gt;...&lt;Bar&gt;</pre>
About to start playing with it but any tips would be appreciated <b>😉</b></z><z id="t1622045135" t="noprompt You want to keep the &lt;bar&gt; and discard the &lt;param&gt;"><y>#</y><d>2021-05-26</d><h>16:05</h><r>noprompt</r>You want to keep the <code>&lt;bar&gt;</code> and discard the <code>&lt;param&gt;</code></z><z id="t1622055743" t="noprompt I apologize, my previous message meant to have a question mark at the end of it. 😛"><y>#</y><d>2021-05-26</d><h>19:02</h><r>noprompt</r>I apologize, my previous message meant to have a question mark at the end of it. <b>😛</b></z><z id="t1622055817" t="noprompt {:tag :foo :content (m/seqable (m/or {:tag :bar :as !bar} _)} {:tag &quot;Foo&quot; :content [{:tag &quot;Bar&quot; &amp; !bar} ...]} "><y>#</y><d>2021-05-26</d><h>19:03</h><r>noprompt</r><pre>{:tag :foo 
 :content (m/seqable (m/or {:tag :bar :as !bar} _)}
{:tag &quot;Foo&quot;
 :content [{:tag &quot;Bar&quot; &amp; !bar} ...]}</pre>
</z><z id="t1622057732" t="eoliphant yes, i want to collect some info from params into Foo, then drop params"><y>#</y><d>2021-05-26</d><h>19:35</h><r>eoliphant</r>yes, i want to collect some info from params into Foo, then drop params</z><z id="t1622057940" t="eoliphant ok so I see how this one handles the omission of params, so that seems straightforward, so hmm I guess m/or can match on params use that in :attrs on the RHS, while the check on the RHS in content will keep the params out of the new :content. cool, gonna try that when i get back to my desk"><y>#</y><d>2021-05-26</d><h>19:39</h><r>eoliphant</r>ok so I see how this one handles the omission of params, so that seems straightforward, so hmm I guess m/or can match on params use that in :attrs on the RHS, while the check on the RHS in content will keep the params out of the new :content.  cool, gonna try that when i get back to my desk</z><z id="t1622132725" t="noprompt Following up on this; how can I help?"><y>#</y><d>2021-05-27</d><h>16:25</h><r>noprompt</r>Following up on this; how can I help?</z><z id="t1622132745" t="noprompt Or, rather, do you still need some help?"><y>#</y><d>2021-05-27</d><h>16:25</h><r>noprompt</r>Or, rather, do you still need some help?</z><z id="t1622136415" t="eoliphant hi, actually haven’t gotten to it yet today 🙂 . thanks for checking in will let you know"><y>#</y><d>2021-05-27</d><h>17:26</h><r>eoliphant</r>hi, actually haven’t gotten to it yet today <b>🙂</b>. thanks for checking in will let you know</z><z id="t1622137838" t="noprompt No worries. Drop me a line whenever."><y>#</y><d>2021-05-27</d><h>17:50</h><r>noprompt</r>No worries. Drop me a line whenever.</z><z id="t1621867565" t="eoliphant but just haven’t been able to traverse ‘through’ content in any fashion. I’m either getting nil results or the whole thing back with no transformation applied, etc"><y>#</y><d>2021-05-24</d><h>14:46</h><w>eoliphant</w>but just haven’t been able to traverse ‘through’ content in any fashion.  I’m either getting nil results or the whole thing back with no transformation applied, etc</z><z id="t1622827581" t="Alex Whitt Hi there. I work with Ride Health, and we are interested in using Meander. I&apos;m running into some unknowns as to what meander can and can&apos;t do. Would anyone have time to go over this with me?"><y>#</y><d>2021-06-04</d><h>17:26</h><w>Alex Whitt</w>Hi there. I work with Ride Health, and we are interested in using Meander. I&apos;m running into some unknowns as to what meander can and can&apos;t do. Would anyone have time to go over this with me?</z><z id="t1622830687" t="noprompt Are you interested in a video conference?"><y>#</y><d>2021-06-04</d><h>18:18</h><r>noprompt</r>Are you interested in a video conference?</z><z id="t1622830880" t="noprompt The channel is also fairly responsive, however, video/audio is effective/efficient for more “organic” sorts of discussions."><y>#</y><d>2021-06-04</d><h>18:21</h><r>noprompt</r>The channel is also fairly responsive, however, video/audio is effective/efficient for more “organic” sorts of discussions.</z><z id="t1622838757" t="Alex Whitt Yep, video call would be perfect"><y>#</y><d>2021-06-04</d><h>20:32</h><r>Alex Whitt</r>Yep, video call would be perfect</z><z id="t1622842351" t="noprompt OK. Send me a DM with some proposed times for next week and we can figure something out. I’m often reliably available after 1000 Pacific."><y>#</y><d>2021-06-04</d><h>21:32</h><r>noprompt</r>OK. Send me a DM with some proposed times for next week and we can figure something out. I’m often reliably available after 1000 Pacific.</z><z id="t1622843072" t="Alex Whitt Should I add [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] ?"><y>#</y><d>2021-06-04</d><h>21:44</h><r>Alex Whitt</r>Should I add <a>@U5K8NTHEZ</a>?</z><z id="t1622856653" t="Jimmy Miller Yeah feel free. No guarantees about availability but would love to chat."><y>#</y><d>2021-06-05</d><h>01:30</h><r>Jimmy Miller</r>Yeah feel free. No guarantees about availability but would love to chat.</z><z id="t1622828731" t="Jimmy Miller Happy to answer any questions you have"><y>#</y><d>2021-06-04</d><h>17:45</h><w>Jimmy Miller</w>Happy to answer any questions you have</z><z id="t1623543354" t="markaddleman One common use case I have is editing an element within a sequence. Is there a reason something like the following isn&apos;t included in the meander API? (m/defsyntax within [label element-pattern] `(m/seqable ~(symbol (str &quot;!&quot; label &quot;-before&quot;)) ... ~element-pattern &amp; ~(symbol (str &quot;?&quot; label &quot;-after&quot;)))) "><y>#</y><d>2021-06-13</d><h>00:15</h><w>markaddleman</w>One common use case I have is editing an element within a sequence.  Is there a reason something like the following isn&apos;t included in the meander API?
<pre>(m/defsyntax within [label element-pattern]
  `(m/seqable ~(symbol (str &quot;!&quot; label &quot;-before&quot;))
              ...
              ~element-pattern
              &amp; ~(symbol (str &quot;?&quot; label &quot;-after&quot;))))</pre>
</z><z id="t1623543371" t="markaddleman It allows me to write: (m/rewrite [[1 2 3]] (within outer (within inner (m/and ?n 1))) (within outer (within inner (m/app inc ?n)))) "><y>#</y><d>2021-06-13</d><h>00:16</h><w>markaddleman</w>It allows me to write:
<pre>(m/rewrite [[1 2 3]]
  (within outer (within inner (m/and ?n 1)))
  (within outer (within inner (m/app inc ?n))))</pre>
</z><z id="t1623546459" t="markaddleman That may have come across snarkily - NOT how I meant it. My real question is, is there some reason this approach isn&apos;t going to work in general?"><y>#</y><d>2021-06-13</d><h>01:07</h><w>markaddleman</w>That may have come across snarkily - NOT how I meant it.  My real question is, is there some reason this approach isn&apos;t going to work in general?</z><z id="t1623687388" t="Jimmy Miller Really interesting pattern you have there. I personally, haven&apos;t had that use case, so haven&apos;t really thought about it. Does it work with multiple of them nested? Might have to play around with it"><y>#</y><d>2021-06-14</d><h>16:16</h><w>Jimmy Miller</w>Really interesting pattern you have there. I personally, haven&apos;t had that use case, so haven&apos;t really thought about it. Does it work  with multiple of them nested? Might have to play around with it</z><z id="t1623690549" t="markaddleman I wrote it for a very particular use case - &quot;editing&quot; XML"><y>#</y><d>2021-06-14</d><h>17:09</h><r>markaddleman</r>I wrote it for a very particular use case - &quot;editing&quot; XML</z><z id="t1623690584" t="markaddleman I believe I have one nested use case and I haven&apos;t seen a problem. I&apos;ll look more deeply into it"><y>#</y><d>2021-06-14</d><h>17:09</h><r>markaddleman</r>I believe I have one nested use case and I haven&apos;t seen a problem.  I&apos;ll look more deeply into it</z><z id="t1623690676" t="markaddleman I got to thinking that the &quot;edit&quot; use case might deserve a DSL of its own. The DSL would be similar to m/rewrite but every &quot;rule&quot; would need to specify three things:"><y>#</y><d>2021-06-14</d><h>17:11</h><r>markaddleman</r>I got to thinking that the &quot;edit&quot; use case might deserve a DSL of its own.  The DSL would be similar to <code>m/rewrite</code> but every &quot;rule&quot; would need to specify three things:</z><z id="t1623690877" t="markaddleman 1. a matching rule - just like the current rewrite LHS. the matching rule is used to capture values to be used later 2. the new value rule. this is similar to rewrite&apos;s RHS but a new value rule would only return a value that would be used to replace an existing node in the tree 3. a targeting rule. this is a rule that works similarly to matching rule but is used to locate the position(s) of the new value "><y>#</y><d>2021-06-14</d><h>17:14</h><r>markaddleman</r>1. a matching rule - just like the current rewrite LHS. the matching rule is used to capture values to be used later
2. the new value rule.  this is similar to rewrite&apos;s RHS but a new value rule would only return a value that would be used to replace an existing node in the tree
3. a targeting rule.  this is a rule that works similarly to matching rule but is used to locate the position(s) of the new value </z><z id="t1623697671" t="markaddleman Oh, one more difference from rewrite: If no edit rules match, return the original form"><y>#</y><d>2021-06-14</d><h>19:07</h><r>markaddleman</r>Oh, one more difference from rewrite:  If no edit rules match, return the original form</z><z id="t1623797802" t="noprompt I want to keep this alive too. The conversation about editing is important."><y>#</y><d>2021-06-15</d><h>22:56</h><r>noprompt</r>I want to keep this alive too. The conversation about editing is important.</z><z id="t1623800168" t="markaddleman I will try to write up some code examples this weekend"><y>#</y><d>2021-06-15</d><h>23:36</h><r>markaddleman</r>I will try to write up some code examples this weekend</z><z id="t1624114363" t="markaddleman Picking this back up"><y>#</y><d>2021-06-19</d><h>14:52</h><r>markaddleman</r>Picking this back up</z><z id="t1624114472" t="markaddleman I played around with a new pattern match operator that I call edit . I tried getting it to work the way I describe above but I ran into a problem with recursion. I just couldn&apos;t find an intuitive way to express how to recurse when then target rule is different than the matching rule"><y>#</y><d>2021-06-19</d><h>14:54</h><r>markaddleman</r>I played around with a new pattern match operator that I call <code>edit</code>.  I tried getting it to work the way I describe above but I ran into a problem with recursion.  I just couldn&apos;t find an intuitive way to express how to recurse when then target rule is different than the matching rule</z><z id="t1624114533" t="markaddleman I&apos;m back to believing that the edit use case is best served something like the within syntax. see https://clojurians.slack.com/archives/CFFTD7R6Z/p1623543354015700"><y>#</y><d>2021-06-19</d><h>14:55</h><r>markaddleman</r>I&apos;m back to believing that the edit use case is best served something like the <code>within</code> syntax.  see <a href="https://clojurians.slack.com/archives/CFFTD7R6Z/p1623543354015700" target="_blank">https://clojurians.slack.com/archives/CFFTD7R6Z/p1623543354015700</a></z><z id="t1624114568" t="markaddleman The within syntax that I wrote doesn&apos;t really follow the spirit of meander so I&apos;m going to play around with a better cultural fit today."><y>#</y><d>2021-06-19</d><h>14:56</h><r>markaddleman</r>The <code>within</code> syntax that I wrote doesn&apos;t really follow the spirit of meander so I&apos;m going to play around with a better cultural fit today.</z><z id="t1624114822" t="markaddleman The problem with something like within is that it needs to introduce multiple matching variables each of whose names must match in the match-syntax phase and the subst-syntax phase. I think it would be safer if the pattern matching operator (`rewrite` in this case) provided some context that could be shared between the two macro expansion phases"><y>#</y><d>2021-06-19</d><h>15:00</h><r>markaddleman</r>The problem with something like <code>within</code> is that it needs to introduce multiple matching variables each of whose names must match in the match-syntax phase and the subst-syntax phase.  I think it would be safer if the pattern matching operator (`rewrite` in this case) provided some context that could be shared between the two macro expansion phases</z><z id="t1623696888" t="noprompt [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] That looks interesting. You didn’t come across as a snarky either. 🙂"><y>#</y><d>2021-06-14</d><h>18:54</h><w>noprompt</w><a>@markaddleman</a> That looks interesting. You didn’t come across as a snarky either. <b>🙂</b></z><z id="t1623696992" t="noprompt I’ve done this before too but I confess that I hadn’t thought about doing it this way."><y>#</y><d>2021-06-14</d><h>18:56</h><w>noprompt</w>I’ve done this before too but I confess that I hadn’t thought about doing it this way.</z><z id="t1623697076" t="noprompt This actually makes me think that, among other things, we should be able to use &amp; more than once in sequential types of patterns. (&amp; ?before &lt;pattern&gt; ,,, &amp; ?after) "><y>#</y><d>2021-06-14</d><h>18:57</h><w>noprompt</w>This actually makes me think that, among other things, we should be able to use <code>&amp;</code> more than once in sequential types of patterns.
<pre>(&amp; ?before &lt;pattern&gt; ,,, &amp; ?after)</pre>
</z><z id="t1623697189" t="markaddleman that would be convenient"><y>#</y><d>2021-06-14</d><h>18:59</h><w>markaddleman</w>that would be convenient</z><z id="t1623697206" t="markaddleman What do you think of the edit DSL idea? https://clojurians.slack.com/archives/CFFTD7R6Z/p1623690549018100?thread_ts=1623687388.018000&amp;amp;cid=CFFTD7R6Z"><y>#</y><d>2021-06-14</d><h>19:00</h><w>markaddleman</w>What do you think of the edit DSL idea? <a href="https://clojurians.slack.com/archives/CFFTD7R6Z/p1623690549018100?thread_ts=1623687388.018000&amp;amp;cid=CFFTD7R6Z" target="_blank">https://clojurians.slack.com/archives/CFFTD7R6Z/p1623690549018100?thread_ts=1623687388.018000&amp;amp;cid=CFFTD7R6Z</a></z><z id="t1623697585" t="noprompt I think it makes sense and would be able to contribute more thoughts provided an example/sketch."><y>#</y><d>2021-06-14</d><h>19:06</h><w>noprompt</w>I think it makes sense and would be able to contribute more thoughts provided an example/sketch.</z><z id="t1623697701" t="markaddleman Cool."><y>#</y><d>2021-06-14</d><h>19:08</h><w>markaddleman</w>Cool.</z><z id="t1623697743" t="markaddleman I could play around with some example syntax and post here"><y>#</y><d>2021-06-14</d><h>19:09</h><w>markaddleman</w>I could play around with some example syntax and post here</z><z id="t1623698403" t="noprompt Its certainly welcome. 🙂"><y>#</y><d>2021-06-14</d><h>19:20</h><w>noprompt</w>Its certainly welcome. <b>🙂</b></z><z id="t1623797377" t="noprompt Last week [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] and I encountered a situation where a Meander query was several milliseconds slower than some hand jammed Clojure — which is expected and no surprise — and while normally this would be no issue, in this case performance was critical and, so, we went with the vanilla Clojure. Since it was so close, we took a moment to macroexpand the query, delete all the type checks, and see how the performance fared and, indeed, in doing so we were able to close the gap to just a couple milliseconds. We also made some other tweaks and were able to get the expanded code within just one millisecond. This is something I’ve been aware of and came up in a previous discussion with [:attrs {:href &quot;/_/_/users/UP90Q48J3&quot;}] in the past year. I’ve talked about adding an unsafe flag and, now, I think it’s time to act on that because, in this case, we made a decision to turn down Meander because its performance was unacceptable. At the moment I’m working on this (its a surprisingly simple patch) to disable some of the basic type checks such that it will work similarly to destructure . I suspect we will want some control over. For example, we may want type checks disabled but bounds checks to remain, vice versa, or simply no checks at all. Currently, what I have and plan to submit for review looks like ^::m/unsafe (m/find x ,,,) which will disable both type checks and bounds checks. In the case of disabling bounds checks, this causes the compiler emit (nth target index not-found) instead of (nth target index) . Likely, the patch will include the knobs ::m/omit-type-checks and ::m/omit-bounds-checks with ::m/unsafe expanding to true in both cases."><y>#</y><d>2021-06-15</d><h>22:49</h><w>noprompt</w>Last week <a>@jimmy</a> and I encountered a situation where a Meander query was several milliseconds slower than some hand jammed Clojure — which is expected and no surprise — and while normally this would be no issue, in this case performance was critical and, so, we went with the vanilla Clojure.

Since it was so close, we took a moment to macroexpand the query, delete all the type checks, and see how the performance fared and, indeed, in doing so we were able to close the gap to just a couple milliseconds. We also made some other tweaks and were able to get the expanded code within just one millisecond. This is something I’ve been aware of and came up in a previous discussion with <a>@wxitb2017</a> in the past year.

I’ve talked about adding an unsafe flag and, now, I think it’s time to act on that because, in this case, we made a decision to turn down Meander because its performance was unacceptable.

At the moment I’m working on this (its a surprisingly simple patch) to disable some of the basic type checks such that it will work similarly to <code>destructure</code>. I suspect we will want some control over. For example, we may want type checks disabled but bounds checks to remain, vice versa, or simply no checks at all. Currently, what I have and plan to submit for review looks like

<pre>^::m/unsafe
(m/find x ,,,)</pre>
which will disable both type checks and bounds checks. In the case of disabling bounds checks, this causes the compiler emit <code>(nth target index not-found)</code> instead of <code>(nth target index)</code>. Likely, the patch will include the knobs <code>::m/omit-type-checks</code> and <code>::m/omit-bounds-checks</code> with <code>::m/unsafe</code> expanding to <code>true</code> in both cases.</z><z id="t1624445883" t="Lucy Wang 👏"><y>#</y><d>2021-06-23</d><h>10:58</h><r>Lucy Wang</r><b>👏</b></z><z id="t1623797542" t="noprompt The omissions will happen at the lowest level of the compiler e.g. where Clojure code is generated which means the generated code will have the same structure is safe code (excluding the omissions)."><y>#</y><d>2021-06-15</d><h>22:52</h><w>noprompt</w>The omissions will happen at the lowest level of the compiler e.g. where Clojure code is generated which means the generated code will have the same structure is safe code (excluding the omissions).</z><z id="t1623797685" t="noprompt To avoid potential confusion, this will not affect something like (m/pred map? ,,,) ."><y>#</y><d>2021-06-15</d><h>22:54</h><w>noprompt</w>To avoid potential confusion, this will not affect something like <code>(m/pred map? ,,,)</code>.</z><z id="t1623859070" t="Alex Whitt Hey guys. How do you think Meander would fare as the core of an authentication system? To my understanding, you&apos;re basically trying to match against a pattern when deciding whether or not access to something is authorized: &quot;if the user&apos;s domain and the target domain are the same, AND the user&apos;s permissions level is this or that, OR the user ID is present in a database of special conditions and those conditions match what&apos;s trying to be accessed, THEN return true.&quot; Do you think matching is the right tool for this domain?"><y>#</y><d>2021-06-16</d><h>15:57</h><w>Alex Whitt</w>Hey guys. How do you think Meander would fare as the core of an authentication system? To my understanding, you&apos;re basically trying to match against a pattern when deciding whether or not access to something is authorized: &quot;if the user&apos;s domain and the target domain are the same, AND the user&apos;s permissions level is this or that, OR the user ID is present in a database of special conditions and those conditions match what&apos;s trying to be accessed, THEN return true.&quot;

Do you think matching is the right tool for this domain?</z><z id="t1623861453" t="markaddleman I can&apos;t speak directly to the authentication domain but I have used meander very successfully for complex pattern matching such as rewriting SQL (in honey format)"><y>#</y><d>2021-06-16</d><h>16:37</h><r>markaddleman</r>I can&apos;t speak directly to the authentication domain but I have used meander very successfully for complex pattern matching such as rewriting SQL (in honey format)</z><z id="t1623861518" t="markaddleman I&apos;d be careful of ordering meander match clauses to ensure that you don&apos;t end up inadvertently matching and thus granting access with you shouldn&apos;t."><y>#</y><d>2021-06-16</d><h>16:38</h><r>markaddleman</r>I&apos;d be careful of ordering meander match clauses to ensure that you don&apos;t end up inadvertently matching and thus granting access with you shouldn&apos;t.</z><z id="t1623861574" t="markaddleman If your data structure is complex, this can be a bit hard to get exactly right. However, if the data structure is straightforward (even if it is recursive), meander is good fit"><y>#</y><d>2021-06-16</d><h>16:39</h><r>markaddleman</r>If your data structure is complex, this can be a bit hard to get exactly right.  However, if the data structure is straightforward (even if it is recursive), meander is good fit</z><z id="t1623862025" t="Alex Whitt I&apos;ll try a POC and see how it looks"><y>#</y><d>2021-06-16</d><h>16:47</h><r>Alex Whitt</r>I&apos;ll try a POC and see how it looks</z><z id="t1623862034" t="Alex Whitt I think our data is on the simple end of the spectrum"><y>#</y><d>2021-06-16</d><h>16:47</h><r>Alex Whitt</r>I think our data is on the simple end of the spectrum</z><z id="t1623950509" t="noprompt [:attrs {:href &quot;/_/_/users/UJF17G3T9&quot;}] If you’re comfortable looping others in for feedback/support, drop a gist, etc. 👍"><y>#</y><d>2021-06-17</d><h>17:21</h><r>noprompt</r><a>@UJF17G3T9</a> If you’re comfortable looping others in for feedback/support, drop a gist, etc. <b>👍</b></z><z id="t1623950765" t="markaddleman One additional bit: Most of my &quot;over matching&quot; problems are due to inappropriate use of m/$ . I start out thinking, recursively matching will save me a bunch of typing. I end up thinking, why did I ever think that was a good idea!"><y>#</y><d>2021-06-17</d><h>17:26</h><r>markaddleman</r>One additional bit:  Most of my &quot;over matching&quot; problems are due to inappropriate use of <code>m/$</code> .  I start out thinking, recursively matching will save me a bunch of typing.  I end up thinking, why did I ever think that was a good idea!</z><z id="t1623951363" t="noprompt I love m/$ for rummaging through data I’m unfamiliar with."><y>#</y><d>2021-06-17</d><h>17:36</h><r>noprompt</r>I love <code>m/$</code> for rummaging through data I’m unfamiliar with.</z><z id="t1623951615" t="markaddleman I&apos;ve thought about an extension to m/$ that indicates a &quot;recurse no deeper&quot; pattern"><y>#</y><d>2021-06-17</d><h>17:40</h><r>markaddleman</r>I&apos;ve thought about an extension to <code>m/$</code> that indicates a &quot;recurse no deeper&quot; pattern</z><z id="t1623951630" t="markaddleman something like the top-down-until strategy"><y>#</y><d>2021-06-17</d><h>17:40</h><r>markaddleman</r>something like the <code>top-down-until</code> strategy</z><z id="t1623951825" t="noprompt Yes!"><y>#</y><d>2021-06-17</d><h>17:43</h><r>noprompt</r>Yes!</z><z id="t1624381570" t="timothypratley So I was porting some gamma meander to epsilon and it seems like gamma used to support ~@ but epsilon does not, can I still do the thing some other way?"><y>#</y><d>2021-06-22</d><h>17:06</h><w>timothypratley</w>So I was porting some gamma meander to epsilon and it seems like gamma used to support <code>~@</code> but epsilon does not, can I still do the thing some other way?</z><z id="t1624381924" t="timothypratley {:as ?m} (&apos;and ~@(second (unravel-pattern ?m))) is what I’m trying to port"><y>#</y><d>2021-06-22</d><h>17:12</h><w>timothypratley</w><pre>{:as ?m}
(&apos;and ~@(second (unravel-pattern ?m)))</pre>
is what I’m trying to port</z><z id="t1624382756" t="noprompt [:attrs {:href &quot;/_/_/users/U06S1EJPL&quot;}] We should support ~@ but I’m working on an Asami ticket at the moment. In that case I think you should be able to write (&apos;and &amp; ~(second (unravel-pattern ?m))) Later today I’ll see what is required to add ~@ ."><y>#</y><d>2021-06-22</d><h>17:25</h><w>noprompt</w><a>@timothypratley</a> We should support <code>~@</code> but I’m working on an Asami ticket at the moment.

In that case I think you should be able to write
<pre>(&apos;and &amp; ~(second (unravel-pattern ?m)))</pre>
Later today I’ll see what is required to add <code>~@</code>.</z><z id="t1624382827" t="timothypratley 🙂 oh cool. No rush! 🙂"><y>#</y><d>2021-06-22</d><h>17:27</h><w>timothypratley</w><b>🙂</b> oh cool. No rush! <b>🙂</b></z><z id="t1624383646" t="noprompt Did that work?"><y>#</y><d>2021-06-22</d><h>17:40</h><w>noprompt</w>Did that work?</z><z id="t1624415846" t="timothypratley yes! 🙂 thank you"><y>#</y><d>2021-06-23</d><h>02:37</h><w>timothypratley</w>yes! <b>🙂</b> thank you</z><z id="t1624487904" t="noprompt PR for new options to disable type/bounds checking: https://github.com/noprompt/meander/pull/178"><y>#</y><d>2021-06-23</d><h>22:38</h><w>noprompt</w>PR for new options to disable type/bounds checking: <a href="https://github.com/noprompt/meander/pull/178" target="_blank">https://github.com/noprompt/meander/pull/178</a></z><z id="t1624488031" t="noprompt The CLJS job seems to be busted and I’m not sure why. 😕"><y>#</y><d>2021-06-23</d><h>22:40</h><w>noprompt</w>The CLJS job seems to be busted and I’m not sure why. <b>😕</b></z><z id="t1624488273" t="noprompt Yeah. Hmm. Weird. All of the tests seem to pass on my machine."><y>#</y><d>2021-06-23</d><h>22:44</h><w>noprompt</w>Yeah. Hmm. Weird. All of the tests seem to pass on my machine.</z><z id="t1624557910" t="noprompt OK new release with the above patch [meander/epsilon &quot;0.0.626&quot;] meander/epsilon {:mvn/version &quot;0.0.626&quot;} "><y>#</y><d>2021-06-24</d><h>18:05</h><w>noprompt</w>OK new release with the above patch
<pre>[meander/epsilon &quot;0.0.626&quot;]
meander/epsilon {:mvn/version &quot;0.0.626&quot;}</pre>
</z><z id="t1624575730" t="ribelo unsafe meander by using get instead of valAt sometimes is slower than safe meander"><y>#</y><d>2021-06-24</d><h>23:02</h><w>ribelo</w>unsafe meander by using <code>get</code> instead of <code>valAt</code> sometimes is slower than safe meander</z><z id="t1624578020" t="noprompt Yep"><y>#</y><d>2021-06-24</d><h>23:40</h><w>noprompt</w>Yep</z><z id="t1624578061" t="noprompt We can tweak that to be be very unsafe in that case. 🙂"><y>#</y><d>2021-06-24</d><h>23:41</h><w>noprompt</w>We can tweak that to be be very unsafe in that case. <b>🙂</b></z><z id="t1624578125" t="noprompt I’m pretty sure the same is true of nth"><y>#</y><d>2021-06-24</d><h>23:42</h><w>noprompt</w>I’m pretty sure the same is true of <code>nth</code></z><z id="t1624578191" t="noprompt In the case I described with Jimmy, we had used get and, in that case, the type checks were a part of the slow down."><y>#</y><d>2021-06-24</d><h>23:43</h><w>noprompt</w>In the case I described with Jimmy, we had used <code>get</code> and, in that case, the type checks were a part of the slow down.</z><z id="t1624578353" t="noprompt I’m happy to add another flag for preserving .valAt and .nth ."><y>#</y><d>2021-06-24</d><h>23:45</h><w>noprompt</w>I’m happy to add another flag for preserving <code>.valAt</code> and <code>.nth</code>.</z><z id="t1624602657" t="ribelo PR welcome?"><y>#</y><d>2021-06-25</d><h>06:30</h><w>ribelo</w>PR welcome?</z><z id="t1624625189" t="Jimmy Miller Always"><y>#</y><d>2021-06-25</d><h>12:46</h><w>Jimmy Miller</w>Always</z><z id="t1624642091" t="noprompt [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] you can use the changeset from that PR as a template for your patch."><y>#</y><d>2021-06-25</d><h>17:28</h><w>noprompt</w><a>@huxley</a> you can use the changeset from that PR as a template for your patch.</z><z id="t1624642230" t="noprompt I didn’t add tests for the change because testing macro expansions are gross. However, now that I’m reflecting on my laziness it occurs to me that we could probably write tests with m/find and m/$ to verify the tests are absent."><y>#</y><d>2021-06-25</d><h>17:30</h><w>noprompt</w>I didn’t add tests for the change because testing macro expansions are gross. However, now that I’m reflecting on my laziness it occurs to me that we could probably write tests with <code>m/find</code> and <code>m/$</code> to verify the tests are absent.</z><z id="t1624642322" t="noprompt (m/find (macroexpand (with-meta form {:meander.epsilon/unsafe true}))) (m/$ (clojure.core/map? _)) false _ true) "><y>#</y><d>2021-06-25</d><h>17:32</h><w>noprompt</w><pre>(m/find (macroexpand (with-meta form {:meander.epsilon/unsafe true})))
  (m/$ (clojure.core/map? _)) false
  _ true)</pre>
</z><z id="t1624642341" t="noprompt Its like testing the DOM."><y>#</y><d>2021-06-25</d><h>17:32</h><w>noprompt</w>Its like testing the DOM.</z><z id="t1624642345" t="noprompt 😂"><y>#</y><d>2021-06-25</d><h>17:32</h><w>noprompt</w><b>😂</b></z><z id="t1624902660" t="noprompt https://github.com/noprompt/meander/discussions/179"><y>#</y><d>2021-06-28</d><h>17:51</h><w>noprompt</w><a href="https://github.com/noprompt/meander/discussions/179" target="_blank">https://github.com/noprompt/meander/discussions/179</a></z><z id="t1624902681" t="noprompt Oh, no preview? Boo."><y>#</y><d>2021-06-28</d><h>17:51</h><w>noprompt</w>Oh, no preview? Boo.</z><z id="t1624902776" t="noprompt OK. So that link is for a discussion about configuration."><y>#</y><d>2021-06-28</d><h>17:52</h><w>noprompt</w>OK. So that link is for a discussion about configuration.</z><z id="t1624902814" t="noprompt [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] You can drop your flag ideas there if you want. A PR is fine too."><y>#</y><d>2021-06-28</d><h>17:53</h><w>noprompt</w><a>@huxley</a> You can drop your flag ideas there if you want. A PR is fine too.</z><z id="t1624983902" t="greg Hi, I&apos;m trying to integrate meander in my project and wandering how to transform {:AAA {:prop1 [&quot;A&quot; &quot;B&quot;] :prop2 [1 2 3 4]} :BBB {:prop1 [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;] :prop2 [8 9]}} into {:prop1 {:AAA [&quot;A&quot; &quot;B&quot;] :BBB [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;]} :prop2 {:AAA [1 2 3 4] :BBB [8 9]}} I&apos;m using it for the first time, so a bit struggling with it. The best I end up is this: (m/search {:AAA {:prop1 [&quot;A&quot; &quot;B&quot;] :prop2 [1 2 3 4]} :BBB {:prop1 [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;] :prop2 [8 9]}} {?topkey {:prop1 ?prop1v :prop2 ?prop2v}} {:prop1 {?topkey ?prop1v} :prop2 {?topkey ?prop1v}}) ; =&gt; {:prop1 {:AAA [&quot;A&quot; &quot;B&quot;]}, :prop2 {:AAA [&quot;A&quot; &quot;B&quot;]}} ; {:prop1 {:BBB [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;]}, :prop2 {:BBB [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;]}} Is there a way to perform deep merge out of the box here?"><y>#</y><d>2021-06-29</d><h>16:25</h><w>greg</w>Hi, I&apos;m trying to integrate meander in my project and wandering how to transform
<pre>{:AAA {:prop1 [&quot;A&quot; &quot;B&quot;]     :prop2 [1 2 3 4]}
 :BBB {:prop1 [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;] :prop2 [8 9]}}</pre>
into
<pre>{:prop1 {:AAA [&quot;A&quot; &quot;B&quot;]
         :BBB [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;]}
 :prop2 {:AAA [1 2 3 4]
         :BBB [8 9]}}</pre>
I&apos;m using it for the first time, so a bit struggling with it.
The best I end up is this:
<pre>(m/search {:AAA {:prop1 [&quot;A&quot; &quot;B&quot;] :prop2 [1 2 3 4]}
           :BBB {:prop1 [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;] :prop2 [8 9]}}
          {?topkey {:prop1 ?prop1v :prop2 ?prop2v}}
          {:prop1 {?topkey ?prop1v}
           :prop2 {?topkey ?prop1v}})

; =&gt; {:prop1 {:AAA [&quot;A&quot; &quot;B&quot;]}, :prop2 {:AAA [&quot;A&quot; &quot;B&quot;]}} 
;    {:prop1 {:BBB [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;]}, :prop2 {:BBB [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;]}}</pre>
Is there a way to perform deep merge out of the box here?</z><z id="t1624989514" t="noprompt [:attrs {:href &quot;/_/_/users/U023TQF5FM3&quot;}] Welcome. I’ve seen this problem before and I would say that Meander alone would not be a good fit. The recommendation for this problem is to use a combination of Meander and Clojure. (def result (m/search {:AAA {:prop1 [&quot;A&quot; &quot;B&quot;] :prop2 [1 2 3 4]} :BBB {:prop1 [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;] :prop2 [8 9]}} {?a {?b ?c}} [[?b ?a] ?c])) ;; =&gt; ([[:prop1 :AAA] [&quot;A&quot; &quot;B&quot;]] [[:prop2 :AAA] [1 2 3 4]] [[:prop1 :BBB] [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;]] [[:prop2 :BBB] [8 9]]) (reduce (fn [m [p v]] (assoc-in m p v)) {} result) ;; =&gt; {:prop1 {:AAA [&quot;A&quot; &quot;B&quot;], :BBB [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;]}, :prop2 {:AAA [1 2 3 4], :BBB [8 9]}}"><y>#</y><d>2021-06-29</d><h>17:58</h><w>noprompt</w><a>@grzegorz.rynkowski</a> Welcome. I’ve seen this problem before and I would say that Meander alone would not be a good fit. The recommendation for this problem is to use a combination of Meander and Clojure.

<pre>(def result
  (m/search {:AAA {:prop1 [&quot;A&quot; &quot;B&quot;]
                   :prop2 [1 2 3 4]}
             :BBB {:prop1 [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;]
                   :prop2 [8 9]}}
    {?a {?b ?c}}
    [[?b ?a] ?c]))
;; =&gt;
([[:prop1 :AAA] [&quot;A&quot; &quot;B&quot;]]
 [[:prop2 :AAA] [1 2 3 4]]
 [[:prop1 :BBB] [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;]]
 [[:prop2 :BBB] [8 9]])

(reduce (fn [m [p v]] (assoc-in m p v)) {} result)
;; =&gt;
{:prop1 {:AAA [&quot;A&quot; &quot;B&quot;], :BBB [&quot;X&quot; &quot;Y&quot; &quot;Z&quot;]},
 :prop2 {:AAA [1 2 3 4], :BBB [8 9]}}</pre></z><z id="t1624989980" t="noprompt Comparing the m/search to what you might do in Clojure (input is example map): (mapcat (fn [[a m]] (map (fn [[b c]] [[b a] c]) m)) input) (m/search input {?a {?b ?c}} [[?b ?a] ?c]) "><y>#</y><d>2021-06-29</d><h>18:06</h><w>noprompt</w>Comparing the <code>m/search</code> to what you might do in Clojure (input is example map):
<pre>(mapcat (fn [[a m]] (map (fn [[b c]] [[b a] c]) m)) input)
(m/search input {?a {?b ?c}} [[?b ?a] ?c])</pre>
</z><z id="t1624990018" t="noprompt To produce the intermediate sequence of [[b a] c] ."><y>#</y><d>2021-06-29</d><h>18:06</h><w>noprompt</w>To produce the intermediate sequence of <code>[[b a] c]</code> .</z><z id="t1624990308" t="noprompt A quick (time (dotimes [n 1000] (doall form))) between the two lines above, on my machine, show that Meander is, on average, about 5ms slower than vanilla Clojure. Depending on your goals that could be acceptable."><y>#</y><d>2021-06-29</d><h>18:11</h><w>noprompt</w>A quick <code>(time (dotimes [n 1000] (doall form)))</code> between the two lines above, on my machine,  show that Meander is, on average, about 5ms slower than vanilla Clojure. Depending on your goals that could be acceptable.</z><z id="t1624990462" t="noprompt Certainly I would say the m/search is easier to understand than the combination of mapcat and map . If you have more cases to consider, for example, a key that has a non map value, Meander can adjust to that easily."><y>#</y><d>2021-06-29</d><h>18:14</h><w>noprompt</w>Certainly I would say the <code>m/search</code> is easier to understand than the combination of <code>mapcat</code> and <code>map</code>. If you have more cases to consider, for example, a key that has a non map value, Meander can adjust to that easily.</z><z id="t1624994960" t="greg Thanks for the thorough explanation. Certainly it is easier to understand than mapcat + map, and quite elegant, especially for a generic transformations when properties names are irrelevant. Expressivity was the key reason why tried to use Meander at the first place. Although in my particular case, I ended up with simple reduce: (reduce (fn [{:keys [prop1 prop2]} [k v]] {:prop1 (assoc prop2 k (:prop1 v)) :prop2 (assoc prop1 k (:prop2 v))}) {} input)) It is just simpler, more concise, and in this particular case where properties names are known, it is easier to reason it. I will keep Meander in mind though. It looks like a great tool."><y>#</y><d>2021-06-29</d><h>19:29</h><r>greg</r>Thanks for the thorough explanation. Certainly it is easier to understand than mapcat + map, and quite elegant, especially for a generic transformations when properties names are irrelevant.

Expressivity was the key reason why tried to use Meander at the first place.
Although in my particular case, I ended up with simple reduce:

<pre>(reduce (fn [{:keys [prop1 prop2]} [k v]]
          {:prop1 (assoc prop2 k (:prop1 v))
           :prop2 (assoc prop1 k (:prop2 v))}) {} input))</pre>
It is just simpler, more concise, and in this particular case where properties names are known, it is easier to reason it.

I will keep Meander in mind though. It looks like a great tool.</z><z id="t1624995114" t="noprompt That makes perfect sense to me. 🙂"><y>#</y><d>2021-06-29</d><h>19:31</h><r>noprompt</r>That makes perfect sense to me. <b>🙂</b></z><z id="t1624990537" t="noprompt (m/search (assoc input :CCC &quot;Yarn&quot;) {?a {?b ?c}} [[?b ?a] ?c] {?a ?c} [[?a] ?c]) ;; =&gt; (,,, [[:CCC] &quot;Yarn&quot;]) "><y>#</y><d>2021-06-29</d><h>18:15</h><w>noprompt</w><pre>(m/search (assoc input :CCC &quot;Yarn&quot;)
  {?a {?b ?c}}
  [[?b ?a] ?c]

  {?a ?c}
  [[?a] ?c])
;; =&gt;
(,,, [[:CCC] &quot;Yarn&quot;])</pre>
</z><z id="t1624990750" t="noprompt [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] Do you still have the within examples lying around? Slack has truncated that discussion and I wanted to move it GH."><y>#</y><d>2021-06-29</d><h>18:19</h><w>noprompt</w><a>@markaddleman</a> Do you still have the <code>within</code> examples lying around? Slack has truncated that discussion and I wanted to move it GH.</z><z id="t1624990788" t="markaddleman I&apos;m using within in a dev project. I can easily reconstruct examples"><y>#</y><d>2021-06-29</d><h>18:19</h><r>markaddleman</r>I&apos;m using <code>within</code> in a dev project.  I can easily reconstruct examples</z><z id="t1624990826" t="noprompt If you’re able to open a discussion on GH, do so, if not, I shall create one for this topic. 🙂"><y>#</y><d>2021-06-29</d><h>18:20</h><r>noprompt</r>If you’re able to open a discussion on GH, do so, if not, I shall create one for this topic. <b>🙂</b></z><z id="t1624990849" t="markaddleman Sure I&apos;m picking that project back up later today or tomorrow and I&apos;ll open an issue with it"><y>#</y><d>2021-06-29</d><h>18:20</h><r>markaddleman</r>Sure  I&apos;m picking that project back up later today or tomorrow and I&apos;ll open an issue with it</z><z id="t1624990937" t="noprompt I want to reserve issues for items that have an action plan or bugs, and use discussions for ideas and, um, discussions. 😛"><y>#</y><d>2021-06-29</d><h>18:22</h><r>noprompt</r>I want to reserve issues for items that have an action plan or bugs, and use discussions for ideas and, um, discussions. <b>😛</b></z></g><g id="s11"><z id="t1624990977" t="markaddleman 😄 Sure"><y>#</y><d>2021-06-29</d><h>18:22</h><r>markaddleman</r><b>😄</b>  Sure</z><z id="t1624995099" t="greg [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] Maybe the clojurians archive can help here: https://clojurians-log.clojureverse.org/meander/ I think it&apos;s indexable by Google, so it might be possible to search through it"><y>#</y><d>2021-06-29</d><h>19:31</h><r>greg</r><a>@noprompt</a> Maybe the clojurians archive can help here: <a href="https://clojurians-log.clojureverse.org/meander/" target="_blank">https://clojurians-log.clojureverse.org/meander/</a>

I think it&apos;s indexable by Google, so it might be possible to search through it</z><z id="t1624994466" t="ribelo [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] I&apos;m out for the rest of the week. I&apos;ll definitely do a PR when I get back."><y>#</y><d>2021-06-29</d><h>19:21</h><w>ribelo</w><a>@noprompt</a> I&apos;m out for the rest of the week. I&apos;ll definitely do a PR when I get back.</z><z id="t1624994536" t="noprompt OK. I look forward to it. Have a great week! 😉"><y>#</y><d>2021-06-29</d><h>19:22</h><r>noprompt</r>OK. I look forward to it. Have a great week! <b>😉</b></z><z id="t1624995273" t="ribelo thx"><y>#</y><d>2021-06-29</d><h>19:34</h><r>ribelo</r>thx</z><z id="t1625008319" t="noprompt https://github.com/noprompt/meander/pull/180"><y>#</y><d>2021-06-29</d><h>23:11</h><w>noprompt</w><a href="https://github.com/noprompt/meander/pull/180" target="_blank">https://github.com/noprompt/meander/pull/180</a></z><z id="t1625008369" t="noprompt I know this is overdue. And maps will get the same treatment."><y>#</y><d>2021-06-29</d><h>23:12</h><w>noprompt</w>I know this is overdue. And maps will get the same treatment.</z><z id="t1625008414" t="noprompt I suspect this feature will be more useful for rewriting."><y>#</y><d>2021-06-29</d><h>23:13</h><w>noprompt</w>I suspect this feature will be more useful for rewriting.</z><z id="t1625098272" t="noprompt OK, bit of scope creep on the above PR to include maps. 🙂"><y>#</y><d>2021-07-01</d><h>00:11</h><w>noprompt</w>OK, bit of scope creep on the above PR to include maps. <b>🙂</b></z><z id="t1625098495" t="noprompt Some hilarious examples. (let [m {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7 :h 8 :i 9}] (r/find m {:g 7 :h 8 :i 9 &amp;a {?k (r/pred even?) &amp; &apos;{} :as ?m1} &amp;b ?m2} [?k ?m1 ?m2])) ;; =&gt; [:f {:f 6} {:e 5, :c 3, :b 2, :d 4, :a 1}] (let [?m1 {:a 1 :b 2} ?m2 {:c 3 :d 4} ?kvs1 [[:e 5] [:f 6]]] (r/subst {&amp;1 ?m1 &amp;2 ?m2 &amp;3 ?kvs1 &amp;4 [[:g 7] [:h 8] [:i 9]]})) ;; =&gt; {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7 :h 8 :i 9}"><y>#</y><d>2021-07-01</d><h>00:14</h><w>noprompt</w>Some hilarious examples.
<pre>(let [m {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7 :h 8 :i 9}]
  (r/find m
    {:g 7 :h 8 :i 9
     &amp;a {?k (r/pred even?) &amp; &apos;{} :as ?m1}
     &amp;b ?m2}
    [?k ?m1 ?m2]))
;; =&gt;
[:f {:f 6} {:e 5, :c 3, :b 2, :d 4, :a 1}]

(let [?m1 {:a 1 :b 2}
      ?m2 {:c 3 :d 4}
      ?kvs1 [[:e 5] [:f 6]]]
  (r/subst {&amp;1 ?m1
            &amp;2 ?m2
            &amp;3 ?kvs1
            &amp;4 [[:g 7] [:h 8] [:i 9]]}))
;; =&gt;
{:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7 :h 8 :i 9}</pre></z><z id="t1625098574" t="noprompt So basically symbols with names matching the regex &amp;.* can be used many times."><y>#</y><d>2021-07-01</d><h>00:16</h><w>noprompt</w>So basically symbols with names matching the regex <code>&amp;.*</code> can be used many times.</z><z id="t1625098724" t="noprompt I just need to do a bit of post processing to clean up the output for substitution."><y>#</y><d>2021-07-01</d><h>00:18</h><w>noprompt</w>I just need to do a bit of post processing to clean up the output for substitution.</z><z id="t1625165530" t="noprompt So just FYI the new syntax will allow you to write (a b c &amp; _ l m n &amp; _ x y z) instead of (a b c . _ ... l m n . _ ... x y z) "><y>#</y><d>2021-07-01</d><h>18:52</h><w>noprompt</w>So just FYI the new syntax will allow you to write
<pre>(a b c &amp; _ l m n &amp; _ x y z)</pre>
instead of
<pre>(a b c . _ ... l m n . _ ... x y z)</pre>
</z><z id="t1625165633" t="noprompt The PR is still open, I haven’t merged anything yet. I’m waiting on review/approval/comments from others (if anyone has them)."><y>#</y><d>2021-07-01</d><h>18:53</h><w>noprompt</w>The PR is still open, I haven’t merged anything yet. I’m waiting on review/approval/comments from others (if anyone has them).</z><z id="t1625165913" t="ribelo I&apos;m still not here, but tomorrow I&apos;ll be talking publicly about why meander is awesome"><y>#</y><d>2021-07-01</d><h>18:58</h><w>ribelo</w>I&apos;m still not here, but tomorrow I&apos;ll be talking publicly about why meander is awesome</z><z id="t1625166188" t="noprompt Awesome! Good luck with your talk."><y>#</y><d>2021-07-01</d><h>19:03</h><w>noprompt</w>Awesome! Good luck with your talk.</z><z id="t1625166323" t="noprompt Everyone: I’m also starting to make some updates to the backlog. Currently I’m moving some issues to the discussions section, and closing issues which either can’t be resolved or do not seem like “discussion material” pending an action plan, etc."><y>#</y><d>2021-07-01</d><h>19:05</h><w>noprompt</w>Everyone: I’m also starting to make some updates to the backlog. Currently I’m moving some issues to the discussions section, and closing issues which either can’t be resolved or do not seem like “discussion material” pending an action plan, etc.</z><z id="t1625170388" t="noprompt OK. I think for the most part thats done."><y>#</y><d>2021-07-01</d><h>20:13</h><w>noprompt</w>OK. I think for the most part thats done.</z><z id="t1625170646" t="noprompt Probably the most important discussion at the moment will is the one about configuration: https://github.com/noprompt/meander/discussions/179"><y>#</y><d>2021-07-01</d><h>20:17</h><w>noprompt</w>Probably the most important discussion at the moment will is the one about configuration: <a href="https://github.com/noprompt/meander/discussions/179" target="_blank">https://github.com/noprompt/meander/discussions/179</a></z><z id="t1625170665" t="noprompt I urge anyone with opinions/ideas about the matter to chip in."><y>#</y><d>2021-07-01</d><h>20:17</h><w>noprompt</w>I urge anyone with opinions/ideas about the matter to chip in.</z><z id="t1625170747" t="noprompt When I get a chance, I plan on opening a discussion about zeta ."><y>#</y><d>2021-07-01</d><h>20:19</h><w>noprompt</w>When I get a chance, I plan on opening a discussion about <code>zeta</code> .</z><z id="t1625170949" t="noprompt I will probably mention this in that discussion, but I want to let everyone know that I plan to make zeta the final version of the library (with me as the maintainer anyway) so I would like to ensure that it is robust enough to adapt and extend."><y>#</y><d>2021-07-01</d><h>20:22</h><w>noprompt</w>I will probably mention this in that discussion, but I want to let everyone know that I plan to make <code>zeta</code> the final version of the library (with me as the maintainer anyway) so I would like to ensure that it is robust enough to adapt and extend.</z><z id="t1625172450" t="markaddleman You&apos;ve had enough? 😉"><y>#</y><d>2021-07-01</d><h>20:47</h><w>markaddleman</w>You&apos;ve had enough? <b>😉</b></z><z id="t1625615718" t="ribelo [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] , [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] it seems to me that meander creates unnecessary code"><y>#</y><d>2021-07-06</d><h>23:55</h><w>ribelo</w><a>@noprompt</a>, <a>@jimmy</a> it seems to me that meander creates unnecessary code</z><z id="t1625615757" t="ribelo (m/match {:a 1} {:a ?x} ?x) (let* [R__26396 (let* [T__26393 {:a 1}] (let* [T__26394 (. T__26393 valAt :a)] (let* [?x T__26394] (let* [T__26395 (dissoc T__26393 :a)] ?x))))] (if (meander.match.runtime.epsilon/fail? R__26396) (throw (ex-info &quot;non exhaustive pattern match&quot; {})) R__26396))"><y>#</y><d>2021-07-06</d><h>23:55</h><w>ribelo</w><pre>(m/match {:a 1}
    {:a ?x} ?x)

(let*
  [R__26396
   (let*
     [T__26393 {:a 1}]
     (let*
       [T__26394 (. T__26393 valAt :a)]
       (let*
         [?x T__26394]
         (let* [T__26395 (dissoc T__26393 :a)] ?x))))]
  (if (meander.match.runtime.epsilon/fail? R__26396)
    (throw (ex-info &quot;non exhaustive pattern match&quot; {}))
    R__26396))</pre></z><z id="t1625615793" t="ribelo I don&apos;t think this dissoc serves any purpose"><y>#</y><d>2021-07-06</d><h>23:56</h><w>ribelo</w>I don&apos;t think this <code>dissoc</code> serves any purpose</z><z id="t1625616186" t="noprompt [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] Yes. I’m aware of this problem and have been meaning to fix it."><y>#</y><d>2021-07-07</d><h>00:03</h><w>noprompt</w><a>@huxley</a> Yes. I’m aware of this problem and have been meaning to fix it.</z><z id="t1625616198" t="ribelo oh, ok"><y>#</y><d>2021-07-07</d><h>00:03</h><w>ribelo</w>oh, ok</z><z id="t1625616212" t="noprompt 🙂"><y>#</y><d>2021-07-07</d><h>00:03</h><w>noprompt</w><b>🙂</b></z><z id="t1625616292" t="noprompt Also, thank you for bringing it up."><y>#</y><d>2021-07-07</d><h>00:04</h><w>noprompt</w>Also, thank you for bringing it up.</z><z id="t1625616303" t="noprompt I would’ve forgotten."><y>#</y><d>2021-07-07</d><h>00:05</h><w>noprompt</w>I would’ve forgotten.</z><z id="t1625616309" t="ribelo np"><y>#</y><d>2021-07-07</d><h>00:05</h><w>ribelo</w>np</z><z id="t1625616314" t="noprompt And then have been back at “meaning to fix it”."><y>#</y><d>2021-07-07</d><h>00:05</h><w>noprompt</w>And then have been back at “meaning to fix it”.</z><z id="t1625616341" t="ribelo Unfortunately, I don&apos;t think I can help you here"><y>#</y><d>2021-07-07</d><h>00:05</h><w>ribelo</w>Unfortunately, I don&apos;t think I can help you here</z><z id="t1625616382" t="noprompt Not a problem. I wouldn’t want anyone to suffer fixing it anyway because IIRC the way the dissoc is put there is a bit of a hack."><y>#</y><d>2021-07-07</d><h>00:06</h><w>noprompt</w>Not a problem. I wouldn’t want anyone to suffer fixing it anyway because IIRC the way the dissoc is put there is a bit of a hack.</z><z id="t1625616447" t="noprompt Killing those will help a lot with the performance of map code."><y>#</y><d>2021-07-07</d><h>00:07</h><w>noprompt</w>Killing those will help a lot with the performance of map code.</z><z id="t1625616460" t="noprompt Especially for larger maps."><y>#</y><d>2021-07-07</d><h>00:07</h><w>noprompt</w>Especially for larger maps.</z><z id="t1625616466" t="ribelo I look at what can be done to speed things up following the unsafe patch"><y>#</y><d>2021-07-07</d><h>00:07</h><w>ribelo</w>I look at what can be done to speed things up following the <code>unsafe</code> patch</z><z id="t1625616500" t="ribelo With such a simple map, this dissoc takes 40% of the total time"><y>#</y><d>2021-07-07</d><h>00:08</h><w>ribelo</w>With such a simple map, this <code>dissoc</code> takes 40% of the total time</z><z id="t1625616538" t="ribelo and all in all I can do very little"><y>#</y><d>2021-07-07</d><h>00:08</h><w>ribelo</w>and all in all I can do very little</z><z id="t1625616804" t="noprompt OK. I’ll make this a priority this week."><y>#</y><d>2021-07-07</d><h>00:13</h><w>noprompt</w>OK. I’ll make this a priority this week.</z><z id="t1625617136" t="ribelo there doesn&apos;t seem to be an urgent need"><y>#</y><d>2021-07-07</d><h>00:18</h><w>ribelo</w>there doesn&apos;t seem to be an urgent need</z><z id="t1625617157" t="noprompt I’m pretty sure the problem is due to meander.match.syntax.epsilon/expand-map . This function tries to rewrite the :map node such that certain keys are prioritized, :as is desugared, etc."><y>#</y><d>2021-07-07</d><h>00:19</h><w>noprompt</w>I’m pretty sure the problem is due to <code>meander.match.syntax.epsilon/expand-map</code>. This function tries to rewrite the <code>:map</code> node such that certain keys are prioritized, <code>:as</code> is desugared, etc.</z><z id="t1625617268" t="noprompt It should only perform the dissoc when there are rest patterns involved."><y>#</y><d>2021-07-07</d><h>00:21</h><w>noprompt</w>It should only perform the <code>dissoc</code> when there are rest patterns involved.</z><z id="t1625617303" t="noprompt {:a ?x} should not cause a dissoc to be compiled but {:a ?x &amp; ?rest} definitely should."><y>#</y><d>2021-07-07</d><h>00:21</h><w>noprompt</w><code>{:a ?x}</code> should not cause a <code>dissoc</code> to be compiled but <code>{:a ?x &amp; ?rest}</code> definitely should.</z><z id="t1625617331" t="ribelo it seems not, because after adding the print inside meander.match.syntax.epsilon/expand-map nothing happens :thinking_face:"><y>#</y><d>2021-07-07</d><h>00:22</h><w>ribelo</w>it seems not, because after adding the print inside <code>meander.match.syntax.epsilon/expand-map</code> nothing happens <b>:thinking_face:</b></z><z id="t1625617360" t="noprompt Hmm… I should probably start a REPL."><y>#</y><d>2021-07-07</d><h>00:22</h><w>noprompt</w>Hmm… I should probably start a REPL.</z><z id="t1625617383" t="noprompt Ah, you’re right."><y>#</y><d>2021-07-07</d><h>00:23</h><w>noprompt</w>Ah, you’re right.</z><z id="t1625617392" t="ribelo I could be wrong, because the meander is HUGE and it&apos;s easy to get lost here"><y>#</y><d>2021-07-07</d><h>00:23</h><w>ribelo</w>I could be wrong, because the meander is HUGE and it&apos;s easy to get lost here</z><z id="t1625617432" t="noprompt Line 726 of meander.match.epsilon rest-rhs (r.ir/op-bind rest_target (r.ir/op-eval `(dissoc ~target ~@local-literal-key-codes)) rest-ir) "><y>#</y><d>2021-07-07</d><h>00:23</h><w>noprompt</w>Line 726 of <code>meander.match.epsilon</code>
<pre>rest-rhs (r.ir/op-bind rest_target (r.ir/op-eval `(dissoc ~target ~@local-literal-key-codes))
           rest-ir)</pre>
</z><z id="t1625617467" t="noprompt &gt; meander is HUGE I know. I’m not proud of that. zeta will be much, much smaller."><y>#</y><d>2021-07-07</d><h>00:24</h><w>noprompt</w>&gt; meander is HUGE
I know. I’m not proud of that. <code>zeta</code> will be much, much smaller.</z><z id="t1625617577" t="noprompt The current state of the project is the result of scope creep, and experimentation."><y>#</y><d>2021-07-07</d><h>00:26</h><w>noprompt</w>The current state of the project is the result of scope creep, and experimentation.</z><z id="t1625617592" t="ribelo that wasn&apos;t meant to sound like an objection"><y>#</y><d>2021-07-07</d><h>00:26</h><w>ribelo</w>that wasn&apos;t meant to sound like an objection</z><z id="t1625617600" t="noprompt I know. 🙂"><y>#</y><d>2021-07-07</d><h>00:26</h><w>noprompt</w>I know. <b>🙂</b></z><z id="t1625617888" t="noprompt Seems like I can get rid of the dissoc by changing that line to check if the :rest-map is set."><y>#</y><d>2021-07-07</d><h>00:31</h><w>noprompt</w>Seems like I can get rid of the dissoc by changing that line to check if the <code>:rest-map</code> is set.</z><z id="t1625618027" t="noprompt OK seems like that worked and tests pass."><y>#</y><d>2021-07-07</d><h>00:33</h><w>noprompt</w>OK seems like that worked and tests pass.</z><z id="t1625618069" t="noprompt (let [x {:a 1}] (m/match x {:a ?x, :b ?y, :c ?z} ?x)) ;; =&gt; (let* [R__12612 (let* [T__12607 x] (if (map? T__12607) (let* [T__12610 (. T__12607 valAt :c) T__12609 (. T__12607 valAt :b) T__12608 (. T__12607 valAt :a)] (let* [?x T__12608] (let* [?y T__12609] (let* [?z T__12610] ?x)))) meander.match.runtime.epsilon/FAIL))] (if (meander.match.runtime.epsilon/fail? R__12612) (throw (ex-info &quot;non exhaustive pattern match&quot; {})) R__12612)) No dissoc."><y>#</y><d>2021-07-07</d><h>00:34</h><w>noprompt</w><pre>(let [x {:a 1}]
  (m/match x
    {:a ?x, :b ?y, :c ?z}
    ?x))
;; =&gt;
(let*
  [R__12612
   (let*
     [T__12607 x]
     (if (map? T__12607)
       (let* [T__12610 (. T__12607 valAt :c)
              T__12609 (. T__12607 valAt :b)
              T__12608 (. T__12607 valAt :a)]
         (let* [?x T__12608]
           (let* [?y T__12609] (let* [?z T__12610] ?x))))
       meander.match.runtime.epsilon/FAIL))]
  (if (meander.match.runtime.epsilon/fail? R__12612)
    (throw (ex-info &quot;non exhaustive pattern match&quot; {}))
    R__12612))</pre>
No dissoc.</z><z id="t1625618438" t="noprompt OK fixed on epsilon . I’ll cut a release soon."><y>#</y><d>2021-07-07</d><h>00:40</h><w>noprompt</w>OK fixed on <code>epsilon</code>. I’ll cut a release soon.</z><z id="t1625618447" t="noprompt That should also include the new &amp; abilities."><y>#</y><d>2021-07-07</d><h>00:40</h><w>noprompt</w>That should also include the new <code>&amp;</code> abilities.</z><z id="t1625618492" t="noprompt I’ve gotta get up and get ready for dinner, etc."><y>#</y><d>2021-07-07</d><h>00:41</h><w>noprompt</w>I’ve gotta get up and get ready for dinner, etc.</z><z id="t1625618496" t="ribelo I added PR"><y>#</y><d>2021-07-07</d><h>00:41</h><w>ribelo</w>I added PR</z><z id="t1625618556" t="ribelo It&apos;s 3 a.m. at my place, so I&apos;m off. 😜"><y>#</y><d>2021-07-07</d><h>00:42</h><w>ribelo</w>It&apos;s 3 a.m. at my place, so I&apos;m off. <b>😜</b></z><z id="t1625618574" t="noprompt OK! A quick glance at this and it looks good."><y>#</y><d>2021-07-07</d><h>00:42</h><w>noprompt</w>OK! A quick glance at this and it looks good.</z><z id="t1625618613" t="noprompt I’m guessing fast means “Don’t check anything and call native methods?” 🙂"><y>#</y><d>2021-07-07</d><h>00:43</h><w>noprompt</w>I’m guessing fast means “Don’t check anything and call native methods?” <b>🙂</b></z><z id="t1625618688" t="ribelo yes"><y>#</y><d>2021-07-07</d><h>00:44</h><w>ribelo</w>yes</z><z id="t1625618717" t="ribelo When I get settled in, maybe I&apos;ll think of something else"><y>#</y><d>2021-07-07</d><h>00:45</h><w>ribelo</w>When I get settled in, maybe I&apos;ll think of something else</z><z id="t1625618742" t="noprompt I’m thinking maybe this is what unsafe should be."><y>#</y><d>2021-07-07</d><h>00:45</h><w>noprompt</w>I’m thinking maybe this is what unsafe should be.</z><z id="t1625618791" t="ribelo I&apos;m trying to catch up with datascript speed with my naive implementation of datalog using meander"><y>#</y><d>2021-07-07</d><h>00:46</h><w>ribelo</w>I&apos;m trying to catch up with datascript speed with my naive implementation of datalog using meander</z><z id="t1625618799" t="noprompt Gotcha."><y>#</y><d>2021-07-07</d><h>00:46</h><w>noprompt</w>Gotcha.</z><z id="t1625618827" t="noprompt Yeah, lemme think about it for a moment. I doubt it would break anyone to make this is the implementation of unsafe ."><y>#</y><d>2021-07-07</d><h>00:47</h><w>noprompt</w>Yeah, lemme think about it for a moment. I doubt it would break anyone to make this is the implementation of <code>unsafe</code>.</z><z id="t1625618836" t="noprompt It’s new stuff anyway."><y>#</y><d>2021-07-07</d><h>00:47</h><w>noprompt</w>It’s new stuff anyway.</z><z id="t1625618870" t="ribelo I think so too, but I saw that you changed from valAt to get"><y>#</y><d>2021-07-07</d><h>00:47</h><w>ribelo</w>I think so too, but I saw that you changed from <code>valAt</code> to <code>get</code></z><z id="t1625618915" t="noprompt I did because I was under the impression that using get without type checks was “fast enough”."><y>#</y><d>2021-07-07</d><h>00:48</h><w>noprompt</w>I did because I was under the impression that using <code>get</code> without type checks was “fast enough”.</z><z id="t1625618929" t="ribelo and from what I&apos;ve been testing, .get is probably faster than .valAt"><y>#</y><d>2021-07-07</d><h>00:48</h><w>ribelo</w>and from what I&apos;ve been testing, <code>.get</code> is probably faster than <code>.valAt</code></z><z id="t1625618950" t="noprompt Ah, interesting."><y>#</y><d>2021-07-07</d><h>00:49</h><w>noprompt</w>Ah, interesting.</z><z id="t1625618954" t="noprompt Works for me."><y>#</y><d>2021-07-07</d><h>00:49</h><w>noprompt</w>Works for me.</z><z id="t1625618965" t="ribelo there are cases where unsafe is slower than safe"><y>#</y><d>2021-07-07</d><h>00:49</h><w>ribelo</w>there are cases where <code>unsafe</code> is slower than <code>safe</code></z><z id="t1625619015" t="noprompt TBH I think unsafe, at a minimum, should be as fast safe."><y>#</y><d>2021-07-07</d><h>00:50</h><w>noprompt</w>TBH I think unsafe, at a minimum, should be as fast safe.</z><z id="t1625619169" t="ribelo in case of a large map and many lookups, the benefit of not checking if the object is a map is negated due that the get is much slower"><y>#</y><d>2021-07-07</d><h>00:52</h><w>ribelo</w>in case of a large map and many lookups, the benefit of not checking if the object is a map is negated due that the <code>get</code> is much slower</z><z id="t1625619237" t="ribelo Go to dinner, I&apos;m going to bed. I have to get up in 4 hours:sweat_smile:"><y>#</y><d>2021-07-07</d><h>00:53</h><w>ribelo</w>Go to dinner, I&apos;m going to bed. I have to get up in 4 hours:sweat_smile:</z><z id="t1625684185" t="noprompt [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] do you foresee/have any objections to having unsafe do what the fast flag is doing? IOW should the patch [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] be the implementation of unsafe?"><y>#</y><d>2021-07-07</d><h>18:56</h><w>noprompt</w><a>@jimmy</a> do you foresee/have any objections to having unsafe do what the fast flag is doing? IOW should the patch <a>@huxley</a> be the implementation of unsafe?</z><z id="t1625684311" t="noprompt Because if skipping the type checks and using get is slower than having type checks and using .valAt , etc. it doesn’t really make a lot of sense for the unsafe option, as it is implemented now, to exist."><y>#</y><d>2021-07-07</d><h>18:58</h><w>noprompt</w>Because if skipping the type checks and using <code>get</code> is slower than having type checks and using <code>.valAt</code>, etc. it doesn’t really make a lot of sense for the unsafe option, as it is implemented now, to exist.</z><z id="t1625684482" t="Jimmy Miller I don&apos;t think so. Though I personally think depending on ILookup (.valAt) instead of APersistentMap (.get) gives us more flexibility. We don&apos;t want to only work on APersistentMaps for that. Anything implementing ILookup should be allowed (in my view). Maybe for non-unsafe where we know map? is true we could use .get if it is truly faster. For example, one thing we might want to support in unsafe mode is transients, but transients are not APersistentMaps."><y>#</y><d>2021-07-07</d><h>19:01</h><w>Jimmy Miller</w>I don&apos;t think so. Though I personally think depending on ILookup (.valAt) instead of APersistentMap (.get) gives us more flexibility. We don&apos;t want to only work on APersistentMaps for that. Anything implementing ILookup should be allowed (in my view). Maybe for non-unsafe where we know map? is true we could use .get if it is truly faster.

For example, one thing we might  want to support in unsafe mode is transients, but transients are not APersistentMaps.</z><z id="t1625684628" t="noprompt +-------------+----------------+----------------------------+ | type-check? | native-method? | result | +-------------+----------------+----------------------------+ | true | false | (f object ,,,) | &lt; Slow +-------------+----------------+----------------------------+ | true | true | (.method ^Type object ,,,) | &lt; Safe (Default) +-------------+----------------+----------------------------+ | false | false | (f object ,,,) | &lt; Unsafe +-------------+----------------+----------------------------+ | false | true | (.method ^Type object ,,,) | &lt; Dangerous +-------------+----------------+----------------------------+"><y>#</y><d>2021-07-07</d><h>19:03</h><w>noprompt</w><pre>+-------------+----------------+----------------------------+
| type-check? | native-method? | result                     |
+-------------+----------------+----------------------------+
| true        | false          | (f object ,,,)             | &lt; Slow
+-------------+----------------+----------------------------+
| true        | true           | (.method ^Type object ,,,) | &lt; Safe (Default)
+-------------+----------------+----------------------------+
| false       | false          | (f object ,,,)             | &lt; Unsafe
+-------------+----------------+----------------------------+
| false       | true           | (.method ^Type object ,,,) | &lt; Dangerous
+-------------+----------------+----------------------------+</pre></z><z id="t1625684716" t="noprompt &gt; Maybe for non-unsafe where we know map? is true we could use .get if it is truly faster."><y>#</y><d>2021-07-07</d><h>19:05</h><w>noprompt</w>&gt;  Maybe for non-unsafe where we know map? is true we could use .get if it is truly faster.</z><z id="t1625684723" t="noprompt I think thats a wise response."><y>#</y><d>2021-07-07</d><h>19:05</h><w>noprompt</w>I think thats a wise response.</z><z id="t1625684777" t="noprompt The table up there captures the general picture of safetiness."><y>#</y><d>2021-07-07</d><h>19:06</h><w>noprompt</w>The table up there captures the general picture of safetiness.</z><z id="t1625684809" t="noprompt Instead of fast I think we should dub the flag “dangerous”."><y>#</y><d>2021-07-07</d><h>19:06</h><w>noprompt</w>Instead of fast I think we should dub the flag “dangerous”.</z><z id="t1625685023" t="noprompt Note, that I’m throwing bounds-check? into the same basket as type-check? since it has a similar effect."><y>#</y><d>2021-07-07</d><h>19:10</h><w>noprompt</w>Note, that I’m throwing <code>bounds-check?</code> into the same basket as <code>type-check?</code> since it has a similar effect.</z><z id="t1625685655" t="markaddleman I recently updated to meander 0.0.626 and I get the following warnings when I start the REPL: Performance warning, meander/util/epsilon.cljc:123:3 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:157:3 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:191:3 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:221:3 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:314:6 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:291:4 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:374:6 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:348:4 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:435:3 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:630:3 - case has int tests, but tested expression is not primitive. Reflection warning, meander/util/epsilon.cljc:714:24 - reference to field val can&apos;t be resolved. I doubt it&apos;s a problem but wanted to call it out just in case"><y>#</y><d>2021-07-07</d><h>19:20</h><w>markaddleman</w>I recently updated to meander 0.0.626 and I get the following warnings when I start the REPL:
<pre>Performance warning, meander/util/epsilon.cljc:123:3 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:157:3 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:191:3 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:221:3 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:314:6 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:291:4 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:374:6 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:348:4 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:435:3 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:630:3 - case has int tests, but tested expression is not primitive.
Reflection warning, meander/util/epsilon.cljc:714:24 - reference to field val can&apos;t be resolved.</pre>
I doubt it&apos;s a problem but wanted to call it out just in case</z><z id="t1625686434" t="noprompt [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] I recently fixed those errors and all but the last of those should go away with the next release."><y>#</y><d>2021-07-07</d><h>19:33</h><w>noprompt</w><a>@markaddleman</a> I recently fixed those errors and all but the last of those should go away with the next release.</z><z id="t1625686491" t="noprompt I’m hoping that we come to an agreement/patch on some of the new flag stuff and I can release that in addition to the update to &amp; patterns."><y>#</y><d>2021-07-07</d><h>19:34</h><w>noprompt</w>I’m hoping that we come to an agreement/patch on some of the new flag stuff and I can release that in addition to the update to <code>&amp;</code> patterns.</z><z id="t1625686599" t="noprompt BTW in case anyone is interested, the algorithm I used to generate the space for map patterns like {&amp;1 ?m1 &amp;2 ?m2 &amp;3 ?m3} came from the Art of Computer Programming Volume 4A on the topic of partitions."><y>#</y><d>2021-07-07</d><h>19:36</h><w>noprompt</w>BTW in case anyone is interested, the algorithm I used to generate the space for map patterns like
<pre>{&amp;1 ?m1 &amp;2 ?m2 &amp;3 ?m3}</pre>
came from the Art of Computer Programming Volume 4A on the topic of partitions.</z><z id="t1625686657" t="noprompt I’m sure there’s some more good stuff in there. Its a big book!"><y>#</y><d>2021-07-07</d><h>19:37</h><w>noprompt</w>I’m sure there’s some more good stuff in there. Its a big book!</z><z id="t1625686984" t="markaddleman On a related topic, I just discovered a pattern that compiled in 0.0.602 but does not compile in 626: (comment ; does not compile (m/rewrites {} {:group-defaults (m/scan {:attribute {:alias (m/some ?alias)} :from-expression (m/some ?expression)}) :group-by (m/scan {:alias ?alias :as ?group-by})} {:group-by [{:default {:from-expression ?expression} &amp; ?group-by}]} {:group-by (m/scan {(m/some :alias) ?a :as ?group-by}) :group-defaults (m/scan {:attribute {:alias (m/not ?a)}})} {:group-by [?group-by]}))"><y>#</y><d>2021-07-07</d><h>19:43</h><w>markaddleman</w>On a related topic, I just discovered a pattern that compiled in 0.0.602 but does not compile in 626:
<pre>(comment
  ; does not compile
  (m/rewrites {}
    {:group-defaults (m/scan {:attribute       {:alias (m/some ?alias)}
                              :from-expression (m/some ?expression)})
     :group-by       (m/scan {:alias ?alias :as ?group-by})}
    {:group-by [{:default {:from-expression ?expression} &amp; ?group-by}]}

    {:group-by       (m/scan {(m/some :alias) ?a :as ?group-by})
     :group-defaults (m/scan {:attribute {:alias (m/not ?a)}})}
    {:group-by [?group-by]}))</pre></z><z id="t1625687008" t="markaddleman Meander complains Unable to resolve symbol: ?a in this context"><y>#</y><d>2021-07-07</d><h>19:43</h><w>markaddleman</w>Meander complains <code>Unable to resolve symbol: ?a in this context</code></z><z id="t1625687032" t="markaddleman Oddly, this pattern compiles on .626: (m/rewrites {} {:group-by (m/scan {(m/some :alias) ?a :as ?group-by}) :group-defaults (m/scan {:attribute {:alias (m/not ?a)}})} {:group-by [?group-by]})"><y>#</y><d>2021-07-07</d><h>19:43</h><w>markaddleman</w>Oddly, this pattern compiles on .626:
<pre>(m/rewrites {}
    {:group-by       (m/scan {(m/some :alias) ?a :as ?group-by})
     :group-defaults (m/scan {:attribute {:alias (m/not ?a)}})}
    {:group-by [?group-by]})</pre></z><z id="t1625687075" t="markaddleman Both patterns compile successfully on 602"><y>#</y><d>2021-07-07</d><h>19:44</h><w>markaddleman</w>Both patterns compile successfully on 602</z><z id="t1625687696" t="noprompt I’ll take a look."><y>#</y><d>2021-07-07</d><h>19:54</h><w>noprompt</w>I’ll take a look.</z><z id="t1625691156" t="markaddleman whoopsie: My previous version of meander was 602 (not 606). Edited previous messages to make that clear"><y>#</y><d>2021-07-07</d><h>20:52</h><w>markaddleman</w>whoopsie:  My previous version of meander was 602 (not 606).  Edited previous messages to make that clear</z><z id="t1625691500" t="noprompt OK. I’ll compare the tags and see if I can narrow down the problem."><y>#</y><d>2021-07-07</d><h>20:58</h><w>noprompt</w>OK. I’ll compare the tags and see if I can narrow down the problem.</z><z id="t1625697388" t="ribelo depending on how we test, .get is faster than .valAt about 5-10%, I don&apos;t know if it&apos;s worth worrying about"><y>#</y><d>2021-07-07</d><h>22:36</h><w>ribelo</w>depending on how we test, <code>.get</code> is faster than <code>.valAt</code> about 5-10%, I don&apos;t know if it&apos;s worth worrying about</z><z id="t1625697754" t="ribelo but the situation looks quite different for cljs"><y>#</y><d>2021-07-07</d><h>22:42</h><w>ribelo</w>but the situation looks quite different for <code>cljs</code></z><z id="t1625698055" t="ribelo (let [m {:a 1}] (enc/qb 1e6 (get m :a) (.get m :a) (m :a))) ;; =&gt; [90 26 42] in ms"><y>#</y><d>2021-07-07</d><h>22:47</h><w>ribelo</w><pre>(let [m {:a 1}]
  (enc/qb 1e6
    (get m :a)
    (.get m :a)
    (m :a)))
;; =&gt; [90 26 42] in ms</pre></z><z id="t1625787545" t="noprompt FYI I’ll be doing some more hacking/helping tomorrow."><y>#</y><d>2021-07-08</d><h>23:39</h><w>noprompt</w>FYI I’ll be doing some more hacking/helping tomorrow.</z><z id="t1625867985" t="noprompt [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] do you feel comfortable with the checklist I provided on your PR? If not, I’m happy to merge what you have and hack on it."><y>#</y><d>2021-07-09</d><h>21:59</h><w>noprompt</w><a>@huxley</a> do you feel comfortable with the checklist I provided on your PR? If not, I’m happy to merge what you have and hack on it.</z><z id="t1625868583" t="ribelo Sure, I&apos;ll do it tomorrow [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}]"><y>#</y><d>2021-07-09</d><h>22:09</h><w>ribelo</w>Sure, I&apos;ll do it tomorrow <a>@noprompt</a></z><z id="t1625892187" t="noprompt Great. No rush."><y>#</y><d>2021-07-10</d><h>04:43</h><w>noprompt</w>Great. No rush.</z><z id="t1626044589" t="ribelo [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] what do you mean by desugar? Desugar the flag ::m/unsafe to #::m{:use-native-methods false, :no-type-check true}. "><y>#</y><d>2021-07-11</d><h>23:03</h><w>ribelo</w><a>@noprompt</a> what do you mean by desugar?
<pre>Desugar the flag ::m/unsafe to #::m{:use-native-methods false, :no-type-check true}.</pre>
</z><z id="t1626106378" t="noprompt [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] I’ll leave a note on the PR."><y>#</y><d>2021-07-12</d><h>16:12</h><w>noprompt</w><a>@huxley</a> I’ll leave a note on the PR.</z><z id="t1626608771" t="ribelo [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] Sorry it took so long, but I finally found the time to finish the PR https://github.com/noprompt/meander/pull/193"><y>#</y><d>2021-07-18</d><h>11:46</h><w>ribelo</w><a>@noprompt</a> Sorry it took so long, but I finally found the time to finish the PR <a href="https://github.com/noprompt/meander/pull/193" target="_blank">https://github.com/noprompt/meander/pull/193</a></z><z id="t1626805785" t="noprompt Awesome. I’ll merge it and it’ll go out with the next release. Before the next release, however, I do want to explore the regression mentioned a couple weeks ago."><y>#</y><d>2021-07-20</d><h>18:29</h><w>noprompt</w>Awesome. I’ll merge it and it’ll go out with the next release.

Before the next release, however, I do want to explore the regression mentioned a couple weeks ago.</z><z id="t1626805836" t="noprompt Last week was a busy week for me plus I was out of town so I didn’t have much time."><y>#</y><d>2021-07-20</d><h>18:30</h><w>noprompt</w>Last week was a busy week for me plus I was out of town so I didn’t have much time.</z><z id="t1626813103" t="ribelo Cool, I&apos;m glad PR it&apos;s OK."><y>#</y><d>2021-07-20</d><h>20:31</h><w>ribelo</w>Cool, I&apos;m glad PR it&apos;s OK.</z><z id="t1626813130" t="ribelo Don&apos;t worry, everyone has a life, or at least should have one 😉"><y>#</y><d>2021-07-20</d><h>20:32</h><w>ribelo</w>Don&apos;t worry, everyone has a life, or at least should have one <b>😉</b></z><z id="t1626846640" t="pbaille Hello, i&apos;ve stumble upon something weird this morning: (epsilon 626) (defn bug [expr] (m/match expr (m/pred number?) {:num expr} (?verb &amp; ?args) {:verb ?verb :args (map bug ?args)} _ {:any expr})) (bug &apos;(+ 1 (- 2 3))) ;; =&gt; {:any (+ 1 (- 2 3))} any idea ?"><y>#</y><d>2021-07-21</d><h>05:50</h><w>pbaille</w>Hello, i&apos;ve stumble upon something weird this morning: (epsilon 626)
<pre>(defn bug [expr]
  (m/match expr
           (m/pred number?) {:num expr}
           (?verb &amp; ?args) {:verb ?verb :args (map bug ?args)}
           _ {:any expr}))

(bug &apos;(+ 1 (- 2 3)))
;; =&gt; {:any (+ 1 (- 2 3))}</pre>
any idea ?</z><z id="t1626847107" t="pbaille here the expansion of the match form: (let* [R__26068 (clojure.core/let [T__26061 expr] (clojure.core/letfn [(state__26064 [] (if (number? T__26061) {:num expr} (state__26065))) (state__26065 [] {:any expr}) (state__26066 [] (if (clojure.core/seq? T__26061) (clojure.core/let [T__26061_L__ (clojure.core/take 1 T__26061)] (if (clojure.core/= (clojure.core/bounded-count 2 T__26061_L__) 1) (clojure.core/let [T__26061_R__ (clojure.core/drop 1 T__26061)] (clojure.core/let [T__26061_L___nth_0__ (clojure.core/nth T__26061_L__ 0)] (clojure.core/let [?verb T__26061_L___nth_0__] (clojure.core/let [?args T__26061_R__] {:verb ?verb, :args (map bug ?args)})))) (state__26067))) (state__26067))) (state__26067 [] {:any expr})] (state__26064)))] (if (meander.match.runtime.epsilon/fail? R__26068) (throw (clojure.core/ex-info &quot;non exhaustive pattern match&quot; {})) R__26068)) the :any branch appears two times in the letfn bindings."><y>#</y><d>2021-07-21</d><h>05:58</h><w>pbaille</w>here the expansion of the match form:
<pre>(let*
 [R__26068
  (clojure.core/let
   [T__26061 expr]
   (clojure.core/letfn
    [(state__26064 [] (if (number? T__26061) {:num expr} (state__26065)))
     (state__26065 [] {:any expr})
     (state__26066
      []
      (if
       (clojure.core/seq? T__26061)
       (clojure.core/let
        [T__26061_L__ (clojure.core/take 1 T__26061)]
        (if
         (clojure.core/= (clojure.core/bounded-count 2 T__26061_L__) 1)
         (clojure.core/let
          [T__26061_R__ (clojure.core/drop 1 T__26061)]
          (clojure.core/let
           [T__26061_L___nth_0__ (clojure.core/nth T__26061_L__ 0)]
           (clojure.core/let
            [?verb T__26061_L___nth_0__]
            (clojure.core/let [?args T__26061_R__] {:verb ?verb, :args (map bug ?args)}))))
         (state__26067)))
       (state__26067)))
     (state__26067 [] {:any expr})]
    (state__26064)))]
 (if
  (meander.match.runtime.epsilon/fail? R__26068)
  (throw (clojure.core/ex-info &quot;non exhaustive pattern match&quot; {}))
  R__26068))</pre>
the :any branch appears two times in the letfn bindings.</z><z id="t1626850586" t="pbaille btw it seems ok with epsilon 602"><y>#</y><d>2021-07-21</d><h>06:56</h><w>pbaille</w>btw it seems ok with epsilon 602</z><z id="t1626883511" t="noprompt Thanks for the report [:attrs {:href &quot;/_/_/users/U0A7SU3FS&quot;}] . It seems like I broke a few things in 626. I’ll be working to fix these issues this week."><y>#</y><d>2021-07-21</d><h>16:05</h><w>noprompt</w>Thanks for the report <a>@pbaille</a>. It seems like I broke a few things in 626. I’ll be working to fix these issues this week.</z><z id="t1627081702" t="noprompt I took some time to investigate the issues today and haven’t pinpointed the bug just yet. But I was also pulled in many directions today."><y>#</y><d>2021-07-23</d><h>23:08</h><w>noprompt</w>I took some time to investigate the issues today and haven’t pinpointed the bug just yet. But I was also pulled in many directions today.</z><z id="t1627081734" t="noprompt Tomorrow should be a lot more chill for me though."><y>#</y><d>2021-07-23</d><h>23:08</h><w>noprompt</w>Tomorrow should be a lot more chill for me though.</z><z id="t1627327822" t="noprompt Alright, I’ve found the problem and now I just need to find the solution."><y>#</y><d>2021-07-26</d><h>19:30</h><w>noprompt</w>Alright, I’ve found the problem and now I just need to find the solution.</z><z id="t1627327958" t="markaddleman Often, finding the problem is 80% of fixing the problem. Coming up with a solution is often the other 80% 😛"><y>#</y><d>2021-07-26</d><h>19:32</h><r>markaddleman</r>Often, finding the problem is 80% of fixing the problem.  Coming up with a solution is often the other 80% <b>😛</b></z><z id="t1627485425" t="Geoffrey Gaillard Hello! I’m trying to rewrite an infix pattern into prefix, like: &apos;[1 2 3 4 ! 5 6 7] =&gt; &apos;[1 2 3 (! 4 5) 6 7] I’m using rewrite but I can’t figure out the rule. Have I missed a doc page?"><y>#</y><d>2021-07-28</d><h>15:17</h><w>Geoffrey Gaillard</w>Hello!
I’m trying to rewrite an infix pattern into prefix, like:
<pre>&apos;[1 2 3 4 ! 5 6 7] =&gt; &apos;[1 2 3 (! 4 5) 6 7]</pre>
I’m using <code>rewrite</code> but I can’t figure out the rule. Have I missed a doc page?</z><z id="t1627497901" t="noprompt [:attrs {:href &quot;/_/_/users/U2DART3HA&quot;}] Here are a couple approaches. ;; Before 0.0.626 (let [xs [1 2 3 4 &apos;! 5 6 7 9]] (m/rewrite xs [!head ... ?x &apos;! ?y . !tail ...] [!head ... (&apos;! ?x ?y) . !tail ...])) ;; =&gt; [1 2 3 (! 4 5) 6 7 9] ;; 0.0.626 and later (let [xs [1 2 3 4 &apos;! 5 6 7 9]] (m/rewrite xs [&amp; ?head ?x &apos;! ?y &amp; ?tail] [&amp; ?head (&apos;! ?x ?y) &amp; ?tail])) ;; =&gt; [1 2 3 (! 4 5) 6 7 9] "><y>#</y><d>2021-07-28</d><h>18:45</h><w>noprompt</w><a>@ggaillard</a> Here are a couple approaches.

<pre>;; Before 0.0.626
(let [xs [1 2 3 4 &apos;! 5 6 7 9]]
  (m/rewrite xs
    [!head ... ?x &apos;! ?y . !tail ...]
    [!head ... (&apos;! ?x ?y) . !tail ...]))
;; =&gt;
[1 2 3 (! 4 5) 6 7 9]

;; 0.0.626 and later
(let [xs [1 2 3 4 &apos;! 5 6 7 9]]
  (m/rewrite xs
    [&amp; ?head ?x &apos;! ?y &amp; ?tail]
    [&amp; ?head (&apos;! ?x ?y) &amp; ?tail]))
;; =&gt;
[1 2 3 (! 4 5) 6 7 9]</pre>
</z><z id="t1627498808" t="Geoffrey Gaillard Cool! I&apos;ll try this. Thank you very much!"><y>#</y><d>2021-07-28</d><h>19:00</h><r>Geoffrey Gaillard</r>Cool! I&apos;ll try this.
 Thank you very much!</z><z id="t1627497945" t="noprompt 0.0.626 has some bugs and I would recommend using 0.0.602"><y>#</y><d>2021-07-28</d><h>18:45</h><w>noprompt</w><code>0.0.626</code> has some bugs and I would recommend using <code>0.0.602</code></z><z id="t1627500288" t="schmee really nice improvement between the two versions! 😄"><y>#</y><d>2021-07-28</d><h>19:24</h><w>schmee</w>really nice improvement between the two versions! <b>😄</b></z><z id="t1627500300" t="schmee does Meander have a changelog somewhere?"><y>#</y><d>2021-07-28</d><h>19:25</h><w>schmee</w>does Meander have a changelog somewhere?</z><z id="t1627502303" t="noprompt It does not. It should. There are only so many things I can keep up with. 😛"><y>#</y><d>2021-07-28</d><h>19:58</h><w>noprompt</w>It does not. It should. There are only so many things I can keep up with. <b>😛</b></z><z id="t1627502379" t="noprompt Does anyone know of a strategy for automatically computing a changelog?"><y>#</y><d>2021-07-28</d><h>19:59</h><w>noprompt</w>Does anyone know of a strategy for automatically computing a changelog?</z><z id="t1627502404" t="noprompt One thing we could do is make that a part of the release building process."><y>#</y><d>2021-07-28</d><h>20:00</h><w>noprompt</w>One thing we could do is make that a part of the release building process.</z><z id="t1627502439" t="noprompt Perhaps we could look at the commit history between the last tagged release, parse it, and make a changelog?"><y>#</y><d>2021-07-28</d><h>20:00</h><w>noprompt</w>Perhaps we could look at the commit history between the last tagged release, parse it, and make a changelog?</z><z id="t1627502458" t="noprompt It wouldn’t be perfect but it would at least be something!"><y>#</y><d>2021-07-28</d><h>20:00</h><w>noprompt</w>It wouldn’t be perfect but it would at least be something!</z><z id="t1627502480" t="noprompt Aaaaaand I would totally merge a patch for that! 😉"><y>#</y><d>2021-07-28</d><h>20:01</h><w>noprompt</w>Aaaaaand I would totally merge a patch for that! <b>😉</b></z><z id="t1627511082" t="ribelo IMHO changelog is not needed. Meander can safely be considered a niche of clojure niche library."><y>#</y><d>2021-07-28</d><h>22:24</h><w>ribelo</w>IMHO changelog is not needed. Meander can safely be considered a niche of clojure niche library.</z><z id="t1627511214" t="ribelo The few people who use it are certainly smart enough to be able to figure out the changes from the commit history 🙃"><y>#</y><d>2021-07-28</d><h>22:26</h><w>ribelo</w>The few people who use it are certainly smart enough to be able to figure out the changes from the commit history <b>🙃</b></z><z id="t1627512046" t="noprompt LOL"><y>#</y><d>2021-07-28</d><h>22:40</h><w>noprompt</w>LOL</z><z id="t1627512060" t="noprompt “niche of niche” 😛"><y>#</y><d>2021-07-28</d><h>22:41</h><w>noprompt</w>“niche of niche” <b>😛</b></z><z id="t1627512089" t="noprompt Jimmy recently cast it as “avant-garde” which I thought was both high-praise and certain doom. 🙂"><y>#</y><d>2021-07-28</d><h>22:41</h><w>noprompt</w>Jimmy recently cast it as “avant-garde” which I thought was both high-praise and certain doom. <b>🙂</b></z><z id="t1627512193" t="ribelo But here, there&apos;s no fooling around, and you can be happy about it. It&apos;s our, or at least mine, secret super weapon and super toy."><y>#</y><d>2021-07-28</d><h>22:43</h><w>ribelo</w>But here, there&apos;s no fooling around, and you can be happy about it. It&apos;s our, or at least mine, secret super weapon and super toy.</z><z id="t1627512519" t="ribelo You don&apos;t have many followers in the meandering church, but anyone who uses a meander will certainly appreciate it."><y>#</y><d>2021-07-28</d><h>22:48</h><w>ribelo</w>You don&apos;t have many followers in the meandering church, but anyone who uses a meander will certainly appreciate it.</z><z id="t1627512521" t="noprompt Thats enough for me! 🙂"><y>#</y><d>2021-07-28</d><h>22:48</h><w>noprompt</w>Thats enough for me! <b>🙂</b></z><z id="t1627512580" t="noprompt I mean, FWIW, the term rewriting space is, well, pretty sparse."><y>#</y><d>2021-07-28</d><h>22:49</h><w>noprompt</w>I mean, FWIW, the term rewriting space is, well, pretty sparse.</z><z id="t1627512592" t="noprompt In terms of population and people who “get it”."><y>#</y><d>2021-07-28</d><h>22:49</h><w>noprompt</w>In terms of population and people who “get it”.</z><z id="t1627512658" t="ribelo If you wanted to be the idol of the crowds, you should have written terminal spinners in javascript, or something equally groundbreaking."><y>#</y><d>2021-07-28</d><h>22:50</h><w>ribelo</w>If you wanted to be the idol of the crowds, you should have written terminal spinners in javascript, or something equally groundbreaking.</z><z id="t1627512684" t="noprompt One day."><y>#</y><d>2021-07-28</d><h>22:51</h><w>noprompt</w>One day.</z><z id="t1627512707" t="noprompt I’ve been thinking that its probably time for me to just make an actual language out of this thing."><y>#</y><d>2021-07-28</d><h>22:51</h><w>noprompt</w>I’ve been thinking that its probably time for me to just make an actual language out of this thing.</z><z id="t1627512741" t="noprompt Primarily, I want to build something that is only focused on manipulating data between two pipes."><y>#</y><d>2021-07-28</d><h>22:52</h><w>noprompt</w>Primarily, I want to build something that is only focused on manipulating data between two pipes.</z><z id="t1627512742" t="ribelo regarding term rerwriting, I suspect I don&apos;t get it but I use it anyway. 🙃"><y>#</y><d>2021-07-28</d><h>22:52</h><w>ribelo</w>regarding term rerwriting, I suspect I don&apos;t get it but I use it anyway. <b>🙃</b></z><z id="t1627512829" t="ribelo meander is already like a programming language, and writing macros that use meander to write code for meander is an inception that bends the mind."><y>#</y><d>2021-07-28</d><h>22:53</h><w>ribelo</w>meander is already like a programming language, and writing macros that use meander to write code for meander is an inception that bends the mind.</z><z id="t1627512830" t="noprompt Anyone thats applied an identity in algebra/trigonometry etc understands term rewriting."><y>#</y><d>2021-07-28</d><h>22:53</h><w>noprompt</w>Anyone thats applied an identity in algebra/trigonometry etc understands term rewriting.</z><z id="t1627512835" t="noprompt LOL"><y>#</y><d>2021-07-28</d><h>22:53</h><w>noprompt</w>LOL</z><z id="t1627512888" t="noprompt It is a language, true. But its in Clojure alongside hundreds of other languages."><y>#</y><d>2021-07-28</d><h>22:54</h><w>noprompt</w>It is a language, true. But its in Clojure alongside hundreds of other languages.</z><z id="t1627512930" t="ribelo Of the things I&apos;ve noticed that sell meander well is the size of the buildsize for CLJS"><y>#</y><d>2021-07-28</d><h>22:55</h><w>ribelo</w>Of the things I&apos;ve noticed that sell meander well is the size of the buildsize for CLJS</z><z id="t1627512935" t="noprompt I’d like to be in the same space as, say, like jq or comby ."><y>#</y><d>2021-07-28</d><h>22:55</h><w>noprompt</w>I’d like to be in the same space as, say, like <code>jq</code> or <code>comby</code>.</z><z id="t1627512948" t="noprompt Is it good?"><y>#</y><d>2021-07-28</d><h>22:55</h><w>noprompt</w>Is it good?</z><z id="t1627512952" t="ribelo yes"><y>#</y><d>2021-07-28</d><h>22:55</h><w>ribelo</w>yes</z><z id="t1627512958" t="noprompt Ah, thats great."><y>#</y><d>2021-07-28</d><h>22:55</h><w>noprompt</w>Ah, thats great.</z><z id="t1627512964" t="noprompt I know for a while we had some trouble with that."><y>#</y><d>2021-07-28</d><h>22:56</h><w>noprompt</w>I know for a while we had some trouble with that.</z><z id="t1627512982" t="ribelo meander adds almost nothing of its own, it is after all a macro"><y>#</y><d>2021-07-28</d><h>22:56</h><w>ribelo</w>meander adds almost nothing of its own, it is after all a macro</z><z id="t1627513027" t="noprompt And on top of that it tries to generate the best code it can considering its shoot-from-the-hip design. 😛"><y>#</y><d>2021-07-28</d><h>22:57</h><w>noprompt</w>And on top of that it tries to generate the best code it can considering its shoot-from-the-hip design. <b>😛</b></z><z id="t1627513124" t="ribelo for more difficult things, I&apos;m almost sure that the resulting code will be smaller than normal, as cljs has a lot of kinks and things to avoid"><y>#</y><d>2021-07-28</d><h>22:58</h><w>ribelo</w>for more difficult things, I&apos;m almost sure that the resulting code will be smaller than normal, as cljs has a lot of kinks and things to avoid</z><z id="t1627513146" t="ribelo which is not easy at all"><y>#</y><d>2021-07-28</d><h>22:59</h><w>ribelo</w>which is not easy at all</z><z id="t1627513168" t="noprompt Yeah. There are definitely some rough edges in cljs."><y>#</y><d>2021-07-28</d><h>22:59</h><w>noprompt</w>Yeah. There are definitely some rough edges in cljs.</z><z id="t1627513244" t="ribelo i have a stupid question, why meander use lazy collections and not for example transducers?"><y>#</y><d>2021-07-28</d><h>23:00</h><w>ribelo</w>i have a stupid question, why meander use lazy collections and not for example transducers?</z><z id="t1627513682" t="noprompt Not a stupid question."><y>#</y><d>2021-07-28</d><h>23:08</h><w>noprompt</w>Not a stupid question.</z><z id="t1627513682" t="ribelo I&apos;m talking about search"><y>#</y><d>2021-07-28</d><h>23:08</h><w>ribelo</w>I&apos;m talking about <code>search</code></z><z id="t1627513742" t="noprompt It mostly has to do with scope."><y>#</y><d>2021-07-28</d><h>23:09</h><w>noprompt</w>It mostly has to do with scope.</z><z id="t1627513839" t="noprompt Meander compiles things like (let [?x TARGET] ,,,) instead of (assoc state &apos;?x TARGET) and, it could be my lack of imagination, but the former is hard to shoe into a transducer approach."><y>#</y><d>2021-07-28</d><h>23:10</h><w>noprompt</w>Meander compiles things like <code>(let [?x TARGET] ,,,)</code> instead of <code>(assoc state &apos;?x TARGET)</code> and, it could be my lack of imagination, but the former is hard to shoe into a transducer approach.</z><z id="t1627513853" t="noprompt The latter, however, will totally work with transducers."><y>#</y><d>2021-07-28</d><h>23:10</h><w>noprompt</w>The latter, however, will totally work with transducers.</z><z id="t1627514035" t="ribelo As I am just checking search , changing to into [] is ~2x faster"><y>#</y><d>2021-07-28</d><h>23:13</h><w>ribelo</w>As I am just checking <code>search</code>, changing to <code>into []</code> is ~2x faster</z><z id="t1627514143" t="ribelo http://ix.io/3um4"><y>#</y><d>2021-07-28</d><h>23:15</h><w>ribelo</w><a href="http://ix.io/3um4" target="_blank">http://ix.io/3um4</a></z><z id="t1627514699" t="noprompt OK. Thats good information. Honestly, I think this project needs to be more accessible and problems like these should be easier to resolve with some help."><y>#</y><d>2021-07-28</d><h>23:24</h><w>noprompt</w>OK. Thats good information. Honestly, I think this project needs to be more accessible and problems like these should be easier to resolve with some help.</z><z id="t1627514711" t="noprompt Right now, epsilon is not so great for that."><y>#</y><d>2021-07-28</d><h>23:25</h><w>noprompt</w>Right now, epsilon is not so great for that.</z><z id="t1627514742" t="noprompt The approach I’ve tried with zeta works really well for interpretation but has proven to be too slow for macro compilation."><y>#</y><d>2021-07-28</d><h>23:25</h><w>noprompt</w>The approach I’ve tried with <code>zeta</code> works really well for interpretation but has proven to be too slow for macro compilation.</z><z id="t1627514869" t="ribelo We&apos;ll see soon if it&apos;s too difficult. If I can handle redoing it through metadata then that means anyone could"><y>#</y><d>2021-07-28</d><h>23:27</h><w>ribelo</w>We&apos;ll see soon if it&apos;s too difficult. If I can handle redoing it through metadata then that means anyone could</z><z id="t1627514887" t="ribelo and by the way, I&apos;ll find out how it works underneath"><y>#</y><d>2021-07-28</d><h>23:28</h><w>ribelo</w>and by the way, I&apos;ll find out how it works underneath</z><z id="t1627514893" t="noprompt I think its probably the best way to sneak something from the future in."><y>#</y><d>2021-07-28</d><h>23:28</h><w>noprompt</w>I think its probably the best way to sneak something from the future in.</z><z id="t1627515159" t="schmee haha, this turned into quite the conversation 😄"><y>#</y><d>2021-07-28</d><h>23:32</h><w>schmee</w>haha, this turned into quite the conversation <b>😄</b></z><z id="t1627515205" t="schmee I agree that Meander is secret sauce, I’ve used it for some things where I just end up staring at the solution in awe cause it’s so clear and concise"><y>#</y><d>2021-07-28</d><h>23:33</h><w>schmee</w>I agree that Meander is secret sauce, I’ve used it for some things where I just end up staring at the solution in awe cause it’s so clear and concise</z><z id="t1627515221" t="schmee it’s an incredible piece of work 😄"><y>#</y><d>2021-07-28</d><h>23:33</h><w>schmee</w>it’s an incredible piece of work <b>😄</b></z><z id="t1627515293" t="noprompt Awesome."><y>#</y><d>2021-07-28</d><h>23:34</h><w>noprompt</w>Awesome.</z><z id="t1627515769" t="ribelo [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] , is there any way to debug meander? To understand what is going on and refer to the expanded code somehow?"><y>#</y><d>2021-07-28</d><h>23:42</h><w>ribelo</w><a>@noprompt</a>, is there any way to debug meander? To understand what is going on and refer to the expanded code somehow?</z><z id="t1627515847" t="ribelo I think I know, but I don&apos;t know at what point I can print out a sequence with operators that will later be compiled into code"><y>#</y><d>2021-07-28</d><h>23:44</h><w>ribelo</w>I think I know, but I don&apos;t know at what point I can print out a sequence with operators that will later be compiled into code</z><z id="t1627516760" t="noprompt Ugh, its sadly an “art”."><y>#</y><d>2021-07-28</d><h>23:59</h><w>noprompt</w>Ugh, its sadly an “art”.</z><z id="t1627516768" t="noprompt I may have some stuff to help."><y>#</y><d>2021-07-28</d><h>23:59</h><w>noprompt</w>I may have some stuff to help.</z><z id="t1627516831" t="noprompt Basically what you want is to take a form, parse it, compile it through the match compilation machinery, and then compile that with ir. You’ll then want to save the result of each of those steps."><y>#</y><d>2021-07-29</d><h>00:00</h><w>noprompt</w>Basically what you want is to take a form, parse it, compile it through the match compilation machinery, and then compile that with ir. You’ll then want to save the result of each of those steps.</z><z id="t1627516855" t="ribelo I already know something there"><y>#</y><d>2021-07-29</d><h>00:00</h><w>ribelo</w>I already know something there</z><z id="t1627516879" t="ribelo ({:op :bind, :symbol SEQ__21245, :value {:op :eval, :form xs}, :then {:op :branch, :arms ({:op :branch, :arms ({:symbol SEQ__21245__X, :value {:op :eval, :form SEQ__21245}, :op :search, :body {:op :branch, :arms ({:op :check-boolean, :then {:op :branch, :arms ({:op :branch, :arms ({:symbol ?x, :op :lvr-bind, :then {:value ?x, :op :return}, :target {:op :eval, :form SEQ__21245__X}} {:op :fail})} {:op :fail})}, :test {:op :eval, :form (even? SEQ__21245__X)}} {:op :fail})}} {:op :fail})} {:op :fail})}} {:op :fail} {:op :fail}) the most important thing is to get something like this"><y>#</y><d>2021-07-29</d><h>00:01</h><w>ribelo</w><pre>({:op :bind, :symbol SEQ__21245, :value {:op :eval, :form xs}, :then {:op :branch, :arms ({:op :branch, :arms ({:symbol SEQ__21245__X, :value {:op :eval, :form SEQ__21245}, :op :search, :body {:op :branch, :arms ({:op :check-boolean, :then {:op :branch, :arms ({:op :branch, :arms ({:symbol ?x, :op :lvr-bind, :then {:value ?x, :op :return}, :target {:op :eval, :form SEQ__21245__X}} {:op :fail})} {:op :fail})}, :test {:op :eval, :form (even? SEQ__21245__X)}} {:op :fail})}} {:op :fail})} {:op :fail})}} {:op :fail} {:op :fail})</pre>
the most important thing is to get something like this</z><z id="t1627516925" t="noprompt (let [form &apos;[?x ?y] ast (m.match.syntax/parse form env) ir (m.match/compile &apos;[TARGET] [{:cols [ast], :rhs true}]) code ( ir :find env)] ,,,) Something like this."><y>#</y><d>2021-07-29</d><h>00:02</h><w>noprompt</w><pre>(let [form &apos;[?x ?y]
      ast (m.match.syntax/parse form env)
      ir (m.match/compile &apos;[TARGET] [{:cols [ast], :rhs true}])
      code ( ir :find env)]
  ,,,)</pre>
Something like this.</z><z id="t1627516948" t="noprompt Yeah"><y>#</y><d>2021-07-29</d><h>00:02</h><w>noprompt</w>Yeah</z><z id="t1627516950" t="ribelo all :op, are operators, and for each there is a multimethod (defnmethod complie :key..."><y>#</y><d>2021-07-29</d><h>00:02</h><w>ribelo</w>all :op, are operators, and for each there is a multimethod <code>(defnmethod complie :key...</code></z><z id="t1627516960" t="noprompt Yep."><y>#</y><d>2021-07-29</d><h>00:02</h><w>noprompt</w>Yep.</z><z id="t1627516979" t="ribelo a little around, but somehow I got to it ; P"><y>#</y><d>2021-07-29</d><h>00:02</h><w>ribelo</w>a little around, but somehow I got to it ; P</z><z id="t1627517001" t="ribelo any amount of information can be obtained with a finite number of prints"><y>#</y><d>2021-07-29</d><h>00:03</h><w>ribelo</w>any amount of information can be obtained with a finite number of prints</z><z id="t1627517007" t="noprompt Indeed. 😛"><y>#</y><d>2021-07-29</d><h>00:03</h><w>noprompt</w>Indeed. <b>😛</b></z><z id="t1627517122" t="noprompt Ideally, the substitution namespace would use the IR too."><y>#</y><d>2021-07-29</d><h>00:05</h><w>noprompt</w>Ideally, the substitution namespace would use the IR too.</z><z id="t1627517164" t="noprompt But, again, I didn’t really have a solid plan for that because almost all of my attention went into match related code."><y>#</y><d>2021-07-29</d><h>00:06</h><w>noprompt</w>But, again, I didn’t really have a solid plan for that because almost all of my attention went into match related code.</z><z id="t1627517199" t="ribelo I&apos;ll hack tomorrow, Now I can barely look at my eyes"><y>#</y><d>2021-07-29</d><h>00:06</h><w>ribelo</w>I&apos;ll hack tomorrow, Now I can barely look at my eyes</z><z id="t1627517219" t="noprompt Get some sleep! 🙂"><y>#</y><d>2021-07-29</d><h>00:06</h><w>noprompt</w>Get some sleep! <b>🙂</b></z><z id="t1627517355" t="ribelo https://www.youtube.com/watch?v=m98MBACe1xk"><y>#</y><d>2021-07-29</d><h>00:09</h><w>ribelo</w><a href="https://www.youtube.com/watch?v=m98MBACe1xk" target="_blank">https://www.youtube.com/watch?v=m98MBACe1xk</a></z><z id="t1627669880" t="noprompt I really enjoyed this one. 🙂"><y>#</y><d>2021-07-30</d><h>18:31</h><r>noprompt</r>I really enjoyed this one. <b>🙂</b></z><z id="t1627517376" t="ribelo I remember that you like Mark Grechuta so maybe you will like this one too ; )"><y>#</y><d>2021-07-29</d><h>00:09</h><w>ribelo</w>I remember that you like Mark Grechuta so maybe you will like this one too ; )</z><z id="t1627520558" t="markaddleman picking up on an earlier part of the conversation: meander has become my #1 choice when i need to manipulate a data structure more than just assoc&apos;ing in new data to a map."><y>#</y><d>2021-07-29</d><h>01:02</h><w>markaddleman</w>picking up on an earlier part of the conversation:  meander has become my #1 choice when i need to manipulate a data structure more than just assoc&apos;ing in new data to a map.</z><z id="t1627520623" t="markaddleman comparatively, it&apos;s much easier to think about the shape of the data (both before and after) using meander"><y>#</y><d>2021-07-29</d><h>01:03</h><w>markaddleman</w>comparatively, it&apos;s much easier to think about the shape of the data (both before and after) using meander</z><z id="t1627543951" t="ribelo [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] Unfortunately 0.0.626 breaks one more thing https://github.com/noprompt/meander/issues/195"><y>#</y><d>2021-07-29</d><h>07:32</h><w>ribelo</w><a>@noprompt</a> Unfortunately 0.0.626 breaks one more thing
<a href="https://github.com/noprompt/meander/issues/195" target="_blank">https://github.com/noprompt/meander/issues/195</a></z><z id="t1627581192" t="noprompt Hmm… That is strange. There are tests for that. Here’s one: https://github.com/noprompt/meander/blob/epsilon/test/meander/epsilon_test.cljc#L2543"><y>#</y><d>2021-07-29</d><h>17:53</h><w>noprompt</w>Hmm… That is strange. There are tests for that. Here’s one: <a href="https://github.com/noprompt/meander/blob/epsilon/test/meander/epsilon_test.cljc#L2543" target="_blank">https://github.com/noprompt/meander/blob/epsilon/test/meander/epsilon_test.cljc#L2543</a></z><z id="t1627581205" t="noprompt Very odd."><y>#</y><d>2021-07-29</d><h>17:53</h><w>noprompt</w>Very odd.</z><z id="t1627581266" t="noprompt I think we should probably patch the README to manually recommend a specific version. I know this is experimental software but 0.0.626 is not representing the library well."><y>#</y><d>2021-07-29</d><h>17:54</h><w>noprompt</w>I think we should probably patch the README to manually recommend a specific version. I know this is experimental software but <code>0.0.626</code> is not representing the library well.</z><z id="t1627581448" t="noprompt OK. Check."><y>#</y><d>2021-07-29</d><h>17:57</h><w>noprompt</w>OK. Check.</z><z id="t1627596728" t="Gary Berger Hello all, is there any way to represent a logic variable in a pattern ?foo {:foo ?foo} as a string? or is there a way to convert that from a string easily? I want to store the patterns outside the system i.e in a JSON format which will not be marshaled into a symbol automatically."><y>#</y><d>2021-07-29</d><h>22:12</h><w>Gary Berger</w>Hello all, is there any way to represent a logic variable in a pattern <code>?foo</code>
<pre>{:foo ?foo}</pre>
as a string? or is there a way to convert that from a string easily? I want to store the patterns outside the system i.e in a JSON format which will  not be marshaled into a symbol automatically.</z><z id="t1627596906" t="Jimmy Miller So we do have interpreter that lets you do dynamic things like that. But I will say that I&apos;m not sure I&apos;d recommend meander as a target like that. Meander is definitely more focused on being a way you write code. It isn&apos;t focused on having more dynamic rules. That said, meander is great for writing a little interpreter to do transformations defined in data."><y>#</y><d>2021-07-29</d><h>22:15</h><w>Jimmy Miller</w>So we do have interpreter that lets you do dynamic things like that. But I will say that I&apos;m not sure I&apos;d recommend meander as a target like that. Meander is definitely more focused on being a way you write code. It isn&apos;t focused on having more dynamic rules.

That said, meander is great for writing a little interpreter to do transformations defined in data.</z><z id="t1627596957" t="Gary Berger yea thats what I am looking for to translate data in a workflow"><y>#</y><d>2021-07-29</d><h>22:15</h><w>Gary Berger</w>yea thats what I am looking for to translate data in a workflow</z><z id="t1627597027" t="Jimmy Miller Maybe I misunderstood. It sounded like you wanted to store meander patterns as data. Like serialize meander code and then deserialize it and run it. Is that incorrect?"><y>#</y><d>2021-07-29</d><h>22:17</h><w>Jimmy Miller</w>Maybe I misunderstood. It sounded like you wanted to store meander patterns as data. Like serialize meander code and then deserialize it and run it. 

Is that incorrect?</z><z id="t1627597120" t="Jimmy Miller If so, I&apos;d advise against that. I&apos;m betting there are better ways to solve your problem using meander. Happy to help with the more concrete problem if that&apos;s the case :)"><y>#</y><d>2021-07-29</d><h>22:18</h><w>Jimmy Miller</w>If so, I&apos;d advise against that. I&apos;m betting there are better ways to solve your problem using meander. Happy to help with the more concrete problem if that&apos;s the case :)</z><z id="t1627597368" t="Gary Berger yea well thats what I am looking for, a simple declarative approach to change the shape of input data such that I pass the input + pattern from outside the system to a function that does the translation."><y>#</y><d>2021-07-29</d><h>22:22</h><w>Gary Berger</w>yea well thats what I am looking for, a simple declarative approach to change the shape of input data such that I pass the input + pattern  from outside the system to a function that does the translation.</z><z id="t1627597554" t="Jimmy Miller So with meander you have two options, use the meander interpreter (still a bit experimental). Or use meander to write an interpreter for your patterns that is specific to your app. That&apos;s my recommendation. I wrote a blog post that is kind of like that, writing a meander interpreter and then compiler all using meander. https://jimmyhmiller.github.io/building-meander-in-meander"><y>#</y><d>2021-07-29</d><h>22:25</h><w>Jimmy Miller</w>So with meander you have two options, use the meander interpreter (still a bit experimental). Or use meander to write an interpreter for your patterns that is specific to your app. That&apos;s my recommendation. 

I wrote a blog post that is kind of like that, writing a meander interpreter and then compiler all using meander. <a href="https://jimmyhmiller.github.io/building-meander-in-meander" target="_blank">https://jimmyhmiller.github.io/building-meander-in-meander</a></z><z id="t1627667351" t="noprompt [:attrs {:href &quot;/_/_/users/U01S20S3552&quot;}] Are you looking for something like this? (let [json {&quot;?bar&quot; [1 &quot;?foo&quot; 2] &quot;userName&quot; &quot;?user-name&quot;}] (m/rewrite json ;; Arrays [(m/cata !x) ...] [!x ...] ;; Objects {(m/cata ?k) (m/cata ?v) &amp; (m/cata ?rest)} {?k ?v &amp; ?rest} ;; Logic variables (m/re #&quot;\?[^\s]+&quot; ?variable) (m/symbol ?variable) ;; Else ?x ?x)) ;; =&gt; {&quot;userName&quot; ?user-name ?bar [1 ?foo 2]} "><y>#</y><d>2021-07-30</d><h>17:49</h><w>noprompt</w><a>@garyberger</a> Are you looking for something like this?
<pre>(let [json {&quot;?bar&quot; [1 &quot;?foo&quot; 2]
            &quot;userName&quot; &quot;?user-name&quot;}]
  (m/rewrite json
    ;; Arrays
    [(m/cata !x) ...]
    [!x ...]

    ;; Objects
    {(m/cata ?k) (m/cata ?v) &amp; (m/cata ?rest)}
    {?k ?v &amp; ?rest}

    ;; Logic variables
    (m/re #&quot;\?[^\s]+&quot; ?variable)
    (m/symbol ?variable)

    ;; Else
    ?x ?x))
;; =&gt; 
{&quot;userName&quot; ?user-name
 ?bar [1 ?foo 2]}</pre>
</z><z id="t1627667503" t="Gary Berger Yes exactly, spectacular.. I was just experimenting with m/rewrite to do that and needed to figure out the recursion.. Thanks so much!! this is gold"><y>#</y><d>2021-07-30</d><h>17:51</h><r>Gary Berger</r>Yes exactly, spectacular.. I was just experimenting with m/rewrite to do that and needed to figure out the recursion.. Thanks so much!! this is gold</z><z id="t1627669549" t="noprompt Cool. You can find more information (by example) about cata in the cookbook: https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md"><y>#</y><d>2021-07-30</d><h>18:25</h><r>noprompt</r>Cool. You can find more information (by example) about <code>cata</code> in the cookbook: <a href="https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md</a></z><z id="t1627669602" t="noprompt Also, please make sure to use version 0.0.602 of meander/epsilon as the latest release is broken in a few ways."><y>#</y><d>2021-07-30</d><h>18:26</h><r>noprompt</r>Also, please make sure to use version <code>0.0.602</code> of <code>meander/epsilon</code> as the latest release is broken in a few ways.</z><z id="t1627930843" t="Gary Berger Sorry to be a pain on this but can you use (m/rewrite in ;; ;; Arrays [(m/cata !x) ...] [!x ...] ;; Objects {(m/cata ?k) (m/cata ?v) &amp; (m/cata ?rest)} {?k ?v &amp; ?rest} ;; Logic variables (m/re #&quot;\?[^\s]+&quot; ?variable) (m/symbol ?variable) ;; Else ?x ?x) inside of a m/match I am getting a Syntax error macroexpanding meander.match.epsilon/match at ... ; When matching, map patterns may not contain variables in their keys that would make it so there is more than one match possible. I tried using it as a function but the evaluation fails"><y>#</y><d>2021-08-02</d><h>19:00</h><r>Gary Berger</r>Sorry to be a pain on this but can you use
<pre>(m/rewrite in
    ;; ;; Arrays
               [(m/cata !x) ...]
               [!x ...]
    ;; Objects
               {(m/cata ?k) (m/cata ?v) &amp; (m/cata ?rest)}
               {?k ?v &amp; ?rest}
    ;; Logic variables
               (m/re #&quot;\?[^\s]+&quot; ?variable)
               (m/symbol ?variable)
    ;; Else
               ?x ?x) </pre>
inside of a <code>m/match</code> I am getting a
<pre>Syntax error macroexpanding meander.match.epsilon/match at ...
; When matching, map patterns may not contain variables in their keys that would make it so there is more than one match possible.</pre>
I tried using it as a function but the evaluation fails</z><z id="t1628019596" t="noprompt Yes. m/match does not allow ambiguous patterns. A map pattern with a variable key ie. {?x _} is ambiguous because maps have no canonical representation, and because a map patterns are actually submap patterns. The pattern above means “a map of at least size one with the key ?x ”. For any map of size greater than one, which key do we bind to ?x ? Meander can’t say. So for m/match this is a problem and hence the error. However, m/find is available for this purpose, but it doesn’t default to throwing an error when all the patterns have been exhausted."><y>#</y><d>2021-08-03</d><h>19:39</h><r>noprompt</r>Yes. <code>m/match</code> does not allow ambiguous patterns. A map pattern with a variable key ie.
<pre>{?x _}</pre>
is ambiguous because maps have no canonical representation, and because a map patterns are actually submap patterns. The pattern above means “a map of at least size one with the key <code>?x</code>”. For any map of size greater than one, which key do we bind to <code>?x</code>? Meander can’t say. So for <code>m/match</code> this is a problem and hence the error. However, <code>m/find</code> is available for this purpose, but it doesn’t default to throwing an error when all the patterns have been exhausted.</z><z id="t1628118028" t="noprompt [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] I remember now one of the reasons I paused working on a transducer version: disjunctions."><y>#</y><d>2021-08-04</d><h>23:00</h><w>noprompt</w><a>@huxley</a> I remember now one of the reasons I paused working on a transducer version: disjunctions.</z><z id="t1628118242" t="noprompt I was taking a moment to play around with it. I ended up with something kinda gross like (defn x-some [xg1 xg2] (fn [rf] (fn ([] (rf)) ([acc] (rf acc)) ([acc x] (rf (algorithms/mix ((xg1 rf) acc x) ((xg2 rf) acc x))))))) where xg1 and xg2 are xform goals."><y>#</y><d>2021-08-04</d><h>23:04</h><w>noprompt</w>I was taking a moment to play around with it. I ended up with something kinda gross like
<pre>(defn x-some [xg1 xg2]
  (fn [rf]
    (fn
      ([] (rf))
      ([acc] (rf acc))
      ([acc x] (rf (algorithms/mix ((xg1 rf) acc x) ((xg2 rf) acc x)))))))</pre>
where <code>xg1</code> and <code>xg2</code> are xform goals.</z><z id="t1628118404" t="noprompt Maybe this is fine since conjunctions are the most common and those play nicely with transducers."><y>#</y><d>2021-08-04</d><h>23:06</h><w>noprompt</w>Maybe this is fine since conjunctions are the most common and those play nicely with transducers.</z><z id="t1628118566" t="ribelo but basically all we need to do is add the ability to use into [] at m/search and we get ~10-15% for free"><y>#</y><d>2021-08-04</d><h>23:09</h><w>ribelo</w>but basically all we need to do is add the ability to use <code>into []</code> at <code>m/search</code> and we get ~10-15% for free</z><z id="t1628118647" t="ribelo :search - `(mapcat - (fn [~(:symbol ir)] - ~(compile* (:body ir) fail kind)) - ~(compile* (:value ir) fail kind)))) + (if (use-transduces?) + `(into [] + (mapcat + (fn [~(:symbol ir)] + ~(compile* (:body ir) fail kind))) + ~(compile* (:value ir) fail kind)) + `(mapcat + (fn [~(:symbol ir)] + ~(compile* (:body ir) fail kind)) + ~(compile* (:value ir) fail kind)))))"><y>#</y><d>2021-08-04</d><h>23:10</h><w>ribelo</w><pre>:search
-    `(mapcat
-      (fn [~(:symbol ir)]
-        ~(compile* (:body ir) fail kind))
-      ~(compile* (:value ir) fail kind))))
+    (if (use-transduces?)
+      `(into []
+             (mapcat
+              (fn [~(:symbol ir)]
+                ~(compile* (:body ir) fail kind)))
+             ~(compile* (:value ir) fail kind))
+      `(mapcat
+        (fn [~(:symbol ir)]
+          ~(compile* (:body ir) fail kind))
+        ~(compile* (:value ir) fail kind)))))</pre></z><z id="t1628118729" t="ribelo As for the rest, I haven&apos;t gotten that deep yet."><y>#</y><d>2021-08-04</d><h>23:12</h><w>ribelo</w>As for the rest, I haven&apos;t gotten that deep yet.</z><z id="t1628118762" t="noprompt OK. Well, definitely continue to explore. 🙂"><y>#</y><d>2021-08-04</d><h>23:12</h><w>noprompt</w>OK. Well, definitely continue to explore. <b>🙂</b></z><z id="t1628118779" t="noprompt How does sequence perform there?"><y>#</y><d>2021-08-04</d><h>23:12</h><w>noprompt</w>How does <code>sequence</code> perform there?</z><z id="t1628118826" t="ribelo if I remember correctly, identical to into []"><y>#</y><d>2021-08-04</d><h>23:13</h><w>ribelo</w>if I remember correctly, identical to <code>into []</code></z><z id="t1628118938" t="ribelo The same is true for ...permutations-with-unselected , but there the speed gain is marginal."><y>#</y><d>2021-08-04</d><h>23:15</h><w>ribelo</w>The same is true for <code>...permutations-with-unselected</code>, but there the speed gain is marginal.</z><z id="t1628119345" t="noprompt (into [] ,,,) will make it eager, (sequence ,,,) will keep it lazy."><y>#</y><d>2021-08-04</d><h>23:22</h><w>noprompt</w><code>(into [] ,,,)</code> will make it eager, <code>(sequence ,,,)</code> will keep it lazy.</z><z id="t1628119697" t="noprompt I don’t know of any situations where the size of the result set of search is infinite but one thing I can tell you is that the transducer version of mapcat can end up blocking in certain situations where there are infinite or extremely large intermediate results."><y>#</y><d>2021-08-04</d><h>23:28</h><w>noprompt</w>I don’t know of any situations where the size of the result set of search is infinite but one thing I can tell you is that the transducer version of <code>mapcat</code> can end up blocking in certain situations where there are infinite or extremely large intermediate results.</z><z id="t1628120076" t="ribelo It can stay as it is, I&apos;m just posting what I&apos;ve observed 😉"><y>#</y><d>2021-08-04</d><h>23:34</h><w>ribelo</w>It can stay as it is, I&apos;m just posting what I&apos;ve observed <b>😉</b></z><z id="t1628707586" t="noprompt I fixed a couple of odd ball issues just a bit a go. I added a test for #195 on my local just now (t/deftest gh-195-test (r/rewrite {:a 1 :b 2 :c 3 :d 4} (r/map-of !ks !vs) {&amp; [[!ks !vs] ...]})) and it passes."><y>#</y><d>2021-08-11</d><h>18:46</h><w>noprompt</w>I fixed a couple of odd ball issues just a bit a go. I added a test for #195 on my local just now
<pre>(t/deftest gh-195-test
  (r/rewrite {:a 1 :b 2 :c 3 :d 4}
    (r/map-of !ks !vs)
    {&amp; [[!ks !vs] ...]}))</pre>
and it passes.</z><z id="t1628707646" t="noprompt [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] Are you able to check out epsilon as it stands right now and check to see if its still a problem?"><y>#</y><d>2021-08-11</d><h>18:47</h><w>noprompt</w><a>@huxley</a> Are you able to check out epsilon as it stands right now and check to see if its still a problem?</z><z id="t1628793709" t="ribelo It looks like everything working properly."><y>#</y><d>2021-08-12</d><h>18:41</h><r>ribelo</r>It looks like everything working properly.</z><z id="t1628793877" t="ribelo 👍"><y>#</y><d>2021-08-12</d><h>18:44</h><r>ribelo</r><b>👍</b></z><z id="t1628708329" t="noprompt [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] You had posted a failing example about a month ago but I’m having some trouble recalling it and also difficulty retrieving it from the archives."><y>#</y><d>2021-08-11</d><h>18:58</h><w>noprompt</w><a>@markaddleman</a> You had posted a failing example about a month ago but I’m having some trouble recalling it and also difficulty retrieving it from the archives.</z><z id="t1628708335" t="noprompt Any chance you still have that?"><y>#</y><d>2021-08-11</d><h>18:58</h><w>noprompt</w>Any chance you still have that?</z><z id="t1628708367" t="markaddleman I do but it will take me a few hours to get in a position to recover it."><y>#</y><d>2021-08-11</d><h>18:59</h><r>markaddleman</r>I do but it will take me a few hours to get in a position to recover it.</z><z id="t1628708374" t="markaddleman I can open an issue if that would be helpful"><y>#</y><d>2021-08-11</d><h>18:59</h><r>markaddleman</r>I can open an issue if that would be helpful</z><z id="t1628709886" t="noprompt That would be perfect."><y>#</y><d>2021-08-11</d><h>19:24</h><r>noprompt</r>That would be perfect.</z><z id="t1628714387" t="markaddleman Here you go"><y>#</y><d>2021-08-11</d><h>20:39</h><r>markaddleman</r>Here you go</z><z id="t1628714388" t="markaddleman https://github.com/noprompt/meander/issues/198"><y>#</y><d>2021-08-11</d><h>20:39</h><r>markaddleman</r><a href="https://github.com/noprompt/meander/issues/198" target="_blank">https://github.com/noprompt/meander/issues/198</a></z><z id="t1628714408" t="markaddleman I think the example is pretty self explanatory but if anything is not clear, please let me know"><y>#</y><d>2021-08-11</d><h>20:40</h><r>markaddleman</r>I think the example is pretty self explanatory but if anything is not clear, please let me know</z><z id="t1628721080" t="noprompt Example is perfect. I just turned it into a test."><y>#</y><d>2021-08-11</d><h>22:31</h><r>noprompt</r>Example is perfect. I just turned it into a test.</z><z id="t1628721100" t="noprompt I left a remark about it but it seems operational on epsilon."><y>#</y><d>2021-08-11</d><h>22:31</h><r>noprompt</r>I left a remark about it but it seems operational on epsilon.</z><z id="t1628733840" t="markaddleman Awesome. This Friday, I should have some cycles to test my app against the latest epsilon commit"><y>#</y><d>2021-08-12</d><h>02:04</h><r>markaddleman</r>Awesome.  This Friday, I should have some cycles to test my app against the latest epsilon commit</z><z id="t1628791721" t="eoliphant hi i’m trying to do a transform where i need to select a single value out of a list.. something like {:a &quot;a&quot; :b [{:name &quot;pickme&quot; :value &quot;foo&quot;} {:name &quot;somethingelse&quot; :value &quot;bar&quot; ..]} ;becomes {:my/a &quot;a&quot; :my/b &quot;foo&quot;} ; have tried various things with ... scan, etc but i&apos;m obivously not doing the right thing {... :b [{:name &quot;pickme&quot; :value !value} ...]} etc"><y>#</y><d>2021-08-12</d><h>18:08</h><w>eoliphant</w>hi i’m trying to do a transform where i need to select a single value out of a list.. something like
<pre>{:a &quot;a&quot; 
 :b  [{:name &quot;pickme&quot; :value &quot;foo&quot;} {:name &quot;somethingelse&quot; :value &quot;bar&quot; ..]}
;becomes
{:my/a &quot;a&quot;
 :my/b &quot;foo&quot;}

; have tried various things with ... scan, etc but i&apos;m obivously not doing the right thing
{...
 :b [{:name &quot;pickme&quot; :value !value} ...]}

etc</pre></z><z id="t1628792878" t="ribelo (m/rewrite {:a &quot;a&quot; :b [{:name &quot;pickname&quot; :value &quot;foo&quot;} {:name &quot;somthingelse&quot; :value &quot;bar&quot;}]} {:a ?a :b [{:value !value} ...]} [{:my/a ?a :my/b !value} ...]) ;; =&gt; [#:my{:a &quot;a&quot;, :b &quot;foo&quot;} #:my{:a &quot;a&quot;, :b &quot;bar&quot;}]"><y>#</y><d>2021-08-12</d><h>18:27</h><r>ribelo</r><pre>(m/rewrite {:a &quot;a&quot;
            :b [{:name &quot;pickname&quot; :value &quot;foo&quot;} {:name &quot;somthingelse&quot; :value &quot;bar&quot;}]}
  {:a ?a
   :b [{:value !value} ...]}
  [{:my/a ?a
    :my/b !value} ...])
;; =&gt; [#:my{:a &quot;a&quot;, :b &quot;foo&quot;} #:my{:a &quot;a&quot;, :b &quot;bar&quot;}]</pre></z><z id="t1628793004" t="ribelo Wait, I misread"><y>#</y><d>2021-08-12</d><h>18:30</h><r>ribelo</r>Wait, I misread</z><z id="t1628793043" t="ribelo You want to get whatever has pickme"><y>#</y><d>2021-08-12</d><h>18:30</h><r>ribelo</r>You want to get whatever has <code>pickme</code></z><z id="t1628793048" t="eoliphant right."><y>#</y><d>2021-08-12</d><h>18:30</h><r>eoliphant</r>right.</z><z id="t1628793055" t="eoliphant i got something sorta working with cata"><y>#</y><d>2021-08-12</d><h>18:30</h><r>eoliphant</r>i got something sorta working with cata</z><z id="t1628793096" t="ribelo (m/rewrite {:a &quot;a&quot; :b [{:name &quot;pickme&quot; :value &quot;foo&quot;} {:name &quot;somthingelse&quot; :value &quot;bar&quot;}]} {:a ?a :b (m/scan {:name &quot;pickme&quot; :value !value})} {:my/a ?a :my/b !value}) ;; =&gt; #:my{:a &quot;a&quot;, :b &quot;foo&quot;}"><y>#</y><d>2021-08-12</d><h>18:31</h><r>ribelo</r><pre>(m/rewrite {:a &quot;a&quot;
            :b [{:name &quot;pickme&quot; :value &quot;foo&quot;} {:name &quot;somthingelse&quot; :value &quot;bar&quot;}]}
  {:a ?a
   :b (m/scan {:name &quot;pickme&quot; :value !value})}
  {:my/a ?a
   :my/b !value})

;; =&gt; #:my{:a &quot;a&quot;, :b &quot;foo&quot;}</pre></z><z id="t1628793124" t="eoliphant ok cool i thought i tried that but at this point who knows lol"><y>#</y><d>2021-08-12</d><h>18:32</h><r>eoliphant</r>ok cool i thought i tried that but at this point who knows lol</z><z id="t1628793127" t="eoliphant one sec"><y>#</y><d>2021-08-12</d><h>18:32</h><r>eoliphant</r>one sec</z><z id="t1628793236" t="eoliphant ah i was using match instead of rewrite"><y>#</y><d>2021-08-12</d><h>18:33</h><r>eoliphant</r>ah i was using match instead of rewrite</z><z id="t1628793237" t="eoliphant ugh"><y>#</y><d>2021-08-12</d><h>18:33</h><r>eoliphant</r>ugh</z><z id="t1628793239" t="eoliphant thx!"><y>#</y><d>2021-08-12</d><h>18:33</h><r>eoliphant</r>thx!</z><z id="t1628793358" t="ribelo Scan does not work with match , but with find it does."><y>#</y><d>2021-08-12</d><h>18:35</h><r>ribelo</r>Scan does not work with <code>match</code>, but with <code>find</code> it does.</z><z id="t1628793365" t="ribelo (m/find {:a &quot;a&quot; :b [{:name &quot;pickme&quot; :value &quot;foo&quot;} {:name &quot;somthingelse&quot; :value &quot;bar&quot;}]} {:a ?a :b (m/scan {:name &quot;pickme&quot; :value !value})} {:my/a ?a :my/b !value}) "><y>#</y><d>2021-08-12</d><h>18:36</h><r>ribelo</r><pre>(m/find {:a &quot;a&quot;
            :b [{:name &quot;pickme&quot; :value &quot;foo&quot;} {:name &quot;somthingelse&quot; :value &quot;bar&quot;}]}
  {:a ?a
   :b (m/scan {:name &quot;pickme&quot; :value !value})}
  {:my/a ?a
   :my/b !value})</pre>
</z><z id="t1628793392" t="eoliphant gotcha. still working through what works with what lol"><y>#</y><d>2021-08-12</d><h>18:36</h><r>eoliphant</r>gotcha.  still working through what works with what lol</z><z id="t1628793429" t="ribelo and if you don&apos;t need to collect multiple values, it&apos;s a better idea to use ?value instead of !value"><y>#</y><d>2021-08-12</d><h>18:37</h><r>ribelo</r>and if you don&apos;t need to collect multiple values, it&apos;s a better idea to use <code>?value</code> instead of <code>!value</code></z><z id="t1628793605" t="ribelo The learning curve of meander is very steep, I recommend to start with find , only after that play with rewrite , and finally recursion with cata and with"><y>#</y><d>2021-08-12</d><h>18:40</h><r>ribelo</r>The learning curve of meander is very steep, I recommend to start with <code>find</code>, only after that play with <code>rewrite</code>, and finally recursion with <code>cata</code> and <code>with</code></z><z id="t1628793823" t="eoliphant yeah that’s what threw me a little"><y>#</y><d>2021-08-12</d><h>18:43</h><r>eoliphant</r>yeah that’s what threw me a little</z><z id="t1628793857" t="eoliphant because i know i wanted a single value ?… but in that context most of the examples are the memory vars !.."><y>#</y><d>2021-08-12</d><h>18:44</h><r>eoliphant</r>because i know i wanted a single value ?… but in that context most of the examples are the memory vars !..</z><z id="t1628793866" t="eoliphant gotca"><y>#</y><d>2021-08-12</d><h>18:44</h><r>eoliphant</r>gotca</z><z id="t1628793876" t="eoliphant will use that heuristic going forward"><y>#</y><d>2021-08-12</d><h>18:44</h><r>eoliphant</r>will use that heuristic going forward</z><z id="t1628793942" t="ribelo memory vars will always work too, but they are obviously slower"><y>#</y><d>2021-08-12</d><h>18:45</h><r>ribelo</r>memory vars will always work too, but they are obviously slower</z><z id="t1628794003" t="eoliphant i’ll maybe add that to the docs lol. because it seems simple for a lot of common cases but, yeah there are quite a few dangerous left turns lol"><y>#</y><d>2021-08-12</d><h>18:46</h><r>eoliphant</r>i’ll maybe add that to the docs lol.  because it seems  simple for a lot of common cases but, yeah there are quite a few dangerous left turns lol</z><z id="t1628807891" t="noprompt [:attrs {:href &quot;/_/_/users/U380J7PAQ&quot;}] I merge 100% of patches to our docs. 🙂"><y>#</y><d>2021-08-12</d><h>22:38</h><r>noprompt</r><a>@U380J7PAQ</a> I merge 100% of patches to our docs. <b>🙂</b></z><z id="t1628798178" t="noprompt Has anyone had a chance to double check if whats on epsilon right now works for them e.g. it passes tests, etc.?"><y>#</y><d>2021-08-12</d><h>19:56</h><w>noprompt</w>Has anyone had a chance to double check if whats on epsilon right now works for them e.g. it passes tests, etc.?</z><z id="t1628798444" t="ribelo 1 sec"><y>#</y><d>2021-08-12</d><h>20:00</h><w>ribelo</w>1 sec</z><z id="t1628798575" t="ribelo"><y>#</y><d>2021-08-12</d><h>20:02</h><w>ribelo</w></z><z id="t1628798666" t="ribelo"><y>#</y><d>2021-08-12</d><h>20:04</h><w>ribelo</w></z><z id="t1628798718" t="ribelo doxa uses meander very heavily and it also seems to work."><y>#</y><d>2021-08-12</d><h>20:05</h><w>ribelo</w><code>doxa</code> uses meander very heavily and it also seems to work.</z><z id="t1628799094" t="noprompt Awesome. What font is that? I looks almost like Monoid."><y>#</y><d>2021-08-12</d><h>20:11</h><w>noprompt</w>Awesome. What font is that? I looks almost like Monoid.</z><z id="t1628801149" t="ribelo Iosevka"><y>#</y><d>2021-08-12</d><h>20:45</h><w>ribelo</w><code>Iosevka</code></z><z id="t1628801196" t="ribelo [buildPlans.iosevka-custom] family = &quot;Iosevka Custom&quot; spacing = &quot;normal&quot; serifs = &quot;sans&quot; no-cv-ss = true [buildPlans.iosevka-custom.variants] inherits = &quot;ss04&quot; [buildPlans.iosevka-custom.ligations] inherits = &quot;dlig&quot;"><y>#</y><d>2021-08-12</d><h>20:46</h><w>ribelo</w><pre>[buildPlans.iosevka-custom]
         family = &quot;Iosevka Custom&quot;
         spacing = &quot;normal&quot;
         serifs = &quot;sans&quot;
         no-cv-ss = true

         [buildPlans.iosevka-custom.variants]
         inherits = &quot;ss04&quot;

         [buildPlans.iosevka-custom.ligations]
         inherits = &quot;dlig&quot;</pre></z><z id="t1628801567" t="noprompt Ah, nice. I knew it looked familiar. 🙂"><y>#</y><d>2021-08-12</d><h>20:52</h><w>noprompt</w>Ah, nice. I knew it looked familiar. <b>🙂</b></z><z id="t1628801991" t="ribelo A good font is essential, I admire people from the previous era who had to look at jagged angular fonts on crt monitors."><y>#</y><d>2021-08-12</d><h>20:59</h><w>ribelo</w>A good font is essential, I admire people from the previous era who had to look at jagged angular fonts on crt monitors.</z><z id="t1628808018" t="noprompt The past couple years have been generous for monospace typography. There are so many fantastic options available."><y>#</y><d>2021-08-12</d><h>22:40</h><w>noprompt</w>The past couple years have been generous for monospace typography. There are so many fantastic options available.</z><z id="t1628808097" t="noprompt Also, I will probably cut a release tomorrow."><y>#</y><d>2021-08-12</d><h>22:41</h><w>noprompt</w>Also, I will probably cut a release tomorrow.</z><z id="t1628808110" t="noprompt [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] After that I think we can get back on track with the fast flag."><y>#</y><d>2021-08-12</d><h>22:41</h><w>noprompt</w><a>@huxley</a> After that I think we can get back on track with the fast flag.</z><z id="t1628808293" t="ribelo great:+1:"><y>#</y><d>2021-08-12</d><h>22:44</h><w>ribelo</w>great:+1:</z><z id="t1628813260" t="markaddleman The following rules compile under 0.0.602 but not under the latest commit: (m/rewrite query {:as ?query :aggregates [(m/cata !agg) ...]} {&amp; ?query :aggregates [!agg ...]} {:op &quot;AVG&quot;, :args [{:computed [&quot;deal_count_by_user&quot;]}], :alias ?alias :as ?agg} {?agg &amp; :op &quot;AVG&quot;, :args [{:computed [&quot;user_count_by_deal&quot;]}], :alias ?alias} ?? ??) "><y>#</y><d>2021-08-13</d><h>00:07</h><w>markaddleman</w>The following rules compile under 0.0.602 but not under the latest commit:
<pre>(m/rewrite query
             {:as ?query :aggregates [(m/cata !agg) ...]}
             {&amp; ?query :aggregates [!agg ...]}

             {:op &quot;AVG&quot;, :args [{:computed [&quot;deal_count_by_user&quot;]}], :alias ?alias :as ?agg}
             {?agg &amp; :op &quot;AVG&quot;, :args [{:computed [&quot;user_count_by_deal&quot;]}], :alias ?alias}

             ?? ??)</pre>
</z><z id="t1628813278" t="markaddleman I&apos;ll open an issue"><y>#</y><d>2021-08-13</d><h>00:07</h><w>markaddleman</w>I&apos;ll open an issue</z><z id="t1628813648" t="markaddleman https://github.com/noprompt/meander/issues/199"><y>#</y><d>2021-08-13</d><h>00:14</h><w>markaddleman</w><a href="https://github.com/noprompt/meander/issues/199" target="_blank">https://github.com/noprompt/meander/issues/199</a></z><z id="t1628873352" t="noprompt Fixing"><y>#</y><d>2021-08-13</d><h>16:49</h><w>noprompt</w>Fixing</z><z id="t1628874807" t="noprompt Fixed"><y>#</y><d>2021-08-13</d><h>17:13</h><w>noprompt</w>Fixed</z><z id="t1628874837" t="noprompt [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] I left an explanation for why that did not compile properly."><y>#</y><d>2021-08-13</d><h>17:13</h><w>noprompt</w><a>@markaddleman</a> I left an explanation for why that did not compile properly.</z><z id="t1628874888" t="noprompt OK hopefully that settles most of the problems."><y>#</y><d>2021-08-13</d><h>17:14</h><w>noprompt</w>OK hopefully that settles most of the problems.</z><z id="t1628877685" t="markaddleman great. I&apos;ll give the latest a try in about an hour"><y>#</y><d>2021-08-13</d><h>18:01</h><r>markaddleman</r>great.  I&apos;ll give the latest a try in about an hour</z><z id="t1628881022" t="markaddleman with the latest commit, all my tests pass. thanks!"><y>#</y><d>2021-08-13</d><h>18:57</h><r>markaddleman</r>with the latest commit, all my tests pass.  thanks!</z><z id="t1628884581" t="noprompt https://clojars.org/meander/epsilon"><y>#</y><d>2021-08-13</d><h>19:56</h><w>noprompt</w><a href="https://clojars.org/meander/epsilon" target="_blank">https://clojars.org/meander/epsilon</a></z></g><g id="s12"><z id="t1629038881" t="markaddleman Congrats on the release! Do you want to update the github readme to point to v643?"><y>#</y><d>2021-08-15</d><h>14:48</h><r>markaddleman</r>Congrats on the release!  Do you want to update the github readme to point to v643?</z><z id="t1629138325" t="noprompt That’d be a good idea."><y>#</y><d>2021-08-16</d><h>18:25</h><r>noprompt</r>That’d be a good idea.</z><z id="t1628884604" t="noprompt Whew! OK! Several fixes went out with this one."><y>#</y><d>2021-08-13</d><h>19:56</h><w>noprompt</w>Whew! OK! Several fixes went out with this one.</z><z id="t1629190572" t="mkvlr hi [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] , really love your meander datascript example. Curious if you or anybody else ever profiled it against datascript? Or how it compares in terms of CLJS bundle size?"><y>#</y><d>2021-08-17</d><h>08:56</h><w>mkvlr</w>hi <a>@huxley</a>, really love your meander datascript example. Curious if you or anybody else ever profiled it against datascript? Or how it compares in terms of CLJS bundle size?</z><z id="t1629190833" t="ribelo https://github.com/ribelo/doxa"><y>#</y><d>2021-08-17</d><h>09:00</h><r>ribelo</r><a href="https://github.com/ribelo/doxa" target="_blank">https://github.com/ribelo/doxa</a></z><z id="t1629190877" t="ribelo this is an evolution of the idea in that example"><y>#</y><d>2021-08-17</d><h>09:01</h><r>ribelo</r>this is an evolution of the idea in that example</z><z id="t1629190922" t="ribelo boundle size is basically zero, because the meander is macro-based and very little code is added"><y>#</y><d>2021-08-17</d><h>09:02</h><r>ribelo</r>boundle size is basically zero, because the meander is macro-based and very little code is added</z><z id="t1629191051" t="ribelo"><y>#</y><d>2021-08-17</d><h>09:04</h><r>ribelo</r></z><z id="t1629191160" t="ribelo this is from a small project using a re-frame and a doxa. all for about 3kloc"><y>#</y><d>2021-08-17</d><h>09:06</h><r>ribelo</r>this is from a small project using a re-frame and a doxa. all for about 3kloc</z><z id="t1629192631" t="ribelo all subscriptions use doxa queries, which means meander in total. [:attrs {:href &quot;/_/_/users/U5H74UNSF&quot;}]"><y>#</y><d>2021-08-17</d><h>09:30</h><r>ribelo</r>all subscriptions use doxa queries, which means meander in total. <a>@U5H74UNSF</a></z><z id="t1629193683" t="mkvlr oh cool"><y>#</y><d>2021-08-17</d><h>09:48</h><r>mkvlr</r>oh cool</z><z id="t1629194855" t="mhuebert [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] looks great. So doxa/meander is fast enough that using subscriptions to recompute queries whenever the root map changes is fast enough - no need for something like pattern-matching on a tx-log of changes to invalidate queries "><y>#</y><d>2021-08-17</d><h>10:07</h><r>mhuebert</r><a>@huxley</a> looks great. So doxa/meander is fast enough that using subscriptions to recompute queries whenever the root map changes is fast enough - no need for something like pattern-matching on a tx-log of changes to invalidate queries </z><z id="t1629195309" t="ribelo [:attrs {:href &quot;/_/_/users/U050RLRRQ&quot;}] Yes, it&apos;s fast enough, but I&apos;m actually working on what you&apos;re talking about"><y>#</y><d>2021-08-17</d><h>10:15</h><r>ribelo</r><a>@U050RLRRQ</a> Yes, it&apos;s fast enough, but I&apos;m actually working on what you&apos;re talking about</z><z id="t1629195335" t="mhuebert Cool, I’m very interested in that direction "><y>#</y><d>2021-08-17</d><h>10:15</h><r>mhuebert</r>Cool, I’m very interested in that direction </z><z id="t1629195359" t="ribelo https://github.com/ribelo/doxa/blob/memoized-query/src/ribelo/doxa.cljc#L831"><y>#</y><d>2021-08-17</d><h>10:15</h><r>ribelo</r><a href="https://github.com/ribelo/doxa/blob/memoized-query/src/ribelo/doxa.cljc#L831" target="_blank">https://github.com/ribelo/doxa/blob/memoized-query/src/ribelo/doxa.cljc#L831</a></z><z id="t1629195535" t="ribelo underneath I use editscript , to calculate the difference in db, it is fast enough and its overhead is ~1ms"><y>#</y><d>2021-08-17</d><h>10:18</h><r>ribelo</r>underneath I use <code>editscript</code>, to calculate the difference in db, it is fast enough and its overhead is ~1ms</z><z id="t1629195613" t="ribelo I want the queries to be memoized and recalculated only when the data that affects the result changes."><y>#</y><d>2021-08-17</d><h>10:20</h><r>ribelo</r>I want the queries to be memoized and recalculated only when the data that affects the result changes.</z><z id="t1629195631" t="ribelo looks promising so far"><y>#</y><d>2021-08-17</d><h>10:20</h><r>ribelo</r>looks promising so far</z><z id="t1629230599" t="mkvlr that’s very exciting"><y>#</y><d>2021-08-17</d><h>20:03</h><r>mkvlr</r>that’s very exciting</z><z id="t1629230614" t="mkvlr any plans for supporting a datascript like schema as well?"><y>#</y><d>2021-08-17</d><h>20:03</h><r>mkvlr</r>any plans for supporting a datascript like schema as well?</z><z id="t1629230722" t="ribelo doxa is intentionally schemaless"><y>#</y><d>2021-08-17</d><h>20:05</h><r>ribelo</r><code>doxa</code> is intentionally schemaless</z><z id="t1629230903" t="ribelo however, there is no problem adding it, but it would be far down on the list of things to do"><y>#</y><d>2021-08-17</d><h>20:08</h><r>ribelo</r>however, there is no problem adding it, but it would be far down on the list of things to do</z><z id="t1629231044" t="mkvlr guess it can also be added on top later"><y>#</y><d>2021-08-17</d><h>20:10</h><r>mkvlr</r>guess it can also be added on top later</z><z id="t1629231067" t="mkvlr what is on the top of the list besides memoized-query?"><y>#</y><d>2021-08-17</d><h>20:11</h><r>mkvlr</r>what is on the top of the list besides memoized-query?</z><z id="t1629231322" t="ribelo Currently q is based only on meander, the consequence of which is that it expands on runetime"><y>#</y><d>2021-08-17</d><h>20:15</h><r>ribelo</r>Currently <code>q</code> is based only on meander, the consequence of which is that it expands on runetime</z><z id="t1629231372" t="ribelo datascript simply takes a vector that can be sent, stored, or generated etc"><y>#</y><d>2021-08-17</d><h>20:16</h><r>ribelo</r><code>datascript</code> simply takes a vector that can be sent, stored, or generated etc</z><z id="t1629231537" t="ribelo currently, apart from me, only one other person is using doxa , and he is actually giving it direction by sharing ideas"><y>#</y><d>2021-08-17</d><h>20:18</h><r>ribelo</r>currently, apart from me, only one other person is using <code>doxa</code>, and he is actually giving it direction by sharing ideas</z><z id="t1629231542" t="ribelo [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}]"><y>#</y><d>2021-08-17</d><h>20:19</h><r>ribelo</r><a>@U0510KXTU</a></z><z id="t1629238545" t="steveb8n that’s me. I can confirm that Doxa works very well in a re-frame app. looking forward to trying out the new caching feature"><y>#</y><d>2021-08-17</d><h>22:15</h><r>steveb8n</r>that’s me. I can confirm that Doxa works very well in a re-frame app. looking forward to trying out the new caching feature</z><z id="t1629238569" t="steveb8n I’ll have an OSS project out soon with the Doxa/re-frame combo in use"><y>#</y><d>2021-08-17</d><h>22:16</h><r>steveb8n</r>I’ll have an OSS project out soon with the Doxa/re-frame combo in use</z><z id="t1629209727" t="Max When matching against a map, is there a way to capture all of the unmatched kvs? For example, imagine I have this input structure: {:foo &quot;a&quot;, :bar &quot;2&quot;, :baz :ping} And I want to transform it into: {:foo &quot;a&quot;, :bar 2, :baz &quot;ping&quot;} but I don’t want to have to explicitly account for :foo . I guess this question could be rephrased as, “can meander be used to work with open maps?”"><y>#</y><d>2021-08-17</d><h>14:15</h><w>Max</w>When matching against a map, is there a way to capture all of the unmatched kvs? For example, imagine I have this input structure:
<pre>{:foo &quot;a&quot;, :bar &quot;2&quot;, :baz :ping}</pre>
And I want to transform it into:
<pre>{:foo &quot;a&quot;, :bar 2, :baz &quot;ping&quot;}</pre>
but I don’t want to have to explicitly account for <code>:foo</code>.

I guess this question could be rephrased as, “can meander be used to work with open maps?”</z><z id="t1629210892" t="ribelo https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#rest"><y>#</y><d>2021-08-17</d><h>14:34</h><r>ribelo</r><a href="https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#rest" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#rest</a></z><z id="t1629211338" t="Max That requires you to pass the extra kvs along manually though, which means you’d have to remember to do it if you want your maps to be open. There’s not a way to do something like that semi-automatically, is there?"><y>#</y><d>2021-08-17</d><h>14:42</h><r>Max</r>That requires you to pass the extra kvs along manually though, which means you’d have to remember to do it if you want your maps to be open. There’s not a way to do something like that semi-automatically, is there?</z><z id="t1629213174" t="ribelo I guess I didn&apos;t understand the question at first."><y>#</y><d>2021-08-17</d><h>15:12</h><r>ribelo</r>I guess I didn&apos;t understand the question at first.</z><z id="t1629213176" t="ribelo w8"><y>#</y><d>2021-08-17</d><h>15:12</h><r>ribelo</r>w8</z><z id="t1629213596" t="ribelo (m/rewrite {:foo &quot;a&quot;, :bar &quot;2&quot;, :baz :ping} (m/map-of !ks (m/cata !vs)) {&amp; [[!ks !vs] ...]} (m/pred keyword? (m/app name ?k)) ?k (m/re #&quot;\d+&quot; (m/app #(Long/parseLong %) ?v)) ?v ?x ?x) "><y>#</y><d>2021-08-17</d><h>15:19</h><r>ribelo</r><pre>(m/rewrite {:foo &quot;a&quot;, :bar &quot;2&quot;, :baz :ping}
  (m/map-of !ks (m/cata !vs))
  {&amp; [[!ks !vs] ...]}
  (m/pred keyword? (m/app name ?k))
  ?k
  (m/re #&quot;\d+&quot; (m/app #(Long/parseLong %) ?v))
  ?v
  ?x ?x)</pre>
</z><z id="t1629213610" t="ribelo ;; =&gt; {:foo &quot;a&quot;, :bar 2, :baz &quot;ping&quot;} "><y>#</y><d>2021-08-17</d><h>15:20</h><r>ribelo</r><pre>;; =&gt; {:foo &quot;a&quot;, :bar 2, :baz &quot;ping&quot;}</pre>
</z><z id="t1629218455" t="Max Is cata documented anywhere? I couldn’t find it in the cljdoc"><y>#</y><d>2021-08-17</d><h>16:40</h><r>Max</r>Is cata documented anywhere? I couldn’t find it in the cljdoc</z><z id="t1629218478" t="Max Seems like open maps are technically supported, but not super straightforwardly"><y>#</y><d>2021-08-17</d><h>16:41</h><r>Max</r>Seems like open maps are technically supported, but not super straightforwardly</z><z id="t1629230546" t="ribelo [:attrs {:href &quot;/_/_/users/U01EB0V3H39&quot;}] https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md"><y>#</y><d>2021-08-17</d><h>20:02</h><r>ribelo</r><a>@U01EB0V3H39</a> <a href="https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md</a></z><z id="t1629230564" t="ribelo here&apos;s the bit about cata"><y>#</y><d>2021-08-17</d><h>20:02</h><r>ribelo</r>here&apos;s the bit about <code>cata</code></z><z id="t1629230661" t="ribelo and unfortunately, the best source for learning meander is tests"><y>#</y><d>2021-08-17</d><h>20:04</h><r>ribelo</r>and unfortunately, the best source for learning meander is tests</z><z id="t1629230666" t="ribelo https://github.com/noprompt/meander/blob/epsilon/test/meander/epsilon_test.cljc"><y>#</y><d>2021-08-17</d><h>20:04</h><r>ribelo</r><a href="https://github.com/noprompt/meander/blob/epsilon/test/meander/epsilon_test.cljc" target="_blank">https://github.com/noprompt/meander/blob/epsilon/test/meander/epsilon_test.cljc</a></z><z id="t1629361389" t="dominicm I finally have the perfect use case for meander! However, there&apos;s a problem with the jar you&apos;re releasing. It contains a copy of Clojure AOT&apos;d!"><y>#</y><d>2021-08-19</d><h>08:23</h><w>dominicm</w>I finally have the perfect use case for meander!  However, there&apos;s a problem with the jar you&apos;re releasing.  It contains a copy of Clojure AOT&apos;d!</z><z id="t1629361502" t="dominicm ❯ jar tf ~/.m2/repository/meander/epsilon/0.0.643/epsilon-0.0.643.jar | grep &apos;^clojure/&apos; | head clojure/ clojure/core$generate_proxy$gen_method__7051.class clojure/reflect$declared_fields.class clojure/string$split_lines.class clojure/pprint$init_cap_writer$fn__10632.class clojure/core$fn__7417.class clojure/core$bean$fn__7221.class clojure/core$vector_QMARK___5414.class clojure/core$destructure$pb__6246$pmap__6249$fn__6252$fn__6256.class clojure/core$mk_am.class This makes the jar bigger than Clojure itself! ❯ du -hs ~/.m2/repository/meander/epsilon/0.0.643/epsilon-0.0.643.jar ~/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar 4.6M /home/overfl0w/.m2/repository/meander/epsilon/0.0.643/epsilon-0.0.643.jar 3.8M /home/overfl0w/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar"><y>#</y><d>2021-08-19</d><h>08:25</h><w>dominicm</w><pre>❯ jar tf  ~/.m2/repository/meander/epsilon/0.0.643/epsilon-0.0.643.jar | grep &apos;^clojure/&apos; | head
clojure/
clojure/core$generate_proxy$gen_method__7051.class
clojure/reflect$declared_fields.class
clojure/string$split_lines.class
clojure/pprint$init_cap_writer$fn__10632.class
clojure/core$fn__7417.class
clojure/core$bean$fn__7221.class
clojure/core$vector_QMARK___5414.class
clojure/core$destructure$pb__6246$pmap__6249$fn__6252$fn__6256.class
clojure/core$mk_am.class</pre>
This makes the jar bigger than Clojure itself!

<pre>❯ du -hs ~/.m2/repository/meander/epsilon/0.0.643/epsilon-0.0.643.jar ~/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar
4.6M	/home/overfl0w/.m2/repository/meander/epsilon/0.0.643/epsilon-0.0.643.jar
3.8M	/home/overfl0w/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar</pre></z><z id="t1629385754" t="noprompt [:attrs {:href &quot;/_/_/users/U09LZR36F&quot;}] Hmm… OK. I packaged this one up manually with uberdeps and I’m betting I made a mistake."><y>#</y><d>2021-08-19</d><h>15:09</h><w>noprompt</w><a>@dominicm</a> Hmm… OK. I packaged this one up manually with uberdeps and I’m betting I made a mistake.</z><z id="t1629385784" t="noprompt Juxt has a deps package thingy, yeah?"><y>#</y><d>2021-08-19</d><h>15:09</h><w>noprompt</w>Juxt has a deps package thingy, yeah?</z><z id="t1629386015" t="noprompt I’ll try and get this fixed up."><y>#</y><d>2021-08-19</d><h>15:13</h><w>noprompt</w>I’ll try and get this fixed up.</z><z id="t1629386101" t="Jimmy Miller In this case we don&apos;t want a uberjar. Depstar might be an easy way to do this https://cljdoc.org/d/com.github.seancorfield/depstar/2.1.278/doc/getting-started/building-a-library-jar"><y>#</y><d>2021-08-19</d><h>15:15</h><w>Jimmy Miller</w>In this case we don&apos;t want a uberjar. Depstar might be an easy way to do this <a href="https://cljdoc.org/d/com.github.seancorfield/depstar/2.1.278/doc/getting-started/building-a-library-jar" target="_blank">https://cljdoc.org/d/com.github.seancorfield/depstar/2.1.278/doc/getting-started/building-a-library-jar</a></z><z id="t1629387703" t="delaguardo newest version of clojure cli can help as well https://github.com/DotFox/meander/commit/21112eb3ce689524f005d0ce9a3d065ba3c43752 here is my attempt (successful 🙂 ) to make a package and install into local repository"><y>#</y><d>2021-08-19</d><h>15:41</h><w>delaguardo</w>newest version of clojure cli can help as well
<a href="https://github.com/DotFox/meander/commit/21112eb3ce689524f005d0ce9a3d065ba3c43752" target="_blank">https://github.com/DotFox/meander/commit/21112eb3ce689524f005d0ce9a3d065ba3c43752</a>
here is my attempt (successful <b>🙂</b>) to make a package and install into local repository</z><z id="t1629387723" t="delaguardo clj -T:build all"><y>#</y><d>2021-08-19</d><h>15:42</h><w>delaguardo</w><code>clj -T:build all</code></z><z id="t1629387808" t="delaguardo result is 94K"><y>#</y><d>2021-08-19</d><h>15:43</h><w>delaguardo</w>result is 94K</z><z id="t1629388219" t="noprompt Nice!"><y>#</y><d>2021-08-19</d><h>15:50</h><w>noprompt</w>Nice!</z><z id="t1629388260" t="noprompt Thanks for the tips. 🙂"><y>#</y><d>2021-08-19</d><h>15:51</h><w>noprompt</w>Thanks for the tips. <b>🙂</b></z><z id="t1629403732" t="dominicm I tried to figure out the release process and got a bit lost with the whole project.clj generation stuff tbh 😅"><y>#</y><d>2021-08-19</d><h>20:08</h><w>dominicm</w>I tried to figure out the release process and got a bit lost with the whole project.clj generation stuff tbh <b>😅</b></z><z id="t1629404790" t="noprompt That stuff needs to get dumped in the toilet. I’m don’t want to use lein deploy clojars anymore because reasons. 🙂"><y>#</y><d>2021-08-19</d><h>20:26</h><w>noprompt</w>That stuff needs to get dumped in the toilet. I’m don’t want to use <code>lein deploy clojars</code> anymore because reasons. <b>🙂</b></z><z id="t1629404806" t="noprompt I’m good to have anything else."><y>#</y><d>2021-08-19</d><h>20:26</h><w>noprompt</w>I’m good to have anything else.</z><z id="t1629404824" t="noprompt A basic script would be fine."><y>#</y><d>2021-08-19</d><h>20:27</h><w>noprompt</w>A basic script would be fine.</z><z id="t1629406587" t="dominicm I did stumble across https://github.com/applied-science/deps-library which might be of interest"><y>#</y><d>2021-08-19</d><h>20:56</h><w>dominicm</w>I did stumble across <a href="https://github.com/applied-science/deps-library" target="_blank">https://github.com/applied-science/deps-library</a> which might be of interest</z><z id="t1629409486" t="noprompt Great. I’ll take a look at this stuff tomorrow and see about reducing the size of the jar."><y>#</y><d>2021-08-19</d><h>21:44</h><w>noprompt</w>Great. I’ll take a look at this stuff tomorrow and see about reducing the size of the jar.</z><z id="t1629409492" t="noprompt Thanks for reporting the issue. 🙂"><y>#</y><d>2021-08-19</d><h>21:44</h><w>noprompt</w>Thanks for reporting the issue. <b>🙂</b></z><z id="t1629432140" t="Lucy Wang With meander 0.626 I got a bunch of such errors, are these expected? Performance warning, meander/util/epsilon.cljc:123:3 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:157:3 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:191:3 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:221:3 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:314:6 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:291:4 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:374:6 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:348:4 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:435:3 - case has int tests, but tested expression is not primitive. Performance warning, meander/util/epsilon.cljc:630:3 - case has int tests, but tested expression is not primitive. Reflection warning, meander/util/epsilon.cljc:714:24 - reference to field val can&apos;t be resolved. "><y>#</y><d>2021-08-20</d><h>04:02</h><w>Lucy Wang</w>With meander 0.626 I got a bunch of such errors, are these expected?
<pre>Performance warning, meander/util/epsilon.cljc:123:3 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:157:3 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:191:3 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:221:3 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:314:6 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:291:4 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:374:6 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:348:4 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:435:3 - case has int tests, but tested expression is not primitive.
Performance warning, meander/util/epsilon.cljc:630:3 - case has int tests, but tested expression is not primitive.
Reflection warning, meander/util/epsilon.cljc:714:24 - reference to field val can&apos;t be resolved.</pre>
</z><z id="t1630373243" t="Lucy Wang I&apos;m still seeing these warnings in the latest 0.0.650 release (when used in a shadow-cljs project)"><y>#</y><d>2021-08-31</d><h>01:27</h><r>Lucy Wang</r>I&apos;m still seeing these warnings in the latest 0.0.650 release (when used in a shadow-cljs project)</z><z id="t1630425699" t="noprompt All of these?"><y>#</y><d>2021-08-31</d><h>16:01</h><r>noprompt</r>All of these?</z><z id="t1630426397" t="noprompt Here’s what I see: $ clj Downloading: meander/epsilon/0.0.650/epsilon-0.0.650.pom from clojars Downloading: meander/epsilon/0.0.650/epsilon-0.0.650.jar from clojars Clojure 1.10.3 user=&gt; (require &apos;[meander.epsilon :as m]) Reflection warning, meander/util/epsilon.cljc:758:24 - reference to field val can&apos;t be resolved. nil user=&gt; I don’t see the other warnings, however. Does anyone else still see the warnings about case on 0.0.0650 ?"><y>#</y><d>2021-08-31</d><h>16:13</h><r>noprompt</r>Here’s what I see:

<pre>$ clj
Downloading: meander/epsilon/0.0.650/epsilon-0.0.650.pom from clojars
Downloading: meander/epsilon/0.0.650/epsilon-0.0.650.jar from clojars
Clojure 1.10.3
user=&gt; (require &apos;[meander.epsilon :as m])
Reflection warning, meander/util/epsilon.cljc:758:24 - reference to field val can&apos;t be resolved.
nil
user=&gt;</pre>
I don’t see the other warnings, however. Does anyone else still see the warnings about <code>case</code> on <code>0.0.0650</code>?</z><z id="t1630630350" t="Lucy Wang You&apos;re right! I didn&apos;t actually use 0.0.650 - it was still 0.0.626. With 650 all is ok."><y>#</y><d>2021-09-03</d><h>00:52</h><r>Lucy Wang</r>You&apos;re right! I didn&apos;t actually use 0.0.650 - it was still 0.0.626. With 650 all is ok.</z><z id="t1629449542" t="dominicm I also saw the reflection"><y>#</y><d>2021-08-20</d><h>08:52</h><w>dominicm</w>I also saw the reflection</z><z id="t1629485490" t="noprompt I can fix that one as part of my excuse-to-cut-a-new-release-today."><y>#</y><d>2021-08-20</d><h>18:51</h><w>noprompt</w>I can fix that one as part of my excuse-to-cut-a-new-release-today.</z><z id="t1629700563" t="pithyless I&apos;m assuming it&apos;s the same one, but with &quot;0.0.643&quot; the reflection warning is: Reflection warning, meander/util/epsilon.cljc:758:24 - reference to field val can&apos;t be resolved."><y>#</y><d>2021-08-23</d><h>06:36</h><r>pithyless</r>I&apos;m assuming it&apos;s the same one, but with <code>&quot;0.0.643&quot;</code> the reflection warning is:
<pre>Reflection warning, meander/util/epsilon.cljc:758:24 - reference to field val can&apos;t be resolved.</pre></z><z id="t1629834663" t="noprompt Yep"><y>#</y><d>2021-08-24</d><h>19:51</h><r>noprompt</r>Yep</z><z id="t1630373243" t="Lucy Wang I&apos;m still seeing these warnings in the latest 0.0.650 release (when used in a shadow-cljs project)"><y>#</y><d>2021-08-31</d><h>01:27</h><w>Lucy Wang</w>I&apos;m still seeing these warnings in the latest 0.0.650 release (when used in a shadow-cljs project)</z><z id="t1630426397" t="noprompt Here’s what I see: $ clj Downloading: meander/epsilon/0.0.650/epsilon-0.0.650.pom from clojars Downloading: meander/epsilon/0.0.650/epsilon-0.0.650.jar from clojars Clojure 1.10.3 user=&gt; (require &apos;[meander.epsilon :as m]) Reflection warning, meander/util/epsilon.cljc:758:24 - reference to field val can&apos;t be resolved. nil user=&gt; I don’t see the other warnings, however. Does anyone else still see the warnings about case on 0.0.0650 ?"><y>#</y><d>2021-08-31</d><h>16:13</h><w>noprompt</w>Here’s what I see:

<pre>$ clj
Downloading: meander/epsilon/0.0.650/epsilon-0.0.650.pom from clojars
Downloading: meander/epsilon/0.0.650/epsilon-0.0.650.jar from clojars
Clojure 1.10.3
user=&gt; (require &apos;[meander.epsilon :as m])
Reflection warning, meander/util/epsilon.cljc:758:24 - reference to field val can&apos;t be resolved.
nil
user=&gt;</pre>
I don’t see the other warnings, however. Does anyone else still see the warnings about <code>case</code> on <code>0.0.0650</code>?</z><z id="t1629835785" t="noprompt Reflection warning, meander/util/epsilon.cljc:714:24 - reference to field val can&apos;t be resolved. AFAICT this is the only remaining warning as of the latest release."><y>#</y><d>2021-08-24</d><h>20:09</h><w>noprompt</w><pre>Reflection warning, meander/util/epsilon.cljc:714:24 - reference to field val can&apos;t be resolved.</pre>
AFAICT this is the only remaining warning as of the latest release.</z><z id="t1629835817" t="noprompt TBH I’m not sure how to get rid of this one. I’m gonna bug the guy who added the code. 🙂"><y>#</y><d>2021-08-24</d><h>20:10</h><w>noprompt</w>TBH I’m not sure how to get rid of this one. I’m gonna bug the guy who added the code. <b>🙂</b></z><z id="t1629847377" t="ribelo Shouldn&apos;t this work? (m/rewrite &apos;[:a b c 1 2] [:a . (m/pred symbol? !xs) ... !rest ...] [!xs ...])"><y>#</y><d>2021-08-24</d><h>23:22</h><w>ribelo</w>Shouldn&apos;t this work?
<pre>(m/rewrite &apos;[:a b c 1 2]
  [:a . (m/pred symbol? !xs) ... !rest ...]
  [!xs ...])</pre></z><z id="t1629847471" t="ribelo Or this? (m/rewrite &apos;[:a b c 1 2] [:a . (m/pred symbol? !xs) ... &amp; ?rest] [!xs ...])"><y>#</y><d>2021-08-24</d><h>23:24</h><w>ribelo</w>Or this?
<pre>(m/rewrite &apos;[:a b c 1 2]
  [:a . (m/pred symbol? !xs) ... &amp; ?rest]
  [!xs ...])</pre></z><z id="t1629908110" t="noprompt Yes they should. I’m guessing they don’t?"><y>#</y><d>2021-08-25</d><h>16:15</h><w>noprompt</w>Yes they should. I’m guessing they don’t?</z><z id="t1629908520" t="noprompt Investigating."><y>#</y><d>2021-08-25</d><h>16:22</h><w>noprompt</w>Investigating.</z><z id="t1629909198" t="noprompt OK. So those are working properly."><y>#</y><d>2021-08-25</d><h>16:33</h><w>noprompt</w>OK. So those are working properly.</z><z id="t1629909460" t="noprompt (m/rewrite &apos;[:a b c 1 2] [:a . (m/pred symbol? !xs) ... !rest ...] [!xs ... !rest ...]) ;; =&gt; [b c 1 2] (m/rewrite &apos;[:a b c 1 2] [:a . (m/pred symbol? !xs) ... &amp; ?rest] [!xs ... &amp; ?rest]) ;; =&gt; [b c 1 2] rewrite is based on find. The search space for the partitions of the list after :a is. [:a . (m/pred symbol? !xs) ... !rest ...] ;; ^^^^^^^^ XS ^^^^^^^^ ^ YS ^ ;; ;; XS =&gt; [], YS =&gt; [b c 1 2] ;; XS =&gt; [b], YS =&gt; [c 1 2] ;; XS =&gt; [b c], YS =&gt; [1 2] ;; XS =&gt; [b c 1], YS =&gt; [2] ;; XS =&gt; [b c 1 2], YS =&gt; [] "><y>#</y><d>2021-08-25</d><h>16:37</h><w>noprompt</w><pre>(m/rewrite &apos;[:a b c 1 2]
  [:a . (m/pred symbol? !xs) ... !rest ...]
  [!xs ... !rest ...])
;; =&gt; [b c 1 2]


(m/rewrite &apos;[:a b c 1 2]
  [:a . (m/pred symbol? !xs) ... &amp; ?rest]
  [!xs ... &amp; ?rest])
;; =&gt; [b c 1 2]</pre>
<code>rewrite</code> is based on find. The search space for the partitions of the list after <code>:a</code> is.
<pre>[:a . (m/pred symbol? !xs) ... !rest ...]
;;    ^^^^^^^^ XS ^^^^^^^^    ^  YS ^
;;                             
;; XS =&gt; [],        YS =&gt; [b c 1 2]
;; XS =&gt; [b],       YS =&gt; [c 1 2]
;; XS =&gt; [b c],     YS =&gt; [1 2]
;; XS =&gt; [b c 1],   YS =&gt; [2]
;; XS =&gt; [b c 1 2], YS =&gt; []</pre>
</z><z id="t1629909496" t="noprompt What Meander lacks is a greedy star for matching."><y>#</y><d>2021-08-25</d><h>16:38</h><w>noprompt</w>What Meander lacks is a greedy star for matching.</z><z id="t1629909563" t="noprompt I know how to implement it as I have done this for zeta . For epsilon I just need a notation."><y>#</y><d>2021-08-25</d><h>16:39</h><w>noprompt</w>I know how to implement it as I have done this for <code>zeta</code>. For <code>epsilon</code> I just need a notation.</z><z id="t1629910102" t="noprompt IOW Does anyone have an idea for what sort of notation we could use for a greedy version of … ?"><y>#</y><d>2021-08-25</d><h>16:48</h><w>noprompt</w>IOW Does anyone have an idea for what sort of notation we could use for a greedy version of <code>…</code>?</z><z id="t1629910181" t="noprompt epsilon also makes the mistake of … being greedy on the RHS, something we can’t fix without, well, making a new version."><y>#</y><d>2021-08-25</d><h>16:49</h><w>noprompt</w><code>epsilon</code> also makes the mistake of <code>…</code> being greedy on the RHS, something we can’t fix without, well, making a new version.</z><z id="t1629913309" t="chucklehead ..* ?"><y>#</y><d>2021-08-25</d><h>17:41</h><w>chucklehead</w><code>..*</code>?</z><z id="t1629915663" t="ribelo ¯\_(ツ)_/¯"><y>#</y><d>2021-08-25</d><h>18:21</h><w>ribelo</w><code>¯\_(ツ)_/¯</code></z><z id="t1629921016" t="ribelo I&apos;m trying to rewrite the doxa datalog parsing functions using meander , and I&apos;ve pretty much stuck out on a simple thing"><y>#</y><d>2021-08-25</d><h>19:50</h><w>ribelo</w>I&apos;m trying to rewrite the <code>doxa</code> <code>datalog</code> parsing functions using <code>meander</code>, and I&apos;ve pretty much stuck out on a simple thing</z><z id="t1629921245" t="ribelo I would like to transform [:find ?e ?age :in ?name :where [?e :name ?name] [?e :age ?age]] to {:find [?e ?age] :in [?name] :where [[?e :name ?name] ...]} seems simple, but the order is not fixed, all keys are optional and all vals can be anything but a keyword"><y>#</y><d>2021-08-25</d><h>19:54</h><w>ribelo</w>I would like to transform
<code>[:find ?e ?age :in ?name :where [?e :name ?name] [?e :age ?age]]</code>
to
<code>{:find [?e ?age] :in [?name] :where [[?e :name ?name] ...]}</code>
seems simple, but the order is not fixed, all keys are optional and all vals can be anything but a keyword</z><z id="t1629921438" t="ribelo In theory, such a thing should work, but because &amp; ?more is greedy, it doesn&apos;t. (defn parse-query2 [q &amp; args] (m/rewrite q [:find . (m/pred (complement keyword?) !find) ... &amp; (m/cata ?more)] {:find [!find ...] &amp; ?more} [:in . (m/pred (complement keyword?) !in) ... &amp; (m/cata ?more)] {:in [!in ...] &amp; ?more} [:where . (m/pred vector? !xs) ...] {:where [!xs ...]} ?x nil nil {:args ~args}))"><y>#</y><d>2021-08-25</d><h>19:57</h><w>ribelo</w>In theory, such a thing should work, but because <code>&amp; ?more</code> is greedy, it doesn&apos;t.
<pre>(defn parse-query2 [q &amp; args]
  (m/rewrite q
    [:find . (m/pred (complement keyword?) !find) ... &amp; (m/cata ?more)]
    {:find [!find ...] &amp; ?more}
    [:in . (m/pred (complement keyword?) !in) ... &amp; (m/cata ?more)]
    {:in [!in ...] &amp; ?more}
    [:where . (m/pred vector? !xs) ...]
    {:where [!xs ...]}

    ?x nil
    nil {:args ~args}))</pre></z><z id="t1629931230" t="noprompt Here’s what I came up with: (let [q &apos;[:find ?e ?age :in ?name :where [?e :name ?name] [?e :age ?age]]] (m/rewrite [q {}] [[(m/keyword _ _ :as ?keyword) &amp; ?args &amp; [(m/keyword _) &amp; _ :as ?rest-q]] ?out] (m/cata [?rest-q {?keyword ?args &amp; ?out}]) [[(m/keyword _ _ :as ?keyword) &amp; ?args] ?out] {?keyword ?args &amp; ?out} [_ ?out] ?out)) ;; =&gt; {:find [?e ?age], :in [?name], :where [[?e :name ?name] [?e :age ?age]]} "><y>#</y><d>2021-08-25</d><h>22:40</h><w>noprompt</w>Here’s what I came up with:
<pre>(let [q &apos;[:find ?e ?age :in ?name :where [?e :name ?name] [?e :age ?age]]]
  (m/rewrite [q {}]
    [[(m/keyword _ _ :as ?keyword) &amp; ?args &amp; [(m/keyword _) &amp; _ :as ?rest-q]] ?out]
    (m/cata [?rest-q {?keyword ?args &amp; ?out}])

    [[(m/keyword _ _ :as ?keyword) &amp; ?args] ?out]
    {?keyword ?args &amp; ?out}

    [_ ?out]
    ?out))
;; =&gt;
{:find [?e ?age],
 :in [?name],
 :where [[?e :name ?name] [?e :age ?age]]}</pre>
</z><z id="t1629931333" t="noprompt I’m definitely not proud of the hackery here. The first rule is annoying because don’t have a greedy operator can’t (m/and (m/not (m/keyword _)) !args) "><y>#</y><d>2021-08-25</d><h>22:42</h><w>noprompt</w>I’m definitely not proud of the hackery here. The first rule is annoying because don’t have a greedy operator can’t
<pre>(m/and (m/not (m/keyword _)) !args)</pre>
</z><z id="t1629931348" t="noprompt So I want to correct that."><y>#</y><d>2021-08-25</d><h>22:42</h><w>noprompt</w>So I want to correct that.</z><z id="t1629931541" t="noprompt Also, ideally, something like this should work. (let [q &apos;[:find ?e ?age :in ?name :where [?e :name ?name] [?e :age ?age]]] (m/rewrite q [(m/keyword _ _ :as ?keyword) &amp; ?args &amp; (m/cata ?out)] {?keyword ?args &amp; ?out})) "><y>#</y><d>2021-08-25</d><h>22:45</h><w>noprompt</w>Also, ideally, something like this should work.
<pre>(let [q &apos;[:find ?e ?age :in ?name :where [?e :name ?name] [?e :age ?age]]]
  (m/rewrite q
    [(m/keyword _ _ :as ?keyword) &amp; ?args &amp; (m/cata ?out)]
    {?keyword ?args &amp; ?out}))</pre>
</z><z id="t1629931588" t="noprompt Oh. It does. I just forgot the empty case."><y>#</y><d>2021-08-25</d><h>22:46</h><w>noprompt</w>Oh. It does. I just forgot the empty case.</z><z id="t1629931590" t="noprompt (let [q &apos;[:find ?e ?age :in ?name :where [?e :name ?name] [?e :age ?age]]] (m/rewrite q [(m/keyword _ _ :as ?keyword) &amp; ?args &amp; (m/cata ?out)] {?keyword ?args &amp; ?out} [] {})) ;;=&gt; {:where [[?e :name ?name] [?e :age ?age]], :in [?name], :find [?e ?age]} "><y>#</y><d>2021-08-25</d><h>22:46</h><w>noprompt</w><pre>(let [q &apos;[:find ?e ?age :in ?name :where [?e :name ?name] [?e :age ?age]]]
  (m/rewrite q
    [(m/keyword _ _ :as ?keyword) &amp; ?args &amp; (m/cata ?out)]
    {?keyword ?args &amp; ?out}

    [] {}))
;;=&gt;
{:where [[?e :name ?name] [?e :age ?age]],
 :in [?name],
 :find [?e ?age]}</pre>
</z><z id="t1629931691" t="noprompt 🙂"><y>#</y><d>2021-08-25</d><h>22:48</h><w>noprompt</w><b>🙂</b></z><z id="t1629931865" t="noprompt I might also consider returning a sequence of pairs. (let [q &apos;[:find :find ?e ?age :in ?name :where [?e :name ?name] [?e :age ?age]]] (m/rewrite q [(m/keyword _ _ :as ?keyword) &amp; ?args &amp; (m/cata ?out)] [[?keyword ?args] &amp; ?out] [] [])) ;;=&gt; [[:find []] [:find [?e ?age]] [:in [?name]] [:where [[?e :name ?name] [?e :age ?age]]]] "><y>#</y><d>2021-08-25</d><h>22:51</h><w>noprompt</w>I might also consider returning a sequence of pairs.
<pre>(let [q &apos;[:find :find ?e ?age :in ?name :where [?e :name ?name] [?e :age ?age]]]
  (m/rewrite q
    [(m/keyword _ _ :as ?keyword) &amp; ?args &amp; (m/cata ?out)]
    [[?keyword ?args] &amp; ?out]

    [] []))
;;=&gt;
[[:find []]
 [:find [?e ?age]]
 [:in [?name]]
 [:where [[?e :name ?name] [?e :age ?age]]]]</pre>
</z><z id="t1629932013" t="noprompt But growing the cata could also accommodate this. (let [q &apos;[:find :find ?e ?age :in ?name :where [?e :name ?name] [?e :age ?age]]] (m/rewrite q [(m/keyword _ _ :as ?keyword) . !args ... &amp; (m/cata (m/or {?keyword [!args ...] &amp; ?out} ?out))] {?keyword [!args ...] &amp; ?out} [] {})) ;; =&gt; {:where [[?e :name ?name] [?e :age ?age]], :in [?name], :find [?e ?age]}"><y>#</y><d>2021-08-25</d><h>22:53</h><w>noprompt</w>But growing the <code>cata</code> could also accommodate this.
<pre>(let [q &apos;[:find :find ?e ?age :in ?name :where [?e :name ?name] [?e :age ?age]]]
  (m/rewrite q
    [(m/keyword _ _ :as ?keyword) . !args ...
     &amp; (m/cata (m/or {?keyword [!args ...] &amp; ?out} ?out))]
    {?keyword [!args ...] &amp; ?out}

    [] {}))
;; =&gt;
{:where [[?e :name ?name] [?e :age ?age]],
 :in [?name],
 :find [?e ?age]}</pre></z><z id="t1629932089" t="noprompt Vector queries are kind of a mixed bag. 😕"><y>#</y><d>2021-08-25</d><h>22:54</h><w>noprompt</w>Vector queries are kind of a mixed bag. <b>😕</b></z><z id="t1629932100" t="noprompt But I hope some of this helps?"><y>#</y><d>2021-08-25</d><h>22:55</h><w>noprompt</w>But I hope some of this helps?</z><z id="t1629979379" t="ribelo Meander is scary"><y>#</y><d>2021-08-26</d><h>12:02</h><w>ribelo</w>Meander is scary</z><z id="t1629979497" t="ribelo I think I&apos;m starting to understand something, that I&apos;ve licked a bit and can do things, and then it turns out that it&apos;s not true"><y>#</y><d>2021-08-26</d><h>12:04</h><w>ribelo</w>I think I&apos;m starting to understand something, that I&apos;ve licked a bit and can do things, and then it turns out that it&apos;s not true</z><z id="t1629979541" t="ribelo [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] (let [q &apos;[:find ?e ?age :in ?name :where [?e :name ?name] [?e :age ?age]]] (m/rewrite q [(m/keyword _ _ :as ?keyword) &amp; ?args &amp; (m/cata ?out)] {?keyword ?args &amp; ?out} [] {})) I had to write it down on a piece of paper to understand how and why it worked"><y>#</y><d>2021-08-26</d><h>12:05</h><w>ribelo</w><a>@noprompt</a>
<pre>(let [q &apos;[:find ?e ?age :in ?name :where [?e :name ?name] [?e :age ?age]]]
  (m/rewrite q
    [(m/keyword _ _ :as ?keyword) &amp; ?args &amp; (m/cata ?out)]
    {?keyword ?args &amp; ?out}

    [] {}))</pre>
I had to write it down on a piece of paper to understand how and why it worked</z><z id="t1629979617" t="ribelo thanks!"><y>#</y><d>2021-08-26</d><h>12:06</h><w>ribelo</w>thanks!</z><z id="t1629989496" t="jgdavey Hi! Long time, no chat, folks. 🙂 Anyway, I’m working on improving test failure messages using meander. Right now, a really big pattern that does not match the subject under test is just printing out the full pattern and full data, but I have a feeling that can be improved. Specifically, I’m wondering if there are any ways to decompose a pattern into smaller bits, such that the “matching” parts of a pattern could be separated from the “non-matching” parts. Does this make sense?"><y>#</y><d>2021-08-26</d><h>14:51</h><w>jgdavey</w>Hi! Long time, no chat, folks. <b>🙂</b> Anyway, I’m working on improving test failure messages using meander. Right now, a really big pattern that does not match the subject under test is just printing out the full pattern and full data, but I have a feeling that can be improved. Specifically, I’m wondering if there are any ways to decompose a pattern into smaller bits, such that the “matching” parts of a pattern could be separated from the “non-matching” parts. Does this make sense?</z><z id="t1629993890" t="jgdavey To expound a bit, let’s say I’m trying to match a map pattern: (let [expr {:present &quot;yes&quot; &quot;notkeyword&quot; &quot;missing&quot;}] (m/find expr {:present &quot;yes&quot; :missing &quot;no&quot; (m/pred keyword? ?k) &quot;missing&quot;} true _ false)) This returns false, as expected. What I’d love is to return the portion of the pattern map that doesn’t unify, like: {(m/pred keyword? ?k) &quot;missing&quot; :missing &quot;no&quot;} Does this make sense?"><y>#</y><d>2021-08-26</d><h>16:04</h><r>jgdavey</r>To expound a bit, let’s say I’m trying to match a map pattern:

<pre>(let [expr {:present &quot;yes&quot;
              &quot;notkeyword&quot; &quot;missing&quot;}]
    (m/find expr
      {:present &quot;yes&quot;
       :missing &quot;no&quot;
       (m/pred keyword? ?k) &quot;missing&quot;}
      true
      _
      false))</pre>
This returns false, as expected. What I’d love is to return the portion of the pattern map that doesn’t unify, like:

<pre>{(m/pred keyword? ?k) &quot;missing&quot;
   :missing &quot;no&quot;}</pre>
Does this make sense?</z><z id="t1630003203" t="jgdavey For now, I’m mapping each mapentry of the map pattern into individual “patterns”, and then seeing which work with m/find , and which don’t. If they don’t, I merge them back into a pattern to display the “missing” map entries."><y>#</y><d>2021-08-26</d><h>18:40</h><r>jgdavey</r>For now, I’m mapping each mapentry of the map pattern into individual “patterns”, and then seeing which work with <code>m/find</code>, and which don’t. If they don’t, I merge them back into a pattern to display the “missing” map entries.</z><z id="t1630009437" t="Jimmy Miller Yeah, that would definitely be cool to have. Not really sure we can make something like that happen given the current setup. We&apos;ve talked about build some separate explainer for why a pattern didn&apos;t match."><y>#</y><d>2021-08-26</d><h>20:23</h><r>Jimmy Miller</r>Yeah, that would definitely be cool to have. Not really sure we can make something like that happen given the current setup. We&apos;ve talked about build some separate explainer for why a pattern didn&apos;t match.</z><z id="t1630025367" t="jgdavey :thumbsup:"><y>#</y><d>2021-08-27</d><h>00:49</h><r>jgdavey</r><b>:thumbsup:</b></z><z id="t1630025402" t="jgdavey I just wanted to make sure there wasn’t some idiomatic obvious thing I was missing 🙂"><y>#</y><d>2021-08-27</d><h>00:50</h><r>jgdavey</r>I just wanted to make sure there wasn’t some idiomatic obvious thing I was missing <b>🙂</b></z><z id="t1629993087" t="markaddleman hey [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] - regarding https://clojurians.slack.com/archives/CFFTD7R6Z/p1629361502065800 - Would it be helpful if I updated meander&apos;s deps.edn with a packaging task? I&apos;ll have some time this weekend and happy to do it if it&apos;ll help"><y>#</y><d>2021-08-26</d><h>15:51</h><w>markaddleman</w>hey <a>@noprompt</a> <a>@jimmy</a> - regarding <a href="https://clojurians.slack.com/archives/CFFTD7R6Z/p1629361502065800" target="_blank">https://clojurians.slack.com/archives/CFFTD7R6Z/p1629361502065800</a>  - Would it be helpful if I updated meander&apos;s deps.edn with a packaging task?  I&apos;ll have some time this weekend and happy to do it if it&apos;ll help</z><z id="t1629993146" t="Jimmy Miller That would be great!"><y>#</y><d>2021-08-26</d><h>15:52</h><w>Jimmy Miller</w>That would be great!</z><z id="t1630005446" t="markaddleman I have a map and a vector. I&apos;d like to gather up all of the values within the vector that are also keys in the map. It&apos;s natural to write (let [m {:a &quot;a&quot;, :b &quot;b&apos;&quot;} v [:a :b :c]] (m/rewrite [m v] [?m (m/gather (m/and (m/pred contains? ?m ?v) !v))] [!v ...])) but, it doesn&apos;t work: Zero or more patterns may not have references to unbound logic variables . I&apos;ve tried many different varieties of the above but it&apos;s always one error or another. Any ideas?"><y>#</y><d>2021-08-26</d><h>19:17</h><w>markaddleman</w>I have a map and a vector.  I&apos;d like to gather up all of the values within the vector that are also keys in the map.  It&apos;s natural to write
<pre>(let [m {:a &quot;a&quot;, :b &quot;b&apos;&quot;}
        v [:a :b :c]]
    (m/rewrite [m v]
      [?m (m/gather (m/and (m/pred contains? ?m ?v)
                           !v))]
      [!v ...]))</pre>
but, it doesn&apos;t work: <code>Zero or more patterns may not have references to unbound logic variables</code>.  I&apos;ve tried many different varieties of the above but it&apos;s always one error or another.

Any ideas?</z><z id="t1630007481" t="ribelo The error refers to the fact that once you have !v once ?v"><y>#</y><d>2021-08-26</d><h>19:51</h><r>ribelo</r>The error refers to the fact that once you have <code>!v</code> once <code>?v</code></z><z id="t1630007495" t="ribelo probably"><y>#</y><d>2021-08-26</d><h>19:51</h><r>ribelo</r>probably</z><z id="t1630007591" t="markaddleman Thanks, I thought meander kept those separate but I&apos;ll give it a try"><y>#</y><d>2021-08-26</d><h>19:53</h><r>markaddleman</r>Thanks, I thought meander kept those separate but I&apos;ll give it a try</z><z id="t1630007596" t="ribelo (let [m {:a &quot;a&quot;, :b &quot;b&apos;&quot;} v [:a :b :c]] (m/rewrite [m v] [?m (m/gather (m/pred #(contains? ?m %) !xs))] [!xs ...])) ;; =&gt; [:a :b]"><y>#</y><d>2021-08-26</d><h>19:53</h><r>ribelo</r><pre>(let [m {:a &quot;a&quot;, :b &quot;b&apos;&quot;} v [:a :b :c]]
  (m/rewrite [m v]
    [?m (m/gather (m/pred #(contains? ?m %) !xs))]
    [!xs ...]))
;; =&gt; [:a :b]</pre></z><z id="t1630007631" t="ribelo it works ; )"><y>#</y><d>2021-08-26</d><h>19:53</h><r>ribelo</r>it works ; )</z><z id="t1630007635" t="markaddleman 😄 thanks!"><y>#</y><d>2021-08-26</d><h>19:53</h><r>markaddleman</r><b>😄</b>  thanks!</z><z id="t1630007665" t="ribelo np"><y>#</y><d>2021-08-26</d><h>19:54</h><r>ribelo</r>np</z><z id="t1630007710" t="markaddleman btw, I really like what you&apos;re doing with doxa. I have been working through https://github.com/fulcro-community/fulcro-exercises and doxa makes handling the normalized database much nicer"><y>#</y><d>2021-08-26</d><h>19:55</h><r>markaddleman</r>btw, I really like what you&apos;re doing with doxa.  I have been working through <a href="https://github.com/fulcro-community/fulcro-exercises" target="_blank">https://github.com/fulcro-community/fulcro-exercises</a> and doxa makes handling the normalized database much nicer</z><z id="t1630007727" t="ribelo thx!"><y>#</y><d>2021-08-26</d><h>19:55</h><r>ribelo</r>thx!</z><z id="t1630007761" t="ribelo I&apos;m quietly working on a major update, but I have many conceptual dilemmas"><y>#</y><d>2021-08-26</d><h>19:56</h><r>ribelo</r>I&apos;m quietly working on a major update, but I have many conceptual dilemmas</z><z id="t1630007847" t="markaddleman Such as? (I don&apos;t mean to pry but I&apos;m very curious)"><y>#</y><d>2021-08-26</d><h>19:57</h><r>markaddleman</r>Such as? (I don&apos;t mean to pry but I&apos;m very curious)</z><z id="t1630007868" t="ribelo I don&apos;t know how much compatibility with datascript I should keep"><y>#</y><d>2021-08-26</d><h>19:57</h><r>ribelo</r>I don&apos;t know how much compatibility with datascript I should keep</z><z id="t1630007912" t="markaddleman I can only speak for myself: very little 🙂"><y>#</y><d>2021-08-26</d><h>19:58</h><r>markaddleman</r>I can only speak for myself:  very little <b>🙂</b></z><z id="t1630007916" t="ribelo the current use of vector as ident , as in fulcro , has many advantages but is not without disadvantages"><y>#</y><d>2021-08-26</d><h>19:58</h><r>ribelo</r>the current use of vector as <code>ident</code>, as in <code>fulcro</code>, has many advantages but is not without disadvantages</z><z id="t1630007956" t="markaddleman I&apos;m exclusively interested in doxa as a convenience for fulcro. I&apos;m sure there are other use cases but, again, I can only speak for myself"><y>#</y><d>2021-08-26</d><h>19:59</h><r>markaddleman</r>I&apos;m exclusively interested in doxa as a convenience for fulcro.  I&apos;m sure there are other use cases but, again, I can only speak for myself</z><z id="t1630008068" t="ribelo I don&apos;t really need it either, but a couple of people have asked about schema, or the possibility that q is not a macro and can take a query on runetime"><y>#</y><d>2021-08-26</d><h>20:01</h><r>ribelo</r>I don&apos;t really need it either, but a couple of people have asked about schema, or the possibility that <code>q</code> is not a macro and can take a query on runetime</z><z id="t1630008092" t="markaddleman I can see the value of taking a query at runtime."><y>#</y><d>2021-08-26</d><h>20:01</h><r>markaddleman</r>I can see the value of taking a query at runtime.</z><z id="t1630008133" t="markaddleman It seems to me that schema can (and should?) be handled as a layer above doxa. seems pretty straightforward given that with is available"><y>#</y><d>2021-08-26</d><h>20:02</h><r>markaddleman</r>It seems to me that schema can (and should?) be handled as a layer above doxa.  seems pretty straightforward given that <code>with</code> is available</z><z id="t1630008137" t="ribelo you know, you speak for yourself, but all the people who use doxa can sit at the same table"><y>#</y><d>2021-08-26</d><h>20:02</h><r>ribelo</r>you know, you speak for yourself, but all the people who use <code>doxa</code> can sit at the same table</z><z id="t1630008149" t="markaddleman 🙂"><y>#</y><d>2021-08-26</d><h>20:02</h><r>markaddleman</r><b>🙂</b></z><z id="t1630008158" t="markaddleman Is there a #doxa channel?"><y>#</y><d>2021-08-26</d><h>20:02</h><r>markaddleman</r>Is there a #doxa channel?</z><z id="t1630008171" t="ribelo no, not yet"><y>#</y><d>2021-08-26</d><h>20:02</h><r>ribelo</r>no, not yet</z><z id="t1630008209" t="ribelo maybe it will happen if there is a need and doxa has an official release"><y>#</y><d>2021-08-26</d><h>20:03</h><r>ribelo</r>maybe it will happen if there is a need and doxa has an official release</z><z id="t1630008233" t="ribelo for now, it&apos;s just thinktering"><y>#</y><d>2021-08-26</d><h>20:03</h><r>ribelo</r>for now, it&apos;s just thinktering</z><z id="t1630008236" t="markaddleman sounds good to me. in the meantime, I&apos;ll keep enjoying it and looking forward to your new release"><y>#</y><d>2021-08-26</d><h>20:03</h><r>markaddleman</r>sounds good to me.  in the meantime, I&apos;ll keep enjoying it and looking forward to your new release</z><z id="t1630008298" t="ribelo https://github.com/ribelo/doxa/tree/memoized-query"><y>#</y><d>2021-08-26</d><h>20:04</h><r>ribelo</r><a href="https://github.com/ribelo/doxa/tree/memoized-query" target="_blank">https://github.com/ribelo/doxa/tree/memoized-query</a></z><z id="t1630008314" t="ribelo for now, everything is happening in a separate branch"><y>#</y><d>2021-08-26</d><h>20:05</h><r>ribelo</r>for now, everything is happening in a separate branch</z><z id="t1630008370" t="ribelo If you have any questions, have any ideas or find a bug, please don&apos;t hesitate to tell me"><y>#</y><d>2021-08-26</d><h>20:06</h><r>ribelo</r>If you have any questions, have any ideas or find a bug, please don&apos;t hesitate to tell me</z><z id="t1630008399" t="ribelo it is much better to work knowing that someone is watching"><y>#</y><d>2021-08-26</d><h>20:06</h><r>ribelo</r>it is much better to work knowing that someone is watching</z><z id="t1630008405" t="markaddleman 🙂"><y>#</y><d>2021-08-26</d><h>20:06</h><r>markaddleman</r><b>🙂</b></z><z id="t1630008414" t="markaddleman Yes, I agree and I&apos;m happy to provide feedback"><y>#</y><d>2021-08-26</d><h>20:06</h><r>markaddleman</r>Yes, I agree and I&apos;m happy to provide feedback</z><z id="t1630008423" t="ribelo 🙃"><y>#</y><d>2021-08-26</d><h>20:07</h><r>ribelo</r><b>🙃</b></z><z id="t1630008774" t="markaddleman regarding the meander example you provided, what build of meander are you using? I tried your solution in 602 and 643. It didn&apos;t work in either"><y>#</y><d>2021-08-26</d><h>20:12</h><r>markaddleman</r>regarding the meander example you provided, what build of meander are you using?  I tried your solution in 602 and 643.  It didn&apos;t work in either</z><z id="t1630009111" t="ribelo huh"><y>#</y><d>2021-08-26</d><h>20:18</h><r>ribelo</r>huh</z><z id="t1630009131" t="ribelo {:mvn/version &quot;0.0.643&quot;} "><y>#</y><d>2021-08-26</d><h>20:18</h><r>ribelo</r><pre>{:mvn/version &quot;0.0.643&quot;}</pre>
</z><z id="t1630009166" t="ribelo clj or cljs?"><y>#</y><d>2021-08-26</d><h>20:19</h><r>ribelo</r>clj or cljs?</z><z id="t1630009185" t="ribelo shouldn&apos;t matter, but maybe it does"><y>#</y><d>2021-08-26</d><h>20:19</h><r>ribelo</r>shouldn&apos;t matter, but maybe it does</z><z id="t1630009215" t="markaddleman clj"><y>#</y><d>2021-08-26</d><h>20:20</h><r>markaddleman</r>clj</z><z id="t1630009243" t="markaddleman Double checking that this is what works for you: (let [m {:a &quot;a&quot;, :b &quot;b&apos;&quot;} v [:a :b :c]] (m/rewrite [m v] [?m (m/gather (m/pred #(contains? ?m %) !xs))] [!xs ...])) "><y>#</y><d>2021-08-26</d><h>20:20</h><r>markaddleman</r>Double checking that this is what works for you:
<pre>(let [m {:a &quot;a&quot;, :b &quot;b&apos;&quot;} v [:a :b :c]]
    (m/rewrite [m v]
      [?m (m/gather (m/pred #(contains? ?m %) !xs))]
      [!xs ...]))</pre>
</z><z id="t1630009308" t="markaddleman Ah, it works in 643 but not in 602"><y>#</y><d>2021-08-26</d><h>20:21</h><r>markaddleman</r>Ah,  it works in 643 but not in 602</z><z id="t1630009319" t="markaddleman I screwed up earlier when testing against 643"><y>#</y><d>2021-08-26</d><h>20:21</h><r>markaddleman</r>I screwed up earlier when testing against 643</z><z id="t1630009359" t="ribelo 😉"><y>#</y><d>2021-08-26</d><h>20:22</h><r>ribelo</r><b>😉</b></z><z id="t1630009398" t="ribelo The worst thing about the meander is that it&apos;s a moving target"><y>#</y><d>2021-08-26</d><h>20:23</h><r>ribelo</r>The worst thing about the meander is that it&apos;s a moving target</z><z id="t1630009445" t="markaddleman True but it&apos;s so nice that these minor hiccups are worth it 🙂"><y>#</y><d>2021-08-26</d><h>20:24</h><r>markaddleman</r>True but it&apos;s so nice that these minor hiccups are worth it <b>🙂</b></z><z id="t1630009451" t="ribelo noprompt is doing a gigantic job on its own and it is so complicated that it is difficult to help"><y>#</y><d>2021-08-26</d><h>20:24</h><r>ribelo</r>noprompt is doing a gigantic job on its own and it is so complicated that it is difficult to help</z><z id="t1630009457" t="ribelo definitely"><y>#</y><d>2021-08-26</d><h>20:24</h><r>ribelo</r>definitely</z><z id="t1630009481" t="ribelo I currently use meander for anything more complicated than get/get-in"><y>#</y><d>2021-08-26</d><h>20:24</h><r>ribelo</r>I currently use meander for anything more complicated than <code>get/get-in</code></z><z id="t1630019205" t="ribelo I wonder how it can be written better and more efficiently (m/rewrite {:a 1 :db/id 1} {(m/keyword _ &quot;id&quot; :as ?k) ?v &amp; _} [?k ?v] {_ _ &amp; ?more} (m/cata ?more) _ false) in this form is 10x slower than a simple clojure loop"><y>#</y><d>2021-08-26</d><h>23:06</h><w>ribelo</w>I wonder how it can be written better and more efficiently
<pre>(m/rewrite {:a 1 :db/id 1}
  {(m/keyword _ &quot;id&quot; :as ?k) ?v &amp; _}
  [?k ?v]
  {_ _ &amp; ?more}
  (m/cata ?more)
  _ false)</pre>
in this form is 10x slower than a simple clojure loop</z><z id="t1630019502" t="ribelo (m/rewrite {:a 1 :db/id 1} (m/scan [(m/keyword _ &quot;id&quot; :as ?k) ?v]) [?k ?v] _ false) this, on the other hand, is only 3x slower"><y>#</y><d>2021-08-26</d><h>23:11</h><w>ribelo</w><pre>(m/rewrite {:a 1 :db/id 1}
    (m/scan [(m/keyword _ &quot;id&quot; :as ?k) ?v])
    [?k ?v]
    _ false)</pre>
this, on the other hand, is only 3x slower</z><z id="t1630069697" t="markaddleman I found some time this morning to improve meander&apos;s build. See https://github.com/noprompt/meander/pull/200 The key fix is to produce a slim jar"><y>#</y><d>2021-08-27</d><h>13:08</h><w>markaddleman</w>I found some time this morning to improve meander&apos;s build.  See <a href="https://github.com/noprompt/meander/pull/200" target="_blank">https://github.com/noprompt/meander/pull/200</a>  The key fix is to produce a slim jar</z><z id="t1630080782" t="noprompt [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] This is awesome! 🙂"><y>#</y><d>2021-08-27</d><h>16:13</h><w>noprompt</w><a>@markaddleman</a> This is awesome! <b>🙂</b></z><z id="t1630082081" t="noprompt I keep getting this message Error building classpath. Library io.github.clojure/tools.build has missing :sha in coordinate. "><y>#</y><d>2021-08-27</d><h>16:34</h><w>noprompt</w>I keep getting this message
<pre>Error building classpath. Library io.github.clojure/tools.build has missing :sha in coordinate.</pre>
</z><z id="t1630083520" t="noprompt https://clojars.org/meander/epsilon"><y>#</y><d>2021-08-27</d><h>16:58</h><w>noprompt</w><a href="https://clojars.org/meander/epsilon" target="_blank">https://clojars.org/meander/epsilon</a></z><z id="t1630083793" t="noprompt [:attrs {:href &quot;/_/_/users/U09LZR36F&quot;}] ☝️ new release. I don’t see Clojure in the jar. 🙂"><y>#</y><d>2021-08-27</d><h>17:03</h><w>noprompt</w><a>@dominicm</a> <b>☝️</b> new release. I don’t see Clojure in the jar. <b>🙂</b></z><z id="t1630083803" t="noprompt Thank [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] for that! 🙂"><y>#</y><d>2021-08-27</d><h>17:03</h><w>noprompt</w>Thank <a>@markaddleman</a> for that! <b>🙂</b></z><z id="t1630085715" t="noprompt I made a tweak to have the deploy part optional. bin/build-release # Build the jar bin/build-release deploy # Build the jar and attempt to deploy it "><y>#</y><d>2021-08-27</d><h>17:35</h><w>noprompt</w>I made a tweak to have the deploy part optional.
<pre>bin/build-release        # Build the jar
bin/build-release deploy # Build the jar and attempt to deploy it</pre>
</z><z id="t1630085770" t="noprompt This is like 900% better than what was there before."><y>#</y><d>2021-08-27</d><h>17:36</h><w>noprompt</w>This is like 900% better than what was there before.</z><z id="t1630085790" t="noprompt I’m so happy today. lein deploy clojars was a headache."><y>#</y><d>2021-08-27</d><h>17:36</h><w>noprompt</w>I’m so happy today. <code>lein deploy clojars</code> was a headache.</z><z id="t1630154509" t="dominicm [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] Great, time to improve the security of CSPs!"><y>#</y><d>2021-08-28</d><h>12:41</h><w>dominicm</w><a>@noprompt</a> Great, time to improve the security of CSPs!</z><z id="t1630258947" t="dominicm Unrelated to my other project, I&apos;m evaluating pattern matching in an open world context based on something like best-fit. Meander is a macro in current design, is there a version where pattern matching is compiled to a value that&apos;s run through an interpreter of some kind? My thinking is to avoid eval after adding a new pattern, sorting and compiling."><y>#</y><d>2021-08-29</d><h>17:42</h><w>dominicm</w>Unrelated to my other project, I&apos;m evaluating pattern matching in an open world context based on something like best-fit.

Meander is a macro in current design, is there a version where pattern matching is compiled to a value that&apos;s run through an interpreter of some kind?  My thinking is to avoid <code>eval</code> after adding a new pattern, sorting and compiling.</z><z id="t1630259602" t="ribelo meander.interpreter.epsilon"><y>#</y><d>2021-08-29</d><h>17:53</h><r>ribelo</r><code>meander.interpreter.epsilon</code></z><z id="t1630259933" t="delaguardo Unrelated to meander but here&apos;s my attempt to create macro-free pattern matching library https://github.com/xapix-io/matchete"><y>#</y><d>2021-08-29</d><h>17:58</h><r>delaguardo</r>Unrelated to meander but here&apos;s my attempt to create macro-free pattern matching library <a href="https://github.com/xapix-io/matchete" target="_blank">https://github.com/xapix-io/matchete</a></z><z id="t1630272793" t="dominicm [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] that&apos;s great, thanks. I&apos;d missed that!"><y>#</y><d>2021-08-29</d><h>21:33</h><r>dominicm</r><a>@U0BBFDED7</a> that&apos;s great, thanks.  I&apos;d missed that!</z><z id="t1630272868" t="dominicm [:attrs {:href &quot;/_/_/users/U04V4KLKC&quot;}] I considered matchete but I&apos;m unclear on the performance characteristics. Meander has a lot of optimizations in reducing redundant checks."><y>#</y><d>2021-08-29</d><h>21:34</h><r>dominicm</r><a>@U04V4KLKC</a> I considered matchete but I&apos;m unclear on the performance characteristics.  Meander has a lot of optimizations in reducing redundant checks.</z><z id="t1630272916" t="ribelo np"><y>#</y><d>2021-08-29</d><h>21:35</h><r>ribelo</r>np</z><z id="t1630273049" t="ribelo however the interpreter is rather difficult to use and the performance sucks"><y>#</y><d>2021-08-29</d><h>21:37</h><r>ribelo</r>however the interpreter is rather difficult to use and the performance sucks</z><z id="t1630273055" t="ribelo [:attrs {:href &quot;/_/_/users/U09LZR36F&quot;}]"><y>#</y><d>2021-08-29</d><h>21:37</h><r>ribelo</r><a>@U09LZR36F</a></z><z id="t1630273104" t="ribelo meander&apos;s super optimizations have no way of working on runetime"><y>#</y><d>2021-08-29</d><h>21:38</h><r>ribelo</r>meander&apos;s super optimizations have no way of working on runetime</z><z id="t1630274773" t="dominicm Oh, that&apos;s a shame [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] . I&apos;d hoped it&apos;d be possible to do analysis on the forms to determine redundant paths... The machinery for those optimizations is all there, so perhaps that&apos;s possible in a future update."><y>#</y><d>2021-08-29</d><h>22:06</h><r>dominicm</r>Oh, that&apos;s a shame <a>@U0BBFDED7</a>. I&apos;d hoped it&apos;d be possible to do analysis on the forms to determine redundant paths... The machinery for those optimizations is all there, so perhaps that&apos;s possible in a future update.</z><z id="t1630338524" t="noprompt The performance of the interpreter can be improved. It probably will never get as close to the performance of the compiled code but it can get closer. At the moment, I don’t think the interpreter does any optimizations. Since the interpreter is built e.g. it “compiles” a function, it is possible to eliminate many redundancies."><y>#</y><d>2021-08-30</d><h>15:48</h><r>noprompt</r>The performance of the interpreter can be improved. It probably will never get as close to the performance of the compiled code but it can get closer. At the moment, I don’t think the interpreter does any optimizations. Since the interpreter is built e.g. it “compiles” a function, it is possible to eliminate many redundancies.</z><z id="t1630331480" t="ribelo Is there any way to catch exception inside lhs ?"><y>#</y><d>2021-08-30</d><h>13:51</h><w>ribelo</w>Is there any way to catch exception inside <code>lhs</code>?</z><z id="t1630331560" t="ribelo idiotic example (m/rewrite &quot;foo&quot; (try (m/pred neg? ?x)) ?x) "><y>#</y><d>2021-08-30</d><h>13:52</h><w>ribelo</w>idiotic example
<pre>(m/rewrite &quot;foo&quot;
  (try (m/pred neg? ?x)) ?x)</pre>
</z><z id="t1630332351" t="ribelo can be done this way, but maybe it can be done simpler? (m/match &quot;foo&quot; (m/and ?x (m/guard (catching (zero? ?x)))) ?x _ false) "><y>#</y><d>2021-08-30</d><h>14:05</h><w>ribelo</w>can be done this way, but maybe it can be done simpler?
<pre>(m/match &quot;foo&quot;
  (m/and ?x (m/guard (catching (zero? ?x)))) ?x
  _ false)</pre>
</z><z id="t1630338622" t="noprompt [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] are you asking if m/pred can use try /`catch`?"><y>#</y><d>2021-08-30</d><h>15:50</h><w>noprompt</w><a>@huxley</a> are you asking if <code>m/pred</code> can use <code>try</code>/`catch`?</z><z id="t1630341260" t="ribelo Yes"><y>#</y><d>2021-08-30</d><h>16:34</h><w>ribelo</w>Yes</z><z id="t1630428829" t="noprompt Looks like we got a tip on eliminating that warning."><y>#</y><d>2021-08-31</d><h>16:53</h><w>noprompt</w>Looks like we got a tip on eliminating that warning.</z><z id="t1630444987" t="dominicm Something I&apos;d be interested in is a (m/case) where I solemnly swear there&apos;s no overlap &amp; I don&apos;t care about order. I have a (m/match) like: (m/match {::anom/category ::anom/unavailable} {:status 503} {::anom/category ::anom/interrupted} {:status 500 :retry? true}) Which then generates one big fast case statement. However, if I switch each statement to an m/or (m/or {::anom/category ::anom/unavailable} {:exoscale.ex/type :exoscale.ex/unavailable}) {:status 503} because m/match preserves order, it degrades to (essentially) a cond check (kinda, it uses case with default causes to fall back onto other keys). I haven&apos;t benched the performance, but I&apos;m assuming it&apos;s slower than a pair of case statements."><y>#</y><d>2021-08-31</d><h>21:23</h><w>dominicm</w>Something I&apos;d be interested in is a <code>(m/case)</code> where I solemnly swear there&apos;s no overlap &amp; I don&apos;t care about order.

I have a <code>(m/match)</code> like:

<pre>(m/match
  {::anom/category ::anom/unavailable} {:status 503}
  {::anom/category ::anom/interrupted} {:status 500
                                        :retry? true})</pre>
Which then generates one big fast <code>case</code> statement.  However, if I switch each statement to an <code>m/or</code>

<pre>(m/or {::anom/category ::anom/unavailable}
      {:exoscale.ex/type :exoscale.ex/unavailable}) {:status 503}</pre>
because m/match preserves order, it degrades to (essentially) a <code>cond</code> check (kinda, it uses case with default causes to fall back onto other keys).

I haven&apos;t benched the performance, but I&apos;m assuming it&apos;s slower than a pair of <code>case</code> statements.</z><z id="t1630445013" t="dominicm For now, I&apos;ll probably copy/paste as my then is pretty small."><y>#</y><d>2021-08-31</d><h>21:23</h><w>dominicm</w>For now, I&apos;ll probably copy/paste as my <code>then</code> is pretty small.</z><z id="t1630455074" t="ribelo I don&apos;t think there is anything that can&apos;t be done in meander under 100 lines of code 🙃"><y>#</y><d>2021-09-01</d><h>00:11</h><w>ribelo</w>I don&apos;t think there is anything that can&apos;t be done in meander under 100 lines of code <b>🙃</b></z><z id="t1630524223" t="noprompt This is great! 🙂"><y>#</y><d>2021-09-01</d><h>19:23</h><r>noprompt</r>This is great! <b>🙂</b></z><z id="t1630455083" t="ribelo https://github.com/noprompt/meander/pull/202/files"><y>#</y><d>2021-09-01</d><h>00:11</h><w>ribelo</w><a href="https://github.com/noprompt/meander/pull/202/files" target="_blank">https://github.com/noprompt/meander/pull/202/files</a></z><z id="t1630524136" t="noprompt lol"><y>#</y><d>2021-09-01</d><h>19:22</h><w>noprompt</w>lol</z><z id="t1630524648" t="noprompt I should fish out one the things I made to generate JavaScript."><y>#</y><d>2021-09-01</d><h>19:30</h><w>noprompt</w>I should fish out one the things I made to generate JavaScript.</z><z id="t1630525003" t="ribelo in general, the great tragedy of meander is that most of the clojure community does not love macros as it should"><y>#</y><d>2021-09-01</d><h>19:36</h><w>ribelo</w>in general, the great tragedy of meander is that most of the clojure community does not love macros as it should</z><z id="t1630525047" t="ribelo I keep hitting on the sentence data &gt; functions &gt; macros"><y>#</y><d>2021-09-01</d><h>19:37</h><w>ribelo</w>I keep hitting on the sentence <code>data &gt; functions &gt; macros</code></z><z id="t1630525201" t="ribelo and that&apos;s probably true in terms of long-term project maintenance, which I have no idea about yet but in terms of pure enjoyment, imho macros &gt; yesterday&apos;s pizza &gt; functions &gt; data"><y>#</y><d>2021-09-01</d><h>19:40</h><w>ribelo</w>and that&apos;s probably true in terms of long-term project maintenance, which I have no idea about yet

but in terms of pure enjoyment, imho <code>macros &gt; yesterday&apos;s pizza &gt; functions &gt; data</code></z><z id="t1630589474" t="jgdavey I’m attempted to do something like a “left” join, but there’s definitely a couple of issues with my attempt, as you can see. What’s the right way to think of this?"><y>#</y><d>2021-09-02</d><h>13:31</h><w>jgdavey</w>I’m attempted to do something like a “left” join, but there’s definitely a couple of issues with my attempt, as you can see. What’s the right way to think of this?</z><z id="t1630591478" t="schmee this might help! https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#the-maybe-pattern"><y>#</y><d>2021-09-02</d><h>14:04</h><r>schmee</r>this might help! <a href="https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#the-maybe-pattern" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#the-maybe-pattern</a></z><z id="t1630598903" t="jgdavey If I’m understanding correctly, this maybe pattern helps in the case of a nil , but not when a key is not present in the map. Also, I’m struggling with m/scan or if what I really want is m/cata . Any intuition on when to use those?"><y>#</y><d>2021-09-02</d><h>16:08</h><r>jgdavey</r>If I’m understanding correctly, this maybe pattern helps in the case of a <code>nil</code>, but not when a key is not present in the map.

Also, I’m struggling with <code>m/scan</code> or if what I really want is <code>m/cata</code>. Any intuition on when to use those?</z><z id="t1630601491" t="jgdavey It looks like this is what I’m looking for: (m/rewrite data {:name ?name :categories [{:category-name !cat-name :id !cat-id} ...] :sub-categories ?subs} {:name ?name :categories [{:name !cat-name :sub-categories (m/app get ?subs !cat-id)} ...]})"><y>#</y><d>2021-09-02</d><h>16:51</h><r>jgdavey</r>It looks like this is what I’m looking for:

<pre>(m/rewrite data
    {:name ?name
     :categories [{:category-name !cat-name
                   :id !cat-id} ...]
     :sub-categories ?subs}

    {:name ?name
     :categories [{:name !cat-name
                   :sub-categories (m/app get ?subs !cat-id)}
                  ...]})</pre></z><z id="t1631233536" t="ribelo (m/rewrites {:x {:y [:a :b :c] :q [:a :b :c]}} {!xs {!ys (m/scan :b)}} [[!xs !ys] ...]) Is there any way to do this without using rewriteS but with just simple rewrite ?"><y>#</y><d>2021-09-10</d><h>00:25</h><w>ribelo</w><pre>(m/rewrites {:x {:y [:a :b :c]
                         :q [:a :b :c]}}
          {!xs {!ys (m/scan :b)}}
          [[!xs !ys] ...])</pre>
Is there any way to do this without using <code>rewriteS</code> but with just simple <code>rewrite</code>?</z><z id="t1631291611" t="noprompt I think. Lemme try…"><y>#</y><d>2021-09-10</d><h>16:33</h><r>noprompt</r>I think. Lemme try…</z><z id="t1631235630" t="Richie Why does it work with r1 and not with r2?"><y>#</y><d>2021-09-10</d><h>01:00</h><w>Richie</w>Why does it work with r1 and not with r2?</z><z id="t1631235703" t="Richie Sorry, I&apos;m also having trouble creating a more minimal example. I feel in over my head."><y>#</y><d>2021-09-10</d><h>01:01</h><r>Richie</r>Sorry, I&apos;m also having trouble creating a more minimal example. I feel in over my head.</z><z id="t1631236422" t="ribelo There are a multiple keys in map r2 :active and scan can&apos;t handle it"><y>#</y><d>2021-09-10</d><h>01:13</h><r>ribelo</r>There are a multiple keys in map r2 :active and scan can&apos;t handle it</z><z id="t1631236476" t="ribelo Unfortunately I&apos;m writing from my phone so I can&apos;t help you right now"><y>#</y><d>2021-09-10</d><h>01:14</h><r>ribelo</r>Unfortunately I&apos;m writing from my phone so I can&apos;t help you right now</z><z id="t1631236553" t="Richie No trouble. That&apos;s already very helpful. Thank you!"><y>#</y><d>2021-09-10</d><h>01:15</h><r>Richie</r>No trouble. That&apos;s already very helpful. Thank you!</z><z id="t1631258306" t="ribelo (let [r1 [[0 {:active {:a {:ids [{:business &quot;123&quot;}]}}}] [1 {:active {:d {:ids [{:business &quot;567&quot;}]}}}]] r2 [[0 {:active {:a {:ids [{:business &quot;123&quot;}]} :b {:ids [{:business &quot;234&quot;}]}}}] [1 {:active {:d {:ids [{:business &quot;567&quot;}]} :c {:ids [{:business &quot;678&quot;}]}}}]] f (fn [arg] (m/rewrite arg [[(m/and !xs !ys) {:active (m/map-of _ {:ids [{:business !ids}]})}] ...] [[[!xs !ids] [!ys !ids] ...]]))] (f r1) ;; [[0 &quot;123&quot;] [1 &quot;567&quot;]] (f r2) ;; [[0 &quot;123&quot;] [0 &quot;234&quot;] [1 &quot;567&quot;] [1 &quot;678&quot;]] ) "><y>#</y><d>2021-09-10</d><h>07:18</h><r>ribelo</r><pre>(let [r1 [[0 {:active {:a {:ids [{:business &quot;123&quot;}]}}}]
          [1 {:active {:d {:ids [{:business &quot;567&quot;}]}}}]]
      r2 [[0 {:active {:a {:ids [{:business &quot;123&quot;}]}
                       :b {:ids [{:business &quot;234&quot;}]}}}]
          [1 {:active {:d {:ids [{:business &quot;567&quot;}]}
                       :c {:ids [{:business &quot;678&quot;}]}}}]]
      f (fn [arg]
          (m/rewrite arg
            [[(m/and !xs !ys) {:active (m/map-of _ {:ids [{:business !ids}]})}] ...]
            [[[!xs !ids] [!ys !ids] ...]]))]
  (f r1)                                ;; [[0 &quot;123&quot;] [1 &quot;567&quot;]]
  (f r2)                                ;; [[0 &quot;123&quot;] [0 &quot;234&quot;] [1 &quot;567&quot;] [1 &quot;678&quot;]]
  )</pre>
</z><z id="t1631258346" t="ribelo Surely it can be done more simply"><y>#</y><d>2021-09-10</d><h>07:19</h><r>ribelo</r>Surely it can be done more simply</z><z id="t1631258373" t="ribelo [:attrs {:href &quot;/_/_/users/UPD88PGNT&quot;}]"><y>#</y><d>2021-09-10</d><h>07:19</h><r>ribelo</r><a>@UPD88PGNT</a></z><z id="t1631299060" t="Richie Hey. I figured some things out. First I got the answer I wanted from this smaller example: (let [r2 [{:a [{:word &quot;123&quot;} {:word &quot;abc&quot;}] :b [{:word &quot;234&quot;} {:word &quot;bcd&quot;}]}] f (fn [arg] (m/find arg (m/gather (m/map-of _ (m/gather {:word !a}))) !a))] (f r2)) ;; =&gt; [&quot;123&quot; &quot;abc&quot; &quot;234&quot; &quot;bcd&quot;] But it didn’t seem like I was doing this correctly since I think I should be able to search with a logic var instead of using a memory var like that. The example for scan gave me the idea to treat a map as a seq of MapEntry. (m/search {:x 1 :y 2 :z 3} (m/scan [?a ?b]) {?b ?a}) ;; =&gt; ({1 :x} {2 :y} {3 :z}) So then I got this working code: (let [r2 [{:a [{:word &quot;123&quot;} {:word &quot;abc&quot;}] :b [{:word &quot;234&quot;} {:word &quot;bcd&quot;}]}] f (fn [arg] (m/search arg (m/scan (m/scan [_ (m/scan {:word ?a})])) ?a))] (f r2)) ;; =&gt; (&quot;123&quot; &quot;abc&quot; &quot;234&quot; &quot;bcd&quot;) Going back to an example of my actual problem: (let [r2 [[0 {:active {:a {:ids [{:business &quot;123&quot;} {:business &quot;aha&quot;}]} :b {:ids [{:business &quot;234&quot;}]}}}] [1 {:active {:d {:ids [{:business &quot;567&quot;}]} :c {:ids [{:business &quot;678&quot;}]}}}]] f (fn [arg] (m/search arg (m/scan [?t {:active (m/scan [_ {:ids [{:business !a} ...]}])}]) [?t !a]))] (f r2)) ;; =&gt; ([0 [&quot;123&quot; &quot;aha&quot;]] [0 [&quot;234&quot;]] [1 [&quot;567&quot;]] [1 [&quot;678&quot;]]) I actually want to get a result like ([0 [“123” “aha” “234”]] [1 [“567&quot; “678”]]) but I haven’t figured it out yet. Thank you all of you for making such a sick library and for the great support."><y>#</y><d>2021-09-10</d><h>18:37</h><r>Richie</r>Hey. I figured some things out.

First I got the answer I wanted from this smaller example:

<pre>(let [r2 [{:a [{:word &quot;123&quot;}
               {:word &quot;abc&quot;}]
           :b [{:word &quot;234&quot;}
               {:word &quot;bcd&quot;}]}]
      f (fn [arg]
          (m/find
            arg
            (m/gather (m/map-of _ (m/gather {:word !a})))
            !a))]
  (f r2))
  ;; =&gt; [&quot;123&quot; &quot;abc&quot; &quot;234&quot; &quot;bcd&quot;]</pre>
But it didn’t seem like I was doing this correctly since I think I should be able to search with a logic var instead of using a memory var like that.

The example for <code>scan</code> gave me the idea to treat a map as a seq of MapEntry.

<pre>(m/search {:x 1 :y 2 :z 3}
  (m/scan [?a ?b])
  {?b ?a})
;; =&gt; ({1 :x} {2 :y} {3 :z})</pre>
So then I got this working code:
<pre>(let [r2 [{:a [{:word &quot;123&quot;}
               {:word &quot;abc&quot;}]
           :b [{:word &quot;234&quot;}
               {:word &quot;bcd&quot;}]}]
      f (fn [arg]
          (m/search
            arg
            (m/scan (m/scan [_ (m/scan {:word ?a})]))
            ?a))]
  (f r2))

  ;; =&gt; (&quot;123&quot; &quot;abc&quot; &quot;234&quot; &quot;bcd&quot;)</pre>

  Going back to an example of my actual problem:

<pre>(let [r2 [[0 {:active {:a {:ids [{:business &quot;123&quot;}
                                 {:business &quot;aha&quot;}]}
                       :b {:ids [{:business &quot;234&quot;}]}}}]
          [1 {:active {:d {:ids [{:business &quot;567&quot;}]}
                       :c {:ids [{:business &quot;678&quot;}]}}}]]
      f (fn [arg]
          (m/search
            arg
            (m/scan [?t {:active (m/scan [_ {:ids [{:business !a} ...]}])}])
            [?t !a]))]

  (f r2))
;; =&gt; ([0 [&quot;123&quot; &quot;aha&quot;]] [0 [&quot;234&quot;]] [1 [&quot;567&quot;]] [1 [&quot;678&quot;]])</pre>
I actually want to get a result like <code>([0 [“123” “aha” “234”]] [1 [“567&quot; “678”]])</code> but I haven’t figured it out yet.

Thank you all of you for making such a sick library and for the great support.</z><z id="t1631299447" t="Richie [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] Thanks for the working example. I didn’t know about map-of until I saw you use it. After that, I cloned the repo and poked around reading through some of the docstrings. Ultimately, I don’t think I want to use and since I don’t know how many things I’ll have there; I could have made a better question than to just ask why it was broken, haha. Thanks again."><y>#</y><d>2021-09-10</d><h>18:44</h><r>Richie</r><a>@U0BBFDED7</a> Thanks for the working example. I didn’t know about <code>map-of</code> until I saw you use it. After that, I cloned the repo and poked around reading through some of the docstrings. Ultimately, I don’t think I want to use <code>and</code> since I don’t know how many things I’ll have there; I could have made a better question than to just ask why it was broken, haha. Thanks again.</z><z id="t1631267299" t="Ben Sless Wanted to share something cool and ask if you think I made any mistakes or it could be improved - beta reduction of tools.analyzer ast node: (m/rewrite node {:op :invoke :args [!args ..?n] :fn {:op :fn :methods [{:fixed-arity ?n :variadic? false :form _ :arglist _ :tag _ :o-tag _ ;; rudely ignore :params [{:local _ :arg-id _ &amp; !params} ...] :body ?body} ..1]} ;; there can be only one! &amp; ?rest} {:op :let :children [:bindings :body] :bindings [{:init !args :local :let :children [:init] &amp; !params} ...] :body ?body})"><y>#</y><d>2021-09-10</d><h>09:48</h><w>Ben Sless</w>Wanted to share something cool and ask if you think I made any mistakes or it could be improved - beta reduction of tools.analyzer ast node:
<pre>(m/rewrite
    node
    {:op :invoke
     :args [!args ..?n]
     :fn {:op :fn
          :methods
          [{:fixed-arity ?n
            :variadic? false
            :form _ :arglist _ :tag _ :o-tag _ ;; rudely ignore
            :params
            [{:local _ :arg-id _
              &amp; !params} ...]
            :body ?body}
           ..1]} ;; there can be only one!
     &amp; ?rest}
    {:op :let
     :children [:bindings :body]
     :bindings
     [{:init !args
       :local :let
       :children [:init]
       &amp; !params} ...]
     :body ?body})</pre></z><z id="t1631270530" t="ribelo I don&apos;t know what it does but it looks cool"><y>#</y><d>2021-09-10</d><h>10:42</h><r>ribelo</r>I don&apos;t know what it does but it looks cool</z><z id="t1631270624" t="ribelo _ can be omitted if they are not for readability"><y>#</y><d>2021-09-10</d><h>10:43</h><r>ribelo</r><code>_</code> can be omitted if they are not for readability</z><z id="t1631270658" t="ribelo whereas, if these are the required things that should be there, then it&apos;s a good idea to wrap in (m/some)"><y>#</y><d>2021-09-10</d><h>10:44</h><r>ribelo</r>whereas, if these are the required things that should be there, then it&apos;s a good idea to wrap in <code>(m/some)</code></z><z id="t1631274785" t="Ben Sless It&apos;s a poor man&apos;s dissoc but you&apos;re right, I should rewrite it"><y>#</y><d>2021-09-10</d><h>11:53</h><r>Ben Sless</r>It&apos;s a poor man&apos;s dissoc but you&apos;re right, I should rewrite it</z><z id="t1631274818" t="Ben Sless what it does: ((fn [x] B) E) -&gt; (let [x E] B)"><y>#</y><d>2021-09-10</d><h>11:53</h><r>Ben Sless</r>what it does:
<code>((fn [x] B) E)</code> -&gt; <code>(let [x E] B)</code></z><z id="t1631291676" t="noprompt Awesome! This is definitely one of the use cases I was designing for. 🙂"><y>#</y><d>2021-09-10</d><h>16:34</h><r>noprompt</r>Awesome! This is definitely one of the use cases I was designing for. <b>🙂</b></z><z id="t1631291879" t="Ben Sless Success :)"><y>#</y><d>2021-09-10</d><h>16:37</h><r>Ben Sless</r>Success :)</z><z id="t1631280329" t="Ben Sless Is it possible to perform a recursive search and substitution inside a bound variable?"><y>#</y><d>2021-09-10</d><h>13:25</h><w>Ben Sless</w>Is it possible to perform a recursive search and substitution inside a bound variable?</z><z id="t1631280767" t="schmee not entirely sure this is what you’re looking for but m/cata might help: https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#recursion-reduction-and-aggregation"><y>#</y><d>2021-09-10</d><h>13:32</h><r>schmee</r>not entirely sure this is what you’re looking for but <code>m/cata</code> might help: <a href="https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#recursion-reduction-and-aggregation" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#recursion-reduction-and-aggregation</a></z><z id="t1631281479" t="Ben Sless cata still assumes I know the shape of the input (sort of). In the case where I don&apos;t want to specify all the possible patterns, is there a generic walk ?"><y>#</y><d>2021-09-10</d><h>13:44</h><r>Ben Sless</r><code>cata</code> still assumes I know the shape of the input (sort of). In the case where I don&apos;t want to specify all the possible patterns, is there a generic <code>walk</code>?</z><z id="t1631282180" t="ribelo Try strategy namespace"><y>#</y><d>2021-09-10</d><h>13:56</h><r>ribelo</r>Try <code>strategy</code> namespace</z><z id="t1631282303" t="ribelo Probably bottom-up is what you&apos;re looking for"><y>#</y><d>2021-09-10</d><h>13:58</h><r>ribelo</r>Probably <code>bottom-up</code> is what you&apos;re looking for</z><z id="t1631282971" t="Ben Sless I&apos;d still have to specify all the patterns I want to search over 😞"><y>#</y><d>2021-09-10</d><h>14:09</h><r>Ben Sless</r>I&apos;d still have to specify all the patterns I want to search over <b>😞</b></z><z id="t1631291755" t="noprompt Ben, are you able to layout in more detail what your idea/goal is? I’m not sure I totally follow."><y>#</y><d>2021-09-10</d><h>16:35</h><r>noprompt</r>Ben, are you able to layout in more detail what your idea/goal is? I’m not sure I totally follow.</z><z id="t1631291855" t="Ben Sless Sure, I&apos;m trying to implement optimization passes on tools.analyzer output. Beta reduction, copy and constant propagation"><y>#</y><d>2021-09-10</d><h>16:37</h><r>Ben Sless</r>Sure, I&apos;m trying to implement optimization passes on tools.analyzer output. Beta reduction, copy and constant propagation</z><z id="t1631292197" t="noprompt Cool. I follow this. I was looking for an example/sketch (could be contrived) of the problem and what you would like the solution to look like/the result, etc."><y>#</y><d>2021-09-10</d><h>16:43</h><r>noprompt</r>Cool. I follow this. I was looking for an example/sketch (could be contrived) of the problem and what you would like the solution to look like/the result, etc.</z><z id="t1631292298" t="noprompt We do need a more general walking mechanism that isn’t strategy based. I have some ideas about that but none that I can invest time in right now."><y>#</y><d>2021-09-10</d><h>16:44</h><r>noprompt</r>We do need a more general walking mechanism that isn’t strategy based. I have some ideas about that but none that I can invest time in right now.</z><z id="t1631292971" t="noprompt One of the things that I’ve done in the past is write rules like this (m/rewrite form [::special def ?tail] {:type :def ,,,} ((m/pred special-symbol? ?symbol) &amp; tail) (m/cata [::special ?symbol ?tail])) essentially emulating a function/function call inside the system."><y>#</y><d>2021-09-10</d><h>16:56</h><r>noprompt</r>One of the things that I’ve done in the past is write rules like this
<pre>(m/rewrite form
  [::special def ?tail]
  {:type :def  ,,,}

  ((m/pred special-symbol? ?symbol) &amp; tail)
  (m/cata [::special ?symbol ?tail]))</pre>
essentially emulating a function/function call inside the system.</z><z id="t1631293183" t="Ben Sless You could write a HOF which returns a walker"><y>#</y><d>2021-09-10</d><h>16:59</h><r>Ben Sless</r>You could write a HOF which returns a walker</z><z id="t1631293331" t="Ben Sless Bottom up and top down are a special case of post/pre walk derived from it"><y>#</y><d>2021-09-10</d><h>17:02</h><r>Ben Sless</r>Bottom up and top down are a special case of post/pre walk derived from it</z><z id="t1631293625" t="noprompt Yeah."><y>#</y><d>2021-09-10</d><h>17:07</h><r>noprompt</r>Yeah.</z><z id="t1631295445" t="noprompt I wanted to mention earlier, Github discussions are available too if you want to jot down something a bit more long form that lays out the full scope of the problem."><y>#</y><d>2021-09-10</d><h>17:37</h><r>noprompt</r>I wanted to mention earlier, Github discussions are available too if you want to jot down something a bit more long form that lays out the full scope of the problem.</z><z id="t1631296930" t="Ben Sless Probably will, thank you 🙂"><y>#</y><d>2021-09-10</d><h>18:02</h><r>Ben Sless</r>Probably will, thank you <b>🙂</b></z><z id="t1631299692" t="Richie Oh nice. I was upset that slack limits the conversation history since I’d like to dig through the history for more examples."><y>#</y><d>2021-09-10</d><h>18:48</h><r>Richie</r>Oh nice. I was upset that slack limits the conversation history since I’d like to dig through the history for more examples.</z><z id="t1631300877" t="noprompt Please post there. And, if you do, share the link here as well."><y>#</y><d>2021-09-10</d><h>19:07</h><r>noprompt</r>Please post there. And, if you do, share the link here as well.</z><z id="t1631300985" t="noprompt Honestly, I should probably do that too."><y>#</y><d>2021-09-10</d><h>19:09</h><r>noprompt</r>Honestly, I should probably do that too.</z><z id="t1631302001" t="Ben Sless You could probably make half a cookbook by scraping the history of this channel on the log. zulip?"><y>#</y><d>2021-09-10</d><h>19:26</h><r>Ben Sless</r>You could probably make half a cookbook by scraping the history of this channel on the log. zulip?</z><z id="t1631516720" t="Ben Sless OPened a discussion for both"><y>#</y><d>2021-09-13</d><h>07:05</h><r>Ben Sless</r>OPened a discussion for both</z><z id="t1631717558" t="Richie Just found https://clojurians-log.clojureverse.org/meander a log of clojurians slack."><y>#</y><d>2021-09-15</d><h>14:52</h><r>Richie</r>Just found <a href="https://clojurians-log.clojureverse.org/meander" target="_blank">https://clojurians-log.clojureverse.org/meander</a> a log of clojurians slack.</z><z id="t1631299060" t="Richie Hey. I figured some things out. First I got the answer I wanted from this smaller example: (let [r2 [{:a [{:word &quot;123&quot;} {:word &quot;abc&quot;}] :b [{:word &quot;234&quot;} {:word &quot;bcd&quot;}]}] f (fn [arg] (m/find arg (m/gather (m/map-of _ (m/gather {:word !a}))) !a))] (f r2)) ;; =&gt; [&quot;123&quot; &quot;abc&quot; &quot;234&quot; &quot;bcd&quot;] But it didn’t seem like I was doing this correctly since I think I should be able to search with a logic var instead of using a memory var like that. The example for scan gave me the idea to treat a map as a seq of MapEntry. (m/search {:x 1 :y 2 :z 3} (m/scan [?a ?b]) {?b ?a}) ;; =&gt; ({1 :x} {2 :y} {3 :z}) So then I got this working code: (let [r2 [{:a [{:word &quot;123&quot;} {:word &quot;abc&quot;}] :b [{:word &quot;234&quot;} {:word &quot;bcd&quot;}]}] f (fn [arg] (m/search arg (m/scan (m/scan [_ (m/scan {:word ?a})])) ?a))] (f r2)) ;; =&gt; (&quot;123&quot; &quot;abc&quot; &quot;234&quot; &quot;bcd&quot;) Going back to an example of my actual problem: (let [r2 [[0 {:active {:a {:ids [{:business &quot;123&quot;} {:business &quot;aha&quot;}]} :b {:ids [{:business &quot;234&quot;}]}}}] [1 {:active {:d {:ids [{:business &quot;567&quot;}]} :c {:ids [{:business &quot;678&quot;}]}}}]] f (fn [arg] (m/search arg (m/scan [?t {:active (m/scan [_ {:ids [{:business !a} ...]}])}]) [?t !a]))] (f r2)) ;; =&gt; ([0 [&quot;123&quot; &quot;aha&quot;]] [0 [&quot;234&quot;]] [1 [&quot;567&quot;]] [1 [&quot;678&quot;]]) I actually want to get a result like ([0 [“123” “aha” “234”]] [1 [“567&quot; “678”]]) but I haven’t figured it out yet. Thank you all of you for making such a sick library and for the great support."><y>#</y><d>2021-09-10</d><h>18:37</h><w>Richie</w>Hey. I figured some things out.

First I got the answer I wanted from this smaller example:

<pre>(let [r2 [{:a [{:word &quot;123&quot;}
               {:word &quot;abc&quot;}]
           :b [{:word &quot;234&quot;}
               {:word &quot;bcd&quot;}]}]
      f (fn [arg]
          (m/find
            arg
            (m/gather (m/map-of _ (m/gather {:word !a})))
            !a))]
  (f r2))
  ;; =&gt; [&quot;123&quot; &quot;abc&quot; &quot;234&quot; &quot;bcd&quot;]</pre>
But it didn’t seem like I was doing this correctly since I think I should be able to search with a logic var instead of using a memory var like that.

The example for <code>scan</code> gave me the idea to treat a map as a seq of MapEntry.

<pre>(m/search {:x 1 :y 2 :z 3}
  (m/scan [?a ?b])
  {?b ?a})
;; =&gt; ({1 :x} {2 :y} {3 :z})</pre>
So then I got this working code:
<pre>(let [r2 [{:a [{:word &quot;123&quot;}
               {:word &quot;abc&quot;}]
           :b [{:word &quot;234&quot;}
               {:word &quot;bcd&quot;}]}]
      f (fn [arg]
          (m/search
            arg
            (m/scan (m/scan [_ (m/scan {:word ?a})]))
            ?a))]
  (f r2))

  ;; =&gt; (&quot;123&quot; &quot;abc&quot; &quot;234&quot; &quot;bcd&quot;)</pre>

  Going back to an example of my actual problem:

<pre>(let [r2 [[0 {:active {:a {:ids [{:business &quot;123&quot;}
                                 {:business &quot;aha&quot;}]}
                       :b {:ids [{:business &quot;234&quot;}]}}}]
          [1 {:active {:d {:ids [{:business &quot;567&quot;}]}
                       :c {:ids [{:business &quot;678&quot;}]}}}]]
      f (fn [arg]
          (m/search
            arg
            (m/scan [?t {:active (m/scan [_ {:ids [{:business !a} ...]}])}])
            [?t !a]))]

  (f r2))
;; =&gt; ([0 [&quot;123&quot; &quot;aha&quot;]] [0 [&quot;234&quot;]] [1 [&quot;567&quot;]] [1 [&quot;678&quot;]])</pre>
I actually want to get a result like <code>([0 [“123” “aha” “234”]] [1 [“567&quot; “678”]])</code> but I haven’t figured it out yet.

Thank you all of you for making such a sick library and for the great support.</z><z id="t1631302921" t="Richie I put my question in gh discussions. https://github.com/noprompt/meander/discussions/208"><y>#</y><d>2021-09-10</d><h>19:42</h><w>Richie</w>I put my question in gh discussions.
<a href="https://github.com/noprompt/meander/discussions/208" target="_blank">https://github.com/noprompt/meander/discussions/208</a></z><z id="t1631303374" t="noprompt &gt; Hey! I hope you’re having a great day. This sentence. 😄"><y>#</y><d>2021-09-10</d><h>19:49</h><w>noprompt</w>&gt;  Hey! I hope you’re having a great day.
This sentence. <b>😄</b></z><z id="t1631303424" t="noprompt Also the title. High marks. 100%"><y>#</y><d>2021-09-10</d><h>19:50</h><w>noprompt</w>Also the title. High marks. 100%</z><z id="t1631304124" t="Richie Haha, thanks. I was feeling punchy after punching away at the same problem all day."><y>#</y><d>2021-09-10</d><h>20:02</h><r>Richie</r>Haha, thanks. I was feeling punchy after punching away at the same problem all day.</z><z id="t1631304293" t="Ben Sless New meaning of &quot;using X in anger&quot;?"><y>#</y><d>2021-09-10</d><h>20:04</h><r>Ben Sless</r>New meaning of &quot;using X in anger&quot;?</z><z id="t1631304386" t="noprompt Ah, yeah, that can be frustrating. And I know there is a learning curve. Buuuut, hopefully, we can help. 🙂"><y>#</y><d>2021-09-10</d><h>20:06</h><r>noprompt</r>Ah, yeah, that can be frustrating. And I know there is a learning curve. Buuuut, hopefully, we can help. <b>🙂</b></z><z id="t1631304786" t="Ben Sless One day I&apos;ll understand m/cata then I&apos;ll be able to just communicate telepathically or something"><y>#</y><d>2021-09-10</d><h>20:13</h><r>Ben Sless</r>One day I&apos;ll understand <code>m/cata</code> then I&apos;ll be able to just communicate telepathically or something</z><z id="t1631305031" t="Richie It seems like the learning curve is steeper than most new things that I encounter while programming but the payoff also seems much greater than the usual new thing. So much so that the ratio of cost to benefit weighs heavily in favor of learning and using it. It’s existence and this community are also gifts so I can’t begin to be critical. I’m not actually angry; I’m just playing it up for the humor. 🙂"><y>#</y><d>2021-09-10</d><h>20:17</h><r>Richie</r>It seems like the learning curve is steeper than most new things that I encounter while programming but the payoff also seems much greater than the usual new thing. So much so that the ratio of cost to benefit weighs heavily in favor of learning and using it. It’s existence and this community are also gifts so I can’t begin to be critical. I’m not actually angry; I’m just playing it up for the humor. <b>🙂</b></z><z id="t1631305847" t="noprompt &gt; the learning curve is steeper … the ratio of cost to benefit weighs heavily in favor of learning and using it This is a perspective I think others in the channel share. Improving the overall experience and reducing the learning curve/providing help are priorities. For me, the criticism is inspiring actually, I’ve just had a rough time the past year dealing with burn out from software, and $pandemic_related_reasons ."><y>#</y><d>2021-09-10</d><h>20:30</h><r>noprompt</r>&gt;  the learning curve is steeper … the ratio of cost to benefit weighs heavily in favor of learning and using it
This is a perspective I think others in the channel share. Improving the overall experience and reducing the learning curve/providing help are priorities. For me, the criticism is inspiring actually, I’ve just had a rough time the past year dealing with burn out from software, and <code>$pandemic_related_reasons</code> .</z><z id="t1631305905" t="noprompt But I will say, this channel is awesome. I’m really proud of the folks in here. People are helpful and courteous. “No stupid questions” kind of attitude. 🙂"><y>#</y><d>2021-09-10</d><h>20:31</h><r>noprompt</r>But I will say, this channel is awesome. I’m really proud of the folks in here. People are helpful and courteous. “No stupid questions” kind of attitude. <b>🙂</b></z><z id="t1631305917" t="noprompt This channel has kept me going!"><y>#</y><d>2021-09-10</d><h>20:31</h><r>noprompt</r>This channel has kept me going!</z><z id="t1631305938" t="noprompt Also, I will try and fill in some explaining on my replies to your question."><y>#</y><d>2021-09-10</d><h>20:32</h><r>noprompt</r>Also, I will try and fill in some explaining on my replies to your question.</z><z id="t1631735780" t="ribelo regarding the learning curve, I don&apos;t think there is anything that can be done about it"><y>#</y><d>2021-09-15</d><h>19:56</h><r>ribelo</r>regarding the learning curve, I don&apos;t think there is anything that can be done about it</z><z id="t1631735797" t="ribelo meander is simple but not easy"><y>#</y><d>2021-09-15</d><h>19:56</h><r>ribelo</r>meander is simple but not easy</z><z id="t1631735882" t="ribelo some concepts like cata or with just have to pop in our head"><y>#</y><d>2021-09-15</d><h>19:58</h><r>ribelo</r>some concepts like <code>cata</code> or <code>with</code> just have to pop in our head</z><z id="t1631736037" t="Ben Sless Is there anything I can read which would help me understand cata? Sometimes I find original papers on subjects make it click for me. Did so for HAMTs and CSP"><y>#</y><d>2021-09-15</d><h>20:00</h><r>Ben Sless</r>Is there anything I can read which would help me understand cata? Sometimes I find original papers on subjects make it click for me. Did so for HAMTs and CSP</z><z id="t1631736058" t="ribelo cata is simply recursion"><y>#</y><d>2021-09-15</d><h>20:00</h><r>ribelo</r>cata is simply recursion</z><z id="t1631736114" t="ribelo of the non-obvious things that came out of using cata was discovering that you can put the processed data into a vector, where the first element is whatever tells you what to do with it"><y>#</y><d>2021-09-15</d><h>20:01</h><r>ribelo</r>of the non-obvious things that came out of using cata was discovering that you can put the processed data into a vector, where the first element is whatever tells you what to do with it</z><z id="t1631736212" t="Ben Sless I understand all of these words, but have no way to translate them to actionable knowledge yet. Maybe 11pm is not the time"><y>#</y><d>2021-09-15</d><h>20:03</h><r>Ben Sless</r>I understand all of these words, but have no way to translate them to actionable knowledge yet.
Maybe 11pm is not the time</z><z id="t1631736321" t="ribelo I guess it just requires some practice"><y>#</y><d>2021-09-15</d><h>20:05</h><r>ribelo</r>I guess it just requires some practice</z><z id="t1631736698" t="ribelo I would start by looking at all the examples that are in the meander repo. Reading through all the tests also gave me a lot."><y>#</y><d>2021-09-15</d><h>20:11</h><r>ribelo</r>I would start by looking at all the examples that are in the meander repo. Reading through all the tests also gave me a lot.</z><z id="t1631736871" t="Ben Sless I read the cata tests several times. The trivial cases made sense but didn&apos;t click for me yet. No worries, I shall bang my head against that wall until it breaks"><y>#</y><d>2021-09-15</d><h>20:14</h><r>Ben Sless</r>I read the cata tests several times. The trivial cases made sense but didn&apos;t click for me yet.
No worries, I shall bang my head against that wall until it breaks</z><z id="t1631736973" t="ribelo I&apos;ve been through it, and after some head-banging, the tinnitus even stops"><y>#</y><d>2021-09-15</d><h>20:16</h><r>ribelo</r>I&apos;ve been through it, and after some head-banging, the tinnitus even stops</z><z id="t1631737040" t="ribelo in general I appreciate your work, e.g. on malli , a lot can be learned by reading the code"><y>#</y><d>2021-09-15</d><h>20:17</h><r>ribelo</r>in general I appreciate your work, e.g. on <code>malli</code>, a lot can be learned by reading the code</z><z id="t1631737059" t="ribelo I think you have a perversion to numbers and like to speed up other people&apos;s code 🙃"><y>#</y><d>2021-09-15</d><h>20:17</h><r>ribelo</r>I think you have a perversion to numbers and like to speed up other people&apos;s code <b>🙃</b></z><z id="t1631737273" t="Ben Sless Ha, guilty"><y>#</y><d>2021-09-15</d><h>20:21</h><r>Ben Sless</r>Ha, guilty</z><z id="t1631737282" t="Ben Sless And thank you 😃"><y>#</y><d>2021-09-15</d><h>20:21</h><r>Ben Sless</r>And thank you <b>😃</b></z><z id="t1631737402" t="ribelo you&apos;ll probably find something to do once you get into the meander code"><y>#</y><d>2021-09-15</d><h>20:23</h><r>ribelo</r>you&apos;ll probably find something to do once you get into the meander code</z><z id="t1631737485" t="Ben Sless"><y>#</y><d>2021-09-15</d><h>20:24</h><r>Ben Sless</r></z><z id="t1631737542" t="Ben Sless Besides, I want to use meander to speed up other code. All the code, if possible 🙂"><y>#</y><d>2021-09-15</d><h>20:25</h><r>Ben Sless</r>Besides, I want to use meander to speed up other code. All the code, if possible <b>🙂</b></z><z id="t1631737573" t="ribelo well, that&apos;s what I&apos;m currently trying to do"><y>#</y><d>2021-09-15</d><h>20:26</h><r>ribelo</r>well, that&apos;s what I&apos;m currently trying to do</z><z id="t1631737589" t="ribelo and it&apos;s addictive"><y>#</y><d>2021-09-15</d><h>20:26</h><r>ribelo</r>and it&apos;s addictive</z><z id="t1631737593" t="Ben Sless Speed up meander or use meander to write a compiler?"><y>#</y><d>2021-09-15</d><h>20:26</h><r>Ben Sless</r>Speed up meander or use meander to write a compiler?</z><z id="t1631737620" t="ribelo yes"><y>#</y><d>2021-09-15</d><h>20:27</h><r>ribelo</r>yes</z><z id="t1631737620" t="Ben Sless &gt; and it&apos;s addictive Absolutely"><y>#</y><d>2021-09-15</d><h>20:27</h><r>Ben Sless</r>&gt; and it&apos;s addictive
Absolutely</z><z id="t1631737627" t="Ben Sless numbers go woosh"><y>#</y><d>2021-09-15</d><h>20:27</h><r>Ben Sless</r>numbers go woosh</z><z id="t1631737644" t="ribelo dopamine over 9000!!!"><y>#</y><d>2021-09-15</d><h>20:27</h><r>ribelo</r>dopamine over 9000!!!</z><z id="t1631737732" t="Ben Sless have you applied meander to tools.analyzer ast?"><y>#</y><d>2021-09-15</d><h>20:28</h><r>Ben Sless</r>have you applied meander to tools.analyzer ast?</z><z id="t1631737774" t="ribelo not yet"><y>#</y><d>2021-09-15</d><h>20:29</h><r>ribelo</r>not yet</z><z id="t1631737804" t="ribelo code in meander can be fully declarative, imho it is often much more readable than pure clojure, moreover it is easy to come back to, because, omits some concepts like cata , it is clear and understandable"><y>#</y><d>2021-09-15</d><h>20:30</h><r>ribelo</r>code in meander can be fully declarative, imho it is often much more readable than pure clojure, moreover it is easy to come back to, because, omits some concepts like <code>cata</code>, it is clear and understandable</z><z id="t1631737864" t="ribelo for now, I&apos;m learning meander mostly by writing doxa and poking around in meander itself"><y>#</y><d>2021-09-15</d><h>20:31</h><r>ribelo</r>for now, I&apos;m learning meander mostly by writing <code>doxa</code> and poking around in meander itself</z><z id="t1631738147" t="Ben Sless it seems like a very good fit. There are some Haskell papers which are relevant"><y>#</y><d>2021-09-15</d><h>20:35</h><r>Ben Sless</r>it seems like a very good fit. There are some Haskell papers which are relevant</z><z id="t1631738181" t="Ben Sless https://github.com/noprompt/meander/discussions/212 this example"><y>#</y><d>2021-09-15</d><h>20:36</h><r>Ben Sless</r><a href="https://github.com/noprompt/meander/discussions/212" target="_blank">https://github.com/noprompt/meander/discussions/212</a> this example</z><z id="t1631738249" t="ribelo wait, because I don&apos;t think I quite caught on before"><y>#</y><d>2021-09-15</d><h>20:37</h><r>ribelo</r>wait, because I don&apos;t think I quite caught on before</z><z id="t1631738284" t="ribelo You literally want to use meander to rewrite other people&apos;s code"><y>#</y><d>2021-09-15</d><h>20:38</h><r>ribelo</r>You literally want to use meander to rewrite other people&apos;s code</z><z id="t1631738301" t="Ben Sless yes"><y>#</y><d>2021-09-15</d><h>20:38</h><r>Ben Sless</r>yes</z><z id="t1631738303" t="Ben Sless any code"><y>#</y><d>2021-09-15</d><h>20:38</h><r>Ben Sless</r>any code</z><z id="t1631738324" t="Ben Sless An alternative compiler"><y>#</y><d>2021-09-15</d><h>20:38</h><r>Ben Sless</r>An alternative compiler</z><z id="t1631738357" t="ribelo crazy idea"><y>#</y><d>2021-09-15</d><h>20:39</h><r>ribelo</r>crazy idea</z><z id="t1631738364" t="Ben Sless thanks 😄"><y>#</y><d>2021-09-15</d><h>20:39</h><r>Ben Sless</r>thanks <b>😄</b></z><z id="t1631738366" t="ribelo I&apos;m in xD"><y>#</y><d>2021-09-15</d><h>20:39</h><r>ribelo</r>I&apos;m in xD</z><z id="t1631738465" t="Ben Sless Links here are a good starting point https://wiki.haskell.org/Performance/GHC#Looking_at_the_Core"><y>#</y><d>2021-09-15</d><h>20:41</h><r>Ben Sless</r>Links here are a good starting point <a href="https://wiki.haskell.org/Performance/GHC#Looking_at_the_Core" target="_blank">https://wiki.haskell.org/Performance/GHC#Looking_at_the_Core</a></z><z id="t1631738478" t="Ben Sless and the video linked in the discussion"><y>#</y><d>2021-09-15</d><h>20:41</h><r>Ben Sless</r>and the video linked in the discussion</z><z id="t1631738488" t="Ben Sless https://www.youtube.com/watch?v=uR_VzYxvbxg"><y>#</y><d>2021-09-15</d><h>20:41</h><r>Ben Sless</r><a href="https://www.youtube.com/watch?v=uR_VzYxvbxg" target="_blank">https://www.youtube.com/watch?v=uR_VzYxvbxg</a></z></g><g id="s13"><z id="t1631738540" t="ribelo it&apos;s a bit beyond my homegrown programming knowledge, but I&apos;m happy to watch"><y>#</y><d>2021-09-15</d><h>20:42</h><r>ribelo</r>it&apos;s a bit beyond my homegrown programming knowledge, but I&apos;m happy to watch</z><z id="t1631738572" t="Ben Sless I did not study computer science 🤷"><y>#</y><d>2021-09-15</d><h>20:42</h><r>Ben Sless</r>I did not study computer science <b>🤷</b></z><z id="t1631738592" t="Ben Sless If you can get meander, you can get Core"><y>#</y><d>2021-09-15</d><h>20:43</h><r>Ben Sless</r>If you can get meander, you can get Core</z><z id="t1631738614" t="Ben Sless Besides Big Lambda type constructors don&apos;t ask me about those types are hard"><y>#</y><d>2021-09-15</d><h>20:43</h><r>Ben Sless</r>Besides Big Lambda type constructors don&apos;t ask me about those types are hard</z><z id="t1631738652" t="ribelo haskel sounds like something you need a PhD to understand"><y>#</y><d>2021-09-15</d><h>20:44</h><r>ribelo</r>haskel sounds like something you need a PhD to understand</z><z id="t1631738695" t="Ben Sless Yes, which is why I&apos;m not trying to understand Haskell, but the intermediate language and how they transform it for optimizations"><y>#</y><d>2021-09-15</d><h>20:44</h><r>Ben Sless</r>Yes, which is why I&apos;m not trying to understand Haskell, but the intermediate language and how they transform it for optimizations</z><z id="t1631738706" t="ribelo Meanwhile, I&apos;ve got to go. Thanks for the chat."><y>#</y><d>2021-09-15</d><h>20:45</h><r>ribelo</r>Meanwhile, I&apos;ve got to go. Thanks for the chat.</z><z id="t1631738712" t="Ben Sless gladly"><y>#</y><d>2021-09-15</d><h>20:45</h><r>Ben Sless</r>gladly</z><z id="t1631738728" t="Ben Sless sleep time for me 🌃"><y>#</y><d>2021-09-15</d><h>20:45</h><r>Ben Sless</r>sleep time for me <b>🌃</b></z><z id="t1632240906" t="noprompt Core is cool. 😎"><y>#</y><d>2021-09-21</d><h>16:15</h><r>noprompt</r>Core is cool. <b>😎</b></z><z id="t1632241061" t="Ben Sless I wish I could take a sabbatical to work on this"><y>#</y><d>2021-09-21</d><h>16:17</h><r>Ben Sless</r>I wish I could take a sabbatical to work on this</z><z id="t1631717558" t="Richie Just found https://clojurians-log.clojureverse.org/meander a log of clojurians slack."><y>#</y><d>2021-09-15</d><h>14:52</h><w>Richie</w>Just found <a href="https://clojurians-log.clojureverse.org/meander" target="_blank">https://clojurians-log.clojureverse.org/meander</a> a log of clojurians slack.</z><z id="t1631403357" t="schmee is there a more concise way to write this? (m/rewrite &apos;(sym :foo 1 :bar 2) (sym . !xs ... :foo ?e . !ys ...) (sym . !xs ... :qux ?e :baz ?e . !ys ...))"><y>#</y><d>2021-09-11</d><h>23:35</h><w>schmee</w>is there a more concise way to write this?
<pre>(m/rewrite &apos;(sym :foo 1 :bar 2)
    (sym . !xs ... :foo ?e . !ys ...)
    (sym . !xs ... :qux ?e :baz ?e . !ys ...))</pre></z><z id="t1632235192" t="Jimmy Miller Probably not if your goal is to match on these exact symbols. What would you hope for it to look like? Also, sorry for such a late response on this."><y>#</y><d>2021-09-21</d><h>14:39</h><r>Jimmy Miller</r>Probably not if your goal is to match on these exact symbols. What would you hope for it to look like? Also, sorry for such a late response on this.</z><z id="t1632239058" t="schmee no worries at all! what got me thinking is that this is almost m/scan but not quite, so I was wondering if that could come into play somehow."><y>#</y><d>2021-09-21</d><h>15:44</h><r>schmee</r>no worries at all! what got me thinking is that this is almost <code>m/scan</code> but not quite, so I was wondering if that could come into play somehow.</z><z id="t1631727840" t="Richie In https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#rest What’s happening in (m/match #{1 2 3} #{^&amp; ?rest} ?rest) What is &amp; contributing here? More importantly what’s ^ contributing here??"><y>#</y><d>2021-09-15</d><h>17:44</h><w>Richie</w>In <a href="https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#rest" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#rest</a>
What’s happening in
<pre>(m/match #{1 2 3}
  #{^&amp; ?rest}
  ?rest)</pre>
What is <code>&amp;</code> contributing here? More importantly what’s <code>^</code> contributing here??</z><z id="t1631734698" t="Ben Sless I&apos;m guessing it&apos;s a hack to be able to rest match a set, so it&apos;s attached as a tag"><y>#</y><d>2021-09-15</d><h>19:38</h><r>Ben Sless</r>I&apos;m guessing it&apos;s a hack to be able to rest match a set, so it&apos;s attached as a tag</z><z id="t1631734702" t="Ben Sless because sets are unordered"><y>#</y><d>2021-09-15</d><h>19:38</h><r>Ben Sless</r>because sets are unordered</z><z id="t1631735519" t="ribelo (m/match #{1 2 3} #{1 ^&amp; ?rest} ?rest) ;;=&gt; #{2 3}"><y>#</y><d>2021-09-15</d><h>19:51</h><r>ribelo</r><pre>(m/match #{1 2 3}
  #{1 ^&amp; ?rest}
  ?rest)
;;=&gt; #{2 3}</pre></z><z id="t1631735610" t="ribelo allows you to match the rest of the elements from the set"><y>#</y><d>2021-09-15</d><h>19:53</h><r>ribelo</r>allows you to match the rest of the elements from the set</z><z id="t1631735675" t="ribelo macro expands to cojure.set/difference"><y>#</y><d>2021-09-15</d><h>19:54</h><r>ribelo</r>macro expands to <code>cojure.set/difference</code></z><z id="t1631748867" t="Richie Woa, thanks. I didn’t think to macroexpand but I can actually read the code I get out of macroexpanding that example!"><y>#</y><d>2021-09-15</d><h>23:34</h><r>Richie</r>Woa, thanks. I didn’t think to <code>macroexpand</code> but I can actually read the code I get out of macroexpanding that example!</z><z id="t1632086169" t="ribelo doxa  is a simple in-memory database, trying to copy the best solutions from `datascript`, `crux`, `fulcro`, `autonormal`, `kechema`, `shadow-grow` I finally finished something between poor man `diferential dataflow` and query caching. in the meantime, I also completely rewrote `datalog query` parsing and many other things. all using `meander` of course, just because I can  🙃 https://github.com/ribelo/doxa#caching--matching"><y>#</y><d>2021-09-19</d><h>21:16</h><w>ribelo</w><code>doxa</code> is a simple in-memory database, trying to copy the best solutions from `datascript`, `crux`, `fulcro`, `autonormal`, `kechema`, `shadow-grow`

I finally finished something between poor man `diferential dataflow` and query caching. in the meantime, I also completely rewrote `datalog query` parsing and many other things. all using `meander` of course, just because I can <b>🙃</b>

<a href="https://github.com/ribelo/doxa#caching--matching" target="_blank">https://github.com/ribelo/doxa#caching--matching</a></z><z id="t1632254878" t="wilkerlucio hello, trying to figure how to parte pedestal-like nested URL format using meander, for example, go from [&quot;v1&quot; [&quot;/foo&quot; [&quot;/baz&quot; {:post baz-handler}]] [&quot;/bar&quot; {:get bar-handler :post post-bar}]] to [{:url &quot;v1/foo/baz&quot; :method :post :handler baz-handler} {:url &quot;v1/bar&quot; :method :get :handler bar-handler} {:url &quot;v1/bar&quot; :method :post :handler post-bar}]"><y>#</y><d>2021-09-21</d><h>20:07</h><w>wilkerlucio</w>hello, trying to figure how to parte pedestal-like nested URL format using meander, for example, go from
<pre>[&quot;v1&quot;
 [&quot;/foo&quot;
  [&quot;/baz&quot; {:post baz-handler}]]
 [&quot;/bar&quot;
  {:get  bar-handler
   :post post-bar}]]</pre>
to
<pre>[{:url &quot;v1/foo/baz&quot; :method :post :handler baz-handler}
 {:url &quot;v1/bar&quot; :method :get :handler bar-handler}
 {:url &quot;v1/bar&quot; :method :post :handler post-bar}]</pre></z><z id="t1632254892" t="wilkerlucio I guess I gotta use cata , but not sure how"><y>#</y><d>2021-09-21</d><h>20:08</h><r>wilkerlucio</r>I guess I gotta use <code>cata</code>, but not sure how</z><z id="t1632256318" t="ribelo (m/rewrite &apos;[&quot;v1&quot; [&quot;/foo&quot; [&quot;/baz&quot; {:post baz-handler}]] [&quot;/bar&quot; {:get bar-handler :post post-bar}]] (m/with [%1 (m/map-of !methods !handlers) %2 [!paths . (m/or %2 %1) ...]] %2) [{:url !paths :method !methods :handler !handlers} ...]) "><y>#</y><d>2021-09-21</d><h>20:31</h><r>ribelo</r><pre>(m/rewrite &apos;[&quot;v1&quot;
             [&quot;/foo&quot;
              [&quot;/baz&quot; {:post baz-handler}]]
             [&quot;/bar&quot; {:get bar-handler :post post-bar}]]
  (m/with [%1 (m/map-of !methods !handlers)
           %2 [!paths . (m/or %2 %1) ...]]
          %2)
  [{:url !paths :method !methods :handler !handlers} ...])</pre>
</z><z id="t1632256348" t="ribelo often with is simpler than cata"><y>#</y><d>2021-09-21</d><h>20:32</h><r>ribelo</r>often <code>with</code> is simpler than <code>cata</code></z><z id="t1632256373" t="ribelo but now I see that it is not quite so, because the paths have been concatet"><y>#</y><d>2021-09-21</d><h>20:32</h><r>ribelo</r>but now I see that it is not quite so, because the paths have been concatet</z><z id="t1632256376" t="wilkerlucio cool, that almost solves, the missing part is accumulating the previous routes"><y>#</y><d>2021-09-21</d><h>20:32</h><r>wilkerlucio</r>cool, that almost solves, the missing part is accumulating the previous routes</z><z id="t1632256380" t="wilkerlucio yeah"><y>#</y><d>2021-09-21</d><h>20:33</h><r>wilkerlucio</r>yeah</z><z id="t1632256509" t="ribelo honestly, I don&apos;t know how to do this"><y>#</y><d>2021-09-21</d><h>20:35</h><r>ribelo</r>honestly, I don&apos;t know how to do this</z><z id="t1632256530" t="ribelo but it&apos;ll keep me busy tonight xD"><y>#</y><d>2021-09-21</d><h>20:35</h><r>ribelo</r>but it&apos;ll keep me busy tonight xD</z><z id="t1632256627" t="wilkerlucio haha, would love to hear, I’m trying to figure on my end as well, if I figure I’ll post here"><y>#</y><d>2021-09-21</d><h>20:37</h><r>wilkerlucio</r>haha, would love to hear, I’m trying to figure on my end as well, if I figure I’ll post here</z><z id="t1632256739" t="markaddleman Give this a try"><y>#</y><d>2021-09-21</d><h>20:38</h><r>markaddleman</r>Give this a try</z><z id="t1632256802" t="markaddleman The first rewrite does the data re-organization that you&apos;re looking for but suffers from nested vectors (this is often a result of using cata )."><y>#</y><d>2021-09-21</d><h>20:40</h><r>markaddleman</r>The first rewrite does the data re-organization that you&apos;re looking for but suffers from nested vectors (this is often a result of using <code>cata</code>).</z><z id="t1632256815" t="markaddleman The second rewrite &quot;flattens&quot; the structure"><y>#</y><d>2021-09-21</d><h>20:40</h><r>markaddleman</r>The second rewrite &quot;flattens&quot; the structure</z><z id="t1632256862" t="wilkerlucio cool, I guess the last rewrite can be replaced with flatten , got the same result here"><y>#</y><d>2021-09-21</d><h>20:41</h><r>wilkerlucio</r>cool, I guess the last rewrite can be replaced with <code>flatten</code>, got the same result here</z><z id="t1632256870" t="wilkerlucio thanks [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] !"><y>#</y><d>2021-09-21</d><h>20:41</h><r>wilkerlucio</r>thanks <a>@U2845S9KL</a>!</z><z id="t1632256962" t="wilkerlucio not sure if its a fixable issue, but when I tried with a real longer structure, it did stack overflow 😅"><y>#</y><d>2021-09-21</d><h>20:42</h><r>wilkerlucio</r>not sure if its a fixable issue, but when I tried with a real longer structure, it did stack overflow <b>😅</b></z><z id="t1632256962" t="markaddleman It&apos;s funny - I&apos;m so used to using meander that I reached for meander to flatten the data without even thinking of flatten 🙂"><y>#</y><d>2021-09-21</d><h>20:42</h><r>markaddleman</r>It&apos;s funny - I&apos;m so used to using meander that I reached for meander to flatten the data without even thinking of <code>flatten</code> <b>🙂</b></z><z id="t1632257006" t="markaddleman cata does stack-based recursion so a sufficiently deep structure could result in an overflow, I guess"><y>#</y><d>2021-09-21</d><h>20:43</h><r>markaddleman</r><code>cata</code> does stack-based recursion so a sufficiently deep structure could result in an overflow, I guess</z><z id="t1632257019" t="markaddleman Let me see if I can rewrite it to avoid some of the recursion"><y>#</y><d>2021-09-21</d><h>20:43</h><r>markaddleman</r>Let me see if I can rewrite it to avoid some of the recursion</z><z id="t1632257032" t="wilkerlucio I don’t think its that deep, from a quick look I guess its less than 10 depth"><y>#</y><d>2021-09-21</d><h>20:43</h><r>wilkerlucio</r>I don’t think its that deep, from a quick look I guess its less than 10 depth</z><z id="t1632257042" t="markaddleman Can you post the structure?"><y>#</y><d>2021-09-21</d><h>20:44</h><r>markaddleman</r>Can you post the structure?</z><z id="t1632257052" t="ribelo stack overlow occurs when cata loops indefinitely"><y>#</y><d>2021-09-21</d><h>20:44</h><r>ribelo</r><code>stack overlow</code> occurs when <code>cata</code> loops indefinitely</z><z id="t1632257054" t="markaddleman I assume you&apos;re getting the SO from the first rewrite?"><y>#</y><d>2021-09-21</d><h>20:44</h><r>markaddleman</r>I assume you&apos;re getting the SO from the first rewrite?</z><z id="t1632257062" t="wilkerlucio sadly no, but there are a few other patterns that needs to be taken in account"><y>#</y><d>2021-09-21</d><h>20:44</h><r>wilkerlucio</r>sadly no, but there are a few other patterns that needs to be taken in account</z><z id="t1632257069" t="wilkerlucio and I guess those are screwing it up"><y>#</y><d>2021-09-21</d><h>20:44</h><r>wilkerlucio</r>and I guess those are screwing it up</z><z id="t1632257096" t="markaddleman Unfortunately, I&apos;m not very familiar with these routing data structures"><y>#</y><d>2021-09-21</d><h>20:44</h><r>markaddleman</r>Unfortunately, I&apos;m not very familiar with these routing data structures</z><z id="t1632257106" t="ribelo (m/rewrite 1 (m/app inc ?x) (m/cata ?x)) "><y>#</y><d>2021-09-21</d><h>20:45</h><r>ribelo</r><pre>(m/rewrite 1
  (m/app inc ?x)
  (m/cata ?x))</pre>
</z><z id="t1632257146" t="ribelo I recommend using cata with instructions"><y>#</y><d>2021-09-21</d><h>20:45</h><r>ribelo</r>I recommend using <code>cata</code> with instructions</z><z id="t1632257151" t="wilkerlucio I can make a shorter version that has more of those features, let me check"><y>#</y><d>2021-09-21</d><h>20:45</h><r>wilkerlucio</r>I can make a shorter version that has more of those features, let me check</z><z id="t1632257160" t="markaddleman cool"><y>#</y><d>2021-09-21</d><h>20:46</h><r>markaddleman</r>cool</z><z id="t1632257165" t="ribelo is more readable and harder to error with an infinite loop"><y>#</y><d>2021-09-21</d><h>20:46</h><r>ribelo</r>is more readable and harder to error with an infinite loop</z><z id="t1632257308" t="ribelo (m/rewrite [:start 1] [:start (m/app inc ?x)] (m/cata [:end ?x]) [:end ?x] ~(str &quot;end with ?x = &quot; ?x)) "><y>#</y><d>2021-09-21</d><h>20:48</h><r>ribelo</r><pre>(m/rewrite [:start 1]
  [:start (m/app inc ?x)]
  (m/cata [:end ?x])
  [:end ?x]
  ~(str &quot;end with ?x = &quot; ?x))</pre>
</z><z id="t1632257367" t="ribelo you can easily set checkpoints and also check which instruction will be executed next"><y>#</y><d>2021-09-21</d><h>20:49</h><r>ribelo</r>you can easily set checkpoints and also check which instruction will be executed next</z><z id="t1632257522" t="wilkerlucio found a simple stack overflow example:"><y>#</y><d>2021-09-21</d><h>20:52</h><r>wilkerlucio</r>found a simple stack overflow example:</z><z id="t1632257523" t="wilkerlucio &apos;[&quot;v1&quot; [&quot;/foo&quot; [&quot;/baz&quot; {:post baz-handler}] [&quot;/other&quot; []]] [&quot;/bar&quot; {:get bar-handler :post post-bar}]]"><y>#</y><d>2021-09-21</d><h>20:52</h><r>wilkerlucio</r><pre>&apos;[&quot;v1&quot;
         [&quot;/foo&quot;
          [&quot;/baz&quot; {:post baz-handler}]
          [&quot;/other&quot; []]]
         [&quot;/bar&quot;
          {:get  bar-handler
           :post post-bar}]]</pre></z><z id="t1632257534" t="wilkerlucio sometimes instead of a map, its a vector with interceptors on the right side"><y>#</y><d>2021-09-21</d><h>20:52</h><r>wilkerlucio</r>sometimes instead of a map, its a vector with interceptors on the right side</z><z id="t1632257551" t="markaddleman ah, yeah. I can see how this would overflow"><y>#</y><d>2021-09-21</d><h>20:52</h><r>markaddleman</r>ah, yeah.  I can see how this would overflow</z><z id="t1632257561" t="markaddleman I&apos;ll take a crack at this data structure"><y>#</y><d>2021-09-21</d><h>20:52</h><r>markaddleman</r>I&apos;ll take a crack at this data structure</z><z id="t1632257599" t="wilkerlucio feels a little ambiguous case, curious to see what you come with for that 😉"><y>#</y><d>2021-09-21</d><h>20:53</h><r>wilkerlucio</r>feels a little ambiguous case, curious to see what you come with for that <b>😉</b></z><z id="t1632257606" t="markaddleman ha"><y>#</y><d>2021-09-21</d><h>20:53</h><r>markaddleman</r>ha</z><z id="t1632257608" t="markaddleman you read my mind"><y>#</y><d>2021-09-21</d><h>20:53</h><r>markaddleman</r>you read my mind</z><z id="t1632257626" t="markaddleman unctions? fI&apos;m guessing the vector of interceptors is always a vector of"><y>#</y><d>2021-09-21</d><h>20:53</h><r>markaddleman</r>unctions?
fI&apos;m guessing the vector of interceptors is always a vector of</z><z id="t1632257628" t="markaddleman functions?"><y>#</y><d>2021-09-21</d><h>20:53</h><r>markaddleman</r>functions?</z><z id="t1632257645" t="markaddleman What does the result for this look like?"><y>#</y><d>2021-09-21</d><h>20:54</h><r>markaddleman</r>What does the result for this look like?</z><z id="t1632257704" t="wilkerlucio the real one looks more like this:"><y>#</y><d>2021-09-21</d><h>20:55</h><r>wilkerlucio</r>the real one looks more like this:</z><z id="t1632257706" t="wilkerlucio &apos;[&quot;v1&quot; [&quot;/foo&quot; [&quot;/baz&quot; {:post baz-handler}] [&quot;/other&quot; [[:interceptor [{:features {:policy-authz-enabled? false}, :interceptor [:scope {:scope &quot;xxx&quot;}]} {:features {:policy-authz-enabled? true}, :interceptor [:scope [{:policy &quot;yyy&quot;}]]}]]]]] [&quot;/bar&quot; {:get bar-handler :post post-bar}]]"><y>#</y><d>2021-09-21</d><h>20:55</h><r>wilkerlucio</r><pre>&apos;[&quot;v1&quot;
        [&quot;/foo&quot;
         [&quot;/baz&quot; {:post baz-handler}]
         [&quot;/other&quot; [[:interceptor
                     [{:features    {:policy-authz-enabled? false},
                       :interceptor [:scope
                                     {:scope &quot;xxx&quot;}]}
                      {:features    {:policy-authz-enabled? true},
                       :interceptor [:scope
                                     [{:policy &quot;yyy&quot;}]]}]]]]]
        [&quot;/bar&quot;
         {:get  bar-handler
          :post post-bar}]]</pre></z><z id="t1632257729" t="wilkerlucio but I’m not sure all possible variations (like if they always start with double vector)"><y>#</y><d>2021-09-21</d><h>20:55</h><r>wilkerlucio</r>but I’m not sure all possible variations (like if they always start with double vector)</z><z id="t1632257762" t="markaddleman I&apos;ve got a meeting in 5 minutes but I&apos;ll pick this up after"><y>#</y><d>2021-09-21</d><h>20:56</h><r>markaddleman</r>I&apos;ve got a meeting in 5 minutes but I&apos;ll pick this up after</z><z id="t1632257784" t="wilkerlucio thanks, I’ll keep playing here too"><y>#</y><d>2021-09-21</d><h>20:56</h><r>wilkerlucio</r>thanks, I’ll keep playing here too</z><z id="t1632257799" t="wilkerlucio seems like a notable difference is that those never start with strings at the beginning of the vector"><y>#</y><d>2021-09-21</d><h>20:56</h><r>wilkerlucio</r>seems like a notable difference is that those never start with strings at the beginning of the vector</z><z id="t1632257802" t="wilkerlucio only routes do that"><y>#</y><d>2021-09-21</d><h>20:56</h><r>wilkerlucio</r>only routes do that</z><z id="t1632257900" t="ribelo (m/rewrite &apos;[&quot;v1&quot; [&quot;/foo&quot; [&quot;/baz&quot; {:post baz-handler}]] [&quot;/bar&quot; {:get bar-handler :post post-bar}]] (m/with [%1 (m/map-of !methods !handlers) %2 [(m/app #(str (last !paths) %) !paths) . (m/or %2 %1) ...]] %2) [{:url !paths :method !methods :handler !handlers} ...]) "><y>#</y><d>2021-09-21</d><h>20:58</h><r>ribelo</r><pre>(m/rewrite &apos;[&quot;v1&quot;
             [&quot;/foo&quot;
              [&quot;/baz&quot; {:post baz-handler}]]
             [&quot;/bar&quot; {:get bar-handler :post post-bar}]]
  (m/with [%1 (m/map-of !methods !handlers)
           %2 [(m/app #(str (last !paths) %) !paths) . (m/or %2 %1) ...]]
    %2)
  [{:url !paths :method !methods :handler !handlers} ...])</pre>
</z><z id="t1632257976" t="ribelo I can&apos;t make it any shorter [:attrs {:href &quot;/_/_/users/U066U8JQJ&quot;}]"><y>#</y><d>2021-09-21</d><h>20:59</h><r>ribelo</r>I can&apos;t make it any shorter <a>@U066U8JQJ</a></z><z id="t1632257980" t="ribelo 😉"><y>#</y><d>2021-09-21</d><h>20:59</h><r>ribelo</r><b>😉</b></z><z id="t1632258017" t="wilkerlucio looks nice!"><y>#</y><d>2021-09-21</d><h>21:00</h><r>wilkerlucio</r>looks nice!</z><z id="t1632258044" t="wilkerlucio on the large example it didn’t match though =/"><y>#</y><d>2021-09-21</d><h>21:00</h><r>wilkerlucio</r>on the large example it didn’t match though =/</z><z id="t1632258049" t="wilkerlucio but I’ll play with it"><y>#</y><d>2021-09-21</d><h>21:00</h><r>wilkerlucio</r>but I’ll play with it</z><z id="t1632258069" t="wilkerlucio it probably because of the interceptors in the middle"><y>#</y><d>2021-09-21</d><h>21:01</h><r>wilkerlucio</r>it probably because of the interceptors in the middle</z><z id="t1632258077" t="ribelo what should be returned from the longer one?"><y>#</y><d>2021-09-21</d><h>21:01</h><r>ribelo</r>what should be returned from the longer one?</z><z id="t1632258115" t="ribelo \other should be omitted?"><y>#</y><d>2021-09-21</d><h>21:01</h><r>ribelo</r><code>\other</code> should be omitted?</z><z id="t1632258144" t="wilkerlucio omitting other is good"><y>#</y><d>2021-09-21</d><h>21:02</h><r>wilkerlucio</r>omitting other is good</z><z id="t1632258184" t="wilkerlucio the longer one currently returns nil , so something is going bad in the middle, I’m trying to get a case to reproduce with your solution"><y>#</y><d>2021-09-21</d><h>21:03</h><r>wilkerlucio</r>the longer one currently returns <code>nil</code>, so something is going bad in the middle, I’m trying to get a case to reproduce with your solution</z><z id="t1632258206" t="ribelo (m/rewrite &apos;[&quot;v1&quot; [&quot;/foo&quot; [&quot;/baz&quot; {:post baz-handler}] [&quot;/other&quot; [[:interceptor [{:features {:policy-authz-enabled? false} , :interceptor [:scope {:scope &quot;xxx&quot;}]} {:features {:policy-authz-enabled? true} , :interceptor [:scope [{:policy &quot;yyy&quot;}]]}]]]]] [&quot;/bar&quot; {:get bar-handler :post post-bar}]] (m/with [%1 (m/map-of !methods !handlers) %2 [(m/pred string?) _] %3 [(m/app #(str (last !paths) %) !paths) . (m/or %3 %2 %1) ...]] %3) [{:url !paths :method !methods :handler !handlers} ...]) "><y>#</y><d>2021-09-21</d><h>21:03</h><r>ribelo</r><pre>(m/rewrite &apos;[&quot;v1&quot;
             [&quot;/foo&quot;
              [&quot;/baz&quot; {:post baz-handler}]
              [&quot;/other&quot; [[:interceptor
                          [{:features    {:policy-authz-enabled? false} ,
                            :interceptor [:scope
                                          {:scope &quot;xxx&quot;}]}
                           {:features    {:policy-authz-enabled? true} ,
                            :interceptor [:scope
                                          [{:policy &quot;yyy&quot;}]]}]]]]]
             [&quot;/bar&quot;
              {:get bar-handler
               :post post-bar}]]
  (m/with [%1 (m/map-of !methods !handlers)
           %2 [(m/pred string?) _]
           %3 [(m/app #(str (last !paths) %) !paths) . (m/or %3 %2 %1) ...]]
    %3)
  [{:url !paths :method !methods :handler !handlers} ...])</pre>
</z><z id="t1632258302" t="ribelo \other catches under %2 , which is defined in the simplest possible way, [string? whatever]"><y>#</y><d>2021-09-21</d><h>21:05</h><r>ribelo</r><code>\other</code> catches under <code>%2</code>, which is defined in the simplest possible way, <code>[string? whatever]</code></z><z id="t1632258345" t="wilkerlucio here is an example that’s going off, but not the main problem yet:"><y>#</y><d>2021-09-21</d><h>21:05</h><r>wilkerlucio</r>here is an example that’s going off, but not the main problem yet:</z><z id="t1632258347" t="wilkerlucio (m/rewrite &apos;[&quot;v1&quot; [&quot;/foo&quot; [:some-interceptors] [&quot;/baz&quot; {:post baz-handler}] [&quot;/other&quot; [[:interceptor [{:features {:policy-authz-enabled? false}, :interceptor [:scope {:scope &quot;xxx&quot;}]} {:features {:policy-authz-enabled? true}, :interceptor [:scope [{:policy &quot;yyy&quot;}]]}]]]]] [&quot;/bar&quot; {:get bar-handler :post post-bar}]] (m/with [%1 (m/map-of !methods !handlers) %2 [(m/pred string?) _] %3 [(m/app #(str (last !paths) %) !paths) . (m/or %3 %2 %1) ...]] %3) [{:url !paths :method !methods :handler !handlers} ...])"><y>#</y><d>2021-09-21</d><h>21:05</h><r>wilkerlucio</r><pre>(m/rewrite &apos;[&quot;v1&quot;
               [&quot;/foo&quot;
                [:some-interceptors]
                [&quot;/baz&quot; {:post baz-handler}]
                [&quot;/other&quot; [[:interceptor
                            [{:features    {:policy-authz-enabled? false},
                              :interceptor [:scope
                                            {:scope &quot;xxx&quot;}]}
                             {:features    {:policy-authz-enabled? true},
                              :interceptor [:scope
                                            [{:policy &quot;yyy&quot;}]]}]]]]]
               [&quot;/bar&quot; {:get bar-handler :post post-bar}]]
    (m/with [%1 (m/map-of !methods !handlers)
             %2 [(m/pred string?) _]
             %3 [(m/app #(str (last !paths) %) !paths) . (m/or %3 %2 %1) ...]]
      %3)
    [{:url !paths :method !methods :handler !handlers} ...])</pre></z><z id="t1632258371" t="ribelo probably with a more complicated example it will fall in a different place"><y>#</y><d>2021-09-21</d><h>21:06</h><r>ribelo</r>probably with a more complicated example it will fall in a different place</z><z id="t1632258382" t="wilkerlucio (in this case the :some-interceptors should be ignored)"><y>#</y><d>2021-09-21</d><h>21:06</h><r>wilkerlucio</r>(in this case the <code>:some-interceptors</code> should be ignored)</z><z id="t1632258458" t="wilkerlucio anyway you guys are meander masters, its already really helpful 🙇"><y>#</y><d>2021-09-21</d><h>21:07</h><r>wilkerlucio</r>anyway you guys are meander masters, its already really helpful <b>🙇</b></z><z id="t1632258563" t="ribelo not so much I see that it is probably wrong, because it does not return a map with the path :url foo/bar 😕"><y>#</y><d>2021-09-21</d><h>21:09</h><r>ribelo</r>not so much

I see that it is probably wrong, because it does not return a map with the path :url <code>foo/bar</code> <b>😕</b></z><z id="t1632258579" t="ribelo but I&apos;m glad I could help a little."><y>#</y><d>2021-09-21</d><h>21:09</h><r>ribelo</r>but I&apos;m glad I could help a little.</z><z id="t1632258680" t="ribelo It would be nice if [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] offered a solution"><y>#</y><d>2021-09-21</d><h>21:11</h><r>ribelo</r>It would be nice if <a>@U06MDAPTP</a> offered a solution</z><z id="t1632258722" t="ribelo I have no idea how to better concatenate urls into one, and what I&apos;ve done doesn&apos;t always work"><y>#</y><d>2021-09-21</d><h>21:12</h><r>ribelo</r>I have no idea how to better concatenate urls into one, and what I&apos;ve done doesn&apos;t always work</z><z id="t1632259205" t="wilkerlucio the examples you posted are nice as well, I’ll spend some time to understand and learn those patterns 🙂"><y>#</y><d>2021-09-21</d><h>21:20</h><r>wilkerlucio</r>the examples you posted are nice as well, I’ll spend some time to understand and learn those patterns <b>🙂</b></z><z id="t1632260677" t="markaddleman Thanks for showing with [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] ! I was aware of it but I don&apos;t think I&apos;ve ever used it before"><y>#</y><d>2021-09-21</d><h>21:44</h><r>markaddleman</r>Thanks  for showing <code>with</code> <a>@U0BBFDED7</a> !  I was aware of it but I don&apos;t think I&apos;ve ever used it before</z><z id="t1632260737" t="ribelo ☺️"><y>#</y><d>2021-09-21</d><h>21:45</h><r>ribelo</r><b>☺️</b></z><z id="t1632278358" t="wilkerlucio this worked! (m/rewrite (-&gt; data :ig/system :pipo.module/web-routes :routes ffirst) (m/with [%route-map (m/map-of !methods !handlers) %item [(m/pred string?) _] %interceptors [(m/pred keyword?) . _ ...] %all [(m/app #(str (last !paths) %) !paths) . (m/or %all %item %interceptors %route-map) ...]] %all) [{:url !paths :method !methods :handler !handlers} ...])"><y>#</y><d>2021-09-22</d><h>02:39</h><r>wilkerlucio</r>this worked!
<pre>(m/rewrite
    (-&gt; data :ig/system :pipo.module/web-routes :routes ffirst)
    
    (m/with [%route-map (m/map-of !methods !handlers)
             %item [(m/pred string?) _]
             %interceptors [(m/pred keyword?) . _ ...]
             %all [(m/app #(str (last !paths) %) !paths) . (m/or %all %item %interceptors %route-map) ...]]
      %all)
    [{:url !paths :method !methods :handler !handlers} ...])</pre></z><z id="t1632278382" t="wilkerlucio thank you again folks!"><y>#</y><d>2021-09-22</d><h>02:39</h><r>wilkerlucio</r>thank you again folks!</z><z id="t1632279071" t="wilkerlucio I celebrated too soon, [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] I found this way to concatenate is not doing the stack as expected, on the base example it outputs: [{:url &quot;v1&quot;, :method :post, :handler baz-handler} {:url &quot;v1/foo&quot;, :method :get, :handler bar-handler} {:url &quot;v1/foo/baz&quot;, :method :post, :handler post-bar}]"><y>#</y><d>2021-09-22</d><h>02:51</h><r>wilkerlucio</r>I celebrated too soon, <a>@U0BBFDED7</a> I found this way to concatenate is not doing the stack as expected, on the base example it outputs:
<pre>[{:url &quot;v1&quot;, :method :post, :handler baz-handler}
 {:url &quot;v1/foo&quot;, :method :get, :handler bar-handler}
 {:url &quot;v1/foo/baz&quot;, :method :post, :handler post-bar}]</pre></z><z id="t1632279094" t="wilkerlucio but it should be ({:url &quot;v1/foo/baz&quot;, :method :post, :handler baz-handler} {:url &quot;v1/bar&quot;, :method :get, :handler bar-handler} {:url &quot;v1/bar&quot;, :method :post, :handler post-bar}) (which is the result given frmo the [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] solution)"><y>#</y><d>2021-09-22</d><h>02:51</h><r>wilkerlucio</r>but it should be
<pre>({:url &quot;v1/foo/baz&quot;, :method :post, :handler baz-handler}
 {:url &quot;v1/bar&quot;, :method :get, :handler bar-handler}
 {:url &quot;v1/bar&quot;, :method :post, :handler post-bar})</pre>
(which is the result given frmo the <a>@U2845S9KL</a> solution)</z><z id="t1632279175" t="wilkerlucio now trying to work more on the mark example to add the interceptors part"><y>#</y><d>2021-09-22</d><h>02:52</h><r>wilkerlucio</r>now trying to work more on the mark example to add the interceptors part</z><z id="t1632279219" t="markaddleman I thought you guys already had a solution so I didn&apos;t pick up the interceptor piece. I&apos;ll give it a look tomorrow morning"><y>#</y><d>2021-09-22</d><h>02:53</h><r>markaddleman</r>I thought you guys already had a solution so I didn&apos;t pick up the interceptor piece.  I&apos;ll give it a look tomorrow morning</z><z id="t1632279447" t="wilkerlucio thanks, this is the example I’m working on top of now:"><y>#</y><d>2021-09-22</d><h>02:57</h><r>wilkerlucio</r>thanks, this is the example I’m working on top of now:</z><z id="t1632279449" t="wilkerlucio &apos;[&quot;v1&quot; [&quot;/foo&quot; [:some-interceptors] [&quot;/baz&quot; {:post baz-handler}]] [&quot;/bar&quot; {:get bar-handler :post post-bar}]]"><y>#</y><d>2021-09-22</d><h>02:57</h><r>wilkerlucio</r><pre>&apos;[&quot;v1&quot;
        [&quot;/foo&quot;
         [:some-interceptors]
         [&quot;/baz&quot; {:post baz-handler}]]
        [&quot;/bar&quot; {:get bar-handler :post post-bar}]]</pre></z><z id="t1632279467" t="wilkerlucio you can forget the value as vectors, that wasn’t a thing, just the interceptors in the middle 🙂"><y>#</y><d>2021-09-22</d><h>02:57</h><r>wilkerlucio</r>you can forget the value as vectors, that wasn’t a thing, just the interceptors in the middle <b>🙂</b></z><z id="t1632283375" t="wilkerlucio got it 😄 🎉 (-&gt; &apos;[&quot;v1&quot; [&quot;/foo&quot; [:bla :me []] [&quot;/baz&quot; {:post baz-handler}]] [&quot;/bar&quot; {:get bar-handler :post post-bar}]] (m/rewrite [?path (m/map-of !action !handler)] [{:url ?path :method !action :handler !handler} ...] [?path-prefix [(m/pred keyword?) &amp; _] &amp; ?rest] (m/cata [?path-prefix &amp; ?rest]) [?path-prefix [?path-suffix &amp; ?deeper-or-handlers]] (m/cata [(m/app str ?path-prefix ?path-suffix) &amp; ?deeper-or-handlers]) [?path-prefix . !deeper ...] [(m/cata [?path-prefix !deeper]) ...]) flatten) that was fun to learn! thanks folks"><y>#</y><d>2021-09-22</d><h>04:02</h><r>wilkerlucio</r>got it <b>😄</b> <b>🎉</b>
<pre>(-&gt; &apos;[&quot;v1&quot;
        [&quot;/foo&quot;
         [:bla :me []]
         [&quot;/baz&quot; {:post baz-handler}]]
        [&quot;/bar&quot; {:get bar-handler :post post-bar}]]
      (m/rewrite
        [?path (m/map-of !action !handler)]
        [{:url ?path :method !action :handler !handler} ...]

        [?path-prefix [(m/pred keyword?) &amp; _] &amp; ?rest]
        (m/cata [?path-prefix &amp; ?rest])

        [?path-prefix [?path-suffix &amp; ?deeper-or-handlers]]
        (m/cata [(m/app str ?path-prefix ?path-suffix) &amp; ?deeper-or-handlers])

        [?path-prefix . !deeper ...]
        [(m/cata [?path-prefix !deeper]) ...])
      flatten)</pre>
that was fun to learn! thanks folks</z><z id="t1632415348" t="noprompt Sorry I missed this conversation. I was out with a few doctor appointments for myself and my son. 😅"><y>#</y><d>2021-09-23</d><h>16:42</h><r>noprompt</r>Sorry I missed this conversation. I was out with a few doctor appointments for myself and my son. <b>😅</b></z><z id="t1632340319" t="wilkerlucio hello, I have another Meander puzzle 😅 , this seems easier but I still hitting the wall on this: ; input data &apos;{:body-params {:baz int?} :path-params {:foo string? :bar uuid?}} ; expect output &apos;[{:name :baz, :kind :body-params, :type int?} {:name :foo, :kind :path-params, :type string?} {:name :bar, :kind :path-params, :type uuid?}] ; non-meander implementation (defn params-&gt;fields [params] (reduce-kv (fn [out kind params] (if (map? params) (reduce-kv (fn [out name type] (conj out {:name name :kind kind :type type})) out params) out)) [] params)) with meander I tried using rewrites , but I ended up with some cardinal products, so wonder how you would tackle this"><y>#</y><d>2021-09-22</d><h>19:51</h><w>wilkerlucio</w>hello, I have another Meander puzzle <b>😅</b>, this seems easier but I still hitting the wall on this:

<pre>; input data
&apos;{:body-params {:baz int?}
  :path-params {:foo string?
                :bar uuid?}}

; expect output
&apos;[{:name :baz, :kind :body-params, :type int?}
  {:name :foo, :kind :path-params, :type string?}
  {:name :bar, :kind :path-params, :type uuid?}]

; non-meander implementation
(defn params-&gt;fields [params]
  (reduce-kv
    (fn [out kind params]
      (if (map? params)
        (reduce-kv
          (fn [out name type]
            (conj out {:name name :kind kind :type type}))
          out
          params)
        out))
    []
    params))</pre>
with meander I tried using <code>rewrites</code>, but I ended up with some cardinal products, so wonder how you would tackle this</z><z id="t1632340861" t="ribelo w8 😉"><y>#</y><d>2021-09-22</d><h>20:01</h><r>ribelo</r>w8 <b>😉</b></z><z id="t1632341142" t="ribelo (m/rewrite &apos;{:body-params {:baz int?} :path-params {:foo string? :bar uuid?}} {?k ?v &amp; ?more} [&amp; (m/cata [?k ?v]) &amp; (m/cata ?more)] [?k (m/map-of !ks !vs)] [{:kind ?k &amp; {:name !ks :type !vs}} ...] ?x ?x) ;; =&gt; [{:name :baz, :type int?, :kind :body-params} ;; {:name :foo, :type string?, :kind :path-params} ;; {:name :bar, :type uuid?, :kind :path-params}]"><y>#</y><d>2021-09-22</d><h>20:05</h><r>ribelo</r><pre>(m/rewrite &apos;{:body-params {:baz int?}
             :path-params {:foo string?
                           :bar uuid?}}
  {?k ?v &amp; ?more}
  [&amp; (m/cata [?k ?v]) &amp; (m/cata ?more)]
  [?k (m/map-of !ks !vs)]
  [{:kind ?k &amp; {:name !ks :type !vs}} ...]
  ?x ?x)
;; =&gt; [{:name :baz, :type int?, :kind :body-params}
;;     {:name :foo, :type string?, :kind :path-params}
;;     {:name :bar, :type uuid?, :kind :path-params}]</pre></z><z id="t1632341212" t="ribelo If you have any more problems, let me know. better than crossword puzzles and sudoku"><y>#</y><d>2021-09-22</d><h>20:06</h><r>ribelo</r>If you have any more problems, let me know. better than crossword puzzles and sudoku</z><z id="t1632404217" t="wilkerlucio awesome, thank you so much, and since you asked, there is a twist on this one that I wonder if we solve strait from meander"><y>#</y><d>2021-09-23</d><h>13:36</h><r>wilkerlucio</r>awesome, thank you so much, and since you asked, there is a twist on this one that I wonder if we solve strait from meander</z><z id="t1632404220" t="wilkerlucio this is my current code:"><y>#</y><d>2021-09-23</d><h>13:37</h><r>wilkerlucio</r>this is my current code:</z><z id="t1632404228" t="wilkerlucio (defn params-&gt;fields [params] (-&gt;&gt; (m/rewrite params {?k ?v &amp; ?more} [&amp; (m/cata [?k ?v]) &amp; (m/cata ?more)] [?k (m/map-of !ks !vs)] [{:kind ?k &amp; {:name !ks :type !vs}} ...] ?x ?x) (mapv (fn [{:keys [name] :as field}] (cond-&gt; field (and (coll? name) (= :opt (first name))) (assoc :name (second name) :optional? true))))))"><y>#</y><d>2021-09-23</d><h>13:37</h><r>wilkerlucio</r><pre>(defn params-&gt;fields [params]
  (-&gt;&gt; (m/rewrite params
         {?k ?v &amp; ?more}
         [&amp; (m/cata [?k ?v]) &amp; (m/cata ?more)]

         [?k (m/map-of !ks !vs)]
         [{:kind ?k &amp; {:name !ks :type !vs}} ...]

         ?x ?x)
       (mapv (fn [{:keys [name] :as field}]
               (cond-&gt; field
                 (and (coll? name) (= :opt (first name)))
                 (assoc :name (second name) :optional? true))))))</pre></z><z id="t1632404250" t="wilkerlucio the mapv is to take care of optional params, here is a test including those: (is (= (forms/params-&gt;fields &apos;{:path-params {:foo string? (:opt :bar) uuid?}}) &apos;[{:name :foo, :kind :path-params, :type string?} {:name :bar, :kind :path-params, :type uuid?, :optional? true}]))"><y>#</y><d>2021-09-23</d><h>13:37</h><r>wilkerlucio</r>the mapv is to take care of optional params, here is a test including those:
<pre>(is (= (forms/params-&gt;fields
           &apos;{:path-params {:foo   string?
                           (:opt :bar) uuid?}})
         &apos;[{:name :foo, :kind :path-params, :type string?}
           {:name :bar, :kind :path-params, :type uuid?, :optional? true}]))</pre></z><z id="t1632404289" t="wilkerlucio so in that case, it needs to extract from [:opt :name] (sometimes its (:opt :name) , so not always a vector"><y>#</y><d>2021-09-23</d><h>13:38</h><r>wilkerlucio</r>so in that case, it needs to extract from <code>[:opt :name]</code> (sometimes its <code>(:opt :name)</code>, so not always a vector</z><z id="t1632404308" t="wilkerlucio and add the optional? true flag"><y>#</y><d>2021-09-23</d><h>13:38</h><r>wilkerlucio</r>and add the <code>optional? true</code> flag</z><z id="t1632404555" t="ribelo to make it easier please give input and expected output"><y>#</y><d>2021-09-23</d><h>13:42</h><r>ribelo</r>to make it easier please give input and expected output</z><z id="t1632404563" t="ribelo I don&apos;t know if I understand correctly"><y>#</y><d>2021-09-23</d><h>13:42</h><r>ribelo</r>I don&apos;t know if I understand correctly</z><z id="t1632404737" t="ribelo I got it, I missed something when I was reading"><y>#</y><d>2021-09-23</d><h>13:45</h><r>ribelo</r>I got it, I missed something when I was reading</z><z id="t1632405694" t="ribelo [:attrs {:href &quot;/_/_/users/U066U8JQJ&quot;}] (defn params-&gt;fields [params] (-&gt;&gt; (m/rewrite params {?k ?v &amp; ?more} [&amp; (m/cata [?k ?v]) &amp; (m/cata ?more)] [?k (m/map-of (m/or (m/and (m/keyword _ _ :as !ks) (m/let [!optional false])) (m/and (:opt !ks) (m/let [!optional true]))) !vs)] [{:kind ?k &amp; {:name !ks :type !vs :optional? !optional}} ...] {} {}))) "><y>#</y><d>2021-09-23</d><h>14:01</h><r>ribelo</r><a>@U066U8JQJ</a>
<pre>(defn params-&gt;fields [params]
  (-&gt;&gt; (m/rewrite params
         {?k ?v &amp; ?more}
         [&amp; (m/cata [?k ?v]) &amp; (m/cata ?more)]

         [?k (m/map-of (m/or (m/and (m/keyword _ _ :as !ks) (m/let [!optional false]))
                             (m/and (:opt !ks) (m/let [!optional true]))) !vs)]
         [{:kind ?k &amp; {:name !ks :type !vs :optional? !optional}} ...]
         

         {} {})))</pre>
</z><z id="t1632405771" t="ribelo with optional arguments, the meander is no longer concise and things get a bit messy"><y>#</y><d>2021-09-23</d><h>14:02</h><r>ribelo</r>with optional arguments, the meander is no longer concise and things get a bit messy</z><z id="t1632405924" t="ribelo and in general, except quick hacking, I would advise you not to generally use the notation at the end of ?x ?x , you might get surprised. It&apos;s a good idea to throw an exception just like m/match"><y>#</y><d>2021-09-23</d><h>14:05</h><r>ribelo</r>and in general, except quick hacking, I would advise you not to generally use the notation at the end of <code>?x ?x</code>, you might get surprised. It&apos;s a good idea to throw an exception just like <code>m/match</code></z><z id="t1632406024" t="ribelo in the worst case ?x ?x causes rewrite return unchanged whatever it takes"><y>#</y><d>2021-09-23</d><h>14:07</h><r>ribelo</r>in the worst case <code>?x ?x</code> causes <code>rewrite</code> return unchanged whatever it takes</z><z id="t1632430001" t="noprompt I just noticed the use of two &amp; on the RHS. 🙂"><y>#</y><d>2021-09-23</d><h>20:46</h><r>noprompt</r>I just noticed the use of two <code>&amp;</code> on the RHS. <b>🙂</b></z><z id="t1632430133" t="ribelo I guess that&apos;s a good thing? ;&gt;"><y>#</y><d>2021-09-23</d><h>20:48</h><r>ribelo</r>I guess that&apos;s a good thing? ;&gt;</z><z id="t1632505897" t="wilkerlucio I’m starting to look at meander rewrite fn as a “reduce via pattern matching”, do you think this a good/valid way to think about it?"><y>#</y><d>2021-09-24</d><h>17:51</h><w>wilkerlucio</w>I’m starting to look at meander <code>rewrite</code> fn as a “reduce via pattern matching”, do you think this a good/valid way to think about it?</z><z id="t1632506708" t="ribelo :thinking_face:"><y>#</y><d>2021-09-24</d><h>18:05</h><r>ribelo</r><b>:thinking_face:</b></z><z id="t1632506994" t="ribelo rewrite + cata"><y>#</y><d>2021-09-24</d><h>18:09</h><r>ribelo</r><code>rewrite + cata</code></z><z id="t1632509961" t="markaddleman &quot;reduce via pattern matching&quot; - do you mean some form of optimization?"><y>#</y><d>2021-09-24</d><h>18:59</h><r>markaddleman</r>&quot;reduce via pattern matching&quot; - do you mean some form of optimization?</z><z id="t1632510020" t="markaddleman fwiw, I&apos;m using meander to generate SQL queries and perform some optimizations on them . in general it works very well."><y>#</y><d>2021-09-24</d><h>19:00</h><r>markaddleman</r>fwiw, I&apos;m using meander to generate SQL queries and perform some optimizations on them .  in general it works very well.</z><z id="t1632512625" t="ribelo probably the point, at least as I understand it, is that rewrite + cata can be simplified as reduce , where you laboriously build up the output data using pattern matching"><y>#</y><d>2021-09-24</d><h>19:43</h><r>ribelo</r>probably the point, at least as I understand it, is that <code>rewrite + cata</code> can be simplified as <code>reduce</code>, where you laboriously build up the output data using <code>pattern matching</code></z><z id="t1632512635" t="ribelo and I think it is accurate"><y>#</y><d>2021-09-24</d><h>19:43</h><r>ribelo</r>and I think it is accurate</z><z id="t1632514758" t="markaddleman Oh, yes. I completely misunderstood wilker&apos;s comment"><y>#</y><d>2021-09-24</d><h>20:19</h><r>markaddleman</r>Oh, yes.  I completely misunderstood wilker&apos;s comment</z><z id="t1632527242" t="noprompt I think so. Rewrite systems are also known as “reduction systems”."><y>#</y><d>2021-09-24</d><h>23:47</h><r>noprompt</r>I think so. Rewrite systems are also known as “reduction systems”.</z><z id="t1632527408" t="noprompt Normally the pattern matching/substitution bit is assumed in that context."><y>#</y><d>2021-09-24</d><h>23:50</h><r>noprompt</r>Normally the pattern matching/substitution bit is assumed in that context.</z><z id="t1632527432" t="noprompt So I think the “via” bit is useful. 🙂"><y>#</y><d>2021-09-24</d><h>23:50</h><r>noprompt</r>So I think the “via” bit is useful. <b>🙂</b></z><z id="t1632533502" t="wilkerlucio [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] the more I use Meander more I get amazed by it, its such a different level of thinking, I love it ❤️ , I’m getting more curious about the underlying idea, can you tell me what inspired you to do it? is there another language in a library doing something similar? or you just had some eureka moment to get to it?"><y>#</y><d>2021-09-25</d><h>01:31</h><r>wilkerlucio</r><a>@U06MDAPTP</a> the more I use Meander more I get amazed by it, its such a different level of thinking, I love it <b>❤️</b>, I’m getting more curious about the underlying idea, can you tell me what inspired you to do it? is there another language in a library doing something similar? or you just had some eureka moment to get to it?</z><z id="t1632775335" t="noprompt [:attrs {:href &quot;/_/_/users/U066U8JQJ&quot;}] I should probably jot this down somewhere because I’ve been asked about this a few times, but several things influenced/inspired me toward the project and it’s difficult to pin down a single inspiration. Pattern matching/substitution; regular expression; the perpetual labor of having to read programs to understand what they doing; the numerous asymmetries between constructing and deconstructing data in virtually all mainstream programming languages; the fact data as represented by literal notation requires virtually no “reasoning” and the assumption that the closer code can be to data — in the literal data sense — the easier it should be to “reason” about; the fact semantically equivalent data can be constructed infinitely many ways with functions but finitely many ways as with literal notation; it’s a big list."><y>#</y><d>2021-09-27</d><h>20:42</h><r>noprompt</r><a>@U066U8JQJ</a> I should probably jot this down somewhere because I’ve been asked about this a few times, but several things influenced/inspired me toward the project and it’s difficult to pin down a single inspiration. Pattern matching/substitution; regular expression; the perpetual labor of having to read programs to understand what they doing; the numerous asymmetries between constructing and deconstructing data in virtually all mainstream programming languages; the fact data as represented by literal notation requires virtually no “reasoning” and the assumption that the closer code can be to data — in the literal data sense — the easier it should be to “reason” about; the fact semantically equivalent data can be constructed infinitely many ways with functions but finitely many ways as with literal notation; it’s a big list.</z><z id="t1632776014" t="noprompt In the past couple years, I’ve spent much more time reflecting on my sensitivity to situations connected to writing software. When we’re reading code we have to hold this mental model of what something “looks like” in our minds. I have poor executive function and often have to rely on writing things down to keep track of something that I’m reading. Other people might have a better executive function than myself but, generally speaking, it’s not that much better."><y>#</y><d>2021-09-27</d><h>20:53</h><r>noprompt</r>In the past couple years, I’ve spent much more time reflecting on my sensitivity to situations connected to writing software. When we’re reading code we have to hold this mental model of what something “looks like” in our minds. I have poor executive function and often have to rely on writing things down to keep track of something that I’m reading. Other people might have a better executive function than myself but, generally speaking, it’s not that much better.</z><z id="t1632845589" t="noprompt I meant to complete these thoughts yesterday but got pulled away. Anyway, the sum total of all of this and some other stuff (I didn’t say more about the writing part of software) contributed to starting on the project about 5ish years ago."><y>#</y><d>2021-09-28</d><h>16:13</h><r>noprompt</r>I meant to complete these thoughts yesterday but got pulled away. Anyway, the sum total of all of this and some other stuff (I didn’t say more about the writing part of software) contributed to starting on the project about 5ish years ago.</z><z id="t1632857972" t="wilkerlucio hello, I’m looking for some operation to sub match , I’m not sure if there is one, but if it existed I expected to working something like this: (def items {1 {:a &quot;a&quot; :b &quot;b&quot;}}) (m/find {:id 1} {:id (m/sub-match (m/app items ?item) {:a ?a})} ?a)"><y>#</y><d>2021-09-28</d><h>19:39</h><w>wilkerlucio</w>hello, I’m looking for some operation to <code>sub match</code>, I’m not sure if there is one, but if it existed I expected to working something like this:

<pre>(def items
  {1 {:a &quot;a&quot;
      :b &quot;b&quot;}})

(m/find {:id 1}
  {:id (m/sub-match (m/app items ?item)
         {:a ?a})}
  ?a)</pre></z><z id="t1632857982" t="wilkerlucio is there an operator or way to do that?"><y>#</y><d>2021-09-28</d><h>19:39</h><r>wilkerlucio</r>is there an operator or way to do that?</z><z id="t1632858002" t="wilkerlucio in terms of text, I want to extract some data point, get over a fn (using m/app ) and them match again over that result"><y>#</y><d>2021-09-28</d><h>19:40</h><r>wilkerlucio</r>in terms of text, I want to extract some data point, get over a fn (using <code>m/app</code>) and them match again over that result</z><z id="t1632859467" t="ribelo [:attrs {:href &quot;/_/_/users/U066U8JQJ&quot;}] every problem can be solved with a finite number of m/cata"><y>#</y><d>2021-09-28</d><h>20:04</h><r>ribelo</r><a>@U066U8JQJ</a> every problem can be solved with a finite number of <code>m/cata</code></z><z id="t1632859788" t="ribelo (def items {1 {:a &quot;a&quot; :b &quot;b&quot;}}) (m/rewrite {:id 1} {:id (m/app items ?item)} (m/cata [:sub-match ?item]) [:sub-match ?x] [:after-sub-match ?x]) "><y>#</y><d>2021-09-28</d><h>20:09</h><r>ribelo</r><pre>(def items
  {1 {:a &quot;a&quot;
      :b &quot;b&quot;}})

(m/rewrite {:id 1}
  {:id (m/app items ?item)}
  (m/cata [:sub-match ?item])
  [:sub-match ?x]
  [:after-sub-match ?x])</pre>
</z><z id="t1632860470" t="jgdavey"><y>#</y><d>2021-09-28</d><h>20:21</h><r>jgdavey</r></z><z id="t1632860472" t="jgdavey Sometimes, I also shove more information into the data structure in question. In your case, it looks a little like a join."><y>#</y><d>2021-09-28</d><h>20:21</h><r>jgdavey</r>Sometimes, I also shove more information into the data structure in question. In your case, it looks a little like a join.</z><z id="t1632920072" t="wilkerlucio nice! the integrated index solution is neat 🙂"><y>#</y><d>2021-09-29</d><h>12:54</h><r>wilkerlucio</r>nice! the integrated index solution is neat <b>🙂</b></z><z id="t1633058947" t="markaddleman I have to transform a bunch of XML files. The transformations are all basically the same: reach into the XML tree and pick out elements of data and flatten the result into a sequence of maps. I just invented a data language that describes the paths to the data elements and each data elements&apos; output name. Then, I use meander to translate that data language into a meander program which performs the XML transformation. All this took a couple of hours. meander^2 is awesome. That is all 🙂"><y>#</y><d>2021-10-01</d><h>03:29</h><w>markaddleman</w>I have to transform a bunch of XML files.  The transformations are all basically the same:  reach into the XML tree and pick out elements of data and flatten the result into a sequence of maps.

I just invented a data language that describes the paths to the data elements   and each data elements&apos; output name. Then, I use meander to translate that data language into a meander program which performs the XML transformation.

All this took a couple of hours.

meander^2 is awesome.

That is all <b>🙂</b></z><z id="t1634427470" t="Richie Hey! Can I use with with rewrite ? Or should I use defsyntax ?"><y>#</y><d>2021-10-16</d><h>23:37</h><w>Richie</w>Hey! Can I use <code>with</code> with <code>rewrite</code>? Or should I use <code>defsyntax</code>?</z><z id="t1634427846" t="Jimmy Miller You can use with with rewrite."><y>#</y><d>2021-10-16</d><h>23:44</h><w>Jimmy Miller</w>You can use with with rewrite.</z><z id="t1634428148" t="Richie (m/rewrite (vec &quot;a&quot;) (m/with [%ident \a] [%ident] &apos;a)) This wouldn&apos;t make sense since I need to pass the patterns to rewrite meander complains that rewrite requires an even number of forms. (m/with [%ident \a] (m/rewrite (vec &quot;a&quot;) [%ident] &apos;a)) This doesn&apos;t work right away since clojure just says that it can&apos;t resolve %ident. I tried quoting things but haven&apos;t figured it out. e.g. (m/with &apos;[%ident \a] (m/rewrite (vec &quot;a&quot;) [%ident] &apos;a)) Unbound reference %ident"><y>#</y><d>2021-10-16</d><h>23:49</h><w>Richie</w><pre>(m/rewrite (vec &quot;a&quot;)
  (m/with [%ident \a]
    [%ident] &apos;a))</pre>
This wouldn&apos;t make sense since I need to pass the patterns to rewrite meander complains that rewrite requires an even number of forms.
<pre>(m/with [%ident \a]
  (m/rewrite (vec &quot;a&quot;)
    [%ident] &apos;a))</pre>
This doesn&apos;t work right away since clojure just says that it can&apos;t resolve %ident. I tried quoting things but haven&apos;t figured it out. e.g.
<pre>(m/with &apos;[%ident \a]
  (m/rewrite (vec &quot;a&quot;)
    [%ident] &apos;a))</pre>
<code>Unbound reference %ident</code></z><z id="t1634428242" t="Richie Show: Project-Only All Hide: Clojure Java REPL Tooling Duplicates (26 frames hidden) 2. Unhandled clojure.lang.Compiler$CompilerException Error compiling c:/Users/richie/Documents/org/projects/fun-with-meander/meander-fun/src/rgkirch/core/main.clj at (51:3) #:clojure.error{:phase :macro-syntax-check, :line 51, :column 3, :source &quot;c:/Users/richie/Documents/org/projects/fun-with-meander/meander-fun/src/rgkirch/core/main.clj&quot;, :symbol m/rewrite} Compiler.java: 7014 clojure.lang.Compiler/macroexpand1 Compiler.java: 7097 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 3892 clojure.lang.Compiler$InvokeExpr/parse Compiler.java: 7113 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 6124 clojure.lang.Compiler$BodyExpr$Parser/parse Compiler.java: 5471 clojure.lang.Compiler$FnMethod/parse Compiler.java: 4033 clojure.lang.Compiler$FnExpr/parse Compiler.java: 7109 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7178 clojure.lang.Compiler/eval Compiler.java: 7136 clojure.lang.Compiler/eval core.clj: 3202 clojure.core/eval core.clj: 3198 clojure.core/eval interruptible_eval.clj: 87 nrepl.middleware.interruptible-eval/evaluate/fn/fn AFn.java: 152 clojure.lang.AFn/applyToHelper AFn.java: 144 clojure.lang.AFn/applyTo core.clj: 667 clojure.core/apply core.clj: 1977 clojure.core/with-bindings* core.clj: 1977 clojure.core/with-bindings* RestFn.java: 425 clojure.lang.RestFn/invoke interruptible_eval.clj: 87 nrepl.middleware.interruptible-eval/evaluate/fn main.clj: 437 clojure.main/repl/read-eval-print/fn main.clj: 437 clojure.main/repl/read-eval-print main.clj: 458 clojure.main/repl/fn main.clj: 458 clojure.main/repl main.clj: 368 clojure.main/repl RestFn.java: 1523 clojure.lang.RestFn/invoke interruptible_eval.clj: 84 nrepl.middleware.interruptible-eval/evaluate interruptible_eval.clj: 56 nrepl.middleware.interruptible-eval/evaluate interruptible_eval.clj: 152 nrepl.middleware.interruptible-eval/interruptible-eval/fn/fn AFn.java: 22 clojure.lang.AFn/run session.clj: 202 nrepl.middleware.session/session-exec/main-loop/fn session.clj: 201 nrepl.middleware.session/session-exec/main-loop AFn.java: 22 clojure.lang.AFn/run Thread.java: 831 java.lang.Thread/run 1. Caused by clojure.lang.ExceptionInfo Unbound reference %ident {:env {:lvrs #{}, :mvrs #{}, :refs {}, :path [[%ident]]}, :reference %ident, :syntax-trace [%ident [%ident]]} epsilon.cljc: 127 meander.match.check.epsilon$check/invokeStatic epsilon.cljc: 116 meander.match.check.epsilon$check/invoke epsilon.cljc: 2016 meander.match.epsilon$analyze_find_args$fn__10654/invoke core.clj: 7327 clojure.core/keep/fn/fn protocols.clj: 168 clojure.core.protocols/fn protocols.clj: 124 clojure.core.protocols/fn protocols.clj: 19 clojure.core.protocols/fn/G protocols.clj: 31 clojure.core.protocols/seq-reduce protocols.clj: 75 clojure.core.protocols/fn protocols.clj: 75 clojure.core.protocols/fn protocols.clj: 13 clojure.core.protocols/fn/G core.clj: 6886 clojure.core/transduce core.clj: 6901 clojure.core/into core.clj: 6889 clojure.core/into epsilon.cljc: 2014 meander.match.epsilon$analyze_find_args/invokeStatic epsilon.cljc: 1991 meander.match.epsilon$analyze_find_args/invoke epsilon.clj: 17 meander.rewrite.epsilon/analyze-rewrite-args epsilon.clj: 13 meander.rewrite.epsilon/analyze-rewrite-args epsilon.clj: 54 meander.rewrite.epsilon/compile-rewrite-args epsilon.clj: 51 meander.rewrite.epsilon/compile-rewrite-args epsilon.clj: 199 meander.epsilon/rewrite epsilon.clj: 185 meander.epsilon/rewrite RestFn.java: 146 clojure.lang.RestFn/applyTo Var.java: 705 clojure.lang.Var/applyTo Compiler.java: 6997 clojure.lang.Compiler/macroexpand1 Compiler.java: 7097 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 3892 clojure.lang.Compiler$InvokeExpr/parse Compiler.java: 7113 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 6124 clojure.lang.Compiler$BodyExpr$Parser/parse Compiler.java: 5471 clojure.lang.Compiler$FnMethod/parse Compiler.java: 4033 clojure.lang.Compiler$FnExpr/parse Compiler.java: 7109 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7178 clojure.lang.Compiler/eval Compiler.java: 7136 clojure.lang.Compiler/eval core.clj: 3202 clojure.core/eval core.clj: 3198 clojure.core/eval interruptible_eval.clj: 87 nrepl.middleware.interruptible-eval/evaluate/fn/fn AFn.java: 152 clojure.lang.AFn/applyToHelper AFn.java: 144 clojure.lang.AFn/applyTo core.clj: 667 clojure.core/apply core.clj: 1977 clojure.core/with-bindings* core.clj: 1977 clojure.core/with-bindings* RestFn.java: 425 clojure.lang.RestFn/invoke interruptible_eval.clj: 87 nrepl.middleware.interruptible-eval/evaluate/fn main.clj: 437 clojure.main/repl/read-eval-print/fn main.clj: 437 clojure.main/repl/read-eval-print main.clj: 458 clojure.main/repl/fn main.clj: 458 clojure.main/repl main.clj: 368 clojure.main/repl RestFn.java: 1523 clojure.lang.RestFn/invoke interruptible_eval.clj: 84 nrepl.middleware.interruptible-eval/evaluate interruptible_eval.clj: 56 nrepl.middleware.interruptible-eval/evaluate interruptible_eval.clj: 152 nrepl.middleware.interruptible-eval/interruptible-eval/fn/fn AFn.java: 22 clojure.lang.AFn/run session.clj: 202 nrepl.middleware.session/session-exec/main-loop/fn session.clj: 201 nrepl.middleware.session/session-exec/main-loop AFn.java: 22 clojure.lang.AFn/run Thread.java: 831 java.lang.Thread/run "><y>#</y><d>2021-10-16</d><h>23:50</h><r>Richie</r><pre>Show: Project-Only All 
  Hide: Clojure Java REPL Tooling Duplicates  (26 frames hidden)

2. Unhandled clojure.lang.Compiler$CompilerException
   Error compiling c:/Users/richie/Documents/org/projects/fun-with-meander/meander-fun/src/rgkirch/core/main.clj at (51:3)
   #:clojure.error{:phase :macro-syntax-check,
                   :line 51,
                   :column 3,
                   :source
                   &quot;c:/Users/richie/Documents/org/projects/fun-with-meander/meander-fun/src/rgkirch/core/main.clj&quot;,
                   :symbol m/rewrite}
             Compiler.java: 7014  clojure.lang.Compiler/macroexpand1
             Compiler.java: 7097  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 3892  clojure.lang.Compiler$InvokeExpr/parse
             Compiler.java: 7113  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 6124  clojure.lang.Compiler$BodyExpr$Parser/parse
             Compiler.java: 5471  clojure.lang.Compiler$FnMethod/parse
             Compiler.java: 4033  clojure.lang.Compiler$FnExpr/parse
             Compiler.java: 7109  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7178  clojure.lang.Compiler/eval
             Compiler.java: 7136  clojure.lang.Compiler/eval
                  core.clj: 3202  clojure.core/eval
                  core.clj: 3198  clojure.core/eval
    interruptible_eval.clj:   87  nrepl.middleware.interruptible-eval/evaluate/fn/fn
                  AFn.java:  152  clojure.lang.AFn/applyToHelper
                  AFn.java:  144  clojure.lang.AFn/applyTo
                  core.clj:  667  clojure.core/apply
                  core.clj: 1977  clojure.core/with-bindings*
                  core.clj: 1977  clojure.core/with-bindings*
               RestFn.java:  425  clojure.lang.RestFn/invoke
    interruptible_eval.clj:   87  nrepl.middleware.interruptible-eval/evaluate/fn
                  main.clj:  437  clojure.main/repl/read-eval-print/fn
                  main.clj:  437  clojure.main/repl/read-eval-print
                  main.clj:  458  clojure.main/repl/fn
                  main.clj:  458  clojure.main/repl
                  main.clj:  368  clojure.main/repl
               RestFn.java: 1523  clojure.lang.RestFn/invoke
    interruptible_eval.clj:   84  nrepl.middleware.interruptible-eval/evaluate
    interruptible_eval.clj:   56  nrepl.middleware.interruptible-eval/evaluate
    interruptible_eval.clj:  152  nrepl.middleware.interruptible-eval/interruptible-eval/fn/fn
                  AFn.java:   22  clojure.lang.AFn/run
               session.clj:  202  nrepl.middleware.session/session-exec/main-loop/fn
               session.clj:  201  nrepl.middleware.session/session-exec/main-loop
                  AFn.java:   22  clojure.lang.AFn/run
               Thread.java:  831  java.lang.Thread/run

1. Caused by clojure.lang.ExceptionInfo
   Unbound reference %ident
   {:env {:lvrs #{}, :mvrs #{}, :refs {}, :path [[%ident]]},
    :reference %ident,
    :syntax-trace [%ident [%ident]]}
              epsilon.cljc:  127  meander.match.check.epsilon$check/invokeStatic
              epsilon.cljc:  116  meander.match.check.epsilon$check/invoke
              epsilon.cljc: 2016  meander.match.epsilon$analyze_find_args$fn__10654/invoke
                  core.clj: 7327  clojure.core/keep/fn/fn
             protocols.clj:  168  clojure.core.protocols/fn
             protocols.clj:  124  clojure.core.protocols/fn
             protocols.clj:   19  clojure.core.protocols/fn/G
             protocols.clj:   31  clojure.core.protocols/seq-reduce
             protocols.clj:   75  clojure.core.protocols/fn
             protocols.clj:   75  clojure.core.protocols/fn
             protocols.clj:   13  clojure.core.protocols/fn/G
                  core.clj: 6886  clojure.core/transduce
                  core.clj: 6901  clojure.core/into
                  core.clj: 6889  clojure.core/into
              epsilon.cljc: 2014  meander.match.epsilon$analyze_find_args/invokeStatic
              epsilon.cljc: 1991  meander.match.epsilon$analyze_find_args/invoke
               epsilon.clj:   17  meander.rewrite.epsilon/analyze-rewrite-args
               epsilon.clj:   13  meander.rewrite.epsilon/analyze-rewrite-args
               epsilon.clj:   54  meander.rewrite.epsilon/compile-rewrite-args
               epsilon.clj:   51  meander.rewrite.epsilon/compile-rewrite-args
               epsilon.clj:  199  meander.epsilon/rewrite
               epsilon.clj:  185  meander.epsilon/rewrite
               RestFn.java:  146  clojure.lang.RestFn/applyTo
                  Var.java:  705  clojure.lang.Var/applyTo
             Compiler.java: 6997  clojure.lang.Compiler/macroexpand1
             Compiler.java: 7097  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 3892  clojure.lang.Compiler$InvokeExpr/parse
             Compiler.java: 7113  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 6124  clojure.lang.Compiler$BodyExpr$Parser/parse
             Compiler.java: 5471  clojure.lang.Compiler$FnMethod/parse
             Compiler.java: 4033  clojure.lang.Compiler$FnExpr/parse
             Compiler.java: 7109  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7178  clojure.lang.Compiler/eval
             Compiler.java: 7136  clojure.lang.Compiler/eval
                  core.clj: 3202  clojure.core/eval
                  core.clj: 3198  clojure.core/eval
    interruptible_eval.clj:   87  nrepl.middleware.interruptible-eval/evaluate/fn/fn
                  AFn.java:  152  clojure.lang.AFn/applyToHelper
                  AFn.java:  144  clojure.lang.AFn/applyTo
                  core.clj:  667  clojure.core/apply
                  core.clj: 1977  clojure.core/with-bindings*
                  core.clj: 1977  clojure.core/with-bindings*
               RestFn.java:  425  clojure.lang.RestFn/invoke
    interruptible_eval.clj:   87  nrepl.middleware.interruptible-eval/evaluate/fn
                  main.clj:  437  clojure.main/repl/read-eval-print/fn
                  main.clj:  437  clojure.main/repl/read-eval-print
                  main.clj:  458  clojure.main/repl/fn
                  main.clj:  458  clojure.main/repl
                  main.clj:  368  clojure.main/repl
               RestFn.java: 1523  clojure.lang.RestFn/invoke
    interruptible_eval.clj:   84  nrepl.middleware.interruptible-eval/evaluate
    interruptible_eval.clj:   56  nrepl.middleware.interruptible-eval/evaluate
    interruptible_eval.clj:  152  nrepl.middleware.interruptible-eval/interruptible-eval/fn/fn
                  AFn.java:   22  clojure.lang.AFn/run
               session.clj:  202  nrepl.middleware.session/session-exec/main-loop/fn
               session.clj:  201  nrepl.middleware.session/session-exec/main-loop
                  AFn.java:   22  clojure.lang.AFn/run
               Thread.java:  831  java.lang.Thread/run</pre>
</z><z id="t1634429514" t="Richie Hmm. I&apos;d expect (m/with [%ident \a] (m/rewrite ... to work since m/with is defined with defsyntax which says that &quot;it defines a function which will be called with unevaluated arguments&quot;"><y>#</y><d>2021-10-17</d><h>00:11</h><r>Richie</r>Hmm. I&apos;d expect <code>(m/with [%ident \a] (m/rewrite ...</code> to work since <code>m/with</code> is defined with <code>defsyntax</code> which says that &quot;it defines a function which will be called with unevaluated arguments&quot;</z><z id="t1634429557" t="Richie Show: Project-Only All Hide: Clojure Java REPL Tooling Duplicates (29 frames hidden) 2. Unhandled clojure.lang.Compiler$CompilerException Error compiling c:/Users/richie/Documents/org/projects/fun-with-meander/meander-fun/src/rgkirch/core/main.clj at (51:1) #:clojure.error{:phase :compile-syntax-check, :line 51, :column 1, :source &quot;c:/Users/richie/Documents/org/projects/fun-with-meander/meander-fun/src/rgkirch/core/main.clj&quot;} Compiler.java: 6812 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 3264 clojure.lang.Compiler$VectorExpr/parse Compiler.java: 6795 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 3892 clojure.lang.Compiler$InvokeExpr/parse Compiler.java: 7113 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 6124 clojure.lang.Compiler$BodyExpr$Parser/parse Compiler.java: 5471 clojure.lang.Compiler$FnMethod/parse Compiler.java: 4033 clojure.lang.Compiler$FnExpr/parse Compiler.java: 7109 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7178 clojure.lang.Compiler/eval Compiler.java: 7136 clojure.lang.Compiler/eval core.clj: 3202 clojure.core/eval core.clj: 3198 clojure.core/eval interruptible_eval.clj: 87 nrepl.middleware.interruptible-eval/evaluate/fn/fn AFn.java: 152 clojure.lang.AFn/applyToHelper AFn.java: 144 clojure.lang.AFn/applyTo core.clj: 667 clojure.core/apply core.clj: 1977 clojure.core/with-bindings* core.clj: 1977 clojure.core/with-bindings* RestFn.java: 425 clojure.lang.RestFn/invoke interruptible_eval.clj: 87 nrepl.middleware.interruptible-eval/evaluate/fn main.clj: 437 clojure.main/repl/read-eval-print/fn main.clj: 437 clojure.main/repl/read-eval-print main.clj: 458 clojure.main/repl/fn main.clj: 458 clojure.main/repl main.clj: 368 clojure.main/repl RestFn.java: 1523 clojure.lang.RestFn/invoke interruptible_eval.clj: 84 nrepl.middleware.interruptible-eval/evaluate interruptible_eval.clj: 56 nrepl.middleware.interruptible-eval/evaluate interruptible_eval.clj: 152 nrepl.middleware.interruptible-eval/interruptible-eval/fn/fn AFn.java: 22 clojure.lang.AFn/run session.clj: 202 nrepl.middleware.session/session-exec/main-loop/fn session.clj: 201 nrepl.middleware.session/session-exec/main-loop AFn.java: 22 clojure.lang.AFn/run Thread.java: 831 java.lang.Thread/run 1. Caused by java.lang.RuntimeException Unable to resolve symbol: %ident in this context Util.java: 221 clojure.lang.Util/runtimeException Compiler.java: 7418 clojure.lang.Compiler/resolveIn Compiler.java: 7362 clojure.lang.Compiler/resolve Compiler.java: 7323 clojure.lang.Compiler/analyzeSymbol Compiler.java: 6772 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 3264 clojure.lang.Compiler$VectorExpr/parse Compiler.java: 6795 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 3892 clojure.lang.Compiler$InvokeExpr/parse Compiler.java: 7113 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 6124 clojure.lang.Compiler$BodyExpr$Parser/parse Compiler.java: 5471 clojure.lang.Compiler$FnMethod/parse Compiler.java: 4033 clojure.lang.Compiler$FnExpr/parse Compiler.java: 7109 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7178 clojure.lang.Compiler/eval Compiler.java: 7136 clojure.lang.Compiler/eval core.clj: 3202 clojure.core/eval core.clj: 3198 clojure.core/eval interruptible_eval.clj: 87 nrepl.middleware.interruptible-eval/evaluate/fn/fn AFn.java: 152 clojure.lang.AFn/applyToHelper AFn.java: 144 clojure.lang.AFn/applyTo core.clj: 667 clojure.core/apply core.clj: 1977 clojure.core/with-bindings* core.clj: 1977 clojure.core/with-bindings* RestFn.java: 425 clojure.lang.RestFn/invoke interruptible_eval.clj: 87 nrepl.middleware.interruptible-eval/evaluate/fn main.clj: 437 clojure.main/repl/read-eval-print/fn main.clj: 437 clojure.main/repl/read-eval-print main.clj: 458 clojure.main/repl/fn main.clj: 458 clojure.main/repl main.clj: 368 clojure.main/repl RestFn.java: 1523 clojure.lang.RestFn/invoke interruptible_eval.clj: 84 nrepl.middleware.interruptible-eval/evaluate interruptible_eval.clj: 56 nrepl.middleware.interruptible-eval/evaluate interruptible_eval.clj: 152 nrepl.middleware.interruptible-eval/interruptible-eval/fn/fn AFn.java: 22 clojure.lang.AFn/run session.clj: 202 nrepl.middleware.session/session-exec/main-loop/fn session.clj: 201 nrepl.middleware.session/session-exec/main-loop AFn.java: 22 clojure.lang.AFn/run Thread.java: 831 java.lang.Thread/run "><y>#</y><d>2021-10-17</d><h>00:12</h><r>Richie</r><pre>Show: Project-Only All 
  Hide: Clojure Java REPL Tooling Duplicates  (29 frames hidden)

2. Unhandled clojure.lang.Compiler$CompilerException
   Error compiling c:/Users/richie/Documents/org/projects/fun-with-meander/meander-fun/src/rgkirch/core/main.clj at (51:1)
   #:clojure.error{:phase :compile-syntax-check,
                   :line 51,
                   :column 1,
                   :source
                   &quot;c:/Users/richie/Documents/org/projects/fun-with-meander/meander-fun/src/rgkirch/core/main.clj&quot;}
             Compiler.java: 6812  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 3264  clojure.lang.Compiler$VectorExpr/parse
             Compiler.java: 6795  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 3892  clojure.lang.Compiler$InvokeExpr/parse
             Compiler.java: 7113  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 6124  clojure.lang.Compiler$BodyExpr$Parser/parse
             Compiler.java: 5471  clojure.lang.Compiler$FnMethod/parse
             Compiler.java: 4033  clojure.lang.Compiler$FnExpr/parse
             Compiler.java: 7109  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7178  clojure.lang.Compiler/eval
             Compiler.java: 7136  clojure.lang.Compiler/eval
                  core.clj: 3202  clojure.core/eval
                  core.clj: 3198  clojure.core/eval
    interruptible_eval.clj:   87  nrepl.middleware.interruptible-eval/evaluate/fn/fn
                  AFn.java:  152  clojure.lang.AFn/applyToHelper
                  AFn.java:  144  clojure.lang.AFn/applyTo
                  core.clj:  667  clojure.core/apply
                  core.clj: 1977  clojure.core/with-bindings*
                  core.clj: 1977  clojure.core/with-bindings*
               RestFn.java:  425  clojure.lang.RestFn/invoke
    interruptible_eval.clj:   87  nrepl.middleware.interruptible-eval/evaluate/fn
                  main.clj:  437  clojure.main/repl/read-eval-print/fn
                  main.clj:  437  clojure.main/repl/read-eval-print
                  main.clj:  458  clojure.main/repl/fn
                  main.clj:  458  clojure.main/repl
                  main.clj:  368  clojure.main/repl
               RestFn.java: 1523  clojure.lang.RestFn/invoke
    interruptible_eval.clj:   84  nrepl.middleware.interruptible-eval/evaluate
    interruptible_eval.clj:   56  nrepl.middleware.interruptible-eval/evaluate
    interruptible_eval.clj:  152  nrepl.middleware.interruptible-eval/interruptible-eval/fn/fn
                  AFn.java:   22  clojure.lang.AFn/run
               session.clj:  202  nrepl.middleware.session/session-exec/main-loop/fn
               session.clj:  201  nrepl.middleware.session/session-exec/main-loop
                  AFn.java:   22  clojure.lang.AFn/run
               Thread.java:  831  java.lang.Thread/run

1. Caused by java.lang.RuntimeException
   Unable to resolve symbol: %ident in this context

                 Util.java:  221  clojure.lang.Util/runtimeException
             Compiler.java: 7418  clojure.lang.Compiler/resolveIn
             Compiler.java: 7362  clojure.lang.Compiler/resolve
             Compiler.java: 7323  clojure.lang.Compiler/analyzeSymbol
             Compiler.java: 6772  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 3264  clojure.lang.Compiler$VectorExpr/parse
             Compiler.java: 6795  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 3892  clojure.lang.Compiler$InvokeExpr/parse
             Compiler.java: 7113  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 6124  clojure.lang.Compiler$BodyExpr$Parser/parse
             Compiler.java: 5471  clojure.lang.Compiler$FnMethod/parse
             Compiler.java: 4033  clojure.lang.Compiler$FnExpr/parse
             Compiler.java: 7109  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7178  clojure.lang.Compiler/eval
             Compiler.java: 7136  clojure.lang.Compiler/eval
                  core.clj: 3202  clojure.core/eval
                  core.clj: 3198  clojure.core/eval
    interruptible_eval.clj:   87  nrepl.middleware.interruptible-eval/evaluate/fn/fn
                  AFn.java:  152  clojure.lang.AFn/applyToHelper
                  AFn.java:  144  clojure.lang.AFn/applyTo
                  core.clj:  667  clojure.core/apply
                  core.clj: 1977  clojure.core/with-bindings*
                  core.clj: 1977  clojure.core/with-bindings*
               RestFn.java:  425  clojure.lang.RestFn/invoke
    interruptible_eval.clj:   87  nrepl.middleware.interruptible-eval/evaluate/fn
                  main.clj:  437  clojure.main/repl/read-eval-print/fn
                  main.clj:  437  clojure.main/repl/read-eval-print
                  main.clj:  458  clojure.main/repl/fn
                  main.clj:  458  clojure.main/repl
                  main.clj:  368  clojure.main/repl
               RestFn.java: 1523  clojure.lang.RestFn/invoke
    interruptible_eval.clj:   84  nrepl.middleware.interruptible-eval/evaluate
    interruptible_eval.clj:   56  nrepl.middleware.interruptible-eval/evaluate
    interruptible_eval.clj:  152  nrepl.middleware.interruptible-eval/interruptible-eval/fn/fn
                  AFn.java:   22  clojure.lang.AFn/run
               session.clj:  202  nrepl.middleware.session/session-exec/main-loop/fn
               session.clj:  201  nrepl.middleware.session/session-exec/main-loop
                  AFn.java:   22  clojure.lang.AFn/run
               Thread.java:  831  java.lang.Thread/run</pre>
</z><z id="t1634428164" t="Richie Thanks for the help."><y>#</y><d>2021-10-16</d><h>23:49</h><w>Richie</w>Thanks for the help.</z><z id="t1634431660" t="Jimmy Miller On mobile sadly. But you need an output. You have the input. A left-hand side pattern to match. But you don&apos;t define any output. (m/rewrite &quot;x&quot; (m/with [%x ?x] %x) ?x)"><y>#</y><d>2021-10-17</d><h>00:47</h><w>Jimmy Miller</w>On mobile sadly. But you need an output. You have the input. A left-hand side pattern to match. But you don&apos;t define any output. 

<pre>(m/rewrite &quot;x&quot; 
   (m/with [%x ?x] %x)
   ?x)</pre></z><z id="t1634506609" t="Richie Yes, thank you. I was expecting to apply with to all of the patterns but I see that&apos;s not how it works. Thank you for the help."><y>#</y><d>2021-10-17</d><h>21:36</h><r>Richie</r>Yes, thank you. I was expecting to apply <code>with</code> to all of the patterns but I see that&apos;s not how it works. Thank you for the help.</z><z id="t1634431719" t="Jimmy Miller Maybe &apos;a was meant to be the output? If so it was inside the with instead of outside."><y>#</y><d>2021-10-17</d><h>00:48</h><w>Jimmy Miller</w>Maybe &apos;a was meant to be the output? If so it was inside the with instead of outside.</z><z id="t1634506627" t="Richie Yea, I intended &apos;a to be the output. Thanks again!"><y>#</y><d>2021-10-17</d><h>21:37</h><r>Richie</r>Yea, I intended &apos;a to be the output. Thanks again!</z><z id="t1634973454" t="Ben Sless Is there a convenient way to compile patterns without resorting to something like (defn compile-match [pat] (eval `(fn [~&apos;x] (e/match ~&apos;x ~pat true)))) ?"><y>#</y><d>2021-10-23</d><h>07:17</h><w>Ben Sless</w>Is there a convenient way to compile patterns without resorting to something like
<pre>(defn compile-match
  [pat]
  (eval `(fn [~&apos;x] (e/match ~&apos;x ~pat true))))</pre>
?</z><z id="t1634986798" t="markaddleman Can you use a strategy to dynamically compose the patterns? It not, check out meander interpreter. Not compiled and much slowe, but the interpreter does take data."><y>#</y><d>2021-10-23</d><h>10:59</h><r>markaddleman</r>Can you use a strategy to dynamically compose the patterns? It not, check out meander interpreter. Not compiled and much slowe, but the interpreter does take data.</z><z id="t1634989928" t="Ben Sless I don&apos;t really mind using eval, but I wouldn&apos;t do that with data coming over the wire"><y>#</y><d>2021-10-23</d><h>11:52</h><r>Ben Sless</r>I don&apos;t really mind using eval, but I wouldn&apos;t do that with data coming over the wire</z><z id="t1634974485" t="ribelo why not macro?"><y>#</y><d>2021-10-23</d><h>07:34</h><w>ribelo</w>why not macro?</z><z id="t1634974542" t="Ben Sless want to pass it as data"><y>#</y><d>2021-10-23</d><h>07:35</h><w>Ben Sless</w>want to pass it as data</z><z id="t1635003150" t="Jimmy Miller Meander is definitely not optimized around patterns coming over the network. If you allow that, you are ultimately allowing arbitrary code. What we typically recommend is to use meander to write an interpreter/compiler for your own little pattern language."><y>#</y><d>2021-10-23</d><h>15:32</h><w>Jimmy Miller</w>Meander is definitely not optimized around patterns coming over the network. If you allow that, you are ultimately allowing arbitrary code. 

What we typically recommend is to use meander to write an interpreter/compiler for your own little pattern language.</z><z id="t1635260381" t="Richie Hey. I&apos;m stuck trying to parse a string into sexps and I&apos;d appreciate help. Thanks! https://github.com/noprompt/meander/discussions/216"><y>#</y><d>2021-10-26</d><h>14:59</h><w>Richie</w>Hey. I&apos;m stuck trying to parse a string into sexps and I&apos;d appreciate help. Thanks! <a href="https://github.com/noprompt/meander/discussions/216" target="_blank">https://github.com/noprompt/meander/discussions/216</a></z><z id="t1635361389" t="noprompt [:attrs {:href &quot;/_/_/users/UPD88PGNT&quot;}] I’ll take a look!"><y>#</y><d>2021-10-27</d><h>19:03</h><w>noprompt</w><a>@rgkirch</a> I’ll take a look!</z><z id="t1635361884" t="Richie Thanks!"><y>#</y><d>2021-10-27</d><h>19:11</h><r>Richie</r>Thanks!</z><z id="t1635369019" t="noprompt I’m sketching up something along with with an explanation and will post to the discussion once its up."><y>#</y><d>2021-10-27</d><h>21:10</h><r>noprompt</r>I’m sketching up something along with with an explanation and will post to the discussion once its up.</z><z id="t1635477316" t="Richie Hey, I don&apos;t want this to go under the radar and I think it&apos;s worth everyone&apos;s time. noprompt gave me a truly eye opening solution to the problem I posed. https://github.com/noprompt/meander/discussions/216#discussioncomment-1555041"><y>#</y><d>2021-10-29</d><h>03:15</h><w>Richie</w>Hey, I don&apos;t want this to go under the radar and I think it&apos;s worth everyone&apos;s time. noprompt gave me a truly eye opening solution to the problem I posed.
<a href="https://github.com/noprompt/meander/discussions/216#discussioncomment-1555041" target="_blank">https://github.com/noprompt/meander/discussions/216#discussioncomment-1555041</a></z><z id="t1635644576" t="Lucy Wang I just contributed (for fun) an implementation based on an explicit state machine here https://github.com/noprompt/meander/discussions/216#discussioncomment-1563336"><y>#</y><d>2021-10-31</d><h>01:42</h><r>Lucy Wang</r>I just contributed (for fun) an implementation based on an explicit state machine here <a href="https://github.com/noprompt/meander/discussions/216#discussioncomment-1563336" target="_blank">https://github.com/noprompt/meander/discussions/216#discussioncomment-1563336</a></z><z id="t1635718896" t="noprompt I love it! Thanks for contributing. 🙂"><y>#</y><d>2021-10-31</d><h>22:21</h><r>noprompt</r>I love it! Thanks for contributing. <b>🙂</b></z><z id="t1635517892" t="Jimmy Miller And with all that explanation, this example might be a bit clearer for people as well. An abstract machine interpreter for the lambda calculus. https://github.com/noprompt/meander/blob/epsilon/examples/cek.clj"><y>#</y><d>2021-10-29</d><h>14:31</h><w>Jimmy Miller</w>And with all that explanation, this example might be a bit clearer for people as well. An abstract machine interpreter for the lambda calculus. <a href="https://github.com/noprompt/meander/blob/epsilon/examples/cek.clj" target="_blank">https://github.com/noprompt/meander/blob/epsilon/examples/cek.clj</a></z><z id="t1635540979" t="ribelo [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] just out of curiosity, how is work progressing on zeta?"><y>#</y><d>2021-10-29</d><h>20:56</h><w>ribelo</w><a>@noprompt</a> just out of curiosity, how is work progressing on zeta?</z><z id="t1635545016" t="noprompt It is progressing but I’m no longer pushing to the zeta branch and I’ve scaled back the amount of time I’m investing in it. After a few different failed iterations to get a unified interface for both compilation and interpretation, I’ve gone back to just having the two separate. All that failed work has come at a cost to my motivation. Plus, working solo gets old after awhile. Compounding all of that has been some really demotivating shit at work. The project is still important to me — I think about it practically everyday — but I’m low on motivation and help."><y>#</y><d>2021-10-29</d><h>22:03</h><r>noprompt</r>It is progressing but I’m no longer pushing to the <code>zeta</code> branch and I’ve scaled back the amount of time I’m investing in it. After a few different failed iterations to get a unified interface for both compilation and interpretation, I’ve gone back to just having the two separate. All that failed work has come at a cost to my motivation. Plus, working solo gets old after awhile. Compounding all of that has been some really demotivating shit at work.

The project is still important to me — I think about it practically everyday — but I’m low on motivation and help.</z><z id="t1635545134" t="noprompt To be totally transparent: the project is not dead."><y>#</y><d>2021-10-29</d><h>22:05</h><r>noprompt</r>To be totally transparent: the project is not dead.</z><z id="t1635545459" t="noprompt To be doubly transparent: I could use a hand. If I need to write down what is needed to complete the next version in the form of tickets, semantics, etc. then I can do that."><y>#</y><d>2021-10-29</d><h>22:10</h><r>noprompt</r>To be doubly transparent: I could use a hand.

If I need to write down what is needed to complete the next version in the form of tickets, semantics, etc. then I can do that.</z><z id="t1635546481" t="Carlo Hey this is one of my favorite projects, so I&apos;m more than up to lend a hand. The only issue (which might very well be a deal-breaker if you want to scale down your time investment) is that I don&apos;t want to work in solitude - I do that at work already. But, if you want to pair on the weekends, I&apos;m up for it 🙂"><y>#</y><d>2021-10-29</d><h>22:28</h><r>Carlo</r>Hey this is one of my favorite projects, so I&apos;m more than up to lend a hand. The only issue (which might very well be a deal-breaker if you want to scale down your time investment) is that I don&apos;t want to work in solitude - I do that at work already. But, if you want to pair on the weekends, I&apos;m up for it <b>🙂</b></z><z id="t1635548325" t="noprompt Pairing on the weekend is difficult for me right now because my kids are still young and its difficult to block out time for that sort of thing. However, I think I could make room for a monthly meet up to discuss the project, make tickets, etc."><y>#</y><d>2021-10-29</d><h>22:58</h><r>noprompt</r>Pairing on the weekend is difficult for me right now because my kids are still young and its difficult to block out time for that sort of thing. However, I think I could make room for a monthly meet up to discuss the project, make tickets, etc.</z><z id="t1635549459" t="noprompt Could something like that work?"><y>#</y><d>2021-10-29</d><h>23:17</h><r>noprompt</r>Could something like that work?</z><z id="t1635650015" t="Richie Can you suggest reading material related to the work? Foundational material? You pointed me at SECD and CEK which both have wikipedia articles with handfuls of citations (which is an intimidating starting point). That is an application of meander that I had not considered. My current plan is to try to use it for everything and experience what works and what doesn&apos;t. I&apos;m nowhere near being able to contribute ideas or code to the project but I&apos;m sympathetic. I&apos;d like to see myself contribute examples and docs in the future but I&apos;m not making a commitment."><y>#</y><d>2021-10-31</d><h>03:13</h><r>Richie</r>Can you suggest reading material related to the work? Foundational material? You pointed me at SECD and CEK which both have wikipedia articles with handfuls of citations (which is an intimidating starting point). That is an application of meander that I had not considered.
My current plan is to try to use it for everything and experience what works and what doesn&apos;t.
I&apos;m nowhere near being able to contribute ideas or code to the project but I&apos;m sympathetic. I&apos;d like to see myself contribute examples and docs in the future but I&apos;m not making a commitment.</z><z id="t1636067136" t="Richie [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] What literature motivated you and influenced meander?"><y>#</y><d>2021-11-04</d><h>23:05</h><r>Richie</r><a>@noprompt</a> What literature motivated you and influenced meander?</z><z id="t1636078810" t="noprompt It was less the literature and more my experiences with programming. But if I had to pick something it&apos;d be the literature connected to Small Step Interpreters, and Operational Semantics (connected to the stuff I mentioned about abstract interpreters in the Github discussion). At the time I&apos;d been really interested in programming languages for a while but I had never encountered anything like the CESK machine. I was really blown away that languages could be interpreted that way. That is what sparked me to start on what would eventually become the rewrite macro."><y>#</y><d>2021-11-05</d><h>02:20</h><r>noprompt</r>It was less the literature and more my experiences with programming. But if I had to pick something it&apos;d be the literature connected to Small Step Interpreters, and Operational Semantics (connected to the stuff I mentioned about abstract interpreters in the Github discussion). At the time I&apos;d been really interested in programming languages for a while but I had never encountered anything like the CESK machine. I was really blown away that languages could be interpreted that way. That is what sparked me to start on what would eventually become the <code>rewrite</code> macro.</z><z id="t1636078889" t="noprompt This was the article that started it: https://matt.might.net/articles/cesk-machines/ Then this paper: https://matt.might.net/papers/vanhorn2010abstract.pdf Then this book: https://mitpress.mit.edu/books/semantics-engineering-plt-redex"><y>#</y><d>2021-11-05</d><h>02:21</h><r>noprompt</r>This was the article that started it: <a href="https://matt.might.net/articles/cesk-machines/" target="_blank">https://matt.might.net/articles/cesk-machines/</a>
Then this paper: <a href="https://matt.might.net/papers/vanhorn2010abstract.pdf" target="_blank">https://matt.might.net/papers/vanhorn2010abstract.pdf</a>
Then this book: <a href="https://mitpress.mit.edu/books/semantics-engineering-plt-redex" target="_blank">https://mitpress.mit.edu/books/semantics-engineering-plt-redex</a></z><z id="t1636079222" t="noprompt Later on, I found out that, in general, I was actually interested in the topic of &quot;term rewriting&quot; and found a lot of inspiration in the languages Maude, TXL, and Stratego. Books on the topic are incredibly dry and, I&apos;ll admit, I found some of the material dense and struggled with it. But even if I didn&apos;t always grasp everything, I&apos;m confident I came away with the main ideas. Sometimes that required a lot digging around on the internet. Sometimes it just meant retracing my steps until the light went off or I gave up and moved on."><y>#</y><d>2021-11-05</d><h>02:27</h><r>noprompt</r>Later on, I found out that, in general, I was actually interested in the topic of &quot;term rewriting&quot; and found a lot of inspiration in the languages Maude, TXL, and Stratego. Books on the topic are incredibly dry and, I&apos;ll admit, I found some of the material dense and struggled with it. But even if I didn&apos;t always grasp everything, I&apos;m confident I came away with the main ideas. Sometimes that required a lot digging around on the internet. Sometimes it just meant retracing my steps until the light went off or I gave up and moved on.</z><z id="t1636157587" t="Richie Thanks."><y>#</y><d>2021-11-06</d><h>00:13</h><r>Richie</r>Thanks.</z><z id="t1636183332" t="Ivan Thanks 👍"><y>#</y><d>2021-11-06</d><h>07:22</h><r>Ivan</r>Thanks <b>👍</b></z><z id="t1635545016" t="noprompt It is progressing but I’m no longer pushing to the zeta branch and I’ve scaled back the amount of time I’m investing in it. After a few different failed iterations to get a unified interface for both compilation and interpretation, I’ve gone back to just having the two separate. All that failed work has come at a cost to my motivation. Plus, working solo gets old after awhile. Compounding all of that has been some really demotivating shit at work. The project is still important to me — I think about it practically everyday — but I’m low on motivation and help."><y>#</y><d>2021-10-29</d><h>22:03</h><w>noprompt</w>It is progressing but I’m no longer pushing to the <code>zeta</code> branch and I’ve scaled back the amount of time I’m investing in it. After a few different failed iterations to get a unified interface for both compilation and interpretation, I’ve gone back to just having the two separate. All that failed work has come at a cost to my motivation. Plus, working solo gets old after awhile. Compounding all of that has been some really demotivating shit at work.

The project is still important to me — I think about it practically everyday — but I’m low on motivation and help.</z><z id="t1635545134" t="noprompt To be totally transparent: the project is not dead."><y>#</y><d>2021-10-29</d><h>22:05</h><w>noprompt</w>To be totally transparent: the project is not dead.</z><z id="t1635545459" t="noprompt To be doubly transparent: I could use a hand. If I need to write down what is needed to complete the next version in the form of tickets, semantics, etc. then I can do that."><y>#</y><d>2021-10-29</d><h>22:10</h><w>noprompt</w>To be doubly transparent: I could use a hand.

If I need to write down what is needed to complete the next version in the form of tickets, semantics, etc. then I can do that.</z><z id="t1635549105" t="ribelo (m/rewrites (:doxa/db #:doxa{:db {}}) (m/and {?t2 {?document {:document/id (m/some ?document-id) , :project (m/or [_ (m/some :foo)] (m/scan [_ :foo]))}}} {?t1 {?bucket {:opsUnmergedField/id (m/some ?bucket-id) , :document (m/or [_ (m/some ?document)] (m/scan [_ (m/some ?document)]))}}}) true) why is it not compiling?"><y>#</y><d>2021-10-29</d><h>23:11</h><w>ribelo</w><pre>(m/rewrites
  (:doxa/db #:doxa{:db {}})
  (m/and
   {?t2 {?document {:document/id (m/some ?document-id) ,
                    :project (m/or [_ (m/some :foo)]
                                   (m/scan [_ :foo]))}}}
   {?t1 {?bucket {:opsUnmergedField/id (m/some ?bucket-id) ,
                  :document (m/or [_ (m/some ?document)]
                                  (m/scan [_ (m/some ?document)]))}}})
  true)</pre>
why is it not compiling?</z><z id="t1635549175" t="ribelo usually when it returns Unable to resolve symbol: T__40212 in this context it means that the order is wrong, but here I cannot come to anything"><y>#</y><d>2021-10-29</d><h>23:12</h><w>ribelo</w>usually when it returns
<pre>Unable to resolve symbol: T__40212 in this context</pre>
it means that the order is wrong, but here I cannot come to anything</z><z id="t1636044529" t="noprompt I&apos;ve been working on this issue. I figured out where the problem is and am close to fixing."><y>#</y><d>2021-11-04</d><h>16:48</h><r>noprompt</r>I&apos;ve been working on this issue. I figured out where the problem is and am close to fixing.</z><z id="t1635549297" t="ribelo after deleting the (m/or from : project , there is no longer any problem"><y>#</y><d>2021-10-29</d><h>23:14</h><w>ribelo</w>after deleting the <code>(m/or</code> from <code>: project</code>,  there is no longer any problem</z><z id="t1635644576" t="Lucy Wang I just contributed (for fun) an implementation based on an explicit state machine here https://github.com/noprompt/meander/discussions/216#discussioncomment-1563336"><y>#</y><d>2021-10-31</d><h>01:42</h><w>Lucy Wang</w>I just contributed (for fun) an implementation based on an explicit state machine here <a href="https://github.com/noprompt/meander/discussions/216#discussioncomment-1563336" target="_blank">https://github.com/noprompt/meander/discussions/216#discussioncomment-1563336</a></z><z id="t1636044529" t="noprompt I&apos;ve been working on this issue. I figured out where the problem is and am close to fixing."><y>#</y><d>2021-11-04</d><h>16:48</h><w>noprompt</w>I&apos;ve been working on this issue. I figured out where the problem is and am close to fixing.</z><z id="t1636048226" t="ribelo Is it possible to use a meander to collect all the symbols from the given data? maybe a meander strategy? not really necessary, but it seems like a cool puzzle"><y>#</y><d>2021-11-04</d><h>17:50</h><w>ribelo</w>Is it possible to use a meander to collect all the symbols from the given data? maybe a meander strategy? not really necessary, but it seems like a cool puzzle</z><z id="t1636048304" t="ribelo e.g"><y>#</y><d>2021-11-04</d><h>17:51</h><w>ribelo</w>e.g</z><z id="t1636048327" t="noprompt Sure, you could use (m/search x (m/$ (m/symbol _ _ :as ?symbol)) ?symbol) which will effectively do (filter symbol? (tree-seq coll seqable? seq x))"><y>#</y><d>2021-11-04</d><h>17:52</h><w>noprompt</w>Sure, you could use
<pre>(m/search x
  (m/$ (m/symbol _ _ :as ?symbol))
  ?symbol)</pre>
which will effectively do
<pre>(filter symbol? (tree-seq coll seqable? seq x))</pre></z><z id="t1636048329" t="ribelo (collect-args &apos;[1 ?a 2 [?b {:b ?c}]]) ;; =&gt; [?a ?b ?c] "><y>#</y><d>2021-11-04</d><h>17:52</h><w>ribelo</w><pre>(collect-args &apos;[1 ?a 2 [?b {:b ?c}]])
;; =&gt; [?a ?b ?c]</pre>
</z><z id="t1636048357" t="ribelo heh, I forgot about the existence of m/$"><y>#</y><d>2021-11-04</d><h>17:52</h><w>ribelo</w>heh, I forgot about the existence of <code>m/$</code></z><z id="t1636048400" t="ribelo I have already tried meander.strategy/bottom-up , but not much has come out of it"><y>#</y><d>2021-11-04</d><h>17:53</h><w>ribelo</w>I have already tried <code>meander.strategy/bottom-up</code>, but not much has come out of it</z><z id="t1636048478" t="noprompt Strategies like bottom-up are mostly for doing postwalk types of transforms."><y>#</y><d>2021-11-04</d><h>17:54</h><w>noprompt</w>Strategies like <code>bottom-up</code> are mostly for doing <code>postwalk</code> types of transforms.</z><z id="t1636048511" t="ribelo Now I know 🙂"><y>#</y><d>2021-11-04</d><h>17:55</h><w>ribelo</w>Now I know <b>🙂</b></z><z id="t1636048551" t="ribelo the strategy is not well described at all, and some of the functions are not in the documentation at all, but maybe when I get the hang of it I will do a PR"><y>#</y><d>2021-11-04</d><h>17:55</h><w>ribelo</w>the <code>strategy</code> is not well described at all, and some of the functions are not in the documentation at all, but maybe when I get the hang of it I will do a PR</z><z id="t1636048939" t="noprompt Yeah. The strategy namespace hasn&apos;t gotten as much attention because it hasn&apos;t be promoted so much."><y>#</y><d>2021-11-04</d><h>18:02</h><w>noprompt</w>Yeah. The strategy namespace hasn&apos;t gotten as much attention because it hasn&apos;t be promoted so much.</z><z id="t1636049052" t="noprompt Actually, most of it was originally written by Brandon Bloom and then I started building on top of it."><y>#</y><d>2021-11-04</d><h>18:04</h><w>noprompt</w>Actually, most of it was originally written by Brandon Bloom and then I started building on top of it.</z><z id="t1636049131" t="noprompt But the closer m/rewrite got to where I wanted it, I had fewer use cases for that namespace."><y>#</y><d>2021-11-04</d><h>18:05</h><w>noprompt</w>But the closer <code>m/rewrite</code> got to where I wanted it, I had fewer use cases for that namespace.</z><z id="t1636049157" t="noprompt Going forward, it should probably be a separate package."><y>#</y><d>2021-11-04</d><h>18:05</h><w>noprompt</w>Going forward, it should probably be a separate package.</z><z id="t1636139421" t="jjttjj Is there a way to get an &quot;identity&quot; of a quoted meander query such that two queries can be compared for equality and will be equal even if the binding names used are different?"><y>#</y><d>2021-11-05</d><h>19:10</h><w>jjttjj</w>Is there a way to get an &quot;identity&quot; of a quoted meander query such that two queries can be compared for equality and will be equal even if the binding names used are different?</z><z id="t1636145751" t="Ben Sless postwalk replace all the binding names deterministically then compare?"><y>#</y><d>2021-11-05</d><h>20:55</h><r>Ben Sless</r>postwalk replace all the binding names deterministically then compare?</z><z id="t1636146441" t="noprompt Great question. Ben&apos;s reply is good here. You could use something like this to make a name mapping: https://github.com/noprompt/meander/blob/epsilon/src/meander/syntax/epsilon.cljc#L1636-L1646"><y>#</y><d>2021-11-05</d><h>21:07</h><r>noprompt</r>Great question. Ben&apos;s reply is good here. You could use something like this to make a name mapping: <a href="https://github.com/noprompt/meander/blob/epsilon/src/meander/syntax/epsilon.cljc#L1636-L1646" target="_blank">https://github.com/noprompt/meander/blob/epsilon/src/meander/syntax/epsilon.cljc#L1636-L1646</a></z><z id="t1636146718" t="noprompt This could get you to a place where you can tell if two forms are representationally equivalent (almost) but not semantically equivalent. So terms like [?a [?b 1 ?a]] [?1 [?2 1 ?1]] could be found to be equivalent via the method of constructing the rename map deterministically and then applying it."><y>#</y><d>2021-11-05</d><h>21:11</h><r>noprompt</r>This could get you to a place where you can tell if two forms are representationally equivalent (almost) but not semantically equivalent. So terms like
<pre>[?a [?b 1 ?a]]
[?1 [?2 1 ?1]]</pre>
could be found to be equivalent via the method of constructing the rename map deterministically and then applying it.</z><z id="t1636146852" t="noprompt I think this will also work for persistent array maps but, of course, on larger maps a simple = check may not work."><y>#</y><d>2021-11-05</d><h>21:14</h><r>noprompt</r>I think this will also work for persistent array maps but, of course, on larger maps a simple <code>=</code> check may not work.</z><z id="t1636146992" t="noprompt For fewer traversals, you could try comparing the subnodes for each of the terms iteratively, building the rename map as you go."><y>#</y><d>2021-11-05</d><h>21:16</h><r>noprompt</r>For fewer traversals, you could try comparing the <code>subnodes</code> for each of the terms iteratively, building the rename map as you go.</z><z id="t1636147549" t="noprompt If you&apos;re interested in this problem, I&apos;ve actually wanted a unifier for Meander terms for a little while. It&apos;d be useful."><y>#</y><d>2021-11-05</d><h>21:25</h><r>noprompt</r>If you&apos;re interested in this problem, I&apos;ve actually wanted a unifier for Meander terms for a little while. It&apos;d be useful.</z><z id="t1636147684" t="noprompt Because this is very much like unification, we want to see if one term is essentially equivalent to another. This has implications for things like cata where we could use that information."><y>#</y><d>2021-11-05</d><h>21:28</h><r>noprompt</r>Because this is very much like unification, we want to see if one term is essentially equivalent to another. This has implications for things like <code>cata</code> where we could use that information.</z><z id="t1636147944" t="noprompt (m/rewrite x (foo (m/cata [?a ?b])) {:type &quot;foo&quot;, :a ?a, :b ?b} ?x {:type &quot;unknown&quot;, :form ?x}) This is an example where that information could be used to demonstrate to a user the cata form could never succeed."><y>#</y><d>2021-11-05</d><h>21:32</h><r>noprompt</r><pre>(m/rewrite x
  (foo (m/cata [?a ?b]))
  {:type &quot;foo&quot;, :a ?a, :b ?b}
  
  ?x
  {:type &quot;unknown&quot;, :form ?x})</pre>
This is an example where that information could be used to demonstrate to a user the <code>cata</code> form could never succeed.</z><z id="t1636148606" t="jjttjj Thanks both of you! This should get me started"><y>#</y><d>2021-11-05</d><h>21:43</h><r>jjttjj</r>Thanks both of you! This should get me started</z><z id="t1636153849" t="noprompt Awesome!"><y>#</y><d>2021-11-05</d><h>23:10</h><r>noprompt</r>Awesome!</z><z id="t1636153859" t="noprompt Ping if you need more help, etc."><y>#</y><d>2021-11-05</d><h>23:10</h><r>noprompt</r>Ping if you need more help, etc.</z><z id="t1636306603" t="chaos Hi, what is the right way to rewrite map key/value pairs of a nested structures? I think I should be using a strategy, but can&apos;t seem to make it work. For example, I thought the following would rewrite any map :viewbox entries with :viewBox (capital b ), but it loses the rest of the entries in the map (as if the substitution rule replaces the whole map rather than the matching entry): (let [vb (m*/bottom-up (m*/attempt (m*/match {:viewbox (m/some ?vb)} {:viewBox ?vb})))] (vb [:svg {:xmlns &quot;&quot;, :viewbox &quot;0 0 24 24&quot;}])) ;; =&gt; [:svg {:viewBox &quot;0 0 24 24&quot;}] Thanks"><y>#</y><d>2021-11-07</d><h>17:36</h><w>chaos</w>Hi, what is the right way to rewrite map key/value pairs of a nested structures? I think I should be using a strategy, but can&apos;t seem to make it work. For example, I thought the following would rewrite any map <code>:viewbox</code> entries with <code>:viewBox</code> (capital <code>b</code>),  but it loses the rest of the entries in the map (as if the substitution rule replaces the whole map rather than the matching entry):
<pre>(let [vb (m*/bottom-up 
            (m*/attempt
             (m*/match 
              {:viewbox (m/some ?vb)} {:viewBox ?vb})))]
    (vb [:svg
         {:xmlns &quot;&quot;,
          :viewbox &quot;0 0 24 24&quot;}]))
;; =&gt; [:svg {:viewBox &quot;0 0 24 24&quot;}]</pre>
Thanks</z><z id="t1636394103" t="Richie (let [vb (r/bottom-up (r/attempt (r/match {:viewbox (m/some ?vb) &amp; ?rest} (into {:viewBox ?vb} ?rest))))] (vb [:svg {:xmlns &quot;&quot; , :viewbox &quot;0 0 24 24&quot;}])) [:svg {:viewBox &quot;0 0 24 24&quot;, :xmlns &quot;&quot;}]"><y>#</y><d>2021-11-08</d><h>17:55</h><r>Richie</r><pre>(let [vb (r/bottom-up
          (r/attempt
           (r/match
            {:viewbox (m/some ?vb)
             &amp; ?rest} (into {:viewBox ?vb} ?rest))))]
  (vb [:svg
       {:xmlns &quot;&quot; ,
        :viewbox &quot;0 0 24 24&quot;}]))</pre>
<code>[:svg {:viewBox &quot;0 0 24 24&quot;, :xmlns &quot;&quot;}]</code></z><z id="t1636395993" t="chaos Great, it works, thanks!"><y>#</y><d>2021-11-08</d><h>18:26</h><r>chaos</r>Great, it works, thanks!</z><z id="t1636399638" t="noprompt You could also use (r/rewrite {:viewbox (m/some ?vb) &amp; ?rest} {:viewBox ?vb &amp; ?rest}) "><y>#</y><d>2021-11-08</d><h>19:27</h><r>noprompt</r>You could also use
<pre>(r/rewrite
  {:viewbox (m/some ?vb) &amp; ?rest}
  {:viewBox ?vb &amp; ?rest})</pre>
</z><z id="t1636400329" t="chaos Thanks! unfortunately I have a second rule for naively splitting the style attribute, which I do not think it can be used for a rewrite substitution (or can it?): (let [t1 (m*/bottom-up (m*/attempt (m*/match {:viewbox (m/some ?vb) &amp; ?rest} (assoc ?rest :viewBox ?vb) {:style (m/some ?st) &amp; ?rest} (assoc ?rest :style (let [[k v] (clojure.string/split ?st #&quot;: &quot; 2)] {(keyword k) (str v)})))))] (t1 [:div {:style &quot;width: 100px&quot;} [:svg {:xmlns &quot;&quot;, :viewbox &quot;0 0 24 24&quot;}]])) ;; =&gt; [:div {:style {:width &quot;100px&quot;}} [:svg {:xmlns &quot;&quot;, :viewBox &quot;0 0 24 24&quot;}]]"><y>#</y><d>2021-11-08</d><h>19:38</h><r>chaos</r>Thanks! unfortunately I have a second rule for naively splitting the style attribute, which I do not think it can be used for a rewrite substitution (or can it?):

<pre>(let [t1 (m*/bottom-up 
            (m*/attempt
             (m*/match 
              {:viewbox (m/some ?vb) &amp; ?rest}
              (assoc ?rest :viewBox ?vb)

              {:style (m/some ?st) &amp; ?rest}
              (assoc ?rest :style (let [[k v] (clojure.string/split ?st #&quot;: &quot; 2)]
                                    {(keyword k) (str v)})))))]
    (t1 [:div
         {:style &quot;width: 100px&quot;}
         [:svg
          {:xmlns &quot;&quot;,
           :viewbox &quot;0 0 24 24&quot;}]]))
;; =&gt; [:div
 {:style {:width &quot;100px&quot;}}
 [:svg {:xmlns &quot;&quot;, :viewBox &quot;0 0 24 24&quot;}]]</pre></z><z id="t1636400942" t="noprompt Sure, you can use m/re for the splitting on the left side and m/keyword on the right: (m*/rewrite {:viewbox (m/some ?vb) &amp; ?rest} {:viewBox ?vb &amp; ?rest} {:style (m/re #&quot;(?s)([^:])*:\s+(.*)&quot; [_ ?k ?v]) &amp; ?rest} {:style {(m/keyword ?k) ?v} &amp; ?rest}) "><y>#</y><d>2021-11-08</d><h>19:49</h><r>noprompt</r>Sure, you can use <code>m/re</code> for the splitting on the left side and <code>m/keyword</code> on the right:
<pre>(m*/rewrite 
 {:viewbox (m/some ?vb) &amp; ?rest}
 {:viewBox ?vb &amp; ?rest}

 {:style (m/re #&quot;(?s)([^:])*:\s+(.*)&quot; [_ ?k ?v]) &amp; ?rest}
 {:style {(m/keyword ?k) ?v} &amp; ?rest})</pre>
</z><z id="t1636400957" t="noprompt t1 produces [:div {:style {:h &quot;100px&quot;}} [:svg {:xmlns &quot;&quot;, :viewBox &quot;0 0 24 24&quot;}]] "><y>#</y><d>2021-11-08</d><h>19:49</h><r>noprompt</r><code>t1</code> produces
<pre>[:div
 {:style {:h &quot;100px&quot;}}
 [:svg {:xmlns &quot;&quot;, :viewBox &quot;0 0 24 24&quot;}]]</pre>
</z><z id="t1636400985" t="noprompt If you don&apos;t need . to match newlines you can drop the (?s) modifier"><y>#</y><d>2021-11-08</d><h>19:49</h><r>noprompt</r>If you don&apos;t need <code>.</code> to match newlines you can drop the <code>(?s)</code> modifier</z><z id="t1636402008" t="chaos Thanks, pretty cool thinking only in terms of pure symbolic terms: (let [t2 (m*/bottom-up (m*/attempt (m*/rewrite {:viewbox (m/some ?vb) &amp; ?rest} {:viewBox ?vb &amp; ?rest} {:style (m/re #&quot;(?s)([^:]+):\s+(.*)&quot; [_ ?k ?v]) &amp; ?rest} {:style {(m/keyword ?k) ?v} &amp; ?rest} )))] (t2 [:div {:style &quot;width: 100px&quot;} [:svg {:xmlns &quot;&quot;, :viewbox &quot;0 0 24 24&quot;}]])) ;; =&gt; [:div {:style {:width &quot;100px&quot;}} [:svg {:xmlns &quot;&quot;, :viewBox &quot;0 0 24 24&quot;}]] "><y>#</y><d>2021-11-08</d><h>20:06</h><r>chaos</r>Thanks, pretty cool thinking only in terms of pure symbolic terms:

<pre>(let [t2 (m*/bottom-up 
            (m*/attempt
             (m*/rewrite
              {:viewbox (m/some ?vb) &amp; ?rest}
              {:viewBox ?vb &amp; ?rest}
              
              {:style (m/re #&quot;(?s)([^:]+):\s+(.*)&quot; [_ ?k ?v]) &amp; ?rest}
              {:style {(m/keyword ?k) ?v} &amp; ?rest}
              )))]
    (t2 [:div
         {:style &quot;width: 100px&quot;}
         [:svg
          {:xmlns &quot;&quot;,
           :viewbox &quot;0 0 24 24&quot;}]]))
;; =&gt; [:div
 {:style {:width &quot;100px&quot;}}
 [:svg {:xmlns &quot;&quot;, :viewBox &quot;0 0 24 24&quot;}]]</pre>
</z><z id="t1636402653" t="chaos Up to the next thing I&apos;d need to consider, what if :style has more than one inline styles separated by ; that I&apos;d like to collect in the final result, would this be something I could write with pure rewrite terms? for example I can quickly update match to further naively split on ; : (let [t1 (m*/bottom-up (m*/attempt (m*/match {:viewbox (m/some ?vb) &amp; ?rest} (assoc ?rest :viewBox ?vb) {:style (m/some ?st) &amp; ?rest} (assoc ?rest :style (into {} (for [style (clojure.string/split ?st #&quot;; &quot;)] (let [[k v] (clojure.string/split style #&quot;: &quot; 2)] {(keyword k) (str v)})))))))] (t1 [:div {:style &quot;width: 100px; height: 200px&quot;} [:svg {:xmlns &quot;&quot;, :viewbox &quot;0 0 24 24&quot;}]])) ;; =&gt; [:div {:style {:width &quot;100px&quot;, :height &quot;200px&quot;}} [:svg {:xmlns &quot;&quot;, :viewBox &quot;0 0 24 24&quot;}]]"><y>#</y><d>2021-11-08</d><h>20:17</h><r>chaos</r>Up to the next thing I&apos;d need to consider, what if <code>:style</code> has more than one inline styles separated by <code>;</code> that I&apos;d like to collect in the final result, would this be something I could write with pure <code>rewrite</code> terms? for example I can quickly update <code>match</code> to further naively split on <code>;</code>  :
<pre>(let [t1 (m*/bottom-up 
            (m*/attempt
             (m*/match 
              {:viewbox (m/some ?vb) &amp; ?rest}
              (assoc ?rest :viewBox ?vb)

              {:style (m/some ?st) &amp; ?rest}
              (assoc ?rest :style (into {}
                                        (for [style (clojure.string/split ?st #&quot;; &quot;)]
                                          (let [[k v] (clojure.string/split style #&quot;: &quot; 2)]
                                            {(keyword k) (str v)})))))))]
    (t1 [:div
         {:style &quot;width: 100px; height: 200px&quot;}
         [:svg
          {:xmlns &quot;&quot;,
           :viewbox &quot;0 0 24 24&quot;}]]))
;; =&gt; [:div
 {:style {:width &quot;100px&quot;, :height &quot;200px&quot;}}
 [:svg {:xmlns &quot;&quot;, :viewBox &quot;0 0 24 24&quot;}]]</pre></z><z id="t1636403010" t="chaos (It is not important, I am just trying to see how far I could go by just using pure symbolic substitutions)"><y>#</y><d>2021-11-08</d><h>20:23</h><r>chaos</r>(It is not important, I am just trying to see how far I could go by just using pure symbolic substitutions)</z><z id="t1636405449" t="Richie I don&apos;t have experience with strategies. I can&apos;t run the code... ;; (:require [meander.epsilon :as m] ;; [meander.strategy.epsilon :as r]) (let [t1 (r/rewrite {:viewbox (m/some ?vb) &amp; ?rest} {:viewBox ?vb &amp; ?rest} {:style (m/re #&quot;(?s)([^:])*:\s+(.*)&quot; [_ ?k ?v]) &amp; ?rest} {:style {(m/keyword ?k) ?v} &amp; ?rest} )] (t1 [:div {:style &quot;width: 100px; height: 200px&quot;} [:svg {:xmlns &quot;&quot;, :viewbox &quot;0 0 24 24&quot;}]])) gives me #meander.epsilon/fail[]"><y>#</y><d>2021-11-08</d><h>21:04</h><r>Richie</r>I don&apos;t have experience with strategies. I can&apos;t run the code...
<pre>;; (:require [meander.epsilon :as m]
;;           [meander.strategy.epsilon :as r])
(let [t1 (r/rewrite
          {:viewbox (m/some ?vb) &amp; ?rest}
          {:viewBox ?vb &amp; ?rest}

          {:style (m/re #&quot;(?s)([^:])*:\s+(.*)&quot; [_ ?k ?v]) &amp; ?rest}
          {:style {(m/keyword ?k) ?v} &amp; ?rest}
          )]
  (t1 [:div
       {:style &quot;width: 100px; height: 200px&quot;}
       [:svg
        {:xmlns &quot;&quot;,
         :viewbox &quot;0 0 24 24&quot;}]]))</pre>
gives me <code>#meander.epsilon/fail[]</code></z><z id="t1636405750" t="chaos perhaps this is because r/attempt is missing from the code and fails on the first mismatch?"><y>#</y><d>2021-11-08</d><h>21:09</h><r>chaos</r>perhaps this is because r/attempt is missing from the code and fails on the first mismatch?</z><z id="t1636491247" t="Richie Oh, ok. I thought noprompt was suggesting rewrite instead of bottom-up+attempt+match. I guess it would actually be bottom-up+attempt+rewrite? Anyways, I think you can just write a function to do what you want and stick it in with app (let [t1 (r/bottom-up (r/attempt (r/rewrite {:viewbox (m/some ?vb) &amp; ?rest} {:viewBox ?vb &amp; ?rest} {:style (m/app (constantly :whatever) ?a) &amp; ?rest} {:style ?a &amp; ?rest})))] (t1 [:div {:style &quot;width: 100px; height: 200px&quot;} [:svg {:xmlns &quot;&quot;, :viewbox &quot;0 0 24 24&quot;}]])) [:div {:style :whatever} [:svg {:xmlns &quot;&quot;, :viewBox &quot;0 0 24 24&quot;}]]"><y>#</y><d>2021-11-09</d><h>20:54</h><r>Richie</r>Oh, ok. I thought noprompt was suggesting rewrite instead of bottom-up+attempt+match. I guess it would actually be bottom-up+attempt+rewrite? Anyways, I think you can just write a function to do what you want and stick it in with <code>app</code>
<pre>(let [t1 (r/bottom-up
          (r/attempt
           (r/rewrite
            {:viewbox (m/some ?vb) &amp; ?rest}
            {:viewBox ?vb &amp; ?rest}

            {:style (m/app (constantly :whatever) ?a) &amp; ?rest}
            {:style ?a &amp; ?rest})))]
  (t1 [:div
       {:style &quot;width: 100px; height: 200px&quot;}
       [:svg
        {:xmlns &quot;&quot;,
         :viewbox &quot;0 0 24 24&quot;}]]))</pre>
<code>[:div {:style :whatever} [:svg {:xmlns &quot;&quot;, :viewBox &quot;0 0 24 24&quot;}]]</code></z><z id="t1636498839" t="noprompt This looks pretty clean, IMHO. Sorry I haven’t been able to participate in the thread since I first replied, I haven’t had a moment to focus here."><y>#</y><d>2021-11-09</d><h>23:00</h><r>noprompt</r>This looks pretty clean, IMHO. Sorry I haven’t been able to participate in the thread since I first replied, I haven’t had a moment to focus here.</z><z id="t1636570127" t="chaos Great thanks, you have both been very helpful. And the final rewrite version with the naive split: (let [styles-&gt;map #(into {} (for [style (clojure.string/split % #&quot;; &quot;)] (let [[k v] (clojure.string/split style #&quot;: &quot; 2)] {(keyword k) (str v)}))) t4 (m*/bottom-up (m*/attempt (m*/rewrite {:viewbox (m/some ?vb) &amp; ?rest} {:viewBox ?vb &amp; ?rest} {:style (m/app styles-&gt;map ?styles) &amp; ?rest} {:style ?styles &amp; ?rest} )))] (t4 [:div {:style &quot;width: 100px; height: 200px&quot;} [:svg {:xmlns &quot;&quot;, :viewbox &quot;0 0 24 24&quot;}]])) ;; =&gt; [:div ;; {:style {:width &quot;100px&quot;, :height &quot;200px&quot;}} ;; [:svg {:xmlns &quot;&quot;, :viewBox &quot;0 0 24 24&quot;}]]"><y>#</y><d>2021-11-10</d><h>18:48</h><r>chaos</r>Great thanks, you have both been very helpful.  And the final rewrite version with the naive split:

<pre>(let [styles-&gt;map
        #(into {} (for [style (clojure.string/split % #&quot;; &quot;)]
                    (let [[k v] (clojure.string/split style #&quot;: &quot; 2)]
                      {(keyword k) (str v)})))

        t4 (m*/bottom-up 
            (m*/attempt
             (m*/rewrite
              {:viewbox (m/some ?vb) &amp; ?rest}
              {:viewBox ?vb &amp; ?rest}
              
              {:style (m/app styles-&gt;map ?styles) &amp; ?rest}
              {:style ?styles &amp; ?rest}
              )))]
    (t4 [:div
         {:style &quot;width: 100px; height: 200px&quot;}
         [:svg
          {:xmlns &quot;&quot;,
           :viewbox &quot;0 0 24 24&quot;}]]))
;; =&gt; [:div
;;     {:style {:width &quot;100px&quot;, :height &quot;200px&quot;}}
;;     [:svg {:xmlns &quot;&quot;, :viewBox &quot;0 0 24 24&quot;}]]</pre></z><z id="t1636570186" t="chaos I think I have enough now to get going with rewrite"><y>#</y><d>2021-11-10</d><h>18:49</h><r>chaos</r>I think I have enough now to get going with rewrite</z><z id="t1636570364" t="Richie cool"><y>#</y><d>2021-11-10</d><h>18:52</h><r>Richie</r>cool</z><z id="t1636846721" t="ribelo [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] does cata always add an elem to a stack?"><y>#</y><d>2021-11-13</d><h>23:38</h><w>ribelo</w><a>@noprompt</a> does <code>cata</code> always add an elem to a stack?</z><z id="t1636846748" t="ribelo I have a problem with stack overflow and am wondering how to get around it"><y>#</y><d>2021-11-13</d><h>23:39</h><w>ribelo</w>I have a problem with stack overflow and am wondering how to get around it</z><z id="t1636853326" t="noprompt Yes, cata uses stack based recursion."><y>#</y><d>2021-11-14</d><h>01:28</h><w>noprompt</w>Yes, <code>cata</code> uses stack based recursion.</z><z id="t1636853653" t="ribelo m/with as well?"><y>#</y><d>2021-11-14</d><h>01:34</h><w>ribelo</w><code>m/with</code> as well?</z><z id="t1636863628" t="noprompt Yes."><y>#</y><d>2021-11-14</d><h>04:20</h><w>noprompt</w>Yes.</z><z id="t1636921850" t="noprompt Sorry for the short reply yesterday. Yes, for the recursive definitions. That could probably be improved but would need some thinking on."><y>#</y><d>2021-11-14</d><h>20:30</h><w>noprompt</w>Sorry for the short reply yesterday. Yes, for the recursive definitions. That could probably be improved but would need some thinking on.</z><z id="t1636925065" t="ribelo no problem"><y>#</y><d>2021-11-14</d><h>21:24</h><w>ribelo</w>no problem</z><z id="t1636925091" t="ribelo open source is not about me : &gt;"><y>#</y><d>2021-11-14</d><h>21:24</h><w>ribelo</w>open source is not about me : &gt;</z><z id="t1636958853" t="noprompt Ha! I wanted to make sure I followed up because I only had a moment to reply and, personally, I&apos;m not fond of curt replies."><y>#</y><d>2021-11-15</d><h>06:47</h><w>noprompt</w>Ha! I wanted to make sure I followed up because I only had a moment to reply and, personally, I&apos;m not fond of curt replies.</z><z id="t1637430759" t="markaddleman Just throwing an idea out there to make working with memory variables slightly easier: I have lots of cases where I need to expand the same memory variable multiple times. Currently, I can do this using something like (m/sequence (m/and !a1 !a2) ...) . Would it be possible to introduce a new operator on the RHS to make this cleaner? I imagine something like: (m/rewrite [1 2 3] [!a ...] [[(m/from-start !a) ...], [(m/from-start !a)...]] "><y>#</y><d>2021-11-20</d><h>17:52</h><w>markaddleman</w>Just throwing an idea out there to make working with memory variables slightly easier:  I have lots of cases where I need to expand the same memory variable multiple times.  Currently, I can do this using something like <code>(m/sequence (m/and !a1 !a2) ...)</code> .  Would it be possible to introduce a new operator on the RHS to make this cleaner?  I imagine something like:
<pre>(m/rewrite [1 2 3]
   [!a ...]
   [[(m/from-start !a) ...], [(m/from-start !a)...]]</pre>
</z><z id="t1637607959" t="noprompt That would be difficult to implement with the project in its current state due to the way the compiler currently generates code for memory variables. Could you capture the sequence as logic variable? (m/rewrite [1 2 3] [&amp; ?a] [[&amp; ?a], [&amp; ?a]]) "><y>#</y><d>2021-11-22</d><h>19:05</h><w>noprompt</w>That would be difficult to implement with the project in its current state due to the way the compiler currently generates code for memory variables. Could you capture the sequence as logic variable?
<pre>(m/rewrite [1 2 3]
  [&amp; ?a]
  [[&amp; ?a], [&amp; ?a]])</pre>
</z><z id="t1637609476" t="markaddleman I some cases, yes. In others, I think it would end up complicating the rewrite since I&apos;d have to more with m/app and handling the sequence in with map or something"><y>#</y><d>2021-11-22</d><h>19:31</h><r>markaddleman</r>I some cases, yes.  In others, I think it would end up complicating the rewrite since I&apos;d have to more with <code>m/app</code> and handling the sequence in with <code>map</code> or something</z><z id="t1637609491" t="markaddleman It&apos;s not a big deal - it just occurred to make while I was working through some code"><y>#</y><d>2021-11-22</d><h>19:31</h><r>markaddleman</r>It&apos;s not a big deal - it just occurred to make while I was working through some code</z><z id="t1637610494" t="noprompt OK. I can think on other examples if you want to share their basic shapes with me too."><y>#</y><d>2021-11-22</d><h>19:48</h><r>noprompt</r>OK. I can think on other examples if you want to share their basic shapes with me too.</z><z id="t1637608040" t="noprompt &amp; can be used multiple times now and you can use m/and as in [&amp; ?a &amp; (m/and ?b [!x !y ...])]"><y>#</y><d>2021-11-22</d><h>19:07</h><w>noprompt</w><code>&amp;</code> can be used multiple times now and you can use <code>m/and</code> as in <code>[&amp; ?a &amp; (m/and ?b [!x !y ...])]</code></z><z id="t1638199401" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] Perhaps you could comment here as to why you wanted dispatch-fn exposed in CLJS? https://ask.clojure.org/index.php/10261/please-add-dispatch-fn-to-clojure-core"><y>#</y><d>2021-11-29</d><h>15:23</h><w>borkdude</w><a>@noprompt</a> Perhaps you could comment here as to why you wanted <code>dispatch-fn</code> exposed in CLJS?
<a href="https://ask.clojure.org/index.php/10261/please-add-dispatch-fn-to-clojure-core" target="_blank">https://ask.clojure.org/index.php/10261/please-add-dispatch-fn-to-clojure-core</a></z><z id="t1638216660" t="noprompt Hmm… that was a long time ago. I don’t recall why! Maybe it’ll come to me."><y>#</y><d>2021-11-29</d><h>20:11</h><r>noprompt</r>Hmm… that was a long time ago. I don’t recall why! Maybe it’ll come to me.</z><z id="t1638217024" t="borkdude ok thanks"><y>#</y><d>2021-11-29</d><h>20:17</h><r>borkdude</r>ok thanks</z><z id="t1638645675" t="wilkerlucio hello, is there a more &quot;meander way&quot; to do this? (m/find {:foo [{:bar &quot;baz&quot;} {:bar &quot;baz2&quot;}]} {:foo (m/app #(mapv (fn [x] (m/find x {:bar ?bar} {:tx/bar ?bar})) %) ?foos)} {:renamed/foo ?foos})"><y>#</y><d>2021-12-04</d><h>19:21</h><w>wilkerlucio</w>hello, is there a more &quot;meander way&quot; to do this?
<pre>(m/find
  {:foo [{:bar &quot;baz&quot;}
         {:bar &quot;baz2&quot;}]}

  {:foo (m/app
          #(mapv (fn [x] (m/find x
                           {:bar ?bar}
                           {:tx/bar ?bar}))
             %)
          ?foos)}

  {:renamed/foo ?foos})</pre></z><z id="t1638645724" t="wilkerlucio this works, just feels a bit ugly to have this sub-meander calls and have to use mapv , what I would like to is to pattern-replace each item on the collection under :foo , and get a reference to that transformed list, is there a better way to do it?"><y>#</y><d>2021-12-04</d><h>19:22</h><r>wilkerlucio</r>this works, just feels a bit ugly to have this sub-meander calls and have to use <code>mapv</code>, what I would like to is to pattern-replace each item on the collection under <code>:foo</code>, and get a reference to that transformed list, is there a better way to do it?</z><z id="t1638647170" t="wilkerlucio my best so far was to hide the mess in a defsyntax: (m/defsyntax mmap [&amp; patterns] (let [out (first patterns) patterns&apos; (next patterns)] `(m/app (fn [x#] (into (empty x#) (map (fn [i#] (m/find i# ~@patterns&apos;))) x#)) ~out))) (m/find {:foo [{:bar &quot;baz&quot;} {:bar &quot;baz2&quot;}]} {:foo (mmap ?foos {:bar ?b} {:b ?b})} {:renamed/foo ?foos})"><y>#</y><d>2021-12-04</d><h>19:46</h><r>wilkerlucio</r>my best so far was to hide the mess in a defsyntax:

<pre>(m/defsyntax mmap [&amp; patterns]
  (let [out       (first patterns)
        patterns&apos; (next patterns)]
    `(m/app
       (fn [x#]
         (into (empty x#)
               (map (fn [i#]
                      (m/find i# ~@patterns&apos;)))
               x#))
       ~out)))
(m/find
  {:foo [{:bar &quot;baz&quot;}
         {:bar &quot;baz2&quot;}]}

  {:foo (mmap ?foos
          {:bar ?b}
          {:b ?b})}

  {:renamed/foo ?foos})</pre></z><z id="t1638650328" t="noprompt Like this? (m/rewrite {:foo [{:bar &quot;baz&quot;} {:bar &quot;baz2&quot;}]} {:foo [{:bar !bar &amp; !rest} ...]} {:renamed/foo [{:tx/bar !bar &amp; !rest} ...]}) ;; =&gt; #:renamed{:foo [#:tx{:bar &quot;baz&quot;} #:tx{:bar &quot;baz2&quot;}]}"><y>#</y><d>2021-12-04</d><h>20:38</h><r>noprompt</r>Like this?
<pre>(m/rewrite {:foo [{:bar &quot;baz&quot;}
                  {:bar &quot;baz2&quot;}]}
  {:foo [{:bar !bar &amp; !rest} ...]}
  {:renamed/foo [{:tx/bar !bar &amp; !rest} ...]})
;; =&gt;
#:renamed{:foo [#:tx{:bar &quot;baz&quot;} #:tx{:bar &quot;baz2&quot;}]}</pre></z><z id="t1638650577" t="noprompt You could also do the same thing with a bottom-up strategy: (let [s (m*/bottom-up (m*/rewrite {:foo (m/some ?foo)} {:renamed/foo ?foo} {:bar (m/some ?bar) &amp; ?rest} {:tx/bar ?bar &amp; ?rest} ?x ?x))] (s {:foo [{:bar &quot;baz&quot;} {:bar &quot;baz2&quot;}]})) ;; =&gt; #:renamed{:foo [#:tx{:bar &quot;baz&quot;} #:tx{:bar &quot;baz2&quot;}]}"><y>#</y><d>2021-12-04</d><h>20:42</h><r>noprompt</r>You could also do the same thing with a <code>bottom-up</code> strategy:
<pre>(let [s (m*/bottom-up
         (m*/rewrite {:foo (m/some ?foo)}
                     {:renamed/foo ?foo}

                     {:bar (m/some ?bar) &amp; ?rest}
                     {:tx/bar ?bar &amp; ?rest}

                     ?x ?x))]
  (s {:foo [{:bar &quot;baz&quot;} {:bar &quot;baz2&quot;}]}))
;; =&gt;
#:renamed{:foo [#:tx{:bar &quot;baz&quot;} #:tx{:bar &quot;baz2&quot;}]}</pre></z><z id="t1638650859" t="noprompt Similarly, if you don&apos;t want to involve strategy, you can use m/cata (m/rewrite {:foo [{:bar &quot;baz&quot;} {:bar &quot;baz2&quot;}]} [(m/cata !x) ...] [!x ...] {:foo (m/and (m/some) (m/cata ?foo))} {:renamed/foo ?foo} {:bar (m/some ?bar) &amp; ?rest} {:tx/bar ?bar &amp; ?rest} ?x ?x) #:renamed{:foo [#:tx{:bar &quot;baz&quot;} #:tx{:bar &quot;baz2&quot;}]} "><y>#</y><d>2021-12-04</d><h>20:47</h><r>noprompt</r>Similarly, if you don&apos;t want to involve strategy, you can use <code>m/cata</code>
<pre>(m/rewrite {:foo [{:bar &quot;baz&quot;}
                  {:bar &quot;baz2&quot;}]}

  [(m/cata !x) ...]
  [!x ...]

  {:foo (m/and (m/some) (m/cata ?foo))}
  {:renamed/foo ?foo}

  {:bar (m/some ?bar) &amp; ?rest}
  {:tx/bar ?bar &amp; ?rest}

  ?x ?x)
#:renamed{:foo [#:tx{:bar &quot;baz&quot;} #:tx{:bar &quot;baz2&quot;}]}</pre>
</z><z id="t1638650923" t="noprompt And if you don&apos;t want to use m/rewrite you can still use m/find with manual control over the right side (m/find {:foo [{:bar &quot;baz&quot;} {:bar &quot;baz2&quot;}]} [(m/cata !x) ...] !x {:foo (m/and (m/some) (m/cata ?foo))} {:renamed/foo ?foo} {:bar (m/some ?bar) &amp; ?rest} (merge {:tx/bar ?bar} ?rest) ?x ?x) ;; =&gt; #:renamed{:foo [#:tx{:bar &quot;baz&quot;} #:tx{:bar &quot;baz2&quot;}]} "><y>#</y><d>2021-12-04</d><h>20:48</h><r>noprompt</r>And if you don&apos;t want to use <code>m/rewrite</code> you can still use <code>m/find</code> with manual control over the right side
<pre>(m/find {:foo [{:bar &quot;baz&quot;}
               {:bar &quot;baz2&quot;}]}

  [(m/cata !x) ...]
  !x

  {:foo (m/and (m/some) (m/cata ?foo))}
  {:renamed/foo ?foo}

  {:bar (m/some ?bar) &amp; ?rest}
  (merge {:tx/bar ?bar} ?rest)

  ?x ?x)
;; =&gt;
#:renamed{:foo [#:tx{:bar &quot;baz&quot;} #:tx{:bar &quot;baz2&quot;}]}</pre>
</z><z id="t1638650947" t="noprompt Does this help?"><y>#</y><d>2021-12-04</d><h>20:49</h><r>noprompt</r>Does this help?</z><z id="t1638659920" t="wilkerlucio gotcha, yes, it does, the first rewrite is the thing, its surprising to me how Meander is able to get it right, but it does 😄"><y>#</y><d>2021-12-04</d><h>23:18</h><r>wilkerlucio</r>gotcha, yes, it does, the first rewrite is the thing, its surprising to me how Meander is able to get it right, but it does <b>😄</b></z><z id="t1638663810" t="wilkerlucio hello, is there any idea in the horizon for when meander might work on Babashka? I ask because its very often that I would like to leverage meander in some BB script, but end up having to choose for the meander convenience or the babashka startup time, always a hard choice 😛"><y>#</y><d>2021-12-05</d><h>00:23</h><w>wilkerlucio</w>hello, is there any idea in the horizon for when meander might work on Babashka? I ask because its very often that I would like to leverage meander in some BB script, but end up having to choose for the meander convenience or the babashka startup time, always a hard choice <b>😛</b></z><z id="t1638687107" t="borkdude There is the meander interpreter namespace which works with bb"><y>#</y><d>2021-12-05</d><h>06:51</h><r>borkdude</r>There is the meander interpreter namespace which works with bb</z><z id="t1638725921" t="wilkerlucio just looking at it, but seems to be quite limited, not sure if I&apos;m looking it in the wrong way, but I often use the deep search operator (`$`) for example, and it doesn&apos;t seem to be available there"><y>#</y><d>2021-12-05</d><h>17:38</h><r>wilkerlucio</r>just looking at it, but seems to be quite limited, not sure if I&apos;m looking it in the wrong way, but I often use the deep search operator (`$`) for example, and it doesn&apos;t seem to be available there</z><z id="t1638725927" t="wilkerlucio am I missing something?"><y>#</y><d>2021-12-05</d><h>17:38</h><r>wilkerlucio</r>am I missing something?</z><z id="t1638738925" t="borkdude [:attrs {:href &quot;/_/_/users/U066U8JQJ&quot;}] I&apos;m sometimes using a meander test script with babashka to measure performance: (ns private.tmp.meander) (require &apos;[babashka.deps :as deps]) (deps/add-deps &apos;{:deps {meander/epsilon {:mvn/version &quot;0.0.588&quot;}}}) (time (require &apos;[meander.interpreter.epsilon :as mi])) (time (prn (select-keys ((mi/finder &apos;[?x ?y] identity) [1 2]) &apos;[?x ?y]))) "><y>#</y><d>2021-12-05</d><h>21:15</h><r>borkdude</r><a>@U066U8JQJ</a> I&apos;m sometimes using a meander test script with babashka to measure performance:
<pre>(ns private.tmp.meander)

(require &apos;[babashka.deps :as deps])
(deps/add-deps &apos;{:deps
                 {meander/epsilon {:mvn/version &quot;0.0.588&quot;}}})


(time (require &apos;[meander.interpreter.epsilon :as mi]))

(time (prn (select-keys ((mi/finder &apos;[?x ?y] identity) [1 2]) &apos;[?x ?y])))</pre>
</z><z id="t1638738954" t="borkdude I&apos;m not very well up to date on this API to be honest. Perhaps [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] is :)"><y>#</y><d>2021-12-05</d><h>21:15</h><r>borkdude</r>I&apos;m not very well up to date on this API to be honest. Perhaps <a>@U06MDAPTP</a> is :)</z><z id="t1638739021" t="borkdude $ bb tmp/meander.clj :foo :bar &quot;Elapsed time: 96.066405 msecs&quot; :end "><y>#</y><d>2021-12-05</d><h>21:17</h><r>borkdude</r><pre>$ bb tmp/meander.clj
:foo
:bar
&quot;Elapsed time: 96.066405 msecs&quot;
:end</pre>
</z><z id="t1638739138" t="borkdude $ bb tmp/meander.clj &quot;Elapsed time: 98.478887 msecs&quot; {?x 1, ?y 2} &quot;Elapsed time: 1.565369 msecs&quot;"><y>#</y><d>2021-12-05</d><h>21:18</h><r>borkdude</r><pre>$ bb tmp/meander.clj
&quot;Elapsed time: 98.478887 msecs&quot;
{?x 1, ?y 2}
&quot;Elapsed time: 1.565369 msecs&quot;</pre></z><z id="t1638752842" t="noprompt I was working on it and then, like anything else, I got distracted and forgot about it. There&apos;s an outstanding PR and I can&apos;t remember what else there is to do on there. Remind me to look at this tomorrow and I&apos;ll see what else there is to do to merge that PR."><y>#</y><d>2021-12-06</d><h>01:07</h><r>noprompt</r>I was working on it and then, like anything else, I got distracted and forgot about it. There&apos;s an outstanding PR and I can&apos;t remember what else there is to do on there.

Remind me to look at this tomorrow and I&apos;ll see what else there is to do to merge that PR.</z><z id="t1638798529" t="wilkerlucio friendly reminder as requested 🙂"><y>#</y><d>2021-12-06</d><h>13:48</h><r>wilkerlucio</r>friendly reminder as requested <b>🙂</b></z><z id="t1638803006" t="borkdude [:attrs {:href &quot;/_/_/users/U066U8JQJ&quot;}] forgot to mention, there is also this &quot;simpler&quot; pattern matching lib which works with bb https://github.com/babashka/babashka/blob/master/doc/projects.md#matchete"><y>#</y><d>2021-12-06</d><h>15:03</h><r>borkdude</r><a>@U066U8JQJ</a> forgot to mention, there is also this &quot;simpler&quot; pattern matching lib which works with bb <a href="https://github.com/babashka/babashka/blob/master/doc/projects.md#matchete" target="_blank">https://github.com/babashka/babashka/blob/master/doc/projects.md#matchete</a></z><z id="t1638803202" t="wilkerlucio thanks man, sadly machete doesn&apos;t cover the kinds of cases that I use Meander for =/"><y>#</y><d>2021-12-06</d><h>15:06</h><r>wilkerlucio</r>thanks man, sadly machete doesn&apos;t cover the kinds of cases that I use Meander for =/</z><z id="t1639173057" t="noprompt I haven’t forgotten about this."><y>#</y><d>2021-12-10</d><h>21:50</h><r>noprompt</r>I haven’t forgotten about this.</z><z id="t1639173080" t="noprompt I’ve been pretty busy with work this week."><y>#</y><d>2021-12-10</d><h>21:51</h><r>noprompt</r>I’ve been pretty busy with work this week.</z><z id="t1639181228" t="wilkerlucio no worries man, busy lifes, it happens when it can happen :)"><y>#</y><d>2021-12-11</d><h>00:07</h><r>wilkerlucio</r>no worries man, busy lifes, it happens when it can happen :)</z><z id="t1639181276" t="wilkerlucio thanks for looking for time to check it 🙏"><y>#</y><d>2021-12-11</d><h>00:07</h><r>wilkerlucio</r>thanks for looking for time to check it <b>🙏</b></z><z id="t1639506455" t="noprompt [:attrs {:href &quot;/_/_/users/U066U8JQJ&quot;}] I’m probably not going to be able to look at that ticket for a bit. There is an outstanding PR for bb support that was never completed. What I would suggest, if you’re open to it, would be to look at that ticket and try to put together a new PR with the most recent code."><y>#</y><d>2021-12-14</d><h>18:27</h><r>noprompt</r><a>@U066U8JQJ</a> I’m probably not going to be able to look at that ticket for a bit. There is an outstanding PR for bb support that was never completed. What I would suggest, if you’re open to it, would be to look at that ticket and try to put together a new PR with the most recent code.</z><z id="t1639507972" t="wilkerlucio no worries, thanks, can&apos;t promise but I&apos;ll try to have a look at it 👍"><y>#</y><d>2021-12-14</d><h>18:52</h><r>wilkerlucio</r>no worries, thanks, can&apos;t promise but I&apos;ll try to have a look at it <b>👍</b></z><z id="t1639273708" t="Lukas Domagala whats the best way to approach normalized trees if i want to be able to do things like get-subtree or get-path-to-root, but still get the output as a normalized tree? as an example: [{:name :a, :parent :root} {:name :c, :parent :root} {:name :d, :parent :c} {:name :e, :parent :d} {:name :f, :parent :b} {:name :b, :parent :a}] now i’d like to find :b and :f when if i ask for children of :a. are there any examples for doing that?"><y>#</y><d>2021-12-12</d><h>01:48</h><w>Lukas Domagala</w>whats the best way to approach normalized trees if i want to be able to do things like get-subtree or get-path-to-root, but still get the output as a normalized tree?
as an example:
<pre>[{:name :a, :parent :root}
 {:name :c, :parent :root}
 {:name :d, :parent :c}
 {:name :e, :parent :d}
 {:name :f, :parent :b}
 {:name :b, :parent :a}]</pre>
now i’d like to find <code>:b</code> and :f when if i ask for children of :a.
are there any examples for doing that?</z><z id="t1639503519" t="noprompt At the moment, Meander doesn’t have an obvious solution to this and I would probably index the data prior to doing any queries over it. (let [data [{:name :a, :parent :root} {:name :c, :parent :root} {:name :d, :parent :c} {:name :e, :parent :d} {:name :f, :parent :b} {:name :b, :parent :a}] index (group-by :parent data) parent :root plain-clj (fn f [parent] (map (fn [?node] (cons ?node (flatten (f (:name ?node))))) (get index parent))) meander (fn f [parent] (m/search [parent index] [?parent {?parent (m/scan {:name ?name :as ?node})}] (cons ?node (flatten (f ?name)))))] (= (plain-clj parent) (meander parent)) ;; =&gt; true (meander parent)) ;; =&gt; (({:name :a, :parent :root} {:name :b, :parent :a} {:name :f, :parent :b}) ({:name :c, :parent :root} {:name :d, :parent :c} {:name :e, :parent :d})) "><y>#</y><d>2021-12-14</d><h>17:38</h><r>noprompt</r>At the moment, Meander doesn’t have an obvious solution to this and I would probably index the data prior to doing any queries over it.

<pre>(let [data [{:name :a, :parent :root}
            {:name :c, :parent :root}
            {:name :d, :parent :c}
            {:name :e, :parent :d}
            {:name :f, :parent :b}
            {:name :b, :parent :a}]
      index (group-by :parent data)
      parent :root

      plain-clj (fn f [parent]
                  (map (fn [?node]
                         (cons ?node (flatten (f (:name ?node)))))
                    (get index parent)))

      meander (fn f [parent]
                (m/search [parent index]
                  [?parent {?parent (m/scan {:name ?name :as ?node})}]
                  (cons ?node (flatten (f ?name)))))]
  (= (plain-clj parent)
     (meander parent))
  ;; =&gt; true
  (meander parent))
;; =&gt;
(({:name :a, :parent :root}
  {:name :b, :parent :a}
  {:name :f, :parent :b})
 ({:name :c, :parent :root}
  {:name :d, :parent :c}
  {:name :e, :parent :d}))</pre>
</z><z id="t1639505154" t="Lukas Domagala ah ok, thank you. I wound up adding a :children array and indexing by :id so that i can do proper tail recursion like this: (defn dependants [n traces] (let [roots (find-roots n traces)] (loop [[x &amp; xs :as nodes] roots seen []] (cond (empty? nodes) seen (empty? (:children x)) (recur xs (conj seen x)) (coll? (:children x)) (recur (into xs (vals (select-keys traces (:children x)))) (conj seen x)))))) just out of interest and if you’ve got a minute, would the “equivalent” meander just replace the cond call?"><y>#</y><d>2021-12-14</d><h>18:05</h><r>Lukas Domagala</r>ah ok, thank you. I wound up adding a :children array and indexing by :id so that i can do proper tail recursion like this:
<pre>(defn dependants [n traces]
  (let [roots (find-roots n traces)]
    (loop [[x &amp; xs :as nodes] roots
           seen []]
      (cond
        (empty? nodes) seen
        (empty? (:children x)) (recur xs (conj seen x))
        (coll? (:children x)) (recur 
                               (into xs (vals (select-keys traces (:children x)))) 
                               (conj seen x))))))</pre>
just out of interest and if you’ve got a minute, would the “equivalent” meander just replace the cond call?</z><z id="t1639505572" t="noprompt I’m not sure I understand the question."><y>#</y><d>2021-12-14</d><h>18:12</h><r>noprompt</r>I’m not sure I understand the question.</z><z id="t1639506111" t="noprompt I don’t think the second clause of the cond is necessary though. If (:children x) is empty? the call to select-keys will return an empty map, vals will return an empty sequence, thus making the into have no effect. But, of course, overall that raises the cost slightly."><y>#</y><d>2021-12-14</d><h>18:21</h><r>noprompt</r>I don’t think the second clause of the <code>cond</code> is necessary though. If <code>(:children x)</code> is <code>empty?</code> the call to <code>select-keys</code> will return an empty map, <code>vals</code> will return an empty sequence, thus making the <code>into</code> have no effect. But, of course,  overall that raises the cost slightly.</z><z id="t1639515219" t="Lukas Domagala you are correct, I haven’t cleaned it up yet since I’m still playing with other features. my question was if a meander alternative to the handwritten function would look more or less the same with (m/search … (m/scan …) (recur …)) or if it’s going to be easier and give some benefits. I’m trying to figure out if I should try to make most of the query’s on that data meander search calls for consistency or if it makes more sense to mix and match plain clojure with it."><y>#</y><d>2021-12-14</d><h>20:53</h><r>Lukas Domagala</r>you are correct, I haven’t cleaned it up yet since I’m still playing with other features.
my question was if a meander alternative to the handwritten function would look more or less the same with (m/search … (m/scan …) (recur …)) or if it’s going to be easier and give some benefits.
I’m trying to figure out if I should try to make most of the query’s on that data meander search calls for consistency or if it makes more sense to mix and match plain clojure with it.</z><z id="t1639516491" t="noprompt So, at the moment, recur can’t be used on the right side of any meander expression like search . This is because the compiler will often emit functions that wrap the right side. In terms of comparing plain Clojure or Meander, that is honestly up to you. Meander is often a suitable replacement for nested map , mapcat , filter , etc. type of work. It is especially designed for pulling apart data and matching patterns in data that would be a pain to write by hand in Clojure."><y>#</y><d>2021-12-14</d><h>21:14</h><r>noprompt</r>So, at the moment, <code>recur</code> can’t be used on the right side of any meander expression like <code>search</code>. This is because the compiler will often emit functions that wrap the right side.

In terms of comparing plain Clojure or Meander, that is honestly up to you. Meander is often a suitable replacement for nested <code>map</code>, <code>mapcat</code>, <code>filter</code>, etc. type of work. It is especially designed for pulling apart data and matching patterns in data that would be a pain to write by hand in Clojure.</z><z id="t1639516544" t="noprompt If you use it for a little while, you’ll figure out where it helps you and where it is just a distraction. 🙂"><y>#</y><d>2021-12-14</d><h>21:15</h><r>noprompt</r>If you use it for a little while, you’ll figure out where it helps you and where it is just a distraction. <b>🙂</b></z><z id="t1639656514" t="Ben Sless Anyone ever tried implementing something like syntax-case with meander?"><y>#</y><d>2021-12-16</d><h>12:08</h><w>Ben Sless</w>Anyone ever tried implementing something like <code>syntax-case</code> with meander?</z><z id="t1639699828" t="noprompt Sort of. syntax-case is the inspiration for what the next iteration of meander will have as its extension mechanism (instead of defsyntax ). It looks like (defoperator boolean (_) (`pick true false) (_ &amp; ?rest) (`each (boolean) &amp; ?rest)) So (boolean) would expand to (pick true false) and (boolean ?x) would expand to (each (pick true false) ?x) . I like this approach a lot because the left side is pattern matching on the form (the _ is boolean ). The other thing I like is that the right side is using substitution. I think syntax-case works much like this with ... being usable on the right side IIRC."><y>#</y><d>2021-12-17</d><h>00:10</h><r>noprompt</r>Sort of. <code>syntax-case</code> is the inspiration for what the next iteration of meander will have as its extension mechanism (instead of <code>defsyntax</code>). It looks like

<pre>(defoperator boolean
  (_) (`pick true false)
  (_ &amp; ?rest) (`each (boolean) &amp; ?rest))</pre>
So <code>(boolean)</code> would expand to <code>(pick true false)</code> and <code>(boolean ?x)</code> would expand to <code>(each (pick true false) ?x)</code>.

I like this approach a lot because the left side is pattern matching on the form (the <code>_</code> is <code>boolean</code>).  The other thing I like is that the right side is using substitution. I think <code>syntax-case</code> works much like this with <code>...</code> being usable on the right side IIRC.</z><z id="t1639719231" t="Ben Sless It&apos;s pretty easy to define a macro which expands to rewrite. The problem (?) is schemes syntax definition has way less semantics and is hygienic. I tried playing around with it and it works, but requires lots of care in the definition. Will paste my experiments later"><y>#</y><d>2021-12-17</d><h>05:33</h><r>Ben Sless</r>It&apos;s pretty easy to define a macro which expands to rewrite. The problem (?) is schemes syntax definition has way less semantics and is hygienic.
I tried playing around with it and it works, but requires lots of care in the definition. Will paste my experiments later</z></g><g id="s14"><z id="t1639721551" t="Ben Sless Here, juxtaposed scheme and meander defined macros https://gist.github.com/bsless/ef07a7ab21a614720a36c698b5121d6e"><y>#</y><d>2021-12-17</d><h>06:12</h><r>Ben Sless</r>Here, juxtaposed scheme and meander defined macros
<a href="https://gist.github.com/bsless/ef07a7ab21a614720a36c698b5121d6e" target="_blank">https://gist.github.com/bsless/ef07a7ab21a614720a36c698b5121d6e</a></z><z id="t1639933304" t="Ben Sless A question this experiment raises, should ... be greedy? The only way I had to match the correct number was to require the aggregation stop at a certain number on both sides"><y>#</y><d>2021-12-19</d><h>17:01</h><r>Ben Sless</r>A question this experiment raises, should <code>...</code> be greedy? The only way I had to match the correct number was to require the aggregation stop at a certain number on both sides</z><z id="t1640126027" t="noprompt ... is not correct on epsilon and it took me some time to realize this. Basically we need two operators as we do in regular expression: * and *? , greedy and frugal. Greedy star for query (matching) consumes as much as it can, and for yielding (substitution) it produces as much as it can. Frugal star for query gradually consumes more and more of the input like ... does not, and for yielding it does the same for production. ... on epsilon is somewhat of a Frankenstein. It gradually consumes but greedily produces."><y>#</y><d>2021-12-21</d><h>22:33</h><r>noprompt</r><code>...</code> is not correct on <code>epsilon</code> and it took me some time to realize this. Basically we need two operators as we do in regular expression: <code>*</code> and <code>*?</code> , greedy and frugal. Greedy star for query (matching) consumes as much as it can, and for yielding (substitution) it produces as much as it can. Frugal star for query gradually consumes more and more of the input like <code>...</code> does not, and for yielding it does the same for production.

<code>...</code> on <code>epsilon</code> is somewhat of a Frankenstein. It gradually consumes but greedily produces.</z><z id="t1640126080" t="noprompt On the zeta branch, there is GreedyStar and FrugalStar . https://github.com/noprompt/meander/blob/zeta/src/meander/pattern/zeta.cljc"><y>#</y><d>2021-12-21</d><h>22:34</h><r>noprompt</r>On the <code>zeta</code> branch, there is <code>GreedyStar</code> and <code>FrugalStar</code>. <a href="https://github.com/noprompt/meander/blob/zeta/src/meander/pattern/zeta.cljc" target="_blank">https://github.com/noprompt/meander/blob/zeta/src/meander/pattern/zeta.cljc</a></z><z id="t1640126194" t="noprompt This branch is very stale right now as the approach ended up being too slow. The code looks weird because it was designed to construct interpreters and compilers from the same interface. It does this, but rewriting the trees produced by the compiler ended up being too slow and hard to get right though in many cases it was able to produce incredibly compact code."><y>#</y><d>2021-12-21</d><h>22:36</h><r>noprompt</r>This branch is very stale right now as the approach ended up being too slow. The code looks weird because it was designed to construct interpreters and compilers from the same interface. It does this, but rewriting the trees produced by the compiler ended up being too slow and hard to get right though in many cases it was able to produce incredibly compact code.</z><z id="t1640189523" t="Ben Sless This was probably answered many times but what literature would you recommend for the theoretical underpinnings if meander?"><y>#</y><d>2021-12-22</d><h>16:12</h><r>Ben Sless</r>This was probably answered many times but what literature would you recommend for the theoretical underpinnings if meander?</z><z id="t1640200691" t="noprompt I read all kinds of stuff about term rewriting/logic programming/unification/regular expression/combinatorics and kinda mixed all the parts of those things together that I liked. The Handbook of Automated Reasoning has a number of good articles that are worth checking out. Many of the articles in that book can be found freely available on line with a little digging. I read most of Term Rewriting and All That which gave me a lot of new vocabulary words (for Google searches) and introduced me to many of the famous problems and algorithms in the space. In the past year, I&apos;ve found The Art of Computer Programming Combinatorial Alogrithms Part 1 (Vol. 4A of the series) to be an incredible resource. Thanks to that book, I was able to greatly improve the algorithms used to find partitions/permutations of maps and sets far more efficiently than I did before. Of course, there are tons and tons of papers on the influential topics that I enumerated but I can&apos;t recall any off the top of my head at the moment that really stand out."><y>#</y><d>2021-12-22</d><h>19:18</h><r>noprompt</r>I read all kinds of stuff about term rewriting/logic programming/unification/regular expression/combinatorics and kinda mixed all the parts of those things together that I liked. The Handbook of Automated Reasoning has a number of good articles that are worth checking out. Many of the articles in that book can be found freely available on line with a little digging. I read most of Term Rewriting and All That which gave me a lot of new vocabulary words (for Google searches) and introduced me to many of the famous problems and algorithms in the space. In the past year, I&apos;ve found The Art of Computer Programming Combinatorial Alogrithms Part 1 (Vol. 4A of the series) to be an incredible resource. Thanks to that book, I was able to greatly improve the algorithms used to find partitions/permutations of maps and sets far more efficiently than I did before.

Of course, there are tons and tons of papers on the influential topics that I enumerated but I can&apos;t recall any off the top of my head at the moment that really stand out.</z><z id="t1640200778" t="noprompt If you&apos;re up to it, I would accept a patch for a new section of our documentation for &quot;Resources&quot; with links to books and papers. 🙂"><y>#</y><d>2021-12-22</d><h>19:19</h><r>noprompt</r>If you&apos;re up to it, I would accept a patch for a new section of our documentation for &quot;Resources&quot; with links to books and papers. <b>🙂</b></z><z id="t1640204095" t="Ben Sless I&apos;ll start by chasing these references down and PRing an initial patch if you promise in the future to throw in the papers and other books when they come to mind 🙂"><y>#</y><d>2021-12-22</d><h>20:14</h><r>Ben Sless</r>I&apos;ll start by chasing these references down and PRing an initial patch if you promise in the future to throw in the papers and other books when they come to mind <b>🙂</b></z><z id="t1640660778" t="noprompt Works for me!"><y>#</y><d>2022-12-28</d><h>03:06</h><r>noprompt</r>Works for me!</z><z id="t1640691748" t="Ben Sless Done 🙂"><y>#</y><d>2022-12-28</d><h>11:42</h><r>Ben Sless</r>Done <b>🙂</b></z><z id="t1640691767" t="Ben Sless Also separately volunteered some cookbook examples"><y>#</y><d>2022-12-28</d><h>11:42</h><r>Ben Sless</r>Also separately volunteered some cookbook examples</z><z id="t1641247825" t="noprompt Thanks a lot."><y>#</y><d>2022-01-03</d><h>22:10</h><r>noprompt</r>Thanks a lot.</z><z id="t1639933304" t="Ben Sless A question this experiment raises, should ... be greedy? The only way I had to match the correct number was to require the aggregation stop at a certain number on both sides"><y>#</y><d>2021-12-19</d><h>17:01</h><w>Ben Sless</w>A question this experiment raises, should <code>...</code> be greedy? The only way I had to match the correct number was to require the aggregation stop at a certain number on both sides</z><z id="t1639705953" t="jgdavey I’ve got an interesting problem. The shape of data that I’m working with is a map of triples (representing an entity-value-temp-id) to a value. For updates, the data temp-id needs to resolves to the original temp-id of existing data. While I could just munge the data to make it easier to work with, it felt like a cool challenge for meander. What I’ve got currenty looks like this: https://gist.github.com/jgdavey/685ba1fa3c530b09312f95a065050792 . But it feels like I’m missing something. 3 rewrites, but it feels like it should be 2, or perhaps even just 1."><y>#</y><d>2021-12-17</d><h>01:52</h><w>jgdavey</w>I’ve got an interesting problem. The shape of data that I’m working with is a map of triples (representing an entity-value-temp-id) to a value.

For updates, the data temp-id needs to resolves to the original temp-id of existing data. While I could just munge the data to make it easier to work with, it felt like a cool challenge for meander.

What I’ve got currenty looks like this: <a href="https://gist.github.com/jgdavey/685ba1fa3c530b09312f95a065050792" target="_blank">https://gist.github.com/jgdavey/685ba1fa3c530b09312f95a065050792</a>. But it feels like I’m missing something. 3 rewrites, but it feels like it should be 2, or perhaps even just 1.</z><z id="t1640126396" t="noprompt I just glanced at this and I think it seems ok as is. Later today, I&apos;ll start up a REPL and play around with it and see what I can sketch up. 👍"><y>#</y><d>2021-12-21</d><h>22:39</h><r>noprompt</r>I just glanced at this and I think it seems ok as is. Later today, I&apos;ll start up a REPL and play around with it and see what I can sketch up. <b>👍</b></z><z id="t1640187082" t="jgdavey gratitude-thank-you 🙂"><y>#</y><d>2021-12-22</d><h>15:31</h><r>jgdavey</r><b>gratitude-thank-you</b> <b>🙂</b></z><z id="t1640126332" t="noprompt Just an FYI, I&apos;m on vacation for the next few weeks but I&apos;ll be checking in every once in a while. 🙂"><y>#</y><d>2021-12-21</d><h>22:38</h><w>noprompt</w>Just an FYI, I&apos;m on vacation for the next few weeks but I&apos;ll be checking in every once in a while. <b>🙂</b></z><z id="t1640129331" t="markaddleman Well deserved! Enjoy!"><y>#</y><d>2021-12-21</d><h>23:28</h><r>markaddleman</r>Well deserved!  Enjoy!</z><z id="t1640534227" t="Ben Sless Assuming I have some nested map {:x {:y {:z {&amp; (m/seqable [!ks !vs] ...)}} :foo ?foo} how do I rewrite it to a sequence of maps for all vs and add ?foo to the mix?"><y>#</y><d>2022-12-26</d><h>15:57</h><w>Ben Sless</w>Assuming I have some nested map <code>{:x {:y {:z {&amp; (m/seqable [!ks !vs] ...)}} :foo ?foo}</code> how do I rewrite it to a sequence of maps for all <code>vs</code> and add <code>?foo</code> to the mix?</z><z id="t1640534286" t="Ben Sless I tried using cata on the rhs but get only a map back and not a vector"><y>#</y><d>2022-12-26</d><h>15:58</h><w>Ben Sless</w>I tried using <code>cata</code> on the rhs but get only a map back and not a vector</z><z id="t1640534296" t="Ben Sless using rewrite, btw"><y>#</y><d>2022-12-26</d><h>15:58</h><w>Ben Sless</w>using rewrite, btw</z><z id="t1640535053" t="Ben Sless I think I got it, I need to rewrite the RHS to [{:foo ?foo &amp; (m/cata !vs)} ...]"><y>#</y><d>2022-12-26</d><h>16:10</h><w>Ben Sless</w>I think I got it, I need to rewrite the RHS to <code>[{:foo ?foo &amp; (m/cata !vs)} ...]</code></z><z id="t1640719631" t="Richie Why doesn&apos;t the second example match? cheshire parse-string is giving me an java.lang.Integer and I&apos;m trying to join on some data but it&apos;s not matching... (m/match 1 1 :match _ :no) ;; =&gt; :match (m/match (Long. 1) (Long. 1) :match _ :no) ;; =&gt; :no (type 1) ;; =&gt; java.lang.Long (type (Long. 1)) ;; =&gt; java.lang.Long "><y>#</y><d>2022-12-28</d><h>19:27</h><w>Richie</w>Why doesn&apos;t the second example match? cheshire parse-string is giving me an java.lang.Integer and I&apos;m trying to join on some data but it&apos;s not matching...
<pre>(m/match 1
  1 :match
  _ :no)
;; =&gt; :match

(m/match (Long. 1)
  (Long. 1) :match
  _ :no)
;; =&gt; :no

(type 1)
;; =&gt; java.lang.Long

(type (Long. 1))
;; =&gt; java.lang.Long</pre>
</z><z id="t1640719655" t="Richie [meander/epsilon &quot;0.0.650&quot;]"><y>#</y><d>2022-12-28</d><h>19:27</h><r>Richie</r>[meander/epsilon &quot;0.0.650&quot;]</z><z id="t1640721090" t="Jimmy Miller Meander is matching that at the symbol level. It is looking for &apos;(Long. 1) (m/match (Long. 1) 1 :match _ :no) ;; =&gt; :match (m/match &apos;(Long. 1) (Long. 1) :match _ :no) ;; =&gt; :match "><y>#</y><d>2022-12-28</d><h>19:51</h><r>Jimmy Miller</r>Meander is matching that at the symbol level. It is looking for <code>&apos;(Long. 1)</code>

<pre>(m/match (Long. 1)
  1 :match
  _ :no)

;; =&gt; :match

(m/match &apos;(Long. 1)
  (Long. 1) :match
  _ :no)

;; =&gt; :match</pre>
</z><z id="t1640721150" t="Jimmy Miller If you want to just match all numbers, you can do something like thos (m/match (Long. 1) (m/pred number? ?x) :match _ :no)"><y>#</y><d>2022-12-28</d><h>19:52</h><r>Jimmy Miller</r>If you want to just match all numbers, you can do something like thos

<pre>(m/match (Long. 1)
  (m/pred number? ?x) :match
  _ :no)</pre></z><z id="t1640724701" t="Richie good (let [n (Integer. 2)] (m/find [n [{:a (Integer. 1)} {:a (Integer. 2)}]] [?n (m/scan (m/and {:a ?n} ?t))] ?t)) bad (let [n (Integer. 2)] (m/find [{:a (Integer. 1)} {:a (Integer. 2)}] (m/scan (m/and {:a n} ?t)) ?t)) Thanks! Yea, I was thinking that it would have the value there but what you said makes total sense. It&apos;s term rewriting!"><y>#</y><d>2022-12-28</d><h>20:51</h><r>Richie</r>good
<pre>(let [n (Integer. 2)]
  (m/find [n [{:a (Integer. 1)}
              {:a (Integer. 2)}]]
    [?n (m/scan (m/and {:a ?n} ?t))] ?t))</pre>
bad
<pre>(let [n (Integer. 2)]
  (m/find [{:a (Integer. 1)}
           {:a (Integer. 2)}]
    (m/scan (m/and {:a n} ?t)) ?t))</pre>
Thanks! Yea, I was thinking that it would have the value there but what you said makes total sense. It&apos;s term rewriting!</z><z id="t1640811345" t="Richie Oh right, unquote. https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#unquote"><y>#</y><d>2022-12-29</d><h>20:55</h><r>Richie</r>Oh right, unquote. <a href="https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#unquote" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#unquote</a></z><z id="t1640813899" t="Richie Hey. I have this working code: (m/find [{:fruit &quot;apples&quot; :id 1000}] (m/scan (m/and {:fruit &quot;apples&quot; :id ?id1 :identifier ?id2}) (m/and {:fruit &quot;oarnges&quot; :id ?id1 :identifier ?id2})) (or ?id1 ?id2) _ :none) ;; 1000 But I don&apos;t want to repeat myself as much so I&apos;m trying to use defsyntax: (m/defsyntax dry [fruit id] ;; code here ) (m/find [{:fruit &quot;apples&quot; :id 1000}] (m/scan (dry &quot;apples&quot; ?id)) ?id (m/scan (dry &quot;oarnges&quot; ?id)) ?id _ :none) Interestingly, this code works... (m/find [{:fruit &quot;apples&quot; :id 1000}] (m/scan (m/and {:fruit &quot;apples&quot; :id ?id1 :identifier ?id2} (m/let [?id (or ?id1 ?id2)]))) ?id _ :none) ;; 1000 But I don&apos;t know how to get anything to work in a defsyntax. Latest attempt doesn&apos;t compile: (m/defsyntax dry [fruit id] `(m/and {:fruit ~fruit :id ?id1 :identifier ?id2} (m/let [~id (or ?id1 ?id2)]))) Thanks!"><y>#</y><d>2022-12-29</d><h>21:38</h><w>Richie</w>Hey.
I have this working code:
<pre>(m/find [{:fruit &quot;apples&quot;
          :id 1000}]
  (m/scan (m/and
           {:fruit &quot;apples&quot;
            :id ?id1
            :identifier ?id2})
          (m/and
           {:fruit &quot;oarnges&quot;
            :id ?id1
            :identifier ?id2})) (or ?id1 ?id2)
  _ :none)
;; 1000</pre>
But I don&apos;t want to repeat myself as much so I&apos;m trying to use defsyntax:
<pre>(m/defsyntax dry
  [fruit id]
  ;; code here
  )

(m/find [{:fruit &quot;apples&quot;
          :id 1000}]
  (m/scan (dry &quot;apples&quot; ?id)) ?id
  (m/scan (dry &quot;oarnges&quot; ?id)) ?id
  _ :none)</pre>
Interestingly, this code works...
<pre>(m/find [{:fruit &quot;apples&quot;
          :id 1000}]
  (m/scan (m/and
           {:fruit &quot;apples&quot;
            :id ?id1
            :identifier ?id2}
           (m/let [?id (or ?id1 ?id2)]))) ?id
  _ :none)
;; 1000</pre>
But I don&apos;t know how to get anything to work in a defsyntax. Latest attempt doesn&apos;t compile:
<pre>(m/defsyntax dry
  [fruit id]
  `(m/and
    {:fruit ~fruit
     :id ?id1
     :identifier ?id2}
    (m/let [~id (or ?id1 ?id2)])))</pre>
Thanks!</z><z id="t1640814027" t="Richie Correction! the defsyntax compiles but it has a runtime exception 1. Caused by java.lang.RuntimeException No such var: auto-red.api/?id1 Util.java: 221 clojure.lang.Util/runtimeException Compiler.java: 7392 clojure.lang.Compiler/resolveIn Compiler.java: 7362 clojure.lang.Compiler/resolve Compiler.java: 7323 clojure.lang.Compiler/analyzeSymbol Compiler.java: 6772 clojure.lang.Compiler/analyze Compiler.java: 38 clojure.lang.Compiler/access$300 Compiler.java: 6388 clojure.lang.Compiler$LetExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 38 clojure.lang.Compiler/access$300 Compiler.java: 6388 clojure.lang.Compiler$LetExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 9051 clojure.lang.Compiler$CaseExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 6124 clojure.lang.Compiler$BodyExpr$Parser/parse Compiler.java: 6440 clojure.lang.Compiler$LetExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 9051 clojure.lang.Compiler$CaseExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 6124 clojure.lang.Compiler$BodyExpr$Parser/parse Compiler.java: 6440 clojure.lang.Compiler$LetExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 9051 clojure.lang.Compiler$CaseExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 6124 clojure.lang.Compiler$BodyExpr$Parser/parse Compiler.java: 6440 clojure.lang.Compiler$LetExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 6124 clojure.lang.Compiler$BodyExpr$Parser/parse Compiler.java: 6440 clojure.lang.Compiler$LetExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 2833 clojure.lang.Compiler$IfExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 38 clojure.lang.Compiler/access$300 Compiler.java: 6388 clojure.lang.Compiler$LetExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 2833 clojure.lang.Compiler$IfExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 6124 clojure.lang.Compiler$BodyExpr$Parser/parse Compiler.java: 6440 clojure.lang.Compiler$LetExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 6124 clojure.lang.Compiler$BodyExpr$Parser/parse Compiler.java: 5471 clojure.lang.Compiler$FnMethod/parse Compiler.java: 4033 clojure.lang.Compiler$FnExpr/parse Compiler.java: 7109 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 38 clojure.lang.Compiler/access$300 Compiler.java: 6248 clojure.lang.Compiler$LetFnExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 6124 clojure.lang.Compiler$BodyExpr$Parser/parse Compiler.java: 6440 clojure.lang.Compiler$LetExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 6124 clojure.lang.Compiler$BodyExpr$Parser/parse Compiler.java: 5471 clojure.lang.Compiler$FnMethod/parse Compiler.java: 4033 clojure.lang.Compiler$FnExpr/parse Compiler.java: 7109 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 38 clojure.lang.Compiler/access$300 Compiler.java: 6248 clojure.lang.Compiler$LetFnExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 6124 clojure.lang.Compiler$BodyExpr$Parser/parse Compiler.java: 6440 clojure.lang.Compiler$LetExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7099 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 38 clojure.lang.Compiler/access$300 Compiler.java: 6388 clojure.lang.Compiler$LetExpr$Parser/parse Compiler.java: 7111 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 6749 clojure.lang.Compiler/analyze Compiler.java: 6124 clojure.lang.Compiler$BodyExpr$Parser/parse Compiler.java: 5471 clojure.lang.Compiler$FnMethod/parse Compiler.java: 4033 clojure.lang.Compiler$FnExpr/parse Compiler.java: 7109 clojure.lang.Compiler/analyzeSeq Compiler.java: 6793 clojure.lang.Compiler/analyze Compiler.java: 7178 clojure.lang.Compiler/eval Compiler.java: 7136 clojure.lang.Compiler/eval core.clj: 3202 clojure.core/eval core.clj: 3198 clojure.core/eval interruptible_eval.clj: 87 nrepl.middleware.interruptible-eval/evaluate/fn/fn AFn.java: 152 clojure.lang.AFn/applyToHelper AFn.java: 144 clojure.lang.AFn/applyTo core.clj: 667 clojure.core/apply core.clj: 1977 clojure.core/with-bindings* core.clj: 1977 clojure.core/with-bindings* RestFn.java: 425 clojure.lang.RestFn/invoke interruptible_eval.clj: 87 nrepl.middleware.interruptible-eval/evaluate/fn main.clj: 437 clojure.main/repl/read-eval-print/fn main.clj: 437 clojure.main/repl/read-eval-print main.clj: 458 clojure.main/repl/fn main.clj: 458 clojure.main/repl main.clj: 368 clojure.main/repl RestFn.java: 1523 clojure.lang.RestFn/invoke interruptible_eval.clj: 84 nrepl.middleware.interruptible-eval/evaluate interruptible_eval.clj: 56 nrepl.middleware.interruptible-eval/evaluate interruptible_eval.clj: 152 nrepl.middleware.interruptible-eval/interruptible-eval/fn/fn AFn.java: 22 clojure.lang.AFn/run session.clj: 202 nrepl.middleware.session/session-exec/main-loop/fn session.clj: 201 nrepl.middleware.session/session-exec/main-loop AFn.java: 22 clojure.lang.AFn/run Thread.java: 831 java.lang.Thread/run"><y>#</y><d>2022-12-29</d><h>21:40</h><r>Richie</r>Correction! the defsyntax compiles but it has a runtime exception
<pre>1. Caused by java.lang.RuntimeException
   No such var: auto-red.api/?id1

                 Util.java:  221  clojure.lang.Util/runtimeException
             Compiler.java: 7392  clojure.lang.Compiler/resolveIn
             Compiler.java: 7362  clojure.lang.Compiler/resolve
             Compiler.java: 7323  clojure.lang.Compiler/analyzeSymbol
             Compiler.java: 6772  clojure.lang.Compiler/analyze
             Compiler.java:   38  clojure.lang.Compiler/access$300
             Compiler.java: 6388  clojure.lang.Compiler$LetExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java:   38  clojure.lang.Compiler/access$300
             Compiler.java: 6388  clojure.lang.Compiler$LetExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 9051  clojure.lang.Compiler$CaseExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 6124  clojure.lang.Compiler$BodyExpr$Parser/parse
             Compiler.java: 6440  clojure.lang.Compiler$LetExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 9051  clojure.lang.Compiler$CaseExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 6124  clojure.lang.Compiler$BodyExpr$Parser/parse
             Compiler.java: 6440  clojure.lang.Compiler$LetExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 9051  clojure.lang.Compiler$CaseExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 6124  clojure.lang.Compiler$BodyExpr$Parser/parse
             Compiler.java: 6440  clojure.lang.Compiler$LetExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 6124  clojure.lang.Compiler$BodyExpr$Parser/parse
             Compiler.java: 6440  clojure.lang.Compiler$LetExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 2833  clojure.lang.Compiler$IfExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java:   38  clojure.lang.Compiler/access$300
             Compiler.java: 6388  clojure.lang.Compiler$LetExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 2833  clojure.lang.Compiler$IfExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 6124  clojure.lang.Compiler$BodyExpr$Parser/parse
             Compiler.java: 6440  clojure.lang.Compiler$LetExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 6124  clojure.lang.Compiler$BodyExpr$Parser/parse
             Compiler.java: 5471  clojure.lang.Compiler$FnMethod/parse
             Compiler.java: 4033  clojure.lang.Compiler$FnExpr/parse
             Compiler.java: 7109  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java:   38  clojure.lang.Compiler/access$300
             Compiler.java: 6248  clojure.lang.Compiler$LetFnExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 6124  clojure.lang.Compiler$BodyExpr$Parser/parse
             Compiler.java: 6440  clojure.lang.Compiler$LetExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 6124  clojure.lang.Compiler$BodyExpr$Parser/parse
             Compiler.java: 5471  clojure.lang.Compiler$FnMethod/parse
             Compiler.java: 4033  clojure.lang.Compiler$FnExpr/parse
             Compiler.java: 7109  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java:   38  clojure.lang.Compiler/access$300
             Compiler.java: 6248  clojure.lang.Compiler$LetFnExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 6124  clojure.lang.Compiler$BodyExpr$Parser/parse
             Compiler.java: 6440  clojure.lang.Compiler$LetExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7099  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java:   38  clojure.lang.Compiler/access$300
             Compiler.java: 6388  clojure.lang.Compiler$LetExpr$Parser/parse
             Compiler.java: 7111  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 6749  clojure.lang.Compiler/analyze
             Compiler.java: 6124  clojure.lang.Compiler$BodyExpr$Parser/parse
             Compiler.java: 5471  clojure.lang.Compiler$FnMethod/parse
             Compiler.java: 4033  clojure.lang.Compiler$FnExpr/parse
             Compiler.java: 7109  clojure.lang.Compiler/analyzeSeq
             Compiler.java: 6793  clojure.lang.Compiler/analyze
             Compiler.java: 7178  clojure.lang.Compiler/eval
             Compiler.java: 7136  clojure.lang.Compiler/eval
                  core.clj: 3202  clojure.core/eval
                  core.clj: 3198  clojure.core/eval
    interruptible_eval.clj:   87  nrepl.middleware.interruptible-eval/evaluate/fn/fn
                  AFn.java:  152  clojure.lang.AFn/applyToHelper
                  AFn.java:  144  clojure.lang.AFn/applyTo
                  core.clj:  667  clojure.core/apply
                  core.clj: 1977  clojure.core/with-bindings*
                  core.clj: 1977  clojure.core/with-bindings*
               RestFn.java:  425  clojure.lang.RestFn/invoke
    interruptible_eval.clj:   87  nrepl.middleware.interruptible-eval/evaluate/fn
                  main.clj:  437  clojure.main/repl/read-eval-print/fn
                  main.clj:  437  clojure.main/repl/read-eval-print
                  main.clj:  458  clojure.main/repl/fn
                  main.clj:  458  clojure.main/repl
                  main.clj:  368  clojure.main/repl
               RestFn.java: 1523  clojure.lang.RestFn/invoke
    interruptible_eval.clj:   84  nrepl.middleware.interruptible-eval/evaluate
    interruptible_eval.clj:   56  nrepl.middleware.interruptible-eval/evaluate
    interruptible_eval.clj:  152  nrepl.middleware.interruptible-eval/interruptible-eval/fn/fn
                  AFn.java:   22  clojure.lang.AFn/run
               session.clj:  202  nrepl.middleware.session/session-exec/main-loop/fn
               session.clj:  201  nrepl.middleware.session/session-exec/main-loop
                  AFn.java:   22  clojure.lang.AFn/run
               Thread.java:  831  java.lang.Thread/run</pre></z><z id="t1640814199" t="Richie Oh. (m/defsyntax dry [fruit id] `(m/and {:fruit ~fruit (m/or :id :identifier) ~id})) (m/find [{:fruit &quot;apples&quot; :id 1000}] (m/scan (dry &quot;apples&quot; ?id)) ?id (m/scan (dry &quot;oarnges&quot; ?id)) ?id _ :none)"><y>#</y><d>2022-12-29</d><h>21:43</h><r>Richie</r>Oh.
<pre>(m/defsyntax dry
  [fruit id]
  `(m/and
    {:fruit ~fruit
     (m/or :id :identifier) ~id}))

(m/find [{:fruit &quot;apples&quot;
          :id 1000}]
  (m/scan (dry &quot;apples&quot; ?id)) ?id
  (m/scan (dry &quot;oarnges&quot; ?id)) ?id
  _ :none)</pre></z><z id="t1640814225" t="Richie Duh."><y>#</y><d>2022-12-29</d><h>21:43</h><r>Richie</r>Duh.</z><z id="t1640814235" t="Richie That took me hours."><y>#</y><d>2022-12-29</d><h>21:43</h><r>Richie</r>That took me hours.</z><z id="t1640814267" t="Richie Never mind, I got it. Just needed to say (m/or :id :identifier) instead."><y>#</y><d>2022-12-29</d><h>21:44</h><r>Richie</r>Never mind, I got it. Just needed to say <code>(m/or :id :identifier)</code> instead.</z><z id="t1640814273" t="Richie lol"><y>#</y><d>2022-12-29</d><h>21:44</h><r>Richie</r>lol</z><z id="t1640814267" t="Richie Never mind, I got it. Just needed to say (m/or :id :identifier) instead."><y>#</y><d>2022-12-29</d><h>21:44</h><w>Richie</w>Never mind, I got it. Just needed to say <code>(m/or :id :identifier)</code> instead.</z><z id="t1641121954" t="Ben Sless I feel like I&apos;m missing something essential here: (m/match {:b &quot;b&quot;} {:a ?a} [:a ?a] {:b ?b} [:b ?b]) ;; =&gt; [:a nil] "><y>#</y><d>2022-01-02</d><h>11:12</h><w>Ben Sless</w>I feel like I&apos;m missing something essential here:
<pre>(m/match {:b &quot;b&quot;}
  {:a ?a} [:a ?a]
  {:b ?b} [:b ?b]) ;; =&gt; [:a nil]</pre>
</z><z id="t1641123327" t="ribelo you missing m/some"><y>#</y><d>2022-01-02</d><h>11:35</h><r>ribelo</r>you missing <code>m/some</code></z><z id="t1641123391" t="ribelo (m/match {:b &quot;b&quot;} {:a (m/some ?a)} [:a ?a] {:b (m/some ?b)} [:b ?b]) "><y>#</y><d>2022-01-02</d><h>11:36</h><r>ribelo</r><pre>(m/match {:b &quot;b&quot;}
  {:a (m/some ?a)} [:a ?a]
  {:b (m/some ?b)} [:b ?b])</pre>
</z><z id="t1641123440" t="ribelo"><y>#</y><d>2022-01-02</d><h>11:37</h><r>ribelo</r></z><z id="t1641123825" t="Ben Sless Guess I was missing something 🙂"><y>#</y><d>2022-01-02</d><h>11:43</h><r>Ben Sless</r>Guess I was missing something <b>🙂</b></z><z id="t1641123852" t="Ben Sless :drum_with_drumsticks:"><y>#</y><d>2022-01-02</d><h>11:44</h><r>Ben Sless</r><b>:drum_with_drumsticks:</b></z><z id="t1641610476" t="geoff Hi, is it possible to call a function in r/rewrite?"><y>#</y><d>2022-01-08</d><h>02:54</h><w>geoff</w>Hi, is it possible to call a function in r/rewrite?</z><z id="t1641610565" t="geoff (r/rewrite (foo &amp; ?x) (apply fn-to-be-called ?x))"><y>#</y><d>2022-01-08</d><h>02:56</h><w>geoff</w><pre>(r/rewrite (foo &amp; ?x) (apply fn-to-be-called ?x))</pre></z><z id="t1641610598" t="geoff where the result of fn-to-be-called will be substituted in, rather than just the list of symbols (apply fn-to-be-called ?x) with the ?x substituted"><y>#</y><d>2022-01-08</d><h>02:56</h><w>geoff</w>where the result of fn-to-be-called will be substituted in, rather than just the list of symbols <code>(apply fn-to-be-called ?x)</code> with the ?x substituted</z><z id="t1641610723" t="geoff nevermind, looks like defsyntax does exactly what I wanted"><y>#</y><d>2022-01-08</d><h>02:58</h><w>geoff</w>nevermind, looks like defsyntax does exactly what I wanted</z><z id="t1641610729" t="geoff thanks for working on this library"><y>#</y><d>2022-01-08</d><h>02:58</h><w>geoff</w>thanks for working on this library</z><z id="t1641610767" t="Jimmy Miller m/app lets you call functions"><y>#</y><d>2022-01-08</d><h>02:59</h><w>Jimmy Miller</w>m/app lets you call functions</z><z id="t1641610811" t="Jimmy Miller Or I guess in your case r/app"><y>#</y><d>2022-01-08</d><h>03:00</h><r>Jimmy Miller</r>Or I guess in your case r/app</z><z id="t1641612294" t="geoff how would I apply that in the above case?"><y>#</y><d>2022-01-08</d><h>03:24</h><r>geoff</r>how would I apply that in the above case?</z><z id="t1641612312" t="geoff (r/rewrite (foo &amp; ?x) (m/app fn-to-be-called ?x))"><y>#</y><d>2022-01-08</d><h>03:25</h><r>geoff</r><code>(r/rewrite (foo &amp; ?x) (m/app fn-to-be-called ?x))</code></z><z id="t1641612314" t="geoff ?"><y>#</y><d>2022-01-08</d><h>03:25</h><r>geoff</r>?</z><z id="t1641612598" t="geoff ah got it, thanks"><y>#</y><d>2022-01-08</d><h>03:29</h><r>geoff</r>ah got it, thanks</z><z id="t1641835309" t="noprompt FYI I&apos;m back from vacation (been out for about 3 weeks). I&apos;m easing back into work/code now but I should gradually become more responsive."><y>#</y><d>2022-01-10</d><h>17:21</h><w>noprompt</w>FYI I&apos;m back from vacation (been out for about 3 weeks). I&apos;m easing back into work/code now but I should gradually become more responsive.</z><z id="t1641910943" t="Ben Sless This might be a big question, but anything you can share regarding meander&apos;s roadmap?"><y>#</y><d>2022-01-11</d><h>14:22</h><r>Ben Sless</r>This might be a big question, but anything you can share regarding meander&apos;s roadmap?</z><z id="t1641928143" t="noprompt Right now the future of the project depends on having at least one other active participant working on the code from a common starting point on zeta . Though I&apos;ve had of help from folks in the channel on various things, most of the serious implementation work has been done by me. This is unsustainable as I have a job, a family, and other interests. Though I realize that I am under no obligation to be a servant, people value the project and it requires maintenance. When I am unable to maintain the project, it suffers. I have been working on the project privately for a couple hours each week experimenting with different ideas but I have the main idea figured out. Those ideas are in code but need to be translated into a document, tickets, etc."><y>#</y><d>2022-01-11</d><h>19:09</h><r>noprompt</r>Right now the future of the project depends on having at least one other active participant working on the code from a common starting point on <code>zeta</code>. Though I&apos;ve had of help from folks in the channel on various things, most of the serious implementation work has been done by me. This is unsustainable as I have a job, a family, and other interests. Though I realize that I am under no obligation to be a servant, people value the project and it requires maintenance. When I am unable to maintain the project, it suffers.

I have been working on the project privately for a couple hours each week experimenting with different ideas but I have the main idea figured out. Those ideas are in code but need to be translated into a document, tickets, etc.</z><z id="t1641928270" t="noprompt Send me a DM with some available time to meet up on Zoom/Hangouts/Discord/Webex and I&apos;ll consider that and application. 🙂"><y>#</y><d>2022-01-11</d><h>19:11</h><r>noprompt</r>Send me a DM with some available time to meet up on Zoom/Hangouts/Discord/Webex and I&apos;ll consider that and application. <b>🙂</b></z><z id="t1642079291" t="Ben Sless Is there a way in meander to not add a matched value to the result if it&apos;s nil ?"><y>#</y><d>2022-01-13</d><h>13:08</h><w>Ben Sless</w>Is there a way in meander to not add a matched value to the result if it&apos;s <code>nil</code>?</z><z id="t1642080299" t="ribelo IIRC m/some also works on rhs"><y>#</y><d>2022-01-13</d><h>13:24</h><w>ribelo</w>IIRC <code>m/some</code> also works on <code>rhs</code></z><z id="t1642081003" t="Ben Sless How would that look like if I&apos;m matching {:x ?x :y ?y} and want to rewrite as {:x ?x :y ?y} if ?y is some and {:x ?x} if not?"><y>#</y><d>2022-01-13</d><h>13:36</h><w>Ben Sless</w>How would that look like if I&apos;m matching <code>{:x ?x :y ?y}</code> and want to rewrite as <code>{:x ?x :y ?y}</code> if <code>?y</code> is <code>some</code> and <code>{:x ?x}</code> if not?</z><z id="t1642081450" t="ribelo when I&apos;m at the computer later, I&apos;ll take a look"><y>#</y><d>2022-01-13</d><h>13:44</h><w>ribelo</w>when I&apos;m at the computer later, I&apos;ll take a look</z><z id="t1642082483" t="ribelo [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] (me/rewrite {:a 1 :b 2 :c 3} {:a ?a :d ?d} {&amp; [[:aa ?a] ~(if ?d [:dd ?d])]}) "><y>#</y><d>2022-01-13</d><h>14:01</h><w>ribelo</w><a>@ben.sless</a>
<pre>(me/rewrite {:a 1 :b 2 :c 3}
  {:a ?a :d ?d}
  {&amp; [[:aa ?a] ~(if ?d [:dd ?d])]})</pre>
</z><z id="t1642082509" t="ribelo unfortunately m/some does not work on rhs"><y>#</y><d>2022-01-13</d><h>14:01</h><w>ribelo</w>unfortunately <code>m/some</code> does not work on <code>rhs</code></z><z id="t1642082526" t="ribelo and even worse, I am getting old because my memory is failing ; P"><y>#</y><d>2022-01-13</d><h>14:02</h><w>ribelo</w>and even worse, I am getting old because my memory is failing ; P</z><z id="t1642088692" t="Ben Sless GOT IT (m/rewrite {:a &apos;a :b nil} {:a ?a :b ?b} {:a ?a &amp; ~@(if ?b [[:b ?b]])}) "><y>#</y><d>2022-01-13</d><h>15:44</h><w>Ben Sless</w>GOT IT
<pre>(m/rewrite {:a &apos;a :b nil}
  {:a ?a :b ?b} {:a ?a &amp; ~@(if ?b [[:b ?b]])})</pre>
</z><z id="t1642088702" t="Ben Sless Feels evil"><y>#</y><d>2022-01-13</d><h>15:45</h><w>Ben Sless</w>Feels evil</z><z id="t1642088706" t="Ben Sless will do it anyway"><y>#</y><d>2022-01-13</d><h>15:45</h><w>Ben Sless</w>will do it anyway</z><z id="t1642088930" t="Ben Sless Even better: (m/rewrite {:a &apos;a :b nil :c 3} {:a ?a :b ?b :c ?c} {:a ?a &amp; ~[(if ?b [:b ?b]) (if ?c [:c ?c])]}) "><y>#</y><d>2022-01-13</d><h>15:48</h><w>Ben Sless</w>Even better:
<pre>(m/rewrite {:a &apos;a :b nil :c 3}

  {:a ?a :b ?b :c ?c}
  {:a ?a
   &amp; ~[(if ?b [:b ?b])
       (if ?c [:c ?c])]})</pre>
</z><z id="t1642096645" t="Ben Sless Thanks borkdude, we now have a starting point"><y>#</y><d>2022-01-13</d><h>17:57</h><w>Ben Sless</w>Thanks borkdude, we now have a starting point</z><z id="t1642133101" t="noprompt (m/rewrite {:a &apos;a :b nil} {:a ?a &amp; (m/gather [!k (m/some !v)])} {:a ?a &amp; [[!k !v] ...]}) ;; =&gt; {:a a} (m/rewrite {:a &apos;a :b nil :c &apos;c :d nil} {:a ?a &amp; (m/gather [!k (m/some !v)])} {:a ?a &amp; [[!k !v] ...]}) ;; =&gt; {:a a, :c c} "><y>#</y><d>2022-01-14</d><h>04:05</h><w>noprompt</w><pre>(m/rewrite {:a &apos;a :b nil}
  {:a ?a &amp; (m/gather [!k (m/some !v)])}
  {:a ?a &amp; [[!k !v] ...]})
;; =&gt;
{:a a}

(m/rewrite {:a &apos;a :b nil :c &apos;c :d nil}
  {:a ?a &amp; (m/gather [!k (m/some !v)])}
  {:a ?a &amp; [[!k !v] ...]})
;; =&gt;
{:a a, :c c}</pre>
</z><z id="t1642133134" t="noprompt You can use m/gather for this kind (it works the best for memory variables)."><y>#</y><d>2022-01-14</d><h>04:05</h><w>noprompt</w>You can use <code>m/gather</code> for this kind (it works the best for memory variables).</z><z id="t1642133178" t="noprompt That pattern is the same as writing {:a ?a &amp; (m/seqable (m/or [!k (m/some !v)] _) ...)} "><y>#</y><d>2022-01-14</d><h>04:06</h><w>noprompt</w>That pattern is the same as writing
<pre>{:a ?a &amp; (m/seqable (m/or [!k (m/some !v)] _) ...)}</pre>
</z><z id="t1642133408" t="noprompt More verbosely (m/rewrite {:a &apos;a :b nil :c &apos;c :d nil} {?k nil &amp; (m/cata ?m)} ?m {?k ?v &amp; (m/cata ?m)} {?k ?v &amp; ?m} {} {}) ;; =&gt; {:a a, :c c} Pattern match on the ?k nil first."><y>#</y><d>2022-01-14</d><h>04:10</h><w>noprompt</w>More verbosely
<pre>(m/rewrite {:a &apos;a :b nil :c &apos;c :d nil}
  {?k nil &amp; (m/cata ?m)}
  ?m
  
  {?k ?v &amp; (m/cata ?m)}
  {?k ?v &amp; ?m}

  {}
  {})
;; =&gt;
{:a a, :c c}</pre>
Pattern match on the <code>?k nil</code> first.</z><z id="t1642506965" t="prepor Hi! I like to use matchers in tests, like https://github.com/nubank/matcher-combinators But I&apos;m not happy with this particular library and all known alternatives (including mine). I&apos;m thinking about integrating meander with clojure.test. What do you think, does it makes sense? Maybe someone already tried or use it in this way?"><y>#</y><d>2022-01-18</d><h>11:56</h><w>prepor</w>Hi! I like to use matchers in tests, like <a href="https://github.com/nubank/matcher-combinators" target="_blank">https://github.com/nubank/matcher-combinators</a>

But I&apos;m not happy with this particular library and all known alternatives (including mine). I&apos;m thinking about integrating meander with clojure.test. What do you think, does it makes sense? Maybe someone already tried or use it in this way?</z><z id="t1642610005" t="noprompt This is something that I&apos;ve experimented with/wanted to do, integrating Meander with clojure.test , but Meander doesn&apos;t have failure reporting or explanation right now. I&apos;ve mostly used Meander in tests this way (t/is (m/find result {:x (m/some) :y (m/some)} true) &quot;result has the right shape&quot;) "><y>#</y><d>2022-01-19</d><h>16:33</h><r>noprompt</r>This is something that I&apos;ve experimented with/wanted to do, integrating Meander with <code>clojure.test</code>, but Meander doesn&apos;t have failure reporting or explanation right now. I&apos;ve mostly used Meander in tests this way
<pre>(t/is (m/find result {:x (m/some) :y (m/some)} true)
      &quot;result has the right shape&quot;)</pre>
</z><z id="t1642959742" t="prepor Yes, without the &quot;why didn&apos;t match&quot; explanation it has bad fit for full-scale usage in tests... As I understand, the generation of useful &quot;explanations&quot; for meander is a really hard or even unsolvable problem. But maybe it can be done in a different way? Clojure development is really dynamic and almost always includes REPL. So, maybe we can make an interactive step-based debugger with access to backtracking, etc. I think we can make it REPL friendly, by for example memoizing the last failed expect / actual pairs in the scope of tests. What do you think? Such a tool could be useful not only for tests but for general meander development / debugging."><y>#</y><d>2022-01-23</d><h>17:42</h><r>prepor</r>Yes, without the &quot;why didn&apos;t match&quot; explanation it has bad fit for full-scale usage in tests...

As I understand, the generation of useful &quot;explanations&quot; for meander is a really hard or even unsolvable problem. But maybe it can be done in a different way?

Clojure development is really dynamic and almost always includes REPL. So, maybe we can make an interactive step-based debugger with access to backtracking, etc. I think we can make it REPL friendly, by for example memoizing the last failed expect / actual pairs in the scope of tests.

What do you think? Such a tool could be useful not only for tests but for general meander development / debugging.</z><z id="t1642904737" t="lvh Hi! I’m using meander to do this: (m/search inferred-schemata (m/and (m/scan {:create-table ?table :with-columns (m/scan [?field _type])}) (m/let [?idx (condp re-find (-&gt;snake-str ?field) #&quot;uuid$&quot; :exact #&quot;name$&quot; :nocase #&quot;^alias&quot; :nocase nil)])) (let [table (-&gt;snake-str ?table) field (-&gt;snake-str ?field) index (format &quot;idx_%s_%s&quot; table field) tail (when (= ?idx :nocase) &quot; COLLATE NOCASE&quot;)] [(format &quot;CREATE INDEX %s ON %s (%s)%s;&quot; index table field tail)])) However, I only want to match when (some? ?let) — how can I do that for an m/let introduced variable?"><y>#</y><d>2022-01-23</d><h>02:25</h><w>lvh</w>Hi! I’m using meander to do this:

<pre>(m/search inferred-schemata
    (m/and
     (m/scan
      {:create-table ?table
       :with-columns (m/scan [?field _type])})
     (m/let [?idx (condp re-find (-&gt;snake-str ?field)
                    #&quot;uuid$&quot; :exact
                    #&quot;name$&quot; :nocase
                    #&quot;^alias&quot; :nocase
                    nil)]))

    (let [table (-&gt;snake-str ?table)
          field (-&gt;snake-str ?field)
          index (format &quot;idx_%s_%s&quot; table field)
          tail (when (= ?idx :nocase) &quot; COLLATE NOCASE&quot;)]
      [(format &quot;CREATE INDEX %s ON %s (%s)%s;&quot; index table field tail)]))</pre>
However, I only want to match when <code>(some? ?let)</code>  — how can I do that for an m/let introduced variable?</z><z id="t1642905446" t="lvh I’m able to hack around it fine: (-&gt;&gt; (m/search inferred-schemata (m/and (m/scan {:create-table ?table :with-columns (m/scan [?field _type])}) (m/let [?idx (condp re-find (-&gt;snake-str ?field) #&quot;uuid$&quot; :exact #&quot;name$&quot; :nocase #&quot;^alias&quot; :nocase nil)])) (when ?idx (let [table (-&gt;snake-str ?table) field (-&gt;snake-str ?field) index (format &quot;idx_%s_%s&quot; table field) tail (when (= ?idx :nocase) &quot; COLLATE NOCASE&quot;)] [(format &quot;CREATE INDEX %s ON %s (%s)%s;&quot; index table field tail)]))) (remove nil?)) but I’d love to be able to just write it in meander"><y>#</y><d>2022-01-23</d><h>02:37</h><w>lvh</w>I’m able to hack around it fine:

<pre>(-&gt;&gt;
   (m/search inferred-schemata
     (m/and
      (m/scan
       {:create-table ?table
        :with-columns (m/scan [?field _type])})
      (m/let [?idx (condp re-find (-&gt;snake-str ?field)
                     #&quot;uuid$&quot; :exact
                     #&quot;name$&quot; :nocase
                     #&quot;^alias&quot; :nocase
                     nil)]))
     (when ?idx
       (let [table (-&gt;snake-str ?table)
             field (-&gt;snake-str ?field)
             index (format &quot;idx_%s_%s&quot; table field)
             tail (when (= ?idx :nocase) &quot; COLLATE NOCASE&quot;)]
         [(format &quot;CREATE INDEX %s ON %s (%s)%s;&quot; index table field tail)])))
   (remove nil?))</pre>
but I’d love to be able to just write it in meander</z><z id="t1642911590" t="noprompt For this kinda thing m/with is gonna help"><y>#</y><d>2022-01-23</d><h>04:19</h><w>noprompt</w>For this kinda thing <code>m/with</code> is gonna help</z><z id="t1642911592" t="noprompt (defn test [] (m/search {:create-table &quot;foo&quot; :with-columns {&quot;foo&quot; &quot;bar&quot;}} (m/with [%index (m/or (m/let [?idx :exact, ?tail &quot;&quot;] (m/re #&quot;.*uuid&quot;)) (m/let [?idx :nocase, ?tail &quot; COLLATE NOCASE&quot;] (m/re #&quot;^alias.*|.*name$&quot;))) %table (m/app -&gt;snake-str ?table) %field (m/app -&gt;snake-str ?field %index)] {:create-table %table :with-columns (m/scan [%field _type])}) (let [index (format &quot;idx_%s_%s&quot; ?table ?field)] [(format &quot;CREATE INDEX %s ON %s (%s)%s;&quot; index ?table ?field ?tail)]))) (do (def -&gt;snake-str (constantly &quot;fooname&quot;)) (test)) ;; =&gt; ([&quot;CREATE INDEX idx_fooname_fooname ON fooname (fooname) COLLATE NOCASE;&quot;]) (do (def -&gt;snake-str (constantly &quot;aliasfoo&quot;)) (test)) ;; =&gt; ([&quot;CREATE INDEX idx_aliasfoo_aliasfoo ON aliasfoo (aliasfoo) COLLATE NOCASE;&quot;]) (do (def -&gt;snake-str (constantly &quot;foouuid&quot;)) (test)) ;; =&gt; ([&quot;CREATE INDEX idx_foouuid_foouuid ON foouuid (foouuid);&quot;]) "><y>#</y><d>2022-01-23</d><h>04:19</h><w>noprompt</w><pre>(defn test []
  (m/search {:create-table &quot;foo&quot;
             :with-columns {&quot;foo&quot; &quot;bar&quot;}}
    (m/with [%index (m/or (m/let [?idx :exact, ?tail &quot;&quot;]
                            (m/re #&quot;.*uuid&quot;))
                          (m/let [?idx :nocase, ?tail &quot; COLLATE NOCASE&quot;]
                            (m/re #&quot;^alias.*|.*name$&quot;)))
             %table (m/app -&gt;snake-str ?table)
             %field (m/app -&gt;snake-str ?field %index)]
      {:create-table %table
       :with-columns (m/scan [%field _type])})
    (let [index (format &quot;idx_%s_%s&quot; ?table ?field)]
      [(format &quot;CREATE INDEX %s ON %s (%s)%s;&quot; index ?table ?field ?tail)])))
(do
  (def -&gt;snake-str
    (constantly &quot;fooname&quot;))
  (test))
;; =&gt;
([&quot;CREATE INDEX idx_fooname_fooname ON fooname (fooname) COLLATE NOCASE;&quot;])

(do 
  (def -&gt;snake-str
    (constantly &quot;aliasfoo&quot;))
  (test))
;; =&gt;
([&quot;CREATE INDEX idx_aliasfoo_aliasfoo ON aliasfoo (aliasfoo) COLLATE NOCASE;&quot;])

(do
  (def -&gt;snake-str
    (constantly &quot;foouuid&quot;))
  (test))
;; =&gt;
([&quot;CREATE INDEX idx_foouuid_foouuid ON foouuid (foouuid);&quot;])</pre>
</z><z id="t1642911665" t="noprompt I made up -&gt;snake-str here to test three regex cases."><y>#</y><d>2022-01-23</d><h>04:21</h><w>noprompt</w>I made up <code>-&gt;snake-str</code> here to test three regex cases.</z><z id="t1642911692" t="noprompt The nil case comes free by virtue of search failure not returning the results."><y>#</y><d>2022-01-23</d><h>04:21</h><w>noprompt</w>The <code>nil</code> case comes free by virtue of search failure not returning the results.</z><z id="t1642911754" t="noprompt In the two m/let cases we can bind ?tail since tail (when (= ?idx :nocase) &quot; COLLATE NOCASE&quot;) from the code you pasted."><y>#</y><d>2022-01-23</d><h>04:22</h><w>noprompt</w>In the two <code>m/let</code> cases we can bind <code>?tail</code> since
<pre>tail (when (= ?idx :nocase) &quot; COLLATE NOCASE&quot;)</pre>
from the code you pasted.</z><z id="t1642911819" t="noprompt I hope I got this right or at least close. 🙂"><y>#</y><d>2022-01-23</d><h>04:23</h><w>noprompt</w>I hope I got this right or at least close. <b>🙂</b></z><z id="t1642911916" t="noprompt My wife made a sushi bake and I ate a lot of it so I&apos;m kinda loopy on the account of a blood sugar spike. 😛"><y>#</y><d>2022-01-23</d><h>04:25</h><w>noprompt</w>My wife made a sushi bake and I ate a lot of it so I&apos;m kinda loopy on the account of a blood sugar spike. <b>😛</b></z><z id="t1642963030" t="lvh ah gotcha yep that makes sense, thanks!"><y>#</y><d>2022-01-23</d><h>18:37</h><w>lvh</w>ah gotcha yep that makes sense, thanks!</z><z id="t1643156038" t="Richie I just noticed https://clojurians.slack.com/archives/C06MAR553/p1638472642137200 that clojurians has slack pro for a year now. That means I can search the meander channel for e.g. &quot;cata&quot; and get lots of examples. Yay."><y>#</y><d>2022-01-26</d><h>00:13</h><w>Richie</w>I just noticed <a href="https://clojurians.slack.com/archives/C06MAR553/p1638472642137200" target="_blank">https://clojurians.slack.com/archives/C06MAR553/p1638472642137200</a> that clojurians has slack pro for a year now. That means I can search the meander channel for e.g. &quot;cata&quot; and get lots of examples. Yay.</z><z id="t1643216634" t="noprompt [:attrs {:href &quot;/_/_/users/UPD88PGNT&quot;}] If you think any of those examples would be good to throw into the documentation/cookbook etc, open up a PR. 🙂"><y>#</y><d>2022-01-26</d><h>17:03</h><w>noprompt</w><a>@rgkirch</a> If you think any of those examples would be good to throw into the documentation/cookbook etc, open up a PR. <b>🙂</b></z><z id="t1643248490" t="Richie I have saved some example that I think would be good and it is my intention to open a pr. I don&apos;t know when. Thanks for the encouragement!"><y>#</y><d>2022-01-27</d><h>01:54</h><r>Richie</r>I have saved some example that I think would be good and it is my intention to open a pr. I don&apos;t know when. Thanks for the encouragement!</z><z id="t1643287190" t="Ben Sless I have some nested data structure looking approximately like: [{:x [{:y [{:z [{:w [!k ...]} ...]} ...]} ...]} ...] Where !k is a string I have another which is a map of {(keyword !k) {:data ?data}} Where I want to produce [{:x [{:y [{:z [{:w [!k ...] :data ?data} ...]} ...]} ...]} ...] "><y>#</y><d>2022-01-27</d><h>12:39</h><w>Ben Sless</w>I have some nested data structure looking approximately like:
<pre>[{:x [{:y [{:z [{:w [!k ...]} ...]} ...]} ...]} ...]</pre>
Where <code>!k</code> is a string
I have another which is a map of <code>{(keyword !k) {:data ?data}}</code>
Where I want to produce
<pre>[{:x [{:y [{:z [{:w [!k ...] :data ?data} ...]} ...]} ...]} ...]</pre>
</z><z id="t1643287482" t="Ben Sless Turns out to be less simple than I expected"><y>#</y><d>2022-01-27</d><h>12:44</h><w>Ben Sless</w>Turns out to be less simple than I expected</z><z id="t1643293048" t="ribelo [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] I am weak in understanding"><y>#</y><d>2022-01-27</d><h>14:17</h><w>ribelo</w><a>@ben.sless</a> I am weak in understanding</z><z id="t1643293102" t="ribelo you could give example input -&gt; output and I will have a try with that."><y>#</y><d>2022-01-27</d><h>14:18</h><w>ribelo</w>you could give example <code>input -&gt; output</code> and I will have a try with that.</z><z id="t1643293476" t="Ben Sless in words: sequence of maps, in key x there is a sequence of maps ,,, down to key w In w there is a sequence of strings I want to take that sequence, use it to lookup in another map where each key maps to a sequence, and assoc this sequence in the same map as w"><y>#</y><d>2022-01-27</d><h>14:24</h><w>Ben Sless</w>in words:
sequence of maps, in key x there is a sequence of maps ,,, down to key w
In w there is a sequence of strings
I want to take that sequence, use it to lookup in another map where each key maps to a sequence, and assoc this sequence in the same map as <code>w</code></z><z id="t1643294181" t="ribelo (m/rewrite [{:a [{:b [{:c [&quot;d&quot; &quot;e&quot; &quot;f&quot;]}]}]} {:d 1 :e 1 :f 1}] [{:a [{:b [{:c [(m/app keyword !ks) ...]}]}] :as ?m} (m/map-of !ks !vs)] {&amp; [?m [!ks !vs] ...]}) "><y>#</y><d>2022-01-27</d><h>14:36</h><w>ribelo</w><pre>(m/rewrite [{:a [{:b [{:c [&quot;d&quot; &quot;e&quot; &quot;f&quot;]}]}]}
            {:d 1 :e 1 :f 1}]
  [{:a [{:b [{:c [(m/app keyword !ks) ...]}]}] :as ?m}
   (m/map-of !ks !vs)]
  {&amp; [?m [!ks !vs] ...]})</pre>
</z><z id="t1643294220" t="ribelo [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] something like that?"><y>#</y><d>2022-01-27</d><h>14:37</h><w>ribelo</w><a>@ben.sless</a> something like that?</z><z id="t1643294612" t="Ben Sless yes but all the nested sequences can also repeat"><y>#</y><d>2022-01-27</d><h>14:43</h><w>Ben Sless</w>yes but all the nested sequences can also repeat</z><z id="t1643294630" t="Ben Sless More like (let [lookup {:a [1 2 3] :b [4 5 6] :c [7 8 9] :H &apos;[x y z]}] (m/rewrite {:x [{:y [{:z [{:w [&quot;a&quot; &quot;b&quot;]} {:w [&quot;c&quot; &quot;d&quot;]}]} {:z [{:w [&quot;e&quot; &quot;f&quot;]} {:w [&quot;g&quot; &quot;h&quot;]}]}]} {:y [{:z [{:w [&quot;A&quot; &quot;B&quot;]} {:w [&quot;C&quot; &quot;D&quot;]}]} {:z [{:w [&quot;E&quot; &quot;F&quot;]} {:w [&quot;G&quot; &quot;H&quot;]}]}]}]} {:x [!x ...]} {:x [(m/cata !x) ...]} {:y [!x ...]} {:y [(m/cata !x) ...]} {:z [!x ...]} {:z [(m/cata !x) ...]} {:w [(m/and !x (m/app keyword !k)) ...]} {:w [!x ...] :k [!k ...] :lookup ~lookup})) "><y>#</y><d>2022-01-27</d><h>14:43</h><w>Ben Sless</w>More like
<pre>(let [lookup {:a [1 2 3]
              :b [4 5 6]
              :c [7 8 9]
              :H &apos;[x y z]}]
  (m/rewrite
    {:x
     [{:y
       [{:z
         [{:w [&quot;a&quot; &quot;b&quot;]}
          {:w [&quot;c&quot; &quot;d&quot;]}]}
        {:z
         [{:w [&quot;e&quot; &quot;f&quot;]}
          {:w [&quot;g&quot; &quot;h&quot;]}]}]}
      {:y
       [{:z
         [{:w [&quot;A&quot; &quot;B&quot;]}
          {:w [&quot;C&quot; &quot;D&quot;]}]}
        {:z
         [{:w [&quot;E&quot; &quot;F&quot;]}
          {:w [&quot;G&quot; &quot;H&quot;]}]}]}]}

    {:x [!x ...]}
    {:x [(m/cata !x) ...]}

    {:y [!x ...]}
    {:y [(m/cata !x) ...]}

    {:z [!x ...]}
    {:z [(m/cata !x) ...]}

    {:w [(m/and !x (m/app keyword !k)) ...]}
    {:w [!x ...] :k [!k ...] :lookup ~lookup}))</pre>
</z><z id="t1643294635" t="Ben Sless But I&apos;m stuck on the final transition"><y>#</y><d>2022-01-27</d><h>14:43</h><w>Ben Sless</w>But I&apos;m stuck on the final transition</z><z id="t1643294741" t="Jimmy Miller You can use [!x ..!n] to capture the number of times something repeats. Helps keep those nested repeats in place."><y>#</y><d>2022-01-27</d><h>14:45</h><w>Jimmy Miller</w>You can use <code>[!x ..!n]</code> to capture the number of times something repeats. Helps keep those nested repeats in place.</z><z id="t1643294939" t="Ben Sless I&apos;ll try again and try to see where I bumped against that specific wall, because I started with it"><y>#</y><d>2022-01-27</d><h>14:48</h><w>Ben Sless</w>I&apos;ll try again and try to see where I bumped against that specific wall, because I started with it</z><z id="t1643295154" t="Ben Sless (m/rewrite {:in [{:x [{:y [{:z [{:w [&quot;a&quot; &quot;b&quot;]} {:w [&quot;c&quot; &quot;d&quot;]}]} {:z [{:w [&quot;e&quot; &quot;f&quot;]} {:w [&quot;g&quot; &quot;h&quot;]}]}]} {:y [{:z [{:w [&quot;A&quot; &quot;B&quot;]} {:w [&quot;C&quot; &quot;D&quot;]}]} {:z [{:w [&quot;E&quot; &quot;F&quot;]} {:w [&quot;G&quot; &quot;H&quot;]}]}]}]}] :look {:a [1 2 3] :b [4 5 6] :c [7 8 9] :H &apos;[x y z]}} {:in [{:x [{:y [{:z [{:w [(m/and !s (m/app keyword !k)) ..!nk]} ..!nw]} ..!nz]} ..!ny]} ..!nx] :look {!k [!d ...]}} [{:x [{:y [{:z [{:w [!s ..!nk] :d [!d ...]} ..!nw]} ..!nz]} ..!ny]} ..!nx] ) "><y>#</y><d>2022-01-27</d><h>14:52</h><w>Ben Sless</w><pre>(m/rewrite
  {:in [{:x
         [{:y
           [{:z
             [{:w [&quot;a&quot; &quot;b&quot;]}
              {:w [&quot;c&quot; &quot;d&quot;]}]}
            {:z
             [{:w [&quot;e&quot; &quot;f&quot;]}
              {:w [&quot;g&quot; &quot;h&quot;]}]}]}
          {:y
           [{:z
             [{:w [&quot;A&quot; &quot;B&quot;]}
              {:w [&quot;C&quot; &quot;D&quot;]}]}
            {:z
             [{:w [&quot;E&quot; &quot;F&quot;]}
              {:w [&quot;G&quot; &quot;H&quot;]}]}]}]}]
   :look
   {:a [1 2 3]
    :b [4 5 6]
    :c [7 8 9]
    :H &apos;[x y z]}}
  {:in [{:x [{:y [{:z [{:w [(m/and !s (m/app keyword !k))
                            ..!nk]}
                       ..!nw]}
                  ..!nz]}
             ..!ny]}
        ..!nx]
   :look {!k [!d ...]}}

  [{:x [{:y [{:z [{:w [!s ..!nk]
                   :d [!d ...]}
                  ..!nw]}
             ..!nz]}
        ..!ny]}
   ..!nx]
  )</pre>
</z><z id="t1643295207" t="Ben Sless accumulating the looked-up values doesn&apos;t work right, I&apos;m probably missing something"><y>#</y><d>2022-01-27</d><h>14:53</h><w>Ben Sless</w>accumulating the looked-up values doesn&apos;t work right, I&apos;m probably missing something</z><z id="t1643295502" t="Jimmy Miller (on my phone). Memory variables don&apos;t join like that. You&apos;d want to assign :look to something and do something like (m/app get lookup) Can&apos;t think of the right way right now. But will try to play with it later if I have time at the computer and no one else already solved it."><y>#</y><d>2022-01-27</d><h>14:58</h><w>Jimmy Miller</w>(on my phone). Memory variables don&apos;t join like that. You&apos;d want to assign :look to something and do something like <code>(m/app get lookup)</code> 

Can&apos;t think of the right way right now. But will try to play with it later if I have time at the computer and no one else already solved it.</z><z id="t1643295564" t="Ben Sless No pressure"><y>#</y><d>2022-01-27</d><h>14:59</h><w>Ben Sless</w>No pressure</z><z id="t1643296149" t="Ben Sless Very close now (let [lookup {:a [1 2 3] :b [4 5 6] :c [7 8 9] :H &apos;[x y z]} f (fn [x] (get lookup (keyword x)))] (m/rewrite {:x [{:y [{:z [{:w [&quot;a&quot; &quot;b&quot;]} {:w [&quot;c&quot; &quot;d&quot;]}]} {:z [{:w [&quot;e&quot; &quot;f&quot;]} {:w [&quot;g&quot; &quot;h&quot;]}]}]} {:y [{:z [{:w [&quot;A&quot; &quot;B&quot;]} {:w [&quot;C&quot; &quot;D&quot;]}]} {:z [{:w [&quot;E&quot; &quot;F&quot;]} {:w [&quot;G&quot; &quot;H&quot;]}]}]}]} {:x [!x ...]} {:x [(m/cata !x) ...]} {:y [!x ...]} {:y [(m/cata !x) ...]} {:z [!x ...]} {:z [(m/cata !x) ...]} {:w [(m/and !x (m/app f !d)) ...]} {:w [!x ...] :d [!d ...]})) "><y>#</y><d>2022-01-27</d><h>15:09</h><w>Ben Sless</w>Very close now
<pre>(let [lookup {:a [1 2 3]
              :b [4 5 6]
              :c [7 8 9]
              :H &apos;[x y z]}
      f (fn [x] (get lookup (keyword x)))]
  (m/rewrite
    {:x
     [{:y
       [{:z
         [{:w [&quot;a&quot; &quot;b&quot;]}
          {:w [&quot;c&quot; &quot;d&quot;]}]}
        {:z
         [{:w [&quot;e&quot; &quot;f&quot;]}
          {:w [&quot;g&quot; &quot;h&quot;]}]}]}
      {:y
       [{:z
         [{:w [&quot;A&quot; &quot;B&quot;]}
          {:w [&quot;C&quot; &quot;D&quot;]}]}
        {:z
         [{:w [&quot;E&quot; &quot;F&quot;]}
          {:w [&quot;G&quot; &quot;H&quot;]}]}]}]}

    {:x [!x ...]}
    {:x [(m/cata !x) ...]}

    {:y [!x ...]}
    {:y [(m/cata !x) ...]}

    {:z [!x ...]}
    {:z [(m/cata !x) ...]}

    {:w [(m/and !x (m/app f !d)) ...]}
    {:w [!x ...] :d [!d ...]}))</pre>
</z><z id="t1643296206" t="Ben Sless Now :d is [[1 2 3] [4 5 6]] for a b and [[7 8 9] nil] for c d"><y>#</y><d>2022-01-27</d><h>15:10</h><w>Ben Sless</w>Now <code>:d</code> is <code>[[1 2 3] [4 5 6]]</code> for <code>a</code> <code>b</code> and <code>[[7 8 9] nil]</code> for <code>c d</code></z><z id="t1643296215" t="Ben Sless just need to figure out how to... gather?"><y>#</y><d>2022-01-27</d><h>15:10</h><w>Ben Sless</w>just need to figure out how to... gather?</z><z id="t1643296568" t="Ben Sless Aha! (let [lookup {:a [1 2 3] :b [4 5 6] :c [7 8 9] :H &apos;[x y z]} f (fn [x] (get lookup (keyword x) []))] (m/rewrite {:x [{:y [{:z [{:w [&quot;a&quot; &quot;b&quot;]} {:w [&quot;c&quot; &quot;d&quot;]}]} {:z [{:w [&quot;e&quot; &quot;f&quot;]} {:w [&quot;g&quot; &quot;h&quot;]}]}]} {:y [{:z [{:w [&quot;A&quot; &quot;B&quot;]} {:w [&quot;C&quot; &quot;D&quot;]}]} {:z [{:w [&quot;E&quot; &quot;F&quot;]} {:w [&quot;G&quot; &quot;H&quot;]}]}]}]} {:x [!x ...]} {:x [(m/cata !x) ...]} {:y [!x ...]} {:y [(m/cata !x) ...]} {:z [!x ...]} {:z [(m/cata !x) ...]} {:w [(m/and !x (m/app f [!d ...])) ...]} {:w [!x ...] :d [!d ...]})) "><y>#</y><d>2022-01-27</d><h>15:16</h><w>Ben Sless</w>Aha!
<pre>(let [lookup {:a [1 2 3]
              :b [4 5 6]
              :c [7 8 9]
              :H &apos;[x y z]}
      f (fn [x] (get lookup (keyword x) []))]
  (m/rewrite
    {:x
     [{:y
       [{:z
         [{:w [&quot;a&quot; &quot;b&quot;]}
          {:w [&quot;c&quot; &quot;d&quot;]}]}
        {:z
         [{:w [&quot;e&quot; &quot;f&quot;]}
          {:w [&quot;g&quot; &quot;h&quot;]}]}]}
      {:y
       [{:z
         [{:w [&quot;A&quot; &quot;B&quot;]}
          {:w [&quot;C&quot; &quot;D&quot;]}]}
        {:z
         [{:w [&quot;E&quot; &quot;F&quot;]}
          {:w [&quot;G&quot; &quot;H&quot;]}]}]}]}

    {:x [!x ...]}
    {:x [(m/cata !x) ...]}

    {:y [!x ...]}
    {:y [(m/cata !x) ...]}

    {:z [!x ...]}
    {:z [(m/cata !x) ...]}

    {:w [(m/and !x (m/app f [!d ...])) ...]}
    {:w [!x ...] :d [!d ...]}))</pre>
</z><z id="t1643299853" t="Ben Sless not a fan of this solution though, so if you come up with something better, please share"><y>#</y><d>2022-01-27</d><h>16:10</h><w>Ben Sless</w>not a fan of this solution though, so if you come up with something better, please share</z><z id="t1643300411" t="Richie Not much but it looks like this works (m/rewrite thing {:w [(m/and !x (m/app f [!d ...])) ...]} {:w [!x ...] :d [!d ...]} {(m/and ?k (m/or :x :y :z)) [!x ...]} {?k [(m/cata !x) ...]}) "><y>#</y><d>2022-01-27</d><h>16:20</h><w>Richie</w>Not much but it looks like this works
<pre>(m/rewrite
     thing

     {:w [(m/and !x (m/app f [!d ...])) ...]}
     {:w [!x ...] :d [!d ...]}

     {(m/and ?k (m/or :x :y :z)) [!x ...]}
     {?k [(m/cata !x) ...]})</pre>
</z><z id="t1643300881" t="Ben Sless more concise, less explicit about the shape of the data"><y>#</y><d>2022-01-27</d><h>16:28</h><r>Ben Sless</r>more concise, less explicit about the shape of the data</z><z id="t1643334790" t="Richie [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] Here’s something for inspiration. Hopefully you can take it from here. (require &apos;[juxt.pull.core :refer [pull]]) (pull {:x [{:y [{:z [{:w [&quot;a&quot; &quot;b&quot;]} {:w [&quot;c&quot; &quot;d&quot;]}]} {:z [{:w [&quot;e&quot; &quot;f&quot;]} {:w [&quot;g&quot; &quot;h&quot;]}]}]} {:y [{:z [{:w [&quot;A&quot; &quot;B&quot;]} {:w [&quot;C&quot; &quot;D&quot;]}]} {:z [{:w [&quot;E&quot; &quot;F&quot;]} {:w [&quot;G&quot; &quot;H&quot;]}]}]}]} [{:x [{:y [{:z [:temp]}]}]}] {:shadow {:temp println}}) prints {:w [a b]} {:w [c d]} {:w [e f]} {:w [g h]} {:w [A B]} {:w [C D]} {:w [E F]} {:w [G H]} {:w [a b]} {:w [c d]} {:w [e f]} {:w [g h]} {:w [A B]} {:w [C D]} {:w [E F]} {:w [G H]} and returns {:x [{:y [{:z [{:temp nil} {:temp nil}]} {:z [{:temp nil} {:temp nil}]}]} {:y [{:z [{:temp nil} {:temp nil}]} {:z [{:temp nil} {:temp nil}]}]}]} The problem that I faced is that the api doesn’t let me calculate the new value in place. I’m calculating the value that should fill in that location using the data at that location but it gets inserted unter a new key. i.e. :temp “You can define attributes (values) not exists but calculated by the value of the map, they are shadow attributes:” https://github.com/juxt/pull"><y>#</y><d>2022-01-28</d><h>01:53</h><w>Richie</w><a>@ben.sless</a> Here’s something for inspiration. Hopefully you can take it from here.
<pre>(require &apos;[juxt.pull.core :refer [pull]])
(pull {:x
       [{:y
         [{:z
           [{:w [&quot;a&quot; &quot;b&quot;]}
            {:w [&quot;c&quot; &quot;d&quot;]}]}
          {:z
           [{:w [&quot;e&quot; &quot;f&quot;]}
            {:w [&quot;g&quot; &quot;h&quot;]}]}]}
        {:y
         [{:z
           [{:w [&quot;A&quot; &quot;B&quot;]}
            {:w [&quot;C&quot; &quot;D&quot;]}]}
          {:z
           [{:w [&quot;E&quot; &quot;F&quot;]}
            {:w [&quot;G&quot; &quot;H&quot;]}]}]}]}
      [{:x [{:y [{:z [:temp]}]}]}]
      {:shadow {:temp println}})</pre>
prints
<pre>{:w [a b]}
{:w [c d]}
{:w [e f]}
{:w [g h]}
{:w [A B]}
{:w [C D]}
{:w [E F]}
{:w [G H]}
{:w [a b]}
{:w [c d]}
{:w [e f]}
{:w [g h]}
{:w [A B]}
{:w [C D]}
{:w [E F]}
{:w [G H]}</pre>
and returns
<pre>{:x [{:y
      [{:z [{:temp nil} {:temp nil}]}
       {:z [{:temp nil} {:temp nil}]}]}
     {:y
      [{:z [{:temp nil} {:temp nil}]}
       {:z [{:temp nil} {:temp nil}]}]}]}</pre>
The problem that I faced is that the api doesn’t let me calculate the new value in place. I’m calculating the value that should fill in that location using the data at that location but it gets inserted unter a new key. i.e. <code>:temp</code>
“You can define attributes (values) not exists but calculated by the value of the map, they are shadow attributes:”
<a href="https://github.com/juxt/pull" target="_blank">https://github.com/juxt/pull</a></z><z id="t1643334974" t="Richie I started my journey http://edn-query-language.org/ but I had trouble finding a library that did what I wanted."><y>#</y><d>2022-01-28</d><h>01:56</h><r>Richie</r>I started my journey <a href="http://edn-query-language.org/" target="_blank">http://edn-query-language.org/</a> but I had trouble finding a library that did what I wanted.</z><z id="t1643385079" t="Richie I also tried using m/$ with ?context but the ?context had everything and I didn’t know how to get just the path… I think that was the issue."><y>#</y><d>2022-01-28</d><h>15:51</h><r>Richie</r>I also tried using m/$ with ?context but the ?context had everything and I didn’t know how to get just the path… I think that was the issue.</z><z id="t1643385848" t="Ben Sless I figured out both solutions eventually but the grouping had to be cut explicitly because star is greedy"><y>#</y><d>2022-01-28</d><h>16:04</h><r>Ben Sless</r>I figured out both solutions eventually but the grouping had to be cut explicitly because star is greedy</z><z id="t1643385855" t="Ben Sless Turned out pretty ugly"><y>#</y><d>2022-01-28</d><h>16:04</h><r>Ben Sless</r>Turned out pretty ugly</z><z id="t1643385980" t="Richie I don’t think I understand. Are you talking about the solution with ..n! because … is greedy?"><y>#</y><d>2022-01-28</d><h>16:06</h><r>Richie</r>I don’t think I understand. Are you talking about the solution with ..n! because … is greedy?</z><z id="t1643386026" t="Richie Eh, interesting problem anyway. Lmk if you find anything elegant."><y>#</y><d>2022-01-28</d><h>16:07</h><r>Richie</r>Eh, interesting problem anyway. Lmk if you find anything elegant.</z><z id="t1643399064" t="noprompt I&apos;ve mentioned it before but, yeah, ... is broken on the RHS because it is greedy. It should be frugal as it is on the LHS. This will be &quot;fixed&quot; in the distant future."><y>#</y><d>2022-01-28</d><h>19:44</h><r>noprompt</r>I&apos;ve mentioned it before but, yeah, <code>...</code> is broken on the RHS because it is greedy. It should be frugal as it is on the LHS. This will be &quot;fixed&quot; in the distant future.</z><z id="t1643399155" t="noprompt In general, what is on epsilon and prior is, IMO, &quot;wrong&quot; since it does not have distinct operators for greediness/frugalness e.g. * and *? etc."><y>#</y><d>2022-01-28</d><h>19:45</h><r>noprompt</r>In general, what is on epsilon and prior is, IMO, &quot;wrong&quot; since it does not have distinct operators for greediness/frugalness e.g. <code>*</code> and <code>*?</code> etc.</z><z id="t1643399303" t="noprompt The zeta branch does make the distinction and there are tests that demonstrate how it works. The zeta branch was never able to get off the ground though because I had some struggles with the compiler and organization."><y>#</y><d>2022-01-28</d><h>19:48</h><r>noprompt</r>The <code>zeta</code> branch does make the distinction and there are tests that demonstrate how it works. The <code>zeta</code> branch was never able to get off the ground though because I had some struggles with the compiler and organization.</z><z id="t1643399333" t="noprompt Hopefully Ben and I can make something happen before too long. 🙂"><y>#</y><d>2022-01-28</d><h>19:48</h><r>noprompt</r>Hopefully Ben and I can make something happen before too long. <b>🙂</b></z><z id="t1643399476" t="Richie Please let me know if you make tickets or have a meetup. I’m content atm trying to learn what’s already there but I don’t want to miss out if you start moving forward with zeta development."><y>#</y><d>2022-01-28</d><h>19:51</h><r>Richie</r>Please let me know if you make tickets or have a meetup. I’m content atm trying to learn what’s already there but I don’t want to miss out if you start moving forward with zeta development.</z><z id="t1643399546" t="Richie I’m trying to learn how to make webapps with reagent. I’ve been learning datascript and reading about graph databases…"><y>#</y><d>2022-01-28</d><h>19:52</h><r>Richie</r>I’m trying to learn how to make webapps with reagent. I’ve been learning datascript and reading about graph databases…</z><z id="t1643399559" t="noprompt Hmm... I wonder if we could make a recurring meeting or something."><y>#</y><d>2022-01-28</d><h>19:52</h><r>noprompt</r>Hmm... I wonder if we could make a recurring meeting or something.</z><z id="t1643399603" t="noprompt Cool, cool. All good stuff to learn. 🙂"><y>#</y><d>2022-01-28</d><h>19:53</h><r>noprompt</r>Cool, cool. All good stuff to learn. <b>🙂</b></z><z id="t1643399901" t="noprompt As a proud heretic in this &quot;community&quot; I&apos;d also recommend learning how type inference works and a bit about type theory at some point in your journey."><y>#</y><d>2022-01-28</d><h>19:58</h><r>noprompt</r>As a proud heretic in this &quot;community&quot; I&apos;d also recommend learning how type inference works and a bit about type theory at some point in your journey.</z><z id="t1643399914" t="Richie I came from Scala."><y>#</y><d>2022-01-28</d><h>19:58</h><r>Richie</r>I came from Scala.</z><z id="t1643399920" t="noprompt Ah, cool. 🙂"><y>#</y><d>2022-01-28</d><h>19:58</h><r>noprompt</r>Ah, cool. <b>🙂</b></z><z id="t1643399931" t="noprompt I come from everywhere. 🙂"><y>#</y><d>2022-01-28</d><h>19:58</h><r>noprompt</r>I come from everywhere. <b>🙂</b></z><z id="t1643399948" t="Richie I was eyeing haskell for a while."><y>#</y><d>2022-01-28</d><h>19:59</h><r>Richie</r>I was eyeing haskell for a while.</z><z id="t1643399968" t="noprompt Too many good ideas out there to be a &quot;$language programmer&quot;."><y>#</y><d>2022-01-28</d><h>19:59</h><r>noprompt</r>Too many good ideas out there to be a &quot;$language programmer&quot;.</z><z id="t1643400003" t="noprompt TBH I&apos;d use Haskell more if it weren&apos;t for the whitespace sensitive syntax and lame non-whitespace sensitive syntax."><y>#</y><d>2022-01-28</d><h>20:00</h><r>noprompt</r>TBH I&apos;d use Haskell more if it weren&apos;t for the whitespace sensitive syntax and lame non-whitespace sensitive syntax.</z><z id="t1643400044" t="noprompt I actually used Haskell to inform how zeta and beyond should work. The combination of data and class helped guide me a lot. I can&apos;t understate that."><y>#</y><d>2022-01-28</d><h>20:00</h><r>noprompt</r>I actually used Haskell to inform how <code>zeta</code> and beyond should work. The combination of <code>data</code> and <code>class</code> helped guide me a lot. I can&apos;t understate that.</z><z id="t1643400087" t="Richie I implied I know about type inference works but I don’t really. Category Theory for Programmers and Seven Sketches in Compositionality have been on my reading list for too long. I’ve not made much progress."><y>#</y><d>2022-01-28</d><h>20:01</h><r>Richie</r>I implied I know about type inference works but I don’t really. Category Theory for Programmers and Seven Sketches in Compositionality have been on my reading list for too long. I’ve not made much progress.</z><z id="t1643400153" t="noprompt There&apos;s a paper out there by SPJ that teaches how to make a mini version of the HM style type checker in Haskell with code examples. I can&apos;t remember the title but was very helpful."><y>#</y><d>2022-01-28</d><h>20:02</h><r>noprompt</r>There&apos;s a paper out there by SPJ that teaches how to make a mini version of the HM style type checker in Haskell with code examples. I can&apos;t remember the title but was very helpful.</z><z id="t1643400188" t="noprompt I think CT is interesting but I&apos;ve gotten more out of AA (Abstract Algebra) and ST (Set Theory) than CT."><y>#</y><d>2022-01-28</d><h>20:03</h><r>noprompt</r>I think CT is interesting but I&apos;ve gotten more out of AA (Abstract Algebra) and ST (Set Theory) than CT.</z><z id="t1643400201" t="Richie I am now obsessed with https://github.com/abo-abo/lispy style editing and I don’t know how I’d get it without parenthesis."><y>#</y><d>2022-01-28</d><h>20:03</h><r>Richie</r>I am now obsessed with <a href="https://github.com/abo-abo/lispy" target="_blank">https://github.com/abo-abo/lispy</a> style editing and I don’t know how I’d get it without parenthesis.</z><z id="t1643400225" t="noprompt The cool thing about learning CT, AA, and ST is that many ideas are portable across languages."><y>#</y><d>2022-01-28</d><h>20:03</h><r>noprompt</r>The cool thing about learning CT, AA, and ST is that many ideas are portable across languages.</z><z id="t1643400232" t="noprompt Monoid always comes to mind."><y>#</y><d>2022-01-28</d><h>20:03</h><r>noprompt</r>Monoid always comes to mind.</z><z id="t1643400240" t="noprompt Because, you know, they&apos;re everywhere."><y>#</y><d>2022-01-28</d><h>20:04</h><r>noprompt</r>Because, you know, they&apos;re everywhere.</z><z id="t1643400368" t="Richie Yea. I’ll recognize that “I’m sequencing” and realize I have a monad. I appreciate having a language for it."><y>#</y><d>2022-01-28</d><h>20:06</h><r>Richie</r>Yea. I’ll recognize that “I’m sequencing” and realize I have a monad. I appreciate having a language for it.</z><z id="t1643400451" t="Richie I know what spj and ct are short for but I can’t think what aa or st mean."><y>#</y><d>2022-01-28</d><h>20:07</h><r>Richie</r>I know what spj and ct are short for but I can’t think what aa or st mean.</z><z id="t1643400474" t="noprompt I also love things like Monoid means &quot;I can divided and conquer&quot;."><y>#</y><d>2022-01-28</d><h>20:07</h><r>noprompt</r>I also love things like Monoid means &quot;I can divided and conquer&quot;.</z><z id="t1643400499" t="noprompt &gt; AA (Abstract Algebra) and ST (Set Theory)"><y>#</y><d>2022-01-28</d><h>20:08</h><r>noprompt</r>&gt;  AA (Abstract Algebra) and ST (Set Theory)</z><z id="t1643400505" t="Richie Ah."><y>#</y><d>2022-01-28</d><h>20:08</h><r>Richie</r>Ah.</z><z id="t1643400566" t="noprompt My brain might just be biased to those since I learned them first and pick up some CT stuff later"><y>#</y><d>2022-01-28</d><h>20:09</h><r>noprompt</r>My brain might just be biased to those since I learned them first and pick up some CT stuff later</z><z id="t1643403754" t="Ben Sless A nice and concise example is someone wrote a HM inferencer over malli schemas"><y>#</y><d>2022-01-28</d><h>21:02</h><r>Ben Sless</r>A nice and concise example is someone wrote a HM inferencer over malli schemas</z><z id="t1643403797" t="Ben Sless Are you a heretic? Is meander a pattern matching library? 😉"><y>#</y><d>2022-01-28</d><h>21:03</h><r>Ben Sless</r>Are you a heretic? Is meander a pattern matching library? <b>😉</b></z><z id="t1643407866" t="noprompt Hehehe, I don&apos;t think I am a heretic. 😄 I subscribe to ideas that I think are good, like type inference, pattern matching, etc."><y>#</y><d>2022-01-28</d><h>22:11</h><r>noprompt</r>Hehehe, I don&apos;t think I am a heretic. <b>😄</b> I subscribe to ideas that I think are good, like type inference, pattern matching, etc.</z><z id="t1643435615" t="Ben Sless Type inference is cool, programming with types maybe less so, i.e. I want to know when I messed up with types but let me keep my open dynamic collections. Clj kondo just added map key type inference which is exciting and useful. Wrt pattern matching I can see where it falls apart (expression problem), can still be a very useful and powerful tool"><y>#</y><d>2022-01-29</d><h>05:53</h><r>Ben Sless</r>Type inference is cool, programming with types maybe less so, i.e. I want to know when I messed up with types but let me keep my open dynamic collections. Clj kondo just added map key type inference which is exciting and useful.
Wrt pattern matching I can see where it falls apart (expression problem), can still be a very useful and powerful tool</z><z id="t1643651669" t="noprompt My take on this is, of course, logic. I think types are awesome, I think dynamic typing is awesome, and I think there is a middle ground that says you can have the best of both worlds. I think that middle ground is terms, rules, patterns. I think it is possible to write programs which are type safe but &quot;feel&quot; dynamic. IMO the expression problem exists when types and functions are coupled to each other such that there is a behavior associated with misapplication e.g. type error at compile time/run time. I think rewrite rules are much better here because they aren&apos;t &quot;applied to&quot;, &quot;called on&quot;, or &quot;sent messages to&quot;. The work strictly with data and only &quot;fire&quot; when the left recognizes the input. There&apos;s no need to blow up, like, at all."><y>#</y><d>2022-01-31</d><h>17:54</h><r>noprompt</r>My take on this is, of course, logic. I think types are awesome, I think dynamic typing is awesome, and I think there is a middle ground that says you can have the best of both worlds. I think that middle ground is terms, rules, patterns. I think it is possible to write programs which are type safe but &quot;feel&quot; dynamic.

IMO the expression problem exists when types and functions are coupled to each other such that there is a behavior associated with misapplication e.g. type error at compile time/run time. I think rewrite rules are much better here because they aren&apos;t &quot;applied to&quot;, &quot;called on&quot;, or &quot;sent messages to&quot;. The work strictly with data and only &quot;fire&quot; when the left recognizes the input. There&apos;s no need to blow up, like, at all.</z><z id="t1643670464" t="lvh https://clojurians.slack.com/archives/C03S1KBA2/p1632095585187800 -- this seems like a problem meander may be able to solve, but I could&apos;ve sworn I had seen an equation solver before using meander. FWIW: this is really expresso being too clever for its own good, I don&apos;t even think I need to rewrite any equations, it should be able to get where it needs to with strictly constraint propagation. if no-one has this off the shelf I&apos;ll just quickly write one; this feels like a simple call to rewrite?"><y>#</y><d>2022-01-31</d><h>23:07</h><w>lvh</w><a href="https://clojurians.slack.com/archives/C03S1KBA2/p1632095585187800" target="_blank">https://clojurians.slack.com/archives/C03S1KBA2/p1632095585187800</a> -- this seems like a problem meander may be able to solve, but I could&apos;ve sworn I had seen an equation solver before using meander. FWIW: this is really expresso being too clever for its own good, I don&apos;t even think I need to rewrite any equations, it should be able to get where it needs to with strictly constraint propagation. if no-one has this off the shelf I&apos;ll just quickly write one; this feels like a simple call to rewrite?</z><z id="t1643723270" t="Richie Sorry, I haven’t taken the time to understand your code but when you mentioned that you had seen an equation solver before using meander I thought of https://github.com/noprompt/meander/blob/epsilon/doc/strategies.md#rewrite . Idk if you mean in the docs or elsewhere."><y>#</y><d>2022-02-01</d><h>13:47</h><r>Richie</r>Sorry, I haven’t taken the time to understand your code but when you mentioned that you had seen an equation solver before using meander I thought of <a href="https://github.com/noprompt/meander/blob/epsilon/doc/strategies.md#rewrite" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/strategies.md#rewrite</a>. Idk if you mean in the docs or elsewhere.</z><z id="t1643723093" t="Richie Hey, I’m trying to make the first example work. It doesn’t match when I think it should. (do (m/defsyntax content [a] `{:content (_ ~a _)}) (m/rewrite &apos;{:content (no yes no2)} (content ?body) ?body)) ;; nil (do (m/defsyntax content [a] `{:content (m/app second ~a)}) (m/rewrite &apos;{:content (no yes no2)} (content ?body) ?body)) ;; yes (do (m/defsyntax content [a] `{:content (m/app type ~a)}) (m/rewrite &apos;{:content (no yes no2)} (content ?body) ?body)) ;; clojure.lang.PersistentList Thanks!"><y>#</y><d>2022-02-01</d><h>13:44</h><w>Richie</w>Hey, I’m trying to make the first example work. It doesn’t match when I think it should.
<pre>(do
  (m/defsyntax content
    [a]
    `{:content (_ ~a _)})

  (m/rewrite &apos;{:content (no yes no2)}
    (content ?body) ?body))
;; nil

(do
  (m/defsyntax content
    [a]
    `{:content (m/app second ~a)})

  (m/rewrite &apos;{:content (no yes no2)}
    (content ?body) ?body))
;; yes

(do
  (m/defsyntax content
    [a]
    `{:content (m/app type ~a)})

  (m/rewrite &apos;{:content (no yes no2)}
    (content ?body) ?body))
;; clojure.lang.PersistentList</pre>
Thanks!</z><z id="t1643723449" t="Richie I can do this though: (m/defsyntax content [a] `{:content (m/app #(map second (partition 2 2 %)) ~a)}) (m/rewrite &apos;{:content (no yes no2)} (content (?body)) ?body) ;; yes "><y>#</y><d>2022-02-01</d><h>13:50</h><r>Richie</r>I can do this though:
<pre>(m/defsyntax content
  [a]
  `{:content (m/app #(map second (partition 2 2 %)) ~a)})

(m/rewrite &apos;{:content (no yes no2)}
  (content (?body)) ?body)
;; yes</pre>
</z><z id="t1643732497" t="Richie (m/rewrite &apos;{:content (no1 yes no2 yes2 no3)} {:content (m/seqable _ ?a _ ?b _)} (?a ?b)) expands to (let [R__28517 (let [TARGET__28511 &apos;{:content (no1 yes no2 yes2 no3)}] (let [T__28512 (.valAt TARGET__28511 :content)] (if (seqable? T__28512) (let [SEQ__28514 (seq T__28512)] (if (= (bounded-count 6 SEQ__28514) 5) (let [SEQ__28514_nth_1__ (nth SEQ__28514 1) SEQ__28514_nth_3__ (nth SEQ__28514 3)] (let [?a SEQ__28514_nth_1__] (let [?b SEQ__28514_nth_3__] (list ?a ?b)))) meander.match.runtime.epsilon/FAIL)) meander.match.runtime.epsilon/FAIL)))] (if (meander.match.runtime.epsilon/fail? R__28517) nil R__28517)) while (m/rewrite &apos;{:content (no1 yes no2 yes2 no3)} (content ?t1 ?t2) (?t1 ?t2)) expands to (let [R__28556 (let [TARGET__28550 &apos;{:content (no1 yes no2 yes2 no3)}] (let [T__28551 (.valAt TARGET__28550 :content)] (if (seqable? T__28551) (let [SEQ__28553 (seq T__28551)] (if (= (bounded-count 6 SEQ__28553) 5) (let [SEQ__28553_nth_0__ (nth SEQ__28553 0) SEQ__28553_nth_1__ (nth SEQ__28553 1) SEQ__28553_nth_2__ (nth SEQ__28553 2) SEQ__28553_nth_3__ (nth SEQ__28553 3) SEQ__28553_nth_4__ (nth SEQ__28553 4)] (case SEQ__28553_nth_0__ (_) (case SEQ__28553_nth_2__ (_) (case SEQ__28553_nth_4__ (_) (let [?t1 SEQ__28553_nth_1__] (let [?t2 SEQ__28553_nth_3__] (list ?t1 ?t2))) meander.match.runtime.epsilon/FAIL) meander.match.runtime.epsilon/FAIL) meander.match.runtime.epsilon/FAIL)) meander.match.runtime.epsilon/FAIL)) meander.match.runtime.epsilon/FAIL)))] (if (meander.match.runtime.epsilon/fail? R__28556) nil R__28556))"><y>#</y><d>2022-02-01</d><h>16:21</h><r>Richie</r><pre>(m/rewrite &apos;{:content (no1 yes no2 yes2 no3)}
  {:content (m/seqable _ ?a _ ?b _)} (?a ?b))</pre>
expands to
<pre>(let [R__28517 (let [TARGET__28511 &apos;{:content (no1 yes no2 yes2 no3)}]
                 (let [T__28512 (.valAt TARGET__28511 :content)]
                   (if (seqable? T__28512)
                     (let [SEQ__28514 (seq T__28512)]
                       (if (= (bounded-count 6 SEQ__28514) 5)
                         (let [SEQ__28514_nth_1__ (nth SEQ__28514 1)
                               SEQ__28514_nth_3__ (nth SEQ__28514 3)]
                           (let [?a SEQ__28514_nth_1__]
                             (let [?b SEQ__28514_nth_3__]
                               (list ?a ?b))))
                         meander.match.runtime.epsilon/FAIL))
                     meander.match.runtime.epsilon/FAIL)))]
  (if (meander.match.runtime.epsilon/fail? R__28517) nil R__28517))</pre>
while
<pre>(m/rewrite &apos;{:content (no1 yes no2 yes2 no3)}
  (content ?t1 ?t2) (?t1 ?t2))</pre>
expands to
<pre>(let [R__28556 (let [TARGET__28550 &apos;{:content (no1 yes no2 yes2 no3)}]
                 (let [T__28551 (.valAt TARGET__28550 :content)]
                   (if (seqable? T__28551)
                     (let [SEQ__28553 (seq T__28551)]
                       (if (= (bounded-count 6 SEQ__28553) 5)
                         (let [SEQ__28553_nth_0__ (nth SEQ__28553 0)
                               SEQ__28553_nth_1__ (nth SEQ__28553 1)
                               SEQ__28553_nth_2__ (nth SEQ__28553 2)
                               SEQ__28553_nth_3__ (nth SEQ__28553 3)
                               SEQ__28553_nth_4__ (nth SEQ__28553 4)]
                           (case
                             SEQ__28553_nth_0__
                             (_)
                             (case
                               SEQ__28553_nth_2__
                               (_)
                               (case
                                 SEQ__28553_nth_4__
                                 (_)
                                 (let 
                                   [?t1 SEQ__28553_nth_1__]
                                   (let 
                                     [?t2 SEQ__28553_nth_3__]
                                     (list ?t1 ?t2)))
                                 meander.match.runtime.epsilon/FAIL)
                               meander.match.runtime.epsilon/FAIL)
                             meander.match.runtime.epsilon/FAIL))
                         meander.match.runtime.epsilon/FAIL))
                     meander.match.runtime.epsilon/FAIL)))]
  (if (meander.match.runtime.epsilon/fail? R__28556) nil R__28556))</pre></z><z id="t1643732544" t="Richie where (m/defsyntax content ([a] `(m/or {:content (m/seqable ~a)} {:content (m/seqable _ ~a _)})) ([a b] `{:content (m/seqable _ ~a _ ~b _)})) "><y>#</y><d>2022-02-01</d><h>16:22</h><r>Richie</r>where
<pre>(m/defsyntax content
  ([a]
   `(m/or {:content (m/seqable ~a)}
          {:content (m/seqable _ ~a _)}))
  ([a b]
   `{:content (m/seqable _ ~a _ ~b _)}))</pre>
</z><z id="t1643732760" t="Richie What’s with (case SEQ__28553_nth_0__ (_) That’s checking if it’s uhh… a list of one thing?"><y>#</y><d>2022-02-01</d><h>16:26</h><r>Richie</r>What’s with
<pre>(case
    SEQ__28553_nth_0__
    (_)</pre>
That’s checking if it’s uhh… a list of one thing?</z><z id="t1643732989" t="Richie I just want it to generate code like (let [R__28556 (let [TARGET__28550 &apos;{:content (no1 yes no2 yes2 no3)}] (let [T__28551 (.valAt TARGET__28550 :content)] (if (seqable? T__28551) (let [SEQ__28553 (seq T__28551)] (if (= (bounded-count 6 SEQ__28553) 5) (let [SEQ__28553_nth_0__ (nth SEQ__28553 0) SEQ__28553_nth_1__ (nth SEQ__28553 1) SEQ__28553_nth_2__ (nth SEQ__28553 2) SEQ__28553_nth_3__ (nth SEQ__28553 3) SEQ__28553_nth_4__ (nth SEQ__28553 4)] (let [?t1 SEQ__28553_nth_1__] (let [?t2 SEQ__28553_nth_3__] (list ?t1 ?t2)))) meander.match.runtime.epsilon/FAIL)) meander.match.runtime.epsilon/FAIL)))] (if (meander.match.runtime.epsilon/fail? R__28556) nil R__28556)) "><y>#</y><d>2022-02-01</d><h>16:29</h><r>Richie</r>I just want it to generate code like
<pre>(let [R__28556 (let [TARGET__28550 &apos;{:content (no1 yes no2 yes2 no3)}]
                 (let [T__28551 (.valAt TARGET__28550 :content)]
                   (if (seqable? T__28551)
                     (let [SEQ__28553 (seq T__28551)]
                       (if (= (bounded-count 6 SEQ__28553) 5)
                         (let [SEQ__28553_nth_0__ (nth SEQ__28553 0)
                               SEQ__28553_nth_1__ (nth SEQ__28553 1)
                               SEQ__28553_nth_2__ (nth SEQ__28553 2)
                               SEQ__28553_nth_3__ (nth SEQ__28553 3)
                               SEQ__28553_nth_4__ (nth SEQ__28553 4)]
                           (let 
                               [?t1 SEQ__28553_nth_1__]
                               (let 
                                   [?t2 SEQ__28553_nth_3__]
                                   (list ?t1 ?t2))))
                         meander.match.runtime.epsilon/FAIL))
                     meander.match.runtime.epsilon/FAIL)))]
  (if (meander.match.runtime.epsilon/fail? R__28556) nil R__28556))</pre>
</z><z id="t1643732995" t="Richie that works…"><y>#</y><d>2022-02-01</d><h>16:29</h><r>Richie</r>that works…</z><z id="t1643738431" t="noprompt &gt; That’s checking if it’s uhh… a list of one thing? No, case allows you to group a bunch of cases together with a list: (let [f (fn [x] (case x (:a :b :c) &quot;A&quot; ;; else &quot;B&quot;))] [(f :a) (f :b) (f :c) (f :d)]) ;; =&gt; [&quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot;] "><y>#</y><d>2022-02-01</d><h>18:00</h><r>noprompt</r>&gt;  That’s checking if it’s uhh… a list of one thing?
No, <code>case</code> allows you to group a bunch of cases together with a list:
<pre>(let [f (fn [x]
          (case x
            (:a :b :c) &quot;A&quot;
            ;; else
            &quot;B&quot;))]
  [(f :a)
   (f :b)
   (f :c)
   (f :d)])
;; =&gt;
[&quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot;]</pre>
</z><z id="t1643730763" t="Richie Also, I expect the first two to return (yes yes2) and (yes) but I just get nil . What’s wrong here? (m/defsyntax content ([a] `(m/or (~a) (_ ~a _))) ([a b] `(_ ~a _ ~b _))) (m/rewrite &apos;(no1 yes no2 yes2 no3) (content ?t1 ?t2) (?t1 ?t2)) ;; nil (m/rewrite &apos;(no1 yes no2) (content ?t1) ?t1) ;; nil (m/rewrite &apos;(yes) (content ?t1) ?t1) ;; yes Thanks again!"><y>#</y><d>2022-02-01</d><h>15:52</h><w>Richie</w>Also, I expect the first two to return <code>(yes yes2)</code> and <code>(yes)</code> but I just get <code>nil</code>. What’s wrong here?
<pre>(m/defsyntax content
  ([a]
   `(m/or (~a)
          (_ ~a _)))
  ([a b]
   `(_ ~a _ ~b _)))

(m/rewrite &apos;(no1 yes no2 yes2 no3)
  (content ?t1 ?t2) (?t1 ?t2))
;; nil
(m/rewrite &apos;(no1 yes no2)
  (content ?t1) ?t1)
;; nil
(m/rewrite &apos;(yes)
  (content ?t1) ?t1)
;; yes</pre>
Thanks again!</z><z id="t1643731093" t="Richie Of course this works: (m/rewrite &apos;(no1 yes no2 yes2 no3) (m/seqable _ ?t1 _ ?t2 _) (?t1 ?t2)) Doesn’t help me though."><y>#</y><d>2022-02-01</d><h>15:58</h><r>Richie</r>Of course this works:
<pre>(m/rewrite &apos;(no1 yes no2 yes2 no3)
  (m/seqable _ ?t1 _ ?t2 _) (?t1 ?t2))</pre>
Doesn’t help me though.</z><z id="t1643738022" t="noprompt I’ll try and take a look at this today. I’ve been busy with work stuff."><y>#</y><d>2022-02-01</d><h>17:53</h><w>noprompt</w>I’ll try and take a look at this today. I’ve been busy with work stuff.</z><z id="t1643738115" t="noprompt Actually, I have a few minutes now…"><y>#</y><d>2022-02-01</d><h>17:55</h><w>noprompt</w>Actually, I have a few minutes now…</z><z id="t1643738224" t="noprompt (m/defsyntax content [a] `{:content (_# ~a _#)}) "><y>#</y><d>2022-02-01</d><h>17:57</h><w>noprompt</w><pre>(m/defsyntax content
  [a]
  `{:content (_# ~a _#)})</pre>
</z><z id="t1643738259" t="noprompt (m/rewrite &apos;{:content (no yes no2)} (content ?body) ?body) ;; =&gt; yes "><y>#</y><d>2022-02-01</d><h>17:57</h><w>noprompt</w><pre>(m/rewrite &apos;{:content (no yes no2)}
  (content ?body) ?body)
;; =&gt;
yes</pre>
</z><z id="t1643738270" t="noprompt [:attrs {:href &quot;/_/_/users/UPD88PGNT&quot;}] You need to _# 🙂"><y>#</y><d>2022-02-01</d><h>17:57</h><w>noprompt</w><a>@rgkirch</a> You need to <code>_#</code> <b>🙂</b></z><z id="t1643738345" t="Richie What is that?"><y>#</y><d>2022-02-01</d><h>17:59</h><r>Richie</r>What is that?</z><z id="t1643738439" t="Richie Ah, it’s in the readme…"><y>#</y><d>2022-02-01</d><h>18:00</h><r>Richie</r>Ah, it’s in the readme…</z><z id="t1643738505" t="noprompt Don’t worry, one day, when the next version is available, maybe this year, we’ll be using rewrite rules to define this kinda thing instead of this macro style thing."><y>#</y><d>2022-02-01</d><h>18:01</h><r>noprompt</r>Don’t worry, one day, when the next version is available, maybe this year, we’ll be using rewrite rules to define this kinda thing instead of this macro style thing.</z><z id="t1643738634" t="Richie I was going to ask when else I might need it but it’s only used with _# or like %set# in subset-of so I’ll probably never need it outside of _ in defsyntax."><y>#</y><d>2022-02-01</d><h>18:03</h><r>Richie</r>I was going to ask when else I might need it but it’s only used with <code>_#</code> or like <code>%set#</code> in <code>subset-of</code>  so I’ll probably never need it outside of _ in defsyntax.</z><z id="t1643738646" t="Richie I’m looking forward to that day. I think. I don’t really know what you mean."><y>#</y><d>2022-02-01</d><h>18:04</h><r>Richie</r>I’m looking forward to that day. I think. I don’t really know what you mean.</z><z id="t1643738672" t="Richie I did just notice https://github.com/noprompt/meander/discussions/225 yesterday. Haven’t looked at it yet though."><y>#</y><d>2022-02-01</d><h>18:04</h><r>Richie</r>I did just notice <a href="https://github.com/noprompt/meander/discussions/225" target="_blank">https://github.com/noprompt/meander/discussions/225</a> yesterday. Haven’t looked at it yet though.</z><z id="t1643738699" t="noprompt Yes, I’m incrementally working on this."><y>#</y><d>2022-02-01</d><h>18:04</h><r>noprompt</r>Yes, I’m incrementally working on this.</z><z id="t1643738714" t="Richie Also, thank you!"><y>#</y><d>2022-02-01</d><h>18:05</h><r>Richie</r>Also, thank you!</z><z id="t1643738731" t="noprompt I did a bunch of work and thinking “offline” and now I’m gradually jotting down those thoughts."><y>#</y><d>2022-02-01</d><h>18:05</h><r>noprompt</r>I did a bunch of work and thinking “offline” and now I’m gradually jotting down those thoughts.</z><z id="t1643738785" t="noprompt defsyntax will be replaced by defoperator which uses familiar rewrite rules instead of Clojure style syntax quote, etc (defoperator boolean (_) (`some true false) (_ &amp; ?rest) (`each (`boolean) &amp; ?rest)) "><y>#</y><d>2022-02-01</d><h>18:06</h><r>noprompt</r><code>defsyntax</code> will be replaced by <code>defoperator</code> which uses familiar rewrite rules instead of Clojure style syntax quote, etc
<pre>(defoperator boolean
  (_) (`some true false)
  (_ &amp; ?rest) (`each (`boolean) &amp; ?rest))</pre>
</z><z id="t1643738854" t="noprompt This looks more like Scheme syntax rules."><y>#</y><d>2022-02-01</d><h>18:07</h><r>noprompt</r>This looks more like Scheme syntax rules.</z><z id="t1643738934" t="noprompt That thread will mostly be for explaining the primitive terms of the pattern language and its interpretation."><y>#</y><d>2022-02-01</d><h>18:08</h><r>noprompt</r>That thread will mostly be for explaining the primitive terms of the pattern language and its interpretation.</z><z id="t1643739131" t="Richie Interesting…"><y>#</y><d>2022-02-01</d><h>18:12</h><r>Richie</r>Interesting…</z><z id="t1643739164" t="Richie I’m not familiar with scheme syntax rules."><y>#</y><d>2022-02-01</d><h>18:12</h><r>Richie</r>I’m not familiar with scheme syntax rules.</z><z id="t1643739567" t="noprompt The main reason I’m writing this stuff down is because, at the moment, in my personal life, I’m taking a break from working on Meander and I want to get more people involved such that I don’t get burned out to the point the project dies."><y>#</y><d>2022-02-01</d><h>18:19</h><r>noprompt</r>The main reason I’m writing this stuff down is because, at the moment, in my personal life, I’m taking a break from working on Meander and I want to get more people involved such that I don’t get burned out to the point the project dies.</z><z id="t1643739739" t="Richie I’d rather you document it so that I can follow along and support it than have you work on it alone. You’re the idea factory, haha."><y>#</y><d>2022-02-01</d><h>18:22</h><r>Richie</r>I’d rather you document it so that I can follow along and support it than have you work on it alone. You’re the idea factory, haha.</z><z id="t1643739883" t="noprompt Ah, thanks. Actually, a lot of these ideas I’ve borrowed. 🙂 Shoulders of giants and all that."><y>#</y><d>2022-02-01</d><h>18:24</h><r>noprompt</r>Ah, thanks. Actually, a lot of these ideas I’ve borrowed. <b>🙂</b> Shoulders of giants and all that.</z><z id="t1643740266" t="Richie Oh, and I should mention if I haven’t already. I do want to get involved. I’m still learning epsilon and planning to contribute to the docs sometime."><y>#</y><d>2022-02-01</d><h>18:31</h><r>Richie</r>Oh, and I should mention if I haven’t already. I do want to get involved. I’m still learning epsilon and planning to contribute to the docs sometime.</z><z id="t1643753426" t="noprompt Awesome. I think I’m going to set up a meeting maybe once or twice a month or just find time to meet with people who want to contribute as needed."><y>#</y><d>2022-02-01</d><h>22:10</h><r>noprompt</r>Awesome. I think I’m going to set up a meeting maybe once or twice a month or just find time to meet with people who want to contribute as needed.</z><z id="t1643753452" t="Richie That sounds exciting!"><y>#</y><d>2022-02-01</d><h>22:10</h><r>Richie</r>That sounds exciting!</z><z id="t1644004425" t="Richie Ah, auto gensym. Ok."><y>#</y><d>2022-02-04</d><h>19:53</h><r>Richie</r>Ah, auto gensym. Ok.</z><z id="t1643772750" t="lvh is there a way I can use rewrite to fill in constants in systems of equations, or does that require a match + rewrite combo? I&apos;m looking for a rewrite rule that takes me from a structure like [(= x 5) (= y (+ x 5))] to [(= x 5) (= y (+ 5 5))] "><y>#</y><d>2022-02-02</d><h>03:32</h><w>lvh</w>is there a way I can use rewrite to fill in constants in systems of equations, or does that require a match + rewrite combo?
I&apos;m looking for a rewrite rule that takes me from a structure like
<pre>[(= x 5)
 (= y (+ x 5))]</pre>
to
<pre>[(= x 5)
 (= y (+ 5 5))]</pre>
</z><z id="t1643820566" t="noprompt There&apos;s no official support for math but its something I&apos;ve been meaning to add for a long time because for at least addition, subtraction, and multiplication its kinda straightforward."><y>#</y><d>2022-02-02</d><h>16:49</h><w>noprompt</w>There&apos;s no official support for math but its something I&apos;ve been meaning to add for a long time because for at least addition, subtraction, and multiplication its kinda straightforward.</z><z id="t1643820634" t="noprompt Addition at least with whole numbers just involves partitioning the target number and lining those up with the arguments. If one of the arguments is ground/solved then its even less work."><y>#</y><d>2022-02-02</d><h>16:50</h><w>noprompt</w>Addition at least with whole numbers just involves partitioning the target number and lining those up with the arguments. If one of the arguments is ground/solved then its even less work.</z><z id="t1643820682" t="noprompt But maybe this isn&apos;t what you&apos;re looking for?"><y>#</y><d>2022-02-02</d><h>16:51</h><w>noprompt</w>But maybe this isn&apos;t what you&apos;re looking for?</z><z id="t1643820698" t="noprompt Can you put the example in input/output terms?"><y>#</y><d>2022-02-02</d><h>16:51</h><w>noprompt</w>Can you put the example in input/output terms?</z><z id="t1643897174" t="lvh I’ve done some integer/“lining up” work as you mention with core.logic: https://www.lvh.io/posts/solving-regex-crosswords/ — but I don’t think that’s what I’m looking for here; I’m expecting, largely, everything to be ground and monotonically solvable."><y>#</y><d>2022-02-03</d><h>14:06</h><w>lvh</w>I’ve done some integer/“lining up” work as you mention with core.logic: <a href="https://www.lvh.io/posts/solving-regex-crosswords/" target="_blank">https://www.lvh.io/posts/solving-regex-crosswords/</a> — but I don’t think that’s what I’m looking for here; I’m expecting, largely, everything to be ground and monotonically solvable.</z><z id="t1643897242" t="lvh The underlying use case here FWIW is for some mortgage math. The problem with a spreadsheet is that you have to decide in advance which values depend on which; I’d like to make slightly more complex changes involving a solver, e.g. what happens if you change this variable vs this variable; but it’s still all monotonically solvable and doesn’t require anything fancy a la polynomial solvers or Gaussian elimination or anything like that."><y>#</y><d>2022-02-03</d><h>14:07</h><w>lvh</w>The underlying use case here FWIW is for some mortgage math. The problem with a spreadsheet is that you have to decide in advance which values depend on which; I’d like to make slightly more complex changes involving a solver, e.g. what happens if you change this variable vs this variable; but it’s still all monotonically solvable and doesn’t require anything fancy a la polynomial solvers or Gaussian elimination or anything like that.</z><z id="t1644103544" t="Richie I&apos;ve got some working code but I&apos;m wondering how I could move the (m/app :keys ?entries) from the subst and into the pattern. Working code: (m/rewrite {:pred-map {&apos;list {:min-length 1 :max-length 1} &apos;map {:min-length 1 :max-length 1}} :map {:keys {:a 1}}} {:pred-map {&apos;map {:min-length ?length :max-length ?length :as ?stats}} :map {:keys (m/app count ?length) :as ?entries}} {:entity {:stats ?stats :entries (m/app :keys ?entries)}}) produces {:entity {:stats {:min-length 1, :max-length 1}, :entries {:a 1}}} Changing :as ?entries to :as {:keys ?entries} and changing (m/app :keys ?entries) to ?entries doesn&apos;t match. {:pred-map {&apos;map {:min-length ?length :max-length ?length :as ?stats}} :map {:keys (m/app count ?length) :as {:keys ?entries}}} {:entity {:stats ?stats :entries ?entries}} ;; nil This gives nil. :as (m/app :keys ?entries) {:entity {:stats {:min-length 1, :max-length 1}, :entries nil}} "><y>#</y><d>2022-02-05</d><h>23:25</h><w>Richie</w>I&apos;ve got some working code but I&apos;m wondering how I could move the <code>(m/app :keys ?entries)</code> from the subst and into the pattern.
Working code:
<pre>(m/rewrite {:pred-map {&apos;list {:min-length 1
                              :max-length 1}
                       &apos;map {:min-length 1
                             :max-length 1}}
            :map {:keys {:a 1}}}

           {:pred-map {&apos;map {:min-length ?length
                             :max-length ?length
                             :as ?stats}}
            :map {:keys (m/app count ?length)
                  :as ?entries}}
           {:entity {:stats ?stats
                     :entries (m/app :keys ?entries)}})</pre>
produces
<pre>{:entity {:stats {:min-length 1, :max-length 1}, :entries {:a 1}}}</pre>
Changing <code>:as ?entries</code> to <code>:as {:keys ?entries}</code> and changing <code>(m/app :keys ?entries)</code> to <code>?entries</code> doesn&apos;t match.
<pre>{:pred-map {&apos;map {:min-length ?length
                             :max-length ?length
                             :as ?stats}}
            :map {:keys (m/app count ?length)
                  :as {:keys ?entries}}}
           {:entity {:stats ?stats
                     :entries ?entries}}
;; nil</pre>
This gives nil.
<pre>:as (m/app :keys ?entries)</pre>
<pre>{:entity {:stats {:min-length 1, :max-length 1}, :entries nil}}</pre>
</z><z id="t1644117808" t="Richie I&apos;ve got something else that I want to improve as well. I&apos;m not blocked on this since I&apos;ve got a workaround but I don&apos;t like the workaround. (defn my-fun [x] (apply merge (m/rewrites x {:thing {:map ?stuff} :min ?length :max ?length :map-entries (m/some ?entries)} {:entity {:stuff ?stuff :entries ?entries}} {:thing {:map ?stuff} :map-entries (m/some ?entries)} {:map {:stuff ?stuff :entries ?entries}} {:thing {:list ?stuff} :list-entries (m/some ?entries)} {:list {:stuff ?stuff :entries ?entries}}))) (my-fun {:thing {:map &apos;stuff} :min 1 :max 3 :map-entries [1 2 3]}) ;; {:map {:entries [1 2 3]}} (my-fun {:thing {:map &apos;stuff} :min 1 :max 1 :map-entries [1 2 3]}) ;; produces ;; {:entity {:entries [1 2 3]}, :map {:entries [1 2 3]}} ;; but i only want ;; {:map {:entries [1 2 3]}} (my-fun {:thing {:map &apos;stuff :list &apos;other-stuff} :min 1 :max 3 :map-entries [1 2 3] :list-entries &apos;t}) ;; {:map {:stuff stuff, :entries [1 2 3]}, :list {:stuff other-stuff, :entries t}} (my-fun {:thing {:map &apos;stuff :list &apos;other-stuff} :min 1 :max 1 :map-entries [1 2 3] :list-entries &apos;t}) ;; produces ;; {:entity {:stuff stuff, :entries [1 2 3]}, :map {:stuff stuff, :entries [1 2 3]}, :list {:stuff other-stuff, :entries t}} ;; but I only want ;; {:entity {:stuff stuff, :entries [1 2 3]}, :list {:stuff other-stuff, :entries t}} ;; should only return either :map or :entity, not both I was trying to generate a schema from spec-provider stats output. I want rewrites to return multiple matches in case it&apos;s a map and a list but I don&apos;t want it to return &quot;entity&quot; and &quot;map&quot; together since &quot;entity&quot; trumps&quot; map. I&apos;m guessing it&apos;s an entity if the data is uniform and falling back to a map collection if it&apos;s not. I still want to know if it&apos;s a map and a list so that I can wrap them both in an &quot;or&quot;. Another example: &quot;map&quot; and &quot;nil&quot; makes a nilable map."><y>#</y><d>2022-02-06</d><h>03:23</h><w>Richie</w>I&apos;ve got something else that I want to improve as well. I&apos;m not blocked on this since I&apos;ve got a workaround but I don&apos;t like the workaround.
<pre>(defn my-fun
  [x]
  (apply merge
         (m/rewrites x

                     {:thing {:map ?stuff}
                      :min ?length
                      :max ?length
                      :map-entries (m/some ?entries)}
                     {:entity {:stuff ?stuff
                               :entries ?entries}}

                     {:thing {:map ?stuff}
                      :map-entries (m/some ?entries)}
                     {:map {:stuff ?stuff
                            :entries ?entries}}

                     {:thing {:list ?stuff}
                      :list-entries (m/some ?entries)}
                     {:list {:stuff ?stuff
                             :entries ?entries}})))
(my-fun {:thing {:map &apos;stuff}
         :min 1
         :max 3
         :map-entries [1 2 3]})
;; {:map {:entries [1 2 3]}}
(my-fun {:thing {:map &apos;stuff}
         :min 1
         :max 1
         :map-entries [1 2 3]})
;; produces
;; {:entity {:entries [1 2 3]}, :map {:entries [1 2 3]}}
;; but i only want
;; {:map {:entries [1 2 3]}}

(my-fun {:thing {:map &apos;stuff
                 :list &apos;other-stuff}
         :min 1
         :max 3
         :map-entries [1 2 3]
         :list-entries &apos;t})
;; {:map {:stuff stuff, :entries [1 2 3]}, :list {:stuff other-stuff, :entries t}}
(my-fun {:thing {:map &apos;stuff
                 :list &apos;other-stuff}
         :min 1
         :max 1
         :map-entries [1 2 3]
         :list-entries &apos;t})
;; produces
;; {:entity {:stuff stuff, :entries [1 2 3]}, :map {:stuff stuff, :entries [1 2 3]}, :list {:stuff other-stuff, :entries t}}
;; but I only want
;; {:entity {:stuff stuff, :entries [1 2 3]}, :list {:stuff other-stuff, :entries t}}

;; should only return either :map or :entity, not both</pre>
I was trying to generate a schema from spec-provider stats output. I want rewrites to return multiple matches in case it&apos;s a map and a list but I don&apos;t want it to return &quot;entity&quot; and &quot;map&quot; together since &quot;entity&quot; trumps&quot; map. I&apos;m guessing it&apos;s an entity if the data is uniform and falling back to a map collection if it&apos;s not. I still want to know if it&apos;s a map and a list so that I can wrap them both in an &quot;or&quot;. Another example: &quot;map&quot; and &quot;nil&quot; makes a nilable map.</z><z id="t1644117838" t="Richie Thanks!"><y>#</y><d>2022-02-06</d><h>03:23</h><w>Richie</w>Thanks!</z><z id="t1644255165" t="jgdavey What’s an idiomatic way to express “all elements of this vector match this pattern”? For sets and maps, there’s the built-in map-of and set-of , but I don’t see something like seq-of or vec-of . It’s trivial to implement with defsyntax , but feels like I’m missing something more fundamental. Example: (m/defsyntax vec-of &quot;Pattern matching and substitution operator. When used as a pattern matching operator, matches a vector where all the entries have keys which match `pattern`. When used as a pattern substitution operator, constructs a vector where all entries are constructed with `pattern`.&quot; [pattern] (cond (m/match-syntax? &amp;env) `(m/with [%coll# (m/or [~pattern &amp; %coll#] &apos;[])] %coll#) (m/subst-syntax? &amp;env) `[~pattern ...] :else &amp;form)) (m/rewrite [:a :b] (vec-of (m/and (m/keyword _) !x)) (vec-of !x) ?a :wrong) ;; =&gt; [:a :b]"><y>#</y><d>2022-02-07</d><h>17:32</h><w>jgdavey</w>What’s an idiomatic way to express “all elements of this vector match this pattern”? For sets and maps, there’s the built-in <code>map-of</code> and <code>set-of</code>, but I don’t see something like <code>seq-of</code> or <code>vec-of</code>. It’s trivial to implement with <code>defsyntax</code>, but feels like I’m missing something more fundamental.

Example:
<pre>(m/defsyntax vec-of
    &quot;Pattern matching and substitution operator.

  When used as a pattern matching operator, matches a vector where all
  the entries have keys which match `pattern`.

  When used as a pattern substitution operator, constructs a vector where
  all entries are constructed with `pattern`.&quot;
    [pattern]
    (cond
      (m/match-syntax? &amp;env)
      `(m/with [%coll# (m/or [~pattern &amp; %coll#]
                             &apos;[])]
         %coll#)

      (m/subst-syntax? &amp;env)
      `[~pattern ...]

      :else
      &amp;form))

  (m/rewrite [:a :b]
    (vec-of (m/and (m/keyword _) !x))
    (vec-of !x)

    ?a :wrong) ;; =&gt; [:a :b]</pre></z><z id="t1644255302" t="Jimmy Miller [&lt;pattern&gt; ...]"><y>#</y><d>2022-02-07</d><h>17:35</h><r>Jimmy Miller</r><code>[&lt;pattern&gt; ...]</code></z><z id="t1644256177" t="jgdavey Awesome! And d’oh!"><y>#</y><d>2022-02-07</d><h>17:49</h><r>jgdavey</r>Awesome! And d’oh!</z><z id="t1644256232" t="jgdavey Next issue: How can I specify that a logic variable repeats? That is, repetition of :a keyword in the following example: (m/rewrite [:a :a] [(m/and (m/keyword ?n) !x) ...] [!x ...] ?a :wrong) (This doesn’t compile because of unbound logic var error)"><y>#</y><d>2022-02-07</d><h>17:50</h><r>jgdavey</r>Next issue: How can I specify that a logic variable repeats? That is, repetition of <code>:a</code> keyword in the following example:

<pre>(m/rewrite [:a :a]
    [(m/and (m/keyword ?n) !x) ...]
    [!x ...]
    
    ?a :wrong)</pre>
(This doesn’t compile because of unbound logic var error)</z><z id="t1644256251" t="jgdavey Trying to test that all are keywords that would unify"><y>#</y><d>2022-02-07</d><h>17:50</h><r>jgdavey</r>Trying to test that all are keywords that would unify</z><z id="t1644257315" t="jgdavey Perhaps something with guard ? (m/and [&lt;pattern binding !xs&gt; ...] (m/guard (apply = !xs)))"><y>#</y><d>2022-02-07</d><h>18:08</h><r>jgdavey</r>Perhaps something with <code>guard</code>?
<pre>(m/and [&lt;pattern binding !xs&gt; ...] (m/guard (apply = !xs)))</pre></z><z id="t1644257970" t="noprompt If a logic variable repeats you are saying “one or more” [?x . ?x ...] "><y>#</y><d>2022-02-07</d><h>18:19</h><r>noprompt</r>If a logic variable repeats you are saying “one or more”
<pre>[?x . ?x ...]</pre>
</z><z id="t1644259326" t="jgdavey Huzzah! That did it. Now I can use with for a more complicated pattern than just ?x"><y>#</y><d>2022-02-07</d><h>18:42</h><r>jgdavey</r>Huzzah! That did it. Now I can use <code>with</code> for a more complicated pattern than just <code>?x</code></z><z id="t1644406810" t="Ben Sless I&apos;m rewriting html I parsed with crouton and trying to collect text from within nested tags, but I miss something with the flattening part. What&apos;s missing in this pattern? {:tag (m/or :code :span :p :div :em :a) :content (m/some [!x ...])} [(m/cata !x) ...] "><y>#</y><d>2022-02-09</d><h>11:40</h><w>Ben Sless</w>I&apos;m rewriting html I parsed with <code>crouton</code>  and trying to collect text from within nested tags, but I miss something with the flattening part. What&apos;s missing in this pattern?
<pre>{:tag (m/or :code :span :p :div :em :a)
   :content (m/some [!x ...])} 

[(m/cata !x) ...]</pre>
</z><z id="t1644411452" t="Richie I started writing code like https://clojurians.slack.com/archives/C03S1KBA2/p1644357312001629 instead of cata. It lets me debug it more easily."><y>#</y><d>2022-02-09</d><h>12:57</h><r>Richie</r>I started writing code like <a href="https://clojurians.slack.com/archives/C03S1KBA2/p1644357312001629" target="_blank">https://clojurians.slack.com/archives/C03S1KBA2/p1644357312001629</a> instead of cata. It lets me debug it more easily.</z><z id="t1644411677" t="Ben Sless I&apos;d still rather do it with cata..."><y>#</y><d>2022-02-09</d><h>13:01</h><r>Ben Sless</r>I&apos;d still rather do it with cata...</z><z id="t1644412949" t="Richie It’s not a list is it? (m/rewrite &apos;(1 2 3) [!x ...] [!x ...]) ;; nil "><y>#</y><d>2022-02-09</d><h>13:22</h><r>Richie</r>It’s not a list is it?
<pre>(m/rewrite &apos;(1 2 3)
  [!x ...] [!x ...])
;; nil</pre>
</z><z id="t1644413538" t="Ben Sless No, it&apos;s nested parsed HTML"><y>#</y><d>2022-02-09</d><h>13:32</h><r>Ben Sless</r>No, it&apos;s nested parsed HTML</z><z id="t1644413645" t="Richie Sorry, I’m not sure from your answer. If the value of :content isn’t a vector then [!x …] won’t match. (m/rewrite &apos;(1 2 3) (m/seqable !x ...) [!x ...]) ;; [1 2 3] "><y>#</y><d>2022-02-09</d><h>13:34</h><r>Richie</r>Sorry, I’m not sure from your answer.
If the value of <code>:content</code> isn’t a vector then <code>[!x …]</code> won’t match.
<pre>(m/rewrite &apos;(1 2 3)
  (m/seqable !x ...) [!x ...])
;; [1 2 3]</pre>
</z><z id="t1644414871" t="Ben Sless The value of :content is a vector of strings or maps which will contain more :content"><y>#</y><d>2022-02-09</d><h>13:54</h><r>Ben Sless</r>The value of <code>:content</code> is a vector of strings or maps which will contain more <code>:content</code></z><z id="t1644415748" t="ribelo I recommend adding the key to cata as the first argument, which will tell us what should happen"><y>#</y><d>2022-02-09</d><h>14:09</h><r>ribelo</r>I recommend adding the key to <code>cata</code> as the first argument, which will tell us what should happen</z><z id="t1644415821" t="Ben Sless Not sure I follow. specifically, I&apos;m parsing some html table: (m/rewrite (second tables) {:tag :table :content [(m/cata !m) ...]} [!m ...] {:tag :tbody :content nil} {} {:tag :thead :content [{:content [{:content [?parameter]} {:content [?description]}]}]} {:parameter ?parameter :description ?description} {:tag :tbody :content [!tr ...]} [(m/cata !tr) ...] {:tag :tr :content [{:tag :td :content [?key ?desc]} {:tag :td :content [(m/cata !doc) ...]}]} {:field (m/cata ?key) :type (m/cata ?desc) :doc [!doc ...]} {:tag (m/or :a :code :span :p :div :em :a :ul :li :i) :content (m/some [(m/cata !xs) ...])} [!xs ...] {:tag (m/or :a :code :span :p :div :em :a :ul :li :i)} nil {:tag :br} &quot;\n&quot; ?x ?x) "><y>#</y><d>2022-02-09</d><h>14:10</h><r>Ben Sless</r>Not sure I follow. specifically, I&apos;m parsing some html table:
<pre>(m/rewrite (second tables)

  {:tag :table
   :content [(m/cata !m) ...]}
  [!m ...]

  {:tag :tbody :content nil} {}

  {:tag :thead
   :content
   [{:content
     [{:content [?parameter]}
      {:content [?description]}]}]}

  {:parameter ?parameter
   :description ?description}

  {:tag :tbody
   :content [!tr ...]}

  [(m/cata !tr) ...]

  {:tag :tr
   :content
   [{:tag :td :content [?key ?desc]}
    {:tag :td :content [(m/cata !doc) ...]}]}

  {:field (m/cata ?key)
   :type (m/cata ?desc)
   :doc [!doc ...]}

  {:tag (m/or :a :code :span :p :div :em :a :ul :li :i)
   :content (m/some [(m/cata !xs) ...])} [!xs ...]

  {:tag (m/or :a :code :span :p :div :em :a :ul :li :i)} nil

  {:tag :br} &quot;\n&quot;

  ?x ?x)</pre>
</z><z id="t1644415859" t="ribelo {:tag (m/or :code :span :p :div :em :a) :content (m/some [(m/cata [:flatten !x]) ...])} [:flatten [!xs ...]] [!xs ...] [:flatten ?x] ?x "><y>#</y><d>2022-02-09</d><h>14:10</h><r>ribelo</r><pre>{:tag (m/or :code :span :p :div :em :a)
 :content (m/some [(m/cata [:flatten !x]) ...])}
[:flatten [!xs ...]]
[!xs ...]
[:flatten ?x]
?x</pre>
</z><z id="t1644415883" t="Ben Sless ah, tag the data"><y>#</y><d>2022-02-09</d><h>14:11</h><r>Ben Sless</r>ah, tag the data</z><z id="t1644415915" t="ribelo this way, every time you use cata in any place, it will either unpack the vector or return the argument unchanged"><y>#</y><d>2022-02-09</d><h>14:11</h><r>ribelo</r>this way, every time you use cata in any place, it will either unpack the vector or return the argument unchanged</z><z id="t1644415931" t="ribelo much easier to debug and read code IMHO"><y>#</y><d>2022-02-09</d><h>14:12</h><r>ribelo</r>much easier to debug and read code IMHO</z><z id="t1644415969" t="Ben Sless I&apos;m missing the rhs for the map example"><y>#</y><d>2022-02-09</d><h>14:12</h><r>Ben Sless</r>I&apos;m missing the rhs for the map example</z><z id="t1644416089" t="ribelo can you give a piece of HTML so we have the same?"><y>#</y><d>2022-02-09</d><h>14:14</h><r>ribelo</r>can you give a piece of HTML so we have the same?</z><z id="t1644416154" t="ribelo btw, try this {:tag :table :content [&amp; [(m/cata !m) ...]]} [!m ...] "><y>#</y><d>2022-02-09</d><h>14:15</h><r>ribelo</r>btw, try this
<pre>{:tag :table
   :content [&amp; [(m/cata !m) ...]]}
  [!m ...]</pre>
</z><z id="t1644416169" t="ribelo it should work like into"><y>#</y><d>2022-02-09</d><h>14:16</h><r>ribelo</r>it should work like <code>into</code></z><z id="t1644416242" t="Ben Sless Even a tiny example like {:tag :p :content [{:tag :p :content [{:tag :p :content [&quot;Hello&quot;]} {:tag :p :content [&quot;world&quot;]}]} {:tag :p :content [{:tag :p :content [&quot;Yes&quot; {:tag :p :content [&quot;No&quot;]}]}]}]} "><y>#</y><d>2022-02-09</d><h>14:17</h><r>Ben Sless</r>Even a tiny example like
<pre>{:tag :p
 :content
 [{:tag :p
   :content
   [{:tag :p
     :content [&quot;Hello&quot;]}
    {:tag :p
     :content [&quot;world&quot;]}]}
  {:tag :p
   :content
   [{:tag :p
     :content [&quot;Yes&quot;
               {:tag :p
                :content [&quot;No&quot;]}]}]}]}</pre>
</z><z id="t1644416799" t="ribelo (m/rewrite data {:tag :table :content [&amp; [(m/cata !m) ...]]} [!m ...] {:tag :tbody :content nil} {} {:tag :thead :content [{:content [{:content [?parameter]} {:content [?description]}]}]} {:parameter ?parameter :description ?description} {:tag :tbody :content [!tr ...]} [&amp; [(m/cata !tr) ...]] {:tag :tr :content [{:tag :td :content [?key ?desc]} {:tag :td :content [&amp; [(m/cata !doc) ...]]}]} {:field (m/cata ?key) :type (m/cata ?desc) :doc [!doc ...]} {:tag (m/or :a :code :span :p :div :em :a :ul :li :i) :content (m/some [(m/cata !xs) ...])} (m/cata [!xs ...]) {:tag (m/or :a :code :span :p :div :em :a :ul :li :i)} nil {:tag :br} &quot;\n&quot; (m/with [%a (m/some !xs) %b [(m/or %b %a) ...] %c (m/or %b %a)] %c) [!xs ...] ?x ?x) ;; =&gt; [&quot;Hello&quot; &quot;world&quot; &quot;Yes&quot; &quot;No&quot;]"><y>#</y><d>2022-02-09</d><h>14:26</h><r>ribelo</r><pre>(m/rewrite data

  {:tag :table
   :content [&amp; [(m/cata !m) ...]]}
  [!m ...]

  {:tag :tbody :content nil} {}

  {:tag :thead
   :content
   [{:content
     [{:content [?parameter]}
      {:content [?description]}]}]}

  {:parameter ?parameter
   :description ?description}

  {:tag :tbody
   :content [!tr ...]}

  [&amp; [(m/cata !tr) ...]]

  {:tag :tr
   :content
   [{:tag :td :content [?key ?desc]}
    {:tag :td :content [&amp; [(m/cata !doc) ...]]}]}

  {:field (m/cata ?key)
   :type (m/cata ?desc)
   :doc [!doc ...]}

  {:tag (m/or :a :code :span :p :div :em :a :ul :li :i)
   :content (m/some [(m/cata !xs) ...])} (m/cata [!xs ...])

  {:tag (m/or :a :code :span :p :div :em :a :ul :li :i)} nil

  {:tag :br} &quot;\n&quot;

  (m/with [%a (m/some !xs)
           %b [(m/or %b %a) ...]
           %c (m/or %b %a)]
    %c)
  [!xs ...]
  ?x ?x)</pre>
<pre>;; =&gt; [&quot;Hello&quot; &quot;world&quot; &quot;Yes&quot; &quot;No&quot;]</pre></z><z id="t1644416901" t="ribelo this is for now, but can be done better"><y>#</y><d>2022-02-09</d><h>14:28</h><r>ribelo</r>this is for now, but can be done better</z><z id="t1644416950" t="Ben Sless 👍"><y>#</y><d>2022-02-09</d><h>14:29</h><r>Ben Sless</r><b>👍</b></z><z id="t1644435840" t="Ben Sless This + hiccup example: ;; Collect all content (m/with [%p {:content [(m/or (m/pred string? !s) %p %q) ...]} %q {:content nil}] %p) [!s ...] "><y>#</y><d>2022-02-09</d><h>19:44</h><r>Ben Sless</r>This + hiccup example:
<pre>;; Collect all content
  (m/with [%p {:content [(m/or (m/pred string? !s) %p %q) ...]}
           %q {:content nil}]
    %p)
  [!s ...]</pre>
</z><z id="t1644435856" t="Ben Sless collects all strings, no need to collect then flatten"><y>#</y><d>2022-02-09</d><h>19:44</h><r>Ben Sless</r>collects all strings, no need to collect then flatten</z><z id="t1644436112" t="Ben Sless Slightly more verbose but clearer what&apos;s going on: (m/with [%s (m/pred string? !s) ;; string ref %q {:content nil} ;; empty %c (m/or %s %p %q) ;; content vector can be %p {:content [%c ...]} ;; recursion, mutually ] %p) [!s ...] "><y>#</y><d>2022-02-09</d><h>19:48</h><r>Ben Sless</r>Slightly more verbose but clearer what&apos;s going on:
<pre>(m/with [%s (m/pred string? !s) ;; string ref
           %q {:content nil} ;; empty
           %c (m/or %s %p %q) ;; content vector can be
           %p {:content [%c ...]} ;; recursion, mutually
           ]
    %p)
  [!s ...]</pre>
</z><z id="t1644599747" t="sergey hey y&apos;all I&apos;m trying to write a pattern to match lists with two or more items, and I&apos;m seeing the &quot;n or more&quot; operator match on a empty list when I use it in an m/search - here&apos;s what I&apos;m seeing: (m/match [] [_ ..2] :matched-two-or-more _ :didnt-mach) ;; =&gt; :didnt-mach (m/search [] [_ ..2] :matched-two-or-more) ;; =&gt; (:matched-two-or-more) Is this expected behavior? I would assume that [_ ..2] means 2 or more elements in the list"><y>#</y><d>2022-02-11</d><h>17:15</h><w>sergey</w>hey y&apos;all I&apos;m trying to write a pattern to match lists with two or more items, and I&apos;m seeing the &quot;n or more&quot; operator match on a empty list when I use it in an <code>m/search</code> - here&apos;s what I&apos;m seeing:
<pre>(m/match
    []
    [_ ..2] :matched-two-or-more
    _ :didnt-mach)
;; =&gt; :didnt-mach
  (m/search
    []
    [_ ..2] :matched-two-or-more)
;; =&gt; (:matched-two-or-more)</pre>
Is this expected behavior? I would assume that <code>[_ ..2]</code> means 2 or more elements in the list</z><z id="t1644614404" t="Richie (m/match [1 2] (m/pred #(&lt; 1 (count %))) :more _ :one) "><y>#</y><d>2022-02-11</d><h>21:20</h><r>Richie</r><pre>(m/match [1 2]
  (m/pred #(&lt; 1 (count %))) :more
  _ :one)</pre>
</z><z id="t1644619228" t="noprompt This looks like a bug. Could you file it in the issue tracker? As a temporary work around try [_ _ &amp; _] "><y>#</y><d>2022-02-11</d><h>22:40</h><r>noprompt</r>This looks like a bug. Could you file it in the issue tracker? As a temporary work around try
<pre>[_ _ &amp; _]</pre>
</z><z id="t1644622099" t="sergey sure thing -- will do! FWIW, the pattern I ended up using was [_ . _ . _ ...] but [_ _ &amp; _] worked as expected as well"><y>#</y><d>2022-02-11</d><h>23:28</h><r>sergey</r>sure thing -- will do! FWIW, the pattern I ended up using was <code>[_ . _ . _ ...]</code> but <code>[_ _ &amp; _]</code> worked as expected as well</z><z id="t1644624220" t="sergey alright, https://github.com/noprompt/meander/issues/228#issue-1133344037 - lmk if there&apos;s anything else I can help with"><y>#</y><d>2022-02-12</d><h>00:03</h><r>sergey</r>alright, <a href="https://github.com/noprompt/meander/issues/228#issue-1133344037" target="_blank">https://github.com/noprompt/meander/issues/228#issue-1133344037</a> - lmk if there&apos;s anything else I can help with</z><z id="t1644614471" t="Richie (m/defsyntax compare-op [op a b] (case op :eq `(= ~a ~b) :not-eq `(not= ~a ~b) :lt `(&lt; ~a ~b) :lt-e `(&lt;= ~a ~b) :gt `(&gt; ~a ~b) :gt-e `(&gt;= ~a ~b) :is `(= ~a ~b) :is-not `(not= ~a ~b) :in `(some #{~a} ~b) :not-in `(not (some #{~a} ~b)))) (m/rewrite {:node :eq :a 1 :b 2} {:node :eq :a ?a :b ?b} (compare-op :eq ?a ?b)) ;; (clojure.core/= 1 2) (m/rewrite {:node :eq :a 1 :b 2} {:node ?op :a ?a :b ?b} (compare-op ?op ?a ?b)) ;; 1. Caused by java.lang.IllegalArgumentException ;; No matching clause: ?op How can I understand what’s going on here?"><y>#</y><d>2022-02-11</d><h>21:21</h><w>Richie</w><pre>(m/defsyntax
  compare-op
  [op a b]
  (case op
    :eq `(= ~a ~b)
    :not-eq `(not= ~a ~b)
    :lt `(&lt; ~a ~b)
    :lt-e `(&lt;= ~a ~b)
    :gt `(&gt; ~a ~b)
    :gt-e `(&gt;= ~a ~b)
    :is `(= ~a ~b)
    :is-not `(not= ~a ~b)
    :in `(some #{~a} ~b)
    :not-in `(not (some #{~a} ~b))))

(m/rewrite {:node :eq
            :a 1
            :b 2}
  {:node :eq
   :a ?a
   :b ?b}
  (compare-op :eq ?a ?b))
;; (clojure.core/= 1 2)

(m/rewrite {:node :eq
            :a 1
            :b 2}
  {:node ?op
   :a ?a
   :b ?b}
  (compare-op ?op ?a ?b))
;; 1. Caused by java.lang.IllegalArgumentException
;;    No matching clause: ?op</pre>
How can I understand what’s going on here?</z><z id="t1644619393" t="noprompt When compare-op is expanded it is handed the literal arguments ?op , ?a , and ?b . The case is failing because ?op (the literal symbol ?op ) has no clause."><y>#</y><d>2022-02-11</d><h>22:43</h><r>noprompt</r>When <code>compare-op</code> is expanded it is handed the literal arguments <code>?op</code>, <code>?a</code>, and <code>?b</code>. The <code>case</code> is failing because <code>?op</code> (the literal symbol <code>?op</code>) has no clause.</z><z id="t1644619434" t="noprompt defsyntax for all intents and purposes is like defmacro ."><y>#</y><d>2022-02-11</d><h>22:43</h><r>noprompt</r><code>defsyntax</code> for all intents and purposes is like <code>defmacro</code>.</z><z id="t1644619464" t="noprompt defsyntax defined functions are being called with literal arguments."><y>#</y><d>2022-02-11</d><h>22:44</h><r>noprompt</r><code>defsyntax</code> defined  functions are being called with literal arguments.</z><z id="t1644619979" t="Richie Oh, I get it. ?op doesn’t show up anywhere on the rhs of that rewrite rule."><y>#</y><d>2022-02-11</d><h>22:52</h><r>Richie</r>Oh, I get it. ?op doesn’t show up anywhere on the rhs of that rewrite rule.</z><z id="t1644620007" t="Richie Thanks!"><y>#</y><d>2022-02-11</d><h>22:53</h><r>Richie</r>Thanks!</z><z id="t1644626176" t="xiongtx Wondering how I can do the following w/out a group-by : (let [coll [{:foo &quot;a&quot; :bar &quot;b&quot; :baz 123} {:foo &quot;x&quot; :bar &quot;y&quot; :baz 666} {:foo &quot;a&quot; :bar &quot;b&quot; :baz 987}]] (m/search (group-by (juxt :foo :bar) coll) (m/scan [[?foo ?bar] [{:baz !baz} ...]]) {:foo ?foo :bar ?bar :children (for [v !baz] {:baz v})})) ;; =&gt; ({:foo &quot;a&quot;, :bar &quot;b&quot;, :children ({:baz 123} {:baz 987})} {:foo &quot;x&quot;, :bar &quot;y&quot;, :children ({:baz 666})}) I figure it’d need some way of remembering the different foo &amp; bar values and baz associated w/ them…keep in mind that the maps w/ same foo /`bar` pairs aren’t necessarily in order."><y>#</y><d>2022-02-12</d><h>00:36</h><w>xiongtx</w>Wondering how I can do the following w/out a <code>group-by</code>:

<pre>(let [coll [{:foo &quot;a&quot; :bar &quot;b&quot; :baz 123}
            {:foo &quot;x&quot; :bar &quot;y&quot; :baz 666}
            {:foo &quot;a&quot; :bar &quot;b&quot; :baz 987}]]
  (m/search (group-by (juxt :foo :bar) coll)
    (m/scan [[?foo ?bar] [{:baz !baz} ...]])
    {:foo ?foo
     :bar ?bar
     :children (for [v !baz]
                 {:baz v})}))

;; =&gt;

({:foo &quot;a&quot;, :bar &quot;b&quot;, :children ({:baz 123} {:baz 987})}
 {:foo &quot;x&quot;, :bar &quot;y&quot;, :children ({:baz 666})})</pre>
I figure it’d need some way of remembering the different <code>foo</code> &amp; <code>bar</code> values and <code>baz</code> associated w/ them…keep in mind that the maps w/ same <code>foo</code>/`bar` pairs aren’t necessarily in order.</z><z id="t1644628604" t="noprompt This comes up from time to time (group-by) which currently has no clean solution but will (hopefully) later this year. For these situations group-by is what I typically recommend because the alternative is not always that great. (let [coll [{:foo &quot;a&quot; :bar &quot;b&quot; :baz 123} {:foo &quot;x&quot; :bar &quot;y&quot; :baz 666} {:foo &quot;a&quot; :bar &quot;b&quot; :baz 987}]] (m/rewrite coll (m/with [%it {:foo ?foo, :bar ?bar, :baz !baz}] [%it . (m/or %it !not-it) ...]) ({:foo ?foo, :bar ?bar, :children [!baz ...]} &amp; (m/cata [!not-it ...])) _ ())) Here the issue is performance due to nodes being visited again and again. We can try a different approach. (let [coll [{:foo &quot;a&quot; :bar &quot;b&quot; :baz 123} {:foo &quot;x&quot; :bar &quot;y&quot; :baz 666} {:foo &quot;a&quot; :bar &quot;b&quot; :baz 987}]] (m/rewrite [coll {}] [[{:foo ?foo, :bar ?bar, :baz ?baz} &amp; ?rest] (m/and ?index (m/or {[?foo ?bar] ?children} (m/let [?children []])))] (m/cata [?rest {[?foo ?bar] [?baz &amp; ?children] &amp; ?index}]) [[] (m/map-of [!foo !bar] !children)] ({:foo !foo, :bar !bar, :children !children} ...))) This approach is, eh, not terribly attractive but I think it should be more performant than the other."><y>#</y><d>2022-02-12</d><h>01:16</h><w>noprompt</w>This comes up from time to time (group-by) which currently has no clean solution but will (hopefully) later this year. For these situations <code>group-by</code> is what I typically recommend because the alternative is not always that great.
<pre>(let [coll [{:foo &quot;a&quot; :bar &quot;b&quot; :baz 123}
            {:foo &quot;x&quot; :bar &quot;y&quot; :baz 666}
            {:foo &quot;a&quot; :bar &quot;b&quot; :baz 987}]]
  (m/rewrite coll
    (m/with [%it {:foo ?foo, :bar ?bar, :baz !baz}]
      [%it . (m/or %it !not-it) ...])
    ({:foo ?foo, :bar ?bar, :children [!baz ...]}
     &amp; (m/cata [!not-it ...]))

    _
    ()))</pre>
Here the issue is performance due to nodes being visited again and again. We can try a different approach.
<pre>(let [coll [{:foo &quot;a&quot; :bar &quot;b&quot; :baz 123}
            {:foo &quot;x&quot; :bar &quot;y&quot; :baz 666}
            {:foo &quot;a&quot; :bar &quot;b&quot; :baz 987}]]
  (m/rewrite [coll {}]
    [[{:foo ?foo, :bar ?bar, :baz ?baz} &amp; ?rest]
     (m/and ?index
            (m/or {[?foo ?bar] ?children}
                  (m/let [?children []])))]
    (m/cata [?rest {[?foo ?bar] [?baz &amp; ?children] &amp; ?index}])

    [[] (m/map-of [!foo !bar] !children)]
    ({:foo !foo, :bar !bar, :children !children} ...)))</pre>
This approach is, eh, not terribly attractive but I think it should be more performant than the other.</z><z id="t1644628781" t="noprompt Either way, I think group-by is much easier to wield and has more utility than what Meander can offer at the moment (which is okay!)."><y>#</y><d>2022-02-12</d><h>01:19</h><w>noprompt</w>Either way, I think <code>group-by</code> is much easier to wield and has more utility than what Meander can offer at the moment (which is okay!).</z><z id="t1644628842" t="noprompt Still, I think its a fun exercise to write out the semantically equivalent rules of a particular group by as practice."><y>#</y><d>2022-02-12</d><h>01:20</h><w>noprompt</w>Still, I think its a fun exercise to write out the semantically equivalent rules of a particular group by as practice.</z><z id="t1644633455" t="Richie Hey. This seems simple enough but it’s been hours (I don’t want to admit how many) and I haven’t got a solution. I want to turn this [[:&lt;&gt;] &apos;four [:&lt;&gt; &apos;one [&apos;three [:&lt;&gt; &apos;two]]] [:&lt;&gt; [:&lt;&gt; &apos;three]]] into this [&apos;four &apos;one [&apos;three &apos;two] &apos;three] I’m trying to splat any vector that starts with that keyword into the parent vector."><y>#</y><d>2022-02-12</d><h>02:37</h><w>Richie</w>Hey. This seems simple enough but it’s been hours (I don’t want to admit how many) and I haven’t got a solution.
I want to turn this
<pre>[[:&lt;&gt;]
 &apos;four
 [:&lt;&gt; &apos;one [&apos;three [:&lt;&gt; &apos;two]]]
 [:&lt;&gt; [:&lt;&gt; &apos;three]]]</pre>
into this
<pre>[&apos;four &apos;one [&apos;three &apos;two] &apos;three]</pre>
I’m trying to splat any vector that starts with that keyword into the parent vector.</z><z id="t1644633621" t="Richie This comes up because I have multiple things on the rhs of my rewrite rule but I don’t want it in a vector in the parent vector. e.g. {:node-type :module :body [(m/app f !body) ...]} [:&lt;&gt; (ns file-name-maybe) &amp; [!body ...]] {:node-type :name :id (m/app keb-sym ?id)} ?id The best idea I’ve had so far is to denote the ones that I want to flatten and flatten them after."><y>#</y><d>2022-02-12</d><h>02:40</h><r>Richie</r>This comes up because I have multiple things on the rhs of my rewrite rule but I don’t want it in a vector in the parent vector. e.g.
<pre>{:node-type :module
       :body [(m/app f !body) ...]}
      [:&lt;&gt; (ns file-name-maybe)
       &amp; [!body ...]]

      {:node-type :name
       :id (m/app keb-sym ?id)}
      ?id</pre>
The best idea I’ve had so far is to denote the ones that I want to flatten and flatten them after.</z><z id="t1644682017" t="Richie Oh. This is interesting. I kept trying things that worked top down but then I’d skip collapsing a level. I needed something that worked botom up."><y>#</y><d>2022-02-12</d><h>16:06</h><r>Richie</r>Oh. This is interesting. I kept trying things that worked top down but then I’d skip collapsing a level. I needed something that worked botom up.</z><z id="t1644682019" t="Richie (defn splat-fragments [xs] (cond (sequential? xs) (-&gt;&gt; (map splat-fragments xs) (map #(if (and (sequential? %) (= :&lt;&gt; (first %))) (rest %) [%])) (apply concat)) :else xs)) "><y>#</y><d>2022-02-12</d><h>16:06</h><r>Richie</r><pre>(defn splat-fragments
    [xs]
    (cond
      (sequential? xs) (-&gt;&gt; (map splat-fragments xs)
                            (map
                             #(if (and (sequential? %) (= :&lt;&gt; (first %)))
                                (rest %)
                                [%]))
                            (apply concat))
      :else xs))</pre>
</z><z id="t1644710060" t="noprompt (let [input [[:&lt;&gt;] &apos;four [:&lt;&gt; &apos;one [&apos;three [:&lt;&gt; &apos;two]]] [:&lt;&gt; [:&lt;&gt; &apos;three]]]] (m/rewrite input (m/with [%splice (m/or [:&lt;&gt; . (m/or %splice %node) ...] %node) %node (m/cata !node)] [%splice ...]) [!node ...] ?x ?x)) ;; =&gt; [four one [three two] three] "><y>#</y><d>2022-02-12</d><h>23:54</h><r>noprompt</r><pre>(let [input [[:&lt;&gt;]
             &apos;four
             [:&lt;&gt; &apos;one [&apos;three [:&lt;&gt; &apos;two]]]
             [:&lt;&gt; [:&lt;&gt; &apos;three]]]]
  (m/rewrite input
    (m/with [%splice (m/or [:&lt;&gt; . (m/or %splice %node) ...] %node)
             %node (m/cata !node)]
      [%splice ...])
    [!node ...]

    ?x ?x))
;; =&gt;
[four one [three two] three]</pre>
</z><z id="t1644710172" t="noprompt Somewhere on one of my hard drives I had a generic rule for this kind of thing."><y>#</y><d>2022-02-12</d><h>23:56</h><r>noprompt</r>Somewhere on one of my hard drives I had a generic rule for this kind of thing.</z><z id="t1644710215" t="Richie Woa."><y>#</y><d>2022-02-12</d><h>23:56</h><r>Richie</r>Woa.</z><z id="t1644710377" t="noprompt You can do a similar move to flatten operations like + or something."><y>#</y><d>2022-02-12</d><h>23:59</h><r>noprompt</r>You can do a similar move to flatten operations like <code>+</code> or something.</z><z id="t1644710420" t="Richie Thanks. I’m still digesting it. "><y>#</y><d>2022-02-13</d><h>00:00</h><r>Richie</r>Thanks. I’m still digesting it. </z><z id="t1644710677" t="noprompt This might be a tad clearer? (m/rewrite input (m/with [%splice [:&lt;&gt; . %main ...] %node (m/cata !node) %main (m/or %splice %node)] [%main ...]) [!node ...] ?x ?x) "><y>#</y><d>2022-02-13</d><h>00:04</h><r>noprompt</r>This might be a tad clearer?
<pre>(m/rewrite input
  (m/with [%splice [:&lt;&gt; . %main ...]
           %node (m/cata !node)
           %main (m/or %splice %node)]
    [%main ...])
  [!node ...]

  ?x ?x)</pre>
</z><z id="t1644710814" t="noprompt m/with and m/cata are what you want to reach for these kinds of situations. Think grammar. Think parser."><y>#</y><d>2022-02-13</d><h>00:06</h><r>noprompt</r><code>m/with</code> and <code>m/cata</code> are what you want to reach for these kinds of situations. Think grammar. Think parser.</z><z id="t1644711265" t="Richie I haven’t used ‘with’ successfully yet. This example helps me a lot though. Thanks!"><y>#</y><d>2022-02-13</d><h>00:14</h><r>Richie</r>I haven’t used ‘with’ successfully yet. This example helps me a lot though. Thanks!</z><z id="t1644711856" t="noprompt m/with is conceptually like letfn if that helps at all."><y>#</y><d>2022-02-13</d><h>00:24</h><r>noprompt</r><code>m/with</code> is conceptually like <code>letfn</code> if that helps at all.</z><z id="t1647119016" t="Nikolas Pafitis Is there an option for meander to keep keys that are not specified in the pattern?"><y>#</y><d>2022-03-12</d><h>21:03</h><w>Nikolas Pafitis</w>Is there an option for meander to keep keys that are not specified in the pattern?</z><z id="t1647119070" t="Jimmy Miller {:my-key ?my-key &amp; ?rest}"><y>#</y><d>2022-03-12</d><h>21:04</h><w>Jimmy Miller</w><code>{:my-key ?my-key &amp; ?rest}</code></z><z id="t1647119279" t="Nikolas Pafitis then how would i use ?rest in the output expression?"><y>#</y><d>2022-03-12</d><h>21:07</h><w>Nikolas Pafitis</w>then how would i use ?rest in the output expression?</z><z id="t1647119306" t="Jimmy Miller Yes. (Sorry on my phone so hard to give a full example)"><y>#</y><d>2022-03-12</d><h>21:08</h><w>Jimmy Miller</w>Yes. (Sorry on my phone so hard to give a full example)</z><z id="t1647119339" t="Nikolas Pafitis I did something like this and it works but is there a better way? (meander/match props {:color-scheme ?color-scheme &amp; ?rest} (merge {:color ?color-scheme} ?rest))"><y>#</y><d>2022-03-12</d><h>21:08</h><w>Nikolas Pafitis</w>I did something like this and it works but is there a better way?

<pre>(meander/match props
    {:color-scheme ?color-scheme &amp; ?rest}
    (merge {:color ?color-scheme}
           ?rest))</pre></z><z id="t1647119447" t="Jimmy Miller With match that works. With m/rewrite you could get rid of the merge and should be able to just write {:color ?color-scheme &amp; ?rest } for the output."><y>#</y><d>2022-03-12</d><h>21:10</h><w>Jimmy Miller</w>With match that works. With m/rewrite you could get rid of the merge and should be able to just write <code>{:color ?color-scheme &amp; ?rest }</code> for the output.</z><z id="t1647119664" t="Nikolas Pafitis I see, thanks that works great!"><y>#</y><d>2022-03-12</d><h>21:14</h><w>Nikolas Pafitis</w>I see, thanks that works great!</z><z id="t1647647123" t="borkdude Looks like meander works in #babashka :) https://clojurians.slack.com/archives/CLX41ASCS/p1647647085091009"><y>#</y><d>2022-03-18</d><h>23:45</h><w>borkdude</w>Looks like meander works in #babashka :)
<a href="https://clojurians.slack.com/archives/CLX41ASCS/p1647647085091009" target="_blank">https://clojurians.slack.com/archives/CLX41ASCS/p1647647085091009</a></z><z id="t1647885404" t="enn Hi folks, I’ve been looking for an excuse to use Meander for a while and I think I have a good use case now. One question I’m struggling with: for boring reasons, I’d like to define my input and output patterns in advance, separate from when I actually invoke Meander. But I have some transformation functions I want to use in the output pattern that rely on runtime context (in my case, a DB connection): an example input pattern: {:id ?epic-id :input {:team ?team-id}} an example output pattern: {:id (resolve-as-type db :entity-type/epic ?epic-id) :input {:team_id (resolve-as-type db :entity-type/team ?team-id)}}) My question is: is there some way to pass in parameters to an invocation of m/match (or any of the other top-level Meander macros) that are then available in the patterns? (e.g., the equivalent to the :in clause of a Datomic query)."><y>#</y><d>2022-03-21</d><h>17:56</h><w>enn</w>Hi folks, I’ve been looking for an excuse to use Meander for a while and I think I have a good use case now.

One question I’m struggling with: for boring reasons, I’d like to define my input and output patterns in advance, separate from when I actually invoke Meander. But I have some transformation functions I want to use in the output pattern that rely on runtime context (in my case, a DB connection):

an example input pattern:

<pre>{:id ?epic-id
        :input {:team ?team-id}}</pre>
an example output pattern:

<pre>{:id (resolve-as-type db :entity-type/epic ?epic-id)
           :input {:team_id (resolve-as-type db :entity-type/team ?team-id)}})      </pre>
My question is: is there some way to pass in parameters to an invocation of <code>m/match</code>  (or any of the other top-level Meander macros) that are then available in the patterns? (e.g., the equivalent to the <code>:in</code> clause of a Datomic query).</z><z id="t1647887133" t="enn and if not, what kind of patterns do people have for threading runtime context down into function calls in an output pattern?"><y>#</y><d>2022-03-21</d><h>18:25</h><w>enn</w>and if not, what kind of patterns do people have for threading runtime context down into function calls in an output pattern?</z><z id="t1647887327" t="jgdavey You can use unquote ~ in most pattern places, and in the substitution of m/rewrite"><y>#</y><d>2022-03-21</d><h>18:28</h><w>jgdavey</w>You can use unquote <code>~</code> in most pattern places, and in the substitution of <code>m/rewrite</code></z><z id="t1647891228" t="enn thanks! Is there an example of this somewhere in the docs? I’m not sure I understand what the semantics of ~ would be here."><y>#</y><d>2022-03-21</d><h>19:33</h><w>enn</w>thanks! Is there an example of this somewhere in the docs? I’m not sure I understand what the semantics of <code>~</code> would be here.</z><z id="t1647891790" t="Jimmy Miller https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#unquote"><y>#</y><d>2022-03-21</d><h>19:43</h><w>Jimmy Miller</w><a href="https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#unquote" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#unquote</a></z><z id="t1648078676" t="stathissideris hello! is it possible to convert this: {:items [{:a 10 :b 20 :c 55} {:a 30 :b 40 :c 45}]} to this? {:items [{:alpha 10 :beta 20} {:alpha 30 :beta 40}]}"><y>#</y><d>2022-03-23</d><h>23:37</h><w>stathissideris</w>hello!
is it possible to convert this:
<pre>{:items [{:a 10 :b 20 :c 55}
         {:a 30 :b 40 :c 45}]}</pre>
to this?
<pre>{:items [{:alpha 10 :beta 20}
         {:alpha 30 :beta 40}]}</pre></z><z id="t1648079477" t="stathissideris obviously for any number of maps"><y>#</y><d>2022-03-23</d><h>23:51</h><w>stathissideris</w>obviously for any number of maps</z><z id="t1648079525" t="stathissideris I tried with ! and ... but I get all :a s in the same sequence"><y>#</y><d>2022-03-23</d><h>23:52</h><w>stathissideris</w>I tried with <code>!</code> and <code>...</code> but I get all <code>:a</code>s in the same sequence</z><z id="t1648091991" t="Jimmy Miller (m/rewrite {:items [{:a 10 :b 20 :c 55} {:a 30 :b 40 :c 45}]} {:items [{:a !alpha :b !beta} ...]} {:items [{:alpha !alpha :b !beta} ...]})"><y>#</y><d>2022-03-24</d><h>03:19</h><w>Jimmy Miller</w><pre>(m/rewrite {:items [{:a 10 :b 20 :c 55}
                    {:a 30 :b 40 :c 45}]}
  {:items [{:a !alpha :b !beta} ...]}
  {:items [{:alpha !alpha :b !beta} ...]})</pre></z><z id="t1648108931" t="stathissideris [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] thank you!"><y>#</y><d>2022-03-24</d><h>08:02</h><w>stathissideris</w><a>@jimmy</a> thank you!</z><z id="t1648127443" t="enn As part of a larger transform, I’m trying to handle parameters that follow this pattern, i.e., they can either express simple operations to apply to a set, or they can express the desired value of the set: ;; owners current state: [3 4 5] {:owners {:add [1 2] :remove [3 4]}} ;; =&gt; {:owner_ids [1 2 5]} {:owners {:reset [1 2]}} ;; =&gt; {:owner_ids [1 2]} Right now I’m doing the actual application of the add/remove operations in Clojure code in the RHS of a match : (m/match {:ctx {:db db} :attributes {:id 123 :input {:owners {:add [1 2] :remove [3 4]}}}} {:ctx {:db ?db :as ?ctx} :attributes {:id ?id :input {:owners ?owner-ops}}} {:ctx ?ctx :attributes {:id ?id :input {:owner_ids (apply-ops (get-current-owners ?db ?id) ?owner-ops)}}}) Is there a more idiomatic way to do this that expresses more of the transformation in Meander?"><y>#</y><d>2022-03-24</d><h>13:10</h><w>enn</w>As part of a larger transform, I’m trying to handle parameters that follow this pattern, i.e., they can either express simple operations to apply to a set, or they can express the desired value of the set:

<pre>;; owners current state: [3 4 5]
{:owners {:add [1 2] :remove [3 4]}} ;; =&gt; {:owner_ids [1 2 5]}
{:owners {:reset [1 2]}} ;; =&gt; {:owner_ids [1 2]}</pre>
Right now I’m doing the actual application of the add/remove operations in Clojure code in the RHS of a <code>match</code>:

<pre>(m/match
  {:ctx {:db db}
   :attributes {:id 123
                :input {:owners {:add [1 2] :remove [3 4]}}}}
       
  {:ctx {:db ?db :as ?ctx}
   :attributes {:id ?id
                :input {:owners ?owner-ops}}}
       
  {:ctx ?ctx
   :attributes {:id ?id
                :input {:owner_ids (apply-ops
                                    (get-current-owners ?db ?id)
                                    ?owner-ops)}}})</pre>
Is there a more idiomatic way to do this that expresses more of the transformation in Meander?</z><z id="t1648138474" t="noprompt That looks good to me. Pretty easy to follow."><y>#</y><d>2022-03-24</d><h>16:14</h><w>noprompt</w>That looks good to me. Pretty easy to follow.</z><z id="t1648138863" t="noprompt In terms of idioms, I would say just try to balance what Meander and &quot;vanilla&quot; Clojure are good at. For example, it is totally possible to apply the owner operations you have here using m/rewrite but, apart from being a good exercise, it may confuse people on your team, etc."><y>#</y><d>2022-03-24</d><h>16:21</h><w>noprompt</w>In terms of idioms, I would say just try to balance what Meander and &quot;vanilla&quot; Clojure are good at. For example, it is totally possible to apply the owner operations you have here using <code>m/rewrite</code> but, apart from being a good exercise, it may confuse people on your team, etc.</z><z id="t1648156542" t="enn Thanks [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] , I appreciate the sanity check."><y>#</y><d>2022-03-24</d><h>21:15</h><w>enn</w>Thanks <a>@noprompt</a>, I appreciate the sanity check.</z><z id="t1648165101" t="stathissideris I have this rewrite where I’m using m/app to slightly post-process the output. In the case of !description I would like to keep the original value as well as the post-processed one, but mentioning it twice in the output means that 2 descriptions are consumed per :invoice/item . Is there a way to overcome this?"><y>#</y><d>2022-03-24</d><h>23:38</h><w>stathissideris</w>I have this rewrite where I’m using <code>m/app</code> to slightly post-process the output. In the case of <code>!description</code> I would like to keep the original value as well as the post-processed one, but mentioning it twice in the output means that 2 descriptions are consumed per <code>:invoice/item</code>. Is there a way to overcome this?</z><z id="t1648165110" t="stathissideris (defn xero-invoice-&gt;datom [invoice &amp; {:keys [service/provider]}] (m/rewrite (assoc invoice ::provider provider) {::provider ?provider :Invoices [{:LineItems [{:UnitAmount !unit-amount :LineAmount !line-amount :Description !description :Quantity !quantity} ...] :CurrencyCode ?currency :InvoiceNumber ?invoice-id :DateString ?issue-date :Total ?amount :DueDateString ?due-date :InvoiceID ?xero-id :TotalTax ?vat :Contact {:Name ?xero-contact-name}}]} {:service/provider ?provider :service/consumer (m/app names-&gt;consumers ?xero-contact-name) :time/issue-date (m/app instant/read-instant-timestamp ?issue-date) :time/due-date (m/app instant/read-instant-timestamp ?due-date) :payment/amount ?amount :payment/currency (m/app currency ?currency) :payment/vat ?vat :xero/id ?xero-id :invoice/id ?invoice-id :invoice/items [{:person/consultant (m/app desc-&gt;consultant !description) :xero/description !description :service/quantity !quantity :service/unit :hours :payment/amount !line-amount} ...]}))"><y>#</y><d>2022-03-24</d><h>23:38</h><w>stathissideris</w><pre>(defn xero-invoice-&gt;datom [invoice &amp; {:keys [service/provider]}]
  (m/rewrite
    (assoc invoice ::provider provider)
    {::provider ?provider
     :Invoices
     [{:LineItems     [{:UnitAmount  !unit-amount
                        :LineAmount  !line-amount
                        :Description !description
                        :Quantity    !quantity}
                       ...]
       :CurrencyCode  ?currency
       :InvoiceNumber ?invoice-id
       :DateString    ?issue-date
       :Total         ?amount
       :DueDateString ?due-date
       :InvoiceID     ?xero-id
       :TotalTax      ?vat
       :Contact       {:Name ?xero-contact-name}}]}
    {:service/provider ?provider
     :service/consumer (m/app names-&gt;consumers ?xero-contact-name)
     :time/issue-date  (m/app instant/read-instant-timestamp ?issue-date)
     :time/due-date    (m/app instant/read-instant-timestamp ?due-date)
     :payment/amount   ?amount
     :payment/currency (m/app currency ?currency)
     :payment/vat      ?vat
     :xero/id          ?xero-id
     :invoice/id       ?invoice-id
     :invoice/items    [{:person/consultant (m/app desc-&gt;consultant !description)
                         :xero/description  !description
                         :service/quantity  !quantity
                         :service/unit      :hours
                         :payment/amount    !line-amount}
                        ...]}))</pre></z><z id="t1648170487" t="markaddleman I use the following idiom: (m/rewrite [1 2 3] [(m/and !a1 !a2) ...] {:a1 [!a1 ...] :a2 [!a2 ...]}) "><y>#</y><d>2022-03-25</d><h>01:08</h><w>markaddleman</w>I use the following idiom:
<pre>(m/rewrite [1 2 3]
   [(m/and !a1 !a2) ...]
   {:a1 [!a1 ...] :a2 [!a2 ...]})</pre>
</z><z id="t1648229939" t="enn How can I bind nested values without failing if a parent is absent? (m/match {:a 1} {:b {:c ?c}} ?c) Execution error (ExceptionInfo) at clubhouse.resolvers.datalayer/eval641426 (REPL:203). non exhaustive pattern match"><y>#</y><d>2022-03-25</d><h>17:38</h><w>enn</w>How can I bind nested values without failing if a parent is absent?

<pre>(m/match {:a 1}
  {:b {:c ?c}}
  ?c)
Execution error (ExceptionInfo) at clubhouse.resolvers.datalayer/eval641426 (REPL:203).
non exhaustive pattern match</pre></z><z id="t1648230014" t="Jimmy Miller You can always add an extra case like _ nil or ?x ?x"><y>#</y><d>2022-03-25</d><h>17:40</h><w>Jimmy Miller</w>You can always add an extra case like <code>_ nil</code> or <code>?x ?x</code></z><z id="t1648230080" t="Jimmy Miller Or use m/or at the variable"><y>#</y><d>2022-03-25</d><h>17:41</h><w>Jimmy Miller</w>Or use m/or at the variable</z><z id="t1648230239" t="enn in my real use case, I still want to bind a bunch of other things at other levels, something like (m/match {:a 1 :c {:foo 3}} {:a ?a :b ?b :c {:foo ?c} :d {:bar ?d}} [?a ?b ?c ?d])"><y>#</y><d>2022-03-25</d><h>17:43</h><w>enn</w>in my real use case, I still want to bind a bunch of other things at other levels, something like

<pre>(m/match {:a 1 :c {:foo 3}}
  {:a ?a
   :b ?b
   :c {:foo ?c}
   :d {:bar ?d}}
  [?a ?b ?c ?d])</pre></z><z id="t1648230307" t="enn I thought I could do :d {:bar (m/or ?d (m/let [?d 1]))} , but that still gives me non-exhaustive pattern match . Is that not the right level for the m/or ?"><y>#</y><d>2022-03-25</d><h>17:45</h><w>enn</w>I thought I could do <code>:d {:bar (m/or ?d (m/let [?d 1]))}</code>, but that still gives me <code>non-exhaustive pattern match</code>. Is that not the right level for the <code>m/or</code>?</z><z id="t1648230365" t="enn ah, if I move m/or up a level it works"><y>#</y><d>2022-03-25</d><h>17:46</h><w>enn</w>ah, if I move <code>m/or</code> up a level it works</z><z id="t1648230484" t="Jimmy Miller Yeah at that level there would have to be a map at :d. The key couldn&apos;t be missing. Moving it up one level allows that."><y>#</y><d>2022-03-25</d><h>17:48</h><w>Jimmy Miller</w>Yeah at that level there would have to be a map at :d.  The key couldn&apos;t be missing. Moving it up one level allows that.</z><z id="t1648239859" t="enn When matching a map, how can I distinguish between a key’s absence and its having the value nil ?"><y>#</y><d>2022-03-25</d><h>20:24</h><w>enn</w>When matching a map, how can I distinguish between a key’s absence and its having the value <code>nil</code> ?</z><z id="t1648246613" t="noprompt This is one of those areas where I don&apos;t have a great answer. When I went to put together the map pattern matching semantics I based them on the observations that 1) find use is uncommon, and 2) most folks are concerned with observable equivalence and not semantic equivalence when it comes to get . The subtle difference between the following two expressions do not weight heavily on most. Its a pragmatic trade off I suppose. (get {} :m) (get {:m nil} :m) Considering these observations, I chose to have the compiler use get instead of find and favor the common map access patterns. The nice thing is that it does help reduce the number of clauses you might write for map pattern matching. The drawback is exactly this case. 🙂"><y>#</y><d>2022-03-25</d><h>22:16</h><w>noprompt</w>This is one of those areas where I don&apos;t have a great answer.

When I went to put together the map pattern matching semantics I based them on the observations that 1) <code>find</code> use is uncommon, and 2) most folks are concerned with observable equivalence and not semantic equivalence when it comes to <code>get</code> . The subtle difference between the following two expressions do not weight heavily on most. Its a pragmatic trade off I suppose.
<pre>(get {} :m)
(get {:m nil} :m)</pre>
Considering these observations, I chose to have the compiler use <code>get</code> instead of <code>find</code> and favor the common map access patterns. The nice thing is that it does help reduce the number of clauses you might write for map pattern matching. The drawback is exactly this case. <b>🙂</b></z><z id="t1648247230" t="noprompt If it is cheap, you could preprocess the map to have &quot;semantic nil s&quot; i.e. ::blank / ::undefined and then pattern match on those. So user=&gt; (def blank (fnil identity ::blank)) #&apos;user/blank user=&gt; (blank (get {:m nil} :m ::undefined)) :user/blank user=&gt; (blank (get {} :m ::undefined)) :user/undefined user=&gt; (blank (get {:m 10} :m ::undefined)) 10 (`blank` is probably a terrible name but you get the idea.)"><y>#</y><d>2022-03-25</d><h>22:27</h><w>noprompt</w>If it is cheap, you could preprocess the map to have &quot;semantic <code>nil</code>s&quot; i.e. <code>::blank</code> / <code>::undefined</code> and then pattern match on those. So
<pre>user=&gt; (def blank (fnil identity ::blank))
#&apos;user/blank
user=&gt; (blank (get {:m nil} :m ::undefined))
:user/blank
user=&gt; (blank (get {} :m ::undefined))
:user/undefined
user=&gt; (blank (get {:m 10} :m ::undefined))
10</pre>
(`blank` is probably a terrible name but you get the idea.)</z><z id="t1648249243" t="enn Interesting, that makes sense. It’s good to know I’m not missing an obvious way to do this."><y>#</y><d>2022-03-25</d><h>23:00</h><w>enn</w>Interesting, that makes sense. It’s good to know I’m not missing an obvious way to do this.</z><z id="t1648249385" t="enn Perhaps regrettably, we’ve got an API contract for updates where {:foo nil} means “unset the :foo property,” while the absence of :foo means “leave the :foo property as it is.”"><y>#</y><d>2022-03-25</d><h>23:03</h><w>enn</w>Perhaps regrettably, we’ve got an API contract for updates where <code>{:foo nil}</code> means “unset the <code>:foo</code> property,” while the absence of <code>:foo</code> means “leave the <code>:foo</code> property as it is.”</z><z id="t1648249690" t="noprompt Ha! Yep. We have a situation like that with one of our APIs too. {:foo nil} is fine but if :foo is missing the API yells at you. 😐"><y>#</y><d>2022-03-25</d><h>23:08</h><w>noprompt</w>Ha! Yep. We have a situation like that with one of our APIs too. <code>{:foo nil}</code> is fine but if <code>:foo</code> is missing the API yells at you. <b>😐</b></z></g><g id="s15"><z id="t1649073346" t="Carlo I&apos;m a bit confused by this interaction: (-&gt; {:a {:b 0.5 :c 0.5} :b {:c 1} :c {:a 1}} (meander/search (meander/scan [!sources {:c (meander/some _)}]) !sources)) the result I get back is ([:a] [:b]) but I would have expected ([:a :b]) . I&apos;m tring to find all map keys that contain :c in the submap. edit: I get why this happens: each search is a separate search, that only finds one source. But how could I find them all?"><y>#</y><d>2022-04-04</d><h>11:55</h><w>Carlo</w>I&apos;m a bit confused by this interaction:
<pre>(-&gt; {:a {:b 0.5 :c 0.5}
     :b {:c 1}
     :c {:a 1}}
    (meander/search
     (meander/scan [!sources {:c (meander/some _)}])
     !sources))</pre>
the result I get back is <code>([:a] [:b])</code> but I would have expected <code>([:a :b])</code> . I&apos;m tring to find all map keys that contain <code>:c</code> in the submap.
edit: I get why this happens: each search is a separate search, that only finds one source. But how could I find them all?</z><z id="t1649087670" t="noprompt (m/find {:a {:b 0.5 :c 0.5} :b {:c 1} :c {:a 1}} (m/gather [!sources {:c (m/some _)}]) !sources) "><y>#</y><d>2022-04-04</d><h>15:54</h><w>noprompt</w><pre>(m/find {:a {:b 0.5 :c 0.5}
         :b {:c 1}
         :c {:a 1}}
  (m/gather [!sources {:c (m/some _)}])
  !sources)</pre>
</z><z id="t1649096763" t="Carlo Thanks for the solution, gather was the missing piece, wasn&apos;t aware it existed. I&apos;ll confess I still have a bit of difficulty in formulating the correct mental plan when I want to write something with meander. Case in point, the original problem I wanted to solve was turning: {:a {:b 0.5 :c 0.5} :b {:c 1} :c {:a 1}} into: {:a {:c 1} :b {:a 0.5} :c {:a 0.5 :b 1}} (which are two representation of a weighted graph: the first by outgoing edges, the second by incoming edges). It&apos;s still unclear to me how to jump from this solution to the complete one: I was trying something along the line of: -&gt; {:a {:b 0.5 :c 0.5} :b {:c 1} :c {:a 1}} (meander/find (meander/gather [!sources {:c (meander/some !weights)}]) {:c [!sources !weights]})) but I don&apos;t see how to interleave !sources and weights to make them a map (almost all the combinations I tried return nil ). Also, it doesn&apos;t seem possible to turn the key :c above in a logical variable. What should I think when solving this problem with meander?"><y>#</y><d>2022-04-04</d><h>18:26</h><r>Carlo</r>Thanks for the solution, <code>gather</code> was the missing piece, wasn&apos;t aware it existed. I&apos;ll confess I still have a bit of difficulty in formulating the correct mental plan when I want to write something with meander. Case in point, the original problem I wanted to solve was turning:

<pre>{:a {:b 0.5 :c 0.5}
 :b {:c 1}
 :c {:a 1}}</pre>
into:
<pre>{:a {:c 1}
 :b {:a 0.5}
 :c {:a 0.5 :b 1}}</pre>
(which are two representation of a weighted graph: the first by outgoing edges, the second by incoming edges).

It&apos;s still unclear to me how to jump from this solution to the complete one:
I was trying something along the line of:
<pre>-&gt; {:a {:b 0.5 :c 0.5}
     :b {:c 1}
     :c {:a 1}}
    (meander/find
     (meander/gather [!sources {:c (meander/some !weights)}])
     {:c  [!sources !weights]}))</pre>
but I don&apos;t see how to interleave <code>!sources</code> and <code>weights</code> to make them a map (almost all the combinations I tried return <code>nil</code>). Also, it doesn&apos;t seem possible to turn the key <code>:c</code> above in a logical variable. What should I think when solving this problem with meander?</z><z id="t1649098568" t="Carlo (-&gt; {:a {:b 0.5 :c 0.5} :b {:c 1} :c {:a 1}} (meander/find (meander/gather [!sources {:c (meander/some !weights)}]) {:c (zipmap !sources !weights)})) if only I could do this for each key. Maybe the solution is doing that step outside of meander?"><y>#</y><d>2022-04-04</d><h>18:56</h><r>Carlo</r><pre>(-&gt; {:a {:b 0.5 :c 0.5}
     :b {:c 1}
     :c {:a 1}}
    (meander/find
     (meander/gather [!sources {:c (meander/some !weights)}])
     {:c (zipmap !sources !weights)}))</pre>
if only I could do this for each key. Maybe the solution is doing that step outside of meander?</z><z id="t1649100450" t="noprompt Re: thinking: The problem should be broken down into steps rather than trying to be solved with one rule: ;; Step 1. (m/search {:a {:b 0.5 :c 0.5} :b {:c 1} :c {:a 1}} {?k {?sk ?sv}} [[?sk ?k] ?sv]) ;; =&gt; ([[:b :a] 0.5] [[:c :a] 0.5] [[:c :b] 1] [[:a :c] 1]) ;; Step 2. (reduce (fn [m [path v]] (assoc-in m path v)) {} &apos;([[:b :a] 0.5] [[:c :a] 0.5] [[:c :b] 1] [[:a :c] 1])) ;; =&gt; {:a {:c 1} :b {:a 0.5} :c {:a 0.5 :b 1}} "><y>#</y><d>2022-04-04</d><h>19:27</h><r>noprompt</r>Re: thinking: The problem should be broken down into steps rather than trying to be solved with one rule:
<pre>;; Step 1.
(m/search {:a {:b 0.5 :c 0.5}
           :b {:c 1}
           :c {:a 1}}
  {?k {?sk ?sv}}
  [[?sk ?k] ?sv])
;; =&gt;
([[:b :a] 0.5]
 [[:c :a] 0.5]
 [[:c :b] 1]
 [[:a :c] 1])

;; Step 2.
(reduce
 (fn [m [path v]]
   (assoc-in m path v))
 {}
 &apos;([[:b :a] 0.5]
   [[:c :a] 0.5]
   [[:c :b] 1]
   [[:a :c] 1]))
;; =&gt;
{:a {:c 1}
 :b {:a 0.5}
 :c {:a 0.5 :b 1}}</pre>
</z><z id="t1649100640" t="Carlo ok, I&apos;m glad that&apos;s the solution, as I did something similar in two steps (but didn&apos;t have the idea of grouping the keys to use them with assoc-in ; brilliant!) Thank you! 🙂"><y>#</y><d>2022-04-04</d><h>19:30</h><r>Carlo</r>ok, I&apos;m glad that&apos;s the solution, as I did something similar in two steps (but didn&apos;t have the idea of grouping the keys to use them with <code>assoc-in</code> ; brilliant!)
Thank you! <b>🙂</b></z><z id="t1649101817" t="noprompt OK. Sorry, I made a small mistake in the previous post. Here is the corrected m/rewrite version: (m/rewrite [{:a {:b 0.5 :c 0.5} :b {:c 1} :c {:a 1}} {}] [{?k {?sk ?sv &amp; ?m-k} &amp; ?m-in} {?sk ?m-ko &amp; ?m-out}] (m/cata [{?k ?m-k &amp; ?m-in} {?sk {?k ?sv &amp; ?m-ko} &amp; ?m-out}]) [{?k {?sk ?sv &amp; ?m-k} &amp; ?m-in} ?m-out] (m/cata [{?k ?m-k &amp; ?m-in} {?sk {?k ?sv} &amp; ?m-out}]) [_ ?m-out] ?m-out) ;; =&gt; {:b {:a 0.5}, :c {:b 1, :a 0.5}, :a {:c 1}}"><y>#</y><d>2022-04-04</d><h>19:50</h><r>noprompt</r>OK. Sorry, I made a small mistake in the previous post. Here is the corrected <code>m/rewrite</code> version:
<pre>(m/rewrite [{:a {:b 0.5 :c 0.5}
             :b {:c 1}
             :c {:a 1}}
            {}]
  [{?k {?sk ?sv &amp; ?m-k} &amp; ?m-in}
   {?sk ?m-ko &amp; ?m-out}]
  (m/cata [{?k ?m-k &amp; ?m-in}
           {?sk {?k ?sv &amp; ?m-ko} &amp; ?m-out}])

  [{?k {?sk ?sv &amp; ?m-k} &amp; ?m-in}
   ?m-out]
  (m/cata [{?k ?m-k &amp; ?m-in}
           {?sk {?k ?sv} &amp; ?m-out}])

  [_ ?m-out]
  ?m-out)
;; =&gt;
{:b {:a 0.5}, :c {:b 1, :a 0.5}, :a {:c 1}}</pre></z><z id="t1649101922" t="noprompt Using a step-wise approach: (let [step (fn [pair] (m/rewrite pair [{?k {?sk ?sv &amp; ?m-k} &amp; ?m-in} {?sk ?m-ko &amp; ?m-out}] [{?k ?m-k &amp; ?m-in} {?sk {?k ?sv &amp; ?m-ko} &amp; ?m-out}] [{?k {?sk ?sv &amp; ?m-k} &amp; ?m-in} ?m-out] [{?k ?m-k &amp; ?m-in} {?sk {?k ?sv} &amp; ?m-out}] [_ ?m-out] ?m-out)) init [{:a {:b 0.5 :c 0.5} :b {:c 1} :c {:a 1}} {}]] (-&gt; init step ;; =&gt; [{:b {:c 1}, :c {:a 1}, :a {:c 0.5}} {:b {:a 0.5}}] step ;; =&gt; [{:c {:a 1}, :a {:c 0.5}, :b {}} {:b {:a 0.5}, :c {:b 1}}] step ;; =&gt; [{:c {:a 1}, :b {}, :a {}} {:b {:a 0.5}, :c {:b 1, :a 0.5}}] step ;; =&gt; [{:b {}, :a {}, :c {}} {:b {:a 0.5}, :c {:b 1, :a 0.5}, :a {:c 1}}] step)) ;; =&gt; {:b {:c 0.5, :a 0.5}, :c {:a 0.5}, :a {:c 1}} "><y>#</y><d>2022-04-04</d><h>19:52</h><r>noprompt</r>Using a step-wise approach:
<pre>(let [step (fn [pair]
             (m/rewrite pair
               [{?k {?sk ?sv &amp; ?m-k} &amp; ?m-in}
                {?sk ?m-ko &amp; ?m-out}]
               [{?k ?m-k &amp; ?m-in}
                {?sk {?k ?sv &amp; ?m-ko} &amp; ?m-out}]

               [{?k {?sk ?sv &amp; ?m-k} &amp; ?m-in}
                ?m-out]
               [{?k ?m-k &amp; ?m-in}
                {?sk {?k ?sv} &amp; ?m-out}]

               [_ ?m-out]
               ?m-out))
      init [{:a {:b 0.5 :c 0.5}
             :b {:c 1}
             :c {:a 1}}
            {}]]
  (-&gt; init
      step ;; =&gt; [{:b {:c 1}, :c {:a 1}, :a {:c 0.5}} {:b {:a 0.5}}]
      step ;; =&gt; [{:c {:a 1}, :a {:c 0.5}, :b {}} {:b {:a 0.5}, :c {:b 1}}]
      step ;; =&gt; [{:c {:a 1}, :b {}, :a {}} {:b {:a 0.5}, :c {:b 1, :a 0.5}}]
      step ;; =&gt; [{:b {}, :a {}, :c {}} {:b {:a 0.5}, :c {:b 1, :a 0.5}, :a {:c 1}}]
      step))
;; =&gt;
{:b {:c 0.5, :a 0.5},
 :c {:a 0.5},
 :a {:c 1}}</pre>
</z><z id="t1649102169" t="noprompt The second case can be handled in the first case with m/or and m/let : (m/rewrite [{:a {:b 0.5 :c 0.5} :b {:c 1} :c {:a 1}} {}] [{?k {?sk ?sv &amp; ?m-k} &amp; ?m-in} (m/or {?sk ?m-ko &amp; ?m-out} (m/let [?m-ko {}] ?m-out))] (m/cata [{?k ?m-k &amp; ?m-in} {?sk {?k ?sv &amp; ?m-ko} &amp; ?m-out}]) [_ ?m-out] ?m-out) ;; =&gt; {:b {:a 0.5}, :a {:c 1}, :c {:b 1, :a 0.5}} "><y>#</y><d>2022-04-04</d><h>19:56</h><r>noprompt</r>The second case can be handled in the first case with  <code>m/or</code> and <code>m/let</code>:
<pre>(m/rewrite [{:a {:b 0.5 :c 0.5}
             :b {:c 1}
             :c {:a 1}}
            {}]
  [{?k {?sk ?sv &amp; ?m-k} &amp; ?m-in}
   (m/or {?sk ?m-ko &amp; ?m-out}
         (m/let [?m-ko {}] ?m-out))]
  (m/cata [{?k ?m-k &amp; ?m-in}
           {?sk {?k ?sv &amp; ?m-ko} &amp; ?m-out}])

  [_ ?m-out]
  ?m-out)
;; =&gt;
{:b {:a 0.5}, :a {:c 1}, :c {:b 1, :a 0.5}}</pre>
</z><z id="t1649102205" t="noprompt This is to demonstrate that you can do this kind of thing but not necessarily that you should do this kind of thing. 🙂"><y>#</y><d>2022-04-04</d><h>19:56</h><r>noprompt</r>This is to demonstrate that you can do this kind of thing but not necessarily that you should do this kind of thing. <b>🙂</b></z><z id="t1649102300" t="noprompt Find a balance that works for you!"><y>#</y><d>2022-04-04</d><h>19:58</h><r>noprompt</r>Find a balance that works for you!</z><z id="t1649087965" t="noprompt [:attrs {:href &quot;/_/_/users/UA7E6DU04&quot;}] search is for finding all possible solutions, find is for finding one (or none). The reason the search returns is ([:a] [:b]) is because it there are two solutions and !sources is a singleton vector where !sources matched once for each of the solutions. m/scan is sugar for (m/seqable &amp; _ &lt;patterns ...&gt; &amp; _) The &amp; _ on either side of &lt;patterns ...&gt; is the flexible, ambiguous space and &lt;patterns ...&gt; is what is being matched."><y>#</y><d>2022-04-04</d><h>15:59</h><w>noprompt</w><a>@meditans</a> <code>search</code> is for finding all possible solutions, <code>find</code> is for finding one (or none). The reason the <code>search</code> returns is <code>([:a] [:b])</code> is because it there are two solutions and <code>!sources</code> is a singleton vector where <code>!sources</code> matched once for each of the solutions. <code>m/scan</code> is sugar for
<pre>(m/seqable &amp; _ &lt;patterns ...&gt; &amp; _)</pre>
The <code>&amp; _</code> on either side of <code>&lt;patterns ...&gt;</code> is the flexible, ambiguous space and <code>&lt;patterns ...&gt;</code> is what is being matched.</z><z id="t1649088060" t="noprompt (m/search [1 2 3 4 5 6] (m/scan (m/pred number? !number)) !number) ;; =&gt; ([1] [2] [3] [4] [5] [6]) "><y>#</y><d>2022-04-04</d><h>16:01</h><w>noprompt</w><pre>(m/search [1 2 3 4 5 6]
  (m/scan (m/pred number? !number))
  !number)
;; =&gt;
([1] [2] [3] [4] [5] [6])</pre>
</z><z id="t1649254790" t="jgdavey Looking through the logs for an elegant to pull up (simplify) nested boolean logic. For example, a program like this: (and aa (and bb cc) dd (or ee (and ff)) would simplify to: (and aa bb cc dd (or ee ff))"><y>#</y><d>2022-04-06</d><h>14:19</h><w>jgdavey</w>Looking through the logs for an elegant to pull up (simplify) nested boolean logic. For example, a program like this:
<pre>(and aa (and bb cc) dd (or ee (and ff))</pre>
would simplify to:
<pre>(and aa bb cc dd (or ee ff))</pre></z><z id="t1649256146" t="jgdavey (m/rewrite program ;; single arg and/or unnest ((m/or and or) ?single-arg) ?single-arg ;; pull up nested ands, recursively (and . (m/or (m/cata (and . !arg ...)) (m/cata !arg)) ...) (and . !arg ...) ;; recurse ((m/cata !x) ...) (!x ...) ;; stop ?x ?x) Maybe something like this? ^"><y>#</y><d>2022-04-06</d><h>14:42</h><w>jgdavey</w><pre>(m/rewrite
    program

    ;; single arg and/or unnest
    ((m/or and or) ?single-arg)
    ?single-arg

    ;; pull up nested ands, recursively
    (and . (m/or (m/cata (and . !arg ...)) (m/cata !arg)) ...)
    (and . !arg ...)

    ;; recurse
    ((m/cata !x) ...)
    (!x ...)

    ;; stop
    ?x ?x)</pre>
Maybe something like this? ^</z><z id="t1649256501" t="Jimmy Miller Something like that could probably work. When I’ve made logic simplifiers in the past, I always followed a structure like this. Made it nice and explicit what the rules for simplification were imo. (defn reduce-logic [prop] (m/rewrite prop (or true ?x) true (or ?x true) true (or false ?x) ?x (or ?x false) ?x ?x ?x)) (defn recursive-reduce [prop] (m/match prop (?op ?x ?y) (reduce-logic (list ?op (recursive-reduce ?x) (recursive-reduce ?y))) (?op ?x) (reduce-logic (list ?op (recursive-reduce ?x))) ?x ?x)) (recursive-reduce &apos;(or true true)) (recursive-reduce &apos;(or true x)) (recursive-reduce &apos;(or false x)) (recursive-reduce &apos;(or (or (or false false) x) false)) (recursive-reduce &apos;(or (or (or true false) x) false))"><y>#</y><d>2022-04-06</d><h>14:48</h><w>Jimmy Miller</w>Something like that could probably work. When I’ve made logic simplifiers in the past, I always followed a structure like this. Made it nice and explicit what the rules for simplification were imo.

<pre>(defn reduce-logic [prop]
  (m/rewrite prop
    (or true ?x) true
    (or ?x true) true
    (or false ?x) ?x
    (or ?x false) ?x
    ?x ?x))

(defn recursive-reduce [prop]
  (m/match prop
    (?op ?x ?y) (reduce-logic (list ?op (recursive-reduce ?x) (recursive-reduce ?y)))
    (?op ?x) (reduce-logic (list ?op (recursive-reduce ?x)))
    ?x ?x))

(recursive-reduce &apos;(or true true))
(recursive-reduce &apos;(or true x))
(recursive-reduce &apos;(or false x))
(recursive-reduce &apos;(or (or (or false false) x) false))
(recursive-reduce &apos;(or (or (or true false) x) false))</pre></z><z id="t1649256608" t="Jimmy Miller I have some haskell code that uses this exact structure, just with more rules https://github.com/jimmyhmiller/PlayGround/blob/master/logic.hs"><y>#</y><d>2022-04-06</d><h>14:50</h><r>Jimmy Miller</r>I have some haskell code that uses this exact structure, just with more rules <a href="https://github.com/jimmyhmiller/PlayGround/blob/master/logic.hs" target="_blank">https://github.com/jimmyhmiller/PlayGround/blob/master/logic.hs</a></z><z id="t1649256603" t="jgdavey Oh, nice, I dig the explicit recursion. Seems easy to follow"><y>#</y><d>2022-04-06</d><h>14:50</h><w>jgdavey</w>Oh, nice, I dig the explicit recursion. Seems easy to follow</z><z id="t1649256677" t="Jimmy Miller Yeah, that is always the tricky bit is not infinite looping. This structure prevents you from having to think about that. In, fact I actually have an unnecessary cata. Let me remove that"><y>#</y><d>2022-04-06</d><h>14:51</h><w>Jimmy Miller</w>Yeah, that is always the tricky bit is not infinite looping. This structure prevents you from having to think about that.  In, fact I actually have an unnecessary cata. Let me remove that</z><z id="t1649256728" t="Jimmy Miller Yeah, so everything in reduce-logic does not recurse at all. It is just the basic rules for simplification."><y>#</y><d>2022-04-06</d><h>14:52</h><w>Jimmy Miller</w>Yeah, so everything in reduce-logic does not recurse at all. It is just the basic rules for simplification.</z><z id="t1649332264" t="Carlo I was taking a look at: (macroexpand &apos;(meander/search seafloor {[?i ?j] {:type \v} [(meander/app #(dec-mod height %) ?i) ?j] {:type \.}} [?i ?j])) and the behavior is quadratic because we are generating two nested calls to meander.match.runtime.epsilon/map-k-permutations-with-unselected . It seems this isn&apos;t strictly needed because the second pattern in the map is completely determined from the first one. Is this just an optimization that has not yet been done, or are there other problems that push us toward this expansion?"><y>#</y><d>2022-04-07</d><h>11:51</h><w>Carlo</w>I was taking a look at:
<pre>(macroexpand &apos;(meander/search
               seafloor
               {[?i                                   ?j] {:type \v}
                [(meander/app #(dec-mod height %) ?i) ?j] {:type \.}}
               [?i ?j]))</pre>
and the behavior is quadratic because we are generating two nested calls to <code>meander.match.runtime.epsilon/map-k-permutations-with-unselected</code>. It seems this isn&apos;t strictly needed because the second pattern in the map is completely determined from the first one. Is this just an optimization that has not yet been done, or are there other problems that push us toward this expansion?</z><z id="t1649349853" t="noprompt &gt; Is this just an optimization that has not yet been done It is indeed."><y>#</y><d>2022-04-07</d><h>16:44</h><w>noprompt</w>&gt; Is this just an optimization that has not yet been done
It is indeed.</z><z id="t1649351771" t="noprompt I guess this is a good time to check in with the community and let everyone know what’s been up. People who have been in contact with me personally can ignore this. Around June of last year I started burning out on coding. Between some personal health issues, frustrations I was having at work, and trying to work on meander.zeta in the face of existing issues with meander.epsilon , I totally ran out of steam a few months ago and then completely hit my limit about six weeks ago. Since then I’ve been in a “recovery mode” of sorts but the good news is that I’m beginning to feel better. Even better news is that a couple people (who I won’t name personally) have agreed to try and help me move the project forward. This is great because, hopefully, moving forward I won’t be the only person to know the internals of the project, the core concepts, etc. The main thing everyone here needs to know is that I’m still committed to the project (specifically meander.zeta ). I know that meander.epsilon has internal issues/complexity, that there are bugs, and doesn’t always generate the best code (these issue affect me too!). So, please try and bear with the state of things a bit longer. 🙂"><y>#</y><d>2022-04-07</d><h>17:16</h><w>noprompt</w>I guess this is a good time to check in with the community and let everyone know what’s been up. People who have been in contact with me personally can ignore this.

Around June of last year I started burning out on coding. Between some personal health issues, frustrations I was having at work, and trying to work on <code>meander.zeta</code> in the face of existing issues with <code>meander.epsilon</code> , I totally ran out of steam a few months ago and then completely hit my limit about six weeks ago. Since then I’ve been in a “recovery mode” of sorts but the good news is that I’m beginning to feel better.

Even better news is that a couple people (who I won’t name personally) have agreed to try and help me move the project forward. This is great because, hopefully, moving forward I won’t be the only person to know the internals of the project, the core concepts, etc.

The main thing everyone here needs to know is that I’m still committed to the project (specifically <code>meander.zeta</code> ). I know that <code>meander.epsilon</code> has internal issues/complexity, that there are bugs, and doesn’t always generate the best code (these issue affect me too!).

So, please try and bear with the state of things a bit longer. <b>🙂</b></z><z id="t1649353097" t="Carlo These code issues aren&apos;t at all a problem - I&apos;m grateful that this project exists in the first place; I just reported because I found meander interesting enough to poke at the internals ☺️ Hope you continue to recover :hugging_face:"><y>#</y><d>2022-04-07</d><h>17:38</h><r>Carlo</r>These code issues aren&apos;t at all a problem - I&apos;m grateful that this project exists in the first place; I just reported because I found meander interesting enough to poke at the internals <b>☺️</b> Hope you continue to recover  <b>:hugging_face:</b></z><z id="t1649354436" t="noprompt [:attrs {:href &quot;/_/_/users/UA7E6DU04&quot;}] I wasn’t directing this at you. 😄 Your question just prompted me to take a moment and let people know where things are. I try to stay in touch with everyone here and keep people posted because I appreciate all of the people that use this library and have supported it over the years. 👍"><y>#</y><d>2022-04-07</d><h>18:00</h><r>noprompt</r><a>@UA7E6DU04</a> I wasn’t directing this at you. <b>😄</b>  Your question just prompted me to take a moment and let people know where things are. I try to stay in touch with everyone here and keep people posted because I appreciate all of the people that use this library and have supported it over the years. <b>👍</b></z><z id="t1649362500" t="Linus Ericsson Your health is much more important than some files of source code on GitHub."><y>#</y><d>2022-04-07</d><h>20:15</h><r>Linus Ericsson</r>Your health is much more important than some files of source code on GitHub.</z><z id="t1649366351" t="noprompt Thank you!"><y>#</y><d>2022-04-07</d><h>21:19</h><r>noprompt</r>Thank you!</z><z id="t1649501721" t="lvh Hey! Thanks so much for meander. Please take care of yourself! :hugging_face: "><y>#</y><d>2022-04-09</d><h>10:55</h><r>lvh</r>Hey! Thanks so much for meander. Please take care of yourself! <b>:hugging_face:</b> </z><z id="t1649450064" t="Augustus Is there a way in meander to search a deeply nested map for all occurrences of a particular keyword?"><y>#</y><d>2022-04-08</d><h>20:34</h><w>Augustus</w>Is there a way in meander to search a deeply nested map for all occurrences of a particular keyword?</z><z id="t1649456067" t="noprompt You can use m/$ for this kind of thing."><y>#</y><d>2022-04-08</d><h>22:14</h><r>noprompt</r>You can use <code>m/$</code> for this kind of thing.</z><z id="t1649456255" t="noprompt https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#subtree-search-"><y>#</y><d>2022-04-08</d><h>22:17</h><r>noprompt</r><a href="https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#subtree-search-" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#subtree-search-</a></z><z id="t1649524198" t="Augustus I hadn&apos;t seen that one thank you"><y>#</y><d>2022-04-09</d><h>17:09</h><r>Augustus</r>I hadn&apos;t seen that one thank you</z><z id="t1650568075" t="noprompt Hi everyone. I wanted to follow up with the previous post from two weeks ago. As I stated at the time I was beginning to feel better and, so far, this trend has continued with commits to zeta branch happening more frequently but at a steady, maintainable pace."><y>#</y><d>2022-04-21</d><h>19:07</h><w>noprompt</w>Hi everyone. I wanted to follow up with the previous post from two weeks ago. As I stated at the time I was beginning to feel better and, so far, this trend has continued with commits to <code>zeta</code> branch happening more frequently but at a steady, maintainable pace.</z><z id="t1651238366" t="markaddleman I just discovered https://jimmyhmiller.github.io/meander-rewriting - very cool intro to term rewriting. Thanks!"><y>#</y><d>2022-04-29</d><h>13:19</h><w>markaddleman</w>I just discovered <a href="https://jimmyhmiller.github.io/meander-rewriting" target="_blank">https://jimmyhmiller.github.io/meander-rewriting</a> - very cool intro to term rewriting.  Thanks!</z><z id="t1651238451" t="Jimmy Miller Glad you liked it :)"><y>#</y><d>2022-04-29</d><h>13:20</h><r>Jimmy Miller</r>Glad you liked it :)</z><z id="t1651238726" t="markaddleman Term rewriting was part of my coursework 20+ years ago. It didn&apos;t sink in at the time because I had nothing practical to attach it to in my head. Now, it&apos;s a lot easier for me to see how my projects can benefit from it and I&apos;m happy to get your tutorials"><y>#</y><d>2022-04-29</d><h>13:25</h><r>markaddleman</r>Term rewriting was part of my coursework 20+ years ago.  It didn&apos;t sink in at the time because I had nothing practical to attach it to in my head.  Now, it&apos;s a lot easier for me to see how my projects can benefit from it and I&apos;m happy to get your tutorials</z><z id="t1651601489" t="wilkerlucio hello folks, I have a meander puzzle I&apos;m trying to solve and hope you can me figure it 🙂 this is what I have now: (m/search [1 2 true 3 &quot;foo&quot; &quot;bar&quot; 4 5 &quot;not after thing&quot; 6 true 34 &quot;more&quot; &quot;text&quot; &quot;thing&quot; 4 5] [_ ... true _ . (m/pred string? !n) ... . _ ...] !n)"><y>#</y><d>2022-05-03</d><h>18:11</h><w>wilkerlucio</w>hello folks, I have a meander puzzle I&apos;m trying to solve and hope you can me figure it <b>🙂</b>

this is what I have now:
<pre>(m/search
    [1
     2
     true
     3
     &quot;foo&quot;
     &quot;bar&quot;
     4
     5
     &quot;not after thing&quot;
     6
     true
     34
     &quot;more&quot;
     &quot;text&quot;
     &quot;thing&quot;
     4
     5]
    
    [_ ... true _ . (m/pred string? !n) ... . _ ...]
    !n)</pre></z><z id="t1651601569" t="wilkerlucio so, what I&apos;m trying to extract here are the strings, that occur after a true entry and skipping the item right after it"><y>#</y><d>2022-05-03</d><h>18:12</h><r>wilkerlucio</r>so, what I&apos;m trying to extract here are the strings, that occur after a <code>true</code> entry and skipping the item right after it</z><z id="t1651601576" t="wilkerlucio current result: =&gt; ([] [&quot;foo&quot;] [&quot;foo&quot; &quot;bar&quot;] [] [&quot;more&quot;] [&quot;more&quot; &quot;text&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;])"><y>#</y><d>2022-05-03</d><h>18:12</h><r>wilkerlucio</r>current result:
<code>=&gt; ([] [&quot;foo&quot;] [&quot;foo&quot; &quot;bar&quot;] [] [&quot;more&quot;] [&quot;more&quot; &quot;text&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;])</code></z><z id="t1651601611" t="wilkerlucio the string &quot;not after thing&quot; should not match because it doesn&apos;t fits in the true + any criteria"><y>#</y><d>2022-05-03</d><h>18:13</h><r>wilkerlucio</r>the string <code>&quot;not after thing&quot;</code> should not match because it doesn&apos;t fits in the <code>true + any</code> criteria</z><z id="t1651601639" t="wilkerlucio my target goal here is to have: =&gt; ([&quot;foo&quot; &quot;bar&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;])"><y>#</y><d>2022-05-03</d><h>18:13</h><r>wilkerlucio</r>my target goal here is to have:
<code>=&gt; ([&quot;foo&quot; &quot;bar&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;])</code></z><z id="t1651601647" t="wilkerlucio how would you guys go about this case?"><y>#</y><d>2022-05-03</d><h>18:14</h><r>wilkerlucio</r>how would you guys go about this case?</z><z id="t1651603006" t="Danny Isn’t search supposed to find multiple instances of the given pattern? Try find?"><y>#</y><d>2022-05-03</d><h>18:36</h><r>Danny</r>Isn’t search supposed to find multiple instances of the given pattern?
Try find?</z><z id="t1651603024" t="wilkerlucio but I want multiple instances of the thing"><y>#</y><d>2022-05-03</d><h>18:37</h><r>wilkerlucio</r>but I want multiple instances of the thing</z><z id="t1651603039" t="wilkerlucio the pattern happens multiple times in the sequence, and I want all of them"><y>#</y><d>2022-05-03</d><h>18:37</h><r>wilkerlucio</r>the pattern happens multiple times in the sequence, and I want all of them</z><z id="t1651603041" t="Danny ah"><y>#</y><d>2022-05-03</d><h>18:37</h><r>Danny</r>ah</z><z id="t1651603298" t="Danny Why do you have string? !n) ... . _ ...] when you only want to drop the item after true if I understand correctly?"><y>#</y><d>2022-05-03</d><h>18:41</h><r>Danny</r>Why do you have <code>string? !n) ... . _ ...]</code> when you only want to drop the item after <code>true</code> if I understand correctly?</z><z id="t1651603330" t="wilkerlucio I want to drop 1 line after the true , and get all the items that are strings after that, a non-string should stop the capture of that group"><y>#</y><d>2022-05-03</d><h>18:42</h><r>wilkerlucio</r>I want to drop 1 line after the <code>true</code>, and get all the items that are strings after that, a non-string should stop the capture of that group</z><z id="t1651603387" t="Danny but a non string won’t match pred string? what’s the . _ for after the pred?"><y>#</y><d>2022-05-03</d><h>18:43</h><r>Danny</r>but a non string won’t match <code>pred string?</code> what’s the <code>. _</code> for after the pred?</z><z id="t1651603402" t="wilkerlucio my real case is some text processing that I&apos;m doing (from PDF&apos;s, which are very messy :P), so I&apos;m looking for a start condition to find something (the true is an example here), then I have to skip some lines, start grabbing all the items that match a condition in sequence, stop, and look for that pattern down again, makes sense?"><y>#</y><d>2022-05-03</d><h>18:43</h><r>wilkerlucio</r>my real case is some text processing that I&apos;m doing (from PDF&apos;s, which are very messy :P), so I&apos;m looking for a start condition to find something (the <code>true</code> is an example here), then I have to skip some lines, start grabbing all the items that match a condition in sequence, stop, and look for that pattern down again, makes sense?</z><z id="t1651603450" t="Danny Uhg PDFs … &lt;ptsd dog gif/&gt;"><y>#</y><d>2022-05-03</d><h>18:44</h><r>Danny</r>Uhg PDFs … &lt;ptsd dog gif/&gt;</z><z id="t1651603450" t="wilkerlucio . _ after the pred is to allow for extra items after, the . partitions it, and _ ... allow for other things after my match"><y>#</y><d>2022-05-03</d><h>18:44</h><r>wilkerlucio</r><code>. _</code> after the pred is to allow for extra items after, the <code>.</code> partitions it, and <code>_ ...</code> allow for other things after my match</z><z id="t1651603533" t="Danny Just wondering because your current results look “exploded”"><y>#</y><d>2022-05-03</d><h>18:45</h><r>Danny</r>Just wondering because your current results look “exploded”</z><z id="t1651603569" t="wilkerlucio yeah, I dont fully understand what I&apos;m doing, but this is the best aproximation of what I need that I could figure 😛"><y>#</y><d>2022-05-03</d><h>18:46</h><r>wilkerlucio</r>yeah, I dont fully understand what I&apos;m doing, but this is the best aproximation of what I need that I could figure <b>😛</b></z><z id="t1651603581" t="wilkerlucio removing the . _ .... results in nothing matching"><y>#</y><d>2022-05-03</d><h>18:46</h><r>wilkerlucio</r>removing the <code>. _ ....</code> results in nothing matching</z><z id="t1651603884" t="Danny &gt; The . operator, read as “partition”, partitions the collection into two parts: left and right. This operator is used primarily to delimit the start of a variable length subsequence. It is important to note that both ... and ..n act as partition operators as well. "><y>#</y><d>2022-05-03</d><h>18:51</h><r>Danny</r>&gt; The <code>.</code> operator, read as “partition”, partitions the collection into two parts: left and right. This operator is used primarily to delimit the start of a variable length subsequence. It is important to note that both <code>...</code> and <code>..n</code> act as partition operators as well.
</z><z id="t1651603889" t="Danny Do you even need ... ?"><y>#</y><d>2022-05-03</d><h>18:51</h><r>Danny</r>Do you even need <code>...</code> ?</z><z id="t1651603893" t="Danny (I’m a noob)"><y>#</y><d>2022-05-03</d><h>18:51</h><r>Danny</r>(I’m a noob)</z><z id="t1651604029" t="Danny ..1 should probably filter out the empty matches"><y>#</y><d>2022-05-03</d><h>18:53</h><r>Danny</r>..1 should probably filter out the empty matches</z><z id="t1651604591" t="wilkerlucio which of the ... ?"><y>#</y><d>2022-05-03</d><h>19:03</h><r>wilkerlucio</r>which of the <code>...</code>?</z><z id="t1651604602" t="wilkerlucio ..1 means 1 repetition"><y>#</y><d>2022-05-03</d><h>19:03</h><r>wilkerlucio</r><code>..1</code> means 1 repetition</z><z id="t1651604616" t="wilkerlucio (so its same as not using it at all :P)"><y>#</y><d>2022-05-03</d><h>19:03</h><r>wilkerlucio</r>(so its same as not using it at all :P)</z><z id="t1651604630" t="Danny Docs say at least 1"><y>#</y><d>2022-05-03</d><h>19:03</h><r>Danny</r>Docs say at least 1</z><z id="t1651604639" t="wilkerlucio ah, yeah, zero could match too"><y>#</y><d>2022-05-03</d><h>19:03</h><r>wilkerlucio</r>ah, yeah, zero could match too</z><z id="t1651604661" t="wilkerlucio you can play with my example if you like to try a bit, but in my tests here, removing any of hte things breaks the match"><y>#</y><d>2022-05-03</d><h>19:04</h><r>wilkerlucio</r>you can play with my example if you like to try a bit, but in my tests here, removing any of hte things breaks the match</z><z id="t1651604687" t="Danny if you put ..1 after string pred does it keep the empty matches still?"><y>#</y><d>2022-05-03</d><h>19:04</h><r>Danny</r>if you put ..1 after string pred does it keep the empty matches still?</z><z id="t1651604697" t="Danny I need to get my hands on a repl again 😛"><y>#</y><d>2022-05-03</d><h>19:04</h><r>Danny</r>I need to get my hands on a repl again <b>😛</b></z><z id="t1651604707" t="wilkerlucio ..1 there would match at max 1 item, and I want many there"><y>#</y><d>2022-05-03</d><h>19:05</h><r>wilkerlucio</r>..1 there would match at max 1 item, and I want many there</z><z id="t1651604754" t="Danny ..1 = 1 or more things"><y>#</y><d>2022-05-03</d><h>19:05</h><r>Danny</r><code>..1</code> = 1 or more things</z><z id="t1651604769" t="Danny if not, https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#subsequences need a PR"><y>#</y><d>2022-05-03</d><h>19:06</h><r>Danny</r>if not, <a href="https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#subsequences" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#subsequences</a> need a PR</z><z id="t1651604813" t="wilkerlucio ah, you right, yeha, that&apos;s better, it removes the empty cases"><y>#</y><d>2022-05-03</d><h>19:06</h><r>wilkerlucio</r>ah, you right, yeha, that&apos;s better, it removes the empty cases</z><z id="t1651604824" t="wilkerlucio (m/search [1 2 true 3 &quot;foo&quot; &quot;bar&quot; 4 5 &quot;not after thing&quot; 6 true 34 &quot;more&quot; &quot;text&quot; &quot;thing&quot; 4 5] [_ ... true _ . (m/pred string? !n) ..1 . _ ...] !n) =&gt; ([&quot;foo&quot;] [&quot;foo&quot; &quot;bar&quot;] [&quot;more&quot;] [&quot;more&quot; &quot;text&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;])"><y>#</y><d>2022-05-03</d><h>19:07</h><r>wilkerlucio</r><pre>(m/search
    [1
     2
     true
     3
     &quot;foo&quot;
     &quot;bar&quot;
     4
     5
     &quot;not after thing&quot;
     6
     true
     34
     &quot;more&quot;
     &quot;text&quot;
     &quot;thing&quot;
     4
     5]

    [_ ... true _ . (m/pred string? !n) ..1 . _ ...]
    !n)
=&gt; ([&quot;foo&quot;] [&quot;foo&quot; &quot;bar&quot;] [&quot;more&quot;] [&quot;more&quot; &quot;text&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;])</pre></z><z id="t1651604844" t="wilkerlucio this is my though process on the current matcher: [_ ... ; allow for precedent items true _ . ; find my starting point (m/pred string? !n) ..1 . ; matches every string in sequence _ ... ; allow for successor items ]"><y>#</y><d>2022-05-03</d><h>19:07</h><r>wilkerlucio</r>this is my though process on the current matcher:
<pre>[_ ... ; allow for precedent items
 true _ . ; find my starting point
 (m/pred string? !n) ..1 . ; matches every string in sequence
 _ ... ; allow for successor items
 ]</pre></z><z id="t1651604920" t="Danny Ok now we just need to make !n greedy I guess?"><y>#</y><d>2022-05-03</d><h>19:08</h><r>Danny</r>Ok now we just need to make <code>!n</code> greedy I guess?</z><z id="t1651604980" t="wilkerlucio yeah, I also wonder if there is a completly different solution that I&apos;m just not aware of (some operator on meander that may be able to handle it)"><y>#</y><d>2022-05-03</d><h>19:09</h><r>wilkerlucio</r>yeah, I also wonder if there is a completly different solution that I&apos;m just not aware of (some operator on meander that may be able to handle it)</z><z id="t1651604994" t="Danny Did you play around with scan?"><y>#</y><d>2022-05-03</d><h>19:09</h><r>Danny</r>Did you play around with scan?</z><z id="t1651605017" t="wilkerlucio yeah, but scan is for more regular things on a sequence afaik"><y>#</y><d>2022-05-03</d><h>19:10</h><r>wilkerlucio</r>yeah, but scan is for more regular things on a sequence afaik</z><z id="t1651605381" t="wilkerlucio this works, but its quite ugly XD (-&gt;&gt; (m/search [1 true 3 &quot;a&quot; true 3 &quot;b&quot; 2 true 3 &quot;foo&quot; &quot;bar&quot; 4 5 &quot;not after thing&quot; 6 true 34 &quot;more&quot; &quot;text&quot; &quot;thing&quot; 4 5] [_ ... true _ . (m/pred string? !n) ..1 . _ ...] !n) (partition-all 2 1) (filter #(or (nil? (second %)) (&gt;= (count (first %)) (count (second %))))) (map first)) =&gt; ([&quot;a&quot;] [&quot;b&quot;] [&quot;foo&quot; &quot;bar&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;])"><y>#</y><d>2022-05-03</d><h>19:16</h><r>wilkerlucio</r>this works, but its quite ugly XD

<pre>(-&gt;&gt; (m/search
         [1
          true
          3
          &quot;a&quot;
          true
          3
          &quot;b&quot;
          2
          true
          3
          &quot;foo&quot;
          &quot;bar&quot;
          4
          5
          &quot;not after thing&quot;
          6
          true
          34
          &quot;more&quot;
          &quot;text&quot;
          &quot;thing&quot;
          4
          5]

         [_ ... true _ . (m/pred string? !n) ..1 . _ ...]
         !n)
       (partition-all 2 1)
       (filter #(or (nil? (second %))
                    (&gt;= (count (first %))
                      (count (second %)))))
       (map first))
=&gt; ([&quot;a&quot;] [&quot;b&quot;] [&quot;foo&quot; &quot;bar&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;])</pre></z><z id="t1651605502" t="Danny What would this do: (m/pred string? !n ..1)"><y>#</y><d>2022-05-03</d><h>19:18</h><r>Danny</r>What would this do: <code>(m/pred string? !n ..1)</code></z><z id="t1651605547" t="wilkerlucio moving the ..1 inside m/pred ?"><y>#</y><d>2022-05-03</d><h>19:19</h><r>wilkerlucio</r>moving the <code>..1</code> inside <code>m/pred</code>?</z><z id="t1651605562" t="wilkerlucio I think that&apos;s not valid syntax"><y>#</y><d>2022-05-03</d><h>19:19</h><r>wilkerlucio</r>I think that&apos;s not valid syntax</z><z id="t1651605579" t="Danny pred can take multiple patterns and they all must match the predicate"><y>#</y><d>2022-05-03</d><h>19:19</h><r>Danny</r>pred can take multiple patterns and they all must match the predicate</z><z id="t1651605587" t="wilkerlucio No method in multimethod &apos;compile-specialized-matrix&apos; for dispatch value: :dt+"><y>#</y><d>2022-05-03</d><h>19:19</h><r>wilkerlucio</r><pre>No method in multimethod &apos;compile-specialized-matrix&apos; for dispatch value: :dt+</pre></z><z id="t1651605604" t="Danny wew"><y>#</y><d>2022-05-03</d><h>19:20</h><r>Danny</r>wew</z><z id="t1651605624" t="Danny maybe not with ... then 😄"><y>#</y><d>2022-05-03</d><h>19:20</h><r>Danny</r>maybe not with ... then <b>😄</b></z><z id="t1651606808" t="Ben Sless This is close (m/search [1 2 true 3 &quot;foo&quot; &quot;bar&quot; 4 5 &quot;not after thing&quot; 6 true 34 &quot;more&quot; &quot;text&quot; &quot;thing&quot; 4 5] [_ ... true _ (m/pred string? !s) . (m/pred string? !s) ... _ ...] !s ) The problem is getting all intermeadiate states ([&quot;foo&quot;] [&quot;foo&quot; &quot;bar&quot;] [&quot;more&quot;] [&quot;more&quot; &quot;text&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;]) "><y>#</y><d>2022-05-03</d><h>19:40</h><r>Ben Sless</r>This is close
<pre>(m/search
  [1
   2
   true
   3
   &quot;foo&quot;
   &quot;bar&quot;
   4
   5
   &quot;not after thing&quot;
   6
   true
   34
   &quot;more&quot;
   &quot;text&quot;
   &quot;thing&quot;
   4
   5]
  [_ ... true _ (m/pred string? !s) . (m/pred string? !s) ... _ ...] !s
  )</pre>
The problem is getting all intermeadiate states
<pre>([&quot;foo&quot;] [&quot;foo&quot; &quot;bar&quot;] [&quot;more&quot;] [&quot;more&quot; &quot;text&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;])</pre>
</z><z id="t1651606847" t="wilkerlucio [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] we got the same by replace the original ... after the pred with ..1"><y>#</y><d>2022-05-03</d><h>19:40</h><r>wilkerlucio</r><a>@UK0810AQ2</a> we got the same by replace the original <code>...</code> after the <code>pred</code> with <code>..1</code></z><z id="t1651606868" t="Danny I got this far: =&gt; (m/search input [_ ... true _ (m/pred string? !n) ..1 . _ ...] !n) ([&quot;foo&quot;] [&quot;more&quot;])"><y>#</y><d>2022-05-03</d><h>19:41</h><r>Danny</r>I got this far:
<pre>=&gt; (m/search input [_ ... true _ (m/pred string? !n) ..1 . _ ...] !n)
([&quot;foo&quot;] [&quot;more&quot;])</pre></z><z id="t1651607230" t="Ben Sless This match finds only the more next thing [_ ... true _ (m/pred string? !s) . (m/pred string? !s) ... (m/pred (complement string?)) _ ...] !s"><y>#</y><d>2022-05-03</d><h>19:47</h><r>Ben Sless</r>This match finds only the more next thing
<pre>[_ ... true _ (m/pred string? !s) . (m/pred string? !s) ... (m/pred (complement string?)) _ ...] !s</pre></z><z id="t1651607587" t="Ben Sless Slightly more concise [_ ... true _ . (m/pred string? !s) ... (m/pred (complement string?)) _ ...] !s still wrong"><y>#</y><d>2022-05-03</d><h>19:53</h><r>Ben Sless</r>Slightly more concise
<pre>[_ ... true _ . (m/pred string? !s)  ... (m/pred (complement string?)) _ ...] !s</pre>
still wrong</z><z id="t1651607703" t="Ben Sless GOT IT (m/search [1 2 true 3 &quot;foo&quot; &quot;bar&quot; 4 5 &quot;not after thing&quot; 6 true 34 &quot;more&quot; &quot;text&quot; &quot;thing&quot; 4 5] [_ ... true _ . (m/pred string? !s) ... (m/pred (complement string?)) . _ ...] !s )"><y>#</y><d>2022-05-03</d><h>19:55</h><r>Ben Sless</r>GOT IT
<pre>(m/search
  [1 2 true 3 &quot;foo&quot; &quot;bar&quot; 4 5 &quot;not after thing&quot; 6 true 34 &quot;more&quot; &quot;text&quot; &quot;thing&quot; 4 5]
  [_ ... true _ . (m/pred string? !s)  ... (m/pred (complement string?)) . _ ...] !s
  )</pre></z><z id="t1651607761" t="wilkerlucio nice!"><y>#</y><d>2022-05-03</d><h>19:56</h><r>wilkerlucio</r>nice!</z><z id="t1651607781" t="wilkerlucio I think we can extract this pattern somehow in a syntax thing, to avoid writing the pred + complement pred"><y>#</y><d>2022-05-03</d><h>19:56</h><r>wilkerlucio</r>I think we can extract this pattern somehow in a syntax thing, to avoid writing the pred + complement pred</z><z id="t1651607839" t="wilkerlucio looking at this: https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#reuse-subpatterns-in-other-patterns"><y>#</y><d>2022-05-03</d><h>19:57</h><r>wilkerlucio</r>looking at this: <a href="https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#reuse-subpatterns-in-other-patterns" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#reuse-subpatterns-in-other-patterns</a></z><z id="t1651607879" t="wilkerlucio humm, but now not sure if that works, it needs to splice the thing"><y>#</y><d>2022-05-03</d><h>19:57</h><r>wilkerlucio</r>humm, but now not sure if that works, it needs to splice the thing</z><z id="t1651607889" t="Ben Sless May not need the complement"><y>#</y><d>2022-05-03</d><h>19:58</h><r>Ben Sless</r>May not need the complement</z><z id="t1651607938" t="Ben Sless Important part was judicious use of dot, which is a stop point for the regex pattern looking left"><y>#</y><d>2022-05-03</d><h>19:58</h><r>Ben Sless</r>Important part was judicious use of dot, which is a stop point for the regex pattern looking left</z><z id="t1651607965" t="Ben Sless problem is without it you get more than one success"><y>#</y><d>2022-05-03</d><h>19:59</h><r>Ben Sless</r>problem is without it you get more than one success</z><z id="t1651607987" t="Ben Sless What is this for?"><y>#</y><d>2022-05-03</d><h>19:59</h><r>Ben Sless</r>What is this for?</z><z id="t1651608044" t="wilkerlucio [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] there is a problem also when the matching is at the end of the collection, in this example it fails to get the correct results: (m/search [1 2 true 3 &quot;foo&quot; &quot;bar&quot; 4 5 &quot;not after thing&quot; 6 true 34 &quot;more&quot; &quot;text&quot; &quot;thing&quot;] [_ ... true _ . (m/pred string? !s) ... . (m/pred (complement string?)) . _ ...] !s )"><y>#</y><d>2022-05-03</d><h>20:00</h><r>wilkerlucio</r><a>@UK0810AQ2</a> there is a problem also when the matching is at the end of the collection, in this example it fails to get the correct results:
<pre>(m/search
    [1 2 true 3 &quot;foo&quot; &quot;bar&quot; 4 5 &quot;not after thing&quot; 6 true 34 &quot;more&quot; &quot;text&quot; &quot;thing&quot;]
    [_ ... true _ . (m/pred string? !s) ... . (m/pred (complement string?)) . _ ...] !s
    )</pre></z><z id="t1651608218" t="Ben Sless Fun! Try to add another pattern where the vector ends before the complement"><y>#</y><d>2022-05-03</d><h>20:03</h><r>Ben Sless</r>Fun!
Try to add another pattern where the vector ends before the complement</z><z id="t1651614424" t="Danny Basically this but how to DRY it? (m/search [1 2 true 3 &quot;foo&quot; &quot;bar&quot; 4 5 &quot;not after thing&quot; 6 true 34 &quot;more&quot; &quot;text&quot; &quot;thing&quot;] [_ ... true _ . (m/pred string? !s) ..1] !s [_ ... true _ . (m/pred string? !s) ..1 (m/pred (complement string?)) . _ ...] !s) =&gt; ([&quot;foo&quot; &quot;bar&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;])"><y>#</y><d>2022-05-03</d><h>21:47</h><r>Danny</r>Basically this but how to DRY it?

<pre>(m/search
  [1 2 true 3 &quot;foo&quot; &quot;bar&quot; 4 5 &quot;not after thing&quot; 6 true 34 &quot;more&quot; &quot;text&quot; &quot;thing&quot;]

  [_ ... true _ . (m/pred string? !s) ..1] !s
  [_ ... true _ . (m/pred string? !s) ..1 (m/pred (complement string?)) . _ ...] !s)</pre>
=&gt;
<pre>([&quot;foo&quot; &quot;bar&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;])</pre></z><z id="t1651614505" t="Danny Can’t seem to splice ~@ patterns defined with m/with"><y>#</y><d>2022-05-03</d><h>21:48</h><r>Danny</r>Can’t seem to splice <code>~@</code> patterns defined with <code>m/with</code></z><z id="t1651614539" t="Danny Seems like the regex $ (end) operator is missing"><y>#</y><d>2022-05-03</d><h>21:48</h><r>Danny</r>Seems like the regex $ (end) operator is missing</z><z id="t1651670887" t="Danny [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] 😅 ?"><y>#</y><d>2022-05-04</d><h>13:28</h><r>Danny</r><a>@U5K8NTHEZ</a> <b>😅</b> ?</z><z id="t1651790091" t="Danny https://clojurians.slack.com/archives/CFFTD7R6Z/p1651790046071399"><y>#</y><d>2022-05-05</d><h>22:34</h><r>Danny</r><a href="https://clojurians.slack.com/archives/CFFTD7R6Z/p1651790046071399" target="_blank">https://clojurians.slack.com/archives/CFFTD7R6Z/p1651790046071399</a></z><z id="t1651790101" t="Danny [:attrs {:href &quot;/_/_/users/U066U8JQJ&quot;}] 🙂"><y>#</y><d>2022-05-05</d><h>22:35</h><r>Danny</r><a>@U066U8JQJ</a> <b>🙂</b></z><z id="t1651709772" t="Danny Is meander the worlds most powerful lens? 😄 https://www.hytradboi.com/2022/cambria-schema-translations-in-distributed-systems-using-bidirectional-lenses"><y>#</y><d>2022-05-05</d><h>00:16</h><w>Danny</w>Is meander the worlds most powerful lens? <b>😄</b>
<a href="https://www.hytradboi.com/2022/cambria-schema-translations-in-distributed-systems-using-bidirectional-lenses" target="_blank">https://www.hytradboi.com/2022/cambria-schema-translations-in-distributed-systems-using-bidirectional-lenses</a></z><z id="t1651715878" t="wilkerlucio this sounds to me a lot like the work I do on Pathom, which covers the case for schema evolution, you can always make resolvers to allow both old and new names to work together 🙂 have you checked #pathom [:attrs {:href &quot;/_/_/users/U0P7M2VHR&quot;}] ?"><y>#</y><d>2022-05-05</d><h>01:57</h><r>wilkerlucio</r>this sounds to me a lot like the work I do on Pathom, which covers the case for schema evolution, you can always make resolvers to allow both old and new names to work together <b>🙂</b> have you checked #pathom <a>@U0P7M2VHR</a>?</z><z id="t1651716507" t="wilkerlucio just for fun, I re-created the Cambria todo demo using Pathom 3: https://gist.github.com/wilkerlucio/ca2628616ea8bf42e24169f02b9c30a5"><y>#</y><d>2022-05-05</d><h>02:08</h><r>wilkerlucio</r>just for fun, I re-created the Cambria todo demo using Pathom 3: <a href="https://gist.github.com/wilkerlucio/ca2628616ea8bf42e24169f02b9c30a5" target="_blank">https://gist.github.com/wilkerlucio/ca2628616ea8bf42e24169f02b9c30a5</a></z><z id="t1651724045" t="noprompt Lenses are one of those &quot;great in theory, not in practice&quot; things IMO. 🙂"><y>#</y><d>2022-05-05</d><h>04:14</h><r>noprompt</r>Lenses are one of those &quot;great in theory, not in practice&quot; things IMO. <b>🙂</b></z><z id="t1651724314" t="nivekuil specter is the clojure lens library, and indeed for me confirm pathom + meander crowds out its uses 95% of the time"><y>#</y><d>2022-05-05</d><h>04:18</h><r>nivekuil</r>specter is the clojure lens library, and indeed for me confirm pathom + meander crowds out its uses 95% of the time</z><z id="t1651724384" t="Danny This video is quite a bit different though. Bi-directional, middleware on top of an event log."><y>#</y><d>2022-05-05</d><h>04:19</h><r>Danny</r>This video is quite a bit different though.  Bi-directional, middleware on top of an event log.</z><z id="t1651724481" t="Danny Just the yaml would be so much nicer to replace with meander expression that works both directions."><y>#</y><d>2022-05-05</d><h>04:21</h><r>Danny</r>Just the yaml would be so much nicer to replace with meander expression that works both directions.</z><z id="t1651724314" t="nivekuil ￱*￱ specter is the clojure lens library, and indeed for me pathom + meander crowds out its uses 95% of the time"><y>#</y><d>2022-05-05</d><h>04:18</h><w>nivekuil</w> ￱*￱ specter is the clojure lens library, and indeed for me pathom + meander crowds out its uses 95% of the time</z><z id="t1651783994" t="Danny Is there something like [_ ... true _ . (m/pred string? !s) ..1 (m/or false $)] where $ is like regex end-of-line (end of seq/vector) in meander? I couldn’t find it 🤷"><y>#</y><d>2022-05-05</d><h>20:53</h><w>Danny</w>Is there something like <code>[_ ... true _ . (m/pred string? !s) ..1 (m/or false $)]</code>
  where <code>$</code> is like regex end-of-line (end of seq/vector) in meander?
I couldn’t find it <b>🤷</b></z><z id="t1651784053" t="Danny Basically how to match something followed by something specific, or nothing at all"><y>#</y><d>2022-05-05</d><h>20:54</h><w>Danny</w>Basically how to match something followed by something specific, or nothing at all</z><z id="t1651786674" t="noprompt The end would be [&amp; _ _END] (BTW _ is a prefix for wildcards _&lt;suffix&gt; )"><y>#</y><d>2022-05-05</d><h>21:37</h><w>noprompt</w>The end would be
<pre>[&amp; _ _END]</pre>
(BTW <code>_</code> is a prefix for wildcards <code>_&lt;suffix&gt;</code> )</z><z id="t1651786738" t="noprompt I think you are trying to say the end can be false?"><y>#</y><d>2022-05-05</d><h>21:38</h><w>noprompt</w>I think you are trying to say the end can be false?</z><z id="t1651786805" t="noprompt [&amp; _ true _ . (m/pred string? !s) ..1 &amp; (m/or [false] [])] "><y>#</y><d>2022-05-05</d><h>21:40</h><w>noprompt</w><pre>[&amp; _ true _ . (m/pred string? !s) ..1 &amp; (m/or [false] [])]</pre>
</z><z id="t1651786847" t="noprompt Because &lt;pattern&gt; in &amp; &lt;pattern&gt; is applied to the sequence"><y>#</y><d>2022-05-05</d><h>21:40</h><w>noprompt</w>Because <code>&lt;pattern&gt;</code> in <code>&amp; &lt;pattern&gt;</code> is applied to the sequence</z><z id="t1651786876" t="noprompt And, FWIW, you can use &amp; _ as a substitute for _ ..."><y>#</y><d>2022-05-05</d><h>21:41</h><w>noprompt</w>And, FWIW, you can use <code>&amp; _</code> as a substitute for <code>_ ...</code></z><z id="t1651786939" t="noprompt [&amp; _ true _ &amp; [(m/pred string? !s) ..1] &amp; (m/or [false] [])] "><y>#</y><d>2022-05-05</d><h>21:42</h><w>noprompt</w><pre>[&amp; _ true _ &amp; [(m/pred string? !s) ..1] &amp; (m/or [false] [])]</pre>
</z><z id="t1651787023" t="noprompt Some where there is a true followed by another object followed by 1 or more strings end the end of the sequence is either [false] or [] (because we consumed everything)"><y>#</y><d>2022-05-05</d><h>21:43</h><w>noprompt</w>Some where there is a <code>true</code> followed by another object followed by 1 or more strings end the end of the sequence is either <code>[false]</code> or <code>[]</code> (because we consumed everything)</z><z id="t1651787032" t="noprompt Is that correct?"><y>#</y><d>2022-05-05</d><h>21:43</h><w>noprompt</w>Is that correct?</z><z id="t1651789416" t="Danny Let me try"><y>#</y><d>2022-05-05</d><h>22:23</h><w>Danny</w>Let me try</z><z id="t1651789762" t="Danny (def input [1 2 true 3 &quot;foo&quot; &quot;bar&quot; 4 5 &quot;not after thing&quot; 6 true 34 &quot;more&quot; &quot;text&quot; &quot;thing&quot; 4 5]) (m/search input [&amp; _ true _ &amp; [(m/pred string? !s) ..1] &amp; (m/or [(m/pred (complement string?))] [])] !s) =&gt; () "><y>#</y><d>2022-05-05</d><h>22:29</h><w>Danny</w><pre>(def input [1  2 true  3 &quot;foo&quot; &quot;bar&quot;  4  5 &quot;not after thing&quot;  6  true  34 &quot;more&quot; &quot;text&quot; &quot;thing&quot;  4  5])

(m/search input [&amp; _ true _ &amp; [(m/pred string? !s) ..1] &amp; (m/or [(m/pred (complement string?))] [])] !s)

=&gt; ()</pre>
</z><z id="t1651789798" t="Danny Trying to get ([&quot;foo&quot; &quot;bar&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;])"><y>#</y><d>2022-05-05</d><h>22:29</h><w>Danny</w>Trying to get <code>([&quot;foo&quot; &quot;bar&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;])</code></z><z id="t1651790037" t="Danny Got it"><y>#</y><d>2022-05-05</d><h>22:33</h><w>Danny</w>Got it</z><z id="t1651790046" t="Danny (m/search input [&amp; _ true _ &amp; [(m/pred string? !s) ..1] &amp; (m/or [(m/pred (complement string?)) &amp; _] [])] !s) =&gt; ([&quot;foo&quot; &quot;bar&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;])"><y>#</y><d>2022-05-05</d><h>22:34</h><w>Danny</w><pre>(m/search input  [&amp; _ true _ &amp; [(m/pred string? !s) ..1] &amp; (m/or [(m/pred (complement string?)) &amp; _] [])] !s)
=&gt;
([&quot;foo&quot; &quot;bar&quot;] [&quot;more&quot; &quot;text&quot; &quot;thing&quot;])</pre></z><z id="t1651790062" t="Danny Ok so &amp; creates a new sequence of the rest, of course 😄 … nice"><y>#</y><d>2022-05-05</d><h>22:34</h><w>Danny</w>Ok so <code>&amp;</code> creates a new sequence of the rest, of course <b>😄</b> … nice</z><z id="t1651790296" t="Danny Is there any “efficiency” difference between the tail sequence matching, or “inline” matching? (m/search input [_ ... true _ . (m/pred string? !s) ..1 &amp; (m/or [(m/pred (complement string?)) . _ ...] [])] !s) also works, but I need &amp; for the m/or to work"><y>#</y><d>2022-05-05</d><h>22:38</h><w>Danny</w>Is there any “efficiency” difference between the tail sequence matching, or “inline” matching?

<pre>(m/search input  [_ ... true _ . (m/pred string? !s) ..1 &amp; (m/or [(m/pred (complement string?)) . _ ...] [])] !s)</pre>
also works, but I need <code>&amp;</code> for the <code>m/or</code> to work</z><z id="t1651801553" t="Danny [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] do you expect any performance difference? Or is the rewrite going to change everything? 😄"><y>#</y><d>2022-05-06</d><h>01:45</h><r>Danny</r><a>@U06MDAPTP</a> do you expect any performance difference?
Or is the rewrite going to change everything? <b>😄</b></z><z id="t1651848716" t="noprompt Well, the goal is to eventually exceed the current level of performance in many situations, however, at the moment I&apos;ve only been focused on building out the most basic implementation of the semantics. The basic implementation is an interpreter and I&apos;m very close to having it finished. Once that is done, work will start on optimizing that by using simplification (aka rewriting rules). After that, the then moving on to a compiler, probably doing something staged, would be next."><y>#</y><d>2022-05-06</d><h>14:51</h><r>noprompt</r>Well, the goal is to eventually exceed the current level of performance in many situations, however, at the moment I&apos;ve only been focused on building out the most basic implementation of the semantics. The basic implementation is an interpreter and I&apos;m very close to having it finished. Once that is done, work will start on optimizing that by using simplification (aka rewriting rules). After that, the then moving on to a compiler, probably doing something staged, would be next.</z><z id="t1651848914" t="noprompt The zeta-0 branch does staged compilation and produces very nice code in many situations. The problem was that the compiler was too slow to be suitable for a macro. Also, in some cases debugging was a bit difficult. I could have a suite a of passing tests that showed that all the basic parts were working correctly but I would encounter unexpected interaction behavior between those parts."><y>#</y><d>2022-05-06</d><h>14:55</h><r>noprompt</r>The <code>zeta-0</code> branch does staged compilation and produces very nice code in many situations. The problem was that the compiler was too slow to be suitable for a macro. Also, in some cases debugging was a bit difficult. I could have a suite a of passing tests that showed that all the basic parts were working correctly but I would encounter unexpected interaction behavior between those parts.</z><z id="t1651849139" t="noprompt So now, I&apos;m starting from &quot;dumb&quot;."><y>#</y><d>2022-05-06</d><h>14:58</h><r>noprompt</r>So now, I&apos;m starting from &quot;dumb&quot;.</z><z id="t1651790598" t="Danny Well this is good to know! user=&gt; (m/search (vec &quot;ayo nopromptz&quot;) [!first &amp; _ !last] [!first !last]) ([[\a] [\z]])"><y>#</y><d>2022-05-05</d><h>22:43</h><w>Danny</w>Well this is good to know!
<pre>user=&gt; (m/search (vec &quot;ayo nopromptz&quot;) [!first &amp; _ !last] [!first !last])

([[\a] [\z]])</pre></z><z id="t1651790891" t="Danny I don’t really get it yet though: (m/search (vec &quot;ayo nopromptz&quot;) [?first &amp; [_ ..1 ?last] ?last2] [?first ?last ?last2]) ([\a \t \z])"><y>#</y><d>2022-05-05</d><h>22:48</h><w>Danny</w>I don’t really get it yet though:
<pre>(m/search (vec &quot;ayo nopromptz&quot;) [?first &amp; [_ ..1 ?last] ?last2] [?first ?last ?last2])

([\a \t \z])</pre></z><z id="t1651790948" t="Danny So the first vector directly after &amp; can match, and then more can follow outside the vector that basically terminates the in-vector match earlier 🤯 (because ?last becomes \t and not \z )"><y>#</y><d>2022-05-05</d><h>22:49</h><w>Danny</w>So the first vector directly after &amp; can match, and then more can follow outside the vector that basically terminates the in-vector match earlier <b>🤯</b> (because <code>?last</code> becomes <code>\t</code> and not <code>\z</code> )</z><z id="t1651791123" t="Danny This even more confusing user=&gt; (m/search (vec &quot;ayo nopromptz&quot;) [?first &amp; [_ ..1 \y \o \space \n \o \p \r \o \m \p ?last] ?last2] [?first ?last ?last2]) ([\a \t \z]) but user=&gt; (m/search (vec &quot;ayo nopromptz&quot;) [?first &amp; [_ ... \a \y \o \space \n \o \p \r \o \m \p ?last] ?last2] [?first ?last ?last2]) nil "><y>#</y><d>2022-05-05</d><h>22:52</h><r>Danny</r>This even more confusing
<pre>user=&gt; (m/search (vec &quot;ayo nopromptz&quot;) [?first &amp; [_ ..1 \y \o \space \n \o \p \r \o \m \p ?last] ?last2] [?first ?last ?last2])

([\a \t \z])</pre>
but
<pre>user=&gt; (m/search (vec &quot;ayo nopromptz&quot;) [?first &amp; [_ ... \a \y \o \space \n \o \p \r \o \m \p ?last] ?last2] [?first ?last ?last2])

nil</pre>
</z><z id="t1651791237" t="Danny a is captured in ?first but then _ ..1 still matches! But when a is captured in ?first it’s not available in &amp; [_ ... \a \y \o"><y>#</y><d>2022-05-05</d><h>22:53</h><r>Danny</r><code>a</code> is captured in <code>?first</code> but then <code>_ ..1</code> still matches!

But when <code>a</code> is captured in <code>?first</code> it’s not available in <code>&amp; [_ ... \a \y \o</code></z><z id="t1651791302" t="Danny What character (?) is the _ in [_ ..1 \y \o ?"><y>#</y><d>2022-05-05</d><h>22:55</h><r>Danny</r>What character (?) is the <code>_</code>  in <code>[_ ..1 \y \o</code> ?</z><z id="t1651791530" t="Danny Seems like a bug (m/search (vec &quot;ayo nopromptz&quot;) [?first &amp; [_ ..1337 \y \o \space \n \o \p \r \o \m \p ?last] ?last2] [?first ?last ?last2]) ([\a \t \z]) "><y>#</y><d>2022-05-05</d><h>22:58</h><r>Danny</r>Seems like a bug
<pre>(m/search (vec &quot;ayo nopromptz&quot;) [?first &amp; [_ ..1337 \y \o \space \n \o \p \r \o \m \p ?last] ?last2] [?first ?last ?last2])

([\a \t \z])</pre>
</z><z id="t1651791578" t="Danny String is not 1337 chars long 😄"><y>#</y><d>2022-05-05</d><h>22:59</h><r>Danny</r>String is not 1337 chars long <b>😄</b></z><z id="t1651791639" t="Danny This works pretty much like expected user=&gt; (m/search (vec &quot;ayo nopromptz&quot;) [?first &amp; [_ \y \o \space \n \o \p \r \o \m \p ?last] ?last2] [?first ?last ?last2]) nil user=&gt; (m/search (vec &quot;ayo nopromptz&quot;) [?first &amp; [\y \o \space \n \o \p \r \o \m \p ?last] ?last2] [?first ?last ?last2]) ([\a \t \z])"><y>#</y><d>2022-05-05</d><h>23:00</h><r>Danny</r>This works pretty much like expected
<pre>user=&gt; (m/search (vec &quot;ayo nopromptz&quot;) [?first &amp; [_ \y \o \space \n \o \p \r \o \m \p ?last] ?last2] [?first ?last ?last2])
nil
user=&gt; (m/search (vec &quot;ayo nopromptz&quot;) [?first &amp; [\y \o \space \n \o \p \r \o \m \p ?last] ?last2] [?first ?last ?last2])
([\a \t \z])</pre></z><z id="t1651791736" t="Danny Can I have more than 1 group after &amp; :thinking_face: Yes! (m/search (vec &quot;ayo nopromptz&quot;) [?first &amp; [\y \o \space] &amp; [\n \o \p \r \o \m \p ?last] ?last2] [?first ?last ?last2]) =&gt; ([\a \t \z])"><y>#</y><d>2022-05-05</d><h>23:02</h><r>Danny</r>Can I have more than 1 group after &amp; <b>:thinking_face:</b>
Yes!

<pre>(m/search
  (vec &quot;ayo nopromptz&quot;)
  [?first
     &amp; [\y \o \space]
     &amp; [\n \o \p \r \o \m \p ?last]
   ?last2]
  [?first ?last ?last2])

=&gt;
([\a \t \z])</pre></z><z id="t1651793608" t="noprompt Yah. There are some bugs. I&apos;ve been slowly iterating on the next version of the library which starts from a much simpler, naïve base."><y>#</y><d>2022-05-05</d><h>23:33</h><r>noprompt</r>Yah. There are some bugs. I&apos;ve been slowly iterating on the next version of the library which starts from a much simpler, naïve base.</z><z id="t1651793715" t="Danny 🙌"><y>#</y><d>2022-05-05</d><h>23:35</h><r>Danny</r><b>🙌</b></z><z id="t1652724290" t="Gary Berger Hello struggling with something that maybe obvious but. How do I get the complement of this such that I return all records that the keyword :signedLicenseKey is present? :signedLicenseKey (m/pred nil? ?signedLicenseKey) "><y>#</y><d>2022-05-16</d><h>18:04</h><w>Gary Berger</w>Hello struggling with something that maybe obvious but. How do I get the complement of this such that I return all records that the keyword <code>:signedLicenseKey</code>is present?


<pre>:signedLicenseKey  (m/pred nil? ?signedLicenseKey)</pre>
</z><z id="t1652724959" t="Danny Have you tried :signedLicenseKey (m/pred (comp nil?) ?signedLicenseKey)"><y>#</y><d>2022-05-16</d><h>18:15</h><r>Danny</r>Have you tried
<pre>:signedLicenseKey  (m/pred (comp nil?) ?signedLicenseKey)</pre></z><z id="t1652725528" t="Gary Berger actually this does work (m/pred (complement nil?) ?signedLicenseKey)"><y>#</y><d>2022-05-16</d><h>18:25</h><r>Gary Berger</r>actually this does work
<pre>(m/pred (complement nil?) ?signedLicenseKey)</pre></z><z id="t1652725538" t="Gary Berger tks! [:attrs {:href &quot;/_/_/users/UCM3R6R7S&quot;}]"><y>#</y><d>2022-05-16</d><h>18:25</h><r>Gary Berger</r>tks! <a>@UCM3R6R7S</a></z><z id="t1652813366" t="Danny I remembered the wrong comp 😄"><y>#</y><d>2022-05-17</d><h>18:49</h><r>Danny</r>I remembered the wrong <code>comp</code> <b>😄</b></z><z id="t1652883106" t="wilkerlucio [:attrs {:href &quot;/_/_/users/U01S20S3552&quot;}] some? is the complement of nil? in Clojure, so you can also use: (m/pred some? ?signedLicenseKey)"><y>#</y><d>2022-05-18</d><h>14:11</h><r>wilkerlucio</r><a>@U01S20S3552</a> <code>some?</code> is the complement of <code>nil?</code> in Clojure, so you can also use: <code>(m/pred some? ?signedLicenseKey)</code></z><z id="t1652892555" t="noprompt You can also use (m/some ?signedLicenseKey)"><y>#</y><d>2022-05-18</d><h>16:49</h><r>noprompt</r>You can also use <code>(m/some ?signedLicenseKey)</code></z><z id="t1652758301" t="xiongtx Wondering how best to deal w/ matching on nested map data where keys are sometimes missing. This is fine: (require &apos;[meander.epsilon :as meander]) (meander/match {:foo 1} {:foo ?foo :bar ?bar} [?foo ?bar]) ;; =&gt; [1 nil] But adding a layer breaks it (meander/match {:foo 1} {:foo ?foo :bar {:baz ?baz}} [?foo ?baz]) ;; =&gt; non exhaustive pattern match I’d like the result to be [1 nil] again. Using [meander/epsilon &quot;0.0.602&quot;] ."><y>#</y><d>2022-05-17</d><h>03:31</h><w>xiongtx</w>Wondering how best to deal w/ matching on nested map data where keys are sometimes missing.

This is fine:

<pre>(require &apos;[meander.epsilon :as meander])

(meander/match {:foo 1}
  {:foo ?foo
   :bar ?bar} [?foo ?bar])
;; =&gt; [1 nil]</pre>
But adding a layer breaks it

<pre>(meander/match {:foo 1}
  {:foo ?foo
   :bar {:baz ?baz}} [?foo ?baz])
;; =&gt; non exhaustive pattern match</pre>
I’d like the result to be <code>[1 nil]</code> again.

Using <code>[meander/epsilon &quot;0.0.602&quot;]</code>.</z><z id="t1652758942" t="xiongtx I guess the problem is that nil doesn’t match a map. (meander/match nil {:foo ?foo} ?foo) ;; =&gt; non exhaustive pattern match "><y>#</y><d>2022-05-17</d><h>03:42</h><r>xiongtx</r>I guess the problem is that <code>nil</code>  doesn’t match a map.

<pre>(meander/match nil
  {:foo ?foo} ?foo)
;; =&gt; non exhaustive pattern match</pre>
</z><z id="t1652759046" t="xiongtx Would be nice to have something like: (meander/match {:foo 1} {:foo ?foo :bar (meander/optional {:baz ?baz})} [?foo ?baz]) ;; =&gt; [1 nil]"><y>#</y><d>2022-05-17</d><h>03:44</h><r>xiongtx</r>Would be nice to have something like:

<pre>(meander/match {:foo 1}
  {:foo ?foo
   :bar (meander/optional {:baz ?baz})} [?foo ?baz])
;; =&gt; [1 nil]</pre></z><z id="t1652759785" t="xiongtx I see that there’s a recipe for a “Maybe pattern”: https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#the-maybe-pattern But in my case if there are many keys beyond just :baz , all of them have to be specified in the (m/and nil ...) clause. Which is fine…but rather tedious and inelegant."><y>#</y><d>2022-05-17</d><h>03:56</h><r>xiongtx</r>I see that there’s a recipe for a “Maybe pattern”: <a href="https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#the-maybe-pattern" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#the-maybe-pattern</a>

But in my case if there are many keys beyond just <code>:baz</code>, all of them have to be specified in the <code>(m/and nil ...)</code> clause. Which is fine…but rather tedious and inelegant.</z><z id="t1652760631" t="noprompt Yes. It is not elegant. Another solution, which is also not elegant, is to use cata . (m/match {:foo 1} {:foo ?foo :bar (m/cata ?x)} [?foo ?x] {:baz (m/some ?baz)} ?baz _ nil) "><y>#</y><d>2022-05-17</d><h>04:10</h><r>noprompt</r>Yes. It is not elegant. Another solution, which is also not elegant, is to use <code>cata</code>.
<pre>(m/match {:foo 1}
  {:foo ?foo
   :bar (m/cata ?x)} [?foo ?x]

  {:baz (m/some ?baz)} ?baz

  _ nil)</pre>
</z><z id="t1652760649" t="noprompt This returns [1 nil]"><y>#</y><d>2022-05-17</d><h>04:10</h><r>noprompt</r>This returns <code>[1 nil]</code></z><z id="t1652760723" t="noprompt This also returns [1 nil] : (m/match {:foo 1} {:foo ?foo :bar (m/or {:baz ?baz} ?baz)} [?foo ?baz]) "><y>#</y><d>2022-05-17</d><h>04:12</h><r>noprompt</r>This also returns <code>[1 nil]</code>:
<pre>(m/match {:foo 1}
  {:foo ?foo
   :bar (m/or {:baz ?baz}
              ?baz)}
  [?foo ?baz])</pre>
</z><z id="t1652760867" t="xiongtx I think the last solution works if there’s only one expected key in the :bar map, but in my case there could be many…"><y>#</y><d>2022-05-17</d><h>04:14</h><r>xiongtx</r>I think the last solution works if there’s only one expected key in the <code>:bar</code> map, but in my case there could be many…</z><z id="t1652760871" t="noprompt (The (m/and nil ,,,) can be dropped because either you have a map or you don&apos;t. If you do have a map, then ?baz will bind to whatever is there. If you don&apos;t have a map then ?baz will be bound to that."><y>#</y><d>2022-05-17</d><h>04:14</h><r>noprompt</r>(The <code>(m/and nil ,,,)</code> can be dropped because either you have a map or you don&apos;t. If you do have a map, then <code>?baz</code> will bind to whatever is there. If you don&apos;t have a map then <code>?baz</code> will be bound to that.</z><z id="t1652760936" t="noprompt If there are many optional keys, then it will be a lot of m/or . FWIW this is actually the price of maps with optional keys."><y>#</y><d>2022-05-17</d><h>04:15</h><r>noprompt</r>If there are many optional keys, then it will be a lot of <code>m/or</code>. FWIW this is actually the price of maps with optional keys.</z><z id="t1652761010" t="noprompt In vanilla Clojure there&apos;s (if-some [e (find m k)] ,,,) , (get-in m [k1 k2] not-found) , (or (get m k) not-found) , etc."><y>#</y><d>2022-05-17</d><h>04:16</h><r>noprompt</r>In vanilla Clojure there&apos;s <code>(if-some [e (find m k)] ,,,)</code> , <code>(get-in m [k1 k2] not-found)</code>, <code>(or (get m k) not-found)</code>, etc.</z><z id="t1652761162" t="noprompt This is one of those things where I&apos;m open to suggestions about how it could be more elegant."><y>#</y><d>2022-05-17</d><h>04:19</h><r>noprompt</r>This is one of those things where I&apos;m open to suggestions about how it could be more elegant.</z><z id="t1652761436" t="xiongtx Dunno about the practicality of implementation but I like this syntax: https://clojurians.slack.com/archives/CFFTD7R6Z/p1652759046882109?thread_ts=1652758301.794729&amp;amp;cid=CFFTD7R6Z"><y>#</y><d>2022-05-17</d><h>04:23</h><r>xiongtx</r>Dunno about the practicality of implementation but I like this syntax: <a href="https://clojurians.slack.com/archives/CFFTD7R6Z/p1652759046882109?thread_ts=1652758301.794729&amp;amp;cid=CFFTD7R6Z" target="_blank">https://clojurians.slack.com/archives/CFFTD7R6Z/p1652759046882109?thread_ts=1652758301.794729&amp;amp;cid=CFFTD7R6Z</a></z><z id="t1652761503" t="xiongtx The meander/optional could just be a rewrite of the cookbook’s solution, where it collects all the binding vars &amp; sticks them in an (m/and nil …) ."><y>#</y><d>2022-05-17</d><h>04:25</h><r>xiongtx</r>The <code>meander/optional</code> could just be a rewrite of the cookbook’s solution, where it collects all the binding vars &amp; sticks them in an <code>(m/and nil …)</code>.</z><z id="t1652761765" t="noprompt [?foo (m/optional [:baz ?baz]) ?baz] What happens in a case like this?"><y>#</y><d>2022-05-17</d><h>04:29</h><r>noprompt</r><pre>[?foo (m/optional [:baz ?baz]) ?baz]</pre>
What happens in a case like this?</z><z id="t1652761910" t="xiongtx I’d think it’d be equivalent to [?foo (m/or (m/and nil ?baz) [:baz ?baz]) ?baz]"><y>#</y><d>2022-05-17</d><h>04:31</h><r>xiongtx</r>I’d think it’d be equivalent to

<pre>[?foo (m/or (m/and nil ?baz) [:baz ?baz]) ?baz]</pre></z><z id="t1652762345" t="noprompt (require &apos;[meander.epsilon :as m]) (require &apos;[meander.syntax.epsilon :as m.syntax]) (m/defsyntax optional [p] (if (m/match-syntax? &amp;env) (let [var-syms (map :symbol (m.syntax/variables (m.syntax/parse p)))] `(m/or ~p (m/and nil ~@var-syms))) (throw (ex-info &quot;substition not supported&quot; {:form &amp;form})))) (m/match {:foo 1} {:foo ?foo :bar (optional {:baz ?baz})} [?foo ?baz]) ;; =&gt; [1 nil]"><y>#</y><d>2022-05-17</d><h>04:39</h><r>noprompt</r><pre>(require &apos;[meander.epsilon :as m])
(require &apos;[meander.syntax.epsilon :as m.syntax])

(m/defsyntax optional [p]
  (if (m/match-syntax? &amp;env)
    (let [var-syms (map :symbol (m.syntax/variables (m.syntax/parse p)))]
      `(m/or ~p (m/and nil ~@var-syms)))
    (throw (ex-info &quot;substition not supported&quot; {:form &amp;form}))))</pre>
<pre>(m/match {:foo 1}
  {:foo ?foo
   :bar (optional {:baz ?baz})}
  [?foo ?baz])
;; =&gt;
[1 nil]</pre></z><z id="t1652762462" t="noprompt This is approximately what I would do. Maybe some more thinking on it. But you can use this in your project if it helps you and irons out some of that ugliness. 🙂"><y>#</y><d>2022-05-17</d><h>04:41</h><r>noprompt</r>This is approximately what I would do. Maybe some more thinking on it. But you can use this in your project if it helps you and irons out some of that ugliness. <b>🙂</b></z><z id="t1652763124" t="xiongtx It’s hardcoded to :baz ?baz though? Or should that be replaced w/ something?"><y>#</y><d>2022-05-17</d><h>04:52</h><r>xiongtx</r>It’s hardcoded to <code>:baz ?baz</code> though? Or should that be replaced w/ something?</z><z id="t1652766403" t="noprompt Yes, it should be replaced with p . (I fixed the code above)."><y>#</y><d>2022-05-17</d><h>05:46</h><r>noprompt</r>Yes, it should be replaced with <code>p</code>. (I fixed the code above).</z><z id="t1654696421" t="Lucy Wang I&apos;m late to the party, but this may be helpful https://github.com/noprompt/meander/pull/144/files?short_path=e88fbb5#diff-e88fbb5c0cd00327380696124537df29287c3c89a5a2395a0757548eb5b5d2f3"><y>#</y><d>2022-06-08</d><h>13:53</h><r>Lucy Wang</r>I&apos;m late to the party, but this may be helpful <a href="https://github.com/noprompt/meander/pull/144/files?short_path=e88fbb5#diff-e88fbb5c0cd00327380696124537df29287c3c89a5a2395a0757548eb5b5d2f3" target="_blank">https://github.com/noprompt/meander/pull/144/files?short_path=e88fbb5#diff-e88fbb5c0cd00327380696124537df29287c3c89a5a2395a0757548eb5b5d2f3</a></z><z id="t1656797562" t="xiongtx [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] Unfortunately optional doesn’t seem to nest: (m/match {:foo {:bar &quot;bar&quot; :baz nil}} {:foo (optional {:bar ?bar :baz (optional {:quux ?quux})})} ?quux) ;; =&gt; 1. Caused by clojure.lang.ExceptionInfo substition not supported {:form (optional {:quux ?quux})} "><y>#</y><d>2022-07-02</d><h>21:32</h><r>xiongtx</r><a>@U06MDAPTP</a> Unfortunately <code>optional</code> doesn’t seem to nest:

<pre>(m/match {:foo {:bar &quot;bar&quot;
                :baz nil}}
  {:foo (optional {:bar ?bar
                   :baz (optional {:quux ?quux})})} ?quux)

;; =&gt; 1. Caused by clojure.lang.ExceptionInfo
   substition not supported
   {:form (optional {:quux ?quux})}</pre>
</z><z id="t1656818861" t="xiongtx Also running into performance issue when using a lot of optional : https://github.com/noprompt/meander/issues/234"><y>#</y><d>2022-07-03</d><h>03:27</h><r>xiongtx</r>Also running into performance issue when using a lot of <code>optional</code> : <a href="https://github.com/noprompt/meander/issues/234" target="_blank">https://github.com/noprompt/meander/issues/234</a></z><z id="t1686345622" t="xiongtx Changing the definition of optional to the following allows nesting: (defsyntax optional [p] (if (m/match-syntax? &amp;env) (let [var-syms (map :symbol (m-syntax/variables (m-syntax/parse p)))] `(m/or ~p (m/and nil ~@var-syms))) &amp;form)) This seems to be the [pattern]( https://github.com/noprompt/meander/blob/epsilon/doc/defsyntax.md ) used by most defsyntax constructs."><y>#</y><d>2023-06-09</d><h>21:20</h><r>xiongtx</r>Changing the definition of <code>optional</code> to the following allows nesting:
<pre>(defsyntax optional [p]
  (if (m/match-syntax? &amp;env)
    (let [var-syms (map :symbol (m-syntax/variables (m-syntax/parse p)))]
      `(m/or ~p (m/and nil ~@var-syms)))
    &amp;form))</pre>
This seems to be the [pattern](<a href="https://github.com/noprompt/meander/blob/epsilon/doc/defsyntax.md" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/defsyntax.md</a>) used by most <code>defsyntax</code> constructs.</z><z id="t1652767904" t="xiongtx Just ran into the strangest bug, but only on [meander/epsilon &quot;0.0.602&quot;] (the version I was on). W/ a project containing nothing but: (ns meander-test.core (:require [meander.epsilon :as m])) (defn extract [m] (m/match m {:letters (m/or (m/and nil ?a ?b ?c ?d ?e ?f ?g ?h ?i ?j ?k ?l ?m ?n) {:a ?a :b ?b :c ?c :d ?d :e ?e :f ?f :g ?g :h ?h :i ?i :j ?j :k ?k :l ?l :m ?m :n ?n})} {:a ?a})) cider-jack-in hangs &amp; causes CPU usage to go crazy. Doesn’t happen w/ 0.0.626 ."><y>#</y><d>2022-05-17</d><h>06:11</h><w>xiongtx</w>Just ran into the strangest bug, but only on <code>[meander/epsilon &quot;0.0.602&quot;]</code>  (the version I was on).

W/ a project containing nothing but:

<pre>(ns meander-test.core
  (:require [meander.epsilon :as m]))

(defn extract
  [m]
  (m/match m
    {:letters (m/or
               (m/and nil
                      ?a
                      ?b
                      ?c
                      ?d
                      ?e
                      ?f
                      ?g
                      ?h
                      ?i
                      ?j
                      ?k
                      ?l
                      ?m
                      ?n)
               {:a ?a
                :b ?b
                :c ?c
                :d ?d
                :e ?e
                :f ?f
                :g ?g
                :h ?h
                :i ?i
                :j ?j
                :k ?k
                :l ?l
                :m ?m
                :n ?n})}
    {:a ?a}))</pre>
<code>cider-jack-in</code> hangs &amp; causes CPU usage to go crazy. Doesn’t happen w/ <code>0.0.626</code>.</z><z id="t1652768011" t="xiongtx But, if I comment out one element in the and , it works fine again! 🤯 (ns meander-test.core (:require [meander.epsilon :as m])) (defn extract [m] (m/match m {:letters (m/or (m/and nil ?a ?b ?c ?d ?e ?f ?g ?h ?i ?j ?k ?l ?m #_?n) {:a ?a :b ?b :c ?c :d ?d :e ?e :f ?f :g ?g :h ?h :i ?i :j ?j :k ?k :l ?l :m ?m :n ?n})} {:a ?a}))"><y>#</y><d>2022-05-17</d><h>06:13</h><r>xiongtx</r>But, if I comment out one element in the <code>and</code>, it works fine again! <b>🤯</b>

<pre>(ns meander-test.core
  (:require [meander.epsilon :as m]))

(defn extract
  [m]
  (m/match m
    {:letters (m/or
               (m/and nil
                      ?a
                      ?b
                      ?c
                      ?d
                      ?e
                      ?f
                      ?g
                      ?h
                      ?i
                      ?j
                      ?k
                      ?l
                      ?m
                      #_?n)
               {:a ?a
                :b ?b
                :c ?c
                :d ?d
                :e ?e
                :f ?f
                :g ?g
                :h ?h
                :i ?i
                :j ?j
                :k ?k
                :l ?l
                :m ?m
                :n ?n})}
    {:a ?a}))</pre></z><z id="t1652768041" t="xiongtx No 💡 why it does this but boy was this one a doozy to 🔨 🐛 !"><y>#</y><d>2022-05-17</d><h>06:14</h><r>xiongtx</r>No <b>💡</b> why it does this but boy was this one a doozy to <b>🔨</b> <b>🐛</b> !</z><z id="t1652835775" t="jgdavey What’s the best way to represent repetition where one sub-element in the repeated clause is the same, while the other can differ? Example: ;; would match, because of repeated :foo [:or [:= :foo 123] [:= :foo 456]] ;; would not match [:or [:= :foo 123] [:= :BAR 456]] I’m trying to do a rewrite of the first example above that would result in [:one-of :foo [123 456]] I would have thought that this would work: (m/rewrite [:or [:= :foo 123] [:= :foo 456]] [:or . [:= ?a !b] ...] [:one-of ?a [!b ...]]) But results in error “Zero or more patterns may not have references to unbound logic variables.”"><y>#</y><d>2022-05-18</d><h>01:02</h><w>jgdavey</w>What’s the best way to represent repetition where one sub-element in the repeated clause is the same, while the other can differ? Example:

<pre>;; would match, because of repeated :foo
  [:or
   [:= :foo 123]
   [:= :foo 456]]

  ;; would not match
  [:or
   [:= :foo 123]
   [:= :BAR 456]]</pre>
I’m trying to do a rewrite of the first example above that would result in <code>[:one-of :foo [123 456]]</code>


I would have thought that this would work:

<pre>(m/rewrite
  [:or
   [:= :foo 123]
   [:= :foo 456]]
  [:or . [:= ?a !b] ...]
  [:one-of ?a [!b ...]])</pre>
But results in error “Zero or more patterns may not have references to unbound logic variables.”</z><z id="t1652881317" t="jgdavey Looks like this does it: (m/rewrite [:or [:= :foo 123] [:= :foo 456]] [:or [:= ?a !b] . [:= ?a !b] ...] [:one-of ?a [!b ...]])"><y>#</y><d>2022-05-18</d><h>13:41</h><w>jgdavey</w>Looks like this does it:
<pre>(m/rewrite
    [:or
     [:= :foo 123]
     [:= :foo 456]]
    [:or [:= ?a !b] . [:= ?a !b] ...]
    [:one-of ?a [!b ...]])</pre></z><z id="t1654089213" t="Aleksander Maybe a trivial question... but how can I transform list items of a list nested in a map, eg in the sample structure below I would like to transform both val1 and all of it* items. The return should be a single top level map with nested items updated. Doing a match on each of the it* would work, but I assume there needs to be a better way to do it rather than update-in map match {:key val1 :key2 {:key3 [it1 it2 it3]}}"><y>#</y><d>2022-06-01</d><h>13:13</h><w>Aleksander</w>Maybe a trivial question... but how can I transform list items of a list nested in a map, eg in the sample structure below I would like to transform both val1 and all of it* items. The return should be a single top level map with nested items updated. Doing a <code>match</code> on each of the it* would work, but I assume there needs to be a better way to do it rather than <code>update-in</code> <code>map</code> <code>match</code>
<pre>{:key val1
 :key2 {:key3 [it1 it2 it3]}}</pre></z><z id="t1654092335" t="Richie Do you mean like this? (m/rewrite {:key &quot;val1&quot; :key2 {:key3 [&quot;it1&quot; &quot;it2&quot; &quot;it3&quot;]}} {:key ?a :key2 {:key3 [!b ...]}} {:key ?a :key2 {:key3 [(m/app string/reverse !b) ...]}}) ;; {:key &quot;val1&quot;, :key2 {:key3 [&quot;1ti&quot; &quot;2ti&quot; &quot;3ti&quot;]}} "><y>#</y><d>2022-06-01</d><h>14:05</h><r>Richie</r>Do you mean like this?
<pre>(m/rewrite {:key &quot;val1&quot;
            :key2 {:key3 [&quot;it1&quot; &quot;it2&quot; &quot;it3&quot;]}}
  {:key ?a
   :key2 {:key3 [!b ...]}}
  {:key ?a
   :key2 {:key3 [(m/app string/reverse !b) ...]}})
;; {:key &quot;val1&quot;, :key2 {:key3 [&quot;1ti&quot; &quot;2ti&quot; &quot;3ti&quot;]}}</pre>
</z><z id="t1654092450" t="Richie Maybe you mean like this: (ns scratch (:require [meander.epsilon :as m] [clojure.string :as string])) (defn my-fun [a b] {:a a :b b}) (m/rewrite {:key &quot;val1&quot; :key2 {:key3 [&quot;it1&quot; &quot;it2&quot; &quot;it3&quot;]}} {:key ?a :key2 {:key3 [!b ...]}} {:key ?a :key2 {:key3 [(m/app #(my-fun ?a %) !b) ...]}}) ;; {:key &quot;val1&quot;, :key2 {:key3 [{:a &quot;val1&quot;, :b &quot;it1&quot;} {:a &quot;val1&quot;, :b &quot;it2&quot;} {:a &quot;val1&quot;, :b &quot;it3&quot;}]}}e"><y>#</y><d>2022-06-01</d><h>14:07</h><r>Richie</r>Maybe you mean like this:
<pre>(ns scratch
  (:require [meander.epsilon :as m]
            [clojure.string :as string]))

(defn my-fun
  [a b]
  {:a a
   :b b})

(m/rewrite {:key &quot;val1&quot;
            :key2 {:key3 [&quot;it1&quot; &quot;it2&quot; &quot;it3&quot;]}}
  {:key ?a
   :key2 {:key3 [!b ...]}}
  {:key ?a
   :key2 {:key3 [(m/app #(my-fun ?a %) !b) ...]}})
;; {:key &quot;val1&quot;, :key2 {:key3 [{:a &quot;val1&quot;, :b &quot;it1&quot;} {:a &quot;val1&quot;, :b &quot;it2&quot;} {:a &quot;val1&quot;, :b &quot;it3&quot;}]}}e</pre></z><z id="t1654093995" t="Aleksander hmm, maybe using examples from specter would be easier: (specter/transform [:sites s/MAP-VALS :services s/ALL] #(meander/match ~~fairly simple map trasformation here, just structure, not using values~~))"><y>#</y><d>2022-06-01</d><h>14:33</h><r>Aleksander</r>hmm, maybe using examples from specter would be easier:

<pre>(specter/transform [:sites s/MAP-VALS :services s/ALL] #(meander/match ~~fairly simple map trasformation here, just structure, not using values~~))</pre></z><z id="t1654094030" t="Richie Can you give an example input and output?"><y>#</y><d>2022-06-01</d><h>14:33</h><r>Richie</r>Can you give an example input and output?</z><z id="t1654095106" t="Aleksander sites: site1: services: mainService: name: &quot;name1&quot; sidecar1: name: &quot;name2&quot; sidecar2: name: &quot;name3&quot; site2: services: mainService: name: &quot;name4&quot; sidecar1: name: &quot;name5&quot; sidecar2: name: &quot;name6&quot; sites: site1: httpService: name: &quot;name1&quot; sidecars: - name: &quot;name2&quot; - name: &quot;name3&quot; site2: httpService: name: &quot;name4&quot; sidecars: - name: &quot;name5&quot; - name: &quot;name6&quot; "><y>#</y><d>2022-06-01</d><h>14:51</h><r>Aleksander</r><pre>sites:
  site1:
    services:
      mainService:
        name: &quot;name1&quot;
      sidecar1:
        name: &quot;name2&quot;
      sidecar2:
        name: &quot;name3&quot;
  site2:
    services:
      mainService:
        name: &quot;name4&quot;
      sidecar1:
        name: &quot;name5&quot;
      sidecar2:
        name: &quot;name6&quot;</pre>
<pre>sites:
  site1:
     httpService:
       name: &quot;name1&quot;
     sidecars:
        - name: &quot;name2&quot;
        - name: &quot;name3&quot;
  site2: 
     httpService:
       name: &quot;name4&quot;
     sidecars:
        - name: &quot;name5&quot;
        - name: &quot;name6&quot;    </pre></z><z id="t1654095143" t="Aleksander the number/name of sites can be variable, we can&apos;t depend of them, they need to be maintained"><y>#</y><d>2022-06-01</d><h>14:52</h><r>Aleksander</r>the number/name of sites can be variable, we can&apos;t depend of them, they need to be maintained</z><z id="t1654095153" t="Aleksander same for number of sidecars"><y>#</y><d>2022-06-01</d><h>14:52</h><r>Aleksander</r>same for number of sidecars</z><z id="t1654095195" t="Aleksander out of services one has special status and is treated as main service, the rest are sidecars"><y>#</y><d>2022-06-01</d><h>14:53</h><r>Aleksander</r>out of services one has special status and is treated as main service, the rest are sidecars</z><z id="t1654095477" t="Aleksander This is still a simplified example. Right now I&apos;m tempted to have few transformations using combination of specter and meander, ie using transform to select appropriate places in the tree to update, use meanders match to do the transformation"><y>#</y><d>2022-06-01</d><h>14:57</h><r>Aleksander</r>This is still a simplified example. Right now I&apos;m tempted to have few transformations using combination of specter and meander, ie using transform to select appropriate places in the tree to update, use meanders match to do the transformation</z><z id="t1654099555" t="Richie (def ex1 {:sites {:site-one {:services {:main-service {:name &quot;s1-main&quot;} :side-car-one {:name &quot;s1-one&quot;} :side-car-two {:name &quot;s1-two&quot;}}} :site-two {:services {:main-service {:name &quot;main&quot;} :side-car-one {:name &quot;s2-one&quot;} :side-car-two {:name &quot;s2-two&quot;}}}}}) (m/rewrite ex1 {:sites (m/map-of !k {:services {:main-service !main-service &amp; (m/app seq ([_ !sidecar] ..!n))}})} {:sites (m/map-of !k {:http-service !main-service :sidecars [!sidecar ..!n]})}) ;; {:sites {:site-one {:http-service {:name &quot;s1-main&quot;} ;; :sidecars [{:name &quot;s1-one&quot;} ;; {:name &quot;s1-two&quot;}]} ;; :site-two {:http-service {:name &quot;main&quot;} ;; :sidecars [{:name &quot;s2-one&quot;} ;; {:name &quot;s2-two&quot;}]}}} "><y>#</y><d>2022-06-01</d><h>16:05</h><r>Richie</r><pre>(def ex1 {:sites {:site-one {:services {:main-service {:name &quot;s1-main&quot;}
                                        :side-car-one {:name &quot;s1-one&quot;}
                                        :side-car-two {:name &quot;s1-two&quot;}}}
                  :site-two {:services {:main-service {:name &quot;main&quot;}
                                        :side-car-one {:name &quot;s2-one&quot;}
                                        :side-car-two {:name &quot;s2-two&quot;}}}}})

(m/rewrite ex1
  {:sites (m/map-of !k {:services {:main-service !main-service
                                   &amp; (m/app seq ([_ !sidecar] ..!n))}})}
  {:sites (m/map-of !k {:http-service !main-service
                        :sidecars [!sidecar ..!n]})})

;; {:sites {:site-one {:http-service {:name &quot;s1-main&quot;}
;;                     :sidecars [{:name &quot;s1-one&quot;}
;;                                {:name &quot;s1-two&quot;}]}
;;          :site-two {:http-service {:name &quot;main&quot;}
;;                     :sidecars [{:name &quot;s2-one&quot;}
;;                                {:name &quot;s2-two&quot;}]}}}</pre>
</z><z id="t1654101377" t="Aleksander Thanks a lot! That looks near 🙂"><y>#</y><d>2022-06-01</d><h>16:36</h><r>Aleksander</r>Thanks a lot! That looks near <b>🙂</b></z><z id="t1656080643" t="Aleksander What if I wanted to extend the example with main-service having a key, eg environment that is supposed to go up one level. From being subkey of :main-service to being a sibling of :http-service (def ex1 {:sites {:site-one {:services {:main-service {:name &quot;s1-main&quot; :environment {:env-var1 &quot;env-var1&quot;}} :side-car-one {:name &quot;s1-one&quot;} :side-car-two {:name &quot;s1-two&quot;}}} :site-two {:services {:main-service {:name &quot;main&quot; :environment {:env-var2 &quot;env-var2&quot;}} :side-car-one {:name &quot;s2-one&quot;} :side-car-two {:name &quot;s2-two&quot;}}}}}) (m/rewrite ex1 {:sites (m/map-of !k {:services {:main-service !main-service &amp; (m/app seq ([_ !sidecar] ..!n))}})} {:sites (m/map-of !k {:http-service !main-service :sidecars [!sidecar ..!n]})}) ;; {:sites {:site-one {:http-service {:name &quot;s1-main&quot;} ;; :environment {:env-var1 &quot;env-var1&quot;} ;; :sidecars [{:name &quot;s1-one&quot;} ;; {:name &quot;s1-two&quot;}]} ;; :site-two {:http-service {:name &quot;main&quot;} ;; :environment {:env-var2 &quot;env-var2&quot;} ;; :sidecars [{:name &quot;s2-one&quot;} ;; {:name &quot;s2-two&quot;}]}}}"><y>#</y><d>2022-06-24</d><h>14:24</h><r>Aleksander</r>What if I wanted to extend the example with main-service having a key, eg environment that is supposed to go up one level. From being subkey of :main-service to being a sibling of :http-service
<pre>(def ex1 {:sites {:site-one {:services {:main-service {:name &quot;s1-main&quot; :environment {:env-var1 &quot;env-var1&quot;}}
                                        :side-car-one {:name &quot;s1-one&quot;}
                                        :side-car-two {:name &quot;s1-two&quot;}}}
                  :site-two {:services {:main-service {:name &quot;main&quot; :environment {:env-var2 &quot;env-var2&quot;}}
                                        :side-car-one {:name &quot;s2-one&quot;}
                                        :side-car-two {:name &quot;s2-two&quot;}}}}})

(m/rewrite ex1
  {:sites (m/map-of !k {:services {:main-service !main-service
                                   &amp; (m/app seq ([_ !sidecar] ..!n))}})}
  {:sites (m/map-of !k {:http-service !main-service
                        :sidecars [!sidecar ..!n]})})

;; {:sites {:site-one {:http-service {:name &quot;s1-main&quot;}
;;                     :environment {:env-var1 &quot;env-var1&quot;}                  
;;                     :sidecars [{:name &quot;s1-one&quot;}
;;                                {:name &quot;s1-two&quot;}]}
;;          :site-two {:http-service {:name &quot;main&quot;}
;;                     :environment {:env-var2 &quot;env-var2&quot;}
;;                     :sidecars [{:name &quot;s2-one&quot;}
;;                                {:name &quot;s2-two&quot;}]}}}</pre></z><z id="t1656881120" t="Richie"><y>#</y><d>2022-07-03</d><h>20:45</h><r>Richie</r></z><z id="t1654909064" t="Richie Why can’t I use &amp; for sets? (m/rewrite #{:one :two :three} #{:one &amp; ?rest} ?rest) gives No method in multimethod &apos;ground?&apos; for dispatch value: :amp "><y>#</y><d>2022-06-11</d><h>00:57</h><w>Richie</w>Why can’t I use <code>&amp;</code> for sets?
<pre>(m/rewrite #{:one :two :three}
  #{:one &amp; ?rest} ?rest)</pre>
gives
<pre>No method in multimethod &apos;ground?&apos; for dispatch value: :amp</pre>
</z><z id="t1654909117" t="Richie I expect it to only match if :one exists and then bind the other values except :one to ?rest ."><y>#</y><d>2022-06-11</d><h>00:58</h><r>Richie</r>I expect it to only match if <code>:one</code> exists and then bind the other values except <code>:one</code> to <code>?rest</code>.</z><z id="t1654912206" t="noprompt [:attrs {:href &quot;/_/_/users/UPD88PGNT&quot;}] You can use &amp; for sets but it is limited because it hackily use meta. #{1 2 ^&amp; ?rest} "><y>#</y><d>2022-06-11</d><h>01:50</h><r>noprompt</r><a>@UPD88PGNT</a> You can use <code>&amp;</code> for sets but it is limited because it hackily use meta.
<pre>#{1 2 ^&amp; ?rest}</pre>
</z><z id="t1654912226" t="Richie Oh…"><y>#</y><d>2022-06-11</d><h>01:50</h><r>Richie</r>Oh…</z><z id="t1654912230" t="noprompt Yah"><y>#</y><d>2022-06-11</d><h>01:50</h><r>noprompt</r>Yah</z><z id="t1654912279" t="noprompt This is because, for sets, the elements will end up unordered so there is obvious way to know what the pretzel should apply to."><y>#</y><d>2022-06-11</d><h>01:51</h><r>noprompt</r>This is because, for sets, the elements will end up unordered so there is obvious way to know what the pretzel should apply to.</z><z id="t1654912317" t="Richie If I can just remember this then I’ll be happy enough. (defn step [[left right]] (m/rewrites [left right] [(m/and #{:you} (m/app #(disj % :you) (m/app vec [!a ... ?x . !b ...]))) ?right] [[!a ... !b ...] [?x :you &amp; ?right]] [?left (m/and #{:you} (m/app #(disj % :you) (m/app vec [!a ... ?x . !b ...])))] [[?x :you &amp; ?left] [!a ... !b ...]])) (defn step [[left right]] (m/rewrites [left right] [#{:you ^&amp; (m/app vec [!a ... ?x . !b ...])} ?right] [[!a ... !b ...] [?x :you &amp; ?right]] [?left #{:you ^&amp; (m/app vec [!a ... ?x . !b ...])}] [[?x :you &amp; ?left] [!a ... !b ...]])) "><y>#</y><d>2022-06-11</d><h>01:51</h><r>Richie</r>If I can just remember this then I’ll be happy enough.
<pre>(defn step
  [[left right]]
  (m/rewrites [left right]
    [(m/and #{:you}
            (m/app #(disj % :you)
                   (m/app vec [!a ... ?x . !b ...]))) ?right]
    [[!a ... !b ...] [?x :you &amp; ?right]]

    [?left
     (m/and #{:you}
            (m/app #(disj % :you)
                   (m/app vec [!a ... ?x . !b ...])))]
    [[?x :you &amp; ?left] [!a ... !b ...]]))

(defn step
  [[left right]]
  (m/rewrites [left right]
    [#{:you ^&amp; (m/app vec [!a ... ?x . !b ...])} ?right]
    [[!a ... !b ...] [?x :you &amp; ?right]]

    [?left #{:you ^&amp; (m/app vec [!a ... ?x . !b ...])}]
    [[?x :you &amp; ?left] [!a ... !b ...]]))</pre>
</z><z id="t1654912351" t="Richie It is much shorter."><y>#</y><d>2022-06-11</d><h>01:52</h><r>Richie</r>It is much shorter.</z><z id="t1654912374" t="Richie Thanks!"><y>#</y><d>2022-06-11</d><h>01:52</h><r>Richie</r>Thanks!</z><z id="t1654912375" t="noprompt A solution to this problem would be to simply have a non-literal syntax (as is slowly being worked out on zeta but could be added to epsilon): (m.set/union (m/hash-set p1 p2 p3) ?rest) "><y>#</y><d>2022-06-11</d><h>01:52</h><r>noprompt</r>A solution to this problem would be to simply have a non-literal syntax (as is slowly being worked out on zeta but could be added to epsilon):
<pre>(m.set/union (m/hash-set p1 p2 p3) ?rest)</pre>
</z><z id="t1654912415" t="noprompt Ah, glad it worked out for you! 😅"><y>#</y><d>2022-06-11</d><h>01:53</h><r>noprompt</r>Ah, glad it worked out for you! <b>😅</b></z><z id="t1654912705" t="Richie (defn step [[left right]] (m/rewrites [left right] [#{:you ^&amp; (m/seqable !a ... ?x . !b ...)} ?right] [#{^&amp; [!a ... !b ...]} #{?x :you ^&amp; ?right}] [?left #{:you ^&amp; (m/seqable !a ... ?x . !b ...)}] [#{?x :you ^&amp; ?left} #{^&amp; [!a ... !b ...]}])) (step [#{:fox :corn :you} #{:goose}]) ;; ([#{:corn} #{:you :fox :goose}] [#{:fox} #{:you :goose :corn}]) "><y>#</y><d>2022-06-11</d><h>01:58</h><r>Richie</r><pre>(defn step
  [[left right]]
  (m/rewrites [left right]
    [#{:you ^&amp; (m/seqable !a ... ?x . !b ...)} ?right]
    [#{^&amp; [!a ... !b ...]} #{?x :you ^&amp; ?right}]

    [?left #{:you ^&amp; (m/seqable !a ... ?x . !b ...)}]
    [#{?x :you ^&amp; ?left} #{^&amp; [!a ... !b ...]}]))
(step [#{:fox :corn :you} #{:goose}])
;; ([#{:corn} #{:you :fox :goose}] [#{:fox} #{:you :goose :corn}])</pre>
</z><z id="t1654914127" t="noprompt 🙂"><y>#</y><d>2022-06-11</d><h>02:22</h><r>noprompt</r><b>🙂</b></z><z id="t1654916154" t="Richie Oh right, it actually gets cleaner than that. (defn step [[left right]] (m/rewrites [left right] [#{:you ^&amp; ?left} ?right] [?left #{:you ^&amp; ?right}] [#{:you ?x ^&amp; ?left} ?right] [?left #{?x :you ^&amp; ?right}] [?left #{:you ^&amp; ?right}] [#{:you ^&amp; ?left} ?right] [?left #{:you ?x ^&amp; ?right}] [#{?x :you ^&amp; ?left} ?right])) (step [#{:you :corn :fox} #{:goose}]) ;; ([#{:fox :corn} #{:you :goose}] [#{:corn} #{:you :fox :goose}] [#{:fox} #{:you :goose :corn}]) "><y>#</y><d>2022-06-11</d><h>02:55</h><r>Richie</r>Oh right, it actually gets cleaner than that.
<pre>(defn step
  [[left right]]
  (m/rewrites [left right]

    [#{:you ^&amp; ?left} ?right]
    [?left #{:you ^&amp; ?right}]

    [#{:you ?x ^&amp; ?left} ?right]
    [?left #{?x :you ^&amp; ?right}]

    [?left #{:you ^&amp; ?right}]
    [#{:you ^&amp; ?left} ?right]

    [?left #{:you ?x ^&amp; ?right}]
    [#{?x :you ^&amp; ?left} ?right]))

(step [#{:you :corn :fox} #{:goose}])
;; ([#{:fox :corn} #{:you :goose}] [#{:corn} #{:you :fox :goose}] [#{:fox} #{:you :goose :corn}])</pre>
</z><z id="t1654916160" t="Richie Cool!"><y>#</y><d>2022-06-11</d><h>02:56</h><r>Richie</r>Cool!</z><z id="t1655129227" t="lvh Hi! I have an instaparse parser for ini files (specifically intended for AWS configs). It understands kv pairs in with in section headers, and kv pairs without a section header, but I’m trying to figure out if I can write both in 1 (or at least 2 minimally duplicative) meander expression."><y>#</y><d>2022-06-13</d><h>14:07</h><w>lvh</w>Hi! I have an instaparse parser for ini files (specifically intended for AWS configs). It understands kv pairs in with in section headers, and kv pairs without a section header, but I’m trying to figure out if I can write both in 1 (or at least 2 minimally duplicative) meander expression.</z><z id="t1655129236" t="lvh Grammar 🧵"><y>#</y><d>2022-06-13</d><h>14:07</h><w>lvh</w>Grammar <b>🧵</b></z><z id="t1655129240" t="lvh ini = body section*. section = header (eol body)?. header = &quot;[&quot; wsp name wsp &quot;]&quot; wsp comment?. name = #&quot;[\w ]+(?&lt;! )&quot; body = (kv? wsp comment? eol)* (kv wsp comment?)? kv = key wsp &quot;=&quot; wsp val. key = #&quot;[\w ]*(?&lt;! )&quot; val = #&quot;[\w ]*(?&lt;! )&quot; comment = #&quot;#.*&quot;. wsp = &quot;(\t| )*&quot;. eol = &quot;(\r|\n|\r\n)&quot;. blank-line = wsp comment? eol. comment = #&quot;#.*&quot;. wsp = #&quot;( |\t)*&quot;. eol = #&quot;\R&quot;."><y>#</y><d>2022-06-13</d><h>14:07</h><r>lvh</r><pre>ini = body section*.

section = header (eol body)?.
header = &quot;[&quot; wsp name wsp &quot;]&quot; wsp comment?.
name = #&quot;[\w ]+(?&lt;! )&quot;

body = (kv? wsp comment? eol)* (kv wsp comment?)?

kv = key wsp &quot;=&quot; wsp val.
key = #&quot;[\w ]*(?&lt;! )&quot;
val = #&quot;[\w ]*(?&lt;! )&quot;

comment = #&quot;#.*&quot;.
wsp = &quot;(\t| )*&quot;.
eol = &quot;(\r|\n|\r\n)&quot;.

blank-line = wsp comment? eol.

comment = #&quot;#.*&quot;.
wsp = #&quot;( |\t)*&quot;.
eol = #&quot;\R&quot;.</pre></z><z id="t1655129270" t="lvh Example parses 🧵"><y>#</y><d>2022-06-13</d><h>14:07</h><w>lvh</w>Example parses <b>🧵</b></z><z id="t1655129278" t="lvh (def no-section (i/ini-parser &quot;x=1&quot;)) [:ini [:body [:kv [:key &quot;x&quot;] [:wsp &quot;&quot;] &quot;=&quot; [:wsp &quot;&quot;] [:val &quot;1&quot;]] [:wsp &quot;&quot;]]] (def empty-section (i/ini-parser &quot;[x]&quot;)) [:ini [:body] [:section [:header &quot;[&quot; [:wsp &quot;&quot;] [:name &quot;x&quot;] [:wsp &quot;&quot;] &quot;]&quot; [:wsp &quot;&quot;]]]] (def empty-section-with-newline (i/ini-parser &quot;[x]\n&quot;)) [:ini [:body] [:section [:header &quot;[&quot; [:wsp &quot;&quot;] [:name &quot;x&quot;] [:wsp &quot;&quot;] &quot;]&quot; [:wsp &quot;&quot;]] [:eol &quot;\n&quot;] [:body]]] (def one-section-with-one-kv (i/ini-parser &quot;[xyzzy]\nx = 1&quot;)) [:ini [:body] [:section [:header &quot;[&quot; [:wsp &quot;&quot;] [:name &quot;xyzzy&quot;] [:wsp &quot;&quot;] &quot;]&quot; [:wsp &quot;&quot;]] [:eol &quot;\n&quot;] [:body [:kv [:key &quot;x&quot;] [:wsp &quot; &quot;] &quot;=&quot; [:wsp &quot; &quot;] [:val &quot;1&quot;]] [:wsp &quot;&quot;]]]] (def one-section-with-two-kvs (i/ini-parser &quot;[xyzzy]\nx = 1\ny = 2&quot;)) [:ini [:body] [:section [:header &quot;[&quot; [:wsp &quot;&quot;] [:name &quot;xyzzy&quot;] [:wsp &quot;&quot;] &quot;]&quot; [:wsp &quot;&quot;]] [:eol &quot;\n&quot;] [:body [:kv [:key &quot;x&quot;] [:wsp &quot; &quot;] &quot;=&quot; [:wsp &quot; &quot;] [:val &quot;1&quot;]] [:wsp &quot;&quot;] [:eol &quot;\n&quot;] [:kv [:key &quot;y&quot;] [:wsp &quot; &quot;] &quot;=&quot; [:wsp &quot; &quot;] [:val &quot;2&quot;]] [:wsp &quot;&quot;]]]] (def two-sections (i/ini-parser &quot;[xyzzy]\nx = 1\n[iddqd]\ny=2&quot;)) [:ini [:body] [:section [:header &quot;[&quot; [:wsp &quot;&quot;] [:name &quot;xyzzy&quot;] [:wsp &quot;&quot;] &quot;]&quot; [:wsp &quot;&quot;]] [:eol &quot;\n&quot;] [:body [:kv [:key &quot;x&quot;] [:wsp &quot; &quot;] &quot;=&quot; [:wsp &quot; &quot;] [:val &quot;1&quot;]] [:wsp &quot;&quot;] [:eol &quot;\n&quot;]]] [:section [:header &quot;[&quot; [:wsp &quot;&quot;] [:name &quot;iddqd&quot;] [:wsp &quot;&quot;] &quot;]&quot; [:wsp &quot;&quot;]] [:eol &quot;\n&quot;] [:body [:kv [:key &quot;y&quot;] [:wsp &quot;&quot;] &quot;=&quot; [:wsp &quot;&quot;] [:val &quot;2&quot;]] [:wsp &quot;&quot;]]]]"><y>#</y><d>2022-06-13</d><h>14:07</h><r>lvh</r><pre>(def no-section
  (i/ini-parser &quot;x=1&quot;))

[:ini
 [:body
  [:kv [:key &quot;x&quot;] [:wsp &quot;&quot;] &quot;=&quot; [:wsp &quot;&quot;] [:val &quot;1&quot;]] [:wsp &quot;&quot;]]]

(def empty-section
  (i/ini-parser &quot;[x]&quot;))

[:ini
 [:body]
 [:section
  [:header &quot;[&quot; [:wsp &quot;&quot;] [:name &quot;x&quot;] [:wsp &quot;&quot;] &quot;]&quot; [:wsp &quot;&quot;]]]]

(def empty-section-with-newline
  (i/ini-parser &quot;[x]\n&quot;))

[:ini
 [:body]
 [:section
  [:header &quot;[&quot; [:wsp &quot;&quot;] [:name &quot;x&quot;] [:wsp &quot;&quot;] &quot;]&quot; [:wsp &quot;&quot;]]
  [:eol &quot;\n&quot;]
  [:body]]]


(def one-section-with-one-kv
  (i/ini-parser &quot;[xyzzy]\nx = 1&quot;))

[:ini
 [:body]
 [:section
  [:header &quot;[&quot; [:wsp &quot;&quot;] [:name &quot;xyzzy&quot;] [:wsp &quot;&quot;] &quot;]&quot; [:wsp &quot;&quot;]]
  [:eol &quot;\n&quot;]
  [:body [:kv [:key &quot;x&quot;] [:wsp &quot; &quot;] &quot;=&quot; [:wsp &quot; &quot;] [:val &quot;1&quot;]] [:wsp &quot;&quot;]]]]

(def one-section-with-two-kvs
  (i/ini-parser &quot;[xyzzy]\nx = 1\ny = 2&quot;))

[:ini
 [:body]
 [:section
  [:header &quot;[&quot; [:wsp &quot;&quot;] [:name &quot;xyzzy&quot;] [:wsp &quot;&quot;] &quot;]&quot; [:wsp &quot;&quot;]]
  [:eol &quot;\n&quot;]
  [:body
   [:kv [:key &quot;x&quot;] [:wsp &quot; &quot;] &quot;=&quot; [:wsp &quot; &quot;] [:val &quot;1&quot;]]
   [:wsp &quot;&quot;]
   [:eol &quot;\n&quot;]
   [:kv [:key &quot;y&quot;] [:wsp &quot; &quot;] &quot;=&quot; [:wsp &quot; &quot;] [:val &quot;2&quot;]]
   [:wsp &quot;&quot;]]]]


(def two-sections
  (i/ini-parser &quot;[xyzzy]\nx = 1\n[iddqd]\ny=2&quot;))

[:ini
 [:body]
 [:section
  [:header &quot;[&quot; [:wsp &quot;&quot;] [:name &quot;xyzzy&quot;] [:wsp &quot;&quot;] &quot;]&quot; [:wsp &quot;&quot;]]
  [:eol &quot;\n&quot;]
  [:body
   [:kv [:key &quot;x&quot;] [:wsp &quot; &quot;] &quot;=&quot; [:wsp &quot; &quot;] [:val &quot;1&quot;]]
   [:wsp &quot;&quot;]
   [:eol &quot;\n&quot;]]]
 [:section
  [:header &quot;[&quot; [:wsp &quot;&quot;] [:name &quot;iddqd&quot;] [:wsp &quot;&quot;] &quot;]&quot; [:wsp &quot;&quot;]]
  [:eol &quot;\n&quot;]
  [:body [:kv [:key &quot;y&quot;] [:wsp &quot;&quot;] &quot;=&quot; [:wsp &quot;&quot;] [:val &quot;2&quot;]] [:wsp &quot;&quot;]]]]</pre></z><z id="t1655129300" t="lvh Meander code I have 🧵"><y>#</y><d>2022-06-13</d><h>14:08</h><w>lvh</w>Meander code I have <b>🧵</b></z><z id="t1655129305" t="lvh (defn get-kvs [ini-parse] (m/search ini-parse [:ini [:body . _ ...] ;; &lt;= below body rule can occur here too &amp; (m/scan [:section [:header &amp; (m/scan [:name ?h])] . _ ... [:body &amp; (m/scan [:kv [:key ?k] [:wsp _] &quot;=&quot; [:wsp _] [:val ?v]])] . _ ...])] [?h ?k ?v]))"><y>#</y><d>2022-06-13</d><h>14:08</h><r>lvh</r><pre>(defn get-kvs
  [ini-parse]
  (m/search
   ini-parse
   [:ini
    [:body . _ ...] ;; &lt;= below body rule can occur here too
    &amp;
    (m/scan
     [:section
      [:header &amp; (m/scan [:name ?h])]
      . _ ...
      [:body &amp; (m/scan [:kv [:key ?k] [:wsp _] &quot;=&quot; [:wsp _] [:val ?v]])]
      . _ ...])]
   [?h ?k ?v]))</pre></z><z id="t1655129340" t="lvh basically this works great for finding [?header ?key ?value] pairs, and I can find kvs in the section headerless body, but I’m trying to see if I can extract both"><y>#</y><d>2022-06-13</d><h>14:09</h><r>lvh</r>basically this works great for finding [?header ?key ?value] pairs, and I can find kvs in the section headerless body, but I’m trying to see if I can extract both</z><z id="t1655129352" t="lvh I assume the way to write this is recursively"><y>#</y><d>2022-06-13</d><h>14:09</h><r>lvh</r>I assume the way to write this is recursively</z><z id="t1655496853" t="noprompt Can you give an example of what you want the output to look like?"><y>#</y><d>2022-06-17</d><h>20:14</h><r>noprompt</r>Can you give an example of what you want the output to look like?</z><z id="t1655496909" t="noprompt Also, sorry for the lag! I’ve had a wacky week."><y>#</y><d>2022-06-17</d><h>20:15</h><r>noprompt</r>Also, sorry for the lag! I’ve had a wacky week.</z><z id="t1655146077" t="noprompt [:attrs {:href &quot;/_/_/users/U07QKGF9P&quot;}] When I get a free moment I&apos;ll take a look at this. 👍"><y>#</y><d>2022-06-13</d><h>18:47</h><w>noprompt</w><a>@lvh</a> When I get a free moment I&apos;ll take a look at this. <b>👍</b></z><z id="t1655235575" t="dmegas Hello all! I’m pretty new to meander and I’m stuck trying to do the following (contrived example in thread):"><y>#</y><d>2022-06-14</d><h>19:39</h><w>dmegas</w>Hello all! I’m pretty new to meander and I’m stuck trying to do the following (contrived example in thread):</z><z id="t1655235681" t="dmegas Given an input of the form (def input {:result {:brands-list {:items [{:url &quot;&quot; :image &quot;&quot; :id &quot;52845&quot;}]} :products-list [{:name &quot;Product A&quot; :brand-id &quot;1173500&quot; :price &quot;33.00&quot;} {:name &quot;Product B&quot; :brand-id &quot;52845&quot; :price &quot;20.65&quot;}]}}) "><y>#</y><d>2022-06-14</d><h>19:41</h><r>dmegas</r>Given an input of the form
<pre>(def input {:result {:brands-list {:items [{:url   &quot;&quot;
                                              :image &quot;&quot;
                                              :id    &quot;52845&quot;}]}
                       :products-list
                       [{:name    &quot;Product A&quot;
                         :brand-id &quot;1173500&quot;
                         :price   &quot;33.00&quot;}
                        {:name    &quot;Product B&quot;
                         :brand-id &quot;52845&quot;
                         :price   &quot;20.65&quot;}]}})</pre>
</z><z id="t1655235705" t="dmegas I’d like to get the product info like follows: ({:product-name &quot;Product B&quot;, :brand-id &quot;52845&quot;, :brand-url &quot;&quot;, :product-price &quot;20.65&quot;} {:product-name &quot;Product A&quot;, :brand-id &quot;1173500&quot;, :brand-url nil, :product-price &quot;33.00&quot;})"><y>#</y><d>2022-06-14</d><h>19:41</h><r>dmegas</r>I’d like to get the product info like follows:
<pre>({:product-name &quot;Product B&quot;,
    :brand-id &quot;52845&quot;,
    :brand-url &quot;&quot;,
    :product-price &quot;20.65&quot;}
   {:product-name &quot;Product A&quot;,
    :brand-id &quot;1173500&quot;,
    :brand-url nil,
    :product-price &quot;33.00&quot;})</pre></z><z id="t1655235821" t="dmegas The tricky thing I can’t get to work is to get a “brand”’s :url if the product’s :brand-id matches one of the :id s in :brands-list but leave it blank otherwise."><y>#</y><d>2022-06-14</d><h>19:43</h><r>dmegas</r>The tricky thing I can’t get to work is to get a “brand”’s <code>:url</code> if the product’s <code>:brand-id</code> matches one of the <code>:id</code> s in <code>:brands-list</code> but leave it blank otherwise.</z><z id="t1655235905" t="dmegas Trying with (defn products [input] (m/search input {:result {:brands-list {:items (m/scan {:url ?brand-url :id ?brand-id})} :products-list (m/scan {:name ?product-name :brand-id ?brand-id :price ?product-price})}} {:product-name ?product-name :brand-id ?brand-id :brand-url ?brand-url :product-price ?product-price})) I’m only able to get the product with a matching brand-id (products input) =&gt; ({:product-name &quot;Product B&quot;, :brand-id &quot;52845&quot;, :brand-url &quot;&quot;, :product-price &quot;20.65&quot;})"><y>#</y><d>2022-06-14</d><h>19:45</h><r>dmegas</r>Trying with
<pre>(defn products
    [input]
    (m/search input

              {:result {:brands-list   {:items (m/scan {:url ?brand-url
                                                        :id  ?brand-id})}
                        :products-list (m/scan {:name    ?product-name
                                                :brand-id ?brand-id
                                                :price   ?product-price})}}
              {:product-name ?product-name
               :brand-id ?brand-id
               :brand-url ?brand-url
               :product-price ?product-price}))</pre>
I’m only able to get the product with a matching <code>brand-id</code>
<pre>(products input) =&gt; ({:product-name &quot;Product B&quot;,
  :brand-id &quot;52845&quot;,
  :brand-url &quot;&quot;,
  :product-price &quot;20.65&quot;})</pre></z><z id="t1655235915" t="dmegas Is there a way to accomplish what I’m after?"><y>#</y><d>2022-06-14</d><h>19:45</h><r>dmegas</r>Is there a way to accomplish what I’m after?</z><z id="t1655261739" t="Richie https://github.com/noprompt/meander/issues/137 might help you. Sorry if that&apos;s not much help; it&apos;s late and I&apos;m logging off."><y>#</y><d>2022-06-15</d><h>02:55</h><r>Richie</r><a href="https://github.com/noprompt/meander/issues/137" target="_blank">https://github.com/noprompt/meander/issues/137</a> might help you. Sorry if that&apos;s not much help; it&apos;s late and I&apos;m logging off.</z><z id="t1655280667" t="dmegas thank you, this was helpful indeed! It is working with a combination of m/or and m/let (defn products [input] (m/search input {:result {:products-list (m/scan {:name ?product-name :brand-id ?brand-id :price ?product-price}) :brands-list {:items (m/or (m/scan {:url ?brand-url :id ?brand-id}) (m/let [?brand-url nil] (m/not (m/scan {:id ?brand-id}))))}}} {:product-name ?product-name :brand-id ?brand-id :brand-url ?brand-url :product-price ?product-price})) "><y>#</y><d>2022-06-15</d><h>08:11</h><r>dmegas</r>thank you, this was helpful indeed! It is working with a combination of <code>m/or</code> and <code>m/let</code>
<pre>(defn products
    [input]
    (m/search input

              {:result {:products-list (m/scan {:name    ?product-name
                                                :brand-id ?brand-id
                                                :price   ?product-price})
                        :brands-list   {:items (m/or (m/scan {:url ?brand-url
                                                              :id  ?brand-id})
                                                     (m/let [?brand-url nil]
                                                       (m/not (m/scan {:id ?brand-id}))))}}}
              {:product-name ?product-name
               :brand-id ?brand-id
               :brand-url ?brand-url
               :product-price ?product-price})) </pre></z><z id="t1655280775" t="dmegas The only thing is that I had to change the keys in the pattern, :products-list first and then :brands-list . Otherwise it fails with Unable to resolve symbol: ?brand-id in this context , not sure if there is another way that works with the initial order."><y>#</y><d>2022-06-15</d><h>08:12</h><r>dmegas</r>The only thing is that I had to change the keys in the pattern, <code>:products-list</code> first and then <code>:brands-list</code> . Otherwise it fails with <code>Unable to resolve symbol: ?brand-id in this context</code>, not sure if there is another way that works with the initial order.</z><z id="t1656338680" t="wilkerlucio hello, how can I make a pattern that says a key must not be in the map?"><y>#</y><d>2022-06-27</d><h>14:04</h><w>wilkerlucio</w>hello, how can I make a pattern that says a key must not be in the map?</z><z id="t1656339258" t="Ben Sless Maybe by writing a pattern that fails (bottom) if it succeed in matching a key in a map? (and {k (some v)} fail)"><y>#</y><d>2022-06-27</d><h>14:14</h><r>Ben Sless</r>Maybe by writing a pattern that fails (bottom) if it succeed in matching a key in a map? 
(and {k (some v)} fail)</z><z id="t1656339309" t="wilkerlucio I found that just using {:key nil} seems to work fine"><y>#</y><d>2022-06-27</d><h>14:15</h><r>wilkerlucio</r>I found that just using <code>{:key nil}</code> seems to work fine</z><z id="t1656339807" t="Ben Sless What if the key exists with a nil value? Is it possible?"><y>#</y><d>2022-06-27</d><h>14:23</h><r>Ben Sless</r>What if the key exists with a nil value? Is it possible?</z><z id="t1656339839" t="wilkerlucio I think in this case will match the same, which is fine for my use case but I can see some other case might wanna know the difference"><y>#</y><d>2022-06-27</d><h>14:23</h><r>wilkerlucio</r>I think in this case will match the same, which is fine for my use case but I can see some other case might wanna know the difference</z><z id="t1656358612" t="noprompt There is currently not a (clean) way to distinguish between a missing key and a key with a nil value. 😐"><y>#</y><d>2022-06-27</d><h>19:36</h><r>noprompt</r>There is currently not a (clean) way to distinguish between a missing key and a key with a <code>nil</code> value. <b>😐</b></z><z id="t1656358716" t="wilkerlucio I think something in the direction of what match combinators do would be interesting to have in meander, for the case we are discussing they have the absent matcher ( https://github.com/nubank/matcher-combinators#negative-matchers )"><y>#</y><d>2022-06-27</d><h>19:38</h><r>wilkerlucio</r>I think something in the direction of what match combinators do would be interesting to have in meander, for the case we are discussing they have the <code>absent</code> matcher (<a href="https://github.com/nubank/matcher-combinators#negative-matchers" target="_blank">https://github.com/nubank/matcher-combinators#negative-matchers</a>)</z><z id="t1656358750" t="wilkerlucio it is possible to make a custom syntax on meander for that?"><y>#</y><d>2022-06-27</d><h>19:39</h><r>wilkerlucio</r>it is possible to make a custom syntax on meander for that?</z><z id="t1656359110" t="noprompt For interpreted Meander, sure, but for compiled, it’s possible but too much work for the time I am currently making for the project (which has only been on the zeta branch). The issue boils down to compiled meander resolving key values with get . We could switch to find for specific keys but, again, it’s a lot of work. A workaround be papered over with defsyntax {&amp; (m/scan [:foo ?x])} "><y>#</y><d>2022-06-27</d><h>19:45</h><r>noprompt</r>For interpreted Meander, sure, but for compiled, it’s possible but too much work for the time I am currently making for the project (which has only been on the <code>zeta</code> branch). The issue boils down to compiled meander resolving key values with <code>get</code>. We could switch to <code>find</code> for specific keys but, again, it’s a lot of work.

A workaround be papered over with <code>defsyntax</code>

<pre>{&amp; (m/scan [:foo ?x])}</pre>
</z><z id="t1656359150" t="noprompt Use {} to ensure you get a map, then m/scan the keys. But that is really kinda ugly."><y>#</y><d>2022-06-27</d><h>19:45</h><r>noprompt</r>Use <code>{}</code> to ensure you get a map, then <code>m/scan</code> the keys. But that is really kinda ugly.</z><z id="t1656359221" t="noprompt {:foo ?foo &amp; (not ?x) :as ?x} Might work too."><y>#</y><d>2022-06-27</d><h>19:47</h><r>noprompt</r><pre>{:foo ?foo &amp; (not ?x) :as ?x}</pre>
Might work too.</z><z id="t1656359258" t="noprompt Right because if ?x is {} and &amp; ?x succeeds then you know :foo isn’t a key."><y>#</y><d>2022-06-27</d><h>19:47</h><r>noprompt</r>Right because if <code>?x</code> is <code>{}</code> and <code>&amp; ?x</code> succeeds then you know <code>:foo</code> isn’t a key.</z><z id="t1656683472" t="borkdude FYI"><y>#</y><d>2022-07-01</d><h>13:51</h><w>borkdude</w>FYI</z><z id="t1656703085" t="noprompt Sweet!"><y>#</y><d>2022-07-01</d><h>19:18</h><r>noprompt</r>Sweet!</z><z id="t1656703125" t="noprompt Hmm... this could get me into some transpiler mischief."><y>#</y><d>2022-07-01</d><h>19:18</h><r>noprompt</r>Hmm... this could get me into some transpiler mischief.</z><z id="t1657573570" t="noprompt [:attrs {:href &quot;/_/_/users/U2J7JRTDX&quot;}] I apologize for the delay in responding to your issue. I replied here: https://github.com/noprompt/meander/issues/234#issuecomment-1180869312"><y>#</y><d>2022-07-11</d><h>21:06</h><w>noprompt</w><a>@xiongtx</a> I apologize for the delay in responding to your issue. I replied here: <a href="https://github.com/noprompt/meander/issues/234#issuecomment-1180869312" target="_blank">https://github.com/noprompt/meander/issues/234#issuecomment-1180869312</a></z><z id="t1657573696" t="noprompt Recently, I have been spending more time working on zeta because I really wan to get it released before the end of the year. Over the past week I have been working to move stuff that has been in development in to the primary source directory and test it."><y>#</y><d>2022-07-11</d><h>21:08</h><w>noprompt</w>Recently, I have been spending more time working on <code>zeta</code> because I really wan to get it released before the end of the year. Over the past week I have been working to move stuff that has been in development in to the primary source directory and test it.</z><z id="t1657573851" t="noprompt I will be focusing more on compilation in a couple weeks."><y>#</y><d>2022-07-11</d><h>21:10</h><w>noprompt</w>I will be focusing more on compilation in a couple weeks.</z><z id="t1657574545" t="xiongtx [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] Thanks! Looking forward to the new release 😃 !"><y>#</y><d>2022-07-11</d><h>21:22</h><w>xiongtx</w><a>@noprompt</a> Thanks! Looking forward to the new release <b>😃</b>!</z><z id="t1657574670" t="noprompt This one has gone through a lot. 😄"><y>#</y><d>2022-07-11</d><h>21:24</h><w>noprompt</w>This one has gone through a lot. <b>😄</b></z><z id="t1657574684" t="noprompt Personally, I need to finish it and get it out there."><y>#</y><d>2022-07-11</d><h>21:24</h><w>noprompt</w>Personally, I need to finish it and get it out there.</z><z id="t1657574701" t="noprompt I keep running into situations in my personal projects where I want the new features."><y>#</y><d>2022-07-11</d><h>21:25</h><w>noprompt</w>I keep running into situations in my personal projects where I want the new features.</z><z id="t1658574257" t="peterh Is there a shorter or more idiomatic way in Meander to constrain a matching set to only include specific elements than by using the empty? predicate? (let [f (r/find #{&apos;a ^&amp; (m/pred empty?)} :yes)] [(f #{&apos;a &apos;b}) (f #{&apos;a})]) ;=&gt; [nil :yes] ;; this will not work: (let [f (r/find #{&apos;a ^&amp; #{}} :yes)] [(f #{&apos;a &apos;b}) (f #{&apos;a})]) ;=&gt; [:yes :yes]"><y>#</y><d>2022-07-23</d><h>11:04</h><w>peterh</w>Is there a shorter or more idiomatic way in Meander to constrain a matching set to only include specific elements than by using the <code>empty?</code> predicate?

<pre>(let [f (r/find
          #{&apos;a ^&amp; (m/pred empty?)} :yes)]
  [(f #{&apos;a &apos;b}) (f #{&apos;a})])
;=&gt; [nil :yes]

;; this will not work:
(let [f (r/find
          #{&apos;a ^&amp; #{}} :yes)]
  [(f #{&apos;a &apos;b}) (f #{&apos;a})])
;=&gt; [:yes :yes]</pre></z><z id="t1658575182" t="peterh I see now why the second idea does not work: in the macroexpansion, it checks for #{} to be a subset of the rest of the input set, which of course will be the case for any set. With the predicate solution, it will only apply the predicate to the rest of the set to check if it is empty. Maybe I can do something with defsyntax here to make it shorter, have to learn how this works."><y>#</y><d>2022-07-23</d><h>11:19</h><r>peterh</r>I see now why the second idea does not work: in the macroexpansion, it checks for <code>#{}</code> to be a subset of the rest of the input set, which of course will be the case for any set.
With the predicate solution, it will only apply the predicate to the rest of the set to check if it is empty.

Maybe I can do something with <code>defsyntax</code> here to make it shorter, have to learn how this works.</z><z id="t1658576179" t="peterh Okay, so I can do it like this: (m/defsyntax ∅ [] `(m/pred empty?)) (let [f (r/find #{&apos;a ^&amp; (∅)} :yes)] [(f #{&apos;a &apos;b}) (f #{&apos;a})]) ;=&gt; [nil :yes] Although I feel like this may be a more common thing and would have a built-in solution, but I couldn’t find anything yet."><y>#</y><d>2022-07-23</d><h>11:36</h><r>peterh</r>Okay, so I can do it like this:
<pre>(m/defsyntax ∅ []
  `(m/pred empty?))

(let [f (r/find
          #{&apos;a ^&amp; (∅)} :yes)]
  [(f #{&apos;a &apos;b}) (f #{&apos;a})])
;=&gt; [nil :yes]</pre>
Although I feel like this may be a more common thing and would have a built-in solution, but I couldn’t find anything yet.</z><z id="t1658603899" t="Richie (mr/match #{:a :b} (m/pred #(= #{:a} %)) :one _ :two) ;; :two "><y>#</y><d>2022-07-23</d><h>19:18</h><r>Richie</r><pre>(mr/match #{:a :b}
  (m/pred #(= #{:a} %)) :one
  _ :two)
;; :two</pre>
</z><z id="t1658604019" t="Richie (let [x #{:a :b}] (mr/match x (m/guard (= x #{:a})) :one _ :two)) ;; :two "><y>#</y><d>2022-07-23</d><h>19:20</h><r>Richie</r><pre>(let [x #{:a :b}]
  (mr/match x
    (m/guard (= x #{:a})) :one
    _ :two))
;; :two</pre>
</z><z id="t1658705661" t="peterh I haven’t thought about this, but the issue I see with your suggestions is that I cannot use a pattern in the predicate, just an ordinary Clojure expression. Or is there a trick that would still allow me to do so?"><y>#</y><d>2022-07-24</d><h>23:34</h><r>peterh</r>I haven’t thought about this, but the issue I see with your suggestions is that I cannot use a pattern in the predicate, just an ordinary Clojure expression. Or is there a trick that would still allow me to do so?</z><z id="t1658705757" t="peterh By pattern I mean a Meander pattern with logic variables, etc."><y>#</y><d>2022-07-24</d><h>23:35</h><r>peterh</r>By pattern I mean a Meander pattern with logic variables, etc.</z><z id="t1658706939" t="Richie (mr/match #{:a} (mr/and (mr/pred #(= #{:a} %)) ?x) [:one ?x] _ :two) "><y>#</y><d>2022-07-24</d><h>23:55</h><r>Richie</r><pre>(mr/match #{:a}
          (mr/and (mr/pred #(= #{:a} %)) ?x) [:one ?x]
          _ :two)</pre>
</z><z id="t1658707008" t="Richie This may not address your concern. I&apos;m not sure if you&apos;re saying that you don&apos;t know how to further match on it or if you&apos;re pointing out that I&apos;m using clojure.core/=."><y>#</y><d>2022-07-24</d><h>23:56</h><r>Richie</r>This may not address your concern. I&apos;m not sure if you&apos;re saying that you don&apos;t know how to further match on it or if you&apos;re pointing out that I&apos;m using clojure.core/=.</z><z id="t1658738605" t="peterh Yeah, I don’t know how to further match on it. The ?x in your example only matches the whole expression. Basically I would like to use logic variables inside the set pattern, like #{:a ?x} and then match on that, but at the same time the set should not contain more than 2 items (in this example)."><y>#</y><d>2022-07-25</d><h>08:43</h><r>peterh</r>Yeah, I don’t know how to further match on it. The <code>?x</code> in your example only matches the whole expression.

Basically I would like to use logic variables inside the set pattern, like <code>#{:a ?x}</code> and then match on that, but at the same time the set should not contain more than 2 items (in this example).</z><z id="t1658726961" t="noprompt [:attrs {:href &quot;/_/_/users/U032GJ90EMA&quot;}] You want to use &apos;#{} (let [f (r/find #{&apos;a ^&amp; &apos;#{}} :yes)] [(f #{&apos;a &apos;b}) (f #{&apos;a})]) ;=&gt; [nil :yes] "><y>#</y><d>2022-07-25</d><h>05:29</h><w>noprompt</w><a>@peterhfmnn</a> You want to use <code>&apos;#{}</code>

<pre>(let [f (r/find
          #{&apos;a ^&amp; &apos;#{}} :yes)]
  [(f #{&apos;a &apos;b}) (f #{&apos;a})])
;=&gt; [nil :yes]</pre>
</z><z id="t1658755823" t="peterh Awesome! I somehow wasn’t aware that (= #{} &apos;#{}) , but this makes a lot of sense!"><y>#</y><d>2022-07-25</d><h>13:30</h><r>peterh</r>Awesome! I somehow wasn’t aware that <code>(= #{} &apos;#{})</code>, but this makes a lot of sense!</z><z id="t1658788860" t="noprompt I have mixed feelings about this though and, in the next version of the library, I think this will be an optional semantic because I think it is slightly confusing. Mostly, I did this to make matching on those data types more Clojure friendly."><y>#</y><d>2022-07-25</d><h>22:41</h><r>noprompt</r>I have mixed feelings about this though and, in the next version of the library, I think this will be an optional semantic because I think it is slightly confusing.

Mostly, I did this to make matching on those data types more Clojure friendly.</z><z id="t1658727002" t="noprompt Set patterns represent subsets the same way map patterns represent submaps."><y>#</y><d>2022-07-25</d><h>05:30</h><w>noprompt</w>Set patterns represent subsets the same way map patterns represent submaps.</z><z id="t1658940584" t="sergey let&apos;s say I want to collect lists of matching patterns and also a map key at a higher level in a nested map. ie. given the following map: {:a {:client &quot;foo&quot; :items [{:x 1} 2 3]} :b {:client &quot;bar&quot; :items [{:x &quot;q&quot;} {:x &quot;x&quot;}]}} I&apos;d like to collect all values of maps with key :x under :items and also the value of :client that appears alongside those :items : [[&quot;foo&quot; [1] [&quot;bar&quot; [&quot;q&quot; &quot;x&quot;]] What&apos;s a good way of doing this? Is it possible to generate that output with meander alone?"><y>#</y><d>2022-07-27</d><h>16:49</h><w>sergey</w>let&apos;s say I want to collect lists of matching patterns and also a map key at a higher level in a nested map. ie. given the following map:
<pre>{:a {:client &quot;foo&quot;
     :items [{:x 1} 2 3]}
 :b {:client &quot;bar&quot;
     :items [{:x &quot;q&quot;} {:x &quot;x&quot;}]}}</pre>
I&apos;d like to collect all values of maps with key <code>:x</code>  under <code>:items</code> and also the value of <code>:client</code> that appears alongside those <code>:items</code>:
<pre>[[&quot;foo&quot; [1] [&quot;bar&quot; [&quot;q&quot; &quot;x&quot;]]</pre>
What&apos;s a good way of doing this? Is it possible to generate that output with meander alone?</z><z id="t1658940596" t="sergey I can get pretty close with the following: (m/search {:a {:client &quot;foo&quot; :items [{:x 1} 2 3]} :b {:client &quot;bar&quot; :items [{:x &quot;q&quot;} {:x &quot;x&quot;}]} } (m/$ {:client ?c :items (m/scan {:x !i})}) [?c !i]) but it gives me pairs for each match rather than aggregating the !i values: ([&quot;foo&quot; [1]] [&quot;bar&quot; [&quot;q&quot;]] [&quot;bar&quot; [&quot;x&quot;]]) "><y>#</y><d>2022-07-27</d><h>16:49</h><r>sergey</r>I can get pretty close with the following:
<pre>(m/search {:a {:client &quot;foo&quot;
                 :items [{:x 1} 2 3]}
             :b {:client &quot;bar&quot;
                 :items [{:x &quot;q&quot;} {:x &quot;x&quot;}]}
             }
            (m/$ {:client ?c
                  :items (m/scan {:x !i})})
            [?c !i])</pre>
but it gives me pairs for each match rather than aggregating the <code>!i</code> values:
<pre>([&quot;foo&quot; [1]] [&quot;bar&quot; [&quot;q&quot;]] [&quot;bar&quot; [&quot;x&quot;]])</pre>
</z><z id="t1658940725" t="sergey (For more context, the map above is a simplified one; the actual map I want to extract the data from has a lot more levels of nesting under :items before the :x keys appear)"><y>#</y><d>2022-07-27</d><h>16:52</h><r>sergey</r>(For more context, the map above is a simplified one; the actual map I want to extract the data from has a lot more levels of nesting under <code>:items</code> before the <code>:x</code> keys appear)</z><z id="t1659032617" t="noprompt (defn f [m] (m/find m {:client ?client :items [(m/or {:x !x} _) ...]} [?client !x])) (m/search {:a {:client &quot;bar&quot; :items [{:x &quot;q&quot;} {:x &quot;x&quot;}]} :b {:client &quot;foo&quot; :items [{:x 1} 2 3]}} {_ {:as ?v}} (f ?v)) ;; =&gt; ([&quot;bar&quot; [&quot;q&quot; &quot;x&quot;]] [&quot;foo&quot; [1]])"><y>#</y><d>2022-07-28</d><h>18:23</h><r>noprompt</r><pre>(defn f [m]
  (m/find m
    {:client ?client
     :items [(m/or {:x !x} _) ...]}
    [?client !x]))

(m/search {:a {:client &quot;bar&quot;
               :items [{:x &quot;q&quot;} {:x &quot;x&quot;}]}
           :b {:client &quot;foo&quot;
               :items [{:x 1} 2 3]}}
  {_ {:as ?v}} (f ?v))
;; =&gt;
([&quot;bar&quot; [&quot;q&quot; &quot;x&quot;]] [&quot;foo&quot; [1]])</pre></z><z id="t1659032734" t="noprompt This would all be one pattern if epsilon had proper greediness."><y>#</y><d>2022-07-28</d><h>18:25</h><r>noprompt</r>This would all be one pattern if epsilon had proper greediness.</z><z id="t1659119888" t="sergey Gotcha - thanks for the context! I&apos;ll keep this in mind when I write queries in the future. The output without proper greediness is still very useful to me because it simplifies a lot of the map traversal logic that I&apos;d otherwise have to write"><y>#</y><d>2022-07-29</d><h>18:38</h><r>sergey</r>Gotcha - thanks for the context! I&apos;ll keep this in mind when I write queries in the future. The output without proper greediness is still very useful to me because it simplifies a lot of the map traversal logic that I&apos;d otherwise have to write</z><z id="t1659228604" t="peterh I try to implement a pattern on a set where I need to match the same subset twice: - 1) the subset is a singular element of the parent set - 2) the elements of the subset are elements of the parent set Example: #{ y #{x y} x } (the subset here being #{x y} of course) It should work with any given subset, not a specific one. I thought about something like this: (m/find [[&apos;a &apos;b] &apos;a &apos;b] [?x &amp; ?x] :yes) but using set patterns, like: (m/find #{&apos;b #{&apos;a &apos;b} &apos;a} #{?x ^&amp; ?x} :yes) But this does not work, because ?x appears twice in the set and Clojure doesn’t seem to recognize this “fake” rest pattern in sets: ^&amp; Can I use something like #{?x ^&amp; ?y} instead and somehow unify the two logic variables similar to (== ?x ?y) in Clojures core.logic? Or is there any other way to solve this in Meander, if it is possible at all?"><y>#</y><d>2022-07-31</d><h>00:50</h><w>peterh</w>I try to implement a pattern on a set where I need to match the same subset twice:
- 1) the subset is a singular element of the parent set
- 2) the elements of the subset are elements of the parent set

Example: <code>#{ y #{x y} x }</code>  (the subset here being <code>#{x y}</code> of course)

It should work with any given subset, not a specific one.

I thought about something like this:
<pre>(m/find
  [[&apos;a &apos;b] &apos;a &apos;b]
  [?x &amp; ?x] :yes)</pre>
but using set patterns, like:
<pre>(m/find
  #{&apos;b #{&apos;a &apos;b} &apos;a}
  #{?x ^&amp; ?x} :yes)</pre>
But this does not work, because <code>?x</code> appears twice in the set and Clojure doesn’t seem to recognize this “fake” rest pattern in sets: <code>^&amp;</code>

Can I use something like <code>#{?x ^&amp; ?y}</code> instead and somehow unify the two logic variables similar to <code>(== ?x ?y)</code> in Clojures core.logic? Or is there any other way to solve this in Meander, if it is possible at all?</z><z id="t1659298857" t="peterh Okay, so I just found out that I can do this with maps: (m/find {&apos;b 0, {&apos;a 0, &apos;b 0} 0, &apos;a 0} {?x _ &amp; ?x} ?x) ;=&gt; {a 0, b 0} This is pretty nice and it makes me believe that it should actually - in principle - work with sets the same way, since sets in Clojure are just (as far as I know) maps that map each element to itself (please correct me if I’m wrong). So the only reason why it does not work is that Clojure has no “real” rest syntax for sets, right? Any workarounds?"><y>#</y><d>2022-07-31</d><h>20:20</h><r>peterh</r>Okay, so I just found out that I can do this with maps:
<pre>(m/find {&apos;b 0, {&apos;a 0, &apos;b 0} 0, &apos;a 0}
    {?x _ &amp; ?x} ?x)
;=&gt; {a 0, b 0}</pre>
This is pretty nice and it makes me believe that it should actually - in principle - work with sets the same way, since sets in Clojure are just (as far as I know) maps that map each element to itself (please correct me if I’m wrong).

So the only reason why it does not work is that Clojure has no “real” rest syntax for sets, right? Any workarounds?</z><z id="t1659301753" t="peterh (this is just a note to myself as I try to figure this out, maybe it helps others too, so I post it here) The example in my last post only works if there are no further keys in the outer map, because the ?x will try to unify the exact same map: (m/find {&apos;b 0, &apos;c 2, {&apos;a 0, &apos;b 0} 0, &apos;a 0} {?x _ &amp; ?x} ?x) ;=&gt; nil (because of &apos;c 2) The following example works because the map pattern in the rest match is only matched as a submap (same with sets): (m/find {&apos;b 0, &apos;c 2, {&apos;a 0, &apos;b 0} 0, &apos;a 0} {{&apos;a 0, &apos;b 0} _ &amp; {&apos;a 0, &apos;b 0}} :true) ;=&gt; true Somewhere I have seen that you can have multiple rest patterns, so with logic variables it can be done like this instead: (m/find {&apos;b 0, &apos;c 2, {&apos;a 0, &apos;b 0} 0, &apos;a 0} {?x _ &amp;0 ?x &amp;1 _} ?x) ;=&gt; {a 0, b 0}"><y>#</y><d>2022-07-31</d><h>21:09</h><r>peterh</r>(this is just a note to myself as I try to figure this out, maybe it helps others too, so I post it here)

The example in my last post only works if there are no further keys in the outer map, because the <code>?x</code> will try to unify the exact same map:

<pre>(m/find {&apos;b 0, &apos;c 2, {&apos;a 0, &apos;b 0} 0, &apos;a 0}
    {?x _ &amp; ?x} ?x)
;=&gt; nil  (because of &apos;c 2)</pre>
The following example works because the map pattern in the rest match is only matched as a submap (same with sets):

<pre>(m/find {&apos;b 0, &apos;c 2, {&apos;a 0, &apos;b 0} 0, &apos;a 0}
    {{&apos;a 0, &apos;b 0} _ &amp; {&apos;a 0, &apos;b 0}}
    :true)
;=&gt; true</pre>
Somewhere I have seen that you can have multiple rest patterns, so with logic variables it can be done like this instead:
<pre>(m/find {&apos;b 0, &apos;c 2, {&apos;a 0, &apos;b 0} 0, &apos;a 0}
    {?x _ &amp;0 ?x &amp;1 _} ?x)
;=&gt; {a 0, b 0}</pre></z><z id="t1659317680" t="timothypratley Something I&apos;ve been struggling to think through: a) Meander is a term rewriting library and that&apos;s very good. b) It is difficult to differentiate between a &quot;greedy&quot; pattern consumption, and an &quot;all possible matches&quot; comprehension [more accurately the former is not supported, you can only really do the latter, but this limitation is probably syntactic in the sense of how would you request greediness]. c) Instaparse has a similar tension between &quot;greedy&quot; and &quot;possible interpretations of a grammar applied to an input. The way Instaparse resolves this is by having the grammar be not greedy, but including regex matchers which are greedy. This feels very natural in Instaparse because you often want to regex match on tokens. d) Instaparse benefits greatly from being able to greedily match identifiers and then fold the result into an AST. e) Can a similar strategy be used in Meander? Well the limitation here is that we don&apos;t have regex for data structures (Instaparse can use regexes for strings because that&apos;s it&apos;s fundamental building block). Or do we? I&apos;m tempted to say that someone has probably tackled regex for data structures... certainly Clojure.spec advertises itself as regex for data structures... maybe Meader is kind of a regex for data structures already and I&apos;m missing the point. f) Instaparse is great on strings but I don&apos;t see how to use it on data structures, Meander is great on data structures and not so much on strings which is fine they serve different purposes, but in both situations both the ability to rewrite, and the ability to create an AST are useful. Meander is excellent at AST manipulation, but I claim that it misses the capability to go from data structure to AST. Similarly Instaparse is missing the capability to go from data structures to AST. How would one define a grammar for data? Instaparse -&gt; AST -&gt; rewrite with Meander works really well, but could there also be a Data -&gt; AST -&gt; rewrite Motivation: Finding it hard to explain why I think this could be useful hahahaha g) What would it look like to provide a grammar for data? Well it&apos;s just adding labels to Meander patterns: S = AB* AB = A | B A = #data[1 &amp; _] B = #data(2 &amp; _) h) 🤯"><y>#</y><d>2022-08-01</d><h>01:34</h><w>timothypratley</w>Something I&apos;ve been struggling to think through:
a) Meander is a term rewriting library and that&apos;s very good.
b) It is difficult to differentiate between a &quot;greedy&quot; pattern consumption, and an &quot;all possible matches&quot; comprehension [more accurately the former is not supported, you can only really do the latter, but this limitation is probably syntactic in the sense of how would you request greediness].
c) Instaparse has a similar tension between &quot;greedy&quot; and &quot;possible interpretations of a grammar applied to an input. The way Instaparse resolves this is by having the grammar be not greedy, but including regex matchers which are greedy. This feels very natural in Instaparse because you often want to regex match on tokens.
d) Instaparse benefits greatly from being able to greedily match identifiers and then fold the result into an AST.
e) Can a similar strategy be used in Meander? Well the limitation here is that we don&apos;t have regex for data structures (Instaparse can use regexes for strings because that&apos;s it&apos;s fundamental building block). Or do we? I&apos;m tempted to say that someone has probably tackled regex for data structures... certainly Clojure.spec advertises itself as regex for data structures... maybe Meader is kind of a regex for data structures already and I&apos;m missing the point.
f) Instaparse is great on strings but I don&apos;t see how to use it on data structures, Meander is great on data structures and not so much on strings which is fine they serve different purposes, but in both situations both the ability to rewrite, and the ability to create an AST are useful. Meander is excellent at AST manipulation, but I claim that it misses the capability to go from data structure to AST. Similarly Instaparse is missing the capability to go from data structures to AST. How would one define a grammar for data?
Instaparse -&gt; AST -&gt; rewrite with Meander works really well, but could there also be a Data -&gt; AST -&gt; rewrite
Motivation: Finding it hard to explain why I think this could be useful hahahaha
g) What would it look like to provide a grammar for data? Well it&apos;s just adding labels to Meander patterns:
<pre>S = AB*
AB = A | B
A = #data[1 &amp; _]
B = #data(2 &amp; _)</pre>
h) <b>🤯</b></z><z id="t1659377673" t="noprompt For epsilon to have greediness all it would require is adding a committed choice operator. On the zeta branch, this is called pick . Greediness ends up looking like: (m/with {%head &lt;some-pattern&gt; %tail ?tail %args (m/cons %head (m/pick %args %tail))} %args) "><y>#</y><d>2022-08-01</d><h>18:14</h><w>noprompt</w>For <code>epsilon</code> to have greediness all it would require is adding a committed choice operator. On the <code>zeta</code> branch, this is called <code>pick</code>. Greediness ends up looking like:

<pre>(m/with {%head &lt;some-pattern&gt;
         %tail ?tail
         %args (m/cons %head (m/pick %args %tail))}
  %args)</pre>
</z><z id="t1659377825" t="noprompt This will cause ?tail to always be empty. However, if you replace m/pick with m/some (`m/or` on epsilon ) you get the behavior of … ."><y>#</y><d>2022-08-01</d><h>18:17</h><w>noprompt</w>This will cause <code>?tail</code> to always be empty. However, if you replace <code>m/pick</code> with <code>m/some</code> (`m/or` on <code>epsilon</code>) you get the behavior of <code>…</code>.</z><z id="t1659377967" t="noprompt I haven’t been talking much about zeta because I have been working very hard on getting an initial working release of it ready hopefully by the end of this month."><y>#</y><d>2022-08-01</d><h>18:19</h><w>noprompt</w>I haven’t been talking much about <code>zeta</code> because I have been working very hard on getting an initial working release of it ready hopefully by the end of this month.</z><z id="t1659378045" t="noprompt It may not be be as fast as epsilon out of the box, however, it will be (is) far more flexible and powerful."><y>#</y><d>2022-08-01</d><h>18:20</h><w>noprompt</w>It may not be be as fast as <code>epsilon</code> out of the box, however, it will be (is) far more flexible and powerful.</z><z id="t1659378423" t="noprompt [:attrs {:href &quot;/_/_/users/U06S1EJPL&quot;}] On that grammar thing, I think you will like the zeta approach to language extension. 🙂"><y>#</y><d>2022-08-01</d><h>18:27</h><w>noprompt</w><a>@timothypratley</a> On that grammar thing, I think you will like the <code>zeta</code> approach to language extension. <b>🙂</b></z><z id="t1659378505" t="noprompt zeta not only allows you to define your own operators like epsilon does but it also allows you to define your own notation (like &amp; ?rest ) and use it in a hygienic way."><y>#</y><d>2022-08-01</d><h>18:28</h><w>noprompt</w><code>zeta</code> not only allows you to define your own operators like <code>epsilon</code> does but it also allows you to define your own notation (like <code>&amp; ?rest</code>) and use it in a hygienic way.</z><z id="t1659378604" t="noprompt And, actually, stuff like &amp; and :as patterns are defined as notation rather than being a part of the core language."><y>#</y><d>2022-08-01</d><h>18:30</h><w>noprompt</w>And, actually, stuff like <code>&amp;</code> and <code>:as</code> patterns are defined as notation rather than being a part of the core language.</z><z id="t1659378628" t="noprompt And so is _ , ?&lt;name&gt; , notation. 😉"><y>#</y><d>2022-08-01</d><h>18:30</h><w>noprompt</w>And so is <code>_</code>, <code>?&lt;name&gt;</code> , notation. <b>😉</b></z><z id="t1659378684" t="noprompt Apart from the primitive parts, everything thing is done by creating new operators or new notation."><y>#</y><d>2022-08-01</d><h>18:31</h><w>noprompt</w>Apart from the primitive parts, everything thing is done by creating new operators or new notation.</z><z id="t1659378708" t="noprompt So if you wanted, say, a grammar notation like what you have above, you could define it."><y>#</y><d>2022-08-01</d><h>18:31</h><w>noprompt</w>So if you wanted, say, a grammar notation like what you have above, you could define it.</z><z id="t1659378742" t="noprompt zeta also has a rough draft of explanations too"><y>#</y><d>2022-08-01</d><h>18:32</h><w>noprompt</w><code>zeta</code> also has a rough draft of explanations too</z><z id="t1659378992" t="noprompt (defnotation ^{:doc &quot;Convert symbols that start with \&quot;_\&quot;? into the form (anything).&quot;} anything-symbol (rule (symbol (anything) (str &quot;_&quot; (anything))) (`anything))) "><y>#</y><d>2022-08-01</d><h>18:36</h><w>noprompt</w><pre>(defnotation
  ^{:doc &quot;Convert symbols that start with \&quot;_\&quot;? into the form (anything).&quot;}
  anything-symbol
  (rule
   (symbol (anything) (str &quot;_&quot; (anything)))
   (`anything)))</pre>
</z><z id="t1659380507" t="timothypratley sweet! 🙂"><y>#</y><d>2022-08-01</d><h>19:01</h><r>timothypratley</r>sweet! <b>🙂</b></z><z id="t1659379074" t="noprompt The left side of the rule says “match a symbol with any namespace value, and a name value that is a string which starts with &quot;_&quot; “. The right side says “build the form (meander.zeta/anything) “."><y>#</y><d>2022-08-01</d><h>18:37</h><w>noprompt</w>The left side of the <code>rule</code> says “match a symbol with any namespace value, and a name value that is a string which starts with <code>&quot;_&quot;</code>“. The right side says “build the form <code>(meander.zeta/anything)</code>“.</z><z id="t1659379155" t="noprompt So its pretty much like a macro, however, it applies to any term not just terms that look like lists."><y>#</y><d>2022-08-01</d><h>18:39</h><w>noprompt</w>So its pretty much like a macro, however, it applies to any term not just terms that look like lists.</z><z id="t1659379258" t="noprompt Notation is not global like operators are. That would be crazy."><y>#</y><d>2022-08-01</d><h>18:40</h><w>noprompt</w>Notation is not global like operators are. That would be crazy.</z><z id="t1659379381" t="noprompt Instead, you have to tell Meander when you want to use notation: ;; Vector of length 3 (pattern [_ _ _] {:notations [anything-symbol]}) ;; Vector of 3 _ symbols (pattern [_ _ _] {:notations []}) "><y>#</y><d>2022-08-01</d><h>18:43</h><w>noprompt</w>Instead, you have to tell Meander when you want to use notation:

<pre>;; Vector of length 3
(pattern [_ _ _] {:notations [anything-symbol]})

;; Vector of 3 _ symbols
(pattern [_ _ _] {:notations []})</pre>
</z><z id="t1659379418" t="noprompt So, if you want to build a custom dialect that doesn’t have things like _ symbols or whatever, you can do that."><y>#</y><d>2022-08-01</d><h>18:43</h><w>noprompt</w>So, if you want to build a custom dialect that doesn’t have things like <code>_</code> symbols or whatever, you can do that.</z><z id="t1659379442" t="noprompt This also makes the parser smaller. 🙂"><y>#</y><d>2022-08-01</d><h>18:44</h><w>noprompt</w>This also makes the parser smaller. <b>🙂</b></z><z id="t1659396824" t="markaddleman Thanks for the peek into zeta !"><y>#</y><d>2022-08-01</d><h>23:33</h><w>markaddleman</w>Thanks for the peek into <code>zeta</code> !</z></g><g id="s16"><z id="t1659762884" t="bbss I&apos;m parsing a bunch of python into an ast and so I can answer some questions about it and thought of using meander for that, so far it&apos;s proven very useful and elegant. I hope I can keep figuring it out as my &quot;questions&quot; become more complicated 🙂"><y>#</y><d>2022-08-06</d><h>05:14</h><w>bbss</w>I&apos;m parsing a bunch of python into an ast and so I can answer some questions about it and thought of using meander for that, so far it&apos;s proven very useful and elegant. I hope I can keep figuring it out as my &quot;questions&quot; become more complicated <b>🙂</b></z><z id="t1659763618" t="bbss for example I wanted to &quot;find all the places where ?x get called and give me the ?first-argument ?x gets called with&quot; so used search and $ to describe the pattern in the ast. Then I used scan on the arguments, but that made it so there is no notion of &quot;first&quot; so I did some transformation on the result, however. Then I thought perhaps I could not scan but try a vector with logic-var in the first position and a &amp;rest after that (first tried ... in stead of &amp;rest) Don&apos;t see any mention of &amp; in the docs but happy it worked intuitively like that 🙂"><y>#</y><d>2022-08-06</d><h>05:26</h><w>bbss</w>for example I wanted to &quot;find all the places where ?x get called and give me the ?first-argument ?x gets called with&quot; so used <code>search</code> and <code>$</code> to describe the pattern in the ast. Then I used <code>scan</code> on the arguments, but that made it so there is no notion of &quot;first&quot; so I did some transformation on the result, however. Then I thought perhaps I could not <code>scan</code> but try a vector with logic-var in the first position and a &amp;rest after that (first tried ... in stead of &amp;rest) Don&apos;t see any mention of &amp; in the docs but happy it worked intuitively like that <b>🙂</b></z><z id="t1659766947" t="noprompt [:attrs {:href &quot;/_/_/users/U09MR0T5Y&quot;}] I would be happy to give you a hand (the Python bit has me curious since I&apos;m starting to mess around with Python myself). Can I ping you Monday or some time next week?"><y>#</y><d>2022-08-06</d><h>06:22</h><r>noprompt</r><a>@U09MR0T5Y</a> I would be happy to give you a hand (the Python bit has me curious since I&apos;m starting to mess around with Python myself). Can I ping you Monday or some time next week?</z><z id="t1659767024" t="bbss Oh cool, sure, I don&apos;t have many questions just yet, but happy to chat about what I&apos;m making :)"><y>#</y><d>2022-08-06</d><h>06:23</h><r>bbss</r>Oh cool, sure, I don&apos;t have many questions just yet, but happy to chat about what I&apos;m making :)</z><z id="t1659767346" t="noprompt Nice. OK. I&apos;ll get in touch next week. 🙂"><y>#</y><d>2022-08-06</d><h>06:29</h><r>noprompt</r>Nice. OK. I&apos;ll get in touch next week. <b>🙂</b></z><z id="t1660290346" t="Peter Nagy Is there a clear pattern to transform a deeply nested part of a data structure? E.g. specter ($/transform [:x :y :zs $/ALL] inc {:foo :bar :x {:y {:zs [1 2 3]}}}) returns {:foo :bar :x {:y {:zs [2 3 4]}}}"><y>#</y><d>2022-08-12</d><h>07:45</h><w>Peter Nagy</w>Is there a clear pattern to transform a deeply nested part of a data structure? E.g. specter <code>($/transform [:x :y :zs $/ALL] inc {:foo :bar :x {:y {:zs [1 2 3]}}})</code> returns <code>{:foo :bar :x {:y {:zs [2 3 4]}}}</code></z><z id="t1660320220" t="noprompt No. The library wasn’t designed for those kinds of transforms."><y>#</y><d>2022-08-12</d><h>16:03</h><r>noprompt</r>No. The library wasn’t designed for those kinds of transforms.</z><z id="t1660320234" t="noprompt Somewhat intentionally too."><y>#</y><d>2022-08-12</d><h>16:03</h><r>noprompt</r>Somewhat intentionally too.</z><z id="t1660320237" t="noprompt 🙂"><y>#</y><d>2022-08-12</d><h>16:03</h><r>noprompt</r><b>🙂</b></z><z id="t1660550031" t="Peter Nagy thanks. Why intentionally, is it just out of scope? Do you have something else you use for this case? I think lenses are quite useful on their own, just wanted to know if meander also covers that use case"><y>#</y><d>2022-08-15</d><h>07:53</h><r>Peter Nagy</r>thanks. Why intentionally, is it just out of scope? Do you have something else you use for this case? I think lenses are quite useful on their own, just wanted to know if meander also covers that use case</z><z id="t1660629888" t="noprompt Lenses can be useful but in my personal experience I find they tend to code that is difficult for people to read (myself included), and favor brevity at the expense of clarity. They provide great abstraction but not great semantics. In a language where that approach is already over represented, I have organized this experiment of Meander around other goals. tl;dr semantics are more important to me than abstraction. Another reason is that the evaluation semantics of Meander style rewriting -- and this is more pronounced on the zeta branch -- don&apos;t map to lenses neatly. Many people, including myself, have schemed ways of building an update-in-place kind of thing with Meander but nothing came out of it. That said, there&apos;s nothing stopping anyone from using Meander in conjunction with a lens library. &gt; Do you have something else you use for this case? I try to break problems down in other ways that don&apos;t require nested transformations. If I&apos;m using Meander, I use things like cata to do those nested transformations. If I have control over the data model, I like to keep things flat and shallow. If I don&apos;t, I transform it into clean semantic piles of data that favor simple operations. When deeply nested transformations are employed, my gut tells me I should investigate. Nested data structures are hell to work with and code often mirrors that hell (a big part of my day job right now is trying to gradually resolve a hell created by a massive nested data structure). Tying this back to lenses: lenses seem like they mitigate that hell but, I think, they just provide an alternative view of it. ;)"><y>#</y><d>2022-08-16</d><h>06:04</h><r>noprompt</r>Lenses can be useful but in my personal experience I find they tend to code that is difficult for people to read (myself included), and favor brevity at the expense of clarity. They provide great abstraction but not great semantics. In a language where that approach is already over represented, I have organized this experiment of Meander around other goals.

tl;dr semantics are more important to me than abstraction.

Another reason is that the evaluation semantics of Meander style rewriting -- and this is more pronounced on the <code>zeta</code> branch --  don&apos;t map to lenses neatly. Many people, including myself, have schemed ways of building an update-in-place kind of thing with Meander but nothing came out of it. That said, there&apos;s nothing stopping anyone from using Meander in conjunction with a lens library.

&gt; Do you have something else you use for this case?
I try to break problems down in other ways that don&apos;t require nested transformations. If I&apos;m using Meander, I use things like <code>cata</code> to do those nested transformations. If I have control over the data model, I like to keep things flat and shallow. If I don&apos;t, I transform it into clean semantic piles of data that favor simple operations.

When deeply nested transformations are employed, my gut tells me I should investigate. Nested data structures are hell to work with and code often mirrors that hell (a big part of my day job right now is trying to gradually resolve a hell created by a massive nested data structure).

Tying this back to lenses: lenses seem like they mitigate that hell but, I think, they just provide an alternative view of it. ;)</z><z id="t1660631352" t="noprompt On a more personal level, I have ADHD which means my working memory runs out pretty quickly. A lot of Clojure code and stuff like Spectre just torch my brain. Though it wasn&apos;t a goal of mine to address that problem with Meander, I think unintentionally I intentionally built it to help with that issue by orienting around externalizing information."><y>#</y><d>2022-08-16</d><h>06:29</h><r>noprompt</r>On a more personal level, I have ADHD which means my working memory runs out pretty quickly. A lot of Clojure code and stuff like Spectre just torch my brain.  Though it wasn&apos;t a goal of mine to address that problem with Meander, I think unintentionally I intentionally built it to help with that issue by orienting around externalizing information.</z><z id="t1660636305" t="Peter Nagy thanks for the detailed response. What I value about lenses is that they compose well. And while I try to make data shallow/normalized, there&apos;s code out there that isn&apos;t. I was looking into meander for finding all actions in a https://lucywang000.github.io/clj-statecharts/docs/get-started/ . As you can see it is deeply nested and rebuilding the whole data structure by hand is just tedious, something the machine should do for me. Another nice thing about specter is that it goes out of its way to keep everything the same, so a vector stays a vector, a set a set etc. I understand the distinction between lenses and meander better now, which will help me use meander in a better way. Thank you! Also, looking forward to zeta !"><y>#</y><d>2022-08-16</d><h>07:51</h><r>Peter Nagy</r>thanks for the detailed response. What I value about lenses is that they compose well. And while I try to make data shallow/normalized, there&apos;s code out there that isn&apos;t. I was looking into meander for finding all actions in a <a href="https://lucywang000.github.io/clj-statecharts/docs/get-started/" target="_blank">https://lucywang000.github.io/clj-statecharts/docs/get-started/</a> . As you can see it is deeply nested and rebuilding the whole data structure by hand is just tedious, something the machine should do for me. Another nice thing about specter is that it goes out of its way to keep everything the same, so a vector stays a vector, a set a set etc.

I understand the distinction between lenses and meander better now, which will help me use meander in a better way. Thank you! Also, looking forward to <code>zeta</code>!</z><z id="t1660805443" t="timothypratley Just chiming in with my opinion... I think that Meander is better than Specter for deeply nested data. If we look at the example described, a simple solution would be: (m/rewrite {:foo :bar :x {:y {:zs [1 2 3]}}} {&amp; ?m :x {&amp; ?m2 :y {&amp; ?m3 :zs [!x ...]}}} {&amp; ?m :x {&amp; ?m2 :y {&amp; ?m3 :zs [(m/app inc !x) ...]}}}) =&gt; {:foo :bar, :x {:y {:zs [2 3 4]}}} ^^ Easy and very clear what is happening. Specter is more compact, but I&apos;d much rather see the shape of my data, thanks. In terms of clarity, the difference is huge. I like patterns. And patterns are just fine with deeply nested data. Moving on from the contrived example... I&apos;ve written at least two large project that are entirely based on Meander for data transformation of deeply nested data structures and it worked great: 1. Kalai (transpiler Clojure to Rust and other languages) basically taking an AST (the mother of all nested data) and rewritting it into many other forms. https://github.com/echeran/kalai/blob/main/src/kalai/pass/kalai/b_kalai_constructs.clj Take a look at this, its really easy to read, clear what tranforms are taking place, and recursive. 2. HappyGAPI https://github.com/timothypratley/happygapi/blob/main/dev/happy/beaver.clj Here again I&apos;m dealing with a pretty scary deeply nested data set (The schemas for Google&apos;s APIs) and Meander is able to express them in an extremely clear and recursive way. All that to say IMO regardless of the design goals, Meander is the best solution to complex data transformations including deeply nested structured data. I&apos;d add that a) I do think it&apos;s best to avoid complex data by simplifying it into a triple store, b) Complex data does exist though, and not everything goes into a triple store, and even if it does you still need to do transformations at the edges, so it&apos;s kinda more a question of how much mapping you have to do. c) When it comes to mapping, I think the closest thing to a competitor to Meander is Instaparse, but they occupy quite different spaces in that Instaparse concerns itself with taking text-&gt;AST and Meander concerns itself with taking data-&gt;data. Coming back to the main question of &quot;what&apos;s the pattern for deeply nested data structures?&quot; My answer would be: 1. If it&apos;s an explicit path, then match the explicit path you expect to find, and collect everything else with &amp; 2. If it&apos;s a nested recursive scenario then just use your favorite recursion tool (I like m/app, maybe you prefer m/cata, or ~. 3. There&apos;s nothing wrong with the old (update-in megamap [:k :k2 :k3 :k4] meander-transform) either Hope that helps"><y>#</y><d>2022-08-18</d><h>06:50</h><r>timothypratley</r>Just chiming in with my opinion...

I think that Meander is better than Specter for deeply nested data.

If we look at the example described, a simple solution would be:

<pre>(m/rewrite {:foo :bar :x {:y {:zs [1 2 3]}}}
           {&amp; ?m :x {&amp; ?m2 :y {&amp; ?m3 :zs [!x ...]}}}
           {&amp; ?m :x {&amp; ?m2 :y {&amp; ?m3 :zs [(m/app inc !x) ...]}}})</pre>
=&gt; {:foo :bar, :x {:y {:zs [2 3 4]}}}

^^ Easy and very clear what is happening.

Specter is more compact, but I&apos;d much rather see the shape of my data, thanks. In terms of clarity, the difference is huge. I like patterns. And patterns are just fine with deeply nested data.

Moving on from the contrived example... I&apos;ve written at least two large project that are entirely based on Meander for data transformation of deeply nested data structures and it worked great:

1. Kalai (transpiler Clojure to Rust and other languages) basically taking an AST (the mother of all nested data) and rewritting it into many other forms. <a href="https://github.com/echeran/kalai/blob/main/src/kalai/pass/kalai/b_kalai_constructs.clj" target="_blank">https://github.com/echeran/kalai/blob/main/src/kalai/pass/kalai/b_kalai_constructs.clj</a> Take a look at this, its really easy to read, clear what tranforms are taking place, and recursive.
2. HappyGAPI <a href="https://github.com/timothypratley/happygapi/blob/main/dev/happy/beaver.clj" target="_blank">https://github.com/timothypratley/happygapi/blob/main/dev/happy/beaver.clj</a> Here again I&apos;m dealing with a pretty scary deeply nested data set (The schemas for Google&apos;s APIs) and Meander is able to express them in an extremely clear and recursive way.
All that to say IMO regardless of the design goals, Meander is the best solution to complex data transformations including deeply nested structured data.

I&apos;d add that
a) I do think it&apos;s best to avoid complex data by simplifying it into a triple store,
b) Complex data does exist though, and not everything goes into a triple store, and even if it does you still need to do transformations at the edges, so it&apos;s kinda more a question of how much mapping you have to do.
c) When it comes to mapping, I think the closest thing to a competitor to Meander is Instaparse, but they occupy quite different spaces in that Instaparse concerns itself with taking text-&gt;AST and Meander concerns itself with taking data-&gt;data.

Coming back to the main question of &quot;what&apos;s the pattern for deeply nested data structures?&quot; My answer would be:
1. If it&apos;s an explicit path, then match the explicit path you expect to find, and collect everything else with &amp;
2. If it&apos;s a nested recursive scenario then just use your favorite recursion tool (I like m/app, maybe you prefer m/cata, or ~.
3. There&apos;s nothing wrong with the old <code>(update-in megamap [:k :k2 :k3 :k4] meander-transform)</code> either
Hope that helps</z><z id="t1661174399" t="nonrecursive hello! I am drinking the meander koolaid and wondering how to do this transform? ;; input {:a {:m {} :n {}} :b {:m {} :o {}}} ;; output [[:a :m] [:a :n] [:a :m :n] [:b :m] [:b :o] [:b :m :o]]"><y>#</y><d>2022-08-22</d><h>13:19</h><w>nonrecursive</w>hello! I am drinking the meander koolaid and wondering how to do this transform?

<pre>;; input
{:a {:m {}
     :n {}}
 :b {:m {}
     :o {}}}

;; output
[[:a :m]
 [:a :n]
 [:a :m :n]
 [:b :m]
 [:b :o]
 [:b :m :o]]</pre></z><z id="t1661177258" t="jgdavey Does this need to be arbitrarily deep? Or for only the first level of keys?"><y>#</y><d>2022-08-22</d><h>14:07</h><r>jgdavey</r>Does this need to be arbitrarily deep? Or for only the first level of keys?</z><z id="t1661177305" t="nonrecursive only for the first level of keys"><y>#</y><d>2022-08-22</d><h>14:08</h><r>nonrecursive</r>only for the first level of keys</z><z id="t1661177336" t="nonrecursive I found the cookbook and it looks like {&amp; (m/seqable [!ks !vs] …)} might help here"><y>#</y><d>2022-08-22</d><h>14:08</h><r>nonrecursive</r>I found the cookbook and it looks like <code>{&amp; (m/seqable [!ks !vs] …)}</code> might help here</z><z id="t1661178764" t="jgdavey Something like this is almost right: (m/rewrite {:a {:m {} :n {}} :b {:m {} :o {}}} [?k (m/and (m/seqable !v ...) ?v2)] [[?k !v] ... [?k &amp; ?v2]] (m/and {} (m/gather [!k (m/app keys !v)])) [(m/cata [!k !v]) ...])"><y>#</y><d>2022-08-22</d><h>14:32</h><r>jgdavey</r>Something like this is almost right:
<pre>(m/rewrite {:a {:m {}
                :n {}}
            :b {:m {}
                :o {}}}
  [?k (m/and (m/seqable !v ...) ?v2)]
  [[?k !v] ... [?k &amp; ?v2]]

  (m/and {} (m/gather [!k (m/app keys !v)]))
  [(m/cata [!k !v]) ...])</pre></z><z id="t1661178810" t="jgdavey The trick, I think, is using m/cata to “recurse” with k and its set of keys, then doing 2 different things with those keys in the other patter"><y>#</y><d>2022-08-22</d><h>14:33</h><r>jgdavey</r>The trick, I think, is using <code>m/cata</code> to “recurse” with k and its set of keys, then doing 2 different things with those keys in the other patter</z><z id="t1661178874" t="jgdavey It’s possible it could all be done in the one top-level map pattern, but my brain started to get cloudy."><y>#</y><d>2022-08-22</d><h>14:34</h><r>jgdavey</r>It’s possible it could all be done in the one top-level map pattern, but my brain started to get cloudy.</z><z id="t1661178905" t="jgdavey This isn’t quite right, though, as its got an extra layer of vector nesting per top-level key, and you didn’t want that"><y>#</y><d>2022-08-22</d><h>14:35</h><r>jgdavey</r>This isn’t quite right, though, as its got an extra layer of vector nesting per top-level key, and you didn’t want that</z><z id="t1661179678" t="nonrecursive oh wow this is so close though, I really appreciate it"><y>#</y><d>2022-08-22</d><h>14:47</h><r>nonrecursive</r>oh wow this is so close though, I really appreciate it</z><z id="t1661179737" t="jgdavey Another caveat is that m/gather acts like filter , so may or may not be what you want"><y>#</y><d>2022-08-22</d><h>14:48</h><r>jgdavey</r>Another caveat is that <code>m/gather</code> acts like <code>filter</code>, so may or may not be what you want</z><z id="t1661179924" t="nonrecursive oh interesting, I think that’s OK here"><y>#</y><d>2022-08-22</d><h>14:52</h><r>nonrecursive</r>oh interesting, I think that’s OK here</z><z id="t1661182266" t="nonrecursive I was able to flatten it with m/app into : (m/rewrite {:a {:m {} :n {}} :b {:m {} :o {}}} [?k (m/and (m/seqable !v ...) ?v2)] [[?k !v] ... [?k &amp; ?v2]] (m/and {} (m/gather [!k (m/app keys !v)])) (m/app into (m/cata [!k !v]) ...))"><y>#</y><d>2022-08-22</d><h>15:31</h><r>nonrecursive</r>I was able to flatten it with <code>m/app into</code>:

<pre>(m/rewrite {:a {:m {}
                :n {}}
            :b {:m {}
                :o {}}}

  [?k (m/and (m/seqable !v ...) ?v2)]
  [[?k !v] ... [?k &amp; ?v2]]

  (m/and {} (m/gather [!k (m/app keys !v)]))
  (m/app into (m/cata [!k !v]) ...))</pre></z><z id="t1661182300" t="jgdavey Nice"><y>#</y><d>2022-08-22</d><h>15:31</h><r>jgdavey</r>Nice</z><z id="t1661187587" t="Richie I don’t understand the ask. How do I know that it should be :a :m :n and not :a :n :m?"><y>#</y><d>2022-08-22</d><h>16:59</h><r>Richie</r>I don’t understand the ask. How do I know that it should be :a :m :n and not :a :n :m?</z><z id="t1661187622" t="Richie I mean since maps are unordered. "><y>#</y><d>2022-08-22</d><h>17:00</h><r>Richie</r>I mean since maps are unordered. </z><z id="t1661188482" t="nonrecursive good catch, the order is not essential to the solution here"><y>#</y><d>2022-08-22</d><h>17:14</h><r>nonrecursive</r>good catch, the order is not essential to the solution here</z><z id="t1661188639" t="Richie What would it look like if there are multiple entries in the inner map?"><y>#</y><d>2022-08-22</d><h>17:17</h><r>Richie</r>What would it look like if there are multiple entries in the inner map?</z><z id="t1661188751" t="nonrecursive which inner map?"><y>#</y><d>2022-08-22</d><h>17:19</h><r>nonrecursive</r>which inner map?</z><z id="t1661188840" t="Richie Does {:a {:b {} :c {} :d {} :e {}} produce [:a :b :c] as one of the results or just [[:a :b] [:a :c] [:a d] [:a :e] [:a :b :c :d :e]] ?"><y>#</y><d>2022-08-22</d><h>17:20</h><r>Richie</r>Does <code>{:a {:b {} :c {} :d {} :e {}}</code> produce <code>[:a :b :c]</code>  as one of the results or just <code>[[:a :b] [:a :c] [:a d] [:a :e] [:a :b :c :d :e]]</code> ?</z><z id="t1661188870" t="Richie I don&apos;t understand the transformation from just the one example."><y>#</y><d>2022-08-22</d><h>17:21</h><r>Richie</r>I don&apos;t understand the transformation from just the one example.</z><z id="t1661188978" t="nonrecursive the latter"><y>#</y><d>2022-08-22</d><h>17:22</h><r>nonrecursive</r>the latter</z><z id="t1661256285" t="dbj Hello! I ran into some kind of performance issue with the code below. The time to execute seems to increase exponentially for every m&lt;nr&gt; I add on the LHS. The code below takes about 10secs to execute. Any ideas? (m/rewrite {0 {:id 0 :m1 {:a {:id :a, :x 0}} :m2 {:b {:id :b, :x 0}} :m3 {:c {:id :c, :x 0}}} 1 {:id 1 :m1 {:a {:id :a, :x 0}} :m2 {:b {:id :b, :x 0}} :m3 {:c {:id :c, :x 0}}}} (m/map-of _ {:id !id :m1 {&amp; (m/seqable [!m1-ids !m1s] ..!m1-cnt)} :m2 {&amp; (m/seqable [!m2-ids !m2s] ..!m2-cnt)} :m3 {&amp; (m/seqable [!m3-ids !m3s] ..!m3-cnt)}}) [{:id !id :m1-ids [!m1-ids ..!m1-cnt] :m2-ids [!m2-ids ..!m2-cnt] :m3-ids [!m3-ids ..!m3-cnt] } ...])"><y>#</y><d>2022-08-23</d><h>12:04</h><w>dbj</w>Hello! I ran into some kind of performance issue with the code below. The time to execute seems to increase exponentially for every <code>m&lt;nr&gt;</code> I add on the LHS. The code below takes about 10secs to execute. Any ideas?
<pre>(m/rewrite {0 {:id 0
                   :m1 {:a {:id :a, :x 0}}
                   :m2 {:b {:id :b, :x 0}}
                   :m3 {:c {:id :c, :x 0}}}
                1 {:id 1
                   :m1 {:a {:id :a, :x 0}}
                   :m2 {:b {:id :b, :x 0}}
                   :m3 {:c {:id :c, :x 0}}}}
      (m/map-of _
                {:id !id
                 :m1 {&amp; (m/seqable [!m1-ids !m1s] ..!m1-cnt)}
                 :m2 {&amp; (m/seqable [!m2-ids !m2s] ..!m2-cnt)}
                 :m3 {&amp; (m/seqable [!m3-ids !m3s] ..!m3-cnt)}})

      [{:id !id
        :m1-ids [!m1-ids ..!m1-cnt]
        :m2-ids [!m2-ids ..!m2-cnt]
        :m3-ids [!m3-ids ..!m3-cnt]
        } ...])</pre></z><z id="t1661256832" t="dbj It seems the be the compilation that takes time."><y>#</y><d>2022-08-23</d><h>12:13</h><r>dbj</r>It seems the be the compilation that takes time.</z><z id="t1661285238" t="dbj I spent some time narrowing it down to test-m2 being slow compared to the others below ;; fast (defn test-m1 [x] (m/rewrite x (m/map-of _ {:id !id :m1 [!m1s ...] :m2 [!m2s ...] :m3 [!m3s ...] :m4 [!m4s ...]}) [{:id !id } ...])) ;; slow (defn test-m2 [x] (m/rewrite x (m/map-of _ {:id !id :m1 [[!m1-ids !m1s] ...] :m2 [[!m2-ids !m2s] ...] :m3 [[!m3-ids !m3s] ...] :m4 [[!m4-ids !m4s] ...] }) [{:id !id } ...])) ;; fast (defn test-m3 [x] (m/rewrite x {:id !id :m1 [[!m1-ids !m1s] ...] :m2 [[!m2-ids !m2s] ...] :m3 [[!m3-ids !m3s] ...] :m4 [[!m4-ids !m4s] ...] } [{:id !id } ...]))"><y>#</y><d>2022-08-23</d><h>20:07</h><r>dbj</r>I spent some time narrowing it down to <code>test-m2</code>being slow compared to the others below
<pre>;; fast
(defn test-m1 [x]
    (m/rewrite x
               (m/map-of _
                         {:id !id
                          :m1 [!m1s ...]
                          :m2 [!m2s ...]
                          :m3 [!m3s ...]
                          :m4 [!m4s ...]})
               [{:id !id
                 } ...]))
;; slow
(defn test-m2 [x]
    (m/rewrite x
               (m/map-of _
                         {:id !id
                          :m1 [[!m1-ids !m1s] ...]
                          :m2 [[!m2-ids !m2s] ...]
                          :m3 [[!m3-ids !m3s] ...]
                          :m4 [[!m4-ids !m4s] ...]
                          })
               [{:id !id
                 } ...]))
;; fast
(defn test-m3 [x]
  (m/rewrite x
    {:id !id
     :m1 [[!m1-ids !m1s] ...]
     :m2 [[!m2-ids !m2s] ...]
     :m3 [[!m3-ids !m3s] ...]
     :m4 [[!m4-ids !m4s] ...]
     }
    [{:id !id
      } ...]))</pre></z><z id="t1661286153" t="dbj test-m1 is faster than test-m2 because it has fewer memory variables. Repeating the pattern upto m8 in test-m1 will make it perform as test-m2 . test-m3 does not show the same behaviour. So my working conclusion is that it is related to map-of and the amount of memory variables"><y>#</y><d>2022-08-23</d><h>20:22</h><r>dbj</r><code>test-m1</code> is faster than <code>test-m2</code> because it has fewer memory variables. Repeating the pattern upto m8 in <code>test-m1</code> will make it perform as <code>test-m2</code>.
<code>test-m3</code> does not show the same behaviour. So my working conclusion is that it is related to <code>map-of</code> and the amount of memory variables</z><z id="t1661323060" t="dbj I guess this could be a similar issue as #234 https://github.com/noprompt/meander/issues/234#issue-1292196144 I will leave it at that for now and try a different solution."><y>#</y><d>2022-08-24</d><h>06:37</h><r>dbj</r>I guess this could be a similar issue as #234 <a href="https://github.com/noprompt/meander/issues/234#issue-1292196144" target="_blank">https://github.com/noprompt/meander/issues/234#issue-1292196144</a>

I will leave it at that for now and try a different solution.</z><z id="t1661262419" t="Lidor Cohen Hello! I&apos;m starting to learn my way through meander and I hoped someone could help me with (what I believe is) a simple use case I struggle with: I have 2 csvs (vector of vectors) with one holding a vector of ids in the other csv (tags). I want to collect all the tags that match the relevant item. Something like this, but I haven&apos;t wrapped my head around matching \ collecting \ spreading: (defn data-mapper [data] (m/search data {:data (m/scan _ ?product) :tags (m/scan _ (m/pred #(contains? (split (?product 36) &quot;;&quot;) (% 0)) tag?))} {:products {&quot;name&quot; (?product 12) &quot;description&quot; (?product 13) &quot;price&quot; (js/parseInt (?product 17)) &quot;media&quot; {&quot;data&quot; {&quot;src&quot; (?product 24)}} &quot;product_tags&quot; {&quot;data&quot; [{&quot;name&quot; (tag? 3)} ...]}}})) If anyone can point in the right direction that would be great ^_^"><y>#</y><d>2022-08-23</d><h>13:46</h><w>Lidor Cohen</w>Hello! I&apos;m starting to learn my way through meander and I hoped someone could help me with (what I believe is) a simple use case I struggle with:
I have 2 csvs (vector of vectors) with one holding a vector of ids in the other csv (tags).
I want to collect all the tags that match the relevant item.
Something like this, but I haven&apos;t wrapped my head around matching \ collecting \ spreading:
<pre>(defn data-mapper [data]
  (m/search data

            {:data (m/scan _ ?product)
             :tags (m/scan _ (m/pred #(contains? (split (?product 36) &quot;;&quot;) (% 0)) tag?))}

            {:products {&quot;name&quot; (?product 12)
                        &quot;description&quot; (?product 13)
                        &quot;price&quot; (js/parseInt (?product 17))
                        &quot;media&quot; {&quot;data&quot; {&quot;src&quot; (?product 24)}}
                        &quot;product_tags&quot; {&quot;data&quot; [{&quot;name&quot; (tag? 3)} ...]}}}))</pre>
If anyone can point in the right direction that would be great ^_^</z><z id="t1661274056" t="noprompt Hi Lidor, are you able to provide a sample of your input data and expected output data? Also, note that it is only safe to use ?product in the m/pred function like that for small maps e.g. PersistentArrayMap ."><y>#</y><d>2022-08-23</d><h>17:00</h><r>noprompt</r>Hi Lidor, are you able to provide a sample of your input data and expected output data? Also, note that it is only safe to use <code>?product</code> in the <code>m/pred</code> function like that for small maps e.g. <code>PersistentArrayMap</code>.</z><z id="t1661275760" t="Lidor Cohen well it will be pretty hard because the input is quite dirty, its is basically a parsed csv (vector of vectors) with 54 columns and the first vector being the headers, so something like this: {:products [[&quot;name&quot; &quot;some&quot; &quot;unimportant&quot; &quot;values&quot; ... &quot;description&quot; ... &quot;price&quot; ... &quot;media&quot; ... &quot;tags&quot; ...] [&quot;some-name&quot; &quot;bla&quot; &quot;bla&quot; &quot;bla&quot; ... &quot;some long description&quot; ... &quot;42&quot; ... &quot;&quot; ... &quot;238;239;756;785;1111;&quot; ...] ...] :tags [[&quot;Category ID&quot; ... &quot;Category Name&quot; ... &quot;Parent&quot; ...] [&quot;238&quot; ... &quot;catcat&quot; ... &quot;catcat&apos;s mom&quot;] [&quot;239&quot; ... &quot;catcat&apos;s mom&quot; ... &quot;&quot;] ...]} And the output should look something like this: [{&quot;name&quot; &quot;some-name&quot; &quot;description&quot; &quot;some long description&quot; &quot;price&quot; 42 &quot;media&quot; {&quot;data&quot; {&quot;src&quot; &quot;&quot;}} &quot;product_tags&quot; [{&quot;name&quot; &quot;catcat&quot; &quot;parent&quot; &quot;catcat&apos;s mom&quot;} {&quot;name&quot; &quot;catcat&apos;s mom&quot; &quot;parent&quot; &quot;&quot;} ...]} ... ] I&apos;m guessing I didn&apos;t use meanderright for this task, I&apos;m just starting to learn its deeper powers 😅"><y>#</y><d>2022-08-23</d><h>17:29</h><r>Lidor Cohen</r>well it will be pretty hard because the input is quite dirty, its is basically a parsed csv (vector of vectors)  with 54 columns and the first vector being the headers, so something like this:
<pre>{:products [[&quot;name&quot; &quot;some&quot; &quot;unimportant&quot; &quot;values&quot; ... &quot;description&quot; ... &quot;price&quot; ... &quot;media&quot; ... &quot;tags&quot; ...]
            [&quot;some-name&quot; &quot;bla&quot;  &quot;bla&quot; &quot;bla&quot; ... &quot;some long description&quot; ... &quot;42&quot; ... &quot;&quot; ... &quot;238;239;756;785;1111;&quot; ...]
            ...]
 :tags     [[&quot;Category ID&quot; ... &quot;Category Name&quot; ... &quot;Parent&quot; ...]
            [&quot;238&quot; ... &quot;catcat&quot; ... &quot;catcat&apos;s mom&quot;]
            [&quot;239&quot; ... &quot;catcat&apos;s mom&quot; ... &quot;&quot;]
            ...]}</pre>
And the output should look something like this:
<pre>[{&quot;name&quot; &quot;some-name&quot;
 &quot;description&quot; &quot;some long description&quot;
 &quot;price&quot; 42
 &quot;media&quot; {&quot;data&quot; {&quot;src&quot; &quot;&quot;}}
 &quot;product_tags&quot; [{&quot;name&quot; &quot;catcat&quot; &quot;parent&quot; &quot;catcat&apos;s mom&quot;}
                 {&quot;name&quot; &quot;catcat&apos;s mom&quot; &quot;parent&quot; &quot;&quot;}
                 ...]}
 ...
]</pre>
I&apos;m guessing I didn&apos;t use meanderright for this task, I&apos;m just starting to learn its deeper powers <b>😅</b></z><z id="t1661275802" t="Lidor Cohen I could clean the input before inputting into meander but I was hoping to be able to use meander for that as well..."><y>#</y><d>2022-08-23</d><h>17:30</h><r>Lidor Cohen</r>I could clean the input before inputting into meander but I was hoping to be able to use meander for that as well...</z><z id="t1661276292" t="noprompt For the CSV, personally, I would zipmap the fields or pluck them out with nth , etc. in a preprocessing step and then run them through meander."><y>#</y><d>2022-08-23</d><h>17:38</h><r>noprompt</r>For the CSV, personally, I would <code>zipmap</code> the fields or pluck them out with <code>nth</code>, etc. in a preprocessing step and then run them through meander.</z><z id="t1661276411" t="noprompt I would also index the tags as well. You can then do the joins much more easily (and more legibly)."><y>#</y><d>2022-08-23</d><h>17:40</h><r>noprompt</r>I would also index the tags as well. You can then do the joins much more easily (and more legibly).</z><z id="t1661276604" t="noprompt You could also drop the first rows (headers) from each of the two data sets."><y>#</y><d>2022-08-23</d><h>17:43</h><r>noprompt</r>You could also drop the first rows (headers) from each of the two data sets.</z><z id="t1661276776" t="noprompt Then you could {:products (m/scan {:as ?product ,,,}) :tags (m/scan {:name (m/pred #(contains ,,,) ,,,})} "><y>#</y><d>2022-08-23</d><h>17:46</h><r>noprompt</r>Then you could
<pre>{:products (m/scan {:as ?product ,,,})
 :tags (m/scan {:name (m/pred #(contains ,,,) ,,,})}</pre>
</z><z id="t1661278226" t="Lidor Cohen Great I was wondering where I should do the cleaning, now I have an answer 😁"><y>#</y><d>2022-08-23</d><h>18:10</h><r>Lidor Cohen</r>Great I was wondering where I should do the cleaning, now I have an answer <b>😁</b></z><z id="t1661278238" t="Lidor Cohen Thank you!"><y>#</y><d>2022-08-23</d><h>18:10</h><r>Lidor Cohen</r>Thank you!</z><z id="t1661279066" t="noprompt LMK if you need help with next steps. 🙂"><y>#</y><d>2022-08-23</d><h>18:24</h><r>noprompt</r>LMK if you need help with next steps. <b>🙂</b></z><z id="t1661298643" t="Lidor Cohen So I came up with this: (m/search data {:products (m/scan {&quot;Product Name&quot; ?product-name &quot;Meta Tag Description&quot; ?description &quot;Price&quot; ?price &quot;Image(Main image)&quot; ?media &quot;Length&quot; ?length &quot;Width&quot; ?width &quot;height&quot; ?height &quot;Weight&quot; ?weight &quot;Manufacturer&quot; ?manufacturer &quot;Product Tags&quot; ?product-tags &quot;Categories id&quot; ?categories-id}) :categories (m/scan {&quot;Category ID&quot; (m/pred #(some #{%} (split ?categories-id &quot;;&quot;))) &quot;Category Name&quot; ?category-name &quot;Parent&quot; ?parent})} {&quot;name&quot; ?product-name &quot;description&quot; ?description &quot;price&quot; ?price &quot;media&quot; {&quot;data&quot; {&quot;src&quot; ?media}} &quot;categories-id&quot; (split ?categories-id &quot;;&quot;) &quot;category-name&quot; [?category-name]}) And it seems that the second scan emits every match as its own entry so instead of this: [{&quot;name&quot; &quot;some-name&quot; &quot;description&quot; &quot;some long description&quot; &quot;price&quot; 42 &quot;media&quot; {&quot;data&quot; {&quot;src&quot; &quot;&quot;}} &quot;product_tags&quot; [{&quot;name&quot; &quot;catcat&quot; &quot;parent&quot; &quot;catcat&apos;s mom&quot;} {&quot;name&quot; &quot;catcat&apos;s mom&quot; &quot;parent&quot; &quot;&quot;} ...]} ... ] I get this: [{&quot;name&quot; &quot;some-name&quot; &quot;description&quot; &quot;some long description&quot; &quot;price&quot; 42 &quot;media&quot; {&quot;data&quot; {&quot;src&quot; &quot;&quot;}} &quot;product_tags&quot; [{&quot;name&quot; &quot;catcat&quot; &quot;parent&quot; &quot;catcat&apos;s mom&quot;}]} {&quot;name&quot; &quot;some-name&quot; &quot;description&quot; &quot;some long description&quot; &quot;price&quot; 42 &quot;media&quot; {&quot;data&quot; {&quot;src&quot; &quot;&quot;}} &quot;product_tags&quot; [{&quot;name&quot; &quot;catcat&apos;s mom&quot; &quot;parent&quot; &quot;&quot;}]} ... ] which actually makes sense as I understand meander better, but for my task I need to aggregate all of the tags under the relevant product&apos;s &quot;product_tags&quot;"><y>#</y><d>2022-08-23</d><h>23:50</h><r>Lidor Cohen</r>So I came up with this:
<pre>(m/search data

            {:products (m/scan {&quot;Product Name&quot; ?product-name
                                &quot;Meta Tag Description&quot; ?description
                                &quot;Price&quot; ?price
                                &quot;Image(Main image)&quot; ?media
                                &quot;Length&quot; ?length
                                &quot;Width&quot; ?width
                                &quot;height&quot; ?height
                                &quot;Weight&quot; ?weight
                                &quot;Manufacturer&quot; ?manufacturer
                                &quot;Product Tags&quot; ?product-tags
                                &quot;Categories id&quot; ?categories-id})

             :categories (m/scan {&quot;Category ID&quot; (m/pred #(some #{%} (split ?categories-id &quot;;&quot;)))
                                  &quot;Category Name&quot; ?category-name
                                  &quot;Parent&quot; ?parent})}


            {&quot;name&quot; ?product-name
             &quot;description&quot; ?description
             &quot;price&quot; ?price
             &quot;media&quot; {&quot;data&quot; {&quot;src&quot; ?media}}
             &quot;categories-id&quot; (split ?categories-id &quot;;&quot;)
             &quot;category-name&quot; [?category-name]})</pre>
And it seems that the second scan emits every match as its own entry so instead of this:
<pre>[{&quot;name&quot; &quot;some-name&quot;
 &quot;description&quot; &quot;some long description&quot;
 &quot;price&quot; 42
 &quot;media&quot; {&quot;data&quot; {&quot;src&quot; &quot;&quot;}}
 &quot;product_tags&quot; [{&quot;name&quot; &quot;catcat&quot; &quot;parent&quot; &quot;catcat&apos;s mom&quot;}
                 {&quot;name&quot; &quot;catcat&apos;s mom&quot; &quot;parent&quot; &quot;&quot;}
                 ...]}
 ...
]</pre>
I get this:
<pre>[{&quot;name&quot; &quot;some-name&quot;
 &quot;description&quot; &quot;some long description&quot;
 &quot;price&quot; 42
 &quot;media&quot; {&quot;data&quot; {&quot;src&quot; &quot;&quot;}}
 &quot;product_tags&quot; [{&quot;name&quot; &quot;catcat&quot; &quot;parent&quot; &quot;catcat&apos;s mom&quot;}]}
{&quot;name&quot; &quot;some-name&quot;
 &quot;description&quot; &quot;some long description&quot;
 &quot;price&quot; 42
 &quot;media&quot; {&quot;data&quot; {&quot;src&quot; &quot;&quot;}}
 &quot;product_tags&quot; [{&quot;name&quot; &quot;catcat&apos;s mom&quot; &quot;parent&quot; &quot;&quot;}]}
 ...
]</pre>
which actually makes sense as I understand meander better, but for my task I need to aggregate all of the tags under the relevant product&apos;s &quot;product_tags&quot;</z><z id="t1661324851" t="Lidor Cohen I figured what I&apos;m looking for is a join + group by"><y>#</y><d>2022-08-24</d><h>07:07</h><r>Lidor Cohen</r>I figured what I&apos;m looking for is a join + group by</z><z id="t1661329098" t="Lidor Cohen I found a previous answer that suggests to do the group-by out side of meander. can&apos;t wait to see how far will you go with meander, for now I&apos;m happy with the current solution, thank you! P.S I invested time learning meander as I believe in it as a general declarative solution for the complicated data transformations in our company, so... rooting for ya!"><y>#</y><d>2022-08-24</d><h>08:18</h><r>Lidor Cohen</r>I found a previous answer that suggests to do the group-by out side of meander.
can&apos;t wait to see how far will you go with meander, for now I&apos;m happy with the current solution, thank you!

P.S
I invested time learning meander as I believe in it as a general declarative solution for the complicated data transformations in our company, so... rooting for ya!</z><z id="t1661311828" t="nonrecursive hello again friends, is it possible to do something like a list comprehension like (m/rewrite [:a [0 1 2]] ??? ???) ;; =&gt; [[:a 0] [:a 1] [:a 2]] thank you!"><y>#</y><d>2022-08-24</d><h>03:30</h><w>nonrecursive</w>hello again friends, is it possible to do something like a list comprehension like

<pre>(m/rewrite [:a [0 1 2]]
  ???
  ???)
;; =&gt;
[[:a 0]
 [:a 1]
 [:a 2]]</pre>
thank you!</z><z id="t1661311947" t="nonrecursive oh wait this works (m/rewrite [:a [0 1 2]] [?i [!o ...]] [[?i !o] ...]) I tried to come up with a simple example of what I’m trying to do but perhaps it was too simple"><y>#</y><d>2022-08-24</d><h>03:32</h><w>nonrecursive</w>oh wait this works
<pre>(m/rewrite [:a [0 1 2]]
  [?i [!o ...]]
  [[?i !o] ...])</pre>
I tried to come up with a simple example of what I’m trying to do but perhaps it was too simple</z><z id="t1661316276" t="Ben Sless There&apos;s actually an example in the cookbook which might apply here"><y>#</y><d>2022-08-24</d><h>04:44</h><r>Ben Sless</r>There&apos;s actually an example in the cookbook which might apply here</z><z id="t1661316311" t="Ben Sless https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#nested-repetition"><y>#</y><d>2022-08-24</d><h>04:45</h><r>Ben Sless</r><a href="https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#nested-repetition" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#nested-repetition</a></z><z id="t1661316343" t="Ben Sless The problem is there is no control for greed (philosophical, aren&apos;t we?) So you need to qualify it yourself"><y>#</y><d>2022-08-24</d><h>04:45</h><r>Ben Sless</r>The problem is there is no control for greed (philosophical, aren&apos;t we?) So you need to qualify it yourself</z><z id="t1661641160" t="timothypratley Hold onto your hat 🎩 here comes another zany syntax 💡 idea: So . has a meaning in vectors/sequences, but AFAIK isn&apos;t meaningful in maps. What would it mean in a map? Now in JavaScript es6 introduced the whole nifty object constructor shorthand thing: {a} means {:a 1} where a is bound to 1 . This is actually pretty nice when you use long names: {very-descriptive-name} instead of {:very-descriptive-name very-descriptive-name} ES6 also allows you do do things like {foo: 1, ...m} which is kinda the same thing as Meander: (subst {:foo 1, &amp; ?m}) But what Meander is missing is the nifty symbol =&gt; key value pair trick. So that&apos;s one thing you could use . for in a map! (subst {. very-descriptive-name}) =&gt; {:very-descriptive-name very-descriptive-name} Well, it&apos;s a little bit more complicated than that because you need to decide exactly what kind of things can be treated like this... should it be limited to memory variables? Any bound symbol? Not sure, but it is an interesting substitution use case. Pros: being able to provide a key/value pair in a single symbol is very popular in JavaScript. If substitution were allowed for this operator on non memory variables it might make for a very concise collection constructor. Cons: For rewrite patterns, we usually match on a single character name anyway, so it&apos;s likely only useful in the substitution phase, not with matches. Alternatives: % might be a better operator than . because it kinda looks like a key value thingy with the dot slash dot."><y>#</y><d>2022-08-27</d><h>22:59</h><w>timothypratley</w>Hold onto your hat <b>🎩</b> here comes another zany syntax <b>💡</b> idea:
So <code>.</code> has a meaning in vectors/sequences, but AFAIK isn&apos;t meaningful in maps.
What would it mean in a map?
Now in JavaScript es6 introduced the whole nifty object constructor shorthand thing:
<code>{a}</code> means <code>{:a 1}</code> where <code>a</code> is bound to <code>1</code>.
This is actually pretty nice when you use long names:
<code>{very-descriptive-name}</code> instead of <code>{:very-descriptive-name very-descriptive-name}</code>
ES6 also allows you do do things like <code>{foo: 1, ...m}</code> which is kinda the same thing as Meander: <code>(subst {:foo 1, &amp; ?m})</code>
But what Meander is missing is the nifty symbol =&gt; key value pair trick.
So that&apos;s one thing you could use <code>.</code> for in a map!
<code>(subst {. very-descriptive-name}) =&gt; {:very-descriptive-name very-descriptive-name}</code>
Well, it&apos;s a little bit more complicated than that because you need to decide exactly what kind of things can be treated like this... should it be limited to memory variables? Any bound symbol? Not sure, but it is an interesting substitution use case.
Pros: being able to provide a key/value pair in a single symbol is very popular in JavaScript. If substitution were allowed for this operator on non memory variables it might make for a very concise collection constructor.
Cons: For rewrite patterns, we usually match on a single character name anyway, so it&apos;s likely only useful in the substitution phase, not with matches.
Alternatives: <code>%</code> might be a better operator than <code>.</code> because it kinda looks like a key value thingy with the dot slash dot.</z><z id="t1661807215" t="noprompt This can be done on the zeta branch entirely by the user. 🙂"><y>#</y><d>2022-08-29</d><h>21:06</h><r>noprompt</r>This can be done on the <code>zeta</code> branch entirely by the user. <b>🙂</b></z><z id="t1661807304" t="noprompt What is on zeta right now is probably in a stablish state (because I can&apos;t keep experimenting). I mostly need to organize and document it."><y>#</y><d>2022-08-29</d><h>21:08</h><r>noprompt</r>What is on <code>zeta</code> right now is probably in a stablish state (because I can&apos;t keep experimenting). I mostly need to organize and document it.</z><z id="t1661807345" t="noprompt zeta for the time being will probably be much slower than epsilon until a compiler can be devised for it."><y>#</y><d>2022-08-29</d><h>21:09</h><r>noprompt</r><code>zeta</code> for the time being will probably be much slower than <code>epsilon</code> until a compiler can be devised for it.</z><z id="t1661807362" t="noprompt A big part of the problem is CLJS."><y>#</y><d>2022-08-29</d><h>21:09</h><r>noprompt</r>A big part of the problem is CLJS.</z><z id="t1661807374" t="noprompt I really hate CLJS and don&apos;t really want to support it."><y>#</y><d>2022-08-29</d><h>21:09</h><r>noprompt</r>I really hate CLJS and don&apos;t really want to support it.</z><z id="t1661807397" t="timothypratley why&apos;s that?"><y>#</y><d>2022-08-29</d><h>21:09</h><r>timothypratley</r>why&apos;s that?</z><z id="t1661807406" t="noprompt It&apos;s just a pain the ass."><y>#</y><d>2022-08-29</d><h>21:10</h><r>noprompt</r>It&apos;s just a pain the ass.</z><z id="t1661807408" t="noprompt 🙂"><y>#</y><d>2022-08-29</d><h>21:10</h><r>noprompt</r><b>🙂</b></z><z id="t1661807410" t="timothypratley hahaha"><y>#</y><d>2022-08-29</d><h>21:10</h><r>timothypratley</r>hahaha</z><z id="t1661807412" t="timothypratley fair enough."><y>#</y><d>2022-08-29</d><h>21:10</h><r>timothypratley</r>fair enough.</z><z id="t1661807433" t="noprompt What I have on zeta probably mostly works in CLJS."><y>#</y><d>2022-08-29</d><h>21:10</h><r>noprompt</r>What I have on <code>zeta</code> probably mostly works in CLJS.</z><z id="t1661807479" t="noprompt Depending on what google closure can do, it may perform well too."><y>#</y><d>2022-08-29</d><h>21:11</h><r>noprompt</r>Depending on what google closure can do, it may perform well too.</z><z id="t1661807523" t="noprompt zeta is different from previous versions in many ways."><y>#</y><d>2022-08-29</d><h>21:12</h><r>noprompt</r><code>zeta</code> is different from previous versions in many ways.</z><z id="t1661807623" t="noprompt I think I may talk about it toward the end of next month at a scicloj meetup."><y>#</y><d>2022-08-29</d><h>21:13</h><r>noprompt</r>I think I may talk about it toward the end of next month at a scicloj meetup.</z><z id="t1661807659" t="noprompt Mostly, I&apos;m working on it when I feel the urge (in between trying to pick up ML/AI)."><y>#</y><d>2022-08-29</d><h>21:14</h><r>noprompt</r>Mostly, I&apos;m working on it when I feel the urge (in between trying to pick up ML/AI).</z><z id="t1661807673" t="noprompt Lotta time in python."><y>#</y><d>2022-08-29</d><h>21:14</h><r>noprompt</r>Lotta time in python.</z><z id="t1661807711" t="noprompt Not a bad language, but not a great language either."><y>#</y><d>2022-08-29</d><h>21:15</h><r>noprompt</r>Not a bad language, but not a great language either.</z><z id="t1661807724" t="noprompt I really wanna compile to it. 😛"><y>#</y><d>2022-08-29</d><h>21:15</h><r>noprompt</r>I really wanna compile to it. <b>😛</b></z><z id="t1661807731" t="timothypratley 🙂"><y>#</y><d>2022-08-29</d><h>21:15</h><r>timothypratley</r><b>🙂</b></z><z id="t1661807776" t="noprompt But I&apos;m trying to stay focused on picking up all the ML tech and not get bogged down by my own language snobbery."><y>#</y><d>2022-08-29</d><h>21:16</h><r>noprompt</r>But I&apos;m trying to stay focused on picking up all the ML tech and not get bogged down by my own language snobbery.</z><z id="t1661807892" t="noprompt [:attrs {:href &quot;/_/_/users/U06S1EJPL&quot;}] I think I will use your syntax concept as an example."><y>#</y><d>2022-08-29</d><h>21:18</h><r>noprompt</r><a>@U06S1EJPL</a> I think I will use your syntax concept as an example.</z><z id="t1661807920" t="noprompt I&apos;ll post it here when I get around to hacking it together."><y>#</y><d>2022-08-29</d><h>21:18</h><r>noprompt</r>I&apos;ll post it here when I get around to hacking it together.</z><z id="t1661716441" t="timothypratley (s/rewrite 1 2 ?x (m/cata 1)) Syntax error macroexpanding meander.substitute.epsilon/substitute at (/private/var/folders/8r/y2d3thln6s3fyrl_s6vknb440000gn/T/form-init7105795044570115737.clj:1:1). cata not allowed here (m/rewrite :a 1 2 ?x (m/cata 1)) =&gt; 2 ^^ This is confusing to me 🙂"><y>#</y><d>2022-08-28</d><h>19:54</h><w>timothypratley</w><pre>(s/rewrite 1 2 ?x (m/cata 1))
Syntax error macroexpanding meander.substitute.epsilon/substitute at (/private/var/folders/8r/y2d3thln6s3fyrl_s6vknb440000gn/T/form-init7105795044570115737.clj:1:1).
cata not allowed here
(m/rewrite :a 1 2 ?x (m/cata 1))
=&gt; 2</pre>
^^ This is confusing to me <b>🙂</b></z><z id="t1661807971" t="noprompt Is s/rewrite expanding incorrectly?"><y>#</y><d>2022-08-29</d><h>21:19</h><r>noprompt</r>Is <code>s/rewrite</code> expanding incorrectly?</z><z id="t1661808009" t="noprompt I think that error is when m/cata is on the left side, top level."><y>#</y><d>2022-08-29</d><h>21:20</h><r>noprompt</r>I think that error is when <code>m/cata</code> is on the left side, top level.</z><z id="t1661808021" t="noprompt Expansion might be the issue"><y>#</y><d>2022-08-29</d><h>21:20</h><r>noprompt</r>Expansion might be the issue</z><z id="t1661808146" t="timothypratley no big deal, I wouldn&apos;t worry about it, just reported it. ¯\(ツ)/¯"><y>#</y><d>2022-08-29</d><h>21:22</h><r>timothypratley</r>no big deal, I wouldn&apos;t worry about it, just reported it. ¯\(ツ)/¯</z><z id="t1661808166" t="timothypratley one thing I was wondering was whether meander does or can do tail recursion"><y>#</y><d>2022-08-29</d><h>21:22</h><r>timothypratley</r>one thing I was wondering was whether meander does or can do tail recursion</z><z id="t1661808180" t="timothypratley I was messing with using m/app recur"><y>#</y><d>2022-08-29</d><h>21:23</h><r>timothypratley</r>I was messing with using m/app recur</z><z id="t1661808193" t="timothypratley and it kinda almost does something but complains about the number of args"><y>#</y><d>2022-08-29</d><h>21:23</h><r>timothypratley</r>and it kinda almost does something but complains about the number of args</z><z id="t1661808200" t="timothypratley probably due to function nesting"><y>#</y><d>2022-08-29</d><h>21:23</h><r>timothypratley</r>probably due to function nesting</z><z id="t1661808205" t="timothypratley lol I have no idea what I&apos;m talking about"><y>#</y><d>2022-08-29</d><h>21:23</h><r>timothypratley</r>lol I have no idea what I&apos;m talking about</z><z id="t1661808235" t="timothypratley I was doing some reasonably weird stuff admittedly."><y>#</y><d>2022-08-29</d><h>21:23</h><r>timothypratley</r>I was doing some reasonably weird stuff admittedly.</z><z id="t1661808349" t="timothypratley But it seemed to work fine with m/rewrite so that&apos;s good 🙂"><y>#</y><d>2022-08-29</d><h>21:25</h><r>timothypratley</r>But it seemed to work fine with m/rewrite so that&apos;s good <b>🙂</b></z><z id="t1661808733" t="timothypratley To answer you question directly: (macroexpand &apos;(s/rewrite 1 2 ?x (m/cata 1))) =&gt; (fn* ([x__7086__auto__] (meander.match.epsilon/find x__7086__auto__ 1 (meander.substitute.epsilon/substitute 2) ?x (meander.substitute.epsilon/substitute (m/cata 1)) _ meander.strategy.epsilon/*fail*))) and the other one: (macroexpand &apos;(m/rewrite :a 1 2 ?x (m/cata 1))) =&gt; (let* [TARGET__8094 :a] (clojure.core/let [R__8099 (clojure.core/letfn [(C__8092 [TARGET__8094] (clojure.core/letfn [(state__8096 [] (if (clojure.core/= TARGET__8094 1) [2] (state__8097))) (state__8097 [] (clojure.core/let [?x TARGET__8094] (try [(clojure.core/let [R__8093 (C__8092 1)] (if (meander.match.runtime.epsilon/fail? R__8093) (throw meander.substitute.runtime.epsilon/FAIL) (clojure.core/nth R__8093 0)))] (catch clojure.lang.ExceptionInfo e__6502__auto__ (if (meander.substitute.runtime.epsilon/fail? e__6502__auto__) meander.match.runtime.epsilon/FAIL (throw e__6502__auto__))))))] (state__8096)))] (clojure.core/let [R__8098 (C__8092 TARGET__8094)] (if (meander.match.runtime.epsilon/fail? R__8098) meander.match.runtime.epsilon/FAIL (clojure.core/let [[R__8095] R__8098] R__8095))))] (if (meander.match.runtime.epsilon/fail? R__8099) nil R__8099))) "><y>#</y><d>2022-08-29</d><h>21:32</h><r>timothypratley</r>To answer you question directly:
<pre>(macroexpand &apos;(s/rewrite 1 2 ?x (m/cata 1)))
=&gt;
(fn*
 ([x__7086__auto__]
  (meander.match.epsilon/find
   x__7086__auto__
   1
   (meander.substitute.epsilon/substitute 2)
   ?x
   (meander.substitute.epsilon/substitute (m/cata 1))
   _
   meander.strategy.epsilon/*fail*)))</pre>
and the other one:

<pre>(macroexpand &apos;(m/rewrite :a 1 2 ?x (m/cata 1)))
=&gt;
(let*
 [TARGET__8094 :a]
 (clojure.core/let
  [R__8099
   (clojure.core/letfn
    [(C__8092
      [TARGET__8094]
      (clojure.core/letfn
       [(state__8096 [] (if (clojure.core/= TARGET__8094 1) [2] (state__8097)))
        (state__8097
         []
         (clojure.core/let
          [?x TARGET__8094]
          (try
           [(clojure.core/let
             [R__8093 (C__8092 1)]
             (if
              (meander.match.runtime.epsilon/fail? R__8093)
              (throw meander.substitute.runtime.epsilon/FAIL)
              (clojure.core/nth R__8093 0)))]
           (catch
            clojure.lang.ExceptionInfo
            e__6502__auto__
            (if
             (meander.substitute.runtime.epsilon/fail? e__6502__auto__)
             meander.match.runtime.epsilon/FAIL
             (throw e__6502__auto__))))))]
       (state__8096)))]
    (clojure.core/let
     [R__8098 (C__8092 TARGET__8094)]
     (if
      (meander.match.runtime.epsilon/fail? R__8098)
      meander.match.runtime.epsilon/FAIL
      (clojure.core/let [[R__8095] R__8098] R__8095))))]
  (if (meander.match.runtime.epsilon/fail? R__8099) nil R__8099)))</pre>
</z><z id="t1661808756" t="timothypratley ¯\(ツ)/¯"><y>#</y><d>2022-08-29</d><h>21:32</h><r>timothypratley</r>¯\(ツ)/¯</z><z id="t1661808783" t="timothypratley I think just ignore it for now."><y>#</y><d>2022-08-29</d><h>21:33</h><r>timothypratley</r>I think just ignore it for now.</z><z id="t1662668222" t="wilkerlucio hello, is there a way to match over a dynamic pattern in meander? for example: (let [subject {:foo &quot;bar&quot; :baz &quot;oi&quot;} pattern {:foo &quot;bar&quot;}] (m/find subject pattern true _ false))"><y>#</y><d>2022-09-08</d><h>20:17</h><w>wilkerlucio</w>hello, is there a way to match over a dynamic pattern in meander? for example:

<pre>(let [subject {:foo &quot;bar&quot; :baz &quot;oi&quot;}
        pattern {:foo &quot;bar&quot;}]
    (m/find subject pattern true _ false))</pre></z><z id="t1662668233" t="wilkerlucio I tried ~pattern but that still doesn&apos;t work"><y>#</y><d>2022-09-08</d><h>20:17</h><r>wilkerlucio</r>I tried <code>~pattern</code> but that still doesn&apos;t work</z><z id="t1662668249" t="wilkerlucio I like to have a pattern that comes as an input from the user, is there a way to make it work?"><y>#</y><d>2022-09-08</d><h>20:17</h><r>wilkerlucio</r>I like to have a pattern that comes as an input from the user, is there a way to make it work?</z><z id="t1662669147" t="markaddleman Does the meander interpreter work for your use case?"><y>#</y><d>2022-09-08</d><h>20:32</h><r>markaddleman</r>Does the meander interpreter work for your use case?</z><z id="t1662669170" t="markaddleman I’ve used it successfully but it’s much slower than the compiled macro"><y>#</y><d>2022-09-08</d><h>20:32</h><r>markaddleman</r>I’ve used it successfully but it’s much slower than the compiled macro</z><z id="t1662669559" t="wilkerlucio what is the meander interpreter?"><y>#</y><d>2022-09-08</d><h>20:39</h><r>wilkerlucio</r>what is the meander interpreter?</z><z id="t1662669575" t="wilkerlucio how can I try it?"><y>#</y><d>2022-09-08</d><h>20:39</h><r>wilkerlucio</r>how can I try it?</z><z id="t1662670191" t="markaddleman check out meander.interpreter.epsilon"><y>#</y><d>2022-09-08</d><h>20:49</h><r>markaddleman</r>check out <code>meander.interpreter.epsilon</code></z><z id="t1662670237" t="wilkerlucio looking at it, but not sure how to use, can you give me an example snippet?"><y>#</y><d>2022-09-08</d><h>20:50</h><r>wilkerlucio</r>looking at it, but not sure how to use, can you give me an example snippet?</z><z id="t1662670291" t="markaddleman We just recently stopped using the interpreter so I don’t have an example handy…. I can dig through our git history and get you one in an hour or so"><y>#</y><d>2022-09-08</d><h>20:51</h><r>markaddleman</r>We just recently stopped using the interpreter so I don’t have an example handy…. I can dig through our git history and get you one in an hour or so</z><z id="t1662670323" t="wilkerlucio thanks 🙏"><y>#</y><d>2022-09-08</d><h>20:52</h><r>wilkerlucio</r>thanks <b>🙏</b></z><z id="t1662670965" t="markaddleman i just pulled this: (defn meander-pattern [m match-sym] [&apos;_ &apos;... (list `mi/and m match-sym) &apos;. &apos;_ &apos;...]) (defn search [m d] (let [s (mi/searcher (meander-pattern m &apos;?p) &apos;?p)] (s (vec d)))) "><y>#</y><d>2022-09-08</d><h>21:02</h><r>markaddleman</r>i just pulled this:
<pre>(defn meander-pattern [m match-sym]
  [&apos;_ &apos;... (list `mi/and m match-sym) &apos;. &apos;_ &apos;...])

(defn search [m d]
  (let [s (mi/searcher (meander-pattern m &apos;?p)
                       &apos;?p)]
    (s (vec d))))</pre>
</z><z id="t1662670999" t="markaddleman From what I recall, you can build the matching pattern as a flat vector and pass it to mi/searcher"><y>#</y><d>2022-09-08</d><h>21:03</h><r>markaddleman</r>From what I recall, you can build the matching pattern as a flat vector and pass it to <code>mi/searcher</code></z><z id="t1662672384" t="markaddleman The thing to understand (probably obvious from the code) is that mi/searcher returns a single arity function that returns the result of the pattern match"><y>#</y><d>2022-09-08</d><h>21:26</h><r>markaddleman</r>The thing to understand (probably obvious from the code) is that <code>mi/searcher</code> returns a single arity function that returns the result of the pattern match</z><z id="t1662672880" t="markaddleman Is that helpful? Now that I remember, I could create a working example pretty easily"><y>#</y><d>2022-09-08</d><h>21:34</h><r>markaddleman</r>Is that helpful?  Now that I remember, I could create a working example pretty easily</z><z id="t1662676645" t="wilkerlucio hello, I think I got it 🙂"><y>#</y><d>2022-09-08</d><h>22:37</h><r>wilkerlucio</r>hello, I think I got it <b>🙂</b></z><z id="t1662676645" t="wilkerlucio (let [subject {:foo &quot;bar&quot; :baz &quot;oi&quot;} pattern {:foo &quot;bar&quot;}] ((mi/finder pattern (constantly true)) subject))"><y>#</y><d>2022-09-08</d><h>22:37</h><r>wilkerlucio</r>(let [subject {:foo &quot;bar&quot; :baz &quot;oi&quot;}
        pattern {:foo &quot;bar&quot;}]
    ((mi/finder pattern (constantly true)) subject))</z><z id="t1662676748" t="wilkerlucio and speed still on par with my previous non-meander implementation for the simple cases 🙂"><y>#</y><d>2022-09-08</d><h>22:39</h><r>wilkerlucio</r>and speed still on par with my previous non-meander implementation for the simple cases <b>🙂</b></z><z id="t1662676773" t="markaddleman Yeah, I’m pretty amazed at meander 🙂"><y>#</y><d>2022-09-08</d><h>22:39</h><r>markaddleman</r>Yeah, I’m pretty amazed at meander <b>🙂</b></z><z id="t1662676785" t="markaddleman Even after using it for almost two years"><y>#</y><d>2022-09-08</d><h>22:39</h><r>markaddleman</r>Even after using it for almost two years</z><z id="t1662676801" t="wilkerlucio this is a thing I would vote to be on Clojure core, so useful 😄"><y>#</y><d>2022-09-08</d><h>22:40</h><r>wilkerlucio</r>this is a thing I would vote to be on Clojure core, so useful <b>😄</b></z><z id="t1662676817" t="markaddleman I completely agree"><y>#</y><d>2022-09-08</d><h>22:40</h><r>markaddleman</r>I completely agree</z><z id="t1662676893" t="wilkerlucio do you know what I need to change to make this work?"><y>#</y><d>2022-09-08</d><h>22:41</h><r>wilkerlucio</r>do you know what I need to change to make this work?</z><z id="t1662676895" t="wilkerlucio (let [subject {:foo &quot;bar&quot; :baz &quot;oi&quot;} pattern {:foo `(m/pred string?)}] ((mi/finder pattern (constantly true)) subject))"><y>#</y><d>2022-09-08</d><h>22:41</h><r>wilkerlucio</r><pre>(let [subject {:foo &quot;bar&quot; :baz &quot;oi&quot;}
        pattern {:foo `(m/pred string?)}]
    ((mi/finder pattern (constantly true)) subject))</pre></z><z id="t1662676910" t="wilkerlucio from that I got a:"><y>#</y><d>2022-09-08</d><h>22:41</h><r>wilkerlucio</r>from that I got a:</z><z id="t1662676911" t="wilkerlucio Execution error (ArityException) at meander.interpreter.epsilon/eval27313$fn (epsilon.cljc:286). Wrong number of args (0) passed to: meander.pattern-factory.epsilon/all"><y>#</y><d>2022-09-08</d><h>22:41</h><r>wilkerlucio</r><pre>Execution error (ArityException) at meander.interpreter.epsilon/eval27313$fn (epsilon.cljc:286).
Wrong number of args (0) passed to: meander.pattern-factory.epsilon/all</pre></z><z id="t1662676930" t="markaddleman checking…"><y>#</y><d>2022-09-08</d><h>22:42</h><r>markaddleman</r>checking…</z><z id="t1662677186" t="markaddleman This returns a good result: (let [subject {:foo &quot;bar&quot; :baz &quot;oi&quot;} pattern {:foo (list `m/pred string? &apos;?var)}] ((mi/finder pattern (constantly true)) subject)) "><y>#</y><d>2022-09-08</d><h>22:46</h><r>markaddleman</r>This returns a good result:
<pre>(let [subject {:foo &quot;bar&quot; :baz &quot;oi&quot;}
        pattern {:foo (list `m/pred string? &apos;?var)}]
    ((mi/finder pattern (constantly true)) subject))</pre>
</z><z id="t1662677214" t="markaddleman I think m/pred is arity two"><y>#</y><d>2022-09-08</d><h>22:46</h><r>markaddleman</r>I think m/pred is arity two</z><z id="t1662677301" t="wilkerlucio cool, makes sense, I was assuming the other works because this is fine: (let [subject {:foo &quot;bar&quot; :baz &quot;oi&quot;}] (m/find subject {:foo (m/pred string?)} true _ false))"><y>#</y><d>2022-09-08</d><h>22:48</h><r>wilkerlucio</r>cool, makes sense, I was assuming the other works because this is fine:
<pre>(let [subject {:foo &quot;bar&quot; :baz &quot;oi&quot;}]
    (m/find subject {:foo (m/pred string?)} true _ false))</pre></z><z id="t1662677309" t="wilkerlucio but I guess from m/find some magic happens"><y>#</y><d>2022-09-08</d><h>22:48</h><r>wilkerlucio</r>but I guess from <code>m/find</code> some magic happens</z><z id="t1662677318" t="markaddleman That’s my guess too."><y>#</y><d>2022-09-08</d><h>22:48</h><r>markaddleman</r>That’s my guess too.</z><z id="t1662677347" t="markaddleman also, make sure that string? is a function and not a symbol"><y>#</y><d>2022-09-08</d><h>22:49</h><r>markaddleman</r>also, make sure that <code>string?</code> is a function and not a symbol</z><z id="t1662677356" t="wilkerlucio yup, got it :)"><y>#</y><d>2022-09-08</d><h>22:49</h><r>wilkerlucio</r>yup, got it :)</z><z id="t1662897980" t="Joe Hi! I&apos;m planning to user Meander on the back and front end, with the back end passing the necessary pieces to the front, and then the front end turning those into a valid match expression So the back end would deliver something like this (edn format), &apos;{:name &quot;test&quot;, :schema [:map [:a :int] [:b :int]], :pattern {:a ?a, :b ?b}, :target {:new-a ?a, :new-b ?b}} And the front end turns that into a function (fn [data] (e/match data {:a ?a, :b ?b} {:new-a ?a, :new-b ?b})) Which could then be used. In the back end I can just create that form and evaluate it. But I don&apos;t think I can do that from the front. Is there a way I can get this to work? Or would it just be better to have the front end pass the data to the back and have Meander do the xforms there?"><y>#</y><d>2022-09-11</d><h>12:06</h><w>Joe</w>Hi!
I&apos;m planning to user Meander on the back and front end, with the back end passing the necessary pieces to the front, and then the front end turning those into a valid match expression
So the back end would deliver something like this (edn format),
<pre>&apos;{:name &quot;test&quot;, :schema [:map [:a :int] [:b :int]], 
  :pattern {:a ?a, :b ?b}, 
  :target {:new-a ?a, :new-b ?b}}</pre>
And the front end turns that into a function
<pre>(fn [data] (e/match data {:a ?a, :b ?b} {:new-a ?a, :new-b ?b}))</pre>
Which could then be used.

In the back end I can just create that form and evaluate it. But I don&apos;t think I can do that from the front. Is there a way I can get this to work? Or would it just be better to have the front end pass the data to the back and have Meander do the xforms there?</z><z id="t1663000885" t="noprompt There is an interpreter namespace which can take a quoted form an interpret it. It&apos;s cljc so it will work everywhere."><y>#</y><d>2022-09-12</d><h>16:41</h><r>noprompt</r>There is an interpreter namespace which can take a quoted form an interpret it. It&apos;s cljc so it will work everywhere.</z><z id="t1663249335" t="Joe That&apos;s perfect, thanks!"><y>#</y><d>2022-09-15</d><h>13:42</h><r>Joe</r>That&apos;s perfect, thanks!</z><z id="t1663487304" t="Joe [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] , out of interest, I can see in the interpreter namespace there&apos;s a finder, searcher, rewriter to match the main ns find, search, rewrite - is there a reason there isn&apos;t a matcher to go with the main ns match?"><y>#</y><d>2022-09-18</d><h>07:48</h><r>Joe</r><a>@U06MDAPTP</a>, out of interest, I can see in the interpreter namespace there&apos;s a finder, searcher, rewriter to match the main ns find, search, rewrite - is there a reason there isn&apos;t a matcher to go with the main ns match?</z><z id="t1663520646" t="noprompt Its been a while so I can&apos;t remember why I didn&apos;t add it. If I had to guess its probably because I was being lazy. 🙂"><y>#</y><d>2022-09-18</d><h>17:04</h><r>noprompt</r>Its been a while so I can&apos;t remember why I didn&apos;t add it. If I had to guess its probably because I was being lazy. <b>🙂</b></z><z id="t1663520728" t="noprompt It would basically amount to asking if a pattern is ambiguous. IAmbiguous (-ambiguous? [this context] ,,,) "><y>#</y><d>2022-09-18</d><h>17:05</h><r>noprompt</r>It would basically amount to asking if a pattern is ambiguous.
<pre>IAmbiguous
(-ambiguous? [this context] ,,,) </pre>
</z><z id="t1663278036" t="noprompt https://clojurians.slack.com/archives/C03RZRRMP/p1663275996996409"><y>#</y><d>2022-09-15</d><h>21:40</h><w>noprompt</w><a href="https://clojurians.slack.com/archives/C03RZRRMP/p1663275996996409" target="_blank">https://clojurians.slack.com/archives/C03RZRRMP/p1663275996996409</a></z><z id="t1663278079" t="noprompt I don’t have a concrete plan for the discussion just yet but I plan on talking about the history of the library and where it is now."><y>#</y><d>2022-09-15</d><h>21:41</h><w>noprompt</w>I don’t have a concrete plan for the discussion just yet but I plan on talking about the history of the library and where it is now.</z><z id="t1663278315" t="noprompt I kinda sorta wanna demo zeta with some data generation. It probably won’t be practical for most Clojure users, but I want to use this opportunity as an excuse to explore the topic of Shape Grammars and show how zeta can generate structured data that can be used for in application like Houdini to create procedural 3D content."><y>#</y><d>2022-09-15</d><h>21:45</h><w>noprompt</w>I kinda sorta wanna demo <code>zeta</code> with some data generation. It probably won’t be practical for most Clojure users, but I want to use this opportunity as an excuse to explore the topic of Shape Grammars and show how <code>zeta</code> can generate structured data that can be used for in application like Houdini to create procedural 3D content.</z><z id="t1663278496" t="noprompt So many of Clojure discussions orbit around business or theoretical use cases. I think it would be more fun to do something involving a creative tool like Houdini (which I think many people in the Clojure community might actually appreciate in terms of a programming environment with a commitment to data)."><y>#</y><d>2022-09-15</d><h>21:48</h><w>noprompt</w>So many of Clojure discussions orbit around business or theoretical use cases. I think it would be more fun to do something involving a creative tool like Houdini (which I think many people in the Clojure community might actually appreciate in terms of a programming environment with a commitment to data).</z><z id="t1663278574" t="noprompt Wish me luck!"><y>#</y><d>2022-09-15</d><h>21:49</h><w>noprompt</w>Wish me luck!</z><z id="t1663695281" t="wilkerlucio hello, I&apos;m trying to use a rewrite strategy, but I notice that different than when using find or search , I can&apos;t have a clojure expression replacement, for example: (let [f (m*/bottom-up (m*/attempt (m*/rewrite {:all (m/pred some?) :as ?m} (dissoc ?m :all))))] (f {:foo {:all &quot;here&quot;}})) =&gt; {:foo (dissoc {:all &quot;here&quot;} :all)} "><y>#</y><d>2022-09-20</d><h>17:34</h><w>wilkerlucio</w>hello, I&apos;m trying to use a rewrite strategy, but I notice that different than when using <code>find</code> or <code>search</code>, I can&apos;t have a clojure expression replacement, for example:
<pre>(let [f
        (m*/bottom-up
          (m*/attempt
            (m*/rewrite
              {:all (m/pred some?) :as ?m}
              (dissoc ?m :all))))]
    (f {:foo {:all &quot;here&quot;}}))
=&gt; {:foo (dissoc {:all &quot;here&quot;} :all)}</pre>
</z><z id="t1663695303" t="wilkerlucio in this case I was trying to make a meander expression that removes every :all keys from all maps it can find"><y>#</y><d>2022-09-20</d><h>17:35</h><r>wilkerlucio</r>in this case I was trying to make a meander expression that removes every <code>:all</code> keys from all maps it can find</z><z id="t1663774365" t="timothypratley (let [f (s/bottom-up (s/rewrite {:all _ &amp; ?m} ?m ?else ?else))] (f {:foo {:all &quot;here&quot;}})) ^^ this is how I&apos;d do it 🙂"><y>#</y><d>2022-09-21</d><h>15:32</h><r>timothypratley</r><pre>(let [f (s/bottom-up
          (s/rewrite
            {:all _ &amp; ?m}
            ?m
            ?else
            ?else))]
  (f {:foo {:all &quot;here&quot;}}))</pre>
^^ this is how I&apos;d do it <b>🙂</b></z><z id="t1663774398" t="timothypratley =&gt; {:foo {}}"><y>#</y><d>2022-09-21</d><h>15:33</h><r>timothypratley</r>=&gt; {:foo {}}</z><z id="t1663774477" t="timothypratley I think your version should work fine if you either used ~ to execute dissoc, or used match instead of rewrite"><y>#</y><d>2022-09-21</d><h>15:34</h><r>timothypratley</r>I think your version should work fine if you either used <code>~</code> to execute dissoc, or used <code>match</code> instead of <code>rewrite</code></z><z id="t1663774517" t="timothypratley i.e.: (let [f (s/bottom-up (s/attempt (s/rewrite {:all (m/pred some?) :as ?m} ~(dissoc ?m :all))))] (f {:foo {:all &quot;here&quot;}})) =&gt; {:foo {}} "><y>#</y><d>2022-09-21</d><h>15:35</h><r>timothypratley</r>i.e.:
<pre>(let [f
      (s/bottom-up
        (s/attempt
          (s/rewrite
            {:all (m/pred some?) :as ?m}
            ~(dissoc ?m :all))))]
  (f {:foo {:all &quot;here&quot;}}))
=&gt; {:foo {}}</pre>
</z><z id="t1663774572" t="timothypratley But IMO the &amp; thing is nicer as it keeps everything as a pattern 😉"><y>#</y><d>2022-09-21</d><h>15:36</h><r>timothypratley</r>But IMO the &amp; thing is nicer as it keeps everything as a pattern <b>😉</b></z><z id="t1663784718" t="wilkerlucio gotcha, thanks you very much, works great 😄"><y>#</y><d>2022-09-21</d><h>18:25</h><r>wilkerlucio</r>gotcha, thanks you very much, works great <b>😄</b></z><z id="t1664214865" t="noprompt OK folks, so I may not have enough time to get Houdini involved but I&apos;m going to try. The past weekend wasn&apos;t as productive as I would have liked it to be."><y>#</y><d>2022-09-26</d><h>17:54</h><w>noprompt</w>OK folks, so I may not have enough time to get Houdini involved but I&apos;m going to try. The past weekend wasn&apos;t as productive as I would have liked it to be.</z><z id="t1664215018" t="noprompt That said, I am still planning connect Houdini to Meander zeta in the very near future. There&apos;s just no way I&apos;m going give up the effort I&apos;ve put into the new stuff I&apos;ve been working on for Python version of the same thing."><y>#</y><d>2022-09-26</d><h>17:56</h><w>noprompt</w>That said, I am still planning connect Houdini to Meander <code>zeta</code> in the very near future. There&apos;s just no way I&apos;m going give up the effort I&apos;ve put into the new stuff I&apos;ve been working on for Python version of the same thing.</z><z id="t1664306856" t="Daniel Slutsky A Meander meetup with [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] on the coming Friday: https://clojureverse.org/t/data-recur-meeting-3-general-monthly-focusing-on-meander/"><y>#</y><d>2022-09-27</d><h>19:27</h><w>Daniel Slutsky</w>A Meander meetup with <a>@noprompt</a> on the coming Friday:
<a href="https://clojureverse.org/t/data-recur-meeting-3-general-monthly-focusing-on-meander/" target="_blank">https://clojureverse.org/t/data-recur-meeting-3-general-monthly-focusing-on-meander/</a></z><z id="t1664621357" t="Martynas Maciulevičius How can one find the recording? Will you put it into Zulip?"><y>#</y><d>2022-10-01</d><h>10:49</h><r>Martynas Maciulevičius</r>How can one find the recording? Will you put it into Zulip?</z><z id="t1664634836" t="Daniel Slutsky Hi [:attrs {:href &quot;/_/_/users/U028ART884X&quot;}] . Typically I share recordings at Zulip #data-science , Slack #events , Clojureverse, Reddit, Linkedin Clojure Users group, https://twitter.com/scicloj , etc. At the https://scicloj.github.io/ , recordings will also be at the https://scicloj.github.io/docs/resources/video/ and at the page of the relevant group of the various https://scicloj.github.io/docs/community/groups/ . In this case, https://scicloj.github.io/docs/community/groups/data-recur/ . Most of these videos live at the https://www.youtube.com/c/SciCloj , organized in https://www.youtube.com/c/SciCloj/playlists . But some Scicloj videos (see the videos page above) live at other channels, e.g., when Scicloj took part in organizing reClojure workshops and other events. There are many other recordings which are not shared publicly, but only internally, in the relevant Zulip stream. These mostly belong to specific study &amp; dev groups."><y>#</y><d>2022-10-01</d><h>14:33</h><r>Daniel Slutsky</r>Hi <a>@U028ART884X</a>. Typically I share recordings at Zulip <code>#data-science</code>, Slack #events , Clojureverse, Reddit, Linkedin Clojure Users group, <a href="https://twitter.com/scicloj" target="_blank">https://twitter.com/scicloj</a>, etc.

At the <a href="https://scicloj.github.io/" target="_blank">https://scicloj.github.io/</a>, recordings will also be at the <a href="https://scicloj.github.io/docs/resources/video/" target="_blank">https://scicloj.github.io/docs/resources/video/</a> and at the page of the relevant group of the various <a href="https://scicloj.github.io/docs/community/groups/" target="_blank">https://scicloj.github.io/docs/community/groups/</a>. In this case, <a href="https://scicloj.github.io/docs/community/groups/data-recur/" target="_blank">https://scicloj.github.io/docs/community/groups/data-recur/</a>.

Most of these videos live at the <a href="https://www.youtube.com/c/SciCloj" target="_blank">https://www.youtube.com/c/SciCloj</a>, organized in <a href="https://www.youtube.com/c/SciCloj/playlists" target="_blank">https://www.youtube.com/c/SciCloj/playlists</a>. But some Scicloj videos (see the videos page above) live at other channels, e.g., when Scicloj took part in organizing reClojure workshops and other events.

There are many other recordings which are not shared publicly, but only internally, in the relevant Zulip stream. These mostly belong to specific study &amp; dev groups.</z><z id="t1664560774" t="noprompt Zoom just disconnected. We can meet up at another zoom if people want to."><y>#</y><d>2022-09-30</d><h>17:59</h><w>noprompt</w>Zoom just disconnected. We can meet up at another zoom if people want to.</z><z id="t1664560808" t="noprompt https://us05web.zoom.us/j/82350543415 (Passcode: EUE6t7)"><y>#</y><d>2022-09-30</d><h>18:00</h><w>noprompt</w><a href="https://us05web.zoom.us/j/82350543415" target="_blank">https://us05web.zoom.us/j/82350543415</a> (Passcode: EUE6t7)</z><z id="t1664560816" t="noprompt I can be here for another hour."><y>#</y><d>2022-09-30</d><h>18:00</h><w>noprompt</w>I can be here for another hour.</z><z id="t1664637009" t="markaddleman I couldn’t make the zoom session yesterday but I’d love to watch the recording. Any idea if/when it will be available?"><y>#</y><d>2022-10-01</d><h>15:10</h><w>markaddleman</w>I couldn’t make the zoom session yesterday but I’d love to watch the recording.  Any idea if/when it will be available?</z><z id="t1664683743" t="Martynas Maciulevičius https://clojurians.slack.com/archives/CFFTD7R6Z/p1664621357608249?thread_ts=1664306856.411199&amp;amp;cid=CFFTD7R6Z"><y>#</y><d>2022-10-02</d><h>04:09</h><r>Martynas Maciulevičius</r><a href="https://clojurians.slack.com/archives/CFFTD7R6Z/p1664621357608249?thread_ts=1664306856.411199&amp;amp;cid=CFFTD7R6Z" target="_blank">https://clojurians.slack.com/archives/CFFTD7R6Z/p1664621357608249?thread_ts=1664306856.411199&amp;amp;cid=CFFTD7R6Z</a></z><z id="t1664709855" t="markaddleman Thank you"><y>#</y><d>2022-10-02</d><h>11:24</h><r>markaddleman</r>Thank you</z><z id="t1664729467" t="prnc Hello, trying out meander for data exploration Looking at an example like this… (m/search {:foo {:bar :target}} (m/$ :target) :found) I was wondering if it’s possible to get the parent collection of :target without knowing the concrete type of that collection i.e. capture the immediately surrounding ‘context’ of the match? In this particular case that would mean getting out {:bar :target}"><y>#</y><d>2022-10-02</d><h>16:51</h><w>prnc</w>Hello, trying out meander for data exploration
Looking at an example like this…
<pre>(m/search {:foo {:bar :target}}
    (m/$ :target)
    :found)</pre>
I was wondering if it’s possible to get the parent collection of <code>:target</code> without knowing the concrete type of that collection i.e. capture the immediately surrounding ‘context’ of the match?
In this particular case that would mean getting out <code>{:bar :target}</code></z><z id="t1664746079" t="timothypratley Hi 👋 The https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#subtree-search- indicate that you can capture the context like this: (m/search {:foo {:bar :target}} (m/$ ?context :target) (?context :target)) =&gt; ({:foo {:bar :target-replacement}}) But this isn&apos;t quite what you want... because ?context is the entire surrounding context, not just the parent. I can&apos;t think of a way to request the direct parent; in such situations I&apos;d write a pattern to match the parent: (m/search {:foo {:bar :target}} (m/$ {?k :target :as ?m}) ?m) =&gt; ({:bar :target}) You stated that you don&apos;t want to restrict the &apos;type&apos; of the parent, but I think it&apos;s impossible to avoid to some extent... certainly you could search for map parents, and sequable parents, which in combination would cover all the possible parent types: (m/search {:foo {:bar [:baz :booz :target]}} (m/$ (m/and ?parent (m/seqable &amp; _ :target &amp; _))) ?parent) =&gt; ([:baz :booz :target]) ^^ HTH, sorry if I&apos;m misunderstanding your goal."><y>#</y><d>2022-10-02</d><h>21:27</h><r>timothypratley</r>Hi <b>👋</b>

The <a href="https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#subtree-search-" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#subtree-search-</a> indicate that you can capture the context like this:
<pre>(m/search {:foo {:bar :target}}
          (m/$ ?context :target)
          (?context :target))
=&gt; ({:foo {:bar :target-replacement}})</pre>
But this isn&apos;t quite what you want... because <code>?context</code> is the entire surrounding context, not just the parent.

I can&apos;t think of a way to request the direct parent; in such situations I&apos;d write a pattern to match the parent:
<pre>(m/search {:foo {:bar :target}}
          (m/$ {?k :target :as ?m})
          ?m)
=&gt; ({:bar :target})</pre>
You stated that you don&apos;t want to restrict the &apos;type&apos; of the parent, but I think it&apos;s impossible to avoid to some extent... certainly you could search for <code>map</code> parents, and <code>sequable</code> parents, which in combination would cover all the possible parent types:
<pre>(m/search {:foo {:bar [:baz :booz :target]}}
          (m/$ (m/and ?parent (m/seqable &amp; _ :target &amp; _)))
          ?parent)
=&gt; ([:baz :booz :target])</pre>
^^ HTH, sorry if I&apos;m misunderstanding your goal.</z><z id="t1664810185" t="prnc &gt; But this isn’t quite what you want... because ?context is the entire surrounding context, not just the parent. yes! &gt; You stated that you don’t want to restrict the ‘type’ of the parent Yes 🙂 I’m assuming no knowledge of the concrete type, abstractions are great 😜 — so sequable is great Thank you so much 🙏 This indeed helps a lot I might be on some older meander version or something cause I’m seeing (m/search {:foo {:bar [:baz :booz :target]}} (m/$ (m/and ?parent (m/seqable &amp; _ :target &amp; _))) ?parent) ;; =&gt; () Will check! Thanks again :)"><y>#</y><d>2022-10-03</d><h>15:16</h><r>prnc</r>&gt; But this isn’t quite what you want... because <code>?context</code> is the entire surrounding context, not just the parent.
yes!
&gt;  You stated that you don’t want to restrict the ‘type’ of the parent
Yes <b>🙂</b>  I’m assuming no knowledge of the concrete type, abstractions are great <b>😜</b>  — so <code>sequable</code> is great

Thank you so much <b>🙏</b>
This indeed helps a lot

I might be on some older meander version or something cause I’m seeing
<pre>(m/search {:foo {:bar [:baz :booz :target]}}
    (m/$ (m/and ?parent (m/seqable &amp; _ :target &amp; _)))
    ?parent)
  ;; =&gt; ()</pre>
Will check!

Thanks again :)</z><z id="t1664814605" t="timothypratley For reference I was using meander/epsilon {:mvn/version &quot;0.0.650&quot;} "><y>#</y><d>2022-10-03</d><h>16:30</h><r>timothypratley</r>For reference I was using
<pre>meander/epsilon            {:mvn/version &quot;0.0.650&quot;}</pre>
</z><z id="t1664777762" t="Daniel Slutsky Summary &amp; recording of the #meander data-recur meeting last Friday. Thank you so much for the brilliant hands-on teaching, [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] ! https://clojureverse.org/t/data-recur-meeting-3-meander-summary-video/ https://www.youtube.com/watch?v=t8C5Uv1abc4"><y>#</y><d>2022-10-03</d><h>06:16</h><w>Daniel Slutsky</w>Summary &amp; recording of the #meander data-recur meeting last Friday.
Thank you so much for the brilliant hands-on teaching, <a>@noprompt</a>!
<a href="https://clojureverse.org/t/data-recur-meeting-3-meander-summary-video/" target="_blank">https://clojureverse.org/t/data-recur-meeting-3-meander-summary-video/</a>
<a href="https://www.youtube.com/watch?v=t8C5Uv1abc4" target="_blank">https://www.youtube.com/watch?v=t8C5Uv1abc4</a></z><z id="t1664810038" t="noprompt Just a note about this, I&apos;m not particularly great a presenting/time management during a presentation and didn&apos;t cover as much as I would have liked to. For people who already know about the library, there&apos;s nothing new here. For people new to the library, I think the docs are probably going to be the most effective way to learn Meander."><y>#</y><d>2022-10-03</d><h>15:13</h><r>noprompt</r>Just a note about this, I&apos;m not particularly great a presenting/time management during a presentation and didn&apos;t cover as much as I would have liked to. For people who already know about the library, there&apos;s nothing new here. For people new to the library, I think the docs are probably going to be the most effective way to learn Meander.</z><z id="t1664818183" t="prnc I loved it actually! 🙂 Docs are great but I think there is something to be said for seeing someone skilfully use a tool, small mistakes, detours and all — it more closely resembles the actual usage context — gives one ideas and confidence to try them out 💪 So thank you!"><y>#</y><d>2022-10-03</d><h>17:29</h><r>prnc</r>I loved it actually! <b>🙂</b>
Docs are great but I think there is something to be said for seeing someone skilfully use a tool, small mistakes, detours and all — it more closely resembles the actual usage context — gives one ideas and confidence to try them out <b>💪</b>
So thank you!</z><z id="t1664819621" t="noprompt Question: are the Clojure ML folks largely on Zulip?"><y>#</y><d>2022-10-03</d><h>17:53</h><r>noprompt</r>Question: are the Clojure ML folks largely on Zulip?</z><z id="t1664819657" t="noprompt I took a peek at tech.ml.* on Friday and I want to learn more."><y>#</y><d>2022-10-03</d><h>17:54</h><r>noprompt</r>I took a peek at <code>tech.ml.*</code> on Friday and I want to learn more.</z><z id="t1664819675" t="noprompt (Currently learning pytorch and working through the fastai book.)"><y>#</y><d>2022-10-03</d><h>17:54</h><r>noprompt</r>(Currently learning pytorch and working through the fastai book.)</z><z id="t1664820972" t="Daniel Slutsky &gt; largely on Zulip? yes"><y>#</y><d>2022-10-03</d><h>18:16</h><r>Daniel Slutsky</r>&gt;  largely on Zulip?
yes</z><z id="t1664820997" t="Daniel Slutsky a few useful chat streams: https://scicloj.github.io/docs/community/chat/"><y>#</y><d>2022-10-03</d><h>18:16</h><r>Daniel Slutsky</r>a few useful chat streams:    <a href="https://scicloj.github.io/docs/community/chat/" target="_blank">https://scicloj.github.io/docs/community/chat/</a></z><z id="t1664821218" t="Daniel Slutsky &gt; I loved it actually! 🙂 &gt; Docs are great but I think there is something to be said for seeing someone skilfully use a tool, small mistakes, detours and all — it more closely resembles the actual usage context — gives one ideas and confidence to try them out 💪 &gt; So thank you! I felt the same. To me, this seems the best path for learning such a topic, and also the best path to prepare for more advanced topics. For live coding to be clear &amp; didactic, it needs to be slow enough. It actually made sense to spend that time with Meader basics, in my opinion."><y>#</y><d>2022-10-03</d><h>18:20</h><r>Daniel Slutsky</r>&gt;  I loved it actually! <b>🙂</b>
&gt; Docs are great but I think there is something to be said for seeing someone skilfully use a tool, small mistakes, detours and all — it more closely resembles the actual usage context — gives one ideas and confidence to try them out <b>💪</b>
&gt; So thank you!
I felt the same. To me, this seems the best path for learning such a topic, and also the best path to prepare for more advanced topics.
For live coding to be clear &amp; didactic, it needs to be slow enough. It actually made sense to spend that time with Meader basics, in my opinion.</z><z id="t1664810206" t="noprompt Usage poll 1️⃣ I use Meander for hobby projects 2️⃣ I use Meander for/at work 3️⃣ I don&apos;t use Meander"><y>#</y><d>2022-10-03</d><h>15:16</h><w>noprompt</w>Usage poll
<b>1️⃣</b> I use Meander for hobby projects
<b>2️⃣</b> I use Meander for/at work
<b>3️⃣</b> I don&apos;t use Meander</z><z id="t1664810491" t="noprompt I don&apos;t use Meander because 1️⃣ I don&apos;t understand how to apply it 2️⃣ It&apos;s too buggy/hard to debug 3️⃣ There is not enough documentation 4️⃣ Other (specify in reply)"><y>#</y><d>2022-10-03</d><h>15:21</h><w>noprompt</w>I don&apos;t use Meander because
<b>1️⃣</b> I don&apos;t understand how to apply it
<b>2️⃣</b> It&apos;s too buggy/hard to debug
<b>3️⃣</b> There is not enough documentation
<b>4️⃣</b> Other (specify in reply)</z><z id="t1664832791" t="Anthony 4: ... yet, but plan to"><y>#</y><d>2022-10-03</d><h>21:33</h><r>Anthony</r>4: ... yet, but plan to</z><z id="t1665004154" t="Lidor Cohen I use it at work for some tasks and specter for others. I was able to grasp specter a bit better (although I used meander first). They are both missing aggregations."><y>#</y><d>2022-10-05</d><h>21:09</h><r>Lidor Cohen</r>I use it at work for some tasks and specter for others.
I was able to grasp specter a bit better (although I used meander first).
They are both missing aggregations.</z><z id="t1665005095" t="noprompt &gt; They are both missing aggregations. [:attrs {:href &quot;/_/_/users/U8RHR1V60&quot;}] Aggregations exist on the zeta branch and to a degree are also available on the epsilon branch as memory variables. An &quot;aggregation&quot; on the zeta branch is actually just custom variable type which is simply a pair of rewrite systems (functions). The first function takes, as an argument, the current state of the variable and a value to be stored, and computes the new value of the store AKA fold . The second function task, as an argument, the current state variable and computes a pair of the value to return from the store and the next value of the store AKA unfold . ;; Store a value [current-state incoming-value] -&gt; next-state ;; Dispense a value current-state -&gt; [outgoing-value next-state] This generalization of variables is suitable to accommodate virtually any kind of aggregation, be it min , max , a counter, an average, etc. Counter already exists as ++ on zeta . Its fold simply increments the stored valued while ignoring the incoming value, and its unfold simply returns the stored value."><y>#</y><d>2022-10-05</d><h>21:24</h><r>noprompt</r>&gt; They are both missing aggregations.

<a>@lidorcg</a> Aggregations exist on the <code>zeta</code> branch and to a degree are also available on the <code>epsilon</code> branch as memory variables.

An &quot;aggregation&quot; on the <code>zeta</code> branch is actually just custom variable type which is simply a pair of rewrite systems (functions). The first function takes, as an argument, the current state of the variable and a value to be stored, and computes the new value of the store AKA <code>fold</code>. The second function task, as an argument, the current state variable and computes a pair of the value to return from the store and the next value of the store AKA <code>unfold</code>.
<pre>;; Store a value
[current-state incoming-value] -&gt; next-state
;; Dispense a value
current-state -&gt; [outgoing-value next-state]</pre>
This generalization of variables is suitable to accommodate virtually any kind of aggregation, be it <code>min</code>, <code>max</code>, a counter, an average, etc. Counter already exists as <code>++</code> on <code>zeta</code>. Its fold simply increments the stored valued while ignoring the incoming value, and its unfold simply returns the stored value.</z><z id="t1665005509" t="noprompt The only thing this description lacks is an account of failure, both in the fold and in the unfold. Fortunately, zeta does account for this and the definition of variables/aggregators can specify a how storage/retrieval can fail. For example, we can say that if a variable has never stored anything it is unbound . Retrieving an unbound variable could mean failure (in most programming settings this would result in a compile time/runtime error)."><y>#</y><d>2022-10-05</d><h>21:31</h><r>noprompt</r>The only thing this description lacks is an account of failure, both in the fold and in the unfold. Fortunately, <code>zeta</code> does account for this and the definition of variables/aggregators can specify a how storage/retrieval can fail. For example, we can say that if a variable has never stored anything it is <code>unbound</code>. Retrieving an <code>unbound</code> variable could mean failure (in most programming settings this would result in a compile time/runtime error).</z><z id="t1665048364" t="Lidor Cohen [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] thanks for addressing that, on the last task the required group by and aggregation I posted a question here and after a little search on the channel I found an answer that basically said &quot;we&apos;re working on it&quot; so I rooted for you and solved it in the old clojury way 😁 . Next data manipulation task I have I&apos;ll come back to meander and will give it another go 💪 :skin-tone-3: . I always seek different tools that give different perspectives on problems, and meander sure is different so I&apos;ll keep on checking on it"><y>#</y><d>2022-10-06</d><h>09:26</h><r>Lidor Cohen</r><a>@noprompt</a> thanks for addressing that, on the last task the required group by and aggregation I posted a question here and after a little search on the channel I found an answer that basically said &quot;we&apos;re working on it&quot; so I rooted for you and solved it in the old clojury way <b>😁</b> .
Next data manipulation task I have I&apos;ll come back to meander and will give it another go <b>💪</b><b>:skin-tone-3:</b>.

I always seek different tools that give different perspectives on problems, and meander sure is different so I&apos;ll keep on checking on it</z><z id="t1664810579" t="noprompt I will probably think of some more questions. Also, I think there is a proper poll thingy for Slack but I don&apos;t know where it is."><y>#</y><d>2022-10-03</d><h>15:22</h><w>noprompt</w>I will probably think of some more questions. Also, I think there is a proper poll thingy for Slack but I don&apos;t know where it is.</z><z id="t1665005095" t="noprompt &gt; They are both missing aggregations. [:attrs {:href &quot;/_/_/users/U8RHR1V60&quot;}] Aggregations exist on the zeta branch and to a degree are also available on the epsilon branch as memory variables. An &quot;aggregation&quot; on the zeta branch is actually just custom variable type which is simply a pair of rewrite systems (functions). The first function takes, as an argument, the current state of the variable and a value to be stored, and computes the new value of the store AKA fold . The second function task, as an argument, the current state variable and computes a pair of the value to return from the store and the next value of the store AKA unfold . ;; Store a value [current-state incoming-value] -&gt; next-state ;; Dispense a value current-state -&gt; [outgoing-value next-state] This generalization of variables is suitable to accommodate virtually any kind of aggregation, be it min , max , a counter, an average, etc. Counter already exists as ++ on zeta . Its fold simply increments the stored valued while ignoring the incoming value, and its unfold simply returns the stored value."><y>#</y><d>2022-10-05</d><h>21:24</h><w>noprompt</w>&gt; They are both missing aggregations.

<a>@lidorcg</a> Aggregations exist on the <code>zeta</code> branch and to a degree are also available on the <code>epsilon</code> branch as memory variables.

An &quot;aggregation&quot; on the <code>zeta</code> branch is actually just custom variable type which is simply a pair of rewrite systems (functions). The first function takes, as an argument, the current state of the variable and a value to be stored, and computes the new value of the store AKA <code>fold</code>. The second function task, as an argument, the current state variable and computes a pair of the value to return from the store and the next value of the store AKA <code>unfold</code>.
<pre>;; Store a value
[current-state incoming-value] -&gt; next-state
;; Dispense a value
current-state -&gt; [outgoing-value next-state]</pre>
This generalization of variables is suitable to accommodate virtually any kind of aggregation, be it <code>min</code>, <code>max</code>, a counter, an average, etc. Counter already exists as <code>++</code> on <code>zeta</code>. Its fold simply increments the stored valued while ignoring the incoming value, and its unfold simply returns the stored value.</z><z id="t1665005509" t="noprompt The only thing this description lacks is an account of failure, both in the fold and in the unfold. Fortunately, zeta does account for this and the definition of variables/aggregators can specify a how storage/retrieval can fail. For example, we can say that if a variable has never stored anything it is unbound . Retrieving an unbound variable could mean failure (in most programming settings this would result in a compile time/runtime error)."><y>#</y><d>2022-10-05</d><h>21:31</h><w>noprompt</w>The only thing this description lacks is an account of failure, both in the fold and in the unfold. Fortunately, <code>zeta</code> does account for this and the definition of variables/aggregators can specify a how storage/retrieval can fail. For example, we can say that if a variable has never stored anything it is <code>unbound</code>. Retrieving an <code>unbound</code> variable could mean failure (in most programming settings this would result in a compile time/runtime error).</z><z id="t1664906276" t="sakalli cheers [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] for the data-recur meeting, saw the recording today, it was a blast! 😍 🙏"><y>#</y><d>2022-10-04</d><h>17:57</h><w>sakalli</w>cheers <a>@noprompt</a> for the data-recur meeting, saw the recording today, it was a blast! <b>😍</b><b>🙏</b></z><z id="t1665009348" t="noprompt Here&apos;s is an example demonstrating an average computation."><y>#</y><d>2022-10-05</d><h>22:35</h><w>noprompt</w>Here&apos;s is an example demonstrating an average computation.</z><z id="t1665009408" t="noprompt"><y>#</y><d>2022-10-05</d><h>22:36</h><w>noprompt</w></z><z id="t1665009678" t="noprompt Just FYI zeta examples are a bit more verbose at the moment but less &quot;noisy&quot; syntax will be available/is easily achieved through notation extensions. These allow you to extend the parser/reader with rewrite rules."><y>#</y><d>2022-10-05</d><h>22:41</h><w>noprompt</w>Just FYI <code>zeta</code> examples are a bit more verbose at the moment but less &quot;noisy&quot; syntax will be available/is easily achieved through notation extensions. These allow you to extend the parser/reader  with rewrite rules.</z><z id="t1665009745" t="noprompt The parser doesn&apos;t know anything about ?x syntax, for example. It only knows about Clojure&apos;s primitive data types and how to resolve operators."><y>#</y><d>2022-10-05</d><h>22:42</h><w>noprompt</w>The parser doesn&apos;t know anything about <code>?x</code> syntax, for example. It only knows about Clojure&apos;s primitive data types and how to resolve operators.</z><z id="t1665010251" t="noprompt Using the example above. I can also create sum and combine it with avg to compute both at the same time."><y>#</y><d>2022-10-05</d><h>22:50</h><w>noprompt</w>Using the example above. I can also create <code>sum</code> and combine it with <code>avg</code> to compute both at the same time.</z><z id="t1665010269" t="noprompt"><y>#</y><d>2022-10-05</d><h>22:51</h><w>noprompt</w></z><z id="t1665010360" t="noprompt With the logical operators like m/each (conjunction) and/or m/some (`disjunction`) it&apos;s possible to constrain what is summed/averaged etc."><y>#</y><d>2022-10-05</d><h>22:52</h><w>noprompt</w>With the  logical operators like <code>m/each</code> (conjunction) and/or <code>m/some</code> (`disjunction`) it&apos;s possible to constrain what is summed/averaged etc.</z><z id="t1665010485" t="noprompt The sum and avg definition in the examples above don&apos;t constrain the ?incoming type since this is just a demonstration. But it will be possible to say (m/each (m.num/any) ?n) and constraint to numbers. Right now, only () is working."><y>#</y><d>2022-10-05</d><h>22:54</h><w>noprompt</w>The <code>sum</code> and <code>avg</code> definition in the examples above don&apos;t constrain the <code>?incoming</code> type since this is just a demonstration. But it will be possible to say
<pre>(m/each (m.num/any) ?n)</pre>
and constraint to numbers. Right now, only <code>()</code> is working.</z><z id="t1665010985" t="noprompt Oh. Off topic, I should mention that I&apos;m planning to release meander.zeta as just meander when it is ready. I have spent a while thinking about what I want to achieve with the project and distill those bits into a library that can be extensible, support async/sync, and friendly to interpretation/compilation. Also, I wanted the left and right sides of rules to support the same set of operators. That has been hard and there is still work ahead but it is true today that left and right both support projection (`let`), conjunction, disjunction, and negation which makes possible many things."><y>#</y><d>2022-10-05</d><h>23:03</h><w>noprompt</w>Oh. Off topic, I should mention that I&apos;m planning to release <code>meander.zeta</code> as just <code>meander</code> when it is ready.

I have spent a while thinking about what I want to achieve with the project and distill those bits into a library that can be extensible, support async/sync, and friendly to interpretation/compilation. Also, I wanted the left and right sides of rules to support the same set of operators. That has been hard and there is still work ahead but it is true today that left and right both support projection (`let`), conjunction, disjunction, and negation which makes possible many things.</z><z id="t1665011758" t="Jimmy Miller Why not meander.omega? 🙂"><y>#</y><d>2022-10-05</d><h>23:15</h><r>Jimmy Miller</r>Why not meander.omega? <b>🙂</b></z><z id="t1665014212" t="noprompt Ha! Indeed! 😄"><y>#</y><d>2022-10-05</d><h>23:56</h><r>noprompt</r>Ha! Indeed! <b>😄</b></z><z id="t1665856732" t="Richie I just debugged something not obvious so I wanted to share. (m/match assoc assoc :assoc _ :not) ;; :not (m/match assoc ~assoc :assoc _ :not) ;; :assoc "><y>#</y><d>2022-10-15</d><h>17:58</h><w>Richie</w>I just debugged something not obvious so I wanted to share.
<pre>(m/match assoc
  assoc :assoc
  _ :not)
;; :not

(m/match assoc
  ~assoc :assoc
  _ :not)
;; :assoc</pre>
</z><z id="t1665856750" t="Richie"><y>#</y><d>2022-10-15</d><h>17:59</h><r>Richie</r></z><z id="t1665856787" t="Richie So, yea, the function assoc is not the same as the symbol."><y>#</y><d>2022-10-15</d><h>17:59</h><r>Richie</r>So, yea, the function <code>assoc</code> is not the same as the symbol.</z><z id="t1665856939" t="Richie I guess maybe it would have been clear if I were in the right mindset."><y>#</y><d>2022-10-15</d><h>18:02</h><r>Richie</r>I guess maybe it would have been clear if I were in the right mindset.</z><z id="t1666731431" t="benny Hey, I think I&apos;m having a very basic question. I want to effectively keep a sequence a sequence inside a meander/match while rewriting the contents of the sequence. This is what I&apos;ve got so far but it still needs post-processing (which I&apos;m okay with doing in clojure code, but I feel like I&apos;m missing a piece of meander understanding): (meander/search {:foo 1 :bar 2 :baz 3 :lst [{:id 1, :name &quot;a&quot;} {:id 2, :name &quot;b&quot;} {:id 3, :name &quot;c&quot;}]} {:foo ?foo :bar ?bar :baz ?baz :lst (meander/scan {:id ?el-id :name ?el-name})} {:example/foo ?foo :example/bar ?bar :example/baz ?baz :example/list [{:example.list/id ?el-id :example.list/name ?el-name}]})"><y>#</y><d>2022-10-25</d><h>20:57</h><w>benny</w>Hey, I think I&apos;m having a very basic question. I want to effectively keep a sequence a sequence inside a <code>meander/match</code> while rewriting the contents of the sequence. This is what I&apos;ve got so far but it still needs post-processing (which I&apos;m okay with doing in clojure code, but I feel like I&apos;m missing a piece of meander understanding):
<pre>(meander/search {:foo 1
                   :bar 2
                   :baz 3
                   :lst [{:id 1, :name &quot;a&quot;}
                         {:id 2, :name &quot;b&quot;}
                         {:id 3, :name &quot;c&quot;}]}
    {:foo ?foo
     :bar ?bar
     :baz ?baz
     :lst (meander/scan {:id ?el-id
                         :name ?el-name})}
    {:example/foo ?foo
     :example/bar ?bar
     :example/baz ?baz
     :example/list [{:example.list/id ?el-id
                     :example.list/name ?el-name}]})</pre></z><z id="t1666731524" t="benny I would like the output to be: {:example/foo 1, :example/bar 2, :example/baz 3 :example/list [{:example.list/id 1, :example.list/name &quot;a&quot;} {:example.list/id 2, :example.list/name &quot;b&quot;} {:example.list/id 3, :example.list/name &quot;c&quot;}]}"><y>#</y><d>2022-10-25</d><h>20:58</h><r>benny</r>I would like the output to be:
<pre>{:example/foo 1, :example/bar 2, :example/baz 3
   :example/list [{:example.list/id 1, :example.list/name &quot;a&quot;}
                  {:example.list/id 2, :example.list/name &quot;b&quot;}
                  {:example.list/id 3, :example.list/name &quot;c&quot;}]}</pre></z><z id="t1666834556" t="timothypratley (m/rewrite {:foo 1 :bar 2 :baz 3 :lst [{:id 1, :name &quot;a&quot;} {:id 2, :name &quot;b&quot;} {:id 3, :name &quot;c&quot;}]} {:foo ?foo :bar ?bar :baz ?baz :lst [{:id !el-id :name !el-name} ...]} {:example/foo ?foo :example/bar ?bar :example/baz ?baz :example/list [{:example.list/id !el-id :example.list/name !el-name} ...]}) "><y>#</y><d>2022-10-27</d><h>01:35</h><r>timothypratley</r><pre>(m/rewrite {:foo 1
            :bar 2
            :baz 3
            :lst [{:id 1, :name &quot;a&quot;}
                  {:id 2, :name &quot;b&quot;}
                  {:id 3, :name &quot;c&quot;}]}
  {:foo ?foo
   :bar ?bar
   :baz ?baz
   :lst [{:id   !el-id
          :name !el-name} ...]}
  {:example/foo ?foo
   :example/bar ?bar
   :example/baz ?baz
   :example/list [{:example.list/id !el-id
                   :example.list/name !el-name} ...]})</pre>
</z><z id="t1666834602" t="timothypratley =&gt; #:example{:foo 1, :bar 2, :baz 3, :list [#:example.list{:id 1, :name &quot;a&quot;} #:example.list{:id 2, :name &quot;b&quot;} #:example.list{:id 3, :name &quot;c&quot;}]}"><y>#</y><d>2022-10-27</d><h>01:36</h><r>timothypratley</r>=&gt;
<pre>#:example{:foo 1,
          :bar 2,
          :baz 3,
          :list [#:example.list{:id 1, :name &quot;a&quot;} #:example.list{:id 2, :name &quot;b&quot;} #:example.list{:id 3, :name &quot;c&quot;}]}</pre></z><z id="t1666944603" t="benny Thanks [:attrs {:href &quot;/_/_/users/U06S1EJPL&quot;}] !"><y>#</y><d>2022-10-28</d><h>08:10</h><r>benny</r>Thanks <a>@U06S1EJPL</a>!</z><z id="t1667591757" t="David G I’m trying to mimic Clojure’s update but I’m struggling to understand how to do sort of in-place updates to maps using match : (m/match {:a 1 :b 3} {:a ?a &amp; _} {:a (inc ?a) ????}) In this small example I’m trying to perform inc only on :a (and perhaps do that for several other keywords, but this is the basic form of what I’m trying to do). How do you stitch back the “rest” of the map?"><y>#</y><d>2022-11-04</d><h>19:55</h><w>David G</w>I’m trying to mimic Clojure’s <code>update</code> but I’m struggling to understand how to do sort of in-place updates to maps using <code>match</code>:
<pre>(m/match {:a 1 :b 3}
  {:a ?a &amp; _}
  {:a (inc ?a)
   ????})</pre>
In this small example I’m trying to perform <code>inc</code> only on <code>:a</code> (and perhaps do that for several other keywords, but this is the basic form of what I’m trying to do).

How do you stitch back the “rest” of the map?</z><z id="t1667591906" t="jgdavey Perhaps you want m/rewrite ? `"><y>#</y><d>2022-11-04</d><h>19:58</h><r>jgdavey</r>Perhaps you want <code>m/rewrite</code>?

<code></code>`</z><z id="t1667591943" t="David G I thought rewrite outputs a match pattern given an input which you can match against"><y>#</y><d>2022-11-04</d><h>19:59</h><r>David G</r>I thought rewrite outputs a match pattern given an input which you can match against</z><z id="t1667591951" t="jgdavey (m/rewrite {:a 1 :b 3} {:a ?a &amp; ?m} {:a (m/app inc ?a) &amp; ?m})"><y>#</y><d>2022-11-04</d><h>19:59</h><r>jgdavey</r><pre>(m/rewrite {:a 1 :b 3}
  {:a ?a &amp; ?m}
  {:a (m/app inc ?a) &amp; ?m})</pre></z><z id="t1667592071" t="jgdavey rewrite’s “action” branch is pattern-like, as opposed to match/search/find which are more like literal clojure"><y>#</y><d>2022-11-04</d><h>20:01</h><r>jgdavey</r>rewrite’s “action” branch is pattern-like, as opposed to match/search/find which are more like literal clojure</z><z id="t1667592305" t="David G “action” is the second parameter in this case, right?"><y>#</y><d>2022-11-04</d><h>20:05</h><r>David G</r>“action” is the second parameter in this case, right?</z><z id="t1668519310" t="Ben Sless"><y>#</y><d>2022-11-15</d><h>13:35</h><w>Ben Sless</w></z><z id="t1668618468" t="noprompt Is [:attrs {:href &quot;/_/_/users/U055NJ5CC&quot;}] in this channel? If not, I need to send him some love. 🙂"><y>#</y><d>2022-11-16</d><h>17:07</h><r>noprompt</r>Is <a>@U055NJ5CC</a> in this channel? If not, I need to send him some love. <b>🙂</b></z><z id="t1668618501" t="noprompt Ah, I guess not. 😄 Guess its time for a thank you note. 🙂"><y>#</y><d>2022-11-16</d><h>17:08</h><r>noprompt</r>Ah, I guess not. <b>😄</b> Guess its time for a thank you note. <b>🙂</b></z><z id="t1670267817" t="gdubs How did they make the visualization? They use some existing tooling? Or create something custom?"><y>#</y><d>2022-12-05</d><h>19:16</h><r>gdubs</r>How did they make the visualization?  They use some existing tooling? Or create something custom?</z><z id="t1670267878" t="gdubs If I want to transform the same data in two ways, should I just run two operations? Or can I have a single operation with two &quot;right hand sides&quot;?"><y>#</y><d>2022-12-05</d><h>19:17</h><w>gdubs</w>If I want to transform the same data in two ways, should I just run two operations? Or can I have a single operation with two &quot;right hand sides&quot;?</z><z id="t1670267962" t="xificurC Can you give an example?"><y>#</y><d>2022-12-05</d><h>19:19</h><r>xificurC</r>Can you give an example?</z><z id="t1670268338" t="gdubs Sorry for the screenshot. I literally don&apos;t know how to copy and paste out of my remote editor."><y>#</y><d>2022-12-05</d><h>19:25</h><r>gdubs</r>Sorry for the screenshot. I literally don&apos;t know how to copy and paste out of my remote editor.</z><z id="t1670268343" t="gdubs totally silly contrived example."><y>#</y><d>2022-12-05</d><h>19:25</h><r>gdubs</r>totally silly contrived example.</z><z id="t1670278862" t="noprompt [:attrs {:href &quot;/_/_/users/UG9CG9GDB&quot;}] Two seems right in this case. The first query is a join and the second is not. In the second you do not need to look for {:id ?team} though."><y>#</y><d>2022-12-05</d><h>22:21</h><r>noprompt</r><a>@UG9CG9GDB</a> Two seems right in this case. The first query is a join and the second is not. In the second you do not need to look for <code>{:id ?team}</code> though.</z><z id="t1670279039" t="noprompt Depending on the project, it might be a good idea to index the teams by :id first."><y>#</y><d>2022-12-05</d><h>22:23</h><r>noprompt</r>Depending on the project, it might be a good idea to index the teams by <code>:id</code> first.</z><z id="t1670279397" t="noprompt (let [data {:people [{:name &quot;greg&quot;, :team 1} {:name &quot;jill&quot; :team 2}] :teams [{:id 1 :name &quot;stars&quot;} {:id 2 :name &quot;fish&quot;} {:id 3 :name &quot;dogs&quot;}]} teams (:teams data) people (:people data) team-idx (into {} (map (juxt :id identity)) teams)] {:players (m/search [people team-idx] [(m/scan {:name ?name, :team ?team-id}) {?team-id {:name ?team}}] {:name ?name :team ?team}) :teams (map :name teams)})"><y>#</y><d>2022-12-05</d><h>22:29</h><r>noprompt</r><pre>(let [data {:people [{:name &quot;greg&quot;, :team 1} {:name &quot;jill&quot; :team 2}]
            :teams [{:id 1 :name &quot;stars&quot;} {:id 2 :name &quot;fish&quot;} {:id 3 :name &quot;dogs&quot;}]}
      teams (:teams data)
      people (:people data)
      team-idx (into {} (map (juxt :id identity)) teams)]
  {:players (m/search [people team-idx]
              [(m/scan {:name ?name, :team ?team-id})
               {?team-id {:name ?team}}]
              {:name ?name :team ?team})
   :teams (map :name teams)})</pre></z><z id="t1670443807" t="Tanner Emerson I am trying to grab a single list of free and paid item ids from this nested structure. I have tried multiple approaches with no luck. I will post my attempts in the thread. Any ideas on how to approach this problem? {:games [{:id &quot;foo&quot; :items {:free [{:id &quot;a&quot;} {:id &quot;b&quot;}] :paid [{:id &quot;c&quot;}]}} {:id &quot;bar&quot; :items {:free [{:id &quot;d&quot;} {:id &quot;c&quot;}] :paid [{:id &quot;f&quot;}]}} {:id &quot;baz&quot;}]} target =&gt; [&quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;c&quot; &quot;f&quot;] ;; order does not matter ;; ideally no duplicates but not required"><y>#</y><d>2022-12-07</d><h>20:10</h><w>Tanner Emerson</w>I am trying to grab a single list of free and paid item ids from this nested structure.  I have tried multiple approaches with no luck. I will post my attempts in the thread.

Any ideas on how to approach this problem?

<pre>{:games [{:id &quot;foo&quot;
          :items {:free [{:id &quot;a&quot;} {:id &quot;b&quot;}]
                  :paid [{:id &quot;c&quot;}]}}

         {:id &quot;bar&quot;
          :items {:free [{:id &quot;d&quot;} {:id &quot;c&quot;}]
                  :paid [{:id &quot;f&quot;}]}}

         {:id &quot;baz&quot;}]}

target =&gt; [&quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;c&quot; &quot;f&quot;] 
;; order does not matter
;; ideally no duplicates but not required</pre></z><z id="t1670443946" t="Tanner Emerson This attempt accumulates all free items but ignores paid items (m/rewrites {:games [{:id &quot;foo&quot; :items {:free [{:id &quot;a&quot;} {:id &quot;b&quot;}] :paid [{:id &quot;c&quot;}]}} {:id &quot;bar&quot; :items {:free [{:id &quot;d&quot;} {:id &quot;c&quot;}] :paid [{:id &quot;f&quot;}]}} {:id &quot;baz&quot;}]} {:games (m/scan {:items {:free (m/scan {:id !item-ids}) :paid (m/scan {:id !item-ids})}})} !item-ids)"><y>#</y><d>2022-12-07</d><h>20:12</h><r>Tanner Emerson</r>This attempt accumulates all free items but ignores paid items
<pre>(m/rewrites {:games [{:id &quot;foo&quot;
                      :items {:free [{:id &quot;a&quot;} {:id &quot;b&quot;}]
                              :paid [{:id &quot;c&quot;}]}}

                     {:id &quot;bar&quot;
                      :items {:free [{:id &quot;d&quot;} {:id &quot;c&quot;}]
                              :paid [{:id &quot;f&quot;}]}}

                     {:id &quot;baz&quot;}]}
  {:games (m/scan {:items {:free (m/scan {:id !item-ids})
                           :paid (m/scan {:id !item-ids})}})}
  !item-ids)</pre></z><z id="t1670444267" t="Tanner Emerson This attempt gave me an empty list (m/rewrites {:games [{:id &quot;foo&quot; :items {:free [{:id &quot;a&quot;} {:id &quot;b&quot;}] :paid [{:id &quot;c&quot;}]}} {:id &quot;bar&quot; :items {:free [{:id &quot;d&quot;} {:id &quot;c&quot;}] :paid [{:id &quot;f&quot;}]}} {:id &quot;baz&quot;}]} {:games [{:items {:free [{:id !free-ids} ...] :paid [{:id !paid-ids} ...]}} ...]} [!free-ids ... . !paid-ids ...]) "><y>#</y><d>2022-12-07</d><h>20:17</h><r>Tanner Emerson</r>This attempt gave me an empty list
<pre>(m/rewrites {:games [{:id &quot;foo&quot;
                      :items {:free [{:id &quot;a&quot;} {:id &quot;b&quot;}]
                              :paid [{:id &quot;c&quot;}]}}

                     {:id &quot;bar&quot;
                      :items {:free [{:id &quot;d&quot;} {:id &quot;c&quot;}]
                              :paid [{:id &quot;f&quot;}]}}

                     {:id &quot;baz&quot;}]}
  {:games [{:items {:free [{:id !free-ids}
                           ...]
                    :paid [{:id !paid-ids}
                           ...]}}
           ...]}
  [!free-ids ... . !paid-ids ...])</pre>
</z><z id="t1670444400" t="grant In an effort to learn Meander I am attempting to port some existing code to use it. Some of the examples have been pretty easy, but I’m struggling to figure out an elegant way, with Meander, to take input and produce target-out . Any suggestions or advice would be greatly appreciated. (def input {:required [{:id :e1 :a 1} {:id :e2 :a 2} {:id :e3 :a 3} {:id :e4 :a 4}] :optional1 [{:id :e1 :b 1} {:id :e2 :b 2}] :optional2 [{:id :e1 :c 1} {:id :e3 :c 3}]}) (def target-out &apos;({:id :e1 :a 1 :b 1 :c 1} {:id :e2 :a 2 :b 2 } {:id :e3 :a 3 :c 3} {:id :e4 :a 4 }))"><y>#</y><d>2022-12-07</d><h>20:20</h><w>grant</w>In an effort to learn Meander I am attempting to port some existing code to use it. Some of the examples have been pretty easy, but I’m struggling to figure out an elegant way, with Meander, to take <code>input</code> and produce <code>target-out</code>. Any suggestions or advice would be greatly appreciated.

<pre>(def input {:required  [{:id :e1 :a 1}
                          {:id :e2 :a 2}
                          {:id :e3 :a 3}
                          {:id :e4 :a 4}]
              :optional1 [{:id :e1 :b 1}
                          {:id :e2 :b 2}]
              :optional2 [{:id :e1 :c 1}
                          {:id :e3 :c 3}]})</pre>
<pre>(def target-out &apos;({:id :e1 :a 1 :b 1 :c 1}
                    {:id :e2 :a 2 :b 2     }
                    {:id :e3 :a 3      :c 3}
                    {:id :e4 :a 4          }))</pre></z><z id="t1670450563" t="gdubs I&apos;ve had this same question too. Its like you want to do an outer join instead of an inner join."><y>#</y><d>2022-12-07</d><h>22:02</h><r>gdubs</r>I&apos;ve had this same question too.  Its like you want to do an outer join instead of an inner join.</z><z id="t1670566783" t="noprompt Yep. The other thing here is that m/or on epsilon finds all of the solutions which is why the solution set we get with m/rewrites has more results than we want. We can get around this by querying the required portion of the map with m/search and then extracting the optional stuff with m/find . (m/search input {:required (m/scan {:id ?id, :as ?attrs}) :optional1 ?optional1 :optional2 ?optional2} (m/find [?id ?optional1 ?optional2] [?id (m/or (m/scan {:id ?id, &amp; !attrs}) _) (m/or (m/scan {:id ?id, &amp; !attrs}) _)] (reduce merge ?attrs !attrs))) ;; =&gt; ({:id :e1, :a 1, :b 1, :c 1} {:id :e2, :a 2, :b 2} {:id :e3, :a 3, :c 3} {:id :e4, :a 4}) "><y>#</y><d>2022-12-09</d><h>06:19</h><r>noprompt</r>Yep. The other thing here is that <code>m/or</code> on <code>epsilon</code> finds all of the solutions which is why the solution set we get with <code>m/rewrites</code> has more results than we want. We can get around this by querying the required portion of the map with <code>m/search</code> and then extracting the optional stuff with <code>m/find</code>.

<pre>(m/search input
  {:required (m/scan {:id ?id, :as ?attrs})
   :optional1 ?optional1
   :optional2 ?optional2}
  (m/find [?id ?optional1 ?optional2]
    [?id
     (m/or (m/scan {:id ?id, &amp; !attrs}) _)
     (m/or (m/scan {:id ?id, &amp; !attrs}) _)]
    (reduce merge ?attrs !attrs)))
;; =&gt;
({:id :e1, :a 1, :b 1, :c 1}
 {:id :e2, :a 2, :b 2}
 {:id :e3, :a 3, :c 3}
 {:id :e4, :a 4})</pre>
</z><z id="t1670566874" t="noprompt This would actually work, however, if epsilon had a short circuiting m/or ."><y>#</y><d>2022-12-09</d><h>06:21</h><r>noprompt</r>This would actually work, however, if <code>epsilon</code> had a short circuiting <code>m/or</code>.</z><z id="t1670566884" t="noprompt Without the m/find ."><y>#</y><d>2022-12-09</d><h>06:21</h><r>noprompt</r>Without the <code>m/find</code>.</z><z id="t1670567010" t="noprompt This is what the rule currently looks like on zeta that finds the solution. (m/rule {:required (m/scan {:id ?x &amp; ?a}), :optional1 ?optional1, :optional2 ?optional2} (m/let [(m/pick (m/scan {:id ?x &amp; ?b}) _) ?optional1 (m/pick (m/scan {:id ?x &amp; ?c}) _) ?optional2] {:id ?x &amp;0 ?a &amp;1 (m/pick ?b {}) &amp;2 (m/pick ?c {})}))"><y>#</y><d>2022-12-09</d><h>06:23</h><r>noprompt</r>This is what the rule currently looks like on <code>zeta</code> that finds the solution.

<pre>(m/rule
 {:required (m/scan {:id ?x &amp; ?a}),
  :optional1 ?optional1,
  :optional2 ?optional2}
 (m/let [(m/pick (m/scan {:id ?x &amp; ?b}) _) ?optional1
         (m/pick (m/scan {:id ?x &amp; ?c}) _) ?optional2]
   {:id ?x
    &amp;0 ?a
    &amp;1 (m/pick ?b {})
    &amp;2 (m/pick ?c {})}))</pre></z><z id="t1670567066" t="noprompt zeta has a short circuiting m/or called m/pick ."><y>#</y><d>2022-12-09</d><h>06:24</h><r>noprompt</r><code>zeta</code> has a short circuiting <code>m/or</code> called <code>m/pick</code>.</z><z id="t1670567162" t="noprompt It is also slightly different in that everything that you can do on the left you can do on the right which is why m/let is there an there are guards around the variables ?b and ?c which may not be bound."><y>#</y><d>2022-12-09</d><h>06:26</h><r>noprompt</r>It is also slightly different in that everything that you can do on the left you can do on the right which is why <code>m/let</code> is there an there are guards around the variables <code>?b</code> and <code>?c</code> which may not be bound.</z><z id="t1670567526" t="noprompt It might be possible add something like m/or! to epsilon"><y>#</y><d>2022-12-09</d><h>06:32</h><r>noprompt</r>It might be possible add something like <code>m/or!</code> to <code>epsilon</code></z><z id="t1670697877" t="grant Thanks you [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] and [:attrs {:href &quot;/_/_/users/UG9CG9GDB&quot;}] . Both of these are much clearer than the attempts I had managed so far. At this point, is Epsilon still recommended over Zeta, or should I start using Zeta since I don’t have any legacy code (or knowledge) to worry about?"><y>#</y><d>2022-12-10</d><h>18:44</h><r>grant</r>Thanks you <a>@U06MDAPTP</a> and <a>@UG9CG9GDB</a>. Both of these are much clearer than the attempts I had managed so far. At this point, is Epsilon still recommended over Zeta, or should I start using Zeta since I don’t have any legacy code (or knowledge) to worry about?</z><z id="t1672588782" t="markaddleman Happy New Year, meanderers! esp [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] 🙂 I’m wondering if you’ve given any thought to nested memory variables in zeta ? For example, in honeysql, I need to capture inline views {:from [[{:select [[!expr !alias] ...]} !inline-view-alias] ...] and rewrite them as (m/map-of !inline-view-alias (m/map-of !alias !expr)) epsilon collects all expr and alias together from all of the inline views so the outer map only has a single entry."><y>#</y><d>2023-01-01</d><h>15:59</h><w>markaddleman</w>Happy New Year, meanderers!  esp <a>@noprompt</a> <b>🙂</b>

I’m wondering if you’ve given any thought to nested memory variables in <code>zeta</code> ?  For example, in honeysql, I need to capture inline views
<pre>{:from [[{:select [[!expr !alias] ...]} !inline-view-alias] ...]</pre>
and rewrite them as
<pre>(m/map-of !inline-view-alias (m/map-of !alias !expr))</pre>
<code>epsilon</code> collects all <code>expr</code> and <code>alias</code> together from all of the inline views so the outer map only has a single entry.</z><z id="t1672588842" t="markaddleman I’m thinking that a nifty notation for nested memory variables might be !! but I’m not sure if that carries enough information to expand appropriately"><y>#</y><d>2023-01-01</d><h>16:00</h><r>markaddleman</r>I’m thinking that a nifty notation for nested memory variables might be <code>!!</code> but I’m not sure if that carries enough information to expand appropriately</z><z id="t1672693870" t="noprompt Yes, but not quite this way. This is an example where m/let would be useful on the RHS. {:from (m/scan [{:select !pairs} !inline-view])} (m/map-of !inline-view (m/let [[[!expr !alias] ...] !pairs] (m/map-of !alias !expr))) "><y>#</y><d>2023-01-02</d><h>21:11</h><r>noprompt</r>Yes, but not quite this way. This is an example where <code>m/let</code> would be useful on the RHS.

<pre>{:from (m/scan [{:select !pairs} !inline-view])}
(m/map-of !inline-view (m/let [[[!expr !alias] ...] !pairs]
                         (m/map-of !alias !expr)))</pre>
</z><z id="t1672694319" t="markaddleman Neat. I&apos;m looking forward to trying it zeta when it&apos;s ready!"><y>#</y><d>2023-01-02</d><h>21:18</h><r>markaddleman</r>Neat.  I&apos;m looking forward to trying it zeta when it&apos;s ready!</z><z id="t1674171218" t="noprompt [:attrs {:href &quot;/_/_/users/U2845S9KL&quot;}] I’ve been busy at work with a big project and studying ML/AI at home. There hasn’t been a lot of overlap with Meander (yet) but I’m trying to slash through work as quickly (and responsibly) as possible so I can make a time shaped hole for Meander."><y>#</y><d>2023-01-19</d><h>23:33</h><r>noprompt</r><a>@U2845S9KL</a> I’ve been busy at work with a big project and studying ML/AI at home. There hasn’t been a lot of overlap with Meander (yet) but I’m trying to slash through work as quickly (and responsibly) as possible so I can make a time shaped hole for Meander.</z><z id="t1674171470" t="noprompt ML/AI I can’t really cut corners on; I just have to put in the time to learn things. But I’m pretty confident that it’s going to become more commonplace in our line of work and it won’t be time wasted."><y>#</y><d>2023-01-19</d><h>23:37</h><r>noprompt</r>ML/AI I can’t really cut corners on; I just have to put in the time to learn things. But I’m pretty confident that it’s going to become more commonplace in our line of work and it won’t be time wasted.</z><z id="t1673271181" t="Stephan Renatus heya. just starting to wrap my mind around meander, and it’s been pleasant so far. can someone point out my mistake here, please? I had hoped that the following two snippets ( 🧵 ) would to the same, but they don’t. I’m exploring rewrites ."><y>#</y><d>2023-01-09</d><h>13:33</h><w>Stephan Renatus</w>heya. just starting to wrap my mind around meander, and it’s been pleasant so far. can someone point out my mistake here, please? I had hoped that the following two snippets (<b>🧵</b>) would to the same, but they don’t. I’m exploring <code>rewrites</code>.</z><z id="t1673271186" t="Stephan Renatus (defn process-suites [benchmarks] (m/rewrites {:bench benchmarks} {:bench (m/scan {:Version ?v :Date ?d :Suites (m/scan {:Pkg ?pkg :Benchmarks (m/scan {:Name ?name :NsPerOp ?ns_per_op})})})} {:version ?v :date ?d :pkg ?pkg :name ?name :ns_per_op ?ns_per_op})) (defn process-suites0 [benchmarks] (m/rewrites benchmarks [{:Version !v :Date !d :Suites [{:Pkg !pkg :Benchmarks [{:Name !name :NsPerOp !ns_per_op} ...]} ...]} ... ] [{:version !v :date !d :pkg !pkg :name !name :ns_per_op !ns_per_op} ...]))"><y>#</y><d>2023-01-09</d><h>13:33</h><r>Stephan Renatus</r><pre>(defn process-suites [benchmarks]
  (m/rewrites {:bench benchmarks}
              {:bench (m/scan {:Version ?v
                               :Date ?d
                               :Suites (m/scan {:Pkg ?pkg
                                                :Benchmarks (m/scan {:Name ?name
                                                                     :NsPerOp ?ns_per_op})})})}
              {:version ?v :date ?d :pkg ?pkg :name ?name :ns_per_op ?ns_per_op}))

(defn process-suites0 [benchmarks]
  (m/rewrites benchmarks
               [{:Version !v
                 :Date !d
                 :Suites [{:Pkg !pkg
                           :Benchmarks [{:Name !name
                                         :NsPerOp !ns_per_op} ...]} ...]} ... ]
              [{:version !v :date !d :pkg !pkg :name !name :ns_per_op !ns_per_op} ...]))</pre></z><z id="t1673271203" t="Stephan Renatus the first does the trick, the second one returns nil when called on the data"><y>#</y><d>2023-01-09</d><h>13:33</h><r>Stephan Renatus</r>the first does the trick, the second one returns <code>nil</code> when called on the data</z><z id="t1673289971" t="gdubs best provide your input data"><y>#</y><d>2023-01-09</d><h>18:46</h><r>gdubs</r>best provide your input data</z><z id="t1673290018" t="gdubs m/scan isn&apos;t equivalent to what you have below. scan looks for anything that matches and will skip over mismatches. Your below example requires that everything match."><y>#</y><d>2023-01-09</d><h>18:46</h><r>gdubs</r><code>m/scan</code> isn&apos;t equivalent to what you have below.  <code>scan</code> looks for anything that matches and will skip over mismatches.  Your below example requires that everything match.</z><z id="t1673340473" t="Stephan Renatus thanks for your reply. example data would be https://github.com/bobheadxi/gobenchdata/blob/gh-pages/benchmarks.json"><y>#</y><d>2023-01-10</d><h>08:47</h><r>Stephan Renatus</r>thanks for your reply. example data would be <a href="https://github.com/bobheadxi/gobenchdata/blob/gh-pages/benchmarks.json" target="_blank">https://github.com/bobheadxi/gobenchdata/blob/gh-pages/benchmarks.json</a></z><z id="t1673340499" t="Stephan Renatus the records are homogeneous, there are no missing fields"><y>#</y><d>2023-01-10</d><h>08:48</h><r>Stephan Renatus</r>the records are homogeneous, there are no missing fields</z><z id="t1673450863" t="Jamie Walkerdine Hi folks, so we&apos;re working on a project that involves meander quite heavily and we&apos;ve been relying on the search macro (or rather we&apos;ve been compiling search and then evaluating) but we realised that because it&apos;s relying on eval then when we start introducing large blocks of data and trying to evaluate programmatically, we have issues with the methods being too large and resulting in syntax errors. The transform itself works but since we need to compile these transforms programmatically it becomes an issue- tried a solution similar to compile-match-args and deconstructing search (a la https://www.metosin.fi/blog/transforming-data-with-malli-and-meander/ ) but it still relies on eval at the end, for which we need to insert our large pieces of data into a syntactic expression yielding the same error, and we&apos;ve also tried relying on the interpreter endpoint (which seems to be too slow) Does anyone know how to get around this issue?"><y>#</y><d>2023-01-11</d><h>15:27</h><w>Jamie Walkerdine</w>Hi folks, so we&apos;re working on a project that involves meander quite heavily and we&apos;ve been relying on the search macro (or rather we&apos;ve been compiling search and then evaluating) but we realised that because it&apos;s relying on <code>eval</code> then when we start introducing large blocks of data and trying to evaluate programmatically, we have issues with the methods being too large and resulting in syntax errors.
 The transform itself works but since we need to compile these transforms programmatically it becomes an issue- tried a solution similar to <code>compile-match-args</code> and deconstructing <code>search</code> (a la <a href="https://www.metosin.fi/blog/transforming-data-with-malli-and-meander/" target="_blank">https://www.metosin.fi/blog/transforming-data-with-malli-and-meander/</a>)  but it still relies on <code>eval</code> at the end, for which we need to insert our large pieces of data into a syntactic expression yielding the same error, and we&apos;ve also tried relying on the interpreter endpoint (which seems to be too slow)

Does anyone know how to get around this issue?</z><z id="t1673591211" t="noprompt This might sound crazy but have you tried writing the macroexpansion to a file?"><y>#</y><d>2023-01-13</d><h>06:26</h><r>noprompt</r>This might sound crazy but have you tried writing the macroexpansion to a file?</z><z id="t1673591484" t="noprompt I have experimented with this and it does work provided you write out the ns form with all the necessary :require s which is pretty easy to get with something like (into [] (comp (filter qualified-symbol?) (map (comp symbol namespace)) (distinct)) (tree-seq coll? seq expanded-form)) "><y>#</y><d>2023-01-13</d><h>06:31</h><r>noprompt</r>I have experimented with this and it does work provided you write out the <code>ns</code> form with all the necessary <code>:require</code> s which is pretty easy to get with something like
<pre>(into []
  (comp (filter qualified-symbol?)
        (map (comp symbol namespace))
        (distinct))
  (tree-seq coll? seq expanded-form))</pre>
</z><z id="t1673591673" t="noprompt If this doesn&apos;t work, I can try to come up with some other ideas but I might need some more information/examples to be the most helpful."><y>#</y><d>2023-01-13</d><h>06:34</h><r>noprompt</r>If this doesn&apos;t work, I can try to come up with some other ideas but I might need some more information/examples to be the most helpful.</z><z id="t1673591713" t="noprompt The next several days are pretty busy for me but I will check back as soon as I have a chance."><y>#</y><d>2023-01-13</d><h>06:35</h><r>noprompt</r>The next several days are pretty busy for me but I will check back as soon as I have a chance.</z><z id="t1673989051" t="noprompt [:attrs {:href &quot;/_/_/users/U04A9F0Q1GU&quot;}] Hello! I’m following up to see if you are still need help."><y>#</y><d>2023-01-17</d><h>20:57</h><r>noprompt</r><a>@U04A9F0Q1GU</a> Hello! I’m following up to see if you are still need help.</z><z id="t1674744063" t="Roma Hello, I&apos;m learning meander and trying to migrate my existing clojure code for some API client to it. So far it goes pretty good, but I have one use case I&apos;d like to implement and I&apos;m not sure how to do that. The input looks like the following: {:etag &quot;doesn&apos;t matter&quot; :uuid &quot;E6FDD9A4-3820-11ED-A2D1-70110F7B78B9&quot; :called_on &quot;2022-09-19 13:42:28.394228+00&quot; :entity {:prop [{:name &quot;advertiser_id&quot; :value &quot;1&quot;} {:name &quot;concept_id&quot; :value &quot;2&quot;} {:name &quot;name&quot; :value &quot;Some name&quot;} {:name &quot;width&quot; :value &quot;320&quot;} {:name &quot;height&quot; :value &quot;50&quot;} {:name &quot;file_type&quot; :value &quot;jpg&quot;}] :version 3 :type &quot;some type&quot; :name &quot;Some name&quot; :id 5 :entity [{:id 6 :prop [{:name &quot;atomic_creative_id&quot; :value &quot;9&quot;} {:name &quot;is_https&quot; :value &quot;YES&quot;} {:name &quot;url&quot; :value &quot;&quot;}] :rel &quot;atomic_creative_detected_tag_urls&quot; :type &quot;atomic_creative_detected_tag_url&quot; :name &quot;Atomic Creative Detected Tag Urls 9&quot;} {:id 7 :prop [{:name &quot;atomic_creative_id&quot; :value &quot;10&quot;} {:name &quot;is_https&quot; :value &quot;YES&quot;} {:name &quot;url&quot; :value &quot;&quot;} {:name &quot;vendor_domain_id&quot; :value &quot;641&quot;}] :rel &quot;atomic_creative_detected_tag_urls&quot; :type &quot;atomic_creative_detected_tag_url&quot; :name &quot;Atomic Creative Detected Tag Urls 10&quot;} {:id 8 :prop [{:name &quot;atomic_creative_id&quot; :value &quot;11&quot;} {:name &quot;is_https&quot; :value &quot;YES&quot;} {:name &quot;url&quot; :value &quot;&quot;} {:name &quot;vendor_domain_id&quot; :value &quot;812&quot;}] :rel &quot;atomic_creative_detected_tag_urls&quot; :type &quot;atomic_creative_detected_tag_url&quot; :name &quot;Atomic Creative Detected Tag Urls 11&quot;}]} :status {:code &quot;ok&quot;}} I need to fetch url value for :prop where vendor_domain_id value is 812 . So the correct result would be &quot;&quot; . Not sure what I should use, I&apos;m trying rewrite : (m/rewrite input {:entity {:entity [!entities ...]}} [(m/cata !entities) ...] {:prop [!props ...]} [(m/cata !props) ...] {:name ?name :value ?value} [(m/keyword ?name) ?value]) But I guess I need to combine it with pred or gather ? Is it good use case for meander or maybe I should rather stick with pure clojure maps and filters? Thank you in advance."><y>#</y><d>2023-01-26</d><h>14:41</h><w>Roma</w>Hello, I&apos;m learning meander and trying to migrate my existing clojure code for some API client to it. So far it goes pretty good, but I have one use case I&apos;d like to implement and I&apos;m not sure how to do that.

The input looks like the following:
<pre>{:etag      &quot;doesn&apos;t matter&quot;
 :uuid      &quot;E6FDD9A4-3820-11ED-A2D1-70110F7B78B9&quot;
 :called_on &quot;2022-09-19 13:42:28.394228+00&quot;
 :entity
 {:prop
  [{:name &quot;advertiser_id&quot; :value &quot;1&quot;}
   {:name &quot;concept_id&quot; :value &quot;2&quot;}
   {:name &quot;name&quot; :value &quot;Some name&quot;}
   {:name &quot;width&quot; :value &quot;320&quot;}
   {:name &quot;height&quot; :value &quot;50&quot;}
   {:name &quot;file_type&quot; :value &quot;jpg&quot;}]
  :version 3
  :type    &quot;some type&quot;
  :name    &quot;Some name&quot;
  :id      5
  :entity
  [{:id   6
    :prop
    [{:name &quot;atomic_creative_id&quot; :value &quot;9&quot;}
     {:name &quot;is_https&quot; :value &quot;YES&quot;}
     {:name &quot;url&quot; :value &quot;&quot;}]
    :rel  &quot;atomic_creative_detected_tag_urls&quot;
    :type &quot;atomic_creative_detected_tag_url&quot;
    :name &quot;Atomic Creative Detected Tag Urls 9&quot;}
   {:id   7
    :prop
    [{:name &quot;atomic_creative_id&quot; :value &quot;10&quot;}
     {:name &quot;is_https&quot; :value &quot;YES&quot;}
     {:name &quot;url&quot; :value &quot;&quot;}
     {:name &quot;vendor_domain_id&quot; :value &quot;641&quot;}]
    :rel  &quot;atomic_creative_detected_tag_urls&quot;
    :type &quot;atomic_creative_detected_tag_url&quot;
    :name &quot;Atomic Creative Detected Tag Urls 10&quot;}
   {:id   8
    :prop
    [{:name &quot;atomic_creative_id&quot; :value &quot;11&quot;}
     {:name &quot;is_https&quot; :value &quot;YES&quot;}
     {:name &quot;url&quot; :value &quot;&quot;}
     {:name &quot;vendor_domain_id&quot; :value &quot;812&quot;}]
    :rel  &quot;atomic_creative_detected_tag_urls&quot;
    :type &quot;atomic_creative_detected_tag_url&quot;
    :name &quot;Atomic Creative Detected Tag Urls 11&quot;}]}
 :status    {:code &quot;ok&quot;}}</pre>
I need to fetch <code>url</code> value for <code>:prop</code> where <code>vendor_domain_id</code> value is <code>812</code>. So the correct result would be  <code>&quot;&quot;</code> .

Not sure what I should use, I&apos;m trying <code>rewrite</code> :
<pre>(m/rewrite input
  {:entity {:entity [!entities ...]}}
  [(m/cata !entities) ...]

  {:prop [!props ...]}
  [(m/cata !props) ...]

  {:name ?name :value ?value}
  [(m/keyword ?name) ?value])</pre>
But I guess I need to combine it with <code>pred</code> or <code>gather</code>? Is it good use case for meander or maybe I should rather stick with pure clojure maps and filters? Thank you in advance.</z><z id="t1674876778" t="Richie At a glance it seems like a fine use of meander. I’ll check it tomorrow when I get time. "><y>#</y><d>2023-01-28</d><h>03:32</h><r>Richie</r>At a glance it seems like a fine use of meander. I’ll check it tomorrow when I get time. </z><z id="t1674920863" t="Richie This has shown me that I don&apos;t remember much about meander. I really struggled. Anyways, here&apos;s one way. (-&gt; input (m/rewrite {:entity {:entity [{:prop [{:name !name :value !value} ..!n]} ...]}} [{&amp; ([!name !value] ..!n)} ...]) (m/match (m/gather {&quot;vendor_domain_id&quot; &quot;812&quot; &quot;url&quot; !url}) !url)) ;; [&quot;&quot;]"><y>#</y><d>2023-01-28</d><h>15:47</h><r>Richie</r>This has shown me that I don&apos;t remember much about meander. I really struggled. Anyways, here&apos;s one way.
<pre>(-&gt; input
    (m/rewrite
      {:entity {:entity [{:prop [{:name !name :value !value} ..!n]} ...]}}
      [{&amp; ([!name !value] ..!n)} ...])
    (m/match
      (m/gather {&quot;vendor_domain_id&quot; &quot;812&quot;
                 &quot;url&quot; !url})
      !url))
;; [&quot;&quot;]</pre></z><z id="t1675075938" t="Roma Thank you! That&apos;s very helpful. I was trying to achieve it with a single m/rewrite call and didn&apos;t think about combining rewrite with match. Also ..!n syntax is something new to me."><y>#</y><d>2023-01-30</d><h>10:52</h><r>Roma</r>Thank you! That&apos;s very helpful. I was trying to achieve it with a single <code>m/rewrite</code> call and didn&apos;t think about combining rewrite with match. Also <code>..!n</code> syntax is something new to me.</z><z id="t1675092759" t="Richie Awesome; I&apos;m glad that I could help."><y>#</y><d>2023-01-30</d><h>15:32</h><r>Richie</r>Awesome; I&apos;m glad that I could help.</z><z id="t1675424776" t="hanDerPeder I&apos;m struggling translating this transform function to meander. It transform a list of heterogenous values into a different representation. Tried using scan with memory variables, but then I basically have to reimplement the mapping function in the meander expression. Any pointers? (def data [{:value &quot;hello&quot;} {:foo 123}]) (defn transform [data] (mapv (fn [{:keys [value foo]}] (if value {:type :a :value value} {:type :b :foo-amount foo})) data)) (transform data) ; =&gt; [{:type :a, :value &quot;hello&quot;} {:type :b, :foo-amount 123}]"><y>#</y><d>2023-02-03</d><h>11:46</h><w>hanDerPeder</w>I&apos;m struggling translating this transform function to meander. It transform a list of heterogenous values into a different representation. Tried using scan with memory variables, but then I basically have to reimplement the mapping function in the meander expression. Any pointers?

<pre>(def data [{:value &quot;hello&quot;} {:foo 123}])

(defn transform [data]
  (mapv
   (fn [{:keys [value foo]}]
     (if value
       {:type :a :value value}
       {:type :b :foo-amount foo}))
   data))

(transform data) ; =&gt; [{:type :a, :value &quot;hello&quot;} {:type :b, :foo-amount 123}]</pre></z><z id="t1675425593" t="xificurC have a look at m/rewrites . Something like (m/rewrites data {:value (m/pred some? ?v)} {:type :a, :value ?v} {:foo (m/pred some? ?foo)} {:type :b, :value ?foo})"><y>#</y><d>2023-02-03</d><h>11:59</h><r>xificurC</r>have a look at <code>m/rewrites</code>. Something like
<pre>(m/rewrites data
  {:value (m/pred some? ?v)} {:type :a, :value ?v}
  {:foo (m/pred some? ?foo)} {:type :b, :value ?foo})</pre></z><z id="t1675426664" t="hanDerPeder nice thanks. the data list is actually nested inside some larger structure. can I inline rewrites? something like (def data {:title &quot;hello&quot; :list [{:value &quot;hello&quot;} {:foo 123}]}) (match data {:title ?title :list (rewrite {:value (pred some? ?v)} {:type :a :value ?v} {:foo (pred some? ?foo)} {:type :b :foo-amount ?foo})} {:the-title? ?title ...? } )"><y>#</y><d>2023-02-03</d><h>12:17</h><r>hanDerPeder</r>nice thanks.
the data list is actually nested inside some larger structure. can I inline rewrites? something like
<pre>(def data {:title &quot;hello&quot;
           :list
           [{:value &quot;hello&quot;} {:foo 123}]})


(match data
  {:title ?title
   :list (rewrite
          {:value (pred some? ?v)} {:type :a :value ?v}
          {:foo (pred some? ?foo)} {:type :b :foo-amount ?foo})}

  {:the-title? ?title
   ...?
   }
  )</pre></z><z id="t1675427178" t="hanDerPeder or (match data {:title ?title :list ?list} {:the-title? ?title :new-list (m/rewrites ?list {:value (m/pred some? ?v)} {:type :a :value ?v} {:foo (m/pred some? ?foo)} {:type :foo :foo-amount ?foo})})"><y>#</y><d>2023-02-03</d><h>12:26</h><r>hanDerPeder</r>or
<pre>(match data
  {:title ?title
   :list ?list}

  {:the-title? ?title
   :new-list (m/rewrites ?list
               {:value (m/pred some? ?v)} {:type :a :value ?v}
               {:foo (m/pred some? ?foo)} {:type :foo :foo-amount ?foo})})</pre></z><z id="t1675428643" t="hanDerPeder hmm, can&apos;t seem to get this to work this works (mean/rewrites {:value &quot;hello&quot;} {:value (mean/pred some? ?v)} {:type :a :value ?v} {:foo (mean/pred some? ?foo)} {:type :b :foo-amount ?foo}) ; =&gt; ({:type :a, :value &quot;hello&quot;}) and this gives the same output (mean/rewrites [{:value &quot;hello&quot;} {:foo 123}] [{:value (mean/pred some? ?v)} &amp; _] {:type :a :value ?v} [{:foo (mean/pred some? ?foo)} &amp; _] {:type :b :foo-amount ?foo}) ; =&gt; ({:type :a, :value &quot;hello&quot;}) but not sure how to apply this for each element"><y>#</y><d>2023-02-03</d><h>12:50</h><r>hanDerPeder</r>hmm, can&apos;t seem to get this to work

this works
<pre>(mean/rewrites {:value &quot;hello&quot;}
  {:value (mean/pred some? ?v)} {:type :a :value ?v}
  {:foo (mean/pred some? ?foo)} {:type :b :foo-amount ?foo}) ; =&gt; ({:type :a, :value &quot;hello&quot;})</pre>
and this gives the same output
<pre>(mean/rewrites [{:value &quot;hello&quot;} {:foo 123}]
  [{:value (mean/pred some? ?v)} &amp; _] {:type :a :value ?v}
  [{:foo (mean/pred some? ?foo)} &amp; _] {:type :b :foo-amount ?foo}) ; =&gt; ({:type :a, :value &quot;hello&quot;})</pre>
but not sure how to apply this for each element</z><z id="t1675429925" t="xificurC"><y>#</y><d>2023-02-03</d><h>13:12</h><r>xificurC</r></z><z id="t1675429951" t="xificurC https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#rewrite-sequence-of-maps"><y>#</y><d>2023-02-03</d><h>13:12</h><r>xificurC</r><a href="https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#rewrite-sequence-of-maps" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#rewrite-sequence-of-maps</a></z><z id="t1675430158" t="xificurC tbh in this case I&apos;d go with a partial solution like below. Not sure if meander gives you much here though"><y>#</y><d>2023-02-03</d><h>13:15</h><r>xificurC</r>tbh in this case I&apos;d go with a partial solution like below. Not sure if meander gives you much here though</z><z id="t1675430324" t="hanDerPeder thanks for the help!"><y>#</y><d>2023-02-03</d><h>13:18</h><r>hanDerPeder</r>thanks for the help!</z><z id="t1675430582" t="xificurC btw ctrl+shift+enter or type /snippet to create a collapsible snippet that can have syntax highlighting"><y>#</y><d>2023-02-03</d><h>13:23</h><r>xificurC</r>btw <code>ctrl+shift+enter</code> or type <code>/snippet</code> to create a collapsible snippet that can have syntax highlighting</z><z id="t1675430617" t="hanDerPeder cool didn&apos;t know that 👍"><y>#</y><d>2023-02-03</d><h>13:23</h><r>hanDerPeder</r>cool didn&apos;t know that <b>👍</b></z><z id="t1675506181" t="hanDerPeder This works"><y>#</y><d>2023-02-04</d><h>10:23</h><r>hanDerPeder</r>This works</z><z id="t1675890938" t="hanDerPeder (match [1] [!x ...] (subst [(+ 1 !x) ...])) ;; =&gt; [(+ 1 1)] is it possible to get this to return [2] using subst?"><y>#</y><d>2023-02-08</d><h>21:15</h><w>hanDerPeder</w><pre>(match [1]
  [!x ...] (subst [(+ 1 !x) ...])) ;; =&gt; [(+ 1 1)]</pre>
is it possible to get this to return [2] using subst?</z><z id="t1675891243" t="xificurC why not just (match 1 ?x (inc ?x)) ?"><y>#</y><d>2023-02-08</d><h>21:20</h><r>xificurC</r>why not just <code>(match 1 ?x (inc ?x))</code>?</z><z id="t1675891267" t="hanDerPeder doing something else, but trying to simplify the example to focus on my issue"><y>#</y><d>2023-02-08</d><h>21:21</h><r>hanDerPeder</r>doing something else, but trying to simplify the example to focus on my issue</z><z id="t1675891304" t="xificurC user=&gt; (m/match 1 ?x (m/subst ~(+ 1 ?x))) 2"><y>#</y><d>2023-02-08</d><h>21:21</h><r>xificurC</r><pre>user=&gt; (m/match 1 ?x (m/subst ~(+ 1 ?x)))
2</pre></z><z id="t1675891417" t="hanDerPeder doesn&apos;t work since it&apos;s a memory variable in my example. (match [1 2 3] [!x ...] (subst [(+ 1 !x) ...]))"><y>#</y><d>2023-02-08</d><h>21:23</h><r>hanDerPeder</r>doesn&apos;t work since it&apos;s a memory variable in my example.

<pre>(match [1 2 3]
  [!x ...] (subst [(+ 1 !x) ...]))</pre></z><z id="t1675891450" t="jgdavey There are a bunch of ways to “apply”, including the unquote and m/app"><y>#</y><d>2023-02-08</d><h>21:24</h><r>jgdavey</r>There are a bunch of ways to “apply”, including the unquote and <code>m/app</code></z><z id="t1675891471" t="hanDerPeder m/app might be what I&apos;m looking for"><y>#</y><d>2023-02-08</d><h>21:24</h><r>hanDerPeder</r>m/app might be what I&apos;m looking for</z><z id="t1675891539" t="hanDerPeder (match [1 2 3] [!x ...] (subst [(app (partial + 1) !x) ...])) ;; =&gt; [2 3 4] 👍"><y>#</y><d>2023-02-08</d><h>21:25</h><r>hanDerPeder</r><pre>(match [1 2 3]
  [!x ...] (subst [(app (partial + 1) !x) ...]))
;; =&gt; [2 3 4]</pre>
<b>👍</b></z><z id="t1675891570" t="hanDerPeder why cant unqoute work with memory variables?"><y>#</y><d>2023-02-08</d><h>21:26</h><r>hanDerPeder</r>why cant unqoute work with memory variables?</z><z id="t1675891603" t="jgdavey I’m not sure of the limitations, but I do know that unquote-splice is a known thing that doesn’t work"><y>#</y><d>2023-02-08</d><h>21:26</h><r>jgdavey</r>I’m not sure of the limitations, but I do know that unquote-splice is a known thing that doesn’t work</z><z id="t1675891613" t="jgdavey perhaps related?"><y>#</y><d>2023-02-08</d><h>21:26</h><r>jgdavey</r>perhaps related?</z><z id="t1675891667" t="hanDerPeder could be. my understanding of meander is pretty surface level at the moment"><y>#</y><d>2023-02-08</d><h>21:27</h><r>hanDerPeder</r>could be. my understanding of meander is pretty surface level at the moment</z><z id="t1675891675" t="xificurC (app (partial + 1) !x) is just (app inc !x)"><y>#</y><d>2023-02-08</d><h>21:27</h><r>xificurC</r><code>(app (partial + 1) !x)</code> is just <code>(app inc !x)</code></z><z id="t1675891213" t="hanDerPeder my current workaround (match [1] [!x ...] (mapv #(+ 1 %) !x)) ;; =&gt; [2]"><y>#</y><d>2023-02-08</d><h>21:20</h><w>hanDerPeder</w>my current workaround
<pre>(match [1]
  [!x ...] (mapv #(+ 1 %) !x)) ;; =&gt; [2]</pre></z><z id="t1676504436" t="nyor.tr Hi, I just started learning about meander and I have a couple of questions: Using the data bellow, 1. Would it be possible to join the items in a vector of maps which have the same keys? for example for :authors . (Assuming there will only be two items in the vector :editions ). 1. Assign values to keys based on conditions from other keys, for example the key :first-edition-year would have the value of :publication-year if the value of key :first-edition is true. I have: {:editions [{:book {:id 1 :title &quot;title1&quot; :authors [&quot;author1&quot; &quot;author2&quot;] :pages 123 :isbn &quot;2353-2343&quot; :publication-year 1995 :first-edition true}} {:book {:id 2 :title &quot;title1&quot; :authors [&quot;author3&quot;] :pages 123 :isbn &quot;6745-4623&quot; :publication-year 2001}}]} Transform into: {:title &quot;title1&quot; :authors [&quot;author1&quot; &quot;author2&quot; &quot;author3&quot;] :pages 123 :first-edition-year 1995 :publication-year 2001}"><y>#</y><d>2023-02-15</d><h>23:40</h><w>nyor.tr</w>Hi, I just started learning about meander and I have a couple of questions:
Using the data bellow,
1. Would it be possible to join the items in a vector of maps which have the same keys?
 for example for <code>:authors</code>. (Assuming there will only be two items in the vector <code>:editions</code>).
1. Assign values to keys based on conditions from other keys, for example the key <code>:first-edition-year</code> would have the value of <code>:publication-year</code> if the value of key <code>:first-edition</code> is true.
I have:
<pre>{:editions [{:book {:id 1
                    :title &quot;title1&quot;
                    :authors [&quot;author1&quot; &quot;author2&quot;]
                    :pages 123
                    :isbn &quot;2353-2343&quot;
                    :publication-year 1995
                    :first-edition true}}
            {:book {:id 2
                    :title &quot;title1&quot;
                    :authors [&quot;author3&quot;]
                    :pages 123
                    :isbn &quot;6745-4623&quot;
                    :publication-year 2001}}]}</pre>
Transform into:
<pre>{:title &quot;title1&quot;
 :authors [&quot;author1&quot; &quot;author2&quot; &quot;author3&quot;]
 :pages 123
 :first-edition-year 1995
 :publication-year 2001}</pre></z><z id="t1676657354" t="noprompt [:attrs {:href &quot;/_/_/users/U0U2W7B71&quot;}] (def data {:editions [{:book {:id 0 :title &quot;title1&quot; :authors [&quot;author1&quot; &quot;author2&quot;] :pages 123 :isbn &quot;2353-2343&quot; :publication-year 1995 :first-edition true}} {:book {:id 1 :title &quot;title2&quot; :authors [&quot;author3&quot;] :pages 123 :isbn &quot;6745-4623&quot; :publication-year 2001}} {:book {:id 2 :title &quot;title1&quot; :authors [&quot;author3&quot;] :pages 123 :isbn &quot;6745-4623&quot; :publication-year 2001}} {:book {:id 3 :title &quot;title2&quot; :authors [&quot;author4&quot;] :pages 123 :isbn &quot;6745-4623&quot; :publication-year 2001}} {:book {:id 4 :title &quot;title1&quot; :authors [&quot;author3&quot;] :pages 123 :isbn &quot;6745-4623&quot; :publication-year 2001}}]}) (defn join-books [editions] (m/find editions (m/with [%book {:book {:title ?title :authors [!authors ...] &amp; !book-data}}] [%book &amp; [(m/or %book !not-book) ...]]) (cons {:title ?title :authors !authors :book-data !book-data} (join-books !not-book)))) (join-books (:editions data)) ;; =&gt; ({:title &quot;title1&quot;, :authors [&quot;author1&quot; &quot;author2&quot; &quot;author3&quot; &quot;author3&quot;], :book-data [{:id 0, :pages 123, :isbn &quot;2353-2343&quot;, :publication-year 1995, :first-edition true} {:id 2, :pages 123, :isbn &quot;6745-4623&quot;, :publication-year 2001} {:id 4, :pages 123, :isbn &quot;6745-4623&quot;, :publication-year 2001}]} {:title &quot;title2&quot;, :authors [&quot;author3&quot; &quot;author4&quot;], :book-data [{:id 1, :pages 123, :isbn &quot;6745-4623&quot;, :publication-year 2001} {:id 3, :pages 123, :isbn &quot;6745-4623&quot;, :publication-year 2001}]}) "><y>#</y><d>2023-02-17</d><h>18:09</h><w>noprompt</w><a>@nyor.tr</a>
<pre>(def data
  {:editions [{:book {:id 0
                      :title &quot;title1&quot;
                      :authors [&quot;author1&quot; &quot;author2&quot;]
                      :pages 123
                      :isbn &quot;2353-2343&quot;
                      :publication-year 1995
                      :first-edition true}}
              {:book {:id 1
                      :title &quot;title2&quot;
                      :authors [&quot;author3&quot;]
                      :pages 123
                      :isbn &quot;6745-4623&quot;
                      :publication-year 2001}}
              {:book {:id 2
                      :title &quot;title1&quot;
                      :authors [&quot;author3&quot;]
                      :pages 123
                      :isbn &quot;6745-4623&quot;
                      :publication-year 2001}}
              {:book {:id 3
                      :title &quot;title2&quot;
                      :authors [&quot;author4&quot;]
                      :pages 123
                      :isbn &quot;6745-4623&quot;
                      :publication-year 2001}}
              {:book {:id 4
                      :title &quot;title1&quot;
                      :authors [&quot;author3&quot;]
                      :pages 123
                      :isbn &quot;6745-4623&quot;
                      :publication-year 2001}}]})


(defn join-books [editions]
  (m/find editions
    (m/with [%book {:book {:title ?title
                           :authors [!authors ...]
                           &amp; !book-data}}]
      [%book &amp; [(m/or %book !not-book) ...]])
    (cons {:title ?title
           :authors !authors
           :book-data !book-data}
          (join-books !not-book))))

(join-books (:editions data))
;; =&gt;
({:title &quot;title1&quot;,
  :authors [&quot;author1&quot; &quot;author2&quot; &quot;author3&quot; &quot;author3&quot;],
  :book-data
  [{:id 0,
    :pages 123,
    :isbn &quot;2353-2343&quot;,
    :publication-year 1995,
    :first-edition true}
   {:id 2, :pages 123, :isbn &quot;6745-4623&quot;, :publication-year 2001}
   {:id 4, :pages 123, :isbn &quot;6745-4623&quot;, :publication-year 2001}]}
 {:title &quot;title2&quot;,
  :authors [&quot;author3&quot; &quot;author4&quot;],
  :book-data
  [{:id 1, :pages 123, :isbn &quot;6745-4623&quot;, :publication-year 2001}
   {:id 3, :pages 123, :isbn &quot;6745-4623&quot;, :publication-year 2001}]})</pre>
</z><z id="t1676657587" t="noprompt join-books can also be written with m/rewrite but m/find is best starting out. (defn join-books [editions] (m/rewrite editions (m/with [%book {:book {:title ?title :authors [!authors ...] &amp; !book-data}}] [%book &amp; [(m/or %book !not-book) ...]]) [{:title ?title :authors [!authors ...] :book-data [!book-data ...]} &amp; (m/cata [!not-book ...])] _else [])) "><y>#</y><d>2023-02-17</d><h>18:13</h><w>noprompt</w><code>join-books</code> can also be written with <code>m/rewrite</code> but <code>m/find</code> is best starting out.

<pre>(defn join-books [editions]
  (m/rewrite editions
    (m/with [%book {:book {:title ?title
                           :authors [!authors ...]
                           &amp; !book-data}}]
      [%book &amp; [(m/or %book !not-book) ...]])
    [{:title ?title
      :authors [!authors ...]
      :book-data [!book-data ...]}
     &amp; (m/cata [!not-book ...])]

    _else []))</pre>
</z><z id="t1676839678" t="Carlo I have a question on how to make a match optional while still being able to capture the match if it&apos;s there. Example and description in 🧵"><y>#</y><d>2023-02-19</d><h>20:47</h><w>Carlo</w>I have a question on how to make a match optional while still being able to capture the match if it&apos;s there. Example and description in <b>🧵</b></z><z id="t1676839699" t="Carlo Here&apos;s some example data: {:tag :note, :attrs {:default-x &quot;148.88&quot;, :default-y &quot;-10.00&quot;, :dynamics &quot;71.11&quot;, :measure &quot;1&quot;, :voice &quot;P1&quot;}, :content ({:tag :pitch, :attrs {}, :content ({:tag :step, :attrs {}, :content (&quot;D&quot;)} {:tag :alter, :attrs {}, :content (&quot;-1&quot;)} {:tag :octave, :attrs {}, :content (&quot;5&quot;)})} {:tag :duration, :attrs {}, :content (&quot;1&quot;)} {:tag :voice, :attrs {}, :content (&quot;1&quot;)} {:tag :type, :attrs {}, :content (&quot;16th&quot;)} {:tag :stem, :attrs {}, :content (&quot;down&quot;)} {:tag :beam, :attrs {:number &quot;1&quot;}, :content (&quot;continue&quot;)} {:tag :beam, :attrs {:number &quot;2&quot;}, :content (&quot;continue&quot;)})}"><y>#</y><d>2023-02-19</d><h>20:48</h><r>Carlo</r>Here&apos;s some example data:
<pre>{:tag :note,
 :attrs
 {:default-x &quot;148.88&quot;,
  :default-y &quot;-10.00&quot;,
  :dynamics &quot;71.11&quot;,
  :measure &quot;1&quot;,
  :voice &quot;P1&quot;},
 :content
 ({:tag :pitch,
   :attrs {},
   :content
   ({:tag :step, :attrs {}, :content (&quot;D&quot;)}
    {:tag :alter, :attrs {}, :content (&quot;-1&quot;)}
    {:tag :octave, :attrs {}, :content (&quot;5&quot;)})}
  {:tag :duration, :attrs {}, :content (&quot;1&quot;)}
  {:tag :voice, :attrs {}, :content (&quot;1&quot;)}
  {:tag :type, :attrs {}, :content (&quot;16th&quot;)}
  {:tag :stem, :attrs {}, :content (&quot;down&quot;)}
  {:tag :beam, :attrs {:number &quot;1&quot;}, :content (&quot;continue&quot;)}
  {:tag :beam, :attrs {:number &quot;2&quot;}, :content (&quot;continue&quot;)})}</pre></z><z id="t1676839744" t="Carlo Here&apos;s the pattern I&apos;m using to match it, which makes good use of meander&apos;s $ operator: (defn extract-essential-info [note] (meander/find note (meander/and {:tag :note :attrs {:measure ?measure :voice ?voice}} (meander/$ {:tag :step :content (?key)}) (meander/$ {:tag :alter :content (?alteration)}) (meander/$ {:tag :octave :content (?octave)}) (meander/$ {:tag :duration :content (?duration)}) (meander/$ {:tag :type :content (?type)})) {:tag :note :measure ?measure :voice ?voice :key ?key :alteration ?alteration :octave ?octave :duration ?duration :type ?type}))"><y>#</y><d>2023-02-19</d><h>20:49</h><r>Carlo</r>Here&apos;s the pattern I&apos;m using to match it, which makes good use of meander&apos;s <code>$</code> operator:
<pre>(defn extract-essential-info [note]
  (meander/find note
    (meander/and
     {:tag :note
      :attrs {:measure ?measure :voice ?voice}}
     (meander/$ {:tag :step :content (?key)})
     (meander/$ {:tag :alter :content (?alteration)})
     (meander/$ {:tag :octave :content (?octave)})
     (meander/$ {:tag :duration :content (?duration)})
     (meander/$ {:tag :type :content (?type)}))

    {:tag :note
     :measure ?measure
     :voice ?voice
     :key ?key
     :alteration ?alteration
     :octave ?octave
     :duration ?duration
     :type ?type}))</pre></z><z id="t1676839807" t="Carlo My problem is that sometimes I don&apos;t have an :alter tag anywhere in the structure, and in that case the match fails. How would I say that if the :alter match fails, I&apos;d like to have :alteration 0 in my map?"><y>#</y><d>2023-02-19</d><h>20:50</h><r>Carlo</r>My problem is that sometimes I don&apos;t have an <code>:alter</code> tag anywhere in the structure, and in that case the match fails. How would I say that if the <code>:alter</code> match fails, I&apos;d like to have <code>:alteration 0</code> in my map?</z><z id="t1676839946" t="Carlo Possible solution, extending with another clause for when the pattern is not there, like: (defn extract-essential-info [note] (meander/find note (meander/and {:tag :note :attrs {:measure ?measure :voice ?voice}} (meander/$ {:tag :step :content (?key)}) (meander/$ {:tag :alter :content (?alteration)}) (meander/$ {:tag :octave :content (?octave)}) (meander/$ {:tag :duration :content (?duration)}) (meander/$ {:tag :type :content (?type)})) {:tag :note :measure ?measure :voice ?voice :key ?key :alteration ?alteration :octave ?octave :duration ?duration :type ?type} (meander/and {:tag :note :attrs {:measure ?measure :voice ?voice}} (meander/$ {:tag :step :content (?key)}) (meander/not (meander/$ {:tag :alter :content (?alteration)})) (meander/$ {:tag :octave :content (?octave)}) (meander/$ {:tag :duration :content (?duration)}) (meander/$ {:tag :type :content (?type)})) {:tag :note :measure ?measure :voice ?voice :key ?key :alteration 0 :octave ?octave :duration ?duration :type ?type})) but this feels wasteful and it&apos;s subject to combinatorial explosion, I was hoping in a smarter encoding"><y>#</y><d>2023-02-19</d><h>20:52</h><r>Carlo</r>Possible solution, extending with another clause for when the pattern is not there, like:
<pre>(defn extract-essential-info [note]
  (meander/find note
    (meander/and
     {:tag :note
      :attrs {:measure ?measure :voice ?voice}}
     (meander/$ {:tag :step :content (?key)})
     (meander/$ {:tag :alter :content (?alteration)})
     (meander/$ {:tag :octave :content (?octave)})
     (meander/$ {:tag :duration :content (?duration)})
     (meander/$ {:tag :type :content (?type)}))

    {:tag :note
     :measure ?measure
     :voice ?voice
     :key ?key
     :alteration ?alteration
     :octave ?octave
     :duration ?duration
     :type ?type}

    (meander/and
     {:tag :note
      :attrs {:measure ?measure :voice ?voice}}
     (meander/$ {:tag :step :content (?key)})
     (meander/not (meander/$ {:tag :alter :content (?alteration)}))
     (meander/$ {:tag :octave :content (?octave)})
     (meander/$ {:tag :duration :content (?duration)})
     (meander/$ {:tag :type :content (?type)}))

    {:tag :note
     :measure ?measure
     :voice ?voice
     :key ?key
     :alteration 0
     :octave ?octave
     :duration ?duration
     :type ?type}))</pre>
but this feels wasteful and it&apos;s subject to combinatorial explosion, I was hoping in a smarter encoding</z><z id="t1680028380" t="Richie Can you do something like this? (m/rewrites &apos;{:note ({:pitch ({:step (&quot;D&quot;)} {:alter (&quot;-1&quot;)} {:octave (&quot;5&quot;)})} {:duration (&quot;1&quot;)} {:voice (&quot;1&quot;)} {:type (&quot;16th&quot;)} {:stem (&quot;down&quot;)} {:beam (&quot;continue&quot;)} {:beam (&quot;continue&quot;)})} (m/$ {:step (?key)}) {:key ?key} (m/$ {:alter (?alteration)}) {:alteration ?alteration} (m/$ {:octave (?octave)}) {:octave ?octave} (m/$ {:duration (?duration)}) {:duration ?duration} (m/$ {:type (?type)}) {:type ?type} (m/$ {:measure (?measure)}) {:measure ?measure} (m/$ {:voice (?voice)}) {:voice ?voice}) gives ({:key &quot;D&quot;} {:alteration &quot;-1&quot;} {:octave &quot;5&quot;} {:duration &quot;1&quot;} {:voice &quot;1&quot;} {:type &quot;16th&quot;}) "><y>#</y><d>2023-03-28</d><h>18:33</h><r>Richie</r>Can you do something like this?
<pre>(m/rewrites &apos;{:note ({:pitch ({:step (&quot;D&quot;)}
                             {:alter (&quot;-1&quot;)}
                             {:octave (&quot;5&quot;)})}
                    {:duration (&quot;1&quot;)}
                    {:voice (&quot;1&quot;)}
                    {:type (&quot;16th&quot;)}
                    {:stem (&quot;down&quot;)}
                    {:beam (&quot;continue&quot;)}
                    {:beam (&quot;continue&quot;)})}

            (m/$ {:step (?key)}) {:key ?key}
            (m/$ {:alter (?alteration)}) {:alteration ?alteration}
            (m/$ {:octave (?octave)}) {:octave ?octave}
            (m/$ {:duration (?duration)}) {:duration ?duration}
            (m/$ {:type (?type)}) {:type ?type}
            (m/$ {:measure (?measure)}) {:measure ?measure}
            (m/$ {:voice (?voice)}) {:voice ?voice})</pre>
gives
<pre>({:key &quot;D&quot;} {:alteration &quot;-1&quot;} {:octave &quot;5&quot;} {:duration &quot;1&quot;} {:voice &quot;1&quot;} {:type &quot;16th&quot;})</pre>
</z><z id="t1680028579" t="Richie Actually this. (-&gt;&gt; (m/rewrites &apos;{:tag :note, :attrs {:default-x &quot;148.88&quot;, :default-y &quot;-10.00&quot;, :dynamics &quot;71.11&quot;, :measure &quot;1&quot;, :voice &quot;P1&quot;}, :content ({:tag :pitch, :attrs {}, :content ({:tag :step, :attrs {}, :content (&quot;D&quot;)} {:tag :alter, :attrs {}, :content (&quot;-1&quot;)} {:tag :octave, :attrs {}, :content (&quot;5&quot;)})} {:tag :duration, :attrs {}, :content (&quot;1&quot;)} {:tag :voice, :attrs {}, :content (&quot;1&quot;)} {:tag :type, :attrs {}, :content (&quot;16th&quot;)} {:tag :stem, :attrs {}, :content (&quot;down&quot;)} {:tag :beam, :attrs {:number &quot;1&quot;}, :content (&quot;continue&quot;)} {:tag :beam, :attrs {:number &quot;2&quot;}, :content (&quot;continue&quot;)})} (m/$ {:tag :step :content (?key)}) {:key ?key} (m/$ {:tag :alter :content (?alteration)}) {:alteration ?alteration} (m/$ {:tag :octave :content (?octave)}) {:octave ?octave} (m/$ {:tag :duration :content (?duration)}) {:duration ?duration} (m/$ {:tag :type :content (?type)}) {:type ?type} (m/$ {:tag :note :attrs {:measure ?measure :voice ?voice}}) {:measure ?measure :voice ?voice}) (reduce into)) gives {:measure &quot;1&quot;, :voice &quot;P1&quot;, :key &quot;D&quot;, :alteration &quot;-1&quot;, :octave &quot;5&quot;, :duration &quot;1&quot;, :type &quot;16th&quot;}"><y>#</y><d>2023-03-28</d><h>18:36</h><r>Richie</r>Actually this.
<pre>(-&gt;&gt; (m/rewrites &apos;{:tag :note,
                  :attrs {:default-x &quot;148.88&quot;,
                          :default-y &quot;-10.00&quot;,
                          :dynamics &quot;71.11&quot;,
                          :measure &quot;1&quot;,
                          :voice &quot;P1&quot;},
                  :content ({:tag :pitch,
                             :attrs {},
                             :content ({:tag :step, :attrs {}, :content (&quot;D&quot;)}
                                       {:tag :alter, :attrs {}, :content (&quot;-1&quot;)}
                                       {:tag :octave, :attrs {}, :content (&quot;5&quot;)})}
                            {:tag :duration, :attrs {}, :content (&quot;1&quot;)}
                            {:tag :voice, :attrs {}, :content (&quot;1&quot;)}
                            {:tag :type, :attrs {}, :content (&quot;16th&quot;)}
                            {:tag :stem, :attrs {}, :content (&quot;down&quot;)}
                            {:tag :beam, :attrs {:number &quot;1&quot;}, :content (&quot;continue&quot;)}
                            {:tag :beam, :attrs {:number &quot;2&quot;}, :content (&quot;continue&quot;)})}

                (m/$ {:tag :step :content (?key)}) {:key ?key}
                (m/$ {:tag :alter :content (?alteration)}) {:alteration ?alteration}
                (m/$ {:tag :octave :content (?octave)}) {:octave ?octave}
                (m/$ {:tag :duration :content (?duration)}) {:duration ?duration}
                (m/$ {:tag :type :content (?type)}) {:type ?type}
                (m/$ {:tag :note :attrs {:measure ?measure :voice ?voice}}) {:measure ?measure :voice ?voice})
     (reduce into))</pre>
gives
<pre>{:measure &quot;1&quot;, :voice &quot;P1&quot;, :key &quot;D&quot;, :alteration &quot;-1&quot;, :octave &quot;5&quot;, :duration &quot;1&quot;, :type &quot;16th&quot;}</pre></z><z id="t1680028659" t="Richie Does that make sense?"><y>#</y><d>2023-03-28</d><h>18:37</h><r>Richie</r>Does that make sense?</z><z id="t1681782568" t="Richie [:attrs {:href &quot;/_/_/users/UA7E6DU04&quot;}] Did that help?"><y>#</y><d>2023-04-18</d><h>01:49</h><r>Richie</r><a>@UA7E6DU04</a> Did that help?</z><z id="t1677694860" t="Markus Hello y’all! I really like how rewrite works in meander, great job on your part and thanks for creating this piece of software! I am only experiencing a minor inconvenience with clj-kondo , which rightfully complains that all variables like ?a are undefined. How can I prevent this error, apart from muting clj-kondo ?"><y>#</y><d>2023-03-01</d><h>18:21</h><w>Markus</w>Hello y’all! I really like how <code>rewrite</code> works in meander, great job on your part and thanks for creating this piece of software! I am only experiencing a minor inconvenience with <code>clj-kondo</code>, which rightfully complains that all variables like <code>?a</code> are undefined. How can I prevent this error, apart from muting <code>clj-kondo</code>?</z><z id="t1677695532" t="borkdude You can maybe mute clj-kondo selectively only the meander macros"><y>#</y><d>2023-03-01</d><h>18:32</h><r>borkdude</r>You can maybe mute clj-kondo selectively only the meander macros</z><z id="t1677696559" t="Markus Ah ok, thanks anyways!"><y>#</y><d>2023-03-01</d><h>18:49</h><r>Markus</r>Ah ok, thanks anyways!</z></g><g id="s17"><z id="t1677696658" t="Markus I happen to have another question. When starting up the repl, I get a reflection warning for the field val in meander/util/epsilon.cljc:758:24 . What could cause this?"><y>#</y><d>2023-03-01</d><h>18:50</h><r>Markus</r>I happen to have another question. When starting up the repl, I get a reflection warning for the field <code>val</code> in <code>meander/util/epsilon.cljc:758:24</code>. What could cause this?</z><z id="t1677696692" t="borkdude It&apos;s probably better to ask this in the main channel. I only responded to your clj-kondo question because I happen to know stuff about clj-kondo"><y>#</y><d>2023-03-01</d><h>18:51</h><r>borkdude</r>It&apos;s probably better to ask this in the main channel. I only responded to your clj-kondo question because I happen to know stuff about clj-kondo</z><z id="t1677717557" t="Richie IIRC I get that too. "><y>#</y><d>2023-03-02</d><h>00:39</h><r>Richie</r>IIRC I get that too. </z><z id="t1677742259" t="Markus If more people have that issue, I will try to to minimize the problem and open an open issue on github if it persists"><y>#</y><d>2023-03-02</d><h>07:30</h><r>Markus</r>If more people have that issue, I will try to to minimize the problem and open an open issue on github if it persists</z><z id="t1677742509" t="borkdude What issue are you referring to now, kondo or reflection? "><y>#</y><d>2023-03-02</d><h>07:35</h><r>borkdude</r>What issue are you referring to now, kondo or reflection? </z><z id="t1677742546" t="Markus I&apos;m referring to the issue regarding reflection"><y>#</y><d>2023-03-02</d><h>07:35</h><r>Markus</r>I&apos;m referring to the issue regarding reflection</z><z id="t1677742622" t="borkdude Feel free to join #CHY97NXE2 for the kondo"><y>#</y><d>2023-03-02</d><h>07:37</h><r>borkdude</r>Feel free to join #CHY97NXE2 for the kondo</z><z id="t1677742662" t="Markus Thanks for the link!"><y>#</y><d>2023-03-02</d><h>07:37</h><r>Markus</r>Thanks for the link!</z><z id="t1678045483" t="noprompt [:attrs {:href &quot;/_/_/users/U04AAE72R5J&quot;}] I’m not sure about the reflection warning."><y>#</y><d>2023-03-05</d><h>19:44</h><r>noprompt</r><a>@U04AAE72R5J</a> I’m not sure about the reflection warning.</z><z id="t1678046938" t="noprompt Also, not to say something bad about clj-kondo, but I don’t use it myself because of issues with macros and I don’t have enough time in the day to learn all the knobs on the thing. [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] I’d probably use it more if 1) I knew how to tell it never to lint a macro it didn’t come with support for linting already, and 2) there were a UI/nice interface for configuring it. The serious bias toward configuration over convention in the Clojure space comes at the expense of end users — including long time users of Clojure like me — having to spend a lot of time trying to track down whether or not a tool has switch for the thing they want to do. Pitch: considering the abundance of data describing data formats out there pick one and use it to build a humane UI/interface for creating/manipulating them. A VS Code settings like interface would be awesome."><y>#</y><d>2023-03-05</d><h>20:08</h><r>noprompt</r>Also, not to say something bad about clj-kondo, but I don’t use it myself because of issues with macros and I don’t have enough time in the day to learn all the knobs on the thing.

<a>@U04V15CAJ</a> I’d probably use it more if 1) I knew how to tell it never to lint a macro it didn’t come with support for linting already, and 2) there were a UI/nice interface for configuring it.

The serious bias toward configuration over convention in the Clojure space comes at the expense of end users — including long time users of Clojure like me — having to spend a lot of time trying to track down whether or not a tool has switch for the thing they want to do.

Pitch: considering the abundance of data describing data formats out there pick one and use it to build a humane UI/interface for creating/manipulating them. A VS Code settings like interface would be awesome.</z><z id="t1678047068" t="noprompt Like, fuck, we have config for deps.edn , project.clj , CLJS, whatever shadow’s thing is because I forgot the name of it because CLJS dev is hell, config for Kondo, and the list goes on."><y>#</y><d>2023-03-05</d><h>20:11</h><r>noprompt</r>Like, fuck, we have config for <code>deps.edn</code>, <code>project.clj</code>, CLJS, whatever shadow’s thing is because I forgot the name of it because CLJS dev is hell, config for Kondo, and the list goes on.</z><z id="t1678047104" t="borkdude [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] There are ways to provide config for your library which you write only once and the rest of the world gets automatically when using your lib"><y>#</y><d>2023-03-05</d><h>20:11</h><r>borkdude</r><a>@U06MDAPTP</a> There are ways to provide config for your library which you write only once and the rest of the world gets automatically when using your lib</z><z id="t1678047106" t="noprompt I’m ranting a bit here but this is a reality for a lot of Clojure devs."><y>#</y><d>2023-03-05</d><h>20:11</h><r>noprompt</r>I’m ranting a bit here but this is a reality for a lot of Clojure devs.</z><z id="t1678047167" t="borkdude If anyone needs help with that, I&apos;m available in #CHY97NXE2. I&apos;m not here to sell clj-kondo."><y>#</y><d>2023-03-05</d><h>20:12</h><r>borkdude</r>If anyone needs help with that, I&apos;m available in #CHY97NXE2. I&apos;m not here to sell clj-kondo.</z><z id="t1678047191" t="noprompt Most of the time the reason I won’t use a thing is because I don’t have the time to spend hours trying to figure out how to configure it and we have no tools for configuration which is ironic considering how much I’ve heard about the mythical “tool maker” over the years and how “just data” is so liberating in that regard."><y>#</y><d>2023-03-05</d><h>20:13</h><r>noprompt</r>Most of the time the reason I won’t use a thing is because I don’t have the time to spend hours trying to figure out how to configure it and we have no tools for configuration which is ironic considering how much I’ve heard about the mythical “tool maker” over the years and how “just data” is so liberating in that regard.</z><z id="t1678047211" t="Markus Thanks for the information on this [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] ! Well, I’m not so sure what causes the reflection error either, but for now it’s just an annoying error that doesn’t really cause anything in my program. If you don’t have an idea what could be causing it, then I’ll just ignore it for now, since I can’t pinpoint the problem."><y>#</y><d>2023-03-05</d><h>20:13</h><r>Markus</r>Thanks for the information on this <a>@U06MDAPTP</a>! Well, I’m not so sure what causes the reflection error either, but for now it’s just an annoying error that doesn’t really cause anything in my program. If you don’t have an idea what could be causing it, then I’ll just ignore it for now, since I can’t pinpoint the problem.</z><z id="t1678047232" t="noprompt [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] I just want it not to lint any macros it doesn’t understand. Again, I would use it if I could just blanket tell it that."><y>#</y><d>2023-03-05</d><h>20:13</h><r>noprompt</r><a>@U04V15CAJ</a> I just want it not to lint any macros it doesn’t understand. Again, I would use it if I could just blanket tell it that.</z><z id="t1678047341" t="noprompt [:attrs {:href &quot;/_/_/users/U04AAE72R5J&quot;}] Yes, I’m sorry about that. I will look at this tomorrow."><y>#</y><d>2023-03-05</d><h>20:15</h><r>noprompt</r><a>@U04AAE72R5J</a> Yes, I’m sorry about that. I will look at this tomorrow.</z><z id="t1677696658" t="Markus I happen to have another question. When starting up the repl, I get a reflection warning for the field val in meander/util/epsilon.cljc:758:24 . What could cause this?"><y>#</y><d>2023-03-01</d><h>18:50</h><w>Markus</w>I happen to have another question. When starting up the repl, I get a reflection warning for the field <code>val</code> in <code>meander/util/epsilon.cljc:758:24</code>. What could cause this?</z><z id="t1678152531" t="David G Is the zeta branch a potential replacement of the main one? Or does it fulfill different goals/use cases than what epsilon does today?"><y>#</y><d>2023-03-07</d><h>01:28</h><w>David G</w>Is the <code>zeta</code> branch a potential replacement of the main one? Or does it fulfill different goals/use cases than what <code>epsilon</code> does today?</z><z id="t1678212608" t="noprompt Not quite. Its been a work in progress on and off for a couple years. I’ve been a bit quiet about it because I’ve been trying to pin down a specific set of ideas in the cleanest way possible. zeta has been parked for a bit because I got to a point where I realized I the axioms I was starting with were lacking. Since the last commit to that branch, I have spent more time experimenting, both in code and on paper, and have been working on a project that I hope I can build zeta on top of. One of the things that has been nagging me for years is that, up until recently, I didn’t have a set of small step interpretation rules for the underlying semantics of Meander. Those semantics belong to a language I have named “two” which is a non monotonic logic language. The main things I want zeta to have are • disjunction/conjunction on the RHS, • projection operator (being able to generate and query data without necessarily altering bindings, this is makes let work on both the LHS and the RHS), • mechanism for building new operators using only the rewriting language (but also with Clojure functions), • mechanism for defining new types of variables with rule systems (or Clojure functions) which define how to initialize a variable, update its state, and dispense values from it; • string pattern matching, • committed choice (`or` that picks the first solution), • a uniform interface for search DFS, BFS, DFF, etc. • any operator that exists on the LHS should have a cooperator on the RHS, • isolated, non-lexical scope. Currently, most of these things do exist on zeta but the implementation is unsatisfactory which I why I went back to the drawing board months ago. In December, I realized the underlying problem was that the language did not separate the flow control from the patterns. The patterns and , or , and let (`project`) are syntactic sugar; they can be decomposed. Once I separated these, I was able to shrink the size of the implementation. The controls maps cleanly to the logic monad and almost all of the pattern implementations that exist on zeta have been captured by two simple abstractions: a function for constructing data, a cofunction for generating a search space. Even better, I almost have a complete operational semantics for this language. That’s where I am. And, yeah, I’m sorry everyone that this is how things have been for the past couple years but this just the way it is. I don’t know who said it but it wouldn’t be called research if I knew what the hell I was doing. My goal for this project has always been to get to a practical language for manipulating data without functions using pattern matching and substitution. With AI getting better each year, I sort of believe that, eventually, the time I have invested in this endeavor will be of little value to anyone. Still, I want to finish what I started and get to the next plateau because, for me, I’m not sure if there will be another one."><y>#</y><d>2023-03-07</d><h>18:10</h><r>noprompt</r>Not quite. Its been a work in progress on and off for a couple years. I’ve been a bit quiet about it because I’ve been trying to pin down a specific set of ideas in the cleanest way possible. <code>zeta</code> has been parked for a bit because I got to a point where I realized I the axioms I was starting with were lacking.

Since the last commit to that branch, I have spent more time experimenting, both in code and on paper, and have been working on a project that I hope I can build <code>zeta</code> on top of.

One of the things that has been nagging me for years is that, up until recently, I didn’t have a set of small step interpretation rules for the underlying semantics of Meander. Those semantics belong to a language I have named “two” which is a non monotonic logic language.

The main things I want <code>zeta</code> to have are

• disjunction/conjunction on the RHS,
• projection operator (being able to generate and query data without necessarily altering bindings, this is makes <code>let</code> work on both the LHS and the RHS),
• mechanism for building new operators using only the rewriting language (but also with Clojure functions),
• mechanism for defining new types of variables with rule systems (or Clojure functions) which define how to initialize a variable, update its state, and dispense values from it;
• string pattern matching,
• committed choice (`or` that picks the first solution),
• a uniform interface for search DFS, BFS, DFF, etc.
• any operator that exists on the LHS should have a cooperator on the RHS,
• isolated, non-lexical scope.
Currently, most of these things do exist on <code>zeta</code> but the implementation is unsatisfactory which I why I went back to the drawing board months ago.

In December, I realized the underlying problem was that the language did not separate the flow control from the patterns. The patterns <code>and</code>, <code>or</code>, and <code>let</code> (`project`) are syntactic sugar; they can be decomposed. Once I separated these, I was able to shrink the size of the implementation.

The controls maps cleanly to the logic monad and almost all of the pattern implementations that exist on <code>zeta</code> have been captured by two simple abstractions: a function for constructing data, a cofunction for generating a search space. Even better, I almost have a complete operational semantics for this language.

That’s where I am.

And, yeah, I’m sorry everyone that this is how things have been for the past couple years but this just the way it is. I don’t know who said it but it wouldn’t be called research if I knew what the hell I was doing. My goal for this project has always been to get to a practical language for manipulating data without functions using pattern matching and substitution. With AI getting better each year, I sort of believe that, eventually, the time I have invested in this endeavor will be of little value to anyone. Still, I want to finish what I started and get to the next plateau because, for me, I’m not sure if there will be another one.</z><z id="t1678212953" t="markaddleman &gt; it wouldn’t be called research if I knew what the hell I was doing :rolling_on_the_floor_laughing:"><y>#</y><d>2023-03-07</d><h>18:15</h><r>markaddleman</r>&gt;  it wouldn’t be called research if I knew what the hell I was doing
<b>:rolling_on_the_floor_laughing:</b></z><z id="t1678212991" t="markaddleman It’s a testimony to the usefulness of meander that epsilon has such staying power."><y>#</y><d>2023-03-07</d><h>18:16</h><r>markaddleman</r>It’s a testimony to the usefulness of meander that epsilon has such staying power.</z><z id="t1678214065" t="markaddleman &gt; With AI getting better each year, I sort of believe that, eventually, the time I have invested in this endeavor will be of little value to anyone. Still, I want to finish what I started and get to the next plateau because, for me, I’m not sure if there will be another one. Here, I think I completely disagree with you. I believe that AI is going to need simple languages that both humans and AI can understand. I have yet to see any serious (read revenue generating) AI project where a human doesn’t ask, “how did it arrive at that answer?”"><y>#</y><d>2023-03-07</d><h>18:34</h><r>markaddleman</r>&gt;  With AI getting better each year, I sort of believe that, eventually, the time I have invested in this endeavor will be of little value to anyone. Still, I want to finish what I started and get to the next plateau because, for me, I’m not sure if there will be another one.
Here, I think I completely disagree with you.  I believe that AI is going to need simple languages that both humans and AI can understand.  I have yet to see any serious (read revenue generating) AI project where a human doesn’t ask, “how did it arrive at that answer?”</z><z id="t1678214194" t="Ben Sless This is exploration, not research And I doubt AI will ever be able to fill that niche"><y>#</y><d>2023-03-07</d><h>18:36</h><r>Ben Sless</r>This is exploration, not research
And I doubt AI will ever be able to fill that niche</z><z id="t1678217393" t="respatialized &gt; I need to discuss science vs. engineering. Put glibly: In science if you know what you are doing you should not be doing it. in engineering if you do not know what you are doing you should not be doing it. &gt; Richard Hamming, The Art of Doing Science and Engineering [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] I think this is the reference you&apos;re looking for"><y>#</y><d>2023-03-07</d><h>19:29</h><r>respatialized</r>&gt; I need to discuss science vs. engineering. Put glibly: In science if you know what you are doing you should not be doing it. in engineering if you do not know what you are doing you should not be doing it.
&gt; 
Richard Hamming, The Art of Doing Science and Engineering 

<a>@U06MDAPTP</a> I think this is the reference you&apos;re looking for</z><z id="t1678217688" t="respatialized And personally speaking, I&apos;d much rather have a pattern matching/rewriting language with precise denotational semantics that I can apply in a compositional way than a chatbot I recite incantations to until it &quot;looks right&quot; when processing some data"><y>#</y><d>2023-03-07</d><h>19:34</h><r>respatialized</r>And personally speaking, I&apos;d much rather have a pattern matching/rewriting language with precise denotational semantics that I can apply in a compositional way than a chatbot I recite incantations to until it &quot;looks right&quot; when processing some data</z><z id="t1678217780" t="respatialized compositionality is exactly where LLMs fail the hardest (because they&apos;re not built for it), so focusing on it is likely to yield benefits for some time to come"><y>#</y><d>2023-03-07</d><h>19:36</h><r>respatialized</r>compositionality is exactly where LLMs fail the hardest (because they&apos;re not built for it), so focusing on it is likely to yield benefits for some time to come</z><z id="t1678222858" t="noprompt [:attrs {:href &quot;/_/_/users/UFTRLDZEW&quot;}] Denotational semantics is not my strong suit but I think going from operational to denotational should probably be straight forward. I’d probably want to look at the denotational semantics for Prolog and borrow from that since the operational definition I have for Two is very similar to the operational definition of mini-Prolog."><y>#</y><d>2023-03-07</d><h>21:00</h><r>noprompt</r><a>@UFTRLDZEW</a> Denotational semantics is not my strong suit but I think going from operational to denotational should probably be straight forward. I’d probably want to look at the denotational semantics for Prolog and borrow from that since the operational definition I have for Two is very similar to the operational definition of mini-Prolog.</z><z id="t1678223428" t="noprompt What I am slightly stuck on is the function/cofunction algebra. There’s overlap with Hopf algebras and Groupoids but this is not quite it that because the function maps a tuple to a value (though it could be a singleton set) and the cofunction maps a value to a set of tuples. So set union is (s, s) -&gt; s and the counion is s -&gt; { (s1, s2) | s1 ⊆ s, s2 ⊆ s, s1 ⊎ s2 } So there’s a kind of symmetry here but I’m not exactly sure where to plug it in."><y>#</y><d>2023-03-07</d><h>21:10</h><r>noprompt</r>What I am slightly stuck on is the function/cofunction algebra. There’s overlap with Hopf algebras and Groupoids but this is not quite it that because the function maps a tuple to a value (though it could be a singleton set) and the cofunction maps a value to a set of tuples. So set union is
<pre>(s, s) -&gt; s </pre>
and the counion is
<pre>s -&gt; { (s1, s2) | s1 ⊆ s, s2 ⊆ s, s1 ⊎ s2 }</pre>
So there’s a kind of symmetry here but I’m not exactly sure where to plug it in.</z><z id="t1678223497" t="noprompt Calling this a “counion” doesn’t feel right because its not a “co” kinda thing as commonly seen. But I don’t know what else to call it."><y>#</y><d>2023-03-07</d><h>21:11</h><r>noprompt</r>Calling this a “counion” doesn’t feel right because its not a “co” kinda thing as commonly seen. But I don’t know what else to call it.</z><z id="t1678254166" t="Ben Sless What if you map a tuple to a set with one member? Does this sort of symmetry help?"><y>#</y><d>2023-03-08</d><h>05:42</h><r>Ben Sless</r>What if you map a tuple to a set with one member? Does this sort of symmetry help?</z><z id="t1678294263" t="noprompt [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] Yeah, something like that. This is in Coalgebra territory. You have some function (called “multiplication”) (a, a) -&gt; a and another function (call “comultiplication”) a -&gt; (a, a) So, for example, if the multiplication is integer product, the comultiplication would be the coproduct, or integer factor pair. If change the definitions to use a functor F F (a, a) -&gt; F a F a -&gt; F (a, a) then, yeah, I think this works out better. If F is a list and (a, a) are arguments, when I fmap the multiplication operation I get F a , a list of products. If I think fmap the comultiplication operation I would get F (a, a) , the list of factor pairs."><y>#</y><d>2023-03-08</d><h>16:51</h><r>noprompt</r><a>@UK0810AQ2</a> Yeah, something like that. This is in Coalgebra territory. You have some function (called “multiplication”)
<pre>(a, a) -&gt; a</pre>
and another function (call “comultiplication”)
<pre>a -&gt; (a, a)</pre>
So, for example, if the multiplication is integer product, the comultiplication would be the coproduct, or integer factor pair. If change the definitions to use a functor <code>F</code>
<pre>F (a, a) -&gt; F a
F a -&gt; F (a, a)</pre>
then, yeah, I think this works out better. If <code>F</code> is a list and <code>(a, a)</code> are arguments, when I <code>fmap</code> the multiplication operation I get <code>F a</code> , a list of products. If I think <code>fmap</code> the comultiplication operation I would get <code>F (a, a)</code> , the list of factor pairs.</z><z id="t1678294438" t="Ben Sless"><y>#</y><d>2023-03-08</d><h>16:53</h><r>Ben Sless</r></z><z id="t1678294573" t="Ben Sless (I&apos;m kidding, it all makes sense I just have to read it slowly and carefully)"><y>#</y><d>2023-03-08</d><h>16:56</h><r>Ben Sless</r>(I&apos;m kidding, it all makes sense I just have to read it slowly and carefully)</z><z id="t1678295168" t="noprompt [:attrs {:href &quot;/_/_/users/UK0810AQ2&quot;}] Here’s an example using into . ;; F (a, a) -&gt; a (fmap into [[1] [2]]) ;; =&gt; [[1 2]] ;; F a -&gt; F (a, a) (cointo [[1 2]]) ;; =&gt; [[[] [1 2]], [[1] [2]], [[1 2] []]] In practice, I just use into without the functor, so just the (a, a) -&gt; a and same for the cointo , a -&gt; F (a, a) ."><y>#</y><d>2023-03-08</d><h>17:06</h><r>noprompt</r><a>@UK0810AQ2</a> Here’s an example using <code>into</code>.
<pre>;; F (a, a) -&gt; a
(fmap into [[1] [2]])
;; =&gt; [[1 2]]

;; F a -&gt; F (a, a)
(cointo [[1 2]])
;; =&gt; [[[] [1 2]], [[1] [2]], [[1 2] []]]</pre>
In practice, I just use <code>into</code> without the functor, so just the <code>(a, a) -&gt; a</code> and same for the <code>cointo</code>, <code>a -&gt; F (a, a)</code>.</z><z id="t1678295324" t="noprompt So cointo just gives you all of the ways to construct the vector [1 2] via the arguments [] [1 2] , [1] [2] , etc."><y>#</y><d>2023-03-08</d><h>17:08</h><r>noprompt</r>So <code>cointo</code> just gives you all of the ways to construct the vector <code>[1 2]</code> via the arguments <code>[] [1 2]</code>, <code>[1] [2]</code>, etc.</z><z id="t1678295651" t="noprompt The idea can be extended to other data types as well and for operations that take more than two arguments. So assoc could be all the ways to construct a map via assoc provided the map has at least one entry. This represents the pattern (assoc ?m ?k ?v) But suppose I know the value and have (assoc ?m ?k &quot;bar&quot;) then I can also imagine a coassoc-v function which returns a sequence of possible ?m and ?k pairs that associate ?k with the value &quot;bar&quot; in the map ?m ."><y>#</y><d>2023-03-08</d><h>17:14</h><r>noprompt</r>The idea can be extended to other data types as well and for operations that take more than two arguments. So <code>assoc</code> could be all the ways to construct a map via <code>assoc</code> provided the map has at least one entry. This represents the pattern
<pre>(assoc ?m ?k ?v)</pre>
But suppose I know the value and have
<pre>(assoc ?m ?k &quot;bar&quot;)</pre>
then I can also imagine a <code>coassoc-v</code> function which returns a sequence of possible <code>?m</code> and <code>?k</code> pairs that associate <code>?k</code> with the value <code>&quot;bar&quot;</code> in the map <code>?m</code>.</z><z id="t1678295698" t="noprompt If &quot;bar&quot; does not exist as a value in the map ?m , then the sequence is empty."><y>#</y><d>2023-03-08</d><h>17:14</h><r>noprompt</r>If <code>&quot;bar&quot;</code> does not exist as a value in the map <code>?m</code>, then the sequence is empty.</z><z id="t1678687749" t="em Random comment from a long time lurker but just wanted to mention that one of the qualities I admire the most in any project leader is the ability (and resolve) to take a step back and reevaluate fundamental choices, despite sunk costs, for the sake of simplicity and better alignment with the real goals in mind. Meander is very cool, but the journey even more so. Good luck to wherever you&apos;re heading, and know that everything so far has been very helpful to many!"><y>#</y><d>2023-03-13</d><h>06:09</h><r>em</r>Random comment from a long time lurker but just wanted to mention that one of the qualities I admire the most in any project leader is the ability (and resolve) to take a step back and reevaluate fundamental choices, despite sunk costs, for the sake of simplicity and better alignment with the real goals in mind. Meander is very cool, but the journey even more so. Good luck to wherever you&apos;re heading, and know that everything so far has been very helpful to many!</z><z id="t1678212608" t="noprompt Not quite. Its been a work in progress on and off for a couple years. I’ve been a bit quiet about it because I’ve been trying to pin down a specific set of ideas in the cleanest way possible. zeta has been parked for a bit because I got to a point where I realized I the axioms I was starting with were lacking. Since the last commit to that branch, I have spent more time experimenting, both in code and on paper, and have been working on a project that I hope I can build zeta on top of. One of the things that has been nagging me for years is that, up until recently, I didn’t have a set of small step interpretation rules for the underlying semantics of Meander. Those semantics belong to a language I have named “two” which is a non monotonic logic language. The main things I want zeta to have are • disjunction/conjunction on the RHS, • projection operator (being able to generate and query data without necessarily altering bindings, this is makes let work on both the LHS and the RHS), • mechanism for building new operators using only the rewriting language (but also with Clojure functions), • mechanism for defining new types of variables with rule systems (or Clojure functions) which define how to initialize a variable, update its state, and dispense values from it; • string pattern matching, • committed choice (`or` that picks the first solution), • a uniform interface for search DFS, BFS, DFF, etc. • any operator that exists on the LHS should have a cooperator on the RHS, • isolated, non-lexical scope. Currently, most of these things do exist on zeta but the implementation is unsatisfactory which I why I went back to the drawing board months ago. In December, I realized the underlying problem was that the language did not separate the flow control from the patterns. The patterns and , or , and let (`project`) are syntactic sugar; they can be decomposed. Once I separated these, I was able to shrink the size of the implementation. The controls maps cleanly to the logic monad and almost all of the pattern implementations that exist on zeta have been captured by two simple abstractions: a function for constructing data, a cofunction for generating a search space. Even better, I almost have a complete operational semantics for this language. That’s where I am. And, yeah, I’m sorry everyone that this is how things have been for the past couple years but this just the way it is. I don’t know who said it but it wouldn’t be called research if I knew what the hell I was doing. My goal for this project has always been to get to a practical language for manipulating data without functions using pattern matching and substitution. With AI getting better each year, I sort of believe that, eventually, the time I have invested in this endeavor will be of little value to anyone. Still, I want to finish what I started and get to the next plateau because, for me, I’m not sure if there will be another one."><y>#</y><d>2023-03-07</d><h>18:10</h><w>noprompt</w>Not quite. Its been a work in progress on and off for a couple years. I’ve been a bit quiet about it because I’ve been trying to pin down a specific set of ideas in the cleanest way possible. <code>zeta</code> has been parked for a bit because I got to a point where I realized I the axioms I was starting with were lacking.

Since the last commit to that branch, I have spent more time experimenting, both in code and on paper, and have been working on a project that I hope I can build <code>zeta</code> on top of.

One of the things that has been nagging me for years is that, up until recently, I didn’t have a set of small step interpretation rules for the underlying semantics of Meander. Those semantics belong to a language I have named “two” which is a non monotonic logic language.

The main things I want <code>zeta</code> to have are

• disjunction/conjunction on the RHS,
• projection operator (being able to generate and query data without necessarily altering bindings, this is makes <code>let</code> work on both the LHS and the RHS),
• mechanism for building new operators using only the rewriting language (but also with Clojure functions),
• mechanism for defining new types of variables with rule systems (or Clojure functions) which define how to initialize a variable, update its state, and dispense values from it;
• string pattern matching,
• committed choice (`or` that picks the first solution),
• a uniform interface for search DFS, BFS, DFF, etc.
• any operator that exists on the LHS should have a cooperator on the RHS,
• isolated, non-lexical scope.
Currently, most of these things do exist on <code>zeta</code> but the implementation is unsatisfactory which I why I went back to the drawing board months ago.

In December, I realized the underlying problem was that the language did not separate the flow control from the patterns. The patterns <code>and</code>, <code>or</code>, and <code>let</code> (`project`) are syntactic sugar; they can be decomposed. Once I separated these, I was able to shrink the size of the implementation.

The controls maps cleanly to the logic monad and almost all of the pattern implementations that exist on <code>zeta</code> have been captured by two simple abstractions: a function for constructing data, a cofunction for generating a search space. Even better, I almost have a complete operational semantics for this language.

That’s where I am.

And, yeah, I’m sorry everyone that this is how things have been for the past couple years but this just the way it is. I don’t know who said it but it wouldn’t be called research if I knew what the hell I was doing. My goal for this project has always been to get to a practical language for manipulating data without functions using pattern matching and substitution. With AI getting better each year, I sort of believe that, eventually, the time I have invested in this endeavor will be of little value to anyone. Still, I want to finish what I started and get to the next plateau because, for me, I’m not sure if there will be another one.</z><z id="t1678687749" t="em Random comment from a long time lurker but just wanted to mention that one of the qualities I admire the most in any project leader is the ability (and resolve) to take a step back and reevaluate fundamental choices, despite sunk costs, for the sake of simplicity and better alignment with the real goals in mind. Meander is very cool, but the journey even more so. Good luck to wherever you&apos;re heading, and know that everything so far has been very helpful to many!"><y>#</y><d>2023-03-13</d><h>06:09</h><w>em</w>Random comment from a long time lurker but just wanted to mention that one of the qualities I admire the most in any project leader is the ability (and resolve) to take a step back and reevaluate fundamental choices, despite sunk costs, for the sake of simplicity and better alignment with the real goals in mind. Meander is very cool, but the journey even more so. Good luck to wherever you&apos;re heading, and know that everything so far has been very helpful to many!</z><z id="t1681908316" t="ribelo I am trying to get back to meander after almost two and I do not understand my own code 🙃"><y>#</y><d>2023-04-19</d><h>12:45</h><w>ribelo</w>I am trying to get back to meander after almost two and I do not understand my own code <b>🙃</b></z><z id="t1681908363" t="ribelo Can someone remind me if values can be skipped?"><y>#</y><d>2023-04-19</d><h>12:46</h><w>ribelo</w>Can someone remind me if values can be skipped?</z><z id="t1681908428" t="ribelo simplest example, let&apos;s say, I wouldn&apos;t want that nil (me/rewrite [{:a 1} {:b 2}] {:b ?v} ?v [?x &amp; ?more] [(me/cata ?x) &amp; (me/cata ?more)] ?x ?x) ;; =&gt; [nil 2]"><y>#</y><d>2023-04-19</d><h>12:47</h><w>ribelo</w>simplest example, let&apos;s say, I wouldn&apos;t want that <code>nil</code>
<pre>(me/rewrite [{:a 1} {:b 2}]
  {:b ?v} ?v
  [?x &amp; ?more] [(me/cata ?x) &amp; (me/cata ?more)]
  ?x ?x)
;; =&gt; [nil 2]</pre></z><z id="t1681908532" t="ribelo I know I can filter it with one more cata , but I&apos;m trying to recall if there is an easier way"><y>#</y><d>2023-04-19</d><h>12:48</h><w>ribelo</w>I know I can filter it with one more <code>cata</code>, but I&apos;m trying to recall if there is an easier way</z><z id="t1681916939" t="Ben Sless Wrap the v in a some?"><y>#</y><d>2023-04-19</d><h>15:08</h><r>Ben Sless</r>Wrap the <code>v</code> in a some?</z><z id="t1681935792" t="ribelo Of course, it doesn&apos;t work because the pattern needs something to match"><y>#</y><d>2023-04-19</d><h>20:23</h><r>ribelo</r>Of course, it doesn&apos;t work because the pattern needs something to match</z><z id="t1681935811" t="ribelo (me/rewrite [{:a 1} {:b 2}] {:b (me/some ?v)} ?v [?x &amp; ?more] [(me/cata ?x) &amp; (me/cata ?more)] ) ;; =&gt; nil"><y>#</y><d>2023-04-19</d><h>20:23</h><r>ribelo</r><pre>(me/rewrite [{:a 1} {:b 2}]
  {:b (me/some ?v)} ?v
  [?x &amp; ?more] [(me/cata ?x) &amp; (me/cata ?more)]
  )
;; =&gt; nil</pre></z><z id="t1681935842" t="ribelo (me/rewrite [{:a 1} {:b 2}] {:b (me/some ?v)} ?v [?x &amp; ?more] [(me/cata ?x) &amp; (me/cata ?more)] ?x ?x) ;; =&gt; [{:a 1} 2]"><y>#</y><d>2023-04-19</d><h>20:24</h><r>ribelo</r><pre>(me/rewrite [{:a 1} {:b 2}]
  {:b (me/some ?v)} ?v
  [?x &amp; ?more] [(me/cata ?x) &amp; (me/cata ?more)]
  ?x ?x)
;; =&gt; [{:a 1} 2]</pre></z><z id="t1681935908" t="ribelo I am where I was before, but instead of nil I have the entire map 🙂"><y>#</y><d>2023-04-19</d><h>20:25</h><r>ribelo</r>I am where I was before, but instead of nil I have the entire map <b>🙂</b></z><z id="t1681946188" t="noprompt [:attrs {:href &quot;/_/_/users/U0BBFDED7&quot;}] What were you after in this case?"><y>#</y><d>2023-04-19</d><h>23:16</h><r>noprompt</r><a>@U0BBFDED7</a> What were you after in this case?</z><z id="t1681946266" t="ribelo nice to see you again [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}]"><y>#</y><d>2023-04-19</d><h>23:17</h><r>ribelo</r>nice to see you again <a>@U06MDAPTP</a></z><z id="t1681946268" t="ribelo 🙂"><y>#</y><d>2023-04-19</d><h>23:17</h><r>ribelo</r><b>🙂</b></z><z id="t1681946650" t="noprompt 🙂"><y>#</y><d>2023-04-19</d><h>23:24</h><r>noprompt</r><b>🙂</b></z><z id="t1681947185" t="ribelo i already managed this, I rediscovered m/$"><y>#</y><d>2023-04-19</d><h>23:33</h><r>ribelo</r>i already managed this, I rediscovered <code>m/$</code></z><z id="t1683144592" t="timothypratley Just a heads up that I showed quite a few Meander examples off at Conj: https://youtu.be/32aiLfLwDzc?t=1386 --- Meander made the Kalai transpiler much more pleasant to work on, so big thank you to [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] and [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] for making it!"><y>#</y><d>2023-05-03</d><h>20:09</h><w>timothypratley</w>Just a heads up that I showed quite a few Meander examples off at Conj: <a href="https://youtu.be/32aiLfLwDzc?t=1386" target="_blank">https://youtu.be/32aiLfLwDzc?t=1386</a> --- Meander made the Kalai transpiler much more pleasant to work on, so big thank you to <a>@noprompt</a> and <a>@jimmy</a> for making it!</z><z id="t1683144812" t="Jimmy Miller Definitely excited to watch! All credit goes to [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] He let me give a talk about it. But it was all his work and ideas. "><y>#</y><d>2023-05-03</d><h>20:13</h><r>Jimmy Miller</r>Definitely excited to watch! All credit goes to <a>@noprompt</a> He let me give a talk about it. But it was all his work and ideas. </z><z id="t1683144812" t="Jimmy Miller Definitely excited to watch! All credit goes to [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] He let me give a talk about it. But it was all his work and ideas. "><y>#</y><d>2023-05-03</d><h>20:13</h><w>Jimmy Miller</w>Definitely excited to watch! All credit goes to <a>@noprompt</a> He let me give a talk about it. But it was all his work and ideas. </z><z id="t1684227013" t="igrishaev Can anyone help me with meander? Imagine I want the first form to become the second:"><y>#</y><d>2023-05-16</d><h>08:50</h><w>igrishaev</w>Can anyone help me with meander? Imagine I want the first form to become the second:</z><z id="t1684227071" t="igrishaev {:tags [{:name &quot;AAA&quot;} {:name &quot;BBB&quot;}]} -&gt; {:tags [&quot;AAA&quot; &quot;BBB&quot;]} here is what I have in my code: (matcher {:pattern &apos;{:tags [{:name ?tag} ...]} :expression &apos;{:tags [!tags]}}) But sometimes, I&apos;m getting an exception saying &quot;Non-exhaustive pattern match&quot; or something"><y>#</y><d>2023-05-16</d><h>08:51</h><w>igrishaev</w><pre>{:tags [{:name &quot;AAA&quot;} {:name &quot;BBB&quot;}]}
-&gt;
{:tags [&quot;AAA&quot; &quot;BBB&quot;]}</pre>
here is what I have in my code:
<pre>(matcher
 {:pattern    &apos;{:tags [{:name ?tag} ...]}
  :expression &apos;{:tags [!tags]}})</pre>
But sometimes, I&apos;m getting an exception saying &quot;Non-exhaustive pattern match&quot; or something</z><z id="t1684227368" t="igrishaev Let me correct myself: :tags [{:name !tags} ...] :tags !tags Sometimes, it leads to =&gt; ExceptionInfo: non exhaustive pattern match {}"><y>#</y><d>2023-05-16</d><h>08:56</h><w>igrishaev</w>Let me correct myself:

<pre>:tags  [{:name !tags} ...]
:tags  !tags</pre>
Sometimes, it leads to =&gt; ExceptionInfo: non exhaustive pattern match {}</z><z id="t1684227896" t="igrishaev turned out, the exception pops up when the tags field is missing or nil. How can I correct the pattern so the nil tags produce either nil or an empty vector?"><y>#</y><d>2023-05-16</d><h>09:04</h><w>igrishaev</w>turned out, the exception pops up when the tags field is missing or nil. How can I correct the pattern so the nil tags produce either nil or an empty vector?</z><z id="t1684228200" t="igrishaev phew, it should have been (m/or nil [{:name !tags} ...])"><y>#</y><d>2023-05-16</d><h>09:10</h><w>igrishaev</w>phew, it should have been <code>(m/or nil [{:name !tags} ...])</code></z><z id="t1684341246" t="noprompt [:attrs {:href &quot;/_/_/users/U1WAUKQ3E&quot;}] If you&apos;re using the interpreter namespace, you may want to consider using finder instead of matcher . It finds the first solution and doesn&apos;t complain about ambiguity or non-exhaustive matches."><y>#</y><d>2023-05-17</d><h>16:34</h><w>noprompt</w><a>@igrishaev</a> If you&apos;re using the interpreter namespace, you may want to consider using <code>finder</code> instead of <code>matcher</code>. It finds the first solution and doesn&apos;t complain about ambiguity or non-exhaustive matches.</z><z id="t1684398621" t="igrishaev yep, I&apos;ll take a look. I was editing someone else&apos;s code, not mine. A person declared a matcher and passed it into a map function."><y>#</y><d>2023-05-18</d><h>08:30</h><r>igrishaev</r>yep, I&apos;ll take a look. I was editing someone else&apos;s code, not mine. A person declared a matcher and passed it into a map function.</z><z id="t1685560070" t="zane The https://cljdoc.org/d/meander/epsilon/0.0.650 in the README appears to be broken?"><y>#</y><d>2023-05-31</d><h>19:07</h><w>zane</w>The <a href="https://cljdoc.org/d/meander/epsilon/0.0.650" target="_blank">https://cljdoc.org/d/meander/epsilon/0.0.650</a> in the <code>README</code> appears to be broken?</z><z id="t1685627921" t="lread Hey [:attrs {:href &quot;/_/_/users/U050CT4HR&quot;}] , I&apos;ll take a peek and see what problem cljdoc is having here."><y>#</y><d>2023-06-01</d><h>13:58</h><r>lread</r>Hey <a>@zane</a>, I&apos;ll take a peek and see what problem cljdoc is having here.</z><z id="t1685628249" t="lread The https://repo.clojars.org/meander/epsilon/0.0.650/epsilon-0.0.650.pom does not point back to meander sources on GitHub. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;&quot; xmlns:xsi=&quot;&quot; xsi:schemaLocation=&quot; &quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;groupId&gt;meander&lt;/groupId&gt; &lt;artifactId&gt;epsilon&lt;/artifactId&gt; &lt;version&gt;0.0.650&lt;/version&gt; &lt;name&gt;epsilon&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.clojure&lt;/groupId&gt; &lt;artifactId&gt;clojure&lt;/artifactId&gt; &lt;version&gt;1.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;sourceDirectory&gt;src&lt;/sourceDirectory&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;clojars&lt;/id&gt; &lt;url&gt;&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/project&gt;"><y>#</y><d>2023-06-01</d><h>14:04</h><r>lread</r>The <a href="https://repo.clojars.org/meander/epsilon/0.0.650/epsilon-0.0.650.pom" target="_blank">https://repo.clojars.org/meander/epsilon/0.0.650/epsilon-0.0.650.pom</a> does not point back to meander sources on GitHub.
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;&quot; xmlns:xsi=&quot;&quot; xsi:schemaLocation=&quot; &quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;groupId&gt;meander&lt;/groupId&gt;
  &lt;artifactId&gt;epsilon&lt;/artifactId&gt;
  &lt;version&gt;0.0.650&lt;/version&gt;
  &lt;name&gt;epsilon&lt;/name&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.clojure&lt;/groupId&gt;
      &lt;artifactId&gt;clojure&lt;/artifactId&gt;
      &lt;version&gt;1.10.3&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;sourceDirectory&gt;src&lt;/sourceDirectory&gt;
  &lt;/build&gt;
  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;clojars&lt;/id&gt;
      &lt;url&gt;&lt;/url&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;
&lt;/project&gt;</pre></z><z id="t1685628559" t="lread Cljdoc https://github.com/cljdoc/cljdoc/blob/master/doc/userguide/for-library-authors.adoc#git-sources `&lt;scm&gt;` https://github.com/cljdoc/cljdoc/blob/master/doc/userguide/for-library-authors.adoc#git-sources . Older versions of meander published to clojars do have some &lt;scm&gt; info so, the build process probably changed. And meander does have a doc/cljdoc.edn to there has been historical interest in cljdoc."><y>#</y><d>2023-06-01</d><h>14:09</h><r>lread</r>Cljdoc <a href="https://github.com/cljdoc/cljdoc/blob/master/doc/userguide/for-library-authors.adoc#git-sources" target="_blank">https://github.com/cljdoc/cljdoc/blob/master/doc/userguide/for-library-authors.adoc#git-sources</a>`&lt;scm&gt;`<a href="https://github.com/cljdoc/cljdoc/blob/master/doc/userguide/for-library-authors.adoc#git-sources" target="_blank">https://github.com/cljdoc/cljdoc/blob/master/doc/userguide/for-library-authors.adoc#git-sources</a>.
Older versions of meander published to clojars do have some <code>&lt;scm&gt;</code> info so, the build process probably changed.
And meander does have a <code>doc/cljdoc.edn</code> to there has been historical interest in cljdoc.</z><z id="t1685628683" t="zane Er, rather the link isn’t broken, but the page it takes you to is."><y>#</y><d>2023-06-01</d><h>14:11</h><r>zane</r>Er, rather the link isn’t broken, but the page it takes you to is.</z><z id="t1685628695" t="zane Thanks for looking into it, [:attrs {:href &quot;/_/_/users/UE21H2HHD&quot;}] !"><y>#</y><d>2023-06-01</d><h>14:11</h><r>zane</r>Thanks for looking into it, <a>@UE21H2HHD</a>!</z><z id="t1685629405" t="lread Oh [:attrs {:href &quot;/_/_/users/U050CT4HR&quot;}] , I think I maybe misunderstood, I thought you were noting that the articles did not import on cljdoc, and that&apos;s what I looked into. simple_smile"><y>#</y><d>2023-06-01</d><h>14:23</h><r>lread</r>Oh <a>@zane</a>, I think I maybe misunderstood, I thought you were noting that the articles did not import on cljdoc, and that&apos;s what I looked into. <b>simple_smile</b></z><z id="t1685629445" t="zane That is what I noticed! Sorry for the confusion. "><y>#</y><d>2023-06-01</d><h>14:24</h><r>zane</r>That is what I noticed! Sorry for the confusion. </z><z id="t1685629454" t="lread Oh good. Same page then!"><y>#</y><d>2023-06-01</d><h>14:24</h><r>lread</r>Oh good. Same page then!</z><z id="t1685629491" t="zane I was just trying to clarify what was probably already clear from the screenshot: That the link successfully takes you to a webpage, but that the webpage has problems. "><y>#</y><d>2023-06-01</d><h>14:24</h><r>zane</r>I was just trying to clarify what was probably already clear from the screenshot: That the link successfully takes you to a webpage, but that the webpage has problems. </z><z id="t1685629520" t="lread Should we raise an issue on meander repo?"><y>#</y><d>2023-06-01</d><h>14:25</h><r>lread</r>Should we raise an issue on meander repo?</z><z id="t1685629545" t="zane Sounds good!"><y>#</y><d>2023-06-01</d><h>14:25</h><r>zane</r>Sounds good!</z><z id="t1685629757" t="lread Oh https://github.com/noprompt/meander/issues/236 , I&apos;ll add some details."><y>#</y><d>2023-06-01</d><h>14:29</h><r>lread</r>Oh <a href="https://github.com/noprompt/meander/issues/236" target="_blank">https://github.com/noprompt/meander/issues/236</a>, I&apos;ll add some details.</z><z id="t1685630983" t="lread [:attrs {:href &quot;/_/_/users/U050CT4HR&quot;}] , I added the r https://github.com/noprompt/meander/issues/236#issuecomment-1572194270 ."><y>#</y><d>2023-06-01</d><h>14:49</h><r>lread</r><a>@zane</a>, I added the r<a href="https://github.com/noprompt/meander/issues/236#issuecomment-1572194270" target="_blank">https://github.com/noprompt/meander/issues/236#issuecomment-1572194270</a>.</z><z id="t1685565932" t="cch1 I’m struggling with meander’s documentation for what (to me) seems to be a simple transformation. I want to transform nested repeated content along with the containing content. I can’t figure it out. Here’s an example: {:a [{:b 1 :x 12} {:b 2 :y 13}]} needs to become: {:A [{:B 1 :x 12} {:B 2 :y 13}]} It’s the changes to the N contained maps that confounds me. I can do it with a “manual” mapping of meander/match over the value at the :a key, but that seems to break the promise of meander’s declarative approach. Thanks in advance, and my apologies if I’ve missed something in the docs. Memory variables seem like a crucial ingredient, but I can’t see a way to “unify” the elements of each map “positionally” in the output expression to preserve the arity of the input value."><y>#</y><d>2023-05-31</d><h>20:45</h><w>cch1</w>I’m struggling with meander’s documentation for what (to me) seems to be a simple transformation.  I want to transform nested repeated content along with the containing content.  I can’t figure it out.  Here’s an example:
<pre>{:a [{:b 1 :x 12} {:b 2 :y 13}]}</pre>
needs to become:
<pre>{:A [{:B 1 :x 12} {:B 2 :y 13}]}</pre>
It’s the changes to the N contained maps that confounds me.  I can do it with a “manual” mapping of <code>meander/match</code> over the value at the <code>:a</code> key, but that seems to break the promise of meander’s declarative approach.

Thanks in advance, and my apologies if I’ve missed something in the docs.   Memory variables seem like a crucial ingredient, but I can’t see a way to “unify” the elements of each map “positionally” in the output expression to preserve the arity of the input value.</z><z id="t1685625765" t="Richie You want to rewrite everything in the top level and also everything one level down? I might just thread through two rewrites."><y>#</y><d>2023-06-01</d><h>13:22</h><r>Richie</r>You want to rewrite everything in the top level and also everything one level down? I might just thread through two rewrites.</z><z id="t1685631405" t="cch1 Yes, that’s correct. Can you explain what you mean by “thread through two rewrites?” The cleanest method I can come up with involves mapping over the repeated key’s value with a secondary meander/match call. But that just seems wrong. Here’s the rough shape: (meander/match input {:a [!nested ...]} {:A (mapv #(meander/match % {:b ?b :x ?x :y ?y} {:B ?b :x ?x :y ?y}))) (the :x and :y keys are not particularly relevant to this problem and their nil values in the result doesn’t match exactly the example I gave above -ignore it)"><y>#</y><d>2023-06-01</d><h>14:56</h><r>cch1</r>Yes, that’s correct.  Can you explain what you mean by “thread through two rewrites?”  The cleanest method I can come up with involves mapping over the repeated key’s value with a secondary <code>meander/match</code> call.  But that just seems wrong.  Here’s the rough shape:
<pre>(meander/match input
	       {:a [!nested ...]}
	       {:A (mapv #(meander/match %
					 {:b ?b :x ?x :y ?y}
					 {:B ?b :x ?x :y ?y})))</pre>
(the <code>:x</code> and <code>:y</code> keys are not particularly relevant to this problem and their nil values in the result doesn’t match exactly the example I gave above -ignore it)</z><z id="t1685631985" t="Richie Hmm. What I had in mind didn&apos;t work when I actually tried to write code. I was thinking thread-first -&gt; through m/rewrite for :a to :A and then again m/rewrite to turn {:A [{:b ... into {:A [{:B ..."><y>#</y><d>2023-06-01</d><h>15:06</h><r>Richie</r>Hmm. What I had in mind didn&apos;t work when I actually tried to write code. I was thinking thread-first <code>-&gt;</code> through <code>m/rewrite</code> for <code>:a</code> to <code>:A</code> and then again <code>m/rewrite</code> to turn <code>{:A [{:b ...</code> into <code>{:A [{:B ...</code></z><z id="t1685632299" t="Richie This probably isn&apos;t what you want but I still don&apos;t understand what you want. (m/rewrite {:a [{:b 1 :x 3} {:b 2 :y 4}]} {:a [!a ...] &amp; ?rest} {:A [(m/cata !a) ...] &amp; ?rest} {:b ?b &amp; ?rest} {:B ?b &amp; ?rest})"><y>#</y><d>2023-06-01</d><h>15:11</h><r>Richie</r>This probably isn&apos;t what you want but I still don&apos;t understand what you want.
<pre>(m/rewrite {:a [{:b 1 :x 3}
                {:b 2 :y 4}]}
  {:a [!a ...] &amp; ?rest}
  {:A [(m/cata !a) ...] &amp; ?rest}
  {:b ?b &amp; ?rest}
  {:B ?b &amp; ?rest})</pre></z><z id="t1685632301" t="Richie gives {:A [{:x 3, :B 1} {:y 4, :B 2}]}"><y>#</y><d>2023-06-01</d><h>15:11</h><r>Richie</r>gives <code>{:A [{:x 3, :B 1} {:y 4, :B 2}]}</code></z><z id="t1685632368" t="Richie m/cata recurses on each thing. If there&apos;s another :a there then it&apos;ll get matched. that&apos;s probably not what you want."><y>#</y><d>2023-06-01</d><h>15:12</h><r>Richie</r><code>m/cata</code> recurses on each thing. If there&apos;s another <code>:a</code> there then it&apos;ll get matched. that&apos;s probably not what you want.</z><z id="t1685632440" t="Jimmy Miller Is this the kind of thing you are looking for? (def input {:a [{:b 1 :x 12} {:b 2 :y 13}]}) (m/rewrite input {:a [{:b !bs &amp; !xs} ...]} {:A [{:B !bs &amp; !xs} ...]}) ;; =&gt; ;; {:A [{:x 12, :B 1} {:y 13, :B 2}]}"><y>#</y><d>2023-06-01</d><h>15:14</h><r>Jimmy Miller</r>Is this the kind of thing you are looking for?

<pre>(def input {:a [{:b 1 :x 12} {:b 2 :y 13}]})

(m/rewrite input
  {:a [{:b !bs &amp; !xs} ...]}
  {:A [{:B !bs &amp; !xs} ...]})

;; =&gt;
;; {:A [{:x 12, :B 1} {:y 13, :B 2}]}</pre></z><z id="t1685634874" t="cch1 In words, I want to transform a map containing a sequence of maps at some key. I see how to transform a map with a sequence at some key, but if the sequence is composed of maps then I see no way to modify the child maps without a second invocation of meander. It seems weird that nested data structures can’t be “described” sufficiently to allow this. Again, here is the shape of the input: {:a [{:b 1} {:b 2}]} The desired output requires transformation of the outer map and the inner maps. So something like this: {:A [{:B 1} {:B 2}]} The keys at each level are arbitrary and could be duplicated such that nesting context would be essential, but my data doesn’t have that twist."><y>#</y><d>2023-06-01</d><h>15:54</h><r>cch1</r>In words, I want to transform a map containing a sequence of maps at some key.  I see how to transform a map with a sequence at some key, but if the sequence is composed of maps then I see no way to modify the child maps without a second invocation of meander.  It seems weird that nested data structures can’t be “described” sufficiently to allow this.   Again, here is the shape of the input:
<pre>{:a [{:b 1} {:b 2}]}</pre>
The desired output requires transformation of the outer map and the inner maps.  So something like this:
<pre>{:A [{:B 1} {:B 2}]}</pre>
The keys at each level are arbitrary and could be duplicated such that nesting context would be essential, but my data doesn’t have that twist.</z><z id="t1685634976" t="cch1 [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] , I need to study your solution -it looks very close to what I need."><y>#</y><d>2023-06-01</d><h>15:56</h><r>cch1</r><a>@U5K8NTHEZ</a>, I need to study your solution -it looks very close to what I need.</z><z id="t1685635257" t="cch1 Unfortunately, I think the problem with that solution is that it treats the subsequence as a memorization (= memory variable) and AFAICT there is no means to correlate memory variables. A slightly extended example shows how that approach will come up short: {:a [{:b 1 :c 3} {:b 2 :c 4}]} the desired output requires that the inner maps remain correlated entities: {:A [{:B 1 :C 2} {:B 2 :C 4}]} "><y>#</y><d>2023-06-01</d><h>16:00</h><r>cch1</r>Unfortunately, I think the problem with that solution is that it treats the subsequence as a memorization (= memory variable) and AFAICT there is no means to correlate memory variables.  A slightly extended example shows how that approach will come up short:
<pre>{:a [{:b 1 :c 3} {:b 2 :c 4}]}</pre>
the desired output requires that the inner maps remain correlated entities:
<pre>{:A [{:B 1 :C 2} {:B 2 :C 4}]}</pre>
</z><z id="t1685635418" t="cch1 With memory variables, I don’t think it is possible to retain the correlation of 1 and 3 in the first inner map (and similarly for 2 and 4 in the second inner map). My expectations might be unreasonable: I was expecting equivalent transformation power on nested repeated data as on the top-level data. Perhaps invoking meander twice is the best option."><y>#</y><d>2023-06-01</d><h>16:03</h><r>cch1</r>With memory variables, I don’t think it is possible to retain the correlation of <code>1</code> and <code>3</code> in the first inner map (and similarly for <code>2</code> and <code>4</code> in the second inner map).

My expectations might be unreasonable: I was expecting equivalent transformation power on nested repeated data as on the top-level data.  Perhaps invoking meander twice is the best option.</z><z id="t1685639722" t="Richie (m/rewrite {:a [{:b 1 :c 3} {:b 2 :c 4}]} {:a [{:b !b :c !c &amp; !xs} ..!n] &amp; ?rest} {:A [{:B !b :C !c &amp; !xs} ..!n] &amp; ?rest}) ;; {:A [{:B 1, :C 3} {:B 2, :C 4}]} "><y>#</y><d>2023-06-01</d><h>17:15</h><r>Richie</r><pre>(m/rewrite {:a [{:b 1 :c 3} {:b 2 :c 4}]}
  {:a [{:b !b :c !c &amp; !xs} ..!n] &amp; ?rest}
  {:A [{:B !b :C !c &amp; !xs} ..!n] &amp; ?rest})
;; {:A [{:B 1, :C 3} {:B 2, :C 4}]}</pre>
</z><z id="t1685639765" t="Jimmy Miller I&apos;m confused on the output. {:b 1 :c 3} ;; turns into {:B 1 :C 2} Was that a typo?"><y>#</y><d>2023-06-01</d><h>17:16</h><r>Jimmy Miller</r>I&apos;m confused on the output.

<pre>{:b 1 :c 3}
;; turns into 
{:B 1 :C 2}</pre>
Was that a typo?</z><z id="t1685639842" t="Jimmy Miller Assuming it is a typo (m/rewrite input {:a [{:b !bs :c !cs &amp; !xs} ...]} {:A [{:B !bs :C !cs &amp; !xs} ...]}) Seems to work on that input"><y>#</y><d>2023-06-01</d><h>17:17</h><r>Jimmy Miller</r>Assuming it is a typo
<pre>(m/rewrite input
  {:a [{:b !bs :c !cs &amp; !xs} ...]}
  {:A [{:B !bs :C !cs &amp; !xs} ...]})</pre>
Seems to work on that input</z><z id="t1685640289" t="cch1 Yep, it was a typo."><y>#</y><d>2023-06-01</d><h>17:24</h><r>cch1</r>Yep, it was a typo.</z><z id="t1685640340" t="Jimmy Miller So yeah. That seems to work. There are ways to correlate memory variables more specifically but I don’t see the need for that here. So I must be missing something. "><y>#</y><d>2023-06-01</d><h>17:25</h><r>Jimmy Miller</r>So yeah. That seems to work. There are ways to correlate memory variables more specifically but I don’t see the need for that here. So I must be missing something. </z><z id="t1685640350" t="cch1 So that ^ shows that the memory variables are being “consumed” in parallel and maintain the correlation of the map entities."><y>#</y><d>2023-06-01</d><h>17:25</h><r>cch1</r>So that ^ shows that the memory variables are being “consumed” in parallel and maintain the correlation of the map entities.</z><z id="t1685640358" t="cch1 Nice."><y>#</y><d>2023-06-01</d><h>17:25</h><r>cch1</r>Nice.</z><z id="t1685640365" t="cch1 Not at all obvious, but nice."><y>#</y><d>2023-06-01</d><h>17:26</h><r>cch1</r>Not at all obvious, but nice.</z><z id="t1685640459" t="Jimmy Miller Yeah you can do some fancier things with different repeat operators. But in general they do one value for each repeat. So for the same length things they should be fine. "><y>#</y><d>2023-06-01</d><h>17:27</h><r>Jimmy Miller</r>Yeah you can do some fancier things with different repeat operators. But in general they do one value for each repeat. So for the same length things they should be fine. </z><z id="t1686066495" t="cch1 [:attrs {:href &quot;/_/_/users/U5K8NTHEZ&quot;}] and [:attrs {:href &quot;/_/_/users/UPD88PGNT&quot;}] , thanks for your help with this. I’ve got additional requirement that I fear may break the solutions you have proposed… I need each of the subordinate output maps to include the index of the subordinate input maps. So using [:attrs {:href &quot;/_/_/users/UPD88PGNT&quot;}] ’s example from above: (m/rewrite {:a [{:b 1 :c 3} {:b 2 :c 4}]} {:a [{:b !b :c !c &amp; !xs} ..!n] &amp; ?rest} {:A [{:B !b :C !c &amp; !xs} ..!n] &amp; ?rest}) ;; {:A [{:B 1, :C 3 :index 1} {:B 2, :C 4 :index 2}]} Note the addition of the :index key in the desired output. Is this possible? Similarly to how the keys and vals functions in Clojure core commit to returning the keys and values in the same order, I’m wondering if your collective opinion is that the “correlation” of the memory variables is intentional (by the authors of meander) or if it is “luck” -I’m hesitant to invest a lot in this approach without some confidence that it is intentional."><y>#</y><d>2023-06-06</d><h>15:48</h><r>cch1</r><a>@U5K8NTHEZ</a> and <a>@UPD88PGNT</a>, thanks for your help with this.  I’ve got additional requirement that I fear may break the solutions you have proposed… I need each of the subordinate output maps to include the index of the subordinate input maps.  So using <a>@UPD88PGNT</a>’s example from above:

<pre>(m/rewrite {:a [{:b 1 :c 3} {:b 2 :c 4}]}
  {:a [{:b !b :c !c &amp; !xs} ..!n] &amp; ?rest}
  {:A [{:B !b :C !c &amp; !xs} ..!n] &amp; ?rest})
;; {:A [{:B 1, :C 3 :index 1} {:B 2, :C 4 :index 2}]}</pre>
Note the addition of the <code>:index</code> key in the desired output.  Is this possible?

Similarly to how the <code>keys</code> and <code>vals</code> functions in Clojure core commit to returning the keys and values in the same order, I’m wondering if your collective opinion is that the “correlation” of the memory variables is intentional (by the authors of meander) or if it is “luck” -I’m hesitant to invest a lot in this approach without some confidence that it is intentional.</z><z id="t1686067593" t="Jimmy Miller Not at my computer. I’ll have to think about index. But I can confirm for sure that the “correlation” isn’t accidental. The way memory variables work is just conceptually push and pop into a vector. "><y>#</y><d>2023-06-06</d><h>16:06</h><r>Jimmy Miller</r>Not at my computer. I’ll have to think about index. But I can confirm for sure that the “correlation” isn’t accidental. The way memory variables work is just conceptually push and pop into a vector. </z><z id="t1686088257" t="Jimmy Miller For index, I am sure there is some other way. But this was what I first came up with for doing it. (m/rewrite {:a (map-indexed vector [{:b 1 :c 3} {:b 2 :c 4}])} {:a ([!index {:b !b :c !c &amp; !xs}] ...) &amp; ?rest} {:A [{:B !b :C !c :index (m/app inc !index) &amp; !xs} ...] &amp; ?rest}) Maybe not the most elegant approach ever. But as far as I know we don&apos;t have any way to get the index of where you are in a vector. Maybe some cata magic? But personally, I think it is totally fine to do some preprocessing. So ultimately, I&apos;d just do something like defn add-index [coll] (into [] (map-indexed (fn [i x] (assoc x :index (inc i)))) coll)) (m/rewrite {:a (add-index [{:b 1 :c 3} {:b 2 :c 4}])} {:a [{:b !b :c !c &amp; !xs} ...] &amp; ?rest} {:A [{:B !b :C !c &amp; !xs} ...] &amp; ?rest})"><y>#</y><d>2023-06-06</d><h>21:50</h><r>Jimmy Miller</r>For index, I am sure there is some other way. But this was what I first came up with for doing it.

<pre>(m/rewrite {:a (map-indexed vector [{:b 1 :c 3} {:b 2 :c 4}])}
  {:a ([!index {:b !b :c !c &amp; !xs}] ...) &amp; ?rest}
  {:A [{:B !b :C !c :index (m/app inc !index) &amp; !xs} ...] &amp; ?rest})</pre>
Maybe not the most elegant approach ever. But as far as I know we don&apos;t have any way to get the index of where you are in a vector. Maybe some cata magic? But personally, I think it is totally fine to do some preprocessing. So ultimately, I&apos;d just do something like

<pre>defn add-index [coll]
  (into []
        (map-indexed
         (fn [i x]
           (assoc x :index (inc i))))
        coll))


(m/rewrite {:a (add-index [{:b 1 :c 3} {:b 2 :c 4}])}
  {:a [{:b !b :c !c &amp; !xs} ...] &amp; ?rest}
  {:A [{:B !b :C !c &amp; !xs} ...] &amp; ?rest})</pre></z><z id="t1686092787" t="cch1 THanks. I agree: some pre- and post- processing to add content is OK."><y>#</y><d>2023-06-06</d><h>23:06</h><r>cch1</r>THanks.  I agree: some pre- and post- processing to add content is OK.</z><z id="t1685630983" t="lread [:attrs {:href &quot;/_/_/users/U050CT4HR&quot;}] , I added the r https://github.com/noprompt/meander/issues/236#issuecomment-1572194270 ."><y>#</y><d>2023-06-01</d><h>14:49</h><w>lread</w><a>@zane</a>, I added the r<a href="https://github.com/noprompt/meander/issues/236#issuecomment-1572194270" target="_blank">https://github.com/noprompt/meander/issues/236#issuecomment-1572194270</a>.</z><z id="t1686889614" t="noprompt Instruction: Using the meander library in Clojure, demonstrate how to extract all of the values of the keys :x and :y from a sequence of maps. Output: To extract all of the values of the keys :x and :y from a sequence of maps using the meander library in Clojure, we can use the following code: clojure (require &apos;[meander.epsilon :as m]) (defn extract-xy [maps] (m/search [:x :y] maps)) This function takes a sequence of maps as input and returns a sequence of all of the values of the keys :x and :y in those maps. The search function from the meander library is used to match the pattern [:x :y] against each map in the sequence. The result of the search is a sequence of all of the values of the keys :x and :y in the sequence of maps."><y>#</y><d>2023-06-16</d><h>04:26</h><w>noprompt</w>Instruction: Using the meander library in Clojure, demonstrate how to extract all of the values of the keys :x and :y from a sequence of maps.

Output: To extract all of the values of the keys :x and :y from a sequence of maps using the meander library in Clojure, we can use the following code:

<pre>clojure
(require &apos;[meander.epsilon :as m])

(defn extract-xy [maps]
  (m/search [:x :y] maps))
</pre>

This function takes a sequence of maps as input and returns a sequence of all of the values of the keys :x and :y in those maps. The <code>search</code> function from the meander library is used to match the pattern <code>[:x :y]</code> against each map in the sequence. The result of the search is a sequence of all of the values of the keys :x and :y in the sequence of maps.</z><z id="t1686889621" t="noprompt Gotta give it credit for trying."><y>#</y><d>2023-06-16</d><h>04:27</h><w>noprompt</w>Gotta give it credit for trying.</z><z id="t1686889628" t="noprompt https://huggingface.co/WizardLM/WizardCoder-15B-V1.0"><y>#</y><d>2023-06-16</d><h>04:27</h><w>noprompt</w><a href="https://huggingface.co/WizardLM/WizardCoder-15B-V1.0" target="_blank">https://huggingface.co/WizardLM/WizardCoder-15B-V1.0</a></z><z id="t1686889666" t="noprompt ☝️ In all seriousness, this model isn&apos;t half bad at generating code."><y>#</y><d>2023-06-16</d><h>04:27</h><w>noprompt</w><b>☝️</b> In all seriousness, this model isn&apos;t half bad at generating code.</z><z id="t1686890299" t="noprompt It actually managed to cough up an almost working LC interpreter."><y>#</y><d>2023-06-16</d><h>04:38</h><r>noprompt</r>It actually managed to cough up an almost working LC interpreter.</z><z id="t1686889677" t="noprompt Just not Clojure code LOL"><y>#</y><d>2023-06-16</d><h>04:27</h><w>noprompt</w>Just not Clojure code LOL</z><z id="t1688579594" t="Pranav Ram Hello, is there a way to transform this structure: {:name &quot;Interest&quot;, :id &quot;Interest&quot;, :db/ident &quot;Interest&quot;, :type &quot;Label&quot;, :has-element+ [{:name &quot;Credit Interest Parameters&quot;, :id &quot;Credit Interest Parameters&quot;, :db/ident &quot;Credit Interest Parameters&quot;, :type &quot;Label&quot;, :has-element+ [{:dataType &quot;LOV&quot;, :name &quot;Balance Base&quot;, :allowedValues [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;], :id &quot;f73cbbbf-8220-46b5-b88c-31d244468a76&quot;, :db/ident &quot;f73cbbbf-8220-46b5-b88c-31d244468a76&quot;]} Into a list like so: [ [:id &quot;Interest&quot; :has-element+ {:id &quot;Credit Interest Parameters &amp; rest-of-map-except-has-element+}] [:id &quot;Credit Interest Parameters&quot; :has-element+ {:id &quot;f73...&quot; &amp; rest-of-map-except-has-element+}] [....] .... ] I&apos;m trying to use m/rewrite like so to keep accumulating every 2 levels but clearly I don&apos;t have a good grasp over the operators (m/rewrite input {:db/ident !t :has-element+ [(m/cata !t) ...] &amp; ?rest-map} [!t :has-element+ !t])"><y>#</y><d>2023-07-05</d><h>17:53</h><w>Pranav Ram</w>Hello, is there a way to transform this structure:

<pre>{:name &quot;Interest&quot;,
 :id &quot;Interest&quot;,
 :db/ident &quot;Interest&quot;,
 :type &quot;Label&quot;,
 :has-element+
 [{:name &quot;Credit Interest Parameters&quot;,
   :id &quot;Credit Interest Parameters&quot;,
   :db/ident &quot;Credit Interest Parameters&quot;,
   :type &quot;Label&quot;,
   :has-element+
   [{:dataType &quot;LOV&quot;,
     :name &quot;Balance Base&quot;,
     :allowedValues [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;],
     :id &quot;f73cbbbf-8220-46b5-b88c-31d244468a76&quot;,
     :db/ident &quot;f73cbbbf-8220-46b5-b88c-31d244468a76&quot;]}</pre>
Into a list like so:

<pre>[
  [:id &quot;Interest&quot; :has-element+ {:id &quot;Credit Interest Parameters &amp; rest-of-map-except-has-element+}]
  [:id &quot;Credit Interest Parameters&quot; :has-element+ {:id &quot;f73...&quot; &amp; rest-of-map-except-has-element+}]
  [....]
  ....
]</pre>
I&apos;m trying to use m/rewrite like so to keep accumulating every 2 levels but clearly I don&apos;t have a good grasp over the operators

<pre>(m/rewrite input
 {:db/ident !t :has-element+ [(m/cata !t) ...] &amp; ?rest-map}
 [!t :has-element+ !t])</pre></z><z id="t1688848556" t="noprompt [:attrs {:href &quot;/_/_/users/U05EF6LHTRR&quot;}] I think this should do the trick. (m/rewrite input {:id ?id :has-element+ (m/scan ?nested-element)} [[:id ?id :has-element+ ?nested-element] ;; Recursively rewrite the nested element &amp; (m/cata ?nested-element)] _ ;; Default case, empty vector. []) "><y>#</y><d>2023-07-08</d><h>20:35</h><w>noprompt</w><a>@pranav.ram7</a> I think this should do the trick.
<pre>(m/rewrite input
  {:id ?id
   :has-element+ (m/scan ?nested-element)}
  [[:id ?id :has-element+ ?nested-element]
   ;; Recursively rewrite the nested element 
   &amp; (m/cata ?nested-element)]

  _ ;; Default case, empty vector.
  [])</pre>
</z><z id="t1688965215" t="Pranav Ram [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] Fantastic, this worked great. Thank you for the help and library!"><y>#</y><d>2023-07-10</d><h>05:00</h><r>Pranav Ram</r><a>@U06MDAPTP</a> Fantastic, this worked great. Thank you for the help and library!</z><z id="t1688981490" t="Pranav Ram Follow up - is there a way to spread the has-element+ s into their own items? so if a parent has multiple has-element+ items, they get their own entry in relation to the parent. Also try and remove the nested has-element+ from the RHS for each pair"><y>#</y><d>2023-07-10</d><h>09:31</h><r>Pranav Ram</r>Follow up - is there a way to spread the has-element+ s into their own items? so if a parent has multiple has-element+ items, they get their own entry in relation to the parent. Also try and remove the nested has-element+ from the RHS for each pair</z><z id="t1689020073" t="noprompt Example?"><y>#</y><d>2023-07-10</d><h>20:14</h><r>noprompt</r>Example?</z><z id="t1689052713" t="Pranav Ram So for something like so: {:name &quot;Interest&quot;, :id &quot;Interest&quot;, :db/ident &quot;Interest&quot;, :type &quot;Label&quot;, :has-element [{:name &quot;Credit Interest Parameters&quot;, :id &quot;Credit Interest Parameters&quot;, :db/ident &quot;Credit Interest Parameters&quot;, :type &quot;Label&quot;, :has-element [{:mandatory true, :path [&quot;Interest&quot; &quot;Credit Interest Parameters&quot; &quot;Balance Base&quot;], :name &quot;Balance Base&quot;, :apiName nil, :fixedAllowedValues nil, :json-schema {:type &quot;object&quot;, :properties {:value {:enum [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]}}, :required [&quot;value&quot;]}, :size nil, :dataType &quot;LOV&quot;, :id &quot;93b778a4-99cd-4839-95e6-90a965d61e06&quot;, :db/ident &quot;93b778a4-99cd-4839-95e6-90a965d61e06&quot;, :path-string &quot;Interest|Credit Interest Parameters|Balance Base&quot;, :allowedValues [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]} {:mandatory true, :path [&quot;Interest&quot; &quot;Credit Interest Parameters&quot; &quot;Balance Base 2&quot;], :name &quot;Balance Base 2&quot;, :apiName nil, :fixedAllowedValues nil, :json-schema {:type &quot;object&quot;, :properties {:value {:enum [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]}}, :required [&quot;value&quot;]}, :size nil, :dataType &quot;LOV&quot;, :id &quot;7591f44f-da3a-464f-bd3a-d0773f319aa3&quot;, :db/ident &quot;7591f44f-da3a-464f-bd3a-d0773f319aa3&quot;, :path-string &quot;Interest|Credit Interest Parameters|Balance Base 2&quot;, :allowedValues [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]}], :path [&quot;Interest&quot; &quot;Credit Interest Parameters&quot;], :path-string &quot;Interest|Credit Interest Parameters&quot;} {:name &quot;Debit Interest Parameters&quot;, :id &quot;Debit Interest Parameters&quot;, :db/ident &quot;Debit Interest Parameters&quot;, :type &quot;Label&quot;, :has-element [{:mandatory true, :path [&quot;Interest&quot; &quot;Debit Interest Parameters&quot; &quot;Balance Base&quot;], :name &quot;Balance Base&quot;, :apiName nil, :fixedAllowedValues nil, :json-schema {:type &quot;object&quot;, :properties {:value {:enum [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]}}, :required [&quot;value&quot;]}, :size nil, :dataType &quot;LOV&quot;, :id &quot;9c414ea9-1080-41fc-9b54-51faebd3fac7&quot;, :db/ident &quot;9c414ea9-1080-41fc-9b54-51faebd3fac7&quot;, :path-string &quot;Interest|Debit Interest Parameters|Balance Base&quot;, :allowedValues [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]} {:mandatory true, :path [&quot;Interest&quot; &quot;Debit Interest Parameters&quot; &quot;Balance Base 2&quot;], :name &quot;Balance Base 2&quot;, :apiName nil, :fixedAllowedValues nil, :json-schema {:type &quot;object&quot;, :properties {:value {:enum [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]}}, :required [&quot;value&quot;]}, :size nil, :dataType &quot;LOV&quot;, :id &quot;ec66690b-00b6-402c-b943-962e0d7127a3&quot;, :db/ident &quot;ec66690b-00b6-402c-b943-962e0d7127a3&quot;, :path-string &quot;Interest|Debit Interest Parameters|Balance Base 2&quot;, :allowedValues [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]}], :path [&quot;Interest&quot; &quot;Debit Interest Parameters&quot;], :path-string &quot;Interest|Debit Interest Parameters&quot;}], :path [&quot;Interest&quot;], :path-string &quot;Interest&quot;} It should output: [ {:id &quot;Interest&quot; :has-element {:id &quot;Credit Interest Parameters&quot; &amp; rest-map-except-nested-has-element}} {:id &quot;Credit Interest Parameters&quot; :has-element {:id &quot;Balance Base&quot; &amp; rest-map-except-nested-has-element}} {:id &quot;Credit Interest Parameters&quot; :has-element {:id &quot;Balance Base 2&quot; &amp; rest-map-except-nested-has-element}} {:id &quot;Interest&quot; :has-element {:id &quot;Debit Interest Parameters&quot; &amp; rest-map-except-nested-has-element}} {:id &quot;Debit Interest Parameters&quot; :has-element {:id &quot;Balance Base&quot; &amp; rest-map-except-nested-has-element}} {:id &quot;Debit Interest Parameters&quot; :has-element {:id &quot;Balance Base 2&quot; &amp; rest-map-except-nested-has-element}} ] Note that the above tree structure could have any depth with the key :has-element and it should flatten the structure in terms of every 2 nodes (parent :has-element child)"><y>#</y><d>2023-07-11</d><h>05:18</h><r>Pranav Ram</r>So for something like so:

<pre>{:name &quot;Interest&quot;,
 :id &quot;Interest&quot;,
 :db/ident &quot;Interest&quot;,
 :type &quot;Label&quot;,
 :has-element
 [{:name &quot;Credit Interest Parameters&quot;,
   :id &quot;Credit Interest Parameters&quot;,
   :db/ident &quot;Credit Interest Parameters&quot;,
   :type &quot;Label&quot;,
   :has-element
   [{:mandatory true,
     :path [&quot;Interest&quot; &quot;Credit Interest Parameters&quot; &quot;Balance Base&quot;],
     :name &quot;Balance Base&quot;,
     :apiName nil,
     :fixedAllowedValues nil,
     :json-schema
     {:type &quot;object&quot;, :properties {:value {:enum [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]}}, :required [&quot;value&quot;]},
     :size nil,
     :dataType &quot;LOV&quot;,
     :id &quot;93b778a4-99cd-4839-95e6-90a965d61e06&quot;,
     :db/ident &quot;93b778a4-99cd-4839-95e6-90a965d61e06&quot;,
     :path-string &quot;Interest|Credit Interest Parameters|Balance Base&quot;,
     :allowedValues [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]}
    {:mandatory true,
     :path [&quot;Interest&quot; &quot;Credit Interest Parameters&quot; &quot;Balance Base 2&quot;],
     :name &quot;Balance Base 2&quot;,
     :apiName nil,
     :fixedAllowedValues nil,
     :json-schema
     {:type &quot;object&quot;, :properties {:value {:enum [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]}}, :required [&quot;value&quot;]},
     :size nil,
     :dataType &quot;LOV&quot;,
     :id &quot;7591f44f-da3a-464f-bd3a-d0773f319aa3&quot;,
     :db/ident &quot;7591f44f-da3a-464f-bd3a-d0773f319aa3&quot;,
     :path-string &quot;Interest|Credit Interest Parameters|Balance Base 2&quot;,
     :allowedValues [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]}],
   :path [&quot;Interest&quot; &quot;Credit Interest Parameters&quot;],
   :path-string &quot;Interest|Credit Interest Parameters&quot;}
  {:name &quot;Debit Interest Parameters&quot;,
   :id &quot;Debit Interest Parameters&quot;,
   :db/ident &quot;Debit Interest Parameters&quot;,
   :type &quot;Label&quot;,
   :has-element
   [{:mandatory true,
     :path [&quot;Interest&quot; &quot;Debit Interest Parameters&quot; &quot;Balance Base&quot;],
     :name &quot;Balance Base&quot;,
     :apiName nil,
     :fixedAllowedValues nil,
     :json-schema
     {:type &quot;object&quot;, :properties {:value {:enum [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]}}, :required [&quot;value&quot;]},
     :size nil,
     :dataType &quot;LOV&quot;,
     :id &quot;9c414ea9-1080-41fc-9b54-51faebd3fac7&quot;,
     :db/ident &quot;9c414ea9-1080-41fc-9b54-51faebd3fac7&quot;,
     :path-string &quot;Interest|Debit Interest Parameters|Balance Base&quot;,
     :allowedValues [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]}
    {:mandatory true,
     :path [&quot;Interest&quot; &quot;Debit Interest Parameters&quot; &quot;Balance Base 2&quot;],
     :name &quot;Balance Base 2&quot;,
     :apiName nil,
     :fixedAllowedValues nil,
     :json-schema
     {:type &quot;object&quot;, :properties {:value {:enum [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]}}, :required [&quot;value&quot;]},
     :size nil,
     :dataType &quot;LOV&quot;,
     :id &quot;ec66690b-00b6-402c-b943-962e0d7127a3&quot;,
     :db/ident &quot;ec66690b-00b6-402c-b943-962e0d7127a3&quot;,
     :path-string &quot;Interest|Debit Interest Parameters|Balance Base 2&quot;,
     :allowedValues [&quot;Daily Balance&quot; &quot;Average Daily Balance&quot;]}],
   :path [&quot;Interest&quot; &quot;Debit Interest Parameters&quot;],
   :path-string &quot;Interest|Debit Interest Parameters&quot;}],
 :path [&quot;Interest&quot;],
 :path-string &quot;Interest&quot;}</pre>
It should output:

<pre>[
{:id &quot;Interest&quot; :has-element {:id &quot;Credit Interest Parameters&quot; &amp; rest-map-except-nested-has-element}}
{:id &quot;Credit Interest Parameters&quot; :has-element {:id &quot;Balance Base&quot; &amp; rest-map-except-nested-has-element}}
{:id &quot;Credit Interest Parameters&quot; :has-element {:id &quot;Balance Base 2&quot; &amp; rest-map-except-nested-has-element}}
{:id &quot;Interest&quot; :has-element {:id &quot;Debit Interest Parameters&quot; &amp; rest-map-except-nested-has-element}}
{:id &quot;Debit Interest Parameters&quot; :has-element {:id &quot;Balance Base&quot; &amp; rest-map-except-nested-has-element}}
{:id &quot;Debit Interest Parameters&quot; :has-element {:id &quot;Balance Base 2&quot; &amp; rest-map-except-nested-has-element}}
]</pre>
Note that the above tree structure could have any depth with the key :has-element and it should flatten the structure in terms of every 2 nodes (parent :has-element child)</z><z id="t1689053920" t="Pranav Ram This is how I&apos;m solving it in plain clojure with walk: (def output (atom [])) (do (reset! output []) (walk/prewalk (fn [node] (when (and (map? node) (contains? node :has-element)) (swap! output conj (map #(do {:id (:name x) :has-element (dissoc % :has-element)}) (:has-element node))) ) node) input))"><y>#</y><d>2023-07-11</d><h>05:38</h><r>Pranav Ram</r>This is how I&apos;m solving it in plain clojure with walk:

<pre>(def output (atom []))

(do (reset! output [])
    (walk/prewalk (fn [node]
                      (when (and (map? node) (contains? node :has-element))
                        (swap! output conj 
                               (map #(do {:id (:name x) 
                                          :has-element (dissoc % :has-element)}) 
                                (:has-element node)))
                        )
                      node) input))</pre></z><z id="t1689091085" t="noprompt [:attrs {:href &quot;/_/_/users/U05EF6LHTRR&quot;}] Ah, then you probably want to use m/search instead. (m/search input {:id ?id :has-element (m/scan {:has-element _ &amp; ?without-children})} {:id ?id :has-element ?without-children} {:has-element (m/scan (m/cata ?child))} ?child) You have a disjunction in disguise. You want the result with the {:id, :has-element} or you want the transformed {:id, :has-element} from the children."><y>#</y><d>2023-07-11</d><h>15:58</h><r>noprompt</r><a>@pranav.ram7</a> Ah, then you probably want to use <code>m/search</code> instead.

<pre>(m/search input
  {:id ?id
   :has-element (m/scan {:has-element _ &amp; ?without-children})}
  {:id ?id :has-element ?without-children}

  {:has-element (m/scan (m/cata ?child))}
  ?child)</pre>
You have a disjunction in disguise. You want the result with the <code>{:id, :has-element}</code> or you want the transformed <code>{:id, :has-element}</code> from the children.</z><z id="t1689092468" t="noprompt Another thing to consider in the future for problems like this is how you might use tree-seq . You can use tree-seq to extract the branches and then you can post process them to do the remaining work: ;; With `for` (let [branch? (fn [x] (and (map? x) (contains? x :id) (contains? x :has-element))) children (fn [x] (filter branch? (:has-element x)))] (for [branch (tree-seq branch? children input) :let [id (:id branch) children (:has-element branch)] child children :let [without-children (dissoc child :has-element)]] {:id id :has-element without-children})) ;; With `mapcat` (let [branch? (fn [x] (and (map? x) (contains? x :id) (contains? x :has-element))) children (fn [x] (filter branch? (:has-element x)))] (mapcat (fn [branch] (let [id (:id branch) children (:has-element branch)] (map (fn [child] (let [without-children (dissoc child :has-element)] {:id id :has-element without-children})) children))) (tree-seq branch? children input))) "><y>#</y><d>2023-07-11</d><h>16:21</h><r>noprompt</r>Another thing to consider in the future for problems like this is how you might use <code>tree-seq</code>. You can use <code>tree-seq</code> to extract the branches and then you can post process them to do the remaining work:

<pre>;; With `for`
(let [branch? (fn [x]
                (and (map? x)
                     (contains? x :id)
                     (contains? x :has-element)))
      children (fn [x]
                 (filter branch? (:has-element x)))]
  (for [branch (tree-seq branch? children input)
        :let [id (:id branch)
              children (:has-element branch)]
        child children
        :let [without-children (dissoc child :has-element)]]
    {:id id
     :has-element without-children}))

;; With `mapcat`
(let [branch? (fn [x]
                (and (map? x)
                     (contains? x :id)
                     (contains? x :has-element)))
      children (fn [x]
                 (filter branch? (:has-element x)))]
  (mapcat (fn [branch]
            (let [id (:id branch)
                  children (:has-element branch)]
              (map (fn [child]
                     (let [without-children (dissoc child :has-element)]
                       {:id id
                        :has-element without-children}))
                   children)))
          (tree-seq branch? children input)))</pre>
</z><z id="t1689092891" t="noprompt I might also advise against using something like prewalk if possible in favor of something tuned specifically for your use case. prewalk walks everything and this is not often what people want. In this case, we only need to traverse the objects that meet our branch? criteria. If we use postwalk , we&apos;ll end up traversing all of the values in the root node including stuff we know we know is irrelevant."><y>#</y><d>2023-07-11</d><h>16:28</h><r>noprompt</r>I might also advise against using something like <code>prewalk</code> if possible in favor of something tuned specifically for your use case. <code>prewalk</code> walks everything and this is not often what people want. In this case, we only need to traverse the objects that meet our <code>branch?</code> criteria. If we use <code>postwalk</code>, we&apos;ll end up traversing all of the values in the root node including stuff we know we know is irrelevant.</z><z id="t1689093126" t="noprompt A similar, heavy-handed approach using Meander would be to use the m/$ pattern in conjunction with m/search . (m/search input (m/$ {:id ?id :has-element (m/scan {:has-element _ &amp; ?without-children})}) {:id ?id :has-element ?without-children}) This will produce the same result set as the previous solutions at the cost of traversing the whole input."><y>#</y><d>2023-07-11</d><h>16:32</h><r>noprompt</r>A similar, heavy-handed approach using Meander would be to use the <code>m/$</code> pattern in conjunction with <code>m/search</code>.
<pre>(m/search input
  (m/$ {:id ?id :has-element (m/scan {:has-element _ &amp; ?without-children})})
  {:id ?id :has-element ?without-children})</pre>
This will produce the same result set as the previous solutions at the cost of traversing the whole input.</z><z id="t1691051879" t="Pranav Ram Fantastic, thank you! I had to put the project on hold and just returned to it. This worked great and thank you for the advise on using tree-seq to avoid traversing the whole tree."><y>#</y><d>2023-08-03</d><h>08:37</h><r>Pranav Ram</r>Fantastic, thank you! I had to put the project on hold and just returned to it. This worked great and thank you for the advise on using tree-seq to avoid traversing the whole tree.</z><z id="t1691051984" t="Pranav Ram Would you be able to elaborate on how this works, maybe just high level what m/scan does for the structure? https://clojurians.slack.com/archives/CFFTD7R6Z/p1689091085768469?thread_ts=1688848556.713519&amp;amp;cid=CFFTD7R6Z"><y>#</y><d>2023-08-03</d><h>08:39</h><r>Pranav Ram</r>Would you be able to elaborate on how this works, maybe just high level what m/scan does for the structure? <a href="https://clojurians.slack.com/archives/CFFTD7R6Z/p1689091085768469?thread_ts=1688848556.713519&amp;amp;cid=CFFTD7R6Z" target="_blank">https://clojurians.slack.com/archives/CFFTD7R6Z/p1689091085768469?thread_ts=1688848556.713519&amp;amp;cid=CFFTD7R6Z</a></z><z id="t1689093443" t="noprompt I was just thinking: there&apos;s an opportunity to improve the utility of Code LLMs for Clojure (such as WizardCoder) by building an instruction set from Clojurians conversations."><y>#</y><d>2023-07-11</d><h>16:37</h><w>noprompt</w>I was just thinking: there&apos;s an opportunity to improve the utility of Code LLMs for Clojure (such as WizardCoder) by building an instruction set from Clojurians conversations.</z><z id="t1695313446" t="bbss I&apos;m very curious what someone that actually knows what they&apos;re doing with meander can do with LLM&apos;s and meander. Especially with fine-tuning on gpt-3.5-turbo and (announced to become available later) gpt-4 fine-tuning. It should be possible to create some fine-tuning interactions that explain the concepts."><y>#</y><d>2023-09-21</d><h>16:24</h><r>bbss</r>I&apos;m very curious what someone that actually knows what they&apos;re doing with meander can do with LLM&apos;s and meander. Especially with fine-tuning on gpt-3.5-turbo and (announced to become available later) gpt-4 fine-tuning. It should be possible to create some fine-tuning interactions that explain the concepts.</z><z id="t1695313446" t="bbss I&apos;m very curious what someone that actually knows what they&apos;re doing with meander can do with LLM&apos;s and meander. Especially with fine-tuning on gpt-3.5-turbo and (announced to become available later) gpt-4 fine-tuning. It should be possible to create some fine-tuning interactions that explain the concepts."><y>#</y><d>2023-09-21</d><h>16:24</h><w>bbss</w>I&apos;m very curious what someone that actually knows what they&apos;re doing with meander can do with LLM&apos;s and meander. Especially with fine-tuning on gpt-3.5-turbo and (announced to become available later) gpt-4 fine-tuning. It should be possible to create some fine-tuning interactions that explain the concepts.</z><z id="t1690062651" t="geoff How do I learn to write a pattern matching library like meander? Is there some sort of literature/Right Way like parser combinators or bnf grammers or is it mostly custom design?"><y>#</y><d>2023-07-22</d><h>21:50</h><w>geoff</w>How do I learn to write a pattern matching library like meander? Is there some sort of literature/Right Way like parser combinators or bnf grammers or is it mostly custom design?</z><z id="t1690088837" t="Ben Sless https://github.com/noprompt/meander/blob/epsilon/doc/references.md"><y>#</y><d>2023-07-23</d><h>05:07</h><r>Ben Sless</r><a href="https://github.com/noprompt/meander/blob/epsilon/doc/references.md" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/references.md</a></z><z id="t1690150406" t="geoff Oh it’s right in the docs, thank you"><y>#</y><d>2023-07-23</d><h>22:13</h><r>geoff</r>Oh it’s right in the docs, thank you</z><z id="t1690175818" t="Ben Sless Well I know it&apos;s there because I put it there"><y>#</y><d>2023-07-24</d><h>05:16</h><r>Ben Sless</r>Well I know it&apos;s there because I put it there</z><z id="t1690062875" t="geoff Wondering where the ideas and notation comes from in meander "><y>#</y><d>2023-07-22</d><h>21:54</h><w>geoff</w>Wondering where the ideas and notation comes from in meander </z><z id="t1690610441" t="geoff Once term rewriting clicks it’s so incredibly good"><y>#</y><d>2023-07-29</d><h>06:00</h><w>geoff</w>Once term rewriting clicks it’s so incredibly good</z><z id="t1690610513" t="geoff Been adding hiccup like tags to little dsl ast’s and you can just keep rewriting again and again and again until it lowers back into clojure"><y>#</y><d>2023-07-29</d><h>06:01</h><w>geoff</w>Been adding hiccup like tags to little dsl ast’s and you can just keep rewriting again and again and again until it lowers back into clojure</z><z id="t1690610522" t="geoff Love this library "><y>#</y><d>2023-07-29</d><h>06:02</h><w>geoff</w>Love this library </z><z id="t1690610597" t="geoff Dsl -&gt; parse into hiccup like structure -&gt; rewrite until back into clojure -&gt; wrap the whole thing in a macro -&gt; done"><y>#</y><d>2023-07-29</d><h>06:03</h><w>geoff</w>Dsl -&gt; parse into hiccup like structure -&gt; rewrite until back into clojure -&gt; wrap the whole thing in a macro -&gt; done</z><z id="t1691008046" t="Dane Filipczak what do you mean by &apos;back into clojure&apos; here? How is the final clojure representation different from the &apos;parse into hiccup&apos; step?"><y>#</y><d>2023-08-02</d><h>20:27</h><r>Dane Filipczak</r>what do you mean by &apos;back into clojure&apos; here? How is the final clojure representation different from the &apos;parse into hiccup&apos; step?</z><z id="t1691058324" t="geoff I was parsing the clojure dsl forms into hiccup like tags to pick out information and add some loose typing to know what the form is, then rewriting the hiccup into other hiccup forms closer to normal clojure syntax, then finally rewriting it back into valid clojure syntax which I could execute."><y>#</y><d>2023-08-03</d><h>10:25</h><r>geoff</r>I was parsing the clojure dsl forms into hiccup like tags to pick out information and add some loose typing to know what the form is, then rewriting the hiccup into other hiccup forms closer to normal clojure syntax, then finally rewriting it back into valid clojure syntax which I could execute.</z><z id="t1691064786" t="Dane Filipczak thanks! I had misunderstood your final intent as producing some data structure rather than executing clojure syntax."><y>#</y><d>2023-08-03</d><h>12:13</h><r>Dane Filipczak</r>thanks! I had misunderstood your final intent as producing some data structure rather than executing clojure syntax.</z><z id="t1690610605" t="geoff Can’t believe this isn’t more well known"><y>#</y><d>2023-07-29</d><h>06:03</h><w>geoff</w>Can’t believe this isn’t more well known</z><z id="t1690656882" t="noprompt [:attrs {:href &quot;/_/_/users/U01MV1EPVK8&quot;}] I&apos;m glad you&apos;re enjoying it!"><y>#</y><d>2023-07-29</d><h>18:54</h><w>noprompt</w><a>@gcoumessos</a> I&apos;m glad you&apos;re enjoying it!</z><z id="t1691394223" t="Lidor Cohen Hello, I&apos;m trying to refresh my meanderian 🙂 I&apos;m trying to capture the ...rest of the kvs in the map (without ?route of course) and then spread it in the return structure: (m/search preset {:content (m/scan [?key _]) :children {?key {:navigation {:route ?route &amp; (m/cata ?rest)}}}} [?route {:name ?key ...?rest}]) What operators am I looking for (instead of the ... )?"><y>#</y><d>2023-08-07</d><h>07:43</h><w>Lidor Cohen</w>Hello, I&apos;m trying to refresh my meanderian <b>🙂</b>
I&apos;m trying to capture the <code>...rest</code> of the kvs in the map (without <code>?route</code> of course) and then spread it in the return structure:
<pre>(m/search preset
            {:content (m/scan [?key _])
             :children {?key {:navigation {:route ?route &amp; (m/cata ?rest)}}}}

            [?route {:name ?key
                     ...?rest}])</pre>
What operators am I looking for (instead of the <code>...</code>)?</z><z id="t1691397108" t="delaguardo should be ..!rest"><y>#</y><d>2023-08-07</d><h>08:31</h><r>delaguardo</r>should be <code>..!rest</code></z><z id="t1691397137" t="delaguardo https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#tokenize-a-sequence-partitioning"><y>#</y><d>2023-08-07</d><h>08:32</h><r>delaguardo</r><a href="https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#tokenize-a-sequence-partitioning" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/cookbook.md#tokenize-a-sequence-partitioning</a></z><z id="t1691400389" t="Lidor Cohen (m/search preset {:content (m/scan [?key _]) :children {?key {:navigation {:route ?route ..!rest}}}} [?route {:name ?key ..!rest}]) is this what you had in mind? it throws, I&apos;m guessing something to do with search"><y>#</y><d>2023-08-07</d><h>09:26</h><r>Lidor Cohen</r><pre>(m/search preset
            {:content (m/scan [?key _])
             :children {?key {:navigation {:route ?route ..!rest}}}}

            [?route {:name ?key
                     ..!rest}])</pre>
is this what you had in mind?
it throws, I&apos;m guessing something to do with <code>search</code></z><z id="t1691951709" t="noprompt [:attrs {:href &quot;/_/_/users/U8RHR1V60&quot;}] The right hand side of search rules are Clojure code. So you&apos;re looking for (m/search preset {:content (m/scan [?key _]) :children {?key {:navigation {:route ?route &amp; ?rest}}}} [?route (assoc ?rest :name ?key)]) "><y>#</y><d>2023-08-13</d><h>18:35</h><r>noprompt</r><a>@U8RHR1V60</a> The right hand side of <code>search</code> rules are Clojure code. So you&apos;re looking for

<pre>(m/search preset
            {:content (m/scan [?key _])
             :children {?key {:navigation {:route ?route &amp; ?rest}}}}

            [?route (assoc ?rest :name ?key)])</pre>
</z><z id="t1691955000" t="Lidor Cohen BTW I found the docs in the GitHub repo. They&apos;re very good, I&apos;d link to them (or at least the directory) from the main README, so they&apos;d be more obvious to find."><y>#</y><d>2023-08-13</d><h>19:30</h><r>Lidor Cohen</r>BTW I found the docs in the GitHub repo.
They&apos;re very good, I&apos;d link to them (or at least the directory) from the main README, so they&apos;d be more obvious to find.</z><z id="t1692593385" t="Zachary I have a vector of maps in the following shape, with only the keys I care about: [{:data [{:id ?id :external_data {:image ?image :name ?name}} ...] } ...] I’m able to get it to produce the logical variables that I’m interested in on a single map in that vector, put that in a function and map over the whole vector. But I’m wondering if there’s a way to do that better in one transformational step. So that I get something like [{:id 1 :image &quot;image1&quot; :name &quot;foo&quot; }, {:id 2 :image &quot;image2&quot; :name &quot;bar&quot; }...] I’ve tried the ! bang memory variables with ... , but that seems to group all the memory vars together, and really I want them put into a particular shape. Hope it’s okay to ask this here! I definitely look forward to my journey into Meander... just starting with this library, but I do have many years writing Prolog--and a bit with other rewriting systems (Maude)--so excited to explore pattern matching in my other favorite language (Clojure, of course)!"><y>#</y><d>2023-08-21</d><h>04:49</h><w>Zachary</w>I have a vector of maps in the following shape, with only the keys I care about:

<code>[{:data [{:id ?id :external_data {:image ?image :name ?name}} ...] } ...]</code>

I’m able to get it to produce the logical variables that I’m interested in on a single map in that vector, put that in a function and map over the whole vector. But I’m wondering if there’s a way to do that better in one transformational step. So that I get something like

<code>[{:id 1 :image &quot;image1&quot; :name &quot;foo&quot; }, {:id 2 :image &quot;image2&quot; :name &quot;bar&quot; }...]</code>

I’ve tried the <code>!</code> bang memory variables with <code>...</code>, but that seems to group all the memory vars together, and really I want them put into a particular shape.

Hope it’s okay to ask this here! I definitely look forward to my journey into Meander... just starting with this library, but I do have many years writing Prolog--and a bit with other rewriting systems (Maude)--so excited to explore pattern matching in my other favorite language (Clojure, of course)!</z><z id="t1692618448" t="telekid Have you seen the combination of m/search and m/scan? From https://github.com/noprompt/meander/blob/epsilon/doc/understanding.md#search (m/search [1 2 1 3 1 5] (m/scan 1 ?x) ?x) ;; =&gt; (2 3 5)"><y>#</y><d>2023-08-21</d><h>11:47</h><r>telekid</r>Have you seen the combination of <code>m/search</code> and <code>m/scan?</code>

From <a href="https://github.com/noprompt/meander/blob/epsilon/doc/understanding.md#search" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/understanding.md#search</a>

<pre>(m/search [1 2 1 3 1 5]
  (m/scan 1 ?x) ?x)
;; =&gt; (2 3 5)</pre></z><z id="t1692629281" t="Zachary Ah, yes... that is indeed doing the do! 👍"><y>#</y><d>2023-08-21</d><h>14:48</h><r>Zachary</r>Ah, yes... that is indeed doing the do! <b>👍</b></z><z id="t1692640984" t="telekid Once you get comfortable with search with scan , it’s worth trying to solve your problem with search alone. search with scan is just a special case of search , and search by itself is quite a bit more powerful, so it’s nice to know how to use it."><y>#</y><d>2023-08-21</d><h>18:03</h><r>telekid</r>Once you get comfortable with <code>search</code> with <code>scan</code>, it’s worth trying to solve your problem with <code>search</code> alone. <code>search</code> with <code>scan</code> is just a special case of <code>search</code>, and <code>search</code> by itself is quite a bit more powerful, so it’s nice to know how to use it.</z><z id="t1692641005" t="telekid (And find is just search where you only care about the first result.)"><y>#</y><d>2023-08-21</d><h>18:03</h><r>telekid</r>(And <code>find</code> is just search where you only care about the first result.)</z><z id="t1693339347" t="xiongtx Is there a way to search non-constant subsequences? E.g. the following should return [1 2] [7 8] (m/search [1 2 4 5 7 8] [(m/pred odd? ?x) (m/pred even? ?y) ...] [?x ?y]) But instead throws: Zero or more patterns may not have references to unbound logic variables. {:unbound #{?x ?y}, :syntax-trace [((m/pred odd? ?x) (m/pred even? ?y) ...) [(m/pred odd? ?x) (m/pred even? ?y) ...]]}"><y>#</y><d>2023-08-29</d><h>20:02</h><w>xiongtx</w>Is there a way to search non-constant subsequences? E.g. the following should return <code>[1 2] [7 8]</code>

<pre>(m/search [1 2 4 5 7 8]
  [(m/pred odd? ?x) (m/pred even? ?y) ...] [?x ?y])</pre>
But instead throws:

<pre>Zero or more patterns may not have references to unbound logic variables.
   {:unbound #{?x ?y},
    :syntax-trace
    [((m/pred odd? ?x) (m/pred even? ?y) ...)
     [(m/pred odd? ?x) (m/pred even? ?y) ...]]}</pre></z><z id="t1693340169" t="Jimmy Miller You want scan. (m/search [1 2 4 5 7 8] (m/scan (m/pred odd? ?x) (m/pred even? ?y)) [?x ?y]) Which is basically sugar over (m/search [1 2 4 5 7 8] [_ ... (m/pred odd? ?x) (m/pred even? ?y) . _ ...] [?x ?y]) "><y>#</y><d>2023-08-29</d><h>20:16</h><r>Jimmy Miller</r>You want scan.

<pre>(m/search [1 2 4 5 7 8]
  (m/scan (m/pred odd? ?x) (m/pred even? ?y))
  [?x ?y])</pre>
Which is basically sugar over

<pre>(m/search [1 2 4 5 7 8]
  [_ ... (m/pred odd? ?x) (m/pred even? ?y) . _ ...]
  [?x ?y])</pre>
</z><z id="t1693413732" t="xiongtx Ah, okay, I didn’t know scan worked w/ multiple args!"><y>#</y><d>2023-08-30</d><h>16:42</h><r>xiongtx</r>Ah, okay, I didn’t know <code>scan</code> worked w/ multiple args!</z><z id="t1693431536" t="nivekuil how would I get {:title &quot;title&quot; :foos [1 2]} from something like this (mean/search {:title &quot;title&quot; :items [{:foo 1} {:foo 2}]} ;; wrong {:title ?t :items (mean/scan {:foo ?x})} {:title ?t :foos ?x}) "><y>#</y><d>2023-08-30</d><h>21:38</h><w>nivekuil</w>how would I get
<pre>{:title &quot;title&quot;
 :foos [1 2]}</pre>
from something like this
<pre>(mean/search
    {:title &quot;title&quot;
     :items [{:foo 1} {:foo 2}]}
    ;; wrong
    {:title ?t
     :items (mean/scan {:foo ?x})}
    {:title ?t
     :foos ?x})</pre>
</z><z id="t1693447364" t="Richie Probably with m/rewrite and a memory variable !x"><y>#</y><d>2023-08-31</d><h>02:02</h><r>Richie</r>Probably with m/rewrite and a memory variable !x</z><z id="t1693447383" t="Richie I’m on mobile atm. "><y>#</y><d>2023-08-31</d><h>02:03</h><r>Richie</r>I’m on mobile atm. </z><z id="t1693451721" t="Jimmy Miller (m/rewrite {:title &quot;title&quot; :items [{:foo 1} {:foo 2}]} {:title ?title :items [{:foo !foo} ...]} {:title ?title :foos [!foo ...]}) ;; =&gt; {:title &quot;title&quot;, :foos [1 2]}"><y>#</y><d>2023-08-31</d><h>03:15</h><r>Jimmy Miller</r><pre>(m/rewrite {:title &quot;title&quot;
            :items [{:foo 1} {:foo 2}]}

  {:title ?title
   :items [{:foo !foo} ...]}

  
  {:title ?title
   :foos [!foo ...]})

;; =&gt;

{:title &quot;title&quot;, :foos [1 2]}</pre></z><z id="t1693497348" t="nivekuil ah, rewrite. so that&apos;s a purely syntactic transform; if you want to map over the !foo s do you inline your logic as if it were match/search and then eval after, or do you do that outside of rewrite"><y>#</y><d>2023-08-31</d><h>15:55</h><r>nivekuil</r>ah, rewrite. so that&apos;s a purely syntactic transform; if you want to map over the <code>!foo</code> s do you inline your logic as if it were match/search and then <code>eval</code> after, or do you do that outside of <code>rewrite</code></z><z id="t1693497468" t="Jimmy Miller Depends on what you want to do with !foo. If you want to just apply a function you can do something like this (m/rewrite {:title &quot;title&quot; :items [{:foo 1} {:foo 2}]} {:title ?title :items [{:foo !foo} ...]} {:title ?title :foos [(m/app inc !foo) ...]})"><y>#</y><d>2023-08-31</d><h>15:57</h><r>Jimmy Miller</r>Depends on what you want to do with !foo. If you want to just apply a function you can do something like this

<pre>(m/rewrite {:title &quot;title&quot;
            :items [{:foo 1} {:foo 2}]}

  {:title ?title
   :items [{:foo !foo} ...]}

  
  {:title ?title
   :foos [(m/app inc !foo) ...]})</pre></z><z id="t1695342963" t="James Amberger Why’s it called cata ?"><y>#</y><d>2023-09-22</d><h>00:36</h><w>James Amberger</w>Why’s it called <code>cata</code>?</z><z id="t1695345722" t="Jimmy Miller https://en.m.wikipedia.org/wiki/Catamorphism"><y>#</y><d>2023-09-22</d><h>01:22</h><r>Jimmy Miller</r><a href="https://en.m.wikipedia.org/wiki/Catamorphism" target="_blank">https://en.m.wikipedia.org/wiki/Catamorphism</a></z><z id="t1695676655" t="Dave Should I use guard clauses in scan to ensure that these values aren&apos;t both nil? ;; Want to filter nils, such that both ?from and ?to are populated (m/search clj-kondo-analysis {:var-usages (m/scan {:from-var ?from :name ?to})} [?from ?to]) If so, where should I put the clauses? I am having a bit of trouble finding syntax examples with scan . Should I be using a different technique? This is how I structure the data: (def analysis (:analysis (clj-kondo/run! {:lint paths :config {:analysis {:var-usages true :var-definitions {:shallow false}}} :skip-lint true}))) This is a simplified dataset that I am working with: [{:name -&gt;evdev, :from-var -main} {:name -&gt;joydev, :from-var -main}, {:name defn :from-var nil}] "><y>#</y><d>2023-09-25</d><h>21:17</h><w>Dave</w>Should I use <code>guard</code> clauses in <code>scan</code> to ensure that these values aren&apos;t both nil?
<pre>;; Want to filter nils, such that both ?from and ?to are populated
(m/search clj-kondo-analysis
          {:var-usages (m/scan {:from-var ?from :name ?to})}
          
          [?from ?to])</pre>
If so, where should I put the clauses? I am having a bit of trouble finding syntax examples with <code>scan</code>. Should I be using a different technique?

This is how I structure the data:
<pre>(def analysis (:analysis (clj-kondo/run! {:lint      paths
                                          :config    {:analysis {:var-usages      true
                                                                 :var-definitions {:shallow false}}}
                                          :skip-lint true})))</pre>
This is a simplified dataset that I am working with:
<pre>[{:name     -&gt;evdev,
  :from-var -main}
 {:name     -&gt;joydev,
  :from-var -main},
 {:name     defn
  :from-var nil}]</pre>
</z><z id="t1695686488" t="Dave I think I figured it out! (m/search (:analysis analysis) {:var-usages (m/scan {:from-var ?from :name ?to &amp; (m/guard (not= ?from nil))})} [?from ?to])"><y>#</y><d>2023-09-26</d><h>00:01</h><r>Dave</r>I think I figured it out!
<pre>(m/search (:analysis analysis)
          {:var-usages (m/scan {:from-var ?from
                                :name     ?to
                                &amp;         (m/guard (not= ?from nil))})}

          [?from ?to])</pre></z><z id="t1695688861" t="Dave Woooot, got it working!!!! Ubergraph + Meander ❤️ (def multigraph (apply uber/multidigraph (m/search (:analysis analysis) {:namespace-definitions (m/scan {:name ?ns :as ?rest}) :var-usages (m/scan {:from-var ?from :name ?to :to ?ns &amp; (m/and (m/guard (not= nil ?from)) (m/guard (not= nil ?to))) :as ?var-rest})} [?from ?to ?var-rest])))"><y>#</y><d>2023-09-26</d><h>00:41</h><r>Dave</r>Woooot, got it working!!!!

Ubergraph + Meander <b>❤️</b>
<pre>(def multigraph (apply uber/multidigraph
                       (m/search (:analysis analysis)
                                 {:namespace-definitions (m/scan {:name ?ns :as ?rest})
                                  :var-usages            (m/scan {:from-var ?from
                                                                  :name     ?to
                                                                  :to       ?ns
                                                                  &amp;         (m/and (m/guard (not= nil ?from))
                                                                                   (m/guard (not= nil ?to)))
                                                                  :as       ?var-rest})}


                                 [?from ?to ?var-rest])))</pre></z><z id="t1695688928" t="Dave"><y>#</y><d>2023-09-26</d><h>00:42</h><r>Dave</r></z><z id="t1696011391" t="James Amberger Why’s it called cata ?"><y>#</y><d>2023-09-29</d><h>18:16</h><w>James Amberger</w>Why’s it called <code>cata</code>?</z><z id="t1696011595" t="Jimmy Miller It’s short for catamorphism. Which is a concept from recursion schemes. Basically it is a generalization of reduce. "><y>#</y><d>2023-09-29</d><h>18:19</h><r>Jimmy Miller</r>It’s short for catamorphism. Which is a concept from recursion schemes. Basically it is a generalization of reduce. </z><z id="t1696460183" t="Zachary I have a search query, something like: (let [k :my-key] (m/search foo-records (m/scan {:my-val ?val k true}) ?val)) Where I’m trying to pass a key in through a let binding, but it doesn’t seem to be captured. Is there a way to pass in some structure to be pattern matched?"><y>#</y><d>2023-10-04</d><h>22:56</h><w>Zachary</w>I have a search query, something like:
<pre>(let [k :my-key]
  (m/search foo-records
    (m/scan {:my-val ?val k true})
    ?val))</pre>
Where I’m trying to pass a key in through a let binding, but it doesn’t seem to be captured. Is there a way to pass in some structure to be pattern matched?</z><z id="t1696657069" t="Coby Tamayo I&apos;m not completely sure what you&apos;re asking, but I noticed you&apos;re not using k in your pattern at all"><y>#</y><d>2023-10-07</d><h>05:37</h><r>Coby Tamayo</r>I&apos;m not completely sure what you&apos;re asking, but I noticed you&apos;re not using <code>k</code> in your pattern at all</z><z id="t1696804662" t="Zachary Right, typo… meant for the :my-key in the body to be the k . Edited."><y>#</y><d>2023-10-08</d><h>22:37</h><r>Zachary</r>Right, typo… meant for the :my-key in the body to be the <code>k</code>. Edited.</z><z id="t1696825663" t="Coby Tamayo ohhhh I see what&apos;s happening...but it threw me off for a second too. Since m/search and friends allow for arbitrary symbols in your form (like ?val is here), it&apos;s parsing k as such a symbol as well. You can unquote it with ~ to accomplish what you want though: (let [k :my-key] (m/search [{:my-val 5 :my-key true :x :y}] (m/scan {:my-val ?val ~k true}) ?val)) See operator https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#unquote ."><y>#</y><d>2023-10-09</d><h>04:27</h><r>Coby Tamayo</r>ohhhh I see what&apos;s happening...but it threw me off for a second too. Since <code>m/search</code> and friends allow for arbitrary symbols in your form (like <code>?val</code> is here), it&apos;s parsing <code>k</code> as such a symbol as well. You can unquote it with <code>~</code> to accomplish what you want though:
<pre>(let [k :my-key]
  (m/search [{:my-val 5 :my-key true :x :y}]
    (m/scan {:my-val ?val ~k true})
    ?val))</pre>
See operator <a href="https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#unquote" target="_blank">https://github.com/noprompt/meander/blob/epsilon/doc/operator-overview.md#unquote</a>.</z><z id="t1696826782" t="Coby Tamayo Poking at this helped me gain some intuition for how Meander works...consider that without the let binding, it doesn&apos;t throw an error to have k (not unquoted) appear in the form: (m/search {:my-val 5 :my-key true} {:my-val ?val k true} ?val) However, if you try to return k in your result, it&apos;ll throw a syntax error: Unable to resolve symbol: k in this context : (m/search {:my-val 5 :my-key true} {:my-val ?val k true} [?val k]) This kinda makes sense since k is recognizably not a logic or memory var, but this is definitely a sharp edge. [:attrs {:href &quot;/_/_/users/U06MDAPTP&quot;}] is this by design? I would expect that the same logic that decides whether or something can be bound in a LHS expr should match the logic for the bindings that end up in a RHS expr as well. If there is no way to get a non-logic (/etc.) variable &quot;out&quot; as part of a RHS expr I would expect such a variable to get flagged as a syntax error on the LHS...but maybe I am just missing something. 🙂"><y>#</y><d>2023-10-09</d><h>04:46</h><r>Coby Tamayo</r>Poking at this helped me gain some intuition for how Meander works...consider that without the <code>let</code> binding, it doesn&apos;t throw an error to have <code>k</code> (not unquoted) appear in the form:
<pre>(m/search {:my-val 5 :my-key true}
  {:my-val ?val k true} ?val)</pre>
However, if you try to return <code>k</code> in your result, it&apos;ll throw a syntax error: <code>Unable to resolve symbol: k in this context</code>:
<pre>(m/search {:my-val 5 :my-key true}
  {:my-val ?val k true} [?val k])</pre>
This kinda makes sense since <code>k</code> is recognizably not a logic or memory var, but this is definitely a sharp edge. <a>@U06MDAPTP</a> is this by design? I would expect that the same logic that decides whether or something can be bound in a LHS expr should match the logic for the bindings that end up in a RHS expr as well. If there is no way to get a non-logic (/etc.) variable &quot;out&quot; as part of a RHS expr I would expect such a variable to get flagged as a syntax error on the LHS...but maybe I am just missing something. <b>🙂</b></z><z id="t1696827492" t="Coby Tamayo hmmm maybe it has to work this way in order to match on symbols? (m/search {:my-val 5 &apos;sym true} {:my-val ?val sym ?sym} [?val ?sym])"><y>#</y><d>2023-10-09</d><h>04:58</h><r>Coby Tamayo</r>hmmm maybe it has to work this way in order to match on symbols?
<pre>(m/search {:my-val 5 &apos;sym true}
  {:my-val ?val sym ?sym} [?val ?sym])</pre></z><z id="t1696657682" t="Coby Tamayo Is it possible to match the path to a node matching some predicate, through an arbitrarily nested data structure? For example, I can do this to get the binding I care about: (def pull [:db/id {:menu/items [:db/id {:menu.item/entities [{:translatable/fields [:field/key :field/content]}]}]}]) (m/search pull (m/$ (m/scan (m/pred translatable-binding? ?binding))) ?binding) ;; =&gt; (#:translatable{:fields [:field/key :field/content]}) But what I&apos;d really like to be able to do is something like this: (m/search pull (PATH-OP (m/scan (m/pred translatable-binding? ?path))) ?path) ;; =&gt; [1 :menu/items 1 :menu.item/entities 0] "><y>#</y><d>2023-10-07</d><h>05:48</h><w>Coby Tamayo</w>Is it possible to match the path to a node matching some predicate, through an arbitrarily nested data structure? For example, I can do this to get the binding I care about:
<pre>(def pull
    [:db/id
     {:menu/items
      [:db/id
       {:menu.item/entities
        [{:translatable/fields
          [:field/key
           :field/content]}]}]}])

  (m/search pull
            (m/$ (m/scan (m/pred translatable-binding? ?binding)))
            ?binding)
  ;; =&gt; (#:translatable{:fields [:field/key :field/content]})</pre>
But what I&apos;d really like to be able to do is something like this:
<pre>(m/search pull
            (PATH-OP (m/scan (m/pred translatable-binding? ?path)))
            ?path)
  ;; =&gt; [1 :menu/items 1 :menu.item/entities 0]</pre>
</z><z id="t1696666925" t="Coby Tamayo I&apos;ve had some luck with this simplified example using map? as a predicate: (m/search [:a :b :c {:d [:e {:f :g}]} [{}]] [(m/not (m/pred map?)) ..?n {?k ?v} &amp; _] (concat [?n ?k] (m/cata (doto ?v prn)))) ; (out) [:e {:f :g}] ;; =&gt; ((3 :d)) However, I&apos;m not sure why the recursion is coming back with nil . The value of ?v is what I expect based on the output."><y>#</y><d>2023-10-07</d><h>08:22</h><r>Coby Tamayo</r>I&apos;ve had some luck with this simplified example using <code>map?</code> as a predicate:
<pre>(m/search [:a :b :c {:d [:e {:f :g}]} [{}]]
            [(m/not (m/pred map?)) ..?n {?k ?v} &amp; _]
            (concat [?n ?k] (m/cata (doto ?v prn))))
  ; (out) [:e {:f :g}]
  ;; =&gt; ((3 :d))</pre>
However, I&apos;m not sure why the recursion is coming back with <code>nil</code>. The value of <code>?v</code> is what I expect based on the output.</z><z id="t1697347598" t="Coby Tamayo ah, I was using cata on the RHS when it should&apos;ve been on the left."><y>#</y><d>2023-10-15</d><h>05:26</h><r>Coby Tamayo</r>ah, I was using <code>cata</code> on the RHS when it should&apos;ve been on the left.</z><z id="t1697347634" t="Coby Tamayo Got this working! (let [tree pull search-key :translatable/fields pred #(some #{&apos;* :field/content} %)] (m/search tree {~search-key (m/pred pred ?v)} {search-key ?v} [_ ..?n (m/cata ?map) &amp; _] [[?n] ?map] [_ ..?n {(m/and (m/not ~search-key) ?k) (m/cata ?v)} &amp; _] (let [[path m] ?v] [(vec (concat [?n ?k] path)) m])))"><y>#</y><d>2023-10-15</d><h>05:27</h><r>Coby Tamayo</r>Got this working!
<pre>(let [tree pull
        search-key :translatable/fields
        pred #(some #{&apos;* :field/content} %)]
    (m/search
      tree

      {~search-key (m/pred pred ?v)}
      {search-key ?v}

      [_ ..?n (m/cata ?map) &amp; _]
      [[?n] ?map]

      [_ ..?n {(m/and (m/not ~search-key) ?k) (m/cata ?v)} &amp; _]
      (let [[path m] ?v]
        [(vec (concat [?n ?k] path)) m])))</pre></z><z id="t1697348299" t="Coby Tamayo ^ That replaces about 75 lines of baroque, buggy Clojure...I think I&apos;m in love 😍"><y>#</y><d>2023-10-15</d><h>05:38</h><r>Coby Tamayo</r>^ That replaces about 75 lines of baroque, buggy Clojure...I think I&apos;m in love <b>😍</b></z><z id="t1698918167" t="Stephan Renatus hi! I’d like to reduce some noise from a nested structure: the patterns I’d like to simplify are {:type &quot;CallStmt&quot;, :stmt {:func &quot;g0.data.x.p&quot;, :args [{:type &quot;local&quot;, :value 0} {:type &quot;local&quot;, :value 1}], :result 2, :file 0, :col 0, :row 0}} ⬇️ [:CallStmt {:func &quot;g0.data.x.p&quot;, :args [{:type &quot;local&quot;, :value 0} {:type &quot;local&quot;, :value 1}], :result 2}] and I got that base case done, more or less, via (m/match {:type &quot;CallStmt&quot;, :stmt {:func &quot;g0.data.x.p&quot;, :args [{:type &quot;local&quot;, :value 0} {:type &quot;local&quot;, :value 1}], :result 2, :file 0, :col 0, :row 0}} {:type ?t :stmt {:func ?f :args ?a :result ?r}} [(keyword ?t) {:func ?f :args ?a :result ?r}]) but I’ve got a bunch of problems still: 1. I’d like to omit :file, :row, :col, not enumerate what to keep — not every stmt has a :func for example 2. this is just the base, it’s a nested structure that I’d like to — and fail to — cleanup (see thread)"><y>#</y><d>2023-11-02</d><h>09:42</h><w>Stephan Renatus</w>hi! I’d like to reduce some noise from a nested structure: the patterns I’d like to simplify are
<pre>{:type &quot;CallStmt&quot;, :stmt {:func &quot;g0.data.x.p&quot;, :args [{:type &quot;local&quot;, :value 0} {:type &quot;local&quot;, :value 1}], :result 2, :file 0, :col 0, :row 0}} </pre>
<b>⬇️</b>
<pre>[:CallStmt {:func &quot;g0.data.x.p&quot;, :args [{:type &quot;local&quot;, :value 0} {:type &quot;local&quot;, :value 1}], :result 2}]</pre>
and I got that base case done, more or less, via
<pre>(m/match {:type &quot;CallStmt&quot;, :stmt {:func &quot;g0.data.x.p&quot;, :args [{:type &quot;local&quot;, :value 0} {:type &quot;local&quot;, :value 1}], :result 2, :file 0, :col 0, :row 0}}
  {:type ?t :stmt {:func ?f :args ?a :result ?r}}
  [(keyword ?t) {:func ?f :args ?a :result ?r}])</pre>
but I’ve got a bunch of problems still:
1. I’d like to omit :file, :row, :col, not enumerate what to keep — not every stmt has a <code>:func</code>  for example
2. this is just the base, it’s a nested structure that I’d like to — and fail to — cleanup (see thread)</z><z id="t1698918186" t="Stephan Renatus here’s a complete example {:static {:strings [{:value &quot;result&quot;} {:value &quot;xs&quot;} {:value &quot;y&quot;}], :files [{:value &quot;foo.rego&quot;}]}, :plans {:plans [{:name &quot;x/p&quot;, :blocks [{:stmts [{:type &quot;CallStmt&quot;, :stmt {:func &quot;g0.data.x.p&quot;, :args [{:type &quot;local&quot;, :value 0} {:type &quot;local&quot;, :value 1}], :result 2, :file 0, :col 0, :row 0}} {:type &quot;AssignVarStmt&quot;, :stmt {:source {:type &quot;local&quot;, :value 2}, :target 3, :file 0, :col 0, :row 0}} {:type &quot;MakeObjectStmt&quot;, :stmt {:target 4, :file 0, :col 0, :row 0}} {:type &quot;ObjectInsertStmt&quot;, :stmt {:key {:type &quot;string_index&quot;, :value 0}, :value {:type &quot;local&quot;, :value 3}, :object 4, :file 0, :col 0, :row 0}} {:type &quot;ResultSetAddStmt&quot;, :stmt {:value 4, :file 0, :col 0, :row 0}}]}]}]}, :funcs {:funcs [{:name &quot;g0.data.x.p&quot;, :params [0 1], :return 2, :blocks [{:stmts [{:type &quot;ResetLocalStmt&quot;, :stmt {:target 3, :file 0, :col 1, :row 4}} {:type &quot;DotStmt&quot;, :stmt {:source {:type &quot;local&quot;, :value 0}, :key {:type &quot;string_index&quot;, :value 1}, :target 4, :file 0, :col 5, :row 5}} {:type &quot;ScanStmt&quot;, :stmt {:source 4, :key 5, :value 6, :block {:stmts [{:type &quot;AssignVarStmt&quot;, :stmt {:source {:type &quot;local&quot;, :value 5}, :target 7, :file 0, :col 5, :row 5}} {:type &quot;AssignVarStmt&quot;, :stmt {:source {:type &quot;local&quot;, :value 6}, :target 8, :file 0, :col 5, :row 5}} {:type &quot;DotStmt&quot;, :stmt {:source {:type &quot;local&quot;, :value 0}, :key {:type &quot;string_index&quot;, :value 2}, :target 9, :file 0, :col 5, :row 6}} {:type &quot;AssignVarStmt&quot;, :stmt {:source {:type &quot;local&quot;, :value 9}, :target 10, :file 0, :col 5, :row 6}} {:type &quot;EqualStmt&quot;, :stmt {:a {:type &quot;local&quot;, :value 8}, :b {:type &quot;local&quot;, :value 10}, :file 0, :col 5, :row 7}} {:type &quot;AssignVarOnceStmt&quot;, :stmt {:source {:type &quot;bool&quot;, :value true}, :target 3, :file 0, :col 1, :row 4}}]}, :file 0, :col 5, :row 5}}]} {:stmts [{:type &quot;IsDefinedStmt&quot;, :stmt {:source 3, :file 0, :col 1, :row 4}} {:type &quot;AssignVarOnceStmt&quot;, :stmt {:source {:type &quot;local&quot;, :value 3}, :target 2, :file 0, :col 1, :row 4}}]} {:stmts [{:type &quot;ReturnLocalStmt&quot;, :stmt {:source 2, :file 0, :col 1, :row 4}}]}], :path [&quot;g0&quot; &quot;x&quot; &quot;p&quot;]}]}}"><y>#</y><d>2023-11-02</d><h>09:43</h><r>Stephan Renatus</r>here’s a complete example
<pre>{:static {:strings [{:value &quot;result&quot;} {:value &quot;xs&quot;} {:value &quot;y&quot;}], :files [{:value &quot;foo.rego&quot;}]}, :plans {:plans [{:name &quot;x/p&quot;, :blocks [{:stmts [{:type &quot;CallStmt&quot;, :stmt {:func &quot;g0.data.x.p&quot;, :args [{:type &quot;local&quot;, :value 0} {:type &quot;local&quot;, :value 1}], :result 2, :file 0, :col 0, :row 0}} {:type &quot;AssignVarStmt&quot;, :stmt {:source {:type &quot;local&quot;, :value 2}, :target 3, :file 0, :col 0, :row 0}} {:type &quot;MakeObjectStmt&quot;, :stmt {:target 4, :file 0, :col 0, :row 0}} {:type &quot;ObjectInsertStmt&quot;, :stmt {:key {:type &quot;string_index&quot;, :value 0}, :value {:type &quot;local&quot;, :value 3}, :object 4, :file 0, :col 0, :row 0}} {:type &quot;ResultSetAddStmt&quot;, :stmt {:value 4, :file 0, :col 0, :row 0}}]}]}]}, :funcs {:funcs [{:name &quot;g0.data.x.p&quot;, :params [0 1], :return 2, :blocks [{:stmts [{:type &quot;ResetLocalStmt&quot;, :stmt {:target 3, :file 0, :col 1, :row 4}} {:type &quot;DotStmt&quot;, :stmt {:source {:type &quot;local&quot;, :value 0}, :key {:type &quot;string_index&quot;, :value 1}, :target 4, :file 0, :col 5, :row 5}} {:type &quot;ScanStmt&quot;, :stmt {:source 4, :key 5, :value 6, :block {:stmts [{:type &quot;AssignVarStmt&quot;, :stmt {:source {:type &quot;local&quot;, :value 5}, :target 7, :file 0, :col 5, :row 5}} {:type &quot;AssignVarStmt&quot;, :stmt {:source {:type &quot;local&quot;, :value 6}, :target 8, :file 0, :col 5, :row 5}} {:type &quot;DotStmt&quot;, :stmt {:source {:type &quot;local&quot;, :value 0}, :key {:type &quot;string_index&quot;, :value 2}, :target 9, :file 0, :col 5, :row 6}} {:type &quot;AssignVarStmt&quot;, :stmt {:source {:type &quot;local&quot;, :value 9}, :target 10, :file 0, :col 5, :row 6}} {:type &quot;EqualStmt&quot;, :stmt {:a {:type &quot;local&quot;, :value 8}, :b {:type &quot;local&quot;, :value 10}, :file 0, :col 5, :row 7}} {:type &quot;AssignVarOnceStmt&quot;, :stmt {:source {:type &quot;bool&quot;, :value true}, :target 3, :file 0, :col 1, :row 4}}]}, :file 0, :col 5, :row 5}}]} {:stmts [{:type &quot;IsDefinedStmt&quot;, :stmt {:source 3, :file 0, :col 1, :row 4}} {:type &quot;AssignVarOnceStmt&quot;, :stmt {:source {:type &quot;local&quot;, :value 3}, :target 2, :file 0, :col 1, :row 4}}]} {:stmts [{:type &quot;ReturnLocalStmt&quot;, :stmt {:source 2, :file 0, :col 1, :row 4}}]}], :path [&quot;g0&quot; &quot;x&quot; &quot;p&quot;]}]}}</pre></z><z id="t1698918249" t="Stephan Renatus (I’ll keep posting what I come up with trying to figure this out on my own)"><y>#</y><d>2023-11-02</d><h>09:44</h><r>Stephan Renatus</r>(I’ll keep posting what I come up with trying to figure this out on my own)</z><z id="t1698918855" t="Stephan Renatus (m/rewrites (m/$ {:type ?t :stmt {:func (m/some ?f) :args ?a :result ?r}}) [(m/keyword ?t) :func ?f :args ?a :result ?r] ) woah, so this actually does the trick for any CallStmt that appears anywhere, but haven’t figured out how to deal with the :func being absent for other types"><y>#</y><d>2023-11-02</d><h>09:54</h><r>Stephan Renatus</r><pre>(m/rewrites
  (m/$ {:type ?t :stmt {:func (m/some ?f) :args ?a :result ?r}})
  [(m/keyword ?t) :func ?f :args ?a :result ?r]
)</pre>
woah, so this actually does the trick for any CallStmt that appears anywhere, but haven’t figured out how to deal with the :func being absent for other types</z><z id="t1698919844" t="Stephan Renatus not really. trying to ignore the :func, I’ve changed it to (m/rewrites (m/$ {:type ?t :stmt {:args ?a :result ?r}}) [(m/keyword ?t) :args ?a :result ?r]) but that only does the right thing on the first statement it encounters, the rest has :args nil :result nil"><y>#</y><d>2023-11-02</d><h>10:10</h><r>Stephan Renatus</r>not really. trying to ignore the :func, I’ve changed it to
<pre>(m/rewrites
  (m/$ {:type ?t :stmt {:args ?a :result ?r}})
  [(m/keyword ?t) :args ?a :result ?r])</pre>
but that only does the right thing on the first statement it encounters, the rest has <code>:args nil :result nil</code></z><z id="t1698919867" t="Stephan Renatus so I think this is the wrong approach. I’m considered m/cata… 💭"><y>#</y><d>2023-11-02</d><h>10:11</h><r>Stephan Renatus</r>so I think this is the wrong approach. I’m considered m/cata… <b>💭</b></z><z id="t1698921230" t="Stephan Renatus yup this looks better"><y>#</y><d>2023-11-02</d><h>10:33</h><r>Stephan Renatus</r>yup this looks better</z><z id="t1698921545" t="Stephan Renatus (m/rewrite plan {:plans {:plans [!p ...]}} {:plans [(m/cata !p) ...]} {:name ?n :blocks [!b ...]} [?n (m/cata !b) ...] {:stmts [!s ...]} [(m/cata !s) ...] {:type ?t :stmt ?stmt} [?t . ?stmt]) "><y>#</y><d>2023-11-02</d><h>10:39</h><r>Stephan Renatus</r><pre>(m/rewrite plan
        {:plans {:plans [!p ...]}}
	    {:plans [(m/cata !p) ...]}

		{:name ?n :blocks [!b ...]}
		[?n (m/cata !b) ...]

		{:stmts [!s ...]}
		[(m/cata !s) ...]

       	{:type ?t :stmt ?stmt}
        [?t . ?stmt])</pre>
</z><z id="t1698921592" t="Stephan Renatus now only (1.) is left"><y>#</y><d>2023-11-02</d><h>10:39</h><r>Stephan Renatus</r>now only (1.) is left</z><z id="t1698927744" t="Stephan Renatus {:type (m/some ?t) :stmt (m/some !s)} ((m/keyword ?t) . (m/cata {:stmt !s})) {:stmt {:file _ :col _ :row _ &amp; ?rest}} ?rest I think this does the trick"><y>#</y><d>2023-11-02</d><h>12:22</h><r>Stephan Renatus</r><pre>{:type (m/some ?t) :stmt (m/some !s)}
        ((m/keyword ?t) . (m/cata {:stmt !s}))

        {:stmt {:file _ :col _ :row _ &amp; ?rest}}
        ?rest</pre>
I think this does the trick</z><z id="t1698929170" t="Stephan Renatus I think I get the hang of it https://gist.github.com/srenatus/97f693ca911f060380a3305ba02fe55e"><y>#</y><d>2023-11-02</d><h>12:46</h><r>Stephan Renatus</r>I think I get the hang of it <a href="https://gist.github.com/srenatus/97f693ca911f060380a3305ba02fe55e" target="_blank">https://gist.github.com/srenatus/97f693ca911f060380a3305ba02fe55e</a></z><z id="t1702546724" t="nuriaion Hi I&apos;m using Advent of Code to learn Clojure and meander. In the i&apos;m trying to parse the input of day 2 and get the following: [:S [:game [:id &quot;1&quot;] [:draws [:draw [:cubes &quot;3&quot; &quot;blue&quot; &quot;4&quot; &quot;red&quot;] [:cubes &quot;1&quot; &quot;red&quot; &quot;2&quot; &quot;green&quot; &quot;6&quot; &quot;blue&quot;] [:cubes &quot;2&quot; &quot;green&quot;]]]]] which i want to transform to: {:id &quot;1&quot;, :draws [[{:number &quot;3&quot;, :color &quot;blue&quot;} {:number &quot;3&quot;, :color &quot;blue&quot;}] [{:number &quot;1&quot;, :color &quot;red&quot;} {:number &quot;2&quot;, :color &quot;green&quot;} {:number &quot;6&quot;, :color &quot;blue&quot;}] [{:number &quot;2&quot;, :color &quot;green&quot;}]]} So far i tried with: (m/rewrites parsed [:S [:game [:id ?id] [:draws [:draw [:cubes . !n !c ..1] ..1 &amp; ?rest]]]] {:id ?id :draws [{:draw [{:number !n :color !c}]} ...] :rest ?rest}))) which result in: ({:id &quot;1&quot;, :draws [{:draw [{:number &quot;3&quot;, :color &quot;blue&quot;}]} {:draw [{:number &quot;4&quot;, :color &quot;red&quot;}]}], :rest [[:cubes &quot;1&quot; &quot;red&quot; &quot;2&quot; &quot;green&quot; &quot;6&quot; &quot;blue&quot;] [:cubes &quot;2&quot; &quot;green&quot;]]}) but i have the big problem to get this 2 levels of nesting. Can anyone give me tip in which direction i should look?"><y>#</y><d>2023-12-14</d><h>09:38</h><w>nuriaion</w>Hi
I&apos;m using Advent of Code to learn Clojure and meander. In the i&apos;m trying to parse the input of day 2 and get the following:
<pre>[:S
 [:game
  [:id &quot;1&quot;]
  [:draws
   [:draw
    [:cubes &quot;3&quot; &quot;blue&quot; &quot;4&quot; &quot;red&quot;]
    [:cubes &quot;1&quot; &quot;red&quot; &quot;2&quot; &quot;green&quot; &quot;6&quot; &quot;blue&quot;]
    [:cubes &quot;2&quot; &quot;green&quot;]]]]]</pre>
which i want to transform to:
<pre>{:id &quot;1&quot;,
 :draws
 [[{:number &quot;3&quot;, :color &quot;blue&quot;}
   {:number &quot;3&quot;, :color &quot;blue&quot;}]
  [{:number &quot;1&quot;, :color &quot;red&quot;}
   {:number &quot;2&quot;, :color &quot;green&quot;}
   {:number &quot;6&quot;, :color &quot;blue&quot;}]
  [{:number &quot;2&quot;, :color &quot;green&quot;}]]}</pre>
So far i tried with:
<pre>(m/rewrites parsed
      [:S
       [:game
        [:id ?id]
        [:draws
         [:draw [:cubes . !n !c ..1] ..1 &amp; ?rest]]]]
      {:id ?id
       :draws [{:draw [{:number !n :color !c}]} ...]
       :rest ?rest})))</pre>
which result in:
<pre>({:id &quot;1&quot;,
  :draws
  [{:draw [{:number &quot;3&quot;, :color &quot;blue&quot;}]}
   {:draw [{:number &quot;4&quot;, :color &quot;red&quot;}]}],
  :rest
  [[:cubes &quot;1&quot; &quot;red&quot; &quot;2&quot; &quot;green&quot; &quot;6&quot; &quot;blue&quot;] [:cubes &quot;2&quot; &quot;green&quot;]]})</pre>
but i have the big problem to get this 2 levels of nesting. Can anyone give me tip in which direction i should look?</z><z id="t1703631133" t="noprompt I know this is 12 days later (I&apos;ve been too busy with work took keep with the channel) but my recommendation is to break things like this down in to smaller rules and use m/cata to rewrite the structure recursively: (m/rewrite parsed [:S [:game [:id ?id] [:draws [:draw &amp; [(m/cata !draws) ...]]]]] {:id ?id :draws [!draws ...]} [:cubes &amp; [!number !color ...]] [{:number !number, :color !color} ...]) "><y>#</y><d>2023-12-26</d><h>22:52</h><r>noprompt</r>I know this is 12 days later (I&apos;ve been too busy with work took keep with the channel) but my recommendation is to break things like this down in to smaller rules and use <code>m/cata</code> to rewrite the structure recursively:

<pre>(m/rewrite parsed
  [:S
   [:game
    [:id ?id]
    [:draws
     [:draw &amp; [(m/cata !draws) ...]]]]]
  {:id ?id :draws [!draws ...]}

  [:cubes &amp; [!number !color ...]]
  [{:number !number, :color !color} ...])</pre>
</z><z id="t1704787676" t="nuriaion Thanks for your replay, in the end i also found cata. Nice to see that&apos;s the way to go 🙂"><y>#</y><d>2024-01-09</d><h>08:07</h><r>nuriaion</r>Thanks for your replay, in the end i also found cata. Nice to see that&apos;s the way to go <b>🙂</b></z><z id="t1704100345" t="Pranav Ram Given a tree with a root node and children as :successors, is there a better way than tree-seq to pull out all the &quot;nodes&quot; into something like this? (def initial-nodes [{:id &quot;1&quot; :position {:x 0 :y 0} :data {:label &quot;1&quot;}} {:id &quot;2&quot; :position {:x 0 :y 100} :data {:label &quot;2&quot;}}]) I&apos;m using the current method: (defn tree-nodes [tree] (tree-seq (fn [node] (seq (:successors node))) ; Branching function: checks if a node has successors :successors ; Children function: gets the successors of a node tree)) ; The tree to traverse (def hierarchy-nodes (-&gt;&gt; (tree-nodes sa-hierarchy) (map #(dissoc % :successors)) (map (fn [node] {:id (:id node) :position {:x 0 :y 0} :data (assoc node :label (:name node))})))) Follow up, given the following structure: (def initial-nodes [{:id &quot;1&quot; :position {:x 0 :y 0} :data {:label &quot;1&quot;}} {:id &quot;2&quot; :position {:x 0 :y 100} :data {:label &quot;2&quot;}}]) (def initial-edges [{:id &quot;e1-2&quot; :source &quot;1&quot; :target &quot;2&quot;}]) Can it be put back into the tree. Using the previous snippet you shared, I&apos;m able to get the initial-edges created. Just need to figure how to get the nodes and put back the nodes and edges into the tree again via meander. Code for get the edges from the original tree: (defn extract-source-destination-from-hierachy [input] (-&gt;&gt; (m/search input {:id ?id :successors (m/scan {:successors _ &amp; ?without-children})} {:id (str ?id &quot;-|-&quot; (:id ?without-children)) :source ?id :target (:id ?without-children)} {:successors (m/scan (m/cata ?child))} ?child) (into []))) (def hierarchy-edges (extract-source-destination-from-hierachy sa-hierarchy))"><y>#</y><d>2024-01-01</d><h>09:12</h><w>Pranav Ram</w>Given a tree with a root node and children as :successors, is there a better way than tree-seq to pull out all the &quot;nodes&quot; into something like this?

<pre>(def initial-nodes
  [{:id &quot;1&quot; :position {:x 0 :y 0} :data {:label &quot;1&quot;}}
   {:id &quot;2&quot; :position {:x 0 :y 100} :data {:label &quot;2&quot;}}])</pre>

I&apos;m using the current method:

<pre>(defn tree-nodes [tree]
  (tree-seq
   (fn [node] (seq (:successors node))) ; Branching function: checks if a node has successors
   :successors                           ; Children function: gets the successors of a node
   tree))                                ; The tree to traverse

(def hierarchy-nodes (-&gt;&gt; (tree-nodes sa-hierarchy)
                          (map #(dissoc % :successors))
                          (map (fn [node] {:id (:id node) :position {:x 0 :y 0} :data (assoc node :label (:name node))}))))</pre>
Follow up, given the following structure:

<pre>(def initial-nodes
  [{:id &quot;1&quot; :position {:x 0 :y 0} :data {:label &quot;1&quot;}}
   {:id &quot;2&quot; :position {:x 0 :y 100} :data {:label &quot;2&quot;}}])

(def initial-edges
  [{:id &quot;e1-2&quot; :source &quot;1&quot; :target &quot;2&quot;}])</pre>
Can it be put back into the tree. Using the previous snippet you shared, I&apos;m able to get the initial-edges created. Just need to figure how to get the nodes and put back the nodes and edges into the tree again via meander.

Code for get the edges from the original tree:

<pre>(defn extract-source-destination-from-hierachy [input]
  (-&gt;&gt; (m/search input
                 {:id ?id
                  :successors (m/scan {:successors _ &amp; ?without-children})}
                 {:id (str ?id &quot;-|-&quot; (:id ?without-children)) :source ?id :target (:id ?without-children)}

                 {:successors (m/scan (m/cata ?child))}
                 ?child)
       (into [])))

(def hierarchy-edges
  (extract-source-destination-from-hierachy sa-hierarchy))</pre></z><z id="t1707820263" t="Tommi Martin Could someone point me in the right direction with Meander as I try to learn it. Is there a way of matching both map and sub map data in a manner that returns a combined result? Essentially I have a case of {:important-key1 &quot;test&quot; :important-key2 &quot;test2&quot; :useless-key1 &quot;&quot; :useless-map {} :subservices {:dynamic-name1 {:important-key &quot;&quot; :useless-key2 &quot;&quot; :dynamic-name2 {:important-key &quot;&quot; :useless-key2 &quot;&quot;}}}} Actual data is a lot more complex than that. But the structure is the same. I would like to cherry pick the important keys from the data using meander, in the example given it would just drop the useless keys and retain other things. Am I going the wrong way for trying to figure out a meander query that I can use that returns everything with a single match that I wouldn&apos;t have to merge the results of meander outside of it? The real use-case would take similar data to the above one, but create several new keys to the root based on the dynamic-name1 and 2. But one step at a time. Am I going wrong with Meander here?"><y>#</y><d>2024-02-13</d><h>10:31</h><w>Tommi Martin</w>Could someone point me in the right direction with Meander as I try to learn it.
Is there a way of matching both map and sub map data in a manner that returns a combined result?

Essentially I have a case of
<pre>{:important-key1 &quot;test&quot;
 :important-key2 &quot;test2&quot;
 :useless-key1 &quot;&quot;
 :useless-map {}
 :subservices {:dynamic-name1 {:important-key &quot;&quot;
                               :useless-key2 &quot;&quot;
               :dynamic-name2 {:important-key &quot;&quot;
                               :useless-key2 &quot;&quot;}}}}</pre>
Actual data is a lot more complex than that. But the structure is the same.
I would like to cherry pick the important keys from the data using meander, in the example given it would just drop the useless keys and retain other things. Am I going the wrong way for trying to figure out a meander query that I can use that returns everything with a single match that I wouldn&apos;t have to merge the results of meander outside of it?

The real use-case would take similar data to the above one, but create several new keys to the root based on the dynamic-name1 and 2. But one step at a time. Am I going wrong with Meander here?</z><z id="t1707868725" t="Jimmy Miller Not solving your exact case here. But hopefully something useful in this post. https://jimmyhmiller.github.io/meander-practical If you are wanting one result m/rewrite is probably best to focus on. On mobile so sadly can’t write an example. "><y>#</y><d>2024-02-13</d><h>23:58</h><r>Jimmy Miller</r>Not solving your exact case here. But hopefully something useful in this post. <a href="https://jimmyhmiller.github.io/meander-practical" target="_blank">https://jimmyhmiller.github.io/meander-practical</a>

If you are wanting one result m/rewrite is probably best to focus on. On mobile so sadly can’t write an example. </z><z id="t1707984126" t="Tommi Martin Thank you for the examples there, I wasn&apos;t able to get the system quite where I wanted it to be yet but I am getting close with rewrite. It&apos;s slow going and needs more input adjustment. This might take me a hot minute to learn. Currently the challenge holding me back is the questions: how to iterate over a map of objects indexed by name with rewrites. Or how to manipulate rewrite&apos;s [{:important-key ?key} ...] syntax to return a value indexed map instead of a vector. Definately bit more than my skills could handle when I decided to try meander. I&apos;ll get back to you if I figure out a way of doing the above or make a workaround. Edit: My current out is a vector of subservices without key indexes. This isn&apos;t enough because I need to merge values from another datasource into the subservices by their name but it&apos;s closer."><y>#</y><d>2024-02-15</d><h>08:02</h><r>Tommi Martin</r>Thank you for the examples there, I wasn&apos;t able to get the system quite where I wanted it to be yet but I am getting close with rewrite. It&apos;s slow going and needs more input adjustment. This might take me a hot minute to learn. Currently the challenge holding me back is the questions: how to iterate over a map of objects indexed by name with rewrites. Or how to manipulate rewrite&apos;s <code>[{:important-key ?key} ...]</code>  syntax to return a value indexed map instead of a vector.

Definately bit more than my skills could handle when I decided to try meander. I&apos;ll get back to you if I figure out a way of doing the above or make a workaround.

Edit: My current out is a vector of subservices without key indexes. This isn&apos;t enough because I need to merge values from another datasource into the subservices by their name but it&apos;s closer.</z><z id="t1707992727" t="Tommi Martin Cracked it, here is the final result that allows me to work with the data in a way I wanted to.: (meander/rewrite (mu/decode &quot;application/json&quot; (slurp &quot;test/app/fixtures/simple.json&quot;)) {:payload {:name ?name :composite ?composite :type ?type :datasources [{:name (meander/and !name !index) :replicator {:version !version}} ...]}} {(meander/keyword ?name) {:name ?name :composite ?composite :type ?type :datasources {&amp; ([(meander/keyword !index) {:name !name :replicator {:version !version}}] ...)}}}) With an input of payload object with a datasources being a vector it spits out a name indexed map of the sub services. It&apos;s not the ideal solution since the input needs to be a map with a vector instead of a map with a submap. But at this point I&apos;ll take my victory and call it for this round. I can make it work. The solution to my problems is in how the datasources lines are being manipulated and rewritten."><y>#</y><d>2024-02-15</d><h>10:25</h><r>Tommi Martin</r>Cracked it, here is the final result that allows me to work with the data in a way I wanted to.:
<pre>(meander/rewrite
   (mu/decode &quot;application/json&quot; (slurp &quot;test/app/fixtures/simple.json&quot;))
   {:payload {:name ?name
              :composite ?composite
              :type ?type
              :datasources [{:name (meander/and !name !index) :replicator {:version !version}} ...]}}
   {(meander/keyword ?name) {:name ?name
                             :composite ?composite
                             :type ?type
                             :datasources {&amp; ([(meander/keyword !index) {:name !name :replicator {:version !version}}] ...)}}})</pre>
With an input of payload object with a datasources being a vector it spits out a name indexed map of the sub services. It&apos;s not the ideal solution since the input needs to be a map with a vector instead of a map with a submap. But at this point I&apos;ll take my victory and call it for this round. I can make it work. The solution to my problems is in how the datasources lines are being manipulated and rewritten.</z><z id="t1709119703" t="Tommi Martin In a case where I have vector of maps, each of those vectors houses another vector of maps. How should I collect and operate the sub vector and it&apos;s maps. so that Maps on the first level are transformed, and the submaps are transformed? My current code ( in thread ) doesn&apos;t work. as when I try to output it, the expression merges all the subvector&apos;s maps into a single vector and does, preventing repeat of the parent map. I&apos;m feeling I should be able to do a partition based on the parent map somehow but I cannot get the expression right."><y>#</y><d>2024-02-28</d><h>11:28</h><w>Tommi Martin</w>In a case where I have vector of maps, each of those vectors houses another vector of maps.
How should I collect and operate the sub vector and it&apos;s maps. so that Maps on the first level are transformed, and the submaps are transformed?
My current code ( in thread ) doesn&apos;t work. as when I try to output it, the expression merges all the subvector&apos;s maps into a single vector and does, preventing repeat of the parent map. I&apos;m feeling I should be able to do a partition based on the parent map somehow but I cannot get the expression right.</z><z id="t1709120532" t="Tommi Martin Never-mind. the answer is ..!n instead of ... I&apos;m sorry to have bothered over nothing. It seems to retain the parent relationship."><y>#</y><d>2024-02-28</d><h>11:42</h><w>Tommi Martin</w>Never-mind. the answer is <code>..!n</code> instead of <code>...</code> I&apos;m sorry to have bothered over nothing.
It seems to retain the parent relationship.</z><z id="t1709764556" t="hlship I&apos;m pretty new to Meander, but I have some pretty straight-forward use cases; I&apos;m having trouble understanding how to express them. Basic example; for this input: {:widget/id &quot;xyz&quot; :widget/manufacturer {:company/name &quot;Widget Co.&quot;} :widget/parts [{:part/id 123 :part/location {:bin/id 23}} {:part/id 456 :part/location {:bin/id 97}}]} I&apos;d like to fold/spindle/mutilate to: {:widget-id &quot;xyz&quot; :manufacturer-name &quot;Widget Co.&quot; :parts [{:id 123 :bin 23} {:id 456 :bin 97}]} I&apos;m at a loss for how to handle transforming the :widget/parts key. And I&apos;d prefer a solution where I can adapt it to a case where I&apos;m converting multiple widgets, not just one."><y>#</y><d>2024-03-06</d><h>22:35</h><w>hlship</w>I&apos;m pretty new to Meander, but I have some pretty straight-forward use cases; I&apos;m having trouble understanding how to express them.

Basic example; for this input:

<pre>{:widget/id           &quot;xyz&quot;
 :widget/manufacturer {:company/name &quot;Widget Co.&quot;}
 :widget/parts        [{:part/id       123
                        :part/location {:bin/id 23}}
                       {:part/id       456
                        :part/location {:bin/id 97}}]}</pre>
I&apos;d like to fold/spindle/mutilate to:

<pre>{:widget-id         &quot;xyz&quot;
 :manufacturer-name &quot;Widget Co.&quot;
 :parts             [{:id  123
                      :bin 23}
                     {:id  456
                      :bin 97}]}</pre>
I&apos;m at a loss for how to handle transforming the :widget/parts key.    And I&apos;d prefer a solution where I can adapt it to a case where I&apos;m converting multiple widgets, not just one.</z><z id="t1709766337" t="markaddleman Here’s a solution"><y>#</y><d>2024-03-06</d><h>23:05</h><r>markaddleman</r>Here’s a solution</z><z id="t1709766391" t="markaddleman This is a slightly better one"><y>#</y><d>2024-03-06</d><h>23:06</h><r>markaddleman</r>This is a slightly better one</z><z id="t1709766633" t="markaddleman To explain some of the non-obvious pieces of the solution: • m/some is used to ensure that the key exists in the map. Without it, meander might match the wrong map. • Handling the vector of widget parts is a bit magicky. First, we capture each element of the vector into the memory variable !widget-part . During expansion, we try rewriting each element of the vector against the matching rules. The first match rule fails (because of the m/some keys don’t match). The second rule matches and returns the rewritten data."><y>#</y><d>2024-03-06</d><h>23:10</h><r>markaddleman</r>To explain some of the non-obvious pieces of the solution:
• <code>m/some</code> is used to ensure that the key exists in the map.  Without it, meander might match the wrong map.
• Handling the vector of widget parts is a bit magicky.  First, we capture each element of the vector into the memory variable <code>!widget-part</code> .  During expansion, we try rewriting each element of the vector against the matching rules.  The first match rule fails (because of the <code>m/some</code> keys don’t match).  The second rule matches and returns the rewritten data.</z><z id="t1709766743" t="hlship Is there something like cata , but I specify the rules right there? That would eliminate the m/some calls if I&apos;m following you."><y>#</y><d>2024-03-06</d><h>23:12</h><r>hlship</r>Is there something like <code>cata</code>, but I specify the rules right there?  That would eliminate the m/some calls if I&apos;m following you.</z><z id="t1709766806" t="hlship i.e., can I use m/rewrite inline?"><y>#</y><d>2024-03-06</d><h>23:13</h><r>hlship</r>i.e., can I use m/rewrite inline?</z><z id="t1709766818" t="markaddleman Kind of. You can create a separate function which calls m/rewrite"><y>#</y><d>2024-03-06</d><h>23:13</h><r>markaddleman</r>Kind of.  You can create a separate function which calls m/rewrite</z><z id="t1709766823" t="markaddleman One sec and I’ll show you"><y>#</y><d>2024-03-06</d><h>23:13</h><r>markaddleman</r>One sec and I’ll show you</z><z id="t1709766828" t="hlship Thanks!"><y>#</y><d>2024-03-06</d><h>23:13</h><r>hlship</r>Thanks!</z><z id="t1709766864" t="hlship Would you consider what I&apos;m doing a common use case? I think anyone getting Datomic data out on the wire would 😉"><y>#</y><d>2024-03-06</d><h>23:14</h><r>hlship</r>Would you consider what I&apos;m doing a common use case?  I think anyone getting Datomic data out on the wire would <b>😉</b></z><z id="t1709766894" t="markaddleman Here’s an example of “inline” rewrite"><y>#</y><d>2024-03-06</d><h>23:14</h><r>markaddleman</r>Here’s an example of “inline” rewrite</z><z id="t1709766936" t="markaddleman The m/app is necessary because the rewrite macro assumes it’s own micro-language on the right-hand side of the rewrite rule."><y>#</y><d>2024-03-06</d><h>23:15</h><r>markaddleman</r>The <code>m/app</code> is necessary because the <code>rewrite</code> macro assumes it’s own micro-language on the right-hand side of the rewrite rule.</z><z id="t1709766950" t="markaddleman In this case, it would be more straightforward to write this code using m/find"><y>#</y><d>2024-03-06</d><h>23:15</h><r>markaddleman</r>In this case, it would be more straightforward to write this code using <code>m/find</code></z><z id="t1709766965" t="markaddleman It’s just that I normally reach for m/rewrite because it’s so compact and powerful."><y>#</y><d>2024-03-06</d><h>23:16</h><r>markaddleman</r>It’s just that I normally reach for <code>m/rewrite</code> because it’s so compact and powerful.</z><z id="t1709766977" t="markaddleman As for common use case: Yes! I use meander like this all the time."><y>#</y><d>2024-03-06</d><h>23:16</h><r>markaddleman</r>As for common use case:  Yes!  I use meander like this all the time.</z><z id="t1709767030" t="markaddleman As an advanced use case, I will occasionally dynamically generate rewrite rules using the meander strategy namespace."><y>#</y><d>2024-03-06</d><h>23:17</h><r>markaddleman</r>As an advanced use case, I will occasionally dynamically generate rewrite rules using the meander strategy namespace.</z><z id="t1709767119" t="markaddleman Here’s an example of using m/find instead of m/rewrite"><y>#</y><d>2024-03-06</d><h>23:18</h><r>markaddleman</r>Here’s an example of using <code>m/find</code> instead of <code>m/rewrite</code></z><z id="t1709767147" t="markaddleman (oh, you’re right, btw, in these last couple of examples the m/some are not necessary)"><y>#</y><d>2024-03-06</d><h>23:19</h><r>markaddleman</r>(oh, you’re right, btw, in these last couple of examples the <code>m/some</code> are not necessary)</z><z id="t1709767664" t="hlship I&apos;m happy with this: (def widget {:widget/id &quot;xyz&quot; :widget/manufacturer {:company/name &quot;Widget Co.&quot;} :widget/parts [{:part/id 123 :part/location {:bin/id 23}} {:part/id 456 :part/location {:bin/id 97}}]}) (defn- rewrite-widget-part [part] (m/match part {:part/id ?part-id :part/location {:bin/id ?bin-id}} {:id ?part-id :bin ?bin-id})) (m/rewrite widget {:widget/id ?id :widget/manufacturer {:company/name ?company-name} :widget/parts [(m/app rewrite-widget-part !widget-parts) ...]} {:widget-id ?id :manufacturer-name ?company-name :parts [!widget-parts ...]}) But it feels like there could be some syntax sugar instead of the m/app call."><y>#</y><d>2024-03-06</d><h>23:27</h><r>hlship</r>I&apos;m happy with this:

<pre>(def widget {:widget/id           &quot;xyz&quot;
             :widget/manufacturer {:company/name &quot;Widget Co.&quot;}
             :widget/parts        [{:part/id       123
                                    :part/location {:bin/id 23}}
                                   {:part/id       456
                                    :part/location {:bin/id 97}}]})

(defn- rewrite-widget-part [part]
  (m/match part
           {:part/id       ?part-id
            :part/location {:bin/id ?bin-id}}
           {:id  ?part-id
            :bin ?bin-id}))

(m/rewrite widget
           {:widget/id           ?id
            :widget/manufacturer {:company/name ?company-name}
            :widget/parts        [(m/app rewrite-widget-part !widget-parts) ...]}
           {:widget-id         ?id
            :manufacturer-name ?company-name
            :parts             [!widget-parts ...]})</pre>
But it feels like there could be some syntax sugar instead of the m/app call.</z><z id="t1709767742" t="hlship Thanks for the help!"><y>#</y><d>2024-03-06</d><h>23:29</h><r>hlship</r>Thanks for the help!</z><z id="t1709767759" t="markaddleman Sure thing!"><y>#</y><d>2024-03-06</d><h>23:29</h><r>markaddleman</r>Sure thing!</z><z id="t1709767862" t="hlship Strawman: (m/rewrite widget {:widget/id ?id :widget/manufacturer {:company/name ?company-name} :widget/parts [(m/each !widget-parts {:part/id ?part-id :part/location {:bin/id ?bin-id}} {:id ?part-id :bin ?bin-id}) ...]} {:widget-id ?id :manufacturer-name ?company-name :parts [!widget-parts ...]})"><y>#</y><d>2024-03-06</d><h>23:31</h><r>hlship</r>Strawman:

<pre>(m/rewrite widget
           {:widget/id           ?id
            :widget/manufacturer {:company/name ?company-name}
            :widget/parts        [(m/each !widget-parts
                                          {:part/id       ?part-id
                                           :part/location {:bin/id ?bin-id}}
                                          {:id  ?part-id
                                           :bin ?bin-id}) ...]}
           {:widget-id         ?id
            :manufacturer-name ?company-name
            :parts             [!widget-parts ...]})</pre></z><z id="t1709765901" t="hlship I don&apos;t have. a feel for how you combine the pieces."><y>#</y><d>2024-03-06</d><h>22:58</h><w>hlship</w>I don&apos;t have. a feel for how you combine the pieces.</z><z id="t1711235367" t="andersmurphy (m/search [:article [:div [:nav [:div [:p &quot;foo&quot;] [:p &quot;foo&quot;]]]] [:div [:div [:p &quot;foo&quot;]]]] [:article . _ ... (m/$ [(m/not :nav) . _ ... (m/$ [:p &amp; _ :as ?el]) . _ ...]) . _ ...] ?el) I’m trying to get all the :p tags that are not descendants of :nav tags. I’m using m/not and I understand why it doesn’t work, because it can be satisfied with a :div tag before it sees a :nav tag. Effectively, what I’m looking for is m/never that makes m/$ not return a match if it encounters a :nav tag. Is there some mechanism/operator in Meander to achieve this? Basically, how would you write “never a descendant of” in meander. Thanks."><y>#</y><d>2024-03-23</d><h>23:09</h><w>andersmurphy</w><pre>(m/search [:article
           [:div
            [:nav
             [:div
              [:p &quot;foo&quot;]
              [:p &quot;foo&quot;]]]]
           [:div
            [:div
             [:p &quot;foo&quot;]]]]
  [:article
   . _ ...
   (m/$ [(m/not :nav)
         . _ ...
         (m/$ [:p &amp; _ :as ?el])
         . _ ...])
   . _ ...]
  ?el)</pre>
I’m trying to get all the <code>:p</code> tags that are not descendants of <code>:nav</code> tags. I’m using <code>m/not</code> and I understand why it doesn’t work, because it can be satisfied with a <code>:div</code> tag before it sees a <code>:nav</code> tag.

Effectively, what I’m looking for is <code>m/never</code> that  makes <code>m/$</code> not return a match if it encounters a <code>:nav</code> tag.

Is there some mechanism/operator in Meander to achieve this?

Basically, how would you write “never a descendant of” in meander.

Thanks.</z></g></div></body>