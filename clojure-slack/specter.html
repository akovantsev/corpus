<!DOCTYPE html>
<head><title>specter</title><meta charset="UTF-8" /><style type="text/css">body {
    font-family: Monaco, Menlo, Consolas, "Courier New", sans-serif;
    font-size: 12px;
    margin: 15px;
}
h2 {text-align: center}
pre,
code {
    font-family: Monaco, Menlo, Consolas, "Courier New", monospace;
    color: #333;
    line-break: anywhere;
}
a {
    line-break: anywhere;
}
code {
    /*line-height: 1.2;*/
    white-space: normal;
    color: #c25;
    background-color: #f7f7f9;
    border: 1px solid #e1e1e8;
}
pre {
    margin: .5rem 0 .2rem;
    font-size: .75rem;
    /*line-height: 1.15rem;*/
    background: #fbfaf8;
    padding: .5rem;
    word-break: normal;
    display: block;
    border: 1px solid rgba(0, 0, 0, .15);
    white-space: pre-wrap;
    word-wrap: break-word;
    border-radius: 4px;
}
/*span {*/
z {
    white-space: pre-wrap;
}

d {padding-right: 8px;}
h {padding-right: 16px;}

w, r {
    margin-right: 10px;
    padding-right: 8px;
    text-align: right;
}

d,h,w,r {
    background-color: lavender;
    margin-top: 1px;
    display: inline-table; /* prevents doubleclick selection spillover into neighbour elements */
}

h:hover,
d:hover {
    text-decoration: underline;
    color: blue;
    cursor: row-resize;
}
d {padding-right: 8px;}
h {padding-right: 16px;}

z {display: block;}

z:target > r,
z:target > w,
z:target > d,
z:target > h {
    background-color: aquamarine
}

#filters-container {
    position: fixed;
    left: 50px;
    z-index: 1;
}
#filters-container > input {
    /*column:*/
    display: block;
    outline-color: aquamarine;
}

y {
    cursor: pointer;
    text-decoration: none;
    color: blue;
    position: absolute;
    left: 3px;
}

y:hover {
    text-decoration: underline;
    color: aquamarine;
}


</style></head><body><style id="css-username">w {min-width: 160px;} r {min-width: 192px;}</style><style id="css-text-filter"></style><style id="css-date-filter"></style><style id="css-filter-override"></style><p id="filters-container"><input id="text-filter" onkeyup="debtextfilter(this.value)" placeholder="filter text" type="string" /><button hidden="hidden" id="date-filter" onclick="cleardatefilter()"></button></p><h2>#specter</h2><pre><i>generated UTC: 2022-12-24 21:35</i><i>
latest data: <a href="https://clojurians-log.clojureverse.org/specter/2022-11-27">https://clojurians-log.clojureverse.org/specter/2022-11-27</a></i><i>
messages: 7695</i>
pro tips:
* Double click on text to filter by it. (doubleclick + cmd-f for extra points).
* Click on date to keep day visible regardless of filter.
* Click on time to keep hour visible regardless of filter.</pre><script>const textFilterInput = document.getElementById("text-filter");
const dateFilterInput = document.getElementById("date-filter");
const filterTextStyle = document.getElementById("css-text-filter");
const filterDateStyle = document.getElementById("css-date-filter");
const filterStyleOverride = document.getElementById("css-filter-override");



function textFilter2(text) {
    var style = '';
    if (text.trim() !== '') {
        text.split(' ').forEach(function (t) {
            if (t !== '') {
                style = style + "z:not([t*='" + t + "' i]) {display: none; opacity: 0.6}";
            }
        });
    }
    filterTextStyle.innerHTML = style;
}
function textFilter(text) {
    filterTextStyle.innerHTML = "";
    if (text.trim() !== '') {
        var sections = document.getElementsByTagName("g");
        var sectionsArr = Array.prototype.slice.call(sections);
        sectionsArr.forEach(function (s){
            var sid = s.getAttribute("id");
            text.split(' ').forEach(function (t) {
                if (t !== '') {
                    filterTextStyle.innerHTML += "\nw#" + sid + " > z:not([t*='" + t + "' i]) {display: none; opacity: 0.6}";
                }
            });
        })
    }
}
function textFilter3(text) {
    console.time("text search");
    filterTextStyle.innerHTML = "";
    if (text.trim() !== '') {
        const re = new RegExp( text, "i");
        var sections = document.getElementsByTagName("g");
        var sectionsArr = Array.prototype.slice.call(sections);
        sectionsArr.forEach(function (w){
            var zs = w.getElementsByTagName ("z");
            var zsArr = Array.prototype.slice.call(zs);
            var ids = zsArr
                .filter(function (el) {
                    return !re.test(el.innerText);
                })
                .map(function (el){
                    return el.getAttribute("id");
                });
            if (ids) {
                filterTextStyle.innerHTML += "\n#" + ids.join(",#") + " {display: none; opacity: 0.6}";
            }
        })
    }
    console.timeEnd("text search");
}


function filterSelection (e) {
    let sel = document.getSelection();
    let txt = sel.toString();
    textFilterInput.value = (txt || "");
    textFilter(txt);
}
function debounce1(callback, delay) {
    let timeout;
    return function(arg) {
        clearTimeout(timeout);
        timeout = setTimeout(callback, delay, arg);
    }
}

function keyUp (e) {
    if (e.code === "KeyF" && e.ctrlKey) {
        let txt = document.getSelection().toString();
        if (txt.length > 0) {
            textFilterInput.value = (txt || "");
            textFilter(txt);
        }
    }
}


function showDateTimes (el, datestr, hourstr) {
    dateFilterInput.innerText = "clear: " + datestr + " " + hourstr;
    dateFilterInput.hidden = false;
    let ids = [];
    const clicked = el.parentElement;  // el = z#id/t
    ids.push(clicked.id);
    // var idbefore, idafter;
    let cursor = clicked;
    function nextCursor (cursor) {
        const id = (cursor && cursor.id);
        const d = (cursor && cursor.children[1]);
        const h = (cursor && cursor.children[2])
        if (id) {
            ids.push(id); //includes 1st next-id not matching date.
        } else {
            cursor = null;
        }
        if (d && (d.textContent === datestr) && (!hourstr || (h && h.textContent.startsWith(hourstr)))) {
        } else {
            cursor = null;
        }
        return cursor;
    }
    while (cursor) {
        cursor = nextCursor(cursor.previousElementSibling);
    }

    cursor = clicked;

    while (cursor) {
        cursor = nextCursor(cursor.nextElementSibling);
    }


    var style1 = '';
    var style2 = '';
    var content;
    if (datestr.includes(" ")) { //hour
        content = " *";
    } else {
        content = "**";
    }
    ids.forEach(function (id) {
        if (id) {
            style1 = style1 + ", #" + id;
            style2 = style2 + ", #" + id + " h:after";
        }
    })
    if (style1) {
        style1 = style1.substring(1) + " {display: block !important}";
    }
    if (style2) {
        style2 = style2.substring(1) + " {content: \"" + content + "\"; position: absolute}"
    }
    filterDateStyle.innerHTML = style1 + "\n" + style2;
}

// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView
function filterDay (el) {
    showDateTimes(el, el.textContent);
    el.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
}

function filterHours (el) {
    showDateTimes(el, el.previousElementSibling.textContent, el.textContent.substring(0, 2));
    el.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
}

function forceShowSelected (el) {
    var id = el.parentElement.id
    if (id) {
        window.location.hash = "#" + id;
        filterStyleOverride.innerHTML = ""
            + "#" + id
            + " {display: block !important;}"
            + "#" + id + " h:after"
            + " {content: \"  #\"; position: absolute}";

    } else {
        window.location.hash = "";
        filterStyleOverride.innerHTML = "";
    }
}


function cleardatefilter () {
    dateFilterInput.hidden = true;
    dateFilterInput.innerText = "";
    filterDateStyle.innerHTML = "";
}

const debtextfilter = debounce1(textFilter, 200);

function doubleClick (e) {
    if (e.target.tagName !== "INPUT"
        && e.target.tagName !== "D"
        && e.target.tagName !== "H") {

        filterSelection();
        e.target.scrollIntoView({behavior: "auto", block: "center", inline: "start"});
    }
}

function onclick(e) {
    if (e.target.tagName === "Y") {
        e.preventDefault();
        forceShowSelected(e.target);
    } else if (e.target.tagName === "D") {
        e.preventDefault();
        filterDay(e.target);
    } else if (e.target.tagName === "H") {
        e.preventDefault();
        filterHours(e.target);
    }
}

document.onclick = onclick;
document.ondblclick = doubleClick;
document.onkeyup = keyUp;
textFilterInput.focus();
</script><div><g id="s0"><z id="t1449315226" t="sveri That logbot follows everywhere I go 😄"><y>#</y><d>2015-12-05</d><h>11:33</h><w>sveri</w>That logbot follows everywhere I go <b>😄</b></z><z id="t1449843506" t="exupero Is there a way with specter to transform the first element matching a predicate?"><y>#</y><d>2015-12-11</d><h>14:18</h><w>exupero</w>Is there a way with specter to transform the first element matching a predicate?</z><z id="t1449843777" t="sveri @exupero: I had this working for me:"><y>#</y><d>2015-12-11</d><h>14:22</h><w>sveri</w>@exupero: I had this working for me:</z><z id="t1449843791" t="sveri (spec/transform [:new-entity :columns spec/ALL #(= (:id %) id)] #(assoc % key val) @state)``"><y>#</y><d>2015-12-11</d><h>14:23</h><w>sveri</w><code></code>(spec/transform [:new-entity :columns spec/ALL #(= (:id %) id)]
                                      #(assoc % key val)
                                      @state)``</z><z id="t1449843815" t="sveri I guess if you switch ALL by FIRST it will only transform the first met one"><y>#</y><d>2015-12-11</d><h>14:23</h><w>sveri</w>I guess if you switch ALL by FIRST it will only transform the first met one</z><z id="t1449844200" t="exupero Using FIRST pred seems to get the first item in the sequence, then filter it on whether it satisfies the predicate."><y>#</y><d>2015-12-11</d><h>14:30</h><w>exupero</w>Using <code>FIRST pred</code> seems to get the first item in the sequence, then filter it on whether it satisfies the predicate.</z><z id="t1449844216" t="exupero Essentially I want ALL pred FIRST ."><y>#</y><d>2015-12-11</d><h>14:30</h><w>exupero</w>Essentially I want <code>ALL pred FIRST</code>.</z><z id="t1449844244" t="exupero But that gives the error Vector’s key for assoc must be a number."><y>#</y><d>2015-12-11</d><h>14:30</h><w>exupero</w>But that gives the error <code>Vector’s key for assoc must be a number.</code></z><z id="t1451629574" t="onetom Is it just me, or neither the intro article, nor the README on github mentions what namespace specter is using?"><y>#</y><d>2016-01-01</d><h>06:26</h><w>onetom</w>Is it just me, or neither the intro article, nor the README on github mentions what namespace specter is using?</z><z id="t1451630336" t="onetom Is it a convention if the namespace is not mentioned, then it&apos;s the same as the group/artifact-id?"><y>#</y><d>2016-01-01</d><h>06:38</h><w>onetom</w>Is it a convention if the namespace is not mentioned, then it&apos;s the same as the group/artifact-id?</z><z id="t1451702307" t="escherize That threw me off too."><y>#</y><d>2016-01-02</d><h>02:38</h><w>escherize</w>That threw me off too.</z><z id="t1451747138" t="drusellers i just assumed it followed the java conventions."><y>#</y><d>2016-01-02</d><h>15:05</h><w>drusellers</w>i just assumed it followed the java conventions.</z><z id="t1451747156" t="drusellers i’m trying to use Spector in CLJS with React and getting an odd error"><y>#</y><d>2016-01-02</d><h>15:05</h><w>drusellers</w>i’m trying to use Spector in CLJS with React and getting an odd error</z><z id="t1451747163" t="drusellers No protocol method IReduce.-reduce defined for type om.core/IndexedCursor"><y>#</y><d>2016-01-02</d><h>15:06</h><w>drusellers</w><code>No protocol method IReduce.-reduce defined for type om.core/IndexedCursor</code></z><z id="t1451747169" t="drusellers when i try to query out a collection."><y>#</y><d>2016-01-02</d><h>15:06</h><w>drusellers</w>when i try to query out a collection.</z><z id="t1451919412" t="sveri @drusellers: Looks like you reduce on a different type than specter expects. Maybe try to turn it into a seq or vec before working on it with specter?"><y>#</y><d>2016-01-04</d><h>14:56</h><w>sveri</w>@drusellers: Looks like you reduce on a different type than specter expects. Maybe try to turn it into a seq or vec before working on it with specter?</z><z id="t1451919459" t="sveri Basically the message says that om.core/IndexedCursor does not implement the IReduce protocol and therefore cannot reduce on it"><y>#</y><d>2016-01-04</d><h>14:57</h><w>sveri</w>Basically the message says that om.core/IndexedCursor does not implement the IReduce protocol and therefore cannot reduce on it</z><z id="t1451947782" t="drusellers @sveri: fyi - https://github.com/nathanmarz/specter/issues/46"><y>#</y><d>2016-01-04</d><h>22:49</h><w>drusellers</w>@sveri: fyi - <a href="https://github.com/nathanmarz/specter/issues/46" target="_blank">https://github.com/nathanmarz/specter/issues/46</a></z><z id="t1452588284" t="meow boo 👻 :specter:"><y>#</y><d>2016-01-12</d><h>08:44</h><w>meow</w>boo <b>👻</b> <b>:specter:</b></z><z id="t1456953344" t="pdlug Is there a way to provide a default value when doing a transform ? I have a vector of maps and I’m looking to either modify the map found by a key or insert it if not found"><y>#</y><d>2016-03-02</d><h>21:15</h><w>pdlug</w>Is there a way to provide a default value when doing a <code>transform</code>? I have a vector of maps and I’m looking to either modify the map found by a key or insert it if not found</z><z id="t1457375755" t="hugobessaa Hey, hi!"><y>#</y><d>2016-03-07</d><h>18:35</h><w>hugobessaa</w>Hey, hi!</z><z id="t1457375771" t="hugobessaa I&apos;m using specter to filter a nested list"><y>#</y><d>2016-03-07</d><h>18:36</h><w>hugobessaa</w>I&apos;m using specter to filter a nested list</z><z id="t1457375784" t="hugobessaa Any way this could be better written?"><y>#</y><d>2016-03-07</d><h>18:36</h><w>hugobessaa</w>Any way this could be better written?</z><z id="t1457375849" t="hugobessaa (specter/transform [:profile-edit :navigation specter/ALL :anchors] (partial filter anchor-on-page?) db) "><y>#</y><d>2016-03-07</d><h>18:37</h><w>hugobessaa</w><pre>(specter/transform [:profile-edit :navigation specter/ALL :anchors]
                     (partial filter anchor-on-page?)
                     db)
</pre></z><z id="t1457379378" t="wei @hugobessaa: that’s how I would do it"><y>#</y><d>2016-03-07</d><h>19:36</h><w>wei</w>@hugobessaa: that’s how I would do it</z><z id="t1457379383" t="wei there might be a better way but I’m not sure"><y>#</y><d>2016-03-07</d><h>19:36</h><w>wei</w>there might be a better way but I’m not sure</z><z id="t1457380018" t="hugobessaa it would be nice if I could use a transducer with transform"><y>#</y><d>2016-03-07</d><h>19:46</h><w>hugobessaa</w>it would be nice if I could use a transducer with <code>transform</code></z><z id="t1458078819" t="alexisgallagher I have a basic specter question. I think I&apos;m just not understanding its fundamental concepts."><y>#</y><d>2016-03-15</d><h>21:53</h><w>alexisgallagher</w>I have a basic specter question. I think I&apos;m just not understanding its fundamental concepts.</z><z id="t1458078824" t="alexisgallagher Say I have a vector mymaps like so:"><y>#</y><d>2016-03-15</d><h>21:53</h><w>alexisgallagher</w>Say I have a vector <code>mymaps</code> like so:</z><z id="t1458078842" t="alexisgallagher (def mymaps [{:a 1 :b 2 :c {:d true}} {:a 2 :b 2 :c {:d false}} {:a 3 :b 2 :c {:d true}}])"><y>#</y><d>2016-03-15</d><h>21:54</h><w>alexisgallagher</w><pre>(def mymaps [{:a 1 :b 2 :c {:d true}}
               {:a 2 :b 2 :c {:d false}}
               {:a 3 :b 2 :c {:d true}}])</pre></z><z id="t1458078887" t="alexisgallagher And I want to select all the items where the nested map&apos;s :d&apos;s value is true. If I was using filter and get-in , I&apos;d just do it like so:"><y>#</y><d>2016-03-15</d><h>21:54</h><w>alexisgallagher</w>And I want to select all the items where the nested map&apos;s :d&apos;s value is true. If I was using <code>filter</code> and <code>get-in</code>, I&apos;d just do it like so:</z><z id="t1458078898" t="alexisgallagher (filter #(get-in % [:c :d]) mymaps)"><y>#</y><d>2016-03-15</d><h>21:54</h><w>alexisgallagher</w><pre>(filter #(get-in % [:c :d]) mymaps)</pre></z><z id="t1458078915" t="alexisgallagher How would I do this with specter?"><y>#</y><d>2016-03-15</d><h>21:55</h><w>alexisgallagher</w>How would I do this with specter?</z><z id="t1458078948" t="alexisgallagher I&apos;m supposing I should use the select operator, since I don&apos;t want to transform components of the original structure in place. I only want to select certain components within it."><y>#</y><d>2016-03-15</d><h>21:55</h><w>alexisgallagher</w>I&apos;m supposing I should use the <code>select</code> operator, since I don&apos;t want to transform components of the original structure in place. I only want to select certain components within it.</z><z id="t1458078984" t="alexisgallagher So, trivially, I could use select to pull out all the boolean values I want to test, by doing:"><y>#</y><d>2016-03-15</d><h>21:56</h><w>alexisgallagher</w>So, trivially, I could use select to pull out all the boolean values I want to test, by doing:</z><z id="t1458078988" t="alexisgallagher (select [ALL :c :d] mymaps)"><y>#</y><d>2016-03-15</d><h>21:56</h><w>alexisgallagher</w><pre>(select [ALL :c :d] mymaps)</pre></z><z id="t1458078996" t="alexisgallagher But this just gives me an array of booleans."><y>#</y><d>2016-03-15</d><h>21:56</h><w>alexisgallagher</w>But this just gives me an array of booleans.</z><z id="t1458079016" t="alexisgallagher If I want to use those values as a predicate to select the maps themselves, then ... ?"><y>#</y><d>2016-03-15</d><h>21:56</h><w>alexisgallagher</w>If I want to use those values as a predicate to select the maps themselves, then ... ?</z><z id="t1458245594" t="alexisgallagher Well, I see there&apos;s a talk on specter at the Conj. Maybe I&apos;ll fly to Seattle and figure out how to select with an embedded filtering condition there. 😜"><y>#</y><d>2016-03-17</d><h>20:13</h><w>alexisgallagher</w>Well, I see there&apos;s a talk on specter at the Conj. Maybe I&apos;ll fly to Seattle and figure out how to select with an embedded filtering condition there. <b>😜</b></z><z id="t1458302432" t="hugobessaa @alexisgallagher: I tried to do this myself last week. I ended up doing this:"><y>#</y><d>2016-03-18</d><h>12:00</h><w>hugobessaa</w>@alexisgallagher: I tried to do this myself last week. I ended up doing this:</z><z id="t1458302436" t="hugobessaa (specter/transform [:profile-edit :navigation specter/ALL :anchors] (partial filter anchor-on-page?) db) "><y>#</y><d>2016-03-18</d><h>12:00</h><w>hugobessaa</w><pre>(specter/transform [:profile-edit :navigation specter/ALL :anchors]
                     (partial filter anchor-on-page?)
                     db)
</pre></z><z id="t1458302485" t="hugobessaa anchor-on-page? is my predicate that test some nested data"><y>#</y><d>2016-03-18</d><h>12:01</h><w>hugobessaa</w><code>anchor-on-page?</code> is my predicate that test some nested data</z><z id="t1458302642" t="hugobessaa revisiting the docs, I think I found what you and I were looking for:"><y>#</y><d>2016-03-18</d><h>12:04</h><w>hugobessaa</w>revisiting the docs, I think I found what you and I were looking for:</z><z id="t1458302647" t="hugobessaa (transform [ALL (if-path [:a even?] [:c ALL] :d)] inc [{:a 2 :c [1 2] :d 4} {:a 4 :c [0 10 -1]} {:a -1 :c [1 1 1] :d 1}]) "><y>#</y><d>2016-03-18</d><h>12:04</h><w>hugobessaa</w><pre>(transform [ALL (if-path [:a even?] [:c ALL] :d)]
              inc
              [{:a 2 :c [1 2] :d 4} {:a 4 :c [0 10 -1]} {:a -1 :c [1 1 1] :d 1}])
</pre></z><z id="t1458342544" t="wei I would stick with filter /`get-in` in this case."><y>#</y><d>2016-03-18</d><h>23:09</h><w>wei</w>I would stick with <code>filter</code>/`get-in` in this case.</z><z id="t1458780570" t="alexisgallagher @hugobessaa: Interesting. I see my original question has been archived out of existence alas."><y>#</y><d>2016-03-24</d><h>00:49</h><w>alexisgallagher</w>@hugobessaa: Interesting. I see my original question has been archived out of existence alas.</z><z id="t1461447614" t="thomasdeutsch what is the specter equivalent of this? (map (fn [a b] ...) a-coll b-coll) (mapping over two seqs)"><y>#</y><d>2016-04-23</d><h>21:40</h><w>thomasdeutsch</w>what is the specter equivalent of this? <pre>(map (fn [a b] ...) a-coll b-coll) </pre>  (mapping over two seqs)</z><z id="t1461601114" t="tcoupland (select [:workflow ALL LAST keyword? #(= :inc %)] {:workflow [[:in :inc] [:inc :dbl] [:dbl :div] [:div [enough? :out :inc]]]}) =&gt; [:inc] "><y>#</y><d>2016-04-25</d><h>16:18</h><w>tcoupland</w><pre>(select [:workflow ALL LAST keyword? #(= :inc %)]
          {:workflow [[:in :inc]
                      [:inc :dbl]
                      [:dbl :div]
                      [:div [enough? :out :inc]]]}) =&gt; [:inc]
</pre></z><z id="t1461601143" t="tcoupland to my mind i shouldn&apos;t have to wrap the last element in the selector with a function, i should be able to just use &apos;:inc&apos;"><y>#</y><d>2016-04-25</d><h>16:19</h><w>tcoupland</w>to my mind i shouldn&apos;t have to wrap the last element in the selector with a function, i should be able to just use &apos;:inc&apos;</z><z id="t1461601162" t="tcoupland but if i do that i just be nil&apos;s"><y>#</y><d>2016-04-25</d><h>16:19</h><w>tcoupland</w>but if i do that i just be nil&apos;s</z><z id="t1461601170" t="tcoupland wld be interested to know why! simple_smile"><y>#</y><d>2016-04-25</d><h>16:19</h><w>tcoupland</w>wld be interested to know why! <b>simple_smile</b></z><z id="t1461707641" t="aengelberg @tcoupland: Specter doesn&apos;t know you mean to compare an element with :inc , it thinks you want to navigate to (:inc ...) which is nil for anything that isn&apos;t a map"><y>#</y><d>2016-04-26</d><h>21:54</h><w>aengelberg</w>@tcoupland: Specter doesn&apos;t know you mean to compare an element with <code>:inc</code>, it thinks you want to navigate to <code>(:inc ...)</code> which is nil for anything that isn&apos;t a map</z><z id="t1461707699" t="aengelberg (select [:a-keyword] ...) is syntactic sugar for (select [(keypath :a-keyword)] ...) in Specter"><y>#</y><d>2016-04-26</d><h>21:54</h><w>aengelberg</w><code>(select [:a-keyword] ...)</code> is syntactic sugar for <code>(select [(keypath :a-keyword)] ...)</code> in Specter</z><z id="t1461707736" t="tcoupland Aye, it feels very map centric sometimes"><y>#</y><d>2016-04-26</d><h>21:55</h><w>tcoupland</w>Aye, it feels very map centric sometimes</z><z id="t1461707814" t="tcoupland I made a little value-path path fn that does the trick nicely, works with parametrised comp-path"><y>#</y><d>2016-04-26</d><h>21:56</h><w>tcoupland</w>I made a little value-path path fn that does the trick nicely, works with parametrised comp-path</z><z id="t1463416589" t="mac Is it bad form to ask a question here which is a duplicate of an issue submitted to github?"><y>#</y><d>2016-05-16</d><h>16:36</h><w>mac</w>Is it bad form to ask a question here which is a duplicate of an issue submitted to github?</z><z id="t1463420703" t="nathanmarz @mac: just answered it on github"><y>#</y><d>2016-05-16</d><h>17:45</h><w>nathanmarz</w>@mac: just answered it on github</z><z id="t1463421247" t="mac @nathanmarz: Thanks a lot."><y>#</y><d>2016-05-16</d><h>17:54</h><w>mac</w>@nathanmarz:  Thanks a lot.</z><z id="t1463421269" t="mac Took the liberty of posting a followup 🙂"><y>#</y><d>2016-05-16</d><h>17:54</h><w>mac</w>Took the liberty of posting a followup <b>🙂</b></z><z id="t1463421933" t="mac @nathanmarz: I must be slow today - or in general. Why will (walker keyword?) pickup every keyword while (walker :c) only returns the top level map if :c occurs in it, even if the top level map contains children maps with :c as key?"><y>#</y><d>2016-05-16</d><h>18:05</h><w>mac</w>@nathanmarz: I must be slow today - or in general. Why will (walker keyword?) pickup every keyword while (walker :c) only returns the top level map if :c occurs in it, even if the top level map contains children maps with :c as key?</z><z id="t1463422214" t="nathanmarz The argument to walker is a predicate function"><y>#</y><d>2016-05-16</d><h>18:10</h><w>nathanmarz</w>The argument to walker is a predicate function</z><z id="t1463422229" t="nathanmarz So since the top-level map returns truthy when &quot;:c&quot; is run on it"><y>#</y><d>2016-05-16</d><h>18:10</h><w>nathanmarz</w>So since the top-level map returns truthy when &quot;:c&quot; is run on it</z><z id="t1463422231" t="nathanmarz It stops there"><y>#</y><d>2016-05-16</d><h>18:10</h><w>nathanmarz</w>It stops there</z><z id="t1463422303" t="nathanmarz walker walks the entire structure, and stops on any path once its predicate function matches"><y>#</y><d>2016-05-16</d><h>18:11</h><w>nathanmarz</w>walker walks the entire structure, and stops on any path once its predicate function matches</z><z id="t1463422455" t="mac @nathanmarz: &gt;Trying to wrap my head around this"><y>#</y><d>2016-05-16</d><h>18:14</h><w>mac</w>@nathanmarz: &gt;Trying to wrap my head around this</z><z id="t1463423717" t="mac @nathanmarz: Got it. Had to mess a bit with some different predicates, but it sunk in now 🙂"><y>#</y><d>2016-05-16</d><h>18:35</h><w>mac</w>@nathanmarz: Got it. Had to mess a bit with some different predicates, but it sunk in now <b>🙂</b></z><z id="t1463424760" t="nathanmarz great"><y>#</y><d>2016-05-16</d><h>18:52</h><w>nathanmarz</w>great</z><z id="t1463604863" t="benzap so i&apos;ve been looking at specter, do you think it can also be applied to matrices?"><y>#</y><d>2016-05-18</d><h>20:54</h><w>benzap</w>so i&apos;ve been looking at specter, do you think it can also be applied to matrices?</z><z id="t1463604915" t="benzap been trying basic things like accessing elements in a matrix, and i&apos;ve been having a hard time getting it working. Very new to your library, but I love it nonetheless since seeing your talk"><y>#</y><d>2016-05-18</d><h>20:55</h><w>benzap</w>been trying basic things like accessing elements in a matrix, and i&apos;ve been having a hard time getting it working. Very new to your library, but I love it nonetheless since seeing your talk</z><z id="t1463605100" t="benzap for example (use &apos;com.rpl.specter) (def x [[1 2 3] [4 5 6]]) (select [1 1] x) ;; failed"><y>#</y><d>2016-05-18</d><h>20:58</h><w>benzap</w>for example

(use &apos;com.rpl.specter)
(def x [[1 2 3] [4 5 6]])
(select [1 1] x)
;; failed</z><z id="t1463605102" t="benzap (select [FIRST FIRST] x)"><y>#</y><d>2016-05-18</d><h>20:58</h><w>benzap</w>(select [FIRST FIRST] x)</z><z id="t1463605108" t="benzap (select [FIRST FIRST] x)"><y>#</y><d>2016-05-18</d><h>20:58</h><w>benzap</w>(select [FIRST FIRST] x)</z><z id="t1463605112" t="benzap [1]*"><y>#</y><d>2016-05-18</d><h>20:58</h><w>benzap</w>[1]*</z><z id="t1463605144" t="benzap is there a navigator that lets you select a specific value in a matrix"><y>#</y><d>2016-05-18</d><h>20:59</h><w>benzap</w>is there a navigator that lets you select a specific value in a matrix</z><z id="t1463605168" t="benzap I should probably do more reading before I ask this question, sorry in advance"><y>#</y><d>2016-05-18</d><h>20:59</h><w>benzap</w>I should probably do more reading before I ask this question, sorry in advance</z><z id="t1463605867" t="nathanmarz benzap: You can use keypath"><y>#</y><d>2016-05-18</d><h>21:11</h><w>nathanmarz</w>benzap: You can use keypath</z><z id="t1463605885" t="nathanmarz (select [(keypath 1) (keypath 1)] x)"><y>#</y><d>2016-05-18</d><h>21:11</h><w>nathanmarz</w><code>(select [(keypath 1) (keypath 1)] x)</code></z><z id="t1463709576" t="seantempesta hey everyone. Just started using specter and I’m clearly missing something. Why does this return nil? (s/select [:groups s/ALL (s/keypath 15)] {:groups {:present {15 &quot;hi&quot;}}}) "><y>#</y><d>2016-05-20</d><h>01:59</h><w>seantempesta</w>hey everyone.  Just started using specter and I’m clearly missing something.  Why does this return nil?

<pre>(s/select [:groups s/ALL (s/keypath 15)] {:groups {:present {15 &quot;hi&quot;}}})
</pre></z><z id="t1463727883" t="wei how would you write this in specter- given a range of numbers, increment the even numbers and remove the odd numbers? i.e. (transform [..] (fn [n] ..) (range 10)) =&gt; (1 3 5 7 9) this is a contrived example, but basically I’m transforming the value in one case and removing from the list in another case"><y>#</y><d>2016-05-20</d><h>07:04</h><w>wei</w>how would you write this in specter- given a range of numbers, increment the even numbers and remove the odd numbers? i.e. <code>(transform [..] (fn [n] ..) (range 10)) =&gt; (1 3 5 7 9)</code> this is a contrived example, but basically I’m transforming the value in one case and removing from the list in another case</z><z id="t1463740121" t="tcoupland @seantempesta: s/ALL creates a sequence of everything refered to by :groups, [[:present {15 &quot;hi&quot;}]] here, so you need to decend another level of the structure. Either with :present or s/LAST would do the trick"><y>#</y><d>2016-05-20</d><h>10:28</h><w>tcoupland</w>@seantempesta: s/ALL creates a sequence of everything refered to by :groups, [[:present {15 &quot;hi&quot;}]] here, so you need to decend another level of the structure. Either with :present or s/LAST would do the trick</z><z id="t1463754523" t="nathanmarz @wei You can do it with a navigator like this: (defpath ALL-ELEM-SEQ [] (select* [this structure next-fn] (mapcat (fn [e] (next-fn [e])) structure) ) (transform* [this structure next-fn] (mapcat (fn [e] (next-fn [e])) structure) )) "><y>#</y><d>2016-05-20</d><h>14:28</h><w>nathanmarz</w>@wei You can do it with a navigator like this:
<pre>(defpath ALL-ELEM-SEQ []
  (select* [this structure next-fn]
    (mapcat (fn [e] (next-fn [e])) structure)
    )
  (transform* [this structure next-fn]
    (mapcat (fn [e] (next-fn [e])) structure)    
    ))
</pre></z><z id="t1463754561" t="nathanmarz (transform [... ALL-ELEM-SEQ] (fn [[v]] (if (even? v) [(inc v)])))"><y>#</y><d>2016-05-20</d><h>14:29</h><w>nathanmarz</w><pre>(transform [... ALL-ELEM-SEQ] (fn [[v]] (if (even? v) [(inc v)])))</pre></z><z id="t1463790543" t="wei thanks @nathanmarz. just curious why you called it ALL-ELEM-SEQ ?"><y>#</y><d>2016-05-21</d><h>00:29</h><w>wei</w>thanks @nathanmarz. just curious why you called it <code>ALL-ELEM-SEQ</code>?</z><z id="t1464194875" t="wei is there an idiomatic way to handle group-by operations? e.g. group-by :x, [{:id 1 :x 1} {:id 2 :x 1} {:id 3 :x 2}] =&gt; [{:x 1 :ids [1 2]} {:x 2 :ids [3]}] wondering if the implementation is shorter in specter"><y>#</y><d>2016-05-25</d><h>16:47</h><w>wei</w>is there an idiomatic way to handle group-by operations? e.g. group-by :x, <code>[{:id 1 :x 1} {:id 2 :x 1} {:id 3 :x 2}] =&gt; [{:x 1 :ids [1 2]} {:x 2 :ids [3]}]</code> wondering if the implementation is shorter in specter</z><z id="t1464239299" t="nathanmarz @wei not that I can think of"><y>#</y><d>2016-05-26</d><h>05:08</h><w>nathanmarz</w>@wei not that I can think of</z><z id="t1464460619" t="adambros out of curiosity, how was the name (specter) chosen?"><y>#</y><d>2016-05-28</d><h>18:36</h><w>adambros</w>out of curiosity, how was the name (specter) chosen?</z><z id="t1464460678" t="nathanmarz inspect, introspect"><y>#</y><d>2016-05-28</d><h>18:37</h><w>nathanmarz</w>inspect, introspect</z><z id="t1464460822" t="adambros So at work we use om.next, and I saw under the readme’s future work you mention graphs I’ve not had the time to fully think this out, but I was wondering if you had spent any brain power on graphs, om.next &amp; specter"><y>#</y><d>2016-05-28</d><h>18:40</h><w>adambros</w>So at work we use om.next, and I saw under the readme’s future work you mention graphs
I’ve not had the time to fully think this out, but I was wondering if you had spent any brain power on graphs, om.next &amp; specter</z><z id="t1464460844" t="adambros i can elaborate on what an om.next graph is if you aren’t aware"><y>#</y><d>2016-05-28</d><h>18:40</h><w>adambros</w>i can elaborate on what an om.next graph is if you aren’t aware</z><z id="t1464460874" t="nathanmarz well I have my own internal specter graph navigators (on top of loom)"><y>#</y><d>2016-05-28</d><h>18:41</h><w>nathanmarz</w>well I have my own internal specter graph navigators (on top of loom)</z><z id="t1464460896" t="nathanmarz trying to get someone from the community to contribute an open-source version"><y>#</y><d>2016-05-28</d><h>18:41</h><w>nathanmarz</w>trying to get someone from the community to contribute an open-source version</z><z id="t1464460914" t="nathanmarz there was someone at clojure west who was really interested but I haven&apos;t heard from him since"><y>#</y><d>2016-05-28</d><h>18:41</h><w>nathanmarz</w>there was someone at clojure west who was really interested but I haven&apos;t heard from him since</z><z id="t1464460927" t="nathanmarz short summary of om.next graphs?"><y>#</y><d>2016-05-28</d><h>18:42</h><w>nathanmarz</w>short summary of om.next graphs?</z><z id="t1464460942" t="nathanmarz i only have a vague familiarity"><y>#</y><d>2016-05-28</d><h>18:42</h><w>nathanmarz</w>i only have a vague familiarity</z><z id="t1464460974" t="adambros let me grab a snapshot from my app, probably be easier with some real data"><y>#</y><d>2016-05-28</d><h>18:42</h><w>adambros</w>let me grab a snapshot from my app, probably be easier with some real data</z><z id="t1464461025" t="nathanmarz ok"><y>#</y><d>2016-05-28</d><h>18:43</h><w>nathanmarz</w>ok</z><z id="t1464461047" t="nathanmarz btw I gave an example of my specter graph stuff during my clojure west talk: https://youtu.be/VTCy_DkAJGk?t=39m"><y>#</y><d>2016-05-28</d><h>18:44</h><w>nathanmarz</w>btw I gave an example of my specter graph stuff during my clojure west talk: <a href="https://youtu.be/VTCy_DkAJGk?t=39m" target="_blank">https://youtu.be/VTCy_DkAJGk?t=39m</a></z><z id="t1464461290" t="adambros {:todos [[:todo/by-id 111] [:todo/by-id 222]] :todo/by-id {111 {:db/id 111 :todo/title [:string/by-id 112]} 222 {:db/id 222 :todo/title [:string/by-id 223]}} "><y>#</y><d>2016-05-28</d><h>18:48</h><w>adambros</w><pre>{:todos [[:todo/by-id 111] [:todo/by-id 222]]
 :todo/by-id {111 {:db/id 111 :todo/title [:string/by-id 112]}
              222 {:db/id 222 :todo/title [:string/by-id 223]}}
</pre></z><z id="t1464461306" t="adambros so edges are called idents and take the form [:table-name id]"><y>#</y><d>2016-05-28</d><h>18:48</h><w>adambros</w>so edges are called idents and take the form <code>[:table-name id]</code></z><z id="t1464461340" t="adambros and we usually want to perform operations like adding/removing a todo to both the :todos list and to the table :todo/by-id"><y>#</y><d>2016-05-28</d><h>18:49</h><w>adambros</w>and we usually want to perform operations like adding/removing a todo to both the <code>:todos</code> list and to the table <code>:todo/by-id</code></z><z id="t1464461363" t="adambros and editing them in the table, which could itself be an operation that involves modifying a todo’s title which is an ident"><y>#</y><d>2016-05-28</d><h>18:49</h><w>adambros</w>and editing them in the table, which could itself be an operation that involves modifying a todo’s title which is an ident</z><z id="t1464461434" t="adambros anyway i dont know what im looking for as its very new to me, but we end up writing a lot of boilerplate to update this graph"><y>#</y><d>2016-05-28</d><h>18:50</h><w>adambros</w>anyway i dont know what im looking for as its very new to me, but we end up writing a lot of boilerplate to update this graph</z><z id="t1464461485" t="nathanmarz yea, well it&apos;s kind of like manipulating a vector if you had to deal with the internal tree structure directly"><y>#</y><d>2016-05-28</d><h>18:51</h><w>nathanmarz</w>yea, well it&apos;s kind of like manipulating a vector if you had to deal with the internal tree structure directly</z><z id="t1464461503" t="nathanmarz I think loom internally implements graphs with maps but has a proper graph api that you can use"><y>#</y><d>2016-05-28</d><h>18:51</h><w>nathanmarz</w>I think loom internally implements graphs with maps but has a proper graph api that you can use</z><z id="t1464461516" t="adambros so take a look at loom then?"><y>#</y><d>2016-05-28</d><h>18:51</h><w>adambros</w>so take a look at loom then?</z><z id="t1464461544" t="nathanmarz I would start there, yea"><y>#</y><d>2016-05-28</d><h>18:52</h><w>nathanmarz</w>I would start there, yea</z><z id="t1464461555" t="adambros ok thanks, hadn’t heard of it before"><y>#</y><d>2016-05-28</d><h>18:52</h><w>adambros</w>ok thanks, hadn’t heard of it before</z><z id="t1464461567" t="nathanmarz or some sort of API where you do the basic manipulations / queries with a graph-oriented API"><y>#</y><d>2016-05-28</d><h>18:52</h><w>nathanmarz</w>or some sort of API where you do the basic manipulations / queries with a graph-oriented API</z><z id="t1464461569" t="adambros be nice to not reinvent the graph"><y>#</y><d>2016-05-28</d><h>18:52</h><w>adambros</w>be nice to not reinvent the graph</z><z id="t1464461572" t="nathanmarz get-node, children, parents, etc."><y>#</y><d>2016-05-28</d><h>18:52</h><w>nathanmarz</w>get-node, children, parents, etc.</z><z id="t1464461655" t="nathanmarz then when you want to do more sophisticated stuff, you can do something similar like I&apos;ve done with specter graph navigators"><y>#</y><d>2016-05-28</d><h>18:54</h><w>nathanmarz</w>then when you want to do more sophisticated stuff, you can do something similar like I&apos;ve done with specter graph navigators</z><z id="t1464523863" t="luxbock how can I select a subset of keys on a map?"><y>#</y><d>2016-05-29</d><h>12:11</h><w>luxbock</w>how can I select a subset of keys on a map?</z><z id="t1464523896" t="luxbock I thought I could use sets with the keys I&apos;m interested in as the selector but this didn&apos;t work, eventhough I see that they implement the protocol"><y>#</y><d>2016-05-29</d><h>12:11</h><w>luxbock</w>I thought I could use sets with the keys I&apos;m interested in as the selector but this didn&apos;t work, eventhough I see that they implement the protocol</z><z id="t1464524128" t="luxbock i.e. (select [#{:foo}] {:foo 1 :bar 2}) returns nil"><y>#</y><d>2016-05-29</d><h>12:15</h><w>luxbock</w>i.e. <code>(select [#{:foo}] {:foo 1 :bar 2})</code> returns <code>nil</code></z><z id="t1464525085" t="luxbock what I&apos;m trying to achieve is {:foo 1 :bar 2 :baz 3} =&gt; {:foo &quot;1&quot; :bar &quot;2&quot; :baz 3}"><y>#</y><d>2016-05-29</d><h>12:31</h><w>luxbock</w>what I&apos;m trying to achieve is <code>{:foo 1 :bar 2 :baz 3}</code> =&gt; <code>{:foo &quot;1&quot; :bar &quot;2&quot; :baz 3}</code></z><z id="t1464525950" t="nathanmarz @luxbock: You can use either submap or multi-path"><y>#</y><d>2016-05-29</d><h>12:45</h><w>nathanmarz</w>@luxbock: You can use either <code>submap</code> or <code>multi-path</code></z><z id="t1464526029" t="nathanmarz (transform (multi-path :foo :bar) str {:foo 1 :bar 2 :baz 3})"><y>#</y><d>2016-05-29</d><h>12:47</h><w>nathanmarz</w><code>(transform (multi-path :foo :bar) str {:foo 1 :bar 2 :baz 3})</code></z><z id="t1464526064" t="nathanmarz (transform [(submap [:foo :bar]) ALL LAST] str {:foo 1 :bar 2 :baz 3})"><y>#</y><d>2016-05-29</d><h>12:47</h><w>nathanmarz</w><code>(transform [(submap [:foo :bar]) ALL LAST] str {:foo 1 :bar 2 :baz 3})</code></z><z id="t1464533407" t="luxbock @nathanmarz: cheers"><y>#</y><d>2016-05-29</d><h>14:50</h><w>luxbock</w>@nathanmarz: cheers</z><z id="t1464533426" t="luxbock do sets serve some other purpose as selectors?"><y>#</y><d>2016-05-29</d><h>14:50</h><w>luxbock</w>do sets serve some other purpose as selectors?</z><z id="t1464536065" t="nathanmarz they act as filter predicates"><y>#</y><d>2016-05-29</d><h>15:34</h><w>nathanmarz</w>they act as filter predicates</z><z id="t1464536130" t="nathanmarz (select [ALL #{1 2}] [1 2 3 4 1 7]) -&gt; [1 2 1]"><y>#</y><d>2016-05-29</d><h>15:35</h><w>nathanmarz</w><code>(select [ALL #{1 2}] [1 2 3 4 1 7])</code> -&gt; <code>[1 2 1]</code></z><z id="t1464536209" t="luxbock ah I see, yeah makes sense"><y>#</y><d>2016-05-29</d><h>15:36</h><w>luxbock</w>ah I see, yeah makes sense</z><z id="t1464656714" t="diba pardon my noobness, but i’m just starting out w/ specter, and i’m guessing there’s a better way to do the following that achieves better performance, and would love any guidance:"><y>#</y><d>2016-05-31</d><h>01:05</h><w>diba</w>pardon my noobness, but i’m just starting out w/ specter, and i’m guessing there’s a better way to do the following that achieves better performance, and would love any guidance:</z><z id="t1464657321" t="diba actually, here’s a simpler example where i’m still seeing my (likely non-optimal) specter code taking twice as long:"><y>#</y><d>2016-05-31</d><h>01:15</h><w>diba</w>actually, here’s a simpler example where i’m still seeing my (likely non-optimal) specter code taking twice as long:</z><z id="t1464658306" t="diba and &quot;f3 #(reduce-kv (fn [m k v] (assoc m k (dec v))) {} %)” seems to be twice as fast as f1"><y>#</y><d>2016-05-31</d><h>01:31</h><w>diba</w>and &quot;f3 #(reduce-kv (fn [m k v] (assoc m k (dec v))) {} %)” seems to be twice as fast as f1</z><z id="t1464671856" t="luxbock ALL FIRST and ALL LAST seem like really common selectors, @nathanmarz what do you think about including these as KEYS and VALS ?"><y>#</y><d>2016-05-31</d><h>05:17</h><w>luxbock</w><code>ALL FIRST</code> and <code>ALL LAST</code> seem like really common selectors, @nathanmarz what do you think about including these as <code>KEYS</code> and <code>VALS</code>?</z><z id="t1464677960" t="luxbock or perhaps you could have another namespace that contains functions named after the ones in clojure.core but which work as selectors"><y>#</y><d>2016-05-31</d><h>06:59</h><w>luxbock</w>or perhaps you could have another namespace that contains functions named after the ones in <code>clojure.core</code> but which work as selectors</z><z id="t1464700420" t="nathanmarz @diba @luxbock Yea the slowdown is caused by it just using generic functions to access the map as a sequence"><y>#</y><d>2016-05-31</d><h>13:13</h><w>nathanmarz</w>@diba @luxbock Yea the slowdown is caused by it just using generic functions to access the map as a sequence</z><z id="t1464700469" t="nathanmarz and coercing the MapEntry&apos;s to vectors probably wasn&apos;t the right thing to do in retrospect, KEY and VAL selectors would be faster than coercing and using FIRST and LAST"><y>#</y><d>2016-05-31</d><h>13:14</h><w>nathanmarz</w>and coercing the MapEntry&apos;s to vectors probably wasn&apos;t the right thing to do in retrospect, <code>KEY</code> and <code>VAL</code> selectors would be faster than coercing and using <code>FIRST</code> and <code>LAST</code></z><z id="t1464700526" t="nathanmarz I&apos;ll look into using reduce-kv for the map case of ALL , but otherwise you can make specialized navigators to make it faster"><y>#</y><d>2016-05-31</d><h>13:15</h><w>nathanmarz</w>I&apos;ll look into using <code>reduce-kv</code> for the map case of <code>ALL</code>, but otherwise you can make specialized navigators to make it faster</z><z id="t1464700616" t="nathanmarz as for having KEYS and VALS as common navigators, maybe"><y>#</y><d>2016-05-31</d><h>13:16</h><w>nathanmarz</w>as for having KEYS and VALS as common navigators, maybe</z><z id="t1464700647" t="nathanmarz so far I&apos;ve been hesitant to include compound navigators in the core library (since there&apos;s infinite of them possible), but I can see the argument in this case"><y>#</y><d>2016-05-31</d><h>13:17</h><w>nathanmarz</w>so far I&apos;ve been hesitant to include compound navigators in the core library (since there&apos;s infinite of them possible), but I can see the argument in this case</z><z id="t1464706369" t="nathanmarz Big release for Specter today with the new inline factoring and caching feature"><y>#</y><d>2016-05-31</d><h>14:52</h><w>nathanmarz</w>Big release for Specter today with the new inline factoring and caching feature</z><z id="t1464706384" t="nathanmarz No need to do manual precompilation anymore to get high performance"><y>#</y><d>2016-05-31</d><h>14:53</h><w>nathanmarz</w>No need to do manual precompilation anymore to get high performance</z><z id="t1464706415" t="nathanmarz Also wrote up a guide to the internals of how Specter achieves high performance, recommended reading for all users: https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs"><y>#</y><d>2016-05-31</d><h>14:53</h><w>nathanmarz</w>Also wrote up a guide to the internals of how Specter achieves high performance, recommended reading for all users: <a href="https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs" target="_blank">https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs</a></z><z id="t1464708820" t="luxbock awesome"><y>#</y><d>2016-05-31</d><h>15:33</h><w>luxbock</w>awesome</z><z id="t1464709794" t="luxbock @nathanmarz: transform seems to have disappeared from com.rpl.specter in the new version"><y>#</y><d>2016-05-31</d><h>15:49</h><w>luxbock</w>@nathanmarz:  <code>transform</code> seems to have disappeared from <code>com.rpl.specter</code> in the new version</z><z id="t1464709806" t="luxbock as well as select"><y>#</y><d>2016-05-31</d><h>15:50</h><w>luxbock</w>as well as <code>select</code></z><z id="t1464710015" t="nathanmarz it&apos;s in the macros namespace"><y>#</y><d>2016-05-31</d><h>15:53</h><w>nathanmarz</w>it&apos;s in the macros namespace</z><z id="t1464710032" t="luxbock ah I see"><y>#</y><d>2016-05-31</d><h>15:53</h><w>luxbock</w>ah I see</z><z id="t1464710055" t="nathanmarz I recommend reading the changelog for the release as there were a few other backwards incompatible changes"><y>#</y><d>2016-05-31</d><h>15:54</h><w>nathanmarz</w>I recommend reading the changelog for the release as there were a few other backwards incompatible changes</z><z id="t1464711785" t="tony.kay I&apos;m wanting to walk a recursive data structure composed of maps and vectors. When inside of a map I&apos;d like to remove k-v pairs where the value matches a predicate. Can I do that with specter? { :a 1 :b [{:x 4 :y 3}] } ---remove where v == 4 --&gt; {:a 1 :b [{:y 3}]}"><y>#</y><d>2016-05-31</d><h>16:23</h><w>tony.kay</w>I&apos;m wanting to walk a recursive data structure composed of maps and vectors. When inside of a map I&apos;d like to remove k-v pairs where the value matches a predicate. Can I do that with specter?

<code>{ :a 1 :b [{:x 4 :y 3}] }  ---remove where v == 4 --&gt; {:a 1 :b [{:y 3}]}</code></z><z id="t1464711863" t="tony.kay I can easily nullify the value..seems like collect...sort-of: on the k-v pair instead of the value"><y>#</y><d>2016-05-31</d><h>16:24</h><w>tony.kay</w>I can easily nullify the value..seems like collect...sort-of: on the k-v pair instead of the value</z><z id="t1464711943" t="nathanmarz @tony.kay: in that example do you mean remove x when x==4?"><y>#</y><d>2016-05-31</d><h>16:25</h><w>nathanmarz</w>@tony.kay: in that example do you mean remove x when x==4?</z><z id="t1464711972" t="tony.kay remove the :x 4 key-value pair when the value is 4, independent of the key"><y>#</y><d>2016-05-31</d><h>16:26</h><w>tony.kay</w>remove the :x 4 key-value pair when the value is 4, independent of the key</z><z id="t1464711995" t="tony.kay by v I meant the value of a key-value pair"><y>#</y><d>2016-05-31</d><h>16:26</h><w>tony.kay</w>by v I meant the value of a key-value pair</z><z id="t1464712014" t="nathanmarz Oh I see remove all key/value pairs where the value matches some predicate"><y>#</y><d>2016-05-31</d><h>16:26</h><w>nathanmarz</w>Oh I see remove all key/value pairs where the value matches some predicate</z><z id="t1464712021" t="tony.kay right"><y>#</y><d>2016-05-31</d><h>16:27</h><w>tony.kay</w>right</z><z id="t1464712118" t="tony.kay perhaps a walker on map?"><y>#</y><d>2016-05-31</d><h>16:28</h><w>tony.kay</w>perhaps a walker on <code>map?</code></z><z id="t1464712166" t="tony.kay with a nested transform"><y>#</y><d>2016-05-31</d><h>16:29</h><w>tony.kay</w>with a nested transform</z><z id="t1464712190" t="nathanmarz there&apos;s a couple ways to do it"><y>#</y><d>2016-05-31</d><h>16:29</h><w>nathanmarz</w>there&apos;s a couple ways to do it</z><z id="t1464712262" t="nathanmarz one way is to do something like (transform [:b (collect ALL (selected? LAST #(= % 4)) FIRST)] (fn [keys m] (apply dissoc m keys)))"><y>#</y><d>2016-05-31</d><h>16:31</h><w>nathanmarz</w>one way is to do something like <code>(transform [:b (collect ALL (selected? LAST #(= % 4)) FIRST)] (fn [keys m] (apply dissoc m keys)))</code></z><z id="t1464712322" t="nathanmarz oh you want it to be recursive as well"><y>#</y><d>2016-05-31</d><h>16:32</h><w>nathanmarz</w>oh you want it to be recursive as well</z><z id="t1464712326" t="tony.kay yeah"><y>#</y><d>2016-05-31</d><h>16:32</h><w>tony.kay</w>yeah</z><z id="t1464712429" t="nathanmarz one sec, I&apos;ll show you"><y>#</y><d>2016-05-31</d><h>16:33</h><w>nathanmarz</w>one sec, I&apos;ll show you</z><z id="t1464712434" t="tony.kay thx"><y>#</y><d>2016-05-31</d><h>16:33</h><w>tony.kay</w>thx</z><z id="t1464712559" t="nathanmarz (declarepath RecursiveMaps) (providepath RecursiveMaps [(walker map?) (continue-then-stay ALL LAST RecursiveMaps )]) (transform [RecursiveMaps (collect ALL (selected? LAST #(= % 4)) FIRST) ] (fn [keys m] (apply dissoc m keys)) {:a 4 :z 11 :b [{:x 4 :y 3} {:a 1}]} ) ;; =&gt; {:z 11, :b [{:y 3} {:a 1}]} "><y>#</y><d>2016-05-31</d><h>16:35</h><w>nathanmarz</w><pre>(declarepath RecursiveMaps)

(providepath RecursiveMaps
  [(walker map?)
   (continue-then-stay
     ALL
     LAST
     RecursiveMaps
     )])

(transform
  [RecursiveMaps
   (collect ALL (selected? LAST #(= % 4)) FIRST)
   ]
   (fn [keys m] (apply dissoc m keys))
   {:a 4 :z 11 :b [{:x 4 :y 3} {:a 1}]}
  )
;; =&gt; {:z 11, :b [{:y 3} {:a 1}]}
</pre></z><z id="t1464712580" t="tony.kay oh boy...would not have gotten that 🙂"><y>#</y><d>2016-05-31</d><h>16:36</h><w>tony.kay</w>oh boy...would not have gotten that <b>🙂</b></z><z id="t1464712626" t="tony.kay but cool nonetheless!"><y>#</y><d>2016-05-31</d><h>16:37</h><w>tony.kay</w>but cool nonetheless!</z><z id="t1464712701" t="nathanmarz this is more advanced Specter usage, for sure"><y>#</y><d>2016-05-31</d><h>16:38</h><w>nathanmarz</w>this is more advanced Specter usage, for sure</z><z id="t1464712711" t="nathanmarz but built on the same principles"><y>#</y><d>2016-05-31</d><h>16:38</h><w>nathanmarz</w>but built on the same principles</z><z id="t1464712726" t="tony.kay Yeah, I understand it...just not able to write it yet"><y>#</y><d>2016-05-31</d><h>16:38</h><w>tony.kay</w>Yeah, I understand it...just not able to write it yet</z><z id="t1464712771" t="nathanmarz yea, my first few recursive navigations took me awhile even though I came up with this technique"><y>#</y><d>2016-05-31</d><h>16:39</h><w>nathanmarz</w>yea, my first few recursive navigations took me awhile even though I came up with this technique</z><z id="t1464712786" t="nathanmarz now I don&apos;t even think about it"><y>#</y><d>2016-05-31</d><h>16:39</h><w>nathanmarz</w>now I don&apos;t even think about it</z><z id="t1464712887" t="tony.kay I appreciate the help. I&apos;ll read through these functions and maybe play on paper a bit"><y>#</y><d>2016-05-31</d><h>16:41</h><w>tony.kay</w>I appreciate the help. I&apos;ll read through these functions and maybe play on paper a bit</z><z id="t1464712916" t="nathanmarz sure thing"><y>#</y><d>2016-05-31</d><h>16:41</h><w>nathanmarz</w>sure thing</z><z id="t1464714574" t="tony.kay I see select-first, and it mentions it is not more efficient....is there a way of detecting the presence of a value in a nested data structure without continuing a recursive walk?"><y>#</y><d>2016-05-31</d><h>17:09</h><w>tony.kay</w>I see select-first, and it mentions it is not more efficient....is there a way of detecting the presence of a value in a nested data structure without continuing a recursive walk?</z><z id="t1464715049" t="nathanmarz like do a recursive search for a value matching a predicate and stop once it&apos;s reached?"><y>#</y><d>2016-05-31</d><h>17:17</h><w>nathanmarz</w>like do a recursive search for a value matching a predicate and stop once it&apos;s reached?</z><z id="t1464715396" t="tony.kay yes"><y>#</y><d>2016-05-31</d><h>17:23</h><w>tony.kay</w>yes</z><z id="t1464715445" t="nathanmarz you can do that for a lot of cases with com.rpl.specter.zipper"><y>#</y><d>2016-05-31</d><h>17:24</h><w>nathanmarz</w>you can do that for a lot of cases with com.rpl.specter.zipper</z><z id="t1464715459" t="nathanmarz user=&gt; (transform [z/VECTOR-ZIP (z/find-first #(and (number? %) (even? %))) z/NODE] inc [1 3 5 [2 4]]) [1 3 5 [3 4]] "><y>#</y><d>2016-05-31</d><h>17:24</h><w>nathanmarz</w><pre>user=&gt; (transform [z/VECTOR-ZIP (z/find-first #(and (number? %) (even? %))) z/NODE] inc [1 3 5 [2 4]])
[1 3 5 [3 4]]
</pre></z><z id="t1464715509" t="nathanmarz the definition of find-first is pretty simple: https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/zipper.cljx#L119"><y>#</y><d>2016-05-31</d><h>17:25</h><w>nathanmarz</w>the definition of find-first is pretty simple: <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/zipper.cljx#L119" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/zipper.cljx#L119</a></z><z id="t1464715511" t="tony.kay and you&apos;re just using inc because you need something"><y>#</y><d>2016-05-31</d><h>17:25</h><w>tony.kay</w>and you&apos;re just using <code>inc</code> because you need something</z><z id="t1464715531" t="tony.kay oh...nvm, I see"><y>#</y><d>2016-05-31</d><h>17:25</h><w>tony.kay</w>oh...nvm, I see</z><z id="t1464715533" t="nathanmarz oh I was just showing it for the transform case"><y>#</y><d>2016-05-31</d><h>17:25</h><w>nathanmarz</w>oh I was just showing it for the transform case</z><z id="t1464715549" t="nathanmarz works as you&apos;d expect for select"><y>#</y><d>2016-05-31</d><h>17:25</h><w>nathanmarz</w>works as you&apos;d expect for select</z><z id="t1464715556" t="tony.kay yep, I see"><y>#</y><d>2016-05-31</d><h>17:25</h><w>tony.kay</w>yep, I see</z><z id="t1464842090" t="luxbock how would I write the following using Specter: `"><y>#</y><d>2016-06-02</d><h>04:34</h><w>luxbock</w>how would I write the following using Specter:
<code></code>`</z><z id="t1464842129" t="luxbock (into {} (for [[k v] fff] [k (mapv :foo v)]))"><y>#</y><d>2016-06-02</d><h>04:35</h><w>luxbock</w><code>(into {} (for [[k v] fff] [k (mapv :foo v)]))</code></z><z id="t1464842157" t="luxbock where fff is {:x [{:foo &quot;hello&quot; :bar [2 4]} {:foo &quot;there&quot;}] :y [{:foo &quot;moo&quot; :bar [2 4]} {:foo &quot;world&quot;}]}"><y>#</y><d>2016-06-02</d><h>04:35</h><w>luxbock</w>where <code>fff</code> is <code>{:x [{:foo &quot;hello&quot; :bar [2 4]} {:foo &quot;there&quot;}] :y [{:foo &quot;moo&quot;   :bar [2 4]} {:foo &quot;world&quot;}]}</code></z><z id="t1464842169" t="luxbock and the desired output is {:x [&quot;hello&quot; &quot;there&quot;], :y [&quot;moo&quot; &quot;world&quot;]}"><y>#</y><d>2016-06-02</d><h>04:36</h><w>luxbock</w>and the desired output is <code>{:x [&quot;hello&quot; &quot;there&quot;], :y [&quot;moo&quot; &quot;world&quot;]}</code></z><z id="t1464842205" t="luxbock my problem is that all of my attempts at selecting the key :foo throw away the surrounding context of the vector"><y>#</y><d>2016-06-02</d><h>04:36</h><w>luxbock</w>my problem is that all of my attempts at selecting the key <code>:foo</code> throw away the surrounding context of the vector</z><z id="t1464842566" t="nathanmarz @luxbock: (transform [ALL LAST ALL] :foo fff)"><y>#</y><d>2016-06-02</d><h>04:42</h><w>nathanmarz</w>@luxbock: <code>(transform [ALL LAST ALL] :foo fff)</code></z><z id="t1464842653" t="luxbock @nathanmarz: thanks, I finally got it but my way was using select-one which I guess I don&apos;t need"><y>#</y><d>2016-06-02</d><h>04:44</h><w>luxbock</w>@nathanmarz: thanks, I finally got it but my way was using <code>select-one</code> which I guess I don&apos;t need</z><z id="t1464842787" t="nathanmarz what did your select-one solution look like?"><y>#</y><d>2016-06-02</d><h>04:46</h><w>nathanmarz</w>what did your select-one solution look like?</z><z id="t1464842841" t="luxbock (transform [VALS ALL (collect-one :foo)] (fn [x y] x) fff) , where VALS is ALL LAST"><y>#</y><d>2016-06-02</d><h>04:47</h><w>luxbock</w><code>(transform [VALS ALL (collect-one :foo)] (fn [x y] x) fff)</code>, where <code>VALS</code> is <code>ALL LAST</code></z><z id="t1464842864" t="luxbock oh yeah, I meant to say collect-one"><y>#</y><d>2016-06-02</d><h>04:47</h><w>luxbock</w>oh yeah, I meant to say <code>collect-one</code></z><z id="t1464843025" t="luxbock how about if I want to return [[&quot;hello&quot; &quot;there&quot;] [&quot;moo&quot; &quot;world&quot;]] ?"><y>#</y><d>2016-06-02</d><h>04:50</h><w>luxbock</w>how about if I want to return <code>[[&quot;hello&quot; &quot;there&quot;] [&quot;moo&quot; &quot;world&quot;]]</code>?</z><z id="t1464843028" t="nathanmarz yea, besides being more concise my version will be much faster"><y>#</y><d>2016-06-02</d><h>04:50</h><w>nathanmarz</w>yea, besides being more concise my version will be much faster</z><z id="t1464843109" t="nathanmarz (select [ALL LAST (subselect ALL :foo)] fff)"><y>#</y><d>2016-06-02</d><h>04:51</h><w>nathanmarz</w><code> (select [ALL LAST (subselect ALL :foo)] fff)</code></z><z id="t1464843238" t="luxbock ah great, thanks again"><y>#</y><d>2016-06-02</d><h>04:53</h><w>luxbock</w>ah great, thanks again</z><z id="t1464843313" t="luxbock yeah subselect is mentioned at the very bottom of the README so I didn&apos;t spot it as something I should&apos;ve looked into"><y>#</y><d>2016-06-02</d><h>04:55</h><w>luxbock</w>yeah <code>subselect</code> is mentioned at the very bottom of the README so I didn&apos;t spot it as something I should&apos;ve looked into</z><z id="t1464843329" t="luxbock there are currently no API docs for specter right?"><y>#</y><d>2016-06-02</d><h>04:55</h><w>luxbock</w>there are currently no API docs for specter right?</z><z id="t1464843346" t="nathanmarz well the files themselves are documented"><y>#</y><d>2016-06-02</d><h>04:55</h><w>nathanmarz</w>well the files themselves are documented</z><z id="t1464843355" t="nathanmarz I suppose I should generate some html"><y>#</y><d>2016-06-02</d><h>04:55</h><w>nathanmarz</w>I suppose I should generate some html</z><z id="t1464843454" t="luxbock I also noticed that many of the core functions lack doc strings"><y>#</y><d>2016-06-02</d><h>04:57</h><w>luxbock</w>I also noticed that many of the core functions lack doc strings</z><z id="t1464843506" t="nathanmarz specter.cljx mostly has docstrings"><y>#</y><d>2016-06-02</d><h>04:58</h><w>nathanmarz</w>specter.cljx mostly has docstrings</z><z id="t1464843527" t="nathanmarz but yea I agree the docs could use substantial work"><y>#</y><d>2016-06-02</d><h>04:58</h><w>nathanmarz</w>but yea I agree the docs could use substantial work</z><z id="t1464843935" t="nathanmarz @luxbock: Any suggestions for documentation improvements would be appreciated https://github.com/nathanmarz/specter/issues/56"><y>#</y><d>2016-06-02</d><h>05:05</h><w>nathanmarz</w>@luxbock: Any suggestions for documentation improvements would be appreciated <a href="https://github.com/nathanmarz/specter/issues/56" target="_blank">https://github.com/nathanmarz/specter/issues/56</a></z><z id="t1464844016" t="luxbock sure"><y>#</y><d>2016-06-02</d><h>05:06</h><w>luxbock</w>sure</z><z id="t1464848551" t="luxbock it appears that collect and collect-one are identical"><y>#</y><d>2016-06-02</d><h>06:22</h><w>luxbock</w>it appears that <code>collect</code> and <code>collect-one</code> are identical</z><z id="t1464849580" t="nathanmarz @luxbock: they&apos;re not"><y>#</y><d>2016-06-02</d><h>06:39</h><w>nathanmarz</w>@luxbock: they&apos;re not</z><z id="t1464849589" t="nathanmarz same difference as between select and select-one"><y>#</y><d>2016-06-02</d><h>06:39</h><w>nathanmarz</w>same difference as between <code>select</code> and <code>select-one</code></z><z id="t1464850195" t="luxbock ah, yeah you are right, I misread the source. need more coffee"><y>#</y><d>2016-06-02</d><h>06:49</h><w>luxbock</w>ah, yeah you are right, I misread the source. need more coffee</z><z id="t1464883684" t="nathanmarz finally generated api docs https://nathanmarz.github.io/specter/"><y>#</y><d>2016-06-02</d><h>16:08</h><w>nathanmarz</w>finally generated api docs <a href="https://nathanmarz.github.io/specter/" target="_blank">https://nathanmarz.github.io/specter/</a></z><z id="t1464958735" t="darwin hi, is recursive navigation supported under cljs in 0.11, I have troubles calling extend-protocolpath"><y>#</y><d>2016-06-03</d><h>12:58</h><w>darwin</w>hi, is recursive navigation supported under cljs in 0.11, I have troubles calling <code>extend-protocolpath</code></z><z id="t1464958759" t="darwin it complains Use of undeclared Var com.rpl.specter.impl/extend-protocolpath*"><y>#</y><d>2016-06-03</d><h>12:59</h><w>darwin</w>it complains <code>Use of undeclared Var com.rpl.specter.impl/extend-protocolpath*</code></z><z id="t1464958808" t="darwin and indeed it looks there is only #+clj implementation: https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L1085"><y>#</y><d>2016-06-03</d><h>13:00</h><w>darwin</w>and indeed it looks there is only #+clj implementation:
<a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L1085" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L1085</a></z><z id="t1464958810" t="nathanmarz protocol paths don&apos;t work in clojurescript version"><y>#</y><d>2016-06-03</d><h>13:00</h><w>nathanmarz</w>protocol paths don&apos;t work in clojurescript version</z><z id="t1464958819" t="nathanmarz you can still do recursive navigation without protocol paths"><y>#</y><d>2016-06-03</d><h>13:00</h><w>nathanmarz</w>you can still do recursive navigation without protocol paths</z><z id="t1464958839" t="darwin thanks, any pointer to some example? I’m pretty new to specter"><y>#</y><d>2016-06-03</d><h>13:00</h><w>darwin</w>thanks, any pointer to some example? I’m pretty new to specter</z><z id="t1464958846" t="nathanmarz the last example on the README"><y>#</y><d>2016-06-03</d><h>13:00</h><w>nathanmarz</w>the last example on the README</z><z id="t1464958857" t="nathanmarz (declarepath TreeValues) (providepath TreeValues (if-path vector? [ALL TreeValues] STAY )) "><y>#</y><d>2016-06-03</d><h>13:00</h><w>nathanmarz</w><pre>(declarepath TreeValues)

(providepath TreeValues
  (if-path vector?
    [ALL TreeValues]
    STAY
    ))
</pre></z><z id="t1464958879" t="darwin it looks like insanely powerful tool when mastered btw. thanks a bunch!"><y>#</y><d>2016-06-03</d><h>13:01</h><w>darwin</w>it looks like insanely powerful tool when mastered btw. thanks a bunch!</z><z id="t1464958924" t="nathanmarz (transform [TreeValues even?] - [[1 2] [[3] 4] [6 [8 9 10]]]) ;; =&gt; [[1 -2] [[3] -4] [-6 [-8 9 -10]]] "><y>#</y><d>2016-06-03</d><h>13:02</h><w>nathanmarz</w><pre>(transform [TreeValues even?] - [[1 2] [[3] 4] [6 [8 9 10]]])
;; =&gt; [[1 -2] [[3] -4] [-6 [-8 9 -10]]]
</pre></z><z id="t1464958938" t="darwin got it, going to take that route"><y>#</y><d>2016-06-03</d><h>13:02</h><w>darwin</w>got it, going to take that route</z><z id="t1464959012" t="nathanmarz also look at continue-then-stay and stay-then-continue for doing post-order or pre-order traversals"><y>#</y><d>2016-06-03</d><h>13:03</h><w>nathanmarz</w>also look at <code>continue-then-stay</code> and <code>stay-then-continue</code> for doing post-order or pre-order traversals</z><z id="t1464960180" t="darwin I’m probably missing something, here is my current code, cannot make it work, want? predicate is never called according to that log statement, I call filter-rep and then pprint it to string, so possible laziness should NOT prevent those calls, https://gist.github.com/darwin/9a2673fdb2448132c6d1908195df0932"><y>#</y><d>2016-06-03</d><h>13:23</h><w>darwin</w>I’m probably missing something, here is my current code, cannot make it work, <code>want?</code> predicate is never called according to that log statement, I call filter-rep and then pprint it to string, so possible laziness should NOT prevent those calls, <a href="https://gist.github.com/darwin/9a2673fdb2448132c6d1908195df0932" target="_blank">https://gist.github.com/darwin/9a2673fdb2448132c6d1908195df0932</a></z><z id="t1464960240" t="darwin I’d like to use specter as filter for filtering scraped DOM structure for my tests"><y>#</y><d>2016-06-03</d><h>13:24</h><w>darwin</w>I’d like to use specter as filter for filtering scraped DOM structure for my tests</z><z id="t1464960360" t="nathanmarz yea, your path is incorrect"><y>#</y><d>2016-06-03</d><h>13:26</h><w>nathanmarz</w>yea, your path is incorrect</z><z id="t1464960376" t="nathanmarz it only navigates you to elements of :children sequences that aren&apos;t maps"><y>#</y><d>2016-06-03</d><h>13:26</h><w>nathanmarz</w>it only navigates you to elements of :children sequences that aren&apos;t maps</z><z id="t1464960383" t="nathanmarz try this path:"><y>#</y><d>2016-06-03</d><h>13:26</h><w>nathanmarz</w>try this path:</z><z id="t1464960428" t="nathanmarz (declarepath MyWalker) (providepath MyWalker (continue-then-stay :children ALL MyWalker )) "><y>#</y><d>2016-06-03</d><h>13:27</h><w>nathanmarz</w><pre>(declarepath MyWalker)
(providepath MyWalker
  (continue-then-stay
    :children
    ALL
    MyWalker
    ))
</pre></z><z id="t1464960452" t="nathanmarz that navigates you to every map"><y>#</y><d>2016-06-03</d><h>13:27</h><w>nathanmarz</w>that navigates you to every map</z><z id="t1464960644" t="darwin thanks, that works"><y>#</y><d>2016-06-03</d><h>13:30</h><w>darwin</w>thanks, that works</z><z id="t1464960707" t="darwin what if I need to traverse down both into :children and/or :children2 if present"><y>#</y><d>2016-06-03</d><h>13:31</h><w>darwin</w>what if I need to traverse down both into <code>:children</code> and/or <code>:children2</code> if present</z><z id="t1464960777" t="nathanmarz use multi-path + must"><y>#</y><d>2016-06-03</d><h>13:32</h><w>nathanmarz</w>use <code>multi-path</code> + <code>must</code></z><z id="t1464960788" t="nathanmarz (declarepath MyWalker) (providepath MyWalker (continue-then-stay (multi-path (must :children) (must :children2)) ALL MyWalker )) "><y>#</y><d>2016-06-03</d><h>13:33</h><w>nathanmarz</w><pre>(declarepath MyWalker)
(providepath MyWalker
  (continue-then-stay
    (multi-path (must :children) (must :children2))
    ALL
    MyWalker
    ))
</pre></z><z id="t1464960803" t="darwin looks good, thanks a lot"><y>#</y><d>2016-06-03</d><h>13:33</h><w>darwin</w>looks good, thanks a lot</z><z id="t1464960817" t="nathanmarz no problem"><y>#</y><d>2016-06-03</d><h>13:33</h><w>nathanmarz</w>no problem</z><z id="t1464961105" t="nathanmarz nice!"><y>#</y><d>2016-06-03</d><h>13:38</h><w>nathanmarz</w>nice!</z><z id="t1464961138" t="nathanmarz you can make it a little more concise like this: (providepath MyWalker (continue-then-stay (multi-path [(must :children) ALL] (must :shadowRoot)) MyWalker)) "><y>#</y><d>2016-06-03</d><h>13:38</h><w>nathanmarz</w>you can make it a little more concise like this:
<pre>(providepath MyWalker
  (continue-then-stay
    (multi-path
      [(must :children) ALL]
      (must :shadowRoot))
    MyWalker))
</pre></z><z id="t1464961186" t="darwin cool! I have a feeling this will be a “jquery” on steroids 🙂"><y>#</y><d>2016-06-03</d><h>13:39</h><w>darwin</w>cool! I have a feeling this will be a “jquery” on steroids <b>🙂</b></z><z id="t1464961208" t="nathanmarz 🙂"><y>#</y><d>2016-06-03</d><h>13:40</h><w>nathanmarz</w><b>🙂</b></z><z id="t1464968121" t="darwin getting some warnings when compiling specter’s impl namespace: https://gist.github.com/darwin/90bcb9a87d7f1b492cd6d6400bcd103c#file-impl-cljs-L3"><y>#</y><d>2016-06-03</d><h>15:35</h><w>darwin</w>getting some warnings when compiling specter’s impl namespace:
<a href="https://gist.github.com/darwin/90bcb9a87d7f1b492cd6d6400bcd103c#file-impl-cljs-L3" target="_blank">https://gist.github.com/darwin/90bcb9a87d7f1b492cd6d6400bcd103c#file-impl-cljs-L3</a></z><z id="t1464968190" t="darwin not sure about bootstrap, but cljs.js should be cljs.core in my case, I’m not in bootstrapped environment"><y>#</y><d>2016-06-03</d><h>15:36</h><w>darwin</w>not sure about bootstrap, but cljs.js should be cljs.core in my case, I’m not in bootstrapped environment</z><z id="t1464968252" t="nathanmarz You can ignore the warnings, and they&apos;re fixed for the next version: https://github.com/nathanmarz/specter/issues/97"><y>#</y><d>2016-06-03</d><h>15:37</h><w>nathanmarz</w>You can ignore the warnings, and they&apos;re fixed for the next version: <a href="https://github.com/nathanmarz/specter/issues/97" target="_blank">https://github.com/nathanmarz/specter/issues/97</a></z><z id="t1464968273" t="nathanmarz They have to do with code that&apos;s specifically for bootstrap cljs"><y>#</y><d>2016-06-03</d><h>15:37</h><w>nathanmarz</w>They have to do with code that&apos;s specifically for bootstrap cljs</z><z id="t1464968317" t="darwin ok, np, btw. I was searching open issues first and didn’t find anything related"><y>#</y><d>2016-06-03</d><h>15:38</h><w>darwin</w>ok, np, btw. I was searching open issues first and didn’t find anything related</z><z id="t1465045318" t="luxbock is there anything in specter that would allow me to do the following without resorting to the core functions I&apos;m currently using: (reduce + (map count (select [VALS] {:a [1 2 3] :b [5 6]}))) , or (reduce + (vals (transform [VALS] count {:a [1 2 3] :b [5 6]}))) ?"><y>#</y><d>2016-06-04</d><h>13:01</h><w>luxbock</w>is there anything in specter that would allow me to do the following without resorting to the core functions I&apos;m currently using:
<code>(reduce + (map count (select [VALS] {:a [1 2 3] :b [5 6]})))</code>, or
<code>(reduce + (vals (transform [VALS] count {:a [1 2 3] :b [5 6]})))</code> ?</z><z id="t1465045563" t="nathanmarz is this what you want? (select-one [(subselect ALL LAST ALL) (view count)] DATA)"><y>#</y><d>2016-06-04</d><h>13:06</h><w>nathanmarz</w>is this what you want? <code>(select-one [(subselect ALL LAST ALL) (view count)] DATA)</code></z><z id="t1465045638" t="nathanmarz you could also do (count (select [ALL LAST ALL] DATA))"><y>#</y><d>2016-06-04</d><h>13:07</h><w>nathanmarz</w>you could also do <code>(count (select [ALL LAST ALL] DATA))</code></z><z id="t1465045757" t="luxbock yeah both of those work, thanks"><y>#</y><d>2016-06-04</d><h>13:09</h><w>luxbock</w>yeah both of those work, thanks</z><z id="t1465045887" t="luxbock I&apos;m in a phase where I&apos;m trying to figure out where the line between using specter to do things, and having to break out of it to use the core functions is"><y>#</y><d>2016-06-04</d><h>13:11</h><w>luxbock</w>I&apos;m in a phase where I&apos;m trying to figure out where the line between using specter to do things, and having to break out of it to use the core functions is</z><z id="t1465045917" t="luxbock that line is probably quite high once you get familiar with all the features packed in 🙂"><y>#</y><d>2016-06-04</d><h>13:11</h><w>luxbock</w>that line is probably quite high once you get familiar with all the features packed in <b>🙂</b></z><z id="t1465045923" t="nathanmarz I&apos;m still in that phase 🙂"><y>#</y><d>2016-06-04</d><h>13:12</h><w>nathanmarz</w>I&apos;m still in that phase <b>🙂</b></z><z id="t1465045962" t="nathanmarz the line has gotten higher and higher over time as I&apos;ve realized how many things can be expressed elegantly in terms of navigation"><y>#</y><d>2016-06-04</d><h>13:12</h><w>nathanmarz</w>the line has gotten higher and higher over time as I&apos;ve realized how many things can be expressed elegantly in terms of navigation</z><z id="t1465045976" t="luxbock it feels a bit like when I first got comfortable with thinking about all Clojure problems as just transforming data back and fourth beetween the core data types and functions, it feels great!"><y>#</y><d>2016-06-04</d><h>13:12</h><w>luxbock</w>it feels a bit like when I first got comfortable with thinking about all Clojure problems as just transforming data back and fourth beetween the core data types and functions, it feels great!</z><z id="t1465046069" t="nathanmarz assuming your learning trajectory is similar to what mine was, prepare for a very rewarding ride"><y>#</y><d>2016-06-04</d><h>13:14</h><w>nathanmarz</w>assuming your learning trajectory is similar to what mine was, prepare for a very rewarding ride</z><z id="t1465046129" t="nathanmarz a big moment for me was figuring out the &quot;sub{x}&quot; navigators"><y>#</y><d>2016-06-04</d><h>13:15</h><w>nathanmarz</w>a big moment for me was figuring out the &quot;sub{x}&quot; navigators</z><z id="t1465046145" t="nathanmarz subset and then subgraph"><y>#</y><d>2016-06-04</d><h>13:15</h><w>nathanmarz</w>subset and then subgraph</z><z id="t1465080901" t="benzap If I have a row-major matrix, would this be the best way to retrieve a sub-matrix? `"><y>#</y><d>2016-06-04</d><h>22:55</h><w>benzap</w>If I have a row-major matrix, would this be the best way to retrieve a sub-matrix?

<code></code>`</z><z id="t1465080912" t="benzap (defn NAV-SUBMAT [i j rows cols] [specter/ALL (specter/srange i (+ i cols)) [(specter/srange j (+ j rows)) specter/ALL]])"><y>#</y><d>2016-06-04</d><h>22:55</h><w>benzap</w>(defn NAV-SUBMAT [i j rows cols]
  [specter/ALL (specter/srange i (+ i cols)) [(specter/srange j (+ j rows)) specter/ALL]])</z><z id="t1465081148" t="benzap oh woops, that doesn&apos;t work"><y>#</y><d>2016-06-04</d><h>22:59</h><w>benzap</w>oh woops, that doesn&apos;t work</z><z id="t1465081187" t="benzap This is what I was doing before, but I feel like it can be better `(-&gt;&gt; content (specter/select [specter/ALL (specter/srange col-offset (+ cols col-offset))]) (specter/select [(specter/srange row-offset (+ rows row-offset)) specter/ALL]))`"><y>#</y><d>2016-06-04</d><h>22:59</h><w>benzap</w>This is what I was doing before, but I feel like it can be better
`(-&gt;&gt; content
             (specter/select [specter/ALL (specter/srange col-offset (+ cols col-offset))])
             (specter/select [(specter/srange row-offset (+ rows row-offset)) specter/ALL]))`</z><z id="t1465081517" t="benzap it was backwards, this seems to work: (defn NAV-SUBMAT [i j rows cols] [[(specter/srange j (+ j rows)) specter/ALL] (specter/srange i (+ i cols))])"><y>#</y><d>2016-06-04</d><h>23:05</h><w>benzap</w>it was backwards, this seems to work: 

(defn NAV-SUBMAT [i j rows cols]
  [[(specter/srange j (+ j rows)) specter/ALL] (specter/srange i (+ i cols))])</z><z id="t1465185169" t="roberto is there a way to chain transformations?"><y>#</y><d>2016-06-06</d><h>03:52</h><w>roberto</w>is there a way to chain transformations?</z><z id="t1465185296" t="roberto nvm"><y>#</y><d>2016-06-06</d><h>03:54</h><w>roberto</w>nvm</z><z id="t1465305714" t="rodeorockstar this might be a silly question, but is specter/collect intended to be used in conjunction with specter/select, or is it strictly for transformations?"><y>#</y><d>2016-06-07</d><h>13:21</h><w>rodeorockstar</w>this might be a silly question, but is specter/collect intended to be used in conjunction with specter/select, or is it strictly for transformations?</z><z id="t1465306265" t="nathanmarz @rodeorockstar I use it sometimes with select"><y>#</y><d>2016-06-07</d><h>13:31</h><w>nathanmarz</w>@rodeorockstar I use it sometimes with <code>select</code></z><z id="t1465306308" t="nathanmarz It just lets you get more information about the context of each value"><y>#</y><d>2016-06-07</d><h>13:31</h><w>nathanmarz</w>It just lets you get more information about the context of each value</z><z id="t1465306352" t="rodeorockstar yeah, definitely useful when i&apos;ve needed it in the past, but i&apos;ve only used it for transformations where the collected data is passed to the transformation function"><y>#</y><d>2016-06-07</d><h>13:32</h><w>rodeorockstar</w>yeah, definitely useful when i&apos;ve needed it in the past, but i&apos;ve only used it for transformations where the collected data is passed to the transformation function</z><z id="t1465306383" t="rodeorockstar when used with select are collected keys just merged into the result of the select?"><y>#</y><d>2016-06-07</d><h>13:33</h><w>rodeorockstar</w>when used with select are collected keys just merged into the result of the select?</z><z id="t1465306595" t="nathanmarz yea, each result becomes a vector with the final navigated to value as the final element in the vector"><y>#</y><d>2016-06-07</d><h>13:36</h><w>nathanmarz</w>yea, each result becomes a vector with the final navigated to value as the final element in the vector</z><z id="t1465306620" t="rodeorockstar ah, that makes a lot more sense now"><y>#</y><d>2016-06-07</d><h>13:37</h><w>rodeorockstar</w>ah, that makes a lot more sense now</z><z id="t1465306643" t="nathanmarz (select VAL 1) -&gt; [[1 1]]"><y>#</y><d>2016-06-07</d><h>13:37</h><w>nathanmarz</w><code>(select VAL 1)</code> -&gt; <code>[[1 1]]</code></z><z id="t1465306860" t="rodeorockstar thanks for the help 🙂"><y>#</y><d>2016-06-07</d><h>13:41</h><w>rodeorockstar</w>thanks for the help <b>🙂</b></z><z id="t1465306927" t="nathanmarz no problem"><y>#</y><d>2016-06-07</d><h>13:42</h><w>nathanmarz</w>no problem</z><z id="t1465390896" t="quantisan I&apos;m trying to replace my group-by /`merge-with` logic, any suggestion on how to transform: {:1000 {:a {:sends 1}} :2000 {:a {:clicks 1 :opens 1 :sends 1}} :3000 {:b {:sends 1 :opens 1}}} into {:a {:sends 2 :opens 1 :clicks 1} :b {:sends 1 :opens 1}} "><y>#</y><d>2016-06-08</d><h>13:01</h><w>quantisan</w>I&apos;m trying to replace my <code>group-by</code>/`merge-with` logic, any suggestion on how to transform:

<pre>{:1000 {:a {:sends 1}}
 :2000 {:a {:clicks 1 :opens 1 :sends 1}}
 :3000 {:b {:sends 1 :opens 1}}}
</pre>

into

<pre>{:a {:sends 2 :opens 1 :clicks 1}
 :b {:sends 1 :opens 1}}
</pre></z><z id="t1465391715" t="nathanmarz I don&apos;t see a way to express that in terms of navigation"><y>#</y><d>2016-06-08</d><h>13:15</h><w>nathanmarz</w>I don&apos;t see a way to express that in terms of navigation</z><z id="t1465391833" t="quantisan here&apos;s my current ugly solution: (-&gt;&gt; {:1000 {:a {:sends 1}} :2000 {:a {:clicks 1 :opens 1 :sends 1}} :3000 {:b {:sends 1 :opens 1}}} (select [ALL LAST]) (group-by (comp first keys)) (transform [ALL LAST] #(select [ALL LAST LAST] %)) (transform [ALL LAST] (partial apply merge-with +))) "><y>#</y><d>2016-06-08</d><h>13:17</h><w>quantisan</w>here&apos;s my current ugly solution:

<pre>(-&gt;&gt; {:1000 {:a {:sends 1}}
      :2000 {:a {:clicks 1 :opens 1 :sends 1}}
      :3000 {:b {:sends 1 :opens 1}}}
     (select [ALL LAST])
     (group-by (comp first keys))
     (transform [ALL LAST]
                #(select [ALL LAST LAST] %))
     (transform [ALL LAST]
                (partial apply merge-with +)))
</pre></z><z id="t1465392097" t="nathanmarz hmm"><y>#</y><d>2016-06-08</d><h>13:21</h><w>nathanmarz</w>hmm</z><z id="t1465392112" t="nathanmarz (defn merge-with* [f maps] (apply merge-with f maps) ) (merge-with* (fn [&amp; maps] (merge-with* + maps)) (vals data)) "><y>#</y><d>2016-06-08</d><h>13:21</h><w>nathanmarz</w><pre>(defn merge-with* [f maps]
  (apply merge-with f maps)
  )

(merge-with* (fn [&amp; maps] (merge-with* + maps)) (vals data))
</pre></z><z id="t1465392133" t="nathanmarz maybe you could define a merge-with navigator somehow"><y>#</y><d>2016-06-08</d><h>13:22</h><w>nathanmarz</w>maybe you could define a merge-with navigator somehow</z><z id="t1465392219" t="nathanmarz like from a sequence of maps you navigate to a sequence of values for any given key"><y>#</y><d>2016-06-08</d><h>13:23</h><w>nathanmarz</w>like from a sequence of maps you navigate to a sequence of values for any given key</z><z id="t1465392307" t="nathanmarz so then you could do (transform [MERGED-MAPS MERGED-MAPS] sum (vals data))"><y>#</y><d>2016-06-08</d><h>13:25</h><w>nathanmarz</w>so then you could do <pre>(transform [MERGED-MAPS MERGED-MAPS] sum (vals data))</pre></z><z id="t1465392422" t="nathanmarz yea it works"><y>#</y><d>2016-06-08</d><h>13:27</h><w>nathanmarz</w>yea it works</z><z id="t1465392484" t="nathanmarz (defnav MERGED-MAPS [] (select* [this structure next-fn] ;;TODO: fill this in ) (transform* [this structure next-fn] (apply merge-with (fn [&amp; vals] (next-fn vals)) structure) )) (defn sum [vals] (reduce + vals)) (def data {:1000 {:a {:sends 1}} :2000 {:a {:clicks 1 :opens 1 :sends 1}} :3000 {:b {:sends 1 :opens 1}}}) (transform [MERGED-MAPS MERGED-MAPS] sum (vals data)) "><y>#</y><d>2016-06-08</d><h>13:28</h><w>nathanmarz</w><pre>(defnav MERGED-MAPS []
  (select* [this structure next-fn]
    ;;TODO: fill this in
    )
  (transform* [this structure next-fn]
    (apply merge-with (fn [&amp; vals] (next-fn vals)) structure)
    ))


(defn sum [vals] (reduce + vals))



(def data
 {:1000 {:a {:sends 1}}
  :2000 {:a {:clicks 1 :opens 1 :sends 1}}
  :3000 {:b {:sends 1 :opens 1}}})

(transform [MERGED-MAPS MERGED-MAPS] sum (vals data))
</pre></z><z id="t1465392538" t="quantisan @nathanmarz: magic 😉"><y>#</y><d>2016-06-08</d><h>13:28</h><w>quantisan</w>@nathanmarz: magic <b>😉</b></z><z id="t1465392637" t="nathanmarz I do what I can"><y>#</y><d>2016-06-08</d><h>13:30</h><w>nathanmarz</w>I do what I can</z><z id="t1465393168" t="nathanmarz oops, had sum written incorrectly there"><y>#</y><d>2016-06-08</d><h>13:39</h><w>nathanmarz</w>oops, had <code>sum</code> written incorrectly there</z><z id="t1465393175" t="nathanmarz now it&apos;s fixed"><y>#</y><d>2016-06-08</d><h>13:39</h><w>nathanmarz</w>now it&apos;s fixed</z><z id="t1465413780" t="aengelberg @nathanmarz I agree with your point about OMIT . My main reasoning for proposing it was that it allows you to control which layer of the path you want to pass NONE to. For example: (transform [ALL (if-path ... STAY OMIT) ALL (if-path ... STAY OMIT) :a (if-path ... STAY OMIT) ...] ...) Is there a more idiomatic way to do this without coupling the navigation and the transformation as tightly?"><y>#</y><d>2016-06-08</d><h>19:23</h><w>aengelberg</w>@nathanmarz I agree with your point about <code>OMIT</code>. My main reasoning for proposing it was that it allows you to control which layer of the path you want to pass <code>NONE</code> to. For example:
<pre>(transform [ALL (if-path ... STAY OMIT) ALL (if-path ... STAY OMIT) :a (if-path ... STAY OMIT) ...] ...)
</pre>
Is there a more idiomatic way to do this without coupling the navigation and the transformation as tightly?</z><z id="t1465416708" t="nathanmarz well I think what you want is a single operation that can do multiple transforms"><y>#</y><d>2016-06-08</d><h>20:11</h><w>nathanmarz</w>well I think what you want is a single operation that can do multiple transforms</z><z id="t1465416735" t="nathanmarz @aengelberg as it stands now transform does a single transform to all navigated elements"><y>#</y><d>2016-06-08</d><h>20:12</h><w>nathanmarz</w>@aengelberg as it stands now <code>transform</code> does a single transform to all navigated elements</z><z id="t1465416771" t="nathanmarz I&apos;ve thought a bit about this, and basically you could imagine a different transform API that does not take in a transform-fn at the top-level"><y>#</y><d>2016-06-08</d><h>20:12</h><w>nathanmarz</w>I&apos;ve thought a bit about this, and basically you could imagine a different transform API that does not take in a transform-fn at the top-level</z><z id="t1465416815" t="nathanmarz (multi-transform [ALL (if-path even? (setval-transform 2) (setval-transform NONE))] data)"><y>#</y><d>2016-06-08</d><h>20:13</h><w>nathanmarz</w>(multi-transform [ALL (if-path even? (setval-transform 2) (setval-transform NONE))] data)</z><z id="t1465416917" t="aengelberg The question being whether it&apos;s worth an exception being made for the &quot;specter abstracts the path from the transformation&quot; idea"><y>#</y><d>2016-06-08</d><h>20:15</h><w>aengelberg</w>The question being whether it&apos;s worth an exception being made for the &quot;specter abstracts the path from the transformation&quot; idea</z><z id="t1465416945" t="nathanmarz yea"><y>#</y><d>2016-06-08</d><h>20:15</h><w>nathanmarz</w>yea</z><z id="t1465416956" t="nathanmarz that&apos;s basically why I&apos;ve held off on this"><y>#</y><d>2016-06-08</d><h>20:15</h><w>nathanmarz</w>that&apos;s basically why I&apos;ve held off on this</z><z id="t1465416995" t="nathanmarz and also I&apos;ve gotten by just chaining multiple transformations"><y>#</y><d>2016-06-08</d><h>20:16</h><w>nathanmarz</w>and also I&apos;ve gotten by just chaining multiple transformations</z><z id="t1465417008" t="nathanmarz (-&gt;&gt; data (transform ...) (transform ...))"><y>#</y><d>2016-06-08</d><h>20:16</h><w>nathanmarz</w><code>(-&gt;&gt; data (transform ...) (transform ...))</code></z><z id="t1465417069" t="aengelberg But that&apos;s less efficient right?"><y>#</y><d>2016-06-08</d><h>20:17</h><w>aengelberg</w>But that&apos;s less efficient right?</z><z id="t1465417080" t="nathanmarz yea, which is why I keep thinking about this 🙂"><y>#</y><d>2016-06-08</d><h>20:18</h><w>nathanmarz</w>yea, which is why I keep thinking about this <b>🙂</b></z><z id="t1465417096" t="aengelberg heh"><y>#</y><d>2016-06-08</d><h>20:18</h><w>aengelberg</w>heh</z><z id="t1465417111" t="nathanmarz that said, I don&apos;t think places where I do that are bottlenecks for me"><y>#</y><d>2016-06-08</d><h>20:18</h><w>nathanmarz</w>that said, I don&apos;t think places where I do that are bottlenecks for me</z><z id="t1465417121" t="aengelberg Btw I&apos;ve been thinking about the new select semantics, there may be an opportunity to introduce transducers"><y>#</y><d>2016-06-08</d><h>20:18</h><w>aengelberg</w>Btw I&apos;ve been thinking about the new select semantics, there may be an opportunity to introduce transducers</z><z id="t1465417139" t="aengelberg Since the continuation is basically a &quot;reducer&quot;"><y>#</y><d>2016-06-08</d><h>20:18</h><w>aengelberg</w>Since the continuation is basically a &quot;reducer&quot;</z><z id="t1465417195" t="nathanmarz mm"><y>#</y><d>2016-06-08</d><h>20:19</h><w>nathanmarz</w>mm</z></g><g id="s1"><z id="t1465417196" t="nathanmarz hmm"><y>#</y><d>2016-06-08</d><h>20:19</h><w>nathanmarz</w>hmm</z><z id="t1465417199" t="nathanmarz got an example?"><y>#</y><d>2016-06-08</d><h>20:19</h><w>nathanmarz</w>got an example?</z><z id="t1465417237" t="aengelberg (select [ALL] (map inc) [1 2 3]) =&gt; [2 3 4] "><y>#</y><d>2016-06-08</d><h>20:20</h><w>aengelberg</w><pre>(select [ALL] (map inc) [1 2 3])
=&gt;
[2 3 4]
</pre></z><z id="t1465417278" t="aengelberg (select-reduce conj [] [ALL] [1 2 3]) "><y>#</y><d>2016-06-08</d><h>20:21</h><w>aengelberg</w><pre>(select-reduce conj [] [ALL] [1 2 3])
</pre></z><z id="t1465417346" t="aengelberg just some ideas. the latter would be achieved by storing the reduced value in a cell and repeatedly updating it"><y>#</y><d>2016-06-08</d><h>20:22</h><w>aengelberg</w>just some ideas. the latter would be achieved by storing the reduced value in a cell and repeatedly updating it</z><z id="t1465417362" t="nathanmarz that last one would output [1 2 3]?"><y>#</y><d>2016-06-08</d><h>20:22</h><w>nathanmarz</w>that last one would output [1 2 3]?</z><z id="t1465417368" t="aengelberg yes"><y>#</y><d>2016-06-08</d><h>20:22</h><w>aengelberg</w>yes</z><z id="t1465417382" t="nathanmarz I&apos;m not following"><y>#</y><d>2016-06-08</d><h>20:23</h><w>nathanmarz</w>I&apos;m not following</z><z id="t1465417431" t="aengelberg If I understand the new select semantics properly, the continuation (or &quot;final next-fn&quot;) is currently &quot;dump into a vector&quot;. I&apos;m proposing letting the user specify an alternative for that continuation"><y>#</y><d>2016-06-08</d><h>20:23</h><w>aengelberg</w>If I understand the new select semantics properly, the continuation (or &quot;final next-fn&quot;) is currently &quot;dump into a vector&quot;. I&apos;m proposing letting the user specify an alternative for that continuation</z><z id="t1465417444" t="nathanmarz oh I see"><y>#</y><d>2016-06-08</d><h>20:24</h><w>nathanmarz</w>oh I see</z><z id="t1465417452" t="nathanmarz well there are different continuations for the different selects"><y>#</y><d>2016-06-08</d><h>20:24</h><w>nathanmarz</w>well there are different continuations for the different selects</z><z id="t1465417476" t="nathanmarz you basically want &quot;traverse&quot; exposed"><y>#</y><d>2016-06-08</d><h>20:24</h><w>nathanmarz</w>you basically want &quot;traverse&quot; exposed</z><z id="t1465417560" t="aengelberg I just looked up traverse , didn&apos;t realize that was generalizing the continuation internally. Yeah, that&apos;s basically what I&apos;m saying"><y>#</y><d>2016-06-08</d><h>20:26</h><w>aengelberg</w>I just looked up <code>traverse</code>, didn&apos;t realize that was generalizing the continuation internally. Yeah, that&apos;s basically what I&apos;m saying</z><z id="t1465417729" t="nathanmarz I haven&apos;t completely internalized transducers yet"><y>#</y><d>2016-06-08</d><h>20:28</h><w>nathanmarz</w>I haven&apos;t completely internalized transducers yet</z><z id="t1465417749" t="aengelberg transducer: reducer -&gt; reducer"><y>#</y><d>2016-06-08</d><h>20:29</h><w>aengelberg</w>transducer: reducer -&gt; reducer</z><z id="t1465417756" t="nathanmarz yea"><y>#</y><d>2016-06-08</d><h>20:29</h><w>nathanmarz</w>yea</z><z id="t1465417770" t="nathanmarz but basically it&apos;s like an aggregator that looks at its input one value at a time"><y>#</y><d>2016-06-08</d><h>20:29</h><w>nathanmarz</w>but basically it&apos;s like an aggregator that looks at its input one value at a time</z><z id="t1465417787" t="nathanmarz and specter traverse looks at values one at a time"><y>#</y><d>2016-06-08</d><h>20:29</h><w>nathanmarz</w>and specter traverse looks at values one at a time</z><z id="t1465417836" t="aengelberg exposing traverse isn&apos;t necessarily related at all to transducers"><y>#</y><d>2016-06-08</d><h>20:30</h><w>aengelberg</w>exposing <code>traverse</code> isn&apos;t necessarily related at all to transducers</z><z id="t1465417865" t="nathanmarz but you&apos;re saying you could just plug in a transducer for that continuation fn"><y>#</y><d>2016-06-08</d><h>20:31</h><w>nathanmarz</w>but you&apos;re saying you could just plug in a transducer for that continuation fn</z><z id="t1465417888" t="aengelberg err, my posting two examples above probably made things confusing."><y>#</y><d>2016-06-08</d><h>20:31</h><w>aengelberg</w>err, my posting two examples above probably made things confusing.</z><z id="t1465417919" t="aengelberg My first example (providing (map inc) ) was supplying a transducer to modify the hardcoded reducer"><y>#</y><d>2016-06-08</d><h>20:31</h><w>aengelberg</w>My first example (providing <code>(map inc)</code>) was supplying a transducer to modify the hardcoded reducer</z><z id="t1465417925" t="aengelberg The second example (providing conj ) was replacing the reducer"><y>#</y><d>2016-06-08</d><h>20:32</h><w>aengelberg</w>The second example (providing <code>conj</code>) was replacing the reducer</z><z id="t1465417935" t="aengelberg You could potentially combine both"><y>#</y><d>2016-06-08</d><h>20:32</h><w>aengelberg</w>You could potentially combine both</z><z id="t1465417963" t="aengelberg Except there isn&apos;t much advantage of providing both since the user can just call (my-transducer my-reducer) and get a reducer to pass in"><y>#</y><d>2016-06-08</d><h>20:32</h><w>aengelberg</w>Except there isn&apos;t much advantage of providing both since the user can just call <code>(my-transducer my-reducer)</code> and get a reducer to pass in</z><z id="t1465418348" t="nathanmarz what if specter could just integrate into the normal transducer api?"><y>#</y><d>2016-06-08</d><h>20:39</h><w>nathanmarz</w>what if specter could just integrate into the normal transducer api?</z><z id="t1465418374" t="nathanmarz (eduction xf (traverse [ALL :a even?] data))"><y>#</y><d>2016-06-08</d><h>20:39</h><w>nathanmarz</w><code>(eduction xf (traverse [ALL :a even?] data))</code></z><z id="t1465418395" t="nathanmarz or even (eduction xf (traverse [ALL :a even?]) data)"><y>#</y><d>2016-06-08</d><h>20:39</h><w>nathanmarz</w>or even <code>(eduction xf (traverse [ALL :a even?]) data)</code></z><z id="t1465418418" t="nathanmarz actually the former probably makes more sense"><y>#</y><d>2016-06-08</d><h>20:40</h><w>nathanmarz</w>actually the former probably makes more sense</z><z id="t1465418591" t="aengelberg the latter I think would actually be (sequence (traverse [ALL :a even?]) data)"><y>#</y><d>2016-06-08</d><h>20:43</h><w>aengelberg</w>the latter I think would actually be <code>(sequence (traverse [ALL :a even?]) data)</code></z><z id="t1465418622" t="aengelberg or (sequence (comp xf (traverse [ALL :a even?])) data)"><y>#</y><d>2016-06-08</d><h>20:43</h><w>aengelberg</w>or <code>(sequence (comp xf (traverse [ALL :a even?])) data)</code></z><z id="t1465418701" t="aengelberg Would traverse apply the transformation to each input form?"><y>#</y><d>2016-06-08</d><h>20:45</h><w>aengelberg</w>Would <code>traverse</code> apply the transformation to each input form?</z><z id="t1465418720" t="aengelberg err select, not transformation"><y>#</y><d>2016-06-08</d><h>20:45</h><w>aengelberg</w>err select, not transformation</z><z id="t1465418722" t="nathanmarz here I&apos;m thinking traverse would return an object that can be reduced"><y>#</y><d>2016-06-08</d><h>20:45</h><w>nathanmarz</w>here I&apos;m thinking traverse would return an object that can be reduced</z><z id="t1465418735" t="aengelberg that makes more sense"><y>#</y><d>2016-06-08</d><h>20:45</h><w>aengelberg</w>that makes more sense</z><z id="t1465418743" t="aengelberg i.e. implements IReduce"><y>#</y><d>2016-06-08</d><h>20:45</h><w>aengelberg</w>i.e. implements <code>IReduce</code></z><z id="t1465418748" t="nathanmarz yea"><y>#</y><d>2016-06-08</d><h>20:45</h><w>nathanmarz</w>yea</z><z id="t1465418750" t="aengelberg :+1:"><y>#</y><d>2016-06-08</d><h>20:45</h><w>aengelberg</w><b>:+1:</b></z><z id="t1465418768" t="aengelberg and we wouldn&apos;t have to worry about clojure 1.6 compatibility I don&apos;t think"><y>#</y><d>2016-06-08</d><h>20:46</h><w>aengelberg</w>and we wouldn&apos;t have to worry about clojure 1.6 compatibility I don&apos;t think</z><z id="t1465418786" t="nathanmarz yea"><y>#</y><d>2016-06-08</d><h>20:46</h><w>nathanmarz</w>yea</z><z id="t1465418796" t="nathanmarz although I think I might drop that soon anyway"><y>#</y><d>2016-06-08</d><h>20:46</h><w>nathanmarz</w>although I think I might drop that soon anyway</z><z id="t1465418820" t="nathanmarz 1.9 is coming out and I&apos;m sick of cljx 😉"><y>#</y><d>2016-06-08</d><h>20:47</h><w>nathanmarz</w>1.9 is coming out and I&apos;m sick of cljx <b>😉</b></z><z id="t1465418872" t="aengelberg I was working on a project last year but got stuck on leiningen issues. the idea was a plugin that would take cljc files and output clj / cljs similar to cljx"><y>#</y><d>2016-06-08</d><h>20:47</h><w>aengelberg</w>I was working on a project last year but got stuck on leiningen issues. the idea was a plugin that would take cljc files and output clj / cljs similar to cljx</z><z id="t1465418892" t="nathanmarz that would have helped a lot"><y>#</y><d>2016-06-08</d><h>20:48</h><w>nathanmarz</w>that would have helped a lot</z><z id="t1465418934" t="aengelberg the main motivation actually was for instaparse; we don&apos;t really want to pull in instaparse-cljs until a non-deprecated cross-compile solution exists"><y>#</y><d>2016-06-08</d><h>20:48</h><w>aengelberg</w>the main motivation actually was for instaparse; we don&apos;t really want to pull in <code>instaparse-cljs</code> until a non-deprecated cross-compile solution exists</z><z id="t1465418993" t="aengelberg (that also works with &lt;1.7)"><y>#</y><d>2016-06-08</d><h>20:49</h><w>aengelberg</w>(that also works with &lt;1.7)</z><z id="t1465419039" t="aengelberg maybe i&apos;ll pick it back up soon, the main blocking issue was leiningen&apos;s built-in tools.reader was too old (no longer an issue probably)"><y>#</y><d>2016-06-08</d><h>20:50</h><w>aengelberg</w>maybe i&apos;ll pick it back up soon, the main blocking issue was leiningen&apos;s built-in tools.reader was too old (no longer an issue probably)</z><z id="t1465419062" t="nathanmarz any idea how many people are still on 1.6?"><y>#</y><d>2016-06-08</d><h>20:51</h><w>nathanmarz</w>any idea how many people are still on 1.6?</z><z id="t1465419068" t="nathanmarz or below"><y>#</y><d>2016-06-08</d><h>20:51</h><w>nathanmarz</w>or below</z><z id="t1465419175" t="aengelberg my previous job was still on 1.6 well into the lifetime of 1.8"><y>#</y><d>2016-06-08</d><h>20:52</h><w>aengelberg</w>my previous job was still on 1.6 well into the lifetime of 1.8</z><z id="t1465419220" t="aengelberg just one data point, not sure how realistic it is to continue support for 1.6 especially with cider now on &gt;1.7"><y>#</y><d>2016-06-08</d><h>20:53</h><w>aengelberg</w>just one data point, not sure how realistic it is to continue support for 1.6 especially with cider now on &gt;1.7</z><z id="t1465431663" t="aengelberg @nathanmarz shall I create a github issue for the reducible traverse idea?"><y>#</y><d>2016-06-09</d><h>00:21</h><w>aengelberg</w>@nathanmarz shall I create a github issue for the reducible <code>traverse</code> idea?</z><z id="t1465432103" t="nathanmarz @aengelberg yea"><y>#</y><d>2016-06-09</d><h>00:28</h><w>nathanmarz</w>@aengelberg yea</z><z id="t1465432427" t="aengelberg done"><y>#</y><d>2016-06-09</d><h>00:33</h><w>aengelberg</w>done</z><z id="t1465471886" t="mac Do I have to do something special use specter from cljs? I have [com.rpl/specter &quot;0.11.1&quot;] in my build.boot (set-env! :dependencies), but my :require [com.rpl.specter :refer [select]] fails with &quot;Referred var com.rpl.specter/select does not exist&quot;"><y>#</y><d>2016-06-09</d><h>11:31</h><w>mac</w>Do I have to do something special use specter from cljs? I have [com.rpl/specter &quot;0.11.1&quot;] in my build.boot (set-env! :dependencies), but my :require [com.rpl.specter :refer [select]] fails with  &quot;Referred var com.rpl.specter/select does not exist&quot;</z><z id="t1465471937" t="nathanmarz @mac the core select/transform/etc. operations are macros now in com.rpl.specter.macros namespace"><y>#</y><d>2016-06-09</d><h>11:32</h><w>nathanmarz</w>@mac the core select/transform/etc. operations are macros now in com.rpl.specter.macros namespace</z><z id="t1465471960" t="nathanmarz that was a change in 0.11.0"><y>#</y><d>2016-06-09</d><h>11:32</h><w>nathanmarz</w>that was a change in 0.11.0</z><z id="t1465471963" t="mac Ah, got it."><y>#</y><d>2016-06-09</d><h>11:32</h><w>mac</w>Ah, got it.</z><z id="t1465472723" t="mac I get a ton of warnings about &quot;Use of undeclared Var com.rpl.specter.impl/compiled-select*&quot; just from using select."><y>#</y><d>2016-06-09</d><h>11:45</h><w>mac</w>I get a ton of warnings about &quot;Use of undeclared Var com.rpl.specter.impl/compiled-select*&quot; just from using select.</z><z id="t1465472814" t="mac @nathanmarz: I just added (:require-macros [com.rpl.specter.macros :as sp]) to my namespace."><y>#</y><d>2016-06-09</d><h>11:46</h><w>mac</w>@nathanmarz: I just added (:require-macros
          [com.rpl.specter.macros :as sp]) to my namespace.</z><z id="t1465472934" t="nathanmarz are you also requiring com.rpl.specter namespace?"><y>#</y><d>2016-06-09</d><h>11:48</h><w>nathanmarz</w>are you also requiring com.rpl.specter namespace?</z><z id="t1465473017" t="mac nathanmarz: no, is that the issue?"><y>#</y><d>2016-06-09</d><h>11:50</h><w>mac</w>nathanmarz: no, is that the issue?</z><z id="t1465473026" t="nathanmarz could be"><y>#</y><d>2016-06-09</d><h>11:50</h><w>nathanmarz</w>could be</z><z id="t1465473054" t="mac nathanmarz: that fixed it 🙂"><y>#</y><d>2016-06-09</d><h>11:50</h><w>mac</w>nathanmarz: that fixed it <b>🙂</b></z><z id="t1465473058" t="nathanmarz cool"><y>#</y><d>2016-06-09</d><h>11:50</h><w>nathanmarz</w>cool</z><z id="t1465473173" t="mac nathanmarz: thanks, specter is a fantastic piece of kit."><y>#</y><d>2016-06-09</d><h>11:52</h><w>mac</w>nathanmarz: thanks, specter is a fantastic piece of kit.</z><z id="t1465473194" t="nathanmarz thanks"><y>#</y><d>2016-06-09</d><h>11:53</h><w>nathanmarz</w>thanks</z><z id="t1465487485" t="conaw @nathanmarz: when would you use continue-then-stay, vs stay-then-continue."><y>#</y><d>2016-06-09</d><h>15:51</h><w>conaw</w>@nathanmarz: when would you use continue-then-stay, vs stay-then-continue.</z><z id="t1465487527" t="nathanmarz the first is pre-order traversal, the 2nd is post-order"><y>#</y><d>2016-06-09</d><h>15:52</h><w>nathanmarz</w>the first is pre-order traversal, the 2nd is post-order</z><z id="t1465487537" t="nathanmarz in that tree example continue-then-stay would visit the leaves first"><y>#</y><d>2016-06-09</d><h>15:52</h><w>nathanmarz</w>in that tree example continue-then-stay would visit the leaves first</z><z id="t1465487572" t="conaw I’m just trying to think of an example problem, and how that might affect composition"><y>#</y><d>2016-06-09</d><h>15:52</h><w>conaw</w>I’m just trying to think of an example problem, and how that might affect composition</z><z id="t1465487612" t="nathanmarz if you&apos;re changing the structure of the tree itself it can change the result"><y>#</y><d>2016-06-09</d><h>15:53</h><w>nathanmarz</w>if you&apos;re changing the structure of the tree itself it can change the result</z><z id="t1465487640" t="nathanmarz post-order that adds children will not visit the children in the same navigation, pre-order will"><y>#</y><d>2016-06-09</d><h>15:54</h><w>nathanmarz</w>post-order that adds children  will not visit the children in the same navigation, pre-order will</z><z id="t1465488216" t="conaw Inside a recursive navigation path that was visiting every element in a tree this is irrelevant though"><y>#</y><d>2016-06-09</d><h>16:03</h><w>conaw</w>Inside a recursive navigation path that was visiting every element in a tree this is irrelevant though</z><z id="t1465488292" t="conaw I’m just trying to imagine step by step what specter is returning. Is it possible with a continue-then-stay to collect-one from all the leaves of a tree"><y>#</y><d>2016-06-09</d><h>16:04</h><w>conaw</w>I’m just trying to imagine step by step what specter is returning.  Is it possible with a continue-then-stay to collect-one from all the leaves of a tree</z><z id="t1465488319" t="conaw sort of, get the path from each leaf to the root node?"><y>#</y><d>2016-06-09</d><h>16:05</h><w>conaw</w>sort of, get the path from each leaf to the root node?</z><z id="t1465488832" t="conaw got it"><y>#</y><d>2016-06-09</d><h>16:13</h><w>conaw</w>got it</z><z id="t1465489262" t="nathanmarz @conaw you figured out how to do it?"><y>#</y><d>2016-06-09</d><h>16:21</h><w>nathanmarz</w>@conaw you figured out how to do it?</z><z id="t1465489315" t="conaw well, figured out when I might use pre-order and post-order in a select I’m not totally sure how to do the transform though"><y>#</y><d>2016-06-09</d><h>16:21</h><w>conaw</w>well, figured out when I might use pre-order and post-order in a select  I’m not totally sure how to do the transform though</z><z id="t1465489353" t="conaw Is there a way to use setval and just set the val of a particular submap to the values collected"><y>#</y><d>2016-06-09</d><h>16:22</h><w>conaw</w>Is there a way to use setval and just set the val of a particular submap to the values collected</z><z id="t1465489370" t="nathanmarz you need to use transform for that"><y>#</y><d>2016-06-09</d><h>16:22</h><w>nathanmarz</w>you need to use transform for that</z><z id="t1465489402" t="nathanmarz setval ignores value collection"><y>#</y><d>2016-06-09</d><h>16:23</h><w>nathanmarz</w>setval ignores value collection</z><z id="t1465489560" t="conaw gotcha, is it possible to use VAL or collect-one inside of continue-then-stay"><y>#</y><d>2016-06-09</d><h>16:26</h><w>conaw</w>gotcha, is it possible to use VAL or collect-one inside of continue-then-stay</z><z id="t1465489673" t="conaw I keep getting an arity error or nil values"><y>#</y><d>2016-06-09</d><h>16:27</h><w>conaw</w>I keep getting an arity error or nil values</z><z id="t1465489762" t="nathanmarz show me the code"><y>#</y><d>2016-06-09</d><h>16:29</h><w>nathanmarz</w>show me the code</z><z id="t1465489796" t="conaw (transform [ALL (sp/continue-then-stay :children ALL (collect-one :node)) :parents] (fn [&amp; xs] (vector xs)) samplemap)"><y>#</y><d>2016-06-09</d><h>16:29</h><w>conaw</w><pre>(transform [ALL (sp/continue-then-stay :children ALL (collect-one :node)) :parents] 
         (fn [&amp; xs] (vector xs))   samplemap)</pre></z><z id="t1465489810" t="conaw multiple arities passed to next-fn"><y>#</y><d>2016-06-09</d><h>16:30</h><w>conaw</w>multiple arities passed to next-fn</z><z id="t1465489856" t="conaw or rather, wrong number of args(2) passed"><y>#</y><d>2016-06-09</d><h>16:30</h><w>conaw</w>or rather, wrong number of args(2) passed</z><z id="t1465489945" t="nathanmarz oh"><y>#</y><d>2016-06-09</d><h>16:32</h><w>nathanmarz</w>oh</z><z id="t1465489951" t="nathanmarz that&apos;s the only known bug in specter"><y>#</y><d>2016-06-09</d><h>16:32</h><w>nathanmarz</w>that&apos;s the only known bug in specter</z><z id="t1465489956" t="nathanmarz https://github.com/nathanmarz/specter/issues/64"><y>#</y><d>2016-06-09</d><h>16:32</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/issues/64" target="_blank">https://github.com/nathanmarz/specter/issues/64</a></z><z id="t1465489961" t="conaw lol"><y>#</y><d>2016-06-09</d><h>16:32</h><w>conaw</w>lol</z><z id="t1465489986" t="conaw continue-then-stay is a wrapper on multi-path then"><y>#</y><d>2016-06-09</d><h>16:33</h><w>conaw</w>continue-then-stay is a wrapper on multi-path then</z><z id="t1465490003" t="nathanmarz yea"><y>#</y><d>2016-06-09</d><h>16:33</h><w>nathanmarz</w>yea</z><z id="t1465490019" t="nathanmarz same is true for any of the higher order navigators"><y>#</y><d>2016-06-09</d><h>16:33</h><w>nathanmarz</w>same is true for any of the higher order navigators</z><z id="t1465490021" t="nathanmarz like if-path"><y>#</y><d>2016-06-09</d><h>16:33</h><w>nathanmarz</w>like if-path</z><z id="t1465490054" t="conaw cool"><y>#</y><d>2016-06-09</d><h>16:34</h><w>conaw</w>cool</z><z id="t1465490413" t="conaw Also, you mentioned at Clojure/West a few exercises that you thought were good for figuring out how to write navigators or paths well. I think you said something about nested vectors of maps. I’m trying to put together a sort of 4clojurey set of challenges for someone learning specter, if you (or anyone else in this room) have any sample problems I’d love them"><y>#</y><d>2016-06-09</d><h>16:40</h><w>conaw</w>Also, you mentioned at Clojure/West a few exercises that you thought were good for figuring out how to write navigators or paths well.   I think you said something about nested vectors of maps.  I’m trying to put together a sort of 4clojurey set of challenges for someone learning specter, if you (or anyone else in this room) have any sample problems I’d love them</z><z id="t1465491339" t="aengelberg my favorite exercise (spoiler alert, it can only be elegantly solved with subselect ) is: ;; given a vector of vectors, reverse all numbers without changing the length of any vector in: [[1 2 3] [4 5] [6] [7] [8 9 10]] out: [[10 9 8] [7 6] [5] [4] [3 2 1]] "><y>#</y><d>2016-06-09</d><h>16:55</h><w>aengelberg</w>my favorite exercise (spoiler alert, it can only be elegantly solved with <code>subselect</code>) is:
<pre>;; given a vector of vectors, reverse all numbers without changing the length of any vector
in:  [[1 2 3] [4 5] [6] [7] [8 9 10]]
out: [[10 9 8] [7 6] [5] [4] [3 2 1]]
</pre></z><z id="t1465491413" t="conaw love it"><y>#</y><d>2016-06-09</d><h>16:56</h><w>conaw</w>love it</z><z id="t1465491599" t="conaw hey that is quite elegant"><y>#</y><d>2016-06-09</d><h>16:59</h><w>conaw</w>hey that is quite elegant</z><z id="t1465491603" t="aengelberg 🙂"><y>#</y><d>2016-06-09</d><h>17:00</h><w>aengelberg</w><b>🙂</b></z><z id="t1465491631" t="nathanmarz here&apos;s another one: concatenate all continuous sequences of strings together"><y>#</y><d>2016-06-09</d><h>17:00</h><w>nathanmarz</w>here&apos;s another one: concatenate all continuous sequences of strings together</z><z id="t1465491646" t="nathanmarz [&quot;hello&quot; &quot; &quot; &quot;word&quot; 1 2 &quot;a&quot; &quot;b&quot; 3] -&gt; [&quot;hello word&quot; 1 2 &quot;ab&quot; 3]"><y>#</y><d>2016-06-09</d><h>17:00</h><w>nathanmarz</w><code>[&quot;hello&quot; &quot; &quot; &quot;word&quot; 1 2 &quot;a&quot; &quot;b&quot; 3]</code> -&gt; <code>[&quot;hello word&quot; 1 2 &quot;ab&quot; 3]</code></z><z id="t1465491709" t="conaw srange-dynamic?"><y>#</y><d>2016-06-09</d><h>17:01</h><w>conaw</w>srange-dynamic?</z><z id="t1465491727" t="nathanmarz continuous-subseqs"><y>#</y><d>2016-06-09</d><h>17:02</h><w>nathanmarz</w>continuous-subseqs</z><z id="t1465491729" t="conaw filterer"><y>#</y><d>2016-06-09</d><h>17:02</h><w>conaw</w>filterer</z><z id="t1465491815" t="nathanmarz adding an element to a nested set (or creating the set if it doesn&apos;t exist) without defining any new functions (anonymous or not)"><y>#</y><d>2016-06-09</d><h>17:03</h><w>nathanmarz</w>adding an element to a nested set (or creating the set if it doesn&apos;t exist) without defining any new functions (anonymous or not)</z><z id="t1465491843" t="nathanmarz {:a #{1}} -&gt; {:a #{1 2}}"><y>#</y><d>2016-06-09</d><h>17:04</h><w>nathanmarz</w><code>{:a #{1}}</code> -&gt; <code>{:a #{1 2}}</code></z><z id="t1465491948" t="nathanmarz in a sequence of maps, set the :b key to true if the value for :a exists and is greater than 10"><y>#</y><d>2016-06-09</d><h>17:05</h><w>nathanmarz</w>in a sequence of maps, set the <code>:b</code> key to true if the value for <code>:a</code> exists and is greater than 10</z><z id="t1465492020" t="nathanmarz [{:a 1} {:a 11 :c 1} {:d 4}] -&gt; [{:a 1} {:a 11 :b true :c 1} {:d 4}]"><y>#</y><d>2016-06-09</d><h>17:07</h><w>nathanmarz</w><code>[{:a 1} {:a 11 :c 1} {:d 4}]</code> -&gt; <code>[{:a 1} {:a 11 :b true :c 1} {:d 4}]</code></z><z id="t1465492654" t="conaw gotta admit I’m a little stumped by what I got back from the continuous subsequence stuff"><y>#</y><d>2016-06-09</d><h>17:17</h><w>conaw</w>gotta admit I’m a little stumped by what I got back from the continuous subsequence stuff</z><z id="t1465492701" t="conaw its navigating to each character?"><y>#</y><d>2016-06-09</d><h>17:18</h><w>conaw</w>its navigating to each character?</z><z id="t1465492735" t="conaw (transform [(sp/continuous-subseqs string?)] str [&quot;hello &quot; &quot;a &quot; &quot;w&quot; 1 2 3 &quot;a &quot; &quot;b&quot; ]) [\[ \&quot; \h \e \l \l \o \space \&quot; \space \&quot; \a \space \&quot; \space \&quot; \w \&quot; \] 1 2 3 \[ \&quot; \a \space \&quot; \space \&quot; \b \&quot; \]]"><y>#</y><d>2016-06-09</d><h>17:18</h><w>conaw</w>(transform [(sp/continuous-subseqs string?)] str
            [&quot;hello &quot; &quot;a &quot; &quot;w&quot; 1 2 3 &quot;a &quot; &quot;b&quot; ])

[\[ \&quot; \h \e \l \l \o \space \&quot; \space \&quot; \a \space \&quot; \space \&quot; \w \&quot; \] 1 2 3 \[ \&quot; \a \space \&quot; \space \&quot; \b \&quot; \]]</z><z id="t1465492770" t="nathanmarz the transform fn gets sequence in and expects sequence out"><y>#</y><d>2016-06-09</d><h>17:19</h><w>nathanmarz</w>the transform fn gets sequence in and expects sequence out</z><z id="t1465492792" t="conaw so the challenge isn’t in the path, but in the fn you pass to transform"><y>#</y><d>2016-06-09</d><h>17:19</h><w>conaw</w>so the challenge isn’t in the path, but in the fn you pass to transform</z><z id="t1465492796" t="nathanmarz you&apos;re turning a vector of strings into a big string, which is then spliced back in as a sequence"><y>#</y><d>2016-06-09</d><h>17:19</h><w>nathanmarz</w>you&apos;re turning a vector of strings into a big string, which is then spliced back in as a sequence</z><z id="t1465492835" t="nathanmarz yea, it&apos;s just understanding how the navigation works"><y>#</y><d>2016-06-09</d><h>17:20</h><w>nathanmarz</w>yea, it&apos;s just understanding how the navigation works</z><z id="t1465492863" t="conaw gotcha, to do this well you’d really have to do something after the transform fn"><y>#</y><d>2016-06-09</d><h>17:21</h><w>conaw</w>gotcha, to do this well you’d really have to do something after the transform fn</z><z id="t1465492901" t="nathanmarz your path is right and the rest of it is making a different transform-fn"><y>#</y><d>2016-06-09</d><h>17:21</h><w>nathanmarz</w>your path is right and the rest of it is making a different transform-fn</z><z id="t1465492971" t="nathanmarz your transform-fn will be called twice, once with [&quot;hello &quot; &quot;a &quot; &quot;w&quot;] and once with [&quot;a &quot; &quot;b&quot;]"><y>#</y><d>2016-06-09</d><h>17:22</h><w>nathanmarz</w>your transform-fn will be called twice, once with [&quot;hello &quot; &quot;a &quot; &quot;w&quot;] and once with [&quot;a &quot; &quot;b&quot;]</z><z id="t1465494026" t="conaw Yeah, this is a good one, because I’m definitely failing to understand something about specter"><y>#</y><d>2016-06-09</d><h>17:40</h><w>conaw</w>Yeah, this is a good one, because I’m definitely failing to understand something about specter</z><z id="t1465494035" t="conaw (s/def ::stringvec (s/+ (s/spec (s/+ string?)))) (defn joinup [stringvec] (map (partial str/join &quot;&quot;) stringvec)) (s/fdef joinup :args ::stringvec :ret string?) (s/instrument &apos;joinup) (transform [(sp/continuous-subseqs string?)] joinup [&quot;hello &quot; &quot;a &quot; &quot;w&quot; 1 2 3 &quot;a &quot; &quot;b&quot; ]) "><y>#</y><d>2016-06-09</d><h>17:40</h><w>conaw</w><pre>(s/def ::stringvec (s/+ (s/spec (s/+  string?))))



(defn joinup [stringvec]
  (map (partial str/join &quot;&quot;) stringvec))


(s/fdef joinup :args ::stringvec
        :ret string?)

(s/instrument &apos;joinup)

(transform [(sp/continuous-subseqs string?)] joinup
            [&quot;hello &quot; &quot;a &quot; &quot;w&quot; 1 2 3 &quot;a &quot; &quot;b&quot; ])
</pre></z><z id="t1465494065" t="conaw still getting back this [&quot;hello &quot; &quot;a &quot; &quot;w&quot; 1 2 3 &quot;a &quot; &quot;b&quot;]"><y>#</y><d>2016-06-09</d><h>17:41</h><w>conaw</w>still getting back this [&quot;hello &quot; &quot;a &quot; &quot;w&quot; 1 2 3 &quot;a &quot; &quot;b&quot;]</z><z id="t1465494086" t="conaw yet the spec says I’m returning a string"><y>#</y><d>2016-06-09</d><h>17:41</h><w>conaw</w>yet the spec says I’m returning a string</z><z id="t1465494096" t="nathanmarz here i&apos;ll show you"><y>#</y><d>2016-06-09</d><h>17:41</h><w>nathanmarz</w>here i&apos;ll show you</z><z id="t1465494112" t="nathanmarz (fn [strseq] [(apply str strseq)])"><y>#</y><d>2016-06-09</d><h>17:41</h><w>nathanmarz</w><code>(fn [strseq] [(apply str strseq)])</code></z><z id="t1465494135" t="conaw so, because I’m not putting it in a vector at the end"><y>#</y><d>2016-06-09</d><h>17:42</h><w>conaw</w>so, because I’m not putting it in a vector at the end</z><z id="t1465494138" t="conaw what’s happening"><y>#</y><d>2016-06-09</d><h>17:42</h><w>conaw</w>what’s happening</z><z id="t1465494139" t="conaw ?"><y>#</y><d>2016-06-09</d><h>17:42</h><w>conaw</w>?</z><z id="t1465494156" t="nathanmarz continuous-subseqs works just like srange"><y>#</y><d>2016-06-09</d><h>17:42</h><w>nathanmarz</w>continuous-subseqs works just like srange</z><z id="t1465494173" t="nathanmarz the sequence returned back replaces the subsequence navigated to"><y>#</y><d>2016-06-09</d><h>17:42</h><w>nathanmarz</w>the sequence returned back replaces the subsequence navigated to</z><z id="t1465494191" t="nathanmarz so if you just return a string back, that gets interpreted as a sequence and the individual characters get spliced in"><y>#</y><d>2016-06-09</d><h>17:43</h><w>nathanmarz</w>so if you just return a string back, that gets interpreted as a sequence and the individual characters get spliced in</z><z id="t1465494218" t="conaw gotchaaa"><y>#</y><d>2016-06-09</d><h>17:43</h><w>conaw</w>gotchaaa</z><z id="t1465494231" t="conaw yeah, that’s totally obvious when you think about it"><y>#</y><d>2016-06-09</d><h>17:43</h><w>conaw</w>yeah, that’s totally obvious when you think about it</z><z id="t1465494260" t="nathanmarz yea, you just need to visualize it"><y>#</y><d>2016-06-09</d><h>17:44</h><w>nathanmarz</w>yea, you just need to visualize it</z><z id="t1465495073" t="conaw truth, any challenges that involve navigating to a non-empty subset"><y>#</y><d>2016-06-09</d><h>17:57</h><w>conaw</w>truth, any challenges that involve navigating to a non-empty subset</z><z id="t1465495438" t="nathanmarz I could imagine minecraft style ones"><y>#</y><d>2016-06-09</d><h>18:03</h><w>nathanmarz</w>I could imagine minecraft style ones</z><z id="t1465495465" t="nathanmarz for sequence of players, if :inventory contains :flint and :stick, replace with :torch"><y>#</y><d>2016-06-09</d><h>18:04</h><w>nathanmarz</w>for sequence of players, if :inventory contains :flint and :stick, replace with :torch</z><z id="t1465563298" t="conaw Alright, here’s another challenge. Let me know if this is just taking the idea of everything as a navigation too far though. Given this [[1 2] [1 3] [3 4] [4 5] [5 6]]"><y>#</y><d>2016-06-10</d><h>12:54</h><w>conaw</w>Alright, here’s another challenge.  Let me know if this is just taking the idea of everything as a navigation too far though.  Given this

 [[1 2] [1 3] [3 4] [4 5] [5 6]]</z><z id="t1465563315" t="conaw Could you express this"><y>#</y><d>2016-06-10</d><h>12:55</h><w>conaw</w>Could you express this</z><z id="t1465563317" t="conaw (for [[k v] e] {k #{v}}) (apply merge-with clojure.set/union))"><y>#</y><d>2016-06-10</d><h>12:55</h><w>conaw</w>(for [[k v] e]
              {k #{v}})
              (apply merge-with clojure.set/union))</z><z id="t1465563325" t="conaw as a transformation"><y>#</y><d>2016-06-10</d><h>12:55</h><w>conaw</w>as a transformation</z><z id="t1465563340" t="conaw or rather as a navigation"><y>#</y><d>2016-06-10</d><h>12:55</h><w>conaw</w>or rather as a navigation</z><z id="t1465563386" t="conaw especially if you’re planning on going back to tuples"><y>#</y><d>2016-06-10</d><h>12:56</h><w>conaw</w>especially if you’re planning on going back to tuples</z><z id="t1465563393" t="conaw copy paste was off as well"><y>#</y><d>2016-06-10</d><h>12:56</h><w>conaw</w>copy paste was off as well</z><z id="t1465563394" t="conaw (-&gt;&gt; (for [[k v] e] {k #{v}}) (apply merge-with clojure.set/union))"><y>#</y><d>2016-06-10</d><h>12:56</h><w>conaw</w>(-&gt;&gt; (for [[k v] e]
              {k #{v}})
              (apply merge-with clojure.set/union))</z><z id="t1465563793" t="nathanmarz I mean, you can"><y>#</y><d>2016-06-10</d><h>13:03</h><w>nathanmarz</w>I mean, you can</z><z id="t1465563833" t="nathanmarz but it&apos;s not particularly better than the manual code since everything in the structure is used"><y>#</y><d>2016-06-10</d><h>13:03</h><w>nathanmarz</w>but it&apos;s not particularly better than the manual code since everything in the structure is used</z><z id="t1465563995" t="nathanmarz (require &apos;[clojure.set :as set]) (defnav MERGED-MAPS [] (select* [this structure next-fn] ;;TODO: fill this in ) (transform* [this structure next-fn] (apply merge-with (fn [&amp; vals] (next-fn vals)) structure) )) (transform [(parser #(transform ALL (fn [[k v]] {k #{v}}) %) #(vec %)) MERGED-MAPS] #(apply set/union %) [[1 2] [1 3] [3 4] [4 5] [5 6]]) "><y>#</y><d>2016-06-10</d><h>13:06</h><w>nathanmarz</w><pre>(require &apos;[clojure.set :as set])

(defnav MERGED-MAPS []
  (select* [this structure next-fn]
    ;;TODO: fill this in
    )
  (transform* [this structure next-fn]
    (apply merge-with (fn [&amp; vals] (next-fn vals)) structure)
    ))


(transform
  [(parser #(transform ALL (fn [[k v]] {k #{v}}) %) #(vec %))
   MERGED-MAPS]
  #(apply set/union %)
  [[1 2] [1 3] [3 4] [4 5] [5 6]])
</pre></z><z id="t1465564015" t="nathanmarz that outputs [[1 #{3 2}] [3 #{4}] [4 #{5}] [5 #{6}]]"><y>#</y><d>2016-06-10</d><h>13:06</h><w>nathanmarz</w>that outputs <code>[[1 #{3 2}] [3 #{4}] [4 #{5}] [5 #{6}]]</code></z><z id="t1465568227" t="conaw cool, just trying to get a sense of where the edge is"><y>#</y><d>2016-06-10</d><h>14:17</h><w>conaw</w>cool, just trying to get a sense of where the edge is</z><z id="t1465568289" t="conaw are there other examples of when you’d use parser?"><y>#</y><d>2016-06-10</d><h>14:18</h><w>conaw</w>are there other examples of when you’d use parser?</z><z id="t1465568298" t="conaw didn’t see that mentioned in any doc?"><y>#</y><d>2016-06-10</d><h>14:18</h><w>conaw</w>didn’t see that mentioned in any doc?</z><z id="t1465572392" t="nathanmarz @conaw It&apos;s most commonly used for something like this: (def LONG-PARSER (parser #(Long/parseLong %) str)) (transform [ALL LONG-PARSER] inc [&quot;10&quot; &quot;1&quot; &quot;0&quot;]) ;; =&gt; [&quot;11&quot; &quot;2&quot; &quot;1&quot;] "><y>#</y><d>2016-06-10</d><h>15:26</h><w>nathanmarz</w>@conaw It&apos;s most commonly used for something like this:
<pre>(def LONG-PARSER (parser #(Long/parseLong %) str))

(transform [ALL LONG-PARSER] inc [&quot;10&quot; &quot;1&quot; &quot;0&quot;])
;; =&gt; [&quot;11&quot; &quot;2&quot; &quot;1&quot;]
</pre></z><z id="t1465572407" t="nathanmarz the docs are very incomplete, though most of the public API has docstrings"><y>#</y><d>2016-06-10</d><h>15:26</h><w>nathanmarz</w>the docs are very incomplete, though most of the public API has docstrings</z><z id="t1465572445" t="conaw cool"><y>#</y><d>2016-06-10</d><h>15:27</h><w>conaw</w>cool</z><z id="t1465572998" t="conaw ok, here’s a question. Is there a way I could do a transform that would be akin to map-indexed. (transform [TOPSORT :position-id (subset #{})] (fn [x] something that gives me an unique value in the range of zero to the number of items I’m doing the select on) tree)"><y>#</y><d>2016-06-10</d><h>15:36</h><w>conaw</w>ok, here’s a question.  Is there a way I could do a transform that would be akin to map-indexed.  
(transform [TOPSORT :position-id (subset #{})] 
(fn [x]  something that gives me an unique value in the range of zero to the number of items I’m doing the select on)
tree)</z><z id="t1465573045" t="conaw the function for transform is only getting access to one selected value at a time right"><y>#</y><d>2016-06-10</d><h>15:37</h><w>conaw</w>the function for transform is only getting access to one selected value at a time right</z><z id="t1465573101" t="conaw so you’d have to do something like, pass the whole subsequence of values you want as a sequence, and then put them all back in in the right place"><y>#</y><d>2016-06-10</d><h>15:38</h><w>conaw</w>so you’d have to do something like, pass the whole subsequence of values you want as a sequence, and then put them all back in in the right place</z><z id="t1465575138" t="nathanmarz I think you&apos;re looking for subselect"><y>#</y><d>2016-06-10</d><h>16:12</h><w>nathanmarz</w>I think you&apos;re looking for subselect</z><z id="t1465575186" t="conaw right"><y>#</y><d>2016-06-10</d><h>16:13</h><w>conaw</w>right</z><z id="t1465575197" t="nathanmarz (transform (subselect ALL even?) reverse [1 2 3 4 5 6 7]) -&gt; [1 6 3 4 5 2 7]"><y>#</y><d>2016-06-10</d><h>16:13</h><w>nathanmarz</w><code>(transform (subselect ALL even?) reverse [1 2 3 4 5 6 7])</code> -&gt; <code>[1 6 3 4 5 2 7]</code></z><z id="t1465576215" t="conaw (transform [(sp/subselect ALL map? :position)] (partial map-indexed (fn [i x] i)) [{:a 1 😛 1}[:not :me 1]{:b 2}])"><y>#</y><d>2016-06-10</d><h>16:30</h><w>conaw</w>(transform [(sp/subselect ALL map? :position)] 
           (partial map-indexed (fn [i x] i)) 
           [{:a 1 <b>😛</b> 1}[:not :me 1]{:b 2}])</z><z id="t1465576221" t="conaw (transform [(sp/subselect ALL map? :position)] (partial map-indexed (fn [i x] i)) [{:a 1 :b 1}[:not :me 1]{:b 2}]) "><y>#</y><d>2016-06-10</d><h>16:30</h><w>conaw</w><pre>(transform [(sp/subselect ALL map? :position)] 
           (partial map-indexed (fn [i x] i)) 
           [{:a 1 :b 1}[:not :me 1]{:b 2}])
</pre></z><z id="t1465576241" t="conaw [{:a 1, 😛 1, :position 0} [:not :me 1] {:b 2, :position 1}]"><y>#</y><d>2016-06-10</d><h>16:30</h><w>conaw</w>[{:a 1, <b>😛</b> 1, :position 0} [:not :me 1] {:b 2, :position 1}]</z><z id="t1465576253" t="conaw returns [{:a 1, :b 1, :position 0} [:not :me 1] {:b 2, :position 1}]"><y>#</y><d>2016-06-10</d><h>16:30</h><w>conaw</w>returns <pre>[{:a 1, :b 1, :position 0} [:not :me 1] {:b 2, :position 1}]</pre></z><z id="t1465576265" t="conaw much appreciated"><y>#</y><d>2016-06-10</d><h>16:31</h><w>conaw</w>much appreciated</z><z id="t1465576304" t="conaw this is really beautiful the more I’m exploring it"><y>#</y><d>2016-06-10</d><h>16:31</h><w>conaw</w>this is really beautiful the more I’m exploring it</z><z id="t1465576313" t="conaw thanks so much for the help"><y>#</y><d>2016-06-10</d><h>16:31</h><w>conaw</w>thanks so much for the help</z><z id="t1465576511" t="nathanmarz no problem"><y>#</y><d>2016-06-10</d><h>16:35</h><w>nathanmarz</w>no problem</z><z id="t1465576558" t="nathanmarz I think you can do that last one with this transform-fn: (fn [aseq] (range (count aseq)))"><y>#</y><d>2016-06-10</d><h>16:35</h><w>nathanmarz</w>I think you can do that last one with this transform-fn: <code>(fn [aseq] (range (count aseq)))</code></z><z id="t1465576566" t="nathanmarz a little cleaner in my opinion"><y>#</y><d>2016-06-10</d><h>16:36</h><w>nathanmarz</w>a little cleaner in my opinion</z><z id="t1465576657" t="nathanmarz @conaw: or even better: (transform [(subselect ALL map? :position) (view count)] range [{:a 1 :b 1} [:not :me 1] {:b 2}]) "><y>#</y><d>2016-06-10</d><h>16:37</h><w>nathanmarz</w>@conaw: or even better:
<pre>(transform [(subselect ALL map? :position) (view count)] 
           range
           [{:a 1 :b 1} [:not :me 1] {:b 2}])
</pre></z><z id="t1465576683" t="conaw very cool"><y>#</y><d>2016-06-10</d><h>16:38</h><w>conaw</w>very cool</z><z id="t1465576825" t="conaw if you’d like, happy to take a stab at writing up some examples for the wiki."><y>#</y><d>2016-06-10</d><h>16:40</h><w>conaw</w>if you’d like, happy to take a stab at writing up some examples for the wiki.</z><z id="t1465576842" t="nathanmarz that would be awesome"><y>#</y><d>2016-06-10</d><h>16:40</h><w>nathanmarz</w>that would be awesome</z><z id="t1465577000" t="conaw will give it a stab"><y>#</y><d>2016-06-10</d><h>16:43</h><w>conaw</w>will give it a stab</z><z id="t1465577018" t="conaw taking the subselect example into recursion"><y>#</y><d>2016-06-10</d><h>16:43</h><w>conaw</w>taking the subselect example into recursion</z><z id="t1465577062" t="conaw nevermind, actually works just as expected"><y>#</y><d>2016-06-10</d><h>16:44</h><w>conaw</w>nevermind, actually works just as expected</z><z id="t1465577067" t="conaw this is very cool"><y>#</y><d>2016-06-10</d><h>16:44</h><w>conaw</w>this is very cool</z><z id="t1465577091" t="nathanmarz yea subselect is pretty magical"><y>#</y><d>2016-06-10</d><h>16:44</h><w>nathanmarz</w>yea subselect is pretty magical</z><z id="t1465577098" t="nathanmarz contributed by @aengelberg"><y>#</y><d>2016-06-10</d><h>16:44</h><w>nathanmarz</w>contributed by @aengelberg</z><z id="t1465577109" t="aengelberg 👋"><y>#</y><d>2016-06-10</d><h>16:45</h><w>aengelberg</w><b>👋</b></z><z id="t1465577147" t="aengelberg its end result almost outweighs the mutable hackiness I used to achieve it 🙂"><y>#</y><d>2016-06-10</d><h>16:45</h><w>aengelberg</w>its end result almost outweighs the mutable hackiness I used to achieve it <b>🙂</b></z><z id="t1465577272" t="conaw lol, I was trying to figure out how I would even achieve this before @nathanmarz mentioned subselect, only thing I could think of was to create an atom"><y>#</y><d>2016-06-10</d><h>16:47</h><w>conaw</w>lol, I was trying to figure out how I would even achieve this before @nathanmarz mentioned subselect, only thing I could think of was to create an atom</z><z id="t1465577303" t="conaw glad you went into the swamp for us!"><y>#</y><d>2016-06-10</d><h>16:48</h><w>conaw</w>glad you went into the swamp for us!</z><z id="t1465577334" t="aengelberg I like this quote from http://clojure.org/transients : If a tree falls in the woods, does it make a sound? If a pure function mutates some local data in order to produce an immutable return value, is that ok? "><y>#</y><d>2016-06-10</d><h>16:48</h><w>aengelberg</w>I like this quote from <a href="http://clojure.org/transients" target="_blank">http://clojure.org/transients</a>:
<pre>If a tree falls in the woods, does it make a sound?
If a pure function mutates some local data in order to produce an immutable return value, is that ok?
</pre></z><z id="t1465577361" t="conaw so much beauty in this channel"><y>#</y><d>2016-06-10</d><h>16:49</h><w>conaw</w>so much beauty in this channel</z><z id="t1465577414" t="nathanmarz that&apos;s a good one"><y>#</y><d>2016-06-10</d><h>16:50</h><w>nathanmarz</w>that&apos;s a good one</z><z id="t1465577427" t="nathanmarz been digging into clojure&apos;s transducers and they use a lot of mutability"><y>#</y><d>2016-06-10</d><h>16:50</h><w>nathanmarz</w>been digging into clojure&apos;s transducers and they use a lot of mutability</z><z id="t1465577510" t="aengelberg Subselect gets awkward when working with sets: (subselect [ALL ALL] reverse [#{1 2 3} [4 5 6]]) =&gt; [#{6 5 4} [???]] "><y>#</y><d>2016-06-10</d><h>16:51</h><w>aengelberg</w>Subselect gets awkward when working with sets:
<pre>(subselect [ALL ALL] reverse [#{1 2 3} [4 5 6]])
=&gt;
[#{6 5 4} [???]]
</pre></z><z id="t1465577704" t="nathanmarz looks reasonable to me"><y>#</y><d>2016-06-10</d><h>16:55</h><w>nathanmarz</w>looks reasonable to me</z><z id="t1465577792" t="aengelberg often I get overly paranoid about confusing beginners"><y>#</y><d>2016-06-10</d><h>16:56</h><w>aengelberg</w>often I get overly paranoid about confusing beginners</z><z id="t1465577873" t="nathanmarz I know what you mean"><y>#</y><d>2016-06-10</d><h>16:57</h><w>nathanmarz</w>I know what you mean</z><z id="t1465577894" t="nathanmarz but I like the clojure philosophy of keep it simple and well defined"><y>#</y><d>2016-06-10</d><h>16:58</h><w>nathanmarz</w>but I like the clojure philosophy of keep it simple and well defined</z><z id="t1465577900" t="nathanmarz even if it requires a learning curve"><y>#</y><d>2016-06-10</d><h>16:58</h><w>nathanmarz</w>even if it requires a learning curve</z><z id="t1465578398" t="nathanmarz @aengelberg: curious to hear your thoughts on https://github.com/nathanmarz/specter/issues/121"><y>#</y><d>2016-06-10</d><h>17:06</h><w>nathanmarz</w>@aengelberg: curious to hear your thoughts on <a href="https://github.com/nathanmarz/specter/issues/121" target="_blank">https://github.com/nathanmarz/specter/issues/121</a></z><z id="t1465578413" t="nathanmarz a lot of overlap with transducers"><y>#</y><d>2016-06-10</d><h>17:06</h><w>nathanmarz</w>a lot of overlap with transducers</z><z id="t1465578520" t="aengelberg yeah, just saw that. Seems like it could be even more useful if takenav could reset at a later level, e.g. (select [ALL ALL (takenav 3)] [[1 2 3 4 5] [6 7 8 9 10]]) =&gt; [[1 2 3] [6 7 8]]"><y>#</y><d>2016-06-10</d><h>17:08</h><w>aengelberg</w>yeah, just saw that. Seems like it could be even more useful if <code>takenav</code> could reset at a later level, e.g. <code>(select [ALL ALL (takenav 3)] [[1 2 3 4 5] [6 7 8 9 10]]) =&gt; [[1 2 3] [6 7 8]]</code></z><z id="t1465578545" t="aengelberg essentially the volatile would need to get reset in between the two ALL s"><y>#</y><d>2016-06-10</d><h>17:09</h><w>aengelberg</w>essentially the volatile would need to get reset in between the two <code>ALL</code>s</z><z id="t1465578576" t="nathanmarz i think the result you would expect there is [1 2 3 6 7 8]"><y>#</y><d>2016-06-10</d><h>17:09</h><w>nathanmarz</w>i think the result you would expect there is <code>[1 2 3 6 7 8]</code></z><z id="t1465578587" t="nathanmarz you might want both behaviors"><y>#</y><d>2016-06-10</d><h>17:09</h><w>nathanmarz</w>you might want both behaviors</z><z id="t1465578591" t="aengelberg correct, sorry"><y>#</y><d>2016-06-10</d><h>17:09</h><w>aengelberg</w>correct, sorry</z><z id="t1465578613" t="aengelberg thus proving that it&apos;s unreasonable to expect that behavior arbitrarily 🙂"><y>#</y><d>2016-06-10</d><h>17:10</h><w>aengelberg</w>thus proving that it&apos;s unreasonable to expect that behavior arbitrarily <b>🙂</b></z><z id="t1465578619" t="nathanmarz so resetting would be an explicit choice"><y>#</y><d>2016-06-10</d><h>17:10</h><w>nathanmarz</w>so resetting would be an explicit choice</z><z id="t1465578625" t="aengelberg yeah"><y>#</y><d>2016-06-10</d><h>17:10</h><w>aengelberg</w>yeah</z><z id="t1465578639" t="aengelberg have you considered simply introducing (ALL-transduce (take 3))"><y>#</y><d>2016-06-10</d><h>17:10</h><w>aengelberg</w>have you considered simply introducing <code>(ALL-transduce (take 3))</code></z><z id="t1465578678" t="nathanmarz that would be one way to do it"><y>#</y><d>2016-06-10</d><h>17:11</h><w>nathanmarz</w>that would be one way to do it</z><z id="t1465578690" t="nathanmarz then takenav would be a completely different implementation to that"><y>#</y><d>2016-06-10</d><h>17:11</h><w>nathanmarz</w>then takenav would be a completely different implementation to that</z><z id="t1465578695" t="aengelberg yeah"><y>#</y><d>2016-06-10</d><h>17:11</h><w>aengelberg</w>yeah</z><z id="t1465578705" t="nathanmarz seems like they should unify more cleanly"><y>#</y><d>2016-06-10</d><h>17:11</h><w>nathanmarz</w>seems like they should unify more cleanly</z><z id="t1465578717" t="nathanmarz the degree of overlap is very suspicious"><y>#</y><d>2016-06-10</d><h>17:11</h><w>nathanmarz</w>the degree of overlap is very suspicious</z><z id="t1465578837" t="aengelberg or maybe a &quot;take view&quot;"><y>#</y><d>2016-06-10</d><h>17:13</h><w>aengelberg</w>or maybe a &quot;take view&quot;</z><z id="t1465578839" t="nathanmarz could be something like (select [ALL ALL (traversed (takenav 3)] ... )"><y>#</y><d>2016-06-10</d><h>17:13</h><w>nathanmarz</w>could be something like <code>(select [ALL ALL (traversed (takenav 3)] ... )</code></z><z id="t1465578986" t="aengelberg (transform [ALL (subselect (taken 3))] [[1 2 3 4 5] [6 7 8 9 10]]) =&gt; [[1 2 3] [6 7 8]]"><y>#</y><d>2016-06-10</d><h>17:16</h><w>aengelberg</w><code>(transform [ALL (subselect (taken 3))] [[1 2 3 4 5] [6 7 8 9 10]]) =&gt; [[1 2 3] [6 7 8]]</code></z><z id="t1465578994" t="aengelberg uhhhh ignore that"><y>#</y><d>2016-06-10</d><h>17:16</h><w>aengelberg</w>uhhhh ignore that</z><z id="t1465579016" t="aengelberg (transform [ALL (subselect (taken 3))] inc [[1 2 3 4 5] [6 7 8 9 10]]) =&gt; [[2 3 4 4 5] [7 8 9 9 10]]"><y>#</y><d>2016-06-10</d><h>17:16</h><w>aengelberg</w>(transform [ALL (subselect (taken 3))] inc [[1 2 3 4 5] [6 7 8 9 10]]) =&gt; [[2 3 4 4 5] [7 8 9 9 10]]</z><z id="t1465579103" t="nathanmarz with the idea there that subselect re-parameterizes its path on every invocation?"><y>#</y><d>2016-06-10</d><h>17:18</h><w>nathanmarz</w>with the idea there that subselect re-parameterizes its path on every invocation?</z><z id="t1465579111" t="nathanmarz that&apos;s what I was thinking with traversed"><y>#</y><d>2016-06-10</d><h>17:18</h><w>nathanmarz</w>that&apos;s what I was thinking with <code>traversed</code></z><z id="t1465579259" t="nathanmarz either way the semantics are pretty subtle"><y>#</y><d>2016-06-10</d><h>17:20</h><w>nathanmarz</w>either way the semantics are pretty subtle</z><z id="t1465579264" t="nathanmarz maybe too subtle"><y>#</y><d>2016-06-10</d><h>17:21</h><w>nathanmarz</w>maybe too subtle</z><z id="t1465579427" t="conaw hey @nathanmarz @aengelberg total aside, but don’t suppose either of you guys know of any great lecturers or youtube channels/videos relating to graph theory."><y>#</y><d>2016-06-10</d><h>17:23</h><w>conaw</w>hey @nathanmarz @aengelberg total aside, but don’t suppose either of you guys know of any great lecturers or youtube channels/videos relating to graph theory.</z><z id="t1465579518" t="nathanmarz looks like tim roughgarden has a bunch of videos on graph algorithms on youtube"><y>#</y><d>2016-06-10</d><h>17:25</h><w>nathanmarz</w>looks like tim roughgarden has a bunch of videos on graph algorithms on youtube</z><z id="t1465579520" t="nathanmarz https://www.youtube.com/results?search_query=tim+roughgarden+graph+algorithms"><y>#</y><d>2016-06-10</d><h>17:25</h><w>nathanmarz</w><a href="https://www.youtube.com/results?search_query=tim+roughgarden+graph+algorithms" target="_blank">https://www.youtube.com/results?search_query=tim+roughgarden+graph+algorithms</a></z><z id="t1465579528" t="nathanmarz he&apos;s the best teacher I ever had"><y>#</y><d>2016-06-10</d><h>17:25</h><w>nathanmarz</w>he&apos;s the best teacher I ever had</z><z id="t1465579715" t="conaw win"><y>#</y><d>2016-06-10</d><h>17:28</h><w>conaw</w>win</z><z id="t1465581561" t="aengelberg I was suggesting taken would be just a regular (not stateful) navigator that only selects or transforms the first N elements"><y>#</y><d>2016-06-10</d><h>17:59</h><w>aengelberg</w>I was suggesting <code>taken</code> would be just a regular (not stateful) navigator that only selects or transforms the first N elements</z><z id="t1465581570" t="aengelberg less performant though to do a subselect"><y>#</y><d>2016-06-10</d><h>17:59</h><w>aengelberg</w>less performant though to do a subselect</z><z id="t1465582802" t="nathanmarz @aengelberg: ah, yea I&apos;m thinking more cases like [ALL ALL ALL (takenav 3)]"><y>#</y><d>2016-06-10</d><h>18:20</h><w>nathanmarz</w>@aengelberg: ah, yea I&apos;m thinking more cases like <code>[ALL ALL ALL (takenav 3)]</code></z><z id="t1465582816" t="aengelberg too many ALL s 🙂"><y>#</y><d>2016-06-10</d><h>18:20</h><w>aengelberg</w>too many <code>ALL</code>s <b>🙂</b></z><z id="t1465582837" t="nathanmarz (select [ALL (freshpath ALL (take-nav 2)) (take-nav 4)] [[1] [2 3 4] [5 6 7]]) ;; =&gt; [1 2 3 5] "><y>#</y><d>2016-06-10</d><h>18:20</h><w>nathanmarz</w><pre>(select [ALL (freshpath ALL (take-nav 2)) (take-nav 4)]
  [[1] [2 3 4] [5 6 7]])
;; =&gt; [1 2 3 5]
</pre></z><z id="t1465582851" t="nathanmarz &quot;freshpath&quot; would mean to treat that path from scratch"><y>#</y><d>2016-06-10</d><h>18:20</h><w>nathanmarz</w>&quot;freshpath&quot; would mean to treat that path from scratch</z><z id="t1465582886" t="nathanmarz the only impact that would have would be to initialize the states and collected vals every time it enters that part of the path"><y>#</y><d>2016-06-10</d><h>18:21</h><w>nathanmarz</w>the only impact that would have would be to initialize the states and collected vals every time it enters that part of the path</z><z id="t1465641990" t="luxbock I already forgot how to do this: https://gist.github.com/luxbock/3403337442fb3782321209edaa7fffc0"><y>#</y><d>2016-06-11</d><h>10:46</h><w>luxbock</w>I already forgot how to do this: <a href="https://gist.github.com/luxbock/3403337442fb3782321209edaa7fffc0" target="_blank">https://gist.github.com/luxbock/3403337442fb3782321209edaa7fffc0</a></z><z id="t1465642007" t="luxbock how can I move lift the filter-part from the function into the selector?"><y>#</y><d>2016-06-11</d><h>10:46</h><w>luxbock</w>how can I move lift the filter-part from the function into the selector?</z><z id="t1465642028" t="conaw filterer?"><y>#</y><d>2016-06-11</d><h>10:47</h><w>conaw</w>filterer?</z><z id="t1465642086" t="luxbock @conaw: I think that counts the :bar keys as well"><y>#</y><d>2016-06-11</d><h>10:48</h><w>luxbock</w>@conaw: I think that counts the <code>:bar</code> keys as well</z><z id="t1465642212" t="luxbock the return value I want is {:a 2, :b 3}"><y>#</y><d>2016-06-11</d><h>10:50</h><w>luxbock</w>the return value I want is <code>{:a 2, :b 3}</code></z><z id="t1465644947" t="codonnell @luxbock: not sure if this is optimal, but it works"><y>#</y><d>2016-06-11</d><h>11:35</h><w>codonnell</w>@luxbock: not sure if this is optimal, but it works</z><z id="t1465644951" t="codonnell (transform [MAP-VALS (collect-one (filterer (fn [m] (contains? m :foo))))] (fn [ms _] (count ms)) data)"><y>#</y><d>2016-06-11</d><h>11:35</h><w>codonnell</w><code>(transform [MAP-VALS (collect-one (filterer (fn [m] (contains? m :foo))))] (fn [ms _] (count ms)) data)</code></z><z id="t1465645406" t="nathanmarz @luxbock: I would do it like this: (transform [MAP-VALS (collect ALL (pred :foo))] (fn [a _] (count a)) {:a [{:foo 1} {:bar 3} {:foo 4}] :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]} ) "><y>#</y><d>2016-06-11</d><h>11:43</h><w>nathanmarz</w>@luxbock: I would do it like this:
<pre>(transform [MAP-VALS (collect ALL (pred :foo))]
  (fn [a _] (count a))
  {:a [{:foo 1} {:bar 3} {:foo 4}]
   :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]}
  )
</pre></z><z id="t1465645449" t="nathanmarz can also use must instead of pred for contains? semantics"><y>#</y><d>2016-06-11</d><h>11:44</h><w>nathanmarz</w>can also use <code>must</code> instead of <code>pred</code> for <code>contains?</code> semantics</z><z id="t1465649078" t="codonnell I&apos;m trying to understand how late binding works for filterer. It seems to work fine if I pass it a late binding navigator, like must or pred. However, if I try to pass a predicate function directly, I get an exception. Is that just how filterer works or am I missing something?"><y>#</y><d>2016-06-11</d><h>12:44</h><w>codonnell</w>I&apos;m trying to understand how late binding works for filterer. It seems to work fine if I pass it a late binding navigator, like must or pred. However, if I try to pass a predicate function directly, I get an exception. Is that just how filterer works or am I missing something?</z><z id="t1465649152" t="nathanmarz @codonnell: filterer isn&apos;t a navigator"><y>#</y><d>2016-06-11</d><h>12:45</h><w>nathanmarz</w>@codonnell: <code>filterer</code> isn&apos;t a navigator</z><z id="t1465649160" t="nathanmarz it&apos;s a function that returns a navigator"><y>#</y><d>2016-06-11</d><h>12:46</h><w>nathanmarz</w>it&apos;s a function that returns a navigator</z><z id="t1465649188" t="nathanmarz so when you use it in comp-path it gets interpreted like all functions do – as a filter function"><y>#</y><d>2016-06-11</d><h>12:46</h><w>nathanmarz</w>so when you use it in <code>comp-path</code> it gets interpreted like all functions do – as a filter function</z><z id="t1465649231" t="nathanmarz filterer can be invoked with a path that requires more parameters to then create a navigator that requires those parameters"><y>#</y><d>2016-06-11</d><h>12:47</h><w>nathanmarz</w><code>filterer</code> can be invoked with a path that requires more parameters to then create a navigator that requires those parameters</z><z id="t1465649257" t="nathanmarz btw, it&apos;s very rare that you need to explicitly precompile anymore"><y>#</y><d>2016-06-11</d><h>12:47</h><w>nathanmarz</w>btw, it&apos;s very rare that you need to explicitly precompile anymore</z><z id="t1465649299" t="nathanmarz (select-one (filterer even?) (range 10)) in 0.11.2 should be within 2-3% of the precompiled code"><y>#</y><d>2016-06-11</d><h>12:48</h><w>nathanmarz</w><code>(select-one (filterer even?) (range 10))</code> in 0.11.2 should be within 2-3% of the precompiled code</z><z id="t1465649452" t="codonnell Alright, that makes sense. Thanks for the response. I&apos;m aware that compiling paths is generally unnecessary in 0.11.2. I&apos;m writing up some notes for myself and got confused about filterer behavior, so I wanted to clarify for my notes."><y>#</y><d>2016-06-11</d><h>12:50</h><w>codonnell</w>Alright, that makes sense. Thanks for the response. I&apos;m aware that compiling paths is generally unnecessary in 0.11.2. I&apos;m writing up some notes for myself and got confused about filterer behavior, so I wanted to clarify for my notes.</z><z id="t1465649468" t="nathanmarz cool"><y>#</y><d>2016-06-11</d><h>12:51</h><w>nathanmarz</w>cool</z><z id="t1465649473" t="nathanmarz I opened up https://github.com/nathanmarz/specter/issues/122"><y>#</y><d>2016-06-11</d><h>12:51</h><w>nathanmarz</w>I opened up <a href="https://github.com/nathanmarz/specter/issues/122" target="_blank">https://github.com/nathanmarz/specter/issues/122</a></z><z id="t1465649487" t="nathanmarz Specter should detect that mistake and throw an error"><y>#</y><d>2016-06-11</d><h>12:51</h><w>nathanmarz</w>Specter should detect that mistake and throw an error</z><z id="t1465649518" t="codonnell I appreciate that. Informative error messages make a huge difference."><y>#</y><d>2016-06-11</d><h>12:51</h><w>codonnell</w>I appreciate that. Informative error messages make a huge difference.</z><z id="t1465649650" t="conaw is there a reason why MAP-VALS might not work in cljs"><y>#</y><d>2016-06-11</d><h>12:54</h><w>conaw</w>is there a reason why MAP-VALS might not work in cljs</z><z id="t1465649668" t="conaw Use of undeclared Var com.rpl.specter/MAP-VALS at line 1"><y>#</y><d>2016-06-11</d><h>12:54</h><w>conaw</w>Use of undeclared Var com.rpl.specter/MAP-VALS at line 1</z><z id="t1465649728" t="conaw easy enough to define oneself, but surprised by that error"><y>#</y><d>2016-06-11</d><h>12:55</h><w>conaw</w>easy enough to define oneself, but surprised by that error</z><z id="t1465649810" t="nathanmarz Are you using 0.11.1 or later?"><y>#</y><d>2016-06-11</d><h>12:56</h><w>nathanmarz</w>Are you using 0.11.1 or later?</z><z id="t1465649835" t="conaw 11.0"><y>#</y><d>2016-06-11</d><h>12:57</h><w>conaw</w>11.0</z><z id="t1465649836" t="nathanmarz you should use the built-in one as its about twice as fast at [ALL LAST]"><y>#</y><d>2016-06-11</d><h>12:57</h><w>nathanmarz</w>you should use the built-in one as its about twice as fast at <code>[ALL LAST]</code></z><z id="t1465649845" t="nathanmarz it was added in 0.11.1"><y>#</y><d>2016-06-11</d><h>12:57</h><w>nathanmarz</w>it was added in 0.11.1</z><z id="t1465649858" t="nathanmarz Highly recommend upgrading to 0.11.2"><y>#</y><d>2016-06-11</d><h>12:57</h><w>nathanmarz</w>Highly recommend upgrading to 0.11.2</z><z id="t1465650135" t="conaw done"><y>#</y><d>2016-06-11</d><h>13:02</h><w>conaw</w>done</z><z id="t1465651057" t="conaw @nathanmarz: regarding @luxbock’s example, when I do (transform [ALL LAST (sp/collect ALL (sp/pred :foo))] count {:a [{:foo 1} {:bar 3} {:foo 4}] :c [{:foo 1} {:bar 3 :foo 4} {:foo 4}]}) ;;=&gt; {:a 2 c: 3} (transform [MAP-VALS (sp/collect ALL (sp/pred :foo))] (fn [e _] (count e)) {:a [{:foo 1} {:bar 3} {:foo 4}] :c [{:foo 1} {:bar 3 :foo 4} {:foo 4}]}) ;;=&gt; 0"><y>#</y><d>2016-06-11</d><h>13:17</h><w>conaw</w>@nathanmarz: regarding @luxbock’s example, when I do 
<pre>(transform [ALL LAST (sp/collect ALL (sp/pred :foo))]
        count
    {:a [{:foo 1} {:bar 3} {:foo 4}]
     :c [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})

;;=&gt;  {:a 2 c: 3}

(transform [MAP-VALS (sp/collect ALL (sp/pred :foo))]
           (fn [e _] (count e))
           {:a [{:foo 1} {:bar 3} {:foo 4}]
            :c [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
;;=&gt; 0</pre></z><z id="t1465651167" t="conaw (transform [MAP-VALS (sp/collect ALL (sp/pred :foo))] count {:a [{:foo 1} {:bar 3} {:foo 4}] :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]}) ;;=&gt; 0"><y>#</y><d>2016-06-11</d><h>13:19</h><w>conaw</w><pre>(transform [MAP-VALS (sp/collect ALL (sp/pred :foo))]
           count
           {:a [{:foo 1} {:bar 3} {:foo 4}]
     :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
;;=&gt; 0</pre></z><z id="t1465651356" t="codonnell (transform [MAP-VALS (collect ALL (must :foo))] (fn [c _] (count c)) data) {:a 2, :b 3}"><y>#</y><d>2016-06-11</d><h>13:22</h><w>codonnell</w><pre>(transform [MAP-VALS (collect ALL (must :foo))] (fn [c _] (count c)) data)
{:a 2, :b 3}</pre></z><z id="t1465651393" t="conaw I’m just pointing out that ALL LAST and MAP-VALS aren’t equivalent in this case"><y>#</y><d>2016-06-11</d><h>13:23</h><w>conaw</w>I’m just pointing out that ALL LAST and MAP-VALS aren’t equivalent in this case</z><z id="t1465651400" t="codonnell ah, interesting"><y>#</y><d>2016-06-11</d><h>13:23</h><w>codonnell</w>ah, interesting</z><z id="t1465651427" t="conaw pred and must are equivelent"><y>#</y><d>2016-06-11</d><h>13:23</h><w>conaw</w>pred and must are equivelent</z><z id="t1465651458" t="conaw (transform [ALL LAST (sp/collect ALL (sp/must :foo))] count {:a [{:foo 1} {:bar 3} {:foo 4}] :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]}) ;;=&gt; {:a 2 :b 3}"><y>#</y><d>2016-06-11</d><h>13:24</h><w>conaw</w><pre>(transform [ALL LAST (sp/collect ALL (sp/must :foo))]
        count
    {:a [{:foo 1} {:bar 3} {:foo 4}]
     :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
;;=&gt; {:a 2 :b 3}</pre></z><z id="t1465651491" t="conaw in this example at least"><y>#</y><d>2016-06-11</d><h>13:24</h><w>conaw</w>in this example at least</z><z id="t1465651671" t="nathanmarz @conaw: not reproducing your [ALL LAST] vs. MAP-VALS"><y>#</y><d>2016-06-11</d><h>13:27</h><w>nathanmarz</w>@conaw: not reproducing your [ALL LAST] vs. MAP-VALS</z><z id="t1465651702" t="codonnell I&apos;m not sure how those are working with plain count. Shouldn&apos;t the transforming function get passed two values?"><y>#</y><d>2016-06-11</d><h>13:28</h><w>codonnell</w>I&apos;m not sure how those are working with plain count. Shouldn&apos;t the transforming function get passed two values?</z><z id="t1465651719" t="codonnell I get an exception that count is passed two values."><y>#</y><d>2016-06-11</d><h>13:28</h><w>codonnell</w>I get an exception that count is passed two values.</z><z id="t1465651740" t="nathanmarz it shouldn&apos;t be working but it looks like clojurescript doesn&apos;t throw an arity exception"><y>#</y><d>2016-06-11</d><h>13:29</h><w>nathanmarz</w>it shouldn&apos;t be working but it looks like clojurescript doesn&apos;t throw an arity exception</z><z id="t1465651748" t="nathanmarz it just ignores args beyond the first"><y>#</y><d>2016-06-11</d><h>13:29</h><w>nathanmarz</w>it just ignores args beyond the first</z><z id="t1465652144" t="conaw either way, why would I be getting 0 back from the map vals transform"><y>#</y><d>2016-06-11</d><h>13:35</h><w>conaw</w>either way, why would I be getting 0 back from the map vals transform</z><z id="t1465652162" t="conaw this is the exact code I’m running (transform [ALL LAST (collect ALL (must :foo))] count {:a [{:foo 1} {:bar 3} {:foo 4}] :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]}) (transform [MAP-VALS (sp/collect ALL (pred :foo))] (fn [a _] (count a)) {:a [{:foo 1} {:bar 3} {:foo 4}] :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]}) "><y>#</y><d>2016-06-11</d><h>13:36</h><w>conaw</w>this is the exact code I’m running <pre>(transform [ALL LAST (collect ALL (must :foo))]
        count
    {:a [{:foo 1} {:bar 3} {:foo 4}]
     :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})


(transform [MAP-VALS (sp/collect ALL (pred :foo))]
           (fn [a _] (count a))
           {:a [{:foo 1} {:bar 3} {:foo 4}]
            :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
</pre></z><z id="t1465652172" t="conaw using specter 0.11.2"><y>#</y><d>2016-06-11</d><h>13:36</h><w>conaw</w>using specter 0.11.2</z><z id="t1465652217" t="conaw (transform [ALL LAST (collect ALL (must :foo))] (fn [a _] (count a)) {:a [{:foo 1} {:bar 3} {:foo 4}] :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]}) "><y>#</y><d>2016-06-11</d><h>13:36</h><w>conaw</w><pre>(transform [ALL LAST (collect ALL (must :foo))]
        (fn [a _] (count a))
    {:a [{:foo 1} {:bar 3} {:foo 4}]
     :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
</pre></z><z id="t1465652223" t="conaw this also returns expected value"><y>#</y><d>2016-06-11</d><h>13:37</h><w>conaw</w>this also returns expected value</z><z id="t1465652231" t="conaw just MAP-VALS that doesn&apos;t"><y>#</y><d>2016-06-11</d><h>13:37</h><w>conaw</w>just MAP-VALS that doesn&apos;t</z><z id="t1465652241" t="nathanmarz cljs.user=&gt; (transform [s/MAP-VALS (s/collect s/ALL (s/pred :foo))] (fn [a _] (count a)) {:a [{:foo 1} {:bar 3} {:foo 4}] :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]}) {:a 2, :b 3} "><y>#</y><d>2016-06-11</d><h>13:37</h><w>nathanmarz</w><pre>cljs.user=&gt; 
(transform [s/MAP-VALS (s/collect s/ALL (s/pred :foo))]
           (fn [a _] (count a))
           {:a [{:foo 1} {:bar 3} {:foo 4}]
            :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
{:a 2, :b 3}
</pre></z><z id="t1465652264" t="nathanmarz cljs.user=&gt; (transform [s/MAP-VALS (s/collect s/ALL (s/must :foo))] (fn [a _] (count a)) {:a [{:foo 1} {:bar 3} {:foo 4}] :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]}) {:a 2, :b 3} "><y>#</y><d>2016-06-11</d><h>13:37</h><w>nathanmarz</w><pre>cljs.user=&gt; 
(transform [s/MAP-VALS (s/collect s/ALL (s/must :foo))]
           (fn [a _] (count a))
           {:a [{:foo 1} {:bar 3} {:foo 4}]
            :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
{:a 2, :b 3}
</pre></z><z id="t1465652307" t="conaw yeah, that’s what I’m running"><y>#</y><d>2016-06-11</d><h>13:38</h><w>conaw</w>yeah, that’s what I’m running</z><z id="t1465652309" t="conaw getting 0"><y>#</y><d>2016-06-11</d><h>13:38</h><w>conaw</w>getting 0</z><z id="t1465652313" t="conaw weird"><y>#</y><d>2016-06-11</d><h>13:38</h><w>conaw</w>weird</z><z id="t1465652317" t="nathanmarz are you redefining MAP-VALS?"><y>#</y><d>2016-06-11</d><h>13:38</h><w>nathanmarz</w>are you redefining MAP-VALS?</z><z id="t1465652321" t="conaw nope"><y>#</y><d>2016-06-11</d><h>13:38</h><w>conaw</w>nope</z><z id="t1465652343" t="nathanmarz are you doing it from a fresh repl?"><y>#</y><d>2016-06-11</d><h>13:39</h><w>nathanmarz</w>are you doing it from a fresh repl?</z><z id="t1465652350" t="conaw just did a lein clean"><y>#</y><d>2016-06-11</d><h>13:39</h><w>conaw</w>just did a lein clean</z><z id="t1465652354" t="conaw and started repl fresh"><y>#</y><d>2016-06-11</d><h>13:39</h><w>conaw</w>and started repl fresh</z><z id="t1465652384" t="nathanmarz (require &apos;[com.rpl.specter :as s]) (require-macros &apos;[com.rpl.specter.macros :refer [select transform]]) (transform [s/MAP-VALS (s/collect s/ALL (s/pred :foo))] (fn [a _] (count a)) {:a [{:foo 1} {:bar 3} {:foo 4}] :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]}) "><y>#</y><d>2016-06-11</d><h>13:39</h><w>nathanmarz</w><pre>(require &apos;[com.rpl.specter :as s])
(require-macros &apos;[com.rpl.specter.macros :refer [select transform]])

(transform [s/MAP-VALS (s/collect s/ALL (s/pred :foo))]
           (fn [a _] (count a))
           {:a [{:foo 1} {:bar 3} {:foo 4}]
            :b [{:foo 1} {:bar 3 :foo 4} {:foo 4}]})
</pre></z><z id="t1465652390" t="nathanmarz and that exact code returns 0?"><y>#</y><d>2016-06-11</d><h>13:39</h><w>nathanmarz</w>and that exact code returns 0?</z><z id="t1465652400" t="conaw indeed"><y>#</y><d>2016-06-11</d><h>13:40</h><w>conaw</w>indeed</z><z id="t1465652456" t="nathanmarz doesn&apos;t make any sense"><y>#</y><d>2016-06-11</d><h>13:40</h><w>nathanmarz</w>doesn&apos;t make any sense</z><z id="t1465652469" t="nathanmarz you&apos;ll need to put up a repo and instructions to reproduce it"><y>#</y><d>2016-06-11</d><h>13:41</h><w>nathanmarz</w>you&apos;ll need to put up a repo and instructions to reproduce it</z><z id="t1465652506" t="nathanmarz oh one more idea"><y>#</y><d>2016-06-11</d><h>13:41</h><w>nathanmarz</w>oh one more idea</z><z id="t1465652509" t="nathanmarz what version of cljs?"><y>#</y><d>2016-06-11</d><h>13:41</h><w>nathanmarz</w>what version of cljs?</z></g><g id="s2"><z id="t1465652539" t="conaw 1.9.14"><y>#</y><d>2016-06-11</d><h>13:42</h><w>conaw</w>1.9.14</z><z id="t1465652589" t="conaw I’ve been using specter and spec together"><y>#</y><d>2016-06-11</d><h>13:43</h><w>conaw</w>I’ve been using specter and spec together</z><z id="t1465652644" t="nathanmarz what version of clojure are you pairing that with?"><y>#</y><d>2016-06-11</d><h>13:44</h><w>nathanmarz</w>what version of clojure are you pairing that with?</z><z id="t1465652649" t="nathanmarz 1.9.0-alpha4?"><y>#</y><d>2016-06-11</d><h>13:44</h><w>nathanmarz</w>1.9.0-alpha4?</z><z id="t1465652653" t="conaw alpha3"><y>#</y><d>2016-06-11</d><h>13:44</h><w>conaw</w>alpha3</z><z id="t1465652669" t="conaw are you on more recent?"><y>#</y><d>2016-06-11</d><h>13:44</h><w>conaw</w>are you on more recent?</z><z id="t1465652788" t="nathanmarz i just tried on those exact versions and it works fine"><y>#</y><d>2016-06-11</d><h>13:46</h><w>nathanmarz</w>i just tried on those exact versions and it works fine</z><z id="t1465652795" t="nathanmarz so yea, need a repo to see what&apos;s going on"><y>#</y><d>2016-06-11</d><h>13:46</h><w>nathanmarz</w>so yea, need a repo to see what&apos;s going on</z><z id="t1465653691" t="luxbock thanks @nathanmarz"><y>#</y><d>2016-06-11</d><h>14:01</h><w>luxbock</w>thanks @nathanmarz</z><z id="t1465653710" t="conaw @luxbock: map-vals works fine for you right?"><y>#</y><d>2016-06-11</d><h>14:01</h><w>conaw</w>@luxbock: map-vals works fine for you right?</z><z id="t1465653760" t="luxbock @conaw, I need to upgrade to check"><y>#</y><d>2016-06-11</d><h>14:02</h><w>luxbock</w>@conaw, I need to upgrade to check</z><z id="t1465654202" t="conaw @nathanmarz: must be something on my end, created a new clean project and got it working fine"><y>#</y><d>2016-06-11</d><h>14:10</h><w>conaw</w>@nathanmarz: must be something on my end, created a new clean project and got it working fine</z><z id="t1465655281" t="conaw this is what I get back from (transform MAP-VALS inc {:a 1 :b 2}) &quot;{:a 1, :b 2}1”"><y>#</y><d>2016-06-11</d><h>14:28</h><w>conaw</w><pre>this is what I get back from (transform MAP-VALS inc {:a 1 :b 2})

&quot;{:a 1, :b 2}1”</pre></z><z id="t1465655326" t="conaw I’m getting that in a file where the ONLY thing I’m loading in is specter"><y>#</y><d>2016-06-11</d><h>14:28</h><w>conaw</w>I’m getting that in a file where the ONLY thing I’m loading in is specter</z><z id="t1465655335" t="conaw and the only function is that"><y>#</y><d>2016-06-11</d><h>14:28</h><w>conaw</w>and the only function is that</z><z id="t1465655395" t="conaw also strange that this is the only part of specter that’s giving me weird results"><y>#</y><d>2016-06-11</d><h>14:29</h><w>conaw</w>also strange that this is the only part of specter that’s giving me weird results</z><z id="t1465659723" t="luxbock ah yeah works fine for me"><y>#</y><d>2016-06-11</d><h>15:42</h><w>luxbock</w>ah yeah works fine for me</z><z id="t1465684311" t="codonnell Does anyone know how subselect is meant to be used?"><y>#</y><d>2016-06-11</d><h>22:31</h><w>codonnell</w>Does anyone know how subselect is meant to be used?</z><z id="t1465684702" t="eraserhd I’ve just published a library that has specter paths for working with formatted EDN and clojure code: https://github.com/maitria/specter-edn"><y>#</y><d>2016-06-11</d><h>22:38</h><w>eraserhd</w>I’ve just published a library that has specter paths for working with formatted EDN and clojure code: <a href="https://github.com/maitria/specter-edn" target="_blank">https://github.com/maitria/specter-edn</a></z><z id="t1465684734" t="eraserhd It navigates to parsed S-expressions, but re-inserts whitespace and comments."><y>#</y><d>2016-06-11</d><h>22:38</h><w>eraserhd</w>It navigates to parsed S-expressions, but re-inserts whitespace and comments.</z><z id="t1465688822" t="nathanmarz @codonnell: subselect navigates you to the elements in the given path and lets you manipulate them as a sequence, but transformations will be applied back at the original locations"><y>#</y><d>2016-06-11</d><h>23:47</h><w>nathanmarz</w>@codonnell: <code>subselect</code> navigates you to the elements in the given path and lets you manipulate them as a sequence, but transformations will be applied back at the original locations</z><z id="t1465688846" t="nathanmarz (transform (subselect (walker number?) even?) reverse [1 [[[2]] 3] 5 [6 [7 8]] 10]) ;; =&gt; [1 [[[10]] 3] 5 [8 [7 6]] 2] "><y>#</y><d>2016-06-11</d><h>23:47</h><w>nathanmarz</w><pre>(transform (subselect (walker number?) even?)
  reverse
  [1 [[[2]] 3] 5 [6 [7 8]] 10])
;; =&gt; [1 [[[10]] 3] 5 [8 [7 6]] 2]
</pre></z><z id="t1465689009" t="nathanmarz @eraserhd: very cool!"><y>#</y><d>2016-06-11</d><h>23:50</h><w>nathanmarz</w>@eraserhd: very cool!</z><z id="t1465689838" t="codonnell @nathanmarz: ok, so it&apos;s a more general version of pathed functions like srange and filterer"><y>#</y><d>2016-06-12</d><h>00:03</h><w>codonnell</w>@nathanmarz: ok, so it&apos;s a more general version of pathed functions like srange and filterer</z><z id="t1465689843" t="codonnell thanks for the response"><y>#</y><d>2016-06-12</d><h>00:04</h><w>codonnell</w>thanks for the response</z><z id="t1465689847" t="codonnell the example was very helpful"><y>#</y><d>2016-06-12</d><h>00:04</h><w>codonnell</w>the example was very helpful</z><z id="t1465698309" t="nathanmarz @codonnell: It&apos;s a generalization of filterer but not of srange"><y>#</y><d>2016-06-12</d><h>02:25</h><w>nathanmarz</w>@codonnell: It&apos;s a generalization of filterer but not of srange</z><z id="t1465698339" t="nathanmarz filterer is defined as (subselect ALL (selected? path))"><y>#</y><d>2016-06-12</d><h>02:25</h><w>nathanmarz</w>filterer is defined as (subselect ALL (selected? path))</z><z id="t1465698385" t="nathanmarz the expected transformed sequence for subselect is expected to remain the same size, with each index referring to a particular location in the original structure"><y>#</y><d>2016-06-12</d><h>02:26</h><w>nathanmarz</w>the expected transformed sequence for subselect is expected to remain the same size, with each index referring to a particular location in the original structure</z><z id="t1465698408" t="nathanmarz the transformed sequence for srange can be of any size and will splice back into the original sequence to replace the original subsequence"><y>#</y><d>2016-06-12</d><h>02:26</h><w>nathanmarz</w>the transformed sequence for srange can be of any size and will splice back into the original sequence to replace the original subsequence</z><z id="t1465699169" t="codonnell @nathanmarz: that makes sense."><y>#</y><d>2016-06-12</d><h>02:39</h><w>codonnell</w>@nathanmarz: that makes sense.</z><z id="t1465699443" t="codonnell @nathanmarz: I put up my notes and examples as a github wiki page at https://github.com/codonnell/specter/wiki/List-of-Navigators . It could serve as a starting point for navigator reference documentation; you&apos;re welcome to copy any of it that you&apos;d like."><y>#</y><d>2016-06-12</d><h>02:44</h><w>codonnell</w>@nathanmarz: I put up my notes and examples as a github wiki page at <a href="https://github.com/codonnell/specter/wiki/List-of-Navigators" target="_blank">https://github.com/codonnell/specter/wiki/List-of-Navigators</a>. It could serve as a starting point for navigator reference documentation; you&apos;re welcome to copy any of it that you&apos;d like.</z><z id="t1465708892" t="aengelberg I like your wiki page because every navigator has a few examples. I&apos;m hoping Specter&apos;s official docs will be like that eventually."><y>#</y><d>2016-06-12</d><h>05:21</h><w>aengelberg</w>I like your wiki page because every navigator has a few examples. I&apos;m hoping Specter&apos;s official docs will be like that eventually.</z><z id="t1465737836" t="nathanmarz @codonnell: That&apos;s great, I&apos;d like to get that merged into the official docs at some point"><y>#</y><d>2016-06-12</d><h>13:23</h><w>nathanmarz</w>@codonnell: That&apos;s great, I&apos;d like to get that merged into the official docs at some point</z><z id="t1465737865" t="nathanmarz I made some modifications for things that were implementation details and not promised to have that exact behavior in future versions"><y>#</y><d>2016-06-12</d><h>13:24</h><w>nathanmarz</w>I made some modifications for things that were implementation details and not promised to have that exact behavior in future versions</z><z id="t1465737903" t="nathanmarz For example, in many parts it said &quot;returns a lazy sequence when used in a select&quot;, and that behavior is already completely different in 0.12.0"><y>#</y><d>2016-06-12</d><h>13:25</h><w>nathanmarz</w>For example, in many parts it said &quot;returns a lazy sequence when used in a select&quot;, and that behavior is already completely different in 0.12.0</z><z id="t1465737944" t="nathanmarz As for params-reset , that&apos;s used to make a recursive path that requires parameters"><y>#</y><d>2016-06-12</d><h>13:25</h><w>nathanmarz</w>As for <code>params-reset</code>, that&apos;s used to make a recursive path that requires parameters</z><z id="t1465737972" t="nathanmarz by wrapping the recursive call in params-reset , it tells the recursive navigation to use the same parameters"><y>#</y><d>2016-06-12</d><h>13:26</h><w>nathanmarz</w>by wrapping the recursive call in <code>params-reset</code>, it tells the recursive navigation to use the same parameters</z><z id="t1465738016" t="nathanmarz e.g. (declarepath MyWalker [k]) (providepath MyWalker (stay-then-continue must (params-reset MyWalker))) (select (MyWalker :a) {:a {:a {:b 2}}}) ;; =&gt; [{:a {:a {:b 2}}} {:a {:b 2}} {:b 2}] "><y>#</y><d>2016-06-12</d><h>13:26</h><w>nathanmarz</w>e.g.
<pre>(declarepath MyWalker [k])
(providepath MyWalker
  (stay-then-continue must (params-reset MyWalker)))

(select (MyWalker :a) {:a {:a {:b 2}}})
;; =&gt; [{:a {:a {:b 2}}} {:a {:b 2}} {:b 2}]
</pre></z><z id="t1465739272" t="nathanmarz I merged it into the Specter wiki: https://github.com/nathanmarz/specter/wiki/List-of-Navigators"><y>#</y><d>2016-06-12</d><h>13:47</h><w>nathanmarz</w>I merged it into the Specter wiki: <a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators</a></z><z id="t1465743032" t="luxbock https://github.com/nathanmarz/specter/issues/123"><y>#</y><d>2016-06-12</d><h>14:50</h><w>luxbock</w><a href="https://github.com/nathanmarz/specter/issues/123" target="_blank">https://github.com/nathanmarz/specter/issues/123</a></z><z id="t1465743540" t="rauh I like it, but PLEASE don&apos;t introduce anymore breaking changes"><y>#</y><d>2016-06-12</d><h>14:59</h><w>rauh</w>I like it, but PLEASE don&apos;t introduce anymore breaking changes</z><z id="t1465743569" t="rauh It&apos;s such a pain, I can&apos;t currently upgrade and I&apos;m stuck with an older version since the breaking macros changes."><y>#</y><d>2016-06-12</d><h>14:59</h><w>rauh</w>It&apos;s such a pain, I can&apos;t currently upgrade and I&apos;m stuck with an older version since the breaking macros changes.</z><z id="t1465744496" t="nathanmarz @rauh breaking changes are only done when they are necessary to enable very significant improvements"><y>#</y><d>2016-06-12</d><h>15:14</h><w>nathanmarz</w>@rauh breaking changes are only done when they are necessary to enable very significant improvements</z><z id="t1465744547" t="nathanmarz what&apos;s preventing you from upgrading and making the appropriate updates?"><y>#</y><d>2016-06-12</d><h>15:15</h><w>nathanmarz</w>what&apos;s preventing you from upgrading and making the appropriate updates?</z><z id="t1465745176" t="rauh @nathanmarz: I can&apos;t upgrade since midje pulls in an older specter"><y>#</y><d>2016-06-12</d><h>15:26</h><w>rauh</w>@nathanmarz: I can&apos;t upgrade since midje pulls in an older specter</z><z id="t1465745396" t="nathanmarz @rauh yea, that&apos;s unfortunate"><y>#</y><d>2016-06-12</d><h>15:29</h><w>nathanmarz</w>@rauh yea, that&apos;s unfortunate</z><z id="t1465745448" t="rauh Not the end of the world, but specter is getting to the point (1100 gh stars, 57k clojar pulls) that it should be careful if the breaking changes are needed."><y>#</y><d>2016-06-12</d><h>15:30</h><w>rauh</w>Not the end of the world, but specter is getting to the point (1100 gh stars, 57k clojar pulls) that it should be careful if the breaking changes are needed.</z><z id="t1465745484" t="nathanmarz like I said, I only make breaking changes when the benefits are very significant"><y>#</y><d>2016-06-12</d><h>15:31</h><w>nathanmarz</w>like I said, I only make breaking changes when the benefits are very significant</z><z id="t1465745485" t="rauh I agree that the macros was a change that was worth it."><y>#</y><d>2016-06-12</d><h>15:31</h><w>rauh</w>I agree that the macros was a change that was worth it.</z><z id="t1465745504" t="nathanmarz 0.12.0 will have another breaking change, but it only affects projects that define their own navigators"><y>#</y><d>2016-06-12</d><h>15:31</h><w>nathanmarz</w>0.12.0 will have another breaking change, but it only affects projects that define their own navigators</z><z id="t1465745562" t="rauh Well I blame suchwow (used by midje) more for that since they use specter twice! (Two simple transform )"><y>#</y><d>2016-06-12</d><h>15:32</h><w>rauh</w>Well I blame <code>suchwow</code> (used by midje) more for that since they use specter twice! (Two simple <code>transform</code>)</z><z id="t1465745598" t="nathanmarz Ah, well the 0.12.0 change only affects the select path"><y>#</y><d>2016-06-12</d><h>15:33</h><w>nathanmarz</w>Ah, well the 0.12.0 change only affects the select path</z><z id="t1465746189" t="luxbock is there a better way to write the following: https://gist.github.com/luxbock/93d61ccd38b340a99dfd3a93682b5f6c"><y>#</y><d>2016-06-12</d><h>15:43</h><w>luxbock</w>is there a better way to write the following: <a href="https://gist.github.com/luxbock/93d61ccd38b340a99dfd3a93682b5f6c" target="_blank">https://gist.github.com/luxbock/93d61ccd38b340a99dfd3a93682b5f6c</a></z><z id="t1465746206" t="luxbock my actual use case is slightly more complicated"><y>#</y><d>2016-06-12</d><h>15:43</h><w>luxbock</w>my actual use case is slightly more complicated</z><z id="t1465746560" t="nathanmarz (let [foo-map {:foo #{1 2 3} :bar #{5 6}}] (transform [ALL (collect-one FIRST (view #(get foo-map %))) LAST ALL ] (fn [aset v] (if (aset v) (str v) (inc v) )) {:foo [1 2 4 5] :bar [2 3 5 6]} )) "><y>#</y><d>2016-06-12</d><h>15:49</h><w>nathanmarz</w><pre>(let [foo-map {:foo #{1 2 3} :bar #{5 6}}]
  (transform [ALL
              (collect-one FIRST (view #(get foo-map %)))
              LAST
              ALL
              ]
    (fn [aset v]
      (if (aset v)
        (str v)
        (inc v)
        ))
    {:foo [1 2 4 5]
     :bar [2 3 5 6]}
    ))
</pre></z><z id="t1465746705" t="luxbock @nathanmarz: nice, I&apos;ll have to get familiar with view `"><y>#</y><d>2016-06-12</d><h>15:51</h><w>luxbock</w>@nathanmarz: nice, I&apos;ll have to get familiar with <code>view</code>`</z><z id="t1465747739" t="codonnell @nathanmarz: I added a description and examples for params-reset at https://github.com/codonnell/specter/wiki/List-of-Navigators#params-reset"><y>#</y><d>2016-06-12</d><h>16:08</h><w>codonnell</w>@nathanmarz: I added a description and examples for <code>params-reset</code> at <a href="https://github.com/codonnell/specter/wiki/List-of-Navigators#params-reset" target="_blank">https://github.com/codonnell/specter/wiki/List-of-Navigators#params-reset</a></z><z id="t1465747784" t="codonnell Thanks for removing the implementation detail."><y>#</y><d>2016-06-12</d><h>16:09</h><w>codonnell</w>Thanks for removing the implementation detail.</z><z id="t1465748172" t="codonnell Is there a reason params-reset takes a single path argument rather than a varargs like most of the other pathed functions?"><y>#</y><d>2016-06-12</d><h>16:16</h><w>codonnell</w>Is there a reason <code>params-reset</code> takes a single path argument rather than a varargs like most of the other pathed functions?</z><z id="t1465748350" t="nathanmarz @codonnell: It&apos;s only intended for the particular use case of recursive parameterized navigators"><y>#</y><d>2016-06-12</d><h>16:19</h><w>nathanmarz</w>@codonnell: It&apos;s only intended for the particular use case of recursive parameterized navigators</z><z id="t1465748393" t="nathanmarz your description for params-reset is a little inaccurate – it actually decrements position in params array by the number of parameters that navigator requires"><y>#</y><d>2016-06-12</d><h>16:19</h><w>nathanmarz</w>your description for params-reset is a little inaccurate – it actually decrements position in params array by the number of parameters that navigator requires</z><z id="t1465748407" t="nathanmarz where that&apos;s important is a path like [must MyWalker]"><y>#</y><d>2016-06-12</d><h>16:20</h><w>nathanmarz</w>where that&apos;s important is a path like <code>[must MyWalker]</code></z><z id="t1465748423" t="nathanmarz will merge in and fix description"><y>#</y><d>2016-06-12</d><h>16:20</h><w>nathanmarz</w>will merge in and fix description</z><z id="t1465748578" t="nathanmarz https://github.com/nathanmarz/specter/wiki/List-of-Navigators#params-reset"><y>#</y><d>2016-06-12</d><h>16:22</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#params-reset" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#params-reset</a></z><z id="t1465748794" t="codonnell The new description makes perfect sense."><y>#</y><d>2016-06-12</d><h>16:26</h><w>codonnell</w>The new description makes perfect sense.</z><z id="t1465748849" t="nathanmarz By the way, really appreciate the documentation contribution – that&apos;s Specter&apos;s biggest problem at the moment"><y>#</y><d>2016-06-12</d><h>16:27</h><w>nathanmarz</w>By the way, really appreciate the documentation contribution – that&apos;s Specter&apos;s biggest problem at the moment</z><z id="t1465748919" t="codonnell You&apos;re most welcome."><y>#</y><d>2016-06-12</d><h>16:28</h><w>codonnell</w>You&apos;re most welcome.</z><z id="t1465749321" t="conaw @codonnell: 👏"><y>#</y><d>2016-06-12</d><h>16:35</h><w>conaw</w>@codonnell: <b>👏</b></z><z id="t1465749518" t="codonnell @nathanmarz: I just realized every all-caps link and link with a &gt; in it was broken. It&apos;s fixed on my wiki. (Oops)"><y>#</y><d>2016-06-12</d><h>16:38</h><w>codonnell</w>@nathanmarz: I just realized every all-caps link and link with a <code>&gt;</code> in it was broken. It&apos;s fixed on my wiki. (Oops)</z><z id="t1465749629" t="conaw Also, discovered the map-vals bug earlier wasn’t a bug, just my own insufficient cleaning of compiled javascript when updating specter versions."><y>#</y><d>2016-06-12</d><h>16:40</h><w>conaw</w>Also, discovered the map-vals bug earlier wasn’t a bug, just my own insufficient cleaning of compiled javascript when updating specter versions.</z><z id="t1465749711" t="nathanmarz @codonnell: merged, thanks"><y>#</y><d>2016-06-12</d><h>16:41</h><w>nathanmarz</w>@codonnell: merged, thanks</z><z id="t1465749722" t="nathanmarz @conaw: cool, good to know"><y>#</y><d>2016-06-12</d><h>16:42</h><w>nathanmarz</w>@conaw: cool, good to know</z><z id="t1465846749" t="nathanmarz @mfikes: do you think it&apos;s possible to redo your macroexpand&apos; implementation in terms of cljs.analyzer/macroexpand-1 ?"><y>#</y><d>2016-06-13</d><h>19:39</h><w>nathanmarz</w>@mfikes: do you think it&apos;s possible to redo your <code>macroexpand&apos;</code> implementation in terms of <code>cljs.analyzer/macroexpand-1</code>?</z><z id="t1465846770" t="mfikes Sure… I think one just calls the other recursively or somesuch"><y>#</y><d>2016-06-13</d><h>19:39</h><w>mfikes</w>Sure… I think one just calls the other recursively or somesuch</z><z id="t1465846808" t="nathanmarz does it still need to do the eval stuff?"><y>#</y><d>2016-06-13</d><h>19:40</h><w>nathanmarz</w>does it still need to do the eval stuff?</z><z id="t1465846880" t="nathanmarz basically I need a macroexpand-all implementation for non-bootstrap clojurescript that&apos;s distinct from the clojure version of macroexpand-all, and I want to see if the bootstrap and non-bootstrap impls can be the same"><y>#</y><d>2016-06-13</d><h>19:41</h><w>nathanmarz</w>basically I need a macroexpand-all implementation for non-bootstrap clojurescript that&apos;s distinct from the clojure version of macroexpand-all, and I want to see if the bootstrap and non-bootstrap impls can be the same</z><z id="t1465846906" t="mfikes Hmm… I think the need to eval was simply to cope with not having the form being directly passed to macroexpand. (looking at my post http://blog.fikesfarm.com/posts/2015-09-05-runtime-macroexpand.html )"><y>#</y><d>2016-06-13</d><h>19:41</h><w>mfikes</w>Hmm… I think the need to eval was simply to cope with not having the form being directly passed to macroexpand. (looking at my post <a href="http://blog.fikesfarm.com/posts/2015-09-05-runtime-macroexpand.html" target="_blank">http://blog.fikesfarm.com/posts/2015-09-05-runtime-macroexpand.html</a>)</z><z id="t1465847036" t="mfikes If there is a use case that you’d like it to work for, I wouldn’t mind taking a look perhaps later on tonight to see if it can be made to work in bootstrap."><y>#</y><d>2016-06-13</d><h>19:43</h><w>mfikes</w>If there is a use case that you’d like it to work for, I wouldn’t mind taking a look perhaps later on tonight to see if it can be made to work in bootstrap.</z><z id="t1465847102" t="nathanmarz i&apos;ll get it working for non-boostrap cljs, and then I&apos;ll ping you to see if the new impl works for bootstrap"><y>#</y><d>2016-06-13</d><h>19:45</h><w>nathanmarz</w>i&apos;ll get it working for non-boostrap cljs, and then I&apos;ll ping you to see if the new impl works for bootstrap</z><z id="t1465847121" t="nathanmarz otherwise specter will just use a different macroexpand-all for each of the 3 cases"><y>#</y><d>2016-06-13</d><h>19:45</h><w>nathanmarz</w>otherwise specter will just use a different macroexpand-all for each of the 3 cases</z><z id="t1465847157" t="mfikes OK… yeah, and I just saw the thread in #C03S1L9DN 🙂"><y>#</y><d>2016-06-13</d><h>19:45</h><w>mfikes</w>OK… yeah, and I just saw the thread in #C03S1L9DN <b>🙂</b></z><z id="t1465847226" t="mfikes By the way, Specter is the only major lib I’m aware of that is straddling all 3 targets. It feels like it ain’t easy to do, but it can be done. 🙂"><y>#</y><d>2016-06-13</d><h>19:47</h><w>mfikes</w>By the way, Specter is the only major lib I’m aware of that is straddling all 3 targets. It feels like it ain’t easy to do, but it can be done. <b>🙂</b></z><z id="t1465847234" t="nathanmarz indeed"><y>#</y><d>2016-06-13</d><h>19:47</h><w>nathanmarz</w>indeed</z><z id="t1465847286" t="nathanmarz sometimes I yell out the occasional profanity, but it&apos;s doable"><y>#</y><d>2016-06-13</d><h>19:48</h><w>nathanmarz</w>sometimes I yell out the occasional profanity, but it&apos;s doable</z><z id="t1465847319" t="mfikes Hah. As you said, profanity leads to code these days."><y>#</y><d>2016-06-13</d><h>19:48</h><w>mfikes</w>Hah. As you said, profanity leads to code these days.</z><z id="t1465853075" t="nathanmarz @mfikes: alright, finally got it working with this commit https://github.com/nathanmarz/specter/commit/8c128816f58d8e2188a8a19b7d336dc5a128f7d3"><y>#</y><d>2016-06-13</d><h>21:24</h><w>nathanmarz</w>@mfikes: alright, finally got it working with this commit <a href="https://github.com/nathanmarz/specter/commit/8c128816f58d8e2188a8a19b7d336dc5a128f7d3" target="_blank">https://github.com/nathanmarz/specter/commit/8c128816f58d8e2188a8a19b7d336dc5a128f7d3</a></z><z id="t1465853083" t="nathanmarz let me know if it&apos;s still bootstrap-compatible"><y>#</y><d>2016-06-13</d><h>21:24</h><w>nathanmarz</w>let me know if it&apos;s still bootstrap-compatible</z><z id="t1465854801" t="mfikes @nathanmarz: will do"><y>#</y><d>2016-06-13</d><h>21:53</h><w>mfikes</w>@nathanmarz: will do</z><z id="t1465855969" t="mfikes @nathanmarz: Gotta run but was at least able to see a problem with riddley.walk : $ planck -c target/specter-0.12.0-SNAPSHOT.jar:/Users/mfikes/.m2/repository/riddley/riddley/0.1.12/riddley-0.1.12.jar Planck 1.14 ClojureScript 1.9.14 Docs: (doc function-name-here) (find-doc &quot;part-of-name-here&quot;) Source: (source function-name-here) Exit: Control+D or :cljs/quit or exit or quit Results: Stored in vars *1, *2, *3, an exception in *e cljs.user=&gt; (require-macros &apos;[com.rpl.specter.macros :refer [transform]]) No such namespace: riddley.walk, could not locate riddley/walk.cljs, riddley/walk.cljc, or Closure namespace &quot;riddley.walk&quot; nil "><y>#</y><d>2016-06-13</d><h>22:12</h><w>mfikes</w>@nathanmarz: Gotta run but was at least able to see a problem with <code>riddley.walk</code>:
<pre>$ planck -c target/specter-0.12.0-SNAPSHOT.jar:/Users/mfikes/.m2/repository/riddley/riddley/0.1.12/riddley-0.1.12.jar
Planck 1.14
ClojureScript 1.9.14
    Docs: (doc function-name-here)
          (find-doc &quot;part-of-name-here&quot;)
  Source: (source function-name-here)
    Exit: Control+D or :cljs/quit or exit or quit
 Results: Stored in vars *1, *2, *3, an exception in *e

cljs.user=&gt; (require-macros &apos;[com.rpl.specter.macros :refer [transform]])
No such namespace: riddley.walk, could not locate riddley/walk.cljs, riddley/walk.cljc, or Closure namespace &quot;riddley.walk&quot;
nil
</pre></z><z id="t1465861813" t="nathanmarz @mfikes: ok, changed master so that shouldn&apos;t happen anymore with bootstrap"><y>#</y><d>2016-06-13</d><h>23:50</h><w>nathanmarz</w>@mfikes: ok, changed master so that shouldn&apos;t happen anymore with bootstrap</z><z id="t1465866211" t="mfikes @nathanmarz: With master, the transform operation I typically try works. But, when loading com.rpl.specter.macros it complains about the use of require and eval on lines 448 and 452. I’m wondering, though, is a transform call sufficient to cover the new macroexpand code? (I suspect not, given require and eval being in the code paths that you probably want tested.)"><y>#</y><d>2016-06-14</d><h>01:03</h><w>mfikes</w>@nathanmarz: With master, the <code>transform</code> operation I typically try works. But, when loading <code>com.rpl.specter.macros</code> it complains about the use of <code>require</code> and <code>eval</code> on lines 448 and 452. I’m wondering, though, is a <code>transform</code> call sufficient to cover the new macroexpand code? (I suspect not, given <code>require</code> and <code>eval</code> being in the code paths that you probably want tested.)</z><z id="t1465866548" t="mfikes @nathanmarz: Ahh… I found a call that will make it fail in bootstrap: cljs.user=&gt; (transform [(filterer odd?) LAST] #_=&gt; inc #_=&gt; [2 1 3 6 9 4 8]) ⬆ undefined is not an object (evaluating &apos;com.rpl.specter.macros$macros.require.call&apos;) at line 1 "><y>#</y><d>2016-06-14</d><h>01:09</h><w>mfikes</w>@nathanmarz: Ahh… I found a call that will make it fail in bootstrap:
<pre>cljs.user=&gt; (transform [(filterer odd?) LAST]
       #_=&gt;               inc
       #_=&gt;               [2 1 3 6 9 4 8])
             ⬆
undefined is not an object (evaluating &apos;com.rpl.specter.macros$macros.require.call&apos;) at line 1
</pre></z><z id="t1465866593" t="mfikes (I hear the profanity from here.)"><y>#</y><d>2016-06-14</d><h>01:09</h><w>mfikes</w>(I hear the profanity from here.)</z><z id="t1465867638" t="mfikes @nathanmarz: It can be made to work in bootstrap by eliminating the require and the eval. Perhaps macros.clj would need to be converted to macros.cljx or somesuch to pull it off. This bit of code worked: (defn cljs-macroexpand [env form] #_(require &apos;cljs.analyzer) ;; need to get the expansion function like this so that ;; this code compiles in a clojure environment where cljs.analyzer ;; namespace does not exist (let [expand-fn cljs.analyzer/macroexpand-1 mform (expand-fn env form)] (cond (identical? form mform) mform (and (seq? mform) (#{&apos;js*} (first mform))) form :else (cljs-macroexpand env mform)))) and here it is working with those changes: cljs.user=&gt; (require-macros &apos;[com.rpl.specter.macros :refer [transform]]) nil cljs.user=&gt; (require &apos;[com.rpl.specter :refer [filterer LAST]]) nil cljs.user=&gt; (transform [(filterer odd?) LAST] #_=&gt; inc #_=&gt; [2 1 3 6 9 4 8]) [2 1 3 6 10 4 8] "><y>#</y><d>2016-06-14</d><h>01:27</h><w>mfikes</w>@nathanmarz: It can be made to work in bootstrap by eliminating the <code>require</code> and the eval. Perhaps <code>macros.clj</code> would need to be converted to <code>macros.cljx</code> or somesuch to pull it off. This bit of code worked:
<pre>(defn cljs-macroexpand [env form]
  #_(require &apos;cljs.analyzer)
  ;; need to get the expansion function like this so that 
  ;; this code compiles in a clojure environment where cljs.analyzer
  ;; namespace does not exist
  (let [expand-fn cljs.analyzer/macroexpand-1
        mform (expand-fn env form)]
    (cond (identical? form mform) mform
          (and (seq? mform) (#{&apos;js*} (first mform))) form
          :else (cljs-macroexpand env mform))))
</pre>
and here it is working with those changes: 
<pre>cljs.user=&gt; (require-macros &apos;[com.rpl.specter.macros :refer [transform]])
nil
cljs.user=&gt; (require &apos;[com.rpl.specter :refer [filterer LAST]])
nil
cljs.user=&gt; (transform [(filterer odd?) LAST]
       #_=&gt;  inc
       #_=&gt;  [2 1 3 6 9 4 8])
[2 1 3 6 10 4 8]
</pre></z><z id="t1465900100" t="conaw Challenge For all the keys in a map of maps, return a vector that has the key and all of the values of its value, so {:keep0 {:ignore :keep1, :ignore1 :keep2}} -&gt; [[:keep0 :keep1 :keep2]] closest I’ve got is (select [ALL (sp/collect-one sp/FIRST) LAST (sp/subselect MAP-VALS)] nested-map) which gives me [[:keep0 (:keep1 :keep2)]] "><y>#</y><d>2016-06-14</d><h>10:28</h><w>conaw</w>Challenge 
<pre>For all the keys in a map of maps, return a vector that has the key and all of the values of its value,   
so 
 {:keep0 {:ignore :keep1, :ignore1 :keep2}}
-&gt;
[[:keep0 :keep1 :keep2]]

closest I’ve got is

(select [ALL (sp/collect-one sp/FIRST) LAST (sp/subselect MAP-VALS)] nested-map)

which gives me 

[[:keep0 (:keep1 :keep2)]]
</pre></z><z id="t1465907463" t="nathanmarz @conaw: (select [ALL (subselect (multi-path FIRST [LAST MAP-VALS]))] {:keep0 {:ignore :keep1, :ignore1 :keep2}})"><y>#</y><d>2016-06-14</d><h>12:31</h><w>nathanmarz</w>@conaw: <code>(select [ALL (subselect (multi-path FIRST [LAST MAP-VALS]))] {:keep0 {:ignore :keep1, :ignore1 :keep2}})</code></z><z id="t1465907550" t="nathanmarz @mfikes: with those changes does this code work? (require &apos;[com.rpl.specter :as s]) (require-macros &apos;[com.rpl.specter.macros :refer [select transform traverse collected?]]) (select [s/VAL (collected? [v] (= v 1)) s/DISPENSE] 1) "><y>#</y><d>2016-06-14</d><h>12:32</h><w>nathanmarz</w>@mfikes: with those changes does this code work?
<pre>(require &apos;[com.rpl.specter :as s])
(require-macros &apos;[com.rpl.specter.macros :refer [select transform traverse collected?]])

(select [s/VAL (collected? [v] (= v 1)) s/DISPENSE] 1)
</pre></z><z id="t1465907577" t="nathanmarz should return [1]"><y>#</y><d>2016-06-14</d><h>12:32</h><w>nathanmarz</w>should return <code>[1]</code></z><z id="t1465907736" t="mfikes @nathanmarz: Yes, I get [1] in Planck, with no warnings with those proposed changes"><y>#</y><d>2016-06-14</d><h>12:35</h><w>mfikes</w>@nathanmarz: Yes, I get <code>[1]</code> in Planck, with no warnings with those proposed changes</z><z id="t1465907808" t="nathanmarz great"><y>#</y><d>2016-06-14</d><h>12:36</h><w>nathanmarz</w>great</z><z id="t1465907821" t="nathanmarz should be able to fiddle with the code to get it working on all three platforms"><y>#</y><d>2016-06-14</d><h>12:37</h><w>nathanmarz</w>should be able to fiddle with the code to get it working on all three platforms</z><z id="t1465908329" t="nathanmarz @mfikes: ok, made the changes. let me know how it goes"><y>#</y><d>2016-06-14</d><h>12:45</h><w>nathanmarz</w>@mfikes: ok, made the changes. let me know how it goes</z><z id="t1465908527" t="mfikes @nathanmarz: Pulled down master of Specter and it’s a go for bootstrap with respect to trying out the select above."><y>#</y><d>2016-06-14</d><h>12:48</h><w>mfikes</w>@nathanmarz: Pulled down master of Specter and it’s a go for bootstrap with respect to trying out the <code>select</code> above.</z><z id="t1465908544" t="nathanmarz awesome"><y>#</y><d>2016-06-14</d><h>12:49</h><w>nathanmarz</w>awesome</z><z id="t1465938414" t="codonnell @nathanmarz: Continuing my efforts to understand; I wrote up some docs on the macros namespace at https://github.com/codonnell/specter/wiki/List-of-Macros . I don&apos;t have all the macros in there yet and I&apos;m not as confident in the accuracy of my descriptions. Again, it could be a starting point for documentation."><y>#</y><d>2016-06-14</d><h>21:06</h><w>codonnell</w>@nathanmarz: Continuing my efforts to understand; I wrote up some docs on the <code>macros</code> namespace at <a href="https://github.com/codonnell/specter/wiki/List-of-Macros" target="_blank">https://github.com/codonnell/specter/wiki/List-of-Macros</a>. I don&apos;t have all the macros in there yet and I&apos;m not as confident in the accuracy of my descriptions. Again, it could be a starting point for documentation.</z><z id="t1465940287" t="nathanmarz @codonnell: actually very accurate"><y>#</y><d>2016-06-14</d><h>21:38</h><w>nathanmarz</w>@codonnell: actually very accurate</z><z id="t1465940296" t="nathanmarz the only thing I&apos;d change is the example for defpathedfn"><y>#</y><d>2016-06-14</d><h>21:38</h><w>nathanmarz</w>the only thing I&apos;d change is the example for <code>defpathedfn</code></z><z id="t1465940318" t="nathanmarz defpathedfn is only meant for higher order navigators that take in paths as input"><y>#</y><d>2016-06-14</d><h>21:38</h><w>nathanmarz</w><code>defpathedfn</code> is only meant for higher order navigators that take in paths as input</z><z id="t1465940339" t="nathanmarz the ^:notpath thing is if they also require a non-path param, for which transformed is the only case of that"><y>#</y><d>2016-06-14</d><h>21:38</h><w>nathanmarz</w>the <code>^:notpath</code> thing is if they also require a non-path param, for which <code>transformed</code> is the only case of that</z><z id="t1465940372" t="nathanmarz making a constructor function for a navigator which converts the constructor params to the navigator params is what defnavconstructor is for"><y>#</y><d>2016-06-14</d><h>21:39</h><w>nathanmarz</w>making a constructor function for a navigator which converts the constructor params to the navigator params is what <code>defnavconstructor</code> is for</z><z id="t1465940534" t="nathanmarz I would do that walk-pred example like this: (defnavconstructor walk-pred [p walker] [apred] (p #(and (integer? %) (apred %)))) "><y>#</y><d>2016-06-14</d><h>21:42</h><w>nathanmarz</w>I would do that <code>walk-pred</code> example like this:
<pre>(defnavconstructor walk-pred
  [p walker]
  [apred]
  (p #(and (integer? %) (apred %))))
</pre></z><z id="t1465940592" t="nathanmarz the difference between this definition and one using defpathedfn is the parameter to navconstructor walk-pred can be completely dynamic, and the path can still be factored/cached"><y>#</y><d>2016-06-14</d><h>21:43</h><w>nathanmarz</w>the difference between this definition and one using defpathedfn is the parameter to navconstructor walk-pred can be completely dynamic, and the path can still be factored/cached</z><z id="t1465940933" t="codonnell @nathanmarz: &quot;that itself takes in one or more paths as input&quot; is even in my description (taken from Codox) of defpathedfn . I&apos;ll remove that example and add your modified version in the to-be written defnavconstructor . I wasn&apos;t sure of the purpose of defnavconstructor , but your example makes it clearer."><y>#</y><d>2016-06-14</d><h>21:48</h><w>codonnell</w>@nathanmarz: &quot;that itself takes in one or more paths as input&quot; is even in my description (taken from Codox) of <code>defpathedfn</code>. I&apos;ll remove that example and add your modified version in the to-be written <code>defnavconstructor</code>. I wasn&apos;t sure of the purpose of <code>defnavconstructor</code>, but your example makes it clearer.</z><z id="t1465940945" t="codonnell Why is transformed not implemented using defnavconstructor ?"><y>#</y><d>2016-06-14</d><h>21:49</h><w>codonnell</w>Why is <code>transformed</code> not implemented using <code>defnavconstructor</code>?</z><z id="t1465941021" t="nathanmarz because it takes in a path"><y>#</y><d>2016-06-14</d><h>21:50</h><w>nathanmarz</w>because it takes in a path</z><z id="t1465941063" t="nathanmarz navconstructor can only parameterize an existing navigator (either defined via defnav or comp-paths ), it can&apos;t handle threading params into a nested path"><y>#</y><d>2016-06-14</d><h>21:51</h><w>nathanmarz</w>navconstructor can only parameterize an existing navigator (either defined via <code>defnav</code> or <code>comp-paths</code>), it can&apos;t handle threading params into a nested path</z><z id="t1465941258" t="nathanmarz have you read this post? https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs"><y>#</y><d>2016-06-14</d><h>21:54</h><w>nathanmarz</w>have you read this post? <a href="https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs" target="_blank">https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs</a></z><z id="t1465941404" t="codonnell I did, but I should definitely take a second look now that I have a better understanding of how specter operates."><y>#</y><d>2016-06-14</d><h>21:56</h><w>codonnell</w>I did, but I should definitely take a second look now that I have a better understanding of how specter operates.</z><z id="t1465941431" t="nathanmarz yea, understanding the mechanics of factoring is the key to understanding these different macros"><y>#</y><d>2016-06-14</d><h>21:57</h><w>nathanmarz</w>yea, understanding the mechanics of factoring is the key to understanding these different macros</z><z id="t1465941461" t="nathanmarz it all comes down to the fact that to precompile something you need a completely static path"><y>#</y><d>2016-06-14</d><h>21:57</h><w>nathanmarz</w>it all comes down to the fact that to precompile something you need a completely static path</z><z id="t1465941490" t="nathanmarz specter&apos;s trick of threading parameters later using an array leads to all these different mechanisms for parameterization"><y>#</y><d>2016-06-14</d><h>21:58</h><w>nathanmarz</w>specter&apos;s trick of threading parameters later using an array leads to all these different mechanisms for parameterization</z><z id="t1465941591" t="codonnell Thanks for the suggestion. I&apos;ll read through it more carefully before proceeding further with the macro stuff."><y>#</y><d>2016-06-14</d><h>21:59</h><w>codonnell</w>Thanks for the suggestion. I&apos;ll read through it more carefully before proceeding further with the macro stuff.</z><z id="t1465941609" t="nathanmarz sure thing, happy to answer more questions as they arise"><y>#</y><d>2016-06-14</d><h>22:00</h><w>nathanmarz</w>sure thing, happy to answer more questions as they arise</z><z id="t1465941648" t="codonnell appreciate that"><y>#</y><d>2016-06-14</d><h>22:00</h><w>codonnell</w>appreciate that</z><z id="t1465941721" t="nathanmarz the actual code that does the factoring may be helpful as well: https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L1385"><y>#</y><d>2016-06-14</d><h>22:02</h><w>nathanmarz</w>the actual code that does the factoring may be helpful as well: <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L1385" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L1385</a></z><z id="t1465941785" t="codonnell &quot;magic-precompilation&quot; lol"><y>#</y><d>2016-06-14</d><h>22:03</h><w>codonnell</w>&quot;magic-precompilation&quot; lol</z><z id="t1465941986" t="codonnell Yeah, this post makes a lot more sense now I&apos;m more familiar."><y>#</y><d>2016-06-14</d><h>22:06</h><w>codonnell</w>Yeah, this post makes a lot more sense now I&apos;m more familiar.</z><z id="t1465941987" t="nathanmarz a reflection of my surprise when I first wrote this that this was actually possible 🙂"><y>#</y><d>2016-06-14</d><h>22:06</h><w>nathanmarz</w>a reflection of my surprise when I first wrote this that this was actually possible <b>🙂</b></z><z id="t1465943319" t="codonnell @nathanmarz: Just to confirm. magic-precompilation returns the pair of precompiled path and function which sets the late-bound params mentioned in your post, right?"><y>#</y><d>2016-06-14</d><h>22:28</h><w>codonnell</w>@nathanmarz: Just to confirm. <code>magic-precompilation</code> returns the pair of precompiled path and function which sets the late-bound params mentioned in your post, right?</z><z id="t1465943745" t="nathanmarz @codonnell: yes, though to be completely precise the function returns an array of late-bound params"><y>#</y><d>2016-06-14</d><h>22:35</h><w>nathanmarz</w>@codonnell: yes, though to be completely precise the function returns an array of late-bound params</z><z id="t1465947017" t="mac Is there a way of passing a vector of paths to multi-path?"><y>#</y><d>2016-06-14</d><h>23:30</h><w>mac</w>Is there a way of passing a vector of paths to multi-path?</z><z id="t1465947213" t="mac Or an alternative way of atomically transforming several paths using transform or setval?"><y>#</y><d>2016-06-14</d><h>23:33</h><w>mac</w>Or an alternative way of  atomically transforming several paths using transform or setval?</z><z id="t1465947251" t="nathanmarz you can call (apply multi-path my-paths)"><y>#</y><d>2016-06-14</d><h>23:34</h><w>nathanmarz</w>you can call <code>(apply multi-path my-paths)</code></z><z id="t1465947268" t="nathanmarz though if you want that to inline factor you should wrap it in this: (defpathedfn multi-path* [paths] (apply multi-path paths)) "><y>#</y><d>2016-06-14</d><h>23:34</h><w>nathanmarz</w>though if you want that to inline factor you should wrap it in this:
<pre>(defpathedfn multi-path* [paths]
  (apply multi-path paths))
</pre></z><z id="t1465947293" t="mac Oh, I thought multi-path was a macro?"><y>#</y><d>2016-06-14</d><h>23:34</h><w>mac</w>Oh, I thought multi-path was a macro?</z><z id="t1465947297" t="nathanmarz actually nvm, it won&apos;t be possible to inline factor that anyway"><y>#</y><d>2016-06-14</d><h>23:34</h><w>nathanmarz</w>actually nvm, it won&apos;t be possible to inline factor that anyway</z><z id="t1465947308" t="nathanmarz no it&apos;s a regular function"><y>#</y><d>2016-06-14</d><h>23:35</h><w>nathanmarz</w>no it&apos;s a regular function</z><z id="t1465947326" t="nathanmarz hence the fn in defpathedfn"><y>#</y><d>2016-06-14</d><h>23:35</h><w>nathanmarz</w>hence the <code>fn</code> in <code>defpathedfn</code></z><z id="t1465947341" t="mac Ah silly me, it is just defined by a macor"><y>#</y><d>2016-06-14</d><h>23:35</h><w>mac</w>Ah silly me, it is just defined by a macor</z><z id="t1465947343" t="mac macro"><y>#</y><d>2016-06-14</d><h>23:35</h><w>mac</w>macro</z><z id="t1465956282" t="conaw Putting up another puzzle, this one relating to filters or conditionals Given a vector of maps If the values of a key in the map is a) A map that has a key of tempid return just the tempid if the value of a key is a set, list, or vector that contains maps with key of tempid then replace each of those maps with their temp id example [{:a &quot;foo&quot;, :b &quot;bar&quot;, :c [{:this &quot;other thing&quot;, :that {:nested :map, :deeper #{{:in :we-go, :tempid -1}}, :tempid -2}, :tempid -3}], :tempid -4} {:this &quot;other thing&quot;, :that {:nested :map, :deeper #{{:in :we-go, :tempid -1}}, :tempid -2}, :tempid -3} {:nested :map, :deeper #{{:in :we-go, :tempid -1}}, :tempid -2} {:in :we-go, :tempid -1}] would become [{:a “foo” :b “bar” :c [-3] :tempid -4} {:this “other thing” :that -2 :tempid -3} {:nested :map :deeper #{-1} :tempid -2} {:in :we-go :tempid -1}] "><y>#</y><d>2016-06-15</d><h>02:04</h><w>conaw</w>Putting up another puzzle, this one relating to filters or conditionals

<pre>Given a vector of maps
If the values of a key in the map is

a)    A map that has a key of tempid

return just the tempid

if the value of a key is a set, list, or vector  that contains maps with key of tempid
then replace each of those maps with their temp id

example 

[{:a &quot;foo&quot;,
  :b &quot;bar&quot;,
  :c
  [{:this &quot;other thing&quot;,
    :that
    {:nested :map, :deeper #{{:in :we-go, :tempid -1}}, :tempid -2},
    :tempid -3}],
  :tempid -4}
 {:this &quot;other thing&quot;,
  :that {:nested :map, :deeper #{{:in :we-go, :tempid -1}}, :tempid -2},
  :tempid -3}
 {:nested :map, :deeper #{{:in :we-go, :tempid -1}}, :tempid -2}
 {:in :we-go, :tempid -1}]


would become
[{:a “foo” :b “bar” :c [-3] :tempid -4}
  {:this “other thing” :that -2 :tempid -3} 
  {:nested :map :deeper #{-1} :tempid -2}
  {:in :we-go :tempid -1}]
</pre></z><z id="t1465956631" t="conaw right now I have this, for the simpler case of just nested maps (transform [ALL MAP-VALS (sp/pred :tempid) (collect-one :tempid)] (fn [v _] v)) "><y>#</y><d>2016-06-15</d><h>02:10</h><w>conaw</w>right now I have this, for the simpler case of just nested maps <pre>(transform [ALL MAP-VALS (sp/pred :tempid) (collect-one :tempid)]
          (fn [v _] v)) </pre></z><z id="t1465956661" t="nathanmarz what would that transform to?"><y>#</y><d>2016-06-15</d><h>02:11</h><w>nathanmarz</w>what would that transform to?</z><z id="t1465956872" t="conaw the transform I have works fine, but doesn’t handle the case when I have a map inside a seq"><y>#</y><d>2016-06-15</d><h>02:14</h><w>conaw</w>the transform I have works fine, but doesn’t handle the case when I have a map inside a seq</z><z id="t1465956946" t="conaw basically I want to find a way to conditionally insert and ALL between MAP-VALS and (pred :tempid)"><y>#</y><d>2016-06-15</d><h>02:15</h><w>conaw</w>basically I want to find a way to conditionally insert and ALL between MAP-VALS and (pred :tempid)</z><z id="t1465957394" t="nathanmarz i don&apos;t understand"><y>#</y><d>2016-06-15</d><h>02:23</h><w>nathanmarz</w>i don&apos;t understand</z><z id="t1465957404" t="nathanmarz you said when a map has a :tempid to replace it with the :tempid value"><y>#</y><d>2016-06-15</d><h>02:23</h><w>nathanmarz</w>you said when a map has a :tempid to replace it with the :tempid value</z><z id="t1465957413" t="nathanmarz that would make that example transform to [-4 -3 -2 -1]"><y>#</y><d>2016-06-15</d><h>02:23</h><w>nathanmarz</w>that would make that example transform to [-4 -3 -2 -1]</z><z id="t1465957524" t="nathanmarz @conaw: or does that only happen after the first level of maps?"><y>#</y><d>2016-06-15</d><h>02:25</h><w>nathanmarz</w>@conaw: or does that only happen after the first level of maps?</z><z id="t1465957609" t="conaw only happens after first level"><y>#</y><d>2016-06-15</d><h>02:26</h><w>conaw</w>only happens after first level</z><z id="t1465957627" t="conaw yeah, that’s why its ALL MAP-VALS"><y>#</y><d>2016-06-15</d><h>02:27</h><w>conaw</w>yeah, that’s why its ALL MAP-VALS</z><z id="t1465957636" t="nathanmarz ah"><y>#</y><d>2016-06-15</d><h>02:27</h><w>nathanmarz</w>ah</z><z id="t1465957637" t="conaw (transform [ALL MAP-VALS] #((if (and (map? %) #(:tempid %))) (:tempid %) (if (seq %) (keep :tempid %) %)) sampmap2)"><y>#</y><d>2016-06-15</d><h>02:27</h><w>conaw</w>(transform [ALL MAP-VALS]  
           #((if (and (map? %) #(:tempid %)))
             (:tempid %)
             (if (seq %)
               (keep :tempid %)
               %))
           sampmap2)</z><z id="t1465957639" t="nathanmarz got it"><y>#</y><d>2016-06-15</d><h>02:27</h><w>nathanmarz</w>got it</z><z id="t1465957660" t="nathanmarz easy enough"><y>#</y><d>2016-06-15</d><h>02:27</h><w>nathanmarz</w>easy enough</z><z id="t1465957665" t="nathanmarz (transform [ALL MAP-VALS ConawWalker (pred :tempid)] :tempid data)"><y>#</y><d>2016-06-15</d><h>02:27</h><w>nathanmarz</w><code>(transform [ALL MAP-VALS ConawWalker (pred :tempid)] :tempid data)</code></z><z id="t1465957675" t="nathanmarz I&apos;ll let you figure out ConawWalker"><y>#</y><d>2016-06-15</d><h>02:27</h><w>nathanmarz</w>I&apos;ll let you figure out <code>ConawWalker</code></z><z id="t1465957678" t="conaw lol"><y>#</y><d>2016-06-15</d><h>02:27</h><w>conaw</w>lol</z><z id="t1465957681" t="conaw love it"><y>#</y><d>2016-06-15</d><h>02:28</h><w>conaw</w>love it</z><z id="t1465957719" t="conaw the question is, inside ConawWalker, am I using filterer or just a normal checking"><y>#</y><d>2016-06-15</d><h>02:28</h><w>conaw</w>the question is, inside ConawWalker, am I using filterer or just a normal checking</z><z id="t1465957754" t="nathanmarz the solution I have uses cond-path"><y>#</y><d>2016-06-15</d><h>02:29</h><w>nathanmarz</w>the solution I have uses <code>cond-path</code></z><z id="t1465957778" t="nathanmarz and it&apos;s recursive obviously"><y>#</y><d>2016-06-15</d><h>02:29</h><w>nathanmarz</w>and it&apos;s recursive obviously</z><z id="t1465957791" t="conaw hm, in this case I don’t actually need recursion"><y>#</y><d>2016-06-15</d><h>02:29</h><w>conaw</w>hm, in this case I don’t actually need recursion</z><z id="t1465957803" t="conaw well, maybe I do"><y>#</y><d>2016-06-15</d><h>02:30</h><w>conaw</w>well, maybe I do</z><z id="t1465957830" t="nathanmarz yea you do"><y>#</y><d>2016-06-15</d><h>02:30</h><w>nathanmarz</w>yea you do</z><z id="t1465957831" t="conaw but I’ve already flattened the tree out so that I only want to do my replacing at one level of depth in"><y>#</y><d>2016-06-15</d><h>02:30</h><w>conaw</w>but I’ve already flattened the tree out so that I only want to do my replacing at one level of depth in</z><z id="t1465957846" t="nathanmarz not in that example"><y>#</y><d>2016-06-15</d><h>02:30</h><w>nathanmarz</w>not in that example</z><z id="t1465957865" t="nathanmarz :tempid all over the place"><y>#</y><d>2016-06-15</d><h>02:31</h><w>nathanmarz</w>:tempid all over the place</z><z id="t1465957948" t="conaw the example came about this way (def sampmap2 [{:a &quot;foo&quot; :b &quot;bar&quot; :c [{:this &quot;other thing&quot; :that {:nested :map :deeper [{:in :we-go}]}}]}]) (declarepath TOPSORT3) (providepath TOPSORT3 (sp/cond-path map? (stay-then-continue [MAP-VALS TOPSORT3]) vector? [ALL TOPSORT3])) (select TOPSORT3 sampmap2) (defn nested-&gt;ds [mapvec] (-&gt;&gt; mapvec (transform [(subselect TOPSORT3 :tempid) (sp/view count)] #(range (- %) 0)) (select TOPSORT3) (transform [ALL MAP-VALS (sp/pred :tempid) (collect-one :tempid)] (fn [v _] v)))) "><y>#</y><d>2016-06-15</d><h>02:32</h><w>conaw</w>the example came about this way <pre>(def sampmap2
  [{:a &quot;foo&quot;
    :b &quot;bar&quot;
    :c [{:this &quot;other thing&quot;
         :that {:nested :map
                :deeper [{:in :we-go}]}}]}])

(declarepath TOPSORT3)
(providepath TOPSORT3
             (sp/cond-path
              map?
               (stay-then-continue
                [MAP-VALS TOPSORT3])
              vector?
                [ALL TOPSORT3]))


(select TOPSORT3 sampmap2)


(defn nested-&gt;ds [mapvec]
 (-&gt;&gt; mapvec
  (transform [(subselect TOPSORT3 :tempid) (sp/view count)]
           #(range (- %) 0))
  (select TOPSORT3)
  (transform [ALL MAP-VALS (sp/pred :tempid) (collect-one :tempid)]
          (fn [v _] v))))
</pre></z><z id="t1465958012" t="conaw so, I’ve got each of my nodes already pulled out and selected using a recursive cond-path"><y>#</y><d>2016-06-15</d><h>02:33</h><w>conaw</w>so, I’ve got each of my nodes already pulled out and selected using a recursive cond-path</z><z id="t1465958089" t="conaw nvm, let me think on this, I think I mostly have ConawWalker with TOP-SORT3"><y>#</y><d>2016-06-15</d><h>02:34</h><w>conaw</w>nvm, let me think on this, I think I mostly have ConawWalker with TOP-SORT3</z><z id="t1465958107" t="nathanmarz yea it&apos;s close"><y>#</y><d>2016-06-15</d><h>02:35</h><w>nathanmarz</w>yea it&apos;s close</z><z id="t1465958236" t="nathanmarz by the way you can write TOPSORT3 more concisely"><y>#</y><d>2016-06-15</d><h>02:37</h><w>nathanmarz</w>by the way you can write TOPSORT3 more concisely</z><z id="t1465958270" t="conaw yeah?"><y>#</y><d>2016-06-15</d><h>02:37</h><w>conaw</w>yeah?</z><z id="t1465958332" t="nathanmarz this should be equivalent (declarepath TOPSORT3) (providepath TOPSORT3 [(cond-path map? (stay-then-continue MAP-VALS) vector? ALL) TOPSORT3]) "><y>#</y><d>2016-06-15</d><h>02:38</h><w>nathanmarz</w>this should be equivalent
<pre>(declarepath TOPSORT3)
(providepath TOPSORT3
   [(cond-path
     map? (stay-then-continue MAP-VALS)
     vector? ALL)
    TOPSORT3])
</pre></z><z id="t1465958348" t="conaw aha"><y>#</y><d>2016-06-15</d><h>02:39</h><w>conaw</w>aha</z><z id="t1465958609" t="nathanmarz oh nvm, those are not equivalent"><y>#</y><d>2016-06-15</d><h>02:43</h><w>nathanmarz</w>oh nvm, those are not equivalent</z><z id="t1465958640" t="nathanmarz that would stack overflow"><y>#</y><d>2016-06-15</d><h>02:44</h><w>nathanmarz</w>that would stack overflow</z><z id="t1465958708" t="conaw Why is that?"><y>#</y><d>2016-06-15</d><h>02:45</h><w>conaw</w>Why is that?</z><z id="t1465958724" t="conaw would cease to be tail recursive?"><y>#</y><d>2016-06-15</d><h>02:45</h><w>conaw</w>would cease to be tail recursive?</z><z id="t1465958766" t="nathanmarz when it&apos;s on a map, it will first stay"><y>#</y><d>2016-06-15</d><h>02:46</h><w>nathanmarz</w>when it&apos;s on a map, it will first stay</z><z id="t1465958770" t="nathanmarz then execute TOPSORT3 again"><y>#</y><d>2016-06-15</d><h>02:46</h><w>nathanmarz</w>then execute TOPSORT3 again</z><z id="t1465958780" t="nathanmarz then stay, then TOPSORT3, etc."><y>#</y><d>2016-06-15</d><h>02:46</h><w>nathanmarz</w>then stay, then TOPSORT3, etc.</z><z id="t1465958806" t="nathanmarz with yours it stays, does whatever is after TOPSORT3, then continues recursing on the map vals"><y>#</y><d>2016-06-15</d><h>02:46</h><w>nathanmarz</w>with yours it stays, does whatever is after TOPSORT3, then continues recursing on the map vals</z><z id="t1465958869" t="nathanmarz anyway, i gotta run"><y>#</y><d>2016-06-15</d><h>02:47</h><w>nathanmarz</w>anyway, i gotta run</z><z id="t1465958882" t="conaw cool, thanks for help"><y>#</y><d>2016-06-15</d><h>02:48</h><w>conaw</w>cool, thanks for help</z><z id="t1465958892" t="conaw last q"><y>#</y><d>2016-06-15</d><h>02:48</h><w>conaw</w>last q</z><z id="t1465958902" t="conaw #(:a %)"><y>#</y><d>2016-06-15</d><h>02:48</h><w>conaw</w>#(:a %)</z><z id="t1465958904" t="nathanmarz here&apos;s a gist with the solution if you can&apos;t figure it out https://gist.github.com/nathanmarz/16481b3b4578ed446453bd828335eedb"><y>#</y><d>2016-06-15</d><h>02:48</h><w>nathanmarz</w>here&apos;s a gist with the solution if you can&apos;t figure it out <a href="https://gist.github.com/nathanmarz/16481b3b4578ed446453bd828335eedb" target="_blank">https://gist.github.com/nathanmarz/16481b3b4578ed446453bd828335eedb</a></z><z id="t1465958924" t="conaw best way to only navigate to maps with key of a without traversing into a?"><y>#</y><d>2016-06-15</d><h>02:48</h><w>conaw</w>best way to only navigate to maps with key of a without traversing into a?</z><z id="t1465958930" t="conaw is that"><y>#</y><d>2016-06-15</d><h>02:48</h><w>conaw</w>is that</z><z id="t1465958932" t="conaw right?"><y>#</y><d>2016-06-15</d><h>02:48</h><w>conaw</w>right?</z><z id="t1465958961" t="conaw and best way of doing all except would be #(not (:a %))"><y>#</y><d>2016-06-15</d><h>02:49</h><w>conaw</w>and best way of doing all except would be #(not (:a %))</z><z id="t1465958964" t="nathanmarz that&apos;s the same as saying (pred :a)"><y>#</y><d>2016-06-15</d><h>02:49</h><w>nathanmarz</w>that&apos;s the same as saying (pred :a)</z><z id="t1465958979" t="nathanmarz but that doesn&apos;t account for key existing with nil or false value"><y>#</y><d>2016-06-15</d><h>02:49</h><w>nathanmarz</w>but that doesn&apos;t account for key existing with nil or false value</z><z id="t1465958994" t="conaw pred does?"><y>#</y><d>2016-06-15</d><h>02:49</h><w>conaw</w>pred does?</z><z id="t1465959006" t="nathanmarz if you want to truly do it based on key existing, use (selected? (must :a)) or (not-selected? (must :a))"><y>#</y><d>2016-06-15</d><h>02:50</h><w>nathanmarz</w>if you want to truly do it based on key existing, use <code>(selected? (must :a))</code> or <code>(not-selected? (must :a))</code></z><z id="t1465959019" t="conaw great"><y>#</y><d>2016-06-15</d><h>02:50</h><w>conaw</w>great</z><z id="t1465959023" t="conaw much appreciated"><y>#</y><d>2016-06-15</d><h>02:50</h><w>conaw</w>much appreciated</z><z id="t1465959032" t="nathanmarz #(:a %) is equivalent to (pred :a)"><y>#</y><d>2016-06-15</d><h>02:50</h><w>nathanmarz</w><code>#(:a %)</code> is equivalent to <code>(pred :a)</code></z><z id="t1465959039" t="conaw cool"><y>#</y><d>2016-06-15</d><h>02:50</h><w>conaw</w>cool</z><z id="t1465999015" t="codonnell @nathanmarz: Made a few updates to https://github.com/codonnell/specter/wiki/List-of-Macros after rereading your post and looking through magic-precompilation and magic-precompilation* . I&apos;m just missing examples for path , and I&apos;m not clear yet on the difference between comp-paths and path . Can path not return a ParamsNeededPath ?"><y>#</y><d>2016-06-15</d><h>13:56</h><w>codonnell</w>@nathanmarz: Made a few updates to <a href="https://github.com/codonnell/specter/wiki/List-of-Macros" target="_blank">https://github.com/codonnell/specter/wiki/List-of-Macros</a> after rereading your post and looking through <code>magic-precompilation</code> and <code>magic-precompilation*</code>. I&apos;m just missing examples for <code>path</code>, and I&apos;m not clear yet on the difference between <code>comp-paths</code> and <code>path</code>. Can <code>path</code> not return a <code>ParamsNeededPath</code>?</z><z id="t1465999053" t="codonnell On a side note, there&apos;s a typo at https://github.com/nathanmarz/specter/blob/0.11.2/src/clj/com/rpl/specter/impl.cljx#L1150 (s/consructor/constructor)"><y>#</y><d>2016-06-15</d><h>13:57</h><w>codonnell</w>On a side note, there&apos;s a typo at <a href="https://github.com/nathanmarz/specter/blob/0.11.2/src/clj/com/rpl/specter/impl.cljx#L1150" target="_blank">https://github.com/nathanmarz/specter/blob/0.11.2/src/clj/com/rpl/specter/impl.cljx#L1150</a> (s/consructor/constructor)</z><z id="t1466001342" t="nathanmarz @codonnell: path is basically comp-paths plus inline factoring and caching"><y>#</y><d>2016-06-15</d><h>14:35</h><w>nathanmarz</w>@codonnell: <code>path</code> is basically <code>comp-paths</code> plus inline factoring and caching</z><z id="t1466001487" t="nathanmarz You could use path on its own like this: (defn user-path [u] (path ALL (selected? :id #(= u %)))) "><y>#</y><d>2016-06-15</d><h>14:38</h><w>nathanmarz</w>You could use <code>path</code> on its own like this:
<pre>(defn user-path [u]
  (path ALL (selected? :id #(= u %))))
</pre></z><z id="t1466001527" t="nathanmarz user-path will use inline caching + factoring and efficiently return a path to that particular user"><y>#</y><d>2016-06-15</d><h>14:38</h><w>nathanmarz</w><code>user-path</code> will use inline caching + factoring and efficiently return a path to that particular user</z><z id="t1466001558" t="nathanmarz select , transform , etc. all use path"><y>#</y><d>2016-06-15</d><h>14:39</h><w>nathanmarz</w><code>select</code>, <code>transform</code>, etc. all use <code>path</code></z><z id="t1466002400" t="nathanmarz @codonnell: merged the new wiki page in"><y>#</y><d>2016-06-15</d><h>14:53</h><w>nathanmarz</w>@codonnell: merged the new wiki page in</z><z id="t1466002489" t="nathanmarz fyi, there will be a new core operation in 0.12.0 called traverse"><y>#</y><d>2016-06-15</d><h>14:54</h><w>nathanmarz</w>fyi, there will be a new core operation in 0.12.0 called <code>traverse</code></z><z id="t1466007438" t="aengelberg @nathanmarz re: transducers. I agree that the mapcat behavior is the most useful but the name traverse doesn&apos;t seem to imply that behavior."><y>#</y><d>2016-06-15</d><h>16:17</h><w>aengelberg</w>@nathanmarz re: transducers. I agree that the mapcat behavior is the most useful but the name <code>traverse</code> doesn&apos;t seem to imply that behavior.</z><z id="t1466007528" t="aengelberg What&apos;s really happening is you are traversing some path on ALL structures coming on some stream (or collection, etc) then getting all those results. Maybe traverse-all is a more appropriate name?"><y>#</y><d>2016-06-15</d><h>16:18</h><w>aengelberg</w>What&apos;s really happening is you are traversing some path on ALL structures coming on some stream (or collection, etc) then getting all those results. Maybe <code>traverse-all</code> is a more appropriate name?</z><z id="t1466008756" t="nathanmarz @aengelberg: yea, that&apos;s a better name"><y>#</y><d>2016-06-15</d><h>16:39</h><w>nathanmarz</w>@aengelberg: yea, that&apos;s a better name</z><z id="t1466008821" t="aengelberg or go for the pun and call it transverse"><y>#</y><d>2016-06-15</d><h>16:40</h><w>aengelberg</w>or go for the pun and call it <code>transverse</code></z><z id="t1466008845" t="aengelberg 👏 🎉 i&apos;m here all week"><y>#</y><d>2016-06-15</d><h>16:40</h><w>aengelberg</w><b>👏</b> <b>🎉</b> i&apos;m here all week</z><z id="t1466008871" t="nathanmarz lol"><y>#</y><d>2016-06-15</d><h>16:41</h><w>nathanmarz</w>lol</z><z id="t1466012833" t="codonnell @nathanmarz: after creating your user-path function above, I get an error while trying to use it: (select (user-path &quot;chris&quot;) [{:id &quot;nick&quot;} {:id &quot;foo&quot;} {:id &quot;chris&quot;}]) Failed to cache path: Var user-path must be either a parameterized navigator, a higher order pathed constructor function, or a nav consructor "><y>#</y><d>2016-06-15</d><h>17:47</h><w>codonnell</w>@nathanmarz: after creating your <code>user-path</code> function above, I get an error while trying to use it:
<pre>(select (user-path &quot;chris&quot;) [{:id &quot;nick&quot;} {:id &quot;foo&quot;} {:id &quot;chris&quot;}])
Failed to cache path: Var user-path must be either a parameterized navigator, a higher order pathed constructor function, or a nav consructor
</pre></z><z id="t1466012875" t="nathanmarz @codonnell: use compiled-select"><y>#</y><d>2016-06-15</d><h>17:47</h><w>nathanmarz</w>@codonnell: use <code>compiled-select</code></z><z id="t1466012934" t="codonnell alright, that works"><y>#</y><d>2016-06-15</d><h>17:48</h><w>codonnell</w>alright, that works</z><z id="t1466012968" t="nathanmarz yea, I only gave that as an example of using path on its own"><y>#</y><d>2016-06-15</d><h>17:49</h><w>nathanmarz</w>yea, I only gave that as an example of using <code>path</code> on its own</z><z id="t1466012996" t="nathanmarz but in general, to make a parameterized navigator it&apos;s much better to use comp-paths"><y>#</y><d>2016-06-15</d><h>17:49</h><w>nathanmarz</w>but in general, to make a parameterized navigator it&apos;s much better to use comp-paths</z><z id="t1466013053" t="codonnell and I should use compiled-select with a path I have already compiled with comp-paths ?"><y>#</y><d>2016-06-15</d><h>17:50</h><w>codonnell</w>and I should use <code>compiled-select</code> with a path I have already compiled with <code>comp-paths</code>?</z><z id="t1466013154" t="nathanmarz if you know it&apos;s already compiled then that will be the most efficient"><y>#</y><d>2016-06-15</d><h>17:52</h><w>nathanmarz</w>if you know it&apos;s already compiled then that will be the most efficient</z><z id="t1466013188" t="codonnell Also, if I&apos;m understanding path correctly, it doesn&apos;t take late binding parameters because it needs to cache the code which creates the parameters at compile time. Is that right?"><y>#</y><d>2016-06-15</d><h>17:53</h><w>codonnell</w>Also, if I&apos;m understanding <code>path</code> correctly, it doesn&apos;t take late binding parameters because it needs to cache the code which creates the parameters at compile time. Is that right?</z><z id="t1466013190" t="nathanmarz select* is like compiled-select except it will compile the input path if it&apos;s not already compiled"><y>#</y><d>2016-06-15</d><h>17:53</h><w>nathanmarz</w>select* is like compiled-select except it will compile the input path if it&apos;s not already compiled</z><z id="t1466013219" t="nathanmarz yea path is meant for a fully parameterized path"><y>#</y><d>2016-06-15</d><h>17:53</h><w>nathanmarz</w>yea <code>path</code> is meant for a fully parameterized path</z><z id="t1466013269" t="codonnell So is there any reason to use select over select* ?"><y>#</y><d>2016-06-15</d><h>17:54</h><w>codonnell</w>So is there any reason to use <code>select</code> over <code>select*</code>?</z><z id="t1466013317" t="nathanmarz select* doesn&apos;t do inline caching"><y>#</y><d>2016-06-15</d><h>17:55</h><w>nathanmarz</w>select* doesn&apos;t do inline caching</z><z id="t1466013341" t="codonnell Right, because it&apos;s a function rather than a macro."><y>#</y><d>2016-06-15</d><h>17:55</h><w>codonnell</w>Right, because it&apos;s a function rather than a macro.</z><z id="t1466013356" t="nathanmarz 99.9% of usage should be through the core select , transform , etc. operations"><y>#</y><d>2016-06-15</d><h>17:55</h><w>nathanmarz</w>99.9% of usage should be through the core <code>select</code>, <code>transform</code>, etc. operations</z><z id="t1466013419" t="codonnell Alright, thanks for answering my questions. 👍"><y>#</y><d>2016-06-15</d><h>17:56</h><w>codonnell</w>Alright, thanks for answering my questions. <b>👍</b></z><z id="t1466013448" t="nathanmarz in my own usage I use select/transform/replace-in over 400 times, comp-paths 15 times, and compiled-select/compiled-transform only twice"><y>#</y><d>2016-06-15</d><h>17:57</h><w>nathanmarz</w>in my own usage I use select/transform/replace-in over 400 times, comp-paths 15 times, and compiled-select/compiled-transform only twice</z><z id="t1466016909" t="codonnell @nathanmarz: I added some examples and a longer description for the path macro, as well as some minor formatting changes and a fix for broken links in the list of navigators. Can you think of a situation where it would be prefer able to use path over comp-paths ?"><y>#</y><d>2016-06-15</d><h>18:55</h><w>codonnell</w>@nathanmarz: I added some examples and a longer description for the <code>path</code> macro, as well as some minor formatting changes and a fix for broken links in the list of navigators. Can you think of a situation where it would be prefer able to use <code>path</code> over <code>comp-paths</code>?</z><z id="t1466017478" t="thomasdeutsch Hi everyone. I am stuck with a specter problem i can not get a solution for. I have a simple tree structure as a map and the leaves can be at any level (they are a map with a :template key). I can use a walker to simply find the leaves, but for every leaf, i need the path to that leaf. Is there something like collect-one i can use for this? (def mytree {&quot;e1&quot; {&quot;e2&quot; {&quot;e1&quot; {:template 1} &quot;e2&quot; {:template 2}}}}) (select [(walker #(contains? % :template))] mytree)"><y>#</y><d>2016-06-15</d><h>19:04</h><w>thomasdeutsch</w>Hi everyone. I am stuck with a specter problem i can not get a solution for.     I have a simple tree structure as a map and the leaves can be at any level (they are a map with a :template key).  

 I can use a walker to simply find the leaves, but for every leaf, i need the path to that leaf.   Is there something like collect-one i can use for this?   

<pre>(def mytree {&quot;e1&quot; {&quot;e2&quot; {&quot;e1&quot; {:template 1}
                        &quot;e2&quot; {:template 2}}}})

(select [(walker #(contains? % :template))] mytree)</pre></z><z id="t1466017761" t="codonnell @thomasdeutsch: what would you like to be returned for that data structure?"><y>#</y><d>2016-06-15</d><h>19:09</h><w>codonnell</w>@thomasdeutsch: what would you like to be returned for that data structure?</z><z id="t1466017859" t="thomasdeutsch i would like to return a vector of maps. The maps have templates + a path to that template. Like [{:template 1 :path [&quot;e1 &quot;e2&quot; &quot;e1]} {:template 2 :path [&quot;e1&quot; &quot;e2&quot; &quot;e2]}]"><y>#</y><d>2016-06-15</d><h>19:10</h><w>thomasdeutsch</w>i would like to return a vector of maps. The maps have templates + a path to that template.  Like    <code>[{:template 1 :path [&quot;e1 &quot;e2&quot; &quot;e1]} {:template 2 :path [&quot;e1&quot; &quot;e2&quot; &quot;e2]}]</code></z><z id="t1466017907" t="thomasdeutsch i think i need a transform with a filterer and a second one that will transform a path into the structure?"><y>#</y><d>2016-06-15</d><h>19:11</h><w>thomasdeutsch</w>i think i need a transform with a filterer and a second one that will transform a path into the structure?</z><z id="t1466018135" t="codonnell I think you want a recursive navigator that collects the keys as you go."><y>#</y><d>2016-06-15</d><h>19:15</h><w>codonnell</w>I think you want a recursive navigator that collects the keys as you go.</z><z id="t1466019037" t="codonnell @thomasdeutsch: This is close: (declarepath KeyAccumWalker [k]) (providepath KeyAccumWalker (if-path must STAY [ALL (collect-one FIRST) LAST (params-reset KeyAccumWalker)])) (select (KeyAccumWalker :template) mytree) "><y>#</y><d>2016-06-15</d><h>19:30</h><w>codonnell</w>@thomasdeutsch: This is close:
<pre>(declarepath KeyAccumWalker [k])
(providepath KeyAccumWalker (if-path must STAY [ALL (collect-one FIRST) LAST (params-reset KeyAccumWalker)]))
(select (KeyAccumWalker :template) mytree)
</pre></z><z id="t1466019194" t="thomasdeutsch i have to say, i do not understand if-path must STAY ... but this is a great place to start from...."><y>#</y><d>2016-06-15</d><h>19:33</h><w>thomasdeutsch</w>i have to say, i do not understand if-path must STAY ...   but this is a great place to start from....</z><z id="t1466019205" t="thomasdeutsch Thank you"><y>#</y><d>2016-06-15</d><h>19:33</h><w>thomasdeutsch</w>Thank you</z><z id="t1466019226" t="codonnell @thomasdeutsch: must has an implicit late-bound parameter, which is the key :template"><y>#</y><d>2016-06-15</d><h>19:33</h><w>codonnell</w>@thomasdeutsch: <code>must</code> has an implicit late-bound parameter, which is the key :template</z><z id="t1466019234" t="mfikes @nathanmarz: Do you develop on Linux? (If so, wanted to let you know that we now have an alpha of Planck that runs on Linux. It can successfully load Specter from its JAR and evaluate things. Figure that might help if you ever want to check some behavior related to bootstrap ClojureScript.)"><y>#</y><d>2016-06-15</d><h>19:33</h><w>mfikes</w>@nathanmarz: Do you develop on Linux? (If so, wanted to let you know that we now have an alpha of Planck that runs on Linux. It can successfully load Specter from its JAR and evaluate things. Figure that might help if you ever want to check some behavior related to bootstrap ClojureScript.)</z><z id="t1466019249" t="codonnell so what&apos;s really going on there is more like (if-path (must :template) STAY ...)"><y>#</y><d>2016-06-15</d><h>19:34</h><w>codonnell</w>so what&apos;s really going on there is more like <code>(if-path (must :template) STAY ...)</code></z><z id="t1466019271" t="thomasdeutsch aaahhhh, ok! got it."><y>#</y><d>2016-06-15</d><h>19:34</h><w>thomasdeutsch</w>aaahhhh, ok! got it.</z><z id="t1466019311" t="codonnell The problem is that as we recursively call KeyAccumWalker the collected values are getting nested instead of concatenated."><y>#</y><d>2016-06-15</d><h>19:35</h><w>codonnell</w>The problem is that as we recursively call <code>KeyAccumWalker</code> the collected values are getting nested instead of concatenated.</z><z id="t1466020123" t="nathanmarz @codonnell @thomasdeutsch value collection + recursion doesn&apos;t work so well in specter at the moment"><y>#</y><d>2016-06-15</d><h>19:48</h><w>nathanmarz</w>@codonnell @thomasdeutsch value collection + recursion doesn&apos;t work so well in specter at the moment</z><z id="t1466020139" t="nathanmarz also https://github.com/nathanmarz/specter/issues/64"><y>#</y><d>2016-06-15</d><h>19:48</h><w>nathanmarz</w>also <a href="https://github.com/nathanmarz/specter/issues/64" target="_blank">https://github.com/nathanmarz/specter/issues/64</a></z><z id="t1466020159" t="thomasdeutsch thanks for the heads up"><y>#</y><d>2016-06-15</d><h>19:49</h><w>thomasdeutsch</w>thanks for the heads up</z><z id="t1466020430" t="nathanmarz @mfikes: I develop on OSX, does it work there as well?"><y>#</y><d>2016-06-15</d><h>19:53</h><w>nathanmarz</w>@mfikes: I develop on OSX, does it work there as well?</z><z id="t1466020456" t="mfikes Oh… definitely. Planck has worked on OS X all along :) brew install planck and you are good to go"><y>#</y><d>2016-06-15</d><h>19:54</h><w>mfikes</w>Oh… definitely. Planck has worked on OS X all along :) <code>brew install planck</code> and you are good to go</z><z id="t1466020735" t="mfikes @nathanmarz: If you ever want to point Planck at your JAR, here’s how: $ planck -qKc target/specter-0.12.0-SNAPSHOT.jar cljs.user=&gt; (require-macros &apos;[com.rpl.specter.macros :refer [transform]]) nil cljs.user=&gt; (require &apos;[com.rpl.specter :refer [ALL]]) nil cljs.user=&gt; (transform [ALL :a even?] inc [{:a 1} {:a 2} {:a 4} {:a 3}]) [{:a 1} {:a 3} {:a 5} {:a 3}] That’s all there is to it. (Note that -K will cause a .planck_cache directory to be written for faster subsequent startups. You can also use -k to write to a specific path, or just leave it off and live with slower require processing.)"><y>#</y><d>2016-06-15</d><h>19:58</h><w>mfikes</w>@nathanmarz: If you ever want to point Planck at your JAR, here’s how:
<pre>$ planck -qKc target/specter-0.12.0-SNAPSHOT.jar
cljs.user=&gt; (require-macros &apos;[com.rpl.specter.macros :refer [transform]])
nil
cljs.user=&gt; (require &apos;[com.rpl.specter :refer [ALL]])
nil
cljs.user=&gt; (transform [ALL :a even?] inc [{:a 1} {:a 2} {:a 4} {:a 3}])
[{:a 1} {:a 3} {:a 5} {:a 3}]
</pre>
That’s all there is to it.
(Note that <code>-K</code> will cause a <code>.planck_cache</code> directory to be written for faster subsequent startups. You can also use <code>-k</code> to write to a specific path, or just leave it off and live with slower <code>require</code> processing.)</z><z id="t1466020761" t="nathanmarz ok cool, I&apos;ll note this down"><y>#</y><d>2016-06-15</d><h>19:59</h><w>nathanmarz</w>ok cool, I&apos;ll note this down</z><z id="t1466020815" t="mfikes Cool. Of course, happy to continue to sort out bootstrap issues if they arise. Just thought you might want to be able to try things yourself if you ever wanted to. 🙂"><y>#</y><d>2016-06-15</d><h>20:00</h><w>mfikes</w>Cool. Of course, happy to continue to sort out bootstrap issues if they arise. Just thought you might want to be able to try things yourself if you ever wanted to. <b>🙂</b></z><z id="t1466020834" t="nathanmarz any leiningen plugin available to be able to do something like &quot;lein planck&quot;?"><y>#</y><d>2016-06-15</d><h>20:00</h><w>nathanmarz</w>any leiningen plugin available to be able to do something like &quot;lein planck&quot;?</z><z id="t1466020855" t="nathanmarz and get a planck repl with the project code + dependencies available"><y>#</y><d>2016-06-15</d><h>20:00</h><w>nathanmarz</w>and get a planck repl with the project code + dependencies available</z><z id="t1466020887" t="mfikes Well, you can essentially do the opposite: planck -c `lein classpath` "><y>#</y><d>2016-06-15</d><h>20:01</h><w>mfikes</w>Well, you can essentially do the opposite: 
<pre>planck -c `lein classpath`
</pre></z><z id="t1466020905" t="nathanmarz ah nice, just as good"><y>#</y><d>2016-06-15</d><h>20:01</h><w>nathanmarz</w>ah nice, just as good</z><z id="t1466020948" t="mfikes There’s also fairly decent docs covering this stuff (that’s covered in the Dependencies section). http://planck-repl.org/guide.html"><y>#</y><d>2016-06-15</d><h>20:02</h><w>mfikes</w>There’s also fairly decent docs covering this stuff (that’s covered in the Dependencies section). <a href="http://planck-repl.org/guide.html" target="_blank">http://planck-repl.org/guide.html</a></z><z id="t1466085631" t="nathanmarz @codonnell @thomasdeutsch that bug you guys ran into yesterday is now fixed in master"><y>#</y><d>2016-06-16</d><h>14:00</h><w>nathanmarz</w>@codonnell @thomasdeutsch that bug you guys ran into yesterday is now fixed in master</z><z id="t1466085700" t="nathanmarz also deployed 0.12.0-SNAPSHOT to clojars if you want to use it"><y>#</y><d>2016-06-16</d><h>14:01</h><w>nathanmarz</w>also deployed 0.12.0-SNAPSHOT to clojars if you want to use it</z><z id="t1466087207" t="aengelberg @nathanmarz I&apos;m curious why select* really needs each navigator to return one of its navigated values as the return value. If you really want select-any , you could traverse with the final continuation being to deliver to a promise (where only the first value matters)."><y>#</y><d>2016-06-16</d><h>14:26</h><w>aengelberg</w>@nathanmarz I&apos;m curious why <code>select*</code> really needs each navigator to return one of its navigated values as the return value. If you really want <code>select-any</code>, you could traverse with the final continuation being to deliver to a promise (where only the first value matters).</z><z id="t1466087723" t="nathanmarz it&apos;s the most efficient way"><y>#</y><d>2016-06-16</d><h>14:35</h><w>nathanmarz</w>it&apos;s the most efficient way</z><z id="t1466087743" t="nathanmarz don&apos;t need to create any anonymous function, don&apos;t need to write anywhere"><y>#</y><d>2016-06-16</d><h>14:35</h><w>nathanmarz</w>don&apos;t need to create any anonymous function, don&apos;t need to write anywhere</z><z id="t1466087799" t="nathanmarz an anonymous function that closes over local environment requires object creation and field setting"><y>#</y><d>2016-06-16</d><h>14:36</h><w>nathanmarz</w>an anonymous function that closes over local environment requires object creation and field setting</z><z id="t1466087829" t="nathanmarz for cases like (select-any [:a :b :c] {:a {:b {:c 1}}}) these things make a noticeable difference"><y>#</y><d>2016-06-16</d><h>14:37</h><w>nathanmarz</w>for cases like <code>(select-any [:a :b :c] {:a {:b {:c 1}}})</code> these things make a noticeable difference</z><z id="t1466106634" t="codonnell @nathanmarz: (reduce afn init (traverse apath structure)) should always return the same thing as (reduce afn init (select apath structure)) , right? But it is more memory efficient because it only store the reduction value, rather than instantiating the entire seq?"><y>#</y><d>2016-06-16</d><h>19:50</h><w>codonnell</w>@nathanmarz: <code>(reduce afn init (traverse apath structure))</code> should always return the same thing as <code>(reduce afn init (select apath structure))</code>, right? But it is more memory efficient because it only store the reduction value, rather than instantiating the entire seq?</z><z id="t1466106829" t="nathanmarz @codonnell: that&apos;s exactly right"><y>#</y><d>2016-06-16</d><h>19:53</h><w>nathanmarz</w>@codonnell: that&apos;s exactly right</z><z id="t1466106889" t="nathanmarz not just memory efficient but also faster"><y>#</y><d>2016-06-16</d><h>19:54</h><w>nathanmarz</w>not just memory efficient but also faster</z><z id="t1466107001" t="nathanmarz also useful if you want something like a set of results back, e.g. (into #{} (traverse ...))"><y>#</y><d>2016-06-16</d><h>19:56</h><w>nathanmarz</w>also useful if you want something like a set of results back, e.g. <code>(into #{} (traverse ...))</code></z><z id="t1466107084" t="codonnell ok great"><y>#</y><d>2016-06-16</d><h>19:58</h><w>codonnell</w>ok great</z><z id="t1466107832" t="codonnell Is collected? the same as pred , but it takes the collected values as input rather than the structure?"><y>#</y><d>2016-06-16</d><h>20:10</h><w>codonnell</w>Is <code>collected?</code> the same as <code>pred</code>, but it takes the collected values as input rather than the structure?</z><z id="t1466107934" t="nathanmarz yes"><y>#</y><d>2016-06-16</d><h>20:12</h><w>nathanmarz</w>yes</z><z id="t1466107975" t="codonnell alright, these new operations should be pretty easy to write up"><y>#</y><d>2016-06-16</d><h>20:12</h><w>codonnell</w>alright, these new operations should be pretty easy to write up</z><z id="t1466112666" t="codonnell I pushed the 0.12.0 macros and navigators up to https://github.com/codonnell/specter/wiki/List-of-Macros . Pretty sure they are accurate."><y>#</y><d>2016-06-16</d><h>21:31</h><w>codonnell</w>I pushed the 0.12.0 macros and navigators up to <a href="https://github.com/codonnell/specter/wiki/List-of-Macros" target="_blank">https://github.com/codonnell/specter/wiki/List-of-Macros</a>. Pretty sure they are accurate.</z><z id="t1466112957" t="codonnell perhaps jumping the gun, but it&apos;s there on my wiki if needed"><y>#</y><d>2016-06-16</d><h>21:35</h><w>codonnell</w>perhaps jumping the gun, but it&apos;s there on my wiki if needed</z><z id="t1466113517" t="nathanmarz great"><y>#</y><d>2016-06-16</d><h>21:45</h><w>nathanmarz</w>great</z><z id="t1466113522" t="nathanmarz added another traverse example and merged in"><y>#</y><d>2016-06-16</d><h>21:45</h><w>nathanmarz</w>added another traverse example and merged in</z><z id="t1466120035" t="luxbock how would I implement REST ? i.e. (select-one REST [1 2 3]) =&gt; [2 3] ?"><y>#</y><d>2016-06-16</d><h>23:33</h><w>luxbock</w>how would I implement <code>REST</code>? i.e. <code>(select-one REST [1 2 3])</code> =&gt; <code>[2 3]</code>?</z><z id="t1466120482" t="luxbock I can use srange but then I need to know the length of the collection in the selector"><y>#</y><d>2016-06-16</d><h>23:41</h><w>luxbock</w>I can use <code>srange</code> but then I need to know the length of the collection in the selector</z><z id="t1466120516" t="luxbock I was trying to figure out how to do it by looking at ALL and FIRST but the code looks so optimized that I can&apos;t really figure out how to write it"><y>#</y><d>2016-06-16</d><h>23:41</h><w>luxbock</w>I was trying to figure out how to do it by looking at <code>ALL</code> and <code>FIRST</code> but the code looks so optimized that I can&apos;t really figure out how to write it</z><z id="t1466120660" t="codonnell @luxbock: you should be able to do it with defnav (see https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav for a similar example)"><y>#</y><d>2016-06-16</d><h>23:44</h><w>codonnell</w>@luxbock: you should be able to do it with <code>defnav</code> (see <a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav</a> for a similar example)</z><z id="t1466120680" t="codonnell I&apos;m not sure if there&apos;s a better way to do it"><y>#</y><d>2016-06-16</d><h>23:44</h><w>codonnell</w>I&apos;m not sure if there&apos;s a better way to do it</z><z id="t1466120749" t="luxbock @codonnell: thanks"><y>#</y><d>2016-06-16</d><h>23:45</h><w>luxbock</w>@codonnell: thanks</z><z id="t1466120788" t="codonnell no problem"><y>#</y><d>2016-06-16</d><h>23:46</h><w>codonnell</w>no problem</z><z id="t1466121010" t="codonnell ooh"><y>#</y><d>2016-06-16</d><h>23:50</h><w>codonnell</w>ooh</z><z id="t1466121068" t="codonnell @luxbock: (select (transformed STAY rest) (range 10))"><y>#</y><d>2016-06-16</d><h>23:51</h><w>codonnell</w>@luxbock: (select (transformed STAY rest) (range 10))</z><z id="t1466121085" t="codonnell no, (select (view rest) (range 10))"><y>#</y><d>2016-06-16</d><h>23:51</h><w>codonnell</w>no, <code>(select (view rest) (range 10))</code></z><z id="t1466121100" t="codonnell pretty sure (view rest) is optimal"><y>#</y><d>2016-06-16</d><h>23:51</h><w>codonnell</w>pretty sure <code>(view rest)</code> is optimal</z><z id="t1466121608" t="codonnell Note that if you&apos;re doing a transform, you&apos;ll lose the first element (transform [(view rest) ALL] inc (range 5)) (2 3 4 5) "><y>#</y><d>2016-06-17</d><h>00:00</h><w>codonnell</w>Note that if you&apos;re doing a transform, you&apos;ll lose the first element
<pre>(transform [(view rest) ALL] inc (range 5))
(2 3 4 5)
</pre></z><z id="t1466121754" t="luxbock yeah I need the first element to stay intact"><y>#</y><d>2016-06-17</d><h>00:02</h><w>luxbock</w>yeah I need the first element to stay intact</z><z id="t1466121757" t="luxbock https://gist.github.com/luxbock/55ea567166081af107fd7a22582bf8c2"><y>#</y><d>2016-06-17</d><h>00:02</h><w>luxbock</w><a href="https://gist.github.com/luxbock/55ea567166081af107fd7a22582bf8c2" target="_blank">https://gist.github.com/luxbock/55ea567166081af107fd7a22582bf8c2</a></z><z id="t1466121763" t="luxbock that was my first try but it doesn&apos;t quite work"><y>#</y><d>2016-06-17</d><h>00:02</h><w>luxbock</w>that was my first try but it doesn&apos;t quite work</z><z id="t1466121855" t="codonnell you don&apos;t need to call nextfn twice in your select"><y>#</y><d>2016-06-17</d><h>00:04</h><w>codonnell</w>you don&apos;t need to call <code>nextfn</code> twice in your select</z><z id="t1466121871" t="luxbock ah whops"><y>#</y><d>2016-06-17</d><h>00:04</h><w>luxbock</w>ah whops</z><z id="t1466121882" t="codonnell you do need it in your transform*, though"><y>#</y><d>2016-06-17</d><h>00:04</h><w>codonnell</w>you do need it in your transform*, though</z><z id="t1466121919" t="luxbock hmm?"><y>#</y><d>2016-06-17</d><h>00:05</h><w>luxbock</w>hmm?</z><z id="t1466121953" t="codonnell transform* also needs to perform nextfn on the passed in structure, and then reconstruct the original structure, replacing what you navigate to with the results of nextfn"><y>#</y><d>2016-06-17</d><h>00:05</h><w>codonnell</w>transform* also needs to perform <code>nextfn</code> on the passed in structure, and then reconstruct the original structure, replacing what you navigate to with the results of <code>nextfn</code></z><z id="t1466122000" t="codonnell for example, the wiki example stores the result of (nextfn (nth structure n)) and then replaces the nth element of structure with it"><y>#</y><d>2016-06-17</d><h>00:06</h><w>codonnell</w>for example, the wiki example stores the result of <code>(nextfn (nth structure n))</code> and then replaces the nth element of <code>structure</code> with it</z><z id="t1466122064" t="luxbock isn&apos;t that what I was doing though?"><y>#</y><d>2016-06-17</d><h>00:07</h><w>luxbock</w>isn&apos;t that what I was doing though?</z></g><g id="s3"><z id="t1466122118" t="codonnell oops"><y>#</y><d>2016-06-17</d><h>00:08</h><w>codonnell</w>oops</z><z id="t1466122122" t="codonnell yep, you&apos;re right"><y>#</y><d>2016-06-17</d><h>00:08</h><w>codonnell</w>yep, you&apos;re right</z><z id="t1466122138" t="luxbock ah, I needed to map next-fn over the (rest coll)"><y>#</y><d>2016-06-17</d><h>00:08</h><w>luxbock</w>ah, I needed to map <code>next-fn</code> over the <code>(rest coll)</code></z><z id="t1466122157" t="luxbock great, now it works"><y>#</y><d>2016-06-17</d><h>00:09</h><w>luxbock</w>great, now it works</z><z id="t1466122229" t="codonnell no, that&apos;s not right"><y>#</y><d>2016-06-17</d><h>00:10</h><w>codonnell</w>no, that&apos;s not right</z><z id="t1466122244" t="codonnell I mean, you could do that if you want, but that&apos;s like doing [REST ALL]"><y>#</y><d>2016-06-17</d><h>00:10</h><w>codonnell</w>I mean, you could do that if you want, but that&apos;s like doing <code>[REST ALL]</code></z><z id="t1466122267" t="luxbock oh right"><y>#</y><d>2016-06-17</d><h>00:11</h><w>luxbock</w>oh right</z><z id="t1466122359" t="luxbock yeah it was correct the firs time, but my own example useage was wrong"><y>#</y><d>2016-06-17</d><h>00:12</h><w>luxbock</w>yeah it was correct the firs time, but my own example useage was wrong</z><z id="t1466122635" t="luxbock I updated the gist so that it now works on sets and maps as well, although obviously you probably wouldn&apos;t want to use it on thsoe"><y>#</y><d>2016-06-17</d><h>00:17</h><w>luxbock</w>I updated the gist so that it now works on sets  and maps as well, although obviously you probably wouldn&apos;t want to use it on thsoe</z><z id="t1466122726" t="luxbock I think it&apos;d be nice to have more selectors that mimic the bahavior of clojure.core functions (`TAKE`, DROP etc.)"><y>#</y><d>2016-06-17</d><h>00:18</h><w>luxbock</w>I think it&apos;d be nice to have more selectors that mimic the bahavior of <code>clojure.core</code> functions (`TAKE`, <code>DROP</code> etc.)</z><z id="t1466122834" t="codonnell I did not know about empty"><y>#</y><d>2016-06-17</d><h>00:20</h><w>codonnell</w>I did not know about <code>empty</code></z><z id="t1466122835" t="codonnell neat"><y>#</y><d>2016-06-17</d><h>00:20</h><w>codonnell</w>neat</z><z id="t1466123084" t="codonnell some of those functions are in the works, I think ( https://github.com/nathanmarz/specter/issues/121 )"><y>#</y><d>2016-06-17</d><h>00:24</h><w>codonnell</w>some of those functions are in the works, I think (<a href="https://github.com/nathanmarz/specter/issues/121" target="_blank">https://github.com/nathanmarz/specter/issues/121</a>)</z><z id="t1466125285" t="luxbock https://gist.github.com/luxbock/4eb81767e6bb1f6169b4fb12ec8b9356"><y>#</y><d>2016-06-17</d><h>01:01</h><w>luxbock</w><a href="https://gist.github.com/luxbock/4eb81767e6bb1f6169b4fb12ec8b9356" target="_blank">https://gist.github.com/luxbock/4eb81767e6bb1f6169b4fb12ec8b9356</a></z><z id="t1466125298" t="luxbock this returns what I want, but I wonder if there&apos;s a way to write it using just one transform"><y>#</y><d>2016-06-17</d><h>01:01</h><w>luxbock</w>this returns what I want, but I wonder if there&apos;s a way to write it using just one <code>transform</code></z><z id="t1466125332" t="luxbock the task is to read :foo and add it to each number of the REST of :bar"><y>#</y><d>2016-06-17</d><h>01:02</h><w>luxbock</w>the task is to read <code>:foo</code> and add it to each number of the <code>REST</code> of <code>:bar</code></z><z id="t1466125372" t="luxbock and then to lift the modified :bar to be the returned value from the outer transform"><y>#</y><d>2016-06-17</d><h>01:02</h><w>luxbock</w>and then to lift the modified <code>:bar</code> to be the returned value from the outer <code>transform</code></z><z id="t1466125855" t="luxbock I think my vanilla Clojure version might be easier to read"><y>#</y><d>2016-06-17</d><h>01:10</h><w>luxbock</w>I think my vanilla Clojure version might be easier to read</z><z id="t1466126077" t="codonnell (transform [ALL (collect-one :foo) :bar REST ALL ALL] + data)"><y>#</y><d>2016-06-17</d><h>01:14</h><w>codonnell</w><code>(transform [ALL (collect-one :foo) :bar REST ALL ALL] + data)</code></z><z id="t1466126093" t="codonnell @luxbock: ^"><y>#</y><d>2016-06-17</d><h>01:14</h><w>codonnell</w>@luxbock: ^</z><z id="t1466126181" t="luxbock @codonnell: yeah that works except for it doesn&apos;t lift :bar up"><y>#</y><d>2016-06-17</d><h>01:16</h><w>luxbock</w>@codonnell: yeah that works except for it doesn&apos;t lift <code>:bar</code> up</z><z id="t1466126224" t="luxbock but maybe (mapv :bar (transform [ALL (collect-one :foo) :bar REST ALL ALL] + data)) is the most readable"><y>#</y><d>2016-06-17</d><h>01:17</h><w>luxbock</w>but maybe <code>(mapv :bar (transform [ALL (collect-one :foo) :bar REST ALL ALL] + data))</code> is the most readable</z><z id="t1466126225" t="codonnell alright, I&apos;ll take a closer look in a bit"><y>#</y><d>2016-06-17</d><h>01:17</h><w>codonnell</w>alright, I&apos;ll take a closer look in a bit</z><z id="t1466126381" t="luxbock I think that using collect-one with transform for the purpose of lifting an inner structure upwards is a bit verbose and doesn&apos;t feel so easily composable"><y>#</y><d>2016-06-17</d><h>01:19</h><w>luxbock</w>I think that using <code>collect-one</code> with <code>transform</code> for the purpose of lifting an inner structure upwards is a bit verbose and doesn&apos;t feel so easily composable</z><z id="t1466126398" t="codonnell (transform [ALL (collect-one :foo) (view :bar) REST ALL ALL] + data)"><y>#</y><d>2016-06-17</d><h>01:19</h><w>codonnell</w><code>(transform [ALL (collect-one :foo) (view :bar) REST ALL ALL] + data)</code></z><z id="t1466126418" t="codonnell that does it, I think"><y>#</y><d>2016-06-17</d><h>01:20</h><w>codonnell</w>that does it, I think</z><z id="t1466126441" t="codonnell as for which is more readable, I&apos;d say that&apos;s a matter of opinion"><y>#</y><d>2016-06-17</d><h>01:20</h><w>codonnell</w>as for which is more readable, I&apos;d say that&apos;s a matter of opinion</z><z id="t1466126441" t="luxbock yep! nice"><y>#</y><d>2016-06-17</d><h>01:20</h><w>luxbock</w>yep! nice</z><z id="t1466126449" t="codonnell probably has a lot to do with how familiar the reader is with specter"><y>#</y><d>2016-06-17</d><h>01:20</h><w>codonnell</w>probably has a lot to do with how familiar the reader is with specter</z><z id="t1466126458" t="luxbock I did learn about view the other day so I should have been able to get that"><y>#</y><d>2016-06-17</d><h>01:20</h><w>luxbock</w>I did learn about <code>view</code> the other day so I should have been able to get that</z><z id="t1466126636" t="codonnell the fact that it&apos;s even possible to accomplish that transformation in one line of code is pretty absurd IMO"><y>#</y><d>2016-06-17</d><h>01:23</h><w>codonnell</w>the fact that it&apos;s even possible to accomplish that transformation in one line of code is pretty absurd IMO</z><z id="t1466126648" t="luxbock yeah definitely"><y>#</y><d>2016-06-17</d><h>01:24</h><w>luxbock</w>yeah definitely</z><z id="t1466126695" t="luxbock if only I could think at the speed at which I can type that 😛"><y>#</y><d>2016-06-17</d><h>01:24</h><w>luxbock</w>if only I could think at the speed at which I can type that <b>😛</b></z><z id="t1466127065" t="luxbock and adding one more level of complexity takes only a small tweak: https://gist.github.com/luxbock/c499f34ffe07c00404da7b2615295057"><y>#</y><d>2016-06-17</d><h>01:31</h><w>luxbock</w>and adding one more level of complexity takes only a small tweak: <a href="https://gist.github.com/luxbock/c499f34ffe07c00404da7b2615295057" target="_blank">https://gist.github.com/luxbock/c499f34ffe07c00404da7b2615295057</a></z><z id="t1466127889" t="codonnell yep, very nice"><y>#</y><d>2016-06-17</d><h>01:44</h><w>codonnell</w>yep, very nice</z><z id="t1466178413" t="rauh @severed-infinity: Def. a Cursive problem, not specter"><y>#</y><d>2016-06-17</d><h>15:46</h><w>rauh</w>@severed-infinity: Def. a Cursive problem, not specter</z><z id="t1466178424" t="rauh You can get rid of almost all warning with the latest EAP version though"><y>#</y><d>2016-06-17</d><h>15:47</h><w>rauh</w>You can get rid of almost all warning with the latest EAP version though</z><z id="t1466178449" t="rauh There you can tell Cursive that a macro is like a def , thus defining the symbols"><y>#</y><d>2016-06-17</d><h>15:47</h><w>rauh</w>There you can tell Cursive that a macro is like a <code>def</code>, thus defining the symbols</z><z id="t1466178465" t="rauh And voila, you&apos;ll have full autocomplete for specter"><y>#</y><d>2016-06-17</d><h>15:47</h><w>rauh</w>And voila, you&apos;ll have full autocomplete for specter</z><z id="t1466178527" t="rauh Simply go into the specter (and macros) source file, hover over a (eg. devnav ) usage and choose Resolve as ... def"><y>#</y><d>2016-06-17</d><h>15:48</h><w>rauh</w>Simply go into the specter (and macros) source file, hover over a (eg. <code>devnav</code>) usage and choose <code>Resolve as ... def</code></z><z id="t1466178549" t="severed-infinity @rauh Ah I am using the latest EAP but did not know about this"><y>#</y><d>2016-06-17</d><h>15:49</h><w>severed-infinity</w>@rauh Ah I am using the latest EAP but did not know about this</z><z id="t1466179082" t="rauh You have to go into the specter source"><y>#</y><d>2016-06-17</d><h>15:58</h><w>rauh</w>You have to go into the specter source</z><z id="t1466179090" t="rauh F12 for me, goto source or someting like that"><y>#</y><d>2016-06-17</d><h>15:58</h><w>rauh</w>F12 for me, <code>goto source</code> or someting like that</z><z id="t1466179115" t="rauh Well, you can&apos;t do that on an unresolved symbol (yet) 🙂"><y>#</y><d>2016-06-17</d><h>15:58</h><w>rauh</w>Well, you can&apos;t do that on an unresolved symbol (yet) <b>🙂</b></z><z id="t1466179138" t="rauh so jump into specter source from maybe your (:require ...)"><y>#</y><d>2016-06-17</d><h>15:58</h><w>rauh</w>so jump into specter source from maybe your <code>(:require ...)</code></z><z id="t1466258449" t="luxbock how would I write a selector that stops further navigation if the value it points to matches a predicate?"><y>#</y><d>2016-06-18</d><h>14:00</h><w>luxbock</w>how would I write a selector that stops further navigation if the value it points to matches a predicate?</z><z id="t1466258624" t="luxbock probably something with if-path , let&apos;s see"><y>#</y><d>2016-06-18</d><h>14:03</h><w>luxbock</w>probably something with <code>if-path</code>, let&apos;s see</z><z id="t1466260340" t="nathanmarz @luxbock: try not-selected?"><y>#</y><d>2016-06-18</d><h>14:32</h><w>nathanmarz</w>@luxbock: try <code>not-selected?</code></z><z id="t1466260826" t="luxbock @nathanmarz: thanks, yeah I think that would have solved my toy example, but I ended up writing a custom function for what I&apos;m attempting to do"><y>#</y><d>2016-06-18</d><h>14:40</h><w>luxbock</w>@nathanmarz: thanks, yeah I think that would have solved my toy example, but I ended up writing a custom function for what I&apos;m attempting to do</z><z id="t1466260857" t="luxbock https://gist.github.com/luxbock/fda8f2ee4e642903d532d1b34db902e5"><y>#</y><d>2016-06-18</d><h>14:40</h><w>luxbock</w><a href="https://gist.github.com/luxbock/fda8f2ee4e642903d532d1b34db902e5" target="_blank">https://gist.github.com/luxbock/fda8f2ee4e642903d532d1b34db902e5</a></z><z id="t1466260868" t="luxbock maybe it&apos;s possible to do it with specter as well"><y>#</y><d>2016-06-18</d><h>14:41</h><w>luxbock</w>maybe it&apos;s possible to do it with specter as well</z><z id="t1466327031" t="thomasdeutsch what would be the specter version of this: (map #(+ %1 %2) [1 2 3] [2 3 4]) ?"><y>#</y><d>2016-06-19</d><h>09:03</h><w>thomasdeutsch</w>what would be the specter version of this:   <code>(map #(+ %1 %2) [1 2 3] [2 3 4])</code> ?</z><z id="t1466330122" t="nathanmarz @thomasdeutsch there isn&apos;t"><y>#</y><d>2016-06-19</d><h>09:55</h><w>nathanmarz</w>@thomasdeutsch there isn&apos;t</z><z id="t1466546028" t="josh.freckleton @nathanmarz: Thanks for inviting me to specter , I think it&apos;s brilliant to have this sort of DSL for navigation, and I&apos;m excited for this lib to transform my workflow! In our conversation yesterday (on #C03S1KBA2) I was talking about needing to post-order traverse a tree. I think I can see how I&apos;d piece that together using specter , but I see talk toward the end of the readme about navigating graphs. What is the best practice if I wanted to post-order traverse a tree?"><y>#</y><d>2016-06-21</d><h>21:53</h><w>josh.freckleton</w>@nathanmarz: Thanks for inviting me to <code>specter</code>, I think it&apos;s brilliant to have this sort of DSL for navigation, and I&apos;m excited for this lib to transform my workflow!

In our conversation yesterday (on #C03S1KBA2) I was talking about needing to post-order traverse a tree. I think I can see how I&apos;d piece that together using <code>specter</code>, but I see talk toward the end of the <code>readme</code> about navigating graphs. What is the best practice if I wanted to post-order traverse a tree?</z><z id="t1466546048" t="lellis Hello guys! I made a sort using sorted-map-by then i use into these specter: (transform (walker (fn [v] (and (keyword? v)))) #(keyword (clojure.string/replace (subs (str %) 1) &quot;/&quot; &quot;_&quot;)) sorted-map) But because inner specter use walker and walker says &quot;Note: &quot;walk&quot; supports all Clojure data structures EXCEPT maps created with sorted-map-by. There is no (obvious) way to retrieve the sorting function.&quot; Is there another way to do that with specter?"><y>#</y><d>2016-06-21</d><h>21:54</h><w>lellis</w>Hello guys! I made a sort using sorted-map-by then i use into these specter:
<pre>(transform (walker (fn [v] (and (keyword? v)))) #(keyword (clojure.string/replace (subs (str %) 1) &quot;/&quot; &quot;_&quot;)) sorted-map)</pre>

But because inner specter use walker and walker says &quot;Note: &quot;walk&quot; supports all Clojure data structures EXCEPT maps
created with sorted-map-by.  There is no (obvious) way to retrieve
the sorting function.&quot; Is there another way to do that with specter?</z><z id="t1466546247" t="lellis Or is better make my sort without sorted-map-by?"><y>#</y><d>2016-06-21</d><h>21:57</h><w>lellis</w>Or is better  make my sort without sorted-map-by?</z><z id="t1466546971" t="nathanmarz @josh.freckleton: do you mean best practice if you wanted to post-order traverse a graph?"><y>#</y><d>2016-06-21</d><h>22:09</h><w>nathanmarz</w>@josh.freckleton: do you mean best practice if you wanted to post-order traverse a graph?</z><z id="t1466547006" t="josh.freckleton @nathanmarz: yes, that would be awesome! I don&apos;t quite get recursion, or ordering yet in specter"><y>#</y><d>2016-06-21</d><h>22:10</h><w>josh.freckleton</w>@nathanmarz: yes, that would be awesome! I don&apos;t quite get recursion, or ordering yet in <code>specter</code></z><z id="t1466547034" t="nathanmarz so internally I have a bunch of navigators built on top of loom"><y>#</y><d>2016-06-21</d><h>22:10</h><w>nathanmarz</w>so internally I have a bunch of navigators built on top of loom</z><z id="t1466547045" t="nathanmarz https://github.com/aysylu/loom"><y>#</y><d>2016-06-21</d><h>22:10</h><w>nathanmarz</w><a href="https://github.com/aysylu/loom" target="_blank">https://github.com/aysylu/loom</a></z><z id="t1466547109" t="nathanmarz so I can do things like (transform [REVERSE-TOPSORT ...] ...)"><y>#</y><d>2016-06-21</d><h>22:11</h><w>nathanmarz</w>so I can do things like <code>(transform [REVERSE-TOPSORT ...] ...)</code></z><z id="t1466547125" t="nathanmarz where reverse-topsort navigates to pairs of [graph, node-id] in reverse topological order"><y>#</y><d>2016-06-21</d><h>22:12</h><w>nathanmarz</w>where reverse-topsort navigates to pairs of <code>[graph, node-id]</code> in reverse topological order</z><z id="t1466547169" t="nathanmarz at the end of my clojure/west talk I showed a complete example of my specter/loom integration"><y>#</y><d>2016-06-21</d><h>22:12</h><w>nathanmarz</w>at the end of my clojure/west talk I showed a complete example of my specter/loom integration</z><z id="t1466547188" t="nathanmarz trying to encourage someone from the community to build an open-source version"><y>#</y><d>2016-06-21</d><h>22:13</h><w>nathanmarz</w>trying to encourage someone from the community to build an open-source version</z><z id="t1466547278" t="aengelberg That&apos;s odd that clojure.walk/walk claims to not work with sorted-map-by . I just tried it in the REPL and it seems to work fine."><y>#</y><d>2016-06-21</d><h>22:14</h><w>aengelberg</w>That&apos;s odd that <code>clojure.walk/walk</code> claims to not work with <code>sorted-map-by</code>. I just tried it in the REPL and it seems to work fine.</z><z id="t1466547510" t="nathanmarz hmm, didn&apos;t even know about sorted-map-by"><y>#</y><d>2016-06-21</d><h>22:18</h><w>nathanmarz</w>hmm, didn&apos;t even know about <code>sorted-map-by</code></z><z id="t1466547524" t="nathanmarz looks like ALL and MAP-VALS are broken with that, but walker does seem to work"><y>#</y><d>2016-06-21</d><h>22:18</h><w>nathanmarz</w>looks like <code>ALL</code> and <code>MAP-VALS</code> are broken with that, but <code>walker</code> does seem to work</z><z id="t1466548712" t="nathanmarz that bug is fixed for next release https://github.com/nathanmarz/specter/commit/9ff9ef6650d3faab5421dd6452a716421a81554f"><y>#</y><d>2016-06-21</d><h>22:38</h><w>nathanmarz</w>that bug is fixed for next release <a href="https://github.com/nathanmarz/specter/commit/9ff9ef6650d3faab5421dd6452a716421a81554f" target="_blank">https://github.com/nathanmarz/specter/commit/9ff9ef6650d3faab5421dd6452a716421a81554f</a></z><z id="t1466549207" t="josh.freckleton @nathanmarz: ah, it wasn&apos;t clear you were using loom at the end of that talk. Fantastic talk though! Would you by chance have a gist I could study?"><y>#</y><d>2016-06-21</d><h>22:46</h><w>josh.freckleton</w>@nathanmarz: ah, it wasn&apos;t clear you were using <code>loom</code> at the end of that talk. Fantastic talk though! Would you by chance have a <code>gist</code> I could study?</z><z id="t1466549702" t="aengelberg Do priority maps work with ALL ?"><y>#</y><d>2016-06-21</d><h>22:55</h><w>aengelberg</w>Do priority maps work with <code>ALL</code>?</z><z id="t1466552228" t="lellis I make some code for example: (def demo-map {:a &quot;baa&quot; :b &quot;aab&quot;}) (def demo-map-sorted-by-value (into (sorted-map-by (fn [key1 key2] (compare [(get demo-map key1) key1] [(get demo-map key2) key2]))) demo-map)) (def result (transform (walker (fn [v] (and (keyword? v)))) #(keyword (clojure.string/replace (subs (str %) 1) &quot;a&quot; &quot;c&quot;)) demo-map-sorted-by-value)) demo-map =&gt; {:a &quot;baa&quot;, :b &quot;aab&quot;} demo-map-sorted-by-value =&gt; {:b &quot;aab&quot;, :a &quot;baa&quot;} result =&gt; {:c &quot;baa&quot;, :b &quot;aab”} The question is: Why i lost my sort by value?"><y>#</y><d>2016-06-21</d><h>23:37</h><w>lellis</w>I make some code for example: 
<pre>(def demo-map {:a &quot;baa&quot; :b &quot;aab&quot;})

(def demo-map-sorted-by-value (into (sorted-map-by (fn [key1 key2]
                                                     (compare
                                                       [(get demo-map key1) key1]
                                                       [(get demo-map key2) key2]))) demo-map))

(def result (transform (walker (fn [v] (and (keyword? v)))) #(keyword (clojure.string/replace (subs (str %) 1) &quot;a&quot; &quot;c&quot;)) demo-map-sorted-by-value))

demo-map =&gt; {:a &quot;baa&quot;, :b &quot;aab&quot;}
demo-map-sorted-by-value =&gt; {:b &quot;aab&quot;, :a &quot;baa&quot;}
result =&gt; {:c &quot;baa&quot;, :b &quot;aab”}

</pre>
The question is: Why i lost my sort by value?</z><z id="t1466552450" t="codonnell @lellis: that should be fixed in master with https://github.com/nathanmarz/specter/commit/9ff9ef6650d3faab5421dd6452a716421a81554f"><y>#</y><d>2016-06-21</d><h>23:40</h><w>codonnell</w>@lellis: that should be fixed in master with <a href="https://github.com/nathanmarz/specter/commit/9ff9ef6650d3faab5421dd6452a716421a81554f" target="_blank">https://github.com/nathanmarz/specter/commit/9ff9ef6650d3faab5421dd6452a716421a81554f</a></z><z id="t1466557309" t="nathanmarz @lellis: Your compare function compares with the values inside demo-map"><y>#</y><d>2016-06-22</d><h>01:01</h><w>nathanmarz</w>@lellis: Your compare function compares with the values inside <code>demo-map</code></z><z id="t1466557324" t="nathanmarz so you&apos;re comparing [nil :c] vs. [&quot;aab&quot; :b]"><y>#</y><d>2016-06-22</d><h>01:02</h><w>nathanmarz</w>so you&apos;re comparing [nil :c] vs.  [&quot;aab&quot; :b]</z><z id="t1466557333" t="nathanmarz the maps themselves have the correct comparison function"><y>#</y><d>2016-06-22</d><h>01:02</h><w>nathanmarz</w>the maps themselves have the correct comparison function</z><z id="t1466557352" t="nathanmarz user=&gt; (identical? (.comparator result) (.comparator demo-map-sorted-by-value)) true "><y>#</y><d>2016-06-22</d><h>01:02</h><w>nathanmarz</w><pre>user=&gt; (identical? (.comparator result) (.comparator demo-map-sorted-by-value))
true
</pre></z><z id="t1466557476" t="nathanmarz @aengelberg: which priority map?"><y>#</y><d>2016-06-22</d><h>01:04</h><w>nathanmarz</w>@aengelberg: which priority map?</z><z id="t1466557541" t="nathanmarz maps other than clojure&apos;s persistent types will run the Object case of all-transform protocol (which is the former implementation of ALL )"><y>#</y><d>2016-06-22</d><h>01:05</h><w>nathanmarz</w>maps other than clojure&apos;s persistent types will run the <code>Object</code> case of <code>all-transform</code> protocol (which is the former implementation of <code>ALL</code>)</z><z id="t1466557600" t="nathanmarz @josh.freckleton: Nothing besides what I showed in that talk: https://github.com/nathanmarz/specter-clojure-west/blob/master/src/specter_demo/examples.clj#L466"><y>#</y><d>2016-06-22</d><h>01:06</h><w>nathanmarz</w>@josh.freckleton: Nothing besides what I showed in that talk: <a href="https://github.com/nathanmarz/specter-clojure-west/blob/master/src/specter_demo/examples.clj#L466" target="_blank">https://github.com/nathanmarz/specter-clojure-west/blob/master/src/specter_demo/examples.clj#L466</a></z><z id="t1466557644" t="nathanmarz I work with DAGs so my operators are specific to those"><y>#</y><d>2016-06-22</d><h>01:07</h><w>nathanmarz</w>I work with DAGs so my operators are specific to those</z><z id="t1466557675" t="aengelberg External library. clojure.data.priority-map"><y>#</y><d>2016-06-22</d><h>01:07</h><w>aengelberg</w>External library. clojure.data.priority-map</z><z id="t1466557758" t="nathanmarz PARENTS , CHILDREN , TOPSORT , NODE , and then a bunch of different ways to navigate to &quot;subgraphs&quot;"><y>#</y><d>2016-06-22</d><h>01:09</h><w>nathanmarz</w><code>PARENTS</code>, <code>CHILDREN</code>, <code>TOPSORT</code>, <code>NODE</code>, and then a bunch of different ways to navigate to &quot;subgraphs&quot;</z><z id="t1466557816" t="nathanmarz subgraph navigators are similar in concept to subset and submap , and metadata on the transformed subgraph indicates how to re-attach the edges that were formerly to the prior subgraph"><y>#</y><d>2016-06-22</d><h>01:10</h><w>nathanmarz</w>subgraph navigators are similar in concept to <code>subset</code> and <code>submap</code>, and metadata on the transformed subgraph indicates how to re-attach the edges that were formerly to the prior subgraph</z><z id="t1466557830" t="nathanmarz @aengelberg: if it correctly implements empty I imagine it should work"><y>#</y><d>2016-06-22</d><h>01:10</h><w>nathanmarz</w>@aengelberg: if it correctly implements <code>empty</code> I imagine it should work</z><z id="t1466557881" t="nathanmarz and IKVReduce"><y>#</y><d>2016-06-22</d><h>01:11</h><w>nathanmarz</w>and <code>IKVReduce</code></z><z id="t1466557900" t="nathanmarz wouldn&apos;t be as fast as the other ones though since the default handler does a bunch of other checks beforehand"><y>#</y><d>2016-06-22</d><h>01:11</h><w>nathanmarz</w>wouldn&apos;t be as fast as the other ones though since the default handler does a bunch of other checks beforehand</z><z id="t1466592840" t="odinodin Is is possible to remove nodes from a tree structure with specter? I can only manage to replace nodes with nil"><y>#</y><d>2016-06-22</d><h>10:54</h><w>odinodin</w>Is is possible to remove nodes from a tree structure with specter? I can only manage to replace nodes with nil</z><z id="t1466594142" t="nathanmarz @odinodin: how are you representing your tree?"><y>#</y><d>2016-06-22</d><h>11:15</h><w>nathanmarz</w>@odinodin: how are you representing your tree?</z><z id="t1466594521" t="odinodin (def all-pages {:pages {:page-id &quot;home&quot;, :options &apos;({:page-id &quot;other_inq&quot;} {:page-id &quot;other_inq&quot;, :access #{&quot;employee&quot;}})}}) (defn only-authorized [pages access] (-&gt;&gt; pages (transform* [(walker #(and (map? %) (contains? % :access)))] (fn [page] (when (-&gt; page :access (some access)) page))))) "><y>#</y><d>2016-06-22</d><h>11:22</h><w>odinodin</w><pre>(def all-pages
  {:pages {:page-id &quot;home&quot;,
           :options &apos;({:page-id &quot;other_inq&quot;}
                      {:page-id &quot;other_inq&quot;,
                       :access #{&quot;employee&quot;}})}})

(defn only-authorized [pages access]
  (-&gt;&gt; pages
       (transform*
         [(walker #(and (map? %) (contains? % :access)))]
         (fn [page] (when (-&gt; page :access (some access)) page)))))
</pre></z><z id="t1466594546" t="odinodin only-authorized returns {:pages {:page-id &quot;home&quot;, :options ({:page-id &quot;other_inq&quot;} nil)}} "><y>#</y><d>2016-06-22</d><h>11:22</h><w>odinodin</w>only-authorized returns
 <pre>{:pages {:page-id &quot;home&quot;, :options ({:page-id &quot;other_inq&quot;} nil)}} </pre></z><z id="t1466594587" t="odinodin my current fix for removing the nil is : (defn only-authorized [pages access] (-&gt;&gt; pages (transform* [(walker #(and (map? %) (contains? % :access)))] (fn [page] (when (-&gt; page :access (some access)) page))) (transform* [(walker #(and (map? %) (contains? % :options)))] (fn [x] (update x :options (partial remove nil?)))))) "><y>#</y><d>2016-06-22</d><h>11:23</h><w>odinodin</w>my current fix for removing the nil is : 
<pre>(defn only-authorized [pages access]
  (-&gt;&gt; pages
       (transform*
         [(walker #(and (map? %) (contains? % :access)))]
         (fn [page] (when (-&gt; page :access (some access)) page)))
       (transform*
           [(walker #(and (map? %) (contains? % :options)))]
           (fn [x] (update x :options (partial remove nil?))))))
</pre></z><z id="t1466594729" t="nathanmarz well you definitely can&apos;t do it with walker"><y>#</y><d>2016-06-22</d><h>11:25</h><w>nathanmarz</w>well you definitely can&apos;t do it with <code>walker</code></z><z id="t1466594780" t="nathanmarz if you make your own recursive path there&apos;s a variety of ways of doing it"><y>#</y><d>2016-06-22</d><h>11:26</h><w>nathanmarz</w>if you make your own recursive path there&apos;s a variety of ways of doing it</z><z id="t1466594949" t="odinodin I saw the next version of specter has a NONE value, what if I could return NONE instead of nil in the transform-function?"><y>#</y><d>2016-06-22</d><h>11:29</h><w>odinodin</w>I saw the next version of specter has a NONE value, what if I could return NONE instead of nil in the transform-function?</z><z id="t1466595119" t="nathanmarz @odinodin: I&apos;ll show you how to do it"><y>#</y><d>2016-06-22</d><h>11:31</h><w>nathanmarz</w>@odinodin: I&apos;ll show you how to do it</z><z id="t1466595130" t="nathanmarz @odinodin: not yet decided whether that feature idea will become reality"><y>#</y><d>2016-06-22</d><h>11:32</h><w>nathanmarz</w>@odinodin: not yet decided whether that feature idea will become reality</z><z id="t1466595145" t="nathanmarz your data structure also isn&apos;t recursive"><y>#</y><d>2016-06-22</d><h>11:32</h><w>nathanmarz</w>your data structure also isn&apos;t recursive</z><z id="t1466595162" t="odinodin it is, just simplified the example"><y>#</y><d>2016-06-22</d><h>11:32</h><w>odinodin</w>it is, just simplified the example</z><z id="t1466595176" t="nathanmarz this example isn&apos;t recursive so it&apos;s hard to show you what to do"><y>#</y><d>2016-06-22</d><h>11:32</h><w>nathanmarz</w>this example isn&apos;t recursive so it&apos;s hard to show you what to do</z><z id="t1466595223" t="nathanmarz i think if you change :options to :pages its recursive"><y>#</y><d>2016-06-22</d><h>11:33</h><w>nathanmarz</w>i think if you change :options to :pages its recursive</z><z id="t1466595281" t="odinodin (def all-pages {:pages {:page-id &quot;home&quot;, :options &apos;({:page-id &quot;a&quot; :options ({:page-id &quot;c&quot;, :access #{&quot;external&quot;}})} {:page-id &quot;b&quot;, :access #{&quot;employee&quot;}})}}) "><y>#</y><d>2016-06-22</d><h>11:34</h><w>odinodin</w><pre>(def all-pages
  {:pages {:page-id &quot;home&quot;,
           :options &apos;({:page-id &quot;a&quot; :options ({:page-id &quot;c&quot;, :access #{&quot;external&quot;}})}
                       {:page-id &quot;b&quot;, :access #{&quot;employee&quot;}})}})
</pre></z><z id="t1466595484" t="nathanmarz @odinodin: (def all-pages {:page-id &quot;root&quot; :pages [{:page-id &quot;other-page&quot;, :pages &apos;({:page-id &quot;other_inq&quot;} {:page-id &quot;other_inq&quot;, :access #{&quot;employee&quot;}})}] }) (declarepath NODES) (providepath NODES (stay-then-continue (must :pages) ALL NODES )) (setval [NODES (must :pages) (continuous-subseqs :access) ] [] all-pages ) "><y>#</y><d>2016-06-22</d><h>11:38</h><w>nathanmarz</w>@odinodin: 
<pre>(def all-pages
  {:page-id &quot;root&quot;
   :pages [{:page-id &quot;other-page&quot;,
            :pages &apos;({:page-id &quot;other_inq&quot;}
                     {:page-id &quot;other_inq&quot;,
                      :access #{&quot;employee&quot;}})}]
          })

(declarepath NODES)

(providepath NODES
  (stay-then-continue
    (must :pages) ALL NODES
    ))


(setval
  [NODES
   (must :pages)
   (continuous-subseqs :access)
   ]
  []
  all-pages
  )
</pre></z><z id="t1466595489" t="nathanmarz that&apos;s one way to do it"><y>#</y><d>2016-06-22</d><h>11:38</h><w>nathanmarz</w>that&apos;s one way to do it</z><z id="t1466595510" t="odinodin sweet, thanks 🙂"><y>#</y><d>2016-06-22</d><h>11:38</h><w>odinodin</w>sweet, thanks <b>🙂</b></z><z id="t1466595522" t="nathanmarz modified the example data to be recursive in structure"><y>#</y><d>2016-06-22</d><h>11:38</h><w>nathanmarz</w>modified the example data to be recursive in structure</z><z id="t1466595569" t="odinodin specter is really awesome, thanks for making it 🙂"><y>#</y><d>2016-06-22</d><h>11:39</h><w>odinodin</w>specter is really awesome, thanks for making it <b>🙂</b></z><z id="t1466595711" t="nathanmarz enjoy 🙂"><y>#</y><d>2016-06-22</d><h>11:41</h><w>nathanmarz</w>enjoy <b>🙂</b></z><z id="t1466611438" t="luxbock (transform [(collect MAP-VALS) MAP-VALS] (fn [vs n] (/ n (apply + vs))) (frequencies [1 1 2 2 2 3 4 4 4]))"><y>#</y><d>2016-06-22</d><h>16:03</h><w>luxbock</w><code>(transform [(collect MAP-VALS) MAP-VALS] (fn [vs n] (/ n (apply + vs))) (frequencies [1 1 2 2 2 3 4 4 4]))</code></z><z id="t1466611490" t="luxbock is there any way to avoid calculating the sum of the values for every individual value as I&apos;m doing there?"><y>#</y><d>2016-06-22</d><h>16:04</h><w>luxbock</w>is there any way to avoid calculating the sum of the values for every individual value as I&apos;m doing there?</z><z id="t1466611523" t="luxbock a specter way of doing that I mean"><y>#</y><d>2016-06-22</d><h>16:05</h><w>luxbock</w>a specter way of doing that I mean</z><z id="t1466611935" t="nathanmarz @luxbock: like this? (transform [(collect-one (view count)) (view frequencies) MAP-VALS] (fn [s n] (/ n s)) [1 1 2 2 2 3 4 4 4] ) "><y>#</y><d>2016-06-22</d><h>16:12</h><w>nathanmarz</w>@luxbock: like this?
<pre>(transform [(collect-one (view count)) (view frequencies) MAP-VALS]
  (fn [s n] (/ n s))
  [1 1 2 2 2 3 4 4 4]
  )
</pre></z><z id="t1466612089" t="luxbock ah very nice"><y>#</y><d>2016-06-22</d><h>16:14</h><w>luxbock</w>ah very nice</z><z id="t1466613458" t="luxbock (transform [ALL (view :foo) #(&gt; % 2)] str [{:foo 1} {:foo 2} {:foo 3} {:foo 4}]) ;; =&gt; [1 2 &quot;3&quot; &quot;4&quot;] "><y>#</y><d>2016-06-22</d><h>16:37</h><w>luxbock</w><pre>(transform [ALL (view :foo) #(&gt; % 2)]
  str
  [{:foo 1} {:foo 2} {:foo 3} {:foo 4}])
;; =&gt; [1 2 &quot;3&quot; &quot;4&quot;]
</pre></z><z id="t1466613477" t="luxbock how would I do this but only get [&quot;3&quot; &quot;4&quot;] back?"><y>#</y><d>2016-06-22</d><h>16:37</h><w>luxbock</w>how would I do this but only get <code>[&quot;3&quot; &quot;4&quot;]</code> back?</z><z id="t1466614425" t="nathanmarz @luxbock: (select [ALL :foo #(&gt; % 2) (view str)] [{:foo 1} {:foo 2} {:foo 3} {:foo 4}])"><y>#</y><d>2016-06-22</d><h>16:53</h><w>nathanmarz</w>@luxbock: <code>(select [ALL :foo #(&gt; % 2) (view str)] [{:foo 1} {:foo 2} {:foo 3} {:foo 4}])</code></z><z id="t1466614998" t="luxbock @nathanmarz: in my case :foo is actually a function that retrieves the value from deeper in the map, which is why I used view with it"><y>#</y><d>2016-06-22</d><h>17:03</h><w>luxbock</w>@nathanmarz:  in my case <code>:foo</code> is actually a function that retrieves the value from deeper in the map, which is why I used <code>view</code> with it</z><z id="t1466615072" t="luxbock ah, but it looks like it actually works if I just wrap it in view and then use select"><y>#</y><d>2016-06-22</d><h>17:04</h><w>luxbock</w>ah, but it looks like it actually works if I just wrap it in <code>view</code> and then use <code>select</code></z><z id="t1466615073" t="luxbock great"><y>#</y><d>2016-06-22</d><h>17:04</h><w>luxbock</w>great</z><z id="t1466642141" t="aengelberg @nathanmarz just saw your post about multi-transform , looks interesting. Have you considered adding a terminal-val which sets the value instead of transforms it (like setval is to transform )?"><y>#</y><d>2016-06-23</d><h>00:35</h><w>aengelberg</w>@nathanmarz just saw your post about <code>multi-transform</code>, looks interesting. Have you considered adding a <code>terminal-val</code> which sets the value instead of transforms it (like <code>setval</code> is to <code>transform</code>)?</z><z id="t1466643224" t="nathanmarz @aengelberg: good idea, i&apos;ll add that to the branch"><y>#</y><d>2016-06-23</d><h>00:53</h><w>nathanmarz</w>@aengelberg: good idea, i&apos;ll add that to the branch</z><z id="t1466643661" t="nathanmarz @aengelberg: https://github.com/nathanmarz/specter/commit/50d2aa48f57df75b8395950ac0511f63849da400"><y>#</y><d>2016-06-23</d><h>01:01</h><w>nathanmarz</w>@aengelberg: <a href="https://github.com/nathanmarz/specter/commit/50d2aa48f57df75b8395950ac0511f63849da400" target="_blank">https://github.com/nathanmarz/specter/commit/50d2aa48f57df75b8395950ac0511f63849da400</a></z><z id="t1466643785" t="aengelberg just realized that setval does not work with collect... is this a bug? boot.user=&gt; (setval [:a (collect STAY)] 2 {:a 1}) clojure.lang.ArityException: Wrong number of args (2) passed to: impl/compiled-setval*/fn--2959 "><y>#</y><d>2016-06-23</d><h>01:03</h><w>aengelberg</w>just realized that setval does not work with collect... is this a bug?
<pre>boot.user=&gt; (setval [:a (collect STAY)] 2 {:a 1})

clojure.lang.ArityException: Wrong number of args (2) passed to: impl/compiled-setval*/fn--2959
</pre></z><z id="t1466643816" t="aengelberg I was about to say, why not switch constantly to (fn [_] val) like setval uses, for efficiency..."><y>#</y><d>2016-06-23</d><h>01:03</h><w>aengelberg</w>I was about to say, why not switch <code>constantly</code> to <code>(fn [_] val)</code> like setval uses, for efficiency...</z><z id="t1466643883" t="nathanmarz ah, just looked at the implementation of constantly"><y>#</y><d>2016-06-23</d><h>01:04</h><w>nathanmarz</w>ah, just looked at the implementation of <code>constantly</code></z><z id="t1466643896" t="nathanmarz but yea that&apos;s a bug"><y>#</y><d>2016-06-23</d><h>01:04</h><w>nathanmarz</w>but yea that&apos;s a bug</z><z id="t1466643919" t="nathanmarz though it&apos;s a weird bug to hit"><y>#</y><d>2016-06-23</d><h>01:05</h><w>nathanmarz</w>though it&apos;s a weird bug to hit</z><z id="t1466644231" t="aengelberg user&gt; (let [f (constantly 1)] (dotimes [i 5] (time (dotimes [i 10000000] (f 2))))) &quot;Elapsed time: 178.060125 msecs&quot; &quot;Elapsed time: 164.164117 msecs&quot; &quot;Elapsed time: 170.549443 msecs&quot; &quot;Elapsed time: 165.947481 msecs&quot; &quot;Elapsed time: 163.606619 msecs&quot; nil user&gt; (let [f (fn [_] 1)] (dotimes [i 5] (time (dotimes [i 10000000] (f 2))))) &quot;Elapsed time: 55.36876 msecs&quot; &quot;Elapsed time: 47.140944 msecs&quot; &quot;Elapsed time: 46.974314 msecs&quot; &quot;Elapsed time: 46.51298 msecs&quot; &quot;Elapsed time: 44.286403 msecs&quot; nil user&gt; (let [f (fn [_ &amp; _] 1)] (dotimes [i 5] (time (dotimes [i 10000000] (f 2))))) &quot;Elapsed time: 86.562498 msecs&quot; &quot;Elapsed time: 89.103274 msecs&quot; &quot;Elapsed time: 86.074677 msecs&quot; &quot;Elapsed time: 87.669437 msecs&quot; &quot;Elapsed time: 89.690679 msecs&quot; nil (edited with more accurate benchmark)"><y>#</y><d>2016-06-23</d><h>01:10</h><w>aengelberg</w><pre>user&gt; (let [f (constantly 1)] (dotimes [i 5] (time (dotimes [i 10000000] (f 2)))))
&quot;Elapsed time: 178.060125 msecs&quot;
&quot;Elapsed time: 164.164117 msecs&quot;
&quot;Elapsed time: 170.549443 msecs&quot;
&quot;Elapsed time: 165.947481 msecs&quot;
&quot;Elapsed time: 163.606619 msecs&quot;
nil
user&gt; (let [f (fn [_] 1)] (dotimes [i 5] (time (dotimes [i 10000000] (f 2)))))
&quot;Elapsed time: 55.36876 msecs&quot;
&quot;Elapsed time: 47.140944 msecs&quot;
&quot;Elapsed time: 46.974314 msecs&quot;
&quot;Elapsed time: 46.51298 msecs&quot;
&quot;Elapsed time: 44.286403 msecs&quot;
nil
user&gt; (let [f (fn [_ &amp; _] 1)] (dotimes [i 5] (time (dotimes [i 10000000] (f 2)))))
&quot;Elapsed time: 86.562498 msecs&quot;
&quot;Elapsed time: 89.103274 msecs&quot;
&quot;Elapsed time: 86.074677 msecs&quot;
&quot;Elapsed time: 87.669437 msecs&quot;
&quot;Elapsed time: 89.690679 msecs&quot;
nil
</pre>
(edited with more accurate benchmark)</z><z id="t1466644318" t="aengelberg There&apos;s a spectrum"><y>#</y><d>2016-06-23</d><h>01:11</h><w>aengelberg</w>There&apos;s a spectrum</z><z id="t1466644977" t="nathanmarz hand-rolled a fast-constantly and also fixed that bug"><y>#</y><d>2016-06-23</d><h>01:22</h><w>nathanmarz</w>hand-rolled a <code>fast-constantly</code> and also fixed that bug</z><z id="t1466670469" t="luxbock are (transform [&lt;selector&gt; (view f)] identity coll) and (transform &lt;selector&gt; f coll) interchangeable? is the latter going to be faster?"><y>#</y><d>2016-06-23</d><h>08:27</h><w>luxbock</w>are <code>(transform [&lt;selector&gt; (view f)] identity coll)</code> and <code>(transform &lt;selector&gt; f coll)</code> interchangeable? is the latter going to be faster?</z><z id="t1466670688" t="luxbock using specter feels a bit like concatenative programming to me"><y>#</y><d>2016-06-23</d><h>08:31</h><w>luxbock</w>using <code>specter</code> feels a bit like concatenative programming to me</z><z id="t1466670705" t="luxbock I wonder if there are some ideas there that could be applicable"><y>#</y><d>2016-06-23</d><h>08:31</h><w>luxbock</w>I wonder if there are some ideas there that could be applicable</z><z id="t1466670858" t="luxbock you could think of VAL as an analog of dup and the discussed OMIT as being drop"><y>#</y><d>2016-06-23</d><h>08:34</h><w>luxbock</w>you could think of <code>VAL</code> as an analog of <code>dup</code> and the discussed <code>OMIT</code> as being <code>drop</code></z><z id="t1466670934" t="luxbock concatenative languages can be extremely expressive and allow for easy meta-programming"><y>#</y><d>2016-06-23</d><h>08:35</h><w>luxbock</w>concatenative languages can be extremely expressive and allow for easy meta-programming</z><z id="t1466673131" t="luxbock I played around with combining this idea with destructuring: https://gist.github.com/luxbock/f93529b82792ef35db12fcf5e5a78fdb"><y>#</y><d>2016-06-23</d><h>09:12</h><w>luxbock</w>I played around with combining this idea with destructuring: <a href="https://gist.github.com/luxbock/f93529b82792ef35db12fcf5e5a78fdb" target="_blank">https://gist.github.com/luxbock/f93529b82792ef35db12fcf5e5a78fdb</a></z><z id="t1466689955" t="nathanmarz @luxbock: they are not interchangeable as f in the latter form will receive collected values while f in the former will not"><y>#</y><d>2016-06-23</d><h>13:52</h><w>nathanmarz</w>@luxbock: they are not interchangeable as <code>f</code> in the latter form will receive collected values while <code>f</code> in the former will not</z><z id="t1466689960" t="nathanmarz the latter will also be faster"><y>#</y><d>2016-06-23</d><h>13:52</h><w>nathanmarz</w>the latter will also be faster</z><z id="t1466690431" t="nathanmarz @luxbock: interesting ideas, but can&apos;t the starting example be written as this? (transform [MAP-VALS (view frequencies) (collect-one (subselect MAP-VALS) (view #(apply max %))) MAP-VALS] (fn [mx e] (/ e mx)) {:a [1 1 3 4] :b [1 1 2 2 2 3]}) "><y>#</y><d>2016-06-23</d><h>14:00</h><w>nathanmarz</w>@luxbock: interesting ideas, but can&apos;t the starting example be written as this?
<pre>(transform
  [MAP-VALS
   (view frequencies)
   (collect-one (subselect MAP-VALS) (view #(apply max %)))
   MAP-VALS]
  (fn [mx e] (/ e mx))
  {:a [1 1 3 4] :b [1 1 2 2 2 3]})
</pre></z><z id="t1466691168" t="luxbock yes you are correct, my specter-fu is still far from perfect 🙂"><y>#</y><d>2016-06-23</d><h>14:12</h><w>luxbock</w>yes you are correct, my specter-fu is still far from perfect <b>🙂</b></z><z id="t1466693161" t="nathanmarz you&apos;ll get there 🙂"><y>#</y><d>2016-06-23</d><h>14:46</h><w>nathanmarz</w>you&apos;ll get there <b>🙂</b></z><z id="t1466693172" t="nathanmarz just realized it can be made even more concise: (transform [MAP-VALS (view frequencies) (subselect MAP-VALS) (collect-one (view #(apply max %))) ALL] (fn [mx e] (/ e mx)) {:a [1 1 3 4] :b [1 1 2 2 2 3]}) "><y>#</y><d>2016-06-23</d><h>14:46</h><w>nathanmarz</w>just realized it can be made even more concise:
<pre>(transform
  [MAP-VALS
   (view frequencies)
   (subselect MAP-VALS)
   (collect-one (view #(apply max %)))
   ALL]
  (fn [mx e] (/ e mx))
  {:a [1 1 3 4] :b [1 1 2 2 2 3]})
</pre></z><z id="t1466693206" t="luxbock nice"><y>#</y><d>2016-06-23</d><h>14:46</h><w>luxbock</w>nice</z><z id="t1466694011" t="luxbock if I wanted to do the same thing, but wanted to inc all the numbers before using frequencies and the rest of the selectors, can I somehow fit that into the selector?"><y>#</y><d>2016-06-23</d><h>15:00</h><w>luxbock</w>if I wanted to do the same thing, but wanted to <code>inc</code> all the numbers before using <code>frequencies</code> and the rest of the selectors, can I somehow fit that into the selector?</z><z id="t1466694043" t="luxbock I have this type of situation where I had a nested transform like in my example, and I&apos;m now trying to re-write it using your approach"><y>#</y><d>2016-06-23</d><h>15:00</h><w>luxbock</w>I have this type of situation where I had a nested <code>transform</code> like in my example, and I&apos;m now trying to re-write it using your approach</z><z id="t1466694081" t="luxbock but instead of numbers in a vector, I have a collection of maps where I need to fetch a nested value and then round those up before calling frequencies"><y>#</y><d>2016-06-23</d><h>15:01</h><w>luxbock</w>but instead of numbers in a vector, I have a collection of maps where I need to fetch a nested value and then round those up before calling <code>frequencies</code></z><z id="t1466694176" t="luxbock so I need to start with MAP-VALS , ALL , (view inc) , but then I&apos;d need to go back up a level in the selection"><y>#</y><d>2016-06-23</d><h>15:02</h><w>luxbock</w>so I need to start with <code>MAP-VALS</code>, <code>ALL</code>, <code>(view inc)</code>, but then I&apos;d need to go back up a level in the selection</z><z id="t1466694810" t="nathanmarz @luxbock: is transformed what you&apos;re looking for? (transform [MAP-VALS (transformed ALL inc) (view frequencies) (subselect MAP-VALS) (collect-one (view #(apply max %))) ALL] (fn [mx e] (/ e mx)) {:a [1 1 3 4] :b [1 1 2 2 2 3]}) "><y>#</y><d>2016-06-23</d><h>15:13</h><w>nathanmarz</w>@luxbock: is <code>transformed</code> what you&apos;re looking for?
<pre>(transform
  [MAP-VALS
   (transformed ALL inc)
   (view frequencies)
   (subselect MAP-VALS)
   (collect-one (view #(apply max %)))
   ALL]
  (fn [mx e] (/ e mx))
  {:a [1 1 3 4] :b [1 1 2 2 2 3]})
</pre></z><z id="t1466695092" t="luxbock @nathanmarz: yeah it works for my toy example, thanks"><y>#</y><d>2016-06-23</d><h>15:18</h><w>luxbock</w>@nathanmarz: yeah it works for my toy example, thanks</z><z id="t1466695107" t="luxbock my actual use case is still a bit more complicated so I need to figure out a few more things"><y>#</y><d>2016-06-23</d><h>15:18</h><w>luxbock</w>my actual use case is still a bit more complicated so I need to figure out a few more things</z><z id="t1466695188" t="luxbock does view only take one argument? it seems to accept many but I&apos;m not sure if they are doing anything"><y>#</y><d>2016-06-23</d><h>15:19</h><w>luxbock</w>does <code>view</code> only take one argument? it seems to accept many but I&apos;m not sure if they are doing anything</z><z id="t1466695269" t="nathanmarz it only takes one argument"><y>#</y><d>2016-06-23</d><h>15:21</h><w>nathanmarz</w>it only takes one argument</z><z id="t1466695278" t="nathanmarz that it doesn&apos;t error with zero or more than one is an implementation artifact"><y>#</y><d>2016-06-23</d><h>15:21</h><w>nathanmarz</w>that it doesn&apos;t error with zero or more than one is an implementation artifact</z><z id="t1466695363" t="luxbock what do you think if multiple arguments would use an implicit comp ?"><y>#</y><d>2016-06-23</d><h>15:22</h><w>luxbock</w>what do you think if multiple arguments would use an implicit <code>comp</code>?</z><z id="t1466695442" t="nathanmarz i think it&apos;s better to be explicit about that"><y>#</y><d>2016-06-23</d><h>15:24</h><w>nathanmarz</w>i think it&apos;s better to be explicit about that</z><z id="t1466695473" t="nathanmarz comp and view are completely orthogonal to each other"><y>#</y><d>2016-06-23</d><h>15:24</h><w>nathanmarz</w><code>comp</code> and <code>view</code> are completely orthogonal to each other</z><z id="t1466695532" t="luxbock (view f) (view g) (view h) is the same as (view (comp f g h)) right? just making sure I understand how it works"><y>#</y><d>2016-06-23</d><h>15:25</h><w>luxbock</w><code>(view f) (view g) (view h)</code> is the same as <code>(view (comp f g h))</code> right? just making sure I understand how it works</z><z id="t1466695537" t="luxbock EDIT"><y>#</y><d>2016-06-23</d><h>15:25</h><w>luxbock</w>EDIT</z><z id="t1466695570" t="nathanmarz i think it would be (comp h g f)"><y>#</y><d>2016-06-23</d><h>15:26</h><w>nathanmarz</w>i think it would be <code>(comp h g f)</code></z><z id="t1466695576" t="luxbock ah right"><y>#</y><d>2016-06-23</d><h>15:26</h><w>luxbock</w>ah right</z><z id="t1466698833" t="luxbock https://gist.github.com/luxbock/99645147579aee4812ac9870efa9bb4a"><y>#</y><d>2016-06-23</d><h>16:20</h><w>luxbock</w><a href="https://gist.github.com/luxbock/99645147579aee4812ac9870efa9bb4a" target="_blank">https://gist.github.com/luxbock/99645147579aee4812ac9870efa9bb4a</a></z><z id="t1466698839" t="luxbock are there any noticeable anti-patterns in here?"><y>#</y><d>2016-06-23</d><h>16:20</h><w>luxbock</w>are there any noticeable anti-patterns in here?</z><z id="t1466700581" t="codonnell @luxbock: you could use (.intValue (double 12.543)) instead of the string business if that&apos;s clojure"><y>#</y><d>2016-06-23</d><h>16:49</h><w>codonnell</w>@luxbock: you could use <code>(.intValue (double 12.543))</code> instead of the string business if that&apos;s clojure</z><z id="t1466700670" t="nathanmarz @luxbock: you should make the transform function argument for transformed static – otherwise it can&apos;t inline cache"><y>#</y><d>2016-06-23</d><h>16:51</h><w>nathanmarz</w>@luxbock: you should make the transform function argument for <code>transformed</code> static – otherwise it can&apos;t inline cache</z><z id="t1466700687" t="nathanmarz factor it into a defn"><y>#</y><d>2016-06-23</d><h>16:51</h><w>nathanmarz</w>factor it into a <code>defn</code></z><z id="t1466700719" t="luxbock @codonnell: yeah good point"><y>#</y><d>2016-06-23</d><h>16:51</h><w>luxbock</w>@codonnell: yeah good point</z><z id="t1466700740" t="nathanmarz that&apos;s the only case in specter where anonymous functions to a navigator won&apos;t factor automatically"><y>#</y><d>2016-06-23</d><h>16:52</h><w>nathanmarz</w>that&apos;s the only case in specter where  anonymous functions to a navigator won&apos;t factor automatically</z><z id="t1466700763" t="luxbock @nathanmarz: ah, why is that?"><y>#</y><d>2016-06-23</d><h>16:52</h><w>luxbock</w>@nathanmarz: ah, why is that?</z><z id="t1466700788" t="luxbock that&apos;s a good thing to know"><y>#</y><d>2016-06-23</d><h>16:53</h><w>luxbock</w>that&apos;s a good thing to know</z><z id="t1466700822" t="nathanmarz it would be possible to re-engineer transformed to do so, but that will be a lot of work"><y>#</y><d>2016-06-23</d><h>16:53</h><w>nathanmarz</w>it would be possible to re-engineer transformed to do so, but that will be a lot of work</z><z id="t1466700879" t="luxbock is it generally true that I want to do as much of the work in the selector as possible?"><y>#</y><d>2016-06-23</d><h>16:54</h><w>luxbock</w>is it generally true that I want to do as much of the work in the selector as possible?</z><z id="t1466700897" t="luxbock rather than nesting in another call to transform"><y>#</y><d>2016-06-23</d><h>16:54</h><w>luxbock</w>rather than nesting in another call to <code>transform</code></z><z id="t1466701017" t="nathanmarz I find that&apos;s generally more elegant"><y>#</y><d>2016-06-23</d><h>16:56</h><w>nathanmarz</w>I find that&apos;s generally more elegant</z><z id="t1466701162" t="luxbock is there an easier way to do this: (transform [(collect-one :a :b :c) (view (comp :d :b :a))] + {:a {:b {:c 1 :d 2}}}) ?"><y>#</y><d>2016-06-23</d><h>16:59</h><w>luxbock</w>is there an easier way to do this:
<code>(transform [(collect-one :a :b :c) (view (comp :d :b :a))] + {:a {:b {:c 1 :d 2}}})</code> ?</z><z id="t1466701280" t="nathanmarz (reduce + (select [:a :b (multi-path :c :d)] {:a {:b {:c 1 :d 2}}})"><y>#</y><d>2016-06-23</d><h>17:01</h><w>nathanmarz</w><code>(reduce + (select [:a :b (multi-path :c :d)] {:a {:b {:c 1 :d 2}}})</code></z><z id="t1466701306" t="nathanmarz or in 0.12.0 (reduce + (traverse [:a :b (multi-path :c :d)] {:a {:b {:c 1 :d 2}}})"><y>#</y><d>2016-06-23</d><h>17:01</h><w>nathanmarz</w>or in 0.12.0 <code>(reduce + (traverse [:a :b (multi-path :c :d)] {:a {:b {:c 1 :d 2}}})</code></z><z id="t1466701311" t="nathanmarz don&apos;t know if that&apos;s easier"><y>#</y><d>2016-06-23</d><h>17:01</h><w>nathanmarz</w>don&apos;t know if that&apos;s easier</z><z id="t1466701319" t="codonnell I think it&apos;s clearer"><y>#</y><d>2016-06-23</d><h>17:01</h><w>codonnell</w>I think it&apos;s clearer</z><z id="t1466701339" t="codonnell comp feels unnatural for accessing nested maps, because the keys have to be backwards"><y>#</y><d>2016-06-23</d><h>17:02</h><w>codonnell</w>comp feels unnatural for accessing nested maps, because the keys have to be backwards</z><z id="t1466701535" t="luxbock yeah I like the traverse one"><y>#</y><d>2016-06-23</d><h>17:05</h><w>luxbock</w>yeah I like the <code>traverse</code> one</z><z id="t1466701570" t="luxbock one problem that I run into with these large selectors is that they break the cider debugger"><y>#</y><d>2016-06-23</d><h>17:06</h><w>luxbock</w>one problem that I run into with these large selectors is that they break the cider debugger</z><z id="t1466701581" t="luxbock &quot;Method code too large!&quot;"><y>#</y><d>2016-06-23</d><h>17:06</h><w>luxbock</w>&quot;Method code too large!&quot;</z><z id="t1466701629" t="luxbock running macroexpand-all on the transform I can see why"><y>#</y><d>2016-06-23</d><h>17:07</h><w>luxbock</w>running <code>macroexpand-all</code> on the <code>transform</code> I can see why</z><z id="t1466701753" t="nathanmarz that&apos;s the inline caching implementation you&apos;re seeing"><y>#</y><d>2016-06-23</d><h>17:09</h><w>nathanmarz</w>that&apos;s the inline caching implementation you&apos;re seeing</z><z id="t1466701770" t="nathanmarz odd that cider would have a limit like that"><y>#</y><d>2016-06-23</d><h>17:09</h><w>nathanmarz</w>odd that cider would have a limit like that</z><z id="t1466705803" t="luxbock I benchmarked my specter implementation of a function vs a transducer / vanillla core version of the same function"><y>#</y><d>2016-06-23</d><h>18:16</h><w>luxbock</w>I benchmarked my <code>specter</code> implementation of a function vs a transducer / vanillla core version of the same function</z><z id="t1466705805" t="luxbock https://gist.github.com/luxbock/29092fd7357b3932eddfa7ee0df98d46"><y>#</y><d>2016-06-23</d><h>18:16</h><w>luxbock</w><a href="https://gist.github.com/luxbock/29092fd7357b3932eddfa7ee0df98d46" target="_blank">https://gist.github.com/luxbock/29092fd7357b3932eddfa7ee0df98d46</a></z><z id="t1466705881" t="luxbock results are quite close speed wise but in this case I think I prefer the core version slightly for I think it&apos;s easier to go and modify to change its behavior"><y>#</y><d>2016-06-23</d><h>18:18</h><w>luxbock</w>results are quite close speed wise but in this case I think I prefer the core version slightly for I think it&apos;s easier to go and modify to change its behavior</z><z id="t1466706092" t="luxbock for example I actually prefer to have the (filter filter-fn) happen between the two map-steps, and I can&apos;t think off the top of my head how I&apos;d need to modify the selector to accomplish this"><y>#</y><d>2016-06-23</d><h>18:21</h><w>luxbock</w>for example I actually prefer to have the <code>(filter filter-fn)</code> happen between the two map-steps, and I can&apos;t think off the top of my head how I&apos;d need to modify the selector to accomplish this</z><z id="t1466706443" t="nathanmarz you probably want a new pathed navigator"><y>#</y><d>2016-06-23</d><h>18:27</h><w>nathanmarz</w>you probably want a new pathed navigator</z><z id="t1466706446" t="nathanmarz selectview"><y>#</y><d>2016-06-23</d><h>18:27</h><w>nathanmarz</w><code>selectview</code></z><z id="t1466706460" t="nathanmarz then it would look like: (defn round-frequencies [iso-map find-size round-fn filter-fn] (transform [MAP-VALS (selectview [ALL (view find-size) (view round-fn) (pred filter-fn)]) (view frequencies) (transformed [(subselect MAP-VALS) (collect-one (view #(apply + %))) ALL] revdiv)] #(into (sorted-map) (keep (fn [[k v]] (when (&gt; v 1/100) [k (* 100 v)]))) %) iso-map)) "><y>#</y><d>2016-06-23</d><h>18:27</h><w>nathanmarz</w>then it would look like:
<pre>(defn round-frequencies
  [iso-map find-size round-fn filter-fn]
  (transform [MAP-VALS
              (selectview [ALL (view find-size) (view round-fn) (pred filter-fn)])
              (view frequencies)
              (transformed
                [(subselect MAP-VALS)
                 (collect-one (view #(apply + %)))
                 ALL]
                revdiv)]
    #(into (sorted-map)
       (keep (fn [[k v]]
               (when (&gt; v 1/100)
                 [k (* 100 v)])))
       %)
    iso-map))
</pre></z><z id="t1466706513" t="luxbock thanks, yeah I hadn&apos;t seen selectview before"><y>#</y><d>2016-06-23</d><h>18:28</h><w>luxbock</w>thanks, yeah I hadn&apos;t seen <code>selectview</code> before</z><z id="t1466706518" t="nathanmarz it doesn&apos;t exist"><y>#</y><d>2016-06-23</d><h>18:28</h><w>nathanmarz</w>it doesn&apos;t exist</z><z id="t1466706524" t="nathanmarz but it would be easy to make"><y>#</y><d>2016-06-23</d><h>18:28</h><w>nathanmarz</w>but it would be easy to make</z><z id="t1466706533" t="luxbock oh"><y>#</y><d>2016-06-23</d><h>18:28</h><w>luxbock</w>oh</z><z id="t1466706712" t="luxbock my third version which uses (transform MAP-VALS ...) instead of (into {} ...) is the fastest of them all"><y>#</y><d>2016-06-23</d><h>18:31</h><w>luxbock</w>my third version which uses <code>(transform MAP-VALS ...)</code> instead of <code>(into {} ...)</code> is the fastest of them all</z><z id="t1466706727" t="luxbock also I realized I was doing some uneccessary extra work in the vanilla core version"><y>#</y><d>2016-06-23</d><h>18:32</h><w>luxbock</w>also I realized I was doing some uneccessary extra work in the vanilla core version</z><z id="t1466706931" t="nathanmarz If #117 was implemented then it could be simplified further"><y>#</y><d>2016-06-23</d><h>18:35</h><w>nathanmarz</w>If #117 was implemented then it could be simplified further</z><z id="t1466706933" t="nathanmarz https://github.com/nathanmarz/specter/issues/117"><y>#</y><d>2016-06-23</d><h>18:35</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/issues/117" target="_blank">https://github.com/nathanmarz/specter/issues/117</a></z><z id="t1466707275" t="luxbock yeah I think that&apos;d be a really useful feature"><y>#</y><d>2016-06-23</d><h>18:41</h><w>luxbock</w>yeah I think that&apos;d be a really useful feature</z><z id="t1466707317" t="codonnell @luxbock: are you using comp so your maps and filters are composing as transducers rather than generating intermediate sequences?"><y>#</y><d>2016-06-23</d><h>18:41</h><w>codonnell</w>@luxbock: are you using <code>comp</code> so your maps and filters are composing as transducers rather than generating intermediate sequences?</z><z id="t1466707326" t="codonnell rather than -&gt;&gt;"><y>#</y><d>2016-06-23</d><h>18:42</h><w>codonnell</w>rather than <code>-&gt;&gt;</code></z><z id="t1466707334" t="luxbock @codonnell: yep"><y>#</y><d>2016-06-23</d><h>18:42</h><w>luxbock</w>@codonnell: yep</z><z id="t1466707376" t="codonnell have you checked how much of a performance impact that has?"><y>#</y><d>2016-06-23</d><h>18:42</h><w>codonnell</w>have you checked how much of a performance impact that has?</z><z id="t1466707446" t="luxbock no, but I imagine it&apos;s a fair amount, as the bulk of the work is done there"><y>#</y><d>2016-06-23</d><h>18:44</h><w>luxbock</w>no, but I imagine it&apos;s a fair amount, as the bulk of the work is done there</z><z id="t1466707463" t="luxbock about to head to bed but I&apos;ll run that out of curiosity before I log off"><y>#</y><d>2016-06-23</d><h>18:44</h><w>luxbock</w>about to head to bed but I&apos;ll run that out of curiosity before I log off</z><z id="t1466707886" t="codonnell I&apos;d love to hear the results; I&apos;m curious"><y>#</y><d>2016-06-23</d><h>18:51</h><w>codonnell</w>I&apos;d love to hear the results; I&apos;m curious</z><z id="t1466712681" t="nathanmarz @codonnell: specter has a benchmark for that"><y>#</y><d>2016-06-23</d><h>20:11</h><w>nathanmarz</w>@codonnell: specter has a benchmark for that</z><z id="t1466712685" t="nathanmarz Benchmark: even :a values from sequence of maps (500000 iterations) Avg(ms) vs best Code 93.478 1.00 (into [] xf data) 113.85 1.22 (select [ALL :a even?] data) 156.08 1.67 (into [] (comp (map :a) (filter even?)) data) 253.74 2.71 (-&gt;&gt; data (mapv :a) (filter even?) doall) "><y>#</y><d>2016-06-23</d><h>20:11</h><w>nathanmarz</w><pre>Benchmark: even :a values from sequence of maps (500000 iterations)

Avg(ms)		vs best		Code
93.478 		 1.00 		 (into [] xf data)
113.85 		 1.22 		 (select [ALL :a even?] data)
156.08 		 1.67 		 (into [] (comp (map :a) (filter even?)) data)
253.74 		 2.71 		 (-&gt;&gt; data (mapv :a) (filter even?) doall)
</pre></z><z id="t1466712860" t="nathanmarz note that comp with more than two arguments will slow things down a lot"><y>#</y><d>2016-06-23</d><h>20:14</h><w>nathanmarz</w>note that <code>comp</code> with more than two arguments will slow things down a lot</z><z id="t1466712864" t="nathanmarz Benchmark: even :a values from sequence of maps (500000 iterations) Avg(ms) vs best Code 155.98 1.00 (into [] (comp (map :a) (filter even?)) data) 164.82 1.06 (into [] xf data) 203.00 1.30 (select [ALL :a even? even? even?] data) 331.59 2.13 (into [] (comp (map :a) (filter even?) (filter even?) (filter even?)) data) 525.34 3.37 (-&gt;&gt; data (mapv :a) (filter even?) (filter even?) (filter even?) doall) "><y>#</y><d>2016-06-23</d><h>20:14</h><w>nathanmarz</w><pre>Benchmark: even :a values from sequence of maps (500000 iterations)

Avg(ms)		vs best		Code
155.98 		 1.00 		 (into [] (comp (map :a) (filter even?)) data)
164.82 		 1.06 		 (into [] xf data)
203.00 		 1.30 		 (select [ALL :a even? even? even?] data)
331.59 		 2.13 		 (into [] (comp (map :a) (filter even?) (filter even?) (filter even?)) data)
525.34 		 3.37 		 (-&gt;&gt; data (mapv :a) (filter even?) (filter even?) (filter even?) doall)
</pre></z><z id="t1466712884" t="nathanmarz here xf is (comp (map :a) (filter even?) (filter even?) (filter even?))"><y>#</y><d>2016-06-23</d><h>20:14</h><w>nathanmarz</w>here <code>xf</code> is <code>(comp (map :a) (filter even?) (filter even?) (filter even?))</code></z><z id="t1466713107" t="codonnell wow, that&apos;s a huge slowdown"><y>#</y><d>2016-06-23</d><h>20:18</h><w>codonnell</w>wow, that&apos;s a huge slowdown</z><z id="t1466713171" t="nathanmarz https://github.com/clojure/clojure/blob/clojure-1.7.0/src/clj/clojure/core.clj#L2426"><y>#</y><d>2016-06-23</d><h>20:19</h><w>nathanmarz</w><a href="https://github.com/clojure/clojure/blob/clojure-1.7.0/src/clj/clojure/core.clj#L2426" target="_blank">https://github.com/clojure/clojure/blob/clojure-1.7.0/src/clj/clojure/core.clj#L2426</a></z><z id="t1466713211" t="nathanmarz it slows down because it does a reduce after more than two args"><y>#</y><d>2016-06-23</d><h>20:20</h><w>nathanmarz</w>it slows down because it does a reduce after more than two args</z><z id="t1466713235" t="nathanmarz if the implementation of comp was unrolled up to 20 arguments it would work much better"><y>#</y><d>2016-06-23</d><h>20:20</h><w>nathanmarz</w>if the implementation of <code>comp</code> was unrolled up to 20 arguments it would work much better</z><z id="t1466713673" t="codonnell interesting"><y>#</y><d>2016-06-23</d><h>20:27</h><w>codonnell</w>interesting</z><z id="t1466713692" t="codonnell I wonder why it isn&apos;t unrolled like that; other functions in core certainly are."><y>#</y><d>2016-06-23</d><h>20:28</h><w>codonnell</w>I wonder why it isn&apos;t unrolled like that; other functions in core certainly are.</z><z id="t1466713727" t="nathanmarz there&apos;s a bunch that aren&apos;t: http://dev.clojure.org/jira/browse/CLJ-731"><y>#</y><d>2016-06-23</d><h>20:28</h><w>nathanmarz</w>there&apos;s a bunch that aren&apos;t: <a href="http://dev.clojure.org/jira/browse/CLJ-731" target="_blank">http://dev.clojure.org/jira/browse/CLJ-731</a></z><z id="t1466713729" t="codonnell Perhaps they&apos;ve assumed that people aren&apos;t going to be calling comp over and over like in the benchmark."><y>#</y><d>2016-06-23</d><h>20:28</h><w>codonnell</w>Perhaps they&apos;ve assumed that people aren&apos;t going to be calling <code>comp</code> over and over like in the benchmark.</z><z id="t1466713768" t="nathanmarz well it seems like with transducers it would be a common pattern to do it inline like that"><y>#</y><d>2016-06-23</d><h>20:29</h><w>nathanmarz</w>well it seems like with transducers it would be a common pattern to do it inline like that</z><z id="t1466713842" t="codonnell that&apos;s true, though transducers weren&apos;t in existence when that patch was submitted"><y>#</y><d>2016-06-23</d><h>20:30</h><w>codonnell</w>that&apos;s true, though transducers weren&apos;t in existence when that patch was submitted</z><z id="t1466718152" t="aengelberg @nathanmarz It seems like the multi-transform functionality of doing a variety of operations in a single transform is still &quot;doable&quot; with transform , if you collect values along the way and use that to dispatch on some operation in the transform fn."><y>#</y><d>2016-06-23</d><h>21:42</h><w>aengelberg</w>@nathanmarz It seems like the <code>multi-transform</code> functionality of doing a variety of operations in a single transform is still &quot;doable&quot; with <code>transform</code>, if you collect values along the way and use that to dispatch on some operation in the transform fn.</z><z id="t1466718162" t="aengelberg it&apos;s probably not as performant as multi-transform but might be fun to add to your benchmark."><y>#</y><d>2016-06-23</d><h>21:42</h><w>aengelberg</w>it&apos;s probably not as performant as multi-transform but might be fun to add to your benchmark.</z><z id="t1466719283" t="nathanmarz @aengelberg: true but it&apos;s a bit convoluted and definitely would be less performant"><y>#</y><d>2016-06-23</d><h>22:01</h><w>nathanmarz</w>@aengelberg: true but it&apos;s a bit convoluted and definitely would be less performant</z><z id="t1466719316" t="nathanmarz the cases I consider for the benchmarks are the fastest impls, the most concise impls, and the most idiomatic impls"><y>#</y><d>2016-06-23</d><h>22:01</h><w>nathanmarz</w>the cases I consider for the benchmarks are the fastest impls, the most concise impls, and the most idiomatic impls</z><z id="t1466736296" t="conaw If want to use specter to replace the nth value in deeply nested array, is there a better way to navigate to that value than using (srange x (inc x))"><y>#</y><d>2016-06-24</d><h>02:44</h><w>conaw</w>If want to use specter to replace the nth value in deeply nested array, is there a better way to navigate to that value than using (srange x (inc x))</z><z id="t1466737638" t="conaw Ideally I’d like to be able to transform the value there, or put in default if it doesn’t exist"><y>#</y><d>2016-06-24</d><h>03:07</h><w>conaw</w>Ideally I’d like to be able to transform the value there, or put in default if it doesn’t exist</z><z id="t1466737749" t="codonnell @conaw: there&apos;s a custom nth-elt navigator in the wiki at https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav"><y>#</y><d>2016-06-24</d><h>03:09</h><w>codonnell</w>@conaw: there&apos;s a custom <code>nth-elt</code> navigator in the wiki at <a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav</a></z><z id="t1466737760" t="codonnell I don&apos;t know of a better way to do it, personally"><y>#</y><d>2016-06-24</d><h>03:09</h><w>codonnell</w>I don&apos;t know of a better way to do it, personally</z><z id="t1466737787" t="conaw awesome"><y>#</y><d>2016-06-24</d><h>03:09</h><w>conaw</w>awesome</z><z id="t1466737804" t="codonnell under the hood it does basically what you said"><y>#</y><d>2016-06-24</d><h>03:10</h><w>codonnell</w>under the hood it does basically what you said</z><z id="t1466737832" t="codonnell if you want default element behavior, you could modify it to do that"><y>#</y><d>2016-06-24</d><h>03:10</h><w>codonnell</w>if you want default element behavior, you could modify it to do that</z><z id="t1466739363" t="aengelberg @conaw by array do you mean vector? if so, I believe (keypath 3) works"><y>#</y><d>2016-06-24</d><h>03:36</h><w>aengelberg</w>@conaw by array do you mean vector? if so, I believe <code>(keypath 3)</code> works</z><z id="t1466739399" t="conaw yeah, I’m actually working with a matrix, so words slipped"><y>#</y><d>2016-06-24</d><h>03:36</h><w>conaw</w>yeah, I’m actually working with a matrix, so words slipped</z><z id="t1466739429" t="conaw thanks a bunch"><y>#</y><d>2016-06-24</d><h>03:37</h><w>conaw</w>thanks a bunch</z><z id="t1466739438" t="aengelberg np"><y>#</y><d>2016-06-24</d><h>03:37</h><w>aengelberg</w>np</z><z id="t1466739582" t="conaw So I can reasonably do a (if-path (keypath 4) LAST) right?"><y>#</y><d>2016-06-24</d><h>03:39</h><w>conaw</w>So I can reasonably do a (if-path (keypath 4) LAST) right?</z><z id="t1466739640" t="conaw or I would do (if-path (keypath 4) (keypath 4) LAST)"><y>#</y><d>2016-06-24</d><h>03:40</h><w>conaw</w>or I would do (if-path (keypath 4) (keypath 4) LAST)</z><z id="t1466739693" t="conaw or rather END"><y>#</y><d>2016-06-24</d><h>03:41</h><w>conaw</w>or rather END</z><z id="t1466739854" t="conaw nvm (if-path (must 3) (keypath 3) END)"><y>#</y><d>2016-06-24</d><h>03:44</h><w>conaw</w>nvm (if-path (must 3) (keypath 3) END)</z><z id="t1466740877" t="conaw ok, here’s a question, it seems that I can substitute a value into a vector using setval , but if I want to use sp/END i have to have it wrapped in a seqable, so couldn’t insert it in in a flat way, is there a way I might get around that (setval [(sp/if-path (sp/must 3) (sp/keypath 3) sp/END)] :newd [:a :b :c :dd]) =&gt; [:a :b :c :newd] "><y>#</y><d>2016-06-24</d><h>04:01</h><w>conaw</w>ok, here’s a question, it seems that I can substitute a value into a vector using setval , but if I want to use sp/END i have to have it wrapped in a seqable, so couldn’t insert it in in a flat way, is there a way I might get around that
<pre>(setval [(sp/if-path (sp/must 3) (sp/keypath 3) sp/END)] :newd  [:a :b :c :dd])

=&gt;  [:a :b :c :newd]

</pre></z><z id="t1466740910" t="conaw (setval [(sp/if-path (sp/must 3) (sp/keypath 3) sp/END)] [:newd] [:a :b :c]) =&gt; [:a :b :c :newd]"><y>#</y><d>2016-06-24</d><h>04:01</h><w>conaw</w><pre>(setval [(sp/if-path (sp/must 3) (sp/keypath 3) sp/END)] [:newd]  [:a :b :c])
=&gt; [:a :b :c :newd]</pre></z><z id="t1466741162" t="conaw basically, in assoc, if I assoc to the size of a vector, I conj onto the end, I’m looking for a similar behavior here"><y>#</y><d>2016-06-24</d><h>04:06</h><w>conaw</w>basically, in assoc, if I assoc to the size of a vector, I conj onto the end, I’m looking for a similar behavior here</z><z id="t1466742796" t="nathanmarz @conaw: I think you can do [END (keypath 0)]"><y>#</y><d>2016-06-24</d><h>04:33</h><w>nathanmarz</w>@conaw: I think you can do <code>[END (keypath 0)]</code></z><z id="t1466754875" t="luxbock @codonnell: sorry for disappearing last night, I ran the benchmark with (sequence (comp ...) %) substituted for (-&gt;&gt; % ...) and it actually came out faster, 97ms vs 110 ms"><y>#</y><d>2016-06-24</d><h>07:54</h><w>luxbock</w>@codonnell: sorry for disappearing last night, I ran the benchmark with <code>(sequence (comp ...) %)</code> substituted for <code>(-&gt;&gt; % ...)</code>  and it actually came out faster, 97ms vs 110 ms</z><z id="t1466754895" t="luxbock that&apos;s really surprising to me"><y>#</y><d>2016-06-24</d><h>07:54</h><w>luxbock</w>that&apos;s really surprising to me</z><z id="t1466787726" t="aengelberg Does (comp ...) take some time to initially build up the transducer?"><y>#</y><d>2016-06-24</d><h>17:02</h><w>aengelberg</w>Does <code>(comp ...)</code> take some time to initially build up the transducer?</z><z id="t1466791304" t="nathanmarz @aengelberg: yes, most noticeable when operating on relatively little data"><y>#</y><d>2016-06-24</d><h>18:01</h><w>nathanmarz</w>@aengelberg: yes, most noticeable when operating on relatively little data</z><z id="t1466791382" t="nathanmarz @aengelberg: the benchmarks I pasted before show a large performance difference between &quot;precompiling&quot; the transducer and doing it inline"><y>#</y><d>2016-06-24</d><h>18:03</h><w>nathanmarz</w>@aengelberg: the benchmarks I pasted before show a large performance difference between &quot;precompiling&quot; the transducer and doing it inline</z><z id="t1466868126" t="luxbock I have a nested data-structure and I&apos;d like to collect all lists from it, and then return a map with the original data-structure as one value and a vector of all of the lists as another"><y>#</y><d>2016-06-25</d><h>15:22</h><w>luxbock</w>I have a nested data-structure and I&apos;d like to collect all lists from it, and then return a map with the original data-structure as one value and a vector of all of the lists as another</z><z id="t1466868145" t="luxbock am I right in assuming I can&apos;t use walker for this? since it just edits the matched values in-place"><y>#</y><d>2016-06-25</d><h>15:22</h><w>luxbock</w>am I right in assuming I can&apos;t use <code>walker</code> for this? since it just edits the matched values in-place</z><z id="t1466869277" t="nathanmarz @luxbock: walker will not traverse into matched elements, so as long as you don&apos;t need that it sounds like it should work"><y>#</y><d>2016-06-25</d><h>15:41</h><w>nathanmarz</w>@luxbock: <code>walker</code> will not traverse into matched elements, so as long as you don&apos;t need that it sounds like it should work</z><z id="t1466875428" t="luxbock @nathanmarz: yeah thanks, I got it working"><y>#</y><d>2016-06-25</d><h>17:23</h><w>luxbock</w>@nathanmarz: yeah thanks, I got it working</z><z id="t1466996625" t="conaw Lets say I have a tree, and I want to select all of the nodes n levels away from the root following a particular path, is there a smart way to define a navigator that would repeat n times?"><y>#</y><d>2016-06-27</d><h>03:03</h><w>conaw</w>Lets say I have a tree, and I want to select all of the nodes n levels away from the root following a particular path, is there a smart way to define a navigator that would repeat n times?</z><z id="t1466996731" t="conaw (select [(repeat-path [:children ALL] 4)] tree)"><y>#</y><d>2016-06-27</d><h>03:05</h><w>conaw</w><pre>(select [(repeat-path [:children ALL] 4)] tree)</pre></z><z id="t1466996862" t="conaw I’ve noticed some talk of stateful navigators in here but wasn’t paying close attention, is this a case for that?"><y>#</y><d>2016-06-27</d><h>03:07</h><w>conaw</w>I’ve noticed some talk of stateful navigators in here but wasn’t paying close attention, is this a case for that?</z><z id="t1466997001" t="conaw https://github.com/nathanmarz/specter/wiki/List-of-Macros#variable-pathed-nav"><y>#</y><d>2016-06-27</d><h>03:10</h><w>conaw</w><a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#variable-pathed-nav" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Macros#variable-pathed-nav</a></z><z id="t1466997002" t="conaw ?"><y>#</y><d>2016-06-27</d><h>03:10</h><w>conaw</w>?</z><z id="t1466998450" t="conaw (declarepath deeper [i]) (defpathedfn deeper [i] (if (= 0 i) (keypath i) (deeper (dec i)))) (select [(deeper 1)] [0 1 2 3]) "><y>#</y><d>2016-06-27</d><h>03:34</h><w>conaw</w><pre>(declarepath deeper [i])

(defpathedfn deeper [i]
  (if (= 0 i)
    (keypath i)
    (deeper (dec i))))


(select [(deeper 1)] [0 1 2 3])
</pre></z><z id="t1466999247" t="conaw ok, found an answer (declarepath repeat-path [walk-path end-path i]) (defpathedfn repeat-path [walk-path end-path i] (if (= 0 i) end-path [walk-path (repeat-path walk-path end-path (dec i))])) (select [(repeat-path [:node/_children ALL] :db/id 3)] ptest) "><y>#</y><d>2016-06-27</d><h>03:47</h><w>conaw</w>ok, found an answer <pre>(declarepath repeat-path [walk-path end-path i])

(defpathedfn repeat-path [walk-path end-path i]
  (if (= 0 i)
    end-path
    [walk-path (repeat-path walk-path end-path (dec i))]))


(select [(repeat-path [:node/_children ALL] :db/id 3)] ptest)
</pre></z><z id="t1467001801" t="conaw other question, Figwheel doesn’t seem to like that I am declaring a path and then redefining it this way, Figwheel: Compile Warning - repeat-path at line 105 is being replaced at line 107 anything to be done about this?"><y>#</y><d>2016-06-27</d><h>04:30</h><w>conaw</w>other question, Figwheel doesn’t seem to like that I am declaring a path and then redefining it this way, <pre>Figwheel: Compile Warning - repeat-path at line 105 is being replaced at line 107 </pre> anything to be done about this?</z><z id="t1467021388" t="nathanmarz @conaw: don&apos;t call declarepath there, that&apos;s only for usage with providepath"><y>#</y><d>2016-06-27</d><h>09:56</h><w>nathanmarz</w>@conaw: don&apos;t call <code>declarepath</code> there, that&apos;s only for usage with <code>providepath</code></z><z id="t1467021399" t="nathanmarz @conaw: the defpathedfn call works fine without it"><y>#</y><d>2016-06-27</d><h>09:56</h><w>nathanmarz</w>@conaw: the <code>defpathedfn</code> call works fine without it</z><z id="t1467021426" t="conaw yup, discovered that, my bad not updating"><y>#</y><d>2016-06-27</d><h>09:57</h><w>conaw</w>yup, discovered that, my bad not updating</z><z id="t1467021501" t="conaw This has made my life so much easier by the way. Today was an absolute joy because of it. Thank you."><y>#</y><d>2016-06-27</d><h>09:58</h><w>conaw</w>This has made my life so much easier by the way.  Today was an absolute joy because of it.  Thank you.</z><z id="t1467021518" t="nathanmarz good to hear"><y>#</y><d>2016-06-27</d><h>09:58</h><w>nathanmarz</w>good to hear</z><z id="t1467046674" t="jjcomer Has anyone had any issues using specter in an AOT’d uberjar? I’m using it to pull data out of my immutant request. It works fine when running with lein run, but when I run the uberjar, it errors when using the request with: java.lang.IllegalArgumentException: No implementation of method: :get_cell of protocol: #&apos;com.rpl.specter.impl/PMutableCell found for class: clojure.lang.Var$Unbound"><y>#</y><d>2016-06-27</d><h>16:57</h><w>jjcomer</w>Has anyone had any issues using specter in an AOT’d uberjar? I’m using it to pull data out of my immutant request. It works fine when running with lein run, but when I run the uberjar, it errors when using the request with: java.lang.IllegalArgumentException: No implementation of method: :get_cell of protocol: #&apos;com.rpl.specter.impl/PMutableCell found for class: clojure.lang.Var$Unbound</z><z id="t1467047077" t="nathanmarz a few people have reported similar issues, I haven&apos;t looked into it"><y>#</y><d>2016-06-27</d><h>17:04</h><w>nathanmarz</w>a few people have reported similar issues, I haven&apos;t looked into it</z><z id="t1467047337" t="jjcomer Immutant uses a immutant.web.internal.ring.LazyMap for its requests"><y>#</y><d>2016-06-27</d><h>17:08</h><w>jjcomer</w>Immutant uses a immutant.web.internal.ring.LazyMap for its requests</z><z id="t1467047576" t="nathanmarz I&apos;m not seeing the relevance of that"><y>#</y><d>2016-06-27</d><h>17:12</h><w>nathanmarz</w>I&apos;m not seeing the relevance of that</z><z id="t1467048206" t="jjcomer Nor I 🙂"><y>#</y><d>2016-06-27</d><h>17:23</h><w>jjcomer</w>Nor I <b>🙂</b></z><z id="t1467060361" t="adambros i can confirm that error, although it came up from something other than immutant"><y>#</y><d>2016-06-27</d><h>20:46</h><w>adambros</w>i can confirm that error, although it came up from something other than immutant</z><z id="t1467060946" t="nathanmarz @adambros @jjcomer with what versions of clojure/specter did you see those errors?"><y>#</y><d>2016-06-27</d><h>20:55</h><w>nathanmarz</w>@adambros @jjcomer with what versions of clojure/specter did you see those errors?</z><z id="t1467060987" t="adambros iirc clj 1.8 and specter 0.11.0"><y>#</y><d>2016-06-27</d><h>20:56</h><w>adambros</w>iirc clj 1.8 and specter 0.11.0</z><z id="t1467061022" t="adambros correction: specter 0.11.2"><y>#</y><d>2016-06-27</d><h>20:57</h><w>adambros</w>correction: specter 0.11.2</z><z id="t1467061047" t="nathanmarz cool, thanks"><y>#</y><d>2016-06-27</d><h>20:57</h><w>nathanmarz</w>cool, thanks</z><z id="t1467061114" t="adambros im pretty sure i didnt want unbound vars in my data, but it would fail on that if i typo’d a symbol"><y>#</y><d>2016-06-27</d><h>20:58</h><w>adambros</w>im pretty sure i didnt want unbound vars in my data, but it would fail on that if i typo’d a symbol</z><z id="t1467061378" t="nathanmarz oh I think I know what the problem might be"><y>#</y><d>2016-06-27</d><h>21:02</h><w>nathanmarz</w>oh I think I know what the problem might be</z><z id="t1467061676" t="nathanmarz https://github.com/nathanmarz/specter/issues/132"><y>#</y><d>2016-06-27</d><h>21:07</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/issues/132" target="_blank">https://github.com/nathanmarz/specter/issues/132</a></z><z id="t1467061708" t="nathanmarz @jjcomer @adambros do you get the error with specter 0.10.0?"><y>#</y><d>2016-06-27</d><h>21:08</h><w>nathanmarz</w>@jjcomer @adambros do you get the error with specter 0.10.0?</z><z id="t1467061726" t="adambros i dont, which is why i havent upgraded yet"><y>#</y><d>2016-06-27</d><h>21:08</h><w>adambros</w>i dont, which is why i havent upgraded yet</z><z id="t1467061757" t="nathanmarz ok, that supports my hypothesis"><y>#</y><d>2016-06-27</d><h>21:09</h><w>nathanmarz</w>ok, that supports my hypothesis</z><z id="t1467063207" t="nathanmarz @adambros @jjcomer I was able to reproduce it and fix it, give 0.12.0-SNAPSHOT a shot and let me know if it fixes it"><y>#</y><d>2016-06-27</d><h>21:33</h><w>nathanmarz</w>@adambros @jjcomer I was able to reproduce it and fix it, give 0.12.0-SNAPSHOT a shot and let me know if it fixes it</z><z id="t1467063222" t="nathanmarz just deployed 0.12.0-SNAPSHOT to clojars"><y>#</y><d>2016-06-27</d><h>21:33</h><w>nathanmarz</w>just deployed 0.12.0-SNAPSHOT to clojars</z><z id="t1467065383" t="angusiguess @nathanmarz: I built a small repro and just tried with 0.12.0-SNAPSHOT and it worked."><y>#</y><d>2016-06-27</d><h>22:09</h><w>angusiguess</w>@nathanmarz: I built a small repro and just tried with 0.12.0-SNAPSHOT and it worked.</z><z id="t1467069865" t="jjcomer @nathanmarz: awesome thanks!"><y>#</y><d>2016-06-27</d><h>23:24</h><w>jjcomer</w>@nathanmarz: awesome thanks!</z><z id="t1467098958" t="thomasdeutsch is there a way in specter to delete nil keys from a map? {nil 1, :b 2} -&gt; {:b 2}"><y>#</y><d>2016-06-28</d><h>07:29</h><w>thomasdeutsch</w>is there a way in specter to delete nil keys from a map?   <code>{nil 1, :b 2}</code> -&gt; <code>{:b 2}</code></z><z id="t1467114445" t="codonnell (transform ALL (fn [[k v]] (if (nil? k) nil [k v])) data) I think. Can&apos;t check as I&apos;m on my phone. "><y>#</y><d>2016-06-28</d><h>11:47</h><w>codonnell</w><code>(transform ALL (fn [[k v]] (if (nil? k) nil [k v])) data)</code> I think. Can&apos;t check as I&apos;m on my phone. </z><z id="t1467114475" t="codonnell @thomasdeutsch: ^"><y>#</y><d>2016-06-28</d><h>11:47</h><w>codonnell</w>@thomasdeutsch: ^</z><z id="t1467118946" t="codonnell But why not just do (dissoc m nil) ? "><y>#</y><d>2016-06-28</d><h>13:02</h><w>codonnell</w>But why not just do <code>(dissoc m nil)</code>? </z><z id="t1467122151" t="vikeri Hi, I want to select from a vector using srange. It works well until the index is out of bounds. Can I somehow prevent getting an error and instead return only the elements found? Or is this bad coding practice of some reason? As an example, if I have a vector with three elements and does (srange 0 4) it will throw an error, but instead I would like to get the only three elements found."><y>#</y><d>2016-06-28</d><h>13:55</h><w>vikeri</w>Hi, I want to select from a vector using srange. It works well until the index is out of bounds. Can I somehow prevent getting an error and instead return only the elements found? Or is this bad coding practice of some reason? As an example, if I have a vector with three elements and does (srange 0 4) it will throw an error, but instead I would like to get the only three elements found.</z><z id="t1467123430" t="nathanmarz @vikeri: you can use srange-dynamic for that"><y>#</y><d>2016-06-28</d><h>14:17</h><w>nathanmarz</w>@vikeri: you can use srange-dynamic for that</z><z id="t1467123656" t="nathanmarz @vikeri (defnavconstructor bounded-srange [p srange-dynamic] [s e] (p (fn [aseq] (if (&lt; s 0) 0 s)) (fn [aseq] (let [c (count aseq)] (if (&gt;= e c) c e) )))) "><y>#</y><d>2016-06-28</d><h>14:20</h><w>nathanmarz</w>@vikeri
<pre>(defnavconstructor bounded-srange
  [p srange-dynamic]
  [s e]
  (p (fn [aseq]
      (if (&lt; s 0) 0 s))
     (fn [aseq]
      (let [c (count aseq)]
        (if (&gt;= e c) c e)
        ))))
</pre></z><z id="t1467125020" t="vikeri @nathanmarz: Great! Looks a little like black magic to me since I started looking at specter today. But it worked so I’m happy 🙂"><y>#</y><d>2016-06-28</d><h>14:43</h><w>vikeri</w>@nathanmarz: Great! Looks a little like black magic to me since I started looking at specter today. But it worked so I’m happy <b>🙂</b></z><z id="t1467125535" t="vikeri Had to change it to this to fully accomodate my needs: (defnavconstructor bounded-srange [p srange-dynamic] [s e] (p (fn [aseq] (let [c (count aseq)] (cond (&lt; s 0) 0 (&gt;= s c) c :else s))) (fn [aseq] (let [c (count aseq)] (if (&gt;= e c) c e) )))) "><y>#</y><d>2016-06-28</d><h>14:52</h><w>vikeri</w>Had to change it to this to fully accomodate my needs:
<pre>(defnavconstructor bounded-srange
                   [p srange-dynamic]
                   [s e]
                   (p (fn [aseq]
                        (let [c (count aseq)]
                          (cond
                            (&lt; s 0) 0
                            (&gt;= s c) c
                            :else s)))
                      (fn [aseq]
                        (let [c (count aseq)]
                          (if (&gt;= e c) c e)
                          ))))
</pre></z><z id="t1467128238" t="nathanmarz @vikeri: defnavconstructor works like a normal function but also integrates with Specter&apos;s inline caching"><y>#</y><d>2016-06-28</d><h>15:37</h><w>nathanmarz</w>@vikeri: <code>defnavconstructor</code> works like a normal function but also integrates with Specter&apos;s inline caching</z><z id="t1467129676" t="vikeri Alright, I&apos;m sure it makes more sense if I read the docs 😛 . But it seems to be a nifty library, quite useful with a powerful query language for nested data structures."><y>#</y><d>2016-06-28</d><h>16:01</h><w>vikeri</w>Alright, I&apos;m sure it makes more sense if I read the docs <b>😛</b> . But it seems to be a nifty library, quite useful with a powerful query language for nested data structures.</z><z id="t1467987951" t="richiardiandrea Started using specter as well ;)"><y>#</y><d>2016-07-08</d><h>14:25</h><w>richiardiandrea</w>Started using specter as well ;)</z><z id="t1467990114" t="nathanmarz cool"><y>#</y><d>2016-07-08</d><h>15:01</h><w>nathanmarz</w>cool</z></g><g id="s4"><z id="t1467996215" t="richiardiandrea so first question 😄 let&apos;s say I have a map indexed by a long, but i don&apos;t care about that, I want to navigate to the value"><y>#</y><d>2016-07-08</d><h>16:43</h><w>richiardiandrea</w>so first question <b>😄</b> let&apos;s say I have a map indexed by a long, but i don&apos;t care about that, I want to navigate to the value</z><z id="t1467996256" t="richiardiandrea the [sp/ALL sp/MAP-VALS ] path navigates all the keys first, then values"><y>#</y><d>2016-07-08</d><h>16:44</h><w>richiardiandrea</w>the <code>[sp/ALL sp/MAP-VALS ]</code> path navigates all the keys first, then values</z><z id="t1467996278" t="richiardiandrea I&apos;d like to skip keys if possible..."><y>#</y><d>2016-07-08</d><h>16:44</h><w>richiardiandrea</w>I&apos;d like to skip keys if possible...</z><z id="t1467996292" t="nathanmarz easier to understand if you show the input/output you&apos;re looking for"><y>#</y><d>2016-07-08</d><h>16:44</h><w>nathanmarz</w>easier to understand if you show the input/output you&apos;re looking for</z><z id="t1467996340" t="richiardiandrea {:handles {&quot;booma&quot; {:business {:id 3, :name &quot;&quot;, :twitter-handle &quot;booma&quot;}, :sente-uids [&quot;e8a6a187-1e6b-41d1-aa93-d0912a290f49&quot; &quot;arsassa-1e6b-41d1-aa93-d0912a290f49&quot;]} &quot;my-handle&quot; {:business {:id 5, :name &quot;Business&quot;, :twitter-handle &quot;my-handle&quot;}, :sente-uids [&quot;artart27-1e6b-41d1-aa93-d091arsasr49&quot;]}}} "><y>#</y><d>2016-07-08</d><h>16:45</h><w>richiardiandrea</w><pre>{:handles {&quot;booma&quot; {:business {:id 3, :name &quot;&quot;, :twitter-handle &quot;booma&quot;}, :sente-uids [&quot;e8a6a187-1e6b-41d1-aa93-d0912a290f49&quot; &quot;arsassa-1e6b-41d1-aa93-d0912a290f49&quot;]}
           &quot;my-handle&quot; {:business {:id 5, :name &quot;Business&quot;, :twitter-handle &quot;my-handle&quot;}, :sente-uids [&quot;artart27-1e6b-41d1-aa93-d091arsasr49&quot;]}}}
</pre></z><z id="t1467996380" t="richiardiandrea I&apos;d like to fetch the inner maps, skipping the string key"><y>#</y><d>2016-07-08</d><h>16:46</h><w>richiardiandrea</w>I&apos;d like to fetch the inner maps, skipping the string key</z><z id="t1467996404" t="nathanmarz there&apos;s a lot of inner maps"><y>#</y><d>2016-07-08</d><h>16:46</h><w>nathanmarz</w>there&apos;s a lot of inner maps</z><z id="t1467996424" t="nathanmarz so you want the maps that have :business key?"><y>#</y><d>2016-07-08</d><h>16:47</h><w>nathanmarz</w>so you want the maps that have :business key?</z><z id="t1467996431" t="richiardiandrea you are right, skip to {:business .....}"><y>#</y><d>2016-07-08</d><h>16:47</h><w>richiardiandrea</w>you are right, skip to <code>{:business .....}</code></z><z id="t1467996444" t="richiardiandrea yes"><y>#</y><d>2016-07-08</d><h>16:47</h><w>richiardiandrea</w>yes</z><z id="t1467996470" t="nathanmarz (select [:handles MAP-VALS] data)"><y>#</y><d>2016-07-08</d><h>16:47</h><w>nathanmarz</w><code>(select [:handles MAP-VALS] data)</code></z><z id="t1467996497" t="nathanmarz can also do (select [:handles ALL LAST] data) but the former is more efficient"><y>#</y><d>2016-07-08</d><h>16:48</h><w>nathanmarz</w>can also do <code>(select [:handles ALL LAST] data)</code> but the former is more efficient</z><z id="t1467996535" t="richiardiandrea oh cool, yes it works, so I needed no ALL in my code above..."><y>#</y><d>2016-07-08</d><h>16:48</h><w>richiardiandrea</w>oh cool, yes it works, so I needed no <code>ALL</code> in my code above...</z><z id="t1467996602" t="richiardiandrea I so like the fact that you can transform in one go all the things you need to...thanks a lot for the help and the lib"><y>#</y><d>2016-07-08</d><h>16:50</h><w>richiardiandrea</w>I so like the fact that you can transform in one go all the things you need to...thanks a lot for the help and the lib</z><z id="t1467996611" t="nathanmarz sure thing"><y>#</y><d>2016-07-08</d><h>16:50</h><w>nathanmarz</w>sure thing</z><z id="t1467996919" t="richiardiandrea don&apos;t want to take too much of your time as I can check the samples, but I saw that you can collect data while you descend the data structure, in my case it would be really handy to carry the {&quot;booma&quot; {...} &quot;my-handle&quot; {...}} map in the transform ...is it feasible with collect ?"><y>#</y><d>2016-07-08</d><h>16:55</h><w>richiardiandrea</w>don&apos;t want to take too much of your time as I can check the samples, but I saw that you can collect data while you descend the data structure, in my case it would be really handy to carry the <code>{&quot;booma&quot; {...} &quot;my-handle&quot; {...}}</code> map in the <code>transform</code>...is it feasible with <code>collect</code>?</z><z id="t1467996981" t="nathanmarz yes"><y>#</y><d>2016-07-08</d><h>16:56</h><w>nathanmarz</w>yes</z><z id="t1467996991" t="richiardiandrea tnx"><y>#</y><d>2016-07-08</d><h>16:56</h><w>richiardiandrea</w>tnx</z><z id="t1467997000" t="nathanmarz (transform [:handles VAL MAP-VALS ] ..."><y>#</y><d>2016-07-08</d><h>16:56</h><w>nathanmarz</w><code>(transform [:handles VAL MAP-VALS ] ...</code></z><z id="t1467997010" t="richiardiandrea oh cool awesome"><y>#</y><d>2016-07-08</d><h>16:56</h><w>richiardiandrea</w>oh cool awesome</z><z id="t1467997014" t="nathanmarz VAL is same as (collect-one STAY)"><y>#</y><d>2016-07-08</d><h>16:56</h><w>nathanmarz</w><code>VAL</code> is same as <code>(collect-one STAY)</code></z><z id="t1467997034" t="richiardiandrea perfect that is exactly what I need 😉"><y>#</y><d>2016-07-08</d><h>16:57</h><w>richiardiandrea</w>perfect that is exactly what I need <b>😉</b></z><z id="t1467998455" t="richiardiandrea my first specter transformation 🙂 (defn deregister-uid [state uid] (-&gt;&gt; state (spm/transform (sp/multi-path :uids [:handles sp/MAP-VALS :sente-uids] [:businesses sp/MAP-VALS :sente-uids]) #(cond (map? %) (dissoc % uid) (vector? %) (vec (remove #{uid} %)) :else %)))) "><y>#</y><d>2016-07-08</d><h>17:20</h><w>richiardiandrea</w>my first specter transformation <b>🙂</b>
<pre>(defn deregister-uid [state uid]
  (-&gt;&gt; state
       (spm/transform (sp/multi-path :uids
                                     [:handles sp/MAP-VALS :sente-uids]
                                     [:businesses sp/MAP-VALS :sente-uids])
                      #(cond
                         (map? %) (dissoc % uid)
                         (vector? %) (vec (remove #{uid} %))
                         :else %))))
</pre></z><z id="t1468510566" t="peeja How would I select every other element in a vector (that is, every element whose index is even)?"><y>#</y><d>2016-07-14</d><h>15:36</h><w>peeja</w>How would I select every other element in a vector (that is, every element whose index is even)?</z><z id="t1468510912" t="nathanmarz I believe you would need to define a new navigator for that"><y>#</y><d>2016-07-14</d><h>15:41</h><w>nathanmarz</w>I believe you would need to define a new navigator for that</z><z id="t1468510957" t="nathanmarz one idea would be something like this: (select [(all-partitioned 2) LAST] data)"><y>#</y><d>2016-07-14</d><h>15:42</h><w>nathanmarz</w>one idea would be something like this: <code>(select [(all-partitioned 2) LAST] data)</code></z><z id="t1468511000" t="nathanmarz where all-partitioned works like partition and navigates you to each pair"><y>#</y><d>2016-07-14</d><h>15:43</h><w>nathanmarz</w>where <code>all-partitioned</code> works like <code>partition</code> and navigates you to each pair</z><z id="t1468511075" t="nathanmarz or you could have an even more specific navigator called something like every-nth"><y>#</y><d>2016-07-14</d><h>15:44</h><w>nathanmarz</w>or you could have an even more specific navigator called something like <code>every-nth</code></z><z id="t1468511156" t="peeja Cheers!"><y>#</y><d>2016-07-14</d><h>15:45</h><w>peeja</w>Cheers!</z><z id="t1468536137" t="spieden i’m getting a lot of mileage out of specter — thanks for releasing it 😃"><y>#</y><d>2016-07-14</d><h>22:42</h><w>spieden</w>i’m getting a lot of mileage out of specter — thanks for releasing it <b>😃</b></z><z id="t1468537724" t="nathanmarz @spieden: you&apos;re welcome"><y>#</y><d>2016-07-14</d><h>23:08</h><w>nathanmarz</w>@spieden: you&apos;re welcome</z><z id="t1468585252" t="rui.yang Hi, wonder if specter could do the following:"><y>#</y><d>2016-07-15</d><h>12:20</h><w>rui.yang</w>Hi, wonder if specter could do the following:</z><z id="t1468585295" t="rui.yang combine the element in the following list based on item_id: [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;} {:id -2, :item_id &quot;1&quot;, :quantity &quot;2”} {:id -3, :item_id “1”, :quantity “3&quot;]"><y>#</y><d>2016-07-15</d><h>12:21</h><w>rui.yang</w>combine the element in the following list based on item_id:  [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;} {:id -2, :item_id &quot;1&quot;, :quantity &quot;2”} {:id -3, :item_id “1”, :quantity “3&quot;]</z><z id="t1468585318" t="rui.yang it will be transform to [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;} {:id -2, :item_id &quot;1&quot;, :quantity “5”}]"><y>#</y><d>2016-07-15</d><h>12:21</h><w>rui.yang</w>it will be transform to [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;} {:id -2, :item_id &quot;1&quot;, :quantity “5”}]</z><z id="t1468585344" t="rui.yang or what is the best way of doing it in clojure?"><y>#</y><d>2016-07-15</d><h>12:22</h><w>rui.yang</w>or what is the best way of doing it in clojure?</z><z id="t1468586249" t="codonnell @rui.yang: I don&apos;t think this is something that you particularly need specter for. You should be able to accumulate your result using reduce."><y>#</y><d>2016-07-15</d><h>12:37</h><w>codonnell</w>@rui.yang: I don&apos;t think this is something that you particularly need specter for. You should be able to accumulate your result using reduce.</z><z id="t1468586549" t="rui.yang @codonnell: thanks for the tips"><y>#</y><d>2016-07-15</d><h>12:42</h><w>rui.yang</w>@codonnell: thanks for the tips</z><z id="t1468586599" t="rui.yang seems a good usage for reduce, I didn’t think of it 🙂"><y>#</y><d>2016-07-15</d><h>12:43</h><w>rui.yang</w>seems a good usage for reduce, I didn’t think of it <b>🙂</b></z><z id="t1468586635" t="codonnell If you want, you could omit the vals and leave the result as a map of items, keyed by item_id"><y>#</y><d>2016-07-15</d><h>12:43</h><w>codonnell</w>If you want, you could omit the <code>vals</code> and leave the result as a map of items, keyed by <code>item_id</code></z><z id="t1468586654" t="codonnell This is a more natural way to store items, in my opinion."><y>#</y><d>2016-07-15</d><h>12:44</h><w>codonnell</w>This is a more natural way to store items, in my opinion.</z><z id="t1468586924" t="rui.yang yes, but I am using that to map to a list of in UI"><y>#</y><d>2016-07-15</d><h>12:48</h><w>rui.yang</w>yes, but I am using that to map to a list of in UI</z><z id="t1468586944" t="rui.yang the id of every row in UI is actually :id key"><y>#</y><d>2016-07-15</d><h>12:49</h><w>rui.yang</w>the id of every row in UI is actually :id key</z><z id="t1468586959" t="codonnell ah, I see"><y>#</y><d>2016-07-15</d><h>12:49</h><w>codonnell</w>ah, I see</z><z id="t1468587020" t="rui.yang (def items [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;} {:id -2, :item_id &quot;1&quot;, :quantity &quot;2”} {:id -3, :item_id “1”, :quantity “3&quot;}])"><y>#</y><d>2016-07-15</d><h>12:50</h><w>rui.yang</w>(def items [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;} {:id -2, :item_id &quot;1&quot;, :quantity &quot;2”} {:id -3, :item_id “1”, :quantity “3&quot;}])</z><z id="t1468587046" t="rui.yang (reduce (fn [m {:keys [item_id quantity] :as item}] (if (contains? m item_id) (update-in m [item_id :quantity] #(+ % quantity)) (assoc m item_id item))) {} items)"><y>#</y><d>2016-07-15</d><h>12:50</h><w>rui.yang</w>(reduce (fn [m {:keys [item_id quantity] :as item}]
				(if (contains? m item_id)
					(update-in m [item_id :quantity] #(+ % quantity))
					(assoc m item_id item)))
			{}
			items)</z><z id="t1468587049" t="rui.yang gives"><y>#</y><d>2016-07-15</d><h>12:50</h><w>rui.yang</w>gives</z><z id="t1468587089" t="rui.yang {&quot;2&quot; {:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;}, &quot;1&quot; {:id -2, :item_id &quot;1&quot;, :quantity &quot;2”} {:id -3, :item_id “1”, :quantity “3&quot;}}"><y>#</y><d>2016-07-15</d><h>12:51</h><w>rui.yang</w>{&quot;2&quot; {:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;}, &quot;1&quot; {:id -2, :item_id &quot;1&quot;, :quantity &quot;2”} {:id -3, :item_id “1”, :quantity “3&quot;}}</z><z id="t1468587090" t="codonnell You need to parse the :quantity values to integers."><y>#</y><d>2016-07-15</d><h>12:51</h><w>codonnell</w>You need to parse the <code>:quantity</code> values to integers.</z><z id="t1468587109" t="rui.yang yes, I need to do that"><y>#</y><d>2016-07-15</d><h>12:51</h><w>rui.yang</w>yes, I need to do that</z><z id="t1468587113" t="rui.yang but look at that map"><y>#</y><d>2016-07-15</d><h>12:51</h><w>rui.yang</w>but look at that map</z><z id="t1468587117" t="codonnell yeah, I see"><y>#</y><d>2016-07-15</d><h>12:51</h><w>codonnell</w>yeah, I see</z><z id="t1468587119" t="codonnell that&apos;s odd"><y>#</y><d>2016-07-15</d><h>12:51</h><w>codonnell</w>that&apos;s odd</z><z id="t1468587125" t="rui.yang the value of “1” is odd"><y>#</y><d>2016-07-15</d><h>12:52</h><w>rui.yang</w>the value of “1” is odd</z><z id="t1468587166" t="rui.yang I tried in both clojure and clojurescript, same result"><y>#</y><d>2016-07-15</d><h>12:52</h><w>rui.yang</w>I tried in both clojure and clojurescript, same result</z><z id="t1468587235" t="codonnell You&apos;re using nonstandard quote characters around the quantity key in your second item, which is causing the problem, I think."><y>#</y><d>2016-07-15</d><h>12:53</h><w>codonnell</w>You&apos;re using nonstandard quote characters around the quantity key in your second item, which is causing the problem, I think.</z><z id="t1468587277" t="codonnell =&gt; (count items) 2"><y>#</y><d>2016-07-15</d><h>12:54</h><w>codonnell</w><pre>=&gt; (count items)
2</pre></z><z id="t1468587301" t="codonnell it thinks the value for :quantity in the second item is just a long string"><y>#</y><d>2016-07-15</d><h>12:55</h><w>codonnell</w>it thinks the value for <code>:quantity</code> in the second item is just a long string</z><z id="t1468587331" t="rui.yang aha"><y>#</y><d>2016-07-15</d><h>12:55</h><w>rui.yang</w>aha</z><z id="t1468587334" t="madstap Yeah, copy pasting into my emacs shows the problem in the syntax hinghlighter"><y>#</y><d>2016-07-15</d><h>12:55</h><w>madstap</w>Yeah, copy pasting into my emacs shows the problem in the syntax hinghlighter</z><z id="t1468587347" t="rui.yang yes, hard to spot"><y>#</y><d>2016-07-15</d><h>12:55</h><w>rui.yang</w>yes, hard to spot</z><z id="t1468587362" t="madstap If you fix it you&apos;ll get a class cast exception"><y>#</y><d>2016-07-15</d><h>12:56</h><w>madstap</w>If you fix it you&apos;ll get a class cast exception</z><z id="t1468587370" t="rui.yang a special quote character"><y>#</y><d>2016-07-15</d><h>12:56</h><w>rui.yang</w>a special quote character</z><z id="t1468587500" t="rui.yang thank you all, save me tons of pain @madstap @codonnell"><y>#</y><d>2016-07-15</d><h>12:58</h><w>rui.yang</w>thank you all, save me tons of pain @madstap @codonnell</z><z id="t1468587564" t="madstap I fixed it like this: (def items [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;} {:id -2, :item_id &quot;1&quot;, :quantity &quot;2&quot;} {:id -3, :item_id &quot;1&quot;, :quantity &quot;3&quot;}]) (defn str-&gt;int [s] (Integer/parseInt s)) (reduce (fn [m {:keys [item_id quantity] :as item}] (if (contains? m item_id) (update-in m [item_id :quantity] #(+ % quantity)) (assoc m item_id item))) {} (map #(update % :quantity str-&gt;int) items)) "><y>#</y><d>2016-07-15</d><h>12:59</h><w>madstap</w>I fixed it like this:
<pre>(def items [{:id -1, :item_id &quot;2&quot;, :quantity &quot;3&quot;}
            {:id -2, :item_id &quot;1&quot;, :quantity &quot;2&quot;}
            {:id -3, :item_id &quot;1&quot;, :quantity &quot;3&quot;}])

(defn str-&gt;int [s]
  (Integer/parseInt s))

(reduce (fn [m {:keys [item_id quantity] :as item}]
                (if (contains? m item_id)
                  (update-in m [item_id :quantity] #(+ % quantity))
                  (assoc m item_id item)))
            {}
            (map #(update % :quantity str-&gt;int) items))
</pre></z><z id="t1468587659" t="rui.yang it shouldn’t be string, it should be integer. but when UI form update values, somehow it is setting String. I think I should fix it there instead of fixing it in the transformation of map."><y>#</y><d>2016-07-15</d><h>13:00</h><w>rui.yang</w>it shouldn’t be string, it should be integer. but when UI form update values, somehow it is setting String. I think I should fix it there instead of fixing it in the transformation of map.</z><z id="t1468587669" t="codonnell @rui.yang: On a side note, you could use specter to parse those :quantity keys into integers, though it&apos;s pretty easy to do in core, as well. =&gt; (transform [ALL :quantity] #(Integer. %) items) [{:id -1, :item_id &quot;2&quot;, :quantity 3} {:id -2, :item_id &quot;1&quot;, :quantity 2} {:id -3, :item_id &quot;1&quot;, :quantity 3}] "><y>#</y><d>2016-07-15</d><h>13:01</h><w>codonnell</w>@rui.yang: On a side note, you could use specter to parse those <code>:quantity</code> keys into integers, though it&apos;s pretty easy to do in core, as well.
<pre>=&gt; (transform [ALL :quantity] #(Integer. %) items)
[{:id -1, :item_id &quot;2&quot;, :quantity 3} {:id -2, :item_id &quot;1&quot;, :quantity 2} {:id -3, :item_id &quot;1&quot;, :quantity 3}]
</pre></z><z id="t1468587730" t="rui.yang @codonnell: thanks for the tip"><y>#</y><d>2016-07-15</d><h>13:02</h><w>rui.yang</w>@codonnell: thanks for the tip</z><z id="t1468587749" t="codonnell no problem"><y>#</y><d>2016-07-15</d><h>13:02</h><w>codonnell</w>no problem</z><z id="t1468804652" t="richiardiandrea Hello specter folks, I get a weird error in prod and I don&apos;t know what I&apos;d causing it: Omar: No implementation of method: :get_cell of protocol: #&apos;com.rpl.specter.impl/PMutableCell found for class: clojure.lang.Var$Unbound "><y>#</y><d>2016-07-18</d><h>01:17</h><w>richiardiandrea</w>Hello specter folks, I get a weird error in prod and I don&apos;t know what I&apos;d causing it:
<pre>Omar:
No implementation of method: :get_cell of protocol: #&apos;com.rpl.specter.impl/PMutableCell found for class: clojure.lang.Var$Unbound
</pre>

</z><z id="t1468804659" t="richiardiandrea What can be the cause?"><y>#</y><d>2016-07-18</d><h>01:17</h><w>richiardiandrea</w>What can be the cause?</z><z id="t1468804768" t="codonnell @richiardiandrea: are you using 0.12.0? (see https://github.com/nathanmarz/specter/issues/132 )"><y>#</y><d>2016-07-18</d><h>01:19</h><w>codonnell</w>@richiardiandrea: are you using 0.12.0? (see <a href="https://github.com/nathanmarz/specter/issues/132" target="_blank">https://github.com/nathanmarz/specter/issues/132</a>)</z><z id="t1468804842" t="richiardiandrea Oh, it looks like my problem exactly ;)"><y>#</y><d>2016-07-18</d><h>01:20</h><w>richiardiandrea</w>Oh, it looks like my problem exactly ;)</z><z id="t1468805749" t="richiardiandrea I confirm that 0.12 fixed it, thanks @codonnell "><y>#</y><d>2016-07-18</d><h>01:35</h><w>richiardiandrea</w>I confirm that <code>0.12</code> fixed it, thanks @codonnell </z><z id="t1468805774" t="codonnell You&apos;re welcome."><y>#</y><d>2016-07-18</d><h>01:36</h><w>codonnell</w>You&apos;re welcome.</z><z id="t1468950772" t="arvind Hello"><y>#</y><d>2016-07-19</d><h>17:52</h><w>arvind</w>Hello</z><z id="t1468950780" t="arvind I cloned the specter repo from github"><y>#</y><d>2016-07-19</d><h>17:53</h><w>arvind</w>I cloned the specter repo from github</z><z id="t1468950788" t="arvind and ran &quot;lein repl&quot;"><y>#</y><d>2016-07-19</d><h>17:53</h><w>arvind</w>and ran &quot;lein repl&quot;</z><z id="t1468950819" t="arvind I downloaded a lot stuff"><y>#</y><d>2016-07-19</d><h>17:53</h><w>arvind</w>I downloaded a lot stuff</z><z id="t1468950879" t="arvind Can anyone explain what is happening? I am new to Clojure and Java."><y>#</y><d>2016-07-19</d><h>17:54</h><w>arvind</w>Can anyone explain what is happening? I am new to Clojure and Java.</z><z id="t1468950891" t="arvind Does specter have so many dependecies?"><y>#</y><d>2016-07-19</d><h>17:54</h><w>arvind</w>Does specter have so many dependecies?</z><z id="t1468951283" t="nathanmarz @arvind: those are all build/test dependencies"><y>#</y><d>2016-07-19</d><h>18:01</h><w>nathanmarz</w>@arvind: those are all build/test dependencies</z><z id="t1468951308" t="nathanmarz except for riddley, which is actually used by specter&apos;s implementation"><y>#</y><d>2016-07-19</d><h>18:01</h><w>nathanmarz</w>except for riddley, which is actually used by specter&apos;s implementation</z><z id="t1468951388" t="nathanmarz and riddley has no dependencies of its own"><y>#</y><d>2016-07-19</d><h>18:03</h><w>nathanmarz</w>and riddley has no dependencies of its own</z><z id="t1468951404" t="nathanmarz so basically specter is very lean with respect to dependencies"><y>#</y><d>2016-07-19</d><h>18:03</h><w>nathanmarz</w>so basically specter is very lean with respect to dependencies</z><z id="t1468953303" t="arvind @nathanmarz thanks"><y>#</y><d>2016-07-19</d><h>18:35</h><w>arvind</w>@nathanmarz thanks</z><z id="t1468953310" t="arvind another question"><y>#</y><d>2016-07-19</d><h>18:35</h><w>arvind</w>another question</z><z id="t1468953392" t="arvind When I run &quot;lein repl&quot; inside the specter directory and type (require &apos;com.repl.specter)"><y>#</y><d>2016-07-19</d><h>18:36</h><w>arvind</w>When I run &quot;lein repl&quot; inside the specter directory and type
(require &apos;com.repl.specter)</z><z id="t1468953415" t="arvind It says the file was not found on classpath"><y>#</y><d>2016-07-19</d><h>18:36</h><w>arvind</w>It says the file was not found on classpath</z><z id="t1468953434" t="arvind but running &quot;lein classpath&quot; shows that the src directory is in the classpath."><y>#</y><d>2016-07-19</d><h>18:37</h><w>arvind</w>but running &quot;lein classpath&quot; shows that the src directory is in the classpath.</z><z id="t1468953471" t="arvind I want to require &apos;com.repl.specter to play with the transform and select macros"><y>#</y><d>2016-07-19</d><h>18:37</h><w>arvind</w>I want to require &apos;com.repl.specter to play with the transform and select macros</z><z id="t1468953870" t="codonnell @arvind: try (require &apos;[com.rpl.specter]) . Also, the select and transform macros are in com.rpl.specter.macros ."><y>#</y><d>2016-07-19</d><h>18:44</h><w>codonnell</w>@arvind: try <code>(require &apos;[com.rpl.specter])</code>. Also, the select and transform macros are in <code>com.rpl.specter.macros</code>.</z><z id="t1468953891" t="codonnell actually, it should work not in a list"><y>#</y><d>2016-07-19</d><h>18:44</h><w>codonnell</w>actually, it should work not in a list</z><z id="t1468953926" t="codonnell oh, you added an extra e"><y>#</y><d>2016-07-19</d><h>18:45</h><w>codonnell</w>oh, you added an extra e</z><z id="t1468953936" t="codonnell com.rpl.specter , not com.repl.specter"><y>#</y><d>2016-07-19</d><h>18:45</h><w>codonnell</w><code>com.rpl.specter</code>, not <code>com.repl.specter</code></z><z id="t1468954065" t="arvind @codonnell: Please refer below:"><y>#</y><d>2016-07-19</d><h>18:47</h><w>arvind</w>@codonnell: Please refer below:</z><z id="t1468954068" t="arvind user=&gt; (require &apos;com.rpl.specter) FileNotFoundException Could not locate com/rpl/specter__init.class or com/rpl/specter.clj on classpath. clojure.lang.RT.load (RT.java:449)"><y>#</y><d>2016-07-19</d><h>18:47</h><w>arvind</w>user=&gt; (require &apos;com.rpl.specter)

FileNotFoundException Could not locate com/rpl/specter__init.class or com/rpl/specter.clj on classpath.  clojure.lang.RT.load (RT.java:449)</z><z id="t1468954212" t="arvind Also when I run (all-ns) in the repl I don&apos;t see com.rpl.specter in the list of namespaces"><y>#</y><d>2016-07-19</d><h>18:50</h><w>arvind</w>Also when I run <code>(all-ns)</code> in the repl I don&apos;t see com.rpl.specter in the list of namespaces</z><z id="t1468954409" t="codonnell @arvind: if you&apos;ve cloned specter off github, you need to run lein cljx to compile the classes."><y>#</y><d>2016-07-19</d><h>18:53</h><w>codonnell</w>@arvind: if you&apos;ve cloned specter off github, you need to run <code>lein cljx</code> to compile the classes.</z><z id="t1468954498" t="arvind @codonnell: I just ran lein cljx"><y>#</y><d>2016-07-19</d><h>18:54</h><w>arvind</w>@codonnell: I just ran <code>lein cljx</code></z><z id="t1468954512" t="arvind and then lein repl"><y>#</y><d>2016-07-19</d><h>18:55</h><w>arvind</w>and then <code>lein repl</code></z><z id="t1468954541" t="arvind and (require &apos;com.rpl.specter.macros) returned nil"><y>#</y><d>2016-07-19</d><h>18:55</h><w>arvind</w>and <code>(require &apos;com.rpl.specter.macros)</code> returned <code>nil</code></z><z id="t1468954571" t="arvind and I tried (transform) that gave the following error: CompilerException java.lang.RuntimeException: Unable to resolve symbol: transform in this context, compiling:(/tmp/form-init2526821032412369112.clj:1:1)"><y>#</y><d>2016-07-19</d><h>18:56</h><w>arvind</w>and I tried <code>(transform)</code> that gave the following error:
CompilerException java.lang.RuntimeException: Unable to resolve symbol: transform in this context, compiling:(/tmp/form-init2526821032412369112.clj:1:1)</z><z id="t1468954624" t="codonnell If you just do (require &apos;com.rpl.specter.macros) , then transform is named com.rpl.specter.macros.transform"><y>#</y><d>2016-07-19</d><h>18:57</h><w>codonnell</w>If you just do <code>(require &apos;com.rpl.specter.macros)</code>, then <code>transform</code> is named <code>com.rpl.specter.macros.transform</code></z><z id="t1468954639" t="arvind ah"><y>#</y><d>2016-07-19</d><h>18:57</h><w>arvind</w>ah</z><z id="t1468954642" t="codonnell If you want to just type transform , you need to do (require &apos;[com.rpl.specter.macros :refer [transform]])"><y>#</y><d>2016-07-19</d><h>18:57</h><w>codonnell</w>If you want to just type <code>transform</code>, you need to do <code>(require &apos;[com.rpl.specter.macros :refer [transform]])</code></z><z id="t1468954743" t="codonnell there&apos;s a nice piece about namespaces at http://www.braveclojure.com/organization/"><y>#</y><d>2016-07-19</d><h>18:59</h><w>codonnell</w>there&apos;s a nice piece about namespaces at <a href="http://www.braveclojure.com/organization/" target="_blank">http://www.braveclojure.com/organization/</a></z><z id="t1468954752" t="arvind Yeah that worked. Thanks."><y>#</y><d>2016-07-19</d><h>18:59</h><w>arvind</w>Yeah that worked. Thanks.</z><z id="t1468954772" t="codonnell If you&apos;re new to clojure, that&apos;s a great book to work through."><y>#</y><d>2016-07-19</d><h>18:59</h><w>codonnell</w>If you&apos;re new to clojure, that&apos;s a great book to work through.</z><z id="t1468954826" t="arvind @codonnell: I bought that book recently. Have to read through it."><y>#</y><d>2016-07-19</d><h>19:00</h><w>arvind</w>@codonnell: I bought that book recently. Have to read through it.</z><z id="t1468954908" t="hueyp this might be a question of me not understanding spectre … but say I’ve got a nested map that I want to transform multiple times … is it possible to save the lookup? e.g. write a generic path, but for this exact instance of the map, its a very narrow this key, the next key, run the transform, etc?"><y>#</y><d>2016-07-19</d><h>19:01</h><w>hueyp</w>this might be a question of me not understanding spectre … but say I’ve got a nested map that I want to transform multiple times … is it possible to save the lookup?  e.g. write a generic path, but for this exact instance of the map, its a very narrow this key, the next key, run the transform, etc?</z><z id="t1468954961" t="codonnell @hueyp: could you give an example of what you mean?"><y>#</y><d>2016-07-19</d><h>19:02</h><w>codonnell</w>@hueyp: could you give an example of what you mean?</z><z id="t1468955099" t="hueyp sure … {:foo {:a 1 :b 2 :c 3} :bar {:x 1 :y 2 :z 3} … something like … ALL LAST ALL LAST even? (I might have that syntax wrong …) … it would transform [:foo :b] and [:bar :y] … like if I want to double those, or subtract 1, etc … that paths are the same, so I’d like to kind of save that knowledge"><y>#</y><d>2016-07-19</d><h>19:04</h><w>hueyp</w>sure … <code>{:foo {:a 1 :b 2 :c 3} :bar {:x 1 :y 2 :z 3}</code> … something like … <code>ALL LAST ALL LAST even?</code> (I might have that syntax wrong …) … it would transform <code>[:foo :b]</code> and <code>[:bar :y]</code> … like if I want to double those, or subtract 1, etc … that paths are the same, so I’d like to kind of save that knowledge</z><z id="t1468955110" t="hueyp again … might be not something that actually matters re how spectre works 🙂"><y>#</y><d>2016-07-19</d><h>19:05</h><w>hueyp</w>again … might be not something that actually matters re how spectre works <b>🙂</b></z><z id="t1468955251" t="codonnell Sure. If you know the whole path in advance (no parameters), you could save it with (def my-map-path (comp-paths MAP-VALS MAP-VALS even?))"><y>#</y><d>2016-07-19</d><h>19:07</h><w>codonnell</w>Sure. If you know the whole path in advance (no parameters), you could save it with <code>(def my-map-path (comp-paths MAP-VALS MAP-VALS even?))</code></z><z id="t1468955273" t="codonnell (`MAP-VALS` is the same as [ALL LAST] , but more efficient"><y>#</y><d>2016-07-19</d><h>19:07</h><w>codonnell</w>(`MAP-VALS` is the same as <code>[ALL LAST]</code>, but more efficient</z><z id="t1468955288" t="hueyp that would still require a full traversal of the map though to determine what matches?"><y>#</y><d>2016-07-19</d><h>19:08</h><w>hueyp</w>that would still require a full traversal of the map though to determine what matches?</z><z id="t1468955303" t="hueyp basically I’d like to do that traversal one, and save more specific paths?"><y>#</y><d>2016-07-19</d><h>19:08</h><w>hueyp</w>basically I’d like to do that traversal one, and save more specific paths?</z><z id="t1468955353" t="codonnell it would do a traversal each time, that&apos;s right"><y>#</y><d>2016-07-19</d><h>19:09</h><w>codonnell</w>it would do a traversal each time, that&apos;s right</z><z id="t1468955354" t="hueyp this is more of a curiosity … the cost of traversing the maps I have is small … just curious if I could say turn (comp-paths MAP-VALS MAP-VALS even?) + an exact instance of a map into a more specific path"><y>#</y><d>2016-07-19</d><h>19:09</h><w>hueyp</w>this is more of a curiosity … the cost of traversing the maps I have is small … just curious if I could say turn <code>(comp-paths MAP-VALS MAP-VALS even?)</code> + an exact instance of a map into a more specific path</z><z id="t1468955386" t="hueyp and then re-use that with multiple transforms"><y>#</y><d>2016-07-19</d><h>19:09</h><w>hueyp</w>and then re-use that with multiple transforms</z><z id="t1468955395" t="hueyp all on the same starting map 😜"><y>#</y><d>2016-07-19</d><h>19:09</h><w>hueyp</w>all on the same starting map <b>😜</b></z><z id="t1468955478" t="codonnell @hueyp: you could use traverse from 0.12.0, which returns an instance of IReduceable (or something like that; basically it&apos;s only useful when being called with reduce or into )"><y>#</y><d>2016-07-19</d><h>19:11</h><w>codonnell</w>@hueyp: you could use <code>traverse</code> from 0.12.0, which returns an instance of <code>IReduceable</code> (or something like that; basically it&apos;s only useful when being called with <code>reduce</code> or <code>into</code>)</z><z id="t1468955512" t="codonnell that will only do the traversal once, and you could call reduce on it multiple times over the same initial structure"><y>#</y><d>2016-07-19</d><h>19:11</h><w>codonnell</w>that will only do the traversal once, and you could call <code>reduce</code> on it multiple times over the same initial structure</z><z id="t1468955557" t="hueyp @codonnell: interesting, I’ll take a look, thanks~"><y>#</y><d>2016-07-19</d><h>19:12</h><w>hueyp</w>@codonnell: interesting, I’ll take a look, thanks~</z><z id="t1468955570" t="codonnell https://github.com/nathanmarz/specter/wiki/List-of-Macros#traverse"><y>#</y><d>2016-07-19</d><h>19:12</h><w>codonnell</w><a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#traverse" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Macros#traverse</a></z><z id="t1468955611" t="hueyp oh wow, wiki!"><y>#</y><d>2016-07-19</d><h>19:13</h><w>hueyp</w>oh wow, wiki!</z><z id="t1468955652" t="nathanmarz @hueyp: I think you might be looking for a locate feature https://github.com/nathanmarz/specter/issues/49"><y>#</y><d>2016-07-19</d><h>19:14</h><w>nathanmarz</w>@hueyp: I think you might be looking for a <code>locate</code> feature <a href="https://github.com/nathanmarz/specter/issues/49" target="_blank">https://github.com/nathanmarz/specter/issues/49</a></z><z id="t1468955787" t="hueyp wow, yup!"><y>#</y><d>2016-07-19</d><h>19:16</h><w>hueyp</w>wow, yup!</z><z id="t1469063239" t="ghadi just had a thought… specter is vim navigation commands for datastructures"><y>#</y><d>2016-07-21</d><h>01:07</h><w>ghadi</w>just had a thought… specter is vim navigation commands for datastructures</z><z id="t1469110138" t="nathanmarz @ghadi: don&apos;t know vim, care to elaborate?"><y>#</y><d>2016-07-21</d><h>14:08</h><w>nathanmarz</w>@ghadi: don&apos;t know vim, care to elaborate?</z><z id="t1469110196" t="ghadi sure, mutation commands for text are usually preceded by giving a direction. ex:"><y>#</y><d>2016-07-21</d><h>14:09</h><w>ghadi</w>sure, mutation commands for text are usually preceded by giving a direction. ex:</z><z id="t1469110317" t="ghadi or succeeded in this case: d$ means delete from current position to the end of the line dfi means delete from current position to the first i character to the right d4k means delete 4 lines upwards"><y>#</y><d>2016-07-21</d><h>14:11</h><w>ghadi</w>or succeeded in this case:
<code>d$</code>  means delete from current position to the end of the line
<code>dfi</code> means delete from current position to the first <code>i</code> character to the right
<code>d4k</code>  means delete 4 lines upwards</z><z id="t1469110334" t="ghadi and then you have fancy stuff like this, which reminds me of transform ALL:"><y>#</y><d>2016-07-21</d><h>14:12</h><w>ghadi</w>and then you have fancy stuff like this, which reminds me of transform ALL:</z><z id="t1469110348" t="ghadi http://vimgifs.com/"><y>#</y><d>2016-07-21</d><h>14:12</h><w>ghadi</w><a href="http://vimgifs.com/" target="_blank">http://vimgifs.com/</a></z><z id="t1469110376" t="ghadi basically a functor"><y>#</y><d>2016-07-21</d><h>14:12</h><w>ghadi</w>basically a functor</z><z id="t1469110427" t="nathanmarz oh wow, cool"><y>#</y><d>2016-07-21</d><h>14:13</h><w>nathanmarz</w>oh wow, cool</z><z id="t1469110435" t="ghadi in text your navigation commands are 2D. in datastructures, your navigation is structural"><y>#</y><d>2016-07-21</d><h>14:13</h><w>ghadi</w>in text your navigation commands are 2D. in datastructures, your navigation is structural</z><z id="t1469110492" t="ghadi there’s a parallel for sure"><y>#</y><d>2016-07-21</d><h>14:14</h><w>ghadi</w>there’s a parallel for sure</z><z id="t1469110534" t="nathanmarz definitely"><y>#</y><d>2016-07-21</d><h>14:15</h><w>nathanmarz</w>definitely</z><z id="t1469110567" t="nathanmarz the more tangible metaphors to explain specter the better 🙂"><y>#</y><d>2016-07-21</d><h>14:16</h><w>nathanmarz</w>the more tangible metaphors to explain specter the better <b>🙂</b></z><z id="t1469211928" t="arvind I want to learn about specter implementation."><y>#</y><d>2016-07-22</d><h>18:25</h><w>arvind</w>I want to learn about specter implementation.</z><z id="t1469211939" t="arvind One approach"><y>#</y><d>2016-07-22</d><h>18:25</h><w>arvind</w>One approach</z><z id="t1469211970" t="arvind is to build my own specter by studying its API"><y>#</y><d>2016-07-22</d><h>18:26</h><w>arvind</w>is to build my own specter by studying its API</z><z id="t1469212011" t="arvind For this I created a new lein app like lein new app build-specter"><y>#</y><d>2016-07-22</d><h>18:26</h><w>arvind</w>For this I created a new lein app like <code>lein new app build-specter</code></z><z id="t1469212073" t="arvind then created a checkouts directory within build-specter and created a link specter within checkouts directory like below:"><y>#</y><d>2016-07-22</d><h>18:27</h><w>arvind</w>then created a <code>checkouts</code> directory within <code>build-specter</code> and created a link <code>specter</code> within checkouts directory like below:</z><z id="t1469212108" t="arvind ln -s /home/user/clojure/specter specter"><y>#</y><d>2016-07-22</d><h>18:28</h><w>arvind</w><code>ln -s /home/user/clojure/specter specter</code></z><z id="t1469212144" t="arvind Then I ran lein repl from build-specter directory"><y>#</y><d>2016-07-22</d><h>18:29</h><w>arvind</w>Then I ran <code>lein repl</code> from build-specter directory</z><z id="t1469212180" t="arvind Then attempted to require specter: build-specter.core=&gt; (require &apos;com.rpl.specter)"><y>#</y><d>2016-07-22</d><h>18:29</h><w>arvind</w>Then attempted to require specter:
<code>build-specter.core=&gt; (require &apos;com.rpl.specter)</code></z><z id="t1469212195" t="arvind But this gave the below error: CompilerException java.io.FileNotFoundException: Could not locate riddley/walk__init.class or riddley/walk.clj on classpath., compiling:(com/rpl/specter/impl.clj:1:1)"><y>#</y><d>2016-07-22</d><h>18:29</h><w>arvind</w>But this gave the below error:
CompilerException java.io.FileNotFoundException: Could not locate riddley/walk__init.class or riddley/walk.clj on classpath., compiling:(com/rpl/specter/impl.clj:1:1)</z><z id="t1469212222" t="arvind How do I include the checkouts dependencies"><y>#</y><d>2016-07-22</d><h>18:30</h><w>arvind</w>How do I include the checkouts dependencies</z><z id="t1469212728" t="arvind Because specter depends on riddley"><y>#</y><d>2016-07-22</d><h>18:38</h><w>arvind</w>Because specter depends on riddley</z><z id="t1469214191" t="arvind I figured it out. Ran lein install in the specter directory and added specter as a dependency in build-specter&apos;s project.clj"><y>#</y><d>2016-07-22</d><h>19:03</h><w>arvind</w>I figured it out. Ran <code>lein install</code> in the specter directory and added specter as a dependency in build-specter&apos;s project.clj</z><z id="t1469324268" t="rui.yang hi, still new to specter, wonder if specter could do the following"><y>#</y><d>2016-07-24</d><h>01:37</h><w>rui.yang</w>hi, still new to specter, wonder if specter could do the following</z><z id="t1469324271" t="rui.yang the map"><y>#</y><d>2016-07-24</d><h>01:37</h><w>rui.yang</w>the map</z><z id="t1469324273" t="rui.yang {:model {:validaton {:name {:msg &quot;too long&quot;}} {:age {:msg &quot;too young&quot;}}}}"><y>#</y><d>2016-07-24</d><h>01:37</h><w>rui.yang</w>{:model
 {:validaton
  {:name
   {:msg &quot;too long&quot;}}
  {:age
   {:msg &quot;too young&quot;}}}}</z><z id="t1469324315" t="rui.yang How could reset all :msg to nil? (elegantly with specter)"><y>#</y><d>2016-07-24</d><h>01:38</h><w>rui.yang</w>How could reset all :msg to nil? (elegantly with specter)</z><z id="t1469324336" t="rui.yang 🙂"><y>#</y><d>2016-07-24</d><h>01:38</h><w>rui.yang</w><b>🙂</b></z><z id="t1469326867" t="jjunior130 and I renamed :validaton to :validation"><y>#</y><d>2016-07-24</d><h>02:21</h><w>jjunior130</w>and I renamed <code>:validaton</code> to <code>:validation</code></z><z id="t1469326888" t="jjunior130 I don&apos;t know about elegance but I tried"><y>#</y><d>2016-07-24</d><h>02:21</h><w>jjunior130</w>I don&apos;t know about elegance but I tried</z><z id="t1469326966" t="jjunior130 and I didn&apos;t evaluate it. So idk if it&apos;s good."><y>#</y><d>2016-07-24</d><h>02:22</h><w>jjunior130</w>and I didn&apos;t evaluate it. So idk if it&apos;s good.</z><z id="t1469333880" t="rui.yang @jjunior130: thanks for pointing me to MAP-VALS. I used (setval [:model :validation specter/MAP-VALS :msg] nil db) to set all :msg key based on old structure. and it worked. Thanks again 🙂"><y>#</y><d>2016-07-24</d><h>04:18</h><w>rui.yang</w>@jjunior130: thanks for pointing me to MAP-VALS. I used (setval [:model :validation specter/MAP-VALS :msg] nil db) to set all :msg key based on old structure. and it worked. Thanks again <b>🙂</b></z><z id="t1469337879" t="jjunior130 @rui.yang: glad I was of help. Format your text for easy reading. https://get.slack.help/hc/en-us/articles/202288908-Formatting-your-messages"><y>#</y><d>2016-07-24</d><h>05:24</h><w>jjunior130</w>@rui.yang: glad I was of help. 
Format your text for easy reading. <a href="https://get.slack.help/hc/en-us/articles/202288908-Formatting-your-messages" target="_blank">https://get.slack.help/hc/en-us/articles/202288908-Formatting-your-messages</a></z><z id="t1469711939" t="shader how do you do a recursive traversal? I want to create a transform for all of the handlers in a bidi routing structure. This requires getting all of the &apos;leaves&apos; of a nested table/vector structure, where &apos;leaf&apos; is basically a map-val that is a keyword"><y>#</y><d>2016-07-28</d><h>13:18</h><w>shader</w>how do you do a recursive traversal? I want to create a transform for all of the handlers in a bidi routing structure. This requires getting all of the &apos;leaves&apos; of a nested table/vector structure, where &apos;leaf&apos; is basically a map-val that is a keyword</z><z id="t1469711974" t="shader the problem is that the leaves are at variable and unbounded depths in the tree"><y>#</y><d>2016-07-28</d><h>13:19</h><w>shader</w>the problem is that the leaves are at variable and unbounded depths in the tree</z><z id="t1469712577" t="codonnell @shader: The easiest way is to use walker , though sometimes you need to define a custom navigator."><y>#</y><d>2016-07-28</d><h>13:29</h><w>codonnell</w>@shader: The easiest way is to use <code>walker</code>, though sometimes you need to define a custom navigator.</z><z id="t1469712670" t="codonnell Another option would be to use the zipper navigators, though I haven&apos;t played with those personally."><y>#</y><d>2016-07-28</d><h>13:31</h><w>codonnell</w>Another option would be to use the zipper navigators, though I haven&apos;t played with those personally.</z><z id="t1469712735" t="shader I&apos;ve tried walker, but I don&apos;t really know how to use it I guess"><y>#</y><d>2016-07-28</d><h>13:32</h><w>shader</w>I&apos;ve tried walker, but I don&apos;t really know how to use it I guess</z><z id="t1469712750" t="shader I don&apos;t know how to select for &quot;only keywords that are values of maps&quot;"><y>#</y><d>2016-07-28</d><h>13:32</h><w>shader</w>I don&apos;t know how to select for &quot;only keywords that are values of maps&quot;</z><z id="t1469712795" t="codonnell Could you give an example of what you&apos;re trying to do? I&apos;m not familiar with bidi routing structures."><y>#</y><d>2016-07-28</d><h>13:33</h><w>codonnell</w>Could you give an example of what you&apos;re trying to do? I&apos;m not familiar with bidi routing structures.</z><z id="t1469712934" t="shader I&apos;d like to get all all of :trials-list, :trial-details, etc., without getting the :id keywords in the vectors (those define url parameters, not handlers)"><y>#</y><d>2016-07-28</d><h>13:35</h><w>shader</w>I&apos;d like to get all all of :trials-list, :trial-details, etc., without getting the :id keywords in the vectors (those define url parameters, not handlers)</z><z id="t1469713036" t="codonnell So if you were traversing that data structure, you&apos;d want to get a vector [:trials-list :trial-details :records-list :record-details :authorized-trials :revoke :messages :delete-message] ?"><y>#</y><d>2016-07-28</d><h>13:37</h><w>codonnell</w>So if you were traversing that data structure, you&apos;d want to get a vector <code>[:trials-list :trial-details :records-list :record-details :authorized-trials :revoke :messages :delete-message]</code>?</z><z id="t1469713100" t="shader yes"><y>#</y><d>2016-07-28</d><h>13:38</h><w>shader</w>yes</z><z id="t1469713129" t="shader well, specifically a view I can pass to transform to replace them with an actual handler function"><y>#</y><d>2016-07-28</d><h>13:38</h><w>shader</w>well, specifically a view I can pass to transform to replace them with an actual handler function</z><z id="t1469713866" t="codonnell should be able to do it with declarepath and providepath"><y>#</y><d>2016-07-28</d><h>13:51</h><w>codonnell</w>should be able to do it with <code>declarepath</code> and <code>providepath</code></z><z id="t1469713998" t="codonnell there we go"><y>#</y><d>2016-07-28</d><h>13:53</h><w>codonnell</w>there we go</z><z id="t1469714060" t="codonnell =&gt; (declarepath DEEP-MAP-VALS) =&gt; (providepath DEEP-MAP-VALS (sp/if-path map? [sp/MAP-VALS DEEP-MAP-VALS] sp/STAY)) =&gt; (select DEEP-MAP-VALS {:a {:b 2} :c {:d 3 :e {:f 4}} :g 5}) [2 3 4 5] =&gt; (transform DEEP-MAP-VALS inc {:a {:b 2} :c {:d 3 :e {:f 4}} :g 5}) {:a {:b 3}, :c {:d 4, :e {:f 5}}, :g 6} "><y>#</y><d>2016-07-28</d><h>13:54</h><w>codonnell</w><pre>=&gt; (declarepath DEEP-MAP-VALS)
=&gt; (providepath DEEP-MAP-VALS (sp/if-path map? [sp/MAP-VALS DEEP-MAP-VALS] sp/STAY))
=&gt; (select DEEP-MAP-VALS {:a {:b 2} :c {:d 3 :e {:f 4}} :g 5})
[2 3 4 5]
=&gt; (transform DEEP-MAP-VALS inc {:a {:b 2} :c {:d 3 :e {:f 4}} :g 5})
{:a {:b 3}, :c {:d 4, :e {:f 5}}, :g 6}
</pre></z><z id="t1469714086" t="shader interesting"><y>#</y><d>2016-07-28</d><h>13:54</h><w>shader</w>interesting</z><z id="t1469714108" t="codonnell dammit, keep hitting enter instead of ctrl + enter"><y>#</y><d>2016-07-28</d><h>13:55</h><w>codonnell</w>dammit, keep hitting enter instead of ctrl + enter</z><z id="t1469714126" t="codonnell there"><y>#</y><d>2016-07-28</d><h>13:55</h><w>codonnell</w>there</z><z id="t1469714576" t="shader @codonnell: thanks, that helped a lot. My final implementation is: (providepath DEEP-MAP-VALS (cond-path map? [MAP-VALS DEEP-MAP-VALS] vector? [LAST DEEP-MAP-VALS] :default STAY))"><y>#</y><d>2016-07-28</d><h>14:02</h><w>shader</w>@codonnell: thanks, that helped a lot. My final implementation is:
<pre>(providepath DEEP-MAP-VALS (cond-path map? [MAP-VALS DEEP-MAP-VALS] vector? [LAST DEEP-MAP-VALS] :default STAY))</pre></z><z id="t1469714598" t="codonnell nice"><y>#</y><d>2016-07-28</d><h>14:03</h><w>codonnell</w>nice</z><z id="t1469715258" t="codonnell @nathanmarz: I added DEEP-MAP-VALS as an example to my copy of the wiki, since people ask about recursive navigators pretty often."><y>#</y><d>2016-07-28</d><h>14:14</h><w>codonnell</w>@nathanmarz: I added <code>DEEP-MAP-VALS</code> as an example to my copy of the wiki, since people ask about recursive navigators pretty often.</z><z id="t1469732539" t="nathanmarz @codonnell: good idea, merged it in"><y>#</y><d>2016-07-28</d><h>19:02</h><w>nathanmarz</w>@codonnell: good idea, merged it in</z><z id="t1469735158" t="kenny I&apos;m not sure I fully understand how to do a recursive transform. I want to change the value of the key :changeme to negative its current value. This should be done for every nested map inside the structure, including all maps inside a sequential collection. It seems like this would be super simple to do in specter but I am guessing I don&apos;t fully understand the way recursion works in specter. Here is what I wrote: (rsm/declarepath MapWalker) (rsm/providepath MapWalker (rs/cond-path vector? [rs/ALL MapWalker] map? [rs/MAP-VALS coll? MapWalker])) (rsm/transform [MapWalker :changeme] #(- %) {:changeme 1 :ignore-this &quot;&quot; :foo2 {:changeme 2 :bar2 &quot;something&quot;} :foo3 [{:changeme 3} {:changeme 3 :ignore-this &quot;&quot;}]}) Expected output: {:changeme -1 :ignore-this &quot;&quot; :foo2 {:changeme -2 :bar2 &quot;something&quot;} :foo3 [{:changeme -3} {:changeme -3 :ignore-this &quot;&quot;}]} Any help?"><y>#</y><d>2016-07-28</d><h>19:45</h><w>kenny</w>I&apos;m not sure I fully understand how to do a recursive transform. I want to change the value of the key <code>:changeme</code> to negative its current value. This should be done for every nested map inside the structure, including all maps inside a sequential collection. It seems like this would be super simple to do in specter but I am guessing I don&apos;t fully understand the way recursion works in specter. Here is what I wrote: 
<pre>(rsm/declarepath MapWalker)
(rsm/providepath MapWalker
                 (rs/cond-path
                   vector?
                   [rs/ALL MapWalker]
                   map?
                   [rs/MAP-VALS coll? MapWalker]))

(rsm/transform [MapWalker :changeme]
               #(- %)
               {:changeme    1
                :ignore-this &quot;&quot;
                :foo2        {:changeme 2
                              :bar2     &quot;something&quot;}
                :foo3        [{:changeme 3}
                              {:changeme    3
                               :ignore-this &quot;&quot;}]})
</pre>
Expected output:
<pre>{:changeme    -1
 :ignore-this &quot;&quot;
 :foo2        {:changeme -2
               :bar2     &quot;something&quot;}
 :foo3        [{:changeme -3}
               {:changeme    -3
                :ignore-this &quot;&quot;}]}
</pre>
Any help?</z><z id="t1469736129" t="nathanmarz @kenny: easiest is to use walker"><y>#</y><d>2016-07-28</d><h>20:02</h><w>nathanmarz</w>@kenny: easiest is to use <code>walker</code></z><z id="t1469736134" t="nathanmarz (declarepath MapWalker) (providepath MapWalker (stay-then-continue MAP-VALS (walker map?) MapWalker )) "><y>#</y><d>2016-07-28</d><h>20:02</h><w>nathanmarz</w><pre>(declarepath MapWalker)
(providepath MapWalker
  (stay-then-continue
    MAP-VALS
    (walker map?)
    MapWalker
    ))
</pre></z><z id="t1469736352" t="kenny That works. Why does the code I sent not work? It reads like it should work 😛"><y>#</y><d>2016-07-28</d><h>20:05</h><w>kenny</w>That works. Why does the code I sent not work? It reads like it should work <b>😛</b></z><z id="t1469736413" t="nathanmarz @kenny: you can modify it like this to make it work"><y>#</y><d>2016-07-28</d><h>20:06</h><w>nathanmarz</w>@kenny: you can modify it like this to make it work</z><z id="t1469736416" t="nathanmarz (declarepath MapWalker) (providepath MapWalker (cond-path vector? [ALL MapWalker] map? (stay-then-continue MAP-VALS MapWalker))) "><y>#</y><d>2016-07-28</d><h>20:06</h><w>nathanmarz</w><pre>(declarepath MapWalker)
(providepath MapWalker
   (cond-path
     vector?
     [ALL MapWalker]
     map?
     (stay-then-continue MAP-VALS MapWalker)))
</pre></z><z id="t1469736473" t="codonnell @kenny: I think the problem is you&apos;re not actually navigating to anything. You navigate deeper when you encounter a vector or a map, but you stop navigation when you encounter anything else, rather than staying there."><y>#</y><d>2016-07-28</d><h>20:07</h><w>codonnell</w>@kenny: I think the problem is you&apos;re not actually navigating to anything. You navigate deeper when you encounter a vector or a map, but you stop navigation when you encounter anything else, rather than staying there.</z><z id="t1469736508" t="kenny Ah, and stay-then-continue solves that problem"><y>#</y><d>2016-07-28</d><h>20:08</h><w>kenny</w>Ah, and <code>stay-then-continue</code> solves that problem</z><z id="t1469736517" t="codonnell Indeed"><y>#</y><d>2016-07-28</d><h>20:08</h><w>codonnell</w>Indeed</z><z id="t1469736564" t="codonnell Though as @nathanmarz neatly solved for your use case, you want to stay at each map, since you want to grab its value for :changeme"><y>#</y><d>2016-07-28</d><h>20:09</h><w>codonnell</w>Though as @nathanmarz neatly solved for your use case, you want to stay at each map, since you want to grab its value for <code>:changeme</code></z><z id="t1469736621" t="kenny Agreed, I definitely like @nathanmarz solution much better."><y>#</y><d>2016-07-28</d><h>20:10</h><w>kenny</w>Agreed, I definitely like @nathanmarz solution much better.</z><z id="t1469736822" t="kenny In this case I guess the equivalent Clojure code wouldn&apos;t be all that bad to maintain anyways as I could have just used clojure.walk."><y>#</y><d>2016-07-28</d><h>20:13</h><w>kenny</w>In this case I guess the equivalent Clojure code wouldn&apos;t be all that bad to maintain anyways as I could have just used clojure.walk.</z><z id="t1469737013" t="nathanmarz another thing to note is the second solution is significantly faster than using walker or clojure.walk manually"><y>#</y><d>2016-07-28</d><h>20:16</h><w>nathanmarz</w>another thing to note is the second solution is significantly faster than using <code>walker</code> or clojure.walk manually</z><z id="t1469737210" t="kenny Good to know 🙂"><y>#</y><d>2016-07-28</d><h>20:20</h><w>kenny</w>Good to know <b>🙂</b></z><z id="t1469737314" t="kenny It is interesting that each approach you take in Clojure has an &quot;equivalent&quot; approach in specter -- clojure.walk is to walker as manually writing a recursive function is to cond-path."><y>#</y><d>2016-07-28</d><h>20:21</h><w>kenny</w>It is interesting that each approach you take in Clojure has an &quot;equivalent&quot; approach in specter -- clojure.walk is to walker as manually writing a recursive function is to cond-path.</z><z id="t1469737382" t="nathanmarz the nature of abstraction I think"><y>#</y><d>2016-07-28</d><h>20:23</h><w>nathanmarz</w>the nature of abstraction I think</z><z id="t1469737395" t="nathanmarz like how every clojure function could be written manually in bytecode"><y>#</y><d>2016-07-28</d><h>20:23</h><w>nathanmarz</w>like how every clojure function could be written manually in bytecode</z><z id="t1469737640" t="kenny Or rather.. &gt; the nature of a good abstraction"><y>#</y><d>2016-07-28</d><h>20:27</h><w>kenny</w>Or rather.. 
&gt; the nature of a good abstraction</z><z id="t1469739238" t="richiardiandrea Oh I think this declarepath feature is what I was looking for as well for recursive navigation...I notice that in case of unexpected nil sometimes on the path I am navigating, an exception is thrown...still need to investigate so I will come up with a better test case to submit here"><y>#</y><d>2016-07-28</d><h>20:53</h><w>richiardiandrea</w>Oh I think this declarepath feature is what I was looking for as well for recursive navigation...I notice that in case of unexpected nil sometimes on the path I am navigating, an exception is thrown...still need to investigate so I will come up with a better test case to submit here</z><z id="t1469834891" t="wei trying to walk a nested structure and add a sequential index to all the maps. would this be a good use case for specter? e.g. [[{} {}] [{} {} [{}]]] =&gt; [[{:id 1} {:id 2}] [{:id 3} {:id 4} [{:id 5}]]] (x-posted from #C03S1KBA2)"><y>#</y><d>2016-07-29</d><h>23:28</h><w>wei</w>trying to walk a nested structure and add a sequential index to all the maps. would this be a good use case for specter? e.g. <code>[[{} {}] [{} {} [{}]]] =&gt; [[{:id 1} {:id 2}] [{:id 3} {:id 4} [{:id 5}]]]</code> (x-posted from #C03S1KBA2)</z><z id="t1469845298" t="wei I came up with this: (defn walk-with-index [m f] (let [counter (atom -1)] (com.rpl.specter.macros/transform [(com.rpl.specter/walker map?)] #(f (swap! counter inc) %) m)))"><y>#</y><d>2016-07-30</d><h>02:21</h><w>wei</w>I came up with this:
<pre>(defn walk-with-index [m f]
  (let [counter (atom -1)]
    (com.rpl.specter.macros/transform [(com.rpl.specter/walker map?)]
                                      #(f (swap! counter inc) %) m)))</pre></z><z id="t1469845331" t="wei there’s definitely a better way to do it, looking forward to any feedback 🙂"><y>#</y><d>2016-07-30</d><h>02:22</h><w>wei</w>there’s definitely a better way to do it, looking forward to any feedback <b>🙂</b></z><z id="t1469847731" t="codonnell @wei: here&apos;s a stateless solution: (transform (subselect (walker map?)) (partial map #(assoc %2 :id %1) (range)) [[{} {}] {} {}]) [[{:id 0} {:id 1}] {:id 2} {:id 3}]"><y>#</y><d>2016-07-30</d><h>03:02</h><w>codonnell</w>@wei: here&apos;s a stateless solution:
<pre>(transform (subselect (walker map?)) (partial map #(assoc %2 :id %1) (range)) [[{} {}] {} {}])
[[{:id 0} {:id 1}] {:id 2} {:id 3}]</pre></z><z id="t1469847814" t="codonnell no idea how that compares to your atom solution in terms of efficiency, though"><y>#</y><d>2016-07-30</d><h>03:03</h><w>codonnell</w>no idea how that compares to your atom solution in terms of efficiency, though</z><z id="t1469848133" t="wei @codonnell: looks better though, thanks!"><y>#</y><d>2016-07-30</d><h>03:08</h><w>wei</w>@codonnell: looks better though, thanks!</z><z id="t1469848170" t="codonnell no problem"><y>#</y><d>2016-07-30</d><h>03:09</h><w>codonnell</w>no problem</z><z id="t1469858969" t="nathanmarz @wei @codonnell: this solution is even more concise: (setval (subselect (walker map?) :id) (range) [[{} {}] [{} {} [{}]]]) ;; =&gt; [[{:id 0} {:id 1}] [{:id 2} {:id 3} [{:id 4}]]] "><y>#</y><d>2016-07-30</d><h>06:09</h><w>nathanmarz</w>@wei @codonnell: this solution is even more concise:
<pre>(setval (subselect (walker map?) :id)
  (range)
  [[{} {}] [{} {} [{}]]])
;; =&gt; [[{:id 0} {:id 1}] [{:id 2} {:id 3} [{:id 4}]]]
</pre></z><z id="t1469885875" t="codonnell very nice"><y>#</y><d>2016-07-30</d><h>13:37</h><w>codonnell</w>very nice</z><z id="t1469890516" t="codonnell @nathanmarz: Just checked out multi-transform, terminal, and terminal-val and added them to the wiki."><y>#</y><d>2016-07-30</d><h>14:55</h><w>codonnell</w>@nathanmarz: Just checked out multi-transform, terminal, and terminal-val and added them to the wiki.</z><z id="t1469972895" t="luxbock I&apos;d like to use MAP-VALS but ignore one specific key in the passed in map"><y>#</y><d>2016-07-31</d><h>13:48</h><w>luxbock</w>I&apos;d like to use <code>MAP-VALS</code> but ignore one specific key in the passed in map</z><z id="t1469972900" t="luxbock how would I do this?"><y>#</y><d>2016-07-31</d><h>13:48</h><w>luxbock</w>how would I do this?</z><z id="t1469973948" t="codonnell @luxbock: If you don&apos;t need to rebuild, you could do (view #(dissoc % :key))"><y>#</y><d>2016-07-31</d><h>14:05</h><w>codonnell</w>@luxbock: If you don&apos;t need to rebuild, you could do <code>(view #(dissoc % :key))</code></z><z id="t1469973982" t="codonnell You could also define your own navigator to do it, which shouldn&apos;t be too hard"><y>#</y><d>2016-07-31</d><h>14:06</h><w>codonnell</w>You could also define your own navigator to do it, which shouldn&apos;t be too hard</z><z id="t1469973999" t="luxbock I do need the key present in the returned result "><y>#</y><d>2016-07-31</d><h>14:06</h><w>luxbock</w>I do need the key present in the returned result </z><z id="t1469974024" t="luxbock Yeah I was wondering if there had been an easy way to do it with the builtins "><y>#</y><d>2016-07-31</d><h>14:07</h><w>luxbock</w>Yeah I was wondering if there had been an easy way to do it with the builtins </z><z id="t1469974067" t="luxbock I think rather than building a navigator for this specific use case I would rather just wrap the whole thing with dissoc and assoc "><y>#</y><d>2016-07-31</d><h>14:07</h><w>luxbock</w>I think rather than building a navigator for this specific use case I would rather just wrap the whole thing with dissoc and assoc </z><z id="t1469974289" t="codonnell (transform [ALL #(not= :a (first %)) LAST] inc {:a 0 :b 1 :c 2})"><y>#</y><d>2016-07-31</d><h>14:11</h><w>codonnell</w><code>(transform [ALL #(not= :a (first %)) LAST] inc {:a 0 :b 1 :c 2})</code></z><z id="t1469974316" t="codonnell @luxbock: definitely not as efficient as using assoc and dissoc , but it does work"><y>#</y><d>2016-07-31</d><h>14:11</h><w>codonnell</w>@luxbock: definitely not as efficient as using <code>assoc</code> and <code>dissoc</code>, but it does work</z><z id="t1469978145" t="luxbock Yeah, thanks, I think I&apos;ll end up doing it manually because this function gets called a ton "><y>#</y><d>2016-07-31</d><h>15:15</h><w>luxbock</w>Yeah, thanks, I think I&apos;ll end up doing it manually because this function gets called a ton </z><z id="t1470150774" t="borkdude Does anyone has an example of how I should require specter from clojurescript?"><y>#</y><d>2016-08-02</d><h>15:12</h><w>borkdude</w>Does anyone has an example of how I should require specter from clojurescript?</z><z id="t1470150780" t="borkdude It&apos;s missing in the intro page (that uses use )"><y>#</y><d>2016-08-02</d><h>15:13</h><w>borkdude</w>It&apos;s missing in the intro page (that uses <code>use</code>)</z><z id="t1470150884" t="nathanmarz @borkdude (require &apos;[com.rpl.specter :as s]) (require-macros &apos;[com.rpl.specter.macros :refer [select transform]]) "><y>#</y><d>2016-08-02</d><h>15:14</h><w>nathanmarz</w>@borkdude
<pre>(require &apos;[com.rpl.specter :as s])
(require-macros &apos;[com.rpl.specter.macros :refer [select transform]])
</pre></z><z id="t1470150912" t="borkdude @nathanmarz: cool, I was trying something with :refer :all, but that isn&apos;t going to work probably"><y>#</y><d>2016-08-02</d><h>15:15</h><w>borkdude</w>@nathanmarz: cool, I was trying something with :refer :all, but that isn&apos;t going to work probably</z><z id="t1470150914" t="nathanmarz macros namespace also has declarepath, providepath, and other operations for defining navigators"><y>#</y><d>2016-08-02</d><h>15:15</h><w>nathanmarz</w>macros namespace also has declarepath, providepath, and other operations for defining navigators</z><z id="t1470150958" t="nathanmarz yea I think you need to require macros individually"><y>#</y><d>2016-08-02</d><h>15:15</h><w>nathanmarz</w>yea I think you need to require macros individually</z><z id="t1470151023" t="nathanmarz not sure, don&apos;t really use cljs"><y>#</y><d>2016-08-02</d><h>15:17</h><w>nathanmarz</w>not sure, don&apos;t really use cljs</z><z id="t1470151094" t="borkdude where should I require walker from, is it a function or macro?"><y>#</y><d>2016-08-02</d><h>15:18</h><w>borkdude</w>where should I require <code>walker</code> from, is it a function or macro?</z><z id="t1470151314" t="borkdude I&apos;m trying to get Specter going with Planck, but failing so far: https://gist.github.com/borkdude/a7706bf096e1280b3d8a3fd0b33ec95e"><y>#</y><d>2016-08-02</d><h>15:21</h><w>borkdude</w>I&apos;m trying to get Specter going with Planck, but failing so far: <a href="https://gist.github.com/borkdude/a7706bf096e1280b3d8a3fd0b33ec95e" target="_blank">https://gist.github.com/borkdude/a7706bf096e1280b3d8a3fd0b33ec95e</a></z><z id="t1470151451" t="nathanmarz can you get a stack trace for that?"><y>#</y><d>2016-08-02</d><h>15:24</h><w>nathanmarz</w>can you get a stack trace for that?</z><z id="t1470151953" t="borkdude @nathanmarz: for transform?"><y>#</y><d>2016-08-02</d><h>15:32</h><w>borkdude</w>@nathanmarz: for transform?</z><z id="t1470152155" t="borkdude Don&apos;t know if this is helpful? https://gist.github.com/borkdude/9287a872db1038160fd0444ec1cac443"><y>#</y><d>2016-08-02</d><h>15:35</h><w>borkdude</w>Don&apos;t know if this is helpful? <a href="https://gist.github.com/borkdude/9287a872db1038160fd0444ec1cac443" target="_blank">https://gist.github.com/borkdude/9287a872db1038160fd0444ec1cac443</a></z><z id="t1470153109" t="mfikes FWIW, I quickly tried that expression with older versions of specter, back to 0.9.3 and it fails in Planck in the same way. So not a regression at least. Perhaps just a problematic expression."><y>#</y><d>2016-08-02</d><h>15:51</h><w>mfikes</w>FWIW, I quickly tried that expression with older versions of specter, back to 0.9.3 and it fails in Planck in the same way. So not a regression at least. Perhaps just a problematic expression.</z><z id="t1470153330" t="nathanmarz @borkdude: can you open an issue on github for this?"><y>#</y><d>2016-08-02</d><h>15:55</h><w>nathanmarz</w>@borkdude: can you open an issue on github for this?</z><z id="t1470153349" t="borkdude of course! I&apos;m cooking right now, but will do so after dinner"><y>#</y><d>2016-08-02</d><h>15:55</h><w>borkdude</w>of course! I&apos;m cooking right now, but will do so after dinner</z><z id="t1470153508" t="nathanmarz @mfikes: master branch is on clojure 1.7.0 now, does that mean we should be able to integrate automated tests for specter+bootstrap ?"><y>#</y><d>2016-08-02</d><h>15:58</h><w>nathanmarz</w>@mfikes: master branch is on clojure 1.7.0 now, does that mean we should be able to integrate automated tests for specter+bootstrap ?</z><z id="t1470153993" t="borkdude https://github.com/nathanmarz/specter/issues/136"><y>#</y><d>2016-08-02</d><h>16:06</h><w>borkdude</w><a href="https://github.com/nathanmarz/specter/issues/136" target="_blank">https://github.com/nathanmarz/specter/issues/136</a></z><z id="t1470154356" t="mfikes @nathanmarz: still need http://dev.clojure.org/jira/browse/TCHECK-105"><y>#</y><d>2016-08-02</d><h>16:12</h><w>mfikes</w>@nathanmarz: still need <a href="http://dev.clojure.org/jira/browse/TCHECK-105" target="_blank">http://dev.clojure.org/jira/browse/TCHECK-105</a></z><z id="t1470154773" t="nathanmarz @mfikes: hmmm, timestamps there aren&apos;t so encouraging"><y>#</y><d>2016-08-02</d><h>16:19</h><w>nathanmarz</w>@mfikes: hmmm, timestamps there aren&apos;t so encouraging</z><z id="t1470154803" t="nathanmarz would it be possible to fork test.check in the meantime with the appropriate changes? I&apos;d be perfectly happy using that"><y>#</y><d>2016-08-02</d><h>16:20</h><w>nathanmarz</w>would it be possible to fork test.check in the meantime with the appropriate changes? I&apos;d be perfectly happy using that</z><z id="t1470156086" t="mattsfrey few questions.. how would I make select* analogous to get-in, currently (select* [:bleh :blah] {:bleh {:blah 1}}) returns [1] instead of just 1"><y>#</y><d>2016-08-02</d><h>16:41</h><w>mattsfrey</w>few questions.. how would I make select* analogous to get-in, currently (select* [:bleh :blah] {:bleh {:blah 1}}) returns [1] instead of just 1</z><z id="t1470156104" t="mattsfrey and why do the examples on the github use just &apos;select&apos; when the function is select* ?"><y>#</y><d>2016-08-02</d><h>16:41</h><w>mattsfrey</w>and why do the examples on the github use just &apos;select&apos; when the function is select* ?</z><z id="t1470157498" t="mfikes @nathanmarz: Yeah… let me check. There’s an issue related to Transit that might be holding it up, and if that’s the case perhaps I can address it. I agree, if no progress, I’ll pursue an interim fork."><y>#</y><d>2016-08-02</d><h>17:04</h><w>mfikes</w>@nathanmarz: Yeah… let me check. There’s an issue related to Transit that might be holding it up, and if that’s the case perhaps I can address it. I agree, if no progress, I’ll pursue an interim fork.</z><z id="t1470158238" t="codonnell @mattsfrey: There is a select* function, but it&apos;s preferred to use the select macro, as in the docs"><y>#</y><d>2016-08-02</d><h>17:17</h><w>codonnell</w>@mattsfrey: There is a <code>select*</code> function, but it&apos;s preferred to use the <code>select</code> macro, as in the docs</z><z id="t1470158263" t="codonnell and if you know you&apos;ll only be selecting one thing, you can use select-one or select-any"><y>#</y><d>2016-08-02</d><h>17:17</h><w>codonnell</w>and if you know you&apos;ll only be selecting one thing, you can use <code>select-one</code> or <code>select-any</code></z><z id="t1470158291" t="codonnell (`select` is in the com.rpl.specter.macros namespace)"><y>#</y><d>2016-08-02</d><h>17:18</h><w>codonnell</w>(`select` is in the <code>com.rpl.specter.macros</code> namespace)</z><z id="t1470158487" t="nathanmarz @mfikes: sounds good"><y>#</y><d>2016-08-02</d><h>17:21</h><w>nathanmarz</w>@mfikes: sounds good</z><z id="t1470158569" t="nathanmarz @codonnell @mattsfrey select* is the navigator implementation function, which is distinct from select"><y>#</y><d>2016-08-02</d><h>17:22</h><w>nathanmarz</w>@codonnell @mattsfrey <code>select*</code> is the navigator implementation function, which is distinct from <code>select</code></z><z id="t1470158591" t="nathanmarz select-any (introduced in 0.12.0) is the most efficient way to get one result back"><y>#</y><d>2016-08-02</d><h>17:23</h><w>nathanmarz</w><code>select-any</code> (introduced in 0.12.0) is the most efficient way to get one result back</z><z id="t1470158647" t="nathanmarz @codonnell @mattsfrey nevermind, just realized you were referring to the functional version of select macro"><y>#</y><d>2016-08-02</d><h>17:24</h><w>nathanmarz</w>@codonnell @mattsfrey nevermind, just realized you were referring to the functional version of <code>select</code> macro</z><z id="t1470158688" t="nathanmarz the reason to use the macro is because it does inline caching of the navigation path, so is very efficient"><y>#</y><d>2016-08-02</d><h>17:24</h><w>nathanmarz</w>the reason to use the macro is because it does inline caching of the navigation path, so is very efficient</z><z id="t1470158715" t="nathanmarz see https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs for details on that"><y>#</y><d>2016-08-02</d><h>17:25</h><w>nathanmarz</w>see <a href="https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs" target="_blank">https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs</a> for details on that</z><z id="t1470164572" t="hueyp noob question … how do I combine clauses? ;p (spec/comp-paths THINGS spec/ALL (and (spec/selected? :category #{&quot;A&quot;}) (spec/not-selected? :id #{1 2})))"><y>#</y><d>2016-08-02</d><h>19:02</h><w>hueyp</w>noob question … how do I combine clauses? ;p <pre>(spec/comp-paths THINGS spec/ALL (and (spec/selected? :category #{&quot;A&quot;})
                                      (spec/not-selected? :id #{1 2})))</pre></z><z id="t1470165001" t="nathanmarz @hueyp: just get rid of the and"><y>#</y><d>2016-08-02</d><h>19:10</h><w>nathanmarz</w>@hueyp: just get rid of the <code>and</code></z><z id="t1470165009" t="hueyp heh"><y>#</y><d>2016-08-02</d><h>19:10</h><w>hueyp</w>heh</z><z id="t1470165026" t="nathanmarz (spec/comp-paths THINGS spec/ALL (spec/selected? :category #{&quot;A&quot;}) (spec/not-selected? :id #{1 2}))"><y>#</y><d>2016-08-02</d><h>19:10</h><w>nathanmarz</w><code>(spec/comp-paths THINGS spec/ALL (spec/selected? :category #{&quot;A&quot;}) (spec/not-selected? :id #{1 2}))</code></z><z id="t1470165077" t="hueyp perfect thanks 🙂"><y>#</y><d>2016-08-02</d><h>19:11</h><w>hueyp</w>perfect thanks <b>🙂</b></z><z id="t1470166597" t="puzzler If you know you are selecting one element, what are the pros and cons of choosing select-one or select-any vs select-first?"><y>#</y><d>2016-08-02</d><h>19:36</h><w>puzzler</w>If you know you are selecting one element, what are the pros and cons of choosing select-one or select-any vs select-first?</z><z id="t1470166612" t="mattsfrey @nathanmarz: ahh, ok it&apos;s a macro"><y>#</y><d>2016-08-02</d><h>19:36</h><w>mattsfrey</w>@nathanmarz: ahh, ok it&apos;s a macro</z><z id="t1470166654" t="nathanmarz @puzzler: select-any is the fastest"><y>#</y><d>2016-08-02</d><h>19:37</h><w>nathanmarz</w>@puzzler: <code>select-any</code> is the fastest</z><z id="t1470166688" t="nathanmarz not really any perf difference between select-one and select-first (for now), they just have different semantics in terms of what happens if there&apos;s multiple elements to select"><y>#</y><d>2016-08-02</d><h>19:38</h><w>nathanmarz</w>not really any perf difference between <code>select-one</code> and <code>select-first</code> (for now), they just have different semantics in terms of what happens if there&apos;s multiple elements to select</z><z id="t1470166851" t="codonnell @puzzler: Also, select-one will throw an exception if more than one result is found, while select-first and select-any will not (as you may infer from their names)"><y>#</y><d>2016-08-02</d><h>19:40</h><w>codonnell</w>@puzzler: Also, <code>select-one</code> will throw an exception if more than one result is found, while <code>select-first</code> and <code>select-any</code> will not (as you may infer from their names)</z><z id="t1470166979" t="puzzler Is select-any in the latest stable version 0.11.2? For some reason, although I&apos;m &quot;use&quot;ing the macros namespace, I&apos;m not seeing it."><y>#</y><d>2016-08-02</d><h>19:42</h><w>puzzler</w>Is select-any in the latest stable version 0.11.2?  For some reason, although I&apos;m &quot;use&quot;ing the macros namespace, I&apos;m not seeing it.</z><z id="t1470167024" t="nathanmarz it&apos;s in 0.12.0"><y>#</y><d>2016-08-02</d><h>19:43</h><w>nathanmarz</w>it&apos;s in 0.12.0</z><z id="t1470167042" t="nathanmarz should probably get around to releasing it"><y>#</y><d>2016-08-02</d><h>19:44</h><w>nathanmarz</w>should probably get around to releasing it</z><z id="t1470167044" t="puzzler ah, ok."><y>#</y><d>2016-08-02</d><h>19:44</h><w>puzzler</w>ah, ok.</z><z id="t1470167611" t="mattsfrey this question will probably sound dumb, but I can&apos;t for the the life of me figure out how to include the macros"><y>#</y><d>2016-08-02</d><h>19:53</h><w>mattsfrey</w>this question will probably sound dumb, but I can&apos;t for the the life of me figure out how to include the macros</z><z id="t1470167802" t="mattsfrey (:require-macros [com.rpl.specter.macros])"><y>#</y><d>2016-08-02</d><h>19:56</h><w>mattsfrey</w>(:require-macros [com.rpl.specter.macros])</z><z id="t1470167804" t="mattsfrey results in.."><y>#</y><d>2016-08-02</d><h>19:56</h><w>mattsfrey</w>results in..</z><z id="t1470167833" t="mattsfrey #object[TypeError TypeError: undefined is not an object (evaluating &apos;bocl.account.data_test.select.call&apos;)]"><y>#</y><d>2016-08-02</d><h>19:57</h><w>mattsfrey</w>#object[TypeError TypeError: undefined is not an object (evaluating &apos;bocl.account.data_test.select.call&apos;)]</z><z id="t1470167837" t="codonnell @mattsfrey: are you using clojure or clojurescript?"><y>#</y><d>2016-08-02</d><h>19:57</h><w>codonnell</w>@mattsfrey: are you using clojure or clojurescript?</z><z id="t1470167842" t="mattsfrey clojurescript"><y>#</y><d>2016-08-02</d><h>19:57</h><w>mattsfrey</w>clojurescript</z><z id="t1470167937" t="codonnell I haven&apos;t done much clojurescript; you have the correct namespace. Did you do a lein clean?"><y>#</y><d>2016-08-02</d><h>19:58</h><w>codonnell</w>I haven&apos;t done much clojurescript; you have the correct namespace. Did you do a lein clean?</z><z id="t1470167966" t="mattsfrey yeah"><y>#</y><d>2016-08-02</d><h>19:59</h><w>mattsfrey</w>yeah</z><z id="t1470167975" t="mattsfrey i can pull in the normal lib, but not the macros"><y>#</y><d>2016-08-02</d><h>19:59</h><w>mattsfrey</w>i can pull in the normal lib, but not the macros</z><z id="t1470167983" t="mattsfrey &apos;select&apos; is always undefined"><y>#</y><d>2016-08-02</d><h>19:59</h><w>mattsfrey</w>&apos;select&apos; is always undefined</z><z id="t1470168075" t="codonnell maybe you need it to be (:require-macros [com.rpl.specter.macros :refer [select transform]]) ?"><y>#</y><d>2016-08-02</d><h>20:01</h><w>codonnell</w>maybe you need it to be <code>(:require-macros [com.rpl.specter.macros :refer [select transform]])</code>?</z><z id="t1470168081" t="mattsfrey tried pretty much every permutation of :refer :all, :include-macros, etc etc and they all end up in error other than just (:require-macros [com.rpl.specter]), but that isn&apos;t actually incuding any macros"><y>#</y><d>2016-08-02</d><h>20:01</h><w>mattsfrey</w>tried pretty much every permutation of :refer :all, :include-macros, etc etc and they all end up in error other than just (:require-macros [com.rpl.specter]), but that isn&apos;t actually incuding any macros</z><z id="t1470168097" t="codonnell hmm"><y>#</y><d>2016-08-02</d><h>20:01</h><w>codonnell</w>hmm</z><z id="t1470168120" t="mattsfrey lol"><y>#</y><d>2016-08-02</d><h>20:02</h><w>mattsfrey</w>lol</z><z id="t1470168128" t="mattsfrey including transform made it work"><y>#</y><d>2016-08-02</d><h>20:02</h><w>mattsfrey</w>including transform made it work</z><z id="t1470168183" t="mattsfrey actually nvm"><y>#</y><d>2016-08-02</d><h>20:03</h><w>mattsfrey</w>actually nvm</z><z id="t1470168184" t="mattsfrey (:require-macros [com.rpl.specter.macros :refer [select]])"><y>#</y><d>2016-08-02</d><h>20:03</h><w>mattsfrey</w>(:require-macros [com.rpl.specter.macros :refer [select]])</z><z id="t1470168188" t="mattsfrey does work"><y>#</y><d>2016-08-02</d><h>20:03</h><w>mattsfrey</w>does work</z><z id="t1470168294" t="codonnell ok, good"><y>#</y><d>2016-08-02</d><h>20:04</h><w>codonnell</w>ok, good</z><z id="t1470168310" t="mattsfrey definitely have to refer whichever ones you need though"><y>#</y><d>2016-08-02</d><h>20:05</h><w>mattsfrey</w>definitely have to refer whichever ones you need though</z><z id="t1470168324" t="mattsfrey :refer :all and :refer-all causes build errors"><y>#</y><d>2016-08-02</d><h>20:05</h><w>mattsfrey</w>:refer :all and :refer-all causes build errors</z><z id="t1470168373" t="codonnell that&apos;s good to know"><y>#</y><d>2016-08-02</d><h>20:06</h><w>codonnell</w>that&apos;s good to know</z><z id="t1470170104" t="mattsfrey anyone know how to get the ALL keyword?"><y>#</y><d>2016-08-02</d><h>20:35</h><w>mattsfrey</w>anyone know how to get the ALL keyword?</z><z id="t1470170113" t="mattsfrey doesn&apos;t seem to be part of macros or the core"><y>#</y><d>2016-08-02</d><h>20:35</h><w>mattsfrey</w>doesn&apos;t seem to be part of macros or the core</z><z id="t1470170226" t="codonnell it should be in com.rpl.specter"><y>#</y><d>2016-08-02</d><h>20:37</h><w>codonnell</w>it should be in <code>com.rpl.specter</code></z><z id="t1470170285" t="nathanmarz @mattsfrey: https://nathanmarz.github.io/specter/"><y>#</y><d>2016-08-02</d><h>20:38</h><w>nathanmarz</w>@mattsfrey: <a href="https://nathanmarz.github.io/specter/" target="_blank">https://nathanmarz.github.io/specter/</a></z><z id="t1470170584" t="hueyp is there clojure sugar around importing both ns&apos;s as the same alias? e.g. (s/select [s/ALL] things)"><y>#</y><d>2016-08-02</d><h>20:43</h><w>hueyp</w>is there clojure sugar around importing both ns&apos;s as the same alias? e.g. <code>(s/select [s/ALL] things)</code></z><z id="t1470171083" t="nathanmarz @hueyp: not that I know of"><y>#</y><d>2016-08-02</d><h>20:51</h><w>nathanmarz</w>@hueyp: not that I know of</z><z id="t1470171115" t="nathanmarz @hueyp: I use https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj to get everything into the same namespace"><y>#</y><d>2016-08-02</d><h>20:51</h><w>nathanmarz</w>@hueyp: I use <a href="https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj" target="_blank">https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj</a> to get everything into the same namespace</z><z id="t1470171445" t="hueyp thanks~ upgrading 10 -&gt; 11 so was wondering if any tricks 🙂"><y>#</y><d>2016-08-02</d><h>20:57</h><w>hueyp</w>thanks~  upgrading 10 -&gt; 11 so was wondering if any tricks <b>🙂</b></z><z id="t1470172301" t="puzzler It appears that transform [ALL] on a lazy sequence does not produce a lazy sequence. Is there a way to make it operate in a lazy fashion?"><y>#</y><d>2016-08-02</d><h>21:11</h><w>puzzler</w>It appears that transform [ALL] on a lazy sequence does not produce a lazy sequence.  Is there a way to make it operate in a lazy fashion?</z><z id="t1470172519" t="nathanmarz @puzzler: you would need to make a new navigator for that"><y>#</y><d>2016-08-02</d><h>21:15</h><w>nathanmarz</w>@puzzler: you would need to make a new navigator for that</z></g><g id="s5"><z id="t1470172598" t="nathanmarz ALL could have been implemented to work differently for lazy sequences, but I think it&apos;s better for lazy behavior to be explicit"><y>#</y><d>2016-08-02</d><h>21:16</h><w>nathanmarz</w><code>ALL</code> could have been implemented to work differently for lazy sequences, but I think it&apos;s better for lazy behavior to be explicit</z><z id="t1470179703" t="hueyp not sure which construct in specter I’d want to use … I have this: (defn Foo [foo-id] [(spec/selected? :type #{&quot;foo&quot;}) (spec/selected? :id #{foo-id})]) (select [THINGS (Foo &quot;bar&quot;)] things) … which works, but I feel is wrong 🙂 . I can move it to declarepath / providepath but wondering if it should use something else"><y>#</y><d>2016-08-02</d><h>23:15</h><w>hueyp</w>not sure which construct in specter I’d want to use … I have this: <pre>(defn Foo
  [foo-id]
  [(spec/selected? :type #{&quot;foo&quot;}) (spec/selected? :id #{foo-id})])

(select [THINGS (Foo &quot;bar&quot;)]
        things)
</pre> … which works, but I feel is wrong <b>🙂</b>.  I can move it to <code>declarepath</code> / <code>providepath</code> but wondering if it should use something else</z><z id="t1470179839" t="hueyp this example could also just be a predicate fn, but other examples include navigation~"><y>#</y><d>2016-08-02</d><h>23:17</h><w>hueyp</w>this example could also just be a predicate fn, but other examples include navigation~</z><z id="t1470179858" t="hueyp attempt at declarepath / provide path is (declarepath Foo [foo-id]) (providepath Foo [(spec/selected? :type #{&quot;foo&quot;}) (spec/selected? :id (paramsfn [foo-id] [id] (= foo-id id)))]) "><y>#</y><d>2016-08-02</d><h>23:17</h><w>hueyp</w>attempt at <code>declarepath</code> / <code>provide</code> path is <pre>(declarepath Foo [foo-id])
(providepath Foo
             [(spec/selected? :type #{&quot;foo&quot;})
              (spec/selected? :id (paramsfn [foo-id] [id] (= foo-id id)))])
</pre></z><z id="t1470179890" t="hueyp first time using paramsfn … I think it works? 😜"><y>#</y><d>2016-08-02</d><h>23:18</h><w>hueyp</w>first time using <code>paramsfn</code> … I think it works? <b>😜</b></z><z id="t1470179919" t="nathanmarz @hueyp: use comp-paths"><y>#</y><d>2016-08-02</d><h>23:18</h><w>nathanmarz</w>@hueyp: use <code>comp-paths</code></z><z id="t1470179923" t="nathanmarz (def Foo (comp-paths (spec/selected? :type #{&quot;foo&quot;}) (spec/selected? :id (paramsfn [foo-id] [id] (= foo-id id))))) "><y>#</y><d>2016-08-02</d><h>23:18</h><w>nathanmarz</w><pre>(def Foo
  (comp-paths
    (spec/selected? :type #{&quot;foo&quot;})
    (spec/selected? :id (paramsfn [foo-id] [id] (= foo-id id)))))
</pre></z><z id="t1470179938" t="hueyp ah yes"><y>#</y><d>2016-08-02</d><h>23:18</h><w>hueyp</w>ah yes</z><z id="t1470179944" t="nathanmarz declarepath /`providepath` is for defining recursive navigators"><y>#</y><d>2016-08-02</d><h>23:19</h><w>nathanmarz</w><code>declarepath</code>/`providepath` is for defining recursive navigators</z><z id="t1470179965" t="hueyp I saw the example with comp-paths in tests but it didn’t click"><y>#</y><d>2016-08-02</d><h>23:19</h><w>hueyp</w>I saw the example with <code>comp-paths</code> in tests but it didn’t click</z><z id="t1470179973" t="hueyp yah, I felt like those were wrong"><y>#</y><d>2016-08-02</d><h>23:19</h><w>hueyp</w>yah, I felt like those were wrong</z><z id="t1470179976" t="hueyp the declare stuff"><y>#</y><d>2016-08-02</d><h>23:19</h><w>hueyp</w>the declare stuff</z><z id="t1470180008" t="nathanmarz comp-paths result will be high performance and can be further composed with other navigators without its params"><y>#</y><d>2016-08-02</d><h>23:20</h><w>nathanmarz</w><code>comp-paths</code> result will be high performance and can be further composed with other navigators without its params</z><z id="t1470180022" t="hueyp thanks much 🙂"><y>#</y><d>2016-08-02</d><h>23:20</h><w>hueyp</w>thanks much <b>🙂</b></z><z id="t1470180037" t="nathanmarz no problem"><y>#</y><d>2016-08-02</d><h>23:20</h><w>nathanmarz</w>no problem</z><z id="t1470210181" t="borkdude is it possible to transform the keys in a map on just one level with specter?"><y>#</y><d>2016-08-03</d><h>07:43</h><w>borkdude</w>is it possible to transform the keys in a map on just one level with specter?</z><z id="t1470210202" t="borkdude for example {:a 1, :b {:c 2}} =&gt; {:aa 1, :bb {:c 2}}"><y>#</y><d>2016-08-03</d><h>07:43</h><w>borkdude</w>for example <code>{:a 1, :b {:c 2}} =&gt; {:aa 1, :bb {:c 2}}</code></z><z id="t1470221632" t="borkdude so, this example: https://clojurians.slack.com/archives/clojure/p1470213401002703"><y>#</y><d>2016-08-03</d><h>10:53</h><w>borkdude</w>so, this example: <a href="https://clojurians.slack.com/archives/clojure/p1470213401002703" target="_blank">https://clojurians.slack.com/archives/clojure/p1470213401002703</a></z><z id="t1470221647" t="borkdude (defnav KW-NS [] (select* [this kw next-fn] (next-fn (namespace kw))) (transform* [this kw next-fn] (let [kw-name (name kw) new-ns (next-fn (namespace kw))] (keyword new-ns kw-name) ))) (setval [ALL FIRST KW-NS] &quot;user&quot; {:a 1 :b 2 :c 3}) ;; =&gt; {:user/a 1, :user/b 2, :user/c 3} "><y>#</y><d>2016-08-03</d><h>10:54</h><w>borkdude</w><pre>(defnav KW-NS []
  (select* [this kw next-fn]
    (next-fn (namespace kw)))
  (transform* [this kw next-fn]
    (let [kw-name (name kw)
          new-ns (next-fn (namespace kw))]
      (keyword new-ns kw-name)
      )))

(setval [ALL FIRST KW-NS] &quot;user&quot; {:a 1 :b 2 :c 3})
;; =&gt; {:user/a 1, :user/b 2, :user/c 3}
</pre></z><z id="t1470221653" t="borkdude how does it work?"><y>#</y><d>2016-08-03</d><h>10:54</h><w>borkdude</w>how does it work?</z><z id="t1470221671" t="nathanmarz so KW-NS navigates to the namespace portion of a keyword"><y>#</y><d>2016-08-03</d><h>10:54</h><w>nathanmarz</w>so KW-NS navigates to the namespace portion of a keyword</z><z id="t1470221695" t="nathanmarz is it the defnav portion that you&apos;re asking about in particular?"><y>#</y><d>2016-08-03</d><h>10:54</h><w>nathanmarz</w>is it the defnav portion that you&apos;re asking about in particular?</z><z id="t1470221700" t="borkdude yes"><y>#</y><d>2016-08-03</d><h>10:55</h><w>borkdude</w>yes</z><z id="t1470221716" t="nathanmarz there&apos;s two code paths, one for select and one for transform"><y>#</y><d>2016-08-03</d><h>10:55</h><w>nathanmarz</w>there&apos;s two code paths, one for select and one for transform</z><z id="t1470221727" t="nathanmarz select must call next-fn on the &quot;navigated to value(s)&quot;"><y>#</y><d>2016-08-03</d><h>10:55</h><w>nathanmarz</w>select must call next-fn on the &quot;navigated to value(s)&quot;</z><z id="t1470221742" t="nathanmarz in this case, it&apos;s just (next-fn (namespace kw))"><y>#</y><d>2016-08-03</d><h>10:55</h><w>nathanmarz</w>in this case, it&apos;s just <code>(next-fn (namespace kw))</code></z><z id="t1470221752" t="borkdude @nathanmarz: what is next-fn in the example with setval?"><y>#</y><d>2016-08-03</d><h>10:55</h><w>borkdude</w>@nathanmarz: what is next-fn in the example with setval?</z><z id="t1470221771" t="nathanmarz it&apos;s the rest of the navigation + final transformation"><y>#</y><d>2016-08-03</d><h>10:56</h><w>nathanmarz</w>it&apos;s the rest of the navigation + final transformation</z><z id="t1470221785" t="nathanmarz so in this case next-fn will be (fn [v] &quot;user&quot;)"><y>#</y><d>2016-08-03</d><h>10:56</h><w>nathanmarz</w>so in this case next-fn will be (fn [v] &quot;user&quot;)</z><z id="t1470221807" t="nathanmarz if there was more navigation after KW-NS, it would be the transform* code paths for the subsequent navigators"><y>#</y><d>2016-08-03</d><h>10:56</h><w>nathanmarz</w>if there was more navigation after KW-NS, it would be the transform* code paths for the subsequent navigators</z><z id="t1470221814" t="borkdude @nathanmarz: specter takes constants and interprets it as a function?"><y>#</y><d>2016-08-03</d><h>10:56</h><w>borkdude</w>@nathanmarz: specter takes constants and interprets it as a function?</z><z id="t1470221825" t="nathanmarz setval is a thin wrapper around transform"><y>#</y><d>2016-08-03</d><h>10:57</h><w>nathanmarz</w>setval is a thin wrapper around transform</z><z id="t1470221863" t="nathanmarz (setval [ALL FIRST KW-NS] &quot;user&quot; {:a 1 :b 2 :c 3}) == (transform [ALL FIRST KW-NS] (fn [_] &quot;user&quot;) {:a 1 :b 2 :c 3})"><y>#</y><d>2016-08-03</d><h>10:57</h><w>nathanmarz</w><code>(setval [ALL FIRST KW-NS] &quot;user&quot; {:a 1 :b 2 :c 3})</code> == <code>(transform [ALL FIRST KW-NS] (fn [_] &quot;user&quot;) {:a 1 :b 2 :c 3})</code></z><z id="t1470221876" t="borkdude ok understood that part"><y>#</y><d>2016-08-03</d><h>10:57</h><w>borkdude</w>ok understood that part</z><z id="t1470221903" t="borkdude I think I&apos;ll just have to read up on the defnav docs"><y>#</y><d>2016-08-03</d><h>10:58</h><w>borkdude</w>I think I&apos;ll just have to read up on the defnav docs</z><z id="t1470221974" t="nathanmarz here&apos;s how two navigators get composed into one navigator: https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L345"><y>#</y><d>2016-08-03</d><h>10:59</h><w>nathanmarz</w>here&apos;s how two navigators get composed into one navigator: <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L345" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljx#L345</a></z><z id="t1470221996" t="nathanmarz that&apos;s the core of how specter works"><y>#</y><d>2016-08-03</d><h>10:59</h><w>nathanmarz</w>that&apos;s the core of how specter works</z><z id="t1470222020" t="nathanmarz your linear path of navigators becomes a single nested function"><y>#</y><d>2016-08-03</d><h>11:00</h><w>nathanmarz</w>your linear path of navigators becomes a single nested function</z><z id="t1470222040" t="borkdude I think I&apos;m getting it, but you could also have written: (transform [ALL FIRST] (fn [kw] (keyword &quot;user&quot; (name kw)))) right? but your example is more abstract"><y>#</y><d>2016-08-03</d><h>11:00</h><w>borkdude</w>I think I&apos;m getting it, but you could also have written: <code>(transform [ALL FIRST] (fn [kw] (keyword &quot;user&quot; (name kw))))</code> right? but your example is more abstract</z><z id="t1470222055" t="nathanmarz correct"><y>#</y><d>2016-08-03</d><h>11:00</h><w>nathanmarz</w>correct</z><z id="t1470222068" t="nathanmarz much more reusable and composable"><y>#</y><d>2016-08-03</d><h>11:01</h><w>nathanmarz</w>much more reusable and composable</z><z id="t1470222078" t="borkdude cool stuff 🙂"><y>#</y><d>2016-08-03</d><h>11:01</h><w>borkdude</w>cool stuff <b>🙂</b></z><z id="t1470222163" t="borkdude any reason specter is still using cljx? compatibility with previous clj versions?"><y>#</y><d>2016-08-03</d><h>11:02</h><w>borkdude</w>any reason specter is still using cljx? compatibility with previous clj versions?</z><z id="t1470222213" t="nathanmarz yea"><y>#</y><d>2016-08-03</d><h>11:03</h><w>nathanmarz</w>yea</z><z id="t1470222249" t="nathanmarz though finally dropping support for 1.6 as of specter 0.12.0"><y>#</y><d>2016-08-03</d><h>11:04</h><w>nathanmarz</w>though finally dropping support for 1.6 as of specter 0.12.0</z><z id="t1470222260" t="nathanmarz just need to do the work now of porting to cljc"><y>#</y><d>2016-08-03</d><h>11:04</h><w>nathanmarz</w>just need to do the work now of porting to cljc</z><z id="t1470337817" t="jjcomer @nathanmarz: Any chance you could release 0.12.0 in the near future? We are looking to cut a release of our service pretty soon and require the fixes in 0.12.0"><y>#</y><d>2016-08-04</d><h>19:10</h><w>jjcomer</w>@nathanmarz: Any chance you could release 0.12.0 in the near future? We are looking to cut a release of our service pretty soon and require the fixes in 0.12.0</z><z id="t1470344697" t="hueyp master builds fine for us if you clone / build locally (we needed aot fix)"><y>#</y><d>2016-08-04</d><h>21:04</h><w>hueyp</w>master builds fine for us if you clone / build locally (we needed aot fix)</z><z id="t1470378630" t="esirola hi, is it possible to implement something similar to a &quot;group-by&quot; operation with specter?"><y>#</y><d>2016-08-05</d><h>06:30</h><w>esirola</w>hi, is it possible to implement something similar to a &quot;group-by&quot; operation with specter?</z><z id="t1470378751" t="esirola i&apos;d like to do something like [{:a 1, :b 1} {:a 1, :b 2} {:a 2, :b 2}] -&gt; [{:a 1, :b [1 2]} {:a 2, :b [2]}]"><y>#</y><d>2016-08-05</d><h>06:32</h><w>esirola</w>i&apos;d like to do something like <pre>[{:a 1, :b 1} {:a 1, :b 2} {:a 2, :b 2}] -&gt; [{:a 1, :b [1 2]} {:a 2, :b [2]}]</pre></z><z id="t1470378822" t="esirola ... and I&apos;m a bit puzzled"><y>#</y><d>2016-08-05</d><h>06:33</h><w>esirola</w>... and I&apos;m a bit puzzled</z><z id="t1470378960" t="esirola you need to accumulate things while you traverse the collection somewhere, but I can&apos;t figure out how (if possible)"><y>#</y><d>2016-08-05</d><h>06:36</h><w>esirola</w>you need to accumulate things while you traverse the collection somewhere, but I can&apos;t figure out how (if possible)</z><z id="t1470390713" t="nathanmarz @jjcomer: will do once clojars comes back up"><y>#</y><d>2016-08-05</d><h>09:51</h><w>nathanmarz</w>@jjcomer: will do once clojars comes back up</z><z id="t1470390831" t="nathanmarz @esirola: I&apos;m not sure how to express that with navigation"><y>#</y><d>2016-08-05</d><h>09:53</h><w>nathanmarz</w>@esirola: I&apos;m not sure how to express that with navigation</z><z id="t1470391964" t="nathanmarz released 0.12.0: https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><y>#</y><d>2016-08-05</d><h>10:12</h><w>nathanmarz</w>released 0.12.0: <a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md" target="_blank">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></z><z id="t1470392801" t="esirola @nathanmarz: ok thanks a lot"><y>#</y><d>2016-08-05</d><h>10:26</h><w>esirola</w>@nathanmarz: ok thanks a lot</z><z id="t1470393140" t="borkdude @esirola: I just implemented it as an exercise, not with Specter: (let [data [{:a 1, :b 1} {:a 1, :b 2} {:a 2, :b 2}]] #_=&gt; (reduce (fn [acc [k v]] (conj acc {:a k :b (mapv :b v)})) [] (group-by :a data))) "><y>#</y><d>2016-08-05</d><h>10:32</h><w>borkdude</w>@esirola: I just implemented it as an exercise, not with Specter: 
<pre>(let [data [{:a 1, :b 1} {:a 1, :b 2} {:a 2, :b 2}]]
       #_=&gt;   (reduce (fn [acc [k v]] (conj acc {:a k :b (mapv :b v)})) [] (group-by :a data)))
</pre></z><z id="t1470399708" t="jjcomer @nathanmarz: Thanks!"><y>#</y><d>2016-08-05</d><h>12:21</h><w>jjcomer</w>@nathanmarz: Thanks!</z><z id="t1470410082" t="borkdude What is the reason one path is called FIRST and another MAP-VALS, why not FIRST and SECOND?"><y>#</y><d>2016-08-05</d><h>15:14</h><w>borkdude</w>What is the reason one path is called FIRST and another MAP-VALS, why not FIRST and SECOND?</z><z id="t1470411242" t="nathanmarz @borkdude: MAP-VALS navigates to each value of a map, has nothing to do with second"><y>#</y><d>2016-08-05</d><h>15:34</h><w>nathanmarz</w>@borkdude: MAP-VALS navigates to each value of a map, has nothing to do with <code>second</code></z><z id="t1470411656" t="borkdude @nathanmarz: ah, I mean [ALL FIRST] vs [MAP-VALS] - why is there no MAP-KEYS?"><y>#</y><d>2016-08-05</d><h>15:40</h><w>borkdude</w>@nathanmarz: ah, I mean [ALL FIRST] vs [MAP-VALS] - why is there no MAP-KEYS?</z><z id="t1470411819" t="borkdude because this case is rare, probably"><y>#</y><d>2016-08-05</d><h>15:43</h><w>borkdude</w>because this case is rare, probably</z><z id="t1470411827" t="nathanmarz yea"><y>#</y><d>2016-08-05</d><h>15:43</h><w>nathanmarz</w>yea</z><z id="t1470411846" t="nathanmarz there could be a MAP-KEYS that&apos;s more efficient than ALL FIRST but I&apos;ve never needed that"><y>#</y><d>2016-08-05</d><h>15:44</h><w>nathanmarz</w>there could be a MAP-KEYS that&apos;s more efficient than ALL FIRST but I&apos;ve never needed that</z><z id="t1470411859" t="nathanmarz whereas MAP-VALS comes up all the time, so having an optimized version provides a lot of value"><y>#</y><d>2016-08-05</d><h>15:44</h><w>nathanmarz</w>whereas MAP-VALS comes up all the time, so having an optimized version provides a lot of value</z><z id="t1470411892" t="nathanmarz you can do (def MAP-KEYS (comp-paths ALL FIRST)) if you want something reusable"><y>#</y><d>2016-08-05</d><h>15:44</h><w>nathanmarz</w>you can do <code>(def MAP-KEYS (comp-paths ALL FIRST))</code> if you want something reusable</z><z id="t1470411942" t="borkdude I was just wondering, didn&apos;t really need it"><y>#</y><d>2016-08-05</d><h>15:45</h><w>borkdude</w>I was just wondering, didn&apos;t really need it</z><z id="t1470411995" t="nathanmarz pretty much everything in Specter grew out of real use cases"><y>#</y><d>2016-08-05</d><h>15:46</h><w>nathanmarz</w>pretty much everything in Specter grew out of real use cases</z><z id="t1470412010" t="borkdude I needed it when I wanted to solve a stackoverflow question though, I had to transform the keys"><y>#</y><d>2016-08-05</d><h>15:46</h><w>borkdude</w>I needed it when I wanted to solve a stackoverflow question though, I had to transform the keys</z><z id="t1470629610" t="jjunior130 I require both com.rpl.specter &amp; com.rpl.specter.macros namespaces in ClojureScript"><y>#</y><d>2016-08-08</d><h>04:13</h><w>jjunior130</w>I require both <code>com.rpl.specter</code> &amp; <code>com.rpl.specter.macros</code> namespaces in ClojureScript</z><z id="t1470629718" t="jjunior130 all symbols from com.rpl.specter work but not com.rpl.specter.macros"><y>#</y><d>2016-08-08</d><h>04:15</h><w>jjunior130</w>all symbols from <code>com.rpl.specter</code> work but not <code>com.rpl.specter.macros</code></z><z id="t1470629783" t="jjunior130 when I try a symbol from com.rpl.specter.macros such as transform I get this error message: Uncaught TypeError: Cannot read property &apos;cljs$core$IFn$_invoke$arity$1&apos; of undefined core.js [32556] anonymous core.js [19022] anonymous core.js [19023] anonymous core.js [19038] cljs.core.PersistentVector.cljs$core$IReduce$_reduce$arity$3 core.js [7719] cljs.core.reduce.cljs$core$IFn$_invoke$arity$3 core.js [32555] cljs$core$group_by views.js?zx=ibkddq5mtrqz [72] anonymous specter.js [975] $rpl$specter$protocols$Navigator$transform_STAR_$arity$3 protocols.js [46] com$rpl$specter$protocols$transform_STAR_ impl.js [2175] com.rpl.specter.impl.structure_path_impl impl.js [2202] anonymous impl.js [2371] anonymous core.js [16854] anonymous core.js [16855] cljs.core.map.cljs$core$IFn$_invoke$arity$2 core.js [10895] cljs.core.LazySeq.sval core.js [11046] cljs.core.LazySeq.cljs$core$ISeqable$_seq$arity$1 core.js [4117] cljs$core$seq core.js [30313] cljs.core.dorun.cljs$core$IFn$_invoke$arity$1 core.js [30381] cljs.core.doall.cljs$core$IFn$_invoke$arity$1 core.js [30367] cljs$core$doall impl.js [3239] com.rpl.specter.impl.all_transform._ impl.js [3177] com$rpl$specter$impl$all_transform impl.js [3280] $rpl$specter$protocols$Navigator$transform_STAR_$arity$3 protocols.js [46] com$rpl$specter$protocols$transform_STAR_ impl.js [2175] com.rpl.specter.impl.structure_path_impl impl.js [2202] anonymous impl.js [2369] com.rpl.specter.impl.combine_same_types.combiner impl.js [284] anonymous impl.js [3112] com$rpl$specter$impl$compiled_transform_STAR_ views.js?zx=ibkddq5mtrqz [54] anonymous "><y>#</y><d>2016-08-08</d><h>04:16</h><w>jjunior130</w>when I try a symbol from <code>com.rpl.specter.macros</code> such as <code>transform</code> I get this error message:
<pre>Uncaught TypeError: Cannot read property &apos;cljs$core$IFn$_invoke$arity$1&apos; of undefined
core.js [32556]	anonymous
core.js [19022]	anonymous
core.js [19023]	anonymous
core.js [19038]	cljs.core.PersistentVector.cljs$core$IReduce$_reduce$arity$3
core.js [7719]	cljs.core.reduce.cljs$core$IFn$_invoke$arity$3
core.js [32555]	cljs$core$group_by
views.js?zx=ibkddq5mtrqz [72]	anonymous
specter.js [975]	$rpl$specter$protocols$Navigator$transform_STAR_$arity$3
protocols.js [46]	com$rpl$specter$protocols$transform_STAR_
impl.js [2175]	com.rpl.specter.impl.structure_path_impl
impl.js [2202]	anonymous
impl.js [2371]	anonymous
core.js [16854]	anonymous
core.js [16855]	cljs.core.map.cljs$core$IFn$_invoke$arity$2
core.js [10895]	cljs.core.LazySeq.sval
core.js [11046]	cljs.core.LazySeq.cljs$core$ISeqable$_seq$arity$1
core.js [4117]	cljs$core$seq
core.js [30313]	cljs.core.dorun.cljs$core$IFn$_invoke$arity$1
core.js [30381]	cljs.core.doall.cljs$core$IFn$_invoke$arity$1
core.js [30367]	cljs$core$doall
impl.js [3239]	com.rpl.specter.impl.all_transform._
impl.js [3177]	com$rpl$specter$impl$all_transform
impl.js [3280]	$rpl$specter$protocols$Navigator$transform_STAR_$arity$3
protocols.js [46]	com$rpl$specter$protocols$transform_STAR_
impl.js [2175]	com.rpl.specter.impl.structure_path_impl
impl.js [2202]	anonymous
impl.js [2369]	com.rpl.specter.impl.combine_same_types.combiner
impl.js [284]	anonymous
impl.js [3112]	com$rpl$specter$impl$compiled_transform_STAR_
views.js?zx=ibkddq5mtrqz [54]	anonymous
</pre></z><z id="t1470630030" t="jjunior130 I have ran lein clean and lein cljsbuild once"><y>#</y><d>2016-08-08</d><h>04:20</h><w>jjunior130</w>I have ran <code>lein clean</code> and <code>lein cljsbuild once</code></z><z id="t1470640878" t="esirola @borkdude: yes, I guess one can &quot;select&quot; with specter producing something like the maps you worked on and then use something like the code you posted to perform the aggregations"><y>#</y><d>2016-08-08</d><h>07:21</h><w>esirola</w>@borkdude: yes, I guess one can &quot;select&quot; with specter producing something like the maps you worked on and then use something like the code you posted to perform the aggregations</z><z id="t1470649109" t="yonatanel I want to get a deeply nested map value from a parsed SOAP response, so the value of key :contents when the :tag value is :second or any other I choose. I used walker but I wonder if there&apos;s a more elegant way: (select-one [(walker #(= :second (:tag %))) :content FIRST] parsed-soap) =&gt; &quot;123&quot; parsed-soap is {:tag :soap:Envelope, :attrs {:xmlns:xsi &quot;&quot;, :xmlns:xsd &quot;&quot;, :xmlns:soap &quot;&quot;}, :content [{:tag :soap:Body, :attrs nil, :content [{:tag :aResponse :attrs {:xmlns:a &quot;&quot;}, :content [{:tag :a:aResult, :attrs nil, :content [{:tag :first :attrs {:xsi:nil &quot;true&quot;, :xmlns &quot;&quot;}, :content nil} {:tag :second :attrs {:xmlns &quot;&quot;}, :content [&quot;123&quot;]} {:tag :third, :attrs {:xsi:nil &quot;true&quot;, :xmlns &quot;&quot;}, :content nil}]}]}]}]}"><y>#</y><d>2016-08-08</d><h>09:38</h><w>yonatanel</w>I want to get a deeply nested map value from a parsed SOAP response, so the value of key :contents when the :tag value is :second or any other I choose. I used walker but I wonder if there&apos;s a more elegant way:
<pre>(select-one [(walker #(= :second (:tag %))) :content FIRST] parsed-soap)
=&gt;
&quot;123&quot;</pre>

parsed-soap is
<pre>{:tag :soap:Envelope,
 :attrs {:xmlns:xsi &quot;&quot;,
         :xmlns:xsd &quot;&quot;,
         :xmlns:soap &quot;&quot;},
 :content [{:tag :soap:Body,
            :attrs nil,
            :content [{:tag :aResponse
                       :attrs {:xmlns:a &quot;&quot;},
                       :content [{:tag :a:aResult,
                                  :attrs nil,
                                  :content [{:tag :first
                                             :attrs {:xsi:nil &quot;true&quot;, :xmlns &quot;&quot;},
                                             :content nil}
                                            {:tag :second
                                             :attrs {:xmlns &quot;&quot;},
                                             :content [&quot;123&quot;]}
                                            {:tag :third,
                                             :attrs {:xsi:nil &quot;true&quot;, :xmlns &quot;&quot;},
                                             :content nil}]}]}]}]}</pre></z><z id="t1470650357" t="nathanmarz @jjunior130: what version and what&apos;s the exact code you&apos;re running?"><y>#</y><d>2016-08-08</d><h>09:59</h><w>nathanmarz</w>@jjunior130: what version and what&apos;s the exact code you&apos;re running?</z><z id="t1470650594" t="nathanmarz @yonatanel: my only issue with that code is it relies on a strange property of clojure which is that you can do map lookups on non-map values without error"><y>#</y><d>2016-08-08</d><h>10:03</h><w>nathanmarz</w>@yonatanel: my only issue with that code is it relies on a strange property of clojure which is that you can do map lookups on non-map values without error</z><z id="t1470650611" t="nathanmarz since walker will run that function on everything it finds"><y>#</y><d>2016-08-08</d><h>10:03</h><w>nathanmarz</w>since walker will run that function on everything it finds</z><z id="t1470650628" t="nathanmarz that also makes that particular path less performant than ideal"><y>#</y><d>2016-08-08</d><h>10:03</h><w>nathanmarz</w>that also makes that particular path less performant than ideal</z><z id="t1470650650" t="nathanmarz the alternative is to explicitly make a recursive navigator that understands the particular structure of this data"><y>#</y><d>2016-08-08</d><h>10:04</h><w>nathanmarz</w>the alternative is to explicitly make a recursive navigator that understands the particular structure of this data</z><z id="t1470651001" t="nathanmarz @yonatanel: (declarepath SoapPath) (providepath SoapPath (continue-then-stay :content ALL SoapPath )) (select-one [SoapPath #(= :second (:tag %)) :content FIRST] parsed-soap) "><y>#</y><d>2016-08-08</d><h>10:10</h><w>nathanmarz</w>@yonatanel: 
<pre>(declarepath SoapPath)
(providepath SoapPath
  (continue-then-stay
    :content
    ALL
    SoapPath
    ))

(select-one [SoapPath #(= :second (:tag %)) :content FIRST] parsed-soap)
</pre></z><z id="t1470651045" t="yonatanel @nathanmarz: can one be compiled by running an example first? Could be nice to tell it to walk the structure and learn for next time."><y>#</y><d>2016-08-08</d><h>10:10</h><w>yonatanel</w>@nathanmarz: can one be compiled by running an example first? Could be nice to tell it to walk the structure and learn for next time.</z><z id="t1470651092" t="nathanmarz you mean use walker and then have it &quot;learn&quot; the path that I wrote?"><y>#</y><d>2016-08-08</d><h>10:11</h><w>nathanmarz</w>you mean use <code>walker</code> and then have it &quot;learn&quot; the path that I wrote?</z><z id="t1470651231" t="yonatanel yes, assuming it works. I don&apos;t entirely understand it yet."><y>#</y><d>2016-08-08</d><h>10:13</h><w>yonatanel</w>yes, assuming it works. I don&apos;t entirely understand it yet.</z><z id="t1470651380" t="nathanmarz it&apos;s an interesting idea but seems like it would be full of minefields"><y>#</y><d>2016-08-08</d><h>10:16</h><w>nathanmarz</w>it&apos;s an interesting idea but seems like it would be full of minefields</z><z id="t1470651395" t="nathanmarz there&apos;s no way for walker to know that the data structure is recursive, for one"><y>#</y><d>2016-08-08</d><h>10:16</h><w>nathanmarz</w>there&apos;s no way for walker to know that the data structure is recursive, for one</z><z id="t1470663494" t="shader any chance we could get anonymous recursive navigation? so you don&apos;t have to separately declare/provide the navigator? It seems to be a very common pattern"><y>#</y><d>2016-08-08</d><h>13:38</h><w>shader</w>any chance we could get anonymous recursive navigation? so you don&apos;t have to separately declare/provide the navigator? It seems to be a very common pattern</z><z id="t1470664800" t="nathanmarz @shader: you can open up an issue for it"><y>#</y><d>2016-08-08</d><h>14:00</h><w>nathanmarz</w>@shader: you can open up an issue for it</z><z id="t1470691126" t="jjunior130 @nathanmarz: nvm, it&apos;s working now. After I lein clean &amp; lein cljsbuild once yesterday, all I did between then and now was reboot my computer. Probably I didn&apos;t restart the repl I was in yesterday (I thought I did). I&apos;m good now. Namespace com.rpl.specter.macros is working now."><y>#</y><d>2016-08-08</d><h>21:18</h><w>jjunior130</w>@nathanmarz: nvm, it&apos;s working now. After I <code>lein clean</code> &amp; <code>lein cljsbuild once</code> yesterday, all I did between then and now was reboot my computer. Probably I didn&apos;t restart the repl I was in yesterday (I thought I did). I&apos;m good now. Namespace <code>com.rpl.specter.macros</code> is working now.</z><z id="t1470691185" t="nathanmarz @jjunior130: good to hear"><y>#</y><d>2016-08-08</d><h>21:19</h><w>nathanmarz</w>@jjunior130: good to hear</z><z id="t1470727373" t="yonatanel Any plans for a lookahead navigator, for example to select a map value if a sibling descendant matches a predicate?"><y>#</y><d>2016-08-09</d><h>07:22</h><w>yonatanel</w>Any plans for a lookahead navigator, for example to select a map value if a sibling descendant matches a predicate?</z><z id="t1470727491" t="codonnell @yonatanel: you could do something like that with selected?"><y>#</y><d>2016-08-09</d><h>07:24</h><w>codonnell</w>@yonatanel: you could do something like that with <code>selected?</code></z><z id="t1470727861" t="yonatanel very nice. thanks"><y>#</y><d>2016-08-09</d><h>07:31</h><w>yonatanel</w>very nice. thanks</z><z id="t1470728030" t="codonnell you&apos;re welcome"><y>#</y><d>2016-08-09</d><h>07:33</h><w>codonnell</w>you&apos;re welcome</z><z id="t1470832621" t="achesnais @nathanmarz: I wonder, any best practices on aliasing specter? I find that having the split between specter and specter.macros prevents from efficiently aliasing everything under one ‘specter’ alias. I really like using ns aliases for any non-core library I use, to improve readability/non-ambiguity in my code. Is this split due to the treatment of macros in Clojurescript?"><y>#</y><d>2016-08-10</d><h>12:37</h><w>achesnais</w>@nathanmarz: I wonder, any best practices on aliasing specter? I find that having the split between <code>specter</code> and <code>specter.macros</code> prevents from efficiently aliasing everything under one ‘specter’ alias. I really like using ns aliases for any non-core library I use, to improve readability/non-ambiguity in my code. Is this split due to the treatment of macros in Clojurescript?</z><z id="t1470833781" t="nathanmarz @achesnais: yes, it was done for cljs"><y>#</y><d>2016-08-10</d><h>12:56</h><w>nathanmarz</w>@achesnais: yes, it was done for cljs</z><z id="t1470833807" t="nathanmarz @achesnais: I use https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj to get everything into a single namespace"><y>#</y><d>2016-08-10</d><h>12:56</h><w>nathanmarz</w>@achesnais: I use <a href="https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj" target="_blank">https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj</a> to get everything into a single namespace</z><z id="t1470842219" t="sebastianpoeplau is there a way to do something like &quot;insert or update&quot; on a vector? let&apos;s say I have a vector [{:name &quot;Test&quot;} {:name &quot;Whatever&quot;}] and I would like to run f on the element that satisfies #(= &quot;Something&quot; (:name %)) (or create it, as in this case it doesn&apos;t exist)"><y>#</y><d>2016-08-10</d><h>15:16</h><w>sebastianpoeplau</w>is there a way to do something like &quot;insert or update&quot; on a vector? let&apos;s say I have a vector <code>[{:name &quot;Test&quot;} {:name &quot;Whatever&quot;}]</code> and I would like to run f on the element that satisfies <code>#(= &quot;Something&quot; (:name %))</code> (or create it, as in this case it doesn&apos;t exist)</z><z id="t1470842274" t="sebastianpoeplau I&apos;ve been playing with nil-&gt;val but when my predicate doesn&apos;t match on any element of the vector I get an empty vector and not nil"><y>#</y><d>2016-08-10</d><h>15:17</h><w>sebastianpoeplau</w>I&apos;ve been playing with <code>nil-&gt;val</code> but when my predicate doesn&apos;t match on any element of the vector I get an empty vector and not <code>nil</code></z><z id="t1470845270" t="achesnais @nathanmarz: thanks 🙂"><y>#</y><d>2016-08-10</d><h>16:07</h><w>achesnais</w>@nathanmarz: thanks <b>🙂</b></z><z id="t1470853564" t="mattsfrey hello, wondering if anyone knows how to replicate (update-in db [:contacts :show-modal?] assoc true) using transform"><y>#</y><d>2016-08-10</d><h>18:26</h><w>mattsfrey</w>hello, wondering if anyone knows how to replicate <pre>(update-in db [:contacts :show-modal?] assoc true)</pre> using transform</z><z id="t1470853615" t="mattsfrey I tried (transform [:contacts] #(assoc % :show-modal? true) db) and it seems to be doing transformations to much of the db for some reason"><y>#</y><d>2016-08-10</d><h>18:26</h><w>mattsfrey</w>I tried <pre>(transform [:contacts] #(assoc % :show-modal? true) db)</pre> and it seems to be doing transformations to much of the db for some reason</z><z id="t1470854413" t="mattsfrey nvm it is working, was another issue"><y>#</y><d>2016-08-10</d><h>18:40</h><w>mattsfrey</w>nvm it is working, was another issue</z><z id="t1470854443" t="mattsfrey but in the same vein, is there a more efficient or elegant way to write that^^ ?"><y>#</y><d>2016-08-10</d><h>18:40</h><w>mattsfrey</w>but in the same vein, is there a more efficient or elegant way to  write that^^ ?</z><z id="t1470854780" t="nathanmarz @sebastianpoeplau: can you show an example of the input/output you&apos;re looking for?"><y>#</y><d>2016-08-10</d><h>18:46</h><w>nathanmarz</w>@sebastianpoeplau: can you show an example of the input/output you&apos;re looking for?</z><z id="t1470854873" t="nathanmarz @mattsfrey: (setval [:contacts :show-modal?] true db)"><y>#</y><d>2016-08-10</d><h>18:47</h><w>nathanmarz</w>@mattsfrey: <code>(setval [:contacts :show-modal?] true db)</code></z><z id="t1470855783" t="mattsfrey ah that is nice, does it get the 6x performance of transform etc though?"><y>#</y><d>2016-08-10</d><h>19:03</h><w>mattsfrey</w>ah that is nice, does it get the 6x performance of transform etc though?</z><z id="t1470855794" t="mattsfrey or is that not a good example for comparison"><y>#</y><d>2016-08-10</d><h>19:03</h><w>mattsfrey</w>or is that not a good example for comparison</z><z id="t1470856758" t="nathanmarz @mattsfrey: yes, that will be much faster than update-in"><y>#</y><d>2016-08-10</d><h>19:19</h><w>nathanmarz</w>@mattsfrey: yes, that will be much faster than update-in</z><z id="t1470856805" t="nathanmarz the new update-in in 1.9 is much better but specter still outperforms it"><y>#</y><d>2016-08-10</d><h>19:20</h><w>nathanmarz</w>the new update-in in 1.9 is much better but specter still outperforms it</z><z id="t1470856819" t="mattsfrey oic, good to know, thanks!"><y>#</y><d>2016-08-10</d><h>19:20</h><w>mattsfrey</w>oic, good to know, thanks!</z><z id="t1470864717" t="sebastianpoeplau @nathanmarz: of course - say I have (defn f [person] (assoc person :some &quot;value&quot;)) , then I would like the transformation to return [{:name &quot;Test&quot; :some &quot;value&quot;} {:name &quot;Whatever&quot;}] when called on input [{:name &quot;Test&quot;} {:name &quot;Whatever&quot;}] , and it should return the same value when used on input [{:name &quot;Whatever&quot;}] . that is, it should update the entry that has :name &quot;Test&quot; or insert it if it&apos;s not in the vector"><y>#</y><d>2016-08-10</d><h>21:31</h><w>sebastianpoeplau</w>@nathanmarz: of course - say I have <code>(defn f [person] (assoc person :some &quot;value&quot;))</code>, then I would like the transformation to return <code>[{:name &quot;Test&quot; :some &quot;value&quot;} {:name &quot;Whatever&quot;}]</code> when called on input <code>[{:name &quot;Test&quot;} {:name &quot;Whatever&quot;}]</code>, and it should return the same value when used on input <code>[{:name &quot;Whatever&quot;}]</code>. that is, it should update the entry that has <code>:name &quot;Test&quot;</code> or insert it if it&apos;s not in the vector</z><z id="t1470864924" t="sebastianpoeplau my best guess so far is the following: (setval [(not-selected? ALL #(= &quot;Test&quot; (:name %))) END] [{:name &quot;Test&quot;}]) ; insert if necessary (transform [ALL #(= &quot;Test&quot; (:name %))] f my-vector) ; apply my function "><y>#</y><d>2016-08-10</d><h>21:35</h><w>sebastianpoeplau</w>my best guess so far is the following:
<pre>(setval [(not-selected? ALL #(= &quot;Test&quot; (:name %))) END] [{:name &quot;Test&quot;}]) ; insert if necessary
(transform [ALL #(= &quot;Test&quot; (:name %))] f my-vector) ; apply my function
</pre></z><z id="t1470865215" t="sebastianpoeplau I&apos;m just realizing that I could change the lambda #(= &quot;Test&quot; (:name %)) to :name #(= &quot;Test&quot; %) , but the question is still whether I can accomplish both steps, insertion and transformation, in one go"><y>#</y><d>2016-08-10</d><h>21:40</h><w>sebastianpoeplau</w>I&apos;m just realizing that I could change the lambda <code>#(= &quot;Test&quot; (:name %))</code> to <code>:name #(= &quot;Test&quot; %)</code>, but the question is still whether I can accomplish both steps, insertion and transformation, in one go</z><z id="t1470866219" t="nathanmarz @sebastianpoeplau: I think doing it the way you&apos;re doing it is the cleanest approach"><y>#</y><d>2016-08-10</d><h>21:56</h><w>nathanmarz</w>@sebastianpoeplau: I think doing it the way you&apos;re doing it is the cleanest approach</z><z id="t1470866283" t="nathanmarz I would recommend factoring out [ALL #(= &quot;Test&quot; (:name %)))] into a composite navigator and re-using it in each call"><y>#</y><d>2016-08-10</d><h>21:58</h><w>nathanmarz</w>I would recommend factoring out [ALL #(= &quot;Test&quot; (:name %)))] into a composite navigator and re-using it in each call</z><z id="t1470866498" t="nathanmarz @sebastianpoeplau: (def person-nav (comp-paths ALL (paramsfn [id] [p] (= id (:name p))))) (setval [(not-selected? (person-nav &quot;Test&quot;)) END] [{:name &quot;Test&quot;}] my-vector) (transform (person-nav &quot;Test&quot;) #(assoc % :some &quot;hi&quot;) my-vector) "><y>#</y><d>2016-08-10</d><h>22:01</h><w>nathanmarz</w>@sebastianpoeplau: 
<pre>(def person-nav (comp-paths ALL (paramsfn [id] [p] (= id (:name p)))))

(setval [(not-selected? (person-nav &quot;Test&quot;)) END] [{:name &quot;Test&quot;}] my-vector)
(transform (person-nav &quot;Test&quot;) #(assoc % :some &quot;hi&quot;) my-vector)
</pre></z><z id="t1470900869" t="sebastianpoeplau @nathanmarz: cool, thank you!"><y>#</y><d>2016-08-11</d><h>07:34</h><w>sebastianpoeplau</w>@nathanmarz: cool, thank you!</z><z id="t1470912153" t="borkdude nice challenge for specter: https://stackoverflow.com/questions/38893968/how-to-select-keys-in-nested-maps-in-clojure"><y>#</y><d>2016-08-11</d><h>10:42</h><w>borkdude</w>nice challenge for specter: <a href="https://stackoverflow.com/questions/38893968/how-to-select-keys-in-nested-maps-in-clojure" target="_blank">https://stackoverflow.com/questions/38893968/how-to-select-keys-in-nested-maps-in-clojure</a></z><z id="t1470912658" t="borkdude It brings me to the question how you prune a map in specter"><y>#</y><d>2016-08-11</d><h>10:50</h><w>borkdude</w>It brings me to the question how you prune a map in specter</z><z id="t1470912700" t="borkdude like {:a 1, :b 2, :c 3} =&gt; {:a 1} , it must be possible, but I haven&apos;t used this yet"><y>#</y><d>2016-08-11</d><h>10:51</h><w>borkdude</w>like <code>{:a 1, :b 2, :c 3}</code> =&gt; <code>{:a 1}</code>, it must be possible, but I haven&apos;t used this yet</z><z id="t1470912716" t="borkdude I was thinking something with multi-path and filterer ?"><y>#</y><d>2016-08-11</d><h>10:51</h><w>borkdude</w>I was thinking something with <code>multi-path</code> and <code>filterer</code>?</z><z id="t1470919917" t="borkdude Ah, the question is even different than I understood it. I thought he wanted {:a 1, :b 2, :c {:d 3}} leaving the structure intact"><y>#</y><d>2016-08-11</d><h>12:51</h><w>borkdude</w>Ah, the question is even different than I understood it. I thought he wanted <code>{:a 1, :b 2, :c {:d 3}}</code> leaving the structure intact</z><z id="t1470920554" t="nathanmarz @borkdude: submap is the specter analogue to select-keys"><y>#</y><d>2016-08-11</d><h>13:02</h><w>nathanmarz</w>@borkdude: <code>submap</code> is the specter analogue to <code>select-keys</code></z><z id="t1470920568" t="borkdude going to try it"><y>#</y><d>2016-08-11</d><h>13:02</h><w>borkdude</w>going to try it</z><z id="t1470920579" t="nathanmarz (into {} (traverse (multi-path (submap [:a :b]) [:c (submap [:d])]) {:a 1 :b 2 :c {:d 3}}))"><y>#</y><d>2016-08-11</d><h>13:02</h><w>nathanmarz</w><code>(into {} (traverse (multi-path (submap [:a :b]) [:c (submap [:d])]) {:a 1 :b 2 :c {:d 3}}))</code></z><z id="t1470920687" t="nathanmarz could make a function that converts [:a :b [:c :d]] to that path"><y>#</y><d>2016-08-11</d><h>13:04</h><w>nathanmarz</w>could make a function that converts <code>[:a :b [:c :d]] </code> to that path</z><z id="t1470920723" t="borkdude (prune m [:a :b [:c :d]]) "><y>#</y><d>2016-08-11</d><h>13:05</h><w>borkdude</w><pre>(prune m [:a :b [:c :d]])
</pre></z><z id="t1470920755" t="borkdude very clean"><y>#</y><d>2016-08-11</d><h>13:05</h><w>borkdude</w>very clean</z><z id="t1470920813" t="nathanmarz a better way is to capture the idea of &quot;nested submaps&quot; as a navigator"><y>#</y><d>2016-08-11</d><h>13:06</h><w>nathanmarz</w>a better way is to capture the idea of &quot;nested submaps&quot; as a navigator</z><z id="t1470920839" t="nathanmarz (into {} (traverse (nested-submaps :a :b [:c :d]) m))"><y>#</y><d>2016-08-11</d><h>13:07</h><w>nathanmarz</w><code>(into {} (traverse (nested-submaps :a :b [:c :d]) m))</code></z><z id="t1471245949" t="yonatanel In the bank account example, is it possible to collect money from several accounts until a certain sum is reached or no more money is available? Is it then possible to get all the collections made (account+amount pairs) for event sourcing?"><y>#</y><d>2016-08-15</d><h>07:25</h><w>yonatanel</w>In the bank account example, is it possible to collect money from several accounts until a certain sum is reached or no more money is available? Is it then possible to get all the collections made (account+amount pairs) for event sourcing?</z><z id="t1471253506" t="nathanmarz @yonatanel: you could do a subselect of all the accounts and then do an srange-dynamic to choose the first N accounts that sum up to what you&apos;re looking for"><y>#</y><d>2016-08-15</d><h>09:31</h><w>nathanmarz</w>@yonatanel: you could do a subselect of all the accounts and then do an srange-dynamic to choose the first N accounts that sum up to what you&apos;re looking for</z><z id="t1471256451" t="yonatanel Thanks. I&apos;ll check it out."><y>#</y><d>2016-08-15</d><h>10:20</h><w>yonatanel</w>Thanks. I&apos;ll check it out.</z><z id="t1471276251" t="cdine @nathanmarz: Just stopping by, to say thanks for this wonderful library. Great showcase of what simple and powerful abstractions can do.."><y>#</y><d>2016-08-15</d><h>15:50</h><w>cdine</w>@nathanmarz:  Just stopping by, to say thanks for this wonderful library. Great showcase of what simple and powerful abstractions can do..</z><z id="t1471276348" t="nathanmarz @cdine: thanks, glad you&apos;re enjoying it"><y>#</y><d>2016-08-15</d><h>15:52</h><w>nathanmarz</w>@cdine: thanks, glad you&apos;re enjoying it</z><z id="t1471329269" t="conaw What’s the easiest way to dissoc-in, or to transform a value to not being there?"><y>#</y><d>2016-08-16</d><h>06:34</h><w>conaw</w>What’s the easiest way to dissoc-in, or to transform a value to not being there?</z><z id="t1471329332" t="conaw ideally, I’d like to be able to navigate to a value using walker, and then just setval to nothing, not nil, but nothing, is that possible?"><y>#</y><d>2016-08-16</d><h>06:35</h><w>conaw</w>ideally, I’d like to be able to navigate to a value using walker, and then just setval to nothing, not nil, but nothing, is that possible?</z><z id="t1471330686" t="yonatanel @conaw: Perhaps navigate one step behind using selected? and then transform with dissoc. Still not elegant though"><y>#</y><d>2016-08-16</d><h>06:58</h><w>yonatanel</w>@conaw: Perhaps navigate one step behind using <code>selected?</code> and then transform with dissoc. Still not elegant though</z><z id="t1471330978" t="conaw looks like this is the closest we’ve got right now to what I’m looking for"><y>#</y><d>2016-08-16</d><h>07:02</h><w>conaw</w>looks like this is the closest we’ve got right now to what I’m looking for</z><z id="t1471330993" t="conaw based on this https://github.com/nathanmarz/specter/issues/83"><y>#</y><d>2016-08-16</d><h>07:03</h><w>conaw</w>based on this <a href="https://github.com/nathanmarz/specter/issues/83" target="_blank">https://github.com/nathanmarz/specter/issues/83</a></z><z id="t1471335996" t="conaw so, heres where I’m stuck. right now I’m able to filter out a given value from a vector that is nested one level deep, I’m trying to figure out how to do this recursively though so I could go as deep as needed. the following works (defpathedfn remove-x [x] (filterer #(not= x %))) (defn t3 [v a] (select [ (remove-x a) ALL (if-path vector? (remove-x a) STAY)] v)) (deftest test1 (testing &quot;removal&quot; (is (= [1 2 3 [4]] (t3 [1 2 3 [4 5] 5] 5))))) what I want is (= [1 2 3 [4 [6]]] (t3 [1 2 3 [4 [5 6] 5] 5] 5))"><y>#</y><d>2016-08-16</d><h>08:26</h><w>conaw</w>so, heres where I’m stuck. right now I’m able to filter out a given value from a vector that is nested one level deep, I’m trying to figure out how to do this recursively though so I could go as deep as needed.  

the following works

<pre>(defpathedfn remove-x [x]
  (filterer #(not= x %)))


(defn t3 [v a]
  (select [
           (remove-x a)
           ALL
           (if-path vector?
                    (remove-x a)
                    STAY)] v))

(deftest test1
  (testing &quot;removal&quot;
    (is
     (= [1 2 3 [4]]
        (t3 [1 2 3 [4 5] 5] 5)))))
</pre>

what I want is 
(= [1 2 3 [4 [6]]]
     (t3 [1 2 3 [4 [5 6] 5] 5] 5))</z><z id="t1471346960" t="nathanmarz @conaw: here&apos;s one way to do it"><y>#</y><d>2016-08-16</d><h>11:29</h><w>nathanmarz</w>@conaw: here&apos;s one way to do it</z><z id="t1471346971" t="nathanmarz (defn remove-x [x] (fn [v] (filterv #(not= x %) v))) (declarepath AllVectors) (providepath AllVectors (if-path vector? (stay-then-continue ALL AllVectors))) (transform AllVectors (remove-x 5) [1 2 3 [4 [5 6] 5] 5]) "><y>#</y><d>2016-08-16</d><h>11:29</h><w>nathanmarz</w><pre>(defn remove-x [x]
  (fn [v]
    (filterv #(not= x %) v)))

(declarepath AllVectors)
(providepath AllVectors
  (if-path vector?
    (stay-then-continue
      ALL
      AllVectors)))

(transform AllVectors (remove-x 5) [1 2 3 [4 [5 6] 5] 5])
</pre></z><z id="t1471347033" t="nathanmarz you could also use ALL-ELEM-SEQ from that linked github issue in conjunction with AllVectors"><y>#</y><d>2016-08-16</d><h>11:30</h><w>nathanmarz</w>you could also use <code>ALL-ELEM-SEQ</code> from that linked github issue in conjunction with <code>AllVectors</code></z><z id="t1471347074" t="nathanmarz which would look like: (setval [AllVectors ALL-ELEM-SEQ #(= 5 (first %))] nil [1 2 3 [4 [5 6] 5] 5])"><y>#</y><d>2016-08-16</d><h>11:31</h><w>nathanmarz</w>which would look like: <code>(setval [AllVectors ALL-ELEM-SEQ #(= 5 (first %))] nil [1 2 3 [4 [5 6] 5] 5])</code></z><z id="t1471349546" t="joshkh I&apos;m attempting to &quot;shake&quot; a map of all top level keys where where a deeply nested key in each branch matches a predicate. Is that something I would tackle with transform? Or would I use select in combination with filterer?"><y>#</y><d>2016-08-16</d><h>12:12</h><w>joshkh</w>I&apos;m attempting to &quot;shake&quot; a map of all top level keys where where a deeply nested key in each branch matches a predicate. Is that something I would tackle with transform? Or would I use select in combination with filterer?</z><z id="t1471349608" t="nathanmarz what&apos;s an example of the input/output you&apos;re looking for?"><y>#</y><d>2016-08-16</d><h>12:13</h><w>nathanmarz</w>what&apos;s an example of the input/output you&apos;re looking for?</z><z id="t1471349894" t="joshkh In this map, I only want to keep top level branches where at least one of the maps in :where have an :op value of &quot;=&quot; {:k1 {:where [{:op &quot;=&quot; :value &quot;A&quot;} {:op &quot;ignore&quot; :value &quot;X&quot;}]} :k2 {:where [{:op &quot;&lt;&quot; :value &quot;A&quot;} {:op &quot;lookup&quot; :value &quot;C&quot;}]} :k3 {:where [{:op &quot;=&quot; :value &quot;A&quot;} {:op &quot;lookup&quot; :value &quot;E&quot;}]}} ; result {:k1 {:where [{:op &quot;=&quot; :value &quot;A&quot;} {:op &quot;ignore&quot; :value &quot;X&quot;}]} :k3 {:where [{:op &quot;=&quot; :value &quot;A&quot;} {:op &quot;lookup&quot; :value &quot;E&quot;}]}} "><y>#</y><d>2016-08-16</d><h>12:18</h><w>joshkh</w>In this map, I only want to keep top level branches where at least one of the maps in :where have an :op value of &quot;=&quot;

<pre>{:k1 {:where [{:op    &quot;=&quot;
               :value &quot;A&quot;}
              {:op    &quot;ignore&quot;
               :value &quot;X&quot;}]}
 :k2 {:where [{:op    &quot;&lt;&quot;
               :value &quot;A&quot;}
              {:op    &quot;lookup&quot;
               :value &quot;C&quot;}]}
 :k3 {:where [{:op    &quot;=&quot;
               :value &quot;A&quot;}
              {:op    &quot;lookup&quot;
               :value &quot;E&quot;}]}}

; result

{:k1 {:where [{:op    &quot;=&quot;
               :value &quot;A&quot;}
              {:op    &quot;ignore&quot;
               :value &quot;X&quot;}]}
 :k3 {:where [{:op    &quot;=&quot;
               :value &quot;A&quot;}
              {:op    &quot;lookup&quot;
               :value &quot;E&quot;}]}}
</pre></z><z id="t1471349935" t="joshkh (k2 doesn&apos;t make the cut)"><y>#</y><d>2016-08-16</d><h>12:18</h><w>joshkh</w>(k2 doesn&apos;t make the cut)</z><z id="t1471350218" t="joshkh I can build a path to :op no problem, but I lose all parent values when using select . I considered using collect-one at the root of the path while applying filterer at the :op level, but I got the impression I was misunderstanding something fundamental. 🙂"><y>#</y><d>2016-08-16</d><h>12:23</h><w>joshkh</w>I can build a path to :op no problem, but I lose all parent values when using <code>select</code>.  I considered using <code>collect-one</code> at the root of the path while applying <code>filterer</code> at the :op level, but I got the impression I was misunderstanding something fundamental. <b>🙂</b></z><z id="t1471350248" t="nathanmarz (into {} (traverse [ALL (selected? LAST :where ALL :op #(= &quot;=&quot; %))] data))"><y>#</y><d>2016-08-16</d><h>12:24</h><w>nathanmarz</w><code>(into {} (traverse [ALL (selected? LAST :where ALL :op #(= &quot;=&quot; %))] data))</code></z><z id="t1471350318" t="nathanmarz you can do it with select too but traverse is more efficient"><y>#</y><d>2016-08-16</d><h>12:25</h><w>nathanmarz</w>you can do it with <code>select</code> too but <code>traverse</code> is more efficient</z><z id="t1471350345" t="nathanmarz (doesn&apos;t create any intermediate sequence)"><y>#</y><d>2016-08-16</d><h>12:25</h><w>nathanmarz</w>(doesn&apos;t create any intermediate sequence)</z><z id="t1471350351" t="joshkh Ah, okay"><y>#</y><d>2016-08-16</d><h>12:25</h><w>joshkh</w>Ah, okay</z><z id="t1471350391" t="joshkh I think I overlooked selected? as well."><y>#</y><d>2016-08-16</d><h>12:26</h><w>joshkh</w>I think I overlooked <code>selected?</code> as well.</z><z id="t1471350509" t="joshkh In your code response, what&apos;s the difference between 1) using filterer , or 2) passing an anonymous function to the selection path, as you did?"><y>#</y><d>2016-08-16</d><h>12:28</h><w>joshkh</w>In your code response, what&apos;s the difference between 1) using <code>filterer</code> , or 2) passing an anonymous function to the selection path, as you did?</z><z id="t1471350541" t="nathanmarz filterer navigates you to a new sequence"><y>#</y><d>2016-08-16</d><h>12:29</h><w>nathanmarz</w>filterer navigates you to a new sequence</z><z id="t1471350553" t="nathanmarz a function acts as a predicate and stops navigation at that point if the predicate is false"><y>#</y><d>2016-08-16</d><h>12:29</h><w>nathanmarz</w>a function acts as a predicate and stops navigation at that point if the predicate is false</z><z id="t1471350572" t="nathanmarz for selected? , it acts as a predicate where &quot;true&quot; is when anything is selected"><y>#</y><d>2016-08-16</d><h>12:29</h><w>nathanmarz</w>for <code>selected?</code>, it acts as a predicate where  &quot;true&quot; is when anything is selected</z><z id="t1471350591" t="nathanmarz since filterer doesn&apos;t stop navigation, that wouldn&apos;t be relevant in this case"><y>#</y><d>2016-08-16</d><h>12:29</h><w>nathanmarz</w>since filterer doesn&apos;t stop navigation, that wouldn&apos;t be relevant in this case</z><z id="t1471350661" t="joshkh Okay, that helps a lot. Thanks for the explanation and for solving my use case."><y>#</y><d>2016-08-16</d><h>12:31</h><w>joshkh</w>Okay, that helps a lot. Thanks for the explanation and for solving my use case.</z><z id="t1471350677" t="nathanmarz no problem"><y>#</y><d>2016-08-16</d><h>12:31</h><w>nathanmarz</w>no problem</z><z id="t1471350745" t="nathanmarz this is worth reading through if you haven&apos;t already: https://github.com/nathanmarz/specter/wiki/List-of-Navigators"><y>#</y><d>2016-08-16</d><h>12:32</h><w>nathanmarz</w>this is worth reading through if you haven&apos;t already: <a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators</a></z><z id="t1471351112" t="joshkh Great!"><y>#</y><d>2016-08-16</d><h>12:38</h><w>joshkh</w>Great!</z><z id="t1471356421" t="darwin any hints how to rewrite this code to be specter 0.12 compatible? https://github.com/binaryage/dirac/blob/417b81c3959e9b156f148f9448f2935f33631658/src/implant/dirac/implant/automation/reps.cljs#L43-L52"><y>#</y><d>2016-08-16</d><h>14:07</h><w>darwin</w>any hints how to rewrite this code to be specter 0.12 compatible?
<a href="https://github.com/binaryage/dirac/blob/417b81c3959e9b156f148f9448f2935f33631658/src/implant/dirac/implant/automation/reps.cljs#L43-L52" target="_blank">https://github.com/binaryage/dirac/blob/417b81c3959e9b156f148f9448f2935f33631658/src/implant/dirac/implant/automation/reps.cljs#L43-L52</a></z><z id="t1471356451" t="darwin I’m getting &quot;Cannot read property &apos;0&apos; of null” somewhere deep in specter and I wasn’t able to figure out what is going wrong 😞"><y>#</y><d>2016-08-16</d><h>14:07</h><w>darwin</w>I’m getting &quot;Cannot read property &apos;0&apos; of null” somewhere deep in specter and I wasn’t able to figure out what is going wrong <b>😞</b></z><z id="t1471356500" t="darwin the RepWalker is used in this function: https://github.com/binaryage/dirac/blob/417b81c3959e9b156f148f9448f2935f33631658/src/implant/dirac/implant/automation/reps.cljs#L62-L63"><y>#</y><d>2016-08-16</d><h>14:08</h><w>darwin</w>the RepWalker is used in this function:
<a href="https://github.com/binaryage/dirac/blob/417b81c3959e9b156f148f9448f2935f33631658/src/implant/dirac/implant/automation/reps.cljs#L62-L63" target="_blank">https://github.com/binaryage/dirac/blob/417b81c3959e9b156f148f9448f2935f33631658/src/implant/dirac/implant/automation/reps.cljs#L62-L63</a></z><z id="t1471356887" t="nathanmarz @darwin: need a reproducible test case"><y>#</y><d>2016-08-16</d><h>14:14</h><w>nathanmarz</w>@darwin: need a reproducible test case</z><z id="t1471358829" t="joshkh Is it okay to nest selected? functions? Going back to your (into {} (traverse [ALL (selected? LAST :where ALL :op #(= &quot;=&quot; %))] data)) response, what if I wanted to also restrict the selection to the :where vec having a count greater than one?"><y>#</y><d>2016-08-16</d><h>14:47</h><w>joshkh</w>Is it okay to nest <code>selected?</code> functions? Going back to your <code>(into {} (traverse [ALL (selected? LAST :where ALL :op #(= &quot;=&quot; %))] data))</code> response, what if I wanted to also restrict the selection to the :where vec having a count greater than one?</z><z id="t1471358905" t="joshkh Oh wait, I&apos;d just use a function there as well."><y>#</y><d>2016-08-16</d><h>14:48</h><w>joshkh</w>Oh wait, I&apos;d just use a function there as well.</z><z id="t1471358957" t="joshkh Oh, double wait, I&apos;m not sure what I just said made sense."><y>#</y><d>2016-08-16</d><h>14:49</h><w>joshkh</w>Oh, double wait, I&apos;m not sure what I just said made sense.</z><z id="t1471359506" t="joshkh Okay, I think I got it? Two separate selected? expressions: (traverse [s/ALL (s/selected? s/LAST :where #(&lt; 1 (count %))) (s/selected? s/LAST :where s/ALL :op #(= &quot;=&quot; %))] data) "><y>#</y><d>2016-08-16</d><h>14:58</h><w>joshkh</w>Okay, I think I got it? Two separate <code>selected?</code> expressions:
<pre>(traverse [s/ALL
           (s/selected? s/LAST :where #(&lt; 1 (count %)))
           (s/selected? s/LAST :where s/ALL :op #(= &quot;=&quot; %))] data)
</pre></z><z id="t1471359594" t="codonnell @joshkh: I think you could do it with (traverse [ALL (selected? LAST :where #(&lt; 1 (count %)) ALL :op #(= &quot;=&quot; %))] data)"><y>#</y><d>2016-08-16</d><h>14:59</h><w>codonnell</w>@joshkh: I think you could do it with <code>(traverse [ALL (selected? LAST :where #(&lt; 1 (count %)) ALL :op #(= &quot;=&quot; %))] data)</code></z><z id="t1471359657" t="codonnell also, if you&apos;re traversing a map, you could use MAP-VALS instead of LAST"><y>#</y><d>2016-08-16</d><h>15:00</h><w>codonnell</w>also, if you&apos;re traversing a map, you could use <code>MAP-VALS</code> instead of <code>LAST</code></z><z id="t1471359723" t="joshkh Ah, that&apos;s what how I was thinking about it originally, but I wasn&apos;t sure how ALL fit into the path after the function. I guess the obvious answer is that it fits in just fine. 🙂"><y>#</y><d>2016-08-16</d><h>15:02</h><w>joshkh</w>Ah, that&apos;s what how I was thinking about it originally, but I wasn&apos;t sure how ALL fit into the path after the function. I guess the obvious answer is that it fits in just fine. <b>🙂</b></z><z id="t1471359766" t="joshkh And thanks for the advice about MAP-VALS. It&apos;ll be easier to remember the data structure when I come back to this in the future."><y>#</y><d>2016-08-16</d><h>15:02</h><w>joshkh</w>And thanks for the advice about MAP-VALS. It&apos;ll be easier to remember the data structure when I come back to this in the future.</z><z id="t1471359787" t="codonnell for sure, and it should be a little more efficient, too!"><y>#</y><d>2016-08-16</d><h>15:03</h><w>codonnell</w>for sure, and it should be a little more efficient, too!</z><z id="t1471360148" t="nathanmarz ALL is needed in this case since traverse must emit key/value pairs"><y>#</y><d>2016-08-16</d><h>15:09</h><w>nathanmarz</w><code>ALL</code> is needed in this case since traverse must emit key/value pairs</z><z id="t1471360861" t="codonnell good point @nathanmarz. I&apos;m not thinking very clearly today. @joshkh, you can&apos;t use MAP-VALS , since MAP-VALS acts the same as [ALL LAST] , but you need the ALL outside of selected? and LAST inside it."><y>#</y><d>2016-08-16</d><h>15:21</h><w>codonnell</w>good point @nathanmarz. I&apos;m not thinking very clearly today. @joshkh, you can&apos;t use <code>MAP-VALS</code>, since <code>MAP-VALS</code> acts the same as <code>[ALL LAST]</code>, but you need the <code>ALL</code> outside of <code>selected?</code> and <code>LAST</code> inside it.</z><z id="t1471360913" t="joshkh Got it!"><y>#</y><d>2016-08-16</d><h>15:21</h><w>joshkh</w>Got it!</z><z id="t1471367848" t="conaw @nathanmarz: much obliged"><y>#</y><d>2016-08-16</d><h>17:17</h><w>conaw</w>@nathanmarz: much obliged</z><z id="t1471391075" t="richiardiandrea I was having working at a big reduce today and I thought, maybe specter will be able to help me. Basically the atomic input is: [{:timestamp 14424 :chat-id 2 :payload &quot;bla&quot;} {:timestamp 14421 :chat-id 1 :payload &quot;asd&quot;} {:timestamp 14400 :chat-id 1 :payload &quot;test&quot;}] I have a list of those that I want to convert to a map indexed by chat-id but keeping the oldest timestamp in the value, as: {1 {:timestamp 14000 :messages [the list]} 2 {:timestamp 14424 :messages [the list]}} Can you folks give me a hint (without full solution is fine) from where to start exploring a solution with specter?"><y>#</y><d>2016-08-16</d><h>23:44</h><w>richiardiandrea</w>I was having working at a big reduce today and I thought, maybe specter will be able to help me. Basically the atomic input is:

<pre>[{:timestamp 14424
  :chat-id 2
  :payload &quot;bla&quot;}
 {:timestamp 14421
  :chat-id 1
  :payload &quot;asd&quot;}
  {:timestamp 14400
  :chat-id 1
  :payload &quot;test&quot;}]
</pre>

I have a list of those that I want to convert to a map indexed by <code>chat-id</code> but keeping the oldest timestamp in the value, as:

<pre>{1 {:timestamp 14000 :messages [the list]}
  2 {:timestamp 14424 :messages [the list]}}
</pre>

Can you folks give me a hint (without full solution is fine) from where to start exploring a solution with specter?</z><z id="t1471391589" t="codonnell @richiardiandrea: could you give a small example of input/output?"><y>#</y><d>2016-08-16</d><h>23:53</h><w>codonnell</w>@richiardiandrea: could you give a small example of input/output?</z><z id="t1471391698" t="richiardiandrea @codonnell: thanks for answering, yes of course, is the above not enough? I am worried it can take too much space"><y>#</y><d>2016-08-16</d><h>23:54</h><w>richiardiandrea</w>@codonnell: thanks for answering, yes of course, is the above not enough? I am worried it can take too much space</z><z id="t1471391862" t="codonnell @richiardiandrea: Thanks, that clarifies it."><y>#</y><d>2016-08-16</d><h>23:57</h><w>codonnell</w>@richiardiandrea: Thanks, that clarifies it.</z><z id="t1471391868" t="richiardiandrea 😄"><y>#</y><d>2016-08-16</d><h>23:57</h><w>richiardiandrea</w><b>😄</b></z><z id="t1471391887" t="codonnell Would you list just be a list of the payloads for all messages with the given chat-id?"><y>#</y><d>2016-08-16</d><h>23:58</h><w>codonnell</w>Would you list just be a list of the payloads for all messages with the given chat-id?</z><z id="t1471391893" t="richiardiandrea so I need to carry with me the :timestamp"><y>#</y><d>2016-08-16</d><h>23:58</h><w>richiardiandrea</w>so I need to carry with me the <code>:timestamp</code></z><z id="t1471391895" t="richiardiandrea yes"><y>#</y><d>2016-08-16</d><h>23:58</h><w>richiardiandrea</w>yes</z><z id="t1471391928" t="richiardiandrea the calculation on the timestamp is a bit mysterious to me at the moment"><y>#</y><d>2016-08-16</d><h>23:58</h><w>richiardiandrea</w>the calculation on the timestamp is a bit mysterious to me at the moment</z><z id="t1471391949" t="codonnell Does the list of messages need to be in order of timestamp?"><y>#</y><d>2016-08-16</d><h>23:59</h><w>codonnell</w>Does the list of messages need to be in order of timestamp?</z><z id="t1471391952" t="richiardiandrea (specter newbie)"><y>#</y><d>2016-08-16</d><h>23:59</h><w>richiardiandrea</w>(specter newbie)</z><z id="t1471391959" t="richiardiandrea yes preferably yes"><y>#</y><d>2016-08-16</d><h>23:59</h><w>richiardiandrea</w>yes preferably yes</z><z id="t1471392126" t="codonnell In my opinion, the best solution just uses reduce . Your accumulator would be a map keyed by chat-id with values being a sorted-map storing messages, keyed by timestamp."><y>#</y><d>2016-08-17</d><h>00:02</h><w>codonnell</w>In my opinion, the best solution just uses <code>reduce</code>. Your accumulator would be a map keyed by chat-id with values being a <code>sorted-map</code> storing messages, keyed by timestamp.</z><z id="t1471392171" t="richiardiandrea Ok yes that is what I am doing as well :)"><y>#</y><d>2016-08-17</d><h>00:02</h><w>richiardiandrea</w>Ok yes that is what I am doing as well :)</z><z id="t1471392318" t="richiardiandrea It was just out of curiosity, is it because of the oldest timestamp? In general, just for learning, can I carry a counter while I navigate the data with specter?"><y>#</y><d>2016-08-17</d><h>00:05</h><w>richiardiandrea</w>It was just out of curiosity, is it because of the oldest timestamp? In general, just for learning, can I carry a counter while I navigate the data with specter?</z><z id="t1471392618" t="codonnell I can&apos;t think of a great way to do it using specter. I think specter is better for selecting from or transforming pieces of a nested data structure individually, while your task is aggregating all of your structure into something new. Maybe @nathanmarz has more insight."><y>#</y><d>2016-08-17</d><h>00:10</h><w>codonnell</w>I can&apos;t think of a great way to do it using specter. I think specter is better for selecting from or transforming pieces of a nested data structure individually, while your task is aggregating all of your structure into something new. Maybe @nathanmarz  has more insight.</z><z id="t1471392757" t="richiardiandrea @codonnell: ok thanks a lot "><y>#</y><d>2016-08-17</d><h>00:12</h><w>richiardiandrea</w>@codonnell: ok thanks a lot </z><z id="t1471392851" t="codonnell you&apos;re welcome"><y>#</y><d>2016-08-17</d><h>00:14</h><w>codonnell</w>you&apos;re welcome</z><z id="t1471473407" t="darwin @nathanmarz: FYI this was needed for fixing my earlier issue (after upgrading to 0.12): https://github.com/binaryage/dirac/commit/45db785491751cd9e23440139f9b2554094c1759"><y>#</y><d>2016-08-17</d><h>22:36</h><w>darwin</w>@nathanmarz: FYI this was needed for fixing my earlier issue (after upgrading to 0.12):
<a href="https://github.com/binaryage/dirac/commit/45db785491751cd9e23440139f9b2554094c1759" target="_blank">https://github.com/binaryage/dirac/commit/45db785491751cd9e23440139f9b2554094c1759</a></z><z id="t1471474634" t="nathanmarz @darwin hmm, ok"><y>#</y><d>2016-08-17</d><h>22:57</h><w>nathanmarz</w>@darwin hmm, ok</z><z id="t1471474648" t="nathanmarz @darwin do you have a full stack trace from when the error was happening?"><y>#</y><d>2016-08-17</d><h>22:57</h><w>nathanmarz</w>@darwin do you have a full stack trace from when the error was happening?</z><z id="t1471509671" t="darwin @nathanmarz: unfortunately I was unable to make source-mapping work for some strange reason, so I can see only trace with compiled files"><y>#</y><d>2016-08-18</d><h>08:41</h><w>darwin</w>@nathanmarz: unfortunately I was unable to make source-mapping work for some strange reason, so I can see only trace with compiled files</z><z id="t1471509688" t="darwin the problem is somewhere in com.rpl.specter.must"><y>#</y><d>2016-08-18</d><h>08:41</h><w>darwin</w>the problem is somewhere in com.rpl.specter.must</z><z id="t1471509772" t="darwin https://dl.dropboxusercontent.com/u/559047/specter-dirac-issue.png"><y>#</y><d>2016-08-18</d><h>08:42</h><w>darwin</w><a href="https://dl.dropboxusercontent.com/u/559047/specter-dirac-issue.png" target="_blank">https://dl.dropboxusercontent.com/u/559047/specter-dirac-issue.png</a></z><z id="t1471524422" t="nathanmarz @darwin ok thanks, that&apos;s helpful"><y>#</y><d>2016-08-18</d><h>12:47</h><w>nathanmarz</w>@darwin ok thanks, that&apos;s helpful</z><z id="t1471596019" t="rodeorockstar I have another newbie question regarding Specter. Is this something that I can easily do? I have nested vectors of strings representing a tree. If a vector directly follows a string then it is a subtree. I&apos;d like to update the tree in a similar fashion to update-in when dealing with maps. In this non working example I&apos;d want to append &quot;SUB-A-2-2-2&quot; to the &quot;SUB-A-2-2&quot; &quot;node.&quot;: (let [t [&quot;A&quot; [&quot;SUB-A-1&quot; &quot;SUB-A-2&quot; [&quot;SUB-A-2-1&quot; &quot;SUB-A-2-2&quot; [&quot;SUB-A-2-2-1&quot;]]]]] (s/transform [&quot;A&quot; &quot;SUB-A-2&quot; &quot;SUB-A-2-2&quot;] (fn [node] (conj node &quot;SUB-A-2-2-2&quot;)) t) #_[&quot;A&quot; [&quot;SUB-A-1&quot; &quot;SUB-A-2&quot; [&quot;SUB-A-2-1&quot; &quot;SUB-A-2-2&quot; [&quot;SUB-A-2-2-1&quot; ; New: &quot;SUB-A-2-2-2&quot;]]]])"><y>#</y><d>2016-08-19</d><h>08:40</h><w>rodeorockstar</w>I have another newbie question regarding Specter. Is this something that I can easily do? I have nested vectors of strings representing a tree. If a vector directly follows a string then it is a subtree. I&apos;d like to update the tree in a similar fashion to update-in when dealing with maps. In this non working example I&apos;d want to append &quot;SUB-A-2-2-2&quot; to the &quot;SUB-A-2-2&quot; &quot;node.&quot;:

<pre>(let [t [&quot;A&quot;
             [&quot;SUB-A-1&quot;
              &quot;SUB-A-2&quot;
              [&quot;SUB-A-2-1&quot;
               &quot;SUB-A-2-2&quot;
               [&quot;SUB-A-2-2-1&quot;]]]]]

      (s/transform [&quot;A&quot; &quot;SUB-A-2&quot; &quot;SUB-A-2-2&quot;]
                   (fn [node] (conj node &quot;SUB-A-2-2-2&quot;))
                   t)
      #_[&quot;A&quot;
         [&quot;SUB-A-1&quot;
          &quot;SUB-A-2&quot;
          [&quot;SUB-A-2-1&quot;
           &quot;SUB-A-2-2&quot;
           [&quot;SUB-A-2-2-1&quot;
            ; New:
            &quot;SUB-A-2-2-2&quot;]]]])</pre></z><z id="t1471596318" t="rodeorockstar I can&apos;t quite figure out how to work something like #(.indexOf nested-vec %) into the selection path, presumably recursively. Which makes me think I need a walker?"><y>#</y><d>2016-08-19</d><h>08:45</h><w>rodeorockstar</w>I can&apos;t quite figure out how to work something like <code>#(.indexOf nested-vec %)</code> into the selection path, presumably recursively. Which makes me think I need a walker?</z><z id="t1471609766" t="nathanmarz @rodeorockstar: cleanest way is to define a new navigator that determines which index to navigate to dynamically"><y>#</y><d>2016-08-19</d><h>12:29</h><w>nathanmarz</w>@rodeorockstar: cleanest way is to define a new navigator that determines which index to navigate to dynamically</z><z id="t1471609781" t="nathanmarz (defnav dynamic-nth [afn] (select* [this structure next-fn] (next-fn (nth structure (afn structure)))) (transform* [this structure next-fn] (let [i (afn structure)] (assoc structure i (next-fn (nth structure i)))))) (defnavconstructor subtree [p dynamic-nth] [v] (p (fn [avec] (inc (.indexOf avec v))))) "><y>#</y><d>2016-08-19</d><h>12:29</h><w>nathanmarz</w><pre>(defnav dynamic-nth [afn]
  (select* [this structure next-fn]
    (next-fn (nth structure (afn structure))))
  (transform* [this structure next-fn]
    (let [i (afn structure)]
      (assoc structure i (next-fn (nth structure i))))))

(defnavconstructor subtree
  [p dynamic-nth]
  [v]
  (p (fn [avec] (inc (.indexOf avec v)))))
</pre></z><z id="t1471609845" t="nathanmarz example: (transform [(subtree &quot;A&quot;) (subtree &quot;SUB-A-2&quot;) (subtree &quot;SUB-A-2-2&quot;) ALL] #(str % &quot;!&quot;) data) ;; =&gt; [&quot;A&quot; [&quot;SUB-A-1&quot; &quot;SUB-A-2&quot; [&quot;SUB-A-2-1&quot; &quot;SUB-A-2-2&quot; [&quot;SUB-A-2-2-1!&quot;]]]] "><y>#</y><d>2016-08-19</d><h>12:30</h><w>nathanmarz</w>example:
<pre>(transform
  [(subtree &quot;A&quot;)
   (subtree &quot;SUB-A-2&quot;)
   (subtree &quot;SUB-A-2-2&quot;)
   ALL]
   #(str % &quot;!&quot;)
   data)

;; =&gt; [&quot;A&quot; [&quot;SUB-A-1&quot; &quot;SUB-A-2&quot; [&quot;SUB-A-2-1&quot; &quot;SUB-A-2-2&quot; [&quot;SUB-A-2-2-1!&quot;]]]]
</pre></z><z id="t1471610045" t="nathanmarz @rodeorockstar: that said, I would recommend storing your tree in a different format, as right now you&apos;re basically required to parse it as you traverse it"><y>#</y><d>2016-08-19</d><h>12:34</h><w>nathanmarz</w>@rodeorockstar: that said, I would recommend storing your tree in a different format, as right now you&apos;re basically required to parse it as you traverse it</z><z id="t1471610181" t="nathanmarz your particular example can be done like this: (setval [(subtree &quot;A&quot;) (subtree &quot;SUB-A-2&quot;) (subtree &quot;SUB-A-2-2&quot;) END] [&quot;SUB-A-2-2-2&quot;] data) "><y>#</y><d>2016-08-19</d><h>12:36</h><w>nathanmarz</w>your particular example can be done like this:
<pre>(setval [(subtree &quot;A&quot;) (subtree &quot;SUB-A-2&quot;) (subtree &quot;SUB-A-2-2&quot;) END]
  [&quot;SUB-A-2-2-2&quot;]
  data)
</pre></z><z id="t1471610417" t="joshkh That is so cool... Thanks for the example, @nathanmarz . I&apos;ll comb over the devnav devnavconstructor macros until they settle in my head. Agreed, the tree structure isn&apos;t ideal, and I changed it since asking the question. But I was still curious if something like that could be done with specter so it remained a useful exercise to me. I hadn&apos;t thought to use defnav ."><y>#</y><d>2016-08-19</d><h>12:40</h><w>joshkh</w>That is so cool... Thanks for the example, @nathanmarz . I&apos;ll comb over the <code>devnav</code> <code>devnavconstructor</code> macros until they settle in my head. Agreed, the tree structure isn&apos;t ideal, and I changed it since asking the question. But I was still curious if something like that could be done with specter so it remained a useful exercise to me. I hadn&apos;t thought to use <code>defnav</code>.</z><z id="t1471610434" t="joshkh Thanks again for the continued help!"><y>#</y><d>2016-08-19</d><h>12:40</h><w>joshkh</w>Thanks again for the continued help!</z><z id="t1471610504" t="nathanmarz yea, the real power of specter is in being able to define your own navigators and then benefit from the combinatorial ways in which everything can be combined"><y>#</y><d>2016-08-19</d><h>12:41</h><w>nathanmarz</w>yea, the real power of specter is in being able to define your own navigators and then benefit from the combinatorial ways in which everything can be combined</z><z id="t1471610511" t="nathanmarz no problem, happy to help"><y>#</y><d>2016-08-19</d><h>12:41</h><w>nathanmarz</w>no problem, happy to help</z><z id="t1471634843" t="lellis Hi guys, reading codewalker documentation i found “When afn returns a truthy value, codewalker stops searching that branch of the tree and continues its search of the rest of the data structure” So how can i dont stop when afn return true? I just wanna collect when its true and searching that branch of the tree for more patterns to collect. Sorry if the questions isn&apos;t clear."><y>#</y><d>2016-08-19</d><h>19:27</h><w>lellis</w>Hi guys, reading codewalker documentation i found “When afn returns a truthy value, codewalker stops searching that branch of the tree and continues its search of the rest of the data structure” So how can i dont stop when afn return true? I just wanna collect when its true and searching that branch of the tree for more patterns to collect. Sorry if the questions isn&apos;t clear.</z><z id="t1471635968" t="nathanmarz @lellis you probably want something like this: (declarepath MyCodewalker) (providepath MyCodewalker [(codewalker map?) (continue-then-stay MAP-VALS MyCodewalker)]) "><y>#</y><d>2016-08-19</d><h>19:46</h><w>nathanmarz</w>@lellis you probably want something like this:
<pre>(declarepath MyCodewalker)
(providepath MyCodewalker
 [(codewalker map?)
  (continue-then-stay
    MAP-VALS
    MyCodewalker)])
</pre></z><z id="t1471639610" t="mattsfrey wondering if anyone knows offhand the best way to transform a map where I want to select keys of a certain set and map their children into a final map of {:keyname child}"><y>#</y><d>2016-08-19</d><h>20:46</h><w>mattsfrey</w>wondering if anyone knows offhand the best way to transform a map where I want to select keys of a certain set and map their children into a final map of  {:keyname child}</z><z id="t1471639890" t="nathanmarz @mattsfrey what&apos;s an example of input/output?"><y>#</y><d>2016-08-19</d><h>20:51</h><w>nathanmarz</w>@mattsfrey what&apos;s an example of input/output?</z><z id="t1471640133" t="lellis ty! @nathanmarz Done!!"><y>#</y><d>2016-08-19</d><h>20:55</h><w>lellis</w>ty! @nathanmarz  Done!!</z><z id="t1471641291" t="mattsfrey I actually had to re-think it but let me get an example"><y>#</y><d>2016-08-19</d><h>21:14</h><w>mattsfrey</w>I actually had to re-think it but let me get an example</z><z id="t1471641878" t="mattsfrey so this is what I&apos;m trying to achieve:"><y>#</y><d>2016-08-19</d><h>21:24</h><w>mattsfrey</w>so this is what I&apos;m trying to achieve:</z><z id="t1471641879" t="mattsfrey https://pastebin.com/u3SNhevj"><y>#</y><d>2016-08-19</d><h>21:24</h><w>mattsfrey</w><a href="https://pastebin.com/u3SNhevj" target="_blank">https://pastebin.com/u3SNhevj</a></z><z id="t1471641943" t="mattsfrey Basically will have a map of &quot;info types&quot; that are an array of sub maps, I want to pull out the child sub maps and put them into a flat structure as such"><y>#</y><d>2016-08-19</d><h>21:25</h><w>mattsfrey</w>Basically will have a map of &quot;info types&quot; that are an array of sub maps, I want to pull out the child sub maps and put them into a flat structure as such</z><z id="t1471642134" t="mattsfrey (and disregard top level map values that aren&apos;t inside a certain set, i.e :bleh)"><y>#</y><d>2016-08-19</d><h>21:28</h><w>mattsfrey</w>(and disregard top level map values that aren&apos;t inside a certain set, i.e :bleh)</z><z id="t1471642672" t="nathanmarz here&apos;s how I would do it: (def data {:phone-numbers [{:type &quot;work&quot; :value &quot;720-1234&quot;} {:type &quot;home&quot; :value &quot;720-1235&quot;}] :organizations [{:name &quot;Google&quot; :title &quot;Software Engineer&quot;}] :bleh &quot;blah...&quot;}) (-&gt;&gt; data (traverse [ALL (not-selected? FIRST #{:bleh}) (collect-one FIRST) LAST ALL]) (reduce (fn [v [type val]] (conj v {:type type :value val})) [])) "><y>#</y><d>2016-08-19</d><h>21:37</h><w>nathanmarz</w>here&apos;s how I would do it:
<pre>(def data {:phone-numbers [{:type &quot;work&quot; :value &quot;720-1234&quot;}
                           {:type &quot;home&quot; :value &quot;720-1235&quot;}]
           :organizations [{:name &quot;Google&quot; :title &quot;Software Engineer&quot;}]
           :bleh &quot;blah...&quot;})

(-&gt;&gt; data
     (traverse [ALL
                (not-selected? FIRST #{:bleh})
                (collect-one FIRST)
                LAST
                ALL])
     (reduce (fn [v [type val]] (conj v {:type type :value val}))
             []))
</pre></z><z id="t1471643124" t="mattsfrey that seems to be explicitly ignoring bleh whereas I&apos;d rather explicitly include elements of a set and ignore everything else"><y>#</y><d>2016-08-19</d><h>21:45</h><w>mattsfrey</w>that seems to be explicitly ignoring bleh whereas I&apos;d rather explicitly include elements of a set and ignore everything else</z><z id="t1471643177" t="mattsfrey i.e. if in [:organizations :phone-numbers :addresses]"><y>#</y><d>2016-08-19</d><h>21:46</h><w>mattsfrey</w>i.e. if in [:organizations :phone-numbers :addresses]</z><z id="t1471643889" t="nathanmarz just change that line to (selected? FIRST #{:organizations :phone-numbers :addresses})"><y>#</y><d>2016-08-19</d><h>21:58</h><w>nathanmarz</w>just change that line to  <code>(selected? FIRST #{:organizations :phone-numbers :addresses})</code></z><z id="t1471792381" t="amacdougall I&apos;m working with a multidimensional array, and couldn&apos;t quite figure out how to drill into a single grid cell by index without an awkward (srange n (inc n)) . I ended up using (update-in y x &lt;cell-specific keys...&gt; &lt;fn&gt;) , but if I want to do anything more complex, that will break down. Am I missing an easy way to select something out of a vector by index?"><y>#</y><d>2016-08-21</d><h>15:13</h><w>amacdougall</w>I&apos;m working with a multidimensional array, and couldn&apos;t quite figure out how to drill into a single grid cell by index without an awkward <code>(srange n (inc n))</code>. I ended up using <code>(update-in y x &lt;cell-specific keys...&gt; &lt;fn&gt;)</code>, but if I want to do anything more complex, that will break down. Am I missing an easy way to select something out of a vector by index?</z><z id="t1471792443" t="nathanmarz @amacdougall use keypath"><y>#</y><d>2016-08-21</d><h>15:14</h><w>nathanmarz</w>@amacdougall use <code>keypath</code></z><z id="t1471792459" t="nathanmarz (transform [(keypath 2) (keypath 4)] ...)"><y>#</y><d>2016-08-21</d><h>15:14</h><w>nathanmarz</w><code>(transform [(keypath 2) (keypath 4)] ...)</code></z><z id="t1471792522" t="amacdougall ...oh, that makes perfect sense. I saw &quot;key&quot; and my brain jumped to &quot;keyword&quot;."><y>#</y><d>2016-08-21</d><h>15:15</h><w>amacdougall</w>...oh, that makes perfect sense. I saw &quot;key&quot; and my brain jumped to &quot;keyword&quot;.</z><z id="t1471792639" t="amacdougall Worked like a charm!"><y>#</y><d>2016-08-21</d><h>15:17</h><w>amacdougall</w>Worked like a charm!</z><z id="t1471847167" t="yonatanel @nathanmarz: do you have any posts on what makes specter faster than drilling with built in functions, or should I just read the code?"><y>#</y><d>2016-08-22</d><h>06:26</h><w>yonatanel</w>@nathanmarz: do you have any posts on what makes specter faster than drilling with built in functions, or should I just read the code?</z><z id="t1471848859" t="aengelberg @yonatanel it may help to look at the source code of get-in / update-in , or macroexpanding a call to select or transform"><y>#</y><d>2016-08-22</d><h>06:54</h><w>aengelberg</w>@yonatanel it may help to look at the source code of <code>get-in</code> / <code>update-in</code>, or macroexpanding a call to <code>select</code> or <code>transform</code></z><z id="t1471849284" t="yonatanel Thanks, I will"><y>#</y><d>2016-08-22</d><h>07:01</h><w>yonatanel</w>Thanks, I will</z><z id="t1471863343" t="nathanmarz @yonatanel take a look at this as well https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs"><y>#</y><d>2016-08-22</d><h>10:55</h><w>nathanmarz</w>@yonatanel take a look at this as well <a href="https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs" target="_blank">https://github.com/nathanmarz/specter/wiki/Specter-0.11.0:-Performance-without-the-tradeoffs</a></z><z id="t1471880892" t="mattsfrey @nathanmarz my one major complaint dealing with specter so far is it is very difficult to know where functions / macros are coming from, which are which etc. Reading an example I have to guess and check to figure out which is which. I still can&apos;t even find that function &quot;traverse&quot; in either macros or the main com.rpl.specter"><y>#</y><d>2016-08-22</d><h>15:48</h><w>mattsfrey</w>@nathanmarz my one major complaint dealing with specter so far is it is very difficult to know where functions / macros are coming from, which are which etc. Reading an example I have to guess and check to figure out which is which. I still can&apos;t even find that function &quot;traverse&quot; in either macros or the main com.rpl.specter</z><z id="t1471880916" t="mattsfrey Is there any definitive require statement(s) to just import everything specter related?"><y>#</y><d>2016-08-22</d><h>15:48</h><w>mattsfrey</w>Is there any definitive require statement(s) to just import everything specter related?</z><z id="t1471880961" t="nathanmarz @mattsfrey traverse is in specter 0.12.0"><y>#</y><d>2016-08-22</d><h>15:49</h><w>nathanmarz</w>@mattsfrey traverse is in specter 0.12.0</z><z id="t1471880983" t="nathanmarz I use this to get everything into a single namespace in my projects https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj"><y>#</y><d>2016-08-22</d><h>15:49</h><w>nathanmarz</w>I use this to get everything into a single namespace in my projects <a href="https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj" target="_blank">https://github.com/ztellman/potemkin/blob/master/src/potemkin/namespaces.clj</a></z><z id="t1471880998" t="mattsfrey oh no kidding so thats hot off the press then"><y>#</y><d>2016-08-22</d><h>15:49</h><w>mattsfrey</w>oh no kidding so thats hot off the press then</z><z id="t1471881045" t="nathanmarz there&apos;s also https://github.com/nathanmarz/specter/wiki/List-of-Macros and https://github.com/nathanmarz/specter/wiki/List-of-Navigators"><y>#</y><d>2016-08-22</d><h>15:50</h><w>nathanmarz</w>there&apos;s also <a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Macros</a> and <a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators</a></z><z id="t1471881854" t="mattsfrey the lists definitely help, thanks"><y>#</y><d>2016-08-22</d><h>16:04</h><w>mattsfrey</w>the lists definitely help, thanks</z><z id="t1471881870" t="mattsfrey also that code from yesterday (now that i have traverse!) works splendidly"><y>#</y><d>2016-08-22</d><h>16:04</h><w>mattsfrey</w>also that code from yesterday (now that i have traverse!) works splendidly</z><z id="t1471881872" t="mattsfrey thanks!"><y>#</y><d>2016-08-22</d><h>16:04</h><w>mattsfrey</w>thanks!</z><z id="t1471885401" t="nathanmarz @mattsfrey fyi, that code would work the same with select , just less efficiently"><y>#</y><d>2016-08-22</d><h>17:03</h><w>nathanmarz</w>@mattsfrey fyi, that code would work the same with <code>select</code>, just less efficiently</z><z id="t1471967666" t="zane Is there a more comprehensive guide to writing navigators? I feel like I&apos;m not getting the full picture from the API documentation."><y>#</y><d>2016-08-23</d><h>15:54</h><w>zane</w>Is there a more comprehensive guide to writing navigators? I feel like I&apos;m not getting the full picture from the API documentation.</z><z id="t1471967736" t="zane Also, it feels like there&apos;s significant overlap between declarepath / providepath recursive paths and navigators?"><y>#</y><d>2016-08-23</d><h>15:55</h><w>zane</w>Also, it feels like there&apos;s significant overlap between <code>declarepath</code> / <code>providepath</code> recursive paths and navigators?</z><z id="t1471967743" t="zane Am I reading this correctly?"><y>#</y><d>2016-08-23</d><h>15:55</h><w>zane</w>Am I reading this correctly?</z><z id="t1471968921" t="nathanmarz @zane there&apos;s also https://github.com/nathanmarz/specter/wiki/List-of-Macros"><y>#</y><d>2016-08-23</d><h>16:15</h><w>nathanmarz</w>@zane there&apos;s also <a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Macros</a></z><z id="t1471968973" t="nathanmarz not sure what you mean by overlap, declarepath / providepath is the main way to make a recursive navigator"><y>#</y><d>2016-08-23</d><h>16:16</h><w>nathanmarz</w>not sure what you mean by overlap, <code>declarepath</code> / <code>providepath</code> is the main way to make a recursive navigator</z><z id="t1471968978" t="zane I saw that! Definitely helps."><y>#</y><d>2016-08-23</d><h>16:16</h><w>zane</w>I saw that! Definitely helps.</z><z id="t1471968993" t="nathanmarz I do agree the docs need work"><y>#</y><d>2016-08-23</d><h>16:16</h><w>nathanmarz</w>I do agree the docs need work</z><z id="t1471969015" t="zane Ah, there&apos;s probably a hole in my understanding around the intended uses of navigators and paths."><y>#</y><d>2016-08-23</d><h>16:16</h><w>zane</w>Ah, there&apos;s probably a hole in my understanding around the intended uses of navigators and paths.</z><z id="t1471969059" t="nathanmarz studying the implementations of the core navigators will probably help"><y>#</y><d>2016-08-23</d><h>16:17</h><w>nathanmarz</w>studying the implementations of the core navigators will probably help</z><z id="t1471969073" t="zane Ah, that&apos;s a good suggestion."><y>#</y><d>2016-08-23</d><h>16:17</h><w>zane</w>Ah, that&apos;s a good suggestion.</z><z id="t1471969116" t="zane Specter is awesome, by the way! Even with my flawed understanding of it it&apos;s already paying dividends."><y>#</y><d>2016-08-23</d><h>16:18</h><w>zane</w>Specter is awesome, by the way! Even with my flawed understanding of it it&apos;s already paying dividends.</z><z id="t1471969138" t="nathanmarz thanks"><y>#</y><d>2016-08-23</d><h>16:18</h><w>nathanmarz</w>thanks</z><z id="t1471969164" t="nathanmarz though I will say the real power is unlocked when you understand how to write your own navigators"><y>#</y><d>2016-08-23</d><h>16:19</h><w>nathanmarz</w>though I will say the real power is unlocked when you understand how to write your own navigators</z><z id="t1471970039" t="zane I&apos;m getting that sense!"><y>#</y><d>2016-08-23</d><h>16:33</h><w>zane</w>I&apos;m getting that sense!</z><z id="t1471980093" t="zane &gt; though I will say the real power is unlocked when you understand how to write your own navigators I&apos;d love to hear more about this: What kind of custom navigators do you feel deliver the most value?"><y>#</y><d>2016-08-23</d><h>19:21</h><w>zane</w>&gt; though I will say the real power is unlocked when you understand how to write your own navigators
I&apos;d love to hear more about this: What kind of custom navigators do you feel deliver the most value?</z><z id="t1471980405" t="nathanmarz @zane I have a whole suite of navigators for DAGs that I use privately"><y>#</y><d>2016-08-23</d><h>19:26</h><w>nathanmarz</w>@zane I have a whole suite of navigators for DAGs that I use privately</z><z id="t1471980432" t="nathanmarz as an example"><y>#</y><d>2016-08-23</d><h>19:27</h><w>nathanmarz</w>as an example</z><z id="t1471980458" t="nathanmarz I can do very sophisticated recursive DAG transformations with almost no effort at all, and it runs with near optimal performance"><y>#</y><d>2016-08-23</d><h>19:27</h><w>nathanmarz</w>I can do very sophisticated recursive DAG transformations with almost no effort at all, and it runs with near optimal performance</z><z id="t1471980469" t="zane Ah, I think I remember you mentioning that in a video or blog post somewhere."><y>#</y><d>2016-08-23</d><h>19:27</h><w>zane</w>Ah, I think I remember you mentioning that in a video or blog post somewhere.</z><z id="t1471980495" t="nathanmarz the key is since that everything composes, you have a combinatoric explosion of ways in which you can apply Specter"><y>#</y><d>2016-08-23</d><h>19:28</h><w>nathanmarz</w>the key is since that everything composes, you have a combinatoric explosion of ways in which you can apply Specter</z><z id="t1471980504" t="zane Right!"><y>#</y><d>2016-08-23</d><h>19:28</h><w>zane</w>Right!</z><z id="t1471980510" t="zane For simple recursive descent through EDN I shouldn&apos;t have to reach for custom navigators though, right?"><y>#</y><d>2016-08-23</d><h>19:28</h><w>zane</w>For simple recursive descent through EDN I shouldn&apos;t have to reach for custom navigators though, right?</z><z id="t1471980519" t="zane It should just be a matter of defining paths?"><y>#</y><d>2016-08-23</d><h>19:28</h><w>zane</w>It should just be a matter of defining paths?</z><z id="t1471980533" t="nathanmarz most likely"><y>#</y><d>2016-08-23</d><h>19:28</h><w>nathanmarz</w>most likely</z><z id="t1471980540" t="zane Okay, cool. That was my intuition."><y>#</y><d>2016-08-23</d><h>19:29</h><w>zane</w>Okay, cool. That was my intuition.</z><z id="t1471980562" t="nathanmarz you&apos;ll start off using Specter for getting in and out of nested data structures, and later you&apos;ll see how much more the concept of navigation generalizes"><y>#</y><d>2016-08-23</d><h>19:29</h><w>nathanmarz</w>you&apos;ll start off using Specter for getting in and out of nested data structures, and later you&apos;ll see how much more the concept of navigation generalizes</z><z id="t1471980610" t="nathanmarz a big moment for me was realizing that adding to a set could be expressed as a navigator"><y>#</y><d>2016-08-23</d><h>19:30</h><w>nathanmarz</w>a big moment for me was realizing that adding to a set could be expressed as a navigator</z><z id="t1471980632" t="nathanmarz (setval [:a (subset #{})] #{:new-elem} data)"><y>#</y><d>2016-08-23</d><h>19:30</h><w>nathanmarz</w><code>(setval [:a (subset #{})] #{:new-elem} data)</code></z><z id="t1471980777" t="zane Ah."><y>#</y><d>2016-08-23</d><h>19:32</h><w>zane</w>Ah.</z><z id="t1471980778" t="zane Yes."><y>#</y><d>2016-08-23</d><h>19:32</h><w>zane</w>Yes.</z><z id="t1471980786" t="zane Very monadic?"><y>#</y><d>2016-08-23</d><h>19:33</h><w>zane</w>Very monadic?</z><z id="t1471980795" t="zane Atom feels similar."><y>#</y><d>2016-08-23</d><h>19:33</h><w>zane</w>Atom feels similar.</z><z id="t1471980838" t="zane This was making me think about navigators that descended into datomic connections somehow, but that might be 🍌 s."><y>#</y><d>2016-08-23</d><h>19:33</h><w>zane</w>This was making me think about navigators that descended into <b>datomic</b> connections somehow, but that might be <b>🍌</b>s.</z><z id="t1471980842" t="nathanmarz select is semantically identical to the list monad, though specter&apos;s implementation is far more efficient"><y>#</y><d>2016-08-23</d><h>19:34</h><w>nathanmarz</w>select is semantically identical to the list monad, though specter&apos;s implementation is far more efficient</z><z id="t1471980855" t="erichmond #shotsfired"><y>#</y><d>2016-08-23</d><h>19:34</h><w>erichmond</w>#shotsfired</z><z id="t1471980870" t="nathanmarz I looked at how transform might be done as a monad some time ago but it wasn&apos;t obvious, and it wasn&apos;t really important to figure out"><y>#</y><d>2016-08-23</d><h>19:34</h><w>nathanmarz</w>I looked at how transform might be done as a monad some time ago but it wasn&apos;t obvious, and it wasn&apos;t really important to figure out</z><z id="t1471984290" t="zane Are these available somewhere?"><y>#</y><d>2016-08-23</d><h>20:31</h><w>zane</w>Are these available somewhere?</z><z id="t1471985408" t="zane Hmm. So view is a bit weird in that it doesn&apos;t allow for transformations inside the view. (Which I guess makes sense.)"><y>#</y><d>2016-08-23</d><h>20:50</h><w>zane</w>Hmm. So <code>view</code> is a bit weird in that it doesn&apos;t allow for transformations inside the view. (Which I guess makes sense.)</z><z id="t1471985936" t="zane I wonder if transforms should even be allowed on paths that have view s in them…"><y>#</y><d>2016-08-23</d><h>20:58</h><w>zane</w>I wonder if transforms should even be allowed on paths that have <code>view</code>s in them…</z><z id="t1471986163" t="nathanmarz view works just fine in transform"><y>#</y><d>2016-08-23</d><h>21:02</h><w>nathanmarz</w><code>view</code> works just fine in <code>transform</code></z><z id="t1471986208" t="nathanmarz transformed is similar to view except done with a path and transform function"><y>#</y><d>2016-08-23</d><h>21:03</h><w>nathanmarz</w><code>transformed</code> is similar to <code>view</code> except done with a path and transform function</z><z id="t1471986399" t="nathanmarz @zane no, those navigators are not publicly available"><y>#</y><d>2016-08-23</d><h>21:06</h><w>nathanmarz</w>@zane no, those navigators are not publicly available</z><z id="t1471987480" t="zane I guess what I mean is, this is not what I was expecting: (setval [(view namespace)] &quot;woo&quot; :hey/there) "><y>#</y><d>2016-08-23</d><h>21:24</h><w>zane</w>I guess what I mean is, this is not what I was expecting:
<pre>(setval [(view namespace)]
        &quot;woo&quot;
        :hey/there)
</pre></z><z id="t1471987491" t="zane &quot;woo&quot; "><y>#</y><d>2016-08-23</d><h>21:24</h><w>zane</w><pre>&quot;woo&quot;
</pre></z><z id="t1471987512" t="zane So now I&apos;m trying to write NAMESPACE : (defnav NAMESPACE [] (select* [this structure next-fn] (next-fn (namespace structure))) (transform* [this structure next-fn] (keyword (next-fn (namespace structure)) (name structure)))) "><y>#</y><d>2016-08-23</d><h>21:25</h><w>zane</w>So now I&apos;m trying to write <code>NAMESPACE</code>:
<pre>(defnav NAMESPACE
  []
  (select* [this structure next-fn]
           (next-fn (namespace structure)))
  (transform* [this structure next-fn]
              (keyword (next-fn (namespace structure))
                       (name structure))))
</pre></z><z id="t1471987694" t="zane Holy crap, it works."><y>#</y><d>2016-08-23</d><h>21:28</h><w>zane</w>Holy crap, it works.</z><z id="t1471987695" t="zane Magic!"><y>#</y><d>2016-08-23</d><h>21:28</h><w>zane</w>Magic!</z><z id="t1471988796" t="nathanmarz nice one, I have a similar navigator"><y>#</y><d>2016-08-23</d><h>21:46</h><w>nathanmarz</w>nice one, I have a similar navigator</z><z id="t1471988850" t="nathanmarz you want to handle the no-namespace case as well (when (next-fn (namespace structure)) returns nil)"><y>#</y><d>2016-08-23</d><h>21:47</h><w>nathanmarz</w>you want to handle the no-namespace case as well (when <code>(next-fn (namespace structure))</code> returns nil)</z></g><g id="s6"><z id="t1472041595" t="branch14 Hi, I&apos;m struggling to use specter (0.12.0) in cljs. I probably haven&apos;t set the ns up properly. =&gt; (select [:a :b] {:a {:b 42}}) #object[TypeError TypeError: Cannot read property &apos;specter&apos; of undefined] My ns looks like this: (ns dummy (:require [com.rpl.specter :as s]) (:require-macros [com.rpl.specter.macros :refer [select]])) "><y>#</y><d>2016-08-24</d><h>12:26</h><w>branch14</w>Hi, I&apos;m struggling to use specter (0.12.0) in cljs. I probably haven&apos;t set the ns up properly.
<pre>=&gt; (select [:a :b] {:a {:b 42}})
#object[TypeError TypeError: Cannot read property &apos;specter&apos; of undefined]
</pre>
My ns looks like this:
<pre>(ns dummy
  (:require [com.rpl.specter :as s])
  (:require-macros [com.rpl.specter.macros :refer [select]]))
</pre></z><z id="t1472042108" t="nathanmarz @branch14 works fine for me, don&apos;t know what&apos;s causing that"><y>#</y><d>2016-08-24</d><h>12:35</h><w>nathanmarz</w>@branch14 works fine for me, don&apos;t know what&apos;s causing that</z><z id="t1472042506" t="branch14 @nathanmarz Ha, it kind of works in the browser, but it doesn&apos;t on the REPL that figwheel gives me."><y>#</y><d>2016-08-24</d><h>12:41</h><w>branch14</w>@nathanmarz Ha, it kind of works in the browser, but it doesn&apos;t on the REPL that figwheel gives me.</z><z id="t1472042701" t="branch14 Ok, it works perfectly in the browser, but the REPL only yields the error above."><y>#</y><d>2016-08-24</d><h>12:45</h><w>branch14</w>Ok, it works perfectly in the browser, but the REPL only yields the error above.</z><z id="t1472240150" t="sashton I’m trying to write a navigator that drops n items. Here’s what I’ve got: (spm/defnav nav-drop [n] (select* [this structure next-fn] (let [ret (next-fn (drop n structure)) empt (empty structure)] (if (= ret sp/NONE) ret (into empt ret)))) (transform* [this structure next-fn] (let [ret (next-fn (drop n structure))] (-&gt;&gt; (concat (take n structure) ret) (into (empty structure)))))) I found I had to check the return value of next-fn to check for NONE . Is that the right approach? My original attempt was done assuming I’d just get back an empty list, but that didn’t work."><y>#</y><d>2016-08-26</d><h>19:35</h><w>sashton</w>I’m trying to write a navigator that drops <code>n</code> items. Here’s what I’ve got:
<pre>(spm/defnav nav-drop [n]
  (select* [this structure next-fn]
           (let [ret (next-fn (drop n structure))
                 empt (empty structure)]
             (if (= ret sp/NONE)
               ret
               (into empt ret))))
  (transform* [this structure next-fn]
              (let [ret (next-fn (drop n structure))]
                (-&gt;&gt; (concat (take n structure) ret)
                     (into (empty structure))))))
</pre>

I found I had to check the return value of <code>next-fn</code> to check for <code>NONE</code>. Is that the right approach? My original attempt was done assuming I’d just get back an empty list, but that didn’t work.</z><z id="t1472244101" t="nathanmarz @sashton the select* implementation should just be (next-fn (drop n structure))"><y>#</y><d>2016-08-26</d><h>20:41</h><w>nathanmarz</w>@sashton the select* implementation should just be <code> (next-fn (drop n structure))</code></z><z id="t1472244157" t="nathanmarz you&apos;re on 0.12.0, right?"><y>#</y><d>2016-08-26</d><h>20:42</h><w>nathanmarz</w>you&apos;re on 0.12.0, right?</z><z id="t1472244167" t="sashton yes"><y>#</y><d>2016-08-26</d><h>20:42</h><w>sashton</w>yes</z><z id="t1472244180" t="sashton that changes the data type to a list, though, right?"><y>#</y><d>2016-08-26</d><h>20:43</h><w>sashton</w>that changes the data type to a list, though, right?</z><z id="t1472244193" t="sashton even if my input is a vector?"><y>#</y><d>2016-08-26</d><h>20:43</h><w>sashton</w>even if my input is a vector?</z><z id="t1472244208" t="sashton i was trying to preserve the collection type"><y>#</y><d>2016-08-26</d><h>20:43</h><w>sashton</w>i was trying to preserve the collection type</z><z id="t1472244238" t="nathanmarz the requirement of select* is to call next-fn on whatever subvalue should be passed to the next navigator"><y>#</y><d>2016-08-26</d><h>20:43</h><w>nathanmarz</w>the requirement of select* is to call next-fn on whatever subvalue should be passed to the next navigator</z><z id="t1472244260" t="nathanmarz so you should put the logic to maintain type before you call next-fn"><y>#</y><d>2016-08-26</d><h>20:44</h><w>nathanmarz</w>so you should put the logic to maintain type before you call next-fn</z><z id="t1472244281" t="nathanmarz probably (next-fn (into (empty structure) (drop n structure)))"><y>#</y><d>2016-08-26</d><h>20:44</h><w>nathanmarz</w>probably <code>(next-fn (into (empty structure) (drop n structure)))</code></z><z id="t1472244290" t="sashton ah, i’ll give that a try"><y>#</y><d>2016-08-26</d><h>20:44</h><w>sashton</w>ah, i’ll give that a try</z><z id="t1472244337" t="nathanmarz you only need to deal with NONE when a navigator navigates to an indeterminate number of subvalues"><y>#</y><d>2016-08-26</d><h>20:45</h><w>nathanmarz</w>you only need to deal with <code>NONE</code> when a navigator navigates to an indeterminate number of subvalues</z><z id="t1472405488" t="amacdougall Still playing with my maze thing—to implement the first algorithm in the book, I realized that I needed to consider each cell in turn, but during each iteration, I might need to operate on the entire grid. For instance, upon deciding that cell 0,0 should be linked east to cell 1,0, I need to get a grid with both cells changed. I solved it by applying the Feynmann Algorithm, and used traverse : (reduce (fn [grid cell] (let [open-directions (filter (partial move grid cell) [::s ::e])] (if (empty? open-directions) grid (link grid cell (rand-nth open-directions))))) g (sm/traverse [s/ALL s/ALL] g)) This totally works! Just curious if I&apos;m missing a simpler way to do the same thing. (The book is in Ruby, so it has an easier time just navigating around the data structure and changing whatever it wants at any point in the loop.)"><y>#</y><d>2016-08-28</d><h>17:31</h><w>amacdougall</w>Still playing with my maze thing—to implement the first algorithm in the book, I realized that I needed to consider each cell in turn, but during each iteration, I might need to operate on the entire grid. For instance, upon deciding that cell 0,0 should be linked east to cell 1,0, I need to get a grid with both cells changed.

I solved it by applying the Feynmann Algorithm, and used <code>traverse</code>:
<pre>(reduce
  (fn [grid cell]
    (let [open-directions (filter (partial move grid cell) [::s ::e])]
      (if (empty? open-directions)
        grid
        (link grid cell (rand-nth open-directions)))))
  g
  (sm/traverse [s/ALL s/ALL] g))
</pre>
This totally works! Just curious if I&apos;m missing a simpler way to do the same thing.

(The book is in Ruby, so it has an easier time just navigating around the data structure and changing whatever it wants at any point in the loop.)</z><z id="t1472405695" t="amacdougall ...looking at the docs and my code a bit harder, I realize that traverse is just there to have a more efficient implementation than select when used as a reduce argument. And the problem of &quot;make changes to a larger resultset while iterating over individual elements&quot; is exactly what reduce is for. So I guess that kind of answers my question. :duck:"><y>#</y><d>2016-08-28</d><h>17:34</h><w>amacdougall</w>...looking at the docs and my code a bit harder, I realize that <code>traverse</code> is just there to have a more efficient implementation than <code>select</code> when used as a <code>reduce</code> argument. And the problem of &quot;make changes to a larger resultset while iterating over individual elements&quot; is exactly what <code>reduce</code> is for. So I guess that kind of answers my question. <b>:duck:</b></z><z id="t1472482918" t="bill I can (dissoc {:id 1} :id) . Is there an idomatic way to dissoc in specter, or should I nav to the map of interest and call my own function that calls dissoc ?"><y>#</y><d>2016-08-29</d><h>15:01</h><w>bill</w>I can <code>(dissoc {:id 1} :id)</code>.

Is there an idomatic way to dissoc in specter, or should I nav to the map of interest and call my own function that calls <code>dissoc</code>?</z><z id="t1472482989" t="bill (and yes, I searched the docs, bugs and source for “dissoc” first)"><y>#</y><d>2016-08-29</d><h>15:03</h><w>bill</w>(and yes, I searched the docs, bugs and source for “dissoc” first)</z><z id="t1472483754" t="codonnell @bill: you could do (view #(dissoc % :k)) , but if you use that with transform , the key will not be added back during reconstruction"><y>#</y><d>2016-08-29</d><h>15:15</h><w>codonnell</w>@bill: you could do <code>(view #(dissoc % :k))</code>, but if you use that with <code>transform</code>, the key will not be added back during reconstruction</z><z id="t1472483779" t="codonnell you could also write your own navigator, which would be straightforward"><y>#</y><d>2016-08-29</d><h>15:16</h><w>codonnell</w>you could also write your own navigator, which would be straightforward</z><z id="t1472485132" t="bill thanks @codonnell. I don’t understand your caveat “the key will not be added back during reconstruction”. maybe I’m not being clear: I want the key (and value) removed from the hash."><y>#</y><d>2016-08-29</d><h>15:38</h><w>bill</w>thanks @codonnell. I don’t understand your caveat “the key will not be added back during reconstruction”.

maybe I’m not being clear: I want the key (and value) removed from the hash.</z><z id="t1472485335" t="codonnell @bill: For example, (transform [(view #(dissoc % :a)) MAP-VALS] inc {:a 0 :b 0 :c 0}) gives {:b 1, :c 1} , not {:a 0, :b 1, :c 1}"><y>#</y><d>2016-08-29</d><h>15:42</h><w>codonnell</w>@bill: For example, <code>(transform [(view #(dissoc % :a)) MAP-VALS] inc {:a 0 :b 0 :c 0})</code> gives <code>{:b 1, :c 1}</code>, not <code>{:a 0, :b 1, :c 1}</code></z><z id="t1472485376" t="codonnell If you wrote your own navigator, you could make it have the latter behavior."><y>#</y><d>2016-08-29</d><h>15:42</h><w>codonnell</w>If you wrote your own navigator, you could make it have the latter behavior.</z><z id="t1472485449" t="bill ah I get 60% of that which is enough—I think that’ll work for me. thanks!"><y>#</y><d>2016-08-29</d><h>15:44</h><w>bill</w>ah I get 60% of that which is enough—I think that’ll work for me. thanks!</z><z id="t1472485568" t="codonnell @bill: There are lots of examples on the wiki, including an example of a custom navigator at https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav"><y>#</y><d>2016-08-29</d><h>15:46</h><w>codonnell</w>@bill: There are lots of examples on the wiki, including an example of a custom navigator at <a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Macros#defnav</a></z><z id="t1472485605" t="codonnell good luck!"><y>#</y><d>2016-08-29</d><h>15:46</h><w>codonnell</w>good luck!</z><z id="t1472485619" t="bill thanks!"><y>#</y><d>2016-08-29</d><h>15:46</h><w>bill</w>thanks!</z><z id="t1472485914" t="bill so I here is me, removing the :id s: (transform [:results ALL (view #(dissoc % :id)) MAP-VALS] identity {:foo 3 :results [{:id 0 :b 0 :c 0}]}) =&gt; {:foo 3, :results [{:b 0, :c 0}]} It works, but it seems like calling identity is a sign of wrongness here."><y>#</y><d>2016-08-29</d><h>15:51</h><w>bill</w>so I here is me, removing the <code>:id</code>s:

<pre>(transform [:results ALL (view #(dissoc % :id)) MAP-VALS] identity {:foo 3 :results [{:id 0 :b 0 :c 0}]})
=&gt; {:foo 3, :results [{:b 0, :c 0}]}
</pre>

It works, but it seems like calling <code>identity</code> is a sign of wrongness here.</z><z id="t1472486105" t="codonnell @bill: I&apos;m not at a repl, but I think you could do (transform [:results ALL] #(dissoc % :id) data)"><y>#</y><d>2016-08-29</d><h>15:55</h><w>codonnell</w>@bill: I&apos;m not at a repl, but I think you could do <code>(transform [:results ALL] #(dissoc % :id) data)</code></z><z id="t1472486227" t="bill perfecto! (works)"><y>#</y><d>2016-08-29</d><h>15:57</h><w>bill</w>perfecto! (works)</z><z id="t1472486594" t="nathanmarz @bill I&apos;ve used a function like this in the past: (defn dissocer [k] (fn [m] (dissoc m k))) "><y>#</y><d>2016-08-29</d><h>16:03</h><w>nathanmarz</w>@bill I&apos;ve used a function like this in the past:
<pre>(defn dissocer [k]
  (fn [m]
    (dissoc m k)))
</pre></z><z id="t1472486612" t="nathanmarz then you can do (transform [:results ALL] (dissocer :a) data)"><y>#</y><d>2016-08-29</d><h>16:03</h><w>nathanmarz</w>then you can do <code>(transform [:results ALL] (dissocer :a) data)</code></z><z id="t1472486656" t="bill nice ‘un @nathanmarz"><y>#</y><d>2016-08-29</d><h>16:04</h><w>bill</w>nice ‘un @nathanmarz</z><z id="t1472775315" t="caio as we’re talking about dissoc ing, I have a doubt as well 😆 I need to dissoc a key from every map that has it in a nested structure, so if I want to dissoc :a , {:a “le”, :c {:a “lu”, :b “la”}} should become {:c {:b “la”}} . I tried doing (transform (walker coll?) #(dissoc % :a) ds) , but the walker stops on the first level and the transform returns {:c {:a “lu”, :b “la”}} . is there an easy way to do this?"><y>#</y><d>2016-09-02</d><h>00:15</h><w>caio</w>as we’re talking about <code>dissoc</code>ing, I have a doubt as well <b>😆</b> 
I need to dissoc a key from every map that has it in a nested structure, so if I want to dissoc <code>:a</code>, <code>{:a “le”, :c {:a “lu”, :b “la”}}</code> should become <code>{:c {:b “la”}}</code>. I tried doing <code>(transform (walker coll?) #(dissoc % :a) ds)</code>, but the walker stops on the first level and the transform returns <code>{:c {:a “lu”, :b “la”}}</code>. is there an easy way to do this?</z><z id="t1472775820" t="caio oh, nvm. just saw params-reset for declaring recursive navigators"><y>#</y><d>2016-09-02</d><h>00:23</h><w>caio</w>oh, nvm. just saw <code>params-reset</code> for declaring recursive navigators</z><z id="t1472776081" t="codonnell @caio: I don&apos;t think you need params-reset . Here&apos;s what I came up with, though I&apos;m trying to think of a better way. =&gt; (declarepath MapWalker) =&gt; (providepath MapWalker (if-path map? (continue-then-stay MAP-VALS MapWalker))) =&gt; (transform MapWalker #(dissoc % :a) {:a 0 :b {:a 1 :b 2}}) {:b {:b 2}}"><y>#</y><d>2016-09-02</d><h>00:28</h><w>codonnell</w>@caio: I don&apos;t think you need <code>params-reset</code>. Here&apos;s what I came up with, though I&apos;m trying to think of a better way.
 <pre>=&gt; (declarepath MapWalker)
=&gt; (providepath MapWalker (if-path map? (continue-then-stay MAP-VALS MapWalker)))
=&gt; (transform MapWalker #(dissoc % :a) {:a 0 :b {:a 1 :b 2}})
{:b {:b 2}}</pre></z><z id="t1472776229" t="codonnell Yeah, here&apos;s a shorter implementation: (providepath MapWalker (continue-then-stay MAP-VALS map? MapWalker))"><y>#</y><d>2016-09-02</d><h>00:30</h><w>codonnell</w>Yeah, here&apos;s a shorter implementation: <code>(providepath MapWalker (continue-then-stay MAP-VALS map? MapWalker))</code></z><z id="t1472777387" t="caio Oh, nice. Didn&apos;t knew this continue-then-stay . Thanks!"><y>#</y><d>2016-09-02</d><h>00:49</h><w>caio</w>Oh, nice. Didn&apos;t knew this <code>continue-then-stay</code>. Thanks!</z><z id="t1472832875" t="nathanmarz for those interested, I rewrote almost all of Specter&apos;s core https://github.com/nathanmarz/specter/blob/rewrite/CHANGES.md"><y>#</y><d>2016-09-02</d><h>16:14</h><w>nathanmarz</w>for those interested, I rewrote almost all of Specter&apos;s core <a href="https://github.com/nathanmarz/specter/blob/rewrite/CHANGES.md" target="_blank">https://github.com/nathanmarz/specter/blob/rewrite/CHANGES.md</a></z><z id="t1472832947" t="nathanmarz 25% smaller codebase, better performance, and no more restrictions on what can be inline compiled/cached (locals, special forms, and dynamic vars in nav positions can now be inline compiled/cached)"><y>#</y><d>2016-09-02</d><h>16:15</h><w>nathanmarz</w>25% smaller codebase, better performance, and no more restrictions on what can be inline compiled/cached (locals, special forms, and dynamic vars in nav positions can now be inline compiled/cached)</z><z id="t1472835185" t="caio @codonnell the code you sent me actually breaks when there are other nested structures other than maps (vectors for instance). for instance: =&gt; (transform MapWalker #(dissoc % :a) {:a 0 :b [{:a 1 :b 2}]}) {:b [{:a 1 :b 2}]} . after some time, this is what I got: (declarepath map-walker) (providepath map-walker [(walker map?) (continue-then-stay MAP-VALS map-walker)]) now it’s working fine 🙂"><y>#</y><d>2016-09-02</d><h>16:53</h><w>caio</w>@codonnell the code you sent me actually breaks when there are other nested structures other than maps (vectors for instance). for instance:
<pre>=&gt; (transform MapWalker #(dissoc % :a) {:a 0 :b [{:a 1 :b 2}]})
{:b [{:a 1 :b 2}]}
</pre>

. after some time, this is what I got:
<pre>(declarepath map-walker)
(providepath map-walker [(walker map?)
                         (continue-then-stay MAP-VALS map-walker)])
</pre>

now it’s working fine <b>🙂</b></z><z id="t1472835255" t="codonnell @caio: nice!"><y>#</y><d>2016-09-02</d><h>16:54</h><w>codonnell</w>@caio: nice!</z><z id="t1472835300" t="escherize Hello I&apos;m new to specter, and I&apos;m trying to move a keyword from one path to another. so far I have this working but I can&apos;t tell if it is the specter way, and I have a feeling i&apos;m doing it wrong: (defn remover [&amp; n] (fn [coll] (into (empty coll) (remove (set n) coll)))) (-&gt;&gt; {:a [1 2 3] :b [4]} (transform [:a] (remover 2)) (setval [:b BEGINNING] [2])) "><y>#</y><d>2016-09-02</d><h>16:55</h><w>escherize</w>Hello I&apos;m new to specter, and I&apos;m trying to move a keyword from one path to another. so far I have this working but I can&apos;t tell if it is the specter way, and I have a feeling i&apos;m doing it wrong:

<pre>(defn remover [&amp; n]
  (fn [coll] (into (empty coll)
                   (remove (set n) coll))))

(-&gt;&gt; {:a [1 2 3] :b [4]}
     (transform [:a] (remover 2))
     (setval [:b BEGINNING] [2]))
</pre></z><z id="t1472835467" t="escherize I&apos;d like to be able to reference the 2 in this example from inside the paths themselves. is that a thing? I&apos;ve been reading the docs and having trouble finding something that addresses this"><y>#</y><d>2016-09-02</d><h>16:57</h><w>escherize</w>I&apos;d like to be able to reference the <code>2</code> in this example from inside the paths themselves.  is that a thing? I&apos;ve been reading the docs and having trouble finding something that addresses this</z><z id="t1472835576" t="codonnell @escherize: To add onto the beginning of a sequence with specter, it&apos;s more idiomatic to do (setval [:b BEGINNING] [0] [1 2 3])"><y>#</y><d>2016-09-02</d><h>16:59</h><w>codonnell</w>@escherize: To add onto the beginning of a sequence with specter, it&apos;s more idiomatic to do <code>(setval [:b BEGINNING] [0] [1 2 3])</code></z><z id="t1472835614" t="escherize thanks, I thought conjer was a bit much. I&apos;ll update the example"><y>#</y><d>2016-09-02</d><h>17:00</h><w>escherize</w>thanks, I thought conjer was a bit much. I&apos;ll update the example</z><z id="t1472835667" t="codonnell Other than that, your approach looks fine to me."><y>#</y><d>2016-09-02</d><h>17:01</h><w>codonnell</w>Other than that, your approach looks fine to me.</z><z id="t1472835765" t="escherize That&apos;s good to hear, thanks @codonnell"><y>#</y><d>2016-09-02</d><h>17:02</h><w>escherize</w>That&apos;s good to hear, thanks @codonnell</z><z id="t1472836064" t="escherize but is there a way to bake the 2 into the path itself?"><y>#</y><d>2016-09-02</d><h>17:07</h><w>escherize</w>but is there a way to bake the <code>2</code> into the path itself?</z><z id="t1472836139" t="zane Oh wow."><y>#</y><d>2016-09-02</d><h>17:08</h><w>zane</w>Oh wow.</z><z id="t1472836260" t="codonnell Yes @escherize. Transform functions receive as their initial arguments any collected values."><y>#</y><d>2016-09-02</d><h>17:11</h><w>codonnell</w>Yes @escherize. Transform functions receive as their initial arguments any collected values.</z><z id="t1472836411" t="codonnell =&gt; (transform [(putval #{2 3 5}) :a] remove {:a (range 10)}) {:a (0 1 4 6 7 8 9)}"><y>#</y><d>2016-09-02</d><h>17:13</h><w>codonnell</w><pre>=&gt; (transform [(putval #{2 3 5}) :a] remove {:a (range 10)})
{:a (0 1 4 6 7 8 9)}</pre></z><z id="t1472836515" t="escherize ohhh. I see! that&apos;s fantasic, thanks @codonnell !"><y>#</y><d>2016-09-02</d><h>17:15</h><w>escherize</w>ohhh. I see! that&apos;s fantasic, thanks @codonnell !</z><z id="t1472842799" t="codonnell @nathanmarz are you planning on a blog post/wiki page about the 0.13.0 changes similar to the post about 0.11.0&apos;s optimizations?"><y>#</y><d>2016-09-02</d><h>18:59</h><w>codonnell</w>@nathanmarz are you planning on a blog post/wiki page about the 0.13.0 changes similar to the post about 0.11.0&apos;s optimizations?</z><z id="t1472845080" t="nathanmarz @codonnell if I have time"><y>#</y><d>2016-09-02</d><h>19:38</h><w>nathanmarz</w>@codonnell if I have time</z><z id="t1472845097" t="nathanmarz @codonnell the inline caching implementation is completely different now"><y>#</y><d>2016-09-02</d><h>19:38</h><w>nathanmarz</w>@codonnell the inline caching implementation is completely different now</z><z id="t1472845137" t="nathanmarz @codonnell I need to get the new design working for cljs first"><y>#</y><d>2016-09-02</d><h>19:38</h><w>nathanmarz</w>@codonnell I need  to get the new design working for cljs first</z><z id="t1472845337" t="codonnell :+1:"><y>#</y><d>2016-09-02</d><h>19:42</h><w>codonnell</w><b>:+1:</b></z><z id="t1472988049" t="markaddleman i&apos;m pretty new to specter. i have a map with some nils in the values. how would i create a submap of all non-nil values? eg {:a 😛 , :c :d, :nil nil} =&gt; {:a 😛 , :c :d}"><y>#</y><d>2016-09-04</d><h>11:20</h><w>markaddleman</w>i&apos;m pretty new to specter.  i have a map with some nils in the values.  how would i create a submap of all non-nil values?  eg {:a <b>😛</b>, :c :d, :nil nil} =&gt; {:a <b>😛</b>, :c :d}</z><z id="t1472993906" t="nathanmarz @markaddleman at the moment with built-in navs: (into {} (traverse [ALL (selected? LAST some?)] data))"><y>#</y><d>2016-09-04</d><h>12:58</h><w>nathanmarz</w>@markaddleman at the moment with built-in navs: <code>(into {} (traverse [ALL (selected? LAST some?)] data))</code></z><z id="t1472993960" t="nathanmarz though there&apos;s consideration over extending the built-in navs to support removal as well https://github.com/nathanmarz/specter/issues/117"><y>#</y><d>2016-09-04</d><h>12:59</h><w>nathanmarz</w>though there&apos;s consideration over extending the built-in navs to support removal as well <a href="https://github.com/nathanmarz/specter/issues/117" target="_blank">https://github.com/nathanmarz/specter/issues/117</a></z><z id="t1472993985" t="nathanmarz in which case your use case would be (setval [MAP-VALS nil?] NONE data)"><y>#</y><d>2016-09-04</d><h>12:59</h><w>nathanmarz</w>in which case your use case would be <code>(setval [MAP-VALS nil?] NONE data)</code></z><z id="t1472996868" t="markaddleman Thanks"><y>#</y><d>2016-09-04</d><h>13:47</h><w>markaddleman</w>Thanks</z><z id="t1473146376" t="escherize Anyone here have much experience with using re-frame + specter before?"><y>#</y><d>2016-09-06</d><h>07:19</h><w>escherize</w>Anyone here have much experience with using re-frame + specter before?</z><z id="t1473146392" t="escherize There is a little bit of overlap (the re-frame path interceptor for example)."><y>#</y><d>2016-09-06</d><h>07:19</h><w>escherize</w>There is a little bit of overlap (the re-frame path interceptor for example).</z><z id="t1473146401" t="escherize but I&apos;d be curious to here."><y>#</y><d>2016-09-06</d><h>07:20</h><w>escherize</w>but I&apos;d be curious to here.</z><z id="t1473171369" t="nathanmarz Released Specter 0.13.0 https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><y>#</y><d>2016-09-06</d><h>14:16</h><w>nathanmarz</w>Released Specter 0.13.0 <a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md" target="_blank">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></z><z id="t1473171390" t="nathanmarz Here&apos;s a post about the new inline caching implementation https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation"><y>#</y><d>2016-09-06</d><h>14:16</h><w>nathanmarz</w>Here&apos;s a post about the new inline caching implementation <a href="https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation" target="_blank">https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation</a></z><z id="t1473171409" t="nathanmarz And a benchmark https://gist.github.com/nathanmarz/b7c612b417647db80b9eaab618ff8d83"><y>#</y><d>2016-09-06</d><h>14:16</h><w>nathanmarz</w>And a benchmark <a href="https://gist.github.com/nathanmarz/b7c612b417647db80b9eaab618ff8d83" target="_blank">https://gist.github.com/nathanmarz/b7c612b417647db80b9eaab618ff8d83</a></z><z id="t1473171523" t="martinklepsch @nathanmarz in changelog with defnav or defnav"><y>#</y><d>2016-09-06</d><h>14:18</h><w>martinklepsch</w>@nathanmarz in changelog <code>with defnav or defnav</code></z><z id="t1473171533" t="martinklepsch think that&apos;s a typo?"><y>#</y><d>2016-09-06</d><h>14:18</h><w>martinklepsch</w>think that&apos;s a typo?</z><z id="t1473171674" t="nathanmarz @martinklepsch just poorly written, updated it to be clearer"><y>#</y><d>2016-09-06</d><h>14:21</h><w>nathanmarz</w>@martinklepsch just poorly written, updated it to be clearer</z><z id="t1473171743" t="martinklepsch ahh, I get it now 😛 I thought there was an asterisk or something like that missing from the second defnav , congrats on the release as well :+1:"><y>#</y><d>2016-09-06</d><h>14:22</h><w>martinklepsch</w>ahh, I get it now <b>😛</b> I thought there was an asterisk or something like that missing from the second <code>defnav</code>, congrats on the release as well <b>:+1:</b></z><z id="t1473171758" t="nathanmarz thanks!"><y>#</y><d>2016-09-06</d><h>14:22</h><w>nathanmarz</w>thanks!</z><z id="t1473172879" t="caio I’m not being able to run the benchmark 😞 Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: com.rpl.specter.Util, compiling:(com/rpl/specter/impl.cljc:1:1)"><y>#</y><d>2016-09-06</d><h>14:41</h><w>caio</w>I’m not being able to run the benchmark <b>😞</b> <code>Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: com.rpl.specter.Util, compiling:(com/rpl/specter/impl.cljc:1:1)</code></z><z id="t1473172914" t="nathanmarz how are you running it?"><y>#</y><d>2016-09-06</d><h>14:41</h><w>nathanmarz</w>how are you running it?</z><z id="t1473172943" t="caio scripts/run-benchmarks"><y>#</y><d>2016-09-06</d><h>14:42</h><w>caio</w><code>scripts/run-benchmarks</code></z><z id="t1473172963" t="nathanmarz ah, do lein javac first"><y>#</y><d>2016-09-06</d><h>14:42</h><w>nathanmarz</w>ah, do <code>lein javac</code> first</z><z id="t1473173033" t="nathanmarz ah just realized the benchmark script needs a quick update"><y>#</y><d>2016-09-06</d><h>14:43</h><w>nathanmarz</w>ah just realized the benchmark script needs a quick update</z><z id="t1473173034" t="nathanmarz one sec"><y>#</y><d>2016-09-06</d><h>14:43</h><w>nathanmarz</w>one sec</z><z id="t1473173094" t="nathanmarz ok, just pushed a fix"><y>#</y><d>2016-09-06</d><h>14:44</h><w>nathanmarz</w>ok, just pushed a fix</z><z id="t1473173110" t="nathanmarz it wasn&apos;t updated to the namespace change"><y>#</y><d>2016-09-06</d><h>14:45</h><w>nathanmarz</w>it wasn&apos;t updated to the namespace change</z><z id="t1473173278" t="caio now it worked. thanks"><y>#</y><d>2016-09-06</d><h>14:47</h><w>caio</w>now it worked. thanks</z><z id="t1473211749" t="amacdougall I&apos;m still getting up to speed on selectors. I&apos;m creating Hiccup-formatted SVG, and in this case, I&apos;m trying to get the attributes map of the first rect in a g (SVG&apos;s &quot;group&quot; tag). This works for me, but I suspect I&apos;m missing a better way: (sm/select-any [s/ALL vector? #(= :rect (first %)) s/ALL map?] [:g [:line {:x1 0 :y1 0 :x2 100 :y2 100}] [:rect {:x 1 :y 2 :width 100 :height 200}]]) "><y>#</y><d>2016-09-07</d><h>01:29</h><w>amacdougall</w>I&apos;m still getting up to speed on selectors. I&apos;m creating Hiccup-formatted SVG, and in this case, I&apos;m trying to get the attributes map of the first <code>rect</code> in a <code>g</code> (SVG&apos;s &quot;group&quot; tag). This works for me, but I suspect I&apos;m missing a better way:
<pre>(sm/select-any
  [s/ALL vector? #(= :rect (first %)) s/ALL map?]
  [:g
   [:line {:x1 0 :y1 0 :x2 100 :y2 100}]
   [:rect {:x 1 :y 2 :width 100 :height 200}]])
</pre></z><z id="t1473211967" t="nathanmarz @amacdougall if the attributes map is always the last element of the vector you can end with LAST instead of [ALL map?]"><y>#</y><d>2016-09-07</d><h>01:32</h><w>nathanmarz</w>@amacdougall if the attributes map is always the last element of the vector you can end with <code>LAST</code> instead of <code>[ALL map?]</code></z><z id="t1473212003" t="amacdougall Ah, good point! In this case, I think it will be, because the rects are leaf nodes in the SVG tree. For other constructs, this may not hold true, but that&apos;s another story."><y>#</y><d>2016-09-07</d><h>01:33</h><w>amacdougall</w>Ah, good point! In this case, I think it will be, because the rects are leaf nodes in the SVG tree. For other constructs, this may not hold true, but that&apos;s another story.</z><z id="t1473212008" t="amacdougall Thanks!"><y>#</y><d>2016-09-07</d><h>01:33</h><w>amacdougall</w>Thanks!</z><z id="t1473212031" t="nathanmarz you can also use keypath to navigate by index into a vector"><y>#</y><d>2016-09-07</d><h>01:33</h><w>nathanmarz</w>you can also use <code>keypath</code> to navigate by index into a vector</z><z id="t1473212180" t="amacdougall I suppose in this case, it&apos;s okay to assume a lot about the structure of the target. But one of my favorite things about Specter is that paths can be quite flexible. Just trying to develop good habits."><y>#</y><d>2016-09-07</d><h>01:36</h><w>amacdougall</w>I suppose in this case, it&apos;s okay to assume a lot about the structure of the target. But one of my favorite things about Specter is that paths can be quite flexible. Just trying to develop good habits.</z><z id="t1473212253" t="nathanmarz yea just takes practice"><y>#</y><d>2016-09-07</d><h>01:37</h><w>nathanmarz</w>yea just takes practice</z><z id="t1473234267" t="levitanong I’m getting ERROR: contains? not supported on type: clojure.lang.PersistentList when requiring specter. Am I doing anything wrong? The following is my require clause in ns : (:require [com.rpl.specter :refer [ALL FIRST]])"><y>#</y><d>2016-09-07</d><h>07:44</h><w>levitanong</w>I’m getting <code>ERROR: contains? not supported on type: clojure.lang.PersistentList</code> when requiring specter. Am I doing anything wrong? The following is my require clause in <code>ns</code>: <code>(:require [com.rpl.specter :refer [ALL FIRST]])</code></z><z id="t1473235090" t="levitanong this is on specter 0.13.0. Specter 0.12.0 works just fine"><y>#</y><d>2016-09-07</d><h>07:58</h><w>levitanong</w>this is on specter 0.13.0. Specter 0.12.0 works just fine</z><z id="t1473246545" t="nathanmarz @levitanong is this Clojure or ClojureScript? do you have a full stack trace?"><y>#</y><d>2016-09-07</d><h>11:09</h><w>nathanmarz</w>@levitanong is this Clojure or ClojureScript? do you have a full stack trace?</z><z id="t1473248613" t="levitanong clojurescript"><y>#</y><d>2016-09-07</d><h>11:43</h><w>levitanong</w>clojurescript</z><z id="t1473248626" t="levitanong hang on, will come up with the full stack trace"><y>#</y><d>2016-09-07</d><h>11:43</h><w>levitanong</w>hang on, will come up with the full stack trace</z><z id="t1473249157" t="nathanmarz @levitanong what version of cljs?"><y>#</y><d>2016-09-07</d><h>11:52</h><w>nathanmarz</w>@levitanong what version of cljs?</z><z id="t1473249173" t="levitanong 1.9.225"><y>#</y><d>2016-09-07</d><h>11:52</h><w>levitanong</w>1.9.225</z><z id="t1473249327" t="nathanmarz I just pushed a build that renames that function, might fix it"><y>#</y><d>2016-09-07</d><h>11:55</h><w>nathanmarz</w>I just pushed a build that renames that function, might fix it</z><z id="t1473249331" t="nathanmarz try 0.13.1-SNAPSHOT"><y>#</y><d>2016-09-07</d><h>11:55</h><w>nathanmarz</w>try 0.13.1-SNAPSHOT</z><z id="t1473271545" t="levitanong @nathanmarz Works perfectly, thanks 🙂"><y>#</y><d>2016-09-07</d><h>18:05</h><w>levitanong</w>@nathanmarz Works perfectly, thanks <b>🙂</b></z><z id="t1473285564" t="darwin just upgraded to 0.13.0, started getting TypeError: this.$late1$.$select_STAR_$ is not a function , looks like I didn’t include something?"><y>#</y><d>2016-09-07</d><h>21:59</h><w>darwin</w>just upgraded to 0.13.0, started getting <code>TypeError: this.$late1$.$select_STAR_$ is not a function</code>, looks like I didn’t include something?</z><z id="t1473285701" t="darwin relevant call-site: https://github.com/binaryage/dirac/blob/a95e9c3f42ca9cd202240509ecbc7196c3a19753/src/implant/dirac/implant/automation/reps.cljs#L63"><y>#</y><d>2016-09-07</d><h>22:01</h><w>darwin</w>relevant call-site:
<a href="https://github.com/binaryage/dirac/blob/a95e9c3f42ca9cd202240509ecbc7196c3a19753/src/implant/dirac/implant/automation/reps.cljs#L63" target="_blank">https://github.com/binaryage/dirac/blob/a95e9c3f42ca9cd202240509ecbc7196c3a19753/src/implant/dirac/implant/automation/reps.cljs#L63</a></z><z id="t1473285973" t="darwin investigating it more, this looks like advanced-mode optimization problem"><y>#</y><d>2016-09-07</d><h>22:06</h><w>darwin</w>investigating it more, this looks like advanced-mode optimization problem</z><z id="t1473285988" t="darwin I’m compiling my cljs code under :advanced with :pseudo-names true (running my tests against advanced mode build)"><y>#</y><d>2016-09-07</d><h>22:06</h><w>darwin</w>I’m compiling my cljs code under :advanced with :pseudo-names true (running my tests against advanced mode build)</z><z id="t1473286451" t="nathanmarz @darwin so you don&apos;t get the error under a different optimization mode?"><y>#</y><d>2016-09-07</d><h>22:14</h><w>nathanmarz</w>@darwin so you don&apos;t get the error under a different optimization mode?</z><z id="t1473286511" t="darwin trying to test that, but my project is pretty complex and I bumped into another issue with :none mode"><y>#</y><d>2016-09-07</d><h>22:15</h><w>darwin</w>trying to test that, but my project is pretty complex and I bumped into another issue with :none mode</z><z id="t1473286517" t="darwin will get back to you ASAP"><y>#</y><d>2016-09-07</d><h>22:15</h><w>darwin</w>will get back to you ASAP</z><z id="t1473286520" t="nathanmarz ok"><y>#</y><d>2016-09-07</d><h>22:15</h><w>nathanmarz</w>ok</z><z id="t1473286526" t="nathanmarz also, you should try 0.13.1-SNAPSHOT"><y>#</y><d>2016-09-07</d><h>22:15</h><w>nathanmarz</w>also, you should try 0.13.1-SNAPSHOT</z><z id="t1473286541" t="darwin ok, going to do that first"><y>#</y><d>2016-09-07</d><h>22:15</h><w>darwin</w>ok, going to do that first</z><z id="t1473286549" t="nathanmarz what version of cljs are you using?"><y>#</y><d>2016-09-07</d><h>22:15</h><w>nathanmarz</w>what version of cljs are you using?</z><z id="t1473286596" t="darwin 229"><y>#</y><d>2016-09-07</d><h>22:16</h><w>darwin</w>229</z><z id="t1473287123" t="darwin so 0.13.1-SNAPSHOT behaves the same way for me under :advanced, now I’m going to make that :none mode work"><y>#</y><d>2016-09-07</d><h>22:25</h><w>darwin</w>so 0.13.1-SNAPSHOT behaves the same way for me under :advanced, now I’m going to make that :none mode work</z><z id="t1473287142" t="darwin just need to mess with goog/base.js require which is missing for some reason"><y>#</y><d>2016-09-07</d><h>22:25</h><w>darwin</w>just need to mess with goog/base.js require which is missing for some reason</z><z id="t1473288567" t="darwin this is fun, I’m depending on parinfer package from cljsjs and it has missing semicolon in a wrong place, advanced mode optimizer seems to “fix” it and in [:attrs nil] :simple / :whitespace mode browser throws, this will be hard to fix quickly..."><y>#</y><d>2016-09-07</d><h>22:49</h><w>darwin</w>this is fun, I’m depending on parinfer package from cljsjs and it has missing semicolon in a wrong place, advanced mode optimizer seems to “fix” it and in <del>:none</del> :simple / :whitespace mode browser throws, this will be hard to fix quickly...</z><z id="t1473288592" t="darwin maybe I will just try to isolate my specter usage into a standalone project and demonstrate the issue there (if exists)"><y>#</y><d>2016-09-07</d><h>22:49</h><w>darwin</w>maybe I will just try to isolate my specter usage into a standalone project and demonstrate the issue there (if exists)</z><z id="t1473370867" t="gphilipp Hi, I’m trying to solve using Specter the clojure brave and true example of chapter 3 (the one with the hobbit symmetrical body, search &apos;Pulling It All Together&apos; on http://www.braveclojure.com/do-things/ ), but I can’t find a way to do it. Can anybody enlighten me ?"><y>#</y><d>2016-09-08</d><h>21:41</h><w>gphilipp</w>Hi, I’m trying to solve using Specter the clojure brave and true example of chapter 3 (the one with the hobbit symmetrical body, search &apos;Pulling It All Together&apos; on <a href="http://www.braveclojure.com/do-things/" target="_blank">http://www.braveclojure.com/do-things/</a>), but I can’t find a way to do it. Can anybody enlighten me ?</z><z id="t1473370936" t="gphilipp My best shot is to transform existing parts, but I didn’t add them to the whole collection : (transform [ALL needs-matching-part?] make-matching-part asym-hobbit-body-parts)"><y>#</y><d>2016-09-08</d><h>21:42</h><w>gphilipp</w>My best shot is to transform existing parts, but I didn’t add them to the whole collection : <pre>(transform [ALL needs-matching-part?]
           make-matching-part
           asym-hobbit-body-parts)</pre></z><z id="t1473372421" t="loganmhb @gphilipp one way to do that is with multi-transform, I think: (multi-transform [ALL needs-matching-part? (multi-path (terminal identity) (terminal make-matching-part))] asym-hobbit-body-parts) "><y>#</y><d>2016-09-08</d><h>22:07</h><w>loganmhb</w>@gphilipp one way to do that is with multi-transform, I think:
<pre>(multi-transform [ALL needs-matching-part? (multi-path (terminal identity)
                                                       (terminal make-matching-part))]
                 asym-hobbit-body-parts)
</pre></z><z id="t1473372514" t="loganmhb dunno if there’s a way to avoid the explicit identity"><y>#</y><d>2016-09-08</d><h>22:08</h><w>loganmhb</w>dunno if there’s a way to avoid the explicit <code>identity</code></z><z id="t1473372564" t="aengelberg I don&apos;t think that would work, it would overwrite the value with the second transformation in multi-path"><y>#</y><d>2016-09-08</d><h>22:09</h><w>aengelberg</w>I don&apos;t think that would work, it would overwrite the value with the second transformation in <code>multi-path</code></z><z id="t1473372645" t="loganmhb ah, I think you’re right"><y>#</y><d>2016-09-08</d><h>22:10</h><w>loganmhb</w>ah, I think you’re right</z><z id="t1473372664" t="loganmhb was testing with range and misinterpreted the output 🙂"><y>#</y><d>2016-09-08</d><h>22:11</h><w>loganmhb</w>was testing with <code>range</code> and misinterpreted the output <b>🙂</b></z><z id="t1473372712" t="aengelberg there might be a way with com.rpl.specter.zipper"><y>#</y><d>2016-09-08</d><h>22:11</h><w>aengelberg</w>there might be a way with <code>com.rpl.specter.zipper</code></z><z id="t1473372771" t="loganmhb here’s something: (select [ALL keyword? (continue-then-stay (transformed STAY str))] [:a :b :c]) [&quot;:a&quot; :a &quot;:b&quot; :b &quot;:c&quot; :c] "><y>#</y><d>2016-09-08</d><h>22:12</h><w>loganmhb</w>here’s something:
<pre>(select [ALL keyword? (continue-then-stay (transformed STAY str))] [:a :b :c])
[&quot;:a&quot; :a &quot;:b&quot; :b &quot;:c&quot; :c]
</pre></z><z id="t1473372885" t="gphilipp That looks ok. Not very readable though :-/"><y>#</y><d>2016-09-08</d><h>22:14</h><w>gphilipp</w>That looks ok. Not very readable though :-/</z><z id="t1473372929" t="gphilipp Thanks anyway !"><y>#</y><d>2016-09-08</d><h>22:15</h><w>gphilipp</w>Thanks anyway !</z><z id="t1473373167" t="aengelberg (transform [VECTOR-ZIP LEFTMOST (stay-then-continue RIGHT) NODE-SEQ (view set) (collect-one FIRST) (subset #{})] (fn [body-part _] #{(make-matching-part body-part)}) asym-hobbit-body-parts) "><y>#</y><d>2016-09-08</d><h>22:19</h><w>aengelberg</w><pre>(transform [VECTOR-ZIP LEFTMOST (stay-then-continue RIGHT) NODE-SEQ (view set) (collect-one FIRST) (subset #{})] (fn [body-part _] #{(make-matching-part body-part)}) asym-hobbit-body-parts)
</pre></z><z id="t1473373212" t="aengelberg #nailedit"><y>#</y><d>2016-09-08</d><h>22:20</h><w>aengelberg</w>#nailedit</z><z id="t1473373680" t="caio so, I have this small path that I’m using in several places: [map? ALL (sp/if-path #(-&gt; % first ks) LAST)] it’s basically a select-key (didn’t use (view #(select-key …)) cause it doesn’t work on transforms :(). is this the right way of doing it? if it is, how can I transform it into a nav? my goal is to call (key-selector ks) inside a path"><y>#</y><d>2016-09-08</d><h>22:28</h><w>caio</w>so, I have this small path that I’m using in several places: <code>[map? ALL (sp/if-path #(-&gt; % first ks) LAST)]</code>
it’s basically a <code>select-key</code> (didn’t use <code>(view #(select-key …))</code> cause it doesn’t work on transforms :(). is this the right way of doing it? if it is, how can I transform it into a nav? my goal is to call <code>(key-selector ks)</code> inside a path</z><z id="t1473373739" t="caio I looked into defnav , but couldn’t understand how to do it"><y>#</y><d>2016-09-08</d><h>22:28</h><w>caio</w>I looked into <code>defnav</code>, but couldn’t understand how to do it</z><z id="t1473374239" t="codonnell There might be a way to do it with multi-path . "><y>#</y><d>2016-09-08</d><h>22:37</h><w>codonnell</w>There might be a way to do it with <code>multi-path</code>. </z><z id="t1473374314" t="codonnell Or submap"><y>#</y><d>2016-09-08</d><h>22:38</h><w>codonnell</w>Or submap</z><z id="t1473374655" t="codonnell @caio yeah that&apos;s exactly submap ( https://github.com/nathanmarz/specter/wiki/List-of-Navigators#submap )"><y>#</y><d>2016-09-08</d><h>22:44</h><w>codonnell</w>@caio yeah that&apos;s exactly <code>submap</code> (<a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#submap" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#submap</a>)</z><z id="t1473374710" t="caio well, that was easy. thanks again @codonnell"><y>#</y><d>2016-09-08</d><h>22:45</h><w>caio</w>well, that was easy. thanks again @codonnell</z><z id="t1473382643" t="codonnell @caio if you were confused about how to implement it using defnav you could check out the source code for submap at https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L703"><y>#</y><d>2016-09-09</d><h>00:57</h><w>codonnell</w>@caio if you were confused about how to implement it using <code>defnav</code> you could check out the source code for <code>submap</code> at <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L703" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L703</a></z><z id="t1473779120" t="zane Is it possible to attach docstrings via defnav ?"><y>#</y><d>2016-09-13</d><h>15:05</h><w>zane</w>Is it possible to attach docstrings via <code>defnav</code>?</z><z id="t1473779235" t="codonnell @zane IIRC the semantics are the same as clojure.core/defn"><y>#</y><d>2016-09-13</d><h>15:07</h><w>codonnell</w>@zane IIRC the semantics are the same as <code>clojure.core/defn</code></z><z id="t1473779453" t="zane @codonnell: Don&apos;t think so. This doesn&apos;t compile, for example: (defnav EXAMPLE &quot;Docs!&quot; [] (select* [this structure next-fn]) (transform* [this structure next-fn]) Whereas, this does: (defn example &quot;Docs!&quot; [] :ok) "><y>#</y><d>2016-09-13</d><h>15:10</h><w>zane</w>@codonnell: Don&apos;t think so. This doesn&apos;t compile, for example:
<pre>(defnav EXAMPLE
  &quot;Docs!&quot;
  []
  (select* [this structure next-fn])
  (transform* [this structure next-fn])
</pre>
Whereas, this does:
<pre>(defn example
  &quot;Docs!&quot;
  []
  :ok)
</pre></z><z id="t1473779584" t="codonnell @zane which specter version are you using?"><y>#</y><d>2016-09-13</d><h>15:13</h><w>codonnell</w>@zane which specter version are you using?</z><z id="t1473779616" t="zane [com.rpl/specter &quot;0.12.0&quot;]"><y>#</y><d>2016-09-13</d><h>15:13</h><w>zane</w><code>[com.rpl/specter &quot;0.12.0&quot;]</code></z><z id="t1473779806" t="codonnell @zane just took a look at the source; nope, no docstrings"><y>#</y><d>2016-09-13</d><h>15:16</h><w>codonnell</w>@zane just took a look at the source; nope, no docstrings</z><z id="t1473779819" t="zane Yeah. I looked at it too but wanted to confirm. Sad panda."><y>#</y><d>2016-09-13</d><h>15:16</h><w>zane</w>Yeah. I looked at it too but wanted to confirm. Sad panda.</z><z id="t1473784031" t="nathanmarz @zane you can use ^{:doc ...} syntax in front of the symbol, e.g. https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L593"><y>#</y><d>2016-09-13</d><h>16:27</h><w>nathanmarz</w>@zane you can use <code>^{:doc ...}</code> syntax in front of the symbol, e.g. <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L593" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L593</a></z><z id="t1473784126" t="zane Thanks, Nathan!"><y>#</y><d>2016-09-13</d><h>16:28</h><w>zane</w>Thanks, Nathan!</z><z id="t1473801175" t="mac This might be obvious and/or silly, but wouldn&apos;t specter be very well suited to query/update those application state atoms that all the web-frameworks use these days?"><y>#</y><d>2016-09-13</d><h>21:12</h><w>mac</w>This might be obvious and/or silly, but wouldn&apos;t specter be very well suited to query/update those application state atoms that all the web-frameworks use these days?</z><z id="t1473803326" t="nathanmarz @mac I think Specter is extremely useful for web programming in general, as a DOM is just a big nested data structure"><y>#</y><d>2016-09-13</d><h>21:48</h><w>nathanmarz</w>@mac I think Specter is extremely useful for web programming in general, as a DOM is just a big nested data structure</z><z id="t1473806409" t="cjmurphy @mac Something that goes against that idea somewhat is to have the atom have its own internal organisation and way of querying updating, which is what Om Next does with its Idents. (Having said that I imagine Om Next would still benefit from using Specter)."><y>#</y><d>2016-09-13</d><h>22:40</h><w>cjmurphy</w>@mac Something that goes against that idea somewhat is to have the atom have its own internal organisation and way of querying updating, which is what Om Next does with its Idents. (Having said that I imagine Om Next would still benefit from using Specter).</z><z id="t1473857591" t="levitanong Is there any way to transform keys of hashmaps to booleans without filtering out false s?"><y>#</y><d>2016-09-14</d><h>12:53</h><w>levitanong</w>Is there any way to <code>transform</code> keys of hashmaps to booleans without filtering out <code>false</code>s?</z><z id="t1473859093" t="codonnell @levitanong Not sure exactly what behavior you want. Could you give an example?"><y>#</y><d>2016-09-14</d><h>13:18</h><w>codonnell</w>@levitanong Not sure exactly what behavior you want. Could you give an example?</z><z id="t1473869059" t="levitanong @codonnell given the following dataset: (def data {1 {“false” 11 “true” 12} 2 {“false” 21 “true” 22}}) I want to turn the strings to proper booleans. (transform [ALL LAST ALL FIRST] boolean data) However, instead of (def data {1 {false 11 true 12} 2 {false 21 true 22}}) I get (def data {1 {true 12} 2 {true 22}}) So I’m assuming transform automatically removes falsy values or keys."><y>#</y><d>2016-09-14</d><h>16:04</h><w>levitanong</w>@codonnell given the following dataset:
<pre>(def data {1 {“false” 11 “true” 12} 2 {“false” 21 “true” 22}})
</pre>

I want to turn the strings to proper booleans.
<pre>(transform [ALL LAST ALL FIRST]
  boolean
  data)
</pre>

However, instead of

<pre>(def data {1 {false 11 true 12} 2 {false 21 true 22}})
</pre>
I get
<pre>(def data {1 {true 12} 2 {true 22}})
</pre>
So I’m assuming <code>transform</code> automatically removes falsy values or keys.</z><z id="t1473869268" t="nathanmarz @levitanong (boolean &quot;false&quot;) returns true"><y>#</y><d>2016-09-14</d><h>16:07</h><w>nathanmarz</w>@levitanong <code>(boolean &quot;false&quot;)</code> returns <code>true</code></z><z id="t1473869278" t="levitanong derp"><y>#</y><d>2016-09-14</d><h>16:07</h><w>levitanong</w>derp</z><z id="t1473869280" t="nathanmarz I think you want to make a parse-boolean-string function"><y>#</y><d>2016-09-14</d><h>16:08</h><w>nathanmarz</w>I think you want to make a <code>parse-boolean-string</code> function</z><z id="t1473869312" t="levitanong My bad! Thanks @nathanmarz"><y>#</y><d>2016-09-14</d><h>16:08</h><w>levitanong</w>My bad! Thanks @nathanmarz</z><z id="t1474147604" t="karan hey guys, is there an idiomatic way to select a slice of a nested map given a predicate for some level? for example, using even? , {:a {:b 1, :c 2}, :d {:e 3, :f 4}, :g {:h 5}} -&gt; {:a {:c 2} :d {:f 4}}"><y>#</y><d>2016-09-17</d><h>21:26</h><w>karan</w>hey guys, is there an idiomatic way to select a slice of a nested map given a predicate for some level? for example, using <code>even?</code>, <code>{:a {:b 1, :c 2}, :d {:e 3, :f 4}, :g {:h 5}}</code> -&gt; <code>{:a {:c 2} :d {:f 4}}</code></z><z id="t1474147627" t="karan so far I have something like this, which is pretty close: (transform [MAP-VALS] #(into {} (select-one (filterer LAST even?) %)) ex) "><y>#</y><d>2016-09-17</d><h>21:27</h><w>karan</w>so far I have something like this, which is pretty close: 
<pre>(transform [MAP-VALS]
    #(into {} 
               (select-one (filterer LAST even?) %))
      ex)
</pre></z><z id="t1474147720" t="karan with (def ex {:a {:b 1, :c 2}, :d {:e 3, :f 4}, :g {:h 5}})"><y>#</y><d>2016-09-17</d><h>21:28</h><w>karan</w>with <code>(def ex {:a {:b 1, :c 2}, :d {:e 3, :f 4}, :g {:h 5}})</code></z><z id="t1474148078" t="karan the (into {} … ) doesn’t seem like the best solution. maybe if there were a type-aware select ? seems to be an issue from a while back here: https://github.com/nathanmarz/specter/issues/127"><y>#</y><d>2016-09-17</d><h>21:34</h><w>karan</w>the <code>(into {} … )</code> doesn’t seem like the best solution. maybe if there were a type-aware <code>select</code>? seems to be an issue from a while back here: <a href="https://github.com/nathanmarz/specter/issues/127" target="_blank">https://github.com/nathanmarz/specter/issues/127</a></z><z id="t1474148430" t="nathanmarz @karan sounds like that would be a variant on submap that takes in a path to evaluate the vals, e.g. (filtered-submap even?) or (filtered-submap (filterer even?) (view count) #(&gt;= % 2))"><y>#</y><d>2016-09-17</d><h>21:40</h><w>nathanmarz</w>@karan sounds like that would be a variant on <code>submap</code> that takes in a path to evaluate the vals, e.g. <code>(filtered-submap even?)</code> or <code>(filtered-submap (filterer even?) (view count) #(&gt;= % 2))</code></z><z id="t1474148557" t="nathanmarz see selected? implementation for an example of a navigator which uses a path"><y>#</y><d>2016-09-17</d><h>21:42</h><w>nathanmarz</w>see <code>selected?</code> implementation for an example of a navigator which uses a path</z><z id="t1474148739" t="karan @nathanmarz thanks, I’ll try that!"><y>#</y><d>2016-09-17</d><h>21:45</h><w>karan</w>@nathanmarz thanks, I’ll try that!</z><z id="t1474173167" t="fasiha I&apos;m super-hesitant to ask this—I feel I ought to go thru the wikis listing the navigators and macros and other examples a couple more times (and as I just did). Can I navigate to &quot;the space between the first and second element of a vec&quot; and setval it, so that [:a :b :c] becomes [:a :NEW-VAL :b :c] ?"><y>#</y><d>2016-09-18</d><h>04:32</h><w>fasiha</w>I&apos;m super-hesitant to ask this—I feel I ought to go thru the wikis listing the navigators and macros and other examples a couple more times (and as I just did). Can I navigate to &quot;the space between the first and second element of a vec&quot; and <code>setval</code> it, so that <code>[:a :b :c]</code> becomes <code>[:a :NEW-VAL :b :c]</code>?</z><z id="t1474173764" t="karan try this: (def my-nav (n/PosNavigator (fn [v] (nth v 1)) (fn [v afn] (let [val (nth v 1)] (assoc v 1 (afn val)))))) "><y>#</y><d>2016-09-18</d><h>04:42</h><w>karan</w>try this: 
<pre>(def my-nav (n/PosNavigator (fn [v] (nth v 1)) (fn [v afn]
                                                                 (let [val (nth v 1)]
                                                                   (assoc v 1 (afn val))))))
</pre></z><z id="t1474173795" t="karan that will need to polymorphic on the second function (the transformer), but it’s the idea"><y>#</y><d>2016-09-18</d><h>04:43</h><w>karan</w>that will need to polymorphic on the second function (the transformer), but it’s the idea</z><z id="t1474173833" t="karan @fasiha"><y>#</y><d>2016-09-18</d><h>04:43</h><w>karan</w>@fasiha</z><z id="t1474174021" t="karan oh never mind, that’s not what you asked 🙂 . sorry!"><y>#</y><d>2016-09-18</d><h>04:47</h><w>karan</w>oh never mind, that’s not what you asked <b>🙂</b>. sorry!</z><z id="t1474174442" t="karan (defnav POSONE [] (select* [this structure next-fn] (next-fn [])) (transform* [this structure next-fn] (let [new-val (next-fn [])] (vec (cons (first structure) (cons new-val (rest structure))))))) @fasiha take two. similar caveats, but I think that’s the right direction."><y>#</y><d>2016-09-18</d><h>04:54</h><w>karan</w><pre>(defnav POSONE []
                   (select* [this structure next-fn]
                            (next-fn []))
                   (transform* [this structure next-fn]
                               (let [new-val (next-fn [])]
                                 (vec (cons (first structure)
                                            (cons new-val (rest structure)))))))
</pre> 
@fasiha take two. similar caveats, but I think that’s the right direction.</z><z id="t1474197686" t="nathanmarz @fasiha (setval (srange 1 1) [:NEW-VAL] [:a :b :c])"><y>#</y><d>2016-09-18</d><h>11:21</h><w>nathanmarz</w>@fasiha <code>(setval (srange 1 1) [:NEW-VAL] [:a :b :c])</code></z><z id="t1474260286" t="aaelony what is the idiomatic way in Specter to do the following: (mapv (fn [x] {:name x}) (-&gt;&gt; [[:a :b][:b :c][:c :d][:c :e]] flatten set vec )) =&gt; [{:name :e} {:name :c} {:name :b} {:name :d} {:name :a}]"><y>#</y><d>2016-09-19</d><h>04:44</h><w>aaelony</w>what is the idiomatic way in Specter to do the following: <pre>(mapv (fn [x] {:name x}) (-&gt;&gt; [[:a :b][:b :c][:c :d][:c :e]] flatten set vec ))
=&gt; [{:name :e} {:name :c} {:name :b} {:name :d} {:name :a}]</pre></z><z id="t1474260351" t="aaelony taking a vector and constructing a map with new keys and vals?"><y>#</y><d>2016-09-19</d><h>04:45</h><w>aaelony</w>taking a vector and constructing a map with new keys and vals?</z><z id="t1474280605" t="dev-hartmann i am trying to add to a list inside a map of maps if the if the id matches. my code looks like that: (def same-id? (specter/comp-paths (specter/paramsfn [id-key id] [item] (= id (get item id-key)))))"><y>#</y><d>2016-09-19</d><h>10:23</h><w>dev-hartmann</w>i am trying to add to a list inside a map of maps if the if the id matches. my code looks like that: (def same-id?
 (specter/comp-paths (specter/paramsfn [id-key id] [item] (= id (get item id-key)))))</z><z id="t1474280620" t="dev-hartmann (specter/select [specter/ALL same-id? (:entity-id entity) (:entity-val entity)] db)"><y>#</y><d>2016-09-19</d><h>10:23</h><w>dev-hartmann</w>(specter/select [specter/ALL same-id? (:entity-id entity) (:entity-val entity)] db)</z><z id="t1474280670" t="dev-hartmann i know the actual transform is missing, but i have a feeling i missunderstood how to use specter"><y>#</y><d>2016-09-19</d><h>10:24</h><w>dev-hartmann</w>i know the actual transform is missing, but i have a feeling i missunderstood how to use specter</z><z id="t1474280786" t="nathanmarz can you give an example of input/output?"><y>#</y><d>2016-09-19</d><h>10:26</h><w>nathanmarz</w>can you give an example of input/output?</z><z id="t1474280868" t="nathanmarz @aaelony that&apos;s an aggregation producing a brand new data structure construction, so Specter won&apos;t be any better than transducers for that case"><y>#</y><d>2016-09-19</d><h>10:27</h><w>nathanmarz</w>@aaelony that&apos;s an aggregation producing a brand new data structure construction, so Specter won&apos;t be any better than transducers for that case</z><z id="t1474281033" t="nathanmarz @aaelony but this is an efficient way to do it: (-&gt;&gt; [[:a :b][:b :c][:c :d][:c :e]] (traverse [ALL ALL]) (into #{}) (into [] (map (fn [k] {:name k})))) "><y>#</y><d>2016-09-19</d><h>10:30</h><w>nathanmarz</w>@aaelony but this is an efficient way to do it:
<pre>(-&gt;&gt; [[:a :b][:b :c][:c :d][:c :e]]
     (traverse [ALL ALL])
     (into #{})
     (into [] (map (fn [k] {:name k}))))
</pre></z><z id="t1474282300" t="dev-hartmann entity = {:entity-id :advisory-id :entity-val :&quot;2016-1425&quot;} db = {:advisories {:list {:advisory-id &quot;2016-1623&quot; :cvss {:c 1 :d 2 :e 3} :tags ({:tag-key &quot;test-tag&quot; :tag-value nil} {:tag-key &quot;test-tag-2&quot; :tag-value 12})}}}"><y>#</y><d>2016-09-19</d><h>10:51</h><w>dev-hartmann</w>entity = {:entity-id :advisory-id :entity-val :&quot;2016-1425&quot;}
db = {:advisories {:list {:advisory-id &quot;2016-1623&quot; :cvss {:c 1 :d 2 :e 3} :tags ({:tag-key &quot;test-tag&quot; :tag-value nil} {:tag-key &quot;test-tag-2&quot; :tag-value 12})}}}</z><z id="t1474282331" t="dev-hartmann at the moment i don&apos;t get any output because i cannot locate paramsfn"><y>#</y><d>2016-09-19</d><h>10:52</h><w>dev-hartmann</w>at the moment i don&apos;t get any output because i cannot locate paramsfn</z><z id="t1474282421" t="dev-hartmann what i want to do is, append a tag to tags inside advisory inside the advisories list if the id matches"><y>#</y><d>2016-09-19</d><h>10:53</h><w>dev-hartmann</w>what i want to do is, append a tag to tags inside advisory inside the advisories list if the id matches</z><z id="t1474282424" t="dev-hartmann entity id"><y>#</y><d>2016-09-19</d><h>10:53</h><w>dev-hartmann</w>entity id</z><z id="t1474282898" t="nathanmarz @dev-hartmann looking for expected input/output"><y>#</y><d>2016-09-19</d><h>11:01</h><w>nathanmarz</w>@dev-hartmann looking for expected input/output</z><z id="t1474282929" t="nathanmarz paramsfn was removed in 0.13.0 because it&apos;s no longer necessary"><y>#</y><d>2016-09-19</d><h>11:02</h><w>nathanmarz</w><code>paramsfn</code> was removed in 0.13.0 because it&apos;s no longer necessary</z><z id="t1474283018" t="dev-hartmann expected output is the updated db map"><y>#</y><d>2016-09-19</d><h>11:03</h><w>dev-hartmann</w>expected output is the updated db map</z><z id="t1474283071" t="dev-hartmann input is entity map like above and a tag {:tag-key &quot;something&quot; :tag-value &quot;optional&quot;}"><y>#</y><d>2016-09-19</d><h>11:04</h><w>dev-hartmann</w>input is entity map like above and a tag {:tag-key &quot;something&quot; :tag-value &quot;optional&quot;}</z><z id="t1474283277" t="nathanmarz I don&apos;t know what you mean, so I need a specific minimal example of input/output in order to help you"><y>#</y><d>2016-09-19</d><h>11:07</h><w>nathanmarz</w>I don&apos;t know what you mean, so I need a specific minimal example of input/output in order to help you</z><z id="t1474283694" t="dev-hartmann (transform [(filterer #( = (:entity-val entity) (:entity-id %))) ALL] #(conj (:tags %) tag) db)]"><y>#</y><d>2016-09-19</d><h>11:14</h><w>dev-hartmann</w>(transform [(filterer #( = (:entity-val entity) (:entity-id %))) ALL] #(conj (:tags %) tag) db)]</z><z id="t1474283710" t="dev-hartmann that&apos;s what i am trying at the moment, with the data from above"><y>#</y><d>2016-09-19</d><h>11:15</h><w>dev-hartmann</w>that&apos;s what i am trying at the moment, with the data from above</z><z id="t1474284064" t="dev-hartmann as a result i get the unchanged map"><y>#</y><d>2016-09-19</d><h>11:21</h><w>dev-hartmann</w>as a result i get the unchanged map</z><z id="t1474284238" t="nathanmarz @dev-hartmann a specific minimal example is something like [1 2 3] =&gt; [2 3 4]"><y>#</y><d>2016-09-19</d><h>11:23</h><w>nathanmarz</w>@dev-hartmann a specific minimal example is something like <code>[1 2 3]</code> =&gt; <code>[2 3 4]</code></z><z id="t1474284300" t="dev-hartmann ah ok, sry, did not understand -.-"><y>#</y><d>2016-09-19</d><h>11:25</h><w>dev-hartmann</w>ah ok, sry, did not understand -.-</z><z id="t1474284731" t="dev-hartmann {:entity-id :item-id :entity-val 1} {:tag-key &quot;test2&quot; :tag-value &quot;2&quot;} {:items {:item-id 1 :sub-items ({:tag-key :tag &quot;value&quot;} {:tag-key &quot;tag2&quot; &quot;value2&quot;} {:tag-key &quot;tag3&quot; &quot;value1&quot;})} {:item-id 2 :sub-items ({:tag-key &quot;tag1&quot; &quot;value&quot;})}} -&gt; {:items {:item-id 1 :sub-items ({:tag-key :tag &quot;value&quot;} {:tag-key :tag2 &quot;value2&quot;} {:tag-key :tag3 &quot;value1&quot;})} {:item-id 2 :sub-items ({:tag-key &quot;tag-test&quot; &quot;value&quot;} {:tag-key &quot;test2&quot; :tag-value &quot;2&quot;})}} "><y>#</y><d>2016-09-19</d><h>11:32</h><w>dev-hartmann</w><pre>{:entity-id :item-id :entity-val 1} </pre> <pre>{:tag-key &quot;test2&quot; :tag-value &quot;2&quot;}</pre> <pre>{:items {:item-id 1 :sub-items ({:tag-key :tag &quot;value&quot;} {:tag-key &quot;tag2&quot; &quot;value2&quot;} {:tag-key &quot;tag3&quot; &quot;value1&quot;})}
        {:item-id 2 :sub-items ({:tag-key &quot;tag1&quot; &quot;value&quot;})}} </pre> -&gt; <pre>{:items {:item-id 1 :sub-items ({:tag-key :tag &quot;value&quot;} {:tag-key :tag2 &quot;value2&quot;} {:tag-key :tag3 &quot;value1&quot;})}
        {:item-id 2 :sub-items ({:tag-key &quot;tag-test&quot; &quot;value&quot;} {:tag-key &quot;test2&quot; :tag-value &quot;2&quot;})}} </pre></z><z id="t1474284739" t="dev-hartmann like that?"><y>#</y><d>2016-09-19</d><h>11:32</h><w>dev-hartmann</w>like that?</z><z id="t1474284838" t="nathanmarz yes"><y>#</y><d>2016-09-19</d><h>11:33</h><w>nathanmarz</w>yes</z><z id="t1474284850" t="nathanmarz do you mean for value of :items to be in a list of some sort?"><y>#</y><d>2016-09-19</d><h>11:34</h><w>nathanmarz</w>do you mean for value of :items to be in a list of some sort?</z><z id="t1474284878" t="dev-hartmann oh yes, sry"><y>#</y><d>2016-09-19</d><h>11:34</h><w>dev-hartmann</w>oh yes, sry</z><z id="t1474284884" t="dev-hartmann it&apos;s a list"><y>#</y><d>2016-09-19</d><h>11:34</h><w>dev-hartmann</w>it&apos;s a list</z><z id="t1474284906" t="nathanmarz and here you have the append going to subitems of item id 2, but your input says entity-val 1"><y>#</y><d>2016-09-19</d><h>11:35</h><w>nathanmarz</w>and here you have the append going to subitems of item id 2, but your input says entity-val 1</z><z id="t1474284945" t="dev-hartmann my brain is full on monday, sry again, entity-val should be 2"><y>#</y><d>2016-09-19</d><h>11:35</h><w>dev-hartmann</w>my brain is full on monday, sry again, entity-val should be 2</z><z id="t1474285054" t="nathanmarz one way to do it: (setval [:items ALL #(= (get % (:entity-id entity)) (:entity-val entity)) :sub-items END] [tag] db)"><y>#</y><d>2016-09-19</d><h>11:37</h><w>nathanmarz</w>one way to do it: <code>(setval [:items ALL #(= (get % (:entity-id entity)) (:entity-val entity)) :sub-items END] [tag] db)</code></z><z id="t1474285179" t="dev-hartmann thank you very much, seeing your answer explains how i got the way the path is created all wrong. thanks again"><y>#</y><d>2016-09-19</d><h>11:39</h><w>dev-hartmann</w>thank you very much, seeing your answer explains how i got the way the path is created all wrong. thanks again</z><z id="t1474285231" t="nathanmarz I would also suggest using vectors instead of lists for sub-items, as appending to a vector is much more efficient"><y>#</y><d>2016-09-19</d><h>11:40</h><w>nathanmarz</w>I would also suggest using vectors instead of lists for sub-items, as appending to a vector is much more efficient</z><z id="t1474285647" t="dev-hartmann that makes sense, thanks for the advice"><y>#</y><d>2016-09-19</d><h>11:47</h><w>dev-hartmann</w>that makes sense, thanks for the advice</z><z id="t1474301180" t="aaelony thanks, @nathanmarz"><y>#</y><d>2016-09-19</d><h>16:06</h><w>aaelony</w>thanks, @nathanmarz</z><z id="t1474405444" t="puzzler Which is more idiomatic to conj something into a set inside some other stuff : (setval [path1 path2 (subset #{})] #{:a} data) or (transform [path1 path2] #(conj % :a) data) ?"><y>#</y><d>2016-09-20</d><h>21:04</h><w>puzzler</w>Which is more idiomatic to conj something into a set inside some other stuff : <code>(setval [path1 path2 (subset #{})] #{:a} data)</code>  or <code>(transform [path1 path2] #(conj % :a) data)</code>?</z><z id="t1474405476" t="puzzler And is there a meaningful perf difference between the two?"><y>#</y><d>2016-09-20</d><h>21:04</h><w>puzzler</w>And is there a meaningful perf difference between the two?</z><z id="t1474405823" t="nathanmarz @puzzler the latter will be faster but the former works better with nil"><y>#</y><d>2016-09-20</d><h>21:10</h><w>nathanmarz</w>@puzzler the latter will be faster but the former works better with nil</z><z id="t1474405912" t="nathanmarz I&apos;ve considered making navigators that go to &quot;void&quot; elements of specific type, like VOID-SET-ELEM"><y>#</y><d>2016-09-20</d><h>21:11</h><w>nathanmarz</w>I&apos;ve considered making navigators that go to &quot;void&quot; elements of specific type, like VOID-SET-ELEM</z><z id="t1474405931" t="nathanmarz if the transform results in NONE , it wouldn&apos;t conj, otherwise it would conj"><y>#</y><d>2016-09-20</d><h>21:12</h><w>nathanmarz</w>if the transform results in <code>NONE</code>, it wouldn&apos;t conj, otherwise it would conj</z><z id="t1474405983" t="nathanmarz https://github.com/nathanmarz/specter/issues/131"><y>#</y><d>2016-09-20</d><h>21:13</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/issues/131" target="_blank">https://github.com/nathanmarz/specter/issues/131</a></z><z id="t1474422153" t="puzzler @nathanmarz I can see the value, but as far as I can tell this wouldn&apos;t help with the precisely symmetric scenario of wanting to disj a single item from a set nested in a data structure ."><y>#</y><d>2016-09-21</d><h>01:42</h><w>puzzler</w>@nathanmarz I can see the value, but as far as I can tell this wouldn&apos;t help with the precisely symmetric scenario of wanting to disj a single item from a set nested in a data structure .</z><z id="t1474422253" t="puzzler @nathanmarz In general, I&apos;ve been thinking about how assoc-in and setval automatically add levels to your data structure if needed, but I am not aware of a convenient way to make the path down to a leaf go away when the leaf becomes empty."><y>#</y><d>2016-09-21</d><h>01:44</h><w>puzzler</w>@nathanmarz In general, I&apos;ve been thinking about how assoc-in and setval automatically add levels to your data structure if needed, but I am not aware of a convenient way to make the path down to a leaf go away when the leaf becomes empty.</z><z id="t1474425584" t="puzzler I&apos;m having trouble building up a good mental model of how the complex navigators work. For example, I don&apos;t understand why these two navigators behave so differently with setval:"><y>#</y><d>2016-09-21</d><h>02:39</h><w>puzzler</w>I&apos;m having trouble building up a good mental model of how the complex navigators work.  For example, I don&apos;t understand why these two navigators behave so differently with setval:</z><z id="t1474425647" t="puzzler Sorry, that wasn&apos;t quite the right example"><y>#</y><d>2016-09-21</d><h>02:40</h><w>puzzler</w>Sorry, that wasn&apos;t quite the right example</z><z id="t1474425655" t="puzzler =&gt; (setval [(filterer number?)] [:a :b :c] [:x 2 :y 4 :z 6]) [:x :a :y :b :z :c] =&gt; (setval [(walker number?)] [:a :b :c] [:x 2 :y 4 :z 6]) [:x [:a :b :c] :y [:a :b :c] :z [:a :b :c]]"><y>#</y><d>2016-09-21</d><h>02:40</h><w>puzzler</w><pre>=&gt; (setval [(filterer number?)] [:a :b :c] [:x 2 :y 4 :z 6])
[:x :a :y :b :z :c]
=&gt; (setval [(walker number?)] [:a :b :c] [:x 2 :y 4 :z 6])
[:x [:a :b :c] :y [:a :b :c] :z [:a :b :c]]</pre></z><z id="t1474425660" t="puzzler There we go."><y>#</y><d>2016-09-21</d><h>02:41</h><w>puzzler</w>There we go.</z><z id="t1474425686" t="nathanmarz @puzzler I think things like removing from a sequence or a map are fairly easy with variants on ALL or keypath https://github.com/nathanmarz/specter/issues/117"><y>#</y><d>2016-09-21</d><h>02:41</h><w>nathanmarz</w>@puzzler I think things like removing from a sequence or a map are fairly easy with variants on <code>ALL</code> or <code>keypath</code> <a href="https://github.com/nathanmarz/specter/issues/117" target="_blank">https://github.com/nathanmarz/specter/issues/117</a></z><z id="t1474425718" t="nathanmarz the trickier case is removing an entire path, such as specifying to remove a nested map when it becomes empty"><y>#</y><d>2016-09-21</d><h>02:41</h><w>nathanmarz</w>the trickier case is removing an entire path, such as specifying to remove a nested map when it becomes empty</z><z id="t1474425750" t="nathanmarz I&apos;ve done things like making navigators such as non-empty-keypath , but I&apos;m not sure having so many variants is the right approach"><y>#</y><d>2016-09-21</d><h>02:42</h><w>nathanmarz</w>I&apos;ve done things like making navigators such as <code>non-empty-keypath</code>, but I&apos;m not sure having so many variants is the right approach</z><z id="t1474425783" t="nathanmarz filterer navigates to a single value, while walker navigates to many values"><y>#</y><d>2016-09-21</d><h>02:43</h><w>nathanmarz</w><code>filterer</code> navigates to a single value, while <code>walker</code> navigates to many values</z><z id="t1474425820" t="nathanmarz think of filterer as working just like filter , sequence -&gt; single sequence, except it also propagates changes back"><y>#</y><d>2016-09-21</d><h>02:43</h><w>nathanmarz</w>think of <code>filterer</code> as working just like <code>filter</code>, sequence -&gt; single sequence, except it also propagates changes back</z><z id="t1474425833" t="nathanmarz whereas walker is like ALL"><y>#</y><d>2016-09-21</d><h>02:43</h><w>nathanmarz</w>whereas <code>walker</code> is like <code>ALL</code></z><z id="t1474425891" t="puzzler Is there a way to predict this single value vs. multi value behavior from the info on the doc page?"><y>#</y><d>2016-09-21</d><h>02:44</h><w>puzzler</w>Is there a way to predict this single value vs. multi value behavior from the info on the doc page?</z><z id="t1474425918" t="nathanmarz (setval (subselect (walker number?)) [:a :b :c] [:x 2 :y 4 :z 6]) ;; =&gt; [:x :a :y :b :z :c]"><y>#</y><d>2016-09-21</d><h>02:45</h><w>nathanmarz</w><code>(setval (subselect (walker number?)) [:a :b :c] [:x 2 :y 4 :z 6])</code>
;; =&gt; <code>[:x :a :y :b :z :c]</code></z><z id="t1474425931" t="puzzler Similarly, I was confused the first time I encountered that setval on END expected a sequence, not a single value."><y>#</y><d>2016-09-21</d><h>02:45</h><w>puzzler</w>Similarly, I was confused the first time I encountered that setval on END expected a sequence, not a single value.</z><z id="t1474425935" t="nathanmarz filterer uses subselect and ALL"><y>#</y><d>2016-09-21</d><h>02:45</h><w>nathanmarz</w><code>filterer</code> uses <code>subselect</code> and <code>ALL</code></z><z id="t1474426013" t="nathanmarz the doc for filterer could be clearer, but I think the doc for END is pretty clear"><y>#</y><d>2016-09-21</d><h>02:46</h><w>nathanmarz</w>the doc for <code>filterer</code> could be clearer, but I think the doc for <code>END</code> is pretty clear</z><z id="t1474426028" t="nathanmarz &quot;Navigate to the empty subsequence after the last element of the collection.&quot;"><y>#</y><d>2016-09-21</d><h>02:47</h><w>nathanmarz</w>&quot;Navigate to the empty subsequence after the last element of the collection.&quot;</z><z id="t1474426113" t="puzzler Yes, END was clear once I looked it up. Just didn&apos;t match my intuition, I guess. If these things are just something you have to learn over time, I guess that&apos;s the nature of complex libs, but I&apos;m trying to figure out if there&apos;s some big-picture way of thinking about it that makes it clear without looking these details up. Sort of like how, in Clojure, once you realize that &quot;sequence functions&quot; put the sequence as the last input, and &quot;collection functions&quot; put the collection as the first input, it&apos;s a lot easier to remember."><y>#</y><d>2016-09-21</d><h>02:48</h><w>puzzler</w>Yes, END was clear once I looked it up.  Just didn&apos;t match my intuition, I guess.  If these things are just something you have to learn over time, I guess that&apos;s the nature of complex libs, but I&apos;m trying to figure out if there&apos;s some big-picture way of thinking about it that makes it clear without looking these details up.  Sort of like how, in Clojure, once you realize that &quot;sequence functions&quot; put the sequence as the last input, and &quot;collection functions&quot; put the collection as the first input, it&apos;s a lot easier to remember.</z><z id="t1474426244" t="nathanmarz the only way to do that would be with a naming convention, but that could get unwieldy"><y>#</y><d>2016-09-21</d><h>02:50</h><w>nathanmarz</w>the only way to do that would be with a naming convention, but that could get unwieldy</z><z id="t1474426299" t="nathanmarz like you might want to include in the name whether it navigates to many values or a single value, to a substructure, subvalue, or view, etc"><y>#</y><d>2016-09-21</d><h>02:51</h><w>nathanmarz</w>like you might want to include in the name whether it navigates to many values or a single value, to a substructure, subvalue, or view, etc</z><z id="t1474426504" t="puzzler So that list you just typed is very interesting to me, because I realize I don&apos;t have a clear mental model of what kinds of things you can navigate to, when you talk about substructure, subvalue, view, etc. and what the different behavior of setval, transform, and select would be under those scenarios."><y>#</y><d>2016-09-21</d><h>02:55</h><w>puzzler</w>So that list you just typed is very interesting to me, because I realize I don&apos;t have a clear mental model of what kinds of things you can navigate to, when you talk about substructure, subvalue, view, etc. and what the different behavior of setval, transform, and select would be under those scenarios.</z><z id="t1474426553" t="nathanmarz substructure is something like srange or subset, where it&apos;s the same structure as the parent but with a subset of the values"><y>#</y><d>2016-09-21</d><h>02:55</h><w>nathanmarz</w>substructure is something like srange or subset, where it&apos;s the same structure as the parent but with a subset of the values</z><z id="t1474426560" t="nathanmarz transforms on substructures transform the parent"><y>#</y><d>2016-09-21</d><h>02:56</h><w>nathanmarz</w>transforms on substructures transform the parent</z><z id="t1474426583" t="nathanmarz subvalues are the common case where you literally navigate to that value inside the structure"><y>#</y><d>2016-09-21</d><h>02:56</h><w>nathanmarz</w>subvalues are the common case where you literally navigate to that value inside the structure</z><z id="t1474426617" t="nathanmarz and views navigate you to something with no structural relation to the input"><y>#</y><d>2016-09-21</d><h>02:56</h><w>nathanmarz</w>and views navigate you to something with no structural relation to the input</z><z id="t1474426650" t="nathanmarz something like view totally replaces it&apos;s input"><y>#</y><d>2016-09-21</d><h>02:57</h><w>nathanmarz</w>something like <code>view</code> totally replaces it&apos;s input</z><z id="t1474426652" t="nathanmarz on transform"><y>#</y><d>2016-09-21</d><h>02:57</h><w>nathanmarz</w>on transform</z><z id="t1474426719" t="nathanmarz I don&apos;t think these are hard boundaries between navigators, subselect is like a combination of substructure and view"><y>#</y><d>2016-09-21</d><h>02:58</h><w>nathanmarz</w>I don&apos;t think these are hard boundaries between navigators, <code>subselect</code> is like a combination of substructure and view</z><z id="t1474426776" t="puzzler Interesting. That&apos;s helpful to know. Thanks."><y>#</y><d>2016-09-21</d><h>02:59</h><w>puzzler</w>Interesting.  That&apos;s helpful to know. Thanks.</z><z id="t1474426863" t="nathanmarz learning to think in terms of substructure is probably one of the major milestones in using specter to its potential"><y>#</y><d>2016-09-21</d><h>03:01</h><w>nathanmarz</w>learning to think in terms of substructure is probably one of the major milestones in using specter to its potential</z><z id="t1474427220" t="puzzler So the other topic I mentioned is something I encounter a fair amount in my programming. Let&apos;s say I want to keep a map that bins words by first letter. So I start out with {} . Now, I add the word apple {\a #{&quot;apple&quot;}} and then banana and ape {\a #{&quot;apple&quot; &quot;ape&quot;} \b #{&quot;banana&quot;}} . Now I remove apple. {\a #{&quot;ape&quot;} \b #{&quot;banana&quot;}} Now I remove ape and I want it to go to {\b #{&quot;banana&quot;}} . A similar scenario is a map of numeric counters. If a counter doesn&apos;t yet exist in the map, I create it at 0 and increment it to 1 on demand. When it decrements back to 0, I&apos;d like the counter to disappear from the map."><y>#</y><d>2016-09-21</d><h>03:07</h><w>puzzler</w>So the other topic I mentioned is something I encounter a fair amount in my programming.  Let&apos;s say I want to keep a map that bins words by first letter.  So I start out with <code>{}</code>.  Now, I add the word apple <code>{\a #{&quot;apple&quot;}}</code> and then banana and ape <code>{\a #{&quot;apple&quot; &quot;ape&quot;} \b #{&quot;banana&quot;}}</code>.  Now I remove apple.  <code>{\a #{&quot;ape&quot;} \b #{&quot;banana&quot;}}</code> Now I remove ape and I want it to go to <code>{\b #{&quot;banana&quot;}}</code>.  A similar scenario is a map of numeric counters.  If a counter doesn&apos;t yet exist in the map, I create it at 0 and increment it to 1 on demand.  When it decrements back to 0, I&apos;d like the counter to disappear from the map.</z><z id="t1474427656" t="nathanmarz I&apos;ve thought about that a bit, and I think ideally this kind of information would be encoded and handled within the data structure implementation"><y>#</y><d>2016-09-21</d><h>03:14</h><w>nathanmarz</w>I&apos;ve thought about that a bit, and I think ideally this kind of information would be encoded and handled within the data structure implementation</z><z id="t1474427706" t="nathanmarz you could do it with navigators like this: (setval [(non-nil-keypath \a) (nil&lt;-&gt;val #{}) (subset #{&quot;apple&quot;})] #{} data) , but I think it would work better at the data structure impl level"><y>#</y><d>2016-09-21</d><h>03:15</h><w>nathanmarz</w>you could do it with navigators like this: <code>(setval [(non-nil-keypath \a) (nil&lt;-&gt;val #{}) (subset #{&quot;apple&quot;})] #{} data)</code>, but I think it would work better at the data structure impl level</z><z id="t1474427731" t="nathanmarz so for example a map would understand what &quot;empty&quot; values look like, and would automatically remove them if they become empty"><y>#</y><d>2016-09-21</d><h>03:15</h><w>nathanmarz</w>so for example a map would understand what &quot;empty&quot; values look like, and would automatically remove them if they become empty</z><z id="t1474427751" t="nathanmarz and it would know how to initialize a non-existent key to the empty value"><y>#</y><d>2016-09-21</d><h>03:15</h><w>nathanmarz</w>and it would know how to initialize a non-existent key to the empty value</z><z id="t1474427811" t="nathanmarz then you could do with specter: (setval [(keypath \a) (subset #{&quot;apple&quot;})] #{} data) and everything would work in a nice and elegant manner"><y>#</y><d>2016-09-21</d><h>03:16</h><w>nathanmarz</w>then you could do with specter: <code>(setval [(keypath \a) (subset #{&quot;apple&quot;})] #{} data)</code> and everything would work in a nice and elegant manner</z><z id="t1474427828" t="nathanmarz and it composes nicely to arbitrarily complex data structure combinations"><y>#</y><d>2016-09-21</d><h>03:17</h><w>nathanmarz</w>and it composes nicely to arbitrarily complex data structure combinations</z><z id="t1474427987" t="nathanmarz constructing a data structure like that would be something like (def my-map ((hash-map (hash-map (hash-set empty-nil))))"><y>#</y><d>2016-09-21</d><h>03:19</h><w>nathanmarz</w>constructing a data structure like that would be something like <code>(def my-map ((hash-map (hash-map (hash-set empty-nil))))</code></z><z id="t1474435427" t="puzzler Are non-nil-keypath and nil&lt;-&gt;val new? I don&apos;t see them in latest stable or in the github repo."><y>#</y><d>2016-09-21</d><h>05:23</h><w>puzzler</w>Are non-nil-keypath and nil&lt;-&gt;val new?  I don&apos;t see them in latest stable or in the github repo.</z><z id="t1474435681" t="puzzler A bit of a testimonial: Prior to now, I&apos;ve been aware of specter, but figured I&apos;d reach for it only if I really needed it -- get-in and update-in are usually sufficient for me. Today, I decided to use specter for the &quot;trivial&quot; things I could do with get-in and update-in; once I had it at my disposal, within a few hours I started seeing several non-trivial uses for it as well which made my implementation a lot cleaner."><y>#</y><d>2016-09-21</d><h>05:28</h><w>puzzler</w>A bit of a testimonial:  Prior to now, I&apos;ve been aware of specter, but figured I&apos;d reach for it only if I really needed it -- get-in and update-in are usually sufficient for me.  Today, I decided to use specter for the &quot;trivial&quot; things I could do with get-in and update-in; once I had it at my disposal, within a few hours I started seeing several non-trivial uses for it as well which made my implementation a lot cleaner.</z><z id="t1474435988" t="puzzler Was everything in specter motivated by actual use-cases? There are several things I can&apos;t figure out what the utility would be, and I&apos;m wondering whether some of the things are there just because they were an experiment to see if something was doable, or whether each one actually solves some particular problem that comes up in practice."><y>#</y><d>2016-09-21</d><h>05:33</h><w>puzzler</w>Was everything in specter motivated by actual use-cases?  There are several things I can&apos;t figure out what the utility would be, and I&apos;m wondering whether some of the things are there just because they were an experiment to see if something was doable, or whether each one actually solves some particular problem that comes up in practice.</z><z id="t1474456048" t="nathanmarz @puzzler no those are hypothetical navigators... non-nil-keypath would remove the value if it becomes nil and nil&lt;-&gt;val would navigate to val if it&apos;s nil and transform to nil if it&apos;s val . They would be trivial to implement"><y>#</y><d>2016-09-21</d><h>11:07</h><w>nathanmarz</w>@puzzler no those are hypothetical navigators... non-nil-keypath would remove the value if it becomes nil and nil&lt;-&gt;val would navigate to <code>val</code> if it&apos;s nil and transform to <code>nil</code> if it&apos;s <code>val</code>. They would be trivial to implement</z><z id="t1474456091" t="nathanmarz @puzzler yes, I use most of what comes with Specter, plus I have a whole lot of private navigators for dealing with DAGs"><y>#</y><d>2016-09-21</d><h>11:08</h><w>nathanmarz</w>@puzzler yes, I use most of what comes with Specter, plus I have a whole lot of private navigators for dealing with DAGs</z><z id="t1474456207" t="nathanmarz I think the only ones I don&apos;t use are ATOM and the zipper navigators"><y>#</y><d>2016-09-21</d><h>11:10</h><w>nathanmarz</w>I think the only ones I don&apos;t use are <code>ATOM</code> and the zipper navigators</z><z id="t1474456265" t="nathanmarz for which ones do you have trouble seeing the utility?"><y>#</y><d>2016-09-21</d><h>11:11</h><w>nathanmarz</w>for which ones do you have trouble seeing the utility?</z><z id="t1474490862" t="jvuillermet Is this how I&apos;m supposed to require specter macros ?"><y>#</y><d>2016-09-21</d><h>20:47</h><w>jvuillermet</w>Is this how I&apos;m supposed to require specter macros ?</z><z id="t1474490866" t="jvuillermet (:require-macros [com.rpl.specter.macros :refer [transform]]"><y>#</y><d>2016-09-21</d><h>20:47</h><w>jvuillermet</w>(:require-macros [com.rpl.specter.macros :refer [transform]]</z><z id="t1474490870" t="jvuillermet from clojurescript"><y>#</y><d>2016-09-21</d><h>20:47</h><w>jvuillermet</w>from clojurescript</z><z id="t1474491058" t="jvuillermet Ok just saw the changelog, no more macros namespace"><y>#</y><d>2016-09-21</d><h>20:50</h><w>jvuillermet</w>Ok just saw the changelog, no more macros namespace</z><z id="t1474500896" t="puzzler Haven&apos;t imagined a use yet for anything relating to value collection (DISPENSE, collect, collect-one, terminal, terminal-val). Also don&apos;t see the point of the &quot;view functions&quot;, i.e., transformed and view. I&apos;m also not sure whether STAY and STOP have any direct utility, or if they are only useful in building other navigators. If you&apos;re using all these things, then there must be a whole level to specter that I haven&apos;t grokked yet, because I couldn&apos;t extrapolate from the toy examples on the wiki page to a real-world use case."><y>#</y><d>2016-09-21</d><h>23:34</h><w>puzzler</w>Haven&apos;t imagined a use yet for anything relating to value collection (DISPENSE, collect, collect-one, terminal, terminal-val).  Also don&apos;t see the point of the &quot;view functions&quot;, i.e., transformed and view.  I&apos;m also not sure whether STAY and STOP have any direct utility, or if they are only useful in building other navigators.  If you&apos;re using all these things, then there must be a whole level to specter that I haven&apos;t grokked yet, because I couldn&apos;t extrapolate from the toy examples on the wiki page to a real-world use case.</z><z id="t1474502549" t="nathanmarz @puzzler STAY is common with recursive navigators, the README has one for navigating a tree represented by nested vectors. Also continue-then-stay and stay-then-continue use it https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1061"><y>#</y><d>2016-09-22</d><h>00:02</h><w>nathanmarz</w>@puzzler <code>STAY</code> is common with recursive navigators, the README has one for navigating a tree represented by nested vectors. Also <code>continue-then-stay</code> and <code>stay-then-continue</code> use it <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1061" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1061</a></z><z id="t1474502712" t="nathanmarz as for value collection, it&apos;s something I use constantly, especially for more sophisticated transformations"><y>#</y><d>2016-09-22</d><h>00:05</h><w>nathanmarz</w>as for value collection, it&apos;s something I use constantly, especially for more sophisticated transformations</z><z id="t1474502774" t="nathanmarz this is pretty representative of the kinds of things I use it for: https://github.com/nathanmarz/specter-clojure-west/blob/master/src/specter_demo/examples.clj#L489"><y>#</y><d>2016-09-22</d><h>00:06</h><w>nathanmarz</w>this is pretty representative of the kinds of things I use it for: <a href="https://github.com/nathanmarz/specter-clojure-west/blob/master/src/specter_demo/examples.clj#L489" target="_blank">https://github.com/nathanmarz/specter-clojure-west/blob/master/src/specter_demo/examples.clj#L489</a></z><z id="t1474502818" t="nathanmarz those graph navigators aren&apos;t public, but that takes an ancestry graph and adds a field to each node for the &quot;royal name&quot; which is &quot;{name} of {parent1}, {parent2}...&quot;"><y>#</y><d>2016-09-22</d><h>00:06</h><w>nathanmarz</w>those graph navigators aren&apos;t public, but that takes an ancestry graph and adds a field to each node for the &quot;royal name&quot; which is &quot;{name} of {parent1}, {parent2}...&quot;</z><z id="t1474502855" t="nathanmarz it navigates to each :royal-name field to create and along the way collects what it needs to compute that value – the parent names and the name for this node"><y>#</y><d>2016-09-22</d><h>00:07</h><w>nathanmarz</w>it navigates to each :royal-name field to create and along the way collects what it needs to compute that value – the parent names and the name for this node</z><z id="t1474503056" t="nathanmarz the only places I use STOP are in conjunction with protocol paths, essentially saying there&apos;s nothing to navigate to for that type"><y>#</y><d>2016-09-22</d><h>00:10</h><w>nathanmarz</w>the only places I use <code>STOP</code> are in conjunction with protocol paths, essentially saying there&apos;s nothing to navigate to for that type</z><z id="t1474588073" t="puzzler Is there a way to splice things into lists with specter? For example, I want to find all the [:c :d] pairs and splice them like so: [:a :b [:c :d] :e [:c :d]] should yield [:a :b :c :d :e :c :d] ."><y>#</y><d>2016-09-22</d><h>23:47</h><w>puzzler</w>Is there a way to splice things into lists with specter?  For example, I want to find all the [:c :d] pairs and splice them like so: <code>[:a :b [:c :d] :e [:c :d]]</code> should yield <code>[:a :b :c :d :e :c :d]</code>.</z><z id="t1474588558" t="puzzler NM. I figured out a way to do it using continuous-subseqs."><y>#</y><d>2016-09-22</d><h>23:55</h><w>puzzler</w>NM. I figured out a way to do it using continuous-subseqs.</z><z id="t1474688625" t="caio @puzzler (select (pred (complement seq?)) m) ? "><y>#</y><d>2016-09-24</d><h>03:43</h><w>caio</w>@puzzler <code>(select (pred (complement seq?)) m)</code>? </z><z id="t1474690056" t="puzzler `=&gt; (select (pred (complement seq?)) [:a :b [:c :d] :e [:c :d]]) [[:a :b [:c :d] :e [:c :d]]]`"><y>#</y><d>2016-09-24</d><h>04:07</h><w>puzzler</w>`=&gt; (select (pred (complement seq?)) [:a :b [:c :d] :e [:c :d]])
[[:a :b [:c :d] :e [:c :d]]]`</z><z id="t1474690225" t="puzzler I did something like this:"><y>#</y><d>2016-09-24</d><h>04:10</h><w>puzzler</w>I did something like this:</z><z id="t1474690230" t="puzzler =&gt; (transform [(continuous-subseqs vector?)] #(first %) [:a :b [:c :d] :e [:c :d]]) [:a :b :c :d :e :c :d]"><y>#</y><d>2016-09-24</d><h>04:10</h><w>puzzler</w><pre>=&gt; (transform [(continuous-subseqs vector?)] #(first %) [:a :b [:c :d] :e [:c :d]])
[:a :b :c :d :e :c :d]</pre></z><z id="t1474690256" t="puzzler It feels a little hacky to me, but I don&apos;t see another way to do it."><y>#</y><d>2016-09-24</d><h>04:10</h><w>puzzler</w>It feels a little hacky to me, but I don&apos;t see another way to do it.</z><z id="t1474694864" t="puzzler Actually, that won&apos;t work if they are adjacent."><y>#</y><d>2016-09-24</d><h>05:27</h><w>puzzler</w>Actually, that won&apos;t work if they are adjacent.</z><z id="t1474694872" t="puzzler Hmmmm."><y>#</y><d>2016-09-24</d><h>05:27</h><w>puzzler</w>Hmmmm.</z><z id="t1474694982" t="puzzler Any other ideas?"><y>#</y><d>2016-09-24</d><h>05:29</h><w>puzzler</w>Any other ideas?</z><z id="t1474695007" t="puzzler =&gt; (transform [(continuous-subseqs vector?)] #(first %) [:a :b [:c :d] [:c :d]]) [:a :b :c :d]"><y>#</y><d>2016-09-24</d><h>05:30</h><w>puzzler</w><pre>=&gt; (transform [(continuous-subseqs vector?)] #(first %) [:a :b [:c :d] [:c :d]])
[:a :b :c :d]</pre></z><z id="t1474695036" t="puzzler @caio I don&apos;t see how yours would work, but mine doesn&apos;t work either."><y>#</y><d>2016-09-24</d><h>05:30</h><w>puzzler</w>@caio I don&apos;t see how yours would work, but mine doesn&apos;t work either.</z><z id="t1474695128" t="puzzler This works:"><y>#</y><d>2016-09-24</d><h>05:32</h><w>puzzler</w>This works:</z><z id="t1474695138" t="puzzler =&gt; (transform [(continuous-subseqs vector?)] #(apply concat %) [:a :b [:c :d] [:c :d]]) [:a :b :c :d :c :d]"><y>#</y><d>2016-09-24</d><h>05:32</h><w>puzzler</w><pre>=&gt; (transform [(continuous-subseqs vector?)] #(apply concat %) [:a :b [:c :d] [:c :d]])
[:a :b :c :d :c :d]</pre></z><z id="t1474695867" t="puzzler It&apos;s still hacky"><y>#</y><d>2016-09-24</d><h>05:44</h><w>puzzler</w>It&apos;s still hacky</z><z id="t1474718844" t="nathanmarz @puzzler you could make a new navigator which navigates to each element as a 1 element subsequence"><y>#</y><d>2016-09-24</d><h>12:07</h><w>nathanmarz</w>@puzzler you could make a new navigator which navigates to each element as a 1 element subsequence</z><z id="t1474718907" t="nathanmarz or a new version of ALL which does splicing if the transformed element has metadata indicating to do so"><y>#</y><d>2016-09-24</d><h>12:08</h><w>nathanmarz</w>or a new version of <code>ALL</code> which does splicing if the transformed element has metadata indicating to do so</z><z id="t1474719010" t="nathanmarz e.g. (transform [MY-ALL vector?] (fn [v] (with-meta v {:all-splice true})) data)"><y>#</y><d>2016-09-24</d><h>12:10</h><w>nathanmarz</w>e.g. <code>(transform [MY-ALL vector?] (fn [v] (with-meta v {:all-splice true})) data)</code></z><z id="t1474719460" t="nathanmarz can also do this: (def SPLICED (comp-paths (continuous-subseqs vector?) (view #(apply concat %)))) (transform SPLICED identity [:a :b [:c :d] :e [:c :d]]) [:a :b :c :d :e :c :d] "><y>#</y><d>2016-09-24</d><h>12:17</h><w>nathanmarz</w>can also do this:
<pre>(def SPLICED (comp-paths (continuous-subseqs vector?) (view #(apply concat %))))
(transform SPLICED identity [:a :b [:c :d] :e [:c :d]])
[:a :b :c :d :e :c :d]
</pre></z><z id="t1474788929" t="puzzler Nifty!"><y>#</y><d>2016-09-25</d><h>07:35</h><w>puzzler</w>Nifty!</z><z id="t1474788965" t="puzzler BTW, I&apos;m really enjoying the convenience of pulling in a single namespace. Thanks for addressing that in the latest version."><y>#</y><d>2016-09-25</d><h>07:36</h><w>puzzler</w>BTW, I&apos;m really enjoying the convenience of pulling in a single namespace.  Thanks for addressing that in the latest version.</z><z id="t1474961361" t="rnandan273 Trying to use specter with the following configuration [org.clojure/clojurescript &quot;1.9.225&quot; :scope &quot;provided&quot;] [org.clojure/clojure &quot;1.8.0&quot;]"><y>#</y><d>2016-09-27</d><h>07:29</h><w>rnandan273</w>Trying to use specter with the following configuration [org.clojure/clojurescript &quot;1.9.225&quot; :scope &quot;provided&quot;]
                 [org.clojure/clojure &quot;1.8.0&quot;]</z><z id="t1474961391" t="rnandan273 [com.rpl/specter &quot;0.13.0&quot;], but am getting errors such as any? already refers to: cljs.core/any? being replaced by: com.rpl.specter.impl/any?"><y>#</y><d>2016-09-27</d><h>07:29</h><w>rnandan273</w>[com.rpl/specter &quot;0.13.0&quot;], but am getting errors such as any? already refers to: cljs.core/any? being replaced by: com.rpl.specter.impl/any?</z><z id="t1474961401" t="rnandan273 Any ideas on the resolution of this?"><y>#</y><d>2016-09-27</d><h>07:30</h><w>rnandan273</w>Any ideas on the resolution of this?</z><z id="t1474961746" t="rnandan273 Used this option also [com.rpl/specter &quot;0.13.0&quot; :exclusions [org.clojure/clojure org.clojure/clojurescript]] but no luck"><y>#</y><d>2016-09-27</d><h>07:35</h><w>rnandan273</w>Used this option also [com.rpl/specter &quot;0.13.0&quot; :exclusions [org.clojure/clojure org.clojure/clojurescript]] but no luck</z><z id="t1474962191" t="rnandan273 this configuration worked"><y>#</y><d>2016-09-27</d><h>07:43</h><w>rnandan273</w>this configuration worked</z><z id="t1474962192" t="rnandan273 [com.rpl/specter &quot;0.11.2&quot; :exclusions [org.clojure/clojure org.clojure/clojurescript]]"><y>#</y><d>2016-09-27</d><h>07:43</h><w>rnandan273</w>[com.rpl/specter &quot;0.11.2&quot; :exclusions [org.clojure/clojure org.clojure/clojurescript]]</z><z id="t1474978593" t="nathanmarz @rnandan273 try 0.13.1-SNAPSHOT"><y>#</y><d>2016-09-27</d><h>12:16</h><w>nathanmarz</w>@rnandan273 try 0.13.1-SNAPSHOT</z><z id="t1474978995" t="rnandan273 @nathanmarz Could not compile with this version , the error is &quot; Invalid :refer, macro com.rpl.specter.macros/select does not exist&quot;"><y>#</y><d>2016-09-27</d><h>12:23</h><w>rnandan273</w>@nathanmarz  Could not compile with this version , the error is &quot;  Invalid :refer, macro com.rpl.specter.macros/select does not exist&quot;</z><z id="t1474980390" t="nathanmarz @rnandan273 0.13.0 moved all macros to com.rpl.specter namespace"><y>#</y><d>2016-09-27</d><h>12:46</h><w>nathanmarz</w>@rnandan273 0.13.0 moved all macros to com.rpl.specter namespace</z><z id="t1474982959" t="rnandan273 @nathanmarz Removing the namespace worked, i should have checked about the changes before asking the question. thanks a lot for your timely response"><y>#</y><d>2016-09-27</d><h>13:29</h><w>rnandan273</w>@nathanmarz  Removing the namespace worked, i should have checked about the changes before asking the question. thanks a lot for your timely response</z></g><g id="s7"><z id="t1475073734" t="vikeri What am I doing wrong here, I expect: (select [MAP-VALS (filterer [:id #(= 1 %)])] {:h {:id 1 :ad 2} :ho {:id 2 :ad 3}}) To return [{:id 1 :ad 2}] but instead it returns [[] []]"><y>#</y><d>2016-09-28</d><h>14:42</h><w>vikeri</w>What am I doing wrong here, I expect:
<pre>(select [MAP-VALS (filterer [:id #(= 1 %)])] {:h {:id 1 :ad 2} :ho {:id 2 :ad 3}})
</pre>
To return <code>[{:id 1 :ad 2}]</code> but instead it returns <code>[[] []]</code></z><z id="t1475073901" t="nathanmarz @vikeri filterer treats input as a sequence"><y>#</y><d>2016-09-28</d><h>14:45</h><w>nathanmarz</w>@vikeri <code>filterer</code> treats input as a sequence</z><z id="t1475073911" t="nathanmarz if you change filterer to selected? it should work"><y>#</y><d>2016-09-28</d><h>14:45</h><w>nathanmarz</w>if you change <code>filterer</code> to <code>selected?</code> it should work</z><z id="t1475073929" t="nathanmarz and you don&apos;t need to wrap the subpath in []"><y>#</y><d>2016-09-28</d><h>14:45</h><w>nathanmarz</w>and you don&apos;t need to wrap the subpath in <code>[]</code></z><z id="t1475074020" t="vikeri @nathanmarz Great! Thanks! Maybe worth collecting these simple examples somewhere?"><y>#</y><d>2016-09-28</d><h>14:47</h><w>vikeri</w>@nathanmarz Great! Thanks! Maybe worth collecting these simple examples somewhere?</z><z id="t1475074771" t="nathanmarz there&apos;s examples on the wiki and the readme"><y>#</y><d>2016-09-28</d><h>14:59</h><w>nathanmarz</w>there&apos;s examples on the wiki and the readme</z><z id="t1475074787" t="nathanmarz though I agree that the current docs are pretty sparse and disorganized"><y>#</y><d>2016-09-28</d><h>14:59</h><w>nathanmarz</w>though I agree that the current docs are pretty sparse and disorganized</z><z id="t1475074867" t="nathanmarz ideally there would be something like 4clojure but for specter, unfortunately I don&apos;t have the time to put that together"><y>#</y><d>2016-09-28</d><h>15:01</h><w>nathanmarz</w>ideally there would be something like 4clojure but for specter, unfortunately I don&apos;t have the time to put that together</z><z id="t1475076320" t="vikeri Yeah I skimmed through the ones on the readme and the wiki but couldn’t find my use case. Since it’s quite a powerful abstraction I think some people might need some more examples to grok it."><y>#</y><d>2016-09-28</d><h>15:25</h><w>vikeri</w>Yeah I skimmed through the ones on the readme and the wiki but couldn’t find my use case. Since it’s quite a powerful abstraction I think some people might need some more examples to grok it.</z><z id="t1475252348" t="rodeorockstar I&apos;m pretty sure I&apos;ve asked this before but I can&apos;t seem to find the answer. Is subselect the right way to match conditions &quot;deeper&quot; into a tree yet transform higher up?"><y>#</y><d>2016-09-30</d><h>16:19</h><w>rodeorockstar</w>I&apos;m pretty sure I&apos;ve asked this before but I can&apos;t seem to find the answer. Is <code>subselect</code> the right way to match conditions &quot;deeper&quot; into a tree yet transform higher up?</z><z id="t1475252465" t="rodeorockstar I realize there&apos;s no matching function in this subselect, but still I would have expected found to be farther up the tree. Instead it&apos;s the just the :id which is the last part of the subselect (s/transform [:data s/ALL #(= &quot;interactor&quot; (:object %)) (s/subselect [:identifier :id])] (fn [found] (println &quot;FOUND&quot; found)) (:data db)) "><y>#</y><d>2016-09-30</d><h>16:21</h><w>rodeorockstar</w>I realize there&apos;s no matching function in this subselect, but still I would have expected <code>found</code> to be farther up the tree. Instead it&apos;s the just the :id which is the last part of the subselect
<pre>(s/transform [:data s/ALL #(= &quot;interactor&quot; (:object %)) (s/subselect [:identifier :id])]
                 (fn [found] (println &quot;FOUND&quot; found))
                 (:data db))
</pre></z><z id="t1475256260" t="nathanmarz @rodeorockstar it sounds like you&apos;re looking for selected?"><y>#</y><d>2016-09-30</d><h>17:24</h><w>nathanmarz</w>@rodeorockstar it sounds like you&apos;re looking for <code>selected?</code></z><z id="t1475256319" t="nathanmarz but [:identifier :id] will always match something, maybe you wanted to use [(must :identifier) (must :id)] ?"><y>#</y><d>2016-09-30</d><h>17:25</h><w>nathanmarz</w>but <code>[:identifier :id]</code> will always match something, maybe you wanted to use <code>[(must :identifier) (must :id)]</code>?</z><z id="t1475280898" t="puzzler It seems like pred would also work in the last couple examples where you&apos;ve recommended selected? . What are some instances where they would behave differently?"><y>#</y><d>2016-10-01</d><h>00:14</h><w>puzzler</w>It seems like <code>pred</code> would also work in the last couple examples where you&apos;ve recommended <code>selected?</code>.  What are some instances where they would behave differently?</z><z id="t1475329031" t="nathanmarz well, for pred to work like (selected? (must :a) (must :b)) you would have to write #(and (contains? % :a) (contains? (:a %) :b))"><y>#</y><d>2016-10-01</d><h>13:37</h><w>nathanmarz</w>well, for <code>pred</code> to work like <code>(selected? (must :a) (must :b))</code> you would have to write <code>#(and (contains? % :a) (contains? (:a %) :b))</code></z><z id="t1475329122" t="nathanmarz @puzzler selected? is particularly good for things like (selected? (filterer even?) (view count) #(&gt;= % 2)) , which stays navigated at current position if the sequence contains at least 2 even numbers"><y>#</y><d>2016-10-01</d><h>13:38</h><w>nathanmarz</w>@puzzler <code>selected?</code> is particularly good for things like <code>(selected? (filterer even?) (view count) #(&gt;= % 2))</code>, which stays navigated at current position if the sequence contains at least 2 even numbers</z><z id="t1475329161" t="nathanmarz or something like (selected? ALL even?) which stays navigated if at least one even number"><y>#</y><d>2016-10-01</d><h>13:39</h><w>nathanmarz</w>or something like <code>(selected? ALL even?)</code> which stays navigated if at least one even number</z><z id="t1475329246" t="puzzler It sounds like, basically, pred takes a Clojure predicate function and selected? takes a navigator path."><y>#</y><d>2016-10-01</d><h>13:40</h><w>puzzler</w>It sounds like, basically, pred takes a Clojure predicate function and selected? takes a navigator path.</z><z id="t1475333998" t="nathanmarz @puzzler yes, that&apos;s correct"><y>#</y><d>2016-10-01</d><h>14:59</h><w>nathanmarz</w>@puzzler yes, that&apos;s correct</z><z id="t1475514146" t="novakboskov If I have lazy seq made of vector I can do this (transform ALL inc (lazy-seq [1 2])) , then how to do this (transform MAP-VALS inc (lazy-seq {:a 1 :b 2})) ?"><y>#</y><d>2016-10-03</d><h>17:02</h><w>novakboskov</w>If I have lazy seq made of vector I can do this <code>(transform ALL inc (lazy-seq [1 2]))</code>, then how to do this <code>(transform MAP-VALS inc (lazy-seq {:a 1 :b 2}))</code>?</z><z id="t1475518515" t="nathanmarz a seq isn&apos;t a map, so you can&apos;t use MAP-VALS with it"><y>#</y><d>2016-10-03</d><h>18:15</h><w>nathanmarz</w>a seq isn&apos;t a map, so you can&apos;t use <code>MAP-VALS</code> with it</z><z id="t1475518538" t="nathanmarz you could use [ALL LAST] instead"><y>#</y><d>2016-10-03</d><h>18:15</h><w>nathanmarz</w>you could use <code>[ALL LAST]</code> instead</z><z id="t1475524107" t="novakboskov @nathanmarz It makes sense. Thank you for your work! 🙂"><y>#</y><d>2016-10-03</d><h>19:48</h><w>novakboskov</w>@nathanmarz It makes sense. Thank you for your work! <b>🙂</b></z><z id="t1475697114" t="nlessa In 0.13.0 version the macro namespace was deprecated, right? Must we require only com.rpl.specter and use select*, transform*? Bit confused with these last API changes..."><y>#</y><d>2016-10-05</d><h>19:51</h><w>nlessa</w>In 0.13.0 version the macro namespace was deprecated, right? Must we require only com.rpl.specter and use select*, transform*? Bit confused with these last API changes...</z><z id="t1475697266" t="nathanmarz @nlessa use select , transform , etc. as usual except get them from com.rpl.specter now"><y>#</y><d>2016-10-05</d><h>19:54</h><w>nathanmarz</w>@nlessa use <code>select</code>, <code>transform</code>, etc. as usual except get them from com.rpl.specter now</z><z id="t1475699233" t="nlessa Is there any known problem with midje (&quot;1.9.0-alpha5) and 0.13.0? After upgrade to 0.13.0 I am running with a No such var: sm/transform..."><y>#</y><d>2016-10-05</d><h>20:27</h><w>nlessa</w>Is there any known problem with midje (&quot;1.9.0-alpha5)  and 0.13.0? After upgrade to 0.13.0 I am running with a No such var: sm/transform...</z><z id="t1475702007" t="nathanmarz @nlessa it&apos;s probably not updated to the namespace changes"><y>#</y><d>2016-10-05</d><h>21:13</h><w>nathanmarz</w>@nlessa it&apos;s probably not updated to the namespace changes</z><z id="t1475737607" t="yonatanel Is it possible to transform a map according to a transformation that already happened in a nested map? I have nested objects that need to be marked if they have a certain ID, and if they contain a marked object they should also be marked. For example: [{:a 1 :bs [{:b 2} {:b 3}]} {:a 4 :bs [{:b 5} {:b 6}]}] ;; 1, 2 and 6 need to be marked, and also those that contain them: [{:a 1 :mark true :bs [{:b 2 :mark true} {:b 3}]} {:a 4 :mark true :bs [{:b 5} {:b 6 :mark true}]}] "><y>#</y><d>2016-10-06</d><h>07:06</h><w>yonatanel</w>Is it possible to transform a map according to a transformation that already happened in a nested map?
I have nested objects that need to be marked if they have a certain ID, and if they contain a marked object they should also be marked. For example:
<pre>[{:a 1 :bs [{:b 2} {:b 3}]}
 {:a 4 :bs [{:b 5} {:b 6}]}]

;; 1, 2 and 6 need to be marked, and also those that contain them:
[{:a 1 :mark true :bs [{:b 2 :mark true} {:b 3}]}
 {:a 4 :mark true :bs [{:b 5} {:b 6 :mark true}]}]
</pre></z><z id="t1475757550" t="nathanmarz @yonatanel I don&apos;t understand your example"><y>#</y><d>2016-10-06</d><h>12:39</h><w>nathanmarz</w>@yonatanel I don&apos;t understand your example</z><z id="t1475757568" t="nathanmarz the ids are sometimes under :a and sometimes under :b ?"><y>#</y><d>2016-10-06</d><h>12:39</h><w>nathanmarz</w>the ids are sometimes under <code>:a</code> and sometimes under <code>:b</code>?</z><z id="t1475757594" t="nathanmarz is this recursive or just 2 levels? why is the map with :a 4 getting marked in the example?"><y>#</y><d>2016-10-06</d><h>12:39</h><w>nathanmarz</w>is this recursive or just 2 levels? why is the map with :a 4 getting marked in the example?</z><z id="t1475757828" t="nathanmarz oh i see, you want to mark the parent if the child gets marked, still don&apos;t understand when to look at :a vs :b"><y>#</y><d>2016-10-06</d><h>12:43</h><w>nathanmarz</w>oh i see, you want to mark the parent if the child gets marked, still don&apos;t understand when to look at <code>:a</code> vs <code>:b</code></z><z id="t1475757841" t="yonatanel @nathanmarz The ids can have different keys. Only their value matters in this example."><y>#</y><d>2016-10-06</d><h>12:44</h><w>yonatanel</w>@nathanmarz The ids can have different keys. Only their value matters in this example.</z><z id="t1475757875" t="yonatanel Frankly it&apos;s not recursive, just up to 2 levels deeps, but a few hours ago I thought I might need it recursive. It might be only 1 level though."><y>#</y><d>2016-10-06</d><h>12:44</h><w>yonatanel</w>Frankly it&apos;s not recursive, just up to 2 levels deeps, but a few hours ago I thought I might need it recursive. It might be only 1 level though.</z><z id="t1475758100" t="nathanmarz I would just do it as two separate transformations"><y>#</y><d>2016-10-06</d><h>12:48</h><w>nathanmarz</w>I would just do it as two separate transformations</z><z id="t1475758104" t="nathanmarz (def data [{:a 1 :bs [{:b 2} {:b 3}]} {:a 4 :bs [{:b 5} {:b 6}]}]) (-&gt;&gt; data (setval [ALL :bs ALL (selected? :b #{1 2 6}) :mark] true) (setval [ALL (selected? :bs ALL (must :mark)) :mark] true)) "><y>#</y><d>2016-10-06</d><h>12:48</h><w>nathanmarz</w><pre>(def data
  [{:a 1 :bs [{:b 2} {:b 3}]}
   {:a 4 :bs [{:b 5} {:b 6}]}])
   
(-&gt;&gt; data
     (setval [ALL
              :bs
              ALL
              (selected? :b #{1 2 6})
              :mark]
       true)
     (setval [ALL
              (selected? :bs ALL (must :mark))
              :mark]
      true))
</pre></z><z id="t1475758643" t="yonatanel OK, nice!"><y>#</y><d>2016-10-06</d><h>12:57</h><w>yonatanel</w>OK, nice!</z><z id="t1475758869" t="yonatanel It wouldn&apos;t work if I wanted to only mark id 4, but I&apos;ll figure it out."><y>#</y><d>2016-10-06</d><h>13:01</h><w>yonatanel</w>It wouldn&apos;t work if I wanted to only mark id 4, but I&apos;ll figure it out.</z><z id="t1475759152" t="nathanmarz couldn&apos;t tell from your example whether the id matching was just on nested maps or on the parent maps as well"><y>#</y><d>2016-10-06</d><h>13:05</h><w>nathanmarz</w>couldn&apos;t tell from your example whether the id matching was just on nested maps or on the parent maps as well</z><z id="t1475759159" t="nathanmarz not hard to modify to check both"><y>#</y><d>2016-10-06</d><h>13:05</h><w>nathanmarz</w>not hard to modify to check both</z><z id="t1475789811" t="nlessa Hi! Using 0.12.0 version what would be the elegant way to get in a hierarchical map like {:a 1 :b: 1 :c {:a 2 :b 2 :c {:a 3 :b 3 :c …}…} - undetermined levels of c - the most profound value of :a ?"><y>#</y><d>2016-10-06</d><h>21:36</h><w>nlessa</w>Hi! Using 0.12.0 version what would be the elegant way to get in a hierarchical map like
<pre>{:a 1 :b: 1  :c {:a 2 :b 2 :c {:a 3 :b 3 :c …}…}</pre>
- undetermined levels of c - the most profound value of :a ?</z><z id="t1475800992" t="nathanmarz @nlessa what do you mean by &quot;most profound&quot;?"><y>#</y><d>2016-10-07</d><h>00:43</h><w>nathanmarz</w>@nlessa what do you mean by &quot;most profound&quot;?</z><z id="t1475849553" t="nlessa hi @nathanmarz. I mean: navigating continuously in the hierarchy by the :c key, get the last :c you navigated and the get the value of :a 3 examples: {:a 1 :b: 1 :c {:a 2 :d 2 :c {:a 3 :b 3 :c {:a 4 :h 4}}}} =&gt; 4 {:a 1 :b 1 :c: {:a 2 :d 2 :f {:a 3 :b 3 :c {:a 4 :h 4} }}}} =&gt; 2 {:a 1 :b: 1 :j {:a 2 :d 2 :c {:a 3 :b 3 :c {:a 4 :h 4}}}} =&gt; 1 Is it clear?"><y>#</y><d>2016-10-07</d><h>14:12</h><w>nlessa</w>hi @nathanmarz. 
I mean: navigating continuously in the hierarchy by the :c key, get the last :c you navigated and the get the value of :a

3 examples:
<pre>{:a 1 :b: 1 :c {:a 2 :d 2 :c {:a 3 :b 3 :c  {:a 4 :h 4}}}} =&gt;   4

   {:a 1 :b 1 :c: {:a 2 :d 2 :f {:a 3 :b 3 :c  {:a 4 :h 4} }}}} =&gt;  2

   {:a 1 :b: 1 :j {:a 2 :d 2 :c {:a 3 :b 3 :c  {:a 4 :h 4}}}} =&gt;  1</pre>

Is it clear?</z><z id="t1475850226" t="nathanmarz @nlessa you can do something like this with 0.12.0 (declarepath LastCMap) (providepath LastCMap (if-path (must :c) [:c LastCMap] STAY )) (select-any [LastCMap :a] data) "><y>#</y><d>2016-10-07</d><h>14:23</h><w>nathanmarz</w>@nlessa you can do something like this with 0.12.0
<pre>(declarepath LastCMap)
(providepath LastCMap
  (if-path (must :c)
    [:c LastCMap]
    STAY
    ))

(select-any [LastCMap :a] data)
</pre></z><z id="t1475850240" t="nathanmarz though I really recommend using 0.13.0, which is much better at things like this"><y>#</y><d>2016-10-07</d><h>14:24</h><w>nathanmarz</w>though I really recommend using 0.13.0, which is much better at things like this</z><z id="t1475850271" t="nathanmarz in 0.13.0 you can do it like this: (def LastMap (recursive-path [k] p (if-path (must k) [(keypath k) p] STAY))) (select-any [(LastMap :c) :a] data) "><y>#</y><d>2016-10-07</d><h>14:24</h><w>nathanmarz</w>in 0.13.0 you can do it like this:
<pre>(def LastMap
  (recursive-path [k] p
    (if-path (must k)
      [(keypath k) p]
      STAY)))

(select-any [(LastMap :c) :a] data)
</pre></z><z id="t1475854750" t="nlessa Thank you very much, @nathanmarz. Specter is really great, very elegant! When we see the solution it seems obvious. 🙂 I am yet struggling to dominate all the navigators logic and solve some problems in the specter-way."><y>#</y><d>2016-10-07</d><h>15:39</h><w>nlessa</w>Thank you very much, @nathanmarz. Specter is really great, very elegant! When we see the solution it seems obvious. <b>🙂</b> I am yet struggling to dominate all the navigators logic  and solve some problems in the specter-way.</z><z id="t1475854982" t="nathanmarz you&apos;ll get there, it just takes practice"><y>#</y><d>2016-10-07</d><h>15:43</h><w>nathanmarz</w>you&apos;ll get there, it just takes practice</z><z id="t1475854996" t="nathanmarz and a certain amount of retraining on how you think about data structures"><y>#</y><d>2016-10-07</d><h>15:43</h><w>nathanmarz</w>and a certain amount of retraining on how you think about data structures</z><z id="t1475864978" t="aaelony is a transformation from [[:a :b] [:a :c] [:b :d] [:c :d]] to {:a [:b :c], :b [:d], :c [:d]} something that Specter is designed for? Not sure if that should be a transform or a setval or something else..."><y>#</y><d>2016-10-07</d><h>18:29</h><w>aaelony</w>is a transformation from <code>[[:a :b] [:a :c] [:b :d] [:c :d]]</code> to <code>{:a [:b :c], :b [:d], :c [:d]}</code> something that Specter is designed for?  Not sure if that should be a <code>transform</code> or a <code>setval</code> or something else...</z><z id="t1475865121" t="nathanmarz @aaelony the target object doesn&apos;t really share any structure with the source, so I would just do that with regular clojure functions"><y>#</y><d>2016-10-07</d><h>18:32</h><w>nathanmarz</w>@aaelony the target object doesn&apos;t really share any structure with the source, so I would just do that with regular clojure functions</z><z id="t1475865165" t="aaelony perfect, thanks @nathanmarz"><y>#</y><d>2016-10-07</d><h>18:32</h><w>aaelony</w>perfect, thanks @nathanmarz</z><z id="t1475982721" t="richiardiandrea Hello folks! A newbie question, if I have a vec of vecs and want to conj to only the first vec, how should I go about? Sample: [[1 2] [4 6] [42]] -&gt; [[1 2 3] [4 6] [42]]"><y>#</y><d>2016-10-09</d><h>03:12</h><w>richiardiandrea</w>Hello folks! A newbie question, if I have a vec of vecs and want to conj to only the first vec, how should I go about? Sample:
<code>[[1 2] [4 6] [42]] -&gt; [[1 2 3] [4 6] [42]]</code></z><z id="t1475982766" t="richiardiandrea I tried FIRST but it navigates to the first element in each vector I believe (but I am trying again)"><y>#</y><d>2016-10-09</d><h>03:12</h><w>richiardiandrea</w>I tried FIRST but it navigates to the first element in each vector I believe (but I am trying again)</z><z id="t1475982855" t="richiardiandrea I could stop here and do the conj in the transform function only to the first, but there might be a better way 😄"><y>#</y><d>2016-10-09</d><h>03:14</h><w>richiardiandrea</w>I could stop here and do the conj in the transform function only to the first, but there might be a better way <b>😄</b></z><z id="t1475982972" t="richiardiandrea oh, found...it is specter/VAL what I am looking for"><y>#</y><d>2016-10-09</d><h>03:16</h><w>richiardiandrea</w>oh, found...it is <code>specter/VAL</code> what I am looking for</z><z id="t1475983127" t="richiardiandrea uhm..no probably my original idea to do it in the transform function is good for now, but I am open for suggestions"><y>#</y><d>2016-10-09</d><h>03:18</h><w>richiardiandrea</w>uhm..no probably my original idea to do it in the transform function is good for now, but I am open for suggestions</z><z id="t1476010069" t="nathanmarz @richiardiandrea (setval [FIRST END] [3] [[1 2] [4 6] [42]] )"><y>#</y><d>2016-10-09</d><h>10:47</h><w>nathanmarz</w>@richiardiandrea <code>(setval [FIRST END] [3] [[1 2] [4 6] [42]] )</code></z><z id="t1476031139" t="richiardiandrea oh ok tnx !"><y>#</y><d>2016-10-09</d><h>16:38</h><w>richiardiandrea</w>oh ok tnx !</z><z id="t1476221502" t="spieden some specter golf for you all: how to select triples from a nested map where values are nil? e.g. {:foo {:bar nil :bom 1}} -&gt; [:foo :bar]"><y>#</y><d>2016-10-11</d><h>21:31</h><w>spieden</w>some specter golf for you all: how to select triples from a nested map where values are nil? e.g. {:foo {:bar nil :bom 1}} -&gt; [:foo :bar]</z><z id="t1476221861" t="spieden hmm maybe selected? + some subselects"><y>#</y><d>2016-10-11</d><h>21:37</h><w>spieden</w>hmm maybe selected? + some subselects</z><z id="t1476223246" t="nathanmarz @spieden use value collection"><y>#</y><d>2016-10-11</d><h>22:00</h><w>nathanmarz</w>@spieden use value collection</z><z id="t1476223267" t="spieden trying something with multi-path right now but not panning out"><y>#</y><d>2016-10-11</d><h>22:01</h><w>spieden</w>trying something with multi-path right now but not panning out</z><z id="t1476223288" t="nathanmarz (select [ALL (collect-one FIRST) LAST ALL (selected? LAST nil?) FIRST] data)"><y>#</y><d>2016-10-11</d><h>22:01</h><w>nathanmarz</w><code>(select [ALL (collect-one FIRST) LAST ALL (selected? LAST nil?) FIRST] data)</code></z><z id="t1476223375" t="spieden perfect, thanks!"><y>#</y><d>2016-10-11</d><h>22:02</h><w>spieden</w>perfect, thanks!</z><z id="t1476223382" t="spieden (works and now i’ll try to understand it)"><y>#</y><d>2016-10-11</d><h>22:03</h><w>spieden</w>(works and now i’ll try to understand it)</z><z id="t1476223420" t="nathanmarz can make it recursive too if you want to handle arbitrarily nested maps"><y>#</y><d>2016-10-11</d><h>22:03</h><w>nathanmarz</w>can make it recursive too if you want to handle arbitrarily nested maps</z><z id="t1476223544" t="spieden i think i understand it — didn’t realize that selected? would propagate back like that"><y>#</y><d>2016-10-11</d><h>22:05</h><w>spieden</w>i think i understand it — didn’t realize that selected? would propagate back like that</z><z id="t1476223556" t="spieden is this what distinguishes it from filterer?"><y>#</y><d>2016-10-11</d><h>22:05</h><w>spieden</w>is this what distinguishes it from filterer?</z><z id="t1476223569" t="nathanmarz selected? expresses a filter predicate in terms of a path"><y>#</y><d>2016-10-11</d><h>22:06</h><w>nathanmarz</w><code>selected?</code> expresses a filter predicate in terms of a path</z><z id="t1476223573" t="spieden also was trying to use collect instead of collect-one"><y>#</y><d>2016-10-11</d><h>22:06</h><w>spieden</w>also was trying to use collect instead of collect-one</z><z id="t1476223623" t="nathanmarz filterer navigates to result of running filter using the path as a filter predicate"><y>#</y><d>2016-10-11</d><h>22:07</h><w>nathanmarz</w><code>filterer</code> navigates to result of running <code>filter</code> using the path as a filter predicate</z><z id="t1476223635" t="nathanmarz (`filterer` uses selected? in its implementation)"><y>#</y><d>2016-10-11</d><h>22:07</h><w>nathanmarz</w>(`filterer` uses <code>selected?</code> in its implementation)</z><z id="t1476223679" t="spieden ah ok"><y>#</y><d>2016-10-11</d><h>22:07</h><w>spieden</w>ah ok</z><z id="t1476223679" t="nathanmarz (defdynamicnav filterer [&amp; path] (subselect ALL (selected? path))) "><y>#</y><d>2016-10-11</d><h>22:07</h><w>nathanmarz</w><pre>(defdynamicnav filterer
  [&amp; path]
  (subselect ALL (selected? path)))
</pre></z><z id="t1476223764" t="nathanmarz (transform (filterer odd?) reverse [1 2 3 4 5 6 7]) =&gt; [7 2 5 4 3 6 1]"><y>#</y><d>2016-10-11</d><h>22:09</h><w>nathanmarz</w><code>(transform (filterer odd?) reverse [1 2 3 4 5 6 7])</code> =&gt; <code>[7 2 5 4 3 6 1]</code></z><z id="t1476223870" t="spieden wow 💡"><y>#</y><d>2016-10-11</d><h>22:11</h><w>spieden</w>wow <b>💡</b></z><z id="t1476320467" t="kenny Is there some sort of problem with specter + Datomic tempids? I get this very strange error: (rs/declarepath MapWalker) (rs/providepath MapWalker (rs/stay-then-continue rs/MAP-VALS (rs/walker map?) MapWalker)) (rs/transform [MapWalker :db/id] (fn [id] (d/tempid :db.part/user)) {:db/id 1 :foo [{:db/id 2}]}) =&gt; java.lang.UnsupportedOperationException: Can&apos;t create empty: datomic.db.DbId I suspect the error is a red herring.."><y>#</y><d>2016-10-13</d><h>01:01</h><w>kenny</w>Is there some sort of problem with specter + Datomic tempids? I get this very strange error: 
<pre>(rs/declarepath MapWalker)
(rs/providepath MapWalker
                (rs/stay-then-continue
                  rs/MAP-VALS
                  (rs/walker map?)
                  MapWalker))

(rs/transform [MapWalker :db/id]
              (fn [id]
                (d/tempid :db.part/user))
              {:db/id 1
               :foo [{:db/id 2}]})
=&gt; java.lang.UnsupportedOperationException: Can&apos;t create empty: datomic.db.DbId
</pre>
I suspect the error is a red herring..</z><z id="t1476320654" t="kenny I can do this without an error: (rs/transform [MapWalker :db/id] (fn [id] (d/tempid :db.part/user) id) {:db/id 1 :foo [{:db/id 2}]}) =&gt; {:db/id 1, :foo [#:db{:id 2}]} "><y>#</y><d>2016-10-13</d><h>01:04</h><w>kenny</w>I can do this without an error: 
<pre>(rs/transform [MapWalker :db/id]
              (fn [id]
                (d/tempid :db.part/user)
                id)
              {:db/id 1
               :foo [{:db/id 2}]})
=&gt; {:db/id 1, :foo [#:db{:id 2}]}
</pre></z><z id="t1476320680" t="kenny It&apos;s just if the transform-fn returns a tempid that I get the error"><y>#</y><d>2016-10-13</d><h>01:04</h><w>kenny</w>It&apos;s just if the transform-fn returns a tempid that I get the error</z><z id="t1476320763" t="kenny I am using specter v0.13.0"><y>#</y><d>2016-10-13</d><h>01:06</h><w>kenny</w>I am using specter v0.13.0</z><z id="t1476320997" t="nathanmarz @kenny it probably has something to do with clojure.walk interacting with that datomic type"><y>#</y><d>2016-10-13</d><h>01:09</h><w>nathanmarz</w>@kenny it probably has something to do with clojure.walk interacting with that datomic type</z><z id="t1476321038" t="nathanmarz i think you can avoid that situation by doing continue-then-stay instead of stay-then-continue"><y>#</y><d>2016-10-13</d><h>01:10</h><w>nathanmarz</w>i think you can avoid that situation by doing <code>continue-then-stay</code> instead of <code>stay-then-continue</code></z><z id="t1476321105" t="kenny yes that did it"><y>#</y><d>2016-10-13</d><h>01:11</h><w>kenny</w>yes that did it</z><z id="t1476321128" t="kenny Why did that make it work?"><y>#</y><d>2016-10-13</d><h>01:12</h><w>kenny</w>Why did that make it work?</z><z id="t1476321187" t="nathanmarz when you do stay-then-continue , it first updates :db/id on the top-level map. then it does the rest of the path (`MAP-VALS (walker ...) MapWalker`)"><y>#</y><d>2016-10-13</d><h>01:13</h><w>nathanmarz</w>when you do <code>stay-then-continue</code>, it first updates :db/id on the top-level map. then it does the rest of the path (`MAP-VALS (walker ...) MapWalker`)</z><z id="t1476321223" t="nathanmarz when you do continue-then-stay , it does the walk of the submaps first, so at no point does the walk ever go over the datomic types that you produced"><y>#</y><d>2016-10-13</d><h>01:13</h><w>nathanmarz</w>when you do <code>continue-then-stay</code>, it does the walk of the submaps first, so at no point does the walk ever go over the datomic types that you produced</z><z id="t1476321265" t="kenny Ah I see. Thank you for your explanation 🙂"><y>#</y><d>2016-10-13</d><h>01:14</h><w>kenny</w>Ah I see. Thank you for your explanation <b>🙂</b></z><z id="t1476321503" t="nathanmarz no problem!"><y>#</y><d>2016-10-13</d><h>01:18</h><w>nathanmarz</w>no problem!</z><z id="t1476386771" t="jlutteringer noob question here: How do I select the values that come before elements that satisfy a given predicate. For example if I had [1 &quot;a&quot; 22 3 5 2 &quot;b&quot; 10] and wanted to select values that occur before strings to get [1 2] . Is this something that is possible?"><y>#</y><d>2016-10-13</d><h>19:26</h><w>jlutteringer</w>noob question here: How do I select the values that come before elements that satisfy a given predicate. For example if I had <code>[1 &quot;a&quot; 22 3 5 2 &quot;b&quot; 10]</code> and wanted to select values that occur before strings to get <code>[1 2]</code>. Is this something that is possible?</z><z id="t1476387151" t="darwin gave 0.13 another shot, and still having the same issue like 5 weeks ago: https://gist.github.com/darwin/10e6748467e0a13a8f7573c1ae99e4a6 it is calling this function, compiled under :advanced mode with :pseudo-names true https://github.com/binaryage/dirac/blob/6c0c2bc8348eb296174cc72331c031e096af1bda/src/implant/dirac/implant/automation/reps.cljs#L62"><y>#</y><d>2016-10-13</d><h>19:32</h><w>darwin</w>gave 0.13 another shot, and still having the same issue like 5 weeks ago:
<a href="https://gist.github.com/darwin/10e6748467e0a13a8f7573c1ae99e4a6" target="_blank">https://gist.github.com/darwin/10e6748467e0a13a8f7573c1ae99e4a6</a>
it is calling this function, compiled under <code>:advanced</code> mode with <code>:pseudo-names</code> true
<a href="https://github.com/binaryage/dirac/blob/6c0c2bc8348eb296174cc72331c031e096af1bda/src/implant/dirac/implant/automation/reps.cljs#L62" target="_blank">https://github.com/binaryage/dirac/blob/6c0c2bc8348eb296174cc72331c031e096af1bda/src/implant/dirac/implant/automation/reps.cljs#L62</a></z><z id="t1476387173" t="darwin looking into it further, I’m going to solve this today, just posting FYI"><y>#</y><d>2016-10-13</d><h>19:32</h><w>darwin</w>looking into it further, I’m going to solve this today, just posting FYI</z><z id="t1476387451" t="darwin this.$late1$ seems to be ok, but it does not contain $select_STAR_$"><y>#</y><d>2016-10-13</d><h>19:37</h><w>darwin</w>this.$late1$ seems to be ok, but it does not contain $select_STAR_$</z><z id="t1476388752" t="nathanmarz @jlutteringer you could do [(continuous-subseqs (complement string?)) FIRST]"><y>#</y><d>2016-10-13</d><h>19:59</h><w>nathanmarz</w>@jlutteringer you could do <code>[(continuous-subseqs (complement string?)) FIRST]</code></z><z id="t1476388791" t="nathanmarz @darwin can you remind me what was causing the issue before?"><y>#</y><d>2016-10-13</d><h>19:59</h><w>nathanmarz</w>@darwin can you remind me what was causing the issue before?</z><z id="t1476388817" t="nathanmarz also, does it still fail under 0.13.1-SNAPSHOT?"><y>#</y><d>2016-10-13</d><h>20:00</h><w>nathanmarz</w>also, does it still fail under 0.13.1-SNAPSHOT?</z><z id="t1476388853" t="darwin we didn’t go deeper into it, I decided to wait if anyone else hits similar issue, downgraded to 0.12 again"><y>#</y><d>2016-10-13</d><h>20:00</h><w>darwin</w>we didn’t go deeper into it, I decided to wait if anyone else hits similar issue, downgraded to 0.12 again</z><z id="t1476388862" t="darwin I’m going to try the snapshot"><y>#</y><d>2016-10-13</d><h>20:01</h><w>darwin</w>I’m going to try the snapshot</z><z id="t1476388872" t="nathanmarz does it work under non-advanced compilation?"><y>#</y><d>2016-10-13</d><h>20:01</h><w>nathanmarz</w>does it work under non-advanced compilation?</z><z id="t1476388925" t="darwin that is next thing I want to test"><y>#</y><d>2016-10-13</d><h>20:02</h><w>darwin</w>that is next thing I want to test</z><z id="t1476389127" t="nathanmarz can you also wrap that line in (with-inline-debug ...) ?"><y>#</y><d>2016-10-13</d><h>20:05</h><w>nathanmarz</w>can you also wrap that line in <code>(with-inline-debug ...)</code>?</z><z id="t1476389149" t="nathanmarz that will print some debugging info that might be useful"><y>#</y><d>2016-10-13</d><h>20:05</h><w>nathanmarz</w>that will print some debugging info that might be useful</z><z id="t1476389673" t="darwin 0.13.1-SNAPSHOT is broken for me as well, trying to compile it under :whitespace mode and with-inline-debug, unfortunately switching to :none mode would be much more work due to chrome extension packaging restrictions"><y>#</y><d>2016-10-13</d><h>20:14</h><w>darwin</w>0.13.1-SNAPSHOT is broken for me as well, trying to compile it under :whitespace mode and with-inline-debug, unfortunately switching to :none mode would be much more work due to chrome extension packaging restrictions</z><z id="t1476390217" t="darwin ah, I’m going in the same footsteps, :whitespace mode is broken due to this parinfer issue: https://github.com/shaunlebron/parinfer/issues/120 and I cannot upgrade because it wasn’t yet published on cljsjs"><y>#</y><d>2016-10-13</d><h>20:23</h><w>darwin</w>ah, I’m going in the same footsteps, :whitespace mode is broken due to this parinfer issue:
<a href="https://github.com/shaunlebron/parinfer/issues/120" target="_blank">https://github.com/shaunlebron/parinfer/issues/120</a>
and I cannot upgrade because it wasn’t yet published on cljsjs</z><z id="t1476390247" t="darwin now I recall, that is why I gave up few weeks ago"><y>#</y><d>2016-10-13</d><h>20:24</h><w>darwin</w>now I recall, that is why I gave up few weeks ago</z><z id="t1476390357" t="nathanmarz ok"><y>#</y><d>2016-10-13</d><h>20:25</h><w>nathanmarz</w>ok</z><z id="t1476390391" t="darwin I’m going to use parinfer directly as foreign-lib, but it will take me some time until I figure it out"><y>#</y><d>2016-10-13</d><h>20:26</h><w>darwin</w>I’m going to use parinfer directly as foreign-lib, but it will take me some time until I figure it out</z><z id="t1476390401" t="nathanmarz looking at the error more closely, the issue is happening inside of multi-path, so wrapping the providepath in with-inline-debug would be helpful as well"><y>#</y><d>2016-10-13</d><h>20:26</h><w>nathanmarz</w>looking at the error more closely, the issue is happening inside of multi-path, so wrapping the providepath in with-inline-debug would be helpful as well</z><z id="t1476390759" t="darwin also that “undefined” thing in generated identifier names is suspicious"><y>#</y><d>2016-10-13</d><h>20:32</h><w>darwin</w>also that “undefined” thing in generated identifier names is suspicious</z><z id="t1476390822" t="nathanmarz @jlutteringer just realized you asked something completely different, for that use case I would recommend using zipper navigators or making a custom navigator"><y>#</y><d>2016-10-13</d><h>20:33</h><w>nathanmarz</w>@jlutteringer just realized you asked something completely different, for that use case I would recommend using zipper navigators or making a custom navigator</z><z id="t1476390859" t="nathanmarz @darwin agree"><y>#</y><d>2016-10-13</d><h>20:34</h><w>nathanmarz</w>@darwin agree</z><z id="t1476390914" t="jlutteringer I was able to get very close tweaking your example (specter/select [(specter/continuous-subseqs (complement string?)) specter/LAST] [1 &quot;a&quot; 22 3 5 2 &quot;b&quot; 10]) gives me [1 2 10] now I just need to figure out how to drop the last element"><y>#</y><d>2016-10-13</d><h>20:35</h><w>jlutteringer</w>I was able to get very close tweaking your example <code>(specter/select [(specter/continuous-subseqs (complement string?)) specter/LAST] [1 &quot;a&quot; 22 3 5 2 &quot;b&quot; 10])</code> gives me <code>[1 2 10]</code> now I just need to figure out how to drop the last element</z><z id="t1476391202" t="nathanmarz well, if the last element of sequence is a string you wouldn&apos;t want to drop it"><y>#</y><d>2016-10-13</d><h>20:40</h><w>nathanmarz</w>well, if the last element of sequence is a string you wouldn&apos;t want to drop it</z><z id="t1476391326" t="jlutteringer ah, right"><y>#</y><d>2016-10-13</d><h>20:42</h><w>jlutteringer</w>ah, right</z><z id="t1476391357" t="jlutteringer kk, I’ll give zippers a shot, thanks so much for the help!"><y>#</y><d>2016-10-13</d><h>20:42</h><w>jlutteringer</w>kk, I’ll give zippers a shot, thanks so much for the help!</z><z id="t1476391395" t="nathanmarz specter integrates zippers in specter/zipper.cljc"><y>#</y><d>2016-10-13</d><h>20:43</h><w>nathanmarz</w>specter integrates zippers in specter/zipper.cljc</z><z id="t1476391439" t="nathanmarz https://nathanmarz.github.io/specter/com.rpl.specter.zipper.html"><y>#</y><d>2016-10-13</d><h>20:43</h><w>nathanmarz</w><a href="https://nathanmarz.github.io/specter/com.rpl.specter.zipper.html" target="_blank">https://nathanmarz.github.io/specter/com.rpl.specter.zipper.html</a></z><z id="t1476391651" t="nathanmarz @jlutteringer (select [z/VECTOR-ZIP z/DOWN z/NEXT-WALK (selected? z/NODE string?) z/LEFT z/NODE] [1 2 &quot;a&quot; 3 &quot;b&quot; 4]) ;; =&gt; [2 3] "><y>#</y><d>2016-10-13</d><h>20:47</h><w>nathanmarz</w>@jlutteringer
<pre>(select
        [z/VECTOR-ZIP
         z/DOWN
         z/NEXT-WALK
         (selected? z/NODE string?)
         z/LEFT
         z/NODE]
        [1 2 &quot;a&quot; 3 &quot;b&quot; 4])
;; =&gt; [2 3]
</pre></z><z id="t1476391743" t="jlutteringer you’re the man, thank you so much"><y>#</y><d>2016-10-13</d><h>20:49</h><w>jlutteringer</w>you’re the man, thank you so much</z><z id="t1476393514" t="darwin getting close to get :whitespace working, now hitting http://dev.clojure.org/jira/browse/CLJS-1547"><y>#</y><d>2016-10-13</d><h>21:18</h><w>darwin</w>getting close to get :whitespace working, now hitting
<a href="http://dev.clojure.org/jira/browse/CLJS-1547" target="_blank">http://dev.clojure.org/jira/browse/CLJS-1547</a></z><z id="t1476399668" t="darwin @nathanmarz finally got a screenshot for you: https://dl.dropboxusercontent.com/u/559047/specter-dirac-whitespace.png"><y>#</y><d>2016-10-13</d><h>23:01</h><w>darwin</w>@nathanmarz finally got a screenshot for you:
<a href="https://dl.dropboxusercontent.com/u/559047/specter-dirac-whitespace.png" target="_blank">https://dl.dropboxusercontent.com/u/559047/specter-dirac-whitespace.png</a></z><z id="t1476399784" t="darwin https://dl.dropboxusercontent.com/u/559047/specter-dirac-whitespace2.png"><y>#</y><d>2016-10-13</d><h>23:03</h><w>darwin</w><a href="https://dl.dropboxusercontent.com/u/559047/specter-dirac-whitespace2.png" target="_blank">https://dl.dropboxusercontent.com/u/559047/specter-dirac-whitespace2.png</a></z><z id="t1476401773" t="darwin this is output I got from the inline-debug: https://gist.github.com/darwin/1b2d5f75a9348ba2b9dcad241c1e2fb6"><y>#</y><d>2016-10-13</d><h>23:36</h><w>darwin</w>this is output I got from the inline-debug: <a href="https://gist.github.com/darwin/1b2d5f75a9348ba2b9dcad241c1e2fb6" target="_blank">https://gist.github.com/darwin/1b2d5f75a9348ba2b9dcad241c1e2fb6</a></z><z id="t1476406387" t="darwin I was able to isolate the issue: https://github.com/darwin/pesky-select-star"><y>#</y><d>2016-10-14</d><h>00:53</h><w>darwin</w>I was able to isolate the issue: <a href="https://github.com/darwin/pesky-select-star" target="_blank">https://github.com/darwin/pesky-select-star</a></z><z id="t1476406457" t="darwin it is failing even on code from specter’s own tests, I was playing with deps and downgrading clojurescript to 1.7.122 fixed it https://github.com/darwin/pesky-select-star/blob/master/project.clj#L9 so does specter support newer clojurescript versions?"><y>#</y><d>2016-10-14</d><h>00:54</h><w>darwin</w>it is failing even on code from specter’s own tests, I was playing with deps and downgrading clojurescript to 1.7.122 fixed it
<a href="https://github.com/darwin/pesky-select-star/blob/master/project.clj#L9" target="_blank">https://github.com/darwin/pesky-select-star/blob/master/project.clj#L9</a>

so does specter support newer clojurescript versions?</z><z id="t1476406540" t="darwin that 1.7.122 I took from specter’s repo and I don’t see there any other clojurescript version"><y>#</y><d>2016-10-14</d><h>00:55</h><w>darwin</w>that 1.7.122 I took from specter’s repo and I don’t see there any other clojurescript version</z><z id="t1476428374" t="nathanmarz @darwin Thanks, this is all really helpful"><y>#</y><d>2016-10-14</d><h>06:59</h><w>nathanmarz</w>@darwin Thanks, this is all really helpful</z><z id="t1476428537" t="nathanmarz @darwin I opened an issue to track it https://github.com/nathanmarz/specter/issues/152"><y>#</y><d>2016-10-14</d><h>07:02</h><w>nathanmarz</w>@darwin I opened an issue to track it <a href="https://github.com/nathanmarz/specter/issues/152" target="_blank">https://github.com/nathanmarz/specter/issues/152</a></z><z id="t1476443745" t="darwin thanks @nathanmarz, will downgrade to 0.12 and track the issue and do next attempt when you fix it, not a priority, good luck!"><y>#</y><d>2016-10-14</d><h>11:15</h><w>darwin</w>thanks @nathanmarz, will downgrade to 0.12 and track the issue and do next attempt when you fix it, not a priority, good luck!</z><z id="t1476453331" t="nathanmarz @darwin ok give the latest 0.13.1-SNAPSHOT a shot"><y>#</y><d>2016-10-14</d><h>13:55</h><w>nathanmarz</w>@darwin ok give the latest 0.13.1-SNAPSHOT a shot</z><z id="t1476453334" t="nathanmarz should be fixed"><y>#</y><d>2016-10-14</d><h>13:55</h><w>nathanmarz</w>should be fixed</z><z id="t1476453423" t="darwin @nathanmarz thanks a lot! going to test it now"><y>#</y><d>2016-10-14</d><h>13:57</h><w>darwin</w>@nathanmarz thanks a lot! going to test it now</z><z id="t1476456802" t="darwin @nathanmarz works for me, thanks for the quick fix! https://github.com/nathanmarz/specter/issues/152#issuecomment-253822990"><y>#</y><d>2016-10-14</d><h>14:53</h><w>darwin</w>@nathanmarz works for me, thanks for the quick fix!
<a href="https://github.com/nathanmarz/specter/issues/152#issuecomment-253822990" target="_blank">https://github.com/nathanmarz/specter/issues/152#issuecomment-253822990</a></z><z id="t1476457016" t="nathanmarz @darwin awesome, thanks for tracking it down"><y>#</y><d>2016-10-14</d><h>14:56</h><w>nathanmarz</w>@darwin awesome, thanks for tracking it down</z><z id="t1476738760" t="nahuel is possible to use specter to dissoc? ej, transform {:a {:b 1 :c 2}} to {:a {:c 2}} ?"><y>#</y><d>2016-10-17</d><h>21:12</h><w>nahuel</w>is possible to use specter to dissoc? ej, transform  {:a {:b 1 :c 2}} to {:a {:c 2}} ?</z><z id="t1476739349" t="nathanmarz @nahuel You can just do (transform :a #(dissoc % :b) data)"><y>#</y><d>2016-10-17</d><h>21:22</h><w>nathanmarz</w>@nahuel You can just do <code>(transform :a #(dissoc % :b) data)</code></z><z id="t1476739372" t="nathanmarz I have a utility function to help with it: (defn dissocer [k] (fn [m] (dissoc m k)))"><y>#</y><d>2016-10-17</d><h>21:22</h><w>nathanmarz</w>I have a utility function to help with it: <code>(defn dissocer [k] (fn [m] (dissoc m k)))</code></z><z id="t1476739386" t="nathanmarz so you can do (transform :a (dissocer :b) data)"><y>#</y><d>2016-10-17</d><h>21:23</h><w>nathanmarz</w>so you can do <code>(transform :a (dissocer :b) data)</code></z><z id="t1476739429" t="nathanmarz there&apos;s also some thought about extending ALL and keypath to be able to remove elements on this issue https://github.com/nathanmarz/specter/issues/117"><y>#</y><d>2016-10-17</d><h>21:23</h><w>nathanmarz</w>there&apos;s also some thought about extending <code>ALL</code> and <code>keypath</code> to be able to remove elements on this issue <a href="https://github.com/nathanmarz/specter/issues/117" target="_blank">https://github.com/nathanmarz/specter/issues/117</a></z><z id="t1476739450" t="nathanmarz but you could always just make your own navigator with that functionality"><y>#</y><d>2016-10-17</d><h>21:24</h><w>nathanmarz</w>but you could always just make your own navigator with that functionality</z><z id="t1476740138" t="nahuel nathanmarz: thanks"><y>#</y><d>2016-10-17</d><h>21:35</h><w>nahuel</w>nathanmarz: thanks</z><z id="t1476740501" t="nahuel why this doesnt work? (setval [:a #{1 2} ] :y {:a {1 :z 2 :z 3 :z }}) .. I expected {:a {1 :y, 2 :y, 3 :z}} but the map is unchanged (I&apos;m trying to use the set as a predicate)"><y>#</y><d>2016-10-17</d><h>21:41</h><w>nahuel</w>why this doesnt work? (setval [:a #{1 2} ] :y {:a {1 :z 2 :z 3 :z }})  .. I expected {:a {1 :y, 2 :y, 3 :z}} but the map is unchanged (I&apos;m trying to use the set as a predicate)</z><z id="t1476740694" t="nathanmarz sets are interpreted as filter predicates"><y>#</y><d>2016-10-17</d><h>21:44</h><w>nathanmarz</w>sets are interpreted as filter predicates</z><z id="t1476740716" t="nathanmarz (#{1 2} {1 :z 2 :z 3 :z }) is false, so it stops navigation at that point"><y>#</y><d>2016-10-17</d><h>21:45</h><w>nathanmarz</w><code>(#{1 2} {1 :z 2 :z 3 :z })</code> is false, so it stops navigation at that point</z><z id="t1476740747" t="nathanmarz @nahuel you should do this: (setval [:a (multi-path (keypath 1) (keypath 2))] :y {:a {1 :z 2 :z 3 :z }}) "><y>#</y><d>2016-10-17</d><h>21:45</h><w>nathanmarz</w>@nahuel you should do this: <code>(setval [:a (multi-path (keypath 1) (keypath 2))] :y {:a {1 :z 2 :z 3 :z }}) </code></z><z id="t1476740894" t="nahuel but what if the keys are stored in a set? (it can be variable)"><y>#</y><d>2016-10-17</d><h>21:48</h><w>nahuel</w>but what if the keys are stored in a set? (it can be variable)</z><z id="t1476742093" t="nathanmarz probably the easiest is to do (setval [:a (apply multi-path #{1 2})] ...)"><y>#</y><d>2016-10-17</d><h>22:08</h><w>nathanmarz</w>probably the easiest is to do <code>(setval [:a (apply multi-path #{1 2})] ...)</code></z><z id="t1476742210" t="nahuel mm, my set can be very big, I think there is some limitation for apply on the number of arguments"><y>#</y><d>2016-10-17</d><h>22:10</h><w>nahuel</w>mm, my set can be very big, I think there is some limitation for apply on the number of arguments</z><z id="t1476742562" t="nathanmarz there&apos;s not"><y>#</y><d>2016-10-17</d><h>22:16</h><w>nathanmarz</w>there&apos;s not</z><z id="t1476742580" t="nathanmarz (apply + (range 100000)) =&gt; 4999950000"><y>#</y><d>2016-10-17</d><h>22:16</h><w>nathanmarz</w><code>(apply + (range 100000))</code> =&gt; 4999950000</z><z id="t1476742633" t="nathanmarz actually the code I gave you isn&apos;t quite right, it should be (setval [:a (apply multi-path (map keypath #{1 2}))] ...)"><y>#</y><d>2016-10-17</d><h>22:17</h><w>nathanmarz</w>actually the code I gave you isn&apos;t quite right, it should be <code>(setval [:a (apply multi-path (map keypath #{1 2}))] ...)</code></z><z id="t1476742651" t="nahuel oh, thanks"><y>#</y><d>2016-10-17</d><h>22:17</h><w>nahuel</w>oh, thanks</z><z id="t1476785466" t="madstap You can actually apply a function to an infinite list"><y>#</y><d>2016-10-18</d><h>10:11</h><w>madstap</w>You can actually apply a function to an infinite list</z><z id="t1476976517" t="joshkh howdy! just curious about a behaviour in the following example: (s/select [:a s/ALL (juxt :start :end)] {:a [{:start 1 :middle 9 :end 2} {:start 3 :middle 9 :end 4}]}) yields [{:start 1, :middle 9, :end 2} {:start 3, :middle 9, :end 4}] when i would have expected just :start and :end keys in the resulting maps."><y>#</y><d>2016-10-20</d><h>15:15</h><w>joshkh</w>howdy! just curious about a behaviour in the following example:
<pre>(s/select [:a s/ALL (juxt :start :end)]
                  {:a [{:start 1 :middle 9 :end 2} {:start 3 :middle 9 :end 4}]})
</pre>
yields <code>[{:start 1, :middle 9, :end 2} {:start 3, :middle 9, :end 4}]</code>
when i would have expected just :start and :end keys in the resulting maps.</z><z id="t1476976615" t="joshkh i thought multipath might allow me to collect the two values but this throws an exception in cljs: (s/select [:a s/ALL (s/multi-path :start :end)] {:a [{:start 1 :middle 9 :end 2} {:start 3 :middle 9 :end 4}]}) "><y>#</y><d>2016-10-20</d><h>15:16</h><w>joshkh</w>i thought multipath might allow me to collect the two values but this throws an exception in cljs:
<pre>(s/select [:a s/ALL (s/multi-path :start :end)]
                  {:a [{:start 1 :middle 9 :end 2} {:start 3 :middle 9 :end 4}]})
</pre></z><z id="t1476976663" t="joshkh when i really just wanted [[1 2] [3 4]"><y>#</y><d>2016-10-20</d><h>15:17</h><w>joshkh</w>when i really just wanted <code>[[1 2] [3 4]</code></z><z id="t1476976811" t="joshkh i could just throw an anonymous function in there, something like (vals (select-keys..."><y>#</y><d>2016-10-20</d><h>15:20</h><w>joshkh</w>i could just throw an anonymous function in there, something like (vals (select-keys...</z><z id="t1476976830" t="exupero In the juxt example, I’m guessing the function is treated as a predicate, so it returns anything for which that predicate returns a truthy result, not the truthy result itself."><y>#</y><d>2016-10-20</d><h>15:20</h><w>exupero</w>In the <code>juxt</code> example, I’m guessing the function is treated as a predicate, so it returns anything for which that predicate returns a truthy result, not the truthy result itself.</z><z id="t1476976856" t="joshkh ah, that makes sense"><y>#</y><d>2016-10-20</d><h>15:20</h><w>joshkh</w>ah, that makes sense</z><z id="t1476976898" t="joshkh (and i lied about the anonymous function - like you said it&apos;s treated as a predicate)"><y>#</y><d>2016-10-20</d><h>15:21</h><w>joshkh</w>(and i lied about the anonymous function - like you said it&apos;s treated as a predicate)</z><z id="t1476977239" t="nathanmarz @joshkh what exception are you getting? that works fine for me in a cljs repl"><y>#</y><d>2016-10-20</d><h>15:27</h><w>nathanmarz</w>@joshkh what exception are you getting? that works fine for me in a cljs repl</z><z id="t1476977377" t="joshkh specter.cljc?rel=1476963781628:1049 Uncaught TypeError: G__36053.select_STAR_ is not a function"><y>#</y><d>2016-10-20</d><h>15:29</h><w>joshkh</w><code>specter.cljc?rel=1476963781628:1049 Uncaught TypeError: G__36053.select_STAR_ is not a function</code></z><z id="t1476977419" t="joshkh using [com.rpl/specter &quot;0.13.0&quot;]"><y>#</y><d>2016-10-20</d><h>15:30</h><w>joshkh</w>using <code>[com.rpl/specter &quot;0.13.0&quot;]</code></z><z id="t1476977441" t="nathanmarz oh"><y>#</y><d>2016-10-20</d><h>15:30</h><w>nathanmarz</w>oh</z><z id="t1476977453" t="nathanmarz yea that bug is fixed in master"><y>#</y><d>2016-10-20</d><h>15:30</h><w>nathanmarz</w>yea that bug is fixed in master</z><z id="t1476977457" t="nathanmarz try 0.13.1-SNAPSHOT"><y>#</y><d>2016-10-20</d><h>15:30</h><w>nathanmarz</w>try 0.13.1-SNAPSHOT</z><z id="t1476977556" t="joshkh it worked! thanks 🙂"><y>#</y><d>2016-10-20</d><h>15:32</h><w>joshkh</w>it worked! thanks <b>🙂</b></z><z id="t1476977558" t="nathanmarz also if you want to get [[1 2] [3 4]] as the result do this: (select [:a s/ALL (s/collect-one :start) :end] {:a [{:start 1 :middle 9 :end 2} {:start 3 :middle 9 :end 4}]}) "><y>#</y><d>2016-10-20</d><h>15:32</h><w>nathanmarz</w>also if you want to get <code>[[1 2] [3 4]]</code> as the result do this:
 <pre>(select [:a s/ALL (s/collect-one :start) :end]
        {:a [{:start 1 :middle 9 :end 2} {:start 3 :middle 9 :end 4}]})
</pre></z><z id="t1476977696" t="joshkh oh right. i had tried calling collect-one for each respective key but couldn&apos;t figure out how to &quot;drop&quot; the rest from the selection resulting in [1 3 {entire-node}]"><y>#</y><d>2016-10-20</d><h>15:34</h><w>joshkh</w>oh right. i had tried calling <code>collect-one</code> for each respective key but couldn&apos;t figure out how to &quot;drop&quot; the rest from the selection resulting in <code>[1 3 {entire-node}]</code></z><z id="t1476977699" t="joshkh as always, thanks for the help"><y>#</y><d>2016-10-20</d><h>15:34</h><w>joshkh</w>as always, thanks for the help</z><z id="t1476977722" t="nathanmarz no problem, glad I was helpful"><y>#</y><d>2016-10-20</d><h>15:35</h><w>nathanmarz</w>no problem, glad I was helpful</z><z id="t1477417588" t="nlessa Hi, How could I solve in specter this problem? Given a key (eg: :e) located in an undetermined nested level of a map return the map with only the keys that compose the path to reach it. For example: {:a 1 :b {:c 2 :d {:e 3 :f 4} :g {:e 5 :h 8}}} --&gt; {:b {:d {:e 3} :g {:e 5}}}"><y>#</y><d>2016-10-25</d><h>17:46</h><w>nlessa</w>Hi,
How could I solve in specter this problem? Given a key (eg: :e) located in an undetermined nested level of a map return the map with only the keys that compose the path to reach it. 
<pre>For example: 
{:a 1 :b {:c 2 :d {:e 3 :f 4} :g {:e 5 :h 8}}}

 --&gt; {:b {:d {:e 3} :g {:e 5}}}</pre></z><z id="t1477427296" t="nathanmarz @nlessa two ways to go about it"><y>#</y><d>2016-10-25</d><h>20:28</h><w>nathanmarz</w>@nlessa two ways to go about it</z><z id="t1477427326" t="nathanmarz first is to use select with a recursive path + value collection to get the sequence of paths to your desired key/values. Then construct the nested map manually"><y>#</y><d>2016-10-25</d><h>20:28</h><w>nathanmarz</w>first is to use <code>select</code> with a recursive path + value collection to get the sequence of paths to your desired key/values. Then construct the nested map manually</z><z id="t1477427413" t="nathanmarz second is to make a new navigator like ALL that removes values when NONE is returned on transformation"><y>#</y><d>2016-10-25</d><h>20:30</h><w>nathanmarz</w>second is to make a new navigator like <code>ALL</code> that removes values when <code>NONE</code> is returned on transformation</z><z id="t1477427427" t="nathanmarz with that you could solve your use case with a single transform call"><y>#</y><d>2016-10-25</d><h>20:30</h><w>nathanmarz</w>with that you could solve your use case with a single <code>transform</code> call</z><z id="t1477648268" t="achesnais @nathanmarz don’t know if this is a silly question or not, but is there any remote chance or plan to have specter become part of clojure.core?"><y>#</y><d>2016-10-28</d><h>09:51</h><w>achesnais</w>@nathanmarz don’t know if this is a silly question or not, but is there any remote chance or plan to have specter become part of clojure.core?</z><z id="t1477648298" t="achesnais And if not I’d be interested to know if there’s a specific reason why in terms of design philosophy etc."><y>#</y><d>2016-10-28</d><h>09:51</h><w>achesnais</w>And if not I’d be interested to know if there’s a specific reason why in terms of design philosophy etc.</z><z id="t1477648300" t="achesnais 🙂"><y>#</y><d>2016-10-28</d><h>09:51</h><w>achesnais</w><b>🙂</b></z><z id="t1477651823" t="darwin I’m afraid it works the other way around, there may be no specific reasons why something is not in core. To get something into the core there must be very compelling reasons for it. I mean really compelling. Being a popular/useful/well-maintained/general library is not enough of itself. One such compelling reason I could imagine with specter would be the core library using specter internally, so it would make sense to expose it as well. Similar to clojure.spec. Or another reason could be when specter could not be implemented as a library and would have to be implemented as part of core for some reason… just my $0.02 thoughts"><y>#</y><d>2016-10-28</d><h>10:50</h><w>darwin</w>I’m afraid it works the other way around, there may be no specific reasons why something is not in core. To get something into the core there must be very compelling reasons for it. I mean really compelling. Being a popular/useful/well-maintained/general library is not enough of itself. One such compelling reason I could imagine with specter would be the core library using specter internally, so it would make sense to expose it as well. Similar to clojure.spec. Or another reason could be when specter could not be implemented as a library and would have to be implemented as part of core for some reason… just my $0.02 thoughts</z><z id="t1477659628" t="nathanmarz @achesnais @darwin I get that question a lot and I understand why"><y>#</y><d>2016-10-28</d><h>13:00</h><w>nathanmarz</w>@achesnais @darwin I get that question a lot and I understand why</z><z id="t1477659687" t="nathanmarz Specter solves such a fundamental, universal problem that I do believe it makes Clojure much stronger, so in that sense it would make sense to be distributed with the language"><y>#</y><d>2016-10-28</d><h>13:01</h><w>nathanmarz</w>Specter solves such a fundamental, universal problem that I do believe it makes Clojure much stronger, so in that sense it would make sense to be distributed with the language</z><z id="t1477659910" t="nathanmarz ultimately though it&apos;s not up to me what goes into core"><y>#</y><d>2016-10-28</d><h>13:05</h><w>nathanmarz</w>ultimately though it&apos;s not up to me what goes into core</z><z id="t1477895149" t="kzeidler Specter looks really cool, but I can&apos;t figure out how to import it. How do I actually use the library in a namespace?"><y>#</y><d>2016-10-31</d><h>06:25</h><w>kzeidler</w>Specter looks really cool, but I can&apos;t figure out how to import it. How do I actually use the library in a namespace?</z><z id="t1477895176" t="kzeidler Preferably without the prefix, as demonstrated in the examples"><y>#</y><d>2016-10-31</d><h>06:26</h><w>kzeidler</w>Preferably without the prefix, as demonstrated in the examples</z><z id="t1477895335" t="aengelberg @kzeidler: (use &apos;com.rpl.specter) ?"><y>#</y><d>2016-10-31</d><h>06:28</h><w>aengelberg</w>@kzeidler: <code>(use &apos;com.rpl.specter)</code>?</z><z id="t1477895474" t="kzeidler I get: `Only :refer-clojure, :require, :require-macros, :use, :use-macros, and :import libspecs supported at line 1 src/succulent/core.cljs"><y>#</y><d>2016-10-31</d><h>06:31</h><w>kzeidler</w>I get: `Only :refer-clojure, :require, :require-macros, :use, :use-macros, and :import libspecs supported at line 1 src/succulent/core.cljs</z><z id="t1477895560" t="kzeidler aha, taking it out of the (ns ...) s-expr does work though"><y>#</y><d>2016-10-31</d><h>06:32</h><w>kzeidler</w>aha, taking it out of the (ns ...) s-expr does work though</z><z id="t1477895613" t="kzeidler What&apos;s the idiomatic way to put this in my code? Just place it after the ns definition?"><y>#</y><d>2016-10-31</d><h>06:33</h><w>kzeidler</w>What&apos;s the idiomatic way to put this in my code? Just place it after the ns definition?</z><z id="t1477895907" t="kzeidler Spoke too soon. It compiled with your suggestion, but isn&apos;t able to find a definition for any of its functions"><y>#</y><d>2016-10-31</d><h>06:38</h><w>kzeidler</w>Spoke too soon. It compiled with your suggestion, but isn&apos;t able to find a definition for any of its functions</z><z id="t1477895921" t="kzeidler And in the repl: (use &apos;com.rpl.specter) clojure.lang.ExceptionInfo: Only [lib.ns :only (names)] and optionally :rename {from to} specs supported in :use / :use-macros; offending spec: [com.rpl.specter] at line 1 &lt;cljs repl&gt; {:file &quot;&lt;cljs repl&gt;&quot;, :line 1, :column 1, :root-source-info {:source-type :fragment, :source-form (ns succulent.core (:use [com.rpl.specter]))}, :tag :cljs/analysis-error}"><y>#</y><d>2016-10-31</d><h>06:38</h><w>kzeidler</w>And in the repl: (use &apos;com.rpl.specter)
clojure.lang.ExceptionInfo: Only [lib.ns :only (names)] and optionally <code>:rename {from to}</code> specs supported in :use / :use-macros; offending spec: [com.rpl.specter] at line 1 &lt;cljs repl&gt; {:file &quot;&lt;cljs repl&gt;&quot;, :line 1, :column 1, :root-source-info {:source-type :fragment, :source-form (ns succulent.core (:use [com.rpl.specter]))}, :tag :cljs/analysis-error}</z><z id="t1477914399" t="nathanmarz @kzeidler in clojurescript you can&apos;t do use , you have to do require"><y>#</y><d>2016-10-31</d><h>11:46</h><w>nathanmarz</w>@kzeidler in clojurescript you can&apos;t do <code>use</code>, you have to do <code>require</code></z><z id="t1477914505" t="nathanmarz if you don&apos;t want the prefix in cljs you have to enumerate every symbol you want to import, e.g. (require &apos;[com.rpl.specter :refer [ALL srange keypath]])"><y>#</y><d>2016-10-31</d><h>11:48</h><w>nathanmarz</w>if you don&apos;t want the prefix in cljs you have to enumerate every symbol you want to import, e.g. <code>(require &apos;[com.rpl.specter :refer [ALL srange keypath]])</code></z><z id="t1478016055" t="joshkh i noticed that adding specter to my clojurescript project increased the compiled file size from 550kb to 830kb after google closure advanced optimization. that&apos;s quite an increase, and i&apos;m only referencing [select ALL] . does that seem normal?"><y>#</y><d>2016-11-01</d><h>16:00</h><w>joshkh</w>i noticed that adding specter to my clojurescript project increased the compiled file size from 550kb to 830kb after google closure advanced optimization. that&apos;s quite an increase, and i&apos;m only referencing <code>[select ALL]</code>. does that seem normal?</z><z id="t1478017108" t="nathanmarz @joshkh I&apos;m not familiar enough with cljs to understand those details"><y>#</y><d>2016-11-01</d><h>16:18</h><w>nathanmarz</w>@joshkh I&apos;m not familiar enough with cljs to understand those details</z><z id="t1478017129" t="nathanmarz any idea what the increase is? the compiled js for specter?"><y>#</y><d>2016-11-01</d><h>16:18</h><w>nathanmarz</w>any idea what the increase is? the compiled js for specter?</z><z id="t1478017277" t="joshkh i&apos;ll investigate. it&apos;s a bit hard to tell at first glance because advanced optimization munges everything into one garbled file."><y>#</y><d>2016-11-01</d><h>16:21</h><w>joshkh</w>i&apos;ll investigate. it&apos;s a bit hard to tell at first glance because advanced optimization munges everything into one garbled file.</z><z id="t1478017299" t="joshkh i&apos;ll try the same with simple optimization and see where it gets me 🙂"><y>#</y><d>2016-11-01</d><h>16:21</h><w>joshkh</w>i&apos;ll try the same with simple optimization and see where it gets me <b>🙂</b></z><z id="t1478017305" t="nathanmarz ok, thanks"><y>#</y><d>2016-11-01</d><h>16:21</h><w>nathanmarz</w>ok, thanks</z><z id="t1478017313" t="nathanmarz might be a good idea to open an issue on this to track it"><y>#</y><d>2016-11-01</d><h>16:21</h><w>nathanmarz</w>might be a good idea to open an issue on this to track it</z><z id="t1478017379" t="joshkh gotcha, will do"><y>#</y><d>2016-11-01</d><h>16:22</h><w>joshkh</w>gotcha, will do</z><z id="t1478018239" t="shooodooken Having some issues transforming map: I expected the output to be {:parent {:grandchild {}}} (require &apos;[com.rpl.specter.macros :as spm]) (require &apos;[com.rpl.specter :as sp]) (spm/transform [:parent sp/ALL] #(get-in % [:child]) {:parent {:child {:grandchild {}}}}) =&gt; {:parent {nil nil}} Running this will get me close to the desired output: (spm/transform [:parent sp/ALL] #(get-in % [:child]) {:parent [{:child {:grandchild {}}}]}) =&gt; {:parent [{:grandchild {}}]}"><y>#</y><d>2016-11-01</d><h>16:37</h><w>shooodooken</w>Having some issues transforming map:
I expected the output to be <code>{:parent {:grandchild {}}}</code>

<pre>(require &apos;[com.rpl.specter.macros :as spm])
(require &apos;[com.rpl.specter :as sp])

(spm/transform [:parent sp/ALL] #(get-in % [:child]) {:parent {:child {:grandchild {}}}})
=&gt; {:parent {nil nil}}</pre>

Running this will get me close to the desired output:

<pre>(spm/transform [:parent sp/ALL] #(get-in % [:child]) {:parent [{:child {:grandchild {}}}]})
=&gt; {:parent [{:grandchild {}}]}</pre></z><z id="t1478018270" t="shooodooken how can i achieve the desired result without changing the datastructure?"><y>#</y><d>2016-11-01</d><h>16:37</h><w>shooodooken</w>how can i achieve the desired result without changing the datastructure?</z><z id="t1478021099" t="shooodooken reading the docs for ALL ({:doc &quot;Navigate to every element of the collection. For maps navigates to a vector of [key value] .&quot;}) tells me I&apos;ll have to deconstruct &amp; reconstruct data structure manually."><y>#</y><d>2016-11-01</d><h>17:24</h><w>shooodooken</w>reading the docs for ALL ({:doc &quot;Navigate to every element of the collection. For maps navigates to
          a vector of <code>[key value]</code>.&quot;}) tells me I&apos;ll have to deconstruct &amp; reconstruct data structure manually.</z><z id="t1478025552" t="nathanmarz @shooodooken is this what you want? (transform :parent :child {:parent {:child {:grandchild {}}}}) "><y>#</y><d>2016-11-01</d><h>18:39</h><w>nathanmarz</w>@shooodooken is this what you want?
<pre>(transform :parent :child  {:parent {:child {:grandchild {}}}})
</pre></z><z id="t1478036029" t="shooodooken yes sir, thank you. (the real code was bit more tricky but dropping the ALL was ultimately what I needed)"><y>#</y><d>2016-11-01</d><h>21:33</h><w>shooodooken</w>yes sir, thank you. (the real code was bit more tricky but dropping the ALL was ultimately what I needed)</z><z id="t1478506573" t="tianshu Hi, I&apos;m new to specter, I&apos;m very exciting about specter. And I&apos;m trying to use it, does specter ship some features like threading macros? I want to use specter to do something following: (-&gt;&gt; {&quot;20161106020&quot; {:3010 {} :3006 {:3 &quot;3.10&quot; :1 &quot;3.55&quot; :0 &quot;18.00&quot;}} &quot;20161106021&quot; {:3010 {:3 &quot;3.00&quot;} :3006 {:3 &quot;2.00&quot;}}} (map (fn [kv] (-&gt;&gt; (peek kv) (map (fn [kv1] (count (peek kv1)))) (reduce +)))) (reduce *)) what I want is simplify this piece of code with specter. wonder if someone could give me an example. appreciate for any help, thanks!"><y>#</y><d>2016-11-07</d><h>08:16</h><w>tianshu</w>Hi, I&apos;m new to specter, I&apos;m very exciting about specter. 
And I&apos;m trying to use it, does specter ship some features like threading macros? 
I want to use specter to do something following:
<pre>(-&gt;&gt; {&quot;20161106020&quot; {:3010 {}
                       :3006 {:3 &quot;3.10&quot;
                              :1 &quot;3.55&quot;
                              :0 &quot;18.00&quot;}}
        &quot;20161106021&quot; {:3010 {:3 &quot;3.00&quot;}
                       :3006 {:3 &quot;2.00&quot;}}}

       (map (fn [kv]
              (-&gt;&gt; (peek kv)
                   (map (fn [kv1]
                         (count (peek kv1))))
                   (reduce +))))
       (reduce *))
</pre>
what I want is simplify this piece of code with specter. wonder if someone could give me an example.
appreciate for any help, thanks!</z><z id="t1478522421" t="nathanmarz @doglooksgood here&apos;s one way to do it with specter: (defn sum [args] (reduce + args)) (reduce * (traverse [MAP-VALS (subselect MAP-VALS (view count)) (view sum)] data)) "><y>#</y><d>2016-11-07</d><h>12:40</h><w>nathanmarz</w>@doglooksgood here&apos;s one way to do it with specter:
<pre>(defn sum [args] (reduce + args))
(reduce * (traverse [MAP-VALS (subselect MAP-VALS (view count)) (view sum)] data))
</pre></z><z id="t1478522460" t="nathanmarz if there were a traversed navigator builder along the lines of transformed , you could do it like this: (reduce * (traverse [MAP-VALS (traversed [MAP-VALS (view count)] +)] data)) "><y>#</y><d>2016-11-07</d><h>12:41</h><w>nathanmarz</w>if there were a <code>traversed</code> navigator builder along the lines of <code>transformed</code>, you could do it like this:
<pre>(reduce * (traverse [MAP-VALS (traversed [MAP-VALS (view count)] +)] data))
</pre></z><z id="t1478522507" t="nathanmarz the former (which currently works) does materialize some intermediate subsequences, while the latter would not, so the latter would be close to optimal efficiency"><y>#</y><d>2016-11-07</d><h>12:41</h><w>nathanmarz</w>the former (which currently works) does materialize some intermediate subsequences, while the latter would not, so the latter would be close to optimal efficiency</z><z id="t1478522775" t="nathanmarz (defdynamicnav traversed &quot;Navigates to a view of the current value by transforming with a reduction over the specified traversal.&quot; [path reduce-fn] (late-bound-nav [late (late-path path) late-fn reduce-fn] (select* [this structure next-fn] (next-fn (reduce late-fn (compiled-traverse late structure)))) (transform* [this structure next-fn] (next-fn (reduce late-fn (compiled-traverse late structure))) ))) "><y>#</y><d>2016-11-07</d><h>12:46</h><w>nathanmarz</w><pre>(defdynamicnav traversed
  &quot;Navigates to a view of the current value by transforming with a reduction over
   the specified traversal.&quot;
  [path reduce-fn]
  (late-bound-nav [late (late-path path)
                   late-fn reduce-fn]
    (select* [this structure next-fn]
      (next-fn (reduce late-fn (compiled-traverse late structure))))
    (transform* [this structure next-fn]
      (next-fn (reduce late-fn (compiled-traverse late structure)))
      )))
</pre></z><z id="t1478522782" t="nathanmarz I&apos;ll add that to the next version"><y>#</y><d>2016-11-07</d><h>12:46</h><w>nathanmarz</w>I&apos;ll add that to the next version</z><z id="t1478536097" t="nathanmarz Released 0.13.1 https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><y>#</y><d>2016-11-07</d><h>16:28</h><w>nathanmarz</w>Released 0.13.1 <a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md" target="_blank">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></z><z id="t1478546683" t="danielcompton @nathanmarz is this you? http://rpl.com/"><y>#</y><d>2016-11-07</d><h>19:24</h><w>danielcompton</w>@nathanmarz is this you? <a href="http://rpl.com/" target="_blank">http://rpl.com/</a></z><z id="t1478547117" t="nathanmarz @danielcompton no lol"><y>#</y><d>2016-11-07</d><h>19:31</h><w>nathanmarz</w>@danielcompton no lol</z><z id="t1478547125" t="nathanmarz I haven&apos;t put up a website yet"><y>#</y><d>2016-11-07</d><h>19:32</h><w>nathanmarz</w>I haven&apos;t put up a website yet</z><z id="t1478591782" t="levitanong It would suck for renaissance partners, ltd. if they decided to make a clojure library, and found out they couldn’t use the com.rpl namespace 😛"><y>#</y><d>2016-11-08</d><h>07:56</h><w>levitanong</w>It would suck for renaissance partners, ltd. if they decided to make a clojure library, and found out they couldn’t use the <code>com.rpl</code> namespace <b>😛</b></z><z id="t1478622908" t="zane Can anyone think of what the root cause for intermittent java.lang.ClassCastException: clojure.lang.Var$Unbound cannot be cast to com.rpl.specter.MutableCell would be?"><y>#</y><d>2016-11-08</d><h>16:35</h><w>zane</w>Can anyone think of what the root cause for intermittent <code>java.lang.ClassCastException: clojure.lang.Var$Unbound cannot be cast to com.rpl.specter.MutableCell</code> would be?</z><z id="t1478623720" t="nathanmarz @zane what version of Specter?"><y>#</y><d>2016-11-08</d><h>16:48</h><w>nathanmarz</w>@zane what version of Specter?</z><z id="t1478623730" t="nathanmarz and what&apos;s the full stack trace?"><y>#</y><d>2016-11-08</d><h>16:48</h><w>nathanmarz</w>and what&apos;s the full stack trace?</z><z id="t1478625000" t="zane @nathanmarz: [com.rpl/specter &quot;0.12.0&quot;]"><y>#</y><d>2016-11-08</d><h>17:10</h><w>zane</w>@nathanmarz: <code>[com.rpl/specter &quot;0.12.0&quot;]</code></z><z id="t1478625010" t="zane I&apos;ll get you the stack trace. One moment."><y>#</y><d>2016-11-08</d><h>17:10</h><w>zane</w>I&apos;ll get you the stack trace. One moment.</z><z id="t1478625725" t="zane @nathanmarz, the Specter part of the stack trace is just: com.rpl.specter.impl/get-cell impl.clj: 469 java.lang.ClassCastException: clojure.lang.Var$Unbound cannot be cast to com.rpl.specter.MutableCell "><y>#</y><d>2016-11-08</d><h>17:22</h><w>zane</w>@nathanmarz, the Specter part of the stack trace is just:
<pre>com.rpl.specter.impl/get-cell                 impl.clj:  469
java.lang.ClassCastException: clojure.lang.Var$Unbound cannot be cast to com.rpl.specter.MutableCell
</pre></z><z id="t1478629677" t="bfabry we get those all the time as well using specter in a distributed env. I suspect it&apos;s got something to do with caching paths"><y>#</y><d>2016-11-08</d><h>18:27</h><w>bfabry</w>we get those all the time as well using specter in a distributed env. I suspect it&apos;s got something to do with caching paths</z><z id="t1478632902" t="nathanmarz there was a bug in 0.11.2 with that exception related to aot compilation that was fixed in 0.12.0"><y>#</y><d>2016-11-08</d><h>19:21</h><w>nathanmarz</w>there was a bug in 0.11.2 with that exception related to aot compilation that was fixed in 0.12.0</z><z id="t1478632916" t="nathanmarz @zane @bfabry I&apos;ll need a reproducible test case"><y>#</y><d>2016-11-08</d><h>19:21</h><w>nathanmarz</w>@zane @bfabry I&apos;ll need a reproducible test case</z><z id="t1478632950" t="bfabry you won&apos;t be getting one from me 😛"><y>#</y><d>2016-11-08</d><h>19:22</h><w>bfabry</w>you won&apos;t be getting one from me <b>😛</b></z><z id="t1478632958" t="bfabry haha"><y>#</y><d>2016-11-08</d><h>19:22</h><w>bfabry</w>haha</z><z id="t1478633019" t="zane Yeah, I wish. It&apos;s very intermittent. I haven&apos;t found a way to reproduce it reliably yet."><y>#</y><d>2016-11-08</d><h>19:23</h><w>zane</w>Yeah, I wish. It&apos;s very intermittent. I haven&apos;t found a way to reproduce it reliably yet.</z><z id="t1478633049" t="bfabry the error happens for us in an environment that&apos;s serializing classes and sending them over the wire, deserializing and executing. it&apos;s way through the looking glass as far as me actually expecting anyone to support it goes. fortunately by virtue of it being distributed it also retries, and then it starts working. so it&apos;s way down on my list of things to care about"><y>#</y><d>2016-11-08</d><h>19:24</h><w>bfabry</w>the error happens for us in an environment that&apos;s serializing classes and sending them over the wire, deserializing and executing. it&apos;s way through the looking glass as far as me actually expecting anyone to support it goes. fortunately by virtue of it being distributed it also retries, and then it starts working. so it&apos;s way down on my list of things to care about</z><z id="t1478633066" t="nathanmarz The section of the code where it was coming from in the old bug is here: https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L233"><y>#</y><d>2016-11-08</d><h>19:24</h><w>nathanmarz</w>The section of the code where it was coming from in the old bug is here: <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L233" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L233</a></z><z id="t1478633082" t="nathanmarz as you can see, it now catches ClassCastException there"><y>#</y><d>2016-11-08</d><h>19:24</h><w>nathanmarz</w>as you can see, it now catches ClassCastException there</z><z id="t1478633150" t="nathanmarz only possibility is bound? is returning true for clojure.lang.Var$Unbound"><y>#</y><d>2016-11-08</d><h>19:25</h><w>nathanmarz</w>only possibility is <code>bound?</code> is returning true for <code>clojure.lang.Var$Unbound</code></z><z id="t1478633167" t="nathanmarz @zane is the context of these exceptions also a distributed env?"><y>#</y><d>2016-11-08</d><h>19:26</h><w>nathanmarz</w>@zane is the context of these exceptions also a distributed env?</z><z id="t1478633383" t="zane I might needs some help understanding what you mean by a &quot;distributed env&quot;. It&apos;s a web server with multiple threads?"><y>#</y><d>2016-11-08</d><h>19:29</h><w>zane</w>I might needs some help understanding what you mean by a &quot;distributed env&quot;. It&apos;s a web server with multiple threads?</z><z id="t1478633878" t="nathanmarz ok, that&apos;s good to know"><y>#</y><d>2016-11-08</d><h>19:37</h><w>nathanmarz</w>ok, that&apos;s good to know</z><z id="t1478633902" t="nathanmarz by distributed env I mean something like Hadoop where you serialize/deserialize objects"><y>#</y><d>2016-11-08</d><h>19:38</h><w>nathanmarz</w>by distributed env I mean something like Hadoop where you serialize/deserialize objects</z><z id="t1478634029" t="zane Oh, no."><y>#</y><d>2016-11-08</d><h>19:40</h><w>zane</w>Oh, no.</z><z id="t1478634030" t="zane Nothing like that."><y>#</y><d>2016-11-08</d><h>19:40</h><w>zane</w>Nothing like that.</z><z id="t1478700247" t="nathanmarz @zane @bfabry found a race condition in that code that could cause the exception you were seeing, it&apos;s fixed in master"><y>#</y><d>2016-11-09</d><h>14:04</h><w>nathanmarz</w>@zane @bfabry found a race condition in that code that could cause the exception you were seeing, it&apos;s fixed in master</z><z id="t1478704685" t="zane Oh wow. Thanks, Nathan!"><y>#</y><d>2016-11-09</d><h>15:18</h><w>zane</w>Oh wow. Thanks, Nathan!</z><z id="t1478742077" t="tianshu @nathanmarz Thanks for the help. It&apos;s very useful!"><y>#</y><d>2016-11-10</d><h>01:41</h><w>tianshu</w>@nathanmarz Thanks for the help. It&apos;s very useful!</z><z id="t1478771459" t="fredokun Hi there. Lately, I pretty much enjoy writing specter one-liners, neat!"><y>#</y><d>2016-11-10</d><h>09:50</h><w>fredokun</w>Hi there. Lately, I pretty much enjoy writing specter one-liners, neat!</z><z id="t1478771622" t="fredokun I have a probably numb question but is it possible in (transform PATH f val) to make the transformation somewhat depend on the application of val. I give an example (on which I stumbled multiple times)... Consider a map like this: `"><y>#</y><d>2016-11-10</d><h>09:53</h><w>fredokun</w>I have a probably numb question but is it possible in <code>(transform PATH f val)</code> to make 
the transformation somewhat depend on the application of val.

I give an example (on which I stumbled multiple times)...
Consider a map like this:

<code></code>`</z><z id="t1478771745" t="fredokun { :a 2 :b 1 :c 3} And I would like to e.g. decrement all VALS and, at the same time, remove all the pairs whose value gets to 0, i.e. : `"><y>#</y><d>2016-11-10</d><h>09:55</h><w>fredokun</w><pre>{ :a 2 :b 1 :c 3}
</pre>
And I would like to e.g. decrement all VALS and, at the same time, 
remove all the pairs whose value gets to 0, i.e. :

<code></code>`</z><z id="t1478771751" t="fredokun "><y>#</y><d>2016-11-10</d><h>09:55</h><w>fredokun</w><pre></pre></z><z id="t1478771855" t="fredokun (sorry for the very bad slack edits, I&apos;m new here ;-)... So I would like to obtain : { :a 1 :c 3} and :b is no more ... Thanks in advance (and sorry again for the awfully bad typing above)."><y>#</y><d>2016-11-10</d><h>09:57</h><w>fredokun</w>(sorry for the very bad slack edits, I&apos;m new here ;-)...

So I would like to obtain :

<code>{ :a 1 :c 3}</code>   and <code>:b</code> is no more ...

Thanks in advance (and sorry again for the awfully bad typing above).</z><z id="t1478771915" t="fredokun (plus I see that it&apos;s the middle of the night in the U.S. and no one&apos;s here ;-). See you later then !"><y>#</y><d>2016-11-10</d><h>09:58</h><w>fredokun</w>(plus I see that it&apos;s the middle of the night in the U.S. and no one&apos;s here ;-).  See you later then !</z><z id="t1478780612" t="fredokun (oops) To rephrase myself: is it possible in (transform PATH f val) to make the transformation somewhat depend on the application of f ?"><y>#</y><d>2016-11-10</d><h>12:23</h><w>fredokun</w>(oops)
To rephrase myself: is it possible in <code>(transform PATH f val)</code> to make
the transformation somewhat depend on the application of <code>f</code> ?</z><z id="t1478781321" t="nathanmarz @fredokun there&apos;s discussion of a feature for that here: https://github.com/nathanmarz/specter/issues/117"><y>#</y><d>2016-11-10</d><h>12:35</h><w>nathanmarz</w>@fredokun there&apos;s discussion of a feature for that here: <a href="https://github.com/nathanmarz/specter/issues/117" target="_blank">https://github.com/nathanmarz/specter/issues/117</a></z><z id="t1478781328" t="nathanmarz you could always make that navigator yourself"><y>#</y><d>2016-11-10</d><h>12:35</h><w>nathanmarz</w>you could always make that navigator yourself</z><z id="t1478781360" t="nathanmarz keypath , MAP-VALS , and ALL could have that functionality"><y>#</y><d>2016-11-10</d><h>12:36</h><w>nathanmarz</w><code>keypath</code>, <code>MAP-VALS</code>, and <code>ALL</code> could have that functionality</z><z id="t1478798160" t="fredokun thanks for the reply I will look at the issue and try to do something !"><y>#</y><d>2016-11-10</d><h>17:16</h><w>fredokun</w>thanks for the reply I will look at the issue and try to do something !</z><z id="t1478801779" t="zane I wish specs were … Specter-aware, if that makes sense."><y>#</y><d>2016-11-10</d><h>18:16</h><w>zane</w>I wish specs were … Specter-aware, if that makes sense.</z><z id="t1478801813" t="zane Haven&apos;t completely thought this through."><y>#</y><d>2016-11-10</d><h>18:16</h><w>zane</w>Haven&apos;t completely thought this through.</z><z id="t1478801829" t="zane But it would be nice to be able to use Specter selectors in specs rather than traditional keypaths."><y>#</y><d>2016-11-10</d><h>18:17</h><w>zane</w>But it would be nice to be able to use Specter selectors in specs rather than traditional keypaths.</z><z id="t1478865307" t="nathanmarz @zane I haven&apos;t dug that much into Spec yet, care to show an example of what you mean?"><y>#</y><d>2016-11-11</d><h>11:55</h><w>nathanmarz</w>@zane I haven&apos;t dug that much into Spec yet, care to show an example of what you mean?</z><z id="t1478871436" t="imre hi all"><y>#</y><d>2016-11-11</d><h>13:37</h><w>imre</w>hi all</z><z id="t1478871489" t="imre I would be grateful if someone could give me advice on building paths dynamically using a navigator in 0.13.1"><y>#</y><d>2016-11-11</d><h>13:38</h><w>imre</w>I would be grateful if someone could give me advice on building paths dynamically using a navigator in 0.13.1</z><z id="t1478871507" t="imre my navigator is like this"><y>#</y><d>2016-11-11</d><h>13:38</h><w>imre</w>my navigator is like this</z><z id="t1478871511" t="imre (sp/defnav EID [eid] (select* [{:keys [eid]} structure next-fn] (eid-nav-select* eid structure next-fn)) (transform* [{:keys [eid]} structure next-fn] (eid-nav-transform* eid structure next-fn)))"><y>#</y><d>2016-11-11</d><h>13:38</h><w>imre</w><pre>(sp/defnav
  EID
  [eid]
  (select* [{:keys [eid]} structure next-fn] (eid-nav-select* eid structure next-fn))
  (transform* [{:keys [eid]} structure next-fn] (eid-nav-transform* eid structure next-fn)))</pre></z><z id="t1478871580" t="imre and this is how I try to build a path from a list of keys"><y>#</y><d>2016-11-11</d><h>13:39</h><w>imre</w>and this is how I try to build a path from a list of keys</z><z id="t1478871583" t="imre (defn- specter-path [ks] (map #(if (u/uuid? %) (EID %) %) ks))"><y>#</y><d>2016-11-11</d><h>13:39</h><w>imre</w><pre>(defn- specter-path [ks]
  (map #(if (u/uuid? %)
          (EID %)
          %)
       ks))</pre></z><z id="t1478871668" t="imre and getting a Cannot statically combine sequential when not in nav pos error when invoking specter-path"><y>#</y><d>2016-11-11</d><h>13:41</h><w>imre</w>and getting a <code>Cannot statically combine sequential when not in nav pos</code> error when invoking specter-path</z><z id="t1478872140" t="imre well actually the error comes when I try to use the path in a call to setval"><y>#</y><d>2016-11-11</d><h>13:49</h><w>imre</w>well actually the error comes when I try to use the path in a call to <code>setval</code></z><z id="t1478872927" t="imre well, I managed to fix it however I don&apos;t exactly know why it failed."><y>#</y><d>2016-11-11</d><h>14:02</h><w>imre</w>well, I managed to fix it however I don&apos;t exactly know why it failed.</z><z id="t1478872936" t="imre so the calling code looked like this:"><y>#</y><d>2016-11-11</d><h>14:02</h><w>imre</w>so the calling code looked like this:</z><z id="t1478872956" t="imre (-&gt; (concat [:_entity] ks) specter-path (sp/setval value stored-entity)) "><y>#</y><d>2016-11-11</d><h>14:02</h><w>imre</w><pre>(-&gt; (concat [:_entity] ks)
          specter-path
          (sp/setval value stored-entity))
</pre></z><z id="t1478873038" t="imre but when I defined this function (defn- setval [apath aval structure] (sp/setval apath aval structure)) and replaced sp/setval with setval inside the threading macro, it worked"><y>#</y><d>2016-11-11</d><h>14:03</h><w>imre</w>but when I defined this function
<pre>(defn- setval [apath aval structure]
  (sp/setval apath aval structure))
</pre>
and replaced <code>sp/setval</code> with <code>setval</code> inside the threading macro, it worked</z><z id="t1478873538" t="nathanmarz @imre that looks like a bug"><y>#</y><d>2016-11-11</d><h>14:12</h><w>nathanmarz</w>@imre that looks like a bug</z><z id="t1478873550" t="nathanmarz can you open an issue on github for it?"><y>#</y><d>2016-11-11</d><h>14:12</h><w>nathanmarz</w>can you open an issue on github for it?</z><z id="t1478873575" t="nathanmarz you can workaround it by doing (let [p (specter-path ...)] (setval p ...))"><y>#</y><d>2016-11-11</d><h>14:12</h><w>nathanmarz</w>you can workaround it by doing <code>(let [p (specter-path ...)] (setval p ...))</code></z><z id="t1478873629" t="imre thanks @nathanmarz I&apos;ll open one - is it okay if I just put this chatlog in there?"><y>#</y><d>2016-11-11</d><h>14:13</h><w>imre</w>thanks @nathanmarz I&apos;ll open one - is it okay if I just put this chatlog in there?</z><z id="t1478873745" t="nathanmarz sure"><y>#</y><d>2016-11-11</d><h>14:15</h><w>nathanmarz</w>sure</z><z id="t1478873864" t="imre https://github.com/nathanmarz/specter/issues/157 added, thanks again!"><y>#</y><d>2016-11-11</d><h>14:17</h><w>imre</w><a href="https://github.com/nathanmarz/specter/issues/157" target="_blank">https://github.com/nathanmarz/specter/issues/157</a> added, thanks again!</z><z id="t1478873876" t="imre and btw specter absolutely rocks"><y>#</y><d>2016-11-11</d><h>14:17</h><w>imre</w>and btw specter absolutely rocks</z><z id="t1478875141" t="nathanmarz thanks"><y>#</y><d>2016-11-11</d><h>14:39</h><w>nathanmarz</w>thanks</z><z id="t1479220428" t="nathanmarz in a transform, view replaces whatever is at that point with the result of the view function before continuing the transform"><y>#</y><d>2016-11-15</d><h>14:33</h><w>nathanmarz</w>in a transform, <code>view</code> replaces whatever is at that point with the result of the view function before continuing the transform</z><z id="t1479220618" t="achesnais I got that – but here, shouldn’t :value and (view :value) be equivalent?"><y>#</y><d>2016-11-15</d><h>14:36</h><w>achesnais</w>I got that – but here, shouldn’t <code>:value</code> and <code>(view :value)</code> be equivalent?</z><z id="t1479220654" t="achesnais (your lib is so great by the way)"><y>#</y><d>2016-11-15</d><h>14:37</h><w>achesnais</w>(your lib is so great by the way)</z><z id="t1479221174" t="nathanmarz no, :value on its own navigates to the subvalue and continues the transform from there"><y>#</y><d>2016-11-15</d><h>14:46</h><w>nathanmarz</w>no, <code>:value</code> on its own navigates to the subvalue and continues the transform from there</z><z id="t1479221221" t="nathanmarz (transform :a afn data) is the same as (update data :a afn)"><y>#</y><d>2016-11-15</d><h>14:47</h><w>nathanmarz</w><code>(transform :a afn data)</code> is the same as <code>(update data :a afn)</code></z><z id="t1479228956" t="achesnais Ohhh"><y>#</y><d>2016-11-15</d><h>16:55</h><w>achesnais</w>Ohhh</z><z id="t1479228957" t="achesnais okay"><y>#</y><d>2016-11-15</d><h>16:55</h><w>achesnais</w>okay</z><z id="t1479228960" t="achesnais I think I got it"><y>#</y><d>2016-11-15</d><h>16:56</h><w>achesnais</w>I think I got it</z><z id="t1479228966" t="achesnais Thank you!"><y>#</y><d>2016-11-15</d><h>16:56</h><w>achesnais</w>Thank you!</z><z id="t1479341629" t="wei is there a way to get the next/previous element of an collection in a transformation? [1 2 3] =&gt; [[1 0] [2 1] [3 2]]"><y>#</y><d>2016-11-17</d><h>00:13</h><w>wei</w>is there a way to get the next/previous element of an collection in a transformation? <code>[1 2 3]</code> =&gt; <code>[[1 0] [2 1] [3 2]]</code></z><z id="t1479342778" t="wei use case + hacky solution: ((fn [xs] (concat [(first xs)] (-&gt;&gt; (partition 2 1 xs) (map (fn [[prev cur]] (assoc cur :prev prev)))))) [{:id 1} {:id 2} {:id 3} {:id 4}]) =&gt; ({:id 1} {:id 2, :prev {:id 1}} {:id 3, :prev {:id 2}} {:id 4, :prev {:id 3}}) "><y>#</y><d>2016-11-17</d><h>00:32</h><w>wei</w>use case + hacky solution: <pre>((fn [xs]
   (concat [(first xs)]
           (-&gt;&gt; (partition 2 1 xs)
                (map (fn [[prev cur]] (assoc cur :prev prev))))))
 [{:id 1} {:id 2} {:id 3} {:id 4}])
=&gt; ({:id 1} {:id 2, :prev {:id 1}} {:id 3, :prev {:id 2}} {:id 4, :prev {:id 3}})
</pre></z><z id="t1479498105" t="nathanmarz @wei you can use com.rpl.specter.zipper for that"><y>#</y><d>2016-11-18</d><h>19:41</h><w>nathanmarz</w>@wei you can use com.rpl.specter.zipper for that</z><z id="t1479933356" t="caio failing on the following providepath : (sp/declarepath map-walker) (sp/providepath map-walker [(sp/walker map?) (sp/continue-then-stay sp/MAP-VALS map-walker)]) "><y>#</y><d>2016-11-23</d><h>20:35</h><w>caio</w>failing on the following <code>providepath</code>:
<pre>(sp/declarepath map-walker)
(sp/providepath map-walker
                 [(sp/walker map?)
                  (sp/continue-then-stay sp/MAP-VALS map-walker)])
</pre></z><z id="t1479934907" t="nathanmarz @caio what version of specter?"><y>#</y><d>2016-11-23</d><h>21:01</h><w>nathanmarz</w>@caio what version of specter?</z><z id="t1479934919" t="nathanmarz are you doing aot compilation?"><y>#</y><d>2016-11-23</d><h>21:01</h><w>nathanmarz</w>are you doing aot compilation?</z><z id="t1479936670" t="caio [com.rpl/specter “0 .13.1”]`"><y>#</y><d>2016-11-23</d><h>21:31</h><w>caio</w><code>[com.rpl/specter “0</code>.13.1”]`</z><z id="t1479936699" t="caio yep, I’m doing aot compilation"><y>#</y><d>2016-11-23</d><h>21:31</h><w>caio</w>yep, I’m doing aot compilation</z><z id="t1479937900" t="nathanmarz @caio ok"><y>#</y><d>2016-11-23</d><h>21:51</h><w>nathanmarz</w>@caio ok</z><z id="t1479937908" t="nathanmarz could you open an issue for this? don&apos;t have time to look at it now"><y>#</y><d>2016-11-23</d><h>21:51</h><w>nathanmarz</w>could you open an issue for this? don&apos;t have time to look at it now</z><z id="t1479941807" t="bfabry slightly gross: (sp/transform [:parent sp/ALL #(= :children (first %)) sp/LAST] identity {:parent {:something {}}}) =&gt; {:parent {:something {}}} (sp/transform [:parent sp/ALL #(= :children (first %)) sp/LAST] identity {:parent {:something {} :children 1}}) =&gt; {:parent {:something {}, :children 1}} "><y>#</y><d>2016-11-23</d><h>22:56</h><w>bfabry</w>slightly gross:
<pre>(sp/transform [:parent sp/ALL #(= :children (first %)) sp/LAST] identity {:parent {:something {}}})
=&gt; {:parent {:something {}}}
(sp/transform [:parent sp/ALL #(= :children (first %)) sp/LAST] identity {:parent {:something {} :children 1}})
=&gt; {:parent {:something {}, :children 1}}
</pre></z><z id="t1479942167" t="shooodooken :+1: gives me the correct result so not too gross. looks like i can drop the sp/LAST aswell. (sp/transform [:parent sp/ALL #(= :children (first %))] identity {:parent {:something {}}}) =&gt; {:parent {:something {}}} (sp/transform [:parent sp/ALL #(= :children (first %))] identity {:parent {:something {} :children 1}}) =&gt; {:parent {:something {}, :children 1}}"><y>#</y><d>2016-11-23</d><h>23:02</h><w>shooodooken</w><b>:+1:</b>  gives me the correct result so not too gross. looks like i can drop the sp/LAST aswell.
<pre>(sp/transform [:parent sp/ALL #(= :children (first %))] identity {:parent {:something {}}})
=&gt; {:parent {:something {}}}
(sp/transform [:parent sp/ALL #(= :children (first %))] identity {:parent {:something {} :children 1}})
=&gt; {:parent {:something {}, :children 1}}</pre></z><z id="t1479942191" t="shooodooken i&apos;m still thinking there must be a cleaner way out there"><y>#</y><d>2016-11-23</d><h>23:03</h><w>shooodooken</w>i&apos;m still thinking there must be a cleaner way out there</z><z id="t1479942195" t="bfabry yeah"><y>#</y><d>2016-11-23</d><h>23:03</h><w>bfabry</w>yeah</z></g><g id="s8"><z id="t1479942204" t="shooodooken must be a common enough scenario"><y>#</y><d>2016-11-23</d><h>23:03</h><w>shooodooken</w>must be a common enough scenario</z><z id="t1479942217" t="bfabry I guess it defaults to this way because that&apos;s what update-in does"><y>#</y><d>2016-11-23</d><h>23:03</h><w>bfabry</w>I guess it defaults to this way because that&apos;s what update-in does</z><z id="t1479942432" t="shooodooken i could have sworn i already unsuccessfully tried what i&apos;m about to post.. (sp/transform [:parent sp/ALL (sp/selected? :children)] identity {:parent {:something {} }}) =&gt; {:parent {:something {}}} (sp/transform [:parent sp/ALL (sp/selected? :children)] identity {:parent {:something {},:children 1 }}) =&gt; {:parent {:something {}, :children 1}}"><y>#</y><d>2016-11-23</d><h>23:07</h><w>shooodooken</w>i could have sworn i already unsuccessfully tried what i&apos;m about to post..
<pre>(sp/transform [:parent sp/ALL (sp/selected? :children)] identity {:parent {:something {} }})
=&gt; {:parent {:something {}}}
(sp/transform [:parent sp/ALL (sp/selected? :children)] identity {:parent {:something {},:children 1 }})
=&gt; {:parent {:something {}, :children 1}}</pre></z><z id="t1479942463" t="shooodooken but it works!"><y>#</y><d>2016-11-23</d><h>23:07</h><w>shooodooken</w>but it works!</z><z id="t1479942508" t="bfabry I think the difference is the sp/ALL bit"><y>#</y><d>2016-11-23</d><h>23:08</h><w>bfabry</w>I think the difference is the sp/ALL bit</z><z id="t1479942587" t="shooodooken hmm."><y>#</y><d>2016-11-23</d><h>23:09</h><w>shooodooken</w>hmm.</z><z id="t1479942612" t="shooodooken i&apos;m looking at transform now and thinking maybe i should be wrapping everything in sp/selected? (sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent {:something {},:children 1 }}) =&gt; {:parent {:something {}, :children 1}}"><y>#</y><d>2016-11-23</d><h>23:10</h><w>shooodooken</w>i&apos;m looking at transform now and thinking maybe i should be wrapping everything in sp/selected?

<pre>(sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent {:something {},:children 1 }})
=&gt; {:parent {:something {}, :children 1}}</pre></z><z id="t1479942649" t="shooodooken so if it doesn&apos;t exist, it&apos;s not created. not sure if that&apos;s sane or not?!"><y>#</y><d>2016-11-23</d><h>23:10</h><w>shooodooken</w>so if it doesn&apos;t exist, it&apos;s not created. not sure if that&apos;s sane or not?!</z><z id="t1479942672" t="shooodooken (sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {}) =&gt; {}"><y>#</y><d>2016-11-23</d><h>23:11</h><w>shooodooken</w><pre>(sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {})
=&gt; {}</pre></z><z id="t1479942786" t="bfabry not sure it&apos;s doing what you expect (sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {}) =&gt; {} (sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent nil}) =&gt; {:parent nil} (sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent {:something nil}}) =&gt; {:parent {:something nil}} (sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent {:something nil :children nil}}) =&gt; {:parent {:something nil, :children nil}} (sp/transform [(sp/selected? :parent) (sp/selected? :children)] (constantly &apos;foo) {:parent {:something nil :children nil}}) =&gt; foo "><y>#</y><d>2016-11-23</d><h>23:13</h><w>bfabry</w>not sure it&apos;s doing what you expect
<pre>(sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {})
=&gt; {}
(sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent nil})
=&gt; {:parent nil}
(sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent {:something nil}})
=&gt; {:parent {:something nil}}
(sp/transform [(sp/selected? :parent) (sp/selected? :children)] identity {:parent {:something nil :children nil}})
=&gt; {:parent {:something nil, :children nil}}
(sp/transform [(sp/selected? :parent) (sp/selected? :children)] (constantly &apos;foo) {:parent {:something nil :children nil}})
=&gt; foo
</pre></z><z id="t1479942903" t="shooodooken you are correct...damn.!"><y>#</y><d>2016-11-23</d><h>23:15</h><w>shooodooken</w>you are correct...damn.!</z><z id="t1479943680" t="bfabry found it"><y>#</y><d>2016-11-23</d><h>23:28</h><w>bfabry</w>found it</z><z id="t1479943685" t="bfabry undocumented function, sp/must"><y>#</y><d>2016-11-23</d><h>23:28</h><w>bfabry</w>undocumented function, sp/must</z><z id="t1479943699" t="bfabry (sp/transform [(sp/must :parent)] (constantly &apos;foo) {}) =&gt; {} (sp/transform [(sp/must :parent)] (constantly &apos;foo) {:parent {}}) =&gt; {:parent foo} (sp/transform [(sp/must :parent)] (constantly &apos;foo) {:parent {:children {}}}) =&gt; {:parent foo} (sp/transform [(sp/must :parent)] (constantly &apos;foo) {:parent {:children {} :foo nil }}) =&gt; {:parent foo} (sp/transform [(sp/must :parent) (sp/must :children)] (constantly &apos;foo) {:parent {:children {} :foo nil}}) =&gt; {:parent {:children foo, :foo nil}} (sp/transform [(sp/must :parent) (sp/must :children)] (constantly &apos;foo) {:parent { :foo nil}}) =&gt; {:parent {:foo nil}} "><y>#</y><d>2016-11-23</d><h>23:28</h><w>bfabry</w><pre>(sp/transform [(sp/must :parent)] (constantly &apos;foo) {})
=&gt; {}
(sp/transform [(sp/must :parent)] (constantly &apos;foo) {:parent {}})
=&gt; {:parent foo}
(sp/transform [(sp/must :parent)] (constantly &apos;foo) {:parent {:children {}}})
=&gt; {:parent foo}
(sp/transform [(sp/must :parent)] (constantly &apos;foo) {:parent {:children {} :foo nil
                                                              }})
=&gt; {:parent foo}
(sp/transform [(sp/must :parent) (sp/must :children)] (constantly &apos;foo) {:parent {:children {} :foo nil}})
=&gt; {:parent {:children foo, :foo nil}}
(sp/transform [(sp/must :parent) (sp/must :children)] (constantly &apos;foo) {:parent { :foo nil}})
=&gt; {:parent {:foo nil}}
</pre></z><z id="t1479943768" t="bfabry actually that&apos;s not true, it has a docstring, just not visible from core"><y>#</y><d>2016-11-23</d><h>23:29</h><w>bfabry</w>actually that&apos;s not true, it has a docstring, just not visible from core</z><z id="t1479943775" t="bfabry https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L421"><y>#</y><d>2016-11-23</d><h>23:29</h><w>bfabry</w><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L421" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L421</a></z><z id="t1479943914" t="shooodooken super. that&apos;s the one."><y>#</y><d>2016-11-23</d><h>23:31</h><w>shooodooken</w>super. that&apos;s the one.</z><z id="t1479943918" t="shooodooken thanks a lot"><y>#</y><d>2016-11-23</d><h>23:31</h><w>shooodooken</w>thanks a lot</z><z id="t1479943965" t="bfabry np"><y>#</y><d>2016-11-23</d><h>23:32</h><w>bfabry</w>np</z><z id="t1480008060" t="caio @nathanmarz sorry for the delay. I’ve created the issue here, with a repo that reproduces the bug: https://github.com/nathanmarz/specter/issues/160"><y>#</y><d>2016-11-24</d><h>17:21</h><w>caio</w>@nathanmarz sorry for the delay. I’ve created the issue here, with a repo that reproduces the bug: <a href="https://github.com/nathanmarz/specter/issues/160" target="_blank">https://github.com/nathanmarz/specter/issues/160</a></z><z id="t1480047095" t="nathanmarz @caio thanks"><y>#</y><d>2016-11-25</d><h>04:11</h><w>nathanmarz</w>@caio thanks</z><z id="t1480435132" t="zane Out of curiosity, why is there no MAP-KEYS ?"><y>#</y><d>2016-11-29</d><h>15:58</h><w>zane</w>Out of curiosity, why is there no <code>MAP-KEYS</code>?</z><z id="t1480435196" t="nathanmarz @zane never had a need for it"><y>#</y><d>2016-11-29</d><h>15:59</h><w>nathanmarz</w>@zane never had a need for it</z><z id="t1480435215" t="nathanmarz you can make an inefficient one like this: (def MAP-KEYS (comp-paths ALL FIRST))"><y>#</y><d>2016-11-29</d><h>16:00</h><w>nathanmarz</w>you can make an inefficient one like this: <code>(def MAP-KEYS (comp-paths ALL FIRST))</code></z><z id="t1480440964" t="zane Huh. I might be misunderstanding what&apos;s happening here, but ALL seems to behave strangely on records."><y>#</y><d>2016-11-29</d><h>17:36</h><w>zane</w>Huh. I might be misunderstanding what&apos;s happening here, but <code>ALL</code> seems to behave strangely on records.</z><z id="t1480451243" t="zane Is this user error? (defrecord Test []) (transform [specter/ALL] identity (-&gt;Test)) ;; =&gt; UnsupportedOperationException Can&apos;t create empty: test-ns.Test "><y>#</y><d>2016-11-29</d><h>20:27</h><w>zane</w>Is this user error?
<pre>(defrecord Test [])
(transform [specter/ALL] identity (-&gt;Test))
;; =&gt; UnsupportedOperationException Can&apos;t create empty: test-ns.Test 
</pre></z><z id="t1480451472" t="nathanmarz @zane yes"><y>#</y><d>2016-11-29</d><h>20:31</h><w>nathanmarz</w>@zane yes</z><z id="t1480451512" t="nathanmarz ALL works on vectors, maps, lists, queues"><y>#</y><d>2016-11-29</d><h>20:31</h><w>nathanmarz</w><code>ALL</code> works on vectors, maps, lists, queues</z><z id="t1480454989" t="zane Okay. Thanks, Nathan."><y>#</y><d>2016-11-29</d><h>21:29</h><w>zane</w>Okay. Thanks, Nathan.</z><z id="t1480488545" t="mac @nathanmarz Offtopic: When is you start-up coming out of stealth? There must be a good story related to specter there 🙂"><y>#</y><d>2016-11-30</d><h>06:49</h><w>mac</w>@nathanmarz Offtopic: When is you start-up coming out of stealth? There must be a good story related to specter there <b>🙂</b></z><z id="t1480512139" t="nathanmarz @mac not anytime soon"><y>#</y><d>2016-11-30</d><h>13:22</h><w>nathanmarz</w>@mac not anytime soon</z><z id="t1480512201" t="nathanmarz but yes, I use Specter extremely heavily"><y>#</y><d>2016-11-30</d><h>13:23</h><w>nathanmarz</w>but yes, I use Specter extremely heavily</z><z id="t1480512254" t="nathanmarz in my clojure/west talk I talked a little bit about my usage of it, which involves a lot of graph manipulation"><y>#</y><d>2016-11-30</d><h>13:24</h><w>nathanmarz</w>in my clojure/west talk I talked a little bit about my usage of it, which involves a lot of graph manipulation</z><z id="t1480512375" t="mac @nathanmarz Ok, funny you mention that because I think I might try to use it for something similar in the near future. Have you seen it used for AST manipulation?"><y>#</y><d>2016-11-30</d><h>13:26</h><w>mac</w>@nathanmarz Ok, funny you mention that because I think I might try to use it for something similar in the near future. Have you seen it used for AST manipulation?</z><z id="t1480513891" t="nathanmarz that would be really straightforward with the graph navigators I talked about"><y>#</y><d>2016-11-30</d><h>13:51</h><w>nathanmarz</w>that would be really straightforward with the graph navigators I talked about</z><z id="t1480513917" t="nathanmarz if you&apos;re interested in making an open source version of those navigators I&apos;m happy to talk you through it"><y>#</y><d>2016-11-30</d><h>13:51</h><w>nathanmarz</w>if you&apos;re interested in making an open source version of those navigators I&apos;m happy to talk you through it</z><z id="t1480525592" t="mac @nathanmarz Sounds interesting. Will get to it in a couple of weeks probably."><y>#</y><d>2016-11-30</d><h>17:06</h><w>mac</w>@nathanmarz Sounds interesting. Will get to it in a couple of weeks probably.</z><z id="t1480546910" t="nathanmarz @josh.freckleton it&apos;s possible, but I don&apos;t know if it&apos;s a good idea"><y>#</y><d>2016-11-30</d><h>23:01</h><w>nathanmarz</w>@josh.freckleton it&apos;s possible, but I don&apos;t know if it&apos;s a good idea</z><z id="t1480546923" t="nathanmarz doesn&apos;t feel like navigation to me"><y>#</y><d>2016-11-30</d><h>23:02</h><w>nathanmarz</w>doesn&apos;t feel like navigation to me</z><z id="t1480546939" t="nathanmarz you could make a custom navigator that does that though"><y>#</y><d>2016-11-30</d><h>23:02</h><w>nathanmarz</w>you could make a custom navigator that does that though</z><z id="t1480547105" t="bfabry (apply merge-with into (sp/transform sp/MAP-VALS vector [...])) is pretty terse anyway"><y>#</y><d>2016-11-30</d><h>23:05</h><w>bfabry</w>(apply merge-with into (sp/transform sp/MAP-VALS vector [...])) is pretty terse anyway</z><z id="t1480565640" t="josh.freckleton @nathanmarz @bfabry thanks!"><y>#</y><d>2016-12-01</d><h>04:14</h><w>josh.freckleton</w>@nathanmarz @bfabry thanks!</z><z id="t1480631446" t="caio @nathanmarz I tracked the issue 160 to this line: https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L263"><y>#</y><d>2016-12-01</d><h>22:30</h><w>caio</w>@nathanmarz I tracked the issue 160 to this line: <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L263" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L263</a></z><z id="t1480631449" t="caio removing the type hint solves it. I have no idea what that means ¯\(ツ)/¯"><y>#</y><d>2016-12-01</d><h>22:30</h><w>caio</w>removing the type hint solves it. I have no idea what that means ¯\(ツ)/¯</z><z id="t1480631927" t="caio and when I print the result of the sexp, I get this: #com.rpl.specter.impl.CachedPathInfo{:dynamic? false, :precompiled #object[com.rpl.specter.impl$combine_two_navs$reify__446 0x468dda3e , so it is a cachedpathinfo"><y>#</y><d>2016-12-01</d><h>22:38</h><w>caio</w>and when I print the result of the sexp, I get this: <code>#com.rpl.specter.impl.CachedPathInfo{:dynamic? false, :precompiled #object[com.rpl.specter.impl$combine_two_navs$reify__446 0x468dda3e </code>, so it is a cachedpathinfo</z><z id="t1480633476" t="caio related: http://grokbase.com/t/gg/clojure/14c6sjq7hx/debugging-myclass-cannot-be-cast-to-myclass-exceptions wtf..."><y>#</y><d>2016-12-01</d><h>23:04</h><w>caio</w>related: <a href="http://grokbase.com/t/gg/clojure/14c6sjq7hx/debugging-myclass-cannot-be-cast-to-myclass-exceptions" target="_blank">http://grokbase.com/t/gg/clojure/14c6sjq7hx/debugging-myclass-cannot-be-cast-to-myclass-exceptions</a> wtf...</z><z id="t1480633697" t="caio also, is there a benchmark test so I can test the options? I opened a PR without the typehint, but I’m trying to explore it a little bit"><y>#</y><d>2016-12-01</d><h>23:08</h><w>caio</w>also, is there a benchmark test so I can test the options? I opened a PR without the typehint, but I’m trying to explore it a little bit</z><z id="t1480683168" t="nathanmarz @caio I&apos;d really like to understand the underlying issue rather than try to work around it"><y>#</y><d>2016-12-02</d><h>12:52</h><w>nathanmarz</w>@caio I&apos;d really like to understand the underlying issue rather than try to work around it</z><z id="t1480683183" t="nathanmarz that type hint should be working fine"><y>#</y><d>2016-12-02</d><h>12:53</h><w>nathanmarz</w>that type hint should be working fine</z><z id="t1480683216" t="nathanmarz only want to resort to workaround if there&apos;s no other option"><y>#</y><d>2016-12-02</d><h>12:53</h><w>nathanmarz</w>only want to resort to workaround if there&apos;s no other option</z><z id="t1480695179" t="caio @nathanmarz I understand that, but I don’t know if it’s worth it. It’s an obscure bug (all I found was one discussion) and you’re only using a record there because it’s faster to get the resulting instance’s attributes using interop. If you’re going to choose a data structure with the sole purpose of optimizing code, why not choose one that solves it and doesn’t touch a nasty trick involving clojure’s compilation and class generation? 🙂"><y>#</y><d>2016-12-02</d><h>16:12</h><w>caio</w>@nathanmarz I understand that, but I don’t know if it’s worth it. It’s an obscure bug (all I found was one discussion) and you’re only using a record there because it’s faster to get the resulting instance’s attributes using interop. If you’re going to choose a data structure with the sole purpose of optimizing code, why not choose one that solves it and doesn’t touch a nasty trick involving clojure’s compilation and class generation? <b>🙂</b></z><z id="t1480695319" t="caio I think keeping this bug on the latest specter version is horrible (even worse than the lack of clarity introduced by my PR, IMHO). afaik, this is breaking at least one other open source library (xsc/invariant) and breaks a really common and simple use case for specter: recursive paths on projects that must be AOT compiled."><y>#</y><d>2016-12-02</d><h>16:15</h><w>caio</w>I think keeping this bug on the latest specter version is horrible (even worse than the lack of clarity introduced by my PR, IMHO). afaik, this is breaking at least one other open source library (xsc/invariant) and breaks a really common and simple use case for specter: recursive paths on projects that must be AOT compiled.</z><z id="t1480695388" t="caio I am curious about what one would do to solve this bug without removing the record, but I also think there’re more important things to do other than trying to fix something without removing an optimisation “workaround”."><y>#</y><d>2016-12-02</d><h>16:16</h><w>caio</w>I am curious about what one would do to solve this bug without removing the record, but I also think there’re more important things to do other than trying to fix something without removing an optimisation “workaround”.</z><z id="t1480696883" t="caio about the bug: it looks like the compilation generates two identical classes with names com.rpl.specter.impl.CachedPathInfo$reify__XX (they have different suffixes). it looks like what’s being said here is true: http://grokbase.com/t/gg/clojure/14c6sjq7hx/debugging-myclass-cannot-be-cast-to-myclass-exceptions#20141210sl7tnec6xz46p5zfwwnn47er2a I have no idea how to tell clojure compiler to not recompile that class/ns."><y>#</y><d>2016-12-02</d><h>16:41</h><w>caio</w>about the bug: it looks like the compilation generates two identical classes with names <code>com.rpl.specter.impl.CachedPathInfo$reify__XX</code> (they have different suffixes). it looks like what’s being said here is true: <a href="http://grokbase.com/t/gg/clojure/14c6sjq7hx/debugging-myclass-cannot-be-cast-to-myclass-exceptions#20141210sl7tnec6xz46p5zfwwnn47er2a" target="_blank">http://grokbase.com/t/gg/clojure/14c6sjq7hx/debugging-myclass-cannot-be-cast-to-myclass-exceptions#20141210sl7tnec6xz46p5zfwwnn47er2a</a>
I have no idea how to tell clojure compiler to not recompile that class/ns.</z><z id="t1480699714" t="caio @nathanmarz my last attempt on doing this: I implemented a native class for CachedPathInfo so it improves the benchmarks. I doesn’t make it less readable and works both in java/javascript (it uses a record impl on JS). if you don’t want to use simpler DS as a workaround for solving this issue, then maybe a DS that actually (slightly) improves specter’s performance may convince you to forget about this bug 😄 the patch: https://github.com/nathanmarz/specter/compare/master …caioaao:native-impl?expand=1 benchmark logs: https://gist.github.com/caioaao/7f9c44db050aed9a5326cfd28f9efca0 you can compare it with the benchmark I did using the master branch on my pc: https://gist.github.com/caioaao/95a0cd834a08a777a184f5edf6c9bf00"><y>#</y><d>2016-12-02</d><h>17:28</h><w>caio</w>@nathanmarz my last attempt on doing this: I implemented a native class for CachedPathInfo so it improves the benchmarks. I doesn’t make it less readable and works both in java/javascript (it uses a record impl on JS). if you don’t want to use simpler DS as a workaround for solving this issue, then maybe a DS that actually (slightly) improves specter’s performance may convince you to forget about this bug <b>😄</b>

the patch: <a href="https://github.com/nathanmarz/specter/compare/master" target="_blank">https://github.com/nathanmarz/specter/compare/master</a>…caioaao:native-impl?expand=1
benchmark logs: <a href="https://gist.github.com/caioaao/7f9c44db050aed9a5326cfd28f9efca0" target="_blank">https://gist.github.com/caioaao/7f9c44db050aed9a5326cfd28f9efca0</a>
you can compare it with the benchmark I did using the master branch on my pc: <a href="https://gist.github.com/caioaao/95a0cd834a08a777a184f5edf6c9bf00" target="_blank">https://gist.github.com/caioaao/95a0cd834a08a777a184f5edf6c9bf00</a></z><z id="t1480781145" t="nathanmarz @caio thanks for the help figuring this out, I committed a fix to master"><y>#</y><d>2016-12-03</d><h>16:05</h><w>nathanmarz</w>@caio thanks for the help figuring this out, I committed a fix to master</z><z id="t1480796052" t="caio @nathanmarz no problem, I&apos;m glad this is solved 🙂 about the patch I posted before: is it still useful for optimization purposes? if not, I&apos;ll delete the branch"><y>#</y><d>2016-12-03</d><h>20:14</h><w>caio</w>@nathanmarz no problem, I&apos;m glad this is solved <b>🙂</b> about the patch I posted before: is it still useful for optimization purposes? if not, I&apos;ll delete the branch</z><z id="t1480796771" t="caio adds some complexity and is really ugly for a marginal gain so idk if it&apos;s worth it"><y>#</y><d>2016-12-03</d><h>20:26</h><w>caio</w>adds some complexity and is really ugly for a marginal gain  so idk if it&apos;s worth it</z><z id="t1480798009" t="nathanmarz @caio no it&apos;s not, the bytecode won&apos;t be any different"><y>#</y><d>2016-12-03</d><h>20:46</h><w>nathanmarz</w>@caio no it&apos;s not, the bytecode won&apos;t be any different</z><z id="t1481271002" t="mpenet is there a (recommended) way to compose transforms ? I mean other than just (-&gt;&gt; x (transform ...) (transform ...)) etc"><y>#</y><d>2016-12-09</d><h>08:10</h><w>mpenet</w>is there a (recommended) way to compose transforms ? I mean other than just (-&gt;&gt; x (transform ...) (transform ...)) etc</z><z id="t1481271066" t="mpenet I suspect there might be something to do that to allow a single pass over data applying all transforms in a smart way (or not)"><y>#</y><d>2016-12-09</d><h>08:11</h><w>mpenet</w>I suspect there might be something to do that to allow a single pass over data applying all transforms in a smart way (or not)</z><z id="t1481273422" t="mpenet Oh I see multi-transform and compiled-multi-transform could be it"><y>#</y><d>2016-12-09</d><h>08:50</h><w>mpenet</w>Oh I see <code>multi-transform</code> and <code>compiled-multi-transform</code> could be it</z><z id="t1481273490" t="bfabry I reckon the dot point at the bottom of the readme under &quot;Future work&quot; &quot;any connection to transducers?&quot; might be the final end game there 😉"><y>#</y><d>2016-12-09</d><h>08:51</h><w>bfabry</w>I reckon the dot point at the bottom of the readme under &quot;Future work&quot; &quot;any connection to transducers?&quot; might be the final end game there <b>😉</b></z><z id="t1481273535" t="bfabry but I don&apos;t see anything atm"><y>#</y><d>2016-12-09</d><h>08:52</h><w>bfabry</w>but I don&apos;t see anything atm</z><z id="t1481273622" t="mpenet yeah, hard to map to transducers maybe. I was more thinking of some kind of navigation/transformation planner depending on some composition of both"><y>#</y><d>2016-12-09</d><h>08:53</h><w>mpenet</w>yeah, hard to map to transducers maybe. I was more thinking of some kind of navigation/transformation planner depending on some composition of both</z><z id="t1481273683" t="mpenet but yeah, not an easy task"><y>#</y><d>2016-12-09</d><h>08:54</h><w>mpenet</w>but yeah, not an easy task</z><z id="t1481273687" t="mpenet fun tho"><y>#</y><d>2016-12-09</d><h>08:54</h><w>mpenet</w>fun tho</z><z id="t1481287978" t="nathanmarz @mpenet yea you want to use multi-transform"><y>#</y><d>2016-12-09</d><h>12:52</h><w>nathanmarz</w>@mpenet yea you want to use multi-transform</z><z id="t1481306982" t="bfabry are there performance benefits to using multi-transform over intermediate collections?"><y>#</y><d>2016-12-09</d><h>18:09</h><w>bfabry</w>are there performance benefits to using multi-transform over intermediate collections?</z><z id="t1481309306" t="nathanmarz @bfabry yes"><y>#</y><d>2016-12-09</d><h>18:48</h><w>nathanmarz</w>@bfabry yes</z><z id="t1481309350" t="nathanmarz if you want to do two transforms in a row and they share part of the path, it will be more performant to do it as a multi-transform"><y>#</y><d>2016-12-09</d><h>18:49</h><w>nathanmarz</w>if you want to do two transforms in a row and they share part of the path, it will be more performant to do it as a multi-transform</z><z id="t1481309398" t="nathanmarz there&apos;s some benchmarks for that: https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L307"><y>#</y><d>2016-12-09</d><h>18:49</h><w>nathanmarz</w>there&apos;s some benchmarks for that: <a href="https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L307" target="_blank">https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L307</a></z><z id="t1481310332" t="mpenet That s what I ended up using, thanks ;)"><y>#</y><d>2016-12-09</d><h>19:05</h><w>mpenet</w>That s what I ended up using, thanks ;)</z><z id="t1481655907" t="bcarrell Is there a better way of doing this? I&apos;m a novice (to Specter) trying to figure out if it simplifies my use case: querying a nested data structure which might be in two slightly different shapes for the presence of a value. Here&apos;s a gist which hopefully outlines it with a working solution: https://gist.github.com/bcarrell/f9081a7a7a1c5834a09da576a463c9fb"><y>#</y><d>2016-12-13</d><h>19:05</h><w>bcarrell</w>Is there a better way of doing this?  I&apos;m a novice (to Specter) trying to figure out if it simplifies my use case: querying a nested data structure which might be in two slightly different shapes for the presence of a value.  Here&apos;s a gist which hopefully outlines it with a working solution: <a href="https://gist.github.com/bcarrell/f9081a7a7a1c5834a09da576a463c9fb" target="_blank">https://gist.github.com/bcarrell/f9081a7a7a1c5834a09da576a463c9fb</a></z><z id="t1481657525" t="nathanmarz @bcarrell looks pretty good to me"><y>#</y><d>2016-12-13</d><h>19:32</h><w>nathanmarz</w>@bcarrell looks pretty good to me</z><z id="t1481657562" t="nathanmarz you could factor it into two paths if you want to make it more &quot;readable&quot;"><y>#</y><d>2016-12-13</d><h>19:32</h><w>nathanmarz</w>you could factor it into two paths if you want to make it more &quot;readable&quot;</z><z id="t1481657613" t="nathanmarz one to navigate to the :foos value you care about (distinguishing between the two &quot;types&quot;), and another using that to search for your target element"><y>#</y><d>2016-12-13</d><h>19:33</h><w>nathanmarz</w>one to navigate to the <code>:foos</code> value you care about (distinguishing between the two &quot;types&quot;), and another using that to search for your target element</z><z id="t1481657651" t="bcarrell Cool, thanks! I wanted to make sure it was approaching correctness"><y>#</y><d>2016-12-13</d><h>19:34</h><w>bcarrell</w>Cool, thanks!  I wanted to make sure it was approaching correctness</z><z id="t1481657686" t="nathanmarz you can also change the condition of your if-path to [:foo #(= :bar %)]"><y>#</y><d>2016-12-13</d><h>19:34</h><w>nathanmarz</w>you can also change the condition of your <code>if-path</code> to <code>[:foo #(= :bar %)]</code></z><z id="t1482157303" t="souenzzo Hi, https://github.com/nathanmarz/specter/issues/117 (setval [ALL even?] NONE [1 2 3 4]) ;; =&gt; [1 3] Is there any way to do this in 0.12?"><y>#</y><d>2016-12-19</d><h>14:21</h><w>souenzzo</w>Hi,
<a href="https://github.com/nathanmarz/specter/issues/117" target="_blank">https://github.com/nathanmarz/specter/issues/117</a>
<pre>(setval [ALL even?] NONE [1 2 3 4])
;; =&gt; [1 3]
</pre>
Is there any way to do this in 0.12?</z><z id="t1482157685" t="nathanmarz @souenzzo no, that issue isn&apos;t implemented"><y>#</y><d>2016-12-19</d><h>14:28</h><w>nathanmarz</w>@souenzzo no, that issue isn&apos;t implemented</z><z id="t1482157701" t="nathanmarz you could always make your own version of ALL that has that functionality"><y>#</y><d>2016-12-19</d><h>14:28</h><w>nathanmarz</w>you could always make your own version of ALL that has that functionality</z><z id="t1482347486" t="nathanmarz Specter 0.13.2 released (bug fixes) https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><y>#</y><d>2016-12-21</d><h>19:11</h><w>nathanmarz</w>Specter 0.13.2 released (bug fixes) <a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md" target="_blank">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></z><z id="t1482347495" t="nathanmarz next release will probably be 1.0"><y>#</y><d>2016-12-21</d><h>19:11</h><w>nathanmarz</w>next release will probably be 1.0</z><z id="t1482865023" t="stephenmhopper I&apos;m brand new to Specter, but I have a very simple task that I need to perform that I believe will be easy with Specter. I&apos;m just not sure how to do it. I have a Clojure map and a function. I want to apply that function to the value at a given key any time that key appears in the map or any of the child maps. Does that make sense? How would I do that?"><y>#</y><d>2016-12-27</d><h>18:57</h><w>stephenmhopper</w>I&apos;m brand new to Specter, but I have a very simple task that I need to perform that I believe will be easy with Specter. I&apos;m just not sure how to do it. I have a Clojure map and a function. I want to apply that function to the value at a given key any time that key appears in the map or any of the child maps. Does that make sense? How would I do that?</z><z id="t1482865076" t="nathanmarz @stephenmhopper it&apos;s a recursive map?"><y>#</y><d>2016-12-27</d><h>18:57</h><w>nathanmarz</w>@stephenmhopper it&apos;s a recursive map?</z><z id="t1482865085" t="stephenmhopper yep"><y>#</y><d>2016-12-27</d><h>18:58</h><w>stephenmhopper</w>yep</z><z id="t1482865349" t="nathanmarz @stephenmhopper here&apos;s an example (let [all-maps (recursive-path [] p (continue-then-stay MAP-VALS map? p))] (transform [all-maps (must &quot;mykey&quot;)] inc {&quot;mykey&quot; 1 :b {:a 2 :c {&quot;mykey&quot; 2}}}) ) "><y>#</y><d>2016-12-27</d><h>19:02</h><w>nathanmarz</w>@stephenmhopper here&apos;s an example
<pre>(let [all-maps (recursive-path [] p (continue-then-stay MAP-VALS map? p))]
  (transform [all-maps (must &quot;mykey&quot;)] inc {&quot;mykey&quot; 1 :b {:a 2 :c {&quot;mykey&quot; 2}}})
  )
</pre></z><z id="t1482865507" t="stephenmhopper Cool. That works. Thank you! Now I&apos;m going to go read the docs (again) and I&apos;ll be back with questions"><y>#</y><d>2016-12-27</d><h>19:05</h><w>stephenmhopper</w>Cool. That works. Thank you! Now I&apos;m going to go read the docs (again) and I&apos;ll be back with questions</z><z id="t1482868236" t="stephenmhopper Okay, I think I understand this. (recursive-path [] p (continue-then-stay MAP-VALS map? p)) generates a navigator which steps through the parameter data structure, keeping only the values which are maps. It does this recursively and because order isn&apos;t really important here, we could use stay-then-continue interchangeably with continue-then-stay . This navigator is then combined with (must &quot;mykey&quot;) to (1) filter out maps which don&apos;t contain &quot;mykey&quot; and (2) expose the values associated with &quot;mykey&quot;. inc is then mapped across these values and the rest is easy. Is that accurate?"><y>#</y><d>2016-12-27</d><h>19:50</h><w>stephenmhopper</w>Okay, I think I understand this. <code>(recursive-path [] p (continue-then-stay MAP-VALS map? p))</code> generates a navigator which steps through the parameter data structure, keeping only the values which are maps. It does this recursively and because order isn&apos;t really important here, we could use <code>stay-then-continue</code> interchangeably with <code>continue-then-stay</code>.

This navigator is then combined with <code>(must &quot;mykey&quot;)</code> to (1) filter out maps which don&apos;t contain &quot;mykey&quot; and (2) expose the values associated with &quot;mykey&quot;. <code>inc</code> is then mapped across these values and the rest is easy.

Is that accurate?</z><z id="t1482871742" t="stephenmhopper @nathanmarz Stage 2: How do I update the previous example to also handle maps which are nested inside of sequences?"><y>#</y><d>2016-12-27</d><h>20:49</h><w>stephenmhopper</w>@nathanmarz Stage 2: How do I update the previous example to also handle maps which are nested inside of sequences?</z><z id="t1482873366" t="stephenmhopper nvmd on Stage 2. I figured it out"><y>#</y><d>2016-12-27</d><h>21:16</h><w>stephenmhopper</w>nvmd on Stage 2. I figured it out</z><z id="t1482873607" t="nathanmarz @stephenmhopper yes, in this case continue-then-stay can be used interchangeably with stay-then-continue"><y>#</y><d>2016-12-27</d><h>21:20</h><w>nathanmarz</w>@stephenmhopper yes, in this case <code>continue-then-stay</code> can be used interchangeably with <code>stay-then-continue</code></z><z id="t1482976318" t="narkisr Hey, looking for a way of selecting items from a Vector using Specter (like srange but for any index), couldn&apos;t find a way of doing: (select [ALL &lt;?&gt;] [[1 2 3 4 5] [1 2 3 6 7]]) -&gt; [[2 5] [2 7]]"><y>#</y><d>2016-12-29</d><h>01:51</h><w>narkisr</w>Hey, looking for a way of selecting items from a Vector using Specter (like srange but for any index), couldn&apos;t find a way of doing: (select [ALL &lt;?&gt;]  [[1 2 3 4 5] [1 2 3  6 7]]) -&gt; [[2 5] [2 7]]</z><z id="t1482976322" t="narkisr There is multi-path"><y>#</y><d>2016-12-29</d><h>01:52</h><w>narkisr</w>There is multi-path</z><z id="t1482976332" t="narkisr (select [ALL (multi-path (keypath 1) (keypath 4)) ] rs)"><y>#</y><d>2016-12-29</d><h>01:52</h><w>narkisr</w>(select [ALL (multi-path (keypath 1) (keypath 4)) ] rs)</z><z id="t1482976340" t="narkisr but it flattens out the result"><y>#</y><d>2016-12-29</d><h>01:52</h><w>narkisr</w>but it flattens out the result</z><z id="t1482976347" t="narkisr [2 5 2 7] ["><y>#</y><d>2016-12-29</d><h>01:52</h><w>narkisr</w>[2 5 2 7]

[</z><z id="t1482976354" t="narkisr A possible solution might be to use: (transform [ALL (s/collect-one (keypath 0) ) (s/collect-one (keypath 1) )] (fn [a b c] [a b]) rs) which feels a bit akward (I would like to have the ability so select neste sub vectors)"><y>#</y><d>2016-12-29</d><h>01:52</h><w>narkisr</w>A possible solution might be to use: (transform [ALL (s/collect-one (keypath 0) ) (s/collect-one (keypath 1) )] (fn [a b c] [a b]) rs) which feels a bit akward (I would like to have the ability so select neste sub vectors)</z><z id="t1482976551" t="nathanmarz @narkisr you can use subselect"><y>#</y><d>2016-12-29</d><h>01:55</h><w>nathanmarz</w>@narkisr you can use <code>subselect</code></z><z id="t1482976594" t="nathanmarz subselect + multi-path should get you the behavior you want"><y>#</y><d>2016-12-29</d><h>01:56</h><w>nathanmarz</w><code>subselect</code> + <code>multi-path</code> should get you the behavior you want</z><z id="t1482976612" t="narkisr Ok, thanks! ill try to use them"><y>#</y><d>2016-12-29</d><h>01:56</h><w>narkisr</w>Ok, thanks! ill try to use them</z><z id="t1482976703" t="nathanmarz (select [ALL (subselect (multi-path (keypath 1) (keypath 4)))] [[1 2 3 4 5] [1 2 3 6 7]])"><y>#</y><d>2016-12-29</d><h>01:58</h><w>nathanmarz</w><code>(select [ALL (subselect (multi-path (keypath 1) (keypath 4)))] [[1 2 3 4 5] [1 2 3 6 7]])</code></z><z id="t1482976714" t="narkisr Got it"><y>#</y><d>2016-12-29</d><h>01:58</h><w>narkisr</w>Got it</z><z id="t1482976838" t="narkisr BTW is there any reason why indices are not treated like map keys? (since both access assosciative DS)"><y>#</y><d>2016-12-29</d><h>02:00</h><w>narkisr</w>BTW is there any reason why indices are not treated like map keys? (since both access assosciative DS)</z><z id="t1482976852" t="narkisr You need to wrap them using keypath"><y>#</y><d>2016-12-29</d><h>02:00</h><w>narkisr</w>You need to wrap them using keypath</z><z id="t1483021923" t="nathanmarz I just stuck with implementing implicit behavior that&apos;s analogous to what clojure already treats as functions"><y>#</y><d>2016-12-29</d><h>14:32</h><w>nathanmarz</w>I just stuck with implementing implicit behavior that&apos;s analogous to what clojure already treats as functions</z><z id="t1483021931" t="nathanmarz @narkisr namely keywords and sets"><y>#</y><d>2016-12-29</d><h>14:32</h><w>nathanmarz</w>@narkisr namely keywords and sets</z><z id="t1483021951" t="nathanmarz you could always implement that yourself if you want it, see ImplicitNav"><y>#</y><d>2016-12-29</d><h>14:32</h><w>nathanmarz</w>you could always implement that yourself if you want it, see <code>ImplicitNav</code></z><z id="t1483027903" t="narkisr Got it, thanks"><y>#</y><d>2016-12-29</d><h>16:11</h><w>narkisr</w>Got it, thanks</z><z id="t1483213143" t="zmaril Hello! Happy New Year&apos;s! I have some instaparse output in enlive format (will paste example shortly). I&apos;m trying to walk the tree and transform all the maps to include their metadata explicitly. I&apos;ve tried a few things without success and am currently experimenting with recursive-path."><y>#</y><d>2016-12-31</d><h>19:39</h><w>zmaril</w>Hello! Happy New Year&apos;s! I have some instaparse output in enlive format (will paste example shortly). I&apos;m trying to walk the tree and transform all the maps to include their metadata explicitly. I&apos;ve tried a few things without success and am currently experimenting with recursive-path.</z><z id="t1483217076" t="nathanmarz @zmaril if you have some examples can help you through it"><y>#</y><d>2016-12-31</d><h>20:44</h><w>nathanmarz</w>@zmaril if you have some examples can help you through it</z><z id="t1483219093" t="nathanmarz @zmaril cool, seems pretty straightforward"><y>#</y><d>2016-12-31</d><h>21:18</h><w>nathanmarz</w>@zmaril cool, seems pretty straightforward</z><z id="t1483219138" t="zmaril yeah I guess I thought something like recursive-path or the TreeWalker stuff would come in handy"><y>#</y><d>2016-12-31</d><h>21:18</h><w>zmaril</w>yeah I guess I thought something like recursive-path or the TreeWalker stuff would come in handy</z><z id="t1483221923" t="nathanmarz @zmaril you could reframe it with recursive navigation"><y>#</y><d>2016-12-31</d><h>22:05</h><w>nathanmarz</w>@zmaril you could reframe it with recursive navigation</z><z id="t1483221947" t="nathanmarz probably in conjunction with multi-transform since you&apos;re doing a few different changes throughout the tree"><y>#</y><d>2016-12-31</d><h>22:05</h><w>nathanmarz</w>probably in conjunction with <code>multi-transform</code> since you&apos;re doing a few different changes throughout the tree</z><z id="t1483223236" t="zmaril Yeah I don&apos;t understand navigation quite yet, still eludes me. "><y>#</y><d>2016-12-31</d><h>22:27</h><w>zmaril</w>Yeah I don&apos;t understand navigation quite yet, still eludes me. </z><z id="t1483545745" t="gdeer81 when you have a bunch of maps and you want to make all of the maps agree on a unit of measure you have to convert the value for one key to another and remove the old key like, [{:place &quot;here&quot; :degrees-celsius 32} {:place &quot;there&quot; :degrees-faren 100}] you have to do something like (dissoc (assoc mymap :degrees-celsius (f-&gt;c (:degrees-faren mymap)) :degrees-faren)) you could split that out into a general function that takes a key and a conversion function and my implementation probably isn&apos;t very idiomatic, but I&apos;m sure there is a way to do this in specter I just can&apos;t seem to quite get it"><y>#</y><d>2017-01-04</d><h>16:02</h><w>gdeer81</w>when you have a bunch of maps and you want to make all of the maps agree on a unit of measure you have to convert the value for one key to another and remove the old key like, <code>[{:place &quot;here&quot; :degrees-celsius 32} {:place &quot;there&quot; :degrees-faren 100}]</code> you have to do something like <code>(dissoc (assoc mymap  :degrees-celsius (f-&gt;c (:degrees-faren mymap)) :degrees-faren))</code> you could split that out into a general function that takes a key and a conversion function and my implementation probably isn&apos;t very idiomatic, but I&apos;m sure there is a way to do this in specter I just can&apos;t seem to quite get it</z><z id="t1483545893" t="gdeer81 it&apos;s such a common thing I&apos;m sure someone has a recipe for this kind of transform"><y>#</y><d>2017-01-04</d><h>16:04</h><w>gdeer81</w>it&apos;s such a common thing I&apos;m sure someone has a recipe for this kind of transform</z><z id="t1483549461" t="schmee hello! I’m trying to figure out how to annotate the depth of a tree with specter"><y>#</y><d>2017-01-04</d><h>17:04</h><w>schmee</w>hello! I’m trying to figure out how to annotate the depth of a tree with specter</z><z id="t1483549479" t="schmee so something like (= (depth-counter [:a [:b [:d] [:e]] [:c [:f]]]) [{:val :a :depth 0} [{:val :b :depth 1} [{:val :d :depth 2}] [{:val :e :depth 2}]] [{:val :c :depth 1} [{:val :c :depth 2}]]]) "><y>#</y><d>2017-01-04</d><h>17:04</h><w>schmee</w>so something like
<pre>(= (depth-counter [:a [:b [:d] [:e]] [:c [:f]]])
   [{:val :a :depth 0}
    [{:val :b :depth 1}
      [{:val :d :depth 2}]
      [{:val :e :depth 2}]]
    [{:val :c :depth 1}
      [{:val :c :depth 2}]]])
</pre></z><z id="t1483549528" t="schmee looking at the readme I don’t see any immediate way to carry state when navigating, but I’m sure I just haven’t figured out how yet 🙂"><y>#</y><d>2017-01-04</d><h>17:05</h><w>schmee</w>looking at the readme I don’t see any immediate way to carry state when navigating, but I’m sure I just haven’t figured out how yet <b>🙂</b></z><z id="t1483549628" t="schmee or wait, collect seems like something..."><y>#</y><d>2017-01-04</d><h>17:07</h><w>schmee</w>or wait, <code>collect</code> seems like something...</z><z id="t1483549639" t="nathanmarz @gdeer81 you could make a navigator that navigates to the k/v pair and replaces it with a new k/v pair"><y>#</y><d>2017-01-04</d><h>17:07</h><w>nathanmarz</w>@gdeer81 you could make a navigator that navigates to the k/v pair and replaces it with a new k/v pair</z><z id="t1483549724" t="nathanmarz so something like (transform (kvpair :degrees-faren) (fn [[_ v]] [:degrees-celsius (k-&gt;c v)]))"><y>#</y><d>2017-01-04</d><h>17:08</h><w>nathanmarz</w>so something like <code>(transform (kvpair :degrees-faren) (fn [[_ v]] [:degrees-celsius (k-&gt;c v)]))</code></z><z id="t1483549782" t="nathanmarz @schmee yea you should be able to just collect nodes as you go, and then use the count of the collected values list to annotate the depth"><y>#</y><d>2017-01-04</d><h>17:09</h><w>nathanmarz</w>@schmee yea you should be able to just collect nodes as you go, and then use the count of the collected values list to annotate the depth</z><z id="t1483550126" t="nathanmarz @schmee (def data [:a [:b [:d] [:e]] [:c [:f]]]) (def TreeWalker (recursive-path [] p (stay-then-continue VAL (if-path vector? [ALL p])))) (transform [TreeWalker (complement vector?)] (fn [&amp; vals] {:depth (- (count vals) 2) :val (last vals)}) data) "><y>#</y><d>2017-01-04</d><h>17:15</h><w>nathanmarz</w>@schmee 
<pre>(def data [:a [:b [:d] [:e]] [:c [:f]]])

(def TreeWalker
  (recursive-path [] p
    (stay-then-continue
      VAL
      (if-path vector?
        [ALL p]))))
        
(transform [TreeWalker (complement vector?)]
  (fn [&amp; vals]
    {:depth (- (count vals) 2)
     :val (last vals)})
  data)
</pre></z><z id="t1483550574" t="gdeer81 so the naming convention is unparameterized navigators are in all caps else it follows regular function naming conventions?"><y>#</y><d>2017-01-04</d><h>17:22</h><w>gdeer81</w>so the naming convention is unparameterized navigators are in all caps else it follows regular function naming conventions?</z><z id="t1483550759" t="nathanmarz yea"><y>#</y><d>2017-01-04</d><h>17:25</h><w>nathanmarz</w>yea</z><z id="t1483551009" t="schmee nathanmarz thank you so much for that example!"><y>#</y><d>2017-01-04</d><h>17:30</h><w>schmee</w>nathanmarz thank you so much for that example!</z><z id="t1483551025" t="schmee I’m just trying out Specter for the first time and this stuff is blowing my mind already!"><y>#</y><d>2017-01-04</d><h>17:30</h><w>schmee</w>I’m just trying out Specter for the first time and this stuff is blowing my mind already!</z><z id="t1483551045" t="schmee such a breath of fresh air after dealing with zippers 😛"><y>#</y><d>2017-01-04</d><h>17:30</h><w>schmee</w>such a breath of fresh air after dealing with zippers <b>😛</b></z><z id="t1483551315" t="nathanmarz thanks"><y>#</y><d>2017-01-04</d><h>17:35</h><w>nathanmarz</w>thanks</z><z id="t1483551349" t="nathanmarz zippers are still useful but not for the majority of use cases"><y>#</y><d>2017-01-04</d><h>17:35</h><w>nathanmarz</w>zippers are still useful but not for the majority of use cases</z><z id="t1483551359" t="nathanmarz (zippers are integrated with specter in com.rpl.specter.zipper)"><y>#</y><d>2017-01-04</d><h>17:35</h><w>nathanmarz</w>(zippers are integrated with specter in com.rpl.specter.zipper)</z><z id="t1483551482" t="schmee am I correct in thinking that recursive-path is just a shorthand for declarepath + providepath?"><y>#</y><d>2017-01-04</d><h>17:38</h><w>schmee</w>am I correct in thinking that <code>recursive-path</code> is just a shorthand for declarepath + providepath?</z><z id="t1483551489" t="schmee (there are no docs for that macro)"><y>#</y><d>2017-01-04</d><h>17:38</h><w>schmee</w>(there are no docs for that macro)</z><z id="t1483551532" t="nathanmarz https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L80"><y>#</y><d>2017-01-04</d><h>17:38</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L80" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L80</a></z><z id="t1483551541" t="nathanmarz local-declarepath + providepath"><y>#</y><d>2017-01-04</d><h>17:39</h><w>nathanmarz</w><code>local-declarepath</code> + <code>providepath</code></z><z id="t1483551700" t="schmee :+1:"><y>#</y><d>2017-01-04</d><h>17:41</h><w>schmee</w><b>:+1:</b></z><z id="t1483553714" t="gdeer81 @nathanmarz if I write this kvpair navigator do you think it would be useful to add to specter or is it too specific to this one use case? I remember you saying in your talk that most of the functionality that is in specter is from your specific needs so"><y>#</y><d>2017-01-04</d><h>18:15</h><w>gdeer81</w>@nathanmarz if I write this kvpair navigator do you think it would be useful to add to specter or is it too specific to this one use case? I remember you saying in your talk that most of the functionality that is in specter is from your specific needs so</z><z id="t1483553746" t="nathanmarz @gdeer81 doesn&apos;t seem common enough to add to the core"><y>#</y><d>2017-01-04</d><h>18:15</h><w>nathanmarz</w>@gdeer81 doesn&apos;t seem common enough to add to the core</z><z id="t1483553876" t="gdeer81 okay then I guess it will just end up in a gist and if someone needs it, it will show up in their google results 😆"><y>#</y><d>2017-01-04</d><h>18:17</h><w>gdeer81</w>okay then I guess it will just end up in a gist and if someone needs it, it will show up in their google results <b>😆</b></z><z id="t1483555036" t="gdeer81 Okay, so specter is good for ETL, but what about analytics? like {:usa-census [{:state &quot;Texas&quot; :population 20000000} {:state &quot;California&quot; :population 40000000} ...}] :mexico-census [{:state &quot;Coahuila&quot; :population 200000} {:state &quot;Mexico City&quot; :population 20000000} ...]} transformed into {:us-total-pop 3241118787 :mexico-total-pop 128632004 ...}"><y>#</y><d>2017-01-04</d><h>18:37</h><w>gdeer81</w>Okay, so specter is good for ETL, but what about analytics? like <code>{:usa-census [{:state &quot;Texas&quot; :population 20000000} {:state &quot;California&quot; :population 40000000} ...}] :mexico-census  [{:state &quot;Coahuila&quot; :population 200000} {:state &quot;Mexico City&quot; :population 20000000} ...]}</code> transformed into <code>{:us-total-pop 3241118787 :mexico-total-pop 128632004 ...}</code></z><z id="t1483555083" t="gdeer81 basically a collection of maps and you aggregate on one of the keys"><y>#</y><d>2017-01-04</d><h>18:38</h><w>gdeer81</w>basically a collection of maps and you aggregate on one of the keys</z><z id="t1483555113" t="gdeer81 The Clojure that I have for this looks really gnarly"><y>#</y><d>2017-01-04</d><h>18:38</h><w>gdeer81</w>The Clojure that I have for this looks really gnarly</z><z id="t1483555213" t="nathanmarz that&apos;s outside the scope of specter"><y>#</y><d>2017-01-04</d><h>18:40</h><w>nathanmarz</w>that&apos;s outside the scope of specter</z><z id="t1483555543" t="gdeer81 I guess I could write a function that uses specter to collect the values for each key I&apos;m aggregating"><y>#</y><d>2017-01-04</d><h>18:45</h><w>gdeer81</w>I guess I could write a function that uses specter to collect the values for each key I&apos;m aggregating</z><z id="t1483600336" t="schmee how can I transform every nth element of a collection?"><y>#</y><d>2017-01-05</d><h>07:12</h><w>schmee</w>how can I transform every nth element of a collection?</z><z id="t1483600399" t="schmee I’ve tried various combinations of map-indexed but then I’m back to the ‘reconstruct the right type’ problem"><y>#</y><d>2017-01-05</d><h>07:13</h><w>schmee</w>I’ve tried various combinations of <code>map-indexed</code> but then I’m back to the ‘reconstruct the right type’ problem</z><z id="t1483600672" t="schmee if I had a version of collected? that also gave you the current element, I guess something like this would work: (sr/transform [(sr/collect sr/ALL) sr/ALL (sr/collected-with-current? [collected current] (= 0 (mod (.indexOf collected current) n)))] f (range 10))"><y>#</y><d>2017-01-05</d><h>07:17</h><w>schmee</w>if I had a version of <code>collected?</code> that also gave you the current element, I guess something like this would work:
<pre>(sr/transform [(sr/collect sr/ALL) sr/ALL (sr/collected-with-current? [collected current] (= 0 (mod (.indexOf collected current) n)))] f (range 10))</pre></z><z id="t1483602926" t="nathanmarz @schmee you would either need zippers for that or a custom navigator"><y>#</y><d>2017-01-05</d><h>07:55</h><w>nathanmarz</w>@schmee you would either need zippers for that or a custom navigator</z><z id="t1483602936" t="nathanmarz zippers are integrated with specter in com.rpl.specter.zipper"><y>#</y><d>2017-01-05</d><h>07:55</h><w>nathanmarz</w>zippers are integrated with specter in com.rpl.specter.zipper</z><z id="t1483603004" t="nathanmarz something like ALL-INDEXED which navigates to pair of [index value] should do the trick"><y>#</y><d>2017-01-05</d><h>07:56</h><w>nathanmarz</w>something like <code>ALL-INDEXED</code> which navigates to pair of <code>[index value]</code> should do the trick</z><z id="t1483606324" t="schmee I’ll give the custom navigator a shot later today, thanks!"><y>#</y><d>2017-01-05</d><h>08:52</h><w>schmee</w>I’ll give the custom navigator a shot later today, thanks!</z><z id="t1483750819" t="wei I’m confused with the result of (sp/walker sequential?) (sm/select (sp/walker sequential?) {:b [1 2 nil 3]}) =&gt; [[:b [1 2 nil 3]]] I would have expected [1 2 nil 3]"><y>#</y><d>2017-01-07</d><h>01:00</h><w>wei</w>I’m confused with the result of <code>(sp/walker sequential?)</code> <pre>(sm/select (sp/walker sequential?) {:b [1 2 nil 3]}) =&gt; [[:b [1 2 nil 3]]]</pre> I would have expected <code>[1 2 nil 3]</code></z><z id="t1483750884" t="wei as a followup question, what would be the specter-y way to remove nils from sequences?"><y>#</y><d>2017-01-07</d><h>01:01</h><w>wei</w>as a followup question, what would be the specter-y way to remove nils from sequences?</z><z id="t1483753871" t="nathanmarz @wei looks like clojure.walk navigates to the key/value pairs of maps, which it considers sequences"><y>#</y><d>2017-01-07</d><h>01:51</h><w>nathanmarz</w>@wei looks like clojure.walk navigates to the key/value pairs of maps, which it considers sequences</z><z id="t1483753888" t="nathanmarz for removing nils, use com.rpl.specter.zipper"><y>#</y><d>2017-01-07</d><h>01:51</h><w>nathanmarz</w>for removing nils, use com.rpl.specter.zipper</z><z id="t1483753908" t="nathanmarz or navigate to the sequence and use filter"><y>#</y><d>2017-01-07</d><h>01:51</h><w>nathanmarz</w>or navigate to the sequence and use <code>filter</code></z><z id="t1483753951" t="nathanmarz if https://github.com/nathanmarz/specter/issues/117 is implemented will be able to do (setval [ALL nil?] NONE data)"><y>#</y><d>2017-01-07</d><h>01:52</h><w>nathanmarz</w>if <a href="https://github.com/nathanmarz/specter/issues/117" target="_blank">https://github.com/nathanmarz/specter/issues/117</a> is implemented will be able to do <code>(setval [ALL nil?] NONE data)</code></z><z id="t1483825022" t="wei @nathanmarz thanks for the tips. can zipper remove all nils an a nested structure? having some trouble putting it together"><y>#</y><d>2017-01-07</d><h>21:37</h><w>wei</w>@nathanmarz thanks for the tips. can zipper remove all nils an a nested structure? having some trouble putting it together</z><z id="t1483825775" t="nathanmarz @wei like this: (setval [z/VECTOR-ZIP z/DOWN z/RIGHT z/NODE-SEQ] [] [1 2 3 4])"><y>#</y><d>2017-01-07</d><h>21:49</h><w>nathanmarz</w>@wei like this: <code>(setval [z/VECTOR-ZIP z/DOWN z/RIGHT z/NODE-SEQ] [] [1 2 3 4])</code></z><z id="t1483825924" t="nathanmarz @wei removing nils: (setval [z/VECTOR-ZIP z/DOWN z/NEXT-WALK (selected? z/NODE nil?) z/NODE-SEQ] [] [1 2 nil 3 nil])"><y>#</y><d>2017-01-07</d><h>21:52</h><w>nathanmarz</w>@wei removing nils: <code>(setval [z/VECTOR-ZIP z/DOWN z/NEXT-WALK (selected? z/NODE nil?) z/NODE-SEQ] [] [1 2 nil 3 nil])</code></z><z id="t1483825984" t="nathanmarz obviously the approach in #117 would be more elegant as well as more performant"><y>#</y><d>2017-01-07</d><h>21:53</h><w>nathanmarz</w>obviously the approach in #117 would be more elegant as well as more performant</z><z id="t1483926306" t="nathanmarz added ability to remove values in 0.13.3-SNAPSHOT (on clojars)"><y>#</y><d>2017-01-09</d><h>01:45</h><w>nathanmarz</w>added ability to remove values in 0.13.3-SNAPSHOT (on clojars)</z><z id="t1483926328" t="nathanmarz e.g. (setval [ALL nil?] NONE [1 2 nil 3 nil]) =&gt; [1 2 3]"><y>#</y><d>2017-01-09</d><h>01:45</h><w>nathanmarz</w>e.g. <code>(setval [ALL nil?] NONE [1 2 nil 3 nil])</code> =&gt; <code>[1 2 3]</code></z><z id="t1483926369" t="nathanmarz and (setval [:a :b] NONE {:a {:b 1 :c 2}}) =&gt; {:a {:c 2}}"><y>#</y><d>2017-01-09</d><h>01:46</h><w>nathanmarz</w>and <code>(setval [:a :b] NONE {:a {:b 1 :c 2}})</code> =&gt; <code>{:a {:c 2}}</code></z><z id="t1484007433" t="richiardiandrea maybe FAQ 🙂 is there a way in specter to stop to the first MAP-VALS , without further going deep in a map for instance?"><y>#</y><d>2017-01-10</d><h>00:17</h><w>richiardiandrea</w>maybe FAQ <b>🙂</b> is there a way in specter to stop to the first <code>MAP-VALS</code>, without further going deep in a map for instance?</z><z id="t1484007620" t="qqq is there a way to avoid the all caps? On a kinesis advantage pro keyboard, typing all caps is quite annoying"><y>#</y><d>2017-01-10</d><h>00:20</h><w>qqq</w>is there a way to avoid the all caps? On a kinesis advantage pro keyboard, typing all caps is quite annoying</z><z id="t1484008314" t="nathanmarz @qqq you can do (def my-all ALL) if you want"><y>#</y><d>2017-01-10</d><h>00:31</h><w>nathanmarz</w>@qqq you can do <code>(def my-all ALL)</code> if you want</z><z id="t1484008335" t="qqq yeah, I my have to"><y>#</y><d>2017-01-10</d><h>00:32</h><w>qqq</w>yeah, I my have to</z><z id="t1484008342" t="qqq MAP_VALS is really awkward on the kinesis"><y>#</y><d>2017-01-10</d><h>00:32</h><w>qqq</w>MAP_VALS is really awkward on the kinesis</z><z id="t1484008355" t="nathanmarz @richiardiandrea no, not at the moment"><y>#</y><d>2017-01-10</d><h>00:32</h><w>nathanmarz</w>@richiardiandrea no, not at the moment</z><z id="t1484008366" t="qqq I guess you can&apos;t use :all or :map-vals since you&apos;re using kws for kw selector functions"><y>#</y><d>2017-01-10</d><h>00:32</h><w>qqq</w>I guess you can&apos;t use :all or :map-vals since you&apos;re using kws for kw selector functions</z><z id="t1484008416" t="nathanmarz keywords extend ImplicitNav in order to wrap themselves in keypath"><y>#</y><d>2017-01-10</d><h>00:33</h><w>nathanmarz</w>keywords extend <code>ImplicitNav</code> in order to wrap themselves in <code>keypath</code></z><z id="t1484008432" t="nathanmarz https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L896"><y>#</y><d>2017-01-10</d><h>00:33</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L896" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L896</a></z><z id="t1484008862" t="nathanmarz @richiardiandrea fyi, there are some ideas about supporting that in the future though: https://github.com/nathanmarz/specter/issues/125"><y>#</y><d>2017-01-10</d><h>00:41</h><w>nathanmarz</w>@richiardiandrea fyi, there are some ideas about supporting that in the future though: <a href="https://github.com/nathanmarz/specter/issues/125" target="_blank">https://github.com/nathanmarz/specter/issues/125</a></z><z id="t1484008915" t="richiardiandrea oh cool, for a moment I though I could use STOP for it"><y>#</y><d>2017-01-10</d><h>00:41</h><w>richiardiandrea</w>oh cool, for a moment I though I could use <code>STOP</code> for it</z><z id="t1484008963" t="richiardiandrea btw I tried 0.13.3-SNAPSHOT and the NONE syntax works here, but because it navigates deeply in the data, it is still something different from what I was thinking"><y>#</y><d>2017-01-10</d><h>00:42</h><w>richiardiandrea</w>btw I tried <code>0.13.3-SNAPSHOT</code> and the <code>NONE</code> syntax works here, but because it navigates deeply in the data, it is still something different from what I was thinking</z><z id="t1484008990" t="nathanmarz what do you mean?"><y>#</y><d>2017-01-10</d><h>00:43</h><w>nathanmarz</w>what do you mean?</z><z id="t1484008996" t="nathanmarz example?"><y>#</y><d>2017-01-10</d><h>00:43</h><w>nathanmarz</w>example?</z><z id="t1484009202" t="richiardiandrea uhm...no ok I lost it, I tried another example but it works fine, give a couple of minutes 😄"><y>#</y><d>2017-01-10</d><h>00:46</h><w>richiardiandrea</w>uhm...no ok I lost it, I tried another example but it works fine, give a couple of minutes <b>😄</b></z><z id="t1484009276" t="richiardiandrea uhm (2), I tried again what I had in mind and it works fine..."><y>#</y><d>2017-01-10</d><h>00:47</h><w>richiardiandrea</w>uhm (2), I tried again what I had in mind and it works fine...</z><z id="t1484009289" t="richiardiandrea It was (sp/setval [sp/MAP-VALS #(map? %)] sp/NONE {:a 3 :b 5 :c {:d 5}})"><y>#</y><d>2017-01-10</d><h>00:48</h><w>richiardiandrea</w>It was <code>(sp/setval [sp/MAP-VALS #(map? %)] sp/NONE {:a 3 :b 5 :c {:d 5}})</code></z><z id="t1484009353" t="richiardiandrea very convenient btw :+1:"><y>#</y><d>2017-01-10</d><h>00:49</h><w>richiardiandrea</w>very convenient btw <b>:+1:</b></z><z id="t1484010320" t="richiardiandrea @nathanmarz every time I turn to Specter for data manipulation, I surprise myself with the simplicity of the result, thanks: (sp/transform [(sp/collect-one [:family (sp/submap [:name :description])]) :family (sp/submap [:resource :relationship]) sp/MAP-VALS sp/ALL] (fn [family m] (assoc m :family family)) (first families)) "><y>#</y><d>2017-01-10</d><h>01:05</h><w>richiardiandrea</w>@nathanmarz every time I turn to Specter for data manipulation, I surprise myself with the simplicity of the result, thanks:
<pre>(sp/transform [(sp/collect-one [:family (sp/submap [:name :description])])
                                             :family
                                             (sp/submap [:resource :relationship])
                                             sp/MAP-VALS
                                             sp/ALL]
                                            (fn [family m]
                                              (assoc m :family family)) 
                                 (first families))
</pre></z><z id="t1484010335" t="richiardiandrea the collect feature is super neat"><y>#</y><d>2017-01-10</d><h>01:05</h><w>richiardiandrea</w>the collect feature is super neat</z><z id="t1484010519" t="nathanmarz yea I use that feature quite a bit"><y>#</y><d>2017-01-10</d><h>01:08</h><w>nathanmarz</w>yea I use that feature quite a bit</z><z id="t1484010558" t="richiardiandrea I wanted basically to avoid using a submap with keys there"><y>#</y><d>2017-01-10</d><h>01:09</h><w>richiardiandrea</w>I wanted basically to avoid using a <code>submap</code> with keys there</z><z id="t1484010593" t="richiardiandrea so that I can assoc to all the key-values where the value is a map"><y>#</y><d>2017-01-10</d><h>01:09</h><w>richiardiandrea</w>so that I can assoc to all the key-values where the value is a map</z><z id="t1484010912" t="richiardiandrea oh ok wow done 😉"><y>#</y><d>2017-01-10</d><h>01:15</h><w>richiardiandrea</w>oh ok wow done <b>😉</b></z><z id="t1484010970" t="richiardiandrea (defn propagate-family [family] (sp/transform [(sp/collect-one [:family (sp/submap [:name :description])]) :family sp/MAP-VALS #(vector? %) sp/ALL] (fn [family m] (assoc m :family family)) family)) "><y>#</y><d>2017-01-10</d><h>01:16</h><w>richiardiandrea</w><pre>(defn propagate-family
  [family]
  (sp/transform [(sp/collect-one [:family (sp/submap [:name :description])])
                 :family
                 sp/MAP-VALS
                 #(vector? %)
                 sp/ALL]
                (fn [family m]
                  (assoc m :family family))
                family))
</pre></z><z id="t1484017209" t="bfabry omg people use like my only oss contribution ever, goosebumps 😄"><y>#</y><d>2017-01-10</d><h>03:00</h><w>bfabry</w>omg people use like my only oss contribution ever, goosebumps <b>😄</b></z><z id="t1484018838" t="qqq https://stackoverflow.com/questions/39123457/how-to-use-specter-in-clojurescript &lt;-- is using specter in cljs in figwheel still a problem? (I&apos;m having problems using specter in cljs, but not in clj, and I can&apos;t figure out why)"><y>#</y><d>2017-01-10</d><h>03:27</h><w>qqq</w><a href="https://stackoverflow.com/questions/39123457/how-to-use-specter-in-clojurescript" target="_blank">https://stackoverflow.com/questions/39123457/how-to-use-specter-in-clojurescript</a> &lt;-- is using specter in cljs in figwheel still a problem? (I&apos;m having problems using specter in cljs, but not in clj, and I can&apos;t figure out why)</z><z id="t1484019288" t="nathanmarz @qqq I&apos;ve only used it in Node myself"><y>#</y><d>2017-01-10</d><h>03:34</h><w>nathanmarz</w>@qqq I&apos;ve only used it in Node myself</z><z id="t1484019333" t="nathanmarz what specific problem are you having?"><y>#</y><d>2017-01-10</d><h>03:35</h><w>nathanmarz</w>what specific problem are you having?</z><z id="t1484019483" t="nathanmarz @richiardiandrea fyi you can write that in a simpler way like this: (defn propagate-family [family] (sp/transform [:family (sp/collect-one (sp/submap [:name :description])) sp/MAP-VALS vector? sp/ALL :family] (fn [family _] family) family)) "><y>#</y><d>2017-01-10</d><h>03:38</h><w>nathanmarz</w>@richiardiandrea fyi you can write that in a simpler way like this:
<pre>(defn propagate-family
  [family]
  (sp/transform [:family
                 (sp/collect-one (sp/submap [:name :description]))
                 sp/MAP-VALS
                 vector?
                 sp/ALL
                 :family]
                (fn [family _] family)
                family))
</pre></z><z id="t1484020819" t="richiardiandrea Thanks @nathanmarz, is transform acting like update then?"><y>#</y><d>2017-01-10</d><h>04:00</h><w>richiardiandrea</w>Thanks @nathanmarz, is <code>transform</code> acting like <code>update</code> then?</z><z id="t1484020856" t="richiardiandrea Did not know that, even better 😄 "><y>#</y><d>2017-01-10</d><h>04:00</h><w>richiardiandrea</w>Did not know that, even better <b>😄</b> </z><z id="t1484021087" t="qqq @nathanmarz: let me create a minimal failure care"><y>#</y><d>2017-01-10</d><h>04:04</h><w>qqq</w>@nathanmarz: let me create a minimal failure care</z><z id="t1484021320" t="qqq false alarm, I was requiring com.rpl/specter instead of com.rpl/specter"><y>#</y><d>2017-01-10</d><h>04:08</h><w>qqq</w>false alarm, I was requiring com.rpl/specter instead of com.rpl/specter</z><z id="t1484022014" t="nathanmarz @richiardiandrea yea it&apos;s like update on steroids"><y>#</y><d>2017-01-10</d><h>04:20</h><w>nathanmarz</w>@richiardiandrea yea it&apos;s like <code>update</code> on steroids</z><z id="t1484022173" t="qqq @nathanmarz : from a newcomer perspective, it might help if at the very top of the README.md, there was a line to the effect of transform takes two functions, one to select items, one to update, and leaves everything else the samespe"><y>#</y><d>2017-01-10</d><h>04:22</h><w>qqq</w>@nathanmarz : from a newcomer perspective, it might help if at the very top of the README.md, there was a line to the effect of 

transform takes two functions, one to select items, one to update, and leaves everything else the samespe</z><z id="t1484022176" t="richiardiandrea Super!"><y>#</y><d>2017-01-10</d><h>04:22</h><w>richiardiandrea</w>Super!</z><z id="t1484022251" t="nathanmarz yea the documentation could be a lot better"><y>#</y><d>2017-01-10</d><h>04:24</h><w>nathanmarz</w>yea the documentation could be a lot better</z><z id="t1484022286" t="nathanmarz a good beginner tutorial would be great, but I don&apos;t have time for that now"><y>#</y><d>2017-01-10</d><h>04:24</h><w>nathanmarz</w>a good beginner tutorial would be great, but I don&apos;t have time for that now</z><z id="t1484022295" t="nathanmarz would love documentation contributions"><y>#</y><d>2017-01-10</d><h>04:24</h><w>nathanmarz</w>would love documentation contributions</z><z id="t1484022303" t="qqq lol"><y>#</y><d>2017-01-10</d><h>04:25</h><w>qqq</w>lol</z><z id="t1484078939" t="richiardiandrea @nathanmarz is there a more elegant way to do this: (defn normalize-family [family] (merge (sp/setval [sp/MAP-VALS string?] sp/NONE (:family family)) (sp/transform [(sp/collect-one [:family (sp/submap [:name :description])]) :family] (fn [family _] family) family))) "><y>#</y><d>2017-01-10</d><h>20:08</h><w>richiardiandrea</w>@nathanmarz is there a more elegant way to do this:
<pre>(defn normalize-family
  [family]
  (merge
   (sp/setval [sp/MAP-VALS string?] sp/NONE (:family family))
   (sp/transform [(sp/collect-one [:family (sp/submap [:name :description])])
                  :family]
                 (fn [family _] family)
                 family)))
</pre></z><z id="t1484078995" t="richiardiandrea the initial shape is {:family {:name &quot;art&quot; :desc &quot;sda&quot; :complex-map {....}}"><y>#</y><d>2017-01-10</d><h>20:09</h><w>richiardiandrea</w>the initial shape is <code>{:family {:name &quot;art&quot; :desc &quot;sda&quot; :complex-map {....}}</code></z><z id="t1484079025" t="richiardiandrea and I basically want to transform it into {:family {:name &quot;art&quot; :desc &quot;sda&quot;} :complex-map {....}}"><y>#</y><d>2017-01-10</d><h>20:10</h><w>richiardiandrea</w>and I basically want to transform it into <code>{:family {:name &quot;art&quot; :desc &quot;sda&quot;} :complex-map {....}}</code></z><z id="t1484079279" t="nathanmarz you just want to move :complex-map keypair into parent map?"><y>#</y><d>2017-01-10</d><h>20:14</h><w>nathanmarz</w>you just want to move :complex-map keypair into parent map?</z><z id="t1484079295" t="richiardiandrea ah yes that&apos;s another way to see it 😄"><y>#</y><d>2017-01-10</d><h>20:14</h><w>richiardiandrea</w>ah yes that&apos;s another way to see it <b>😄</b></z><z id="t1484079330" t="richiardiandrea but all the :complex-map s, so everything that has not a string? value should go up"><y>#</y><d>2017-01-10</d><h>20:15</h><w>richiardiandrea</w>but all the <code>:complex-map</code>s, so everything that has not a <code>string?</code> value should go up</z><z id="t1484079619" t="nathanmarz I think the way you&apos;re doing it is fine"><y>#</y><d>2017-01-10</d><h>20:20</h><w>nathanmarz</w>I think the way you&apos;re doing it is fine</z><z id="t1484080045" t="richiardiandrea @nathanmarz cool then thanks!"><y>#</y><d>2017-01-10</d><h>20:27</h><w>richiardiandrea</w>@nathanmarz cool then thanks!</z><z id="t1484080943" t="qqq in specter, is it possible for a update function to depend not only on the value, but also on the &quot;path&quot; down to the node ?"><y>#</y><d>2017-01-10</d><h>20:42</h><w>qqq</w>in specter, is it possible for a update function to depend not only on the value, but also on the &quot;path&quot; down to the node ?</z><z id="t1484081269" t="richiardiandrea @qqq I think there is a https://github.com/nathanmarz/specter/wiki/List-of-Navigators#if-path but I guess depends a lot on what you have in mind"><y>#</y><d>2017-01-10</d><h>20:47</h><w>richiardiandrea</w>@qqq I think there is a <a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#if-path" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#if-path</a> but I guess depends a lot on what you have in mind</z><z id="t1484081731" t="bfabry @qqq have you got a pseudo example?"><y>#</y><d>2017-01-10</d><h>20:55</h><w>bfabry</w>@qqq have you got a pseudo example?</z><z id="t1484081769" t="richiardiandrea @qqq also https://github.com/nathanmarz/specter/wiki/List-of-Macros#multi-transform"><y>#</y><d>2017-01-10</d><h>20:56</h><w>richiardiandrea</w>@qqq also <a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#multi-transform" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Macros#multi-transform</a></z><z id="t1484081888" t="qqq {:a {:b [:apple :orange :pear] :c [:juice]} :e [:cat :dog]} to {:a {:b [[[:a :b 0] :apple] [[:a :b 1] :orange] [[:a :b 2] :pear]] :c [[[:a :c 0] :juice]]} :e [[[:e 0] :cat] [[:e 1] :dog] ]} ^^ can specter do the above transform ? I want to map over the leafs, and for each leaf, also store into it its &apos;path&apos;"><y>#</y><d>2017-01-10</d><h>20:58</h><w>qqq</w><pre>{:a {:b [:apple :orange :pear]
     :c [:juice]}
 :e [:cat :dog]}

to

{:a {:b [[[:a :b 0] :apple]
         [[:a :b 1] :orange]
         [[:a :b 2] :pear]]
     :c [[[:a :c 0] :juice]]}
 :e [[[:e 0] :cat]
     [[:e 1] :dog]
     ]}
</pre>
^^ can specter do the above transform ? I want to map over the leafs, and for each leaf, also store into it its &apos;path&apos;</z><z id="t1484081894" t="qqq @bfabry : ^^^"><y>#</y><d>2017-01-10</d><h>20:58</h><w>qqq</w>@bfabry : ^^^</z><z id="t1484081998" t="bfabry that&apos;s an interesting thought. what would you want to receive if it went through a navigator like a predicate? #(.startsWith % &quot;:or&quot;) or similar?"><y>#</y><d>2017-01-10</d><h>20:59</h><w>bfabry</w>that&apos;s an interesting thought. what would you want to receive if it went through a navigator like a predicate? #(.startsWith % &quot;:or&quot;) or similar?</z><z id="t1484082019" t="qqq I never considered that case."><y>#</y><d>2017-01-10</d><h>21:00</h><w>qqq</w>I never considered that case.</z><z id="t1484082037" t="qqq Maybe this is not a right fit with specter, since specter is &quot;does more than indexing&quot;"><y>#</y><d>2017-01-10</d><h>21:00</h><w>qqq</w>Maybe this is not a right fit with specter, since specter is &quot;does more than indexing&quot;</z><z id="t1484082048" t="qqq In haskell, this is trivial with a &quot;reader monad&quot;"><y>#</y><d>2017-01-10</d><h>21:00</h><w>qqq</w>In haskell, this is trivial with a &quot;reader monad&quot;</z><z id="t1484082055" t="qqq not sure the right clojure solution"><y>#</y><d>2017-01-10</d><h>21:00</h><w>qqq</w>not sure the right clojure solution</z><z id="t1484082278" t="bfabry maybe zippers if your data is representable as a tree (which that is)"><y>#</y><d>2017-01-10</d><h>21:04</h><w>bfabry</w>maybe zippers if your data is representable as a tree (which that is)</z><z id="t1484083633" t="nathanmarz @qqq you can collect values as you go"><y>#</y><d>2017-01-10</d><h>21:27</h><w>nathanmarz</w>@qqq you can collect values as you go</z><z id="t1484083730" t="qqq nathanmarz: does this involve (1) making the &apos;update&apos; function impure&apos;, or (2) does specter support the reader monad?"><y>#</y><d>2017-01-10</d><h>21:28</h><w>qqq</w>nathanmarz: does this involve (1) making the &apos;update&apos; function impure&apos;, or (2) does specter support the reader monad?</z><z id="t1484084386" t="nathanmarz @qqq like this: (defnav ALL-INDEXED [] (select* [this structure next-fn] ;; fill this in ) (transform* [this structure next-fn] (map-indexed (fn [i v] (second (next-fn [i v]))) structure ))) (def MyPath (recursive-path [] p (cond-path map? [ALL (collect-one FIRST) LAST p] vector? [ALL-INDEXED (collect-one FIRST) LAST p] STAY STAY))) (transform MyPath (fn [&amp; vals] vals) {:a {:b [:apple :orange :pear] :c [:juice]} :e [:cat :dog]}) "><y>#</y><d>2017-01-10</d><h>21:39</h><w>nathanmarz</w>@qqq like this:
<pre>(defnav ALL-INDEXED []
  (select* [this structure next-fn]
    ;; fill this in
    )
  (transform* [this structure next-fn]
    (map-indexed
      (fn [i v]
        (second (next-fn [i v])))
      structure
      )))


(def MyPath
  (recursive-path [] p
    (cond-path map? [ALL (collect-one FIRST) LAST p]
               vector? [ALL-INDEXED (collect-one FIRST) LAST p]
               STAY STAY)))

(transform MyPath
  (fn [&amp; vals] vals)
  {:a {:b [:apple :orange :pear]
   :c [:juice]}
   :e [:cat :dog]})
</pre></z><z id="t1484084399" t="nathanmarz it&apos;s pure"><y>#</y><d>2017-01-10</d><h>21:39</h><w>nathanmarz</w>it&apos;s pure</z><z id="t1484084415" t="nathanmarz more work is needed on ALL-INDEXED to make it preserve type (ala ALL ), but that&apos;s the gist of it"><y>#</y><d>2017-01-10</d><h>21:40</h><w>nathanmarz</w>more work is needed on <code>ALL-INDEXED</code> to make it preserve type (ala <code>ALL</code>), but that&apos;s the gist of it</z><z id="t1484085145" t="schmee (removed redudant answer cause slack was out of sync)"><y>#</y><d>2017-01-10</d><h>21:52</h><w>schmee</w>(removed redudant answer cause slack was out of sync)</z><z id="t1484087121" t="schmee if I have a path like this, will it get cached automatically?"><y>#</y><d>2017-01-10</d><h>22:25</h><w>schmee</w>if I have a path like this, will it get cached automatically?</z><z id="t1484087124" t="schmee (defn every-nth [n] [ALL-INDEXED (collect-one FIRST) (fn [[i _]] (= 0 (mod i n))) LAST])"><y>#</y><d>2017-01-10</d><h>22:25</h><w>schmee</w><code>(defn every-nth [n] [ALL-INDEXED (collect-one FIRST) (fn [[i _]] (= 0 (mod i n))) LAST])</code></z><z id="t1484087139" t="schmee using your implementation of ALL-INDEXED above"><y>#</y><d>2017-01-10</d><h>22:25</h><w>schmee</w>using your implementation of <code>ALL-INDEXED</code> above</z><z id="t1484087234" t="nathanmarz no"><y>#</y><d>2017-01-10</d><h>22:27</h><w>nathanmarz</w>no</z><z id="t1484087272" t="nathanmarz just do this: (defn every-nth [n] (path ALL-INDEXED (collect-one FIRST) (fn [[i _]] (= 0 (mod i n))) LAST)) "><y>#</y><d>2017-01-10</d><h>22:27</h><w>nathanmarz</w>just do this:
<pre>(defn every-nth [n] (path ALL-INDEXED (collect-one FIRST) (fn [[i _]] (= 0 (mod i n))) LAST))
</pre></z><z id="t1484087299" t="schmee ahh, gotcha"><y>#</y><d>2017-01-10</d><h>22:28</h><w>schmee</w>ahh, gotcha</z><z id="t1484087312" t="nathanmarz path implements all the inline caching stuff"><y>#</y><d>2017-01-10</d><h>22:28</h><w>nathanmarz</w><code>path</code> implements all the inline caching stuff</z><z id="t1484087357" t="schmee also, the macros wiki page mentioned a must-cache-paths! fn, but it seems like that function is gone?"><y>#</y><d>2017-01-10</d><h>22:29</h><w>schmee</w>also, the macros wiki page mentioned a <code>must-cache-paths!</code> fn, but it seems like that function is gone?</z><z id="t1484087378" t="nathanmarz yea that&apos;s gone as of 0.13.0"><y>#</y><d>2017-01-10</d><h>22:29</h><w>nathanmarz</w>yea that&apos;s gone as of 0.13.0</z><z id="t1484087399" t="nathanmarz every path can be inline cached now"><y>#</y><d>2017-01-10</d><h>22:29</h><w>nathanmarz</w>every path can be inline cached now</z><z id="t1484087442" t="schmee sweet :+1:"><y>#</y><d>2017-01-10</d><h>22:30</h><w>schmee</w>sweet <b>:+1:</b></z><z id="t1484087500" t="schmee it’s really a whole new paradigm to use Specter, I feel kinda lost just like I did when I went from imperative to functional programming"><y>#</y><d>2017-01-10</d><h>22:31</h><w>schmee</w>it’s really a whole new paradigm to use Specter, I feel kinda lost just like I did when I went from imperative to functional programming</z><z id="t1484087509" t="schmee but I guess it will reveal itself in due time 🙂"><y>#</y><d>2017-01-10</d><h>22:31</h><w>schmee</w>but I guess it will reveal itself in due time <b>🙂</b></z><z id="t1484087552" t="nathanmarz you&apos;ll get there"><y>#</y><d>2017-01-10</d><h>22:32</h><w>nathanmarz</w>you&apos;ll get there</z><z id="t1484087559" t="nathanmarz eventually you&apos;ll wonder how you ever programmed without it"><y>#</y><d>2017-01-10</d><h>22:32</h><w>nathanmarz</w>eventually you&apos;ll wonder how you ever programmed without it</z><z id="t1484096646" t="qqq what&apos;s a good letter to bind com.rpl.specter to , given that I already have s -&gt; clojure.spec ?"><y>#</y><d>2017-01-11</d><h>01:04</h><w>qqq</w>what&apos;s a good letter to bind com.rpl.specter to , given that I already have s -&gt; clojure.spec ?</z><z id="t1484096925" t="bfabry @qqq our convention is sp and I believe i&apos;ve seen it in other places"><y>#</y><d>2017-01-11</d><h>01:08</h><w>bfabry</w>@qqq our convention is sp and I believe i&apos;ve seen it in other places</z><z id="t1484097005" t="qqq @bfabry : I was going to use &quot;dt&quot; for &quot;data&quot;, but &quot;sp&quot; makes more sense"><y>#</y><d>2017-01-11</d><h>01:10</h><w>qqq</w>@bfabry : I was going to use &quot;dt&quot; for &quot;data&quot;, but &quot;sp&quot; makes more sense</z><z id="t1484097061" t="bfabry quicker to type than dt on a qwerty keyboard 😛"><y>#</y><d>2017-01-11</d><h>01:11</h><w>bfabry</w>quicker to type than dt on a qwerty keyboard <b>😛</b></z><z id="t1484097105" t="qqq it&apos;s unfortunate that spec / specter share such a long prefix"><y>#</y><d>2017-01-11</d><h>01:11</h><w>qqq</w>it&apos;s unfortunate that spec / specter share such a long prefix</z><z id="t1484097153" t="bfabry I guess yeah, though spec is in core so I think it&apos;s fair to just assume it will always get the bare &apos;s&apos;"><y>#</y><d>2017-01-11</d><h>01:12</h><w>bfabry</w>I guess yeah, though spec is in core so I think it&apos;s fair to just assume it will always get the bare &apos;s&apos;</z><z id="t1484100098" t="richiardiandrea I second sp :)"><y>#</y><d>2017-01-11</d><h>02:01</h><w>richiardiandrea</w>I second <code>sp</code> :)</z><z id="t1484105651" t="qqq @nathanmarz : between cascalog, elephantdb, and specter; you have the tools for &quot;manipulating large scale datasets&quot; -- any plans on a database of some sort down the line?"><y>#</y><d>2017-01-11</d><h>03:34</h><w>qqq</w>@nathanmarz : between cascalog, elephantdb, and specter; you have the tools for &quot;manipulating large scale datasets&quot; -- any plans on a database of some sort down the line?</z><z id="t1484106183" t="qqq https://github.com/nathanmarz/specter/search?utf8=%E2%9C%93&amp;amp;q=setval &lt;-- where is setval defined?"><y>#</y><d>2017-01-11</d><h>03:43</h><w>qqq</w><a href="https://github.com/nathanmarz/specter/search?utf8=%E2%9C%93&amp;amp;q=setval" target="_blank">https://github.com/nathanmarz/specter/search?utf8=%E2%9C%93&amp;amp;q=setval</a> &lt;-- where is setval defined?</z><z id="t1484106285" t="qqq (m/pp (com.rpl.specter/setval [:a com.rpl.specter/ALL nil?] com.rpl.specter/NONE {:a [1 2 nil 3 nil]})) is outputting: {:a [1 2 :com.rpl.specter.impl/NONE 3 :com.rpl.specter.impl/NONE]} what am I doing wrong?"><y>#</y><d>2017-01-11</d><h>03:44</h><w>qqq</w><pre>(m/pp (com.rpl.specter/setval [:a com.rpl.specter/ALL nil?] com.rpl.specter/NONE {:a [1 2 nil 3 nil]}))
is outputting:
{:a [1 2 :com.rpl.specter.impl/NONE 3 :com.rpl.specter.impl/NONE]}
</pre>
what am I doing wrong?</z><z id="t1484108948" t="qqq issue resolved -- I was on 0.12 instead of 0.13.3-snapshot"><y>#</y><d>2017-01-11</d><h>04:29</h><w>qqq</w>issue resolved -- I was on 0.12 instead of 0.13.3-snapshot</z><z id="t1484109409" t="nathanmarz @qqq no comment ;)"><y>#</y><d>2017-01-11</d><h>04:36</h><w>nathanmarz</w>@qqq no comment ;)</z><z id="t1484111060" t="qqq @nathanmarz : what, if any, is the theoretical under pinning of specter? in numpy, we can do something like: a :: mxn float b :: mxn bool a [b] = ... // assigns to the portion of a where b is true specter seems to be doing this on a &quot;multi level&quot; way, but I&apos;m wondering if there is some deeper theoretical underpinning"><y>#</y><d>2017-01-11</d><h>05:04</h><w>qqq</w>@nathanmarz : what, if any, is the theoretical under pinning of specter?
in numpy, we can do something like:
a :: mxn float
b :: mxn bool
a [b] = ... 
// assigns to the portion of a where b is true
specter seems to be doing this on a &quot;multi level&quot; way, but I&apos;m wondering if there is some deeper theoretical underpinning</z><z id="t1484117374" t="qqq does (setval BEGINNING) always treat both args as seqs and output a seq?"><y>#</y><d>2017-01-11</d><h>06:49</h><w>qqq</w>does (setval BEGINNING) always treat both args as seqs and output a seq?</z><z id="t1484125320" t="qqq Keeps the element only if it matches the supplied predicate. This is the late-bound parameterized version of using a function directly in a path. ^^ -- I don&apos; get it. Why do I need pred instead of just using the function?"><y>#</y><d>2017-01-11</d><h>09:02</h><w>qqq</w>Keeps the element only if it matches the supplied predicate. This is the late-bound parameterized version of using a function directly in a path.

^^ -- I don&apos; get it. Why do I need pred instead of just using the function?</z><z id="t1484125786" t="qqq ;; not-selected?: stops navigation if something is found (sp/select [sp/all (sp/not-selected? even?)] (range 10)) (sp/select [sp/all (sp/not-selected? [(sp/must :a) even?])] [{:a 0} {:a 1} {:a 2} {:a 3}]) (sp/select-one (sp/not-selected? [sp/all (sp/must :a) even?]) [{:a 0} {:a 1} {:a 2} {:a 3}]) ;; not-selected?: stops navigation if fails to find path (sp/select [sp/all (sp/selected? even?)] (range 10)) (sp/select [sp/all (sp/selected? [(sp/must :a) even?])] [{:a 0} {:a 1} {:a 2} {:a 3}]) (sp/select (sp/selected? [sp/all (sp/must :a) even?]) [{:a 0} {:a 1} {:a 2} {:a 3}]) selected? / not-selected? -- these examples I am not understanding"><y>#</y><d>2017-01-11</d><h>09:09</h><w>qqq</w><pre>;; not-selected?: stops navigation if something is found
(sp/select [sp/all (sp/not-selected? even?)] (range 10))
(sp/select [sp/all (sp/not-selected? [(sp/must :a) even?])] [{:a 0} {:a 1} {:a 2} {:a 3}])
(sp/select-one (sp/not-selected? [sp/all (sp/must :a) even?]) [{:a 0} {:a 1} {:a 2} {:a 3}])

;; not-selected?: stops navigation if fails to find path
(sp/select [sp/all (sp/selected? even?)] (range 10))
(sp/select [sp/all (sp/selected? [(sp/must :a) even?])] [{:a 0} {:a 1} {:a 2} {:a 3}])
(sp/select (sp/selected? [sp/all (sp/must :a) even?]) [{:a 0} {:a 1} {:a 2} {:a 3}])
</pre>
selected? / not-selected? -- these examples I am not understanding</z><z id="t1484141099" t="nathanmarz @qqq pred is the navigator that functions implicitly use"><y>#</y><d>2017-01-11</d><h>13:24</h><w>nathanmarz</w>@qqq <code>pred</code> is the navigator that functions implicitly use</z><z id="t1484141143" t="nathanmarz You would use it in a situation like this: (defn foo [afn data] (select [ALL (pred afn)] data)) "><y>#</y><d>2017-01-11</d><h>13:25</h><w>nathanmarz</w>You would use it in a situation like this:
<pre>(defn foo [afn data]
  (select [ALL (pred afn)] data))
</pre></z><z id="t1484141184" t="nathanmarz if you were just to do (select [ALL afn] data) there&apos;s no way to know what the type of that local will be (or whether it will change on every invocation, so specter would have to figure that out on every single invocation"><y>#</y><d>2017-01-11</d><h>13:26</h><w>nathanmarz</w>if you were just to do <code>(select [ALL afn] data)</code> there&apos;s no way to know what the type of that local will be (or whether it will change on every invocation, so specter would have to figure that out on every single invocation</z><z id="t1484141191" t="nathanmarz which would hurt performance"><y>#</y><d>2017-01-11</d><h>13:26</h><w>nathanmarz</w>which would hurt performance</z><z id="t1484141225" t="nathanmarz by explicitly saying it&apos;s pred , the inline compiler can bake it into the path and avoid that coercion at runtime"><y>#</y><d>2017-01-11</d><h>13:27</h><w>nathanmarz</w>by explicitly saying it&apos;s <code>pred</code>, the inline compiler can bake it into the path and avoid that coercion at runtime</z><z id="t1484141268" t="nathanmarz a common use case of selected? is finding all values in a map where the key matches some criteria"><y>#</y><d>2017-01-11</d><h>13:27</h><w>nathanmarz</w>a common use case of <code>selected?</code> is finding all values in a map where the key matches some criteria</z><z id="t1484141291" t="nathanmarz e.g. (select [ALL (selected? FIRST some-predicate?) LAST] amap)"><y>#</y><d>2017-01-11</d><h>13:28</h><w>nathanmarz</w>e.g. <code>(select [ALL (selected? FIRST some-predicate?) LAST] amap)</code></z><z id="t1484141302" t="nathanmarz lot of other use cases of course"><y>#</y><d>2017-01-11</d><h>13:28</h><w>nathanmarz</w>lot of other use cases of course</z><z id="t1484141323" t="nathanmarz as for theoretical underpinnings... no"><y>#</y><d>2017-01-11</d><h>13:28</h><w>nathanmarz</w>as for theoretical underpinnings... no</z><z id="t1484141359" t="nathanmarz the specter API is the result of me unifying a ton of data manipulation use cases into the simplest possible abstractions"><y>#</y><d>2017-01-11</d><h>13:29</h><w>nathanmarz</w>the specter API is the result of me unifying a ton of data manipulation use cases into the simplest possible abstractions</z><z id="t1484141403" t="nathanmarz there&apos;s similarities to haskell lenses but also some key differences"><y>#</y><d>2017-01-11</d><h>13:30</h><w>nathanmarz</w>there&apos;s similarities to haskell lenses but also some key differences</z><z id="t1484153812" t="gdeer81 I&apos;m starting over and playing with examples to see if I can stub my toe and document beginner gotchas. here&apos;s an interesting example : (setval [:peeps END] [:name &quot;Moe&quot;] {:peeps [{:name &quot;Larry&quot; } {:name &quot;Curly&quot;}]}) (setval [:peeps END] {:name &quot;Moe&quot;} {:peeps [{:name &quot;Larry&quot; } {:name &quot;Curly&quot;}]}) (setval [:peeps END] [{:name &quot;Moe&quot;}] {:peeps [{:name &quot;Larry&quot; } {:name &quot;Curly&quot;}]})"><y>#</y><d>2017-01-11</d><h>16:56</h><w>gdeer81</w>I&apos;m starting over and playing with examples to see if I can stub my toe and document beginner gotchas. here&apos;s an interesting example : <code>(setval [:peeps END] [:name &quot;Moe&quot;] {:peeps [{:name &quot;Larry&quot; } {:name &quot;Curly&quot;}]})</code>
<code>(setval [:peeps END] {:name &quot;Moe&quot;} {:peeps [{:name &quot;Larry&quot; } {:name &quot;Curly&quot;}]})</code>
<code>(setval [:peeps END] [{:name &quot;Moe&quot;}] {:peeps [{:name &quot;Larry&quot; } {:name &quot;Curly&quot;}]})</code></z><z id="t1484154079" t="gdeer81 the first one adds the key and string to the vector, the second adds a vector with the keyword and string to the vector and the last does what I was looking for and adds the map for Moe to the vector of maps"><y>#</y><d>2017-01-11</d><h>17:01</h><w>gdeer81</w>the first one adds the key and string to the vector, the second adds a vector with the keyword and string to the vector and the last does what I was looking for and adds the map for Moe to the vector of maps</z><z id="t1484198580" t="gdeer81 Early access to Specter Koans: https://github.com/gdeer81/specter-koans currently only covers select and navigation and only takes about 10 minutes to complete but I&apos;m going to constantly be adding more"><y>#</y><d>2017-01-12</d><h>05:23</h><w>gdeer81</w>Early access to Specter Koans: <a href="https://github.com/gdeer81/specter-koans" target="_blank">https://github.com/gdeer81/specter-koans</a> currently only covers select and navigation and only takes about 10 minutes to complete but I&apos;m going to constantly be adding more</z><z id="t1484211495" t="schmee nice, I’ll check em out later today!"><y>#</y><d>2017-01-12</d><h>08:58</h><w>schmee</w>nice, I’ll check em out later today!</z><z id="t1484215514" t="james @gdeer81 Great initiative!"><y>#</y><d>2017-01-12</d><h>10:05</h><w>james</w>@gdeer81 Great initiative!</z><z id="t1484215707" t="james Is there a bug here? &quot;FIRST is obvious on collections except for on a map&quot; (= true (= [[0 :a]] (select FIRST (sorted-map 0 :a 1 :b)))) &quot;You will also run into the same thing with LAST on a map&quot; (= false (= [1 :b] (select LAST (sorted-map 0 :a 1 :b)))) As you can’t guarantee order in a map, you can&apos;t know in advance if the result will be true or false. I guess this might be confusing for some people."><y>#</y><d>2017-01-12</d><h>10:08</h><w>james</w>Is there a bug here?
<pre>&quot;FIRST is obvious on collections except for on a map&quot;
 (= true (= [[0 :a]] (select FIRST (sorted-map 0 :a 1 :b))))

 &quot;You will also run into the same thing with LAST on a map&quot;
 (= false (= [1 :b] (select LAST (sorted-map 0 :a 1 :b))))
</pre>
As you can’t guarantee order in a map, you can&apos;t know in advance if the result will be true or false. I guess this might be confusing for some people.</z><z id="t1484215997" t="bfabry I think you&apos;re just missing a wrapping set of [] for the second assertion"><y>#</y><d>2017-01-12</d><h>10:13</h><w>bfabry</w>I think you&apos;re just missing a wrapping set of [] for the second assertion</z><z id="t1484216072" t="bfabry because (though this could just be lucky) (first (sorted-map 0 :a 1 :b)) =&gt; [0 :a] (last (sorted-map 0 :a 1 :b)) =&gt; [1 :b] (sp/select sp/FIRST (sorted-map 0 :a 1 :b)) =&gt; [[0 :a]] (sp/select sp/LAST (sorted-map 0 :a 1 :b)) =&gt; [[1 :b]] "><y>#</y><d>2017-01-12</d><h>10:14</h><w>bfabry</w>because (though this could just be lucky)
<pre>(first (sorted-map 0 :a 1 :b))
=&gt; [0 :a]
(last (sorted-map 0 :a 1 :b))
=&gt; [1 :b]
(sp/select sp/FIRST (sorted-map 0 :a 1 :b))
=&gt; [[0 :a]]
(sp/select sp/LAST (sorted-map 0 :a 1 :b))
=&gt; [[1 :b]]
</pre></z><z id="t1484236612" t="gdeer81 @james that one was actually pulled from the example https://github.com/nathanmarz/specter/wiki/List-of-Navigators#first but it looks like I used select instead of select-one"><y>#</y><d>2017-01-12</d><h>15:56</h><w>gdeer81</w>@james that one was actually pulled from the example <a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#first" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#first</a> but it looks like I used select instead of select-one</z><z id="t1484239515" t="gdeer81 @bfabry yeah this koan has taught me to pay attention to which select function I&apos;m using lol"><y>#</y><d>2017-01-12</d><h>16:45</h><w>gdeer81</w>@bfabry yeah this koan has taught me to pay attention to which select function I&apos;m using lol</z><z id="t1484240489" t="devth checking out specter, looks great so far. one thing i&apos;m trying to figure out is, given a nested data structure and a leaf node (e.g. :foo ), can specter compute the path to that node for me?"><y>#</y><d>2017-01-12</d><h>17:01</h><w>devth</w>checking out specter, looks great so far. one thing i&apos;m trying to figure out is, given a nested data structure and a leaf node (e.g. <code>:foo</code>), can specter compute the path to that node for me?</z><z id="t1484240573" t="nathanmarz @devth you&apos;re looking for this: https://github.com/nathanmarz/specter/issues/49"><y>#</y><d>2017-01-12</d><h>17:02</h><w>nathanmarz</w>@devth you&apos;re looking for this: <a href="https://github.com/nathanmarz/specter/issues/49" target="_blank">https://github.com/nathanmarz/specter/issues/49</a></z><z id="t1484240575" t="nathanmarz not implemented"><y>#</y><d>2017-01-12</d><h>17:02</h><w>nathanmarz</w>not implemented</z><z id="t1484240598" t="nathanmarz you can do it manually for some cases using value collection (`collect` and collect-one )"><y>#</y><d>2017-01-12</d><h>17:03</h><w>nathanmarz</w>you can do it manually for some cases using value collection (`collect` and <code>collect-one</code>)</z><z id="t1484240670" t="devth thanks. i&apos;ll play with it"><y>#</y><d>2017-01-12</d><h>17:04</h><w>devth</w>thanks. i&apos;ll play with it</z><z id="t1484242359" t="devth doesn&apos;t collect require that you know the path ahead of time? e.g. searching for :qux in a given structure – [:foo/bar {:baz/a [:qux]}] as an example"><y>#</y><d>2017-01-12</d><h>17:32</h><w>devth</w>doesn&apos;t <code>collect</code> require that you know the path ahead of time? e.g. searching for <code>:qux</code> in a given structure – <code>[:foo/bar {:baz/a [:qux]}]</code> as an example</z><z id="t1484246078" t="nathanmarz @devth there&apos;s an example above of what I mean"><y>#</y><d>2017-01-12</d><h>18:34</h><w>nathanmarz</w>@devth there&apos;s an example above of what I mean</z><z id="t1484246086" t="nathanmarz here: (defnav ALL-INDEXED [] (select* [this structure next-fn] ;; fill this in ) (transform* [this structure next-fn] (map-indexed (fn [i v] (second (next-fn [i v]))) structure ))) (def MyPath (recursive-path [] p (cond-path map? [ALL (collect-one FIRST) LAST p] vector? [ALL-INDEXED (collect-one FIRST) LAST p] STAY STAY))) (transform MyPath (fn [&amp; vals] vals) {:a {:b [:apple :orange :pear] :c [:juice]} :e [:cat :dog]}) "><y>#</y><d>2017-01-12</d><h>18:34</h><w>nathanmarz</w>here:
<pre>(defnav ALL-INDEXED []
  (select* [this structure next-fn]
    ;; fill this in
    )
  (transform* [this structure next-fn]
    (map-indexed
      (fn [i v]
        (second (next-fn [i v])))
      structure
      )))


(def MyPath
  (recursive-path [] p
    (cond-path map? [ALL (collect-one FIRST) LAST p]
               vector? [ALL-INDEXED (collect-one FIRST) LAST p]
               STAY STAY)))

(transform MyPath
  (fn [&amp; vals] vals)
  {:a {:b [:apple :orange :pear]
   :c [:juice]}
   :e [:cat :dog]})
</pre></z><z id="t1484246103" t="devth @nathanmarz awesome, thanks!"><y>#</y><d>2017-01-12</d><h>18:35</h><w>devth</w>@nathanmarz awesome, thanks!</z><z id="t1484246211" t="nathanmarz if you filled in select* for ALL-INDEXED then you could do (select MyPath data) to retrieve the paths to each leaf element"><y>#</y><d>2017-01-12</d><h>18:36</h><w>nathanmarz</w>if you filled in <code>select*</code> for <code>ALL-INDEXED</code>  then you could do <code>(select MyPath data)</code> to retrieve the paths to each leaf element</z><z id="t1484283177" t="qqq I&apos;m looking for &quot;closest to leaf&quot; nodes that: (1) have a :node filed, (2) have an empty :children field how do I do this?"><y>#</y><d>2017-01-13</d><h>04:52</h><w>qqq</w>I&apos;m looking for &quot;closest to leaf&quot; nodes that:
(1) have a :node filed, (2) have an empty :children field
how do I do this?</z><z id="t1484283190" t="qqq I think it&apos;s something dealing with walk, but I don&apos;t knowhow to &quot;force to the leafs&quot;"><y>#</y><d>2017-01-13</d><h>04:53</h><w>qqq</w>I think it&apos;s something dealing with walk, but I don&apos;t knowhow to &quot;force to the leafs&quot;</z><z id="t1484283231" t="qqq {:node {:name &quot;tex&quot; :key :tex} :children [{:node {:name &quot;glyph&quot; :key :glpyh}} {:node {:name &quot;resize&quot; :key :resize}} {:node {:name &quot;frac&quot; :key :frac}}]} ^^ something like this, but it&apos;s a deep . / big tree, and I want the &apos;glph/resize/frac nodes"><y>#</y><d>2017-01-13</d><h>04:53</h><w>qqq</w><pre>{:node {:name &quot;tex&quot; :key :tex}
   :children
   [{:node {:name &quot;glyph&quot; :key :glpyh}}
    {:node {:name &quot;resize&quot; :key :resize}}
    {:node {:name &quot;frac&quot; :key :frac}}]}
</pre>
^^ something like this, but it&apos;s a deep . / big tree, and I want the &apos;glph/resize/frac nodes</z></g><g id="s9"><z id="t1484284588" t="qqq does specter allow &apos;recursive selectors&apos; without using walk?"><y>#</y><d>2017-01-13</d><h>05:16</h><w>qqq</w>does specter allow &apos;recursive selectors&apos; without using walk?</z><z id="t1484284599" t="qqq I want something that says :stay -- and then process :children ALL, recursively"><y>#</y><d>2017-01-13</d><h>05:16</h><w>qqq</w>I want something that says :stay -- and then process :children ALL, recursively</z><z id="t1484286933" t="qqq specter&apos;s ALL is only &quot;process one level&quot;; is there a recursive-all which processes all subtrees?"><y>#</y><d>2017-01-13</d><h>05:55</h><w>qqq</w>specter&apos;s ALL is only &quot;process one level&quot;; is there a recursive-all which processes all subtrees?</z><z id="t1484305243" t="qqq @nathanmarz : is there any version of specter that runs on java 7? I need to deploy on GAE and spcter appears to reqauire some jav a8 feature"><y>#</y><d>2017-01-13</d><h>11:00</h><w>qqq</w>@nathanmarz : is there any version of specter that runs on java 7? I need to deploy on GAE and spcter appears to reqauire some jav a8 feature</z><z id="t1484316913" t="nathanmarz @qqq that&apos;s easy with recursive-path"><y>#</y><d>2017-01-13</d><h>14:15</h><w>nathanmarz</w>@qqq that&apos;s easy with <code>recursive-path</code></z><z id="t1484316928" t="nathanmarz specter should work fine on java 7, are you running into an issue?"><y>#</y><d>2017-01-13</d><h>14:15</h><w>nathanmarz</w>specter should work fine on java 7, are you running into an issue?</z><z id="t1484442253" t="schmee qqq this seems to work: (def DeepKeys (recursive-path [] p (if-path (must :children) [:children ALL p] [:node :key]))) "><y>#</y><d>2017-01-15</d><h>01:04</h><w>schmee</w>qqq this seems to work: <pre>(def DeepKeys
  (recursive-path [] p
    (if-path (must :children)
      [:children ALL p]
      [:node :key])))
</pre></z><z id="t1484476783" t="qqq is it possible to go a step further and say &quot;:children&quot; is not empty?"><y>#</y><d>2017-01-15</d><h>10:39</h><w>qqq</w>is it possible to go a step further and say &quot;:children&quot; is not empty?</z><z id="t1484476792" t="qqq I wnat (must :children -- this part is not empty)"><y>#</y><d>2017-01-15</d><h>10:39</h><w>qqq</w>I wnat (must :children -- this part is not empty)</z><z id="t1484478753" t="nathanmarz @qqq you can replace (must :children) with [:children FIRST]"><y>#</y><d>2017-01-15</d><h>11:12</h><w>nathanmarz</w>@qqq you can replace <code>(must :children)</code> with <code>[:children FIRST]</code></z><z id="t1484478799" t="qqq @nathanmarz : I found that #(not-empty (:children %)) also worked"><y>#</y><d>2017-01-15</d><h>11:13</h><w>qqq</w>@nathanmarz : I found that #(not-empty (:children %)) also worked</z><z id="t1484478818" t="qqq is the main disaadvantage t omy appraoch lack of optimizability since the funciton is &apos;opaque&apos; ?"><y>#</y><d>2017-01-15</d><h>11:13</h><w>qqq</w>is the main disaadvantage t omy appraoch lack of optimizability since the funciton is &apos;opaque&apos; ?</z><z id="t1484478952" t="nathanmarz no"><y>#</y><d>2017-01-15</d><h>11:15</h><w>nathanmarz</w>no</z><z id="t1484478966" t="nathanmarz the function approach might be a little faster"><y>#</y><d>2017-01-15</d><h>11:16</h><w>nathanmarz</w>the function approach might be a little faster</z><z id="t1484478979" t="nathanmarz you&apos;d have to profile it"><y>#</y><d>2017-01-15</d><h>11:16</h><w>nathanmarz</w>you&apos;d have to profile it</z><z id="t1484505364" t="richiardiandrea the recursive approach is very neat"><y>#</y><d>2017-01-15</d><h>18:36</h><w>richiardiandrea</w>the recursive approach is very neat</z><z id="t1484530920" t="richiardiandrea so if i do something like: (sp/transform [:family :relationship sp/ALL] #(dadada) family) The :relationship key is created even when it is missing. Is there a way to avoid it? Meaning I don&apos;t want to create it at all if it was not there in the first place?"><y>#</y><d>2017-01-16</d><h>01:42</h><w>richiardiandrea</w>so if i do something like:
<pre>(sp/transform [:family
                 :relationship
                 sp/ALL]
                #(dadada)
                family)
</pre>
The <code>:relationship</code> key is created even when it is missing. Is there a way to avoid it? Meaning I don&apos;t want to create it at all if it was not there in the first place?</z><z id="t1484553878" t="schmee richiardiandrea use (must :relationship)"><y>#</y><d>2017-01-16</d><h>08:04</h><w>schmee</w>richiardiandrea use <code>(must :relationship)</code></z><z id="t1484557528" t="schmee https://github.com/nathanmarz/specter/wiki/List-of-Navigators#must"><y>#</y><d>2017-01-16</d><h>09:05</h><w>schmee</w><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#must" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#must</a></z><z id="t1484557536" t="schmee keypath might also be of interest"><y>#</y><d>2017-01-16</d><h>09:05</h><w>schmee</w><code>keypath</code> might also be of interest</z><z id="t1484580645" t="richiardiandrea @schmee thanks! Will try soon"><y>#</y><d>2017-01-16</d><h>15:30</h><w>richiardiandrea</w>@schmee thanks! Will try soon</z><z id="t1484777797" t="zane Has anyone successfully used core.match inside of a recursive path definition?"><y>#</y><d>2017-01-18</d><h>22:16</h><w>zane</w>Has anyone successfully used <code>core.match</code> inside of a recursive path definition?</z><z id="t1484856116" t="zane @nathanmarz, recursive-path is fantastic. Thanks!"><y>#</y><d>2017-01-19</d><h>20:01</h><w>zane</w>@nathanmarz, <code>recursive-path</code> is fantastic. Thanks!</z><z id="t1485221381" t="narkisr Hey, I&apos;m looking for a way to replace a single nested value {:one #{:two}} with a splattered list of values {:one #{1 2 3 4}} using transform"><y>#</y><d>2017-01-24</d><h>01:29</h><w>narkisr</w>Hey, I&apos;m looking for a way to replace a single nested value {:one #{:two}} with a splattered list of values {:one #{1 2 3 4}} using transform</z><z id="t1485221405" t="narkisr Not sure if thats possible"><y>#</y><d>2017-01-24</d><h>01:30</h><w>narkisr</w>Not sure if thats possible</z><z id="t1485244018" t="james @narkisr How about setval ?"><y>#</y><d>2017-01-24</d><h>07:46</h><w>james</w>@narkisr How about <code>setval</code>?</z><z id="t1485244034" t="james (setval [:one] #{1 2 3 4} {:one #{:two}}) &gt; {:one #{1 4 3 2}}"><y>#</y><d>2017-01-24</d><h>07:47</h><w>james</w><pre>(setval [:one] #{1 2 3 4} {:one #{:two}})
&gt; {:one #{1 4 3 2}}</pre></z><z id="t1485248141" t="narkisr Hey James, I need the to be a result of a function call (transformation) and not a static value like in setval"><y>#</y><d>2017-01-24</d><h>08:55</h><w>narkisr</w>Hey James, I need the to be a result of a function call (transformation) and not a static value like in setval</z><z id="t1485248155" t="narkisr the value"><y>#</y><d>2017-01-24</d><h>08:55</h><w>narkisr</w>the value</z><z id="t1485251869" t="james @narkisr (transform [:one] (constantly #{1 2 3 4}) {:one #{:two}})"><y>#</y><d>2017-01-24</d><h>09:57</h><w>james</w>@narkisr <pre>(transform [:one] (constantly #{1 2 3 4}) {:one #{:two}})</pre></z><z id="t1485251872" t="james Does that help?"><y>#</y><d>2017-01-24</d><h>09:57</h><w>james</w>Does that help?</z><z id="t1485262373" t="narkisr So In my case I&apos;m transforming the keys into a list of vectors for example (tranform [:one :two] (fn [_] [[1 2] [3 4]]) {:one #{:two}}) I would like to get {:one #{[1 2] [3 4]}}"><y>#</y><d>2017-01-24</d><h>12:52</h><w>narkisr</w>So In my case I&apos;m transforming the keys into a list of vectors for example (tranform [:one :two] (fn [_] [[1 2] [3 4]]) {:one #{:two}}) I would like to get {:one #{[1 2] [3 4]}}</z><z id="t1485262393" t="narkisr And not {:one #{[[1 2] [3 4]]}}"><y>#</y><d>2017-01-24</d><h>12:53</h><w>narkisr</w>And not  {:one #{[[1 2] [3 4]]}}</z><z id="t1485262468" t="narkisr Its looks like partial flatten but I didn&apos;t manage to come without any working example"><y>#</y><d>2017-01-24</d><h>12:54</h><w>narkisr</w>Its looks like partial flatten but I didn&apos;t manage to come without any working example</z><z id="t1485264420" t="nathanmarz @narkisr I think you&apos;re looking for this: (transform [:one (subset #{:two})] (fn [_] #{[1 2] [3 4]}) {:one #{two}})"><y>#</y><d>2017-01-24</d><h>13:27</h><w>nathanmarz</w>@narkisr I think you&apos;re looking for this: <code>(transform [:one (subset #{:two})] (fn [_] #{[1 2] [3 4]}) {:one #{two}})</code></z><z id="t1485264447" t="james @narkisr Do you actually want the inner data structure to be a set? Because you’re trying to access it like a hashmap (with a keyword), and talking about “transforming keys&quot;."><y>#</y><d>2017-01-24</d><h>13:27</h><w>james</w>@narkisr Do you actually want the inner data structure to be a set? Because you’re trying to access it like a hashmap (with a keyword), and talking about “transforming keys&quot;.</z><z id="t1485267503" t="narkisr The actual code contains a hash which values are days like :sunday which I want so substitute for all the Sundays within a month (so you get multiple values out from a single value)"><y>#</y><d>2017-01-24</d><h>14:18</h><w>narkisr</w>The actual code contains a hash which values are days like :sunday which I want so substitute for all the Sundays within a month (so you get multiple values out from a single value)</z><z id="t1485267544" t="narkisr A set matches this use since the values are always unique"><y>#</y><d>2017-01-24</d><h>14:19</h><w>narkisr</w>A set matches this use since the values are always unique</z><z id="t1485267601" t="narkisr Thanks Natan ill give it a go"><y>#</y><d>2017-01-24</d><h>14:20</h><w>narkisr</w>Thanks Natan ill give it a go</z><z id="t1485267724" t="narkisr for example {:foo #{:sunday}} =&gt; {:foo #{[1 1] [8 1] [15 1] [22 1] [29 1]}"><y>#</y><d>2017-01-24</d><h>14:22</h><w>narkisr</w>for example {:foo #{:sunday}} =&gt; {:foo #{[1 1] [8 1] [15 1] [22 1]  [29 1]}</z><z id="t1485267745" t="narkisr all the Sundays in Jan 2017"><y>#</y><d>2017-01-24</d><h>14:22</h><w>narkisr</w>all the Sundays in Jan 2017</z><z id="t1485304198" t="narkisr Hey Natan its seems that subset does not fit the bill in my case because the values that I&apos;m replace are based on a pred"><y>#</y><d>2017-01-25</d><h>00:29</h><w>narkisr</w>Hey Natan its seems that subset does not fit the bill in my case because the values that I&apos;m replace are based on a pred</z><z id="t1485304291" t="narkisr (tranform [:one (pred keyword?)] (fn [_] [[1 2] [3 4]]) {:one #{:two}})"><y>#</y><d>2017-01-25</d><h>00:31</h><w>narkisr</w>(tranform [:one (pred keyword?)] (fn [_] [[1 2] [3 4]]) {:one #{:two}})</z><z id="t1485305441" t="narkisr Ok managed to solve it"><y>#</y><d>2017-01-25</d><h>00:50</h><w>narkisr</w>Ok managed to solve it</z><z id="t1485305505" t="narkisr Since my kewords are days its closed set (so subset works) but id be curious on how you can use pred to substitute values"><y>#</y><d>2017-01-25</d><h>00:51</h><w>narkisr</w>Since my kewords are days its closed set (so subset works) but id be curious on how you can use pred to substitute values</z><z id="t1485316384" t="nathanmarz @narkisr you would need to iterate over all the values and check the predicate against each value"><y>#</y><d>2017-01-25</d><h>03:53</h><w>nathanmarz</w>@narkisr you would need to iterate over all the values and check the predicate against each value</z><z id="t1485316441" t="nathanmarz ALL isn&apos;t currently implemented for sets though"><y>#</y><d>2017-01-25</d><h>03:54</h><w>nathanmarz</w><code>ALL</code> isn&apos;t currently implemented for sets though</z><z id="t1485316466" t="nathanmarz you could either use a vector there instead of a set or make an ALL-SET-ELEMS navigator"><y>#</y><d>2017-01-25</d><h>03:54</h><w>nathanmarz</w>you could either use a vector there instead of a set or make an <code>ALL-SET-ELEMS</code> navigator</z><z id="t1485316474" t="nathanmarz (or open a pull request to extend ALL to sets)"><y>#</y><d>2017-01-25</d><h>03:54</h><w>nathanmarz</w>(or open a pull request to extend <code>ALL</code> to sets)</z><z id="t1485348602" t="narkisr Thank you Natan, ill take a look on what it takes to add support for that"><y>#</y><d>2017-01-25</d><h>12:50</h><w>narkisr</w>Thank you Natan, ill take a look on what it takes to add support for that</z><z id="t1485349212" t="narkisr Nathan*"><y>#</y><d>2017-01-25</d><h>13:00</h><w>narkisr</w>Nathan*</z><z id="t1485352469" t="nathanmarz @narkisr need to extend AllTransformProtocol to PersistentHashSet"><y>#</y><d>2017-01-25</d><h>13:54</h><w>nathanmarz</w>@narkisr need to extend <code>AllTransformProtocol</code> to <code>PersistentHashSet</code></z><z id="t1485352482" t="nathanmarz https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L87"><y>#</y><d>2017-01-25</d><h>13:54</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L87" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L87</a></z><z id="t1485352596" t="nathanmarz @narkisr actually just realized that ALL already handles sets via the default case, it&apos;s just not optimized like the other data structures"><y>#</y><d>2017-01-25</d><h>13:56</h><w>nathanmarz</w>@narkisr actually just realized that <code>ALL</code> already handles sets via the default case, it&apos;s just not optimized like the other data structures</z><z id="t1485530350" t="rauh I&apos;m guessing setval is faster than assoc-in ? Can&apos;t find setval at all in the performance gist."><y>#</y><d>2017-01-27</d><h>15:19</h><w>rauh</w>I&apos;m guessing <code>setval</code> is faster than <code>assoc-in</code>? Can&apos;t find <code>setval</code> at all in the performance gist.</z><z id="t1485531332" t="nathanmarz @rauh setval is just a thin wrapper over transform"><y>#</y><d>2017-01-27</d><h>15:35</h><w>nathanmarz</w>@rauh <code>setval</code> is just a thin wrapper over transform</z><z id="t1485531360" t="nathanmarz haven&apos;t benchmarked assoc-in but I&apos;d guess setval is faster"><y>#</y><d>2017-01-27</d><h>15:36</h><w>nathanmarz</w>haven&apos;t benchmarked <code>assoc-in</code> but I&apos;d guess <code>setval</code> is faster</z><z id="t1485531362" t="rauh I see, did a non-scientific time and it looks like it&apos;s slightly faster. setval , that is"><y>#</y><d>2017-01-27</d><h>15:36</h><w>rauh</w>I see, did a non-scientific <code>time</code> and it looks like it&apos;s slightly faster. <code>setval</code>, that is</z><z id="t1485531542" t="nathanmarz it&apos;s over 3x faster"><y>#</y><d>2017-01-27</d><h>15:39</h><w>nathanmarz</w>it&apos;s over 3x faster</z><z id="t1485531546" t="nathanmarz ******************************** Benchmark: set value in nested map (2500000 iterations) Avg(ms) vs best Code 370.15 1.00 (setval [:a :b :c] 1 data) 1240.9 3.35 (assoc-in data [:a :b :c] 1) "><y>#</y><d>2017-01-27</d><h>15:39</h><w>nathanmarz</w><pre>********************************

Benchmark: set value in nested map (2500000 iterations)

Avg(ms)		vs best		Code
370.15 		 1.00 		 (setval [:a :b :c] 1 data)
1240.9 		 3.35 		 (assoc-in data [:a :b :c] 1)
</pre></z><z id="t1486138371" t="nha Is specter suited to transform clojure map keys? {:a {:b {:c 123}} :d 456} {:a_b_c 123 :d 456} Something like that, back and forth."><y>#</y><d>2017-02-03</d><h>16:12</h><w>nha</w>Is specter suited to transform clojure map keys?
<pre>{:a {:b {:c 123}} :d 456}
{:a_b_c 123 :d 456}
</pre>
Something like that, back and forth.</z><z id="t1486138709" t="nathanmarz @nha you can do something like this: user=&gt; (def PATH-MAP-WALKER #_=&gt; (recursive-path [] p #_=&gt; (if-path map? #_=&gt; [ALL (collect-one FIRST) LAST p] #_=&gt; STAY #_=&gt; ))) #&apos;user/PATH-MAP-WALKER user=&gt; user=&gt; user=&gt; (reduce #_=&gt; (fn [m path] #_=&gt; (assoc m (apply str (butlast path)) (last path))) #_=&gt; {} #_=&gt; (traverse PATH-MAP-WALKER {:a {:b {:c 1}} :d 2})) {&quot;:a:b:c&quot; 1, &quot;:d&quot; 2} "><y>#</y><d>2017-02-03</d><h>16:18</h><w>nathanmarz</w>@nha you can do something like this:
<pre>user=&gt; (def PATH-MAP-WALKER
  #_=&gt;   (recursive-path [] p
  #_=&gt;     (if-path map?
  #_=&gt;       [ALL (collect-one FIRST) LAST p]
  #_=&gt;       STAY
  #_=&gt;       )))
#&apos;user/PATH-MAP-WALKER
user=&gt; 

user=&gt; 

user=&gt; (reduce
  #_=&gt;   (fn [m path]
  #_=&gt;     (assoc m (apply str (butlast path)) (last path)))
  #_=&gt;   {}
  #_=&gt;   (traverse PATH-MAP-WALKER {:a {:b {:c 1}} :d 2}))
{&quot;:a:b:c&quot; 1, &quot;:d&quot; 2}
</pre></z><z id="t1486140096" t="nha Nice 🙂 I don’t really understand the traverse part: it returns a function? Can I view it as a collection? (I am trying to make the reverse function now - but I am also just starting out with specter)"><y>#</y><d>2017-02-03</d><h>16:41</h><w>nha</w>Nice <b>🙂</b> I don’t really understand the traverse part: it returns a function? Can I view it as a collection?
(I am trying to make the reverse function now - but I am also just starting out with specter)</z><z id="t1486140152" t="nha Ah, get it reducible object ."><y>#</y><d>2017-02-03</d><h>16:42</h><w>nha</w>Ah, get it <code>reducible object</code>.</z><z id="t1486140886" t="nathanmarz @nha traverse is very efficient, there&apos;s no materialization of intermediate data structures (similar to transducers)"><y>#</y><d>2017-02-03</d><h>16:54</h><w>nathanmarz</w>@nha <code>traverse</code> is very efficient, there&apos;s no materialization of intermediate data structures (similar to transducers)</z><z id="t1486140938" t="nha Yes, starting to understand that 🙂 Seems easy enough to modify even without understanding every fn in there. Thanks!"><y>#</y><d>2017-02-03</d><h>16:55</h><w>nha</w>Yes, starting to understand that <b>🙂</b>
Seems easy enough to modify even without understanding every fn in there. Thanks!</z><z id="t1486763442" t="bradford Hi all! I&apos;m trying to get better at Specter. I&apos;m doing a lot of parsing HAR files for metadata. I&apos;m able to do what I want, but it feels...inefficient. like this: (select [ALL #(or (re-find #&quot;css&quot; (get-in % [:response :content :mimeType])) (and (re-find #&quot;html&quot; (get-in % [:response :content :mimeType])) (re-find #&quot;tff|woff&quot; (get-in % [:request :url])) ) (re-find #&quot;font&quot; (get-in % [:response :content :mimeType])) (and (re-find #&quot;javascript&quot; (get-in % [:response :content :mimeType])) (re-find #&quot;js&quot; (get-in % [:request :url])) ) (and (re-find #&quot;image&quot; (get-in % [:response :content :mimeType])) (re-find #&quot;jpg|png|gif|bmp|ico&quot; (get-in % [:request :url])) ) ) [:request :url]] f)"><y>#</y><d>2017-02-10</d><h>21:50</h><w>bradford</w>Hi all! I&apos;m trying to get better at Specter. I&apos;m doing a lot of parsing HAR files for metadata. I&apos;m able to do what I want, but it feels...inefficient. like this: <pre>(select [ALL #(or 
                   (re-find #&quot;css&quot; (get-in % [:response :content :mimeType]))
                   (and (re-find #&quot;html&quot; (get-in % [:response :content :mimeType]))
                        (re-find #&quot;tff|woff&quot; (get-in % [:request :url]))
                        )
                   (re-find #&quot;font&quot; (get-in % [:response :content :mimeType]))
                   (and (re-find #&quot;javascript&quot; (get-in % [:response :content :mimeType]))
                        (re-find #&quot;js&quot; (get-in % [:request :url]))
                        )
                   (and (re-find #&quot;image&quot; (get-in % [:response :content :mimeType]))
                        (re-find #&quot;jpg|png|gif|bmp|ico&quot; (get-in % [:request :url]))
                        )

                   )
         [:request :url]] f)</pre></z><z id="t1486763450" t="bradford Is there a cleaner way to do this?"><y>#</y><d>2017-02-10</d><h>21:50</h><w>bradford</w>Is there a cleaner way to do this?</z><z id="t1486763480" t="bradford (I&apos;m trying to extract URLs that match certain mimeTypes)"><y>#</y><d>2017-02-10</d><h>21:51</h><w>bradford</w>(I&apos;m trying to extract URLs that match certain mimeTypes)</z><z id="t1486765270" t="nathanmarz @bradford I think this is cleaner and it should be much more efficient as well: (defn ^:direct-nav my-matcher [exp1 exp2] (collected? [part1 part2] (and (or (not exp1) (re-find exp1 part1)) (or (not exp2) (re-find exp2 part2))) )) (select [ALL (selected? (collect-one :response :content :mimeType) (collect-one :request :url) (multi-path (my-matcher #&quot;css&quot; nil) (my-matcher #&quot;font&quot; nil) (my-matcher #&quot;html&quot; #&quot;tff|woff&quot;) (my-matcher #&quot;javascript&quot; #&quot;js&quot;) (my-matcher #&quot;image&quot; #&quot;jpg|png|gif|bmp|ico&quot;) )) :request :url] f) "><y>#</y><d>2017-02-10</d><h>22:21</h><w>nathanmarz</w>@bradford I think this is cleaner and it should be much more efficient as well:
<pre>(defn ^:direct-nav my-matcher [exp1 exp2]
  (collected? [part1 part2]
    (and (or (not exp1)
             (re-find exp1 part1))
         (or (not exp2)
             (re-find exp2 part2)))
    ))

(select [ALL 
         (selected?
          (collect-one :response :content :mimeType)
          (collect-one :request :url)
          (multi-path
            (my-matcher #&quot;css&quot; nil)
            (my-matcher #&quot;font&quot; nil)
            (my-matcher #&quot;html&quot; #&quot;tff|woff&quot;)
            (my-matcher #&quot;javascript&quot; #&quot;js&quot;)
            (my-matcher #&quot;image&quot; #&quot;jpg|png|gif|bmp|ico&quot;)
            ))
         :request
         :url]
        f)
</pre></z><z id="t1486765611" t="zane ^:direct-nav ?"><y>#</y><d>2017-02-10</d><h>22:26</h><w>zane</w><code>^:direct-nav</code>?</z><z id="t1486765634" t="nathanmarz minor optimization, not necessary"><y>#</y><d>2017-02-10</d><h>22:27</h><w>nathanmarz</w>minor optimization, not necessary</z><z id="t1486765645" t="zane Hmm."><y>#</y><d>2017-02-10</d><h>22:27</h><w>zane</w>Hmm.</z><z id="t1486765659" t="nathanmarz explained in https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation"><y>#</y><d>2017-02-10</d><h>22:27</h><w>nathanmarz</w>explained in <a href="https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation" target="_blank">https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation</a></z><z id="t1486765665" t="zane Is it idiomatic to use collect-one in that way if you&apos;re trying to, uh, introduce a variable that will be used by a downstream navigator?"><y>#</y><d>2017-02-10</d><h>22:27</h><w>zane</w>Is it idiomatic to use <code>collect-one</code> in that way if you&apos;re trying to, uh, introduce a variable that will be used by a downstream navigator?</z><z id="t1486765712" t="zane Let me see if I can rephrase that question to make it clearer… 🤔"><y>#</y><d>2017-02-10</d><h>22:28</h><w>zane</w>Let me see if I can rephrase that question to make it clearer… <b>🤔</b></z><z id="t1486765840" t="zane I wand to use cond-path , but each of the cond-path tests begins with the same (view …) ."><y>#</y><d>2017-02-10</d><h>22:30</h><w>zane</w>I wand to use <code>cond-path</code>, but each of the <code>cond-path</code> tests begins with the same <code>(view …)</code>.</z><z id="t1486765873" t="zane What is the right way to reuse the (view …) results?"><y>#</y><d>2017-02-10</d><h>22:31</h><w>zane</w>What is the right way to reuse the <code>(view …)</code> results?</z><z id="t1486765898" t="nathanmarz yea collect-one + collected? should do what you need"><y>#</y><d>2017-02-10</d><h>22:31</h><w>nathanmarz</w>yea <code>collect-one</code> + <code>collected?</code> should do what you need</z><z id="t1486765928" t="nathanmarz you can use DISPENSE to drop collected values later in path (so they don&apos;t reach your transform-fn, for instance)"><y>#</y><d>2017-02-10</d><h>22:32</h><w>nathanmarz</w>you can use <code>DISPENSE</code> to drop collected values later in path (so they don&apos;t reach your transform-fn, for instance)</z><z id="t1486766014" t="zane Interesting. Let me give this a shot."><y>#</y><d>2017-02-10</d><h>22:33</h><w>zane</w>Interesting. Let me give this a shot.</z><z id="t1486766040" t="nathanmarz you can also use defrichnav to do more custom manipulation of collected values"><y>#</y><d>2017-02-10</d><h>22:34</h><w>nathanmarz</w>you can also use <code>defrichnav</code> to do more custom manipulation of collected values</z><z id="t1486766056" t="nathanmarz look at definition of DISPENSE for an example"><y>#</y><d>2017-02-10</d><h>22:34</h><w>nathanmarz</w>look at definition of <code>DISPENSE</code> for an example</z><z id="t1486766063" t="zane ok"><y>#</y><d>2017-02-10</d><h>22:34</h><w>zane</w>ok</z><z id="t1486766352" t="bradford @nathanmarz oh... very cool. very."><y>#</y><d>2017-02-10</d><h>22:39</h><w>bradford</w>@nathanmarz oh... very cool. very.</z><z id="t1486766442" t="zane Hmm."><y>#</y><d>2017-02-10</d><h>22:40</h><w>zane</w>Hmm.</z><z id="t1486766448" t="zane Should I be thinking of the collected values as … a stack?"><y>#</y><d>2017-02-10</d><h>22:40</h><w>zane</w>Should I be thinking of the collected values as … a stack?</z><z id="t1486766462" t="zane Like, what happens if some upstream navigator before me also collected a few things?"><y>#</y><d>2017-02-10</d><h>22:41</h><w>zane</w>Like, what happens if some upstream navigator before me also collected a few things?</z><z id="t1486766588" t="nathanmarz @zane they&apos;re a vector"><y>#</y><d>2017-02-10</d><h>22:43</h><w>nathanmarz</w>@zane they&apos;re a vector</z><z id="t1486766596" t="nathanmarz new collected values are conj&apos;d to the end"><y>#</y><d>2017-02-10</d><h>22:43</h><w>nathanmarz</w>new collected values are conj&apos;d to the end</z><z id="t1486766665" t="nathanmarz I&apos;m sure there&apos;s room for all sorts of new navigators to help with those sorts of issues"><y>#</y><d>2017-02-10</d><h>22:44</h><w>nathanmarz</w>I&apos;m sure there&apos;s room for all sorts of new navigators to help with those sorts of issues</z><z id="t1486766710" t="zane I see, okay."><y>#</y><d>2017-02-10</d><h>22:45</h><w>zane</w>I see, okay.</z><z id="t1486766713" t="nathanmarz something like (with-fresh-collected (cond-path ...))"><y>#</y><d>2017-02-10</d><h>22:45</h><w>nathanmarz</w>something like <code>(with-fresh-collected  (cond-path ...))</code></z><z id="t1486766718" t="zane Yeah."><y>#</y><d>2017-02-10</d><h>22:45</h><w>zane</w>Yeah.</z><z id="t1486766722" t="zane That&apos;s what I&apos;m itching for."><y>#</y><d>2017-02-10</d><h>22:45</h><w>zane</w>That&apos;s what I&apos;m itching for.</z><z id="t1486766725" t="zane But this&apos;ll work."><y>#</y><d>2017-02-10</d><h>22:45</h><w>zane</w>But this&apos;ll work.</z><z id="t1486766747" t="nathanmarz should be easy to do using richnav and defdynamicnav"><y>#</y><d>2017-02-10</d><h>22:45</h><w>nathanmarz</w>should be easy to do using <code>richnav</code> and <code>defdynamicnav</code></z><z id="t1486766764" t="zane I haven&apos;t yet wrapped my mind around those, I think."><y>#</y><d>2017-02-10</d><h>22:46</h><w>zane</w>I haven&apos;t yet wrapped my mind around those, I think.</z><z id="t1486766767" t="zane Baby steps."><y>#</y><d>2017-02-10</d><h>22:46</h><w>zane</w>Baby steps.</z><z id="t1486766889" t="nathanmarz I opened an issue for it since it&apos;s actually a pretty good idea https://github.com/nathanmarz/specter/issues/175"><y>#</y><d>2017-02-10</d><h>22:48</h><w>nathanmarz</w>I opened an issue for it since it&apos;s actually a pretty good idea <a href="https://github.com/nathanmarz/specter/issues/175" target="_blank">https://github.com/nathanmarz/specter/issues/175</a></z><z id="t1486766937" t="zane There&apos;s no DISPENSE-ONE ?"><y>#</y><d>2017-02-10</d><h>22:48</h><w>zane</w>There&apos;s no <code>DISPENSE-ONE</code>?</z><z id="t1486766949" t="nathanmarz no"><y>#</y><d>2017-02-10</d><h>22:49</h><w>nathanmarz</w>no</z><z id="t1486767007" t="nathanmarz I have a feeling the use cases for that would be better served by with-fresh-collected"><y>#</y><d>2017-02-10</d><h>22:50</h><w>nathanmarz</w>I have a feeling the use cases for that would be better served by <code>with-fresh-collected</code></z><z id="t1486767025" t="nathanmarz not sure, this part of the design space is fairly unexplored"><y>#</y><d>2017-02-10</d><h>22:50</h><w>nathanmarz</w>not sure, this part of the design space is fairly unexplored</z><z id="t1486767031" t="nathanmarz would need to see more use cases"><y>#</y><d>2017-02-10</d><h>22:50</h><w>nathanmarz</w>would need to see more use cases</z><z id="t1486767289" t="zane defrichnav isn&apos;t documented yet?"><y>#</y><d>2017-02-10</d><h>22:54</h><w>zane</w><code>defrichnav</code> isn&apos;t documented yet?</z><z id="t1486767335" t="zane The only way it differs is that it takes vals , which is the collected vals?"><y>#</y><d>2017-02-10</d><h>22:55</h><w>zane</w>The only way it differs is that it takes <code>vals</code>, which is the collected vals?</z><z id="t1486767393" t="nathanmarz yea, that and next-fn expects to be passed in the new vals + the next value to navigate to"><y>#</y><d>2017-02-10</d><h>22:56</h><w>nathanmarz</w>yea, that and <code>next-fn</code> expects to be passed in the new vals + the next value to navigate to</z><z id="t1486767413" t="zane Got it."><y>#</y><d>2017-02-10</d><h>22:56</h><w>zane</w>Got it.</z><z id="t1486767415" t="zane Cool!"><y>#</y><d>2017-02-10</d><h>22:56</h><w>zane</w>Cool!</z><z id="t1486767431" t="nathanmarz defnav is a thin wrapper around defrichnav"><y>#</y><d>2017-02-10</d><h>22:57</h><w>nathanmarz</w><code>defnav</code> is a thin wrapper around <code>defrichnav</code></z><z id="t1486767563" t="zane Is defnav mainly there for backwards compat at this point?"><y>#</y><d>2017-02-10</d><h>22:59</h><w>zane</w>Is <code>defnav</code> mainly there for backwards compat at this point?</z><z id="t1486767993" t="zane I&apos;m not going to need late-bound-nav here?"><y>#</y><d>2017-02-10</d><h>23:06</h><w>zane</w>I&apos;m not going to need <code>late-bound-nav</code> here?</z><z id="t1486768004" t="zane Rather than richnav ?"><y>#</y><d>2017-02-10</d><h>23:06</h><w>zane</w>Rather than <code>richnav</code>?</z><z id="t1486768936" t="nathanmarz @zane oh yea, you&apos;ll need late-bound-richnav"><y>#</y><d>2017-02-10</d><h>23:22</h><w>nathanmarz</w>@zane oh yea, you&apos;ll need <code>late-bound-richnav</code></z><z id="t1486769439" t="zane Maybe I should re-read the caching implementation doc."><y>#</y><d>2017-02-10</d><h>23:30</h><w>zane</w>Maybe I should re-read the caching implementation doc.</z><z id="t1486776180" t="nathanmarz @zane I assume you&apos;re talking about with-fresh-collected ?"><y>#</y><d>2017-02-11</d><h>01:23</h><w>nathanmarz</w>@zane I assume you&apos;re talking about <code>with-fresh-collected</code>?</z><z id="t1486776200" t="nathanmarz it takes in a path as a parameter, which itself needs to be compiled"><y>#</y><d>2017-02-11</d><h>01:23</h><w>nathanmarz</w>it takes in a path as a parameter, which itself needs to be compiled</z><z id="t1486776271" t="nathanmarz you make sure the subpath is only compiled once by using defdynamicnav , which is like a macro to Specter&apos;s inline compiler, and late-bound-richnav which lets you mark the subpath parameter using late-path to ensure it&apos;s compiled once and re-used for every invocation of the callsite"><y>#</y><d>2017-02-11</d><h>01:24</h><w>nathanmarz</w>you make sure the subpath is only compiled once by using <code>defdynamicnav</code>, which is like a macro to Specter&apos;s inline compiler, and <code>late-bound-richnav</code> which lets you mark the subpath parameter using <code>late-path</code> to ensure it&apos;s compiled once and re-used for every invocation of the callsite</z><z id="t1486776388" t="nathanmarz that wiki page I referenced explains the mechanics of what happens at each callsite which will help you understand what these things do"><y>#</y><d>2017-02-11</d><h>01:26</h><w>nathanmarz</w>that wiki page I referenced explains the mechanics of what happens at each callsite which will help you understand what these things do</z><z id="t1486776543" t="zane Awesome. I&apos;ll have a look. Thanks!"><y>#</y><d>2017-02-11</d><h>01:29</h><w>zane</w>Awesome. I&apos;ll have a look. Thanks!</z><z id="t1486829359" t="zane Beat me to it."><y>#</y><d>2017-02-11</d><h>16:09</h><w>zane</w>Beat me to it.</z><z id="t1486851168" t="bradford Hi fam. How do I remove a value from a vector using setval ? I&apos;ve got the path correct, but when I set the value to NONE, I get com.rpl.specter/NONE in the vector. Which does make sense, but that&apos;s not what I want 😉 (defn remove-luminati-refs-and-save [f] (setval [ALL :response :headers [ALL #(re-find #&quot;luminati|hola&quot; (:name %) )]] NONE f) ) "><y>#</y><d>2017-02-11</d><h>22:12</h><w>bradford</w>Hi fam. How do I remove a value from a vector using <code>setval</code>? I&apos;ve got the path correct, but when I set the value to NONE, I get com.rpl.specter/NONE in the vector. Which does make sense, but that&apos;s not what I want <b>😉</b> <pre>(defn remove-luminati-refs-and-save [f]
  (setval [ALL :response :headers [ALL #(re-find #&quot;luminati|hola&quot; (:name %) )]] NONE f)

  )
</pre></z><z id="t1486851176" t="bradford also specter is super magic and cool"><y>#</y><d>2017-02-11</d><h>22:12</h><w>bradford</w>also specter is super magic and cool</z><z id="t1486852714" t="nathanmarz @bradford setting a value to NONE to remove it is implemented in master but not released yet"><y>#</y><d>2017-02-11</d><h>22:38</h><w>nathanmarz</w>@bradford setting a value to <code>NONE</code> to remove it is implemented in master but not released yet</z><z id="t1486852732" t="bradford Ah, rad. thanks!"><y>#</y><d>2017-02-11</d><h>22:38</h><w>bradford</w>Ah, rad. thanks!</z><z id="t1486852744" t="nathanmarz I think 0.13.3-SNAPSHOT on clojars has it though"><y>#</y><d>2017-02-11</d><h>22:39</h><w>nathanmarz</w>I think 0.13.3-SNAPSHOT on clojars has it though</z><z id="t1486862881" t="richiardiandrea Confirm I am using that feature successfully, very useful one ;)"><y>#</y><d>2017-02-12</d><h>01:28</h><w>richiardiandrea</w>Confirm I am using that feature successfully, very useful one ;)</z><z id="t1487007526" t="zane @nathanmarz: Does this look like valid usage? (specter/select (specter/with-fresh-collected (specter/collect-one (specter/keypath 0)) (specter/cond-path (specter/collected? [x] (even? x)) (specter/keypath 1) (specter/collected? [n] (odd? n)) (specter/keypath 2))) [1 &quot;even&quot; &quot;odd&quot;]) "><y>#</y><d>2017-02-13</d><h>17:38</h><w>zane</w>@nathanmarz: Does this look like valid usage?
<pre>(specter/select
 (specter/with-fresh-collected
   (specter/collect-one (specter/keypath 0))
   (specter/cond-path
    (specter/collected? [x] (even? x))
    (specter/keypath 1)
    (specter/collected? [n] (odd? n))
    (specter/keypath 2)))
 [1 &quot;even&quot; &quot;odd&quot;])
</pre></z><z id="t1487007578" t="zane I&apos;m finding that x in the collected? call is nil ."><y>#</y><d>2017-02-13</d><h>17:39</h><w>zane</w>I&apos;m finding that <code>x</code> in the <code>collected?</code> call is <code>nil</code>.</z><z id="t1487008361" t="zane Hmm. I must be misunderstanding how collections work:"><y>#</y><d>2017-02-13</d><h>17:52</h><w>zane</w>Hmm. I must be misunderstanding how collections work:</z><z id="t1487008364" t="zane (specter/select (specter/comp-paths (specter/collect-one :type) (specter/collected? [type] (clojure.tools.trace/trace &quot;type&quot; type) true) (specter/if-path (specter/collected? [type] (clojure.tools.trace/trace &quot;type&quot; type) (= :a type)) :a :b)) {:type :a :a &quot;a&quot; :b &quot;b&quot;}) "><y>#</y><d>2017-02-13</d><h>17:52</h><w>zane</w><pre>(specter/select
 (specter/comp-paths (specter/collect-one :type)
                     (specter/collected? [type]
                                         (clojure.tools.trace/trace &quot;type&quot; type)
                                         true)
                     (specter/if-path
                      (specter/collected? [type]
                                          (clojure.tools.trace/trace &quot;type&quot; type)
                                          (= :a type))
                      :a
                      :b))
 {:type :a
  :a &quot;a&quot;
  :b &quot;b&quot;})
</pre></z><z id="t1487008380" t="nathanmarz @zane yea looks like a bug"><y>#</y><d>2017-02-13</d><h>17:53</h><w>nathanmarz</w>@zane yea looks like a bug</z><z id="t1487008387" t="zane TRACE type: :a TRACE type: nil [[:a &quot;b&quot;]] "><y>#</y><d>2017-02-13</d><h>17:53</h><w>zane</w><pre>TRACE type: :a
TRACE type: nil
[[:a &quot;b&quot;]]
</pre></z><z id="t1487008396" t="zane Ah, okay."><y>#</y><d>2017-02-13</d><h>17:53</h><w>zane</w>Ah, okay.</z><z id="t1487008399" t="zane Phew. I&apos;m not crazy."><y>#</y><d>2017-02-13</d><h>17:53</h><w>zane</w>Phew. I&apos;m not crazy.</z><z id="t1487008411" t="nathanmarz vals aren&apos;t being passed to condition paths for if-path /`cond-path`"><y>#</y><d>2017-02-13</d><h>17:53</h><w>nathanmarz</w>vals aren&apos;t being passed to condition paths for <code>if-path</code>/`cond-path`</z><z id="t1487008415" t="zane Want me to file an issue or something?"><y>#</y><d>2017-02-13</d><h>17:53</h><w>zane</w>Want me to file an issue or something?</z><z id="t1487008440" t="nathanmarz yes, thanks"><y>#</y><d>2017-02-13</d><h>17:54</h><w>nathanmarz</w>yes, thanks</z><z id="t1487009037" t="zane https://github.com/nathanmarz/specter/issues/176"><y>#</y><d>2017-02-13</d><h>18:03</h><w>zane</w><a href="https://github.com/nathanmarz/specter/issues/176" target="_blank">https://github.com/nathanmarz/specter/issues/176</a></z><z id="t1487018789" t="nathanmarz @zane btw you can handle your previous use case with: (if-path [(keypath 0) even?] (keypath 1) (keypath 2)) "><y>#</y><d>2017-02-13</d><h>20:46</h><w>nathanmarz</w>@zane btw you can handle your previous use case with:
<pre>(if-path [(keypath 0) even?] (keypath 1) (keypath 2))
</pre></z><z id="t1487021904" t="zane Yeah, my actual use case has more than two branches, @nathanmarz. 😞 "><y>#</y><d>2017-02-13</d><h>21:38</h><w>zane</w>Yeah, my actual use case has more than two branches, @nathanmarz. <b>😞</b> </z><z id="t1487021949" t="zane I could repeat the computation of the dispatch value but that feels gross. "><y>#</y><d>2017-02-13</d><h>21:39</h><w>zane</w>I could repeat the computation of the dispatch value but that feels gross. </z><z id="t1487025722" t="shader I&apos;m getting an error &quot;com.rpl.specter.impl.CachedPathInfo cannot be cast to com.rpl.specter.impl.CachedPathInfo&quot;"><y>#</y><d>2017-02-13</d><h>22:42</h><w>shader</w>I&apos;m getting an error &quot;com.rpl.specter.impl.CachedPathInfo cannot be cast to com.rpl.specter.impl.CachedPathInfo&quot;</z><z id="t1487025730" t="shader I presume this has been seen before; any ideas?"><y>#</y><d>2017-02-13</d><h>22:42</h><w>shader</w>I presume this has been seen before; any ideas?</z><z id="t1487025750" t="shader it may just be that I need to update to the latest version..."><y>#</y><d>2017-02-13</d><h>22:42</h><w>shader</w>it may just be that I need to update to the latest version...</z><z id="t1487025860" t="shader hmm... updating changed the error to &quot;No implementation of method: :get_cell of protocol: #&apos;com.rpl.specter.impl/PMutableCell found for class: clojure.lang.Var$Unbound&quot;, which means the api has probably changed"><y>#</y><d>2017-02-13</d><h>22:44</h><w>shader</w>hmm... updating changed the error to &quot;No implementation of method: :get_cell of protocol: #&apos;com.rpl.specter.impl/PMutableCell found for class: clojure.lang.Var$Unbound&quot;, which means the api has probably changed</z><z id="t1487037605" t="nathanmarz @shader that first error was fixed in 0.13.2, as for second issue would need to see the code producing the error to help"><y>#</y><d>2017-02-14</d><h>02:00</h><w>nathanmarz</w>@shader that first error was fixed in 0.13.2, as for second issue would need to see the code producing the error to help</z><z id="t1487098973" t="zane @nathanmarz, I&apos;m finding with-fresh-collected to be incredibly useful."><y>#</y><d>2017-02-14</d><h>19:02</h><w>zane</w>@nathanmarz, I&apos;m finding <code>with-fresh-collected</code> to be incredibly useful.</z><z id="t1487098982" t="zane Here are two navigators I&apos;ve used it for:"><y>#</y><d>2017-02-14</d><h>19:03</h><w>zane</w>Here are two navigators I&apos;ve used it for:</z><z id="t1487098996" t="zane (s/def ::or-spec-path-args (s/cat :spec qualified-keyword? :branches (s/+ (s/alt :branch (s/cat :key simple-keyword? :body any?) :invalid (s/cat :key #{:spec/invalid} :body any?))))) (defmacro or-spec-path &quot;Navigates to one of several subpaths depending on which branch of a `clojure.spec/or` the structure conforms to.&quot; [&amp; args] (let [{:keys [spec branches] :as conformed} (s/conform ::or-spec-path-args args) spec-obj (s/get-spec spec) invalid (or (select-first (fn [[tag _]] (= :invalid tag)) branches) `(fn [val#] (throw (ex-info (s/explain-str ~spec val#) (s/explain-data ~spec val#)))))] (if-not spec-obj (throw (ex-info (str &quot;Spec not found: &quot; spec) {:spec spec :conformed conformed})) `(with-fresh-collected (collect-one (view (partial s/conform ~spec))) (cond-path (collected? [conformed#] (= ::s/invalid conformed#)) ~invalid "><y>#</y><d>2017-02-14</d><h>19:03</h><w>zane</w><pre>(s/def ::or-spec-path-args
  (s/cat :spec qualified-keyword?
         :branches (s/+ (s/alt :branch (s/cat :key simple-keyword? :body any?)
                               :invalid (s/cat :key #{:spec/invalid} :body any?)))))

(defmacro or-spec-path
  &quot;Navigates to one of several subpaths depending on which branch of a
  `clojure.spec/or` the structure conforms to.&quot;
  [&amp; args]
  (let [{:keys [spec branches] :as conformed} (s/conform ::or-spec-path-args args)
        spec-obj (s/get-spec spec)
        invalid (or (select-first (fn [[tag _]] (= :invalid tag))
                                  branches)
                    `(fn [val#] (throw (ex-info (s/explain-str ~spec val#)
                                                (s/explain-data ~spec val#)))))]
    (if-not spec-obj
      (throw (ex-info (str &quot;Spec not found: &quot; spec)
                      {:spec spec
                       :conformed conformed}))
      `(with-fresh-collected
         (collect-one (view (partial s/conform ~spec)))
         (cond-path
          (collected? [conformed#]
            (= ::s/invalid conformed#))
          ~invalid
          </pre></z><z id="t1487099009" t="zane (s/def ::case-path-args (s/cat :path any? :branches (s/+ (s/cat :value any? :body any?)) :default (s/? any?))) (defmacro case-path &quot;Navigates to one of several subpaths depending on the value selected by a the provided path.&quot; [&amp; args] (let [{:keys [path branches default] :as conformed} (s/conform ::case-path-args args)] `(with-fresh-collected (collect-one ~path) (cond-path "><y>#</y><d>2017-02-14</d><h>19:03</h><w>zane</w><pre>(s/def ::case-path-args
  (s/cat :path any?
         :branches (s/+ (s/cat :value any? :body any?))
         :default (s/? any?)))

(defmacro case-path
  &quot;Navigates to one of several subpaths depending on the value selected by a the
  provided path.&quot;
  [&amp; args]
  (let [{:keys [path branches default] :as conformed} (s/conform ::case-path-args args)]
    `(with-fresh-collected
       (collect-one ~path)
       (cond-path
        </pre></z><z id="t1487099716" t="nathanmarz @zane cool, you should be able to do those as dynamic navs though"><y>#</y><d>2017-02-14</d><h>19:15</h><w>nathanmarz</w>@zane cool, you should be able to do those as dynamic navs though</z><z id="t1487208958" t="zane Hmm. Could I do the spec one as a dynamic nav? I want to have compile-time error reporting for that one."><y>#</y><d>2017-02-16</d><h>01:35</h><r>zane</r>Hmm. Could I do the spec one as a dynamic nav? I want to have compile-time error reporting for that one.</z><z id="t1487218801" t="nathanmarz I haven&apos;t dug into spec yet, so I don&apos;t understand every detail of your code. But if you did it as a dynamic nav it would throw the error the first time that callsite is run (when Specter&apos;s inline compiler expands dynamic navs)."><y>#</y><d>2017-02-16</d><h>04:20</h><r>nathanmarz</r>I haven&apos;t dug into spec yet, so I don&apos;t understand every detail of your code. But if you did it as a dynamic nav it would throw the error the first time that callsite is run (when Specter&apos;s inline compiler expands dynamic navs).</z><z id="t1487218851" t="nathanmarz Another approach you could take is have a macro that does your validation and expands to a dynamic nav invocation which does the rest of the work."><y>#</y><d>2017-02-16</d><h>04:20</h><r>nathanmarz</r>Another approach you could take is have a macro that does your validation and expands to a dynamic nav invocation which does the rest of the work.</z><z id="t1487265511" t="zane That last suggestion seems like the way to go. Thanks for the feedback!"><y>#</y><d>2017-02-16</d><h>17:18</h><r>zane</r>That last suggestion seems like the way to go. Thanks for the feedback!</z><z id="t1487106311" t="nathanmarz opened a thread on the mailing list about whether Specter should be part of Clojure core or not https://groups.google.com/forum/#!topic/clojure/qN1UPMVQmaM"><y>#</y><d>2017-02-14</d><h>21:05</h><w>nathanmarz</w>opened a thread on the mailing list about whether Specter should be part of Clojure core or not <a href="https://groups.google.com/forum/#!topic/clojure/qN1UPMVQmaM" target="_blank">https://groups.google.com/forum/#!topic/clojure/qN1UPMVQmaM</a></z><z id="t1487106977" t="schmee I think it is better to have it as a lib since that way we can add and fix stuff faster and easier"><y>#</y><d>2017-02-14</d><h>21:16</h><w>schmee</w>I think it is better to have it as a lib since that way we can add and fix stuff faster and easier</z><z id="t1487110032" t="dm3 it should probably be on a list of “blessed” libs, if one existed for Clojure"><y>#</y><d>2017-02-14</d><h>22:07</h><w>dm3</w>it should probably be on a list of “blessed” libs, if one existed for Clojure</z><z id="t1487110251" t="dm3 I think it’s in the same category as “core.async” - indispensable when you have a good problem for it"><y>#</y><d>2017-02-14</d><h>22:10</h><w>dm3</w>I think it’s in the same category as “core.async” - indispensable when you have a good problem for it</z><z id="t1487132491" t="nathanmarz @schmee new navigators can easily be provided in external libraries"><y>#</y><d>2017-02-15</d><h>04:21</h><w>nathanmarz</w>@schmee new navigators can easily be provided in external libraries</z><z id="t1487132564" t="nathanmarz I don&apos;t see the core of Specter (navigator composition and inline compilation/caching) changing since the performance is near-optimal"><y>#</y><d>2017-02-15</d><h>04:22</h><w>nathanmarz</w>I don&apos;t see the core of Specter (navigator composition and inline compilation/caching) changing since the performance is near-optimal</z><z id="t1487193033" t="richiardiandrea Imho with some small retouch it could be transparently integrated in core, for instance update-in could accept a navigator. "><y>#</y><d>2017-02-15</d><h>21:10</h><w>richiardiandrea</w>Imho with some small retouch it could be transparently integrated in core, for instance <code>update-in</code> could accept a navigator. </z><z id="t1487625566" t="souenzzo Hi! There is some docs to recursive-path ? I&apos;m trying to do: [:a {:b [:c]}] -&gt; [:a {:b [:c :x]} :x] (position of x don&apos;t matter) (append x to all vector? level&apos;s)"><y>#</y><d>2017-02-20</d><h>21:19</h><w>souenzzo</w>Hi!
There is some docs to <code>recursive-path</code>?
I&apos;m trying to do: <code>[:a {:b [:c]}]</code> -&gt; <code>[:a {:b [:c :x]} :x]</code> (position of <code>x</code> don&apos;t matter)
(append <code>x</code> to all <code>vector?</code> level&apos;s)</z><z id="t1487625782" t="nathanmarz @souenzzo it&apos;s just (recursive-path [] p ...)"><y>#</y><d>2017-02-20</d><h>21:23</h><w>nathanmarz</w>@souenzzo it&apos;s just <code>(recursive-path [] p ...)</code></z><z id="t1487625790" t="nathanmarz where p refers to itself"><y>#</y><d>2017-02-20</d><h>21:23</h><w>nathanmarz</w>where <code>p</code> refers to itself</z><z id="t1487625894" t="nathanmarz navigating to all levels of the vector can be done: (recursive-path [] p (if-path vector? (continue-then-stay ALL p)))"><y>#</y><d>2017-02-20</d><h>21:24</h><w>nathanmarz</w>navigating to all levels of the vector can be done: <code>(recursive-path [] p (if-path vector? (continue-then-stay ALL p)))</code></z><z id="t1487625924" t="nathanmarz with 0.13.3-SNAPSHOT can do: user=&gt; (def p (recursive-path [] p (if-path vector? (continue-then-stay ALL p)))) #&apos;user/p user=&gt; (setval [p AFTER-ELEM] :x [1 [2 3] [[4]]]) [1 [2 3 :x] [[4 :x] :x] :x] "><y>#</y><d>2017-02-20</d><h>21:25</h><w>nathanmarz</w>with 0.13.3-SNAPSHOT can do:
<pre>user=&gt; (def p (recursive-path [] p (if-path vector? (continue-then-stay ALL p))))
#&apos;user/p
user=&gt; (setval [p AFTER-ELEM] :x [1 [2 3] [[4]]])
[1 [2 3 :x] [[4 :x] :x] :x]
</pre></z><z id="t1487643065" t="richiardiandrea Woah nice ^"><y>#</y><d>2017-02-21</d><h>02:11</h><w>richiardiandrea</w>Woah nice ^</z><z id="t1487643140" t="richiardiandrea We should take the history of this channel and apply a transformation that generates wiki pages with these kind of examples. Every time I peek in here there is something nice and 🆒"><y>#</y><d>2017-02-21</d><h>02:12</h><w>richiardiandrea</w>We should take the history of this channel and apply a transformation  that generates wiki pages with these kind of examples. Every time I peek in here there is something nice and <b>🆒</b></z><z id="t1487663437" t="dm3 we need something like https://regexr.com/ , but for Specter"><y>#</y><d>2017-02-21</d><h>07:50</h><w>dm3</w>we need something like <a href="https://regexr.com/" target="_blank">https://regexr.com/</a>, but for Specter</z><z id="t1487682756" t="nathanmarz @dm3 various people have said they would do something like that for specter (more along the lines of 4clojure), but no one has done it yet"><y>#</y><d>2017-02-21</d><h>13:12</h><w>nathanmarz</w>@dm3 various people have said they would do something like that for specter (more along the lines of 4clojure), but no one has done it yet</z><z id="t1487682805" t="dm3 not going to say I’ll do that 🙂"><y>#</y><d>2017-02-21</d><h>13:13</h><w>dm3</w>not going to say I’ll do that <b>🙂</b></z><z id="t1487682872" t="dm3 but this type of incremental visual path construction would be awesome"><y>#</y><d>2017-02-21</d><h>13:14</h><w>dm3</w>but this type of incremental visual path construction would be awesome</z><z id="t1487682951" t="dm3 instead of Text pane you have a tree editor with sequences, maps and primitives as building blocks"><y>#</y><d>2017-02-21</d><h>13:15</h><w>dm3</w>instead of Text pane you have a tree editor with sequences, maps and primitives as building blocks</z><z id="t1487683055" t="dm3 instead of Expression - an executable editor panel, because you might want to write new navigators. Or maybe a separate panel for the context NS and a separate path expression editor"><y>#</y><d>2017-02-21</d><h>13:17</h><w>dm3</w>instead of Expression - an executable editor panel, because you might want to write new navigators. Or maybe a separate panel for the context NS and a separate path expression editor</z><z id="t1487683119" t="dm3 does Specter work in bootstrapped cljs?"><y>#</y><d>2017-02-21</d><h>13:18</h><w>dm3</w>does Specter work in bootstrapped cljs?</z><z id="t1487684752" t="nathanmarz @dm3 not at the moment https://github.com/nathanmarz/specter/issues/72"><y>#</y><d>2017-02-21</d><h>13:45</h><w>nathanmarz</w>@dm3 not at the moment <a href="https://github.com/nathanmarz/specter/issues/72" target="_blank">https://github.com/nathanmarz/specter/issues/72</a></z><z id="t1487684785" t="nathanmarz shouldn&apos;t be too much work to get it working again, but the main task that needs to be done to ensure support moving forward is getting the tests running under bootstrap cljs"><y>#</y><d>2017-02-21</d><h>13:46</h><w>nathanmarz</w>shouldn&apos;t be too much work to get it working again, but the main task that needs to be done to ensure support moving forward is getting the tests running under bootstrap cljs</z><z id="t1487780815" t="chromalchemy I am trying to tranform some &quot;Hiccup-y&quot; style data that will be compiled by Garden into CSS. Ex: [:h1 :h2 {:font-weight &quot;none&quot;}] [:body {:font-size &quot;16px&quot;}] But it seem like the Specter functions expect maps. How can I get these vectors into something that Specter can see better?"><y>#</y><d>2017-02-22</d><h>16:26</h><w>chromalchemy</w>I am trying to tranform some &quot;Hiccup-y&quot; style data that will be compiled by Garden into CSS. Ex: <code>[:h1 :h2 {:font-weight &quot;none&quot;}] [:body {:font-size &quot;16px&quot;}]</code>
But it seem like the Specter functions expect maps. How can I get these vectors into something that Specter can see better?</z><z id="t1487780947" t="chromalchemy ps. Thank you for Specter. I&apos;m coming from front end and dont know much about typical database interactions, But Specter + nested EDN just seems to make sense 😅 I&apos;m trying to use it in cljs client with persistance to Firebase JSON tree."><y>#</y><d>2017-02-22</d><h>16:29</h><w>chromalchemy</w>ps. Thank you for Specter. I&apos;m coming from front end and dont know much about typical database interactions, But Specter + nested EDN just seems to make sense <b>😅</b> I&apos;m trying to use it in cljs client with persistance to Firebase JSON tree.</z><z id="t1487782046" t="nathanmarz @chromalchemy specter works on all data structures"><y>#</y><d>2017-02-22</d><h>16:47</h><w>nathanmarz</w>@chromalchemy specter works on all data structures</z><z id="t1487782120" t="nathanmarz what are you trying to do?"><y>#</y><d>2017-02-22</d><h>16:48</h><w>nathanmarz</w>what are you trying to do?</z><z id="t1487782702" t="chromalchemy It might be a lark, but since CSS uses a form of navigators, and Garden follows suit to compile Hiccup style clojure data into CSS, I could take a super-structure of ready-to-compile Garden data, and transform or filter it as needed with Specter for more specific application of the style data. Kind of like querying a style database dynamically, instead of declaring static css rules/paths directly."><y>#</y><d>2017-02-22</d><h>16:58</h><w>chromalchemy</w>It might be a lark, but since CSS uses a form of navigators, and Garden follows suit to compile Hiccup style clojure data into CSS, I could take a super-structure of ready-to-compile Garden data, and transform or filter it as needed with Specter for more specific application of the style data. Kind of like querying a style database dynamically, instead of declaring static css rules/paths directly.</z><z id="t1487782800" t="chromalchemy Im not sure how to navigate the Garden vectors though. They arent exactly maps (though there are nested maps) I cant even get the first key-val out of a vector."><y>#</y><d>2017-02-22</d><h>17:00</h><w>chromalchemy</w>Im not sure how to navigate the Garden vectors though. They arent exactly maps (though there are nested maps) I cant even get the first key-val out of a vector.</z><z id="t1487782857" t="tolitius @chromalchemy =&gt; (def html [[:h1 :h2 {:font-weight &quot;none&quot;}] [:body {:font-size &quot;16px&quot;}]]) =&gt; (transform [(walker :font-size) :font-size] #(s/replace % #&quot;px&quot; &quot;em&quot;) html) [[:h1 :h2 {:font-weight &quot;none&quot;}] [:body {:font-size &quot;16em&quot;}]] your examples are just data structures: i.e. maps, vectors, sets, etc.. or not?"><y>#</y><d>2017-02-22</d><h>17:00</h><w>tolitius</w>@chromalchemy 
<pre>=&gt; (def html [[:h1 :h2 {:font-weight &quot;none&quot;}] [:body {:font-size &quot;16px&quot;}]])

=&gt; (transform [(walker :font-size) :font-size] #(s/replace %  #&quot;px&quot; &quot;em&quot;) html)

[[:h1 :h2 {:font-weight &quot;none&quot;}] [:body {:font-size &quot;16em&quot;}]]
</pre>
your examples are just data structures: i.e. maps, vectors, sets, etc.. or not?</z><z id="t1487783026" t="tolitius would probably be better if you provided an example of a data structure (Garden, ..) + what you need to do with it"><y>#</y><d>2017-02-22</d><h>17:03</h><w>tolitius</w>would probably be better if you provided an example of a data structure (Garden, ..) + what you need to do with it</z><z id="t1487783076" t="chromalchemy Yes, just data. Primarily a list of vectors, each vector is a css rule. I will try out walker. Not familiar with that one yet."><y>#</y><d>2017-02-22</d><h>17:04</h><w>chromalchemy</w>Yes, just data. Primarily a list of vectors, each vector is a css rule.    I will try out walker. Not familiar with that one yet.</z><z id="t1487783171" t="chromalchemy [:myclass {:color &quot;red}] How can I get the map from the :myclass key?"><y>#</y><d>2017-02-22</d><h>17:06</h><w>chromalchemy</w>[:myclass {:color &quot;red}]
How can I get the map from the :myclass key?</z><z id="t1487783251" t="nathanmarz you mean the element to the right of :myclass in the vector?"><y>#</y><d>2017-02-22</d><h>17:07</h><w>nathanmarz</w>you mean the element to the right of <code>:myclass</code> in the vector?</z><z id="t1487783309" t="chromalchemy Yes"><y>#</y><d>2017-02-22</d><h>17:08</h><w>chromalchemy</w>Yes</z><z id="t1487783362" t="nathanmarz you can do it with com.rpl.specter.zipper"><y>#</y><d>2017-02-22</d><h>17:09</h><w>nathanmarz</w>you can do it with com.rpl.specter.zipper</z><z id="t1487783386" t="nathanmarz navigate to the position of :myclass , and then do z/RIGHT"><y>#</y><d>2017-02-22</d><h>17:09</h><w>nathanmarz</w>navigate to the position of <code>:myclass</code>, and then do <code>z/RIGHT</code></z><z id="t1487783405" t="nathanmarz I would really question why you store data like that instead of just using a map"><y>#</y><d>2017-02-22</d><h>17:10</h><w>nathanmarz</w>I would really question why you store data like that instead of just using a map</z><z id="t1487783498" t="chromalchemy Ok, How do I navigate to position of :myclass?"><y>#</y><d>2017-02-22</d><h>17:11</h><w>chromalchemy</w>Ok, How do I navigate to position of :myclass?</z><z id="t1487783598" t="nathanmarz user=&gt; (setval [z/VECTOR-ZIP (z/find-first #(= :myclass %)) z/RIGHT z/NODE :color] &quot;blue&quot; [:myclass {:color &quot;red&quot;}]) [:myclass {:color &quot;blue&quot;}] "><y>#</y><d>2017-02-22</d><h>17:13</h><w>nathanmarz</w><pre>user=&gt; (setval [z/VECTOR-ZIP (z/find-first #(= :myclass %)) z/RIGHT z/NODE :color] &quot;blue&quot; [:myclass {:color &quot;red&quot;}])
[:myclass {:color &quot;blue&quot;}]
</pre></z><z id="t1487783671" t="nathanmarz https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/zipper.cljc#L120"><y>#</y><d>2017-02-22</d><h>17:14</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/zipper.cljc#L120" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/zipper.cljc#L120</a></z><z id="t1487783675" t="chromalchemy Your probably right. The style data super-structure should probably just be maps. I was trying to keep it in the format that Garden wants so I dont have to do more syntax-oriented transformations to be able to compile the results to css"><y>#</y><d>2017-02-22</d><h>17:14</h><w>chromalchemy</w>Your probably right. The style data super-structure should probably just be maps. I was trying to keep it in the format that Garden wants so I dont have to do more syntax-oriented transformations to be able to compile the results to css</z><z id="t1487783716" t="chromalchemy Thanks for that!"><y>#</y><d>2017-02-22</d><h>17:15</h><w>chromalchemy</w>Thanks for that!</z><z id="t1487783791" t="chromalchemy [[:class1 {foo}] [:class2 {bar}]] I assume I can use something similar to get to bar by filtering on :class2"><y>#</y><d>2017-02-22</d><h>17:16</h><w>chromalchemy</w>[[:class1 {foo}] [:class2 {bar}]]
I assume I can use something similar to get to bar by filtering on :class2</z><z id="t1487783872" t="nathanmarz find-first will descend into nested vectors, so the code is pretty much exactly the same"><y>#</y><d>2017-02-22</d><h>17:17</h><w>nathanmarz</w><code>find-first</code> will descend into nested vectors, so the code is pretty much exactly the same</z><z id="t1487783887" t="chromalchemy or in [:class1 :class2 {foo}], getting from class1 to class2 to foo?"><y>#</y><d>2017-02-22</d><h>17:18</h><w>chromalchemy</w>or in [:class1 :class2 {foo}], getting from class1 to class2 to foo?</z><z id="t1487783997" t="chromalchemy Ok cool. I came to Specter after hearing about the challenges of using zippers. But glad that it&apos;s all included :)"><y>#</y><d>2017-02-22</d><h>17:19</h><w>chromalchemy</w>Ok cool. I came to Specter after hearing about the challenges of using zippers. But glad that it&apos;s all included :)</z><z id="t1487784090" t="nathanmarz zippers are just an advanced form of navigation"><y>#</y><d>2017-02-22</d><h>17:21</h><w>nathanmarz</w>zippers are just an advanced form of navigation</z><z id="t1487784102" t="nathanmarz this happens to be a case where it fits"><y>#</y><d>2017-02-22</d><h>17:21</h><w>nathanmarz</w>this happens to be a case where it fits</z><z id="t1487784237" t="chromalchemy Thanks for the help"><y>#</y><d>2017-02-22</d><h>17:23</h><w>chromalchemy</w>Thanks for the help</z><z id="t1487784626" t="chromalchemy On a side note, do you have any best practices on size of nested data in a cljs client. Like could i serialize a one-tree to-do datastructure, and transact on it in the client with atoms. Is this reasonable or am i asking for trouble? especially if there are thousands of items &amp; notes &amp; metadata (i have a lot to do lol) "><y>#</y><d>2017-02-22</d><h>17:30</h><w>chromalchemy</w>On a side note, do you have any best practices on size of nested data in a cljs client. Like could i serialize a one-tree to-do datastructure, and transact on it in the client with atoms. Is this reasonable or am i asking for trouble? especially if there are thousands of items &amp; notes &amp; metadata (i have a lot to do lol) </z><z id="t1487784791" t="nathanmarz no idea, I don&apos;t do much clojurescript"><y>#</y><d>2017-02-22</d><h>17:33</h><w>nathanmarz</w>no idea, I don&apos;t do much clojurescript</z><z id="t1487784800" t="nathanmarz better to ask in #clojurescript channel"><y>#</y><d>2017-02-22</d><h>17:33</h><w>nathanmarz</w>better to ask in #clojurescript channel</z><z id="t1487787478" t="mccraigmccraig @chromalchemy i have a largish cljs (re-frame) app with a single atom for all client state - there are commonly many thousands of items in the tree and it&apos;s fine"><y>#</y><d>2017-02-22</d><h>18:17</h><w>mccraigmccraig</w>@chromalchemy i have a largish cljs (re-frame) app with a single atom for all client state - there are commonly many thousands of items in the tree and it&apos;s fine</z><z id="t1487788296" t="chromalchemy Cool. good to know. Tree soup it is."><y>#</y><d>2017-02-22</d><h>18:31</h><w>chromalchemy</w>Cool. good to know. Tree soup it is.</z><z id="t1487791836" t="alexyakushev Hello folks! Can anyone help me implement a deep filter? I&apos;m looking for the following transformation: ;; Drop all maps from the vector in :stuff where :c key is present {:fluff 42, :stuff [{:a 1, :b 2} {:a 1, :c 3} {:b 2, :c 3} {:b 2, :d 4}]} =&gt; {:fluff 42, :stuff [{:a 1, :b 2} {:b 2, :d 4}]} "><y>#</y><d>2017-02-22</d><h>19:30</h><w>alexyakushev</w>Hello folks! Can anyone help me implement a deep filter? I&apos;m looking for the following transformation:
<pre>;; Drop all maps from the vector in :stuff where :c key is present
{:fluff 42, :stuff [{:a 1, :b 2} {:a 1, :c 3} {:b 2, :c 3} {:b 2, :d 4}]}
=&gt;
{:fluff 42, :stuff [{:a 1, :b 2} {:b 2, :d 4}]}
</pre></z><z id="t1487792207" t="alexyakushev I also discovered NONE , but the example from Github doesn&apos;t work correctly for me (see the impl/NONE): (setval [:a ALL nil?] NONE {:a [1 2 nil 3 nil]}) =&gt; {:a [1 2 :com.rpl.specter.impl/NONE 3 :com.rpl.specter.impl/NONE]} "><y>#</y><d>2017-02-22</d><h>19:36</h><w>alexyakushev</w>I also discovered <code>NONE</code>, but the example from Github doesn&apos;t work correctly for me (see the impl/NONE):
<pre>(setval [:a ALL nil?] NONE {:a [1 2 nil 3 nil]})
=&gt;
{:a [1 2 :com.rpl.specter.impl/NONE 3 :com.rpl.specter.impl/NONE]}
</pre></z><z id="t1487792619" t="alexyakushev Worked with 0.13.0-SNAPSHOT : (setval [:stuff ALL (pred :c)] NONE {:fluff 42, :stuff [{:a 1, :b 2} {:a 1, :c 3} {:b 2, :c 3} {:b 2, :d 4}]}) =&gt; {:fluff 42, :stuff [{:a 1, :b 2} {:b 2, :d 4}]} Thanks for help! 😄"><y>#</y><d>2017-02-22</d><h>19:43</h><w>alexyakushev</w>Worked with <code>0.13.0-SNAPSHOT</code>:
<pre>(setval [:stuff ALL (pred :c)] NONE {:fluff 42, :stuff [{:a 1, :b 2} {:a 1, :c 3} {:b 2, :c 3} {:b 2, :d 4}]})
=&gt;
{:fluff 42, :stuff [{:a 1, :b 2} {:b 2, :d 4}]}
</pre>
Thanks for help! <b>😄</b></z><z id="t1487793040" t="nathanmarz @alexyakushev more precise to do (selected? (must :c)) rather than (pred :c)"><y>#</y><d>2017-02-22</d><h>19:50</h><w>nathanmarz</w>@alexyakushev more precise to do <code>(selected? (must :c))</code> rather than <code>(pred :c)</code></z><z id="t1487793104" t="alexyakushev Thanks! What is the case when they will work differently?"><y>#</y><d>2017-02-22</d><h>19:51</h><w>alexyakushev</w>Thanks! What is the case when they will work differently?</z><z id="t1487793105" t="nathanmarz (pred :c) will filter out maps with :c being false or nil"><y>#</y><d>2017-02-22</d><h>19:51</h><w>nathanmarz</w><code>(pred :c)</code> will filter out maps with <code>:c</code> being false or nil</z><z id="t1487793130" t="alexyakushev Oh, I see. must is like contains? . I get it now, thanks!"><y>#</y><d>2017-02-22</d><h>19:52</h><w>alexyakushev</w>Oh, I see. <code>must</code> is like <code>contains?</code>. I get it now, thanks!</z><z id="t1487793205" t="nathanmarz must is keypath that navigates only if the key is present"><y>#</y><d>2017-02-22</d><h>19:53</h><w>nathanmarz</w><code>must</code> is <code>keypath</code> that navigates only if the key is present</z><z id="t1487875491" t="souenzzo There is something like transform-one! ? (transform-one! (walker :a) f m) with: Return nil if dosen&apos;t apply f in any element Throws or don&apos;t apply f if find more then one &quot;match&quot; Return transformed m case find only one &quot;match&quot;"><y>#</y><d>2017-02-23</d><h>18:44</h><w>souenzzo</w>There is something like <code>transform-one!</code>?
<code>(transform-one! (walker :a) f m)</code>
with:
Return <code>nil</code> if dosen&apos;t apply <code>f</code> in any element
Throws or don&apos;t apply <code>f</code> if find more then one &quot;match&quot;
Return transformed <code>m</code> case find only one &quot;match&quot;</z><z id="t1487878228" t="nathanmarz @souenzzo no, nothing like that"><y>#</y><d>2017-02-23</d><h>19:30</h><w>nathanmarz</w>@souenzzo no, nothing like that</z><z id="t1487878242" t="nathanmarz easy to implement yourself by wrapping the transform fn"><y>#</y><d>2017-02-23</d><h>19:30</h><w>nathanmarz</w>easy to implement yourself by wrapping the transform fn</z><z id="t1487878756" t="souenzzo I implemented with select-one before transform. For now, that&apos;s enough. 😉"><y>#</y><d>2017-02-23</d><h>19:39</h><w>souenzzo</w>I implemented with <code>select-one</code> before transform.
For now, that&apos;s enough. <b>😉</b></z><z id="t1487970354" t="qqq Is there a simple way to rewrite the following without specter? (need to eliminate the dependency) (fn [x] (s/select (s/walker keyword?) x) I want to rewrite the above using just clojure core"><y>#</y><d>2017-02-24</d><h>21:05</h><w>qqq</w>Is there a simple way to rewrite the following without specter? (need to eliminate the dependency)
<pre>(fn [x]
  (s/select (s/walker keyword?) x)
</pre>
I want to rewrite the above using just clojure core</z><z id="t1487972899" t="nathanmarz @qqq you can use clojure.walk, which is what walker uses underneath the hood"><y>#</y><d>2017-02-24</d><h>21:48</h><w>nathanmarz</w>@qqq you can use clojure.walk, which is what <code>walker</code> uses underneath the hood</z><z id="t1488211948" t="mpenet @nathanmarz Could you make a release or are they pending things in master?"><y>#</y><d>2017-02-27</d><h>16:12</h><w>mpenet</w>@nathanmarz Could you make a release or are they pending things in master?</z><z id="t1488211979" t="mpenet (I want to get rid of the reflection warnings from my logs :p)"><y>#</y><d>2017-02-27</d><h>16:12</h><w>mpenet</w>(I want to get rid of the reflection warnings from my logs :p)</z><z id="t1488212434" t="nathanmarz @mpenet next release will be 1.0 and there&apos;s a few pending things"><y>#</y><d>2017-02-27</d><h>16:20</h><w>nathanmarz</w>@mpenet next release will be 1.0 and there&apos;s a few pending things</z><z id="t1488212446" t="nathanmarz 0.13.3-SNAPSHOT is current with master though"><y>#</y><d>2017-02-27</d><h>16:20</h><w>nathanmarz</w>0.13.3-SNAPSHOT is current with master though</z><z id="t1488212685" t="mpenet ok, thanks"><y>#</y><d>2017-02-27</d><h>16:24</h><w>mpenet</w>ok, thanks</z><z id="t1488313995" t="ghadi is there a simple way to transform all values in a nested map recursively?"><y>#</y><d>2017-02-28</d><h>20:33</h><w>ghadi</w>is there a simple way to transform all values in a nested map recursively?</z><z id="t1488314017" t="ghadi I&apos;m trying to make a nicer printout of ElasticSearch mappings... here&apos;s a sample"><y>#</y><d>2017-02-28</d><h>20:33</h><w>ghadi</w>I&apos;m trying to make a nicer printout of ElasticSearch mappings... here&apos;s a sample</z><z id="t1488314055" t="ghadi {:properties {:foo {:type &quot;blah&quot; :properties {....}}"><y>#</y><d>2017-02-28</d><h>20:34</h><w>ghadi</w><code>{:properties {:foo {:type &quot;blah&quot; :properties {....}}</code></z><z id="t1488314087" t="ghadi I&apos;d like to collect all names along all paths... so that I end up with a list of [&quot;blah&quot; &quot;foo&quot;] [&quot;blah&quot; &quot;bar&quot;]"><y>#</y><d>2017-02-28</d><h>20:34</h><w>ghadi</w>I&apos;d like to collect all names along all paths... so that I end up with a list of [&quot;blah&quot; &quot;foo&quot;] [&quot;blah&quot; &quot;bar&quot;]</z><z id="t1488315948" t="nathanmarz @ghadi you can use value collection for that"><y>#</y><d>2017-02-28</d><h>21:05</h><w>nathanmarz</w>@ghadi you can use value collection for that</z><z id="t1488315954" t="nathanmarz (def data {:foo {:type &quot;blah&quot; :properties {:foo {:type &quot;bar&quot;} :foo2 {:type &quot;foo&quot;}}}}) (def MY-WALKER (recursive-path [] p (continue-then-stay MAP-VALS (collect-one :type) :properties p ))) (select MY-WALKER data) ;; =&gt; [[&quot;blah&quot; &quot;bar&quot; nil] [&quot;blah&quot; &quot;foo&quot; nil] [&quot;blah&quot; {:foo {:type &quot;bar&quot;}, :foo2 {:type &quot;foo&quot;}}] {:foo {:type &quot;blah&quot;, :properties {:foo {:type &quot;bar&quot;}, :foo2 {:type &quot;foo&quot;}}}}] "><y>#</y><d>2017-02-28</d><h>21:05</h><w>nathanmarz</w><pre>(def data
  {:foo {:type &quot;blah&quot;
         :properties {:foo {:type &quot;bar&quot;}
   :foo2 {:type &quot;foo&quot;}}}})

(def MY-WALKER
  (recursive-path [] p
    (continue-then-stay
      MAP-VALS
      (collect-one :type)
      :properties
      p
      )))

(select MY-WALKER data)
;; =&gt; [[&quot;blah&quot; &quot;bar&quot; nil] [&quot;blah&quot; &quot;foo&quot; nil] [&quot;blah&quot; {:foo {:type &quot;bar&quot;}, :foo2 {:type &quot;foo&quot;}}] {:foo {:type &quot;blah&quot;, :properties {:foo {:type &quot;bar&quot;}, :foo2 {:type &quot;foo&quot;}}}}]
</pre></z><z id="t1488315994" t="nathanmarz for selection it returns each collected :type followed by the node value at that point"><y>#</y><d>2017-02-28</d><h>21:06</h><w>nathanmarz</w>for selection it returns each collected <code>:type</code> followed by the node value at that point</z><z id="t1488316023" t="ghadi interesting... what does that return?"><y>#</y><d>2017-02-28</d><h>21:07</h><w>ghadi</w>interesting... what does that return?</z><z id="t1488316028" t="nathanmarz for transformation, your transform-fn will receive same thing but as arguments"><y>#</y><d>2017-02-28</d><h>21:07</h><w>nathanmarz</w>for transformation, your transform-fn will receive same thing but as arguments</z><z id="t1488316054" t="nathanmarz edited it"><y>#</y><d>2017-02-28</d><h>21:07</h><w>nathanmarz</w>edited it</z><z id="t1488316109" t="ghadi thanks! I&apos;m going to try to read the docs to understand that"><y>#</y><d>2017-02-28</d><h>21:08</h><w>ghadi</w>thanks! I&apos;m going to try to read the docs to understand that</z><z id="t1488390491" t="nathanmarz Released Specter 1.0 and wrote a post about why I consider it Clojure&apos;s missing piece http://nathanmarz.com/blog/clojures-missing-piece.html"><y>#</y><d>2017-03-01</d><h>17:48</h><w>nathanmarz</w>Released Specter 1.0 and wrote a post about why I consider it Clojure&apos;s missing piece <a href="http://nathanmarz.com/blog/clojures-missing-piece.html" target="_blank">http://nathanmarz.com/blog/clojures-missing-piece.html</a></z><z id="t1488405814" t="wei any tips simplifying this path? sp/ALL (sp/collect-one sp/FIRST) sp/LAST"><y>#</y><d>2017-03-01</d><h>22:03</h><w>wei</w>any tips simplifying this path?
<pre>sp/ALL
(sp/collect-one sp/FIRST)
sp/LAST</pre></z><z id="t1488405828" t="wei basically MAP-VAL but capturing the key"><y>#</y><d>2017-03-01</d><h>22:03</h><w>wei</w>basically MAP-VAL but capturing the key</z><z id="t1488406679" t="nathanmarz @wei you can factor it as (def MY-MAP-VALS (comp-paths ALL (collect-one FIRST) LAST))"><y>#</y><d>2017-03-01</d><h>22:17</h><w>nathanmarz</w>@wei you can factor it as <code>(def MY-MAP-VALS (comp-paths ALL (collect-one FIRST) LAST))</code></z><z id="t1488407918" t="wei aha, thanks @nathanmarz"><y>#</y><d>2017-03-01</d><h>22:38</h><w>wei</w>aha, thanks @nathanmarz</z><z id="t1488407961" t="wei also, if I wanted to run some formatting function on the captured value, how would I express that?"><y>#</y><d>2017-03-01</d><h>22:39</h><w>wei</w>also, if I wanted to run some formatting function on the captured value, how would I express that?</z><z id="t1488407979" t="wei this doesn’t give me what I want: sp/ALL (sp/collect-one sp/FIRST some-format-fn) sp/LAST"><y>#</y><d>2017-03-01</d><h>22:39</h><w>wei</w>this doesn’t give me what I want: <pre>sp/ALL
(sp/collect-one sp/FIRST some-format-fn)
sp/LAST</pre></z><z id="t1488408494" t="nathanmarz @wei do (view some-format-fn)"><y>#</y><d>2017-03-01</d><h>22:48</h><w>nathanmarz</w>@wei do <code>(view some-format-fn)</code></z><z id="t1488414942" t="richiardiandrea By the way great blog post"><y>#</y><d>2017-03-02</d><h>00:35</h><w>richiardiandrea</w>By the way great blog post</z><z id="t1488423500" t="nathanmarz thanks"><y>#</y><d>2017-03-02</d><h>02:58</h><w>nathanmarz</w>thanks</z><z id="t1488441204" t="miikka Regarding Haskell lenses and Lens/Traversal distinction: if I recall correctly, for Lens you&apos;re guaranteed that you can read a single value. This is handy with Haskell&apos;s type system, but in a dynamic language like Clojure, it does not really matter or make sense."><y>#</y><d>2017-03-02</d><h>07:53</h><w>miikka</w>Regarding Haskell lenses and Lens/Traversal distinction: if I recall correctly, for Lens you&apos;re guaranteed that you can read a single value. This is handy with Haskell&apos;s type system, but in a dynamic language like Clojure, it does not really matter or make sense.</z><z id="t1488441338" t="miikka In general, if you try to port Haskell lenses directly to dynamic languages (like people sometimes do), you&apos;ll end up with a bunch of things that just do not do anything useful without the type system."><y>#</y><d>2017-03-02</d><h>07:55</h><w>miikka</w>In general, if you try to port Haskell lenses directly to dynamic languages (like people sometimes do), you&apos;ll end up with a bunch of things that just do not do anything useful without the type system.</z><z id="t1488459483" t="nathanmarz @miikka Thanks, interesting point. Makes sense that the distinction would have something to do with the type system."><y>#</y><d>2017-03-02</d><h>12:58</h><w>nathanmarz</w>@miikka Thanks, interesting point. Makes sense that the distinction would have something to do with the type system.</z><z id="t1488463760" t="mmer (NEWBIE QUESTION) - I have been using specter to work with a structure that was originally yaml. The basic selectors I have some grasp of. What I need to do is find a set of map entries where the values are maps and that have a particular key - eg:"><y>#</y><d>2017-03-02</d><h>14:09</h><w>mmer</w>(NEWBIE QUESTION) - I have been using specter to work with a structure that was originally yaml. The basic selectors I have some grasp of.  What I need to do is find a set of map entries where the values are maps and that have a particular key - eg:</z><z id="t1488463867" t="mmer I want to be able to return :field1 and its contents by finding it because it has the :require true set."><y>#</y><d>2017-03-02</d><h>14:11</h><w>mmer</w>I want to be able to return :field1 and its contents by finding it because it has the :require true set.</z><z id="t1488464960" t="nathanmarz @mmer I think you&apos;re looking for (select [MAP-VALS map? (pred :required)] data)"><y>#</y><d>2017-03-02</d><h>14:29</h><w>nathanmarz</w>@mmer I think you&apos;re looking for <code>(select [MAP-VALS map? (pred :required)] data)</code></z><z id="t1488466104" t="mmer Thanks Nathan, how do I also get the key of the top level map returned i.e. :field1?"><y>#</y><d>2017-03-02</d><h>14:48</h><w>mmer</w>Thanks Nathan,  how do I also get the key of the top level map returned i.e. :field1?</z><z id="t1488466282" t="nathanmarz @mmer you can do (select [ALL (collect-one FIRST) LAST map? (pred :required)] data)"><y>#</y><d>2017-03-02</d><h>14:51</h><w>nathanmarz</w>@mmer you can do <code>(select [ALL (collect-one FIRST) LAST map? (pred :required)] data)</code></z><z id="t1488467345" t="mmer Thanks Nathan. I guess I am struggling to understand how this ends up working - for example the (collect-one FIRST) Is it FIRST because you treat the map as a list? The map? after the LAST is applied to what is returned by the LAST which is the end of the list created from the map?"><y>#</y><d>2017-03-02</d><h>15:09</h><w>mmer</w>Thanks Nathan.  I guess I am struggling to understand how this ends up working - for example the (collect-one FIRST) Is it FIRST because you treat the map as a list?  The map? after the LAST is applied to what is returned by the LAST which is the end of the list created from the map?</z><z id="t1488467874" t="tolitius would this work: =&gt; (select [ALL (pred (comp :required val))] m) [[:field1 {:type &quot;string&quot;, :required true}]] ?"><y>#</y><d>2017-03-02</d><h>15:17</h><w>tolitius</w>would this work:
<pre>=&gt; (select [ALL (pred (comp :required val))] m)
[[:field1 {:type &quot;string&quot;, :required true}]]</pre>?</z><z id="t1488468584" t="nathanmarz @mmer ALL on a map navigates you to each key/value pair as a 2-element vector"><y>#</y><d>2017-03-02</d><h>15:29</h><w>nathanmarz</w>@mmer <code>ALL</code> on a map navigates you to each key/value pair as a 2-element vector</z><z id="t1488468625" t="mmer Ok that really helps my understanding."><y>#</y><d>2017-03-02</d><h>15:30</h><w>mmer</w>Ok that really helps my understanding.</z><z id="t1488468642" t="nathanmarz @tolitius yea, that works too"><y>#</y><d>2017-03-02</d><h>15:30</h><w>nathanmarz</w>@tolitius yea, that works too</z><z id="t1488468715" t="tolitius thanks, I am learning specter, just wanted to make sure I did not miss an edge case"><y>#</y><d>2017-03-02</d><h>15:31</h><w>tolitius</w>thanks, I am learning specter, just wanted to make sure I did not miss an edge case</z><z id="t1488527196" t="james @nathanmarz Congratulations on the 1.0 release! Specter is an amazing feat of software engineering, and an essential part of my Clojure toolbox. Thank you so much for turning my least favourite part of Clojure (manipulating nested data structures) from a frustrating slog into joyful productivity!"><y>#</y><d>2017-03-03</d><h>07:46</h><w>james</w>@nathanmarz Congratulations on the 1.0 release! Specter is an amazing feat of software engineering, and an essential part of my Clojure toolbox. Thank you so much for turning my least favourite part of Clojure (manipulating nested data structures) from a frustrating slog into joyful productivity!</z><z id="t1488547648" t="bill_tozier I’ve been able to replicate all the examples involving trees, of course. The bigger picture for me, though, is to be able to select a random item from a tree and transform that. Working it out with a zipper is simple enough, but I was hoping to produce a clearer and more readable function that uses Specter. I’m working through from the given examples “change every X in a tree to Y”, and I’ve got a working version in which one of the filters is a random function. So I can now change a random subset of the nodes in a tree to new values. But selecting only one of those is turning out to be problematic for me. Maybe if I could find the source for the FIRST and LAST navigators? ¯\(ツ)/¯"><y>#</y><d>2017-03-03</d><h>13:27</h><w>bill_tozier</w>I’ve been able to replicate all the examples involving trees, of course. The bigger picture for me, though, is to be able to select a random item from a tree and transform that. Working it out with a <code>zipper</code> is simple enough, but I was hoping to produce a clearer and more readable function that uses Specter.

I’m working through from the given examples “change every X in a tree to Y”, and I’ve got a working version in which one of the filters is a random function. So I can now change a random subset of the nodes in a tree to new values. But selecting only one of those is turning out to be problematic for me.

Maybe if I could find the source for the <code>FIRST</code> and <code>LAST</code> navigators? ¯\(ツ)/¯</z><z id="t1488548755" t="nathanmarz @bill_tozier FIRST /`LAST` navigate you to the first or last element of a sequence"><y>#</y><d>2017-03-03</d><h>13:45</h><w>nathanmarz</w>@bill_tozier <code>FIRST</code>/`LAST` navigate you to the first or last element of a sequence</z><z id="t1488548796" t="bill_tozier That was my guess, yes."><y>#</y><d>2017-03-03</d><h>13:46</h><w>bill_tozier</w>That was my guess, yes.</z><z id="t1488548808" t="nathanmarz if you want to change a random element, you&apos;ll first need: (def TREE-VALUES (recursive-path [] p (if-path vector? [ALL p] STAY))) "><y>#</y><d>2017-03-03</d><h>13:46</h><w>nathanmarz</w>if you want to change a random element, you&apos;ll first need:
<pre>(def TREE-VALUES
  (recursive-path [] p
    (if-path vector?
      [ALL p]
      STAY)))
</pre></z><z id="t1488548868" t="nathanmarz Then do (transform (subselect TREE-VALUES) (fn [all-vals] ...) tree)"><y>#</y><d>2017-03-03</d><h>13:47</h><w>nathanmarz</w>Then do <code>(transform (subselect TREE-VALUES) (fn [all-vals] ...) tree)</code></z><z id="t1488548893" t="nathanmarz and inside your custom function change a random element of that sequence"><y>#</y><d>2017-03-03</d><h>13:48</h><w>nathanmarz</w>and inside your custom function change a random element of that sequence</z><z id="t1488548997" t="nathanmarz you could also use define a custom navigator for it though it&apos;s tricky since it&apos;s better if navigators are deterministic (so they work with subselect , for instance)"><y>#</y><d>2017-03-03</d><h>13:49</h><w>nathanmarz</w>you could also use define a custom navigator for it though it&apos;s tricky since it&apos;s better if navigators are deterministic (so they work with <code>subselect</code>, for instance)</z><z id="t1488549027" t="nathanmarz your custom navigator would need to generate a random seed, and then always use that seed to navigate to the same random element"><y>#</y><d>2017-03-03</d><h>13:50</h><w>nathanmarz</w>your custom navigator would need to generate a random seed, and then always use that seed to navigate to the same random element</z><z id="t1488549066" t="nathanmarz so usage would probably be something like: (setval [(subselect TREE-VALUES) (random-elem)] 1111 tree)"><y>#</y><d>2017-03-03</d><h>13:51</h><w>nathanmarz</w>so usage would probably be something like: <code>(setval [(subselect TREE-VALUES) (random-elem)] 1111 tree)</code></z><z id="t1488551994" t="bill_tozier nathanmarz: Thanks! I had made the mistake of thinking a navigator accumulated a collection of paths to items. I realize that’s the un-lazy inefficient way, which is how I got sidetracked."><y>#</y><d>2017-03-03</d><h>14:39</h><r>bill_tozier</r>nathanmarz: Thanks! I had made the mistake of thinking a navigator accumulated a collection of paths to items. I realize that’s the un-lazy inefficient way, which is how I got sidetracked.</z><z id="t1488549148" t="nathanmarz @james Thanks!"><y>#</y><d>2017-03-03</d><h>13:52</h><w>nathanmarz</w>@james Thanks!</z><z id="t1488549344" t="val_waeselynck I seem unable to use setval NONE to dissoc fro a map, any idea why ?"><y>#</y><d>2017-03-03</d><h>13:55</h><w>val_waeselynck</w>I seem unable to use <code>setval NONE</code> to dissoc fro a map, any idea why ?</z><z id="t1488549346" t="val_waeselynck (setval [:a :b :c] NONE {:a {:b {:c 1}}}) =&gt; {:a {:b {:c :com.rpl.specter.impl/NONE}}} "><y>#</y><d>2017-03-03</d><h>13:55</h><w>val_waeselynck</w><pre>(setval [:a :b :c] NONE {:a {:b {:c 1}}})
=&gt; {:a {:b {:c :com.rpl.specter.impl/NONE}}}
</pre></z><z id="t1488549444" t="val_waeselynck This is weird as I&apos;m using specter 1.0.0"><y>#</y><d>2017-03-03</d><h>13:57</h><w>val_waeselynck</w>This is weird as I&apos;m using specter 1.0.0</z><z id="t1488549858" t="schmee val_waeselynck are you sure?"><y>#</y><d>2017-03-03</d><h>14:04</h><w>schmee</w>val_waeselynck are you sure?</z><z id="t1488549874" t="schmee I get this: user=&gt; (setval [:a :b :c] NONE {:a {:b {:c 1}}}) {:a {:b {}}}"><y>#</y><d>2017-03-03</d><h>14:04</h><w>schmee</w>I get this: <pre>user=&gt; (setval [:a :b :c] NONE {:a {:b {:c 1}}})
{:a {:b {}}}</pre></z><z id="t1488549879" t="schmee in 1.0.0"><y>#</y><d>2017-03-03</d><h>14:04</h><w>schmee</w>in 1.0.0</z><z id="t1488549903" t="val_waeselynck maybe I have some classpath issue I don&apos;t understand, but I don&apos;t know how to find out..."><y>#</y><d>2017-03-03</d><h>14:05</h><w>val_waeselynck</w>maybe I have some classpath issue I don&apos;t understand, but I don&apos;t know how to find out...</z><z id="t1488549915" t="val_waeselynck $ lein deps :tree | grep specter yields"><y>#</y><d>2017-03-03</d><h>14:05</h><w>val_waeselynck</w><code>$ lein deps :tree | grep specter</code> yields</z><z id="t1488549919" t="val_waeselynck [com.rpl/specter &quot;1.0.0&quot;]"><y>#</y><d>2017-03-03</d><h>14:05</h><w>val_waeselynck</w><code> [com.rpl/specter &quot;1.0.0&quot;]</code></z><z id="t1488549941" t="schmee 🤔"><y>#</y><d>2017-03-03</d><h>14:05</h><w>schmee</w><b>🤔</b></z><z id="t1488549964" t="schmee have you tried restarting the repl?"><y>#</y><d>2017-03-03</d><h>14:06</h><w>schmee</w>have you tried restarting the repl?</z><z id="t1488549974" t="schmee the catch-all solution 😛"><y>#</y><d>2017-03-03</d><h>14:06</h><w>schmee</w>the catch-all solution <b>😛</b></z><z id="t1488550004" t="val_waeselynck yup"><y>#</y><d>2017-03-03</d><h>14:06</h><w>val_waeselynck</w>yup</z><z id="t1488550019" t="val_waeselynck trying again after a lein clean ..."><y>#</y><d>2017-03-03</d><h>14:06</h><w>val_waeselynck</w>trying again after a <code>lein clean</code> ...</z><z id="t1488550028" t="val_waeselynck see you in 2 minutes ^^"><y>#</y><d>2017-03-03</d><h>14:07</h><w>val_waeselynck</w>see you in 2 minutes ^^</z><z id="t1488550082" t="val_waeselynck OK, it does work, awesome"><y>#</y><d>2017-03-03</d><h>14:08</h><w>val_waeselynck</w>OK, it does work, awesome</z><z id="t1488653327" t="oskarkv Hi! New to specter. Is there any particular reason why the data is the last argument to, for example, transform, instead of the first like in update-in?"><y>#</y><d>2017-03-04</d><h>18:48</h><w>oskarkv</w>Hi! New to specter. Is there any particular reason why the data is the last argument to, for example, transform, instead of the first like in update-in?</z><z id="t1488653967" t="schmee I would guess that it is to match map , filter , remove et. al"><y>#</y><d>2017-03-04</d><h>18:59</h><w>schmee</w>I would guess that it is to match <code>map</code>, <code>filter</code>, <code>remove</code> et. al</z><z id="t1488654258" t="oskarkv Yeah, it matters mostly for -&gt; et al, I guess the question was not that important 🙂"><y>#</y><d>2017-03-04</d><h>19:04</h><w>oskarkv</w>Yeah, it matters mostly for -&gt; et al, I guess the question was not that important <b>🙂</b></z><z id="t1488654367" t="schmee -&gt;&gt; should do the trick then 🙂"><y>#</y><d>2017-03-04</d><h>19:06</h><w>schmee</w><code>-&gt;&gt;</code> should do the trick then <b>🙂</b></z><z id="t1488654562" t="oskarkv yeah but i mean when you have several functions in a -&gt; or -&gt;&gt; 😛"><y>#</y><d>2017-03-04</d><h>19:09</h><w>oskarkv</w>yeah but i mean when you have several functions in a -&gt; or -&gt;&gt; <b>😛</b></z><z id="t1488654615" t="schmee then you want as-&gt; 🙂"><y>#</y><d>2017-03-04</d><h>19:10</h><w>schmee</w>then you want <code>as-&gt;</code> <b>🙂</b></z></g><g id="s10"><z id="t1488656215" t="oskarkv I started reading about specter like 30 min ago. It&apos;s amazing 🙂"><y>#</y><d>2017-03-04</d><h>19:36</h><w>oskarkv</w>I started reading about specter like 30 min ago. It&apos;s amazing <b>🙂</b></z><z id="t1488666688" t="oskarkv I saw that there is a function, select* , that seems to do the same thing as the macro select . What&apos;s the difference?"><y>#</y><d>2017-03-04</d><h>22:31</h><w>oskarkv</w>I saw that there is a function, <code>select*</code>, that seems to do the same thing as the macro <code>select</code>. What&apos;s the  difference?</z><z id="t1488666749" t="oskarkv Oh, you need the precompiled path"><y>#</y><d>2017-03-04</d><h>22:32</h><w>oskarkv</w>Oh, you need the precompiled path</z><z id="t1488667276" t="oskarkv Or, now I&apos;m not sure anymore, looks like the select* function calls compile on the path."><y>#</y><d>2017-03-04</d><h>22:41</h><w>oskarkv</w>Or, now I&apos;m not sure anymore, looks like the <code>select*</code> function calls compile on the path.</z><z id="t1488698896" t="puzzler @oskarkv Use the macro select whenever possible -- it does more optimization magic, I believe. select* may be useful in a situation where you absolutely need a function (for example, as an input to a higher-order function like map ). For the most part, it&apos;s best to think of select* as an underlying implementation function, not really an important part of the end-user API. [I&apos;m jumping in because you haven&apos;t gotten a response yet, but if anyone provides a more definitive answer, feel free to ignore mine]."><y>#</y><d>2017-03-05</d><h>07:28</h><w>puzzler</w>@oskarkv Use the macro <code>select</code> whenever possible -- it does more optimization magic, I believe.  <code>select*</code> may be useful in a situation where you absolutely need a function (for example, as an input to a higher-order function like <code>map</code>).    For the most part, it&apos;s best to think of <code>select*</code> as an underlying implementation function, not really an important part of the end-user API.  [I&apos;m jumping in because you haven&apos;t gotten a response yet, but if anyone provides a more definitive answer, feel free to ignore mine].</z><z id="t1488722204" t="nathanmarz gave a bit more detail answering the question on github https://github.com/nathanmarz/specter/issues/186"><y>#</y><d>2017-03-05</d><h>13:56</h><w>nathanmarz</w>gave a bit more detail answering the question on github <a href="https://github.com/nathanmarz/specter/issues/186" target="_blank">https://github.com/nathanmarz/specter/issues/186</a></z><z id="t1488836274" t="vikeri Is there a simple way to get all the keys of a nested map?"><y>#</y><d>2017-03-06</d><h>21:37</h><w>vikeri</w>Is there a simple way to get all the keys of a nested map?</z><z id="t1488836292" t="vikeri I suspect walker might be useful?"><y>#</y><d>2017-03-06</d><h>21:38</h><w>vikeri</w>I suspect <code>walker</code> might be useful?</z><z id="t1488836389" t="tolitius @vikeri http://gitpod.com/talks/config-plus-love/#33"><y>#</y><d>2017-03-06</d><h>21:39</h><w>tolitius</w>@vikeri <a href="http://gitpod.com/talks/config-plus-love/#33" target="_blank">http://gitpod.com/talks/config-plus-love/#33</a></z><z id="t1488836585" t="vikeri @tolitius I actually just want the keywords (spfun {:hello {:hi “Hello” :kew :not-included} :included 123}) =&gt; (:hello :hi :kew :included) "><y>#</y><d>2017-03-06</d><h>21:43</h><w>vikeri</w>@tolitius I actually just want the keywords
<pre>(spfun {:hello {:hi “Hello” :kew :not-included} :included 123})
=&gt; (:hello :hi :kew :included)
</pre></z><z id="t1488838817" t="nathanmarz @vikeri (defn spfun [m] (let [p (recursive-path [] p (if-path map? (continue-then-stay MAP-VALS p)))] (select [p MAP-KEYS] m) )) "><y>#</y><d>2017-03-06</d><h>22:20</h><w>nathanmarz</w>@vikeri
<pre>(defn spfun [m]
  (let [p (recursive-path [] p
            (if-path map?
              (continue-then-stay MAP-VALS p)))]
    (select [p MAP-KEYS] m)
    ))
</pre></z><z id="t1488838912" t="ag do I need to do anything special to be able to use Specter in Clojurescript? when I try to require it like this: (require &apos;[com.rpl.specter :as sp]) I’m seeing bunch of errors"><y>#</y><d>2017-03-06</d><h>22:21</h><w>ag</w>do I need to do anything special to be able to use Specter in Clojurescript? 

when I try to require it like this: (require &apos;[com.rpl.specter :as sp])
I’m seeing bunch of errors</z><z id="t1488838935" t="nathanmarz it should work fine"><y>#</y><d>2017-03-06</d><h>22:22</h><w>nathanmarz</w>it should work fine</z><z id="t1488838938" t="nathanmarz what errors are you seeing?"><y>#</y><d>2017-03-06</d><h>22:22</h><w>nathanmarz</w>what errors are you seeing?</z><z id="t1488838990" t="ag :optimizations :none"><y>#</y><d>2017-03-06</d><h>22:23</h><w>ag</w><code>:optimizations    :none</code></z><z id="t1488839090" t="nathanmarz is that a stack trace?"><y>#</y><d>2017-03-06</d><h>22:24</h><w>nathanmarz</w>is that a stack trace?</z><z id="t1488839125" t="ag that’s what I’m seeing in browser window (dev tools)"><y>#</y><d>2017-03-06</d><h>22:25</h><w>ag</w>that’s what I’m seeing in browser window (dev tools)</z><z id="t1488839140" t="ag when I try to require specter"><y>#</y><d>2017-03-06</d><h>22:25</h><w>ag</w>when I try to require specter</z><z id="t1488839146" t="nathanmarz hmm, it doesn&apos;t say an error type or exception type?"><y>#</y><d>2017-03-06</d><h>22:25</h><w>nathanmarz</w>hmm, it doesn&apos;t say an error type or exception type?</z><z id="t1488839183" t="nathanmarz oh is this being run with bootstrap?"><y>#</y><d>2017-03-06</d><h>22:26</h><w>nathanmarz</w>oh is this being run with bootstrap?</z><z id="t1488839218" t="ag no, it’s a boot-clj project. I’m using [org.clojure/clojurescript “1.9.293”]"><y>#</y><d>2017-03-06</d><h>22:26</h><w>ag</w>no, it’s a boot-clj project. 
I’m using [org.clojure/clojurescript   “1.9.293”]</z><z id="t1488839270" t="nathanmarz i&apos;m not sure how boot works"><y>#</y><d>2017-03-06</d><h>22:27</h><w>nathanmarz</w>i&apos;m not sure how boot works</z><z id="t1488839273" t="nathanmarz this may be relevant: https://github.com/nathanmarz/specter/issues/136"><y>#</y><d>2017-03-06</d><h>22:27</h><w>nathanmarz</w>this may be relevant: <a href="https://github.com/nathanmarz/specter/issues/136" target="_blank">https://github.com/nathanmarz/specter/issues/136</a></z><z id="t1488839294" t="ag I’m gonna try to update to “1.9.494” of CLJS"><y>#</y><d>2017-03-06</d><h>22:28</h><w>ag</w>I’m gonna try to update to “1.9.494” of CLJS</z><z id="t1488839382" t="nathanmarz planck/bootstrap implement macros differently than normal clojurescript, and specter currently doesn&apos;t handle this"><y>#</y><d>2017-03-06</d><h>22:29</h><w>nathanmarz</w>planck/bootstrap implement macros differently than normal clojurescript, and specter currently doesn&apos;t handle this</z><z id="t1488839418" t="nathanmarz https://github.com/nathanmarz/specter/issues/72"><y>#</y><d>2017-03-06</d><h>22:30</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/issues/72" target="_blank">https://github.com/nathanmarz/specter/issues/72</a></z><z id="t1488839625" t="ag bumping clojurescript version didn’t help. still saying same error 😞"><y>#</y><d>2017-03-06</d><h>22:33</h><w>ag</w>bumping clojurescript version didn’t help. still saying same error <b>😞</b></z><z id="t1488839650" t="ag I’m gonna try to repro in a smaller repo and will report"><y>#</y><d>2017-03-06</d><h>22:34</h><w>ag</w>I’m gonna try to repro in a smaller repo and will report</z><z id="t1488839850" t="ag Ha, interesting - actually when required in a file it works."><y>#</y><d>2017-03-06</d><h>22:37</h><w>ag</w>Ha, interesting - actually when required in a file it works.</z><z id="t1488839861" t="ag but when required in a repl - doesn&apos;t"><y>#</y><d>2017-03-06</d><h>22:37</h><w>ag</w>but when required in a repl - doesn&apos;t</z><z id="t1488839865" t="ag ¯\(ツ)/¯"><y>#</y><d>2017-03-06</d><h>22:37</h><w>ag</w>¯\(ツ)/¯</z><z id="t1488840701" t="nathanmarz @ag thanks, just open an issue on github"><y>#</y><d>2017-03-06</d><h>22:51</h><w>nathanmarz</w>@ag thanks, just open an issue on github</z><z id="t1489007971" t="schmee how do I remove all keys where the value is ”_&quot; from a hash like this? {:dim1 &quot;slice1&quot;, :dim2 &quot;slice2&quot;, :dim3 “_”}"><y>#</y><d>2017-03-08</d><h>21:19</h><w>schmee</w>how do I remove all keys where the value is <code>”_&quot;</code> from a hash like this? <pre>{:dim1 &quot;slice1&quot;, :dim2 &quot;slice2&quot;, :dim3 “_”}</pre></z><z id="t1489008039" t="schmee I’ve tried various incantations of selected? , subselect and filterer , and I can’t figure out what goes where"><y>#</y><d>2017-03-08</d><h>21:20</h><w>schmee</w>I’ve tried various incantations of <code>selected?</code>, <code>subselect</code> and <code>filterer</code>, and I can’t figure out what goes where</z><z id="t1489008047" t="schmee or if that is even the right approach"><y>#</y><d>2017-03-08</d><h>21:20</h><w>schmee</w>or if that is even the right approach</z><z id="t1489008175" t="tolitius @schmee: boot.user=&gt; (setval [MAP-VALS #(= % &quot;_&quot;)] NONE data) {:dim1 &quot;slice1&quot;, :dim2 &quot;slice2&quot;}"><y>#</y><d>2017-03-08</d><h>21:22</h><w>tolitius</w>@schmee: <pre>boot.user=&gt; (setval [MAP-VALS #(= % &quot;_&quot;)] NONE data)
{:dim1 &quot;slice1&quot;, :dim2 &quot;slice2&quot;}</pre></z><z id="t1489008248" t="schmee neat, thanks!"><y>#</y><d>2017-03-08</d><h>21:24</h><w>schmee</w>neat, thanks!</z><z id="t1489008288" t="schmee feel like cheating to use setval, I’m so used to immutability that anything involving “set” makes me nervous 😄"><y>#</y><d>2017-03-08</d><h>21:24</h><w>schmee</w>feel like cheating to use setval, I’m so used to immutability that anything involving “set” makes me nervous <b>😄</b></z><z id="t1489008412" t="schmee is there a way to do it with select though?"><y>#</y><d>2017-03-08</d><h>21:26</h><w>schmee</w>is there a way to do it with <code>select</code> though?</z><z id="t1489008467" t="schmee to reformulate, “select all keys that are not ”_” &quot;"><y>#</y><d>2017-03-08</d><h>21:27</h><w>schmee</w>to reformulate, “select all keys that are not <code>”_”</code>&quot;</z><z id="t1489008944" t="tolitius boot.user=&gt; (select [ALL #(-&gt; % val (not= &quot;_&quot;))] data) [[:dim1 &quot;slice1&quot;] [:dim2 &quot;slice2&quot;]] but this is not the right solution, since it does not return you a map + this would likely be better solved with creating a separate navigator.. which I did not wrap my head around yet"><y>#</y><d>2017-03-08</d><h>21:35</h><w>tolitius</w><pre>boot.user=&gt; (select [ALL #(-&gt; % val (not= &quot;_&quot;))] data)
[[:dim1 &quot;slice1&quot;] [:dim2 &quot;slice2&quot;]]</pre>
but this is not the right solution, since it does not return you a map + this would likely be better solved with creating a separate navigator.. which I did not wrap my head around yet</z><z id="t1489008987" t="schmee yeah, this is where I ended up as well"><y>#</y><d>2017-03-08</d><h>21:36</h><w>schmee</w>yeah, this is where I ended up as well</z><z id="t1489009005" t="schmee it seems there is no way to keep the hash when using select"><y>#</y><d>2017-03-08</d><h>21:36</h><w>schmee</w>it seems there is no way to keep the hash when using <code>select</code></z><z id="t1489009080" t="tolitius I don&apos;t think setval is wrong though"><y>#</y><d>2017-03-08</d><h>21:38</h><w>tolitius</w>I don&apos;t think <code>setval</code> is wrong though</z><z id="t1489009108" t="tolitius since you are removing / filtering the map entries"><y>#</y><d>2017-03-08</d><h>21:38</h><w>tolitius</w>since you are removing / filtering the map entries</z><z id="t1489009161" t="schmee indeed, but sometimes you want filter and sometimes you want remove , so I hope there is something equivalent in Specter 🙂"><y>#</y><d>2017-03-08</d><h>21:39</h><w>schmee</w>indeed, but sometimes you want <code>filter</code> and sometimes you want <code>remove</code>, so I hope there is something equivalent in Specter <b>🙂</b></z><z id="t1489009205" t="tolitius do (source remove) , it is filter underneath"><y>#</y><d>2017-03-08</d><h>21:40</h><w>tolitius</w>do <code>(source remove)</code>, it is filter underneath</z><z id="t1489009231" t="tolitius i.e. (filter (complement pred))"><y>#</y><d>2017-03-08</d><h>21:40</h><w>tolitius</w>i.e. <code>(filter (complement pred))</code></z><z id="t1489009272" t="tolitius i.e. setval does not mutate the original data structure"><y>#</y><d>2017-03-08</d><h>21:41</h><w>tolitius</w>i.e. <code>setval</code> does not mutate the original data structure</z><z id="t1489009586" t="schmee I know, and the setval approach works just fine, but aesthetically having both filter and remove can make the code read nicer"><y>#</y><d>2017-03-08</d><h>21:46</h><w>schmee</w>I know, and the <code>setval</code> approach works just fine, but aesthetically having both <code>filter</code> and <code>remove</code> can make the code read nicer</z><z id="t1489009629" t="schmee which is why I want to use specter at all in this case, otherwise I’d just do (into {} (remove #(= &quot;_&quot; (val %)) data))"><y>#</y><d>2017-03-08</d><h>21:47</h><w>schmee</w>which is why I want to use specter at all in this case, otherwise I’d just do <code>(into {} (remove #(= &quot;_&quot; (val %)) data))</code></z><z id="t1489009711" t="schmee I’m hunting for use-cases in my own code where Specter makes sense, that’s why I’m trying to shoehorn it a bit in this case"><y>#</y><d>2017-03-08</d><h>21:48</h><w>schmee</w>I’m hunting for use-cases in my own code where Specter makes sense, that’s why I’m trying to shoehorn it a bit in this case</z><z id="t1489009751" t="tolitius makes sense. I think select will always return you a sequence though"><y>#</y><d>2017-03-08</d><h>21:49</h><w>tolitius</w>makes sense. I think <code>select</code> will always return you a sequence though</z><z id="t1489010706" t="nathanmarz @schmee keep in mind that the setval approach will maintain the type of map and also be significantly faster than the (into {} ...) approach"><y>#</y><d>2017-03-08</d><h>22:05</h><w>nathanmarz</w>@schmee keep in mind that the <code>setval</code> approach will maintain the type of map and also be significantly faster than the <code>(into {} ...)</code> approach</z><z id="t1489100888" t="chromalchemy I am trying to filter a map, but return a map, not just the filtered values. I can use setval, but how do I go one level deep? {:id1 {:a false} :id2 {:a true}} -&gt; {:id2 {:a true}} using something like (setval [MAP-VALS :a true?] ....)"><y>#</y><d>2017-03-09</d><h>23:08</h><w>chromalchemy</w>I am trying to filter a map, but return a map, not just the filtered values. I can use setval, but how do I go one level deep?

<code>{:id1 {:a false} :id2 {:a true}}  -&gt; {:id2 {:a true}}</code> using something like <code>(setval [MAP-VALS :a true?] ....)</code></z><z id="t1489101067" t="nathanmarz @chromalchemy I think you&apos;re looking for: (setval [MAP-VALS (selected? :a (complement identity))] NONE data) "><y>#</y><d>2017-03-09</d><h>23:11</h><w>nathanmarz</w>@chromalchemy I think you&apos;re looking for:
<pre>(setval [MAP-VALS (selected? :a (complement identity))] NONE data)
</pre></z><z id="t1489102011" t="chromalchemy Perfect Thanks!!! Trying to understand (selected?) . What is the difference between [ALL even?] and [ALL (selected? even?)] ?"><y>#</y><d>2017-03-09</d><h>23:26</h><w>chromalchemy</w>Perfect Thanks!!! Trying to understand <code>(selected?)</code>. What is the difference between <code>[ALL even?]</code> and <code>[ALL (selected? even?)]</code>?</z><z id="t1489102059" t="nathanmarz those particular examples are equivalent"><y>#</y><d>2017-03-09</d><h>23:27</h><w>nathanmarz</w>those particular examples are equivalent</z><z id="t1489102076" t="nathanmarz selected? in general is a filter on whether the path selects anything"><y>#</y><d>2017-03-09</d><h>23:27</h><w>nathanmarz</w><code>selected?</code> in general is a filter on whether the path selects anything</z><z id="t1489102099" t="nathanmarz if you only give it functions it&apos;s the same as just using those functions directly in the path"><y>#</y><d>2017-03-09</d><h>23:28</h><w>nathanmarz</w>if you only give it functions it&apos;s the same as just using those functions directly in the path</z><z id="t1489102191" t="chromalchemy Ok so if the path does not &quot;select&quot; a thing, then it is effectively filtered out of the result."><y>#</y><d>2017-03-09</d><h>23:29</h><w>chromalchemy</w>Ok so if the path does not &quot;select&quot; a thing, then it is effectively filtered out of the result.</z><z id="t1489102439" t="chromalchemy Thank you again for Specter and the recent push to 1.0!!! I was surprised to read the consternated feedback on reddit. As a relative noob, it is for me much more obvious and empowering than than the walls I regularly run into when trying to juggle basic clojure functions to screen and transform data for UI stuff in cljs."><y>#</y><d>2017-03-09</d><h>23:33</h><w>chromalchemy</w>Thank you again for Specter and the recent push to 1.0!!! I was surprised to read the consternated feedback on reddit. As a relative noob, it is for me much more obvious and empowering than than the walls I regularly run into when trying to juggle basic clojure functions to screen and transform data for UI stuff in cljs.</z><z id="t1489103242" t="chromalchemy Still a bit confused why (setval [MAP-VALS (selected? :a true?)] NONE {:id1 {:a false} :id2 {:a true}}) returns {:id1 {:a false}} But i&apos;m up an running nonetheless simple_smile"><y>#</y><d>2017-03-09</d><h>23:47</h><w>chromalchemy</w>Still a bit confused why <pre>(setval
      [MAP-VALS (selected? :a true?)]
      NONE
      {:id1 {:a false} :id2 {:a true}})</pre> returns <code>{:id1 {:a false}}</code>
But i&apos;m up an running nonetheless <b>simple_smile</b></z><z id="t1489103331" t="chromalchemy I guess NONE gets rid of the maps that pass the true? test."><y>#</y><d>2017-03-09</d><h>23:48</h><w>chromalchemy</w>I guess <code>NONE</code> gets rid of the maps that pass the <code>true?</code> test.</z><z id="t1489103367" t="nathanmarz @chromalchemy yes, that&apos;s right"><y>#</y><d>2017-03-09</d><h>23:49</h><w>nathanmarz</w>@chromalchemy yes, that&apos;s right</z><z id="t1489103396" t="nathanmarz that code is selecting which values to remove (as opposed to which values to keep)"><y>#</y><d>2017-03-09</d><h>23:49</h><w>nathanmarz</w>that code is selecting which values to remove (as opposed to which values to keep)</z><z id="t1489103462" t="chromalchemy Ok , got it. Thx for the clarification."><y>#</y><d>2017-03-09</d><h>23:51</h><w>chromalchemy</w>Ok , got it. Thx for the clarification.</z><z id="t1489114241" t="tolitius @nathanmarz (setval [MAP-VALS (comp not :a)] NONE data) would also work, what would be the difference in it vs. (setval [MAP-VALS (selected? :a (complement identity))] NONE data)"><y>#</y><d>2017-03-10</d><h>02:50</h><w>tolitius</w>@nathanmarz <pre>(setval [MAP-VALS (comp not :a)] NONE data)</pre> would also work, what would be the difference in it vs. <pre>(setval [MAP-VALS (selected? :a (complement identity))] NONE data)</pre></z><z id="t1489114372" t="nathanmarz @tolitius same thing"><y>#</y><d>2017-03-10</d><h>02:52</h><w>nathanmarz</w>@tolitius same thing</z><z id="t1489114389" t="tolitius would selected? be more performant?"><y>#</y><d>2017-03-10</d><h>02:53</h><w>tolitius</w>would <code>selected?</code> be more performant?</z><z id="t1489114398" t="nathanmarz definitely not"><y>#</y><d>2017-03-10</d><h>02:53</h><w>nathanmarz</w>definitely not</z><z id="t1489114408" t="nathanmarz the comp approach might be slightly more performant"><y>#</y><d>2017-03-10</d><h>02:53</h><w>nathanmarz</w>the comp approach might be slightly more performant</z><z id="t1489114433" t="nathanmarz pretty minor though"><y>#</y><d>2017-03-10</d><h>02:53</h><w>nathanmarz</w>pretty minor though</z><z id="t1489114525" t="tolitius thanks. trying to reason when to use an fn vs. a navigator"><y>#</y><d>2017-03-10</d><h>02:55</h><w>tolitius</w>thanks. trying to reason when to use an <code>fn</code> vs. a navigator</z><z id="t1489116182" t="nathanmarz in this case it doesn&apos;t really matter"><y>#</y><d>2017-03-10</d><h>03:23</h><w>nathanmarz</w>in this case it doesn&apos;t really matter</z><z id="t1489260650" t="firesofmay Hi, I am interested in contributing to specter. Just for fun/learning. But I am not sure which issue I should pick. I don&apos;t know where to begin with the issues already opened. Can someone point me to a good starting bug? Thanks"><y>#</y><d>2017-03-11</d><h>19:30</h><w>firesofmay</w>Hi,
I am interested in contributing to specter. Just for fun/learning. But I am not sure which issue I should pick. I don&apos;t know where to begin with the issues already opened. Can someone point me to a good starting bug?
Thanks</z><z id="t1489260700" t="nathanmarz @firesofmay thanks for the contribution you already made"><y>#</y><d>2017-03-11</d><h>19:31</h><w>nathanmarz</w>@firesofmay thanks for the contribution you already made</z><z id="t1489260747" t="firesofmay @nathanmarz thanks for your contributions to so many projects 🙂"><y>#</y><d>2017-03-11</d><h>19:32</h><w>firesofmay</w>@nathanmarz thanks for your contributions to so many projects <b>🙂</b></z><z id="t1489260755" t="nathanmarz there&apos;s not too much to be added to specter at the moment, I took care of most of the open issues for 1.0"><y>#</y><d>2017-03-11</d><h>19:32</h><w>nathanmarz</w>there&apos;s not too much to be added to specter at the moment, I took care of most of the open issues for 1.0</z><z id="t1489260764" t="nathanmarz this is probably the most self-contained issue: https://github.com/nathanmarz/specter/issues/183"><y>#</y><d>2017-03-11</d><h>19:32</h><w>nathanmarz</w>this is probably the most self-contained issue: <a href="https://github.com/nathanmarz/specter/issues/183" target="_blank">https://github.com/nathanmarz/specter/issues/183</a></z><z id="t1489260804" t="nathanmarz the most important improvement I&apos;m targeting for next version is https://github.com/nathanmarz/specter/issues/72"><y>#</y><d>2017-03-11</d><h>19:33</h><w>nathanmarz</w>the most important improvement I&apos;m targeting for next version is <a href="https://github.com/nathanmarz/specter/issues/72" target="_blank">https://github.com/nathanmarz/specter/issues/72</a></z><z id="t1489260842" t="nathanmarz but that one is pretty difficult due to needing to have some understanding of what&apos;s going on in the inline compiler"><y>#</y><d>2017-03-11</d><h>19:34</h><w>nathanmarz</w>but that one is pretty difficult due to needing to have some understanding of what&apos;s going on in the inline compiler</z><z id="t1489260852" t="firesofmay Hmm"><y>#</y><d>2017-03-11</d><h>19:34</h><w>firesofmay</w>Hmm</z><z id="t1489260859" t="nathanmarz plus the complexity of targeting three platforms simultaneously"><y>#</y><d>2017-03-11</d><h>19:34</h><w>nathanmarz</w>plus the complexity of targeting three platforms simultaneously</z><z id="t1489260890" t="nathanmarz this one would be nice too: https://github.com/nathanmarz/specter/issues/149"><y>#</y><d>2017-03-11</d><h>19:34</h><w>nathanmarz</w>this one would be nice too: <a href="https://github.com/nathanmarz/specter/issues/149" target="_blank">https://github.com/nathanmarz/specter/issues/149</a></z><z id="t1489260904" t="nathanmarz probably won&apos;t be very much code, but will require understanding some of the inline compiler"><y>#</y><d>2017-03-11</d><h>19:35</h><w>nathanmarz</w>probably won&apos;t be very much code, but will require understanding some of the inline compiler</z><z id="t1489260935" t="nathanmarz oh, and this one: https://github.com/nathanmarz/specter/issues/39"><y>#</y><d>2017-03-11</d><h>19:35</h><w>nathanmarz</w>oh, and this one: <a href="https://github.com/nathanmarz/specter/issues/39" target="_blank">https://github.com/nathanmarz/specter/issues/39</a></z><z id="t1489260949" t="nathanmarz that one is much easier than the ones that deal with the inline compiler"><y>#</y><d>2017-03-11</d><h>19:35</h><w>nathanmarz</w>that one is much easier than the ones that deal with the inline compiler</z><z id="t1489260961" t="nathanmarz just need to re-implement protocol paths in terms of primitives shared between cljs and clj"><y>#</y><d>2017-03-11</d><h>19:36</h><w>nathanmarz</w>just need to re-implement protocol paths in terms of primitives shared between cljs and clj</z><z id="t1489260989" t="firesofmay I haven&apos;t tried protocol for cljs. Any reference doc?"><y>#</y><d>2017-03-11</d><h>19:36</h><w>firesofmay</w>I haven&apos;t tried protocol for cljs. Any reference doc?</z><z id="t1489261026" t="nathanmarz https://github.com/clojure/clojurescript/wiki/Differences-from-Clojure"><y>#</y><d>2017-03-11</d><h>19:37</h><w>nathanmarz</w><a href="https://github.com/clojure/clojurescript/wiki/Differences-from-Clojure" target="_blank">https://github.com/clojure/clojurescript/wiki/Differences-from-Clojure</a></z><z id="t1489261031" t="nathanmarz that lists the differences"><y>#</y><d>2017-03-11</d><h>19:37</h><w>nathanmarz</w>that lists the differences</z><z id="t1489261033" t="firesofmay Also in Regex navigator Can you share input output examples?"><y>#</y><d>2017-03-11</d><h>19:37</h><w>firesofmay</w>Also in <code>Regex navigator</code> Can you share input output examples?</z><z id="t1489261048" t="nathanmarz the main difference is lack of extend function, which is what Specter currently uses for protocol paths"><y>#</y><d>2017-03-11</d><h>19:37</h><w>nathanmarz</w>the main difference is lack of <code>extend</code> function, which is what Specter currently uses for protocol paths</z><z id="t1489261170" t="nathanmarz (setval (regex-all #&quot;aa*&quot;) &quot;Q&quot; &quot;aaabcaad&quot;) ;; =&gt; &quot;QbcQd&quot;"><y>#</y><d>2017-03-11</d><h>19:39</h><w>nathanmarz</w><code>(setval (regex-all #&quot;aa*&quot;) &quot;Q&quot; &quot;aaabcaad&quot;) ;; =&gt; &quot;QbcQd&quot;</code></z><z id="t1489261212" t="nathanmarz and this too: (setval (regex-first #&quot;aa*&quot;) &quot;Q&quot; &quot;aaabcaad&quot;) ;; =&gt; &quot;Qbcaad&quot;"><y>#</y><d>2017-03-11</d><h>19:40</h><w>nathanmarz</w>and this too: <code>(setval (regex-first #&quot;aa*&quot;) &quot;Q&quot; &quot;aaabcaad&quot;) ;; =&gt; &quot;Qbcaad&quot;</code></z><z id="t1489261297" t="firesofmay This looks interesting. And a bit more easy to do I guess. So to implement this functionality where should I start looking at? setval fn?"><y>#</y><d>2017-03-11</d><h>19:41</h><w>firesofmay</w>This looks interesting. And a bit more easy to do I guess. So to implement this functionality where should I start looking at? <code>setval</code> fn?</z><z id="t1489261337" t="nathanmarz it would just be a new navigator"><y>#</y><d>2017-03-11</d><h>19:42</h><w>nathanmarz</w>it would just be a new navigator</z><z id="t1489261342" t="nathanmarz using defnav"><y>#</y><d>2017-03-11</d><h>19:42</h><w>nathanmarz</w>using <code>defnav</code></z><z id="t1489261353" t="nathanmarz look at the implementation of existing navigators to see how it works"><y>#</y><d>2017-03-11</d><h>19:42</h><w>nathanmarz</w>look at the implementation of existing navigators to see how it works</z><z id="t1489261370" t="firesofmay Great. I&apos;ll check it out 🙂"><y>#</y><d>2017-03-11</d><h>19:42</h><w>firesofmay</w>Great. I&apos;ll check it out <b>🙂</b></z><z id="t1489261381" t="nathanmarz awesome"><y>#</y><d>2017-03-11</d><h>19:43</h><w>nathanmarz</w>awesome</z><z id="t1489261787" t="firesofmay @nathanmarz Btw I had a question. I noticed in your project.clj file you have (def VERSION (.trim (slurp &quot;VERSION&quot;))) and (defproject com.rpl/specter VERSION What benefit does this provide?"><y>#</y><d>2017-03-11</d><h>19:49</h><w>firesofmay</w>@nathanmarz Btw I had a question. I noticed in your <code>project.clj</code> file you have <code>(def VERSION (.trim (slurp &quot;VERSION&quot;)))</code> and <code>(defproject com.rpl/specter VERSION</code>
What benefit does this provide?</z><z id="t1489262313" t="nathanmarz @firesofmay if I have submodules in the project, that makes it easy to have them all share the same version"><y>#</y><d>2017-03-11</d><h>19:58</h><w>nathanmarz</w>@firesofmay if I have submodules in the project, that makes it easy to have them all share the same version</z><z id="t1489262330" t="nathanmarz like if there were a specter-graph module with navigators for working with graphs"><y>#</y><d>2017-03-11</d><h>19:58</h><w>nathanmarz</w>like if there were a <code>specter-graph</code> module with navigators for working with graphs</z><z id="t1489262364" t="firesofmay @nathanmarz Ah they all just point to the same file and you just have to bump one single file. Make sense"><y>#</y><d>2017-03-11</d><h>19:59</h><w>firesofmay</w>@nathanmarz Ah they all just point to the same file and you just have to bump one single file. Make sense</z><z id="t1489262372" t="nathanmarz yea"><y>#</y><d>2017-03-11</d><h>19:59</h><w>nathanmarz</w>yea</z><z id="t1489502070" t="oskarkv How is (keypath :a) different from just :a in paths?"><y>#</y><d>2017-03-14</d><h>14:34</h><w>oskarkv</w>How is (keypath :a) different from just :a in paths?</z><z id="t1489502408" t="nathanmarz @oskarkv it&apos;s the same thing"><y>#</y><d>2017-03-14</d><h>14:40</h><w>nathanmarz</w>@oskarkv it&apos;s the same thing</z><z id="t1489502432" t="nathanmarz keywords implicitly convert themselves to that https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L984"><y>#</y><d>2017-03-14</d><h>14:40</h><w>nathanmarz</w>keywords implicitly convert themselves to that <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L984" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L984</a></z><z id="t1489502469" t="nathanmarz likewise, functions implicitly convert themselves to pred https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L988"><y>#</y><d>2017-03-14</d><h>14:41</h><w>nathanmarz</w>likewise, functions implicitly convert themselves to <code>pred</code> <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L988" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L988</a></z><z id="t1489502537" t="oskarkv ok, thanks"><y>#</y><d>2017-03-14</d><h>14:42</h><w>oskarkv</w>ok, thanks</z><z id="t1489547289" t="mars0i I&apos;m confused about how continue-then-stay works, for example in (continue-then-stay MAP-VALS p) from a recent example in this channeel."><y>#</y><d>2017-03-15</d><h>03:08</h><w>mars0i</w>I&apos;m confused about how <code>continue-then-stay</code> works, for example in <code>(continue-then-stay MAP-VALS p)</code> from a recent example in this channeel.</z><z id="t1489548384" t="mars0i I&apos;m also a bit confused about recursive-path , although I&apos;ve used it successfully by modifying an example in the &quot;missing piece&quot; blog post. In (recursive-path [] p (if-path vector? [ALL p] STAY)) , what is p bound to when it finds a vector, and why is p put after ALL ? (Also, what&apos;s the meaning of second argument [] ?) recursive-path seems very useful, but I gather it&apos;s new since it doesn&apos;t have a docstring or other documentation yet that I&apos;ve found."><y>#</y><d>2017-03-15</d><h>03:26</h><w>mars0i</w>I&apos;m also a bit confused about <code>recursive-path</code>, although I&apos;ve used it successfully by modifying an example in the &quot;missing piece&quot; blog post.  In <code>(recursive-path []  p (if-path vector? [ALL p] STAY))</code>, what is <code>p</code> bound to when it finds a vector, and why is <code>p</code> put after <code>ALL</code>?  (Also, what&apos;s the meaning of second argument <code>[]</code>?)  <code>recursive-path</code> seems very useful, but I gather it&apos;s new since it doesn&apos;t have a docstring or other documentation yet that I&apos;ve found.</z><z id="t1489574111" t="oskarkv Apparently I don&apos;t understand how not-selected? works. (select [:a (not-selected? :c)] {:a 1 :b {:a 1 :b 2}}) I expected to return something since :c does not exist. &quot;Stops navigation if the path navigator finds a result. Otherwise continues with the current structure.&quot; It couldn&apos;t have found :c, so the current structure is 1, because that&apos;s what just :a gives?"><y>#</y><d>2017-03-15</d><h>10:35</h><w>oskarkv</w>Apparently I don&apos;t understand how <code>not-selected?</code> works. <code>(select [:a (not-selected? :c)] {:a 1 :b {:a 1 :b 2}})</code> I expected to return something since :c does not exist. &quot;Stops navigation if the path navigator finds a result. Otherwise continues with the current structure.&quot; It couldn&apos;t have found :c, so the current structure is 1, because that&apos;s what just :a gives?</z><z id="t1489574815" t="nathanmarz @oskarkv but :c always navigates to something"><y>#</y><d>2017-03-15</d><h>10:46</h><w>nathanmarz</w>@oskarkv but <code>:c</code> always navigates to something</z><z id="t1489574819" t="nathanmarz in this case to nil"><y>#</y><d>2017-03-15</d><h>10:46</h><w>nathanmarz</w>in this case to <code>nil</code></z><z id="t1489574835" t="nathanmarz if you do (must :c) , that only navigates if :c exists in the map"><y>#</y><d>2017-03-15</d><h>10:47</h><w>nathanmarz</w>if you do <code>(must :c)</code>, that only navigates if <code>:c</code> exists in the map</z><z id="t1489574924" t="nathanmarz @mars0i continue-then-stay does literally what it says"><y>#</y><d>2017-03-15</d><h>10:48</h><w>nathanmarz</w>@mars0i <code>continue-then-stay</code> does literally what it says</z><z id="t1489574930" t="nathanmarz first it navigates to the given path"><y>#</y><d>2017-03-15</d><h>10:48</h><w>nathanmarz</w>first it navigates to the given path</z><z id="t1489574937" t="nathanmarz then it navigates to itself"><y>#</y><d>2017-03-15</d><h>10:48</h><w>nathanmarz</w>then it navigates to itself</z><z id="t1489574996" t="nathanmarz (transform (continue-then-stay STAY) inc 1) will return 3 , because it navigates to itself, then navigates to itself again"><y>#</y><d>2017-03-15</d><h>10:49</h><w>nathanmarz</w><code>(transform (continue-then-stay STAY) inc 1)</code> will return <code>3</code>, because it navigates to itself, then navigates to itself again</z><z id="t1489575048" t="nathanmarz p in that example is bound to itself (aka the entire path definition given )"><y>#</y><d>2017-03-15</d><h>10:50</h><w>nathanmarz</w><code>p</code> in that example is bound to itself (aka the entire path definition given )</z><z id="t1489575084" t="nathanmarz so for TREE-VALUES , what it&apos;s saying is: if navigated at a vector, navigate to each element of the vector and recurse"><y>#</y><d>2017-03-15</d><h>10:51</h><w>nathanmarz</w>so for <code>TREE-VALUES</code>, what it&apos;s saying is: if navigated at a vector, navigate to each element of the vector and recurse</z><z id="t1489575109" t="nathanmarz otherwise (meaning not at a vector), just stay navigated at that point (finish recursing)"><y>#</y><d>2017-03-15</d><h>10:51</h><w>nathanmarz</w>otherwise (meaning not at a vector), just stay navigated at that point (finish recursing)</z><z id="t1489575204" t="nathanmarz the [] argument i used to specify arguments to the resulting path"><y>#</y><d>2017-03-15</d><h>10:53</h><w>nathanmarz</w>the <code>[]</code> argument i used to specify arguments to the resulting path</z><z id="t1489575217" t="nathanmarz basically the result of recursive-path will be a function if any arguments are provided"><y>#</y><d>2017-03-15</d><h>10:53</h><w>nathanmarz</w>basically the result of <code>recursive-path</code> will be a function if any arguments are provided</z><z id="t1489575355" t="oskarkv Oh, OK. Thanks!"><y>#</y><d>2017-03-15</d><h>10:55</h><w>oskarkv</w>Oh, OK. Thanks!</z><z id="t1489578889" t="nathanmarz @oskarkv oh just noticed you were navigating to :a first, don&apos;t think that path is what you want"><y>#</y><d>2017-03-15</d><h>11:54</h><w>nathanmarz</w>@oskarkv oh just noticed you were navigating to <code>:a</code> first, don&apos;t think that path is what you want</z><z id="t1489580131" t="oskarkv I was just playing around to learn 😛"><y>#</y><d>2017-03-15</d><h>12:15</h><w>oskarkv</w>I was just playing around to learn <b>😛</b></z><z id="t1489588991" t="mars0i Thanks @nathanmarz. That&apos;s very helpful. I&apos;m still trying to get my head wrapped around some things that aren&apos;t intuitive for me yet. I still don&apos;t understand what p is doing in if-path branches in recursive-path . Here&apos;s an example I&apos;ve been using:"><y>#</y><d>2017-03-15</d><h>14:43</h><w>mars0i</w>Thanks @nathanmarz.  That&apos;s very helpful.  I&apos;m still trying to get my head wrapped around some things that aren&apos;t intuitive for me yet. I still don&apos;t understand what <code>p</code> is doing in <code>if-path</code> branches in <code>recursive-path</code>.  Here&apos;s an example I&apos;ve been using:</z><z id="t1489589034" t="mars0i (def a {:a1 {:b1 {:c1 1, :c2 2}, :b2 {:c1 3, :c2 4}}, :a2 {:b1 {:c1 5, :c2 6}, :b2 {:c1 7, :c2 8}}})"><y>#</y><d>2017-03-15</d><h>14:43</h><w>mars0i</w><pre>(def a {:a1 {:b1 {:c1 1, :c2 2}, :b2 {:c1 3, :c2 4}},
 :a2 {:b1 {:c1 5, :c2 6}, :b2 {:c1 7, :c2 8}}})</pre></z><z id="t1489589311" t="mars0i (select [(recursive-path [] p (if-path map? [MAP-VALS p] [STAY]))] a) produces [1 2 3 4 5 6 7 8] , i.e. the leaf node values. Why do I follow MAP-VALS with p ? Leaving out p just produces the original map wrapped in a vector, so I know I need p , to get the leaf nodes, but I don&apos;t understand why. Normally, if I have a path operator like MAP-VALS in a vector, it&apos;s the first navigation operation, and then the next one is applied, and so on. Here it feels as if p is an argument that&apos;s passed to MAP-VALS , maybe. Is that correct? So that [MAP-VALS p] within recursive-path (or if-path ?) is semantically different from, a sequence of navigators immediately after select or transform ?"><y>#</y><d>2017-03-15</d><h>14:48</h><w>mars0i</w><code>(select [(recursive-path [] p (if-path map? [MAP-VALS p] [STAY]))] a)</code> produces <code>[1 2 3 4 5 6 7 8]</code>, i.e. the leaf node values.  Why do I follow <code>MAP-VALS</code> with <code>p</code>?  Leaving out <code>p</code>  just produces the original map wrapped in a vector, so I know I need <code>p</code>, to get the leaf nodes, but I don&apos;t understand why.  Normally, if I have a path operator like <code>MAP-VALS</code> in a vector, it&apos;s the first navigation operation, and then the next one is applied, and so on.  Here it feels as if <code>p</code> is an argument that&apos;s passed to <code>MAP-VALS</code>, maybe.  Is that correct?  So that <code>[MAP-VALS p]</code> within <code>recursive-path</code>  (or <code>if-path</code>?) is semantically different from, a sequence of navigators immediately after <code>select</code> or <code>transform</code>?</z><z id="t1489589340" t="nathanmarz no, p is just the next navigation to do after MAP-VALS"><y>#</y><d>2017-03-15</d><h>14:49</h><w>nathanmarz</w>no, <code>p</code> is just the next navigation to do after <code>MAP-VALS</code></z><z id="t1489589358" t="nathanmarz think of it just like regular recursion"><y>#</y><d>2017-03-15</d><h>14:49</h><w>nathanmarz</w>think of it just like regular recursion</z><z id="t1489589361" t="nathanmarz (defn foo [i] (if (= 0 i) 1 (* 2 (foo (dec i))))) "><y>#</y><d>2017-03-15</d><h>14:49</h><w>nathanmarz</w><pre>(defn foo [i]
  (if (= 0 i)
    1
    (* 2 (foo (dec i)))))
</pre></z><z id="t1489589363" t="mars0i What is the value of p ?"><y>#</y><d>2017-03-15</d><h>14:49</h><w>mars0i</w>What is the value of <code>p</code>?</z><z id="t1489589377" t="nathanmarz foo refers to itself there, just like how p refers to the overall path"><y>#</y><d>2017-03-15</d><h>14:49</h><w>nathanmarz</w><code>foo</code> refers to itself there, just like how <code>p</code> refers to the overall path</z><z id="t1489589388" t="nathanmarz p is (if-path map? [MAP-VALS p] [STAY]))"><y>#</y><d>2017-03-15</d><h>14:49</h><w>nathanmarz</w><code>p</code> is <code>(if-path map? [MAP-VALS p] [STAY]))</code></z><z id="t1489589418" t="nathanmarz the effect of using p there is to continue going to all map vals until a non-map is encountered"><y>#</y><d>2017-03-15</d><h>14:50</h><w>nathanmarz</w>the effect of using <code>p</code> there is to continue going to all map vals until a non-map is encountered</z><z id="t1489589435" t="mars0i I know I might seem dense. I&apos;m just not in the mindset yet, but want to be."><y>#</y><d>2017-03-15</d><h>14:50</h><w>mars0i</w>I know I might seem dense.  I&apos;m just not in the mindset yet, but want to be.</z><z id="t1489589447" t="nathanmarz (btw you don&apos;t need the [] if it&apos;s just a single navigator)"><y>#</y><d>2017-03-15</d><h>14:50</h><w>nathanmarz</w>(btw you don&apos;t need the <code>[]</code> if it&apos;s just a single navigator)</z><z id="t1489589456" t="nathanmarz the second branch of if-path can just be STAY"><y>#</y><d>2017-03-15</d><h>14:50</h><w>nathanmarz</w>the second branch of <code>if-path</code> can just be <code>STAY</code></z><z id="t1489589504" t="nathanmarz are you comfortable with recursion with functions?"><y>#</y><d>2017-03-15</d><h>14:51</h><w>nathanmarz</w>are you comfortable with recursion with functions?</z><z id="t1489589532" t="mars0i Ah, maybe I see. So recursive-path doesn&apos;t in itself cause recursion to occur. It just sets up a context in which it can occur. The recursion is implemented by using the p that it binds, in if-path ."><y>#</y><d>2017-03-15</d><h>14:52</h><w>mars0i</w>Ah, maybe I see.  So <code>recursive-path</code> doesn&apos;t in itself cause recursion to occur.  It just sets up a context in which it can occur.  The recursion is implemented by using the <code>p</code> that it binds, in <code>if-path</code>.</z><z id="t1489589539" t="nathanmarz that&apos;s right"><y>#</y><d>2017-03-15</d><h>14:52</h><w>nathanmarz</w>that&apos;s right</z><z id="t1489589548" t="mars0i Yes, no problem with recursion. It&apos;s a reasonable question to ask."><y>#</y><d>2017-03-15</d><h>14:52</h><w>mars0i</w>Yes, no problem with recursion.  It&apos;s a reasonable question to ask.</z><z id="t1489589557" t="nathanmarz I see where you were confused now"><y>#</y><d>2017-03-15</d><h>14:52</h><w>nathanmarz</w>I see where you were confused now</z><z id="t1489589561" t="mars0i The Little Lisper set me straight decades ago."><y>#</y><d>2017-03-15</d><h>14:52</h><w>mars0i</w>The Little Lisper set me straight decades ago.</z><z id="t1489589590" t="nathanmarz recursive-path does absolutely nothing except provide you with an object that references itself"><y>#</y><d>2017-03-15</d><h>14:53</h><w>nathanmarz</w><code>recursive-path</code> does absolutely nothing except provide you with an object that references itself</z><z id="t1489589611" t="nathanmarz (recursive-path [] p [ALL even?]) is the same as [ALL even?]"><y>#</y><d>2017-03-15</d><h>14:53</h><w>nathanmarz</w><code>(recursive-path [] p [ALL even?])</code> is the same as <code>[ALL even?]</code></z><z id="t1489589679" t="mars0i OK. That helps a lot. Thanks. It&apos;s just like a special kind of let ."><y>#</y><d>2017-03-15</d><h>14:54</h><w>mars0i</w>OK.  That helps a lot.  Thanks.  It&apos;s just like a special kind of <code>let</code>.</z><z id="t1489589691" t="nathanmarz sort of"><y>#</y><d>2017-03-15</d><h>14:54</h><w>nathanmarz</w>sort of</z><z id="t1489589708" t="nathanmarz if you&apos;re curious, it&apos;s actually a wrapper around the lower level local-declarepath and providepath"><y>#</y><d>2017-03-15</d><h>14:55</h><w>nathanmarz</w>if you&apos;re curious, it&apos;s actually a wrapper around the lower level <code>local-declarepath</code> and <code>providepath</code></z><z id="t1489589717" t="nathanmarz those two can be used to make mutually recursive paths"><y>#</y><d>2017-03-15</d><h>14:55</h><w>nathanmarz</w>those two can be used to make mutually recursive paths</z><z id="t1489589763" t="mars0i &quot;sort of&quot; yeah that&apos;s why I wrote &quot;like&quot; and &quot;kind of&quot; 🙂 . OK, I&apos;ll look at those at some point."><y>#</y><d>2017-03-15</d><h>14:56</h><w>mars0i</w>&quot;sort of&quot; yeah that&apos;s why I wrote &quot;like&quot; and &quot;kind of&quot; <b>🙂</b>  .  OK, I&apos;ll look at those at some point.</z><z id="t1489589938" t="mars0i I&apos;m not sure I understand continue-then-stay followed by p within recursive-path , but I think I should think and experiment a bit and see if I can figure it out before asking further questions. Thanks very mush."><y>#</y><d>2017-03-15</d><h>14:58</h><w>mars0i</w>I&apos;m not sure I understand <code>continue-then-stay</code> followed by <code>p</code> within <code>recursive-path</code>, but I think I should think and experiment a bit and see if I can figure it out before asking further questions.  Thanks very mush.</z><z id="t1489589974" t="nathanmarz no problem, happy to help"><y>#</y><d>2017-03-15</d><h>14:59</h><w>nathanmarz</w>no problem, happy to help</z><z id="t1489589976" t="mars0i much. now that I understand recursive-path better."><y>#</y><d>2017-03-15</d><h>14:59</h><w>mars0i</w>much.  now that I understand <code>recursive-path</code> better.</z><z id="t1489598019" t="mars0i Based on an answer to vikeri a week ago: b ;=&gt; {:b1 {:c1 1, :c2 2}, :b2 {:c1 3, :c2 4}} (select [(recursive-path [] p (if-path map? (continue-then-stay MAP-VALS p))) MAP-KEYS] b) ;=&gt; [:c1 :c2 :c1 :c2 :b1 :b2] "><y>#</y><d>2017-03-15</d><h>17:13</h><w>mars0i</w>Based on an answer to vikeri a week ago: <pre>b ;=&gt; {:b1 {:c1 1, :c2 2}, :b2 {:c1 3, :c2 4}}

(select [(recursive-path [] p
           (if-path map?
	         (continue-then-stay MAP-VALS p)))
         MAP-KEYS]
	b)
;=&gt; [:c1 :c2 :c1 :c2 :b1 :b2]
</pre></z><z id="t1489598042" t="mars0i Just want to check my understanding of how this works."><y>#</y><d>2017-03-15</d><h>17:14</h><w>mars0i</w>Just want to check my understanding of how this works.</z><z id="t1489598167" t="mars0i If the current element is a map, then get its vals and continue with the path, p, but also, return the current element and pass it to MAP-KEYS. So what keeps coming out of all that are the keys, and they are what are wrapped in vector. Something like that?"><y>#</y><d>2017-03-15</d><h>17:16</h><w>mars0i</w>If the current element is a map, then get its vals and continue with the path, p, but also, return the current element and pass it to MAP-KEYS.  So what keeps coming out of all that are the keys, and they are what are wrapped in vector.  Something like that?</z><z id="t1489598339" t="mars0i Or rather MAP-VALS p causes p into which we recurse to be bound to the outputs of MAP-VALS . But also the entire map element at that point is passed to MAP-KEYS ."><y>#</y><d>2017-03-15</d><h>17:18</h><w>mars0i</w>Or rather <code>MAP-VALS p</code> causes <code>p</code> into which we recurse to be bound to the outputs of <code>MAP-VALS</code>.  But also the entire map element at that point is passed to <code>MAP-KEYS</code>.</z><z id="t1489598481" t="nathanmarz better to think of it one step at a time"><y>#</y><d>2017-03-15</d><h>17:21</h><w>nathanmarz</w>better to think of it one step at a time</z><z id="t1489598505" t="nathanmarz @mars0i the recursive-path part navigates to all maps reachable via navigations to map vals"><y>#</y><d>2017-03-15</d><h>17:21</h><w>nathanmarz</w>@mars0i the <code>recursive-path</code> part navigates to all maps reachable via navigations to map vals</z><z id="t1489598517" t="nathanmarz then for each map navigated to, it navigates to the keys"><y>#</y><d>2017-03-15</d><h>17:21</h><w>nathanmarz</w>then for each map navigated to, it navigates to the keys</z><z id="t1489598551" t="nathanmarz because of the continue-then-stay , transformations happen first on more descendant maps"><y>#</y><d>2017-03-15</d><h>17:22</h><w>nathanmarz</w>because of the <code>continue-then-stay</code>, transformations happen first on more descendant maps</z><z id="t1489598563" t="nathanmarz whereas with stay-then-continue the opposite would be true"><y>#</y><d>2017-03-15</d><h>17:22</h><w>nathanmarz</w>whereas with <code>stay-then-continue</code> the opposite would be true</z><z id="t1489598619" t="mars0i Ah, cool about stay-then-continue . I didn&apos;t want the keys in reverse order."><y>#</y><d>2017-03-15</d><h>17:23</h><w>mars0i</w>Ah, cool about <code>stay-then-continue</code>.  I didn&apos;t want the keys in reverse order.</z><z id="t1489598651" t="mars0i Maybe what I wrote applies better to it."><y>#</y><d>2017-03-15</d><h>17:24</h><w>mars0i</w>Maybe what I wrote applies better to it.</z><z id="t1489598680" t="mars0i Thanks again."><y>#</y><d>2017-03-15</d><h>17:24</h><w>mars0i</w>Thanks again.</z><z id="t1489598682" t="nathanmarz worth looking at their implementations https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1204"><y>#</y><d>2017-03-15</d><h>17:24</h><w>nathanmarz</w>worth looking at their implementations <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1204" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1204</a></z><z id="t1489598688" t="nathanmarz thin wrappers around multi-path"><y>#</y><d>2017-03-15</d><h>17:24</h><w>nathanmarz</w>thin wrappers around <code>multi-path</code></z><z id="t1489598851" t="mars0i OK, I see. This is also helping me understand multi-path ."><y>#</y><d>2017-03-15</d><h>17:27</h><w>mars0i</w>OK, I see.   This is also helping me understand <code>multi-path</code>.</z><z id="t1489649462" t="narkisr Hey, looking for a way to dissoc all items that are not matched by a select"><y>#</y><d>2017-03-16</d><h>07:31</h><w>narkisr</w>Hey, looking for a way to dissoc all items that are not matched by a select</z><z id="t1489649888" t="rauh @narkisr Like this? (sp/setval [sp/ALL (sp/not-selected? sp/LAST odd?)] sp/NONE {:a 0 :b 1})"><y>#</y><d>2017-03-16</d><h>07:38</h><w>rauh</w>@narkisr Like this? <code>(sp/setval [sp/ALL (sp/not-selected? sp/LAST odd?)] sp/NONE {:a 0 :b 1})</code></z><z id="t1489649936" t="narkisr I think so but my path is based on srange (I want to remove all items except last n)"><y>#</y><d>2017-03-16</d><h>07:38</h><w>narkisr</w>I think so but my path is based on srange (I want to remove all items except last n)</z><z id="t1489650056" t="narkisr Ill give it a go and report back"><y>#</y><d>2017-03-16</d><h>07:40</h><w>narkisr</w>Ill give it a go and report back</z><z id="t1489650058" t="narkisr thanks!"><y>#</y><d>2017-03-16</d><h>07:40</h><w>narkisr</w>thanks!</z><z id="t1489663626" t="nathanmarz @rauh you can do that more concisely and efficiently with: (setval [MAP-VALS even?] NONE {:a 0 :b 1})"><y>#</y><d>2017-03-16</d><h>11:27</h><w>nathanmarz</w>@rauh you can do that more concisely and efficiently with: <code>(setval [MAP-VALS even?] NONE {:a 0 :b 1})</code></z><z id="t1489663679" t="nathanmarz @narkisr you can do that by transforming the srange to be a smaller sequence only containing the last n elements"><y>#</y><d>2017-03-16</d><h>11:27</h><w>nathanmarz</w>@narkisr you can do that by transforming the srange to be a smaller sequence only containing the last n elements</z><z id="t1489663759" t="nathanmarz e.g. (transform (srange 1 5) #(subvec % 2 4) [1 2 3 4 5 6 7 8]) =&gt; [1 4 5 6 7 8]"><y>#</y><d>2017-03-16</d><h>11:29</h><w>nathanmarz</w>e.g. <code>(transform (srange 1 5) #(subvec % 2 4) [1 2 3 4 5 6 7 8]) =&gt; [1 4 5 6 7 8]</code></z><z id="t1489667570" t="narkisr Hey Natan, (transform [MAP-VALS (srange 1 4)] NONE (into (sorted-map) {1 2 3 4 5 6 7 8 9 10})))"><y>#</y><d>2017-03-16</d><h>12:32</h><w>narkisr</w>Hey Natan,  (transform [MAP-VALS (srange 1 4)] NONE  (into (sorted-map) {1 2 3 4 5 6 7 8 9 10})))</z><z id="t1489667580" t="narkisr Seems to not keep the sorting order"><y>#</y><d>2017-03-16</d><h>12:33</h><w>narkisr</w>Seems to not keep the sorting order</z><z id="t1489667593" t="narkisr ([1 2] [9 10])"><y>#</y><d>2017-03-16</d><h>12:33</h><w>narkisr</w>([1 2] [9 10])</z><z id="t1489667634" t="narkisr Never mind"><y>#</y><d>2017-03-16</d><h>12:33</h><w>narkisr</w>Never mind</z><z id="t1489667635" t="narkisr my bad"><y>#</y><d>2017-03-16</d><h>12:33</h><w>narkisr</w>my bad</z><z id="t1489667681" t="narkisr Just realized iv should have used (srange 0 3)"><y>#</y><d>2017-03-16</d><h>12:34</h><w>narkisr</w>Just realized iv should have used (srange 0 3)</z><z id="t1489667736" t="narkisr Also not sure how many you get feedback but specter is awesome, I can&apos;t imagine writing Clojure without it"><y>#</y><d>2017-03-16</d><h>12:35</h><w>narkisr</w>Also not sure how many you get feedback but specter is awesome, I can&apos;t imagine writing Clojure without it</z><z id="t1489667747" t="narkisr So big thank you"><y>#</y><d>2017-03-16</d><h>12:35</h><w>narkisr</w>So big thank you</z><z id="t1489669268" t="nathanmarz @narkisr thanks, glad to hear it"><y>#</y><d>2017-03-16</d><h>13:01</h><w>nathanmarz</w>@narkisr thanks, glad to hear it</z><z id="t1489761059" t="oskarkv What is this in (defnav a [x] (select* [this structure next-fn] ...)) I tried to use it but &quot;Unable to resolve symbol this&quot;."><y>#</y><d>2017-03-17</d><h>14:30</h><w>oskarkv</w>What is <code>this</code> in <code>(defnav a [x] (select* [this structure next-fn] ...))</code> I tried to use it but &quot;Unable to resolve symbol this&quot;.</z><z id="t1489763206" t="mars0i Looks like it&apos;s being used inside a proxy def @oskarkv "><y>#</y><d>2017-03-17</d><h>15:06</h><w>mars0i</w>Looks like it&apos;s being used inside a <code>proxy</code> def @oskarkv </z><z id="t1489763340" t="mars0i ie is that where that code originated?"><y>#</y><d>2017-03-17</d><h>15:09</h><w>mars0i</w>ie is that where that code originated?</z><z id="t1489764043" t="nathanmarz @oskarkv that&apos;s currently ignored"><y>#</y><d>2017-03-17</d><h>15:20</h><w>nathanmarz</w>@oskarkv that&apos;s currently ignored</z><z id="t1489764119" t="nathanmarz just there for consistency with how method definition works in clojure"><y>#</y><d>2017-03-17</d><h>15:21</h><w>nathanmarz</w>just there for consistency with how method definition works in clojure</z><z id="t1489764171" t="nathanmarz if you use defrichnav , then this refers to the navigator object"><y>#</y><d>2017-03-17</d><h>15:22</h><w>nathanmarz</w>if you use <code>defrichnav</code>, then <code>this</code> refers to the navigator object</z><z id="t1489770875" t="levitanong hi would transformed be able to receive a value from above its scope? Like: (transform [VAL (transformed [some-path] (fn [value-from-VAL path-from-transformed] (do-something)))] (fn [value-from-VAL value-from-transformed] (do-another-thing))) "><y>#</y><d>2017-03-17</d><h>17:14</h><w>levitanong</w>hi would <code>transformed</code> be able to receive a value from above its scope? Like:
<pre>(transform
  [VAL
   (transformed
     [some-path]
     (fn [value-from-VAL path-from-transformed]
       (do-something)))]
  (fn [value-from-VAL value-from-transformed]
    (do-another-thing)))
</pre></z><z id="t1489770996" t="nathanmarz @levitanong no, I opted to design it so the values for transformed are reset"><y>#</y><d>2017-03-17</d><h>17:16</h><w>nathanmarz</w>@levitanong no, I opted to design it so the values for <code>transformed</code> are reset</z><z id="t1489771051" t="levitanong @nathanmarz So if within a transform I use a transformed followed by some navigator, the “cursor” that navigator will operate on will be the original shape of the data passed to transform ?"><y>#</y><d>2017-03-17</d><h>17:17</h><w>levitanong</w>@nathanmarz So if within a <code>transform</code> I use a <code>transformed</code> followed by some navigator, the “cursor” that navigator will operate on will be the original shape of the data passed to <code>transform</code>?</z><z id="t1489771065" t="levitanong i.e. as if i had used a collector"><y>#</y><d>2017-03-17</d><h>17:17</h><w>levitanong</w>i.e. as if i had used a collector</z><z id="t1489771071" t="levitanong without any collecting going on"><y>#</y><d>2017-03-17</d><h>17:17</h><w>levitanong</w>without any collecting going on</z><z id="t1489771073" t="nathanmarz no, it just ignores collected values"><y>#</y><d>2017-03-17</d><h>17:17</h><w>nathanmarz</w>no, it just ignores collected values</z><z id="t1489771149" t="nathanmarz (transform [ALL (transformed STAY inc)] inc [1 2 3 4]) will emit [3 4 5 6]"><y>#</y><d>2017-03-17</d><h>17:19</h><w>nathanmarz</w><code>(transform [ALL (transformed STAY inc)] inc [1 2 3 4])</code> will emit <code>[3 4 5 6]</code></z><z id="t1489771726" t="levitanong hmmm."><y>#</y><d>2017-03-17</d><h>17:28</h><w>levitanong</w>hmmm.</z><z id="t1489771732" t="levitanong I think i have to parse this. lol"><y>#</y><d>2017-03-17</d><h>17:28</h><w>levitanong</w>I think i have to parse this. lol</z><z id="t1489771738" t="levitanong thanks for the replies, @nathanmarz"><y>#</y><d>2017-03-17</d><h>17:28</h><w>levitanong</w>thanks for the replies, @nathanmarz</z><z id="t1489772094" t="levitanong (transform [(transformed [VAL :key ALL] (fn [a b] (inc b)) VAL even?] (fn [a b] (println a)) {:key [1 2 3 4]}) In this above example, I expect a to be [2 3 4 5] , but I seem to be getting {:key [2 3 4 5]} At least, this is a simplified version of what I’m trying to do. Is this expected behavior?"><y>#</y><d>2017-03-17</d><h>17:34</h><w>levitanong</w><pre>(transform [(transformed [VAL :key ALL] (fn [a b] (inc b)) VAL even?] 
  (fn [a b] (println a))
  {:key [1 2 3 4]})
</pre>
In this above example, I expect a to be <code>[2 3 4 5]</code>, but I seem to be getting <code>{:key [2 3 4 5]}</code>

At least, this is a simplified version of what I’m trying to do. Is this expected behavior?</z><z id="t1489774189" t="nathanmarz @levitanong that code produces an error"><y>#</y><d>2017-03-17</d><h>18:09</h><w>nathanmarz</w>@levitanong that code produces an error</z><z id="t1489774206" t="nathanmarz since it&apos;s trying to incrementing a vector in the transformed clause"><y>#</y><d>2017-03-17</d><h>18:10</h><w>nathanmarz</w>since it&apos;s trying to incrementing a vector in the <code>transformed</code> clause</z><z id="t1489775858" t="levitanong @nathanmarz woops, fixed"><y>#</y><d>2017-03-17</d><h>18:37</h><w>levitanong</w>@nathanmarz woops, fixed</z><z id="t1489776527" t="nathanmarz @levitanong still erroring"><y>#</y><d>2017-03-17</d><h>18:48</h><w>nathanmarz</w>@levitanong still erroring</z><z id="t1489776535" t="nathanmarz now because it&apos;s calling even? on the map"><y>#</y><d>2017-03-17</d><h>18:48</h><w>nathanmarz</w>now because it&apos;s calling <code>even?</code> on the map</z><z id="t1489776598" t="nathanmarz but anyway, the navigator after the transformed clause will get {:key [2 3 4 5]} as input"><y>#</y><d>2017-03-17</d><h>18:49</h><w>nathanmarz</w>but anyway, the navigator after the <code>transformed</code> clause will get <code>{:key [2 3 4 5]}</code> as input</z><z id="t1489776745" t="levitanong @nathanmarz so it doesn’t actually navigate to the transformed values"><y>#</y><d>2017-03-17</d><h>18:52</h><w>levitanong</w>@nathanmarz so it doesn’t actually navigate to the transformed values</z><z id="t1489776759" t="nathanmarz correct"><y>#</y><d>2017-03-17</d><h>18:52</h><w>nathanmarz</w>correct</z><z id="t1489776762" t="nathanmarz it works just like view"><y>#</y><d>2017-03-17</d><h>18:52</h><w>nathanmarz</w>it works just like <code>view</code></z><z id="t1489776802" t="levitanong oh, must’ve misread the docs on transformed"><y>#</y><d>2017-03-17</d><h>18:53</h><w>levitanong</w>oh, must’ve misread the docs on transformed</z><z id="t1489776825" t="levitanong i was almost certain it said “navigates to the transformed values” or somesuch."><y>#</y><d>2017-03-17</d><h>18:53</h><w>levitanong</w>i was almost certain it said “navigates to the transformed values” or somesuch.</z><z id="t1489776837" t="levitanong Anyway, thanks! I am no longer confused 😄"><y>#</y><d>2017-03-17</d><h>18:53</h><w>levitanong</w>Anyway, thanks! I am no longer confused <b>😄</b></z><z id="t1489779215" t="mars0i I&apos;ve been trying to use Specter to return paths of keys from embedded maps. e.g. amalloy&apos;s answer at https://stackoverflow.com/questions/21768802/how-can-i-get-the-nested-keys-of-a-map-in-clojure :"><y>#</y><d>2017-03-17</d><h>19:33</h><w>mars0i</w>I&apos;ve been trying to use Specter to return paths of keys from embedded maps.  e.g. amalloy&apos;s answer at <a href="https://stackoverflow.com/questions/21768802/how-can-i-get-the-nested-keys-of-a-map-in-clojure" target="_blank">https://stackoverflow.com/questions/21768802/how-can-i-get-the-nested-keys-of-a-map-in-clojure</a> :</z><z id="t1489779260" t="mars0i (defn keys-in [m] (if (or (not (map? m)) (empty? m)) &apos;(()) (for [[k v] m subkey (keys-in v)] (cons k subkey))))"><y>#</y><d>2017-03-17</d><h>19:34</h><w>mars0i</w><pre>(defn keys-in [m]
  (if (or (not (map? m))
          (empty? m))
    &apos;(())
    (for [[k v] m
          subkey (keys-in v)]
      (cons k subkey))))</pre></z><z id="t1489779387" t="mars0i (keys-in {:a1 {:b1 {:c1 1, :c2 2}, :b2 {:c2 3}}, :a2 {:b2 {:c1 4, :c2 5}}})"><y>#</y><d>2017-03-17</d><h>19:36</h><w>mars0i</w><code>(keys-in {:a1 {:b1 {:c1 1, :c2 2}, :b2 {:c2 3}}, :a2 {:b2 {:c1 4, :c2 5}}})</code></z><z id="t1489779401" t="mars0i ;=&gt; ((:a1 :b1 :c1) (:a1 :b1 :c2) (:a1 :b2 :c2) (:a2 :b2 :c1) (:a2 :b2 :c2))"><y>#</y><d>2017-03-17</d><h>19:36</h><w>mars0i</w><code>;=&gt; ((:a1 :b1 :c1) (:a1 :b1 :c2) (:a1 :b2 :c2) (:a2 :b2 :c1) (:a2 :b2 :c2))</code></z><z id="t1489779448" t="mars0i I have been trying everything, turning myself inside-out. Probably used combinations of half of the items on the navigators page."><y>#</y><d>2017-03-17</d><h>19:37</h><w>mars0i</w>I have been trying everything, turning myself inside-out.  Probably used combinations of half of the items on the navigators page.</z><z id="t1489779474" t="mars0i Found out about transformed from above discussion, thought that was the key. Argh."><y>#</y><d>2017-03-17</d><h>19:37</h><w>mars0i</w>Found out about <code>transformed</code> from above discussion, thought that was the key.  Argh.</z><z id="t1489779517" t="mars0i Is this possible in Specter? Undoubtedly yes. Is it possible more simply than without it, though? I suspect so, but I don&apos;t yet have the insight to see how."><y>#</y><d>2017-03-17</d><h>19:38</h><w>mars0i</w>Is this possible in Specter?  Undoubtedly yes.  Is it possible more simply than without it, though?  I suspect so, but I don&apos;t yet have the insight to see how.</z><z id="t1489779611" t="mars0i Actually I don&apos;t need amalloy&apos;s empty? test. Just testing for map? is enough."><y>#</y><d>2017-03-17</d><h>19:40</h><w>mars0i</w>Actually I don&apos;t need amalloy&apos;s <code>empty?</code> test.  Just testing for <code>map?</code> is enough.</z><z id="t1489780202" t="nathanmarz @mars0i you can do that with value collection"><y>#</y><d>2017-03-17</d><h>19:50</h><w>nathanmarz</w>@mars0i you can do that with value collection</z><z id="t1489780203" t="nathanmarz one sec"><y>#</y><d>2017-03-17</d><h>19:50</h><w>nathanmarz</w>one sec</z><z id="t1489780330" t="mars0i I have experimented with VAL , collect , collect-one , but haven&apos;t figured out the magic configuration."><y>#</y><d>2017-03-17</d><h>19:52</h><w>mars0i</w>I have experimented with <code>VAL</code>, <code>collect</code>, <code>collect-one</code>, but haven&apos;t figured out the magic configuration.</z><z id="t1489780349" t="nathanmarz (defn keys-in [m] (let [p (recursive-path [] p (if-path map? [ALL (collect-one FIRST) LAST p] STAY ))] (map butlast (select p m)) )) "><y>#</y><d>2017-03-17</d><h>19:52</h><w>nathanmarz</w><pre>(defn keys-in [m]
  (let [p (recursive-path [] p
            (if-path map?
              [ALL (collect-one FIRST) LAST p]
              STAY
              ))]
    (map butlast (select p m))
    ))
</pre></z><z id="t1489780353" t="nathanmarz that&apos;s one way"><y>#</y><d>2017-03-17</d><h>19:52</h><w>nathanmarz</w>that&apos;s one way</z><z id="t1489780422" t="mars0i Beautiful. Thanks. I&apos;ll digest that now."><y>#</y><d>2017-03-17</d><h>19:53</h><w>mars0i</w>Beautiful.  Thanks.  I&apos;ll digest that now.</z><z id="t1489780484" t="nathanmarz here&apos;s another way: (defn keys-in [m] (let [p (recursive-path [] p (if-path map? [ALL (if-path [LAST map?] [(collect-one FIRST) LAST p] FIRST )]))] (select p m) )) "><y>#</y><d>2017-03-17</d><h>19:54</h><w>nathanmarz</w>here&apos;s another way:
<pre>(defn keys-in [m]
  (let [p (recursive-path [] p
            (if-path map?
              [ALL
               (if-path [LAST map?]
                [(collect-one FIRST) LAST p]
                FIRST
                )]))]
    (select p m)
    ))
</pre></z><z id="t1489780489" t="nathanmarz more efficient"><y>#</y><d>2017-03-17</d><h>19:54</h><w>nathanmarz</w>more efficient</z><z id="t1489780493" t="mars0i I&apos;d like to have this added to that StackOverflow question. I&apos;ll do it and credit you, if you want, but if you play SO and have time, you could get the points."><y>#</y><d>2017-03-17</d><h>19:54</h><w>mars0i</w>I&apos;d like to have this added to that StackOverflow question.  I&apos;ll do it and credit you, if you want, but if you play SO and have time, you could get the points.</z><z id="t1489780559" t="nathanmarz go for it"><y>#</y><d>2017-03-17</d><h>19:55</h><w>nathanmarz</w>go for it</z><z id="t1489780560" t="mars0i Great. more to digest ..."><y>#</y><d>2017-03-17</d><h>19:56</h><w>mars0i</w>Great.   more to digest ...</z><z id="t1489780605" t="mars0i OK, thanks much. I think there ought to be a Specter solution there. I&apos;ll add both. I saw a discussion elsewhere someone trying to do this with Specter and gave up."><y>#</y><d>2017-03-17</d><h>19:56</h><w>mars0i</w>OK, thanks much.  I think there ought to be a Specter solution there.  I&apos;ll add both.  I saw a discussion elsewhere someone trying to do this with Specter and gave up.</z><z id="t1489780944" t="nathanmarz once your brain adapts to thinking in terms of navigation this is easy stuff"><y>#</y><d>2017-03-17</d><h>20:02</h><w>nathanmarz</w>once your brain adapts to thinking in terms of navigation this is easy stuff</z><z id="t1489781012" t="mars0i I believe that. Still getting there."><y>#</y><d>2017-03-17</d><h>20:03</h><w>mars0i</w>I believe that.  Still getting there.</z><z id="t1489781505" t="mars0i i.e. the discussion elsewhere someone else gave up. So it&apos;s not just me who thought of using Specter for this kind of thing."><y>#</y><d>2017-03-17</d><h>20:11</h><w>mars0i</w>i.e. the discussion elsewhere someone else gave up.  So it&apos;s not just me who thought of using Specter for this kind of thing.</z><z id="t1489782533" t="nathanmarz @mars0i also worth noting that the specter solution should be significantly more efficient than all the solutions on that page"><y>#</y><d>2017-03-17</d><h>20:28</h><w>nathanmarz</w>@mars0i also worth noting that the specter solution should be significantly more efficient than all the solutions on that page</z><z id="t1489782598" t="nathanmarz except for the amalloy one which is probably comparable"><y>#</y><d>2017-03-17</d><h>20:29</h><w>nathanmarz</w>except for the amalloy one which is probably comparable</z><z id="t1489786466" t="mars0i I was wondering about that. I&apos;ll run the specter defs through Criterium later. I&apos;m using very small structures, so differences might not show up."><y>#</y><d>2017-03-17</d><h>21:34</h><w>mars0i</w>I was wondering about that.  I&apos;ll run the specter defs through Criterium later.  I&apos;m using very small structures, so differences might not show up.</z><z id="t1489786524" t="mars0i At some point I might randomly generate some large embedded maps just to see how the algorithms perform, but I don&apos;t have a need for large ones."><y>#</y><d>2017-03-17</d><h>21:35</h><w>mars0i</w>At some point I might randomly generate some large embedded maps just to see how the algorithms perform, but I don&apos;t have a need for large ones.</z><z id="t1489787882" t="nathanmarz @mars0i you should see a substantial difference"><y>#</y><d>2017-03-17</d><h>21:58</h><w>nathanmarz</w>@mars0i you should see a substantial difference</z><z id="t1489807229" t="mars0i nathanmarz or anyone else, I&apos;d like check my understanding of those keys-in functions from earlier if someone is willing. Here are very informal explanations of the functions&apos; operations as I understand them. This would help me understand some basic ideas of specter. Specter&apos;s already been useful for me, but once I went beyond very simple things I was getting confused. No need if you&apos;re not interested, too busy, etc."><y>#</y><d>2017-03-18</d><h>03:20</h><w>mars0i</w>nathanmarz or anyone else, I&apos;d like check my understanding of those keys-in functions from earlier if someone is willing.  Here are very informal explanations of the functions&apos; operations as I understand them.  This would help me understand some basic ideas of specter.  Specter&apos;s already been useful for me, but once I went beyond very simple things I was getting confused.  No need if you&apos;re not interested, too busy, etc.</z><z id="t1489807256" t="mars0i (defn simple-keybranches [m] (let [p (recursive-path [] p (if-path map? [ALL (collect-one FIRST) LAST p] STAY))] (map butlast (select p m)))) ;; Explanation: ;; I&apos;m given a map of maps of ... and ;; (A) since it&apos;s a map ;; it&apos;s passed to the first collection of navigators, which begins with ALL, so ;; for each MapEntry in the map ;; add its first element (key) to: ;; passing its last element (val) to ... now recurse (which is what p does), ;; i.e. for each of those map vals continue at (A) ;; ;; On each of these branches, we eventually get to a non-map; ;; return it and stop processing on that branch (STAY). ;; ;; However, this last thing returned is not one of the keys, it&apos;s ;; the terminal val. So we end up with the leaf vals in each ;; sequence. To strip them out, map butlast over the entire result. "><y>#</y><d>2017-03-18</d><h>03:20</h><w>mars0i</w><pre>(defn simple-keybranches [m]
  (let [p (recursive-path [] p
            (if-path map?
              [ALL (collect-one FIRST) LAST p]
              STAY))]
    (map butlast (select p m))))
;; Explanation:
;; I&apos;m given a map of maps of ... and 
;; (A) since it&apos;s a map
;; it&apos;s passed to the first collection of navigators, which begins with ALL, so
;; for each MapEntry in the map
;; add its first element (key) to:
;; passing its last element (val) to ... now recurse (which is what p does),
;; i.e. for each of those map vals continue at (A)
;; 
;; On each of these branches, we eventually get to a non-map;
;; return it and stop processing on that branch (STAY).
;;
;; However, this last thing returned is not one of the keys, it&apos;s
;; the terminal val.  So we end up with the leaf vals in each
;; sequence.  To strip them out, map butlast over the entire result.
</pre></z><z id="t1489807281" t="mars0i (defn faster-keybranches [m] (let [p (recursive-path [] p (if-path map? [ALL (if-path [LAST map?] [(collect-one FIRST) LAST p] FIRST)]))] (select p m))) ;; Explanation: ;; I&apos;m given a map of maps of ... and ;; (A) since it&apos;s a map ;; it&apos;s passed to ALL, i.e. ;; for each MapEntry e in the map, ;; if e&apos;s val is also a map ;; add its first element (key) to: ;; passing its last element (val) to ... now recurse (which is what p does), ;; i.e. for each of those map vals continue at (A) ;; or if e&apos;s val is not a map, then ;; get its first element, i.e. its key ;; On each of these branches, we eventually get to a non-map, ;; in which case stop processing on that branch and return nothing."><y>#</y><d>2017-03-18</d><h>03:21</h><w>mars0i</w><pre>(defn faster-keybranches [m]
  (let [p (recursive-path [] p
            (if-path map?
              [ALL
               (if-path [LAST map?]
                [(collect-one FIRST) LAST p]
                FIRST)]))]
    (select p m)))
;; Explanation:
;; I&apos;m given a map of maps of ... and 
;; (A) since it&apos;s a map
;; it&apos;s passed to ALL, i.e.
;; for each MapEntry e in the map,
;;   if e&apos;s val is also a map
;;     add its first element (key) to:
;;     passing its last element (val) to ... now recurse (which is what p does),
;;     i.e. for each of those map vals continue at (A)
;;   or if e&apos;s val is not a map, then
;;     get its first element, i.e. its key
;; On each of these branches, we eventually get to a non-map,
;; in which case stop processing on that branch and return nothing.</pre></z><z id="t1489807386" t="mars0i A question: Is the main reason that the first one should be faster is because the butlast is required to strip off the leaf elements?"><y>#</y><d>2017-03-18</d><h>03:23</h><w>mars0i</w>A question: Is the main reason that the first one should be faster is because the <code>butlast</code> is required to strip off the leaf elements?</z><z id="t1489807466" t="mars0i I actually want those! I was trying to figure out how to get the key paths, and then figured it would be easy to add the leaf elements, but that seemed like an additional step, so I didn&apos;t mention it. So I can just leave out the butlast for my application."><y>#</y><d>2017-03-18</d><h>03:24</h><w>mars0i</w>I actually want those!  I was trying to figure out how to get the key paths, and then figured it would be easy to add the leaf elements, but that seemed like an additional step, so I didn&apos;t mention it.  So I can just leave out the <code>butlast</code> for my application.</z><z id="t1489807553" t="mars0i So far it looks like there&apos;s no speed difference between the two specter definitions and the others for my small embedded maps, but that&apos;s not surprising. I&apos;m curious to try it with a larger structure, though."><y>#</y><d>2017-03-18</d><h>03:25</h><w>mars0i</w>So far it looks like there&apos;s no speed difference between the two specter definitions and the others for my small embedded maps, but that&apos;s not surprising.   I&apos;m curious to try it with a larger structure, though.</z><z id="t1489840816" t="nathanmarz correct, that&apos;s why the butlast is there"><y>#</y><d>2017-03-18</d><h>12:40</h><w>nathanmarz</w>correct, that&apos;s why the <code>butlast</code> is there</z><z id="t1489840860" t="nathanmarz I&apos;ve had issues profiling with criterium before, I did Specter&apos;s benchmarks manually: https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj"><y>#</y><d>2017-03-18</d><h>12:41</h><w>nathanmarz</w>I&apos;ve had issues profiling with criterium before, I did Specter&apos;s benchmarks manually: <a href="https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj" target="_blank">https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj</a></z><z id="t1489840915" t="nathanmarz the first run through the specter code it&apos;s doing inline compilation/caching, so unless you look at the aggregate of many runs that will skew the results"><y>#</y><d>2017-03-18</d><h>12:41</h><w>nathanmarz</w>the first run through the specter code it&apos;s doing inline compilation/caching, so unless you look at the aggregate of many runs that will skew the results</z><z id="t1489840930" t="nathanmarz not sure if criterium handles that"><y>#</y><d>2017-03-18</d><h>12:42</h><w>nathanmarz</w>not sure if criterium handles that</z><z id="t1489854476" t="mars0i Yes, that&apos;s the point of Criterium--to do that for you. It&apos;s supposed to run the code a bunch of times before starting timing, and then it reports average times from many runs. It&apos;s also supposed to put garbage collection in a fresh state beforehand. However, something&apos;s wrong with my testing. All of the functions are just as fast with huge embedded maps as with small ones. One has to worry about setting up tests in such a way that Java or Clojure optimizes them away. It looks like what worked to avoid that in the past isn&apos;t working for me. I have to investigate."><y>#</y><d>2017-03-18</d><h>16:27</h><w>mars0i</w>Yes, that&apos;s the point of Criterium--to do that for you.  It&apos;s supposed to run the code a bunch of times before starting timing, and then it reports average times from many runs.  It&apos;s also supposed to put garbage collection in a fresh state beforehand.  However, something&apos;s wrong with my testing.  All of the functions are just as fast with huge embedded maps as with small ones.  One has to worry about setting up tests in such a way that Java or Clojure optimizes them away.  It looks like what worked to avoid that in the past isn&apos;t working for me.  I have to investigate.</z><z id="t1489856006" t="mars0i Halfway systematic testing by hand suggests that both specter keybranch functions are much faster on a large embedded map (800K paths) than all of the other definitions, except for miner49r&apos;s reduce-kv version, which has comparable speed."><y>#</y><d>2017-03-18</d><h>16:53</h><w>mars0i</w>Halfway systematic testing by hand suggests that both specter keybranch functions are much faster on a large embedded map (800K paths) than all of the other definitions, except for miner49r&apos;s <code>reduce-kv</code> version, which has comparable speed.</z><z id="t1489856487" t="mars0i amalloy&apos;s definition might be fastest on small maps, but my testing so far isn&apos;t rigorous enough to be sure."><y>#</y><d>2017-03-18</d><h>17:01</h><w>mars0i</w>amalloy&apos;s definition might be fastest on small maps, but my testing so far isn&apos;t rigorous enough to be sure.</z><z id="t1489858559" t="nathanmarz ah yea, the reduce-kv version should be very fast"><y>#</y><d>2017-03-18</d><h>17:35</h><w>nathanmarz</w>ah yea, the <code>reduce-kv</code> version should be very fast</z><z id="t1489858588" t="nathanmarz the amalloy one uses for on the map which adds a lot of overhead"><y>#</y><d>2017-03-18</d><h>17:36</h><w>nathanmarz</w>the amalloy one uses <code>for</code> on the map which adds a lot of overhead</z><z id="t1489858678" t="nathanmarz for the first specter version you should wrap the (map butlast ...) in a doall so that the laziness doesn&apos;t avoid measurement"><y>#</y><d>2017-03-18</d><h>17:37</h><w>nathanmarz</w>for the first specter version you should wrap the <code>(map butlast ...)</code> in a <code>doall</code> so that the laziness doesn&apos;t avoid measurement</z><z id="t1489863065" t="mars0i I&apos;m putting all of the results through doall . As far as I can tell, none of them produce lazy sequences for the internal sequences."><y>#</y><d>2017-03-18</d><h>18:51</h><w>mars0i</w>I&apos;m putting all of the results through <code>doall</code>.  As far as I can tell, none of them produce lazy sequences for the internal sequences.</z><z id="t1489864191" t="mars0i Problem with Criterium was not optimization. Foolish mistake I was quoting the code passed to Criterium&apos;s macro. It&apos;s not supposed to be quoted."><y>#</y><d>2017-03-18</d><h>19:09</h><w>mars0i</w>Problem with Criterium was not optimization.  Foolish mistake I was quoting the code passed to Criterium&apos;s macro.  It&apos;s not supposed to be quoted.</z><z id="t1489900417" t="mars0i I tested seven functions that extract all paths through on 3-level, 3 keys per level and 6-level, 6 keys per level embedded map structures. The second Specter version above and miner49r&apos;s reduce-kv version are about the same speed, 2X (for the 3x3 map) and 3.5X (for the 6x6 map) faster than any other version. Another illustration of Specter producing code that&apos;s as fast or faster than handwritten code. It&apos;s very impressive. (The first Specter version is about the same speed if I take out map butlast .) Full details about my tests are available here: https://github.com/mars0i/key-path-tests"><y>#</y><d>2017-03-19</d><h>05:13</h><w>mars0i</w>I tested seven functions that extract all paths through on 3-level, 3 keys per level and 6-level, 6 keys per level embedded map structures.  The second Specter version above and miner49r&apos;s <code>reduce-kv</code> version are about the same speed, 2X (for the 3x3 map) and 3.5X (for the 6x6 map)  faster than any other  version.  Another illustration of Specter producing code that&apos;s as fast or faster than handwritten code.   It&apos;s very impressive.  (The first Specter version is about the same speed if I take out <code>map butlast</code>.)  Full details about my tests are available here: <a href="https://github.com/mars0i/key-path-tests" target="_blank">https://github.com/mars0i/key-path-tests</a></z><z id="t1489929905" t="nathanmarz @mars0i nice work, thanks for investigating it"><y>#</y><d>2017-03-19</d><h>13:25</h><w>nathanmarz</w>@mars0i nice work, thanks for investigating it</z><z id="t1489970550" t="mars0i Follow up question about generating paths of keys from embedded maps. My leaf values are sequences of numbers. If I use the first solution you gave, and don&apos;t strip out the values using butlast , I almost get what I want:"><y>#</y><d>2017-03-20</d><h>00:42</h><w>mars0i</w>Follow up question about generating paths of keys from embedded maps.  My leaf values are sequences of numbers.  If I use the first solution you gave, and don&apos;t strip out the values using <code>butlast</code>, I almost get what I want:</z><z id="t1489970585" t="mars0i (select (recursive-path [] p (if-path map? [ALL (collect-one FIRST) LAST p] STAY)) {:a1 {:b1 [1 2 3] :b2 [3 4 5]} :a2 {:b2 [6 7 8]}}) ;=&gt; [[:a1 :b1 [1 2 3]] [:a1 :b2 [3 4 5]] [:a2 :b2 [6 7 8]]]"><y>#</y><d>2017-03-20</d><h>00:43</h><w>mars0i</w><pre>(select (recursive-path [] p
           (if-path map?
             [ALL (collect-one FIRST) LAST p]
             STAY))
        {:a1 {:b1 [1 2 3]
              :b2 [3 4 5]}
         :a2 {:b2 [6 7 8]}})
;=&gt; [[:a1 :b1 [1 2 3]] [:a1 :b2 [3 4 5]] [:a2 :b2 [6 7 8]]]</pre></z><z id="t1489970729" t="mars0i What I want is [[:a1 :b1 1 2 3] [:a1 :b2 3 4 5] [:a2 :b2 6 7 8]] . I&apos;ve been trying to figure out how to do this in specter. Of course it&apos;s easy to fix in core Clojure afterwards. If I replace STAY with ALL , I get a separate path vector for each of the numbers in the leaf vectors. Other things I&apos;ve tried either produce one of these two results, or error. Thanks again for any help."><y>#</y><d>2017-03-20</d><h>00:45</h><w>mars0i</w>What I want is <code>[[:a1 :b1 1 2 3] [:a1 :b2 3 4 5] [:a2 :b2 6 7 8]]</code>.  I&apos;ve been trying to figure out how to do this in specter.  Of course it&apos;s easy to fix in core Clojure afterwards.  If I replace <code>STAY</code> with <code>ALL</code>, I get a separate path vector for each of the numbers in the leaf vectors.  Other things I&apos;ve tried either produce one of these two results, or error.  Thanks again for any help.</z><z id="t1489975942" t="nathanmarz @mars0i for that it&apos;s best to just fix it after the selection, with regular clojure or a transform call"><y>#</y><d>2017-03-20</d><h>02:12</h><w>nathanmarz</w>@mars0i for that it&apos;s best to just fix it after the selection, with regular clojure or a <code>transform</code> call</z><z id="t1489976003" t="nathanmarz it&apos;s possible to do it in one path with specter&apos;s zipper integration, but it won&apos;t be particularly elegant"><y>#</y><d>2017-03-20</d><h>02:13</h><w>nathanmarz</w>it&apos;s possible to do it in one path with specter&apos;s zipper integration, but it won&apos;t be particularly elegant</z><z id="t1489982225" t="mars0i OK, thanks very much. Yeah, I&apos;d rather avoid zippers if I can."><y>#</y><d>2017-03-20</d><h>03:57</h><w>mars0i</w>OK, thanks very much.    Yeah, I&apos;d rather avoid zippers if I can.</z><z id="t1490048133" t="spieden thought i’d share a satisfying solution i was just able to rattle off for extracting some information using specter (spr/select [:Resources spr/ALL (spr/collect spr/FIRST) spr/LAST :Properties :ContainerDefinitions spr/ALL :Environment spr/ALL (spr/selected? :Name #(= % &quot;REFERENCE_DATASET&quot;)) :Value] t) (i’m on an old version still)"><y>#</y><d>2017-03-20</d><h>22:15</h><w>spieden</w>thought i’d share a satisfying solution i was just able to rattle off for extracting some information using specter <code>(spr/select [:Resources spr/ALL (spr/collect spr/FIRST) spr/LAST :Properties :ContainerDefinitions spr/ALL :Environment spr/ALL (spr/selected? :Name #(= % &quot;REFERENCE_DATASET&quot;)) :Value] t)</code> (i’m on an old version still)</z><z id="t1490105797" t="luxbock what&apos;s wrong with my implementation of a take-nth navigator: https://gist.github.com/luxbock/a6a1323497a02e36b09dec624c57b3ab ?"><y>#</y><d>2017-03-21</d><h>14:16</h><w>luxbock</w>what&apos;s wrong with my implementation of a <code>take-nth</code> navigator: <a href="https://gist.github.com/luxbock/a6a1323497a02e36b09dec624c57b3ab" target="_blank">https://gist.github.com/luxbock/a6a1323497a02e36b09dec624c57b3ab</a> ?</z><z id="t1490105842" t="luxbock I am using (:refer-clojure :exclude [take-nth]) so it&apos;s not colliding with the clojure.core version"><y>#</y><d>2017-03-21</d><h>14:17</h><w>luxbock</w>I am using <code>(:refer-clojure :exclude [take-nth])</code> so it&apos;s not colliding with the <code>clojure.core</code> version</z><z id="t1490105862" t="luxbock using transform works fine"><y>#</y><d>2017-03-21</d><h>14:17</h><w>luxbock</w>using <code>transform</code> works fine</z><z id="t1490106431" t="luxbock argh, I&apos;m an idiot, of course I&apos;m calling take-nth inside my select*"><y>#</y><d>2017-03-21</d><h>14:27</h><w>luxbock</w>argh, I&apos;m an idiot, of course I&apos;m calling <code>take-nth</code> inside my <code>select*</code></z><z id="t1490112189" t="luxbock if I want my navigators to respect NONE do I need to implement that for every navigator?"><y>#</y><d>2017-03-21</d><h>16:03</h><w>luxbock</w>if I want my navigators to respect <code>NONE</code> do I need to implement that for every navigator?</z><z id="t1490112272" t="nathanmarz @luxbock yes"><y>#</y><d>2017-03-21</d><h>16:04</h><w>nathanmarz</w>@luxbock yes</z><z id="t1490112311" t="luxbock is that something that could be done automatically for me, or am I missing something obvious?"><y>#</y><d>2017-03-21</d><h>16:05</h><w>luxbock</w>is that something that could be done automatically for me, or am I missing something obvious?</z><z id="t1490112334" t="nathanmarz how to handle transformations to NONE is completely navigator specific"><y>#</y><d>2017-03-21</d><h>16:05</h><w>nathanmarz</w>how to handle transformations to <code>NONE</code> is completely navigator specific</z><z id="t1490112367" t="nathanmarz for keypath it does a dissoc , for ALL it filters it from reconstruction, for nthpath it removes from the sequence, etc."><y>#</y><d>2017-03-21</d><h>16:06</h><w>nathanmarz</w>for <code>keypath</code> it does a <code>dissoc</code>, for <code>ALL</code> it filters it from reconstruction, for <code>nthpath</code> it removes from the sequence, etc.</z><z id="t1490112402" t="luxbock right, makes sense"><y>#</y><d>2017-03-21</d><h>16:06</h><w>luxbock</w>right, makes sense</z><z id="t1490112499" t="nathanmarz looking at how those navigators implement it would be instructive I think"><y>#</y><d>2017-03-21</d><h>16:08</h><w>nathanmarz</w>looking at how those navigators implement it would be instructive I think</z><z id="t1490112588" t="luxbock what is the extra argument vals that defrichnav uses for select and transform?"><y>#</y><d>2017-03-21</d><h>16:09</h><w>luxbock</w>what is the extra argument <code>vals</code> that <code>defrichnav</code> uses for select and transform?</z><z id="t1490112610" t="nathanmarz those are the collected values"><y>#</y><d>2017-03-21</d><h>16:10</h><w>nathanmarz</w>those are the collected values</z><z id="t1490112626" t="nathanmarz like from collect , collect-one"><y>#</y><d>2017-03-21</d><h>16:10</h><w>nathanmarz</w>like from <code>collect</code>, <code>collect-one</code></z><z id="t1490112677" t="luxbock ah I see, thanks"><y>#</y><d>2017-03-21</d><h>16:11</h><w>luxbock</w>ah I see, thanks</z><z id="t1490112736" t="nathanmarz navigators that need to be defined using defrichnav are special cases"><y>#</y><d>2017-03-21</d><h>16:12</h><w>nathanmarz</w>navigators that need to be defined using <code>defrichnav</code> are special cases</z><z id="t1490112771" t="nathanmarz keypath does it as an optimization since Clojure/JVM aren&apos;t smart enough to inline this particular case"><y>#</y><d>2017-03-21</d><h>16:12</h><w>nathanmarz</w><code>keypath</code> does it as an optimization since Clojure/JVM aren&apos;t smart enough to inline this particular case</z><z id="t1490113099" t="luxbock I&apos;m trying to figure out how I could implement every-nth that respects NONE but it feels very difficult: https://gist.github.com/luxbock/69b766830144e4bdb767923ba7fb2f9c"><y>#</y><d>2017-03-21</d><h>16:18</h><w>luxbock</w>I&apos;m trying to figure out how I could implement <code>every-nth</code> that respects <code>NONE</code> but it feels very difficult: <a href="https://gist.github.com/luxbock/69b766830144e4bdb767923ba7fb2f9c" target="_blank">https://gist.github.com/luxbock/69b766830144e4bdb767923ba7fb2f9c</a></z><z id="t1490113193" t="nathanmarz you&apos;ll need a totally different approach"><y>#</y><d>2017-03-21</d><h>16:19</h><w>nathanmarz</w>you&apos;ll need a totally different approach</z><z id="t1490113201" t="nathanmarz better to construct a new vector from scratch"><y>#</y><d>2017-03-21</d><h>16:20</h><w>nathanmarz</w>better to construct a new vector from scratch</z><z id="t1490113227" t="nathanmarz elements that aren&apos;t at the nth indices go in unchanged, and for the others you apply next-fn and filter out ones that transform to NONE"><y>#</y><d>2017-03-21</d><h>16:20</h><w>nathanmarz</w>elements that aren&apos;t at the nth indices go in unchanged, and for the others you apply next-fn and filter out ones that transform to <code>NONE</code></z><z id="t1490113235" t="nathanmarz something similar for lists"><y>#</y><d>2017-03-21</d><h>16:20</h><w>nathanmarz</w>something similar for lists</z><z id="t1490113244" t="nathanmarz that&apos;s basically how ALL works"><y>#</y><d>2017-03-21</d><h>16:20</h><w>nathanmarz</w>that&apos;s basically how <code>ALL</code> works</z><z id="t1490113280" t="luxbock yeah, I&apos;m trying to learn from the specter native navigators but they are so heavily optimized that it&apos;s taking some time 🙂"><y>#</y><d>2017-03-21</d><h>16:21</h><w>luxbock</w>yeah, I&apos;m trying to learn from the specter native navigators but they are so heavily optimized that it&apos;s taking some time <b>🙂</b></z><z id="t1490113319" t="nathanmarz ALL on vectors is pretty simple https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L94"><y>#</y><d>2017-03-21</d><h>16:21</h><w>nathanmarz</w><code>ALL</code> on vectors is pretty simple <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L94" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L94</a></z></g><g id="s11"><z id="t1490113347" t="nathanmarz you should be able to do something very similar"><y>#</y><d>2017-03-21</d><h>16:22</h><w>nathanmarz</w>you should be able to do something very similar</z><z id="t1490113390" t="luxbock yeah, I&apos;ll keep trying, seems like an appropriately challenging example for me to level up on"><y>#</y><d>2017-03-21</d><h>16:23</h><w>luxbock</w>yeah, I&apos;ll keep trying, seems like an appropriately challenging example for me to level up on</z><z id="t1490113413" t="nathanmarz lists are a little trickier due to needing to maintain order https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L71"><y>#</y><d>2017-03-21</d><h>16:23</h><w>nathanmarz</w>lists are a little trickier due to needing to maintain order <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L71" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L71</a></z><z id="t1490113450" t="nathanmarz looks like you&apos;re understanding how navs work pretty well"><y>#</y><d>2017-03-21</d><h>16:24</h><w>nathanmarz</w>looks like you&apos;re understanding how navs work pretty well</z><z id="t1490113503" t="luxbock do you see specter still adding more navigators (such as these) or would you rather people see publish them as utility libraries?"><y>#</y><d>2017-03-21</d><h>16:25</h><w>luxbock</w>do you see specter still adding more navigators (such as these) or would you rather people see publish them as utility libraries?</z><z id="t1490113633" t="luxbock I think it&apos;s easy enough to write navigators that are very naive, but making them highly performant, versatile (in support for all possible datastructures) and respecting NONE is a lot of work, so I would definitely be happy to share the workload with others"><y>#</y><d>2017-03-21</d><h>16:27</h><w>luxbock</w>I think it&apos;s easy enough to write navigators that are very naive, but making them highly performant, versatile (in support for all possible datastructures) and respecting <code>NONE</code> is a lot of work, so I would definitely be happy to share the workload with others</z><z id="t1490114090" t="luxbock I remember a while back you mentioned that transducers that use comp are in some cases slower than just writing the same tranformation sequentially, because of the overhead of comp , and you could improve the performance by pre-compiling the composed transducer"><y>#</y><d>2017-03-21</d><h>16:34</h><w>luxbock</w>I remember a while back you mentioned that transducers that use <code>comp</code> are in some cases slower than just writing the same tranformation sequentially, because of the overhead of <code>comp</code>, and you could improve the performance by pre-compiling the composed transducer</z><z id="t1490114153" t="luxbock how would one compile a transducer, if I already know what it should do and don&apos;t need to compose it further using other transducers?"><y>#</y><d>2017-03-21</d><h>16:35</h><w>luxbock</w>how would one compile a transducer, if I already know what it should do and don&apos;t need to compose it further using other transducers?</z><z id="t1490114394" t="luxbock this seems to work and looks a lot better: https://gist.github.com/luxbock/33fecd25fce1ea91412ff86fb4df1e83"><y>#</y><d>2017-03-21</d><h>16:39</h><w>luxbock</w>this seems to work and looks a lot better: <a href="https://gist.github.com/luxbock/33fecd25fce1ea91412ff86fb4df1e83" target="_blank">https://gist.github.com/luxbock/33fecd25fce1ea91412ff86fb4df1e83</a></z><z id="t1490114631" t="nathanmarz @luxbock these don&apos;t seem core enough to me to go into specter core"><y>#</y><d>2017-03-21</d><h>16:43</h><w>nathanmarz</w>@luxbock these don&apos;t seem core enough to me to go into specter core</z><z id="t1490114669" t="nathanmarz also some of these may be superseded by stateful navigators if that&apos;s ever implemented https://github.com/nathanmarz/specter/issues/121"><y>#</y><d>2017-03-21</d><h>16:44</h><w>nathanmarz</w>also some of these may be superseded by stateful navigators if that&apos;s ever implemented <a href="https://github.com/nathanmarz/specter/issues/121" target="_blank">https://github.com/nathanmarz/specter/issues/121</a></z><z id="t1490114707" t="nathanmarz not sure I understand your question about transducers"><y>#</y><d>2017-03-21</d><h>16:45</h><w>nathanmarz</w>not sure I understand your question about transducers</z><z id="t1490114721" t="nathanmarz you precompile by calling comp in a central spot"><y>#</y><d>2017-03-21</d><h>16:45</h><w>nathanmarz</w>you precompile by calling <code>comp</code> in a central spot</z><z id="t1490114751" t="nathanmarz the problem is you can&apos;t precompile anything that requires the dynamic context (like local variables)"><y>#</y><d>2017-03-21</d><h>16:45</h><w>nathanmarz</w>the problem is you can&apos;t precompile anything that requires the dynamic context (like local variables)</z><z id="t1490114771" t="nathanmarz e.g. (comp (map some-local-arg) (filter even?))"><y>#</y><d>2017-03-21</d><h>16:46</h><w>nathanmarz</w>e.g. <code>(comp (map some-local-arg) (filter even?))</code></z><z id="t1490114836" t="nathanmarz the best you can do is precompile sequences of static transducers for reuse"><y>#</y><d>2017-03-21</d><h>16:47</h><w>nathanmarz</w>the best you can do is precompile sequences of static transducers for reuse</z><z id="t1490114866" t="nathanmarz in theory, transducers could use a similar inline compilation/caching strategy as specter to make this automatic"><y>#</y><d>2017-03-21</d><h>16:47</h><w>nathanmarz</w>in theory, transducers could use a similar inline compilation/caching strategy as specter to make this automatic</z><z id="t1490114981" t="luxbock I see, yeah stateful navigators look very interesting"><y>#</y><d>2017-03-21</d><h>16:49</h><w>luxbock</w>I see, yeah stateful navigators look very interesting</z><z id="t1490205241" t="conaw just had an idea that might be useful for some folks here… the new CSS Grid Module that just shipped in browsers has a feature called “grid-template-areas” which lets you build up an ascii-art style layout and then apply items to that layout according to names"><y>#</y><d>2017-03-22</d><h>17:54</h><w>conaw</w>just had an idea that might be useful for some folks here… the new CSS Grid Module that just shipped in browsers has a feature called “grid-template-areas” which lets you build up an ascii-art style layout and then apply items to that layout according to names</z><z id="t1490205304" t="conaw so you’d have ” ‘header header header’ ‘sidebar content ads&apos; &apos;footer footer footer’&quot; "><y>#</y><d>2017-03-22</d><h>17:55</h><w>conaw</w>so you’d have 
<pre>” ‘header header header’ 
‘sidebar content ads&apos;
&apos;footer footer footer’&quot;
</pre></z><z id="t1490205364" t="conaw I’ve been thinking about how I might dynamically generate certain named layouts based on content and user actions, realized specter could be used for doing things like inserting columns"><y>#</y><d>2017-03-22</d><h>17:56</h><w>conaw</w>I’ve been thinking about how I might dynamically generate certain named layouts based on content and user actions, realized specter could be used for doing things like inserting columns</z><z id="t1490207184" t="conaw http://gridbyexample.com/video/grid-template-areas/"><y>#</y><d>2017-03-22</d><h>18:26</h><w>conaw</w><a href="http://gridbyexample.com/video/grid-template-areas/" target="_blank">http://gridbyexample.com/video/grid-template-areas/</a></z><z id="t1490207204" t="conaw (def a (for [x (range 6)] (for [y (range 6)] y ) )) (sp/setval [(sp/srange 0 3) ALL (sp/srange 4 5) ALL] :a a ) "><y>#</y><d>2017-03-22</d><h>18:26</h><w>conaw</w><pre>(def a (for [x (range 6)]
         (for [y (range 6)]
           y
           )
         ))

(sp/setval [(sp/srange 0 3) ALL
            (sp/srange 4 5) ALL] :a
a
          )
</pre></z><z id="t1490302980" t="mmer Hi I have an question about adding a entry to a map based on the existence of a string within a value of a particular entry in the map:"><y>#</y><d>2017-03-23</d><h>21:03</h><w>mmer</w>Hi I have an question about adding a entry to a map based on the existence of a string within a value of a particular entry in the map:</z><z id="t1490303262" t="mmer I want to do a transform that removes the (read-only) from the desc fields and adds a map entry read-only: true to the map that contains the desc. I tried using the walker and predicate to find the entries with the (read-only) string the problem I have is that I can&apos;t find a way to create a transform that adds the entry. Removing the string is a bonus and I would be happy just to do the add."><y>#</y><d>2017-03-23</d><h>21:07</h><w>mmer</w>I want to do a transform that removes the (read-only) from the desc fields
  and adds a map entry read-only: true to the map that contains the desc.
  
  I tried using the walker and predicate to find the entries with the (read-only) string
  the problem I have is that I can&apos;t find a way to create a transform that adds the entry.
  
  Removing the string is a bonus and I would be happy just to do the add.</z><z id="t1490304630" t="nathanmarz @mmer not understanding your input"><y>#</y><d>2017-03-23</d><h>21:30</h><w>nathanmarz</w>@mmer not understanding your input</z><z id="t1490304640" t="nathanmarz it&apos;s not a map, did you mean to have a vector of maps?"><y>#</y><d>2017-03-23</d><h>21:30</h><w>nathanmarz</w>it&apos;s not a map, did you mean to have a vector of maps?</z><z id="t1490304651" t="nathanmarz what&apos;s &quot;type&quot; and &quot;desc&quot;? strings?"><y>#</y><d>2017-03-23</d><h>21:30</h><w>nathanmarz</w>what&apos;s &quot;type&quot; and &quot;desc&quot;? strings?</z><z id="t1490304655" t="nathanmarz same with their values"><y>#</y><d>2017-03-23</d><h>21:30</h><w>nathanmarz</w>same with their values</z><z id="t1490304736" t="nathanmarz you want to convert maps containing a description containing &quot;(read-only)&quot; to one with key/value pair of :read-only true and with the (&quot;read-only&quot;) removed?"><y>#</y><d>2017-03-23</d><h>21:32</h><w>nathanmarz</w>you want to convert maps containing a description containing <code>&quot;(read-only)&quot;</code> to one with key/value pair of <code>:read-only true</code> and with the <code>(&quot;read-only&quot;)</code> removed?</z><z id="t1490307520" t="mmer Sorry I missed the key in the outside map now edited as it is"><y>#</y><d>2017-03-23</d><h>22:18</h><w>mmer</w>Sorry I missed the key in the outside map  now edited as it is</z><z id="t1490307617" t="mmer target:"><y>#</y><d>2017-03-23</d><h>22:20</h><w>mmer</w>target:</z><z id="t1490307734" t="nathanmarz ok, I&apos;ll just assume the keys are keywords and the value for properties is a sequence"><y>#</y><d>2017-03-23</d><h>22:22</h><w>nathanmarz</w>ok, I&apos;ll just assume the keys are keywords and the value for properties is a sequence</z><z id="t1490307861" t="nathanmarz it would look something like: (multi-transform [:properties ALL (selected? :desc #(.contains % &quot;(read-only&quot;))) (multi-path [:desc (terminal remove-read-only-str)] [:read-only (terminal-val true)])] data) "><y>#</y><d>2017-03-23</d><h>22:24</h><w>nathanmarz</w>it would look something like:
<pre>(multi-transform [:properties 
                  ALL
                  (selected? :desc #(.contains % &quot;(read-only&quot;)))
                  (multi-path [:desc (terminal remove-read-only-str)]
                              [:read-only (terminal-val true)])] 
         data)
</pre></z><z id="t1490308039" t="nathanmarz with https://github.com/nathanmarz/specter/issues/183 you could do this without any custom or anonymous functions"><y>#</y><d>2017-03-23</d><h>22:27</h><w>nathanmarz</w>with <a href="https://github.com/nathanmarz/specter/issues/183" target="_blank">https://github.com/nathanmarz/specter/issues/183</a> you could do this without any custom or anonymous functions</z><z id="t1490308092" t="nathanmarz by replacing the anonymous function with (regex-all #&quot;(read-only)&quot;) and replacing remove-read-only-str custom function with (regex-all #&quot;(read-only)&quot;) (terminal-val &quot;&quot;)"><y>#</y><d>2017-03-23</d><h>22:28</h><w>nathanmarz</w>by replacing the anonymous function with <code>(regex-all #&quot;(read-only)&quot;)</code> and replacing <code>remove-read-only-str</code> custom function with <code>(regex-all #&quot;(read-only)&quot;) (terminal-val &quot;&quot;)</code></z><z id="t1490308439" t="mmer Thanks once again"><y>#</y><d>2017-03-23</d><h>22:33</h><w>mmer</w>Thanks once again</z><z id="t1490308539" t="mmer I am rather puzzled by the #anglican? I presume that is slack getting in the way?"><y>#</y><d>2017-03-23</d><h>22:35</h><w>mmer</w>I am rather puzzled by the #anglican?  I presume that is slack getting in the way?</z><z id="t1490309014" t="nathanmarz hmm not sure why it did that"><y>#</y><d>2017-03-23</d><h>22:43</h><w>nathanmarz</w>hmm not sure why it did that</z><z id="t1490309016" t="nathanmarz fixed it"><y>#</y><d>2017-03-23</d><h>22:43</h><w>nathanmarz</w>fixed it</z><z id="t1490312668" t="mmer Thanks I do have a followup question - if you change :properties with ALL I get a NullPointerException - in fact any changes to the :properties ALL seems to result in the same exception"><y>#</y><d>2017-03-23</d><h>23:44</h><w>mmer</w>Thanks I do have a followup question - if you change :properties with ALL I get a NullPointerException - in fact any changes to the :properties ALL seems to result in the same exception</z><z id="t1490312744" t="nathanmarz well, ALL on a map navigates you to a vector of [key value]"><y>#</y><d>2017-03-23</d><h>23:45</h><w>nathanmarz</w>well, <code>ALL</code> on a map navigates you to a vector of <code>[key value]</code></z><z id="t1490312759" t="nathanmarz the next ALL navigates you to each key and value"><y>#</y><d>2017-03-23</d><h>23:45</h><w>nathanmarz</w>the next <code>ALL</code> navigates you to each <code>key</code> and <code>value</code></z><z id="t1490312781" t="nathanmarz then the selected? line navigates to :desc for each of those values, which in some cases is nil"><y>#</y><d>2017-03-23</d><h>23:46</h><w>nathanmarz</w>then the <code>selected?</code> line navigates to <code>:desc</code> for each of those values, which in some cases is nil</z><z id="t1490312793" t="nathanmarz so doing .contains on nil will be a NullPointedException"><y>#</y><d>2017-03-23</d><h>23:46</h><w>nathanmarz</w>so doing <code>.contains</code> on nil will be a <code>NullPointedException</code></z><z id="t1490312918" t="nathanmarz you probably wanted to replace :properties with MAP-VALS , but I&apos;m not sure since your input data still isn&apos;t clear"><y>#</y><d>2017-03-23</d><h>23:48</h><w>nathanmarz</w>you probably wanted to replace <code>:properties</code> with <code>MAP-VALS</code>, but I&apos;m not sure since your input data still isn&apos;t clear</z><z id="t1490324291" t="snacks hi: If i have a nested map like this map1 {:a [{:b 1 c:3} {:b 2 c:0}] :b 0 } I need to update :b key based on the :c from one of these nested maps under :a and I have a filter function fn1 to select it based on :c value . is this the right way to do it? (transform [(collect :a ALL (selected? [:c ?fn1]) :b) :b] (fn [new old] new) map1)"><y>#</y><d>2017-03-24</d><h>02:58</h><w>snacks</w>hi:  If i have a nested map like this map1 <code> {:a [{:b 1 c:3} {:b 2  c:0}] :b 0 } </code>  I need to update <code>:b</code>  key based on the <code>:c</code>  from one of these nested maps under <code>:a</code> and I have a filter function fn1 to select it based on <code>:c</code> value . is this the right way to do it?
<pre>(transform [(collect :a ALL (selected? [:c ?fn1]) :b) :b] (fn [new old] new) map1)</pre></z><z id="t1490324433" t="nathanmarz the code isn&apos;t matching up with your description"><y>#</y><d>2017-03-24</d><h>03:00</h><w>nathanmarz</w>the code isn&apos;t matching up with your description</z><z id="t1490324458" t="nathanmarz the code is collecting :b values, not :c values"><y>#</y><d>2017-03-24</d><h>03:00</h><w>nathanmarz</w>the code is collecting <code>:b</code> values, not <code>:c</code> values</z><z id="t1490324519" t="nathanmarz you&apos;re also collecting a sequence of values, not &quot;one of&quot; the values"><y>#</y><d>2017-03-24</d><h>03:01</h><w>nathanmarz</w>you&apos;re also collecting a sequence of values, not &quot;one of&quot; the values</z><z id="t1490324771" t="snacks yes it is collecting :b value, but using :c values to select which map to collect :b values from. so if fn1 is ??even it will return [1] while ?odd will return [2]."><y>#</y><d>2017-03-24</d><h>03:06</h><w>snacks</w>yes it is collecting <code>:b</code> value, but using  <code>:c</code> values to select which map to collect <code>:b</code> values from. so if fn1 is <code>??even</code> it will return [1] while <code>?odd</code> will return [2].</z><z id="t1490324918" t="nathanmarz I think you have that reversed"><y>#</y><d>2017-03-24</d><h>03:08</h><w>nathanmarz</w>I think you have that reversed</z><z id="t1490324932" t="nathanmarz if fn1 is odd? it will collect [1]"><y>#</y><d>2017-03-24</d><h>03:08</h><w>nathanmarz</w>if fn1 is <code>odd?</code> it will collect <code>[1]</code></z><z id="t1490324970" t="nathanmarz but yea, the code looks correct as long as you&apos;re looking to set :b in the top-level map to a sequence"><y>#</y><d>2017-03-24</d><h>03:09</h><w>nathanmarz</w>but yea, the code looks correct as long as you&apos;re looking to set <code>:b</code> in the top-level map to a sequence</z><z id="t1490324986" t="nathanmarz also you don&apos;t need the [...] in selected?"><y>#</y><d>2017-03-24</d><h>03:09</h><w>nathanmarz</w>also you don&apos;t need the <code>[...]</code> in <code>selected?</code></z><z id="t1490324996" t="nathanmarz (selected? :c fn1)"><y>#</y><d>2017-03-24</d><h>03:09</h><w>nathanmarz</w><code>(selected? :c fn1)</code></z><z id="t1490325001" t="snacks ok thanks"><y>#</y><d>2017-03-24</d><h>03:10</h><w>snacks</w>ok thanks</z><z id="t1490325011" t="snacks you can use setval with collect?"><y>#</y><d>2017-03-24</d><h>03:10</h><w>snacks</w>you can use setval with collect?</z><z id="t1490325018" t="nathanmarz no"><y>#</y><d>2017-03-24</d><h>03:10</h><w>nathanmarz</w>no</z><z id="t1490325023" t="snacks ok"><y>#</y><d>2017-03-24</d><h>03:10</h><w>snacks</w>ok</z><z id="t1490325054" t="nathanmarz I mean, it will execute but collected values will be ignored"><y>#</y><d>2017-03-24</d><h>03:10</h><w>nathanmarz</w>I mean, it will execute but collected values will be ignored</z><z id="t1490360861" t="borkdude How do I prune a map in specter? select only selects the values, but I want something like a recursive select-keys . I can’t find a good example of this on the wiki"><y>#</y><d>2017-03-24</d><h>13:07</h><w>borkdude</w>How do I prune a map in specter? select only selects the values, but I want something like a recursive <code>select-keys</code>. I can’t find a good example of this on the wiki</z><z id="t1490361558" t="nathanmarz @borkdude you can do something like this: (def data {:a {:a 1 :b 2 :c 3} :b {:a 1 :b 2 :c 3 :d 4} :c {:a 1}}) (def ALL-MAPS (recursive-path [] p (if-path map? (stay-then-continue MAP-VALS p) ))) (transform ALL-MAPS #(select-keys % [:a :b]) data) ;; =&gt; {:a {:a 1, :b 2}, :b {:a 1, :b 2}} "><y>#</y><d>2017-03-24</d><h>13:19</h><w>nathanmarz</w>@borkdude you can do something like this:
<pre>(def data {:a {:a 1 :b 2 :c 3} :b {:a 1 :b 2 :c 3 :d 4} :c {:a 1}})

(def ALL-MAPS
  (recursive-path [] p
    (if-path map?
      (stay-then-continue
        MAP-VALS p)
      )))

(transform ALL-MAPS #(select-keys % [:a :b]) data)
;; =&gt; {:a {:a 1, :b 2}, :b {:a 1, :b 2}}
</pre></z><z id="t1490361757" t="borkdude Thanks"><y>#</y><d>2017-03-24</d><h>13:22</h><w>borkdude</w>Thanks</z><z id="t1491236723" t="tothda Hi All, I&apos;m using specter 1.0.0 and trying this example from the readme: (setval [:a ALL nil?] NONE {:a [1 2 nil 3 nil]}) what I get is this: {:a [1 2 :com.rpl.specter.impl/NONE 3 :com.rpl.specter.impl/NONE]} instead of {:a [1 2 3]} Clojure version: 1.9.0-alpha14."><y>#</y><d>2017-04-03</d><h>16:25</h><w>tothda</w>Hi All, I&apos;m using specter 1.0.0 and trying this example from the readme: 
<code>(setval [:a ALL nil?] NONE {:a [1 2 nil 3 nil]})</code> 
what I get is this: 
<code>{:a [1 2 :com.rpl.specter.impl/NONE 3 :com.rpl.specter.impl/NONE]}</code> 
instead of
<code>{:a [1 2 3]}</code>
Clojure version: 1.9.0-alpha14.</z><z id="t1491237833" t="nathanmarz @tothda that definitely works with 1.0.0"><y>#</y><d>2017-04-03</d><h>16:43</h><w>nathanmarz</w>@tothda that definitely works with 1.0.0</z><z id="t1491237842" t="nathanmarz if you&apos;re using lein what&apos;s the output of lein deps :tree ?"><y>#</y><d>2017-04-03</d><h>16:44</h><w>nathanmarz</w>if you&apos;re using lein what&apos;s the output of <code>lein deps :tree</code>?</z><z id="t1491239270" t="tothda Ohh, I&apos;m sorry, it works. I started the REPL on a branch where specter version was 0.13.2 and then switched to an other branch with specter 1.0.0"><y>#</y><d>2017-04-03</d><h>17:07</h><w>tothda</w>Ohh, I&apos;m sorry, it works. I started the REPL on a branch where specter version was 0.13.2 and then switched to an other branch with specter 1.0.0</z><z id="t1491239343" t="tothda After restarting the REPL with 1.0.0 it works obviously 😳"><y>#</y><d>2017-04-03</d><h>17:09</h><w>tothda</w>After restarting the REPL with 1.0.0 it works obviously <b>😳</b></z><z id="t1491240959" t="nathanmarz cool"><y>#</y><d>2017-04-03</d><h>17:35</h><w>nathanmarz</w>cool</z><z id="t1491586121" t="souenzzo recursive-path shoud be used directly on &quot;path&quot;? ex: (transform [(walker ,,,) (recursive-path ,,,,) ,,,,] foo bar)"><y>#</y><d>2017-04-07</d><h>17:28</h><w>souenzzo</w><code>recursive-path</code> shoud be used directly on &quot;path&quot;?
ex: <code>(transform [(walker ,,,) (recursive-path ,,,,) ,,,,] foo bar)</code></z><z id="t1491589939" t="nathanmarz @souenzzo yes that should work fine"><y>#</y><d>2017-04-07</d><h>18:32</h><w>nathanmarz</w>@souenzzo yes that should work fine</z><z id="t1491589960" t="nathanmarz or you can use it to declare a top-level path or bind a symbol in let"><y>#</y><d>2017-04-07</d><h>18:32</h><w>nathanmarz</w>or you can use it to declare a top-level path or bind a symbol in <code>let</code></z><z id="t1491590235" t="souenzzo I usually declare at top-level. but in this case it contains a lot of parameters and (probably) will not be reuse. I was unsure whether using in-line would lose optimization"><y>#</y><d>2017-04-07</d><h>18:37</h><w>souenzzo</w>I usually declare at top-level. but in this case it contains a lot of parameters and (probably) will not be reuse.
I was unsure whether using in-line would lose optimization</z><z id="t1491590431" t="nathanmarz nope"><y>#</y><d>2017-04-07</d><h>18:40</h><w>nathanmarz</w>nope</z><z id="t1491590449" t="nathanmarz you can see the produced code by wrapping it in with-inline-debug the first time the callsite is executed"><y>#</y><d>2017-04-07</d><h>18:40</h><w>nathanmarz</w>you can see the produced code by wrapping it in <code>with-inline-debug</code> the first time the callsite is executed</z><z id="t1491838032" t="deplect I have a question, supose I want to delete all keys-values pairs in the :exposure map with spectre. How would I go about?"><y>#</y><d>2017-04-10</d><h>15:27</h><w>deplect</w>I have a question, supose I want to delete all keys-values pairs in the :exposure map with spectre. How would I go about?</z><z id="t1491838034" t="deplect {:mdc-artificial/random {5 {:exposure {1000 {[1.0 2.0] 200.0}}} 10 {:exposure {2000 {[1.0 2.0] 400.0}}}}}"><y>#</y><d>2017-04-10</d><h>15:27</h><w>deplect</w>{:mdc-artificial/random {5 {:exposure {1000 {[1.0 2.0] 200.0}}}
                                   10 {:exposure {2000 {[1.0 2.0] 400.0}}}}}</z><z id="t1491838085" t="deplect where all key-values i want to delete must be smaller than 1500 🙂"><y>#</y><d>2017-04-10</d><h>15:28</h><w>deplect</w>where all key-values i want to delete must be smaller than 1500 <b>🙂</b></z><z id="t1491841833" t="nathanmarz @deplect you mean empty all exposure maps where the sum of the numbers within is &lt; 1500?"><y>#</y><d>2017-04-10</d><h>16:30</h><w>nathanmarz</w>@deplect you mean empty all exposure maps where the sum of the numbers within is &lt; 1500?</z><z id="t1491841840" t="nathanmarz that would just be: (transform [:mdc-artificial/random MAP-VALS :exposure (selected? (traversed (walker number?) +) #(&lt; % 1500))] empty data) "><y>#</y><d>2017-04-10</d><h>16:30</h><w>nathanmarz</w>that would just be:
<pre>(transform [:mdc-artificial/random MAP-VALS
            :exposure
            (selected? (traversed (walker number?) +) #(&lt; % 1500))]
  empty
  data)
</pre></z><z id="t1491841862" t="deplect hai Nathan, no I already figured it out …"><y>#</y><d>2017-04-10</d><h>16:31</h><w>deplect</w>hai Nathan, no I already figured it out …</z><z id="t1491841885" t="deplect i want exactly the 1000 key in the exposure map to be gone."><y>#</y><d>2017-04-10</d><h>16:31</h><w>deplect</w>i want exactly the 1000 key in the exposure map to be gone.</z><z id="t1491841913" t="deplect came down to: (sp/transform [MAP-VALS MAP-VALS MAP-VALS] #(remove-keys (partial &gt; expire-time) %) registry)"><y>#</y><d>2017-04-10</d><h>16:31</h><w>deplect</w>came down to: (sp/transform [MAP-VALS MAP-VALS MAP-VALS] #(remove-keys (partial &gt; expire-time) %) registry)</z><z id="t1491842313" t="nathanmarz in that case I think you want something more along the lines of: (setval [:mdc-artificial/random MAP-VALS :exposure MAP-KEYS #(&lt; % 1500)] NONE data) "><y>#</y><d>2017-04-10</d><h>16:38</h><w>nathanmarz</w>in that case I think you want something more along the lines of:
<pre>(setval [:mdc-artificial/random
            MAP-VALS
            :exposure
            MAP-KEYS
            #(&lt; % 1500)]
  NONE
  data)
</pre></z><z id="t1491842371" t="deplect yes buy :mdc-artificial/random can be any value. :exposure will always be called exporsure"><y>#</y><d>2017-04-10</d><h>16:39</h><w>deplect</w>yes buy :mdc-artificial/random can be any value. :exposure will always be called exporsure</z><z id="t1491842405" t="nathanmarz ah"><y>#</y><d>2017-04-10</d><h>16:40</h><w>nathanmarz</w>ah</z><z id="t1491842408" t="nathanmarz easy to modify to handle that"><y>#</y><d>2017-04-10</d><h>16:40</h><w>nathanmarz</w>easy to modify to handle that</z><z id="t1491842584" t="deplect yes works like a charm, the transform version fails under certain circumstances, thx!"><y>#</y><d>2017-04-10</d><h>16:43</h><w>deplect</w>yes works like a charm, the transform version fails under certain circumstances, thx!</z><z id="t1492007252" t="snacks hi Nathan i have a question"><y>#</y><d>2017-04-12</d><h>14:27</h><w>snacks</w>hi Nathan i have a question</z><z id="t1492007260" t="snacks Is there anyway I can use selected? with a selector takes multiple values. for example def data [{:a 1 :b 1 :c 1} {:a 2 :b 1 :c 1}]"><y>#</y><d>2017-04-12</d><h>14:27</h><w>snacks</w>Is there anyway I can use selected? with a selector takes multiple values. for example <code>def data [{:a 1 :b 1 :c 1} {:a 2 :b 1 :c 1}]</code></z><z id="t1492007275" t="snacks I only want to select sub maps where :a = :b"><y>#</y><d>2017-04-12</d><h>14:27</h><w>snacks</w>I only want to select sub maps where <code>:a</code> = <code>:b</code></z><z id="t1492007585" t="nathanmarz @snacks for that I would just use an anonymous function"><y>#</y><d>2017-04-12</d><h>14:33</h><w>nathanmarz</w>@snacks for that I would just use an anonymous function</z><z id="t1492007593" t="nathanmarz #(= (:a %) (:b %))"><y>#</y><d>2017-04-12</d><h>14:33</h><w>nathanmarz</w><code>#(= (:a %) (:b %))</code></z><z id="t1492007762" t="nathanmarz (def data [{:a 1 :b 1 :c &quot;biubiu&quot;} {:a 1 :b 2 :c 3}]) (select [ALL #(= (:a %) (:b %)) :c] data) ;; =&gt; [&quot;biubiu&quot;] "><y>#</y><d>2017-04-12</d><h>14:36</h><w>nathanmarz</w><pre>(def data [{:a 1 :b 1 :c &quot;biubiu&quot;} {:a 1 :b 2 :c 3}])
(select [ALL #(= (:a %) (:b %)) :c] data)
;; =&gt; [&quot;biubiu&quot;]
</pre></z><z id="t1492008035" t="snacks thanks!"><y>#</y><d>2017-04-12</d><h>14:40</h><w>snacks</w>thanks!</z><z id="t1492027501" t="snacks why is it called specter?"><y>#</y><d>2017-04-12</d><h>20:05</h><w>snacks</w>why is it called specter?</z><z id="t1492028139" t="nathanmarz @snacks from &quot;introspect&quot;"><y>#</y><d>2017-04-12</d><h>20:15</h><w>nathanmarz</w>@snacks from &quot;introspect&quot;</z><z id="t1492028199" t="nathanmarz it was also released before clojure.spec was a thing, would choose a different name if I made it today"><y>#</y><d>2017-04-12</d><h>20:16</h><w>nathanmarz</w>it was also released before clojure.spec was a thing, would choose a different name if I made it today</z><z id="t1492037543" t="souenzzo And com.rpl.specter was related with ?"><y>#</y><d>2017-04-12</d><h>22:52</h><w>souenzzo</w>And <code>com.rpl.specter</code> was related with <code></code>?</z><z id="t1492040807" t="nathanmarz @souenzzo no, my company is called Red Planet Labs"><y>#</y><d>2017-04-12</d><h>23:46</h><w>nathanmarz</w>@souenzzo no, my company is called Red Planet Labs</z><z id="t1492040820" t="nathanmarz no website yet"><y>#</y><d>2017-04-12</d><h>23:47</h><w>nathanmarz</w>no website yet</z><z id="t1492091561" t="tankthinks anyone around?"><y>#</y><d>2017-04-13</d><h>13:52</h><w>tankthinks</w>anyone around?</z><z id="t1492092357" t="nathanmarz @tankthinks yes"><y>#</y><d>2017-04-13</d><h>14:05</h><w>nathanmarz</w>@tankthinks yes</z><z id="t1492092367" t="tankthinks hey @nathanmarz!"><y>#</y><d>2017-04-13</d><h>14:06</h><w>tankthinks</w>hey @nathanmarz!</z><z id="t1492092377" t="tankthinks first and foremost … specter is awesome"><y>#</y><d>2017-04-13</d><h>14:06</h><w>tankthinks</w>first and foremost … specter is awesome</z><z id="t1492092386" t="tankthinks now that I have that out of the way"><y>#</y><d>2017-04-13</d><h>14:06</h><w>tankthinks</w>now that I have that out of the way</z><z id="t1492092423" t="nathanmarz thanks"><y>#</y><d>2017-04-13</d><h>14:07</h><w>nathanmarz</w>thanks</z><z id="t1492092430" t="tankthinks I need to transform this data structure (I’ve elided unnecessary bits for now): (def plans {:plans &apos;({:planId &quot;1&quot; :disbursements ({:history ({:amount &quot;1&quot; :disbursementDate &quot;2017-01-01&quot;} {:amount &quot;1&quot; :disbursementDate &quot;2017-01-01&quot;} {:amount &quot;2&quot; :disbursementDate &quot;2017-02-01&quot;} {:amount &quot;3&quot; :disbursementDate &quot;2017-03-01&quot;})})})}) "><y>#</y><d>2017-04-13</d><h>14:07</h><w>tankthinks</w>I need to transform this data structure (I’ve elided unnecessary bits for now):
<pre>(def plans
  {:plans &apos;({:planId &quot;1&quot;
             :disbursements ({:history ({:amount &quot;1&quot; :disbursementDate &quot;2017-01-01&quot;}
                                        {:amount &quot;1&quot; :disbursementDate &quot;2017-01-01&quot;}
                                        {:amount &quot;2&quot; :disbursementDate &quot;2017-02-01&quot;}
                                        {:amount &quot;3&quot; :disbursementDate &quot;2017-03-01&quot;})})})})
</pre></z><z id="t1492092459" t="tankthinks by removing duplicate entries from the :history list"><y>#</y><d>2017-04-13</d><h>14:07</h><w>tankthinks</w>by removing duplicate entries from the <code>:history</code> list</z><z id="t1492092472" t="tankthinks this basically does what I want: (transform [:plans ALL #(= &quot;1&quot; (:planId %)) :disbursements ALL :history] dedupe plans) "><y>#</y><d>2017-04-13</d><h>14:07</h><w>tankthinks</w>this basically does what I want:
<pre>(transform [:plans ALL #(= &quot;1&quot; (:planId %)) :disbursements ALL :history]
  dedupe
  plans)
</pre></z><z id="t1492092510" t="tankthinks but what if I want a predicate to ensure that I’m only dedupe ing entries from January, i.e. “2017-01-01”"><y>#</y><d>2017-04-13</d><h>14:08</h><w>tankthinks</w>but what if I want a predicate to ensure that I’m only <code>dedupe</code>ing entries from January, i.e. “2017-01-01”</z><z id="t1492092552" t="nathanmarz hmm"><y>#</y><d>2017-04-13</d><h>14:09</h><w>nathanmarz</w>hmm</z><z id="t1492092566" t="nathanmarz gonna have to do it manually for now in your transform fn"><y>#</y><d>2017-04-13</d><h>14:09</h><w>nathanmarz</w>gonna have to do it manually for now in your transform fn</z><z id="t1492092586" t="nathanmarz it&apos;s possible subselect could be extended to support that"><y>#</y><d>2017-04-13</d><h>14:09</h><w>nathanmarz</w>it&apos;s possible <code>subselect</code> could be extended to support that</z><z id="t1492092628" t="nathanmarz so you could do: (transform [:plans ALL #(= &quot;1&quot; (:planId %)) :disbursements ALL :history (filterer :disbursementDate #(= % “2017-01-01”))] dedupe plans) "><y>#</y><d>2017-04-13</d><h>14:10</h><w>nathanmarz</w>so you could do:
<pre>(transform [:plans ALL #(= &quot;1&quot; (:planId %)) :disbursements ALL :history (filterer :disbursementDate #(= % “2017-01-01”))]
  dedupe
  plans)
</pre></z><z id="t1492092652" t="nathanmarz right now subselect /`filterer` require the output sequence to be the same size as the input"><y>#</y><d>2017-04-13</d><h>14:10</h><w>nathanmarz</w>right now <code>subselect</code>/`filterer` require the output sequence to be the same size as the input</z><z id="t1492092701" t="nathanmarz the logic change would be to fill in removed entires with NONE to trigger removal"><y>#</y><d>2017-04-13</d><h>14:11</h><w>nathanmarz</w>the logic change would be to fill in removed entires with <code>NONE</code> to trigger removal</z><z id="t1492092726" t="nathanmarz that would be a good issue to open on github"><y>#</y><d>2017-04-13</d><h>14:12</h><w>nathanmarz</w>that would be a good issue to open on github</z><z id="t1492092914" t="tankthinks ah … cool"><y>#</y><d>2017-04-13</d><h>14:15</h><w>tankthinks</w>ah … cool</z><z id="t1492092981" t="tankthinks Thank you for the quick response … I’ll play around a bit to make sure I completely understand, then I’ll submit an issue"><y>#</y><d>2017-04-13</d><h>14:16</h><w>tankthinks</w>Thank you for the quick response … I’ll play around a bit to make sure I completely understand, then I’ll submit an issue</z><z id="t1492092989" t="nathanmarz actually it&apos;s fine"><y>#</y><d>2017-04-13</d><h>14:16</h><w>nathanmarz</w>actually it&apos;s fine</z><z id="t1492092993" t="nathanmarz I was curious so I just implemented it"><y>#</y><d>2017-04-13</d><h>14:16</h><w>nathanmarz</w>I was curious so I just implemented it</z><z id="t1492093001" t="tankthinks haha"><y>#</y><d>2017-04-13</d><h>14:16</h><w>tankthinks</w>haha</z><z id="t1492093245" t="nathanmarz @tankthinks https://github.com/nathanmarz/specter/commit/be30e46960c879d6177d8ab8c2d3f4450bab0095"><y>#</y><d>2017-04-13</d><h>14:20</h><w>nathanmarz</w>@tankthinks <a href="https://github.com/nathanmarz/specter/commit/be30e46960c879d6177d8ab8c2d3f4450bab0095" target="_blank">https://github.com/nathanmarz/specter/commit/be30e46960c879d6177d8ab8c2d3f4450bab0095</a></z><z id="t1492093317" t="nathanmarz quite elegant I think"><y>#</y><d>2017-04-13</d><h>14:21</h><w>nathanmarz</w>quite elegant I think</z><z id="t1492093333" t="tankthinks so … uh … you’re welcome?"><y>#</y><d>2017-04-13</d><h>14:22</h><w>tankthinks</w>so … uh … you’re welcome?</z><z id="t1492093349" t="tankthinks 😃"><y>#</y><d>2017-04-13</d><h>14:22</h><w>tankthinks</w><b>😃</b></z><z id="t1492093350" t="nathanmarz 😉"><y>#</y><d>2017-04-13</d><h>14:22</h><w>nathanmarz</w><b>😉</b></z><z id="t1492094781" t="tankthinks thanks again @nathanmarz, not sure how I would have done that without specter … cheers!"><y>#</y><d>2017-04-13</d><h>14:46</h><w>tankthinks</w>thanks again @nathanmarz, not sure how I would have done that without specter … cheers!</z><z id="t1492460622" t="nathanmarz Released Specter 1.0.1 (bug fixes and minor enhancements) https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><y>#</y><d>2017-04-17</d><h>20:23</h><w>nathanmarz</w>Released Specter 1.0.1 (bug fixes and minor enhancements) <a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md" target="_blank">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></z><z id="t1492533510" t="mbjarland Hi Nathan. I&apos;m new to specter but this seems indeed like the bees knees"><y>#</y><d>2017-04-18</d><h>16:38</h><w>mbjarland</w>Hi Nathan. I&apos;m new to specter but this seems indeed like the bees knees</z><z id="t1492533572" t="mbjarland I have a question, a while back I posted the following s.o. question: https://stackoverflow.com/questions/42551765/idiomatic-and-concise-way-of-working-with-nested-map-vector-structures-in-clojur and I have been playing for the past few hours with using spectre for this nested traversal problem. In essense I have some json data (maps and vectors) and I need to traverse to a certain depth, do a few operations, remember context, traverse a few more levels down, do a few operations etc"><y>#</y><d>2017-04-18</d><h>16:39</h><w>mbjarland</w>I have a question, a while back I posted the following s.o. question: 
<a href="https://stackoverflow.com/questions/42551765/idiomatic-and-concise-way-of-working-with-nested-map-vector-structures-in-clojur" target="_blank">https://stackoverflow.com/questions/42551765/idiomatic-and-concise-way-of-working-with-nested-map-vector-structures-in-clojur</a>
and I have been playing for the past few hours with using spectre for this nested traversal problem. In essense I have some json data (maps and vectors) and I need to traverse to a certain depth, do a few operations, remember context, traverse a few more levels down, do a few operations etc</z><z id="t1492533728" t="mbjarland I am not really interested in changing the traverse structure. I assume I should be using collectors then?"><y>#</y><d>2017-04-18</d><h>16:42</h><w>mbjarland</w>I am not really interested in changing the traverse structure. I assume I should be using collectors then?</z><z id="t1492533841" t="nathanmarz @mbjarland so to clarify, you&apos;re not transforming the nested structure, you just want to perform some operations using values inside?"><y>#</y><d>2017-04-18</d><h>16:44</h><w>nathanmarz</w>@mbjarland so to clarify, you&apos;re not transforming the nested structure, you just want to perform some operations using values inside?</z><z id="t1492533863" t="mbjarland this is the groovy equivalent of what I want to do: json.issues.each { issue -&gt; issue.changelog.histories.each { history -&gt; def date = DateTime.parse(history.created) if (date &lt; fromDate || date &gt; toDate) return def timeItems = history.items.findAll { it.field == &apos;timespent&apos; } if (!timeItems) return def consultant = history.author.displayName timeItems.each { item -&gt; def from = (item.from ?: 0) as Integer def to = ( ?: 0) as Integer timesheets[consultant].entries &lt;&lt; new TimeEntry(date: date, issueKey: issue.key, secondsSpent: to - from) } } } "><y>#</y><d>2017-04-18</d><h>16:44</h><w>mbjarland</w>this is the groovy equivalent of what I want to do: 
<pre>json.issues.each { issue -&gt;
  issue.changelog.histories.each { history -&gt;
    def date = DateTime.parse(history.created)
    if (date &lt; fromDate || date &gt; toDate) return

    def timeItems = history.items.findAll { it.field == &apos;timespent&apos; }
    if (!timeItems) return

    def consultant = history.author.displayName
    timeItems.each { item -&gt;
      def from = (item.from ?: 0) as Integer
      def to   = (   ?: 0) as Integer

      timesheets[consultant].entries &lt;&lt; new TimeEntry(date: date, issueKey: issue.key, secondsSpent: to - from)
    }
  }
}
</pre></z><z id="t1492533893" t="mbjarland and generate some resulting data structure (map)"><y>#</y><d>2017-04-18</d><h>16:44</h><w>mbjarland</w>and generate some resulting data  structure (map)</z><z id="t1492533925" t="mbjarland it seems that the path traversals above json.issues.each , issue.changelog.histories.each , etc are a perfect match for specter"><y>#</y><d>2017-04-18</d><h>16:45</h><w>mbjarland</w>it seems that the path traversals above <code>json.issues.each</code>, <code>issue.changelog.histories.each</code>, etc are a perfect match for specter</z><z id="t1492533929" t="nathanmarz it sounds like you want to do a traverse to get to the values you care about in the order you want"><y>#</y><d>2017-04-18</d><h>16:45</h><w>nathanmarz</w>it sounds like you want to do a <code>traverse</code> to get to the values you care about in the order you want</z><z id="t1492533942" t="nathanmarz and then reduce over that to generate your result"><y>#</y><d>2017-04-18</d><h>16:45</h><w>nathanmarz</w>and then <code>reduce</code> over that to generate your result</z><z id="t1492534020" t="mbjarland and multiple nested traverses to get hold of the different levels (issue, history, item) above?"><y>#</y><d>2017-04-18</d><h>16:47</h><w>mbjarland</w>and multiple nested traverses to get hold of the different levels (issue, history, item) above?</z><z id="t1492534115" t="nathanmarz use collect / collect-one"><y>#</y><d>2017-04-18</d><h>16:48</h><w>nathanmarz</w>use <code>collect</code> / <code>collect-one</code></z><z id="t1492534218" t="nathanmarz a simplified example: (reduce conj [] (traverse [ALL (collect-one :name) :age] [{:name &quot;Bob&quot; :age 21} {:name &quot;Alice&quot; :age 20}])) "><y>#</y><d>2017-04-18</d><h>16:50</h><w>nathanmarz</w>a simplified example:
<pre>(reduce conj [] (traverse [ALL (collect-one :name) :age] [{:name &quot;Bob&quot; :age 21} {:name &quot;Alice&quot; :age 20}]))
</pre></z><z id="t1492534343" t="mbjarland ok, that&apos;s probably enough to nudge me in the right direction"><y>#</y><d>2017-04-18</d><h>16:52</h><w>mbjarland</w>ok, that&apos;s probably enough to nudge me in the right direction</z><z id="t1492534390" t="mbjarland thank you! ...and clojure still makes me feel like an idiot at least once a day"><y>#</y><d>2017-04-18</d><h>16:53</h><w>mbjarland</w>thank you! ...and clojure still makes me feel like an idiot at least once a day</z><z id="t1492534449" t="mbjarland I&apos;ve been trying various methods of getting the groovy code above expressive and terse in clojure, I think specter might be the answer"><y>#</y><d>2017-04-18</d><h>16:54</h><w>mbjarland</w>I&apos;ve been trying various methods of getting the groovy code above expressive and terse in clojure, I think specter might be the answer</z><z id="t1492534515" t="nathanmarz your path would look something like: [:issues ALL :changelog :histories ALL (selected? :date #(&gt; % fromDate) #(&lt; % toDate)) (collect-one :author :displayName) :items ALL #(= (:field %) &quot;timespent&quot;) (collect-one :from (nil-&gt;val 0)) :to (nil-&gt;val 0)]"><y>#</y><d>2017-04-18</d><h>16:55</h><w>nathanmarz</w>your path would look something like: <code>[:issues ALL :changelog :histories ALL (selected? :date #(&gt; % fromDate) #(&lt; % toDate)) (collect-one :author :displayName) :items ALL #(= (:field %) &quot;timespent&quot;) (collect-one :from (nil-&gt;val 0)) :to (nil-&gt;val 0)]</code></z><z id="t1492534549" t="mbjarland : )"><y>#</y><d>2017-04-18</d><h>16:55</h><w>mbjarland</w>: )</z><z id="t1492534565" t="nathanmarz or something like that"><y>#</y><d>2017-04-18</d><h>16:56</h><w>nathanmarz</w>or something like that</z><z id="t1492534626" t="mbjarland this is by the way the json returned from a jira instance and we use the results for invoicing so it is an actual real world example"><y>#</y><d>2017-04-18</d><h>16:57</h><w>mbjarland</w>this is by the way the json returned from a jira instance and we use the results for invoicing so it is an actual real world example</z><z id="t1492534641" t="mbjarland thank you, that helps a ton"><y>#</y><d>2017-04-18</d><h>16:57</h><w>mbjarland</w>thank you, that helps a ton</z><z id="t1492534652" t="nathanmarz cool"><y>#</y><d>2017-04-18</d><h>16:57</h><w>nathanmarz</w>cool</z><z id="t1492534653" t="nathanmarz no problem"><y>#</y><d>2017-04-18</d><h>16:57</h><w>nathanmarz</w>no problem</z><z id="t1492534707" t="mbjarland one more question, in your path the date comparison assumes the date is parsed"><y>#</y><d>2017-04-18</d><h>16:58</h><w>mbjarland</w>one more question, in your path the date comparison assumes the date is parsed</z><z id="t1492534723" t="mbjarland what if I need to do some computation at an intermediate level like parsing the date ?"><y>#</y><d>2017-04-18</d><h>16:58</h><w>mbjarland</w>what if I need to do some computation at an intermediate level like parsing the date ?</z><z id="t1492534749" t="mbjarland just an inline function in the path expression?"><y>#</y><d>2017-04-18</d><h>16:59</h><w>mbjarland</w>just an inline function in the path expression?</z><z id="t1492534951" t="mbjarland a privilege to be able to get answers directly from the author and I have to say I&apos;m impressed with the clojure community experience so far. Thanks again!"><y>#</y><d>2017-04-18</d><h>17:02</h><w>mbjarland</w>a privilege to be able to get answers directly from the author and I have to say I&apos;m impressed with the clojure community experience so far. Thanks again!</z><z id="t1492535347" t="mbjarland : ) and the more I look at the above path expression....this is beautiful!"><y>#</y><d>2017-04-18</d><h>17:09</h><w>mbjarland</w>: ) and the more I look at the above path expression....this is beautiful!</z><z id="t1492536856" t="nathanmarz @mbjarland you can insert (view parse-date) to parse before comparing"><y>#</y><d>2017-04-18</d><h>17:34</h><w>nathanmarz</w>@mbjarland you can insert <code>(view parse-date)</code> to parse before comparing</z><z id="t1492536897" t="nathanmarz a function directly in a path is interpreted as a filter"><y>#</y><d>2017-04-18</d><h>17:34</h><w>nathanmarz</w>a function directly in a path is interpreted as a filter</z><z id="t1492549435" t="mbjarland ok got a last one, for context I have the following function: (defn disect-json [json from-date to-date] (let [path [:issues ALL (collect-one :key) :changelog :histories ALL #(history-in-date-range? % from-date to-date) (selected? [:items ALL #(= (:field %) &quot;timespent&quot;)]) (collect-one (view #(parse-history-date %))) (collect-one [:author :displayName]) :items ALL (collect-one :from (nil-&gt;val &quot;0&quot;) (view #(read-string %))) (collect-one :to (nil-&gt;val &quot;0&quot;) (view #(read-string %)))]] (group-by #(nth % 2) (reduce conj [] (traverse path json))))) looking at the path expression, how do I terminate the path without selecting the currently navigated node and only keeping the collect-one values?"><y>#</y><d>2017-04-18</d><h>21:03</h><w>mbjarland</w>ok got a last one, for context I have the following function: 
<pre>(defn disect-json [json from-date to-date]
  (let [path [:issues ALL
              (collect-one :key)
              :changelog :histories ALL
              #(history-in-date-range? % from-date to-date)
              (selected? [:items ALL #(= (:field %) &quot;timespent&quot;)])
              (collect-one (view #(parse-history-date %)))
              (collect-one [:author :displayName])
              :items ALL
              (collect-one :from (nil-&gt;val &quot;0&quot;) (view #(read-string %)))
              (collect-one :to (nil-&gt;val &quot;0&quot;) (view #(read-string %)))]]
        (group-by #(nth % 2)
          (reduce conj [] (traverse path json)))))
</pre>
looking at the path expression, how do I terminate the path without selecting the currently navigated node and only keeping the <code>collect-one</code> values?</z><z id="t1492549689" t="mbjarland oh and the above works, so I’m happy as a clam after looking for months for a clean solution for this in clojure."><y>#</y><d>2017-04-18</d><h>21:08</h><w>mbjarland</w>oh and the above works, so I’m happy as a clam after looking for months for a clean solution for this in clojure.</z><z id="t1492551414" t="nathanmarz @mbjarland instead of collecting the last element, just navigate to it"><y>#</y><d>2017-04-18</d><h>21:36</h><w>nathanmarz</w>@mbjarland instead of collecting the last element, just navigate to it</z><z id="t1492551435" t="nathanmarz terminate the path with :to (nil-&gt;val &quot;0&quot;) (view #(read-string %))) and drop the collect-one"><y>#</y><d>2017-04-18</d><h>21:37</h><w>nathanmarz</w>terminate the path with <code>:to (nil-&gt;val &quot;0&quot;) (view #(read-string %)))</code> and drop the <code>collect-one</code></z><z id="t1492551491" t="nathanmarz also you can do (view parse-history-date) to make it cleaner, same with usage of read-string"><y>#</y><d>2017-04-18</d><h>21:38</h><w>nathanmarz</w>also you can do <code>(view parse-history-date)</code> to make it cleaner, same with usage of <code>read-string</code></z><z id="t1492551541" t="nathanmarz also if you just want a vector of results back, just do select instead of (reduce ... (traverse ...))"><y>#</y><d>2017-04-18</d><h>21:39</h><w>nathanmarz</w>also if you just want a vector of results back, just do <code>select</code> instead of <code>(reduce ... (traverse ...))</code></z><z id="t1492551567" t="nathanmarz finally, you should specify the path inline with the select call so it can be properly optimized"><y>#</y><d>2017-04-18</d><h>21:39</h><w>nathanmarz</w>finally, you should specify the path inline with the <code>select</code> call so it can be properly optimized</z><z id="t1492551610" t="nathanmarz or define the path local using specter&apos;s path macro"><y>#</y><d>2017-04-18</d><h>21:40</h><w>nathanmarz</w>or define the <code>path</code> local using specter&apos;s <code>path</code> macro</z><z id="t1492551625" t="nathanmarz (let [json-path (path :issues ALL ...) ..."><y>#</y><d>2017-04-18</d><h>21:40</h><w>nathanmarz</w><code>(let [json-path (path :issues ALL ...) ...</code></z><z id="t1492562911" t="albaker is there a way to walk any arbitrary map/vector/map nested structure?"><y>#</y><d>2017-04-19</d><h>00:48</h><w>albaker</w>is there a way to walk any arbitrary map/vector/map nested structure?</z><z id="t1492563184" t="albaker trying to get success generations of something like {:a &quot;blah&quot; :b :undefined} -&gt; {:a blah :b [{:a &quot;blah :b :undefined}] }"><y>#</y><d>2017-04-19</d><h>00:53</h><w>albaker</w>trying to get success generations of something like <code>{:a &quot;blah&quot; :b :undefined}</code> -&gt; <code>{:a blah :b [{:a &quot;blah :b :undefined}] }</code></z><z id="t1492570463" t="nathanmarz @albaker yes, walker does that"><y>#</y><d>2017-04-19</d><h>02:54</h><w>nathanmarz</w>@albaker yes, walker does that</z><z id="t1492570488" t="nathanmarz or you can define a more precise navigator using recursive-path"><y>#</y><d>2017-04-19</d><h>02:54</h><w>nathanmarz</w>or you can define a more precise navigator using <code>recursive-path</code></z><z id="t1492570508" t="nathanmarz not sure what you&apos;re going for with that transformation, need more examples or explanation"><y>#</y><d>2017-04-19</d><h>02:55</h><w>nathanmarz</w>not sure what you&apos;re going for with that transformation, need more examples or explanation</z><z id="t1492576828" t="mbjarland @nathanmarz thank you. Got the select part right while tinkering last night, should have seen the view function pattern, guidance much appreciated."><y>#</y><d>2017-04-19</d><h>04:40</h><w>mbjarland</w>@nathanmarz thank you. Got the select part right while tinkering last night, should have seen the view function pattern, guidance much appreciated.</z><z id="t1492593148" t="mbjarland @nathanmarz is there any way to refer back to a collect-one :ed value in a filter expression later in the path?"><y>#</y><d>2017-04-19</d><h>09:12</h><w>mbjarland</w>@nathanmarz is there any way to refer back to a <code>collect-one</code>:ed value in a filter expression later in the path?</z><z id="t1492599873" t="nathanmarz @mbjarland yes, use collected?"><y>#</y><d>2017-04-19</d><h>11:04</h><w>nathanmarz</w>@mbjarland yes, use <code>collected?</code></z><z id="t1492599898" t="nathanmarz also see DISPENSE and with-fresh-collected"><y>#</y><d>2017-04-19</d><h>11:04</h><w>nathanmarz</w>also see <code>DISPENSE</code> and <code>with-fresh-collected</code></z><z id="t1492601128" t="mbjarland @nathanmarz fresh out the oven? these don&apos;t seem to be part of the online docs, will fire up a repl and take a look"><y>#</y><d>2017-04-19</d><h>11:25</h><w>mbjarland</w>@nathanmarz fresh out the oven? these don&apos;t seem to be part of the online docs, will fire up a repl and take a look</z><z id="t1492602587" t="nathanmarz @mbjarland not on the wiki but in the API docs https://nathanmarz.github.io/specter/"><y>#</y><d>2017-04-19</d><h>11:49</h><w>nathanmarz</w>@mbjarland not on the wiki but in the API docs <a href="https://nathanmarz.github.io/specter/" target="_blank">https://nathanmarz.github.io/specter/</a></z><z id="t1492610322" t="albaker @nathanmarz basically want to run something like (transform walker expander-function) that I can repeatedly call until some notion of completion"><y>#</y><d>2017-04-19</d><h>13:58</h><w>albaker</w>@nathanmarz basically want to run something like <code>(transform walker expander-function)</code> that I can repeatedly call until some notion of completion</z><z id="t1492610360" t="albaker where each transform has that {:a &quot;blah&quot; :b :undefined} -&gt; {:a blah :b [{:a &quot;blah :b :undefined}] } style replace a key in the map, or maybe nested map/vectors"><y>#</y><d>2017-04-19</d><h>13:59</h><w>albaker</w>where each transform has that <code>{:a &quot;blah&quot; :b :undefined}</code> -&gt; <code>{:a blah :b [{:a &quot;blah :b :undefined}] }</code> style replace a key in the map, or maybe nested map/vectors</z><z id="t1492610414" t="nathanmarz @albaker you can use stay-then-continue to transform something and then continue recursing into the transformed value"><y>#</y><d>2017-04-19</d><h>14:00</h><w>nathanmarz</w>@albaker you can use <code>stay-then-continue</code> to transform something and then continue recursing into the transformed value</z><z id="t1492610464" t="nathanmarz e.g. (recursive-path [] p [(walker vector?) (stay-then-continue ALL p)])"><y>#</y><d>2017-04-19</d><h>14:01</h><w>nathanmarz</w>e.g. <code>(recursive-path [] p [(walker vector?) (stay-then-continue ALL p)])</code></z><z id="t1492610502" t="albaker but that&apos;ll walk vectors or also maps/vectors of maps, with vectors of maps, etc"><y>#</y><d>2017-04-19</d><h>14:01</h><w>albaker</w>but that&apos;ll walk vectors or also maps/vectors of maps, with vectors of maps, etc</z><z id="t1492610526" t="nathanmarz that will walk all clojure data structures until it reaches a vector, then it will do the transformation and continue walking"><y>#</y><d>2017-04-19</d><h>14:02</h><w>nathanmarz</w>that will walk all clojure data structures until it reaches a vector, then it will do the transformation and continue walking</z><z id="t1492610541" t="nathanmarz if you want different behavior then you can encode that into your recursive path definition"><y>#</y><d>2017-04-19</d><h>14:02</h><w>nathanmarz</w>if you want different behavior then you can encode that into your recursive path definition</z><z id="t1492610588" t="albaker so walker wants a predicate function that returns truthy for something you want to process"><y>#</y><d>2017-04-19</d><h>14:03</h><w>albaker</w>so walker wants a predicate function that returns truthy for something you want to process</z><z id="t1492610594" t="nathanmarz yea"><y>#</y><d>2017-04-19</d><h>14:03</h><w>nathanmarz</w>yea</z><z id="t1492610600" t="albaker ok cool, I&apos;ll give that a whirl"><y>#</y><d>2017-04-19</d><h>14:03</h><w>albaker</w>ok cool, I&apos;ll give that a whirl</z><z id="t1492611189" t="mbjarland @nathanmarz if I am on a node which is a map and want to do a calculation on the values for two keys on that map, i.e. (view #(- (read-string (:to %)) (read-string (:from %)))) it seems that % does not evaluate to the current node in the above expression?"><y>#</y><d>2017-04-19</d><h>14:13</h><w>mbjarland</w>@nathanmarz if I am on a node which is a map and want to do a calculation on the values for two keys on that map, i.e.
<pre>(view #(- (read-string (:to %)) (read-string (:from %))))
</pre>
it seems that <code>%</code> does not evaluate to the current node in the above expression?</z><z id="t1492612826" t="mbjarland take that back, figured it out, my bad"><y>#</y><d>2017-04-19</d><h>14:40</h><w>mbjarland</w>take that back, figured it out, my bad</z><z id="t1492615790" t="albaker @nathanmarz so that works so well, I&apos;m stack overflowing as the descent into the tree (or madness?) goes.. in this case, making a graph query to find more children until no more children can be had. Are there any gotchas (other then don&apos;t do that) to avoid in the transform?"><y>#</y><d>2017-04-19</d><h>15:29</h><w>albaker</w>@nathanmarz so that works so well, I&apos;m stack overflowing as the descent into the tree (or madness?) goes..  in this case, making a graph query to find more children until no more children can be had.  Are there any gotchas (other then don&apos;t do that) to avoid in the transform?</z><z id="t1492615862" t="albaker I guess I could move the query into a core.async channel, so transform is just pulling from channels"><y>#</y><d>2017-04-19</d><h>15:31</h><w>albaker</w>I guess I could move the query into a core.async channel, so transform is just pulling from channels</z><z id="t1492616089" t="nathanmarz @albaker specter doesn&apos;t use any more stack than you would expect"><y>#</y><d>2017-04-19</d><h>15:34</h><w>nathanmarz</w>@albaker specter doesn&apos;t use any more stack than you would expect</z><z id="t1492616110" t="nathanmarz each level in data structure you go down during the transform will be another stack frame"><y>#</y><d>2017-04-19</d><h>15:35</h><w>nathanmarz</w>each level in data structure you go down during the transform will be another stack frame</z><z id="t1492616136" t="albaker yeah I suspect it&apos;s in the db client somewhere"><y>#</y><d>2017-04-19</d><h>15:35</h><w>albaker</w>yeah I suspect it&apos;s in the db client somewhere</z><z id="t1492616162" t="nathanmarz don&apos;t know enough about your use case to give any guidance beyond that"><y>#</y><d>2017-04-19</d><h>15:36</h><w>nathanmarz</w>don&apos;t know enough about your use case to give any guidance beyond that</z><z id="t1492616285" t="albaker I&apos;ll move the db client behind a core.async queue and leaves the transforming function only doing a quick put a thing on, get a thing back transaction and lets the db query run separately"><y>#</y><d>2017-04-19</d><h>15:38</h><w>albaker</w>I&apos;ll move the db client behind a core.async queue and leaves the transforming function only doing a quick put a thing on, get a thing back transaction and lets the db query run separately</z><z id="t1492616315" t="albaker don&apos;t feel like playing the &quot;why I hate Apache HTTP commons today&quot; game on why it&apos;s stack overflowing 😄"><y>#</y><d>2017-04-19</d><h>15:38</h><w>albaker</w>don&apos;t feel like playing the &quot;why I hate Apache HTTP commons today&quot; game on why it&apos;s stack overflowing <b>😄</b></z><z id="t1492639684" t="lvh Does anyone have any suggestions for a faster clojure.data/diff? I don’t know if anyone’s e.g. tried specter for this (or if it’d even help). I imagine zippers might, at least. I currently have two mostly-similar nested trees (flattened about 2E5 entries) and clojure.data/diff just takes a very long time"><y>#</y><d>2017-04-19</d><h>22:08</h><w>lvh</w>Does anyone have any suggestions for a faster clojure.data/diff? I don’t know if anyone’s e.g. tried specter for this (or if it’d even help). I imagine zippers might, at least. I currently have two mostly-similar nested trees (flattened about 2E5 entries) and clojure.data/diff just takes a very long time</z><z id="t1492639726" t="lvh I dunno if it matters, but the two data structures are very similar, deeply nested, and form a deep (as opposed to broad) tree"><y>#</y><d>2017-04-19</d><h>22:08</h><w>lvh</w>I dunno if it matters, but the two data structures are very similar, deeply nested, and form a deep (as opposed to broad) tree</z><z id="t1492647657" t="nathanmarz @lvh I don&apos;t think specter will be very useful for that"><y>#</y><d>2017-04-20</d><h>00:20</h><w>nathanmarz</w>@lvh I don&apos;t think specter will be very useful for that</z><z id="t1492711140" t="albaker @nathanmarz is there a recursive-path that will not recurse into the transformed value? i.e. (recursive-path [] p [(walker vector?) (stay-then-continue ALL p)]) will go for a while, but I&apos;m still finding something will stackoverflow... core.async, futures, apache client. I&apos;m thinking I need to just run transforms again and again, until it no longer transforms rather than in one big recursive blitz"><y>#</y><d>2017-04-20</d><h>17:59</h><w>albaker</w>@nathanmarz is there a recursive-path that will not recurse into the transformed value?   i.e. <code>(recursive-path [] p [(walker vector?) (stay-then-continue ALL p)])</code> will go for a while, but I&apos;m still finding something will stackoverflow... core.async, futures, apache client. I&apos;m thinking I need to just run transforms again and again, until it no longer transforms rather than in one big recursive blitz</z><z id="t1492711276" t="albaker in the stack overflow error, there&apos;s lots of repeating versions of this:"><y>#</y><d>2017-04-20</d><h>18:01</h><w>albaker</w>in the stack overflow error, there&apos;s lots of repeating versions of this:</z><z id="t1492711378" t="nathanmarz @albaker that path is defined so it will continue recursing"><y>#</y><d>2017-04-20</d><h>18:02</h><w>nathanmarz</w>@albaker that path is defined so it will continue recursing</z><z id="t1492711399" t="nathanmarz recursive-path itself doesn&apos;t do anything besides provide you the programmer the ability to have the path refer to itself"><y>#</y><d>2017-04-20</d><h>18:03</h><w>nathanmarz</w><code>recursive-path</code> itself doesn&apos;t do anything besides provide you the programmer the ability to have the path refer to itself</z><z id="t1492711416" t="nathanmarz if it&apos;s stack overflowing, then you&apos;re doing something wrong in your program"><y>#</y><d>2017-04-20</d><h>18:03</h><w>nathanmarz</w>if it&apos;s stack overflowing, then you&apos;re doing something wrong in your program</z><z id="t1492711427" t="albaker I&apos;m okay recursing, just not into the results, so I recurse down to the last known genration, apply and end"><y>#</y><d>2017-04-20</d><h>18:03</h><w>albaker</w>I&apos;m okay recursing, just not into the results, so I recurse down to the last known genration, apply and end</z><z id="t1492711443" t="nathanmarz I don&apos;t know what that means"><y>#</y><d>2017-04-20</d><h>18:04</h><w>nathanmarz</w>I don&apos;t know what that means</z><z id="t1492711461" t="nathanmarz whatever logic you want will need to be encoded in the path"><y>#</y><d>2017-04-20</d><h>18:04</h><w>nathanmarz</w>whatever logic you want will need to be encoded in the path</z><z id="t1492711484" t="nathanmarz you can use value collection to keep track of how many levels you&apos;ve recursed"><y>#</y><d>2017-04-20</d><h>18:04</h><w>nathanmarz</w>you can use value collection to keep track of how many levels you&apos;ve recursed</z><z id="t1492711515" t="nathanmarz and then check that using collected? to have the path decide whether or not to recurse"><y>#</y><d>2017-04-20</d><h>18:05</h><w>nathanmarz</w>and then check that using <code>collected?</code> to have the path decide whether or not to recurse</z><z id="t1492711541" t="nathanmarz or you can encode in your data itself information to allow the path to decide whether to recurse"><y>#</y><d>2017-04-20</d><h>18:05</h><w>nathanmarz</w>or you can encode in your data itself information to allow the path to decide whether to recurse</z><z id="t1492711543" t="nathanmarz e.g. using metadata"><y>#</y><d>2017-04-20</d><h>18:05</h><w>nathanmarz</w>e.g. using metadata</z><z id="t1492711560" t="albaker yeah, something like that - right now I&apos;m keeping a counter ref going"><y>#</y><d>2017-04-20</d><h>18:06</h><w>albaker</w>yeah, something like that - right now I&apos;m keeping a counter ref going</z><z id="t1492711620" t="nathanmarz yea, that would work too"><y>#</y><d>2017-04-20</d><h>18:07</h><w>nathanmarz</w>yea, that would work too</z><z id="t1492711641" t="nathanmarz lots of options available to control termination"><y>#</y><d>2017-04-20</d><h>18:07</h><w>nathanmarz</w>lots of options available to control termination</z><z id="t1492711673" t="albaker there is a potential for a loop, and I thought I had caught it - but perhaps not"><y>#</y><d>2017-04-20</d><h>18:07</h><w>albaker</w>there is a potential for a loop, and I thought I had caught it - but perhaps not</z><z id="t1492711687" t="albaker there a way to force the transform with recursive path to bail out?"><y>#</y><d>2017-04-20</d><h>18:08</h><w>albaker</w>there a way to force the transform with recursive path to bail out?</z><z id="t1492711709" t="nathanmarz you mean with an exception or something?"><y>#</y><d>2017-04-20</d><h>18:08</h><w>nathanmarz</w>you mean with an exception or something?</z><z id="t1492711786" t="albaker yeah, I guess just a regular exception and wrap the transform in a try/catch"><y>#</y><d>2017-04-20</d><h>18:09</h><w>albaker</w>yeah, I guess just a regular exception and wrap the transform in a try/catch</z><z id="t1492711815" t="nathanmarz I guess you could make a navigator which does that"><y>#</y><d>2017-04-20</d><h>18:10</h><w>nathanmarz</w>I guess you could make a navigator which does that</z><z id="t1492711833" t="nathanmarz try catch over invoking next-fn, and when your special exception is thrown it returns the structure unchanged"><y>#</y><d>2017-04-20</d><h>18:10</h><w>nathanmarz</w>try catch over invoking next-fn, and when your special exception is thrown it returns the structure unchanged</z><z id="t1492711867" t="albaker ok, I&apos;ll take a look at that - thanks!"><y>#</y><d>2017-04-20</d><h>18:11</h><w>albaker</w>ok, I&apos;ll take a look at that - thanks!</z><z id="t1492711909" t="nathanmarz imo that&apos;s a dirty way to solve this and you&apos;re better off more precisely specifying when you want recursion to stop"><y>#</y><d>2017-04-20</d><h>18:11</h><w>nathanmarz</w>imo that&apos;s a dirty way to solve this and you&apos;re better off more precisely specifying when you want recursion to stop</z><z id="t1492711920" t="nathanmarz it&apos;s using exceptions for flow control"><y>#</y><d>2017-04-20</d><h>18:12</h><w>nathanmarz</w>it&apos;s using exceptions for flow control</z><z id="t1492711942" t="albaker yeah"><y>#</y><d>2017-04-20</d><h>18:12</h><w>albaker</w>yeah</z><z id="t1492712236" t="albaker ah sweet, found the bug, took the exception out, and now have a near general purpose specter+stardog graph walker for recursively expanding graph data"><y>#</y><d>2017-04-20</d><h>18:17</h><w>albaker</w>ah sweet, found the bug, took the exception out, and now have a near general purpose specter+stardog graph walker for recursively expanding graph data</z><z id="t1492712561" t="albaker @nathanmarz thanks for all the help - this is really nice, with like 6 lines of specter, and a few lines of SPARQL, this thing walks and queries and walks again. I&apos;ll give a shot out in the blog that&apos;ll fall out from this"><y>#</y><d>2017-04-20</d><h>18:22</h><w>albaker</w>@nathanmarz thanks for all the help - this is really nice, with like 6 lines of specter, and a few lines of SPARQL, this thing walks and queries and walks again.  I&apos;ll give a shot out in the blog that&apos;ll fall out from this</z><z id="t1492712620" t="nathanmarz @albaker no problem, happy to help"><y>#</y><d>2017-04-20</d><h>18:23</h><w>nathanmarz</w>@albaker no problem, happy to help</z><z id="t1492712818" t="jeremyraines I have a (maybe similar?) question. Happy to post on StackOverflow if I can formulate it correctly. I think the imaginary code I want may explain best: (def TreeValues (s/recursive-path [] p (s/if-path #(not (empty? (:children %))) (s/submap [:id :name {{ set :children to [:children s/ALL p] }} ]) (s/submap [:id :name :children])))) "><y>#</y><d>2017-04-20</d><h>18:26</h><w>jeremyraines</w>I have a (maybe similar?) question.  Happy to post on StackOverflow if I can formulate it correctly.  I think the imaginary code I want may explain best:
<pre>(def TreeValues
  (s/recursive-path [] p
    (s/if-path #(not (empty? (:children %)))
      (s/submap [:id :name {{ set :children to [:children s/ALL p] }}  ])
      (s/submap [:id :name :children]))))
</pre></z><z id="t1492712898" t="jeremyraines is this possible without an inner transform ? Maybe with some use of collect that I haven’t hit on yet?"><y>#</y><d>2017-04-20</d><h>18:28</h><w>jeremyraines</w>is this possible without an inner <code>transform</code>?  Maybe with some use of <code>collect</code> that I haven’t hit on yet?</z><z id="t1492713006" t="jeremyraines essentially it’s operating on a vector of maps, where each map has a :children key with a vec of the same type of map"><y>#</y><d>2017-04-20</d><h>18:30</h><w>jeremyraines</w>essentially it’s operating on a vector of maps, where each map has a <code>:children</code> key with a vec of the same type of map</z><z id="t1492713015" t="jeremyraines I’m just trying to prune each level to the keys I want"><y>#</y><d>2017-04-20</d><h>18:30</h><w>jeremyraines</w>I’m just trying to prune each level to the keys I want</z><z id="t1492713048" t="nathanmarz submap isn&apos;t going to prune keys"><y>#</y><d>2017-04-20</d><h>18:30</h><w>nathanmarz</w>submap isn&apos;t going to prune keys</z><z id="t1492713078" t="nathanmarz it lets you operate on a portion of the map with the result being merged back into the original map"><y>#</y><d>2017-04-20</d><h>18:31</h><w>nathanmarz</w>it lets you operate on a portion of the map with the result being merged back into the original map</z><z id="t1492713122" t="nathanmarz I think you want to use continue-then-stay"><y>#</y><d>2017-04-20</d><h>18:32</h><w>nathanmarz</w>I think you want to use <code>continue-then-stay</code></z><z id="t1492713149" t="jeremyraines hmm, OK thanks. I got the notion of pruning because this is the closet I got, but it only returns the leaves"><y>#</y><d>2017-04-20</d><h>18:32</h><w>jeremyraines</w>hmm, OK thanks.  I got the notion of pruning because this is the closet I got, but it only returns the leaves</z><z id="t1492713155" t="nathanmarz (recursive-path [] p (continue-then-stay :children ALL p))"><y>#</y><d>2017-04-20</d><h>18:32</h><w>nathanmarz</w><code>(recursive-path [] p (continue-then-stay :children ALL p))</code></z><z id="t1492713182" t="jeremyraines (def TreeValues (s/recursive-path [] p (s/if-path #(not (empty? (:children %))) [:children s/ALL p] (s/submap [:id :name :children])))) "><y>#</y><d>2017-04-20</d><h>18:33</h><w>jeremyraines</w><pre>(def TreeValues
  (s/recursive-path [] p
    (s/if-path #(not (empty? (:children %)))
      [:children s/ALL p]
      (s/submap [:id :name :children]))))
</pre></z><z id="t1492713197" t="nathanmarz then you could do: (transform TreeNodes #(select-keys % [:id :name :children]) data)"><y>#</y><d>2017-04-20</d><h>18:33</h><w>nathanmarz</w>then you could do: <code>(transform TreeNodes #(select-keys % [:id :name :children]) data)</code></z><z id="t1492713222" t="jeremyraines ok, thanks - reading up on continue-then-stay and trying it out"><y>#</y><d>2017-04-20</d><h>18:33</h><w>jeremyraines</w>ok, thanks - reading up on <code>continue-then-stay</code> and trying it out</z><z id="t1492714119" t="jeremyraines that works, thanks!"><y>#</y><d>2017-04-20</d><h>18:48</h><w>jeremyraines</w>that works, thanks!</z><z id="t1492715023" t="jeremyraines I’m lacking some intuition though . . . I don’t understand why this works: (transform [ALL TreeNodes] #(select-keys % [:id :name :children]) data) but not this: (transform [FIRST TreeNodes] #(select-keys % [:id :name :children]) data)"><y>#</y><d>2017-04-20</d><h>19:03</h><w>jeremyraines</w>I’m lacking some intuition though . . . I don’t understand why this works:
<pre>(transform [ALL TreeNodes] #(select-keys % [:id :name :children]) data)</pre>
but not this:
<pre>(transform [FIRST TreeNodes] #(select-keys % [:id :name :children]) data)</pre></z><z id="t1492715083" t="nathanmarz what&apos;s not working?"><y>#</y><d>2017-04-20</d><h>19:04</h><w>nathanmarz</w>what&apos;s not working?</z><z id="t1492715163" t="jeremyraines the latter does something, I’m not sure what, on the whole data vec. I thought it would be equivalent to:"><y>#</y><d>2017-04-20</d><h>19:06</h><w>jeremyraines</w>the latter does something, I’m not sure what, on the whole data vec.  I thought it would be equivalent to:</z><z id="t1492715190" t="jeremyraines (transform [ALL TreeNodes] #(select-keys % [:id :name :children]) (take 1 data))"><y>#</y><d>2017-04-20</d><h>19:06</h><w>jeremyraines</w><code>(transform [ALL TreeNodes] #(select-keys % [:id :name :children]) (take 1 data))</code></z><z id="t1492715219" t="nathanmarz no, it will just do the transformation on the first element of the vector"><y>#</y><d>2017-04-20</d><h>19:06</h><w>nathanmarz</w>no, it will just do the transformation on the first element of the vector</z><z id="t1492715231" t="nathanmarz you&apos;ll still get the whole vector back, but everything beyond the first element will be untouched"><y>#</y><d>2017-04-20</d><h>19:07</h><w>nathanmarz</w>you&apos;ll still get the whole vector back, but everything beyond the first element will be untouched</z><z id="t1492715242" t="jeremyraines oh, got it"><y>#</y><d>2017-04-20</d><h>19:07</h><w>jeremyraines</w>oh, got it</z><z id="t1492715286" t="nathanmarz transform always operates on a select portion of the data structure, with the path specifying how to navigate to what needs to be operated on"><y>#</y><d>2017-04-20</d><h>19:08</h><w>nathanmarz</w>transform always operates on a select portion of the data structure, with the path specifying how to navigate to what needs to be operated on</z><z id="t1492715407" t="jeremyraines makes sense, I think I understood that but just dropped the context of the basics when struggling with this problem. Thanks"><y>#</y><d>2017-04-20</d><h>19:10</h><w>jeremyraines</w>makes sense, I think I understood that but just dropped the context of the basics when struggling with this problem.  Thanks</z><z id="t1492896459" t="jeremyraines anyone have a way to get the ancestors of a node in a tree, with or without specter.zipper?"><y>#</y><d>2017-04-22</d><h>21:27</h><w>jeremyraines</w>anyone have a way to get the ancestors of a node in a tree, with or without specter.zipper?</z><z id="t1492896642" t="jeremyraines closest I can get is collecting the path with clojure (def NodeAndParents (s/recursive-path [id] p (s/if-path #(= (:id %) id) s/STAY (s/if-path #(empty? (:children %)) [s/DISPENSE s/STOP] [(s/collect-one :id) :children s/ALL p])))) then using the collected ids to go through the tree again, selecting the nodes whose id is in that set"><y>#</y><d>2017-04-22</d><h>21:30</h><w>jeremyraines</w>closest I can get is collecting the path with
<pre>clojure
(def NodeAndParents
  (s/recursive-path [id] p
    (s/if-path #(= (:id %) id)
      s/STAY
      (s/if-path #(empty? (:children %))
        [s/DISPENSE s/STOP]
        [(s/collect-one :id) :children s/ALL p]))))
</pre>
then using the collected ids to go through the tree again, selecting the nodes whose id is in that set</z><z id="t1492896704" t="nathanmarz @jeremyraines yea that&apos;s pretty much how you do it with specter"><y>#</y><d>2017-04-22</d><h>21:31</h><w>nathanmarz</w>@jeremyraines yea that&apos;s pretty much how you do it with specter</z><z id="t1492896729" t="jeremyraines ah ok, cool, thanks"><y>#</y><d>2017-04-22</d><h>21:32</h><w>jeremyraines</w>ah ok, cool, thanks</z><z id="t1492896762" t="nathanmarz you can change the last part to (if-path [:children ALL] [(collect-one :id) :children ALL p])"><y>#</y><d>2017-04-22</d><h>21:32</h><w>nathanmarz</w>you can change the last part to <code>(if-path [:children ALL] [(collect-one :id) :children ALL p])</code></z><z id="t1492896776" t="jeremyraines nice"><y>#</y><d>2017-04-22</d><h>21:32</h><w>jeremyraines</w>nice</z><z id="t1492896777" t="nathanmarz calling DISPENSE before STOP doesn&apos;t do anything"><y>#</y><d>2017-04-22</d><h>21:32</h><w>nathanmarz</w>calling <code>DISPENSE</code> before <code>STOP</code> doesn&apos;t do anything</z><z id="t1492896812" t="nathanmarz and if-path has default &quot;else&quot; branch of STOP"><y>#</y><d>2017-04-22</d><h>21:33</h><w>nathanmarz</w>and <code>if-path</code> has default &quot;else&quot; branch of <code>STOP</code></z><z id="t1492932623" t="sophiago @nathanmarz after seeing your excellent presentation this past week at the NYC Clojure meetup, I think specter could likely greatly help me in working with the output of a library I have that produces deeply nested maps of vectors. Mainly my issue is that built-in functions don&apos;t seem to go deep-enough into the nesting and rolling my own with walking has proven two difficult with all the filtering necessary. I&apos;m using integer keys, which means I should probably switch to the int-map library for efficiency, but that doesn&apos;t seem like it would solve any of my major problems."><y>#</y><d>2017-04-23</d><h>07:30</h><w>sophiago</w>@nathanmarz after seeing your excellent presentation this past week at the NYC Clojure meetup, I think specter could likely greatly help me in working with the output of a library I have that produces deeply nested maps of vectors. Mainly my issue is that built-in functions don&apos;t seem to go deep-enough into the nesting and rolling my own with walking has proven two difficult with all the filtering necessary. I&apos;m using integer keys, which means I should probably switch to the int-map library for efficiency, but that doesn&apos;t seem like it would solve any of my major problems.</z><z id="t1492932657" t="sophiago I&apos;m currently mainly concerned with the following: 1. I&apos;d like to stick with generating the data into an unsorted map for speed, but when I use (into (sorted-map) ...) after the fact it oddly doesn&apos;t sort the deepest level of nesting. 2. Searching for values within the maps using some similarly always returns nil as it doesn&apos;t seem to be searching deep enough. 3. Same when it comes to using filter to eliminate empty vectors. 4. Same when trying to use vals to eliminate keys entirely."><y>#</y><d>2017-04-23</d><h>07:30</h><w>sophiago</w>I&apos;m currently mainly concerned with the following: 1. I&apos;d like to stick with generating the data into an unsorted map for speed, but when I use <code>(into (sorted-map) ...)</code> after the fact it oddly doesn&apos;t sort the deepest level of nesting. 2. Searching for values within the maps using <code>some</code> similarly always returns nil as it doesn&apos;t seem to be searching deep enough. 3. Same when it comes to using <code>filter</code> to eliminate empty vectors. 4. Same when trying to use <code>vals</code> to eliminate keys entirely.</z><z id="t1492932729" t="sophiago Although I can see how navigators like MAP-VALS and NIL-&gt;VECTOR would help with this, I&apos;m having trouble figuring out from the API docs how to compose them to achieve these results. I know this is quite a bit, but any pointers on which functions/macros to look at would be greatly appreciated. Thanks!"><y>#</y><d>2017-04-23</d><h>07:32</h><w>sophiago</w>Although I can see how navigators like <code>MAP-VALS</code> and <code>NIL-&gt;VECTOR</code> would help with this, I&apos;m having trouble figuring out from the API docs how to compose them to achieve these results. I know this is quite a bit, but any pointers on which functions/macros to look at would be greatly appreciated. Thanks!</z><z id="t1492950681" t="nathanmarz @sophiago going to be easiest to help you by working through some specific examples"><y>#</y><d>2017-04-23</d><h>12:31</h><w>nathanmarz</w>@sophiago going to be easiest to help you by working through some specific examples</z><z id="t1492950791" t="nathanmarz which navigators you need to compose for a use case depends entirely on the use case, a huge portion of specter&apos;s core navigators could be relevant for what you&apos;ve described so far"><y>#</y><d>2017-04-23</d><h>12:33</h><w>nathanmarz</w>which navigators you need to compose for a use case depends entirely on the use case, a huge portion of specter&apos;s core navigators could be relevant for what you&apos;ve described so far</z><z id="t1492993410" t="sophiago @nathanmarz thanks for getting back to me so fast! This is the library I&apos;m working with: https://github.com/Sophia-Gold/Madhava-v2 . It&apos;s still pretty rough in terms of functionality I need to build out, but the core of it is computing a large number of partial derivatives all at once and storing them in an atomic hash-map. Since the number of partials grows exponentially by order and are stored with keys that match them to the corresponding variables at each order this means the maps end up heavily nested. The Github README describes how to use it, but I&apos;ll paste a snippet of the function that creates the map (which is quite small) below and describe some operations on it I&apos;m having trouble getting done with core functions."><y>#</y><d>2017-04-24</d><h>00:23</h><w>sophiago</w>@nathanmarz thanks for getting back to me so fast! This is the library I&apos;m working with: <a href="https://github.com/Sophia-Gold/Madhava-v2" target="_blank">https://github.com/Sophia-Gold/Madhava-v2</a>. It&apos;s still pretty rough in terms of functionality I need to build out, but the core of it is computing a large number of partial derivatives all at once and storing them in an atomic hash-map. Since the number of partials grows exponentially by order and are stored with keys that match them to the corresponding variables at each order this means the maps end up heavily nested. The Github README describes how to use it, but I&apos;ll paste a snippet of the function that creates the map (which is quite small) below and describe some operations on it I&apos;m having trouble getting done with core functions.</z><z id="t1492993595" t="sophiago I should also mention I did try using data.int-map last night and the increase in speed was barely noticeable, presumably because when generating the map I&apos;m only assoc ing data into it and not calling update . Let me know if you think int-map makes more sense with some of the operations on it I&apos;m thinking of."><y>#</y><d>2017-04-24</d><h>00:26</h><w>sophiago</w>I should also mention I did try using <code>data.int-map</code> last night and the increase in speed was barely noticeable, presumably because when generating the map I&apos;m only <code>assoc</code>ing data into it and not calling <code>update</code>. Let me know if you think <code>int-map</code> makes more sense with some of the operations on it I&apos;m thinking of.</z><z id="t1492993934" t="sophiago So for starters, the reason why I thought of this project with regards to specter is because I initially tried to implement some functions that would combine two maps by applying a given binary operation to all the values with matching keys (meaning all their keys matching down to the deepest level of nesting) and then either throw out the disjoint key-value pairs or merge them as is. I tried implementing that with postwalk , but found it too messy to match for just the values (all vectors) since it returns everything in the map."><y>#</y><d>2017-04-24</d><h>00:32</h><w>sophiago</w>So for starters, the reason why I thought of this project with regards to specter is because I initially tried to implement some functions that would combine two maps by applying a given binary operation to all the values with matching keys (meaning all their keys matching down to the deepest level of nesting) and then either throw out the disjoint key-value pairs or merge them as is. I tried implementing that with <code>postwalk</code>, but found it too messy to match for just the values (all vectors) since it returns everything in the map.</z><z id="t1492994142" t="sophiago More realistically for calculating gradients I&apos;d need to use my linear-transform function in this library as the binary function yet instead of between two different maps, to values store in adjacent keys with some type of weighting scheme. I don&apos;t have that fully specified yet, so can set it aside, but I think specter could greatly help. I&apos;m thinking something like a zipper except instead of starting from the head, which would be ridiculously slow, I&apos;d want to go straight to the relevant key and then create the zipper right there."><y>#</y><d>2017-04-24</d><h>00:35</h><w>sophiago</w>More realistically for calculating gradients I&apos;d need to use my <code>linear-transform</code> function in this library as the binary function yet instead of between two different maps, to values store in adjacent keys with some type of weighting scheme. I don&apos;t have that fully specified yet, so can set it aside, but I think specter could greatly help. I&apos;m thinking something like a zipper except instead of starting from the head, which would be ridiculously slow, I&apos;d want to go straight to the relevant key and then create the zipper right there.</z><z id="t1492994447" t="sophiago That&apos;s a bit abstract, but a simpler example are the operations I referred to last night. I was trying to see if I could use partial differentiation to encode laws for cellular automata so started playing around with extremely large maps (often verging on too large to print) generated from one very high-dimensional term and going up to many orders like so: (diff [[0 0 0 1 0 0 1 1 0 1 1 1 1 1]] diff-map 7) . That&apos;s the map I was trying to search inside of using some (to see if the initial term was repeated) and realized it failed searching for any values due to the level of nesting. Similarly, when using (into (sorted-map) ...) how it would sort to everything but the final level of nesting, filter to eliminate &gt;50% of it that consisted of empty vectors, and vals to try and visualize the entire thing with the keys stripped out entirely."><y>#</y><d>2017-04-24</d><h>00:40</h><w>sophiago</w>That&apos;s a bit abstract, but a simpler example are the operations I referred to last night. I was trying to see if I could use partial differentiation to encode laws for cellular automata so started playing around with extremely large maps (often verging on too large to print) generated from one very high-dimensional term and going up to many orders like so: <code>(diff [[0 0 0 1 0 0 1 1 0 1 1 1 1 1]] diff-map 7)</code>. That&apos;s the map I was trying to search inside of using <code>some</code> (to see if the initial term was repeated) and realized it failed searching for any values due to the level of nesting. Similarly, when using <code>(into (sorted-map) ...)</code> how it would sort to everything but the final level of nesting, <code>filter</code> to eliminate &gt;50% of it that consisted of empty vectors, and <code>vals</code> to try and visualize the entire thing with the keys stripped out entirely.</z><z id="t1492994526" t="sophiago So that gives me five operations on nested hash-maps I couldn&apos;t achieve with core. I&apos;m not sure how involved they&apos;d be to do with specter, but seems like they could be a very good place to start as far as learning the library."><y>#</y><d>2017-04-24</d><h>00:42</h><w>sophiago</w>So that gives me five operations on nested hash-maps I couldn&apos;t achieve with core. I&apos;m not sure how involved they&apos;d be to do with specter, but seems like they could be a very good place to start as far as learning the library.</z><z id="t1493007693" t="nathanmarz @sophiago partial-diff can be written with specter like: (let [pidx (peek idx)] (select [ALL (selected? (keypath pidx) #(-&gt; % zero? not)) (view (fn [expr] (-&gt; expr (update 0 * (get expr pidx)) (update pidx dec))))] p )) "><y>#</y><d>2017-04-24</d><h>04:21</h><w>nathanmarz</w>@sophiago partial-diff can be written with specter like:
<pre>(let [pidx (peek idx)]
  (select [ALL
           (selected? (keypath pidx) #(-&gt; % zero? not))
           (view
            (fn [expr]
              (-&gt; expr
                  (update 0 * (get expr pidx))
                  (update pidx dec))))]
    p
    ))
</pre></z><z id="t1493007735" t="nathanmarz maybe a little bit of an improvement"><y>#</y><d>2017-04-24</d><h>04:22</h><w>nathanmarz</w>maybe a little bit of an improvement</z><z id="t1493007797" t="nathanmarz this is a lot of code for me to parse, I can&apos;t really help with what are the optimal data structures / algorithms for this purpose"><y>#</y><d>2017-04-24</d><h>04:23</h><w>nathanmarz</w>this is a lot of code for me to parse, I can&apos;t really help with what are the optimal data structures / algorithms for this purpose</z><z id="t1493007835" t="nathanmarz if you show me subproblems you&apos;re dealing with, with inputs you have and outputs you want, I can show you how to use specter for it"><y>#</y><d>2017-04-24</d><h>04:23</h><w>nathanmarz</w>if you show me subproblems you&apos;re dealing with, with inputs you have and outputs you want, I can show you how to use specter for it</z><z id="t1493007840" t="sophiago Interesting. I&apos;m not sure how much of performance I can wring out of that tiny function, but it helps me to understand specter."><y>#</y><d>2017-04-24</d><h>04:24</h><w>sophiago</w>Interesting. I&apos;m not sure how much of performance I can wring out of that tiny function, but it helps me to understand specter.</z><z id="t1493007871" t="nathanmarz specter&apos;s most useful when you want to change part of a data structure"><y>#</y><d>2017-04-24</d><h>04:24</h><w>nathanmarz</w>specter&apos;s most useful when you want to change part of a data structure</z><z id="t1493007876" t="nathanmarz (and leave the rest unchanged)"><y>#</y><d>2017-04-24</d><h>04:24</h><w>nathanmarz</w>(and leave the rest unchanged)</z><z id="t1493007897" t="nathanmarz when you want to combine everything into a new data structure, that&apos;s not what specter is for"><y>#</y><d>2017-04-24</d><h>04:24</h><w>nathanmarz</w>when you want to combine everything into a new data structure, that&apos;s not what specter is for</z><z id="t1493007909" t="nathanmarz though it can be helpful for pieces of it"><y>#</y><d>2017-04-24</d><h>04:25</h><w>nathanmarz</w>though it can be helpful for pieces of it</z><z id="t1493007928" t="nathanmarz (`traverse` is useful when you want to combine only parts of a data structure)"><y>#</y><d>2017-04-24</d><h>04:25</h><w>nathanmarz</w>(`traverse` is useful when you want to combine only parts of a data structure)</z><z id="t1493007980" t="sophiago Well, I mentioned a few tasks so I&apos;m trying to think where&apos;s the best to start. I did have trouble figuring out how to combine two nested maps by applying a function to all values with the same key signature, but you&apos;re saying specter isn&apos;t ideal for something like that?"><y>#</y><d>2017-04-24</d><h>04:26</h><w>sophiago</w>Well, I mentioned a few tasks so I&apos;m trying to think where&apos;s the best to start. I did have trouble figuring out how to combine two nested maps by applying a function to all values with the same key signature, but you&apos;re saying specter isn&apos;t ideal for something like that?</z><z id="t1493008011" t="nathanmarz it really depends on the problem"><y>#</y><d>2017-04-24</d><h>04:26</h><w>nathanmarz</w>it really depends on the problem</z><z id="t1493008031" t="sophiago So far everything I&apos;ve mentioned is an operation on an entire map, either like above, or scrubbing the data in some way or other."><y>#</y><d>2017-04-24</d><h>04:27</h><w>sophiago</w>So far everything I&apos;ve mentioned is an operation on an entire map, either like above, or scrubbing the data in some way or other.</z><z id="t1493008038" t="nathanmarz if you just had two random maps that you wanted to combine, probably not"><y>#</y><d>2017-04-24</d><h>04:27</h><w>nathanmarz</w>if you just had two random maps that you wanted to combine, probably not</z><z id="t1493008058" t="nathanmarz but if you wanted to do something like merge a map in one location in a data structure with another map at some other location, specter will be useful"><y>#</y><d>2017-04-24</d><h>04:27</h><w>nathanmarz</w>but if you wanted to do something like merge a map in one location in a data structure with another map at some other location, specter will be useful</z><z id="t1493008110" t="sophiago As mentioned, even just sorting and filtering deeply nested maps is not quite working out with core. How would you go about that?"><y>#</y><d>2017-04-24</d><h>04:28</h><w>sophiago</w>As mentioned, even just sorting and filtering deeply nested maps is not quite working out with core. How would you go about that?</z><z id="t1493008125" t="nathanmarz well"><y>#</y><d>2017-04-24</d><h>04:28</h><w>nathanmarz</w>well</z><z id="t1493008126" t="sophiago Or searching for a value inside one?"><y>#</y><d>2017-04-24</d><h>04:28</h><w>sophiago</w>Or searching for a value inside one?</z><z id="t1493008133" t="nathanmarz what&apos;s a specific example of what you want to do?"><y>#</y><d>2017-04-24</d><h>04:28</h><w>nathanmarz</w>what&apos;s a specific example of what you want to do?</z><z id="t1493008135" t="nathanmarz input and output"><y>#</y><d>2017-04-24</d><h>04:28</h><w>nathanmarz</w>input and output</z><z id="t1493008168" t="sophiago one second"><y>#</y><d>2017-04-24</d><h>04:29</h><w>sophiago</w>one second</z><z id="t1493008488" t="sophiago So, as one example, (some #(= % [[120 3 3 0]]) @diff-map) returns nil even though that value is in the map."><y>#</y><d>2017-04-24</d><h>04:34</h><w>sophiago</w>So, as one example, <code>(some #(= % [[120 3 3 0]]) @diff-map)</code> returns <code>nil</code> even though that value is in the map.</z><z id="t1493008533" t="nathanmarz ah"><y>#</y><d>2017-04-24</d><h>04:35</h><w>nathanmarz</w>ah</z><z id="t1493008545" t="nathanmarz ok, for this specter can be very helpful"><y>#</y><d>2017-04-24</d><h>04:35</h><w>nathanmarz</w>ok, for this specter can be very helpful</z><z id="t1493008575" t="nathanmarz you can define a recursive navigator to the &quot;leaves&quot; of the structure (values which are vectors)"><y>#</y><d>2017-04-24</d><h>04:36</h><w>nathanmarz</w>you can define a recursive navigator to the &quot;leaves&quot; of the structure (values which are vectors)</z><z id="t1493008577" t="nathanmarz one sec"><y>#</y><d>2017-04-24</d><h>04:36</h><w>nathanmarz</w>one sec</z><z id="t1493008630" t="nathanmarz (def LEAVES (recursive-path [] p (if-path map? [MAP-VALS p] STAY ))) "><y>#</y><d>2017-04-24</d><h>04:37</h><w>nathanmarz</w><pre>(def LEAVES
  (recursive-path [] p
    (if-path map?
      [MAP-VALS p]
      STAY
      )))
</pre></z><z id="t1493008668" t="nathanmarz then you can do (select-first [LEAVES #(= % [[120 3 3 0]])] @diff-map)"><y>#</y><d>2017-04-24</d><h>04:37</h><w>nathanmarz</w>then you can do <code>(select-first [LEAVES #(= % [[120 3 3 0]])] @diff-map)</code></z></g><g id="s12"><z id="t1493008684" t="nathanmarz that will return either [[120 3 3 0]] or nil"><y>#</y><d>2017-04-24</d><h>04:38</h><w>nathanmarz</w>that will return either [[120 3 3 0]] or nil</z><z id="t1493008693" t="sophiago Oh wow, great."><y>#</y><d>2017-04-24</d><h>04:38</h><w>sophiago</w>Oh wow, great.</z><z id="t1493008698" t="nathanmarz if you do select , then you&apos;ll get a sequence of every match"><y>#</y><d>2017-04-24</d><h>04:38</h><w>nathanmarz</w>if you do <code>select</code>, then you&apos;ll get a sequence of every match</z><z id="t1493008717" t="nathanmarz that&apos;s very performant too"><y>#</y><d>2017-04-24</d><h>04:38</h><w>nathanmarz</w>that&apos;s very performant too</z><z id="t1493008747" t="nathanmarz you can continue navigation at each leaf as well"><y>#</y><d>2017-04-24</d><h>04:39</h><w>nathanmarz</w>you can continue navigation at each leaf as well</z><z id="t1493008767" t="nathanmarz (select [LEAVES ALL ALL odd?] @diff-map) gets you call the odd numbers in those vectors"><y>#</y><d>2017-04-24</d><h>04:39</h><w>nathanmarz</w><code>(select [LEAVES ALL ALL odd?] @diff-map)</code> gets you call the odd numbers in those vectors</z><z id="t1493008808" t="sophiago So I can also use select like how I want vals to work on a structure like this? To strip out keys?"><y>#</y><d>2017-04-24</d><h>04:40</h><w>sophiago</w>So I can also use <code>select</code> like how I want <code>vals</code> to work on a structure like this? To strip out keys?</z><z id="t1493008825" t="nathanmarz don&apos;t think of it as &quot;stripping&quot;"><y>#</y><d>2017-04-24</d><h>04:40</h><w>nathanmarz</w>don&apos;t think of it as &quot;stripping&quot;</z><z id="t1493008834" t="sophiago (select [LEAVES ALL] @diff-map) ?"><y>#</y><d>2017-04-24</d><h>04:40</h><w>sophiago</w><code>(select [LEAVES ALL] @diff-map)</code>?</z><z id="t1493008835" t="nathanmarz it&apos;s just querying the data structure for a sequence of matches"><y>#</y><d>2017-04-24</d><h>04:40</h><w>nathanmarz</w>it&apos;s just querying the data structure for a sequence of matches</z><z id="t1493008863" t="nathanmarz but yea, that will get you all the vectors of numbers as a single sequence"><y>#</y><d>2017-04-24</d><h>04:41</h><w>nathanmarz</w>but yea, that will get you all the vectors of numbers as a single sequence</z><z id="t1493008911" t="sophiago Oh, as a sequence? I thought a big feature was returning the same kind of data structure. What if I want to perform operations on all the values and return a map with the same nesting? For example filtering?"><y>#</y><d>2017-04-24</d><h>04:41</h><w>sophiago</w>Oh, as a sequence? I thought a big feature was returning the same kind of data structure. What if I want to perform operations on all the values and return a map with the same nesting? For example filtering?</z><z id="t1493008923" t="nathanmarz use transform for that"><y>#</y><d>2017-04-24</d><h>04:42</h><w>nathanmarz</w>use <code>transform</code> for that</z><z id="t1493008955" t="nathanmarz (transform [LEAVES ALL ALL even?] inc @diff-map)"><y>#</y><d>2017-04-24</d><h>04:42</h><w>nathanmarz</w><code>(transform [LEAVES ALL ALL even?] inc @diff-map)</code></z><z id="t1493008967" t="nathanmarz that gives you a new map with all the even numbers incremented"><y>#</y><d>2017-04-24</d><h>04:42</h><w>nathanmarz</w>that gives you a new map with all the even numbers incremented</z><z id="t1493008983" t="sophiago Ah, this is quite easy once you wrote that LEAVES navigator 🙂"><y>#</y><d>2017-04-24</d><h>04:43</h><w>sophiago</w>Ah, this is quite easy once you wrote that LEAVES navigator <b>🙂</b></z><z id="t1493008995" t="nathanmarz (setval [LEAVES ALL AFTER-ELEM] 10) appends the value 10 to each vector of numbers"><y>#</y><d>2017-04-24</d><h>04:43</h><w>nathanmarz</w><code>(setval [LEAVES ALL AFTER-ELEM] 10)</code> appends the value 10 to each vector of numbers</z><z id="t1493009113" t="sophiago For just filtering would you recommend calling transform with identity as the function?"><y>#</y><d>2017-04-24</d><h>04:45</h><w>sophiago</w>For just filtering would you recommend calling <code>transform</code> with <code>identity</code> as the function?</z><z id="t1493009133" t="nathanmarz what&apos;s an example of what you want to filter?"><y>#</y><d>2017-04-24</d><h>04:45</h><w>nathanmarz</w>what&apos;s an example of what you want to filter?</z><z id="t1493009151" t="nathanmarz most likely it will be something along the lines of (setval [...] NONE @diff-map)"><y>#</y><d>2017-04-24</d><h>04:45</h><w>nathanmarz</w>most likely it will be something along the lines of <code>(setval [...] NONE @diff-map)</code></z><z id="t1493009183" t="nathanmarz (setval [LEAVES ALL (selected? ALL even?)] NONE @diff-map) will remove any vector of nums that has an even number within"><y>#</y><d>2017-04-24</d><h>04:46</h><w>nathanmarz</w><code>(setval [LEAVES ALL (selected? ALL even?)] NONE @diff-map)</code> will remove any vector of nums that has an even number within</z><z id="t1493009188" t="sophiago I was thinking something like (transform [LEAVES ALL ALL #(not= [])] identity @diff-map)"><y>#</y><d>2017-04-24</d><h>04:46</h><w>sophiago</w>I was thinking something like <code>(transform [LEAVES ALL ALL #(not= [])] identity @diff-map)</code></z><z id="t1493009197" t="sophiago err wait...one less ALL"><y>#</y><d>2017-04-24</d><h>04:46</h><w>sophiago</w>err wait...one less ALL</z><z id="t1493009200" t="sophiago I think?"><y>#</y><d>2017-04-24</d><h>04:46</h><w>sophiago</w>I think?</z><z id="t1493009208" t="nathanmarz what you wrote will be a no-op"><y>#</y><d>2017-04-24</d><h>04:46</h><w>nathanmarz</w>what you wrote will be a no-op</z><z id="t1493009212" t="sophiago Ah ok"><y>#</y><d>2017-04-24</d><h>04:46</h><w>sophiago</w>Ah ok</z><z id="t1493009220" t="nathanmarz you want to remove empty vectors?"><y>#</y><d>2017-04-24</d><h>04:47</h><w>nathanmarz</w>you want to remove empty vectors?</z><z id="t1493009285" t="sophiago Yes. I&apos;m more interested in working with the vectors as a whole than values inside of them. So that&apos;s one example. I can see wanting to apply a function to a whole vector like you did about with inc as well, though."><y>#</y><d>2017-04-24</d><h>04:48</h><w>sophiago</w>Yes. I&apos;m more interested in working with the vectors as a whole than values inside of them. So that&apos;s one example. I can see wanting to apply a function to a whole vector like you did about with <code>inc</code> as well, though.</z><z id="t1493009295" t="nathanmarz (setval [LEAVES ALL #(= [] %)] NONE @diff-map) will remove empty vectors"><y>#</y><d>2017-04-24</d><h>04:48</h><w>nathanmarz</w><code>(setval [LEAVES ALL #(= [] %)] NONE @diff-map)</code> will remove empty vectors</z><z id="t1493009324" t="nathanmarz (transform [LEAVES ALL] some-custom-fn @diff-map) runs an arbitrary function on each vec of nums"><y>#</y><d>2017-04-24</d><h>04:48</h><w>nathanmarz</w><code>(transform [LEAVES ALL] some-custom-fn @diff-map)</code> runs an arbitrary function on each vec of nums</z><z id="t1493009377" t="nathanmarz the path in transform says what you want to change in the data structure, meaning anything else will remain unchanged"><y>#</y><d>2017-04-24</d><h>04:49</h><w>nathanmarz</w>the path in transform says what you want to change in the data structure, meaning anything else will remain unchanged</z><z id="t1493009395" t="nathanmarz so what you wrote says to transform each non empty vector with identity"><y>#</y><d>2017-04-24</d><h>04:49</h><w>nathanmarz</w>so what you wrote says to transform each non empty vector with <code>identity</code></z><z id="t1493009399" t="sophiago This is really great! I don&apos;t quite understand how you defined the LEAVES navigator to begin with, but from there everything is incredibly simple."><y>#</y><d>2017-04-24</d><h>04:49</h><w>sophiago</w>This is really great! I don&apos;t quite understand how you defined the LEAVES navigator to begin with, but from there everything is incredibly simple.</z><z id="t1493009413" t="nathanmarz it&apos;s pretty simple"><y>#</y><d>2017-04-24</d><h>04:50</h><w>nathanmarz</w>it&apos;s pretty simple</z><z id="t1493009426" t="nathanmarz it&apos;s just saying how to get to the vec of vecs"><y>#</y><d>2017-04-24</d><h>04:50</h><w>nathanmarz</w>it&apos;s just saying how to get to the vec of vecs</z><z id="t1493009451" t="nathanmarz recursive-path lets you have the path refer to itself (using p in this case)"><y>#</y><d>2017-04-24</d><h>04:50</h><w>nathanmarz</w><code>recursive-path</code> lets you have the path refer to itself (using <code>p</code> in this case)</z><z id="t1493009492" t="nathanmarz it&apos;s saying &quot;if currently at a map, recurse at all the map vals, otherwise already at the target so stay navigated&quot;"><y>#</y><d>2017-04-24</d><h>04:51</h><w>nathanmarz</w>it&apos;s saying &quot;if currently at a map, recurse at all the map vals, otherwise already at the target so stay navigated&quot;</z><z id="t1493009508" t="sophiago Right. I get it now."><y>#</y><d>2017-04-24</d><h>04:51</h><w>sophiago</w>Right. I get it now.</z><z id="t1493009542" t="sophiago What about merging two maps with a transformation function?"><y>#</y><d>2017-04-24</d><h>04:52</h><w>sophiago</w>What about merging two maps with a transformation function?</z><z id="t1493009566" t="nathanmarz example?"><y>#</y><d>2017-04-24</d><h>04:52</h><w>nathanmarz</w>example?</z><z id="t1493009666" t="sophiago Let&apos;s say I have two of that map above, so the keys are equal, and I want a new map with the same structure and the values the result of a binary function applied to the old one?"><y>#</y><d>2017-04-24</d><h>04:54</h><w>sophiago</w>Let&apos;s say I have two of that map above, so the keys are equal, and I want a new map with the same structure and the values the result of a binary function applied to the old one?</z><z id="t1493009755" t="sophiago I don&apos;t want to make it more complicated by adding a long function to multiply or divide two vectors, but you get the idea. I would also ideally like to be able to choose what to do with key signatures that don&apos;t match, but that seems more complicated."><y>#</y><d>2017-04-24</d><h>04:55</h><w>sophiago</w>I don&apos;t want to make it more complicated by adding a long function to multiply or divide two vectors, but you get the idea. I would also ideally like to be able to choose what to do with key signatures that don&apos;t match, but that seems more complicated.</z><z id="t1493009768" t="nathanmarz ah, yea specter won&apos;t help with that"><y>#</y><d>2017-04-24</d><h>04:56</h><w>nathanmarz</w>ah, yea specter won&apos;t help with that</z><z id="t1493009778" t="nathanmarz that sounds like a somewhat complicated merge-with"><y>#</y><d>2017-04-24</d><h>04:56</h><w>nathanmarz</w>that sounds like a somewhat complicated <code>merge-with</code></z><z id="t1493009812" t="sophiago I can&apos;t quite remember, but that must have been the first thing I tried for that before postwalk . It works with nesting?"><y>#</y><d>2017-04-24</d><h>04:56</h><w>sophiago</w>I can&apos;t quite remember, but that must have been the first thing I tried for that before <code>postwalk</code>. It works with nesting?</z><z id="t1493009823" t="nathanmarz well"><y>#</y><d>2017-04-24</d><h>04:57</h><w>nathanmarz</w>well</z><z id="t1493009843" t="nathanmarz your call to merge-with will have to be recursive"><y>#</y><d>2017-04-24</d><h>04:57</h><w>nathanmarz</w>your call to <code>merge-with</code> will have to be recursive</z><z id="t1493009868" t="sophiago Right. I think what happened was I gave up on writing a recursive merge-with 😛"><y>#</y><d>2017-04-24</d><h>04:57</h><w>sophiago</w>Right. I think what happened was I gave up on writing a recursive <code>merge-with</code> <b>😛</b></z><z id="t1493009931" t="nathanmarz i&apos;ve thought a bit about extending specter to walk multiple structures at once, but I haven&apos;t personally had many use cases for it"><y>#</y><d>2017-04-24</d><h>04:58</h><w>nathanmarz</w>i&apos;ve thought a bit about extending specter to walk multiple structures at once, but I haven&apos;t personally had many use cases for it</z><z id="t1493009965" t="nathanmarz it would likely be a massive change to how specter works and I&apos;m not sure it can be done while maintaining near-optimal efficiency"><y>#</y><d>2017-04-24</d><h>04:59</h><w>nathanmarz</w>it would likely be a massive change to how specter works and I&apos;m not sure it can be done while maintaining near-optimal efficiency</z><z id="t1493009966" t="sophiago It seems like it would help with that as is... I&apos;d have to think about it a bit."><y>#</y><d>2017-04-24</d><h>04:59</h><w>sophiago</w>It seems like it would help with that as is... I&apos;d have to think about it a bit.</z><z id="t1493009987" t="sophiago Yeah, I&apos;m not taking into account efficiency of using specter for something like that."><y>#</y><d>2017-04-24</d><h>04:59</h><w>sophiago</w>Yeah, I&apos;m not taking into account efficiency of using specter for something like that.</z><z id="t1493010012" t="nathanmarz those transformations I was showing before will be near-optimal efficiency"><y>#</y><d>2017-04-24</d><h>05:00</h><w>nathanmarz</w>those transformations I was showing before will be near-optimal efficiency</z><z id="t1493010022" t="sophiago I do think being able to precisely define a path and apply transform to that will really help me with this library."><y>#</y><d>2017-04-24</d><h>05:00</h><w>sophiago</w>I do think being able to precisely define a path and apply <code>transform</code> to that will really help me with this library.</z><z id="t1493010034" t="nathanmarz will blow away the performance of postwalk"><y>#</y><d>2017-04-24</d><h>05:00</h><w>nathanmarz</w>will blow away the performance of postwalk</z><z id="t1493010043" t="nathanmarz yea, I think this should be a good start for you"><y>#</y><d>2017-04-24</d><h>05:00</h><w>nathanmarz</w>yea, I think this should be a good start for you</z><z id="t1493010064" t="sophiago postwalk just is really difficult to work with due to everything it returns"><y>#</y><d>2017-04-24</d><h>05:01</h><w>sophiago</w><code>postwalk</code> just is really difficult to work with due to everything it returns</z><z id="t1493010159" t="sophiago I guess the only other thing I was going to ask about was sorting and why (into (sorted-map) @diff-map) wasn&apos;t changing anything. This one came out perfectly sorted, but when they get really gigantic and hairy, they&apos;re not on the deepest level. I designed it that way in case I wanted to use something similar to pmap ."><y>#</y><d>2017-04-24</d><h>05:02</h><w>sophiago</w>I guess the only other thing I was going to ask about was sorting and why <code>(into (sorted-map) @diff-map)</code> wasn&apos;t changing anything. This one came out perfectly sorted, but when they get really gigantic and hairy, they&apos;re not on the deepest level. I designed it that way in case I wanted to use something similar to <code>pmap</code>.</z><z id="t1493010204" t="nathanmarz that will only sort the first level"><y>#</y><d>2017-04-24</d><h>05:03</h><w>nathanmarz</w>that will only sort the first level</z><z id="t1493010216" t="sophiago Ah ok. Then that&apos;s the expected behavior."><y>#</y><d>2017-04-24</d><h>05:03</h><w>sophiago</w>Ah ok. Then that&apos;s the expected behavior.</z><z id="t1493010252" t="nathanmarz you can define a navigator to every map and then do (transform MAP-NODES #(into (sorted-map) %) @diff-map)"><y>#</y><d>2017-04-24</d><h>05:04</h><w>nathanmarz</w>you can define a navigator to every map and then do <code>(transform MAP-NODES #(into (sorted-map) %) @diff-map)</code></z><z id="t1493010289" t="nathanmarz (def MAP-NODES (recursive-path [] p (if-path map? (continue-then-stay MAP-VALS p)) )) "><y>#</y><d>2017-04-24</d><h>05:04</h><w>nathanmarz</w><pre>(def MAP-NODES
  (recursive-path [] p
    (if-path map?
      (continue-then-stay MAP-VALS p))
    ))
</pre></z><z id="t1493010311" t="sophiago Yes, I was just going to say. It helps to see the navigator for that as well."><y>#</y><d>2017-04-24</d><h>05:05</h><w>sophiago</w>Yes, I was just going to say. It helps to see the navigator for that as well.</z><z id="t1493010371" t="nathanmarz anyway, it&apos;s bedtime for me, I&apos;ll be back online tomorrow if you have more questions"><y>#</y><d>2017-04-24</d><h>05:06</h><w>nathanmarz</w>anyway, it&apos;s bedtime for me, I&apos;ll be back online tomorrow if you have more questions</z><z id="t1493010418" t="sophiago Thanks so much! This will definitely get me started. I was also just going to ask whether you find much of a speed increase using int-map with these kind of functions?"><y>#</y><d>2017-04-24</d><h>05:06</h><w>sophiago</w>Thanks so much! This will definitely get me started. I was also just going to ask whether you find much of a speed increase using <code>int-map</code> with these kind of functions?</z><z id="t1493010488" t="nathanmarz I&apos;ve never used int-map so I&apos;m not familiar with which operations it achieves speedups"><y>#</y><d>2017-04-24</d><h>05:08</h><w>nathanmarz</w>I&apos;ve never used <code>int-map</code> so I&apos;m not familiar with which operations it achieves speedups</z><z id="t1493010525" t="nathanmarz I&apos;m guessing it&apos;s faster for get and assoc, which these transformations we&apos;ve been doing aren&apos;t using"><y>#</y><d>2017-04-24</d><h>05:08</h><w>nathanmarz</w>I&apos;m guessing it&apos;s faster for get and assoc, which these transformations we&apos;ve been doing aren&apos;t using</z><z id="t1493010595" t="sophiago I actually found very little increase for assoc . I think the main benefit is when you&apos;re calling update frequently since it provides its own version of that."><y>#</y><d>2017-04-24</d><h>05:09</h><w>sophiago</w>I actually found very little increase for <code>assoc</code>. I think the main benefit is when you&apos;re calling <code>update</code> frequently since it provides its own version of that.</z><z id="t1493213724" t="sophiago @nathanmarz thanks again for all the help again the other day! I just wanted to clarify one thing, this function you gave me for filtering out empty lists isn&apos;t working: (setval [LEAVES ALL #(= [] %)] NONE *map*) . It seems like it should so I&apos;m a bit confused."><y>#</y><d>2017-04-26</d><h>13:35</h><w>sophiago</w>@nathanmarz thanks again for all the help again the other day! I just wanted to clarify one thing, this function you gave me for filtering out empty lists isn&apos;t working: <code>(setval [LEAVES ALL #(= [] %)] NONE *map*)</code>. It seems like it should so I&apos;m a bit confused.</z><z id="t1493213880" t="nathanmarz seems to be working fine user=&gt; (def LEAVES #_=&gt; (recursive-path [] p #_=&gt; (if-path map? #_=&gt; [MAP-VALS p] #_=&gt; STAY #_=&gt; ))) #&apos;user/LEAVES user=&gt; (def m {0 {1 [[1 2 3] [] [4]]} 2 [[] [] [5 6]]}) #&apos;user/m user=&gt; (setval [LEAVES ALL #(= [] %)] NONE m) {0 {1 [[1 2 3] [4]]}, 2 [[5 6]]} "><y>#</y><d>2017-04-26</d><h>13:38</h><w>nathanmarz</w>seems to be working fine
<pre>user=&gt; (def LEAVES
  #_=&gt;   (recursive-path [] p
  #_=&gt;     (if-path map?
  #_=&gt;       [MAP-VALS p]
  #_=&gt;       STAY
  #_=&gt;       )))
#&apos;user/LEAVES
user=&gt; (def m {0 {1 [[1 2 3] [] [4]]} 2 [[] [] [5 6]]}) 
#&apos;user/m
user=&gt; (setval [LEAVES ALL #(= [] %)] NONE m)
{0 {1 [[1 2 3] [4]]}, 2 [[5 6]]}
</pre></z><z id="t1493214116" t="sophiago Oh wait. You&apos;re filtering empty vectors inside the values. I was thinking that would filter values that were empty vectors."><y>#</y><d>2017-04-26</d><h>13:41</h><w>sophiago</w>Oh wait. You&apos;re filtering empty vectors inside the values. I was thinking that would filter values that were empty vectors.</z><z id="t1493214190" t="nathanmarz if you want to filter the direct values of the maps then just remove the ALL"><y>#</y><d>2017-04-26</d><h>13:43</h><w>nathanmarz</w>if you want to filter the direct values of the maps then just remove the <code>ALL</code></z><z id="t1493214228" t="nathanmarz you can also do (setval [LEAVES (continue-then-stay ALL) #(= [] %)] NONE m) to remove empty vectors from inside the map values and then remove key/value pairs where the value is []"><y>#</y><d>2017-04-26</d><h>13:43</h><w>nathanmarz</w>you can also do <code> (setval [LEAVES (continue-then-stay ALL) #(= [] %)] NONE m)</code> to remove empty vectors from inside the map values and then remove key/value pairs where the value is <code>[]</code></z><z id="t1493214344" t="sophiago Ah, I see. I just looked back at the docs. Since I&apos;m already selecting for leaves of the maps that means ALL would go inside any collections present in the values. I assumed it meant &quot;apply this to all leaves.&quot;"><y>#</y><d>2017-04-26</d><h>13:45</h><w>sophiago</w>Ah, I see. I just looked back at the docs. Since I&apos;m already selecting for leaves of the maps that means ALL would go inside any collections present in the values. I assumed it meant &quot;apply this to all leaves.&quot;</z><z id="t1493214399" t="sophiago Yup, looks good now. Thanks!"><y>#</y><d>2017-04-26</d><h>13:46</h><w>sophiago</w>Yup, looks good now. Thanks!</z><z id="t1493214405" t="nathanmarz no problem"><y>#</y><d>2017-04-26</d><h>13:46</h><w>nathanmarz</w>no problem</z><z id="t1493219398" t="nathanmarz @teng srange navigates you to a sequence, so navigating to a keyword from there doesn&apos;t make sense"><y>#</y><d>2017-04-26</d><h>15:09</h><w>nathanmarz</w>@teng <code>srange</code> navigates you to a sequence, so navigating to a keyword from there doesn&apos;t make sense</z><z id="t1493219421" t="nathanmarz I think you want: (setval [:educations (nthpath 1) :major-name] &quot;C&quot; data)"><y>#</y><d>2017-04-26</d><h>15:10</h><w>nathanmarz</w>I think you want: <code>(setval [:educations (nthpath 1) :major-name] &quot;C&quot; data)</code></z><z id="t1493219505" t="teng @nathanmarz That worked, thanks! 🙂"><y>#</y><d>2017-04-26</d><h>15:11</h><w>teng</w>@nathanmarz That worked, thanks! <b>🙂</b></z><z id="t1493248080" t="albaker @nathanmarz so in the crazy nested structure of {:id &quot;blah :children [{:id &quot;blah2 :children [ .. ]]} it looks like a (select-first (recursive-path [] p [(walker (fn [x] ... match an id ...) STAY]) tree) will grab any intermediate node in that structure (and halt with the STAY) is that right?"><y>#</y><d>2017-04-26</d><h>23:08</h><w>albaker</w>@nathanmarz so in the crazy nested structure of <code>{:id &quot;blah :children [{:id &quot;blah2 :children [ .. ]]}</code> it looks like a <code>(select-first (recursive-path [] p [(walker (fn [x] ... match an id ...) STAY]) tree)</code> will grab any intermediate node in that structure (and halt with the STAY) is that right?</z><z id="t1493248980" t="nathanmarz @albaker it&apos;ll grab the first node it encounters"><y>#</y><d>2017-04-26</d><h>23:23</h><w>nathanmarz</w>@albaker it&apos;ll grab the first node it encounters</z><z id="t1493249009" t="nathanmarz fyi that path isn&apos;t recursive so no reason to use recursive-path"><y>#</y><d>2017-04-26</d><h>23:23</h><w>nathanmarz</w>fyi that path isn&apos;t recursive so no reason to use <code>recursive-path</code></z><z id="t1493249023" t="nathanmarz and no reason to have the STAY after walker"><y>#</y><d>2017-04-26</d><h>23:23</h><w>nathanmarz</w>and no reason to have the <code>STAY</code> after <code>walker</code></z><z id="t1493249286" t="albaker ah, so the walker will depth first down through w/o a recursive path, and select-first makes STAY redundant? I&apos;m still wrapping my head around paths"><y>#</y><d>2017-04-26</d><h>23:28</h><w>albaker</w>ah, so the walker will depth first down through w/o a recursive path, and select-first makes STAY redundant?   I&apos;m still wrapping my head around paths</z><z id="t1493282718" t="nathanmarz @albaker recursive-path is only needed when your path definition needs to refer to itself"><y>#</y><d>2017-04-27</d><h>08:45</h><w>nathanmarz</w>@albaker <code>recursive-path</code> is only needed when your path definition needs to refer to itself</z><z id="t1493282745" t="nathanmarz the STAY is redundant regardless of the operation"><y>#</y><d>2017-04-27</d><h>08:45</h><w>nathanmarz</w>the <code>STAY</code> is redundant regardless of the operation</z><z id="t1493282769" t="nathanmarz walker navigates you to all values matching that predicate"><y>#</y><d>2017-04-27</d><h>08:46</h><w>nathanmarz</w><code>walker</code> navigates you to all values matching that predicate</z><z id="t1493282789" t="nathanmarz navigating from those values using STAY does nothing"><y>#</y><d>2017-04-27</d><h>08:46</h><w>nathanmarz</w>navigating from those values using <code>STAY</code> does nothing</z><z id="t1493304541" t="albaker makes sense, thanks!"><y>#</y><d>2017-04-27</d><h>14:49</h><w>albaker</w>makes sense, thanks!</z><z id="t1493661808" t="nijssels Why do the following statements work..."><y>#</y><d>2017-05-01</d><h>18:03</h><w>nijssels</w>Why do the following statements work...</z><z id="t1493661829" t="nijssels But the combination doesnt..."><y>#</y><d>2017-05-01</d><h>18:03</h><w>nijssels</w>But the combination doesnt...</z><z id="t1493662219" t="nijssels This works... It must be the workings of select-one..."><y>#</y><d>2017-05-01</d><h>18:10</h><w>nijssels</w>This works... It must be the workings of select-one...</z><z id="t1493664453" t="levitanong @nathanmarz I can’t seem to find documentation on traverse-all . Tried using it as if it were a transducer version of traverse but it doesn’t seem to work exactly like that."><y>#</y><d>2017-05-01</d><h>18:47</h><w>levitanong</w>@nathanmarz I can’t seem to find documentation on <code>traverse-all</code>. Tried using it as if it were a transducer version of <code>traverse</code> but it doesn’t seem to work exactly like that.</z><z id="t1493664487" t="nathanmarz @nijssels MAP-VALS navigates you to each value individually, which means you&apos;re calling FIRST on a number"><y>#</y><d>2017-05-01</d><h>18:48</h><w>nathanmarz</w>@nijssels <code>MAP-VALS</code> navigates you to each value individually, which means you&apos;re calling <code>FIRST</code> on a number</z><z id="t1493664516" t="nathanmarz you can do (select-first MAP-VALS {:a 1 :b 2 :c 3})"><y>#</y><d>2017-05-01</d><h>18:48</h><w>nathanmarz</w>you can do <code>(select-first MAP-VALS {:a 1 :b 2 :c 3})</code></z><z id="t1493664548" t="nathanmarz @levitanong examples of usage: https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L1370"><y>#</y><d>2017-05-01</d><h>18:49</h><w>nathanmarz</w>@levitanong examples of usage: <a href="https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L1370" target="_blank">https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L1370</a></z><z id="t1493664619" t="levitanong ok that makes sense. thanks!"><y>#</y><d>2017-05-01</d><h>18:50</h><w>levitanong</w>ok that makes sense. thanks!</z><z id="t1493664631" t="nijssels Of course. Thanks @nathanmarz!"><y>#</y><d>2017-05-01</d><h>18:50</h><w>nijssels</w>Of course. Thanks @nathanmarz!</z><z id="t1493673909" t="urbank I probably should have figured this out, but how do recursively navigate this kind of data-structure"><y>#</y><d>2017-05-01</d><h>21:25</h><w>urbank</w>I probably should have figured this out, but how do recursively navigate this kind of data-structure</z><z id="t1493674095" t="urbank I want to get to all the maps that have a :children key"><y>#</y><d>2017-05-01</d><h>21:28</h><w>urbank</w>I want to get to all the maps that have a :children key</z><z id="t1493676323" t="nathanmarz @urbank (def data {:data 10 :children [{:data [1 2 3] :children []} {:data [4 5 6] :children []}]}) (def NODES (recursive-path [] p (continue-then-stay :children ALL p) )) (select [NODES :data] data) ;; =&gt; [[1 2 3] [4 5 6] 10] "><y>#</y><d>2017-05-01</d><h>22:05</h><w>nathanmarz</w>@urbank
<pre>(def data
  {:data 10
   :children [{:data [1 2 3]
               :children []}
              {:data [4 5 6]
               :children []}]})


(def NODES
  (recursive-path [] p
    (continue-then-stay :children ALL p)
    ))

(select [NODES :data] data)
;; =&gt; [[1 2 3] [4 5 6] 10]
</pre></z><z id="t1493677202" t="urbank @nathanmarz Oh cool, thanks! For some reason I thought there needed to be a terminating clause in a recursive path, but I suppose it just stops when it runs out of results"><y>#</y><d>2017-05-01</d><h>22:20</h><w>urbank</w>@nathanmarz Oh cool, thanks! For some reason I thought there needed to be a terminating clause in a recursive path, but I suppose it just stops when it runs out of results</z><z id="t1493677363" t="urbank Still don&apos;t quite understand what Navigates to the provided path and then to the current element means. Stay as opposed to what?"><y>#</y><d>2017-05-01</d><h>22:22</h><w>urbank</w>Still don&apos;t quite understand what <code>Navigates to the provided path and then to the current element</code> means. Stay as opposed to what?</z><z id="t1493677763" t="nathanmarz @urbank as opposed to only navigating to the provided subpath"><y>#</y><d>2017-05-01</d><h>22:29</h><w>nathanmarz</w>@urbank as opposed to only navigating to the provided subpath</z><z id="t1493677814" t="nathanmarz (select (continue-then-stay :a) {:a 1}) ; =&gt; [1 {:a 1}]"><y>#</y><d>2017-05-01</d><h>22:30</h><w>nathanmarz</w><code>(select (continue-then-stay :a) {:a 1}) ; =&gt; [1 {:a 1}]</code></z><z id="t1493677834" t="nathanmarz it navigates to :a, then navigates to itself"><y>#</y><d>2017-05-01</d><h>22:30</h><w>nathanmarz</w>it navigates to :a, then navigates to itself</z><z id="t1493693440" t="luxbock is there some built-in higher order selector that allows me to write the following: (transform (??? FIRST LAST) (fn [[a b]] (if (&gt; a b) [(str a) b] [a (str b)]) [1 2 3]) =&gt; [1 2 &quot;3&quot;]?"><y>#</y><d>2017-05-02</d><h>02:50</h><w>luxbock</w>is there some built-in higher order selector that allows me to write the following: <code>(transform (??? FIRST LAST) (fn [[a b]] (if (&gt; a b) [(str a) b] [a (str b)]) [1 2 3])</code> =&gt; [1 2 &quot;3&quot;]?</z><z id="t1493705906" t="narkisr Hey, looking for a way to transform a single value from set into multiple values using a predicate (subset won&apos;t help in that case becuase its not a static set of items)"><y>#</y><d>2017-05-02</d><h>06:18</h><w>narkisr</w>Hey, looking for a way to transform a single value from set into multiple values using a predicate (subset won&apos;t help in that case becuase its not a static set of items)</z><z id="t1493705936" t="narkisr iv tried to use transform with pred but that can replace only a single value and not expand a value into multiple ones"><y>#</y><d>2017-05-02</d><h>06:18</h><w>narkisr</w>iv tried to use transform with pred but that can replace only a single value and not expand a value into multiple ones</z><z id="t1493707855" t="narkisr I managed to so by using a reduce in the transform function but that not really using specter"><y>#</y><d>2017-05-02</d><h>06:50</h><w>narkisr</w>I managed to so by using a reduce in the transform function but that not really using specter</z><z id="t1493719110" t="nathanmarz @narkisr you would need a new navigator for that"><y>#</y><d>2017-05-02</d><h>09:58</h><w>nathanmarz</w>@narkisr you would need a new navigator for that</z><z id="t1493719151" t="nathanmarz something like (dynamic-subset even?) that navigates to the subset of all even values"><y>#</y><d>2017-05-02</d><h>09:59</h><w>nathanmarz</w>something like <code>(dynamic-subset even?)</code> that navigates to the subset of all even values</z><z id="t1493719187" t="nathanmarz the definition of subset should be a good starting point https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L794"><y>#</y><d>2017-05-02</d><h>09:59</h><w>nathanmarz</w>the definition of <code>subset</code> should be a good starting point <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L794" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L794</a></z><z id="t1493719463" t="mac Has anybody looked at odin https://github.com/halgari/odin Any thoughts on how it compares to specter?"><y>#</y><d>2017-05-02</d><h>10:04</h><w>mac</w>Has anybody looked at odin <a href="https://github.com/halgari/odin" target="_blank">https://github.com/halgari/odin</a> Any thoughts on how it compares to specter?</z><z id="t1493735404" t="nathanmarz @mac from glancing at the readme every example deals with nested maps, so I would want to know if it can handle other data structures / be extensible to user data types"><y>#</y><d>2017-05-02</d><h>14:30</h><w>nathanmarz</w>@mac from glancing at the readme every example deals with nested maps, so I would want to know if it can handle other data structures / be extensible to user data types</z><z id="t1493735537" t="nathanmarz I&apos;m also skeptical of the performance and the expressive power"><y>#</y><d>2017-05-02</d><h>14:32</h><w>nathanmarz</w>I&apos;m also skeptical of the performance and the expressive power</z><z id="t1493735557" t="nathanmarz especially specter&apos;s &quot;substructure&quot; navigators, like &quot;srange&quot;, &quot;filterer&quot;, etc."><y>#</y><d>2017-05-02</d><h>14:32</h><w>nathanmarz</w>especially specter&apos;s &quot;substructure&quot; navigators, like &quot;srange&quot;, &quot;filterer&quot;, etc.</z><z id="t1493735591" t="nathanmarz a good test use case is incrementing the last odd number in a vector of numbers"><y>#</y><d>2017-05-02</d><h>14:33</h><w>nathanmarz</w>a good test use case is incrementing the last odd number in a vector of numbers</z><z id="t1493735627" t="mac @nathanmarz If get the time I will see if I can make that work."><y>#</y><d>2017-05-02</d><h>14:33</h><w>mac</w>@nathanmarz If get the time I will see if I can make that work.</z><z id="t1493735659" t="mac Unrelated I am having trouble with understanding DISPENSE."><y>#</y><d>2017-05-02</d><h>14:34</h><w>mac</w>Unrelated I am having trouble with understanding DISPENSE.</z><z id="t1493735667" t="nathanmarz cool, please post whatever you find"><y>#</y><d>2017-05-02</d><h>14:34</h><w>nathanmarz</w>cool, please post whatever you find</z><z id="t1493735692" t="mac I would have expected (s/select [s/ALL (s/collect-one :a) :b s/DISPENSE #(= % 1)] [{:a &quot;A&quot; :b 1} {:a &quot;AA&quot; :b 1}])"><y>#</y><d>2017-05-02</d><h>14:34</h><w>mac</w>I would have expected <pre>(s/select [s/ALL (s/collect-one :a) :b s/DISPENSE #(= % 1)] [{:a &quot;A&quot; :b 1} {:a &quot;AA&quot; :b 1}])</pre></z><z id="t1493735715" t="mac to return [&quot;A&quot; &quot;AA&quot;]"><y>#</y><d>2017-05-02</d><h>14:35</h><w>mac</w>to return <pre>[&quot;A&quot; &quot;AA&quot;]</pre></z><z id="t1493735741" t="mac but I get [1 1]"><y>#</y><d>2017-05-02</d><h>14:35</h><w>mac</w>but I get <pre>[1 1]</pre></z><z id="t1493735774" t="mac Isn&apos;t DISPENSE suppose to drop whatever navigations comes after it?"><y>#</y><d>2017-05-02</d><h>14:36</h><w>mac</w>Isn&apos;t DISPENSE suppose to drop whatever navigations comes after it?</z><z id="t1493735786" t="nathanmarz it&apos;s producing the right result"><y>#</y><d>2017-05-02</d><h>14:36</h><w>nathanmarz</w>it&apos;s producing the right result</z><z id="t1493735795" t="nathanmarz DISPENSE drops collected values"><y>#</y><d>2017-05-02</d><h>14:36</h><w>nathanmarz</w><code>DISPENSE</code> drops collected values</z><z id="t1493735811" t="nathanmarz that path is equivalent to [ALL :b #(= % 1)]"><y>#</y><d>2017-05-02</d><h>14:36</h><w>nathanmarz</w>that path is equivalent to <code>[ALL :b #(= % 1)]</code></z><z id="t1493735820" t="mac Ok, then I find the docs slightly confusing."><y>#</y><d>2017-05-02</d><h>14:37</h><w>mac</w>Ok, then I find the docs slightly confusing.</z><z id="t1493735863" t="nathanmarz what about it?"><y>#</y><d>2017-05-02</d><h>14:37</h><w>nathanmarz</w>what about it?</z><z id="t1493735900" t="mac Ref &quot;Drops all collected values for subsequent navigation&quot; - I understood this to mean values for subsequent navigations to be droped."><y>#</y><d>2017-05-02</d><h>14:38</h><w>mac</w>Ref &quot;Drops all collected values for subsequent navigation&quot; - I understood this to mean values for subsequent navigations to be droped.</z><z id="t1493735937" t="nathanmarz &quot;collected values&quot; always refers to values collected via collect , collect-one , and VAL"><y>#</y><d>2017-05-02</d><h>14:38</h><w>nathanmarz</w>&quot;collected values&quot; always refers to values collected via <code>collect</code>, <code>collect-one</code>, and <code>VAL</code></z><z id="t1493735998" t="nathanmarz user=&gt; (doc DISPENSE) ------------------------- com.rpl.specter/DISPENSE Drops all collected values for subsequent navigation. nil user=&gt; (doc collect-one) ------------------------- com.rpl.specter/collect-one Adds the result of running select-one with the given path on the current value to the collected vals. nil user=&gt; (doc collect) ------------------------- com.rpl.specter/collect Adds the result of running select with the given path on the current value to the collected vals. nil user=&gt; (doc with-fresh-collected) ------------------------- com.rpl.specter/with-fresh-collected Continues navigating on the given path with the collected vals reset to []. Once navigation leaves the scope of with-fresh-collected, the collected vals revert to what they were before. nil "><y>#</y><d>2017-05-02</d><h>14:39</h><w>nathanmarz</w><pre>user=&gt; (doc DISPENSE)
-------------------------
com.rpl.specter/DISPENSE
  Drops all collected values for subsequent navigation.
nil
user=&gt; (doc collect-one)
-------------------------
com.rpl.specter/collect-one
  Adds the result of running select-one with the given path on the
          current value to the collected vals.
nil
user=&gt; (doc collect)
-------------------------
com.rpl.specter/collect
  Adds the result of running select with the given path on the
          current value to the collected vals.
nil
user=&gt; (doc with-fresh-collected)
-------------------------
com.rpl.specter/with-fresh-collected
  Continues navigating on the given path with the collected vals reset to []. Once
     navigation leaves the scope of with-fresh-collected, the collected vals revert
     to what they were before.
nil
</pre></z><z id="t1493736008" t="nathanmarz terminology is consistent"><y>#</y><d>2017-05-02</d><h>14:40</h><w>nathanmarz</w>terminology is consistent</z><z id="t1493736060" t="mac Ok. Is there a way to achieve what I expected."><y>#</y><d>2017-05-02</d><h>14:41</h><w>mac</w>Ok. Is there a way to achieve what I expected.</z><z id="t1493736109" t="nathanmarz I think you&apos;re looking for (select [ALL #(= 1 (:b %)) :a] data)"><y>#</y><d>2017-05-02</d><h>14:41</h><w>nathanmarz</w>I think you&apos;re looking for <code>(select [ALL #(= 1 (:b %)) :a] data)</code></z><z id="t1493736137" t="nathanmarz or (select [ALL (selected? :b #(= 1 %)) :a] data)"><y>#</y><d>2017-05-02</d><h>14:42</h><w>nathanmarz</w>or <code>(select [ALL (selected? :b #(= 1 %)) :a] data)</code></z><z id="t1493736247" t="mac Thanks. I take it then there is no &quot;do not return any values navigated to after this point just use it for selecting&quot; navigator."><y>#</y><d>2017-05-02</d><h>14:44</h><w>mac</w>Thanks. I take it then there is no &quot;do not return any values navigated to after this point just use it for selecting&quot; navigator.</z><z id="t1493736265" t="nathanmarz correct"><y>#</y><d>2017-05-02</d><h>14:44</h><w>nathanmarz</w>correct</z><z id="t1493758594" t="mac @nathanmarz Gave halgari anouthe look. No obvious way of solving the use case you mentioned."><y>#</y><d>2017-05-02</d><h>20:56</h><w>mac</w>@nathanmarz Gave halgari anouthe look. No obvious way of solving the use case you mentioned.</z><z id="t1493819364" t="mac I am faced with a design dilemma. I have data structure consisting of deeply nested records which reflect the domain I am working in. Querying this is very straight fwd using specter. But some of these records contain &quot;behaviour&quot; (ie. anonymous functions as values) in the form of validation functions, transformation functions (for how to transform themselves or other records in the structure), dispatch functions(that decides when to dispatch certain messages), conditions etc. I am debating (with myself) two different approaches: Either use multimethods to walk/query the datastructure/trigger behaviour OR use specter for the same task. My primary (perhaps very unfounded) concern with specter is that my structure contains &quot;behaviour&quot;. My concern with the multimethod approach is that it will be messy and hard to maintain. Hope my question is even remotely clear, otherwise happy to clarify and context."><y>#</y><d>2017-05-03</d><h>13:49</h><w>mac</w>I am faced with a design dilemma. I have data structure consisting of deeply nested records which reflect the domain I am working in. Querying this is very straight fwd using specter. But some of these records contain &quot;behaviour&quot; (ie. anonymous functions as values) in the form of validation functions, transformation functions (for how to transform themselves or other records in the structure), dispatch functions(that decides when to dispatch certain messages), conditions etc. I am debating (with myself) two different approaches: Either use multimethods to walk/query the datastructure/trigger behaviour OR use specter for the same task. My primary (perhaps very unfounded) concern with specter is that my structure contains &quot;behaviour&quot;.  My concern with the multimethod approach is that it will be messy and hard to maintain. Hope my question is even remotely clear, otherwise happy to clarify and context.</z><z id="t1493819836" t="nathanmarz @mac I think using specter is fine for that task"><y>#</y><d>2017-05-03</d><h>13:57</h><w>nathanmarz</w>@mac I think using specter is fine for that task</z><z id="t1493819864" t="nathanmarz you probably want to use traverse with reduce to trigger the nested functions"><y>#</y><d>2017-05-03</d><h>13:57</h><w>nathanmarz</w>you probably want to use <code>traverse</code> with <code>reduce</code> to trigger the nested functions</z><z id="t1493820237" t="mac Thanks, had not noticed traverse, looks very useful."><y>#</y><d>2017-05-03</d><h>14:03</h><w>mac</w>Thanks, had not noticed traverse, looks very useful.</z><z id="t1493868950" t="nathanmarz @luxbock just noticed your question"><y>#</y><d>2017-05-04</d><h>03:35</h><w>nathanmarz</w>@luxbock just noticed your question</z><z id="t1493868986" t="nathanmarz yes there is, it&apos;s this: (transform (subselect (multi-path FIRST LAST)) (fn [[a b]] (if (&gt; a b) [(str a) b] [a (str b)])) [1 2 3]) ;; =&gt; [1 2 &quot;3&quot;] "><y>#</y><d>2017-05-04</d><h>03:36</h><w>nathanmarz</w>yes there is, it&apos;s this:
<pre>(transform (subselect (multi-path FIRST LAST))
  (fn [[a b]] (if (&gt; a b) [(str a) b] [a (str b)]))
  [1 2 3])
;; =&gt; [1 2 &quot;3&quot;]
</pre></z><z id="t1493869214" t="luxbock Ah that&apos;s great, I will try to see if it works for my original use case "><y>#</y><d>2017-05-04</d><h>03:40</h><w>luxbock</w>Ah that&apos;s great, I will try to see if it works for my original use case </z><z id="t1494175703" t="nha Could this selector be rewritten to avoid sp/range or sp/LAST ? (def data [[:foo {:component &quot;aaa&quot;}] [:bar {:component &quot;bbb&quot;}] [:qux {:component &quot;ccc&quot;}]]) (= (sp/select [sp/ALL (sp/srange 1 2) sp/ALL :component ] data) (sp/select [sp/ALL sp/LAST :component ] data)) ;; =&gt; true Is there something analog to sp/SECOND or sp/NTH ?"><y>#</y><d>2017-05-07</d><h>16:48</h><w>nha</w>Could this selector be rewritten to avoid <code>sp/range</code> or <code>sp/LAST</code>?

<pre>(def data
  [[:foo {:component &quot;aaa&quot;}]
   [:bar {:component &quot;bbb&quot;}]
   [:qux {:component &quot;ccc&quot;}]])

(= (sp/select [sp/ALL
               (sp/srange 1 2)
               sp/ALL
               :component
               ] data)

   (sp/select [sp/ALL
               sp/LAST
               :component
               ] data)) ;; =&gt; true
</pre>

Is there something analog to <code>sp/SECOND</code> or <code>sp/NTH</code> ?</z><z id="t1494182725" t="nathanmarz @nha use nthpath"><y>#</y><d>2017-05-07</d><h>18:45</h><w>nathanmarz</w>@nha use nthpath</z><z id="t1494182738" t="nathanmarz (nthpath 1)"><y>#</y><d>2017-05-07</d><h>18:45</h><w>nathanmarz</w><code>(nthpath 1)</code></z><z id="t1494186742" t="nha Perfect, I missed this one 🙂 Thanks nathanmarz, always helpful!"><y>#</y><d>2017-05-07</d><h>19:52</h><w>nha</w>Perfect, I missed this one <b>🙂</b> Thanks nathanmarz, always helpful!</z><z id="t1494278985" t="mac @nathanmarz I looked at traverse and not sure it does what I need. I have a tree structure of deeply nested records which I would like to walk/transform. Some of these are condition records that should stop navigation of the subtree underneath if the condition (a vector of predicate functions) does not return true. Does that make sense? I have tried to illustrate the structure below. Navigation should not get to the action records of type :three and :three-and-a-half but allow me to select/transform the other records based on some criteria."><y>#</y><d>2017-05-08</d><h>21:29</h><w>mac</w>@nathanmarz I looked at traverse and not sure it does what I need. I have a tree structure of deeply nested records which I would like to walk/transform. Some of these are condition records that should stop navigation of the subtree underneath if the condition (a vector of predicate functions) does not return true. Does that make sense?  I have tried to illustrate the structure below. Navigation should not get to the action records of type :three and :three-and-a-half but allow me to select/transform the other records based on some criteria.</z><z id="t1494280963" t="nathanmarz @mac what do you run the predicate function on?"><y>#</y><d>2017-05-08</d><h>22:02</h><w>nathanmarz</w>@mac what do you run the predicate function on?</z><z id="t1494280979" t="nathanmarz what is #(= % 3) supposed to receive as input?"><y>#</y><d>2017-05-08</d><h>22:02</h><w>nathanmarz</w>what is <code>#(= % 3)</code> supposed to receive as input?</z><z id="t1494281112" t="mac @nathanmarz I will pass it the children it is guarding and probably an environment of some sort (a map most likely)."><y>#</y><d>2017-05-08</d><h>22:05</h><w>mac</w>@nathanmarz I will pass it the children it is guarding and probably an environment of some sort (a map most likely).</z><z id="t1494282123" t="nathanmarz from your prior description it sounded like you needed to get some functions out of a nested structure and run them"><y>#</y><d>2017-05-08</d><h>22:22</h><w>nathanmarz</w>from your prior description it sounded like you needed to get some functions out of a nested structure and run them</z><z id="t1494282149" t="nathanmarz to do this, once you get to a condition, just use a function to filter it"><y>#</y><d>2017-05-08</d><h>22:22</h><w>nathanmarz</w>to do this, once you get to a condition, just use a function to filter it</z><z id="t1494282205" t="nathanmarz (defn cond-filter [cond] ;; return true if every condition function returns true) "><y>#</y><d>2017-05-08</d><h>22:23</h><w>nathanmarz</w><pre>(defn cond-filter [cond]
  ;; return true if every condition function returns true)
</pre></z><z id="t1494282233" t="nathanmarz then your path would contain [... cond-filter :actions ALL ...]"><y>#</y><d>2017-05-08</d><h>22:23</h><w>nathanmarz</w>then your path would contain <code>[... cond-filter :actions ALL ...]</code></z><z id="t1494282563" t="mac @nathanmarz Sorry for the confusion. I only need to run the functions to determine if the subtree they are guarding should be walked or skipped."><y>#</y><d>2017-05-08</d><h>22:29</h><w>mac</w>@nathanmarz Sorry for the confusion. I only need to run the functions to determine if the subtree they are guarding should be walked or skipped.</z><z id="t1494283206" t="nathanmarz @mac does making a function that runs the condition functions solve your problem?"><y>#</y><d>2017-05-08</d><h>22:40</h><w>nathanmarz</w>@mac does making a function that runs the condition functions solve your problem?</z><z id="t1494284202" t="mac @nathanmarz I don&apos;t think so. Only if I the result could control if the children of the Condition record are walked or not - the problem is I don&apos;t know how to do that. Been looking at zippers too, but last time I dealt with them it was painful 🙂"><y>#</y><d>2017-05-08</d><h>22:56</h><w>mac</w>@nathanmarz I don&apos;t think so. Only if I the result could control if the children of the Condition record are walked or not - the problem is I don&apos;t know how to do that. Been looking at zippers too, but last time I dealt with them it was painful <b>🙂</b></z><z id="t1494284922" t="nathanmarz it does control that"><y>#</y><d>2017-05-08</d><h>23:08</h><w>nathanmarz</w>it does control that</z><z id="t1494284935" t="nathanmarz that&apos;s exactly what it does"><y>#</y><d>2017-05-08</d><h>23:08</h><w>nathanmarz</w>that&apos;s exactly what it does</z><z id="t1494284983" t="nathanmarz your path should navigate to condition, then run a filter function there to do all the logic of testing the predicates against the guarded children"><y>#</y><d>2017-05-08</d><h>23:09</h><w>nathanmarz</w>your path should navigate to condition, then run a filter function there to do all the logic of testing the predicates against the guarded children</z><z id="t1494284991" t="nathanmarz if that returns true, then it can continue walking the actions"><y>#</y><d>2017-05-08</d><h>23:09</h><w>nathanmarz</w>if that returns true, then it can continue walking the actions</z><z id="t1494284997" t="nathanmarz if it returns false, then the actions will not be walked"><y>#</y><d>2017-05-08</d><h>23:09</h><w>nathanmarz</w>if it returns false, then the actions will not be walked</z><z id="t1494285372" t="mac And the remainder of the structure will still be walked?"><y>#</y><d>2017-05-08</d><h>23:16</h><w>mac</w>And the remainder of the structure will still be walked?</z><z id="t1494285566" t="mac @nathanmarz I might be missing something here, but I don&apos;t have a path at all, only a walker."><y>#</y><d>2017-05-08</d><h>23:19</h><w>mac</w>@nathanmarz I might be missing something here, but I don&apos;t have a path at all, only a walker.</z><z id="t1494285600" t="nathanmarz you mean you&apos;re using the walker navigator?"><y>#</y><d>2017-05-08</d><h>23:20</h><w>nathanmarz</w>you mean you&apos;re using the <code>walker</code> navigator?</z><z id="t1494285608" t="mac Yes"><y>#</y><d>2017-05-08</d><h>23:20</h><w>mac</w>Yes</z><z id="t1494285627" t="nathanmarz wrap it in a recursive-path"><y>#</y><d>2017-05-08</d><h>23:20</h><w>nathanmarz</w>wrap it in a <code>recursive-path</code></z><z id="t1494285673" t="nathanmarz what are you walking to?"><y>#</y><d>2017-05-08</d><h>23:21</h><w>nathanmarz</w>what are you walking to?</z><z id="t1494285679" t="nathanmarz Action or Condition ?"><y>#</y><d>2017-05-08</d><h>23:21</h><w>nathanmarz</w><code>Action</code> or <code>Condition</code>?</z><z id="t1494285715" t="nathanmarz actually, is your goal to just retrieve all actions that are properly guarded?"><y>#</y><d>2017-05-08</d><h>23:21</h><w>nathanmarz</w>actually, is your goal to just retrieve all actions that are properly guarded?</z><z id="t1494285738" t="mac Yes, and potentially transform them."><y>#</y><d>2017-05-08</d><h>23:22</h><w>mac</w>Yes, and potentially transform them.</z><z id="t1494285831" t="nathanmarz (def SATISFACTORY-ACTION-NODES (recursive-path [] p (if-path #(instance? Condition %) [cond-filter :children ALL p] (continue-then-stay :children ALL p )))) "><y>#</y><d>2017-05-08</d><h>23:23</h><w>nathanmarz</w><pre>(def SATISFACTORY-ACTION-NODES
  (recursive-path [] p
    (if-path #(instance? Condition %)
      [cond-filter :children ALL p]
      (continue-then-stay
        :children
        ALL
        p
        ))))
</pre></z><z id="t1494285835" t="nathanmarz you want something like that"><y>#</y><d>2017-05-08</d><h>23:23</h><w>nathanmarz</w>you want something like that</z><z id="t1494285854" t="nathanmarz I don&apos;t think you want to use walker"><y>#</y><d>2017-05-08</d><h>23:24</h><w>nathanmarz</w>I don&apos;t think you want to use walker</z><z id="t1494285883" t="nathanmarz it&apos;s always better to encode the precise structure of your data rather than brute force it with walker"><y>#</y><d>2017-05-08</d><h>23:24</h><w>nathanmarz</w>it&apos;s always better to encode the precise structure of your data rather than brute force it with <code>walker</code></z><z id="t1494285994" t="nathanmarz an alternative way to solve this is with protocol paths (if you&apos;re using clojure)"><y>#</y><d>2017-05-08</d><h>23:26</h><w>nathanmarz</w>an alternative way to solve this is with protocol paths (if you&apos;re using clojure)</z><z id="t1494286023" t="nathanmarz protocol path solution would be extensible to other types of nodes beyond Action and Condition"><y>#</y><d>2017-05-08</d><h>23:27</h><w>nathanmarz</w>protocol path solution would be extensible to other types of nodes beyond Action and Condition</z><z id="t1494286079" t="mac That might be even better, since I have several other record types."><y>#</y><d>2017-05-08</d><h>23:27</h><w>mac</w>That might be even better, since I have several other record types.</z><z id="t1494286107" t="nathanmarz there&apos;s examples of those on the README"><y>#</y><d>2017-05-08</d><h>23:28</h><w>nathanmarz</w>there&apos;s examples of those on the README</z><z id="t1494286149" t="mac Yeah, looked at those but it wasn&apos;t clear to me how to achieve my goal. Will look at them again."><y>#</y><d>2017-05-08</d><h>23:29</h><w>mac</w>Yeah, looked at those but it wasn&apos;t clear to me how to achieve my goal. Will look at them again.</z><z id="t1494286264" t="nathanmarz (defprotocolpath SatisfactoryActionNodes) (extend-protocolpath SatisfactoryActionNodes Action (continue-then-stay :children ALL SatisfactoryActionNodes) Condition [cond-filter :children ALL SatisfactoryActionNodes]) "><y>#</y><d>2017-05-08</d><h>23:31</h><w>nathanmarz</w><pre>(defprotocolpath SatisfactoryActionNodes)

(extend-protocolpath SatisfactoryActionNodes
  Action (continue-then-stay :children ALL SatisfactoryActionNodes)
  Condition [cond-filter :children ALL SatisfactoryActionNodes])
</pre></z><z id="t1494286478" t="mac @nathanmarz That it is very elegant."><y>#</y><d>2017-05-08</d><h>23:34</h><w>mac</w>@nathanmarz That it is very elegant.</z><z id="t1494512056" t="wilkerlucio hello, I&apos;m trying to figure if I can use specter for a situation I have here"><y>#</y><d>2017-05-11</d><h>14:14</h><w>wilkerlucio</w>hello, I&apos;m trying to figure if I can use specter for a situation I have here</z><z id="t1494512081" t="wilkerlucio I have a map, and I would like to filter the map by some criteria on the values"><y>#</y><d>2017-05-11</d><h>14:14</h><w>wilkerlucio</w>I have a map, and I would like to filter the map by some criteria on the values</z><z id="t1494512104" t="wilkerlucio today my Clojure code is:"><y>#</y><d>2017-05-11</d><h>14:15</h><w>wilkerlucio</w>today my Clojure code is:</z><z id="t1494512137" t="wilkerlucio (-&gt;&gt; some-map (filter (fn [[k v]] (&gt; v 10))) (into {}))"><y>#</y><d>2017-05-11</d><h>14:15</h><w>wilkerlucio</w><pre>(-&gt;&gt; some-map
     (filter (fn [[k v]]
               (&gt; v 10)))
     (into {}))</pre></z><z id="t1494512154" t="wilkerlucio is there a way to replace this with specter select and avoid having to convert the data types?"><y>#</y><d>2017-05-11</d><h>14:15</h><w>wilkerlucio</w>is there a way to replace this with specter <code>select</code> and avoid having to convert the data types?</z><z id="t1494514839" t="nathanmarz @wilkerlucio (transform [MAP-VALS #(&gt; % 10)] some-map)"><y>#</y><d>2017-05-11</d><h>15:00</h><w>nathanmarz</w>@wilkerlucio <code>(transform [MAP-VALS #(&gt; % 10)] some-map)</code></z><z id="t1494514884" t="nathanmarz that will maintain the type of the map and also run about 10x faster"><y>#</y><d>2017-05-11</d><h>15:01</h><w>nathanmarz</w>that will maintain the type of the map and also run about 10x faster</z><z id="t1494515209" t="wilkerlucio @nathanmarz thanks, didn&apos;t even occur to me to use transform to filter, but seeing it makes total sense 🙂"><y>#</y><d>2017-05-11</d><h>15:06</h><w>wilkerlucio</w>@nathanmarz thanks, didn&apos;t even occur to me to use transform to filter, but seeing it makes total sense <b>🙂</b></z><z id="t1494515242" t="wilkerlucio I think would be nice to have some filter example like this on README"><y>#</y><d>2017-05-11</d><h>15:07</h><w>wilkerlucio</w>I think would be nice to have some <code>filter</code> example like this on README</z><z id="t1494515286" t="nathanmarz err"><y>#</y><d>2017-05-11</d><h>15:08</h><w>nathanmarz</w>err</z><z id="t1494515308" t="nathanmarz sorry, meant to write this: (setval [MAP-VALS #(&lt;= % 10)] NONE some-map)"><y>#</y><d>2017-05-11</d><h>15:08</h><w>nathanmarz</w>sorry, meant to write this: <code>(setval [MAP-VALS #(&lt;= % 10)] NONE some-map)</code></z><z id="t1494515318" t="nathanmarz sleepy today"><y>#</y><d>2017-05-11</d><h>15:08</h><w>nathanmarz</w>sleepy today</z><z id="t1494515417" t="wilkerlucio haha, I was just coming back to ask, thanks for the speedy catch 🙂"><y>#</y><d>2017-05-11</d><h>15:10</h><w>wilkerlucio</w>haha, I was just coming back to ask, thanks for the speedy catch <b>🙂</b></z><z id="t1494515472" t="wilkerlucio @nathanmarz why we need to invert the predicate?"><y>#</y><d>2017-05-11</d><h>15:11</h><w>wilkerlucio</w>@nathanmarz why we need to invert the predicate?</z><z id="t1494515494" t="wilkerlucio ah, gotcha, it&apos;s not about filtering ther,e it&apos;s about removing"><y>#</y><d>2017-05-11</d><h>15:11</h><w>wilkerlucio</w>ah, gotcha, it&apos;s not about filtering ther,e it&apos;s about removing</z><z id="t1494515714" t="nathanmarz yea, that&apos;s right"><y>#</y><d>2017-05-11</d><h>15:15</h><w>nathanmarz</w>yea, that&apos;s right</z><z id="t1494628511" t="ksmithbaylor Hey everyone! I&apos;ve got a nested map (It&apos;s a deserialization of a flat file JSON &quot;database&quot; for a budgeting app I&apos;m extending) that looks similar to this (stripped down somewhat): {:categories [{:name &quot;Monthly bills&quot; :subcategories [{:name &quot;Electric&quot;} {:name &quot;Cable&quot; :inactive true} {:name &quot;Mortgage&quot;} {:name &quot;Natural Gas&quot;}]} {:name &quot;Food&quot; :subcategories [{:name &quot;Eating Out&quot;} {:name &quot;Groceries&quot;}]} {:name &quot;Stuff&quot; :inactive true :subcategories [{:name &quot;Things&quot; :inactive true} {:name &quot;Whatever&quot;}]}] :accounts [{:name &quot;Checking&quot; :balance 100} {:name &quot;Old account&quot; :balance 0 :inactive true} {:name &quot;Savings&quot; :balance 500}]} I&apos;m fairly new to specter, and am still learning about what&apos;s possible. How would I recursively remove all maps at all levels that have an :inactive true flag? The result I would get from the above would be: {:categories [{:name &quot;Monthly bills&quot; :subcategories [{:name &quot;Electric&quot;} {:name &quot;Mortgage&quot;} {:name &quot;Natural Gas&quot;}]} {:name &quot;Food&quot; :subcategories [{:name &quot;Eating Out&quot;} {:name &quot;Groceries&quot;}]}] :accounts [{:name &quot;Checking&quot; :balance 100} {:name &quot;Savings&quot; :balance 500}]} "><y>#</y><d>2017-05-12</d><h>22:35</h><w>ksmithbaylor</w>Hey everyone! I&apos;ve got a nested map (It&apos;s a deserialization of a flat file JSON &quot;database&quot; for a budgeting app I&apos;m extending) that looks similar to this (stripped down somewhat):

<pre>{:categories [{:name &quot;Monthly bills&quot;
               :subcategories [{:name &quot;Electric&quot;}
                               {:name &quot;Cable&quot; :inactive true}
                               {:name &quot;Mortgage&quot;}
                               {:name &quot;Natural Gas&quot;}]}
              {:name &quot;Food&quot;
               :subcategories [{:name &quot;Eating Out&quot;}
                               {:name &quot;Groceries&quot;}]}
              {:name &quot;Stuff&quot;
               :inactive true
               :subcategories [{:name &quot;Things&quot; :inactive true}
                               {:name &quot;Whatever&quot;}]}]
 :accounts [{:name &quot;Checking&quot;
             :balance 100}
            {:name &quot;Old account&quot;
             :balance 0
             :inactive true}
            {:name &quot;Savings&quot;
             :balance 500}]}
</pre>

I&apos;m fairly new to specter, and am still learning about what&apos;s possible. How would I recursively remove all maps at all levels that have an <code>:inactive true</code> flag? The result I would get from the above would be:

<pre>{:categories [{:name &quot;Monthly bills&quot;
               :subcategories [{:name &quot;Electric&quot;}
                               {:name &quot;Mortgage&quot;}
                               {:name &quot;Natural Gas&quot;}]}
              {:name &quot;Food&quot;
               :subcategories [{:name &quot;Eating Out&quot;}
                               {:name &quot;Groceries&quot;}]}]
 :accounts [{:name &quot;Checking&quot;
             :balance 100}
            {:name &quot;Savings&quot;
             :balance 500}]}
</pre></z><z id="t1494630195" t="nathanmarz @ksmithbaylor it would be something like: (def NODES (recursive-path [] p (continue-then-stay (must :subcategories) ALL p ))) (setval [(multi-path :categories :accounts) ALL NODES (pred :inactive)] NONE data) "><y>#</y><d>2017-05-12</d><h>23:03</h><w>nathanmarz</w>@ksmithbaylor it would be something like:
<pre>(def NODES
  (recursive-path [] p
    (continue-then-stay
      (must :subcategories) ALL p
      )))

(setval [(multi-path :categories :accounts)
         ALL
         NODES
         (pred :inactive)]
  NONE
  data)
</pre></z><z id="t1494631265" t="ksmithbaylor This is doing almost what I want: (setval [(walker #(and (map? %) (:inactive %)))] nil data)"><y>#</y><d>2017-05-12</d><h>23:21</h><w>ksmithbaylor</w>This is doing almost what I want: <code>(setval [(walker #(and (map? %) (:inactive %)))] nil data)</code></z><z id="t1494631289" t="ksmithbaylor but now I need to recursively remove the nil s"><y>#</y><d>2017-05-12</d><h>23:21</h><w>ksmithbaylor</w>but now I need to recursively remove the <code>nil</code>s</z><z id="t1494631330" t="ksmithbaylor I&apos;d like to keep it generic so I don&apos;t need to know/care what keys are in each level"><y>#</y><d>2017-05-12</d><h>23:22</h><w>ksmithbaylor</w>I&apos;d like to keep it generic so I don&apos;t need to know/care what keys are in each level</z><z id="t1494632876" t="nathanmarz it&apos;s generally better to be more precise about the structure of your data"><y>#</y><d>2017-05-12</d><h>23:47</h><w>nathanmarz</w>it&apos;s generally better to be more precise about the structure of your data</z><z id="t1494632887" t="nathanmarz walker doesn&apos;t perform well and has some pitfalls"><y>#</y><d>2017-05-12</d><h>23:48</h><w>nathanmarz</w><code>walker</code> doesn&apos;t perform well and has some pitfalls</z><z id="t1494632903" t="nathanmarz you can just replace nil with NONE there to get the maps removed"><y>#</y><d>2017-05-12</d><h>23:48</h><w>nathanmarz</w>you can just replace <code>nil</code> with <code>NONE</code> there to get the maps removed</z><z id="t1494632980" t="nathanmarz actually nevermind, walker doesn&apos;t implement NONE removal"><y>#</y><d>2017-05-12</d><h>23:49</h><w>nathanmarz</w>actually nevermind, <code>walker</code> doesn&apos;t implement <code>NONE</code> removal</z><z id="t1494636942" t="ksmithbaylor Is there a way to implement NONE removal for walker? There are a lot of types of entities in the db and they all use the same flag for signifying something as inactive."><y>#</y><d>2017-05-13</d><h>00:55</h><w>ksmithbaylor</w>Is there a way to implement NONE removal for walker? There are a lot of types of entities in the db and they all use the same flag for signifying something as inactive.</z><z id="t1494636999" t="ksmithbaylor Also, the inactive entities always appear in vectors. Would it make sense to wrap the setval above in a transform that would filter each vector to remove NONE?"><y>#</y><d>2017-05-13</d><h>00:56</h><w>ksmithbaylor</w>Also, the inactive entities always appear in vectors. Would it make sense to wrap the setval above in a transform that would filter each vector to remove NONE?</z><z id="t1494637756" t="nathanmarz @ksmithbaylor i don&apos;t think it would be too hard to re-implement walker in terms of recursive-path , ALL , etc."><y>#</y><d>2017-05-13</d><h>01:09</h><w>nathanmarz</w>@ksmithbaylor i don&apos;t think it would be too hard to re-implement walker in terms of <code>recursive-path</code>, <code>ALL</code>, etc.</z><z id="t1494637800" t="nathanmarz you could also use [(walker vector?) ALL (pred :inactive)] as your path, and NONE removal will work"><y>#</y><d>2017-05-13</d><h>01:10</h><w>nathanmarz</w>you could also use <code>[(walker vector?) ALL (pred :inactive)]</code> as your path, and <code>NONE</code> removal will work</z><z id="t1494637977" t="nathanmarz actually that would need to be wrapped in recursive-path so it reaches vectors nested inside maps inside vectors"><y>#</y><d>2017-05-13</d><h>01:12</h><w>nathanmarz</w>actually that would need to be wrapped in <code>recursive-path</code> so it reaches vectors nested inside maps inside vectors</z><z id="t1494711014" t="ksmithbaylor Since I&apos;m fairly new to Clojure, I&apos;m not quite clear on the usage of recursive-path . Here&apos;s what I have so far, but it seems to have no effect on the data: (setval (recursive-path [] p [(walker vector?) ALL (pred :inactive) p]) NONE data) "><y>#</y><d>2017-05-13</d><h>21:30</h><w>ksmithbaylor</w>Since I&apos;m fairly new to Clojure, I&apos;m not quite clear on the usage of <code>recursive-path</code>. Here&apos;s what I have so far, but it seems to have no effect on the data:
<pre>(setval (recursive-path [] p [(walker vector?) ALL (pred :inactive) p]) NONE data)
</pre></z><z id="t1494818130" t="nathanmarz @ksmithbaylor that path as defined never finishes navigation anywhere"><y>#</y><d>2017-05-15</d><h>03:15</h><w>nathanmarz</w>@ksmithbaylor that path as defined never finishes navigation anywhere</z><z id="t1494818401" t="nathanmarz you&apos;ll want something like (let [all-maps (recursive-path [] p [(walker vector?) ALL (continue-then-stay p)])] (setval [all-maps (pred :inactive)] NONE data)) "><y>#</y><d>2017-05-15</d><h>03:20</h><w>nathanmarz</w>you&apos;ll want something like
<pre>(let [all-maps
        (recursive-path [] p
           [(walker vector?)
             ALL
             (continue-then-stay p)])]
(setval [all-maps (pred :inactive)] NONE data))
</pre></z><z id="t1495485919" t="dottedmag Is Specter a good tool for the following task? I have a representation of file tree {:dirs {&quot;name&quot; &lt;...&gt; &quot;name2&quot; &lt;..&gt;} :files {&quot;fname&quot; &lt;...&gt; &quot;fname2&quot; &lt;...&gt;}} , where values in map under :dirs are of the same structure. And I also have a file path &quot;name/subname/subname/filename&quot;. I need to return a new file tree with this path added, potentially creating any missing intermediate directories."><y>#</y><d>2017-05-22</d><h>20:45</h><w>dottedmag</w>Is Specter a good tool for the following task? I have a representation of file tree <code>{:dirs {&quot;name&quot; &lt;...&gt; &quot;name2&quot; &lt;..&gt;} :files {&quot;fname&quot; &lt;...&gt; &quot;fname2&quot; &lt;...&gt;}}</code>, where values in map under <code>:dirs</code> are of the same structure. And I also have a file path &quot;name/subname/subname/filename&quot;. I need to return a new file tree with this path added, potentially creating any missing intermediate directories.</z><z id="t1495495145" t="nathanmarz @dottedmag it&apos;ll help but won&apos;t be as compelling as it is for a lot of other use cases"><y>#</y><d>2017-05-22</d><h>23:19</h><w>nathanmarz</w>@dottedmag it&apos;ll help but won&apos;t be as compelling as it is for a lot of other use cases</z><z id="t1495495201" t="nathanmarz for this I would dynamically create a path using reduce, comp-paths, and keypath"><y>#</y><d>2017-05-22</d><h>23:20</h><w>nathanmarz</w>for this I would dynamically create a path using reduce, comp-paths, and keypath</z><z id="t1495497495" t="dottedmag @nathanmarz Yep, I&apos;ve got the same impression. Looks like a zipper is a better fit for this particular problem."><y>#</y><d>2017-05-22</d><h>23:58</h><w>dottedmag</w>@nathanmarz Yep, I&apos;ve got the same impression. Looks like a zipper is a better fit for this particular problem.</z><z id="t1495501668" t="madstap @dottedmag I would just use core functions: (defn assoc-file [dir-map path content] (let [xs (str/split path #&quot;/&quot;) dirs (butlast xs) file-name (last xs) path-vec (-&gt; (interleave (repeat :dirs) dirs) vec (conj :files file-name))] (assoc-in dir-map path-vec content))) (assoc-file {} &quot;foo/bar/baz.sh&quot; &quot;#!/bin/bash\n\necho foobar&quot;) Edit: (mapcat vector foo bar) is just (interleave foo bar)"><y>#</y><d>2017-05-23</d><h>01:07</h><w>madstap</w>@dottedmag I would just use core functions:
<pre>(defn assoc-file [dir-map path content]
  (let [xs (str/split path #&quot;/&quot;)
        dirs (butlast xs)
        file-name (last xs)
        path-vec (-&gt; (interleave (repeat :dirs) dirs)
                     vec
                     (conj :files file-name))]
    (assoc-in dir-map path-vec content)))

(assoc-file {} &quot;foo/bar/baz.sh&quot; &quot;#!/bin/bash\n\necho foobar&quot;)
</pre>
Edit: <code>(mapcat vector foo bar)</code> is just <code>(interleave foo bar)</code></z><z id="t1495565835" t="dottedmag @madstap Thanks. I&apos;ve got other operations on the same structure, so I went slightly crazy and created https://github.com/dottedmag/azip"><y>#</y><d>2017-05-23</d><h>18:57</h><w>dottedmag</w>@madstap Thanks. I&apos;ve got other operations on the same structure, so I went slightly crazy and created <a href="https://github.com/dottedmag/azip" target="_blank">https://github.com/dottedmag/azip</a></z><z id="t1495566284" t="madstap dottedmag: Nice. I&apos;ve never used zippers before. Out of curiosity, how would my assoc-file function look using azip?"><y>#</y><d>2017-05-23</d><h>19:04</h><r>madstap</r>dottedmag: Nice. I&apos;ve never used zippers before. Out of curiosity, how would my assoc-file function look using azip?</z><z id="t1496084984" t="oskarkv outer-map looks like this: {[1.0 1.0] {:vertices [[0 0] [1.5 0.0] [1.5 1.5] [0.0 1.5]]} ...} Can I do this conveniently with specter? I.e. take the vertices, make a polygon out of them, and put it next to the vertices. (into {} (map (fn [[site m]] (assoc m :polygon (pair-cycle (:vertices m))) outer-map))) "><y>#</y><d>2017-05-29</d><h>19:09</h><w>oskarkv</w>outer-map looks like this:
<pre>{[1.0 1.0] {:vertices [[0 0] [1.5 0.0] [1.5 1.5] [0.0 1.5]]}
 ...}
</pre>

Can I do this conveniently with specter? I.e. take the vertices, make a polygon out of them, and put it next to the vertices.

<pre>(into {} (map (fn [[site m]] (assoc m :polygon
                                    (pair-cycle (:vertices m)))
                outer-map)))
</pre></z><z id="t1496091745" t="oskarkv (s/transform [s/MAP-VALS (s/collect-one :vertices) :polygon] (fn [vs _] (pair-cycle vs)) m) "><y>#</y><d>2017-05-29</d><h>21:02</h><w>oskarkv</w><pre>(s/transform [s/MAP-VALS (s/collect-one :vertices) :polygon]
                   (fn [vs _] (pair-cycle vs))
                   m)
</pre></z><z id="t1496091773" t="oskarkv That&apos;s what I came up with."><y>#</y><d>2017-05-29</d><h>21:02</h><w>oskarkv</w>That&apos;s what I came up with.</z><z id="t1496098014" t="nathanmarz @oskarkv that code looks good to me"><y>#</y><d>2017-05-29</d><h>22:46</h><w>nathanmarz</w>@oskarkv that code looks good to me</z><z id="t1496174451" t="mping hia"><y>#</y><d>2017-05-30</d><h>20:00</h><w>mping</w>hia</z><z id="t1496174545" t="mping is there a way to traverse a map of maps and return a val for a given predicate?"><y>#</y><d>2017-05-30</d><h>20:02</h><w>mping</w>is there a way to traverse a map of maps and return a val for a given predicate?</z><z id="t1496174554" t="mping I&apos;m still wrapping my head around specter"><y>#</y><d>2017-05-30</d><h>20:02</h><w>mping</w>I&apos;m still wrapping my head around specter</z><z id="t1496174620" t="mping something like a recursive tree walk"><y>#</y><d>2017-05-30</d><h>20:03</h><w>mping</w>something like a recursive tree walk</z><z id="t1496182387" t="nathanmarz @mping yes, that&apos;s pretty easy"><y>#</y><d>2017-05-30</d><h>22:13</h><w>nathanmarz</w>@mping yes, that&apos;s pretty easy</z><z id="t1496182391" t="nathanmarz have a particular example?"><y>#</y><d>2017-05-30</d><h>22:13</h><w>nathanmarz</w>have a particular example?</z><z id="t1496191376" t="danboykis If I have the following: (def person [{:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag :a} {:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag :b} {:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag :c}]) I want to transform that to {:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag #{:c :b :a}} In plain clojure I can do it with (into {} (map (fn [[k v]] (assoc k :tag v))) (reduce (fn [accum e] (let [sm (select-keys e [:name :id :job])] (if-let [exists (get accum sm)] (assoc accum sm (conj exists (:tag e))) (assoc accum sm #{(:tag e)})))) {} person)) I am hoping there&apos;s a nicer way to do the same in specter"><y>#</y><d>2017-05-31</d><h>00:42</h><w>danboykis</w>If I have the following:

<pre>(def person
  [{:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag :a}
   {:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag :b}
   {:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag :c}])
</pre>

I want to transform that to

<pre>{:name &quot;Person&quot;, :id 1, :job &quot;Something&quot;, :tag #{:c :b :a}}
</pre>

In plain clojure I can  do it with

<pre>(into {} (map (fn [[k v]] (assoc k :tag v)))
      (reduce (fn [accum e]
          (let [sm (select-keys e [:name :id :job])]
            (if-let [exists (get accum sm)]
              (assoc accum sm (conj exists (:tag e)))
              (assoc accum sm #{(:tag e)}))))
        {}
        person))
</pre>

I am hoping there&apos;s a nicer way to do the same in specter</z><z id="t1496197141" t="nathanmarz @danboykis that&apos;s computing an entirely new value, whereas specter is about changing part of a data structure"><y>#</y><d>2017-05-31</d><h>02:19</h><w>nathanmarz</w>@danboykis that&apos;s computing an entirely new value, whereas specter is about changing part of a data structure</z><z id="t1496197239" t="nathanmarz there are pieces of it you can make nicer with specter, like replacing the if-let clause with (setval [(keypath sm) NONE-ELEM] (:tag e) accum)"><y>#</y><d>2017-05-31</d><h>02:20</h><w>nathanmarz</w>there are pieces of it you can make nicer with specter, like replacing the <code>if-let</code> clause with <code>(setval [(keypath sm) NONE-ELEM] (:tag e) accum)</code></z><z id="t1496199982" t="danboykis @nathanmarz thanks for the explanation, I am new to specter and don&apos;t have a good feel for the its use cases yet"><y>#</y><d>2017-05-31</d><h>03:06</h><w>danboykis</w>@nathanmarz thanks for the explanation, I am new to specter and don&apos;t have a good feel for the its use cases yet</z><z id="t1496211126" t="mping @nathanmarz figured it out: (specter/select (specter/walker is-pdf-attachment?) user/msg)"><y>#</y><d>2017-05-31</d><h>06:12</h><w>mping</w>@nathanmarz figured it out: <code>(specter/select (specter/walker is-pdf-attachment?) user/msg)</code></z><z id="t1496211129" t="mping tks"><y>#</y><d>2017-05-31</d><h>06:12</h><w>mping</w>tks</z><z id="t1496409793" t="wilkerlucio hello, I would like to use specter to apply a function to all map keys (recursively) on a map, can someone please give me an example on doing that?"><y>#</y><d>2017-06-02</d><h>13:23</h><w>wilkerlucio</w>hello, I would like to use specter to apply a function to all map keys (recursively) on a map, can someone please give me an example on doing that?</z><z id="t1496411498" t="nathanmarz @wilkerlucio can you show a specific example of a transformation?"><y>#</y><d>2017-06-02</d><h>13:51</h><w>nathanmarz</w>@wilkerlucio can you show a specific example of a transformation?</z><z id="t1496411507" t="nathanmarz that should be pretty easy"><y>#</y><d>2017-06-02</d><h>13:51</h><w>nathanmarz</w>that should be pretty easy</z><z id="t1496411644" t="wilkerlucio @nathanmarz sure, something like this: {:person/name &quot;Bla&quot; :person/child {:child/something &quot;other&quot; :child/bla {:subchild/entry &quot;blabla&quot;}}} to this: {:name &quot;Bla&quot; :child {:something &quot;other&quot; :bla {:entry &quot;blabla&quot;}}} "><y>#</y><d>2017-06-02</d><h>13:54</h><w>wilkerlucio</w>@nathanmarz sure, something like this:

<pre>{:person/name &quot;Bla&quot;
 :person/child {:child/something &quot;other&quot;
                :child/bla {:subchild/entry &quot;blabla&quot;}}}
</pre>

to this:

<pre>{:name &quot;Bla&quot;
 :child {:something &quot;other&quot;
                :bla {:entry &quot;blabla&quot;}}}
</pre></z><z id="t1496411657" t="wilkerlucio considering it can have N nesting fields"><y>#</y><d>2017-06-02</d><h>13:54</h><w>wilkerlucio</w>considering it can  have N nesting fields</z><z id="t1496412327" t="nathanmarz @wilkerlucio looks like this: (def data {:person/name &quot;Bla&quot; :person/child {:child/something &quot;other&quot; :child/bla {:subchild/entry &quot;blabla&quot;}}}) (def MapWalker (recursive-path [] p (if-path map? (continue-then-stay MAP-VALS p)) )) (setval [MapWalker MAP-KEYS NAMESPACE] nil data) "><y>#</y><d>2017-06-02</d><h>14:05</h><w>nathanmarz</w>@wilkerlucio looks like this:
<pre>(def data
  {:person/name &quot;Bla&quot;
   :person/child {:child/something &quot;other&quot;
                  :child/bla {:subchild/entry &quot;blabla&quot;}}})

(def MapWalker
  (recursive-path [] p
    (if-path map?
      (continue-then-stay MAP-VALS p))
    ))

(setval [MapWalker MAP-KEYS NAMESPACE] nil data)
</pre></z><z id="t1496416649" t="wilkerlucio @nathanmarz thanks 🙂"><y>#</y><d>2017-06-02</d><h>15:17</h><w>wilkerlucio</w>@nathanmarz thanks <b>🙂</b></z><z id="t1496419564" t="souenzzo (def ALL-MAPS &quot;All maps of an entity&quot; (recursive-path [] p [(walker map?) (stay-then-continue MAP-VALS p)])) @wilkerlucio those dont work with {:a [{:b :c}]} ..."><y>#</y><d>2017-06-02</d><h>16:06</h><w>souenzzo</w><pre>(def ALL-MAPS
  &quot;All maps of an entity&quot;
  (recursive-path [] p
                  [(walker map?) (stay-then-continue MAP-VALS p)]))

</pre>
@wilkerlucio those dont work with <code>{:a [{:b :c}]}</code>...</z><z id="t1496422776" t="nathanmarz it&apos;s generally better not to use walker"><y>#</y><d>2017-06-02</d><h>16:59</h><w>nathanmarz</w>it&apos;s generally better not to use walker</z><z id="t1496422801" t="nathanmarz but rather make a path that precisely encodes the structure of the data you&apos;re working with"><y>#</y><d>2017-06-02</d><h>17:00</h><w>nathanmarz</w>but rather make a path that precisely encodes the structure of the data you&apos;re working with</z><z id="t1496422826" t="nathanmarz walker is brute force which makes it less performant and often causes surprising bugs (e.g. by descending into things you didn&apos;t want, like records)"><y>#</y><d>2017-06-02</d><h>17:00</h><w>nathanmarz</w>walker is brute force which makes it less performant and often causes surprising bugs (e.g. by descending into things you didn&apos;t want, like records)</z><z id="t1496422925" t="souenzzo There is some other way to define ALL-MAPS (w/o walker)?"><y>#</y><d>2017-06-02</d><h>17:02</h><w>souenzzo</w>There is some other way to define <code>ALL-MAPS</code> (w/o walker)?</z><z id="t1496422975" t="nathanmarz @souenzzo https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1284"><y>#</y><d>2017-06-02</d><h>17:02</h><w>nathanmarz</w>@souenzzo <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1284" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1284</a></z><z id="t1496422990" t="nathanmarz that&apos;s the new definition of walker I recently committed"><y>#</y><d>2017-06-02</d><h>17:03</h><w>nathanmarz</w>that&apos;s the new definition of <code>walker</code> I recently committed</z><z id="t1496423039" t="nathanmarz can define your ALL-MAPS similarly by handling the different data structure cases in a cond-path"><y>#</y><d>2017-06-02</d><h>17:03</h><w>nathanmarz</w>can define your <code>ALL-MAPS</code> similarly by handling the different data structure cases in a <code>cond-path</code></z><z id="t1496423616" t="souenzzo (def ALL-MAPS-2 (recursive-path [] p (cond-path map? (continue-then-stay MAP-VALS p) coll? [ALL p]))) I will try to swap in my code."><y>#</y><d>2017-06-02</d><h>17:13</h><w>souenzzo</w><pre>(def ALL-MAPS-2
  (recursive-path
    [] p
    (cond-path map? (continue-then-stay MAP-VALS p)
               coll? [ALL p])))
</pre>
I will try to swap in my code.</z><z id="t1496429113" t="wilkerlucio @souenzzo nice catch"><y>#</y><d>2017-06-02</d><h>18:45</h><w>wilkerlucio</w>@souenzzo nice catch</z><z id="t1496505690" t="souenzzo (-&gt;&gt; x (transform [:foo :bar MY-TRANSFORM] inc) (transform [:foo2 :bar2 MY-TRANSFORM] inc)) There is some how to do this with one transoform?"><y>#</y><d>2017-06-03</d><h>16:01</h><w>souenzzo</w><pre>(-&gt;&gt; x
(transform [:foo :bar MY-TRANSFORM] inc)
(transform [:foo2 :bar2 MY-TRANSFORM] inc))
</pre>
There is some how to do this with one transoform?</z><z id="t1496509481" t="urbank Try multi-path"><y>#</y><d>2017-06-03</d><h>17:04</h><w>urbank</w>Try multi-path</z><z id="t1496518312" t="nathanmarz if you want different transformation functions applied at each path, use multi-transform + terminal /`terminal-val`"><y>#</y><d>2017-06-03</d><h>19:31</h><w>nathanmarz</w>if you want different transformation functions applied at each path, use <code>multi-transform</code> + <code>terminal</code>/`terminal-val`</z><z id="t1496518321" t="nathanmarz in this case just multi-path is fine"><y>#</y><d>2017-06-03</d><h>19:32</h><w>nathanmarz</w>in this case just <code>multi-path</code> is fine</z><z id="t1496539840" t="michaelwfogleman Hm, playing around with specter and really loving it so far. I notice that sometimes I want to get a single value but specter wraps the return in a vector - so I call first on the result - is there a more idiomatic way to do this?"><y>#</y><d>2017-06-04</d><h>01:30</h><w>michaelwfogleman</w>Hm, playing around with specter and really loving it so far. I notice that sometimes I want to get a single value but specter wraps the return in a vector - so I call first on the result - is there a more idiomatic way to do this?</z><z id="t1496544888" t="nathanmarz @michaelwfogleman select-any"><y>#</y><d>2017-06-04</d><h>02:54</h><w>nathanmarz</w>@michaelwfogleman <code>select-any</code></z><z id="t1496544897" t="nathanmarz or select-first"><y>#</y><d>2017-06-04</d><h>02:54</h><w>nathanmarz</w>or <code>select-first</code></z><z id="t1496544961" t="nathanmarz those are also much more efficient than (first (select ...))"><y>#</y><d>2017-06-04</d><h>02:56</h><w>nathanmarz</w>those are also much more efficient than <code>(first (select ...))</code></z><z id="t1496849945" t="frankmoyer I’ve really enjoyed working with specter over the past couple of days; its code concision in dealing with nested sequences is beautiful. I’ve run into an issue that has gotten me stuck. I have a defnav my-nav that is returning [[] [] [[&quot;a&quot; {:x &quot;y&quot;}]]] . I cannot figure out a way to remove the empty sequences from the defnav before returning it. I’ve read through recent posts on using (setval [ALL nil?] NONE m) , however that only works when used outside the defnav . Also, when I place FIRST in a path after my-nav like (select [my-nav FIRST] m) , it removes the empty vectors. However, when I place that FIRST at the last part of the navigator within my-nav , it does not remove them. Any ideas on why specter behaves this way and any way around it?"><y>#</y><d>2017-06-07</d><h>15:39</h><w>frankmoyer</w>I’ve really enjoyed working with specter over the past couple of days; its code concision in dealing with nested sequences is beautiful. I’ve run into an issue that has gotten me stuck.

I have a <code>defnav my-nav</code> that is returning <code>[[] [] [[&quot;a&quot; {:x &quot;y&quot;}]]]</code>. I cannot figure out a way to remove the empty sequences from the <code>defnav</code> before returning it. I’ve read through recent posts on using <code>(setval [ALL nil?] NONE m)</code>, however that only works when used outside the <code>defnav</code>. Also, when I place <code>FIRST</code> in a path after <code>my-nav</code> like <code>(select [my-nav FIRST] m)</code>, it removes the empty vectors. However, when I place that <code>FIRST</code> at the last part of the navigator within <code>my-nav</code>, it does not remove them. Any ideas on why specter behaves this way and any way around it?</z><z id="t1496850445" t="nathanmarz @frankmoyer what is the definition of my-nav ?"><y>#</y><d>2017-06-07</d><h>15:47</h><w>nathanmarz</w>@frankmoyer what is the definition of <code>my-nav</code>?</z><z id="t1496850612" t="frankmoyer @nathanmarz (sp/defnav previously-assigned-not-finished [user get-time completion-time-limit] (select* [this structure next-fn] (next-fn (sp/select (sp/selected? ;; return the matching keys-value pairs from this point [sp/LAST ;; pick the map value (now in vector form) :assignments ;; select :assignments entry (sp/must annotator) ;; only the ones assigned to this user (sp/selected? ;; pass through the assignments to both next [(sp/must :assigned) ;; get the assigned entry ;; check that the time limit has not passed #(&gt; completion-time-limit (- (get-time) %))]) (sp/not-selected? ;; exclude when finished (sp/multi-path (sp/must :complete) (sp/must :flagged-for-review) (sp/must :incomplete)))]) structure))) (transform* [this structure next-fn] (next-fn [structure annotator]))) Any other advice is appreciated; I just started working with Specter yesterday."><y>#</y><d>2017-06-07</d><h>15:50</h><w>frankmoyer</w>@nathanmarz 

<pre>(sp/defnav previously-assigned-not-finished
  [user get-time completion-time-limit]
  (select* [this structure next-fn]
    (next-fn
      (sp/select
        (sp/selected? ;; return the matching keys-value pairs from this point
          [sp/LAST ;; pick the map value (now in vector form)
           :assignments ;; select :assignments entry
           (sp/must annotator) ;; only the ones assigned to this user
           (sp/selected? ;; pass through the assignments to both next
             [(sp/must :assigned) ;; get the assigned entry
             ;; check that the time limit has not passed
             #(&gt; completion-time-limit (- (get-time) %))])
             (sp/not-selected? ;; exclude when finished
               (sp/multi-path
                 (sp/must :complete)
                 (sp/must :flagged-for-review)
                 (sp/must :incomplete)))])
      structure)))
  (transform* [this structure next-fn]
        (next-fn [structure annotator])))
</pre>

Any other advice is appreciated; I just started working with Specter yesterday.</z><z id="t1496850660" t="nathanmarz ok, I suspect you don&apos;t want to be using defnav"><y>#</y><d>2017-06-07</d><h>15:51</h><w>nathanmarz</w>ok, I suspect you don&apos;t want to be using <code>defnav</code></z><z id="t1496850666" t="nathanmarz what are you trying to accomplish with that?"><y>#</y><d>2017-06-07</d><h>15:51</h><w>nathanmarz</w>what are you trying to accomplish with that?</z><z id="t1496850680" t="nathanmarz there seems to be no relation between the select* and transform* codepaths"><y>#</y><d>2017-06-07</d><h>15:51</h><w>nathanmarz</w>there seems to be no relation between the <code>select*</code> and <code>transform*</code> codepaths</z><z id="t1496850893" t="frankmoyer I was hoping not to implement transform* , as all I really need is a parameterized navigator."><y>#</y><d>2017-06-07</d><h>15:54</h><w>frankmoyer</w>I was hoping not to implement <code>transform*</code>, as all I really need is a parameterized navigator.</z><z id="t1496850917" t="nathanmarz for your select* code, you can just accomplish that with a regular defn : (defn previously-assigned-not-finished-path [user get-time completion-time-limit] (path ...) ) "><y>#</y><d>2017-06-07</d><h>15:55</h><w>nathanmarz</w>for your select* code, you can just accomplish that with a regular <code>defn</code>:
<pre>(defn previously-assigned-not-finished-path [user get-time completion-time-limit]
  (path ...)
  )
</pre></z><z id="t1496850947" t="nathanmarz and then use it in any select or transform"><y>#</y><d>2017-06-07</d><h>15:55</h><w>nathanmarz</w>and then use it in any <code>select</code> or <code>transform</code></z><z id="t1496850955" t="frankmoyer :+1:"><y>#</y><d>2017-06-07</d><h>15:55</h><w>frankmoyer</w><b>:+1:</b></z><z id="t1496850975" t="nathanmarz the path itself isn&apos;t navigating anywhere"><y>#</y><d>2017-06-07</d><h>15:56</h><w>nathanmarz</w>the path itself isn&apos;t navigating anywhere</z><z id="t1496850978" t="nathanmarz is that what you want?"><y>#</y><d>2017-06-07</d><h>15:56</h><w>nathanmarz</w>is that what you want?</z><z id="t1496850981" t="nathanmarz it&apos;s just a filter"><y>#</y><d>2017-06-07</d><h>15:56</h><w>nathanmarz</w>it&apos;s just a filter</z><z id="t1496851067" t="nathanmarz selected? stays navigated if the provided path selects at least one value"><y>#</y><d>2017-06-07</d><h>15:57</h><w>nathanmarz</w><code>selected?</code> stays navigated if the provided path selects at least one value</z><z id="t1496851080" t="frankmoyer Yes, it is. I was trying to get more advanced with defining navigators and testing them individually, chaining them together for different filters. Given it is my second day, I think I need to spend a few more cycles with Specter."><y>#</y><d>2017-06-07</d><h>15:58</h><w>frankmoyer</w>Yes, it is. I was trying to get more advanced with defining navigators and testing them individually, chaining them together for different filters. Given it is my second day, I think I need to spend a few more cycles with Specter.</z><z id="t1496851129" t="frankmoyer I have been using selected? a lot because in a map I want to also return the key."><y>#</y><d>2017-06-07</d><h>15:58</h><w>frankmoyer</w>I have been using <code>selected?</code> a lot because in a map I want to also return the key.</z><z id="t1496851151" t="nathanmarz selected? has nothing to do with that"><y>#</y><d>2017-06-07</d><h>15:59</h><w>nathanmarz</w><code>selected?</code> has nothing to do with that</z><z id="t1496851180" t="nathanmarz if you can simplify your example it will be easier to show you the best way to handle it"><y>#</y><d>2017-06-07</d><h>15:59</h><w>nathanmarz</w>if you can simplify your example it will be easier to show you the best way to handle it</z><z id="t1496851182" t="frankmoyer How would you get the full filtered value from the incoming structure?"><y>#</y><d>2017-06-07</d><h>15:59</h><w>frankmoyer</w>How would you get the full filtered value from the incoming structure?</z><z id="t1496851207" t="nathanmarz that question is too generic to answer"><y>#</y><d>2017-06-07</d><h>16:00</h><w>nathanmarz</w>that question is too generic to answer</z><z id="t1496851222" t="nathanmarz try to come up with a simple representative example of your use case"><y>#</y><d>2017-06-07</d><h>16:00</h><w>nathanmarz</w>try to come up with a simple representative example of your use case</z><z id="t1496851232" t="frankmoyer will do. thanks!"><y>#</y><d>2017-06-07</d><h>16:00</h><w>frankmoyer</w>will do. thanks!</z><z id="t1496955435" t="souenzzo @nathanmarz It&apos;s missing on docs that on clojurescript you may need to :require with :refer-macros :all"><y>#</y><d>2017-06-08</d><h>20:57</h><w>souenzzo</w>@nathanmarz It&apos;s missing on docs that on clojurescript you may need to <code>:require</code> with <code>:refer-macros :all</code></z><z id="t1496956804" t="nathanmarz @souenzzo please add to https://github.com/nathanmarz/specter/issues/56"><y>#</y><d>2017-06-08</d><h>21:20</h><w>nathanmarz</w>@souenzzo please add to <a href="https://github.com/nathanmarz/specter/issues/56" target="_blank">https://github.com/nathanmarz/specter/issues/56</a></z><z id="t1497027628" t="michaelwfogleman Apparently reagent implements its own form of atom. Does anyone have any experience getting specter to work with reagent atoms?"><y>#</y><d>2017-06-09</d><h>17:00</h><w>michaelwfogleman</w>Apparently reagent implements its own form of atom. Does anyone have any experience getting specter to work with reagent atoms?</z><z id="t1497029571" t="nathanmarz @michaelwfogleman i&apos;m unfamiliar with reagent, but it sounds like you could make a navigator for it similar to ATOM"><y>#</y><d>2017-06-09</d><h>17:32</h><w>nathanmarz</w>@michaelwfogleman i&apos;m unfamiliar with reagent, but it sounds like you could make a navigator for it similar to <code>ATOM</code></z><z id="t1497285070" t="nathanmarz Released Specter 1.0.2 https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><y>#</y><d>2017-06-12</d><h>16:31</h><w>nathanmarz</w>Released Specter 1.0.2 <a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md" target="_blank">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></z><z id="t1497290964" t="souenzzo For ALL transforms on maps, interpret transformed key/value pair of size &lt; 2 as removal REAL AWESOME."><y>#</y><d>2017-06-12</d><h>18:09</h><w>souenzzo</w><code>For ALL transforms on maps, interpret transformed key/value pair of size &lt; 2 as removal</code> REAL AWESOME.</z><z id="t1497432694" t="tcoupland looking for a &apos;stateful collector&apos;, for merging a sequence of values with a value within a nested structure"><y>#</y><d>2017-06-14</d><h>09:31</h><w>tcoupland</w>looking for a &apos;stateful collector&apos;, for merging a sequence of values with a value within a nested structure</z><z id="t1497432704" t="tcoupland something like this: (use &apos;com.rpl.specter) (def o {:a {:x 1} :b {:x 1} :c {:x 1}}) (def i (range 1 10)) (defcollector putseqval [a] (collect-val [this structure] (let [v (first @a)] (swap! a rest) v))) (transform [MAP-VALS MAP-VALS (putseqval (atom i))] + o);; =&gt; {:a {:x 2}, :b {:x 3}, :c {:x 4}} "><y>#</y><d>2017-06-14</d><h>09:31</h><w>tcoupland</w>something like this:
<pre>(use &apos;com.rpl.specter)

(def o {:a {:x 1}
        :b {:x 1}
        :c {:x 1}})

(def i (range 1 10))

(defcollector putseqval
  [a]
  (collect-val 
   [this structure]
   (let [v (first @a)]
     (swap! a rest)
     v)))

(transform
 [MAP-VALS MAP-VALS (putseqval (atom i))] 
 +
 o);; =&gt; {:a {:x 2}, :b {:x 3}, :c {:x 4}}
</pre></z><z id="t1497432726" t="tcoupland anybody have any better ideas? 🙂"><y>#</y><d>2017-06-14</d><h>09:32</h><w>tcoupland</w>anybody have any better ideas? <b>🙂</b></z><z id="t1497450329" t="nathanmarz @tcoupland use subselect"><y>#</y><d>2017-06-14</d><h>14:25</h><w>nathanmarz</w>@tcoupland use <code>subselect</code></z></g><g id="s13"><z id="t1497450351" t="nathanmarz (setval (subselect MAP-VALS MAP-VALS) [2 3 4] o)"><y>#</y><d>2017-06-14</d><h>14:25</h><w>nathanmarz</w><code>(setval (subselect MAP-VALS MAP-VALS) [2 3 4] o)</code></z><z id="t1497450538" t="tcoupland can i work that into the transform?"><y>#</y><d>2017-06-14</d><h>14:28</h><w>tcoupland</w>can i work that into the transform?</z><z id="t1497450936" t="nathanmarz @tcoupland what do you mean?"><y>#</y><d>2017-06-14</d><h>14:35</h><w>nathanmarz</w>@tcoupland what do you mean?</z><z id="t1497451017" t="tcoupland i want to execute a function (+) on the value in the datastructure (o) and values from the sequence (i)"><y>#</y><d>2017-06-14</d><h>14:36</h><w>tcoupland</w>i want to execute a function (+) on the value in the datastructure (o) and values from the sequence (i)</z><z id="t1497451065" t="nathanmarz transform on the subselect will be on the sequence of values"><y>#</y><d>2017-06-14</d><h>14:37</h><w>nathanmarz</w><code>transform</code> on the subselect will be on the sequence of values</z><z id="t1497451071" t="nathanmarz so you can combine the two sequences easily"><y>#</y><d>2017-06-14</d><h>14:37</h><w>nathanmarz</w>so you can combine the two sequences easily</z><z id="t1497451126" t="nathanmarz (transform (subselect MAP-VALS MAP-VALS) (fn [s] (map + s [2 3 4])) o)"><y>#</y><d>2017-06-14</d><h>14:38</h><w>nathanmarz</w><code>(transform (subselect MAP-VALS MAP-VALS) (fn [s] (map + s [2 3 4])) o)</code></z><z id="t1497451366" t="tcoupland clearly i do not grok subselect 🙂"><y>#</y><d>2017-06-14</d><h>14:42</h><w>tcoupland</w>clearly i do not grok subselect <b>🙂</b></z><z id="t1497451373" t="tcoupland thank you nathan 🙇"><y>#</y><d>2017-06-14</d><h>14:42</h><w>tcoupland</w>thank you nathan <b>🙇</b></z><z id="t1497451498" t="nathanmarz i recommend toying around with the size of transformed sequence to fully understand its behavior"><y>#</y><d>2017-06-14</d><h>14:44</h><w>nathanmarz</w>i recommend toying around with the size of transformed sequence to fully understand its behavior</z><z id="t1497455665" t="tcoupland do collect and subselect play nicely together?"><y>#</y><d>2017-06-14</d><h>15:54</h><w>tcoupland</w>do collect and subselect play nicely together?</z><z id="t1497455679" t="tcoupland getting an arity exception in terminal*"><y>#</y><d>2017-06-14</d><h>15:54</h><w>tcoupland</w>getting an arity exception in terminal*</z><z id="t1497455712" t="tcoupland for my function i also need the map keys, trying to collect them on the way"><y>#</y><d>2017-06-14</d><h>15:55</h><w>tcoupland</w>for my function i also need the map keys, trying to collect them on the way</z><z id="t1497455777" t="tcoupland (transform [(subselect MAP-VALS (collect FIRST FIRST) MAP-VALS)] (fn [fnd] (prn (map (fn [[k v] r] (str k v r)) fnd i))) o) "><y>#</y><d>2017-06-14</d><h>15:56</h><w>tcoupland</w><pre>(transform [(subselect MAP-VALS (collect FIRST FIRST) MAP-VALS)]
           (fn [fnd] (prn (map (fn [[k v] r] (str k v r)) fnd  i))) 
           o)
</pre></z><z id="t1497455794" t="tcoupland Wrong number of args (2) passed to: specter/fn--38572/fn/reify--38574/fn--38579 AFn.java: 429 clojure.lang.AFn/throwArity AFn.java: 36 clojure.lang.AFn/invoke AFn.java: 156 clojure.lang.AFn/applyToHelper AFn.java: 144 clojure.lang.AFn/applyTo core.clj: 657 clojure.core/apply core.clj: 652 clojure.core/apply impl.cljc: 406 com.rpl.specter.impl$terminal_STAR_/invokeStatic impl.cljc: 403 com.rpl.specter.impl$terminal_STAR_/invoke impl.cljc: 413 com.rpl.specter.impl$compiled_transform_STAR_$fn__36780/invoke specter.cljc: 673 com.rpl.specter$reify__38443$next_fn__38449/invoke "><y>#</y><d>2017-06-14</d><h>15:56</h><w>tcoupland</w><pre>Wrong number of args (2) passed to:
   specter/fn--38572/fn/reify--38574/fn--38579

                  AFn.java:  429  clojure.lang.AFn/throwArity
                  AFn.java:   36  clojure.lang.AFn/invoke
                  AFn.java:  156  clojure.lang.AFn/applyToHelper
                  AFn.java:  144  clojure.lang.AFn/applyTo
                  core.clj:  657  clojure.core/apply
                  core.clj:  652  clojure.core/apply
                 impl.cljc:  406  com.rpl.specter.impl$terminal_STAR_/invokeStatic
                 impl.cljc:  403  com.rpl.specter.impl$terminal_STAR_/invoke
                 impl.cljc:  413  com.rpl.specter.impl$compiled_transform_STAR_$fn__36780/invoke
              specter.cljc:  673  com.rpl.specter$reify__38443$next_fn__38449/invoke
</pre></z><z id="t1497455821" t="tcoupland the prn in the transform function get&apos;s fired and looks right, but then the exception happens"><y>#</y><d>2017-06-14</d><h>15:57</h><w>tcoupland</w>the prn in the transform function get&apos;s fired and looks right, but then the exception happens</z><z id="t1497456084" t="tcoupland hm, works in a select, but not in the transform"><y>#</y><d>2017-06-14</d><h>16:01</h><w>tcoupland</w>hm, works in a select, but not in the transform</z><z id="t1497456578" t="nathanmarz @tcoupland don&apos;t use value collection in subselect"><y>#</y><d>2017-06-14</d><h>16:09</h><w>nathanmarz</w>@tcoupland don&apos;t use value collection in <code>subselect</code></z><z id="t1497456615" t="nathanmarz i&apos;ll put a note about that in its documentation"><y>#</y><d>2017-06-14</d><h>16:10</h><w>nathanmarz</w>i&apos;ll put a note about that in its documentation</z><z id="t1497561929" t="timgilbert Hey, I&apos;ve got a newbie question. I have a big arbitrarily-nested ball of data (vectors, maps, etc). I want to traverse it looking for maps that pass a certain predicate, and then assoc a new key into those maps."><y>#</y><d>2017-06-15</d><h>21:25</h><w>timgilbert</w>Hey, I&apos;ve got a newbie question. I have a big arbitrarily-nested ball of data (vectors, maps, etc). I want to traverse it looking for maps that pass a certain predicate, and then assoc a new key into those maps.</z><z id="t1497561953" t="timgilbert Here&apos;s what my current implementation looks like: (defn decorate &quot;walk/postwalk version of above that adds get urls in-place&quot; [data] (walk/postwalk (fn [item] (if-not (right-thing? item) item (my-transform item))) data)) "><y>#</y><d>2017-06-15</d><h>21:25</h><w>timgilbert</w>Here&apos;s what my current implementation looks like:
<pre>(defn decorate
  &quot;walk/postwalk version of above that adds get urls in-place&quot;
  [data]
  (walk/postwalk
   (fn [item]
     (if-not (right-thing? item)
       item
       (my-transform item)))
   data))
</pre></z><z id="t1497561983" t="timgilbert Can someone advise me on what the equivalent specter calls would be?"><y>#</y><d>2017-06-15</d><h>21:26</h><w>timgilbert</w>Can someone advise me on what the equivalent specter calls would be?</z><z id="t1497562638" t="nathanmarz @timgilbert it would look something like (setval [(walker right-thing?) :my-new-key] my-new-val data)"><y>#</y><d>2017-06-15</d><h>21:37</h><w>nathanmarz</w>@timgilbert it would look something like <code>(setval [(walker right-thing?) :my-new-key] my-new-val data)</code></z><z id="t1497562827" t="nathanmarz or to match your code exactly (transform (walker right-thing?) my-transform data)"><y>#</y><d>2017-06-15</d><h>21:40</h><w>nathanmarz</w>or to match your code exactly <code>(transform (walker right-thing?) my-transform data)</code></z><z id="t1497562851" t="nathanmarz depending on what my-transform is you may be able to express it within the path"><y>#</y><d>2017-06-15</d><h>21:40</h><w>nathanmarz</w>depending on what <code>my-transform</code> is you may be able to express it within the path</z><z id="t1497562890" t="timgilbert It&apos;s basically just (assoc my-map :my/key (other-fn my-map))"><y>#</y><d>2017-06-15</d><h>21:41</h><w>timgilbert</w>It&apos;s basically just <code>(assoc my-map :my/key (other-fn my-map))</code></z><z id="t1497562980" t="nathanmarz you can do (transform [(walker right-thing?) (collect-one (view other-fn)) :my/key] (fn [m _] m) data)"><y>#</y><d>2017-06-15</d><h>21:43</h><w>nathanmarz</w>you can do <code>(transform [(walker right-thing?) (collect-one (view other-fn)) :my/key] (fn [m _] m) data)</code></z><z id="t1497563017" t="timgilbert Cool. Thanks for the help, I&apos;ll play around with it some. I&apos;m benchmarking a few different approaches"><y>#</y><d>2017-06-15</d><h>21:43</h><w>timgilbert</w>Cool. Thanks for the help, I&apos;ll play around with it some. I&apos;m benchmarking a few different approaches</z><z id="t1497563064" t="nathanmarz the walker in latest specter release is a lot faster than clojure.walk and has same functionality"><y>#</y><d>2017-06-15</d><h>21:44</h><w>nathanmarz</w>the <code>walker</code> in latest specter release is a lot faster than clojure.walk and has same functionality</z><z id="t1497563080" t="nathanmarz i benchmarked 70% improvement"><y>#</y><d>2017-06-15</d><h>21:44</h><w>nathanmarz</w>i benchmarked 70% improvement</z><z id="t1497563116" t="timgilbert Cool. I&apos;ll let you know how it turns out"><y>#</y><d>2017-06-15</d><h>21:45</h><w>timgilbert</w>Cool. I&apos;ll let you know how it turns out</z><z id="t1497564068" t="timgilbert FWIW, I&apos;m seeing about the same speeds on my test data set, which has a lot of stuff I don&apos;t care (about 750K of EDN) about and 0-90 target maps"><y>#</y><d>2017-06-15</d><h>22:01</h><w>timgilbert</w>FWIW, I&apos;m seeing about the same speeds on my test data set, which has a lot of stuff I don&apos;t care (about 750K of EDN) about and 0-90 target maps</z><z id="t1497564097" t="nathanmarz care to share your benchmark code?"><y>#</y><d>2017-06-15</d><h>22:01</h><w>nathanmarz</w>care to share your benchmark code?</z><z id="t1497564156" t="timgilbert It would take me some time to clean it up and put it into a gist, but I&apos;ll try to do it tomorrow afternoon sometime"><y>#</y><d>2017-06-15</d><h>22:02</h><w>timgilbert</w>It would take me some time to clean it up and put it into a gist, but I&apos;ll try to do it tomorrow afternoon sometime</z><z id="t1497564197" t="timgilbert But it&apos;s basically running criterium against a bunch of random data from an EDN file plus a bunch of generated data from specs"><y>#</y><d>2017-06-15</d><h>22:03</h><w>timgilbert</w>But it&apos;s basically running criterium against a bunch of random data from an EDN file plus a bunch of generated data from specs</z><z id="t1497564297" t="timgilbert The context is I need to go through a potentially large API response and decorate some data with derived values, and I&apos;m trying to see how much of a perf hit I&apos;m setting myself up for"><y>#</y><d>2017-06-15</d><h>22:04</h><w>timgilbert</w>The context is I need to go through a potentially large API response and decorate some data with derived values, and I&apos;m trying to see how much of a perf hit I&apos;m setting myself up for</z><z id="t1497564333" t="nathanmarz i&apos;d be curious to see benchmark of (transform (walker right-thing?) my-transform data) approach as well (without using collect-one )"><y>#</y><d>2017-06-15</d><h>22:05</h><w>nathanmarz</w>i&apos;d be curious to see benchmark of <code>(transform (walker right-thing?) my-transform data)</code> approach as well (without using <code>collect-one</code>)</z><z id="t1497564681" t="timgilbert Looks like about the same. In my benchmarks I&apos;ve got 0.2927 for the collect-one version, 0.2994 for the transform one and 0.2962 for the postwalk version"><y>#</y><d>2017-06-15</d><h>22:11</h><w>timgilbert</w>Looks like about the same. In my benchmarks I&apos;ve got 0.2927 for the collect-one version, 0.2994 for the transform one and 0.2962 for the postwalk version</z><z id="t1497564729" t="timgilbert (I&apos;m not going absolutely crazy with the methodology here, I should note, just looking for back-of-the-envelope stuff)"><y>#</y><d>2017-06-15</d><h>22:12</h><w>timgilbert</w>(I&apos;m not going absolutely crazy with the methodology here, I should note, just looking for back-of-the-envelope stuff)</z><z id="t1497564781" t="nathanmarz if your target maps are never within another map&apos;s keys, you can gain big performance improvement by using a custom recursive path"><y>#</y><d>2017-06-15</d><h>22:13</h><w>nathanmarz</w>if your target maps are never within another map&apos;s keys, you can gain big performance improvement by using a custom recursive path</z><z id="t1497564812" t="timgilbert Sadly, they are deeply and somewhat arbitrarily nested"><y>#</y><d>2017-06-15</d><h>22:13</h><w>timgilbert</w>Sadly, they are deeply and somewhat arbitrarily nested</z><z id="t1497564827" t="timgilbert (Which is something I&apos;m looking to fix but that&apos;s another story)"><y>#</y><d>2017-06-15</d><h>22:13</h><w>timgilbert</w>(Which is something I&apos;m looking to fix but that&apos;s another story)</z><z id="t1497564828" t="nathanmarz (def optimized-walker (recursive-path [afn] p (cond-path (pred afn) STAY map? [MAP-VALS p] coll? [ALL p] ))) "><y>#</y><d>2017-06-15</d><h>22:13</h><w>nathanmarz</w><pre>(def optimized-walker
  (recursive-path [afn] p
    (cond-path (pred afn) STAY
               map? [MAP-VALS p]
               coll? [ALL p]
               )))
</pre></z><z id="t1497564844" t="nathanmarz the data has maps within map keys?"><y>#</y><d>2017-06-15</d><h>22:14</h><w>nathanmarz</w>the data has maps within map keys?</z><z id="t1497564863" t="nathanmarz e.g. {[{:a 1}] 2}"><y>#</y><d>2017-06-15</d><h>22:14</h><w>nathanmarz</w>e.g. <code>{[{:a 1}] 2}</code></z><z id="t1497564943" t="timgilbert Yeah, so it could be like {:company &quot;foo&quot; :people [{:person &quot;bob&quot; :avatar {:type :thumbnail :image-path &quot;/dir/file.png&quot;}}]}"><y>#</y><d>2017-06-15</d><h>22:15</h><w>timgilbert</w>Yeah, so it could be like <code>{:company &quot;foo&quot; :people [{:person &quot;bob&quot; :avatar {:type :thumbnail :image-path &quot;/dir/file.png&quot;}}]}</code></z><z id="t1497564955" t="timgilbert I&apos;m looking for :image-path"><y>#</y><d>2017-06-15</d><h>22:15</h><w>timgilbert</w>I&apos;m looking for <code>:image-path</code></z><z id="t1497565004" t="timgilbert But it could also be {:product &quot;foo&quot; :images [{:type :product-img :image-path &quot;foo-bar&quot;}]}"><y>#</y><d>2017-06-15</d><h>22:16</h><w>timgilbert</w>But it could also be <code>{:product &quot;foo&quot; :images [{:type :product-img :image-path &quot;foo-bar&quot;}]}</code></z><z id="t1497565012" t="nathanmarz yea, use optimized-walker"><y>#</y><d>2017-06-15</d><h>22:16</h><w>nathanmarz</w>yea, use <code>optimized-walker</code></z><z id="t1497565015" t="timgilbert ...and those things can all nest in various ways"><y>#</y><d>2017-06-15</d><h>22:16</h><w>timgilbert</w>...and those things can all nest in various ways</z><z id="t1497565039" t="nathanmarz avoiding traversing over key/value pairs and keys should be very significant"><y>#</y><d>2017-06-15</d><h>22:17</h><w>nathanmarz</w>avoiding traversing over key/value pairs and keys should be very significant</z><z id="t1497565074" t="timgilbert Cool. Thanks again for the help. I&apos;ll play around with it more tomorrow and let you know if I kick up anything interesting"><y>#</y><d>2017-06-15</d><h>22:17</h><w>timgilbert</w>Cool. Thanks again for the help. I&apos;ll play around with it more tomorrow and let you know if I kick up anything interesting</z><z id="t1497565102" t="nathanmarz sure thing"><y>#</y><d>2017-06-15</d><h>22:18</h><w>nathanmarz</w>sure thing</z><z id="t1498751608" t="enn Hello … I’m wondering if I’m missing an obvious way to do sorting and/or selecting minimum/maximum values with Specter? I think I could do it with view or transformed and a function that takes the whole array and just does the min/max in Clojure, but is there a more Specter-y (spectral?) way?"><y>#</y><d>2017-06-29</d><h>15:53</h><w>enn</w>Hello … I’m wondering if I’m missing an obvious way to do sorting and/or selecting minimum/maximum values with Specter? I think I could do it with <code>view</code> or <code>transformed</code> and a function that takes  the whole array and just does the min/max in Clojure, but is there a more Specter-y (spectral?) way?</z><z id="t1498752237" t="enn Hmm, it looks like view or transformed will not do what I want because the provided functions get applied to each value matching my ALL selector, rather than the sequence of matching values."><y>#</y><d>2017-06-29</d><h>16:03</h><w>enn</w>Hmm, it looks like <code>view</code> or <code>transformed</code> will not do what I want because the provided functions get applied to each value matching my <code>ALL</code> selector, rather than the sequence of matching values.</z><z id="t1498752442" t="nathanmarz @enn if it&apos;s not already sorted in your data structure, you would need to do (view sort)"><y>#</y><d>2017-06-29</d><h>16:07</h><w>nathanmarz</w>@enn if it&apos;s not already sorted in your data structure, you would need to do <code>(view sort)</code></z><z id="t1498752493" t="nathanmarz if the values are spread throughout your data structure (not together in a sequence), you can first do (subselect &lt;path&gt;) to manipulate them as a single sequence"><y>#</y><d>2017-06-29</d><h>16:08</h><w>nathanmarz</w>if the values are spread throughout your data structure (not together in a sequence), you can first do <code>(subselect &lt;path&gt;)</code>  to manipulate them as a single sequence</z><z id="t1498752629" t="enn @nathanmarz aha, thank you, I will look at subselect"><y>#</y><d>2017-06-29</d><h>16:10</h><w>enn</w>@nathanmarz aha, thank you, I will look at <code>subselect</code></z><z id="t1499206934" t="sophiago Not expecting an answer today, but figured I&apos;d put this out there since I couldn&apos;t figure it out from the wiki this weekend: is there a way to just call select on a sequence of keys? I would expect to at least be able to do something like this unless there&apos;s a simpler way, but it returns all kv pairs: (select [ALL (fn [[k v]] (map #(= k %) [2 3]))] {1 :a, 2 :b, 3, :c, 4 :d})"><y>#</y><d>2017-07-04</d><h>22:22</h><w>sophiago</w>Not expecting an answer today, but figured I&apos;d put this out there since I couldn&apos;t figure it out from the wiki this weekend: is there a way to just call <code>select</code> on a sequence of keys? I would expect to at least be able to do something like this unless there&apos;s a simpler way, but it returns all kv pairs: <code>(select [ALL (fn [[k v]] (map #(= k %) [2 3]))] {1 :a, 2 :b, 3, :c, 4 :d})</code></z><z id="t1499207007" t="sophiago I&apos;m also wondering if, after selecting based on keys, Specter has a faster way to return just the values than val from clojure.core?"><y>#</y><d>2017-07-04</d><h>22:23</h><w>sophiago</w>I&apos;m also wondering if, after selecting based on keys, Specter has a faster way to return just the values than <code>val</code> from clojure.core?</z><z id="t1499208998" t="nathanmarz @sophiago I think you&apos;re looking for (select [(submap [2 3]) MAP-VALS] {1 :a 2 :b 3 :c 4 :d})"><y>#</y><d>2017-07-04</d><h>22:56</h><w>nathanmarz</w>@sophiago I think you&apos;re looking for <code>(select [(submap [2 3]) MAP-VALS] {1 :a 2 :b 3 :c 4 :d})</code></z><z id="t1499209030" t="nathanmarz or possibly (select (multi-path (keypath 2) (keypath 3)) {1 :a 2 :b 3 :c 4 :d})"><y>#</y><d>2017-07-04</d><h>22:57</h><w>nathanmarz</w>or possibly <code>(select (multi-path (keypath 2) (keypath 3)) {1 :a 2 :b 3 :c 4 :d})</code></z><z id="t1499209064" t="sophiago Thanks for responding, Nathan! Probably the first one, unless there&apos;s a performance difference?"><y>#</y><d>2017-07-04</d><h>22:57</h><w>sophiago</w>Thanks for responding, Nathan! Probably the first one, unless there&apos;s a performance difference?</z><z id="t1499209081" t="nathanmarz the latter should be faster"><y>#</y><d>2017-07-04</d><h>22:58</h><w>nathanmarz</w>the latter should be faster</z><z id="t1499209093" t="nathanmarz but the former works with a dynamic sequence of keys"><y>#</y><d>2017-07-04</d><h>22:58</h><w>nathanmarz</w>but the former works with a dynamic sequence of keys</z><z id="t1499209120" t="sophiago Can&apos;t I just map keypath over a sequence of keys?"><y>#</y><d>2017-07-04</d><h>22:58</h><w>sophiago</w>Can&apos;t I just map keypath over a sequence of keys?</z><z id="t1499209157" t="nathanmarz yes, but that won&apos;t perform optimally at the moment"><y>#</y><d>2017-07-04</d><h>22:59</h><w>nathanmarz</w>yes, but that won&apos;t perform optimally at the moment</z><z id="t1499209158" t="nathanmarz https://github.com/nathanmarz/specter/issues/200"><y>#</y><d>2017-07-04</d><h>22:59</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/issues/200" target="_blank">https://github.com/nathanmarz/specter/issues/200</a></z><z id="t1499209170" t="nathanmarz both keypath and multi-path are dynamic navs"><y>#</y><d>2017-07-04</d><h>22:59</h><w>nathanmarz</w>both <code>keypath</code> and <code>multi-path</code> are dynamic navs</z><z id="t1499209224" t="sophiago I see. So the fastest way is with submap until that issue is closed?"><y>#</y><d>2017-07-04</d><h>23:00</h><w>sophiago</w>I see. So the fastest way is with <code>submap</code> until that issue is closed?</z><z id="t1499209252" t="nathanmarz you&apos;d have to benchmark to be sure, but that would be my guess"><y>#</y><d>2017-07-04</d><h>23:00</h><w>nathanmarz</w>you&apos;d have to benchmark to be sure, but that would be my guess</z><z id="t1499209266" t="sophiago Great. Thanks!"><y>#</y><d>2017-07-04</d><h>23:01</h><w>sophiago</w>Great. Thanks!</z><z id="t1499209275" t="nathanmarz actually"><y>#</y><d>2017-07-04</d><h>23:01</h><w>nathanmarz</w>actually</z><z id="t1499209312" t="nathanmarz you can do this: (map #(select-any (keypath %) data) key-seq)"><y>#</y><d>2017-07-04</d><h>23:01</h><w>nathanmarz</w>you can do this: <code>(map #(select-any (keypath %) data) key-seq)</code></z><z id="t1499209340" t="nathanmarz nevermind"><y>#</y><d>2017-07-04</d><h>23:02</h><w>nathanmarz</w>nevermind</z><z id="t1499209360" t="nathanmarz if performance is critical just do (map #(get data %) key-seq)"><y>#</y><d>2017-07-04</d><h>23:02</h><w>nathanmarz</w>if performance is critical just do <code>(map #(get data %) key-seq)</code></z><z id="t1499209514" t="sophiago Ok, got it. I&apos;ll run some microbenchmarks to be sure as well."><y>#</y><d>2017-07-04</d><h>23:05</h><w>sophiago</w>Ok, got it. I&apos;ll run some microbenchmarks to be sure as well.</z><z id="t1499780585" t="mbjarland lets say I have the following data structure: {:2010-12-31 [{:name &quot;New Year&apos;s Eve&quot;, :date &quot;2010-12-31&quot;, :observed &quot;2010-12-31&quot;, :public true}], :2010-12-25 [{:name &quot;Christmas Day&quot;, :date &quot;2010-12-25&quot;, :observed &quot;2010-12-24&quot;, :public true}], :2010-05-31 [{:name &quot;Memorial Day&quot;, :date &quot;2010-05-31&quot;, :observed &quot;2010-05-31&quot;, :public true}], :2010-11-25 [{:name &quot;Thanksgiving Day&quot;, :date &quot;2010-11-25&quot;, :observed &quot;2010-11-25&quot;, :public true}], :2010-09-06 [{:name &quot;Labor Day&quot;, :date &quot;2010-09-06&quot;, :observed &quot;2010-09-06&quot;, :public true}], :2010-01-01 [{:name &quot;New Year&apos;s Day&quot;, :date &quot;2010-01-01&quot;, :observed &quot;2010-01-01&quot;, :public true}], :2010-07-04 [{:name &quot;Independence Day&quot;, :date &quot;2010-07-04&quot;, :observed &quot;2010-07-05&quot;, :public true}], :2010-11-11 [{:name &quot;Veterans Day&quot;, :date &quot;2010-11-11&quot;, :observed &quot;2010-11-11&quot;, :public true}], :2010-02-15 [{:name &quot;George Washington&apos;s Birthday&quot;, :date &quot;2010-02-15&quot;, :observed &quot;2010-02-15&quot;, :public true}], :2010-01-18 [{:name &quot;Martin Luther King, Jr. Day&quot;, :date &quot;2010-01-18&quot;, :observed &quot;2010-01-18&quot;, :public true}], :2010-10-11 [{:name &quot;Columbus Day&quot;, :date &quot;2010-10-11&quot;, :observed &quot;2010-10-11&quot;, :public true}]} and I would like to apply a function to all the dates (root level key and :date and :observed in the inner map). I got as far as using multi-transform on the root level keys but I&apos;m failing at writing the rest of the path expression. I can do the first level with: (multi-transform [MAP-KEYS (terminal my-tranform-fn)] data) how would I go about transforming the other two dates in the data?"><y>#</y><d>2017-07-11</d><h>13:43</h><w>mbjarland</w>lets say I have the following data structure: 
<pre>{:2010-12-31 [{:name &quot;New Year&apos;s Eve&quot;, :date &quot;2010-12-31&quot;, :observed &quot;2010-12-31&quot;, :public true}],
 :2010-12-25 [{:name &quot;Christmas Day&quot;, :date &quot;2010-12-25&quot;, :observed &quot;2010-12-24&quot;, :public true}],
 :2010-05-31 [{:name &quot;Memorial Day&quot;, :date &quot;2010-05-31&quot;, :observed &quot;2010-05-31&quot;, :public true}],
 :2010-11-25 [{:name &quot;Thanksgiving Day&quot;, :date &quot;2010-11-25&quot;, :observed &quot;2010-11-25&quot;, :public true}],
 :2010-09-06 [{:name &quot;Labor Day&quot;, :date &quot;2010-09-06&quot;, :observed &quot;2010-09-06&quot;, :public true}],
 :2010-01-01 [{:name &quot;New Year&apos;s Day&quot;, :date &quot;2010-01-01&quot;, :observed &quot;2010-01-01&quot;, :public true}],
 :2010-07-04 [{:name &quot;Independence Day&quot;, :date &quot;2010-07-04&quot;, :observed &quot;2010-07-05&quot;, :public true}],
 :2010-11-11 [{:name &quot;Veterans Day&quot;, :date &quot;2010-11-11&quot;, :observed &quot;2010-11-11&quot;, :public true}],
 :2010-02-15 [{:name &quot;George Washington&apos;s Birthday&quot;, :date &quot;2010-02-15&quot;, :observed &quot;2010-02-15&quot;, :public true}],
 :2010-01-18 [{:name &quot;Martin Luther King, Jr. Day&quot;, :date &quot;2010-01-18&quot;, :observed &quot;2010-01-18&quot;, :public true}],
 :2010-10-11 [{:name &quot;Columbus Day&quot;, :date &quot;2010-10-11&quot;, :observed &quot;2010-10-11&quot;, :public true}]}
</pre>
and I would like to apply a function to all the dates (root level key and <code>:date</code> and <code>:observed</code> in the inner map). I got as far as using <code>multi-transform</code> on the root level keys but I&apos;m failing at writing the rest of the path expression. I can do the first level with: 
<pre>(multi-transform [MAP-KEYS (terminal my-tranform-fn)] data)
</pre>
how would I go about transforming the other two dates in the data?</z><z id="t1499781202" t="mbjarland ok I think I got it, somebody please tell me if there is a better way: (multi-transform [(multi-path [MAP-VALS ALL (multi-path [:date (terminal my-transform-fn)] [:observed (terminal my-transform-fn)])] [MAP-KEYS (terminal my-transform-fn)])] data) "><y>#</y><d>2017-07-11</d><h>13:53</h><w>mbjarland</w>ok I think I got it, somebody please tell me if there is a better way: 
<pre>(multi-transform [(multi-path [MAP-VALS ALL (multi-path [:date (terminal my-transform-fn)]
                                                        [:observed (terminal my-transform-fn)])]
                              [MAP-KEYS (terminal my-transform-fn)])] data)
</pre></z><z id="t1499782376" t="nathanmarz @mbjarland this is better: (transform (multi-path MAP-KEYS [MAP-VALS ALL (multi-path :date :observed)]) my-transform-fn data)"><y>#</y><d>2017-07-11</d><h>14:12</h><w>nathanmarz</w>@mbjarland this is better: <code>(transform (multi-path MAP-KEYS [MAP-VALS ALL (multi-path :date :observed)]) my-transform-fn data)</code></z><z id="t1499782522" t="nathanmarz multi-transform is more for when you have distinct transformations you want to run on the same structure"><y>#</y><d>2017-07-11</d><h>14:15</h><w>nathanmarz</w><code>multi-transform</code> is more for when you have distinct transformations you want to run on the same structure</z><z id="t1499782627" t="mbjarland : ) figured there would be a better way...so just transform ....when would I use multi-transform ?"><y>#</y><d>2017-07-11</d><h>14:17</h><w>mbjarland</w>: ) figured there would be a better way...so just <code>transform</code>....when would I use <code>multi-transform</code>?</z><z id="t1499782684" t="nathanmarz e.g. (multi-transform [ALL (multi-path [:a (terminal inc)] [:b (terminal dec)])] data)"><y>#</y><d>2017-07-11</d><h>14:18</h><w>nathanmarz</w>e.g. <code>(multi-transform [ALL (multi-path [:a (terminal inc)] [:b (terminal dec)])] data)</code></z><z id="t1499782715" t="nathanmarz another good example: https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L342"><y>#</y><d>2017-07-11</d><h>14:18</h><w>nathanmarz</w>another good example: <a href="https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L342" target="_blank">https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L342</a></z><z id="t1499782741" t="nathanmarz if the transformation functions are distinct and there&apos;s any shared navigation, multi-transform will be more efficient"><y>#</y><d>2017-07-11</d><h>14:19</h><w>nathanmarz</w>if the transformation functions are distinct and there&apos;s any shared navigation, <code>multi-transform</code> will be more efficient</z><z id="t1499782805" t="mbjarland ah so forking paths which shared ancestry are a good candidate"><y>#</y><d>2017-07-11</d><h>14:20</h><w>mbjarland</w>ah so forking paths which shared ancestry are a good candidate</z><z id="t1499782805" t="nathanmarz in your case each date location is transformed the same way, so cleaner to navigate to each date as a single path"><y>#</y><d>2017-07-11</d><h>14:20</h><w>nathanmarz</w>in your case each date location is transformed the same way, so cleaner to navigate to each date as a single path</z><z id="t1499782814" t="nathanmarz yes, that&apos;s right"><y>#</y><d>2017-07-11</d><h>14:20</h><w>nathanmarz</w>yes, that&apos;s right</z><z id="t1499782899" t="mbjarland ok, got it...it seems to me every time I find an excuse to use specter a couple of things happen 1. half my code goes away 2. the end result is beautiful 3. I realize that at least for me, most of the hurdle in specter is to grok paths. Thanks for the pointers"><y>#</y><d>2017-07-11</d><h>14:21</h><w>mbjarland</w>ok, got it...it seems to me every time I find an excuse to use specter a couple of things happen 1. half my code goes away 2. the end result is beautiful 3. I realize that at least for me, most of the hurdle in specter is to grok paths. Thanks for the pointers</z><z id="t1499782923" t="nathanmarz 🙂"><y>#</y><d>2017-07-11</d><h>14:22</h><w>nathanmarz</w><b>🙂</b></z><z id="t1499784418" t="schmee I’m sure this has been asked a million times, but can I use Specter to go from [{:a 1 :b 2} {:a 3 :b 4}] to {:a [1 3] :b [2 4]} ?"><y>#</y><d>2017-07-11</d><h>14:46</h><w>schmee</w>I’m sure this has been asked a million times, but can I use Specter to go from <code>[{:a 1 :b 2} {:a 3 :b 4}]</code> to <code>{:a [1 3] :b [2 4]}</code>?</z><z id="t1499791569" t="nathanmarz @schmee that&apos;s a complete transformation, so should do that with reduce"><y>#</y><d>2017-07-11</d><h>16:46</h><w>nathanmarz</w>@schmee that&apos;s a complete transformation, so should do that with <code>reduce</code></z><z id="t1499791796" t="madstap @schmee I remember seeing a one liner for that that was something like: (defn f [ms] (apply merge-with into (for [m ms, [k v] m] {k [v]})))"><y>#</y><d>2017-07-11</d><h>16:49</h><w>madstap</w>@schmee I remember seeing a one liner for that that was something like: <code>(defn f [ms] (apply merge-with into (for [m ms, [k v] m] {k [v]})))</code></z><z id="t1499794152" t="schmee roger, thanks for the input :+1:"><y>#</y><d>2017-07-11</d><h>17:29</h><w>schmee</w>roger, thanks for the input <b>:+1:</b></z><z id="t1499816144" t="schmee is there a know issue with transform and transients?"><y>#</y><d>2017-07-11</d><h>23:35</h><w>schmee</w>is there a know issue with <code>transform</code> and transients?</z><z id="t1499816192" t="schmee I’m getting java.lang.IllegalAccessError: Transient used after persistent! call at clojure.lang.PersistentVector$TransientVector.ensureEditable(PersistentVector.java:548) at clojure.lang.PersistentVector$TransientVector.persistent(PersistentVector.java:559) at clojure.lang.PersistentVector$TransientVector.persistent(PersistentVector.java:518) at clojure.core$persistent_BANG_.invokeStatic(core.clj:3336) at clojure.core$persistent_BANG_.invoke(core.clj:3329) at com.rpl.specter.impl$terminal_STAR_.invokeStatic(impl.cljc:402) at com.rpl.specter.impl$terminal_STAR_.invoke(impl.cljc:400) at com.rpl.specter.impl$compiled_transform_STAR_$fn__16689.invoke(impl.cljc:410) at com.rpl.specter$reify__18110$next_fn__18116.invoke(specter.cljc:642) at com.rpl.specter.navs$eval17464$fn__17465.invoke(navs.cljc:261) at com.rpl.specter.navs$eval17420$fn__17421$G__17409__17428.invoke(navs.cljc:213) at com.rpl.specter$reify__18110.transform_STAR_(specter.cljc:651) at com.rpl.specter.impl$compiled_transform_STAR_.invokeStatic(impl.cljc:408) at com.rpl.specter.impl$compiled_transform_STAR_.invoke(impl.cljc:407) when using (s/transform s/MAP-VALS persistent! stuff)"><y>#</y><d>2017-07-11</d><h>23:36</h><w>schmee</w>I’m getting 
<pre>java.lang.IllegalAccessError: Transient used after persistent! call
	at clojure.lang.PersistentVector$TransientVector.ensureEditable(PersistentVector.java:548)
	at clojure.lang.PersistentVector$TransientVector.persistent(PersistentVector.java:559)
	at clojure.lang.PersistentVector$TransientVector.persistent(PersistentVector.java:518)
	at clojure.core$persistent_BANG_.invokeStatic(core.clj:3336)
	at clojure.core$persistent_BANG_.invoke(core.clj:3329)
	at com.rpl.specter.impl$terminal_STAR_.invokeStatic(impl.cljc:402)
	at com.rpl.specter.impl$terminal_STAR_.invoke(impl.cljc:400)
	at com.rpl.specter.impl$compiled_transform_STAR_$fn__16689.invoke(impl.cljc:410)
	at com.rpl.specter$reify__18110$next_fn__18116.invoke(specter.cljc:642)
	at com.rpl.specter.navs$eval17464$fn__17465.invoke(navs.cljc:261)
	at com.rpl.specter.navs$eval17420$fn__17421$G__17409__17428.invoke(navs.cljc:213)
	at com.rpl.specter$reify__18110.transform_STAR_(specter.cljc:651)
	at com.rpl.specter.impl$compiled_transform_STAR_.invokeStatic(impl.cljc:408)
	at com.rpl.specter.impl$compiled_transform_STAR_.invoke(impl.cljc:407)
</pre>
when using <code>(s/transform s/MAP-VALS persistent! stuff)</code></z><z id="t1499816222" t="schmee where stuff is a map of keyword to transient vectors"><y>#</y><d>2017-07-11</d><h>23:37</h><w>schmee</w>where <code>stuff</code> is a map of keyword to transient vectors</z><z id="t1499822419" t="nathanmarz @schmee looks fine to me: (transform MAP-VALS persistent! {1 (transient []) 2 (transient [1 2 3])}) ;; =&gt; {1 [], 2 [1 2 3]} "><y>#</y><d>2017-07-12</d><h>01:20</h><w>nathanmarz</w>@schmee looks fine to me:
<pre>(transform MAP-VALS persistent! {1 (transient []) 2 (transient [1 2 3])})
;; =&gt; {1 [], 2 [1 2 3]}
</pre></z><z id="t1499822457" t="nathanmarz there must be another issue with your code"><y>#</y><d>2017-07-12</d><h>01:20</h><w>nathanmarz</w>there must be another issue with your code</z><z id="t1499843643" t="schmee hmm… weird, I’ll see if I can find a minimal case"><y>#</y><d>2017-07-12</d><h>07:14</h><w>schmee</w>hmm… weird, I’ll see if I can find a minimal case</z><z id="t1499848400" t="schmee Two questions: 1. is it possible to return a “subpath” of a path from transform ? e.g. transform [(submap [:a :c]) MAP-VALS] inc {:a 1 :b 2 :c 3} returns {:a 2 :b 2 :c 4} , can you modify the path somehow to make it return {:a 2 :c 4} ? 2. can you “invert” a path? e.g. to make (some-invert-fn (submap [:a :c])) navigate to the map without :a and :c"><y>#</y><d>2017-07-12</d><h>08:33</h><w>schmee</w>Two questions:
1. is it possible to return a “subpath” of a path from <code>transform</code>? e.g. <code>transform [(submap [:a :c]) MAP-VALS] inc {:a 1 :b 2 :c 3}</code> returns <code>{:a 2 :b 2 :c 4}</code>, can you modify the path somehow to make it return <code>{:a 2 :c 4}</code>?
2. can you “invert” a path? e.g. to make <code>(some-invert-fn (submap [:a :c]))</code> navigate to the map without <code>:a</code> and <code>:c</code></z><z id="t1499861586" t="souenzzo @schmee take a look on &quot;select&quot; and on &quot;if-path&quot;"><y>#</y><d>2017-07-12</d><h>12:13</h><w>souenzzo</w>@schmee take a look on &quot;select&quot; and on &quot;if-path&quot;</z><z id="t1499861654" t="schmee could you give a more concrete example on how those would help me?"><y>#</y><d>2017-07-12</d><h>12:14</h><w>schmee</w>could you give a more concrete example on how those would help me?</z><z id="t1499861745" t="souenzzo I&apos;m on mobile. When I arrive I&apos;ll do one"><y>#</y><d>2017-07-12</d><h>12:15</h><r>souenzzo</r>I&apos;m on mobile. When I arrive I&apos;ll do one</z><z id="t1499861765" t="schmee cheers :+1:"><y>#</y><d>2017-07-12</d><h>12:16</h><r>schmee</r>cheers <b>:+1:</b></z><z id="t1499861680" t="schmee AFAIK select always returns a sequence and doesn’t modify the original structure"><y>#</y><d>2017-07-12</d><h>12:14</h><w>schmee</w>AFAIK <code>select</code> always returns a sequence and doesn’t modify the original structure</z><z id="t1499866258" t="nathanmarz @schmee you can do (view #(select-keys % [:a :c]))"><y>#</y><d>2017-07-12</d><h>13:30</h><w>nathanmarz</w>@schmee you can do <code>(view #(select-keys % [:a :c]))</code></z><z id="t1499866384" t="nathanmarz for #2, that would need to be another navigator"><y>#</y><d>2017-07-12</d><h>13:33</h><w>nathanmarz</w>for #2, that would need to be another navigator</z><z id="t1499866454" t="schmee ahh, view is the one!"><y>#</y><d>2017-07-12</d><h>13:34</h><w>schmee</w>ahh, <code>view</code> is the one!</z><z id="t1499866461" t="schmee is there a version of view that takes a path?"><y>#</y><d>2017-07-12</d><h>13:34</h><w>schmee</w>is there a version of <code>view</code> that takes a path?</z><z id="t1499866476" t="nathanmarz no, it just takes a function"><y>#</y><d>2017-07-12</d><h>13:34</h><w>nathanmarz</w>no, it just takes a function</z><z id="t1499866493" t="schmee my intuition was that transformed was the path equivalent"><y>#</y><d>2017-07-12</d><h>13:34</h><w>schmee</w>my intuition was that <code>transformed</code> was the path equivalent</z><z id="t1499866501" t="nathanmarz yes, that&apos;s right"><y>#</y><d>2017-07-12</d><h>13:35</h><w>nathanmarz</w>yes, that&apos;s right</z><z id="t1499866515" t="nathanmarz forgot about that"><y>#</y><d>2017-07-12</d><h>13:35</h><w>nathanmarz</w>forgot about that</z><z id="t1499866526" t="schmee user=&gt; (s/transform [(s/transformed (s/submap [:a :c]) identity) s/MAP-VALS] inc {:a 1 :b 2 :c 3}) {:a 2 :b 3 :c 4} "><y>#</y><d>2017-07-12</d><h>13:35</h><w>schmee</w><pre>user=&gt; (s/transform [(s/transformed (s/submap [:a :c]) identity) s/MAP-VALS] inc {:a 1 :b 2 :c 3})
{:a 2 :b 3 :c 4}
</pre></z><z id="t1499866609" t="schmee seems like that would be equivalent to the view version?"><y>#</y><d>2017-07-12</d><h>13:36</h><w>schmee</w>seems like that would be equivalent to the <code>view</code> version?</z><z id="t1499866837" t="nathanmarz no, that doesn&apos;t remove :b"><y>#</y><d>2017-07-12</d><h>13:40</h><w>nathanmarz</w>no, that doesn&apos;t remove :b</z><z id="t1499866854" t="nathanmarz (transformed (submap [:a :c]) identity) is a no-op"><y>#</y><d>2017-07-12</d><h>13:40</h><w>nathanmarz</w><code>(transformed (submap [:a :c]) identity)</code> is a no-op</z><z id="t1499866889" t="nathanmarz (transformed (submap [:a :c]) (fn [_] nil)) would remove :a and :c"><y>#</y><d>2017-07-12</d><h>13:41</h><w>nathanmarz</w><code>(transformed (submap [:a :c]) (fn [_] nil))</code> would remove :a and :c</z><z id="t1499866905" t="schmee ahh, right!"><y>#</y><d>2017-07-12</d><h>13:41</h><w>schmee</w>ahh, right!</z><z id="t1499866924" t="schmee thank you for your patience in answering all these question, I appreciate it!"><y>#</y><d>2017-07-12</d><h>13:42</h><w>schmee</w>thank you for your patience in answering all these question, I appreciate it!</z><z id="t1499866956" t="nathanmarz no problem, happy to help"><y>#</y><d>2017-07-12</d><h>13:42</h><w>nathanmarz</w>no problem, happy to help</z><z id="t1499879358" t="drowsy While toying around I stumbled over something strange. When using select a MapEntry is handled as MapEntry while when using transform is a Vector. So (select [ALL (pred key)] {:a 1}) =&gt; [[:a 1]] while (transform [ALL (pred key)] identity {:a 1}) throws a ClassCastException"><y>#</y><d>2017-07-12</d><h>17:09</h><w>drowsy</w>While toying around I stumbled over something strange. When using select a MapEntry is handled as MapEntry while when using transform is a Vector. So <code>(select [ALL (pred key)] {:a 1})</code> =&gt; <code>[[:a 1]]</code> while <code>(transform [ALL (pred key)] identity {:a 1})</code> throws a ClassCastException</z><z id="t1499879658" t="drowsy I know this path is not useful, but I&apos;m just curious if this is &quot;working as intended&quot; as select and transform differs"><y>#</y><d>2017-07-12</d><h>17:14</h><w>drowsy</w>I know this path is not useful, but I&apos;m just curious if this is &quot;working as intended&quot; as select and transform differs</z><z id="t1499882048" t="nathanmarz @drowsy that&apos;s a good observation"><y>#</y><d>2017-07-12</d><h>17:54</h><w>nathanmarz</w>@drowsy that&apos;s a good observation</z><z id="t1499882120" t="nathanmarz it&apos;s because select does a reduce over the map, while transform accesses the keys/vals using direct means"><y>#</y><d>2017-07-12</d><h>17:55</h><w>nathanmarz</w>it&apos;s because <code>select</code> does a <code>reduce</code> over the map, while <code>transform</code> accesses the keys/vals using direct means</z><z id="t1499882300" t="nathanmarz while it would be nice to be consistent, it&apos;s not really important"><y>#</y><d>2017-07-12</d><h>17:58</h><w>nathanmarz</w>while it would be nice to be consistent, it&apos;s not really important</z><z id="t1499882346" t="nathanmarz (since there would be a slight performance penalty to do a conversion somewhere)"><y>#</y><d>2017-07-12</d><h>17:59</h><w>nathanmarz</w>(since there would be a slight performance penalty to do a conversion somewhere)</z><z id="t1499882432" t="drowsy @nathanmarz thanks for the explanation, I agree, it&apos;s not important. Are there more things where select and transform differs? maybe those can be documented somewhere?"><y>#</y><d>2017-07-12</d><h>18:00</h><w>drowsy</w>@nathanmarz thanks for the explanation, I agree, it&apos;s not important. Are there more things where select and transform differs? maybe those can be documented somewhere?</z><z id="t1499882553" t="nathanmarz not that i can think of"><y>#</y><d>2017-07-12</d><h>18:02</h><w>nathanmarz</w>not that i can think of</z><z id="t1499882560" t="nathanmarz ALL on maps is a weird case"><y>#</y><d>2017-07-12</d><h>18:02</h><w>nathanmarz</w>ALL on maps is a weird case</z><z id="t1499882576" t="nathanmarz a good thing to add to https://github.com/nathanmarz/specter/issues/56"><y>#</y><d>2017-07-12</d><h>18:02</h><w>nathanmarz</w>a good thing to add to <a href="https://github.com/nathanmarz/specter/issues/56" target="_blank">https://github.com/nathanmarz/specter/issues/56</a></z><z id="t1499882736" t="drowsy i will have a look. btw. I really like specter 🙂 so thank you!"><y>#</y><d>2017-07-12</d><h>18:05</h><w>drowsy</w>i will have a look. btw. I really like specter <b>🙂</b> so thank you!</z><z id="t1499882751" t="nathanmarz 🙂"><y>#</y><d>2017-07-12</d><h>18:05</h><w>nathanmarz</w><b>🙂</b></z><z id="t1500069850" t="frankmoyer I’m using specter in Clojurescript. I have a form that uses specter to remove a row from a deeply nested map. When I call the form from the repl, it works fine. When I run it from the browser, core.cljs?rel=1495975558928:89 Error: No protocol method IAssociative.-assoc defined for type cljs.core/LazySeq:..... I’d really like to get Specter working in Clojurescript, as it will make my code much more manageable. Here is the form: (defn delete-row [db row-nbr] (-&gt;&gt; db (sp/transform [:db (:active (:db db)) :blocks (sp/if-path #(&lt; 1 (count %)) (sp/keypath row-nbr))] sp/NONE) (sp/setval [:db (:active (:db db)) :blocks nil?] sp/NONE))) "><y>#</y><d>2017-07-14</d><h>22:04</h><w>frankmoyer</w>I’m using specter in Clojurescript. I have a form that uses specter to remove a row from a deeply nested map. When I call the form from the repl, it works fine. When I run it from the browser, <code>core.cljs?rel=1495975558928:89 Error: No protocol method IAssociative.-assoc defined for type cljs.core/LazySeq:.....</code>

I’d really like to get Specter working in Clojurescript, as it will make my code much more manageable.

Here is the form:

<pre>(defn delete-row
  [db row-nbr]
  (-&gt;&gt; db
       (sp/transform [:db (:active (:db db)) :blocks
                      (sp/if-path #(&lt; 1 (count %)) (sp/keypath row-nbr))]
                     sp/NONE)
       (sp/setval    [:db (:active (:db db)) :blocks nil?]
                     sp/NONE)))
</pre></z><z id="t1500070582" t="nathanmarz @frankmoyer which line is failing, the transform or the setval?"><y>#</y><d>2017-07-14</d><h>22:16</h><w>nathanmarz</w>@frankmoyer which line is failing, the transform or the setval?</z><z id="t1500070664" t="nathanmarz also, what is (:active (:db db)) ?"><y>#</y><d>2017-07-14</d><h>22:17</h><w>nathanmarz</w>also, what is <code>(:active (:db db))</code>?</z><z id="t1500070678" t="nathanmarz that returns a navigator?"><y>#</y><d>2017-07-14</d><h>22:17</h><w>nathanmarz</w>that returns a navigator?</z><z id="t1500077523" t="frankmoyer @nathanmarz Here is a test map input. {:db {:active :left, :left {:southern false, :blocks [{:tame &quot;first row&quot; :nont false}]}} :event [:last-char-deleted 0]} It looks like it is happening in the keypath part of the transform . Here is some more of the stacktrace: core.cljs?rel=1495975558928:89 Error: No protocol method IAssociative.-assoc defined for type cljs.core/LazySeq: ({:tame &quot;&quot;, :nont false} {:tame &quot;This&quot;, :nont false}) at Object.cljs$core$missing_protocol [as missing_protocol] (core.cljs:270) at Object.cljs$core$_assoc [as _assoc] (core.cljs:529) at Function.cljs.core.assoc.cljs$core$IFn$_invoke$arity$3 (core.cljs:1860) at cljs$core$assoc (core.cljs:1853) at com$rpl$specter$navs$do_keypath_transform (navs.cljc?rel=1495975557245:615) at com.rpl.specter.navs.keypath_STAR_.com.rpl.specter.impl.direct_nav_obj.call.com.rpl.specter.navs.t_com$rpl$specter$$rpl$specter$protocols$RichNavigator$transform_STAR_$arity$4 (navs.cljc?rel=1495975557245:625) at com$rpl$specter$protocols$transform_STAR_ (protocols.cljc?rel=1495975553225:15) at com$rpl$specter$navs$if_transform (navs.cljc?rel=1495975557245:402) "><y>#</y><d>2017-07-15</d><h>00:12</h><w>frankmoyer</w>@nathanmarz Here is a test map input.

<pre>{:db
  {:active                         :left,
   :left
   {:southern                      false,
    :blocks
    [{:tame                        &quot;first row&quot;
      :nont                        false}]}}
 :event                            [:last-char-deleted 0]}
</pre>

It looks like it is happening in the <code>keypath</code> part of the <code>transform</code>. Here is some more of the stacktrace:

<pre>core.cljs?rel=1495975558928:89 Error: No protocol method IAssociative.-assoc defined for type cljs.core/LazySeq: ({:tame &quot;&quot;,  :nont false} {:tame &quot;This&quot;, :nont false})
    at Object.cljs$core$missing_protocol [as missing_protocol] (core.cljs:270)
    at Object.cljs$core$_assoc [as _assoc] (core.cljs:529)
    at Function.cljs.core.assoc.cljs$core$IFn$_invoke$arity$3 (core.cljs:1860)
    at cljs$core$assoc (core.cljs:1853)
    at com$rpl$specter$navs$do_keypath_transform (navs.cljc?rel=1495975557245:615)
    at com.rpl.specter.navs.keypath_STAR_.com.rpl.specter.impl.direct_nav_obj.call.com.rpl.specter.navs.t_com$rpl$specter$$rpl$specter$protocols$RichNavigator$transform_STAR_$arity$4 (navs.cljc?rel=1495975557245:625)
    at com$rpl$specter$protocols$transform_STAR_ (protocols.cljc?rel=1495975553225:15)
    at com$rpl$specter$navs$if_transform (navs.cljc?rel=1495975557245:402)
</pre></z><z id="t1500081725" t="nathanmarz @frankmoyer oh, that transform should be a setval"><y>#</y><d>2017-07-15</d><h>01:22</h><w>nathanmarz</w>@frankmoyer oh, that <code>transform</code> should be a <code>setval</code></z><z id="t1500081805" t="nathanmarz also you should wrap (:active (:db db)) with keypath"><y>#</y><d>2017-07-15</d><h>01:23</h><w>nathanmarz</w>also you should wrap <code>(:active (:db db))</code> with <code>keypath</code></z><z id="t1500081825" t="nathanmarz no semantic difference but will perform better"><y>#</y><d>2017-07-15</d><h>01:23</h><w>nathanmarz</w>no semantic difference but will perform better</z><z id="t1500081844" t="nathanmarz since it doesn&apos;t have to convert keyword -&gt; navigator at runtime"><y>#</y><d>2017-07-15</d><h>01:24</h><w>nathanmarz</w>since it doesn&apos;t have to convert keyword -&gt; navigator at runtime</z><z id="t1500081946" t="frankmoyer Perfect! That worked. I really appreciate it. I was just bragging to my wife about how great Specter is and how responsive you are. It makes working with Specter so much less daunting to know you are there for support!"><y>#</y><d>2017-07-15</d><h>01:25</h><w>frankmoyer</w>Perfect! That worked. I really appreciate it. I was just bragging to my wife about how great Specter is and how responsive you are. It makes working with Specter so much less daunting to know you are there for support!</z><z id="t1500081974" t="nathanmarz you can also combine the two calls using (multi-path (if-path ...) nil?)"><y>#</y><d>2017-07-15</d><h>01:26</h><w>nathanmarz</w>you can also combine the two calls using <code>(multi-path (if-path ...) nil?)</code></z><z id="t1500081996" t="nathanmarz awesome, glad to help"><y>#</y><d>2017-07-15</d><h>01:26</h><w>nathanmarz</w>awesome, glad to help</z><z id="t1500082029" t="frankmoyer I’m not sure I need the second call anymore now that the first call has been changed to a setval ."><y>#</y><d>2017-07-15</d><h>01:27</h><w>frankmoyer</w>I’m not sure I need the second call anymore now that the first call has been changed to a <code>setval</code>.</z><z id="t1500476561" t="slpssm Hi, I’m new to specter and have a select I keep trying to do but I’m not quite sure how. I have data like this: {:foo [{:data &quot;text&quot; :required true}] :bar [{:data &quot;text&quot;}] :baz [{:data &quot;text&quot; :required true}]} and I’d like the list of keys whose value has :required in the inner map. This seems to do it: (map first (s/select [s/ALL (fn[[k,v]] (:required (first v)))] data)) and return the expected (:foo :baz) Is there a better way? There have been a few places where I’d like the outer key depending on some value lower in the data structure."><y>#</y><d>2017-07-19</d><h>15:02</h><w>slpssm</w>Hi, I’m new to specter and have a select I keep trying to do but I’m not quite sure how. I have data like this: <pre>{:foo [{:data &quot;text&quot; :required true}]
 :bar [{:data &quot;text&quot;}]
 :baz [{:data &quot;text&quot; :required true}]}</pre> and I’d like the list of keys whose value has :required in the inner map. This seems to do it: <pre>(map first (s/select [s/ALL (fn[[k,v]] (:required (first v)))] data))</pre> and return the expected <pre>(:foo :baz)</pre> Is there a better way? There have been a few places where I’d like the outer key depending on some value lower in the data structure.</z><z id="t1500477338" t="nathanmarz @slpssm can those inner vectors have multiple elements?"><y>#</y><d>2017-07-19</d><h>15:15</h><w>nathanmarz</w>@slpssm can those inner vectors have multiple elements?</z><z id="t1500477364" t="nathanmarz if so then it&apos;s (select [ALL (selected? LAST ALL (must :required)) FIRST] data)"><y>#</y><d>2017-07-19</d><h>15:16</h><w>nathanmarz</w>if so then it&apos;s <code>(select [ALL (selected? LAST ALL (must :required)) FIRST] data)</code></z><z id="t1500477415" t="nathanmarz otherwise it&apos;s (select [ALL (selected? LAST FIRST (must :required)) FIRST] data) to match your code"><y>#</y><d>2017-07-19</d><h>15:16</h><w>nathanmarz</w>otherwise it&apos;s <code>(select [ALL (selected? LAST FIRST (must :required)) FIRST] data)</code> to match your code</z><z id="t1500477617" t="nathanmarz this code just checks for existence of a :required key, if you need to match only when :required is truthy replace (must :required) with :required identity"><y>#</y><d>2017-07-19</d><h>15:20</h><w>nathanmarz</w>this code just checks for existence of a :required key, if you need to match only when :required is truthy replace <code>(must :required)</code> with <code>:required identity</code></z><z id="t1500477741" t="slpssm I think it can have more than one item, but I’ve never seen one so I’m going with the first version. 🙂 With a note on the second version just in case. Now I just need to parse this so I know how it works."><y>#</y><d>2017-07-19</d><h>15:22</h><w>slpssm</w>I think it can have more than one item, but I’ve never seen one so I’m going with the first version. <b>🙂</b> With a note on the second version just in case. Now I just need to parse this so I know how it works.</z><z id="t1500477776" t="nathanmarz selected? is a filter based on whether the subpath selects at least a single value"><y>#</y><d>2017-07-19</d><h>15:22</h><w>nathanmarz</w><code>selected?</code> is a filter based on whether the subpath selects at least a single value</z><z id="t1500478047" t="slpssm LAST gets you into the array, the next ALL looks at key/values, (must :required) does the :required check and the last FIRST is the outer key. About right?"><y>#</y><d>2017-07-19</d><h>15:27</h><w>slpssm</w><code>LAST</code> gets you into the array, the next <code>ALL</code> looks at key/values, <code>(must :required)</code> does the <code>:required</code> check and the last <code>FIRST</code> is the outer key. About right?</z><z id="t1500478214" t="nathanmarz the initial LAST goes to the value for that key/value pair, the subsequent ALL looks at all maps inside that vector"><y>#</y><d>2017-07-19</d><h>15:30</h><w>nathanmarz</w>the initial <code>LAST</code> goes to the value for that key/value pair, the subsequent <code>ALL</code> looks at all maps inside that vector</z><z id="t1500478946" t="slpssm Ah, OK. Yes. FIRST would be the key, LAST is the value."><y>#</y><d>2017-07-19</d><h>15:42</h><w>slpssm</w>Ah, OK. Yes. <code>FIRST</code> would be the key, <code>LAST</code> is the value.</z><z id="t1500552976" t="alexyakushev Hello everyone. I want to do the following transformation: [[:a :b :c] [:d] [:e :f] [:g]] =&gt; [[0 1 2] [3] [4 5] [6]] In other words, I want to enumerate elements in two-levels-deep nested structure. I managed to achieve this with subselect : (setval (subselect ALL ALL) (iterate inc 0) [[:a :a :a] [:b] [:c :c] [:d]]) Is there a better way than using subselect here? I was looking for something like FLATMAP navigator that is like ALL but splices each sequence into top-level view."><y>#</y><d>2017-07-20</d><h>12:16</h><w>alexyakushev</w>Hello everyone. I want to do the following transformation:
<pre>[[:a :b :c] [:d] [:e :f] [:g]] =&gt; [[0 1 2] [3] [4 5] [6]]
</pre>
In other words, I want to enumerate elements in two-levels-deep nested structure. I managed to achieve this with <code>subselect</code>:
<pre>(setval (subselect ALL ALL) (iterate inc 0) [[:a :a :a] [:b] [:c :c] [:d]])
</pre>
Is there a better way than using <code>subselect</code> here? I was looking for something like <code>FLATMAP</code> navigator that is like <code>ALL</code> but splices each sequence into top-level view.</z><z id="t1500553913" t="nathanmarz @alexyakushev that&apos;s a perfect solution"><y>#</y><d>2017-07-20</d><h>12:31</h><w>nathanmarz</w>@alexyakushev that&apos;s a perfect solution</z><z id="t1500554086" t="nathanmarz you could define FLATMAP with something like: (def FLATMAP (recursive-path [] p (if-path sequential? [ALL p] STAY ))) "><y>#</y><d>2017-07-20</d><h>12:34</h><w>nathanmarz</w>you could define <code>FLATMAP</code> with something like:
<pre>(def FLATMAP
  (recursive-path [] p
    (if-path sequential?
      [ALL p]
      STAY
      )))
</pre></z><z id="t1500554098" t="alexyakushev Thanks, Nathan! A quick follow-up question. Is there a way to transform a vector so that the transform-fn receives an index of the element? Like map-indexed . All I could Google was https://github.com/nathanmarz/specter/issues/169 , but in that case the iterable element was a map, where keys are more easily obtained."><y>#</y><d>2017-07-20</d><h>12:34</h><w>alexyakushev</w>Thanks, Nathan! A quick follow-up question. Is there a way to transform a vector so that the transform-fn receives an index of the element? Like <code>map-indexed</code>. All I could Google was <a href="https://github.com/nathanmarz/specter/issues/169" target="_blank">https://github.com/nathanmarz/specter/issues/169</a>, but in that case the iterable element was a map, where keys are more easily obtained.</z><z id="t1500554128" t="nathanmarz not in specter core"><y>#</y><d>2017-07-20</d><h>12:35</h><w>nathanmarz</w>not in specter core</z><z id="t1500554145" t="nathanmarz you could define a navigator similar to ALL which navigates to [index value]"><y>#</y><d>2017-07-20</d><h>12:35</h><w>nathanmarz</w>you could define a navigator similar to <code>ALL</code> which navigates to [index value]</z><z id="t1500554180" t="alexyakushev Hm, I didn&apos;t know it is this easy to define new navigators 🙂 This is excellent, thank you!"><y>#</y><d>2017-07-20</d><h>12:36</h><w>alexyakushev</w>Hm, I didn&apos;t know it is this easy to define new navigators <b>🙂</b> This is excellent, thank you!</z><z id="t1500998293" t="felipe-campos looking for documentation or some examples about recursive-path"><y>#</y><d>2017-07-25</d><h>15:58</h><w>felipe-campos</w>looking for documentation or some examples about <code>recursive-path</code></z><z id="t1501060379" t="andrea.crotti hi guys"><y>#</y><d>2017-07-26</d><h>09:12</h><w>andrea.crotti</w>hi guys</z><z id="t1501060407" t="andrea.crotti I&apos;m trying to implement something like this (get-capitals {&quot;A&quot; [&quot;hello&quot;] &quot;b&quot; [&quot;other&quot;]}) ;; should return {&quot;A&quot; [&quot;hello&quot;]} "><y>#</y><d>2017-07-26</d><h>09:13</h><w>andrea.crotti</w>I&apos;m trying to implement something like this
<pre>(get-capitals {&quot;A&quot; [&quot;hello&quot;]
               &quot;b&quot; [&quot;other&quot;]})

;; should return {&quot;A&quot; [&quot;hello&quot;]}
</pre></z><z id="t1501060423" t="andrea.crotti with Specter, which in theory it&apos;s just a select right?"><y>#</y><d>2017-07-26</d><h>09:13</h><w>andrea.crotti</w>with Specter, which in theory it&apos;s just a select right?</z><z id="t1501060426" t="andrea.crotti (defn get-capitals [probs] (specter/select [specter/MAP-KEYS #(Character/isUpperCase (first %))] probs)) "><y>#</y><d>2017-07-26</d><h>09:13</h><w>andrea.crotti</w><pre>(defn get-capitals
  [probs]
  (specter/select
   [specter/MAP-KEYS #(Character/isUpperCase (first %))]
   probs))
</pre></z><z id="t1501060435" t="andrea.crotti this loses the original structure though"><y>#</y><d>2017-07-26</d><h>09:13</h><w>andrea.crotti</w>this loses the original structure though</z><z id="t1501060509" t="schmee select always return a sequence, so if you want to maintain the structure you have to use something else"><y>#</y><d>2017-07-26</d><h>09:15</h><w>schmee</w><code>select</code> always return a sequence, so if you want to maintain the structure you have to use something else</z><z id="t1501060512" t="schmee gimmie a sec"><y>#</y><d>2017-07-26</d><h>09:15</h><w>schmee</w>gimmie a sec</z><z id="t1501060581" t="andrea.crotti ah yes ok i can try with transofrm"><y>#</y><d>2017-07-26</d><h>09:16</h><w>andrea.crotti</w>ah yes ok i can try with transofrm</z><z id="t1501060591" t="andrea.crotti but the function itself should be identity then?"><y>#</y><d>2017-07-26</d><h>09:16</h><w>andrea.crotti</w>but the function itself should be identity then?</z><z id="t1501060607" t="schmee this should do it: (defn get-capitals [probs] (specter/setval [specter/MAP-KEYS #(Character/isLowerCase (first %))] specter/NONE probs) "><y>#</y><d>2017-07-26</d><h>09:16</h><w>schmee</w>this should do it: <pre>(defn get-capitals
  [probs]
  (specter/setval
   [specter/MAP-KEYS #(Character/isLowerCase (first %))]
   specter/NONE
   probs)
</pre></z><z id="t1501060624" t="schmee it removes everything that is lower case, instead of selecting what is upper case"><y>#</y><d>2017-07-26</d><h>09:17</h><w>schmee</w>it removes everything that is lower case, instead of selecting what is upper case</z><z id="t1501060625" t="andrea.crotti Ah this also works actualy (defn get-capitals [probs] (specter/transform [specter/MAP-KEYS #(Character/isUpperCase (first %))] identity probs)) "><y>#</y><d>2017-07-26</d><h>09:17</h><w>andrea.crotti</w>Ah this also works actualy
<pre>(defn get-capitals
  [probs]
  (specter/transform
   [specter/MAP-KEYS #(Character/isUpperCase (first %))]
   identity
   probs))
</pre></z><z id="t1501060641" t="andrea.crotti I actually need both submaps really"><y>#</y><d>2017-07-26</d><h>09:17</h><w>andrea.crotti</w>I actually need both submaps really</z><z id="t1501060662" t="andrea.crotti or maybe I can just use select to extract the two set of keys and reconstruct the maps later"><y>#</y><d>2017-07-26</d><h>09:17</h><w>andrea.crotti</w>or maybe I can just use select to extract the two set of keys and reconstruct the maps later</z><z id="t1501103522" t="frankmoyer I have a straight-forward selector that, does not function as I expect it to when the last element is index reference to a collection. Here is the select without the index in the keypath followed by the select with the index (0) in the keypath : (sp/select [(apply sp/keypath [:db :right :text-entry 0 :offset])]) [({:text &quot;180 West&quot;, :label &quot;&quot;})] (sp/select [(apply sp/keypath [:db :right :text-entry 0 :offset 0])]) [nil] The index navigator after :text-entry always works. It seems like it is just when the index is at the last position."><y>#</y><d>2017-07-26</d><h>21:12</h><w>frankmoyer</w>I have a straight-forward selector that, does not function as I expect it to when the last element is index reference to a collection. Here is the <code>select</code> without the index in the <code>keypath</code> followed by the <code>select</code> with the index (0) in the <code>keypath</code>:

<pre>(sp/select [(apply sp/keypath [:db :right :text-entry 0 :offset])])
[({:text &quot;180 West&quot;, :label &quot;&quot;})]

(sp/select [(apply sp/keypath [:db :right :text-entry 0 :offset 0])])
[nil]
</pre>

The index navigator after <code>:text-entry</code> always works. It seems like it is just when the index is at the last position.</z><z id="t1501105888" t="nathanmarz @frankmoyer what&apos;s the input?"><y>#</y><d>2017-07-26</d><h>21:51</h><w>nathanmarz</w>@frankmoyer what&apos;s the input?</z><z id="t1501107911" t="frankmoyer @nathanmarz I just figured out what was going on while I was compiling the input for you. A prior transform altered the portion of the structure that was being modified to be a List . When I convert it to a vec in the form, subsequent transform operations are able to navigate to the index. Thank you!"><y>#</y><d>2017-07-26</d><h>22:25</h><w>frankmoyer</w>@nathanmarz I just figured out what was going on while I was compiling the input for you. A prior <code>transform</code> altered the portion of the structure that was being modified to be a <code>List</code>. When I convert it to a <code>vec</code> in the form, subsequent <code>transform</code> operations are able to navigate to the index. Thank you!</z><z id="t1501107995" t="wei is there a way to make walker search only maps (not e.g. Datomic entitymaps?) (def link-walker [(sp/walker ::link)])"><y>#</y><d>2017-07-26</d><h>22:26</h><w>wei</w>is there a way to make walker search only maps (not e.g. Datomic entitymaps?) <pre>(def link-walker [(sp/walker ::link)])</pre></z><z id="t1501108077" t="nathanmarz @frankmoyer cool, figured it would be something like that"><y>#</y><d>2017-07-26</d><h>22:27</h><w>nathanmarz</w>@frankmoyer cool, figured it would be something like that</z><z id="t1501108146" t="wei I’m confused why these give different results: dev.user=&gt; (sp/transform [(sp/walker ::link)] identity {:a 1 :b (d/entity (db/db) 17592186045447) ::link [:a 1]}) {:a 1, :b #:db{:id 17592186045447}, :dev.user/link [:a 1]} dev.user=&gt; (sp/transform [(sp/walker ::link)] identity {:a 1 :b (d/entity (db/db) 17592186045447)}) AbstractMethodError clojure.lang.RT.conj (RT.java:667) "><y>#</y><d>2017-07-26</d><h>22:29</h><w>wei</w>I’m confused why these give different results: <pre>dev.user=&gt; (sp/transform [(sp/walker ::link)] identity {:a 1 :b (d/entity (db/db) 17592186045447) ::link [:a 1]})
{:a 1, :b #:db{:id 17592186045447}, :dev.user/link [:a 1]}
dev.user=&gt; (sp/transform [(sp/walker ::link)] identity {:a 1 :b (d/entity (db/db) 17592186045447)})
AbstractMethodError   clojure.lang.RT.conj (RT.java:667)
</pre></z><z id="t1501108191" t="wei oh nevermind, I think I know why-- depth first search descends in the second case but cuts off in the first case"><y>#</y><d>2017-07-26</d><h>22:29</h><w>wei</w>oh nevermind, I think I know why-- depth first search descends in the second case but cuts off in the first case</z><z id="t1501108198" t="nathanmarz @wei walker will blindly walk into any collection (functions like clojure.walk)"><y>#</y><d>2017-07-26</d><h>22:29</h><w>nathanmarz</w>@wei walker will blindly walk into any collection (functions like clojure.walk)</z><z id="t1501108228" t="wei thanks @nathanmarz. looking for a good alternative to walker then"><y>#</y><d>2017-07-26</d><h>22:30</h><w>wei</w>thanks @nathanmarz. looking for a good alternative to <code>walker</code> then</z><z id="t1501108254" t="nathanmarz https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1352"><y>#</y><d>2017-07-26</d><h>22:30</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1352" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1352</a></z><z id="t1501108288" t="nathanmarz (walker ::link) doesn&apos;t make much sense"><y>#</y><d>2017-07-26</d><h>22:31</h><w>nathanmarz</w><code>(walker ::link)</code> doesn&apos;t make much sense</z><z id="t1501108303" t="nathanmarz look at the docstring"><y>#</y><d>2017-07-26</d><h>22:31</h><w>nathanmarz</w>look at the docstring</z><z id="t1501108338" t="nathanmarz it&apos;s generally better to make your own recursive path tailored to the data structure / problem at hand"><y>#</y><d>2017-07-26</d><h>22:32</h><w>nathanmarz</w>it&apos;s generally better to make your own recursive path tailored to the data structure / problem at hand</z><z id="t1501108353" t="nathanmarz and it&apos;s really easy to do"><y>#</y><d>2017-07-26</d><h>22:32</h><w>nathanmarz</w>and it&apos;s really easy to do</z><z id="t1501108440" t="wei I’m trying to find maps with the key ::link in them, so it seems like a legit afn to me? could you explain what I’m missing?"><y>#</y><d>2017-07-26</d><h>22:34</h><w>wei</w>I’m trying to find maps with the key <code>::link</code> in them, so it seems like a legit <code>afn</code> to me? could you explain what I’m missing?</z><z id="t1501108516" t="wei (in my example above, the map passed in was contrived and I substituted identity with a function that actually does something useful)"><y>#</y><d>2017-07-26</d><h>22:35</h><w>wei</w>(in my example above, the map passed in was contrived and I substituted <code>identity</code> with a function that actually does something useful)</z><z id="t1501108540" t="nathanmarz it&apos;s going to call ::link on all values / data structures it sees"><y>#</y><d>2017-07-26</d><h>22:35</h><w>nathanmarz</w>it&apos;s going to call <code>::link</code> on all values / data structures it sees</z><z id="t1501108561" t="nathanmarz e.g. (::link 1)"><y>#</y><d>2017-07-26</d><h>22:36</h><w>nathanmarz</w>e.g. <code>(::link 1)</code></z><z id="t1501108572" t="nathanmarz I wouldn&apos;t rely on that behavior"><y>#</y><d>2017-07-26</d><h>22:36</h><w>nathanmarz</w>I wouldn&apos;t rely on that behavior</z><z id="t1501108629" t="nathanmarz #(and (map? %) (contains? % ::link)) is better i think"><y>#</y><d>2017-07-26</d><h>22:37</h><w>nathanmarz</w><code>#(and (map? %) (contains? % ::link))</code> is better i think</z><z id="t1501108781" t="wei ah that makes more sense. unfortunately it’s still descending into the datomic entity I think. is there a way to make walker short-circuit, or is there a better alternative? dev.user=&gt; (sp/transform [(sp/walker #(and (map? %) (contains? % ::link)))] identity {:a 1 :b (d/entity (db/db) 17592186045447)}) AbstractMethodError clojure.lang.RT.conj (RT.java:667) "><y>#</y><d>2017-07-26</d><h>22:39</h><w>wei</w>ah that makes more sense. unfortunately it’s still descending into the datomic entity I think. is there a way to make <code>walker</code> short-circuit, or is there a better alternative? <pre>dev.user=&gt; (sp/transform [(sp/walker #(and (map? %) (contains? % ::link)))] identity {:a 1 :b (d/entity (db/db) 17592186045447)})
AbstractMethodError   clojure.lang.RT.conj (RT.java:667)
</pre></z><z id="t1501108847" t="nathanmarz you can&apos;t avoid that with walker"><y>#</y><d>2017-07-26</d><h>22:40</h><w>nathanmarz</w>you can&apos;t avoid that with <code>walker</code></z><z id="t1501108857" t="nathanmarz an easy variant you could use is: (def walk-skipper (recursive-path [afn skip-fn] p (cond-path (pred skip-fn) STOP (pred afn) STAY coll? [ALL p] ))) "><y>#</y><d>2017-07-26</d><h>22:40</h><w>nathanmarz</w>an easy variant you could use is:
<pre>(def walk-skipper
  (recursive-path [afn skip-fn] p
    (cond-path (pred skip-fn) STOP
               (pred afn) STAY
               coll? [ALL p]
               )))
</pre></z><z id="t1501108869" t="nathanmarz set the skip-fn to return true on datomic entities"><y>#</y><d>2017-07-26</d><h>22:41</h><w>nathanmarz</w>set the <code>skip-fn</code> to return true on datomic entities</z><z id="t1501108875" t="nathanmarz or anything else you don&apos;t want to walk"><y>#</y><d>2017-07-26</d><h>22:41</h><w>nathanmarz</w>or anything else you don&apos;t want to walk</z><z id="t1501109065" t="wei trying to understand recursive-path usage, where does pred come from in this case?"><y>#</y><d>2017-07-26</d><h>22:44</h><w>wei</w>trying to understand <code>recursive-path</code> usage, where does <code>pred</code> come from in this case?</z><z id="t1501109088" t="nathanmarz pred is a navigator"><y>#</y><d>2017-07-26</d><h>22:44</h><w>nathanmarz</w><code>pred</code> is a navigator</z><z id="t1501109103" t="nathanmarz that&apos;s what&apos;s implicitly used when you put a function into a path"><y>#</y><d>2017-07-26</d><h>22:45</h><w>nathanmarz</w>that&apos;s what&apos;s implicitly used when you put a function into a path</z><z id="t1501109122" t="nathanmarz it&apos;s used in this case to avoid runtime conversion of function -&gt; navigator"><y>#</y><d>2017-07-26</d><h>22:45</h><w>nathanmarz</w>it&apos;s used in this case to avoid runtime conversion of function -&gt; navigator</z><z id="t1501109153" t="nathanmarz (for performance)"><y>#</y><d>2017-07-26</d><h>22:45</h><w>nathanmarz</w>(for performance)</z><z id="t1501109286" t="wei great, seems to be working as expected! i substituted com.rpl.specter/pred so I could define walk-skipper in my own ns. thanks for your help."><y>#</y><d>2017-07-26</d><h>22:48</h><w>wei</w>great, seems to be working as expected! i substituted <code>com.rpl.specter/pred</code> so I could define <code>walk-skipper</code> in my own ns. thanks for your help.</z><z id="t1501111274" t="wei sorry to bug you again @nathanmarz but the walk-skipper doesn’t seem to be working for me: (def walk-skipper (sp/recursive-path [afn skip-fn] p (sp/cond-path (sp/pred skip-fn) sp/STOP (sp/pred afn) sp/STAY coll? [sp/ALL p]))) dev.user=&gt; (sp/select [(sp/walker #(and (map? %) (contains? % :d)) )] {:a 1 :b 2 :c {:d 1}}) [{:d 1}] dev.user=&gt; (sp/select [(walk-skipper #(and (map? %) (contains? % :d)) (complement map?))] {:a 1 :b 2 :c {:d 1}}) [] "><y>#</y><d>2017-07-26</d><h>23:21</h><w>wei</w>sorry to bug you again @nathanmarz but the <code>walk-skipper</code> doesn’t seem to be working for me: <pre>(def walk-skipper
  (sp/recursive-path [afn skip-fn] p
                     (sp/cond-path (sp/pred skip-fn) sp/STOP
                                   (sp/pred afn) sp/STAY
                                   coll? [sp/ALL p])))

dev.user=&gt; (sp/select [(sp/walker #(and (map? %) (contains? % :d)) )] {:a 1 :b 2 :c {:d 1}})
[{:d 1}]
dev.user=&gt; (sp/select [(walk-skipper #(and (map? %) (contains? % :d)) (complement map?))] {:a 1 :b 2 :c {:d 1}})
[]
</pre></z><z id="t1501111327" t="wei still wrapping my head around how recursive-path works. mind helping me troubleshoot?"><y>#</y><d>2017-07-26</d><h>23:22</h><w>wei</w>still wrapping my head around how <code>recursive-path</code> works. mind helping me troubleshoot?</z><z id="t1501113450" t="nathanmarz @wei the definition of walker / walk-skipper traverses all collections via ALL to replicate clojure.walk semantics"><y>#</y><d>2017-07-26</d><h>23:57</h><w>nathanmarz</w>@wei the definition of <code>walker</code> / <code>walk-skipper</code> traverses all collections via <code>ALL</code> to replicate clojure.walk semantics</z><z id="t1501113472" t="nathanmarz so that means it traverses each key/value pair as a vector, then traverses those to each key/value"><y>#</y><d>2017-07-26</d><h>23:57</h><w>nathanmarz</w>so that means it traverses each key/value pair as a vector, then traverses those to each key/value</z><z id="t1501113497" t="nathanmarz since you stop navigation if encountering a non-map, it stops traversing once it reaches key/value pairs"><y>#</y><d>2017-07-26</d><h>23:58</h><w>nathanmarz</w>since you stop navigation if encountering a non-map, it stops traversing once it reaches key/value pairs</z><z id="t1501113503" t="nathanmarz so never reaches the inner map"><y>#</y><d>2017-07-26</d><h>23:58</h><w>nathanmarz</w>so never reaches the inner map</z><z id="t1501113534" t="nathanmarz like I said, it&apos;s better to make your own recursive path tailored to the data structure / problem at hand"><y>#</y><d>2017-07-26</d><h>23:58</h><w>nathanmarz</w>like I said, it&apos;s better to make your own recursive path tailored to the data structure / problem at hand</z><z id="t1501113568" t="nathanmarz in this case you probably want to descend using MAP-VALS rather than ALL"><y>#</y><d>2017-07-26</d><h>23:59</h><w>nathanmarz</w>in this case you probably want to descend using <code>MAP-VALS</code> rather than <code>ALL</code></z><z id="t1501113606" t="nathanmarz will be a lot more performant as well by avoiding traversing totally irrelevant parts of the data structure"><y>#</y><d>2017-07-27</d><h>00:00</h><w>nathanmarz</w>will be a lot more performant as well by avoiding traversing totally irrelevant parts of the data structure</z><z id="t1501149454" t="wei ^ I get it now, thanks for the help!"><y>#</y><d>2017-07-27</d><h>09:57</h><w>wei</w>^ I get it now, thanks for the help!</z><z id="t1501166293" t="souenzzo (setval [(walker #(contains? % :foo))] NONE [{:foo true}]) ;=&gt; [:com.rpl.specter.impl/NONE] (setval [ALL (walker #(contains? % :foo))] NONE [{:foo true}]) ;=&gt; [] Is it a bug?"><y>#</y><d>2017-07-27</d><h>14:38</h><w>souenzzo</w><pre>(setval [(walker #(contains? % :foo))] NONE [{:foo true}])  ;=&gt; [:com.rpl.specter.impl/NONE]
(setval [ALL (walker #(contains? % :foo))] NONE [{:foo true}])  ;=&gt; []</pre>
Is it a bug?</z><z id="t1501166753" t="nathanmarz @souenzzo you&apos;re using an old version"><y>#</y><d>2017-07-27</d><h>14:45</h><w>nathanmarz</w>@souenzzo you&apos;re using an old version</z><z id="t1501166778" t="nathanmarz NONE integration with walker was added in 1.0.2"><y>#</y><d>2017-07-27</d><h>14:46</h><w>nathanmarz</w><code>NONE</code> integration with <code>walker</code> was added in 1.0.2</z><z id="t1501166847" t="souenzzo I was on 1.0.1. I did not see the new 😅 sorry"><y>#</y><d>2017-07-27</d><h>14:47</h><r>souenzzo</r>I was on 1.0.1. I did not see the new <b>😅</b> sorry</z><z id="t1501205901" t="eriktjacobsen First-time specter user today; How would I compose [MAP-VALS (multi-path :checks :dependencies) ALL :relation] and [MAP-VALS :features MAP-VALS] ?"><y>#</y><d>2017-07-28</d><h>01:38</h><w>eriktjacobsen</w>First-time specter user today; How would I compose <code>[MAP-VALS (multi-path :checks :dependencies) ALL :relation]</code> and <code>[MAP-VALS :features MAP-VALS]</code> ?</z><z id="t1501206134" t="eriktjacobsen it looked like cond-path, but then it seems you&apos;re duplicating the multi-path and :features? Wasn&apos;t sure if there was a cleaner way. (ie [MAP-VALS (cond-path (multi-path :checks :dependencies) [(multi-path :checks :dependencies) ALL :relation] :features [:features MAP-VALS])] )"><y>#</y><d>2017-07-28</d><h>01:42</h><w>eriktjacobsen</w>it looked like cond-path, but then it seems you&apos;re duplicating the multi-path and :features? Wasn&apos;t sure if there was a cleaner way. (ie <code>[MAP-VALS (cond-path (multi-path :checks :dependencies) [(multi-path :checks :dependencies) ALL :relation] :features [:features MAP-VALS])]</code>)</z><z id="t1501216392" t="nathanmarz @eriktjacobsen not sure what you mean by &quot;compose&quot;"><y>#</y><d>2017-07-28</d><h>04:33</h><w>nathanmarz</w>@eriktjacobsen not sure what you mean by &quot;compose&quot;</z><z id="t1501216426" t="nathanmarz if you want to do both paths at once it&apos;s just multi-path similar to what you&apos;re already doing"><y>#</y><d>2017-07-28</d><h>04:33</h><w>nathanmarz</w>if you want to do both paths at once it&apos;s just <code>multi-path</code> similar to what you&apos;re already doing</z><z id="t1501216435" t="eriktjacobsen fair. the third block using cond-path is what I want, i just thought there might be another way besides duplicating the pieces in cond"><y>#</y><d>2017-07-28</d><h>04:33</h><w>eriktjacobsen</w>fair. the third block using cond-path is what I want, i just thought there might be another way besides duplicating the pieces in cond</z><z id="t1501216480" t="nathanmarz putting (multi-path :checks :dependencies) as your condition does nothing"><y>#</y><d>2017-07-28</d><h>04:34</h><w>nathanmarz</w>putting <code>(multi-path :checks :dependencies)</code> as your condition does nothing</z><z id="t1501216512" t="nathanmarz that condition is always true"><y>#</y><d>2017-07-28</d><h>04:35</h><w>nathanmarz</w>that condition is always true</z><z id="t1501216596" t="nathanmarz conditionals in specter (`cond-path` and if-path ) are true if at least one element is selected"><y>#</y><d>2017-07-28</d><h>04:36</h><w>nathanmarz</w>conditionals in specter (`cond-path` and <code>if-path</code>) are true if at least one element is selected</z><z id="t1501373493" t="rcullito Hey all, I’m a little confused about how conceptually to think about using filterer versus just containing a predicate in my path. To take this example:"><y>#</y><d>2017-07-30</d><h>00:11</h><w>rcullito</w>Hey all, I’m a little confused about how conceptually to think about using <code>filterer</code> versus just containing a predicate in my path. To take this example:</z><z id="t1501373498" t="rcullito (select (filterer even?) (range 10)) [[0 2 4 6 8]] (select [ALL even?] (range 10)) [0 2 4 6 8]"><y>#</y><d>2017-07-30</d><h>00:11</h><w>rcullito</w><pre>(select (filterer even?) (range 10))
[[0 2 4 6 8]]

(select [ALL even?] (range 10))
[0 2 4 6 8]</pre></z><z id="t1501373522" t="rcullito it is still unclear to me why the filterer version would be nested versus the second example."><y>#</y><d>2017-07-30</d><h>00:12</h><w>rcullito</w>it is still unclear to me why the <code>filterer</code> version would be nested versus the second example.</z><z id="t1501374458" t="drowsy as far as I understand filterer navigates to the subcollection (so you could for example reverse it) while ALL pred navigates to every single number (so you could for example inc it)"><y>#</y><d>2017-07-30</d><h>00:27</h><w>drowsy</w>as far as I understand filterer navigates to the subcollection (so you could for example reverse it) while ALL pred navigates to every single number (so you could for example inc it)</z><z id="t1501376166" t="nathanmarz @rcullito by navigating you to a sequence you can do things with filterer that you can&apos;t do with navigators that go straight to subvalues, e.g. selecting the last even number in a sequence: (select-any [(filterer even?) LAST] (range 10)) ; =&gt; 8"><y>#</y><d>2017-07-30</d><h>00:56</h><w>nathanmarz</w>@rcullito by navigating you to a sequence you can do things with <code>filterer</code> that you can&apos;t do with navigators that go straight to subvalues, e.g. selecting the last even number in a sequence: <code>(select-any [(filterer even?) LAST] (range 10)) ; =&gt; 8</code></z><z id="t1501397981" t="rcullito Thanks for the examples: @drowsy, @nathanmarz! Starting to pick up on the subtleties for when it is preferable to use filterer . Much appreciated."><y>#</y><d>2017-07-30</d><h>06:59</h><w>rcullito</w>Thanks for the examples: @drowsy, @nathanmarz! Starting to pick up on the subtleties for when it is preferable to use <code>filterer</code>. Much appreciated.</z><z id="t1501663505" t="levitanong Hi all, is there any way to mimic the functionality of multi-arity map ? (map (fn [a b] ...) [1 2 3] [4 5 6]) "><y>#</y><d>2017-08-02</d><h>08:45</h><w>levitanong</w>Hi all, is there any way to mimic the functionality of multi-arity <code>map</code>?
<pre>(map (fn [a b] ...) [1 2 3] [4 5 6])
</pre></z><z id="t1501720740" t="steveb8n I’m struggling with a conditional transform. seems simple but I can’t work it out. How do I transform a map value only if it is present?"><y>#</y><d>2017-08-03</d><h>00:39</h><w>steveb8n</w>I’m struggling with a conditional transform. seems simple but I can’t work it out. How do I transform a map value only if it is present?</z><z id="t1501720758" t="steveb8n (transform [:b vector?] set {:a 1})"><y>#</y><d>2017-08-03</d><h>00:39</h><w>steveb8n</w><code>(transform [:b vector?] set {:a 1})</code></z><z id="t1501720784" t="steveb8n will return {:a 1, :b nil}"><y>#</y><d>2017-08-03</d><h>00:39</h><w>steveb8n</w>will return <code>{:a 1, :b nil}</code></z><z id="t1501720817" t="steveb8n but I only want the “:b” transformed if “:b” is present"><y>#</y><d>2017-08-03</d><h>00:40</h><w>steveb8n</w>but I only want the “:b” transformed if “:b” is present</z><z id="t1501720911" t="schmee @steveb8n (s/must :b)"><y>#</y><d>2017-08-03</d><h>00:41</h><w>schmee</w>@steveb8n <code>(s/must :b)</code></z><z id="t1501720922" t="schmee https://github.com/nathanmarz/specter/wiki/List-of-Navigators#must"><y>#</y><d>2017-08-03</d><h>00:42</h><w>schmee</w><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#must" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#must</a></z><z id="t1501720974" t="steveb8n thanks @schmee I knew there had to be a simple answer"><y>#</y><d>2017-08-03</d><h>00:42</h><w>steveb8n</w>thanks @schmee I knew there had to be a simple answer</z><z id="t1502706946" t="nathanmarz Released Specter 1.0.3 https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><y>#</y><d>2017-08-14</d><h>10:35</h><w>nathanmarz</w>Released Specter 1.0.3 <a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md" target="_blank">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></z><z id="t1502707106" t="nathanmarz (setval (index-nav 3) 1 [:a :b :c :d :e]) ;; =&gt; [:a :d :b :c :e] (select INDEXED-VALS [:a :b :c]) ;; =&gt; [[0 :a] [1 :b] [2 :c]] (setval [INDEXED-VALS FIRST] 0 [:a :b :c :d]) ;; =&gt; [:d :c :b :a] (setval (before-index 2) :a &apos;(0 1 2 3 4)) ;; =&gt; (0 1 :a 2 3 4) "><y>#</y><d>2017-08-14</d><h>10:38</h><w>nathanmarz</w><pre>(setval (index-nav 3) 1 [:a :b :c :d :e])
;; =&gt; [:a :d :b :c :e]

(select INDEXED-VALS [:a :b :c])
;; =&gt; [[0 :a] [1 :b] [2 :c]]

(setval [INDEXED-VALS FIRST] 0 [:a :b :c :d])
;; =&gt; [:d :c :b :a]

(setval (before-index 2) :a &apos;(0 1 2 3 4))
;; =&gt; (0 1 :a 2 3 4)
</pre></z><z id="t1503249656" t="michaelwfogleman There was recently a very interesting question on Stack Overflow - no one has written a Specter-based solution yet... I am trying to write one."><y>#</y><d>2017-08-20</d><h>17:20</h><w>michaelwfogleman</w>There was recently a very interesting question on Stack Overflow - no one has written a Specter-based solution yet... I am trying to write one.</z><z id="t1503249669" t="michaelwfogleman https://stackoverflow.com/questions/45764946/how-to-find-indexes-in-deeply-nested-data-structurevectors-and-lists-in-clojur"><y>#</y><d>2017-08-20</d><h>17:21</h><w>michaelwfogleman</w><a href="https://stackoverflow.com/questions/45764946/how-to-find-indexes-in-deeply-nested-data-structurevectors-and-lists-in-clojur" target="_blank">https://stackoverflow.com/questions/45764946/how-to-find-indexes-in-deeply-nested-data-structurevectors-and-lists-in-clojur</a></z><z id="t1503250122" t="nathanmarz @michaelwfogleman I&apos;ll take a closer look later, but you basically want to use recursive-path , collect-one , and INDEXED-VALS"><y>#</y><d>2017-08-20</d><h>17:28</h><w>nathanmarz</w>@michaelwfogleman I&apos;ll take a closer look later, but you basically want to use <code>recursive-path</code>, <code>collect-one</code>, and <code>INDEXED-VALS</code></z><z id="t1503254084" t="nathanmarz @michaelwfogleman looks like this: (defn find-index-route [v data] (let [p (recursive-path [] p (if-path sequential? [INDEXED-VALS (if-path [LAST (pred= v)] FIRST [(collect-one FIRST) LAST p] )]))] (let [ret (select-first p data)] (if (vector? ret) ret [ret]) ))) "><y>#</y><d>2017-08-20</d><h>18:34</h><w>nathanmarz</w>@michaelwfogleman looks like this:
<pre>(defn find-index-route [v data]
  (let [p (recursive-path [] p
            (if-path sequential?
              [INDEXED-VALS
               (if-path [LAST (pred= v)]
                 FIRST
                 [(collect-one FIRST) LAST p]
                 )]))]
    (let [ret (select-first p data)]
      (if (vector? ret) ret [ret])
      )))
</pre></z><z id="t1503263743" t="souenzzo Mine, w/o specter but works on maps and find &quot;all&quot; routes (defn find-index-route &quot;find all routes to some value&quot; ([k x] (find-index-route k x [])) ([k x p] (cond (= k x) [p] (coll? x) (-&gt;&gt; (if (map? x) x (vec x)) (reduce-kv (fn [acc i v] (into (vec (find-index-route k v (conj p i))) acc)) [])) :else nil))) "><y>#</y><d>2017-08-20</d><h>21:15</h><r>souenzzo</r>Mine, w/o specter but works on maps and find &quot;all&quot; routes
<pre>(defn find-index-route
  &quot;find all routes to some value&quot;
  ([k x] (find-index-route k x []))
  ([k x p]
   (cond
     (= k x) [p]
     (coll? x) (-&gt;&gt; (if (map? x) x (vec x))
                    (reduce-kv (fn [acc i v]
                                 (into (vec (find-index-route k v (conj p i))) acc)) []))
     :else nil)))
</pre></z><z id="t1503300706" t="nathanmarz @U2J4FRT2T a slight modification makes the specter version work for maps as well: (defn find-index-route [v data] (let [p (recursive-path [] p [(if-path map? ALL INDEXED-VALS) (if-path [LAST (pred= v)] FIRST [(collect-one FIRST) LAST coll? p] )])] (let [ret (select-first p data)] (if (or (nil? ret) (vector? ret)) ret [ret]) ))) "><y>#</y><d>2017-08-21</d><h>07:31</h><r>nathanmarz</r>@U2J4FRT2T a slight modification makes the specter version work for maps as well:
<pre>(defn find-index-route [v data]
  (let [p (recursive-path [] p
            [(if-path map? ALL INDEXED-VALS)
             (if-path [LAST (pred= v)]
               FIRST
               [(collect-one FIRST) LAST coll? p]
               )])]
    (let [ret (select-first p data)]
      (if (or (nil? ret) (vector? ret)) ret [ret])
      )))
</pre></z><z id="t1503317335" t="michaelwfogleman pred= and friends are great!"><y>#</y><d>2017-08-21</d><h>12:08</h><w>michaelwfogleman</w>pred= and friends are great!</z><z id="t1503318266" t="michaelwfogleman @nathanmarz Is it possible to contribute to the Specter wiki?"><y>#</y><d>2017-08-21</d><h>12:24</h><w>michaelwfogleman</w>@nathanmarz Is it possible to contribute to the Specter wiki?</z><z id="t1503318331" t="michaelwfogleman When you first mentioned recursive-path, I noticed it wasn&apos;t documented (in the Macros section?). I dug up the mention in Changes.MD that had an example. I cloned the wiki and made a change locally but would like to contribute it"><y>#</y><d>2017-08-21</d><h>12:25</h><w>michaelwfogleman</w>When you first mentioned recursive-path, I noticed it wasn&apos;t documented (in the Macros section?). I dug up the mention in Changes.MD that had an example. I cloned the wiki and made a change locally but would like to contribute it</z><z id="t1503319230" t="nathanmarz @michaelwfogleman yea, I wish github had a way to make pull requests for project wikis"><y>#</y><d>2017-08-21</d><h>12:40</h><w>nathanmarz</w>@michaelwfogleman yea, I wish github had a way to make pull requests for project wikis</z><z id="t1503319258" t="nathanmarz maybe I can make the specter wiki its own project and keep it in sync myself"><y>#</y><d>2017-08-21</d><h>12:40</h><w>nathanmarz</w>maybe I can make the specter wiki its own project and keep it in sync myself</z><z id="t1503319385" t="nathanmarz @michaelwfogleman ok, make a pull request to https://github.com/nathanmarz/specter-wiki"><y>#</y><d>2017-08-21</d><h>12:43</h><w>nathanmarz</w>@michaelwfogleman ok, make a pull request to <a href="https://github.com/nathanmarz/specter-wiki" target="_blank">https://github.com/nathanmarz/specter-wiki</a></z><z id="t1503319598" t="michaelwfogleman Awesome! Done!"><y>#</y><d>2017-08-21</d><h>12:46</h><w>michaelwfogleman</w>Awesome! Done!</z><z id="t1503319616" t="michaelwfogleman Happy to tweak the documentation if it&apos;s not quite right. 🙂"><y>#</y><d>2017-08-21</d><h>12:46</h><w>michaelwfogleman</w>Happy to tweak the documentation if it&apos;s not quite right. <b>🙂</b></z><z id="t1503319818" t="nathanmarz awesome, merged"><y>#</y><d>2017-08-21</d><h>12:50</h><w>nathanmarz</w>awesome, merged</z><z id="t1503319832" t="nathanmarz should probably add example of transform and an example of a parameterized recursive-path"><y>#</y><d>2017-08-21</d><h>12:50</h><w>nathanmarz</w>should probably add example of transform and an example of a parameterized recursive-path</z><z id="t1503319901" t="nathanmarz can open issues on specter-wiki repository for anything you find that&apos;s lacking"><y>#</y><d>2017-08-21</d><h>12:51</h><w>nathanmarz</w>can open issues on specter-wiki repository for anything you find that&apos;s lacking</z><z id="t1503319909" t="nathanmarz (which is probably a lot of things)"><y>#</y><d>2017-08-21</d><h>12:51</h><w>nathanmarz</w>(which is probably a lot of things)</z><z id="t1503320303" t="twillis hello, just discovered specter yesterday and I thought it might help me transforming honeysql queries. for example given... {:select (:*), :from (:table), :where [:or [:and [:= :a 1] [:b 1]] [:and [:= :c 1] [:= :d 1]]]} example: if i need to add [:= :active true] to each clause. having trouble specifying the path past [:where ALL] , i guess it&apos;s a problem with the sequences having a keyword as the first element."><y>#</y><d>2017-08-21</d><h>12:58</h><w>twillis</w>hello, just discovered specter yesterday and I thought it might help me transforming honeysql queries. for example given...


<pre>{:select (:*), :from (:table), :where [:or [:and [:= :a 1] [:b 1]] [:and [:= :c 1] [:= :d 1]]]}
</pre>

example: if i need to add <code>[:= :active true]</code> to each clause. 

having trouble specifying the path past <code>[:where ALL]</code> , i guess it&apos;s a problem with the sequences having a keyword as the first element.</z><z id="t1503325612" t="nathanmarz @twillis do you want to add that clause to the top-level of :where (e.g. [:and [:= :active true] [:or ...]] ) or within each :and clause?"><y>#</y><d>2017-08-21</d><h>14:26</h><w>nathanmarz</w>@twillis do you want to add that clause to the top-level of <code>:where</code> (e.g. <code>[:and [:= :active true] [:or ...]]</code>) or within each <code>:and</code> clause?</z><z id="t1503325698" t="nathanmarz if the latter you&apos;ll probably need a recursive path since :and and :or can nest arbitrarily"><y>#</y><d>2017-08-21</d><h>14:28</h><w>nathanmarz</w>if the latter you&apos;ll probably need a recursive path since <code>:and</code> and <code>:or</code> can nest arbitrarily</z><z id="t1503325949" t="twillis well in the above example I was thinking of adding to each clause but it was just an arbitrary example. but I think the issue i&apos;m having is that I dont know how to get to things in a vector where the first item is a keyword."><y>#</y><d>2017-08-21</d><h>14:32</h><w>twillis</w>well in the above example I was thinking of adding to each clause but it was just an arbitrary example. but I think the issue i&apos;m having is that I dont know how to get to things in a vector where the first item is a keyword.</z><z id="t1503326314" t="nathanmarz you can use this to navigate to each node in tree: (def TreeNodes (recursive-path [] p (if-path sequential? (continue-then-stay ALL p) STAY ))) "><y>#</y><d>2017-08-21</d><h>14:38</h><w>nathanmarz</w>you can use this to navigate to each node in tree: 
<pre>(def TreeNodes
    (recursive-path [] p
     (if-path sequential?
       (continue-then-stay ALL p)
       STAY
       )))
</pre></z><z id="t1503326512" t="nathanmarz then something like this for your transform: (setval [:where TreeNodes vector? (selected? FIRST (pred= :and)) AFTER-ELEM] [:= :active true] data) "><y>#</y><d>2017-08-21</d><h>14:41</h><w>nathanmarz</w>then something like this for your transform:
<pre>(setval [:where TreeNodes vector? (selected? FIRST (pred= :and)) AFTER-ELEM] [:= :active true] data)
</pre> </z><z id="t1503326727" t="twillis ok thanks for your help @nathanmarz"><y>#</y><d>2017-08-21</d><h>14:45</h><w>twillis</w>ok thanks for your help @nathanmarz</z><z id="t1503338358" t="urbank Hm... where does pred= come from? Is it just a user defined function?"><y>#</y><d>2017-08-21</d><h>17:59</h><w>urbank</w>Hm... where does <code>pred=</code> come from? Is it just a user defined function?</z><z id="t1503338473" t="urbank Oh, it&apos;s a specter function. Didn&apos;t notice that none of the functions were namespaced in the samples"><y>#</y><d>2017-08-21</d><h>18:01</h><w>urbank</w>Oh, it&apos;s a specter function. Didn&apos;t notice that none of the functions were namespaced in the samples</z><z id="t1503338833" t="nathanmarz it&apos;s just a convenience, same as #(= % some-val)"><y>#</y><d>2017-08-21</d><h>18:07</h><w>nathanmarz</w>it&apos;s just a convenience, same as <code>#(= % some-val)</code></z><z id="t1503338994" t="urbank Yeah, figured. Just thought it was a part of clojure core or something"><y>#</y><d>2017-08-21</d><h>18:09</h><w>urbank</w>Yeah, figured. Just thought it was a part of clojure core or something</z><z id="t1503531148" t="lvh Is there some way to coalesce a bunch of sequential transforms, and would there be a performance benefit from doing so?"><y>#</y><d>2017-08-23</d><h>23:32</h><w>lvh</w>Is there some way to coalesce a bunch of sequential transforms, and would there be a performance benefit from doing so?</z><z id="t1503531156" t="lvh (My transforms don’t commute.)"><y>#</y><d>2017-08-23</d><h>23:32</h><w>lvh</w>(My transforms don’t commute.)</z><z id="t1503538318" t="nathanmarz @lvh if there&apos;s shared navigation among the transforms then multi-transform can be used for major performance gains"><y>#</y><d>2017-08-24</d><h>01:31</h><w>nathanmarz</w>@lvh if there&apos;s shared navigation among the transforms then <code>multi-transform</code> can be used for major performance gains</z><z id="t1503538442" t="nathanmarz a couple examples from benchmarks: https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L336"><y>#</y><d>2017-08-24</d><h>01:34</h><w>nathanmarz</w>a couple examples from benchmarks: <a href="https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L336" target="_blank">https://github.com/nathanmarz/specter/blob/master/scripts/benchmarks.clj#L336</a></z><z id="t1503683635" t="sandbags @nathanmarz here&apos;s my use case, see if you think Specter makes this easier. I&apos;m building a library for modular behaviour trees. i&apos;ve decided to represent these as nested vectors a la Hiccup markup so, for example [:selector [:loop {:count 99} [:sequence [:randomly {:p 0.5} [:foo]] [:randomly {:p 0.25} [:bar]] [:baz]]]]"><y>#</y><d>2017-08-25</d><h>17:53</h><w>sandbags</w>@nathanmarz here&apos;s my use case, see if you think Specter makes this easier. I&apos;m building a library for modular behaviour trees. i&apos;ve decided to represent these as nested vectors a la Hiccup markup so, for example <code>[:selector [:loop {:count 99} [:sequence [:randomly {:p 0.5} [:foo]] [:randomly {:p 0.25} [:bar]] [:baz]]]]</code></z><z id="t1503683699" t="sandbags what i want to do is (1) label each vector with an autogenerated id, (2) check that required options are specified (e.g. :loop must always have a :count option) (3) check required number of children is specified (e.g. :loop always has exactly 1 child)"><y>#</y><d>2017-08-25</d><h>17:54</h><w>sandbags</w>what i want to do is (1) label each vector with an autogenerated id, (2) check that required options are specified (e.g. <code>:loop</code> must always have a <code>:count</code> option) (3) check required number of children is specified (e.g. <code>:loop</code> always has exactly 1 child)</z><z id="t1503683740" t="sandbags i have code doing this based on postwalk (well i&apos;ve not done 3 yet but it&apos;s a trivial modification of 2)"><y>#</y><d>2017-08-25</d><h>17:55</h><w>sandbags</w>i have code doing this based on postwalk (well i&apos;ve not done 3 yet but it&apos;s a trivial modification of 2)</z><z id="t1503683766" t="sandbags at the moment I am hoisting the options map (and the id) into the metadata for the vector"><y>#</y><d>2017-08-25</d><h>17:56</h><w>sandbags</w>at the moment I am hoisting the options map (and the id) into the metadata for the vector</z><z id="t1503683797" t="sandbags i&apos;m undecided whether a better approach would be to add an options map to all vectors and put the id in there instead"><y>#</y><d>2017-08-25</d><h>17:56</h><w>sandbags</w>i&apos;m undecided whether a better approach would be to add an options map to all vectors and put the id in there instead</z><z id="t1503685294" t="nathanmarz @sandbags yes, this is exactly the kind of stuff specter excels at"><y>#</y><d>2017-08-25</d><h>18:21</h><w>nathanmarz</w>@sandbags yes, this is exactly the kind of stuff specter excels at</z><z id="t1503685303" t="nathanmarz i&apos;ll show you an example"><y>#</y><d>2017-08-25</d><h>18:21</h><w>nathanmarz</w>i&apos;ll show you an example</z><z id="t1503685497" t="sandbags (one thing that the walk approach does not seem to make particularly easy is giving diagnostic information)"><y>#</y><d>2017-08-25</d><h>18:24</h><w>sandbags</w>(one thing that the walk approach does not seem to make particularly easy is giving diagnostic information)</z><z id="t1503685527" t="nathanmarz (def data [:selector [:loop {:count 99} [:sequence [:randomly {:p 0.5} [:foo]] [:randomly {:p 0.25} [:bar]] [:baz]]]]) (def ALL-VECTORS (recursive-path [] p (if-path vector? (continue-then-stay ALL p)))) (let [data2 (transform (subselect ALL-VECTORS META :id) (fn [s] (-&gt; s count range)) data)] (select [ALL-VECTORS (collect-one META :id)] data2)) ;; =&gt; [[0 [:foo]] [1 [:randomly {:p 0.5} [:foo]]] [2 [:bar]] [3 [:randomly {:p 0.25} [:bar]]] [4 [:baz]] [5 [:sequence [:randomly {:p 0.5} [:foo]] [:randomly {:p 0.25} [:bar]] [:baz]]] [6 [:loop {:count 99} [:sequence [:randomly {:p 0.5} [:foo]] [:randomly {:p 0.25} [:bar]] [:baz]]]] [7 [:selector [:loop {:count 99} [:sequence [:randomly {:p 0.5} [:foo]] [:randomly {:p 0.25} [:bar]] [:baz]]]]]] "><y>#</y><d>2017-08-25</d><h>18:25</h><w>nathanmarz</w><pre>(def data [:selector [:loop {:count 99} [:sequence [:randomly {:p 0.5} [:foo]] [:randomly {:p 0.25} [:bar]] [:baz]]]])

(def ALL-VECTORS
  (recursive-path [] p
    (if-path vector?
      (continue-then-stay ALL p))))

(let [data2 (transform (subselect ALL-VECTORS META :id) (fn [s] (-&gt; s count range)) data)]
  (select [ALL-VECTORS (collect-one META :id)] data2))
;; =&gt;
[[0 [:foo]]
 [1 [:randomly {:p 0.5} [:foo]]]
 [2 [:bar]]
 [3 [:randomly {:p 0.25} [:bar]]]
 [4 [:baz]]
 [5
  [:sequence
   [:randomly {:p 0.5} [:foo]]
   [:randomly {:p 0.25} [:bar]]
   [:baz]]]
 [6
  [:loop
   {:count 99}
   [:sequence
    [:randomly {:p 0.5} [:foo]]
    [:randomly {:p 0.25} [:bar]]
    [:baz]]]]
 [7
  [:selector
   [:loop
    {:count 99}
    [:sequence
     [:randomly {:p 0.5} [:foo]]
     [:randomly {:p 0.25} [:bar]]
     [:baz]]]]]]
</pre></z><z id="t1503685566" t="nathanmarz that&apos;s adding the auto-generated id to the metadata of each vector, the select call is just so you can see what it did"><y>#</y><d>2017-08-25</d><h>18:26</h><w>nathanmarz</w>that&apos;s adding the auto-generated id to the metadata of each vector, the <code>select</code> call is just so you can see what it did</z><z id="t1503685644" t="sandbags interesting, thank you"><y>#</y><d>2017-08-25</d><h>18:27</h><w>sandbags</w>interesting, thank you</z><z id="t1503685681" t="sandbags i definitely need to go back and read the docs again"><y>#</y><d>2017-08-25</d><h>18:28</h><w>sandbags</w>i definitely need to go back and read the docs again</z><z id="t1503685768" t="nathanmarz here&apos;s how you could insert ids at index 1 of each vector: (transform (subselect ALL-VECTORS (srange 1 1)) (fn [s] (-&gt;&gt; s count range (map vector))) data) ;;=&gt; [:selector 7 [:loop 6 {:count 99} [:sequence 5 [:randomly 1 {:p 0.5} [:foo 0]] [:randomly 3 {:p 0.25} [:bar 2]] [:baz 4]]]] "><y>#</y><d>2017-08-25</d><h>18:29</h><w>nathanmarz</w>here&apos;s how you could insert ids at index 1 of each vector:
<pre>(transform (subselect ALL-VECTORS (srange 1 1)) (fn [s] (-&gt;&gt; s count range (map vector))) data)
;;=&gt; [:selector 7 [:loop 6 {:count 99} [:sequence 5 [:randomly 1 {:p 0.5} [:foo 0]] [:randomly 3 {:p 0.25} [:bar 2]] [:baz 4]]]]
</pre></z><z id="t1503685958" t="nathanmarz and as one last example, here&apos;s how you would manipulate a particular node type in the tree: (defn node-type [kw] (path (selected? FIRST (pred= kw)))) (transform [ALL-VECTORS (node-type :randomly) (nthpath 1) :p] #(* 2 %) data) ;; =&gt; [:selector [:loop {:count 99} [:sequence [:randomly {:p 1.0} [:foo]] [:randomly {:p 0.5} [:bar]] [:baz]]]] "><y>#</y><d>2017-08-25</d><h>18:32</h><w>nathanmarz</w>and as one last example, here&apos;s how you would manipulate a particular node type in the tree:
<pre>(defn node-type [kw] (path (selected? FIRST (pred= kw))))

(transform [ALL-VECTORS (node-type :randomly) (nthpath 1) :p] #(* 2 %) data)
;; =&gt; [:selector [:loop {:count 99} [:sequence [:randomly {:p 1.0} [:foo]] [:randomly {:p 0.5} [:bar]] [:baz]]]]
</pre></z><z id="t1503686009" t="sandbags that&apos;s very cute"><y>#</y><d>2017-08-25</d><h>18:33</h><w>sandbags</w>that&apos;s very cute</z><z id="t1503686078" t="sandbags it&apos;s really a shame Specter isn&apos;t better known. I know about it and a number of times i&apos;ve messed around for hours with walk/zippers etc. trying to do something that would have been easier with a bit of Specter"><y>#</y><d>2017-08-25</d><h>18:34</h><w>sandbags</w>it&apos;s really a shame Specter isn&apos;t better known. I know about it and a number of times i&apos;ve messed around for hours with walk/zippers etc. trying to do something that would have been easier with a bit of Specter</z><z id="t1503686217" t="nathanmarz I consider it essential for immutable programming"><y>#</y><d>2017-08-25</d><h>18:36</h><w>nathanmarz</w>I consider it essential for immutable programming</z><z id="t1503686238" t="nathanmarz I&apos;ve encountered a surprising amount of resistance to it though"><y>#</y><d>2017-08-25</d><h>18:37</h><w>nathanmarz</w>I&apos;ve encountered a surprising amount of resistance to it though</z><z id="t1503686241" t="sandbags i guess one downside (but probably just inherent in this kind of complex structure bending) is that those expressions take some real picking apart"><y>#</y><d>2017-08-25</d><h>18:37</h><w>sandbags</w>i guess one downside (but probably just inherent in this kind of complex structure bending) is that those expressions take some real picking apart</z></g><g id="s14"><z id="t1503686268" t="sandbags it&apos;s always going to make for a bit of a learning hill"><y>#</y><d>2017-08-25</d><h>18:37</h><w>sandbags</w>it&apos;s always going to make for a bit of a learning hill</z><z id="t1503686273" t="nathanmarz I wouldn&apos;t consider conciseness a downside, but the opposite"><y>#</y><d>2017-08-25</d><h>18:37</h><w>nathanmarz</w>I wouldn&apos;t consider conciseness a downside, but the opposite</z><z id="t1503686276" t="nathanmarz definitely a learning curve"><y>#</y><d>2017-08-25</d><h>18:37</h><w>nathanmarz</w>definitely a learning curve</z><z id="t1503686290" t="nathanmarz what you&apos;re seeing here is the result after me learning this stuff for years"><y>#</y><d>2017-08-25</d><h>18:38</h><w>nathanmarz</w>what you&apos;re seeing here is the result after me learning this stuff for years</z><z id="t1503686295" t="sandbags that&apos;s what i mean"><y>#</y><d>2017-08-25</d><h>18:38</h><w>sandbags</w>that&apos;s what i mean</z><z id="t1503686317" t="nathanmarz it&apos;s a different way of thinking"><y>#</y><d>2017-08-25</d><h>18:38</h><w>nathanmarz</w>it&apos;s a different way of thinking</z><z id="t1503686351" t="nathanmarz but it brings true simplicity and an incredible amount of power over your data"><y>#</y><d>2017-08-25</d><h>18:39</h><w>nathanmarz</w>but it brings true simplicity and an incredible amount of power over your data</z><z id="t1503686382" t="sandbags i don&apos;t doubt it"><y>#</y><d>2017-08-25</d><h>18:39</h><w>sandbags</w>i don&apos;t doubt it</z><z id="t1503686536" t="sandbags what do Rich &amp; co. make of it?"><y>#</y><d>2017-08-25</d><h>18:42</h><w>sandbags</w>what do Rich &amp; co. make of it?</z><z id="t1503686582" t="nathanmarz no idea, I&apos;m curious about that myself"><y>#</y><d>2017-08-25</d><h>18:43</h><w>nathanmarz</w>no idea, I&apos;m curious about that myself</z><z id="t1503686599" t="nathanmarz they haven&apos;t said anything about it to my knowledge"><y>#</y><d>2017-08-25</d><h>18:43</h><w>nathanmarz</w>they haven&apos;t said anything about it to my knowledge</z><z id="t1503686618" t="sandbags Stuart Holloway, for example, I should have thought would find this interesting."><y>#</y><d>2017-08-25</d><h>18:43</h><w>sandbags</w>Stuart Holloway, for example, I should have thought would find this interesting.</z><z id="t1503686828" t="nathanmarz I suggested contributing specter to clojure awhile back, but the response from core team was &quot;no&quot; with minimal explanation https://groups.google.com/forum/#!searchin/clojure/contribute$20specter%7Csort:relevance/clojure/qN1UPMVQmaM/uegIimKjCwAJ"><y>#</y><d>2017-08-25</d><h>18:47</h><w>nathanmarz</w>I suggested contributing specter to clojure awhile back, but the response from core team was &quot;no&quot; with minimal explanation <a href="https://groups.google.com/forum/#!searchin/clojure/contribute$20specter%7Csort:relevance/clojure/qN1UPMVQmaM/uegIimKjCwAJ" target="_blank">https://groups.google.com/forum/#!searchin/clojure/contribute$20specter%7Csort:relevance/clojure/qN1UPMVQmaM/uegIimKjCwAJ</a></z><z id="t1503686929" t="nathanmarz also saw this recently which makes me think rich would have serious problems with specter: https://gist.github.com/reborg/dc8b0c96c397a56668905e2767fd697f"><y>#</y><d>2017-08-25</d><h>18:48</h><w>nathanmarz</w>also saw this recently which makes me think rich would have serious problems with specter: <a href="https://gist.github.com/reborg/dc8b0c96c397a56668905e2767fd697f" target="_blank">https://gist.github.com/reborg/dc8b0c96c397a56668905e2767fd697f</a></z><z id="t1503687014" t="nathanmarz since he&apos;s philosophically against the same function having different performance characteristics on different datatypes, he won&apos;t like how I designed the navigators"><y>#</y><d>2017-08-25</d><h>18:50</h><w>nathanmarz</w>since he&apos;s philosophically against the same function having different performance characteristics on different datatypes, he won&apos;t like how I designed the navigators</z><z id="t1503687061" t="nathanmarz nthpath for instance being O(n) on lists but faster on vectors (O(log n) I think)"><y>#</y><d>2017-08-25</d><h>18:51</h><w>nathanmarz</w><code>nthpath</code> for instance being O(n) on lists but faster on vectors (O(log n) I think)</z><z id="t1503687517" t="sandbags hrmmm"><y>#</y><d>2017-08-25</d><h>18:58</h><w>sandbags</w>hrmmm</z><z id="t1503687847" t="sandbags Ah well, perhaps for the best anyway"><y>#</y><d>2017-08-25</d><h>19:04</h><w>sandbags</w>Ah well, perhaps for the best anyway</z><z id="t1503851138" t="franquito Hi! I&apos;ve been thinking of defining a new path with parameters. I saw that paramsfn is not available anymore. Now, I think of two possible ways to define the path: (defn [&amp; params] (spec/path ...)) or with declarepath and providepath (BTW, for this last pair of functions there&apos;s not an example of using parameters on the wiki). Which one should I use? 🤔"><y>#</y><d>2017-08-27</d><h>16:25</h><w>franquito</w>Hi! I&apos;ve been thinking of defining a new path with parameters. I saw that <code>paramsfn</code> is not available anymore. Now, I think of two possible ways to define the path: <code>(defn [&amp; params] (spec/path ...))</code> or with <code>declarepath</code> and <code>providepath</code> (BTW, for this last pair of functions there&apos;s not an example of using parameters on the wiki). Which one should I use? <b>🤔</b></z><z id="t1503855690" t="nathanmarz @franquito just use defn and define the returned path with path"><y>#</y><d>2017-08-27</d><h>17:41</h><w>nathanmarz</w>@franquito just use <code>defn</code> and define the returned path with <code>path</code></z><z id="t1503855975" t="nathanmarz examples: https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L843"><y>#</y><d>2017-08-27</d><h>17:46</h><w>nathanmarz</w>examples: <a href="https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L843" target="_blank">https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L843</a></z><z id="t1503857367" t="franquito Sweet! Thank you very much Nathan!"><y>#</y><d>2017-08-27</d><h>18:09</h><w>franquito</w>Sweet! Thank you very much Nathan!</z><z id="t1503950023" t="alexyakushev Hi, I remember I saw something somewhere about Specter supporting iteration over multiple sequences (like Clojure&apos;s map does). Maybe, it was an explanation why Specter doesn&apos;t have this; anyway, I can&apos;t find the link. Can anyone help? A pointer how to work around this problem would be nice too. Thanks!"><y>#</y><d>2017-08-28</d><h>19:53</h><w>alexyakushev</w>Hi, I remember I saw something somewhere about Specter supporting iteration over multiple sequences (like Clojure&apos;s <code>map</code> does). Maybe, it was an explanation why Specter doesn&apos;t have this; anyway, I can&apos;t find the link. Can anyone help? A pointer how to work around this problem would be nice too. Thanks!</z><z id="t1503950209" t="nathanmarz @alexyakushev no, Specter doesn&apos;t support that"><y>#</y><d>2017-08-28</d><h>19:56</h><w>nathanmarz</w>@alexyakushev no, Specter doesn&apos;t support that</z><z id="t1503950298" t="nathanmarz besides questions of how to do a performant implementation of that, there&apos;s questions of semantics too"><y>#</y><d>2017-08-28</d><h>19:58</h><w>nathanmarz</w>besides questions of how to do a performant implementation of that, there&apos;s questions of semantics too</z><z id="t1503950323" t="nathanmarz for instance, what would an ALL transform on a vector and a map produce?"><y>#</y><d>2017-08-28</d><h>19:58</h><w>nathanmarz</w>for instance, what would an <code>ALL</code> transform on a vector and a map produce?</z><z id="t1503950503" t="alexyakushev @nathanmarz Yeah, I thought it was something along these lines. map was always an outlier among other sequence processing functions, it makes sense that Specter doesn&apos;t have it. Regarding my problem, I need to merge two lists of lists of lists of maps. Without Specter, I solved it with an abhorrent lasagna of (partial map ...) . Can Specter help here somehow?"><y>#</y><d>2017-08-28</d><h>20:01</h><w>alexyakushev</w>@nathanmarz Yeah, I thought it was something along these lines. <code>map</code> was always an outlier among other sequence processing functions, it makes sense that Specter doesn&apos;t have it.
Regarding my problem, I need to <code>merge</code> two lists of lists of lists of maps. Without Specter, I solved it with an abhorrent lasagna of <code>(partial map ...)</code>. Can Specter help here somehow?</z><z id="t1503950873" t="nathanmarz @alexyakushev unfortunately not"><y>#</y><d>2017-08-28</d><h>20:07</h><w>nathanmarz</w>@alexyakushev unfortunately not</z><z id="t1503950889" t="nathanmarz I had an idea open awhile ago that would have helped, or an extension of it https://github.com/nathanmarz/specter/issues/49"><y>#</y><d>2017-08-28</d><h>20:08</h><w>nathanmarz</w>I had an idea open awhile ago that would have helped, or an extension of it <a href="https://github.com/nathanmarz/specter/issues/49" target="_blank">https://github.com/nathanmarz/specter/issues/49</a></z><z id="t1503950928" t="nathanmarz basically you locate the specific paths to elements you care about, then use the element-specific path to get the corresponding value in the other data structure"><y>#</y><d>2017-08-28</d><h>20:08</h><w>nathanmarz</w>basically you <code>locate</code> the specific paths to elements you care about, then use the element-specific path to get the corresponding value in the other data structure</z><z id="t1503951021" t="nathanmarz locate is complicated to implement especially for substructure navigators like srange"><y>#</y><d>2017-08-28</d><h>20:10</h><w>nathanmarz</w><code>locate</code> is complicated to implement especially for substructure navigators like <code>srange</code></z><z id="t1503951130" t="nathanmarz I hadn&apos;t thought before about how something like locate would help with processing multiple data structures together"><y>#</y><d>2017-08-28</d><h>20:12</h><w>nathanmarz</w>I hadn&apos;t thought before about how something like <code>locate</code> would help with processing multiple data structures together</z><z id="t1503951893" t="alexyakushev @nathanmarz Thanks! This is still quite helpful."><y>#</y><d>2017-08-28</d><h>20:24</h><w>alexyakushev</w>@nathanmarz Thanks! This is still quite helpful.</z><z id="t1503952085" t="nathanmarz I ended up implementing something different than locate as described in that ticket, but this might be worth considering again"><y>#</y><d>2017-08-28</d><h>20:28</h><w>nathanmarz</w>I ended up implementing something different than <code>locate</code> as described in that ticket, but this might be worth considering again</z><z id="t1503952119" t="nathanmarz Having a broader set of use cases would be needed to understand how to spec the new operation"><y>#</y><d>2017-08-28</d><h>20:28</h><w>nathanmarz</w>Having a broader set of use cases would be needed to understand how to spec the new operation</z><z id="t1503952793" t="nathanmarz https://github.com/nathanmarz/specter/issues/229"><y>#</y><d>2017-08-28</d><h>20:39</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/issues/229" target="_blank">https://github.com/nathanmarz/specter/issues/229</a></z><z id="t1504031801" t="urzds Hi!"><y>#</y><d>2017-08-29</d><h>18:36</h><w>urzds</w>Hi!</z><z id="t1504032254" t="urzds I have an ip-pool {&quot;127.0.0.1&quot; {:k v}} and would like to get first IP where :k is nil . How would I do that? I would hope to get a more readable version of (first (first (filter #(nil? (:k (second %))) ip-pool)"><y>#</y><d>2017-08-29</d><h>18:44</h><w>urzds</w>I have an ip-pool <code>{&quot;127.0.0.1&quot; {:k v}}</code> and would like to get first IP where <code>:k</code> is <code>nil</code>. How would I do that? I would hope to get a more readable version of <code>(first (first (filter #(nil? (:k (second %))) ip-pool)</code></z><z id="t1504032383" t="nathanmarz @urzds what does &quot;first&quot; mean in this context given that your input is an unsorted map?"><y>#</y><d>2017-08-29</d><h>18:46</h><w>nathanmarz</w>@urzds what does &quot;first&quot; mean in this context given that your input is an unsorted map?</z><z id="t1504032409" t="urzds any, but one is enough"><y>#</y><d>2017-08-29</d><h>18:46</h><w>urzds</w>any, but one is enough</z><z id="t1504032495" t="urzds i.e. I don&apos;t care which one, but I want only one and not more. The result shall be the key, i.e. a string, e.g. &quot;127.0.0.1&quot;."><y>#</y><d>2017-08-29</d><h>18:48</h><w>urzds</w>i.e. I don&apos;t care which one, but I want only one and not more. The result shall be the key, i.e. a string, e.g. &quot;127.0.0.1&quot;.</z><z id="t1504032624" t="urzds I don&apos;t like the regular-Clojure version I wrote above, because it is not immediately clear what the two first s mean. second can be deduced, if one knows ip-pool is a map and how filter works, but I find the two first to be not obvious enough."><y>#</y><d>2017-08-29</d><h>18:50</h><w>urzds</w>I don&apos;t like the regular-Clojure version I wrote above, because it is not immediately clear what the two <code>first</code>s mean. <code>second</code> can be deduced, if one knows <code>ip-pool</code> is a map and how <code>filter</code> works, but I find the two <code>first</code> to be not obvious enough.</z><z id="t1504032808" t="nathanmarz @urzds (def data {&quot;127.0.0.1&quot; {:k 3} &quot;127.0.0.2&quot; {} &quot;127.0.0.3&quot; {:b 2}}) (select-first [ALL (selected? LAST :k nil?) FIRST] data) "><y>#</y><d>2017-08-29</d><h>18:53</h><w>nathanmarz</w>@urzds 
<pre>(def data {&quot;127.0.0.1&quot; {:k 3} &quot;127.0.0.2&quot; {} &quot;127.0.0.3&quot; {:b 2}})
(select-first [ALL (selected? LAST :k nil?) FIRST] data)
</pre></z><z id="t1504032835" t="nathanmarz if you want all of them just change select-first to select"><y>#</y><d>2017-08-29</d><h>18:53</h><w>nathanmarz</w>if you want all of them just change <code>select-first</code> to <code>select</code></z><z id="t1504032988" t="urzds (selected? ...) is basically like (some? (select ...)) ?"><y>#</y><d>2017-08-29</d><h>18:56</h><w>urzds</w><code>(selected? ...)</code> is basically like <code>(some? (select ...))</code>?</z><z id="t1504033070" t="nathanmarz it&apos;s like (not (empty? (select ...))) except it runs far more efficiently than that"><y>#</y><d>2017-08-29</d><h>18:57</h><w>nathanmarz</w>it&apos;s like <code>(not (empty? (select ...)))</code> except it runs far more efficiently than that</z><z id="t1504033102" t="nathanmarz no materialization of intermediate sequences and stops traversal as soon as it matches something"><y>#</y><d>2017-08-29</d><h>18:58</h><w>nathanmarz</w>no materialization of intermediate sequences and stops traversal as soon as it matches something</z><z id="t1504033109" t="nathanmarz same as select-first"><y>#</y><d>2017-08-29</d><h>18:58</h><w>nathanmarz</w>same as <code>select-first</code></z><z id="t1504033136" t="urzds Thanks."><y>#</y><d>2017-08-29</d><h>18:58</h><w>urzds</w>Thanks.</z><z id="t1504033141" t="urzds Guess I should alias LAST to VALUE and FIRST to KEY. That might make it easier to read..."><y>#</y><d>2017-08-29</d><h>18:59</h><w>urzds</w>Guess I should alias LAST to VALUE and FIRST to KEY. That might make it easier to read...</z><z id="t1504033177" t="nathanmarz yea, that&apos;s easy enough"><y>#</y><d>2017-08-29</d><h>18:59</h><w>nathanmarz</w>yea, that&apos;s easy enough</z><z id="t1504033232" t="urzds If I wanted to select the IP address where :k is 1, I would run (select-first [ALL (selected? LAST :k #(= % 1)) FIRST] data) ?"><y>#</y><d>2017-08-29</d><h>19:00</h><w>urzds</w>If I wanted to select the IP address where <code>:k</code> is 1, I would run <code>(select-first [ALL (selected? LAST :k #(= % 1)) FIRST] data)</code> ?</z><z id="t1504033283" t="nathanmarz yea"><y>#</y><d>2017-08-29</d><h>19:01</h><w>nathanmarz</w>yea</z><z id="t1504033296" t="nathanmarz can also say (pred= 1) instead of the anonymous function"><y>#</y><d>2017-08-29</d><h>19:01</h><w>nathanmarz</w>can also say <code>(pred= 1)</code> instead of the anonymous function</z><z id="t1504033324" t="urzds pred= is defined by Specter?"><y>#</y><d>2017-08-29</d><h>19:02</h><w>urzds</w><code>pred=</code> is defined by Specter?</z><z id="t1504033327" t="nathanmarz yes"><y>#</y><d>2017-08-29</d><h>19:02</h><w>nathanmarz</w>yes</z><z id="t1504033343" t="nathanmarz there&apos;s also pred&gt; , pred&lt; , pred&lt;= , and pred&gt;="><y>#</y><d>2017-08-29</d><h>19:02</h><w>nathanmarz</w>there&apos;s also <code>pred&gt;</code>, <code>pred&lt;</code>, <code>pred&lt;=</code>, and <code>pred&gt;=</code></z><z id="t1504033353" t="nathanmarz just convenience navigators"><y>#</y><d>2017-08-29</d><h>19:02</h><w>nathanmarz</w>just convenience navigators</z><z id="t1504033365" t="nathanmarz I find it slightly more readable"><y>#</y><d>2017-08-29</d><h>19:02</h><w>nathanmarz</w>I find it slightly more readable</z><z id="t1504034217" t="urzds Thanks @nathanmarz !"><y>#</y><d>2017-08-29</d><h>19:16</h><w>urzds</w>Thanks @nathanmarz !</z><z id="t1504119717" t="lvh I have a data structure like: {:x {:a {:y 1} :b {:y 2} :c {:y 3}}} And I’d like {:a 1 :b 2 :c 3} . I can write the select path that gets the values: [:x (sr/multi-path :a :b :c) :y] , and I guess I can zipmap from there; but is there an elegant way to get specter to do that for me?"><y>#</y><d>2017-08-30</d><h>19:01</h><w>lvh</w>I have a data structure like:

<pre>{:x
 {:a {:y 1}
  :b {:y 2}
  :c {:y 3}}}
</pre>

And I’d like <code>{:a 1 :b 2 :c 3}</code>. I can write the select path that gets the values: <code>[:x (sr/multi-path :a :b :c) :y]</code>, and I guess I can zipmap from there; but is there an elegant way to get specter to do that for me?</z><z id="t1504119771" t="lvh sr/collect’ing the multi-path doesn’t really do what I expected: [[[{:y 1} {:y 2} {:y 3}] nil]]"><y>#</y><d>2017-08-30</d><h>19:02</h><w>lvh</w>sr/collect’ing the multi-path doesn’t really do what I expected:

<code>[[[{:y 1} {:y 2} {:y 3}] nil]]</code></z><z id="t1504120941" t="nathanmarz @lvh something like this? (select-any [:x (transformed MAP-VALS :y)] data)"><y>#</y><d>2017-08-30</d><h>19:22</h><w>nathanmarz</w>@lvh something like this? <code>(select-any [:x (transformed MAP-VALS :y)] data)</code></z><z id="t1504120998" t="lvh Cool; thanks! I guess my sample was a little underspecified; there are other keys in there I do not want; but I guess a multi-path instead of a MAP-VALS would probably do the trick; lemme try"><y>#</y><d>2017-08-30</d><h>19:23</h><w>lvh</w>Cool; thanks! I guess my sample was a little underspecified; there are other keys in there I do not want; but I guess a multi-path instead of a MAP-VALS would probably do the trick; lemme try</z><z id="t1504121076" t="nathanmarz for that you will want multi-transform with keys you don&apos;t want becoming (terminal-val NONE) and ones you do using (terminal :y)"><y>#</y><d>2017-08-30</d><h>19:24</h><w>nathanmarz</w>for that you will want multi-transform with keys you don&apos;t want becoming <code>(terminal-val NONE)</code> and ones you do using <code>(terminal :y)</code></z><z id="t1504121114" t="nathanmarz if you want to do it in a one-liner that is"><y>#</y><d>2017-08-30</d><h>19:25</h><w>nathanmarz</w>if you want to do it in a one-liner that is</z><z id="t1504121193" t="nathanmarz can also just do the select-any followed by a (setval [MAP-KEYS #{:k1 :k2 ...}] NONE data2)"><y>#</y><d>2017-08-30</d><h>19:26</h><w>nathanmarz</w>can also just do the <code>select-any</code> followed by a <code>(setval [MAP-KEYS #{:k1 :k2 ...}] NONE data2)</code></z><z id="t1504121226" t="nathanmarz I would just do the latter since there&apos;s no multi-transformed"><y>#</y><d>2017-08-30</d><h>19:27</h><w>nathanmarz</w>I would just do the latter since there&apos;s no <code>multi-transformed</code></z><z id="t1504121369" t="nathanmarz actually, just use submap before transformed"><y>#</y><d>2017-08-30</d><h>19:29</h><w>nathanmarz</w>actually, just use <code>submap</code> before <code>transformed</code></z><z id="t1504121375" t="nathanmarz that&apos;s the easiest and most efficient"><y>#</y><d>2017-08-30</d><h>19:29</h><w>nathanmarz</w>that&apos;s the easiest and most efficient</z><z id="t1504121428" t="nathanmarz [:x (submap [:k1 :k2...]) (transformed MAP-VALS :y)"><y>#</y><d>2017-08-30</d><h>19:30</h><w>nathanmarz</w><code>[:x (submap [:k1 :k2...]) (transformed MAP-VALS :y)</code></z><z id="t1504350229" t="hmaurer Quick question: is there a set of “laws” that navigators are expected to follow? For example, I assume I should expect the following: (= (select path structure) (transform path (fn [x] x) structure)) or (= 42 (select path (transform path (fn [_] 42) structure))) etc"><y>#</y><d>2017-09-02</d><h>11:03</h><w>hmaurer</w>Quick question: is there a set of “laws” that navigators are expected to follow? For example, I assume I should expect the following:
<pre>(= (select path structure) (transform path (fn [x] x) structure))
</pre>
or

<pre>(= 42 (select path (transform path (fn [_] 42) structure)))
</pre>
etc</z><z id="t1504352265" t="nathanmarz @hmaurer well, those are both not true"><y>#</y><d>2017-09-02</d><h>11:37</h><w>nathanmarz</w>@hmaurer well, those are both not true</z><z id="t1504352299" t="nathanmarz :a for first one, ALL for second one shows falsehood"><y>#</y><d>2017-09-02</d><h>11:38</h><w>nathanmarz</w><code>:a</code> for first one, <code>ALL</code> for second one shows falsehood</z><z id="t1504352303" t="hmaurer @nathanmarz ha! how so? transforming a path with the identity shouldn’t leave the values under that path unchanged?"><y>#</y><d>2017-09-02</d><h>11:38</h><w>hmaurer</w>@nathanmarz ha! how so? transforming a path with the identity shouldn’t leave the values under that path unchanged?</z><z id="t1504352335" t="hmaurer oh sorry, my first example had a typo"><y>#</y><d>2017-09-02</d><h>11:38</h><w>hmaurer</w>oh sorry, my first example had a typo</z><z id="t1504352348" t="hmaurer (= (select path structure) (select path (transform path (fn [x] x) structure))) "><y>#</y><d>2017-09-02</d><h>11:39</h><w>hmaurer</w><pre>(= (select path structure) (select path (transform path (fn [x] x) structure)))
</pre></z><z id="t1504352370" t="nathanmarz (transform (view inc) identity 1)"><y>#</y><d>2017-09-02</d><h>11:39</h><w>nathanmarz</w><code>(transform (view inc) identity 1)</code></z><z id="t1504352392" t="nathanmarz returns 2"><y>#</y><d>2017-09-02</d><h>11:39</h><w>nathanmarz</w>returns 2</z><z id="t1504352487" t="nathanmarz there&apos;s not any mathematical relations I can think of between select and transform"><y>#</y><d>2017-09-02</d><h>11:41</h><w>nathanmarz</w>there&apos;s not any mathematical relations I can think of between <code>select</code> and <code>transform</code></z><z id="t1504352505" t="nathanmarz only important property is that select and transform traverse same values in same order"><y>#</y><d>2017-09-02</d><h>11:41</h><w>nathanmarz</w>only important property is that <code>select</code> and <code>transform</code> traverse same values in same order</z><z id="t1504352518" t="nathanmarz that&apos;s necessary for subselect"><y>#</y><d>2017-09-02</d><h>11:41</h><w>nathanmarz</w>that&apos;s necessary for <code>subselect</code></z><z id="t1504352591" t="hmaurer @nathanmarz in the case of (view inc) , the invariant (= (select path structure) (select path (transform path (fn [x] x) structure))) holds as far as I can see"><y>#</y><d>2017-09-02</d><h>11:43</h><w>hmaurer</w>@nathanmarz in the case of <code>(view inc)</code>, the invariant
<pre>(= (select path structure) (select path (transform path (fn [x] x) structure)))
</pre>
holds as far as I can see</z><z id="t1504352623" t="hmaurer nevermind, it does not"><y>#</y><d>2017-09-02</d><h>11:43</h><w>hmaurer</w>nevermind, it does not</z><z id="t1504352630" t="hmaurer ok, thank you!"><y>#</y><d>2017-09-02</d><h>11:43</h><w>hmaurer</w>ok, thank you!</z><z id="t1504352682" t="hmaurer I need to wrap my head around paths that apply functions while navigating 😄"><y>#</y><d>2017-09-02</d><h>11:44</h><w>hmaurer</w>I need to wrap my head around paths that apply functions while navigating <b>😄</b></z><z id="t1504352715" t="nathanmarz yea, those ones are different"><y>#</y><d>2017-09-02</d><h>11:45</h><w>nathanmarz</w>yea, those ones are different</z><z id="t1504352720" t="nathanmarz just view and transformed"><y>#</y><d>2017-09-02</d><h>11:45</h><w>nathanmarz</w>just <code>view</code> and <code>transformed</code></z><z id="t1504352757" t="hmaurer @nathanmarz what is your mental model for navigation if the model “navigating to a nested structure” is too limiting/unsuitable?"><y>#</y><d>2017-09-02</d><h>11:45</h><w>hmaurer</w>@nathanmarz what is your mental model for navigation if the model “navigating to a nested structure” is too limiting/unsuitable?</z><z id="t1504352762" t="hmaurer if that question makes sense"><y>#</y><d>2017-09-02</d><h>11:46</h><w>hmaurer</w>if that question makes sense</z><z id="t1504352818" t="nathanmarz well most of the time that is my mental model"><y>#</y><d>2017-09-02</d><h>11:46</h><w>nathanmarz</w>well most of the time that is my mental model</z><z id="t1504352826" t="nathanmarz including for substructure navigators like srange"><y>#</y><d>2017-09-02</d><h>11:47</h><w>nathanmarz</w>including for substructure navigators like srange</z><z id="t1504352851" t="nathanmarz I literally visualize moving from one portion of a data structure to another"><y>#</y><d>2017-09-02</d><h>11:47</h><w>nathanmarz</w>I literally visualize moving from one portion of a data structure to another</z><z id="t1504352917" t="nathanmarz it gets easier with practice"><y>#</y><d>2017-09-02</d><h>11:48</h><w>nathanmarz</w>it gets easier with practice</z><z id="t1504352940" t="nathanmarz eventually it&apos;s like anything else in programming and its just instinctive"><y>#</y><d>2017-09-02</d><h>11:49</h><w>nathanmarz</w>eventually it&apos;s like anything else in programming and its just instinctive</z><z id="t1504364123" t="hmaurer @nathanmarz I am having a little bit of difficulty picturing the view example you mentioned about. When selected (reading) values, this makes sense. We are “viewing” the result of applying a function to every navigated value"><y>#</y><d>2017-09-02</d><h>14:55</h><w>hmaurer</w>@nathanmarz I am having a little bit of difficulty picturing the <code>view</code> example you mentioned about. When selected (reading) values, this makes sense. We are “viewing” the result of applying a function to every navigated value</z><z id="t1504364161" t="hmaurer However the transform case seems a bit odd to me. I would expect transform to apply the inverse function of the function passed to view when re-constructing the data"><y>#</y><d>2017-09-02</d><h>14:56</h><w>hmaurer</w>However the <code>transform</code> case seems a bit odd to me. I would expect <code>transform</code> to apply the inverse function of the function passed to <code>view</code> when re-constructing the data</z><z id="t1504364171" t="hmaurer (aka flowing the data back “up the pipe”, if that makes sense)"><y>#</y><d>2017-09-02</d><h>14:56</h><w>hmaurer</w>(aka flowing the data back “up the pipe”, if that makes sense)</z><z id="t1504364187" t="hmaurer Am I fundamentally misunderstanding somethng here?"><y>#</y><d>2017-09-02</d><h>14:56</h><w>hmaurer</w>Am I fundamentally misunderstanding somethng here?</z><z id="t1504364211" t="hmaurer (regardless of the fact that, afaik, there is no way to compute the inverse of an arbitrary function in clojure)"><y>#</y><d>2017-09-02</d><h>14:56</h><w>hmaurer</w>(regardless of the fact that, afaik, there is no way to compute the inverse of an arbitrary function in clojure)</z><z id="t1504364998" t="nathanmarz @hmaurer that&apos;s what parser does https://github.com/nathanmarz/specter/wiki/List-of-Navigators#parser"><y>#</y><d>2017-09-02</d><h>15:09</h><w>nathanmarz</w>@hmaurer that&apos;s what <code>parser</code> does <a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#parser" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#parser</a></z><z id="t1504365079" t="nathanmarz think of view as like a transform function that then continues navigating into the result of the transform"><y>#</y><d>2017-09-02</d><h>15:11</h><w>nathanmarz</w>think of <code>view</code> as like a transform function that then continues navigating into the result of the transform</z><z id="t1504365317" t="hmaurer @nathanmarz that clarifies things. So if my mental model looks like this: [ 1 ] -- inc --&gt; [ 2 ] and I want to apply a transform to the value in the second box, which I then expect to be “flowed back” to the first box by inverting the computation, then parser is the way to go"><y>#</y><d>2017-09-02</d><h>15:15</h><w>hmaurer</w>@nathanmarz that clarifies things. So if my mental model looks like this:
<pre>[ 1 ] -- inc --&gt; [ 2 ]
</pre>
and I want to apply a transform to the value in the second box, which I then expect to be “flowed back” to the first box by inverting the computation, then <code>parser</code> is the way to go</z><z id="t1504365337" t="nathanmarz that&apos;s right"><y>#</y><d>2017-09-02</d><h>15:15</h><w>nathanmarz</w>that&apos;s right</z><z id="t1504365363" t="hmaurer and view would stay navigated in the first box?"><y>#</y><d>2017-09-02</d><h>15:16</h><w>hmaurer</w>and <code>view</code> would stay navigated in the first box?</z><z id="t1504365381" t="nathanmarz the only use case we could think of for the function+inverse was parsing, but it could be used for other things as well"><y>#</y><d>2017-09-02</d><h>15:16</h><w>nathanmarz</w>the only use case we could think of for the function+inverse was parsing, but it could be used for other things as well</z><z id="t1504365392" t="nathanmarz view would stay at the second box"><y>#</y><d>2017-09-02</d><h>15:16</h><w>nathanmarz</w><code>view</code> would stay at the second box</z><z id="t1504365414" t="nathanmarz (transform [(view inc) STOP] dec 1) ;; =&gt; 2"><y>#</y><d>2017-09-02</d><h>15:16</h><w>nathanmarz</w><code>(transform [(view inc) STOP] dec 1) ;; =&gt; 2</code></z><z id="t1504365664" t="hmaurer Wait, I would be navigated to the second box with view ? How so? If I am at the first box and navigate to the second box by applying some computation (here view ), and I then use setval to set the value on that path (the second box), shouldn’t I expect the computation to be inverted to determine the value of the first box?"><y>#</y><d>2017-09-02</d><h>15:21</h><w>hmaurer</w>Wait, I would be navigated to the second box with <code>view</code>? How so? If I am at the first box and navigate to the second box by applying some computation (here <code>view</code>), and I then use <code>setval</code> to set the value on that path (the second box), shouldn’t I expect the computation to be inverted to determine the value of the first box?</z><z id="t1504365687" t="hmaurer If view navigates to the second box, I don’t get why/how its behaviour differs from parser in the transform case"><y>#</y><d>2017-09-02</d><h>15:21</h><w>hmaurer</w>If <code>view</code> navigates to the second box, I don’t get why/how its behaviour differs from <code>parser</code> in the <code>transform</code> case</z><z id="t1504365744" t="nathanmarz well it stays there"><y>#</y><d>2017-09-02</d><h>15:22</h><w>nathanmarz</w>well it stays there</z><z id="t1504365751" t="nathanmarz maybe &quot;boxes&quot; is not the right analogy"><y>#</y><d>2017-09-02</d><h>15:22</h><w>nathanmarz</w>maybe &quot;boxes&quot; is not the right analogy</z><z id="t1504365770" t="nathanmarz you can think of view not navigating at all, just changing the box it&apos;s at"><y>#</y><d>2017-09-02</d><h>15:22</h><w>nathanmarz</w>you can think of <code>view</code> not navigating at all, just changing the box it&apos;s at</z><z id="t1504365781" t="nathanmarz and then the rest of the path continues with the new value"><y>#</y><d>2017-09-02</d><h>15:23</h><w>nathanmarz</w>and then the rest of the path continues with the new value</z><z id="t1504365813" t="nathanmarz in that example I just showed you can see the dec function is never reached"><y>#</y><d>2017-09-02</d><h>15:23</h><w>nathanmarz</w>in that example I just showed you can see the <code>dec</code> function is never reached</z><z id="t1504365819" t="nathanmarz but the view persists in the result"><y>#</y><d>2017-09-02</d><h>15:23</h><w>nathanmarz</w>but the <code>view</code> persists in the result</z><z id="t1504365852" t="nathanmarz it&apos;s equivalent to (transform STOP dec (transform STAY inc 1))"><y>#</y><d>2017-09-02</d><h>15:24</h><w>nathanmarz</w>it&apos;s equivalent to <code>(transform STOP dec (transform STAY inc 1))</code></z><z id="t1504366259" t="hmaurer I see; thank you!"><y>#</y><d>2017-09-02</d><h>15:30</h><w>hmaurer</w>I see; thank you!</z><z id="t1504366309" t="nathanmarz sure thing"><y>#</y><d>2017-09-02</d><h>15:31</h><w>nathanmarz</w>sure thing</z><z id="t1504366372" t="hmaurer ah, last but not least, do you have an example of a scenario where view is useful but parser would be unsuitable?"><y>#</y><d>2017-09-02</d><h>15:32</h><w>hmaurer</w>ah, last but not least, do you have an example of a scenario where <code>view</code> is useful but <code>parser</code> would be unsuitable?</z><z id="t1504367001" t="nathanmarz @hmaurer mostly I use it in select s, where its more concise than parser"><y>#</y><d>2017-09-02</d><h>15:43</h><w>nathanmarz</w>@hmaurer mostly I use it in <code>select</code>s, where its more concise than <code>parser</code></z><z id="t1504367018" t="nathanmarz plus there&apos;s no unparse-fn for those cases"><y>#</y><d>2017-09-02</d><h>15:43</h><w>nathanmarz</w>plus there&apos;s no <code>unparse-fn</code> for those cases</z><z id="t1504367049" t="nathanmarz one spot where I use it in a transform is needing to manipulate a string as a vector of characters"><y>#</y><d>2017-09-02</d><h>15:44</h><w>nathanmarz</w>one spot where I use it in a <code>transform</code> is needing to manipulate a string as a vector of characters</z><z id="t1504367054" t="nathanmarz so I do a (view vec)"><y>#</y><d>2017-09-02</d><h>15:44</h><w>nathanmarz</w>so I do a <code>(view vec)</code></z><z id="t1504367129" t="hmaurer In that case though parser ‘s behaviour would make sense, since when manipulating a string as a list of characters you are essentially navigating into the substructure of that string, right?"><y>#</y><d>2017-09-02</d><h>15:45</h><w>hmaurer</w>In that case though <code>parser</code>‘s behaviour would make sense, since when manipulating a string as a list of characters you are essentially navigating into the substructure of that string, right?</z><z id="t1504367136" t="hmaurer which you could then re-construct"><y>#</y><d>2017-09-02</d><h>15:45</h><w>hmaurer</w>which you could then re-construct</z><z id="t1504367139" t="nathanmarz it&apos;s actually for converting a vector of strings to a matrix of characters with some default rendering info attached to each character"><y>#</y><d>2017-09-02</d><h>15:45</h><w>nathanmarz</w>it&apos;s actually for converting a vector of strings to a matrix of characters with some default rendering info attached to each character</z><z id="t1504367180" t="nathanmarz yea you could have an unparse-fn for that kind of navigation, but in this case the goal is to have vector of characters in the output"><y>#</y><d>2017-09-02</d><h>15:46</h><w>nathanmarz</w>yea you could have an <code>unparse-fn</code> for that kind of navigation, but in this case the goal is to have vector of characters in the output</z><z id="t1504367197" t="nathanmarz (def card-back [ &quot;.------.&quot; &quot;|//////|&quot; &quot;|//////|&quot; &quot;|//////|&quot; &quot;|//////|&quot; &quot;`------&apos;&quot; ]) "><y>#</y><d>2017-09-02</d><h>15:46</h><w>nathanmarz</w><pre>(def card-back
[
&quot;.------.&quot;
&quot;|//////|&quot;
&quot;|//////|&quot;
&quot;|//////|&quot;
&quot;|//////|&quot;
&quot;`------&apos;&quot;
])
</pre></z><z id="t1504367232" t="nathanmarz basically that&apos;s how I specify &quot;images&quot; and the subsequent transform converts it to something that can be rendered"><y>#</y><d>2017-09-02</d><h>15:47</h><w>nathanmarz</w>basically that&apos;s how I specify &quot;images&quot; and the subsequent <code>transform</code> converts it to something that can be rendered</z><z id="t1504367285" t="nathanmarz (def cards (into {} (for [v [2 3 4 5 6 7 8 9 :T :J :Q :K :A]] [v (into {} (for [[s template] {:clubs clubs-template :diamonds diamonds-template :spades spades-template :hearts hearts-template}] [s (transform ALL #(apply str %) (setval [ALL (view vec) ALL (pred= \?)] (last (str v)) template))] ))]))) "><y>#</y><d>2017-09-02</d><h>15:48</h><w>nathanmarz</w><pre>(def cards
  (into {}
    (for [v [2 3 4 5 6 7 8 9 :T :J :Q :K :A]]
      [v
       (into {}
         (for [[s template] {:clubs clubs-template :diamonds diamonds-template
                             :spades spades-template :hearts hearts-template}]
           [s (transform ALL #(apply str %)
                (setval [ALL (view vec) ALL (pred= \?)] (last (str v)) template))]
           ))])))
</pre></z><z id="t1504367329" t="nathanmarz oh actually in this case it turns templates into vector of strings for each card value"><y>#</y><d>2017-09-02</d><h>15:48</h><w>nathanmarz</w>oh actually in this case it turns templates into vector of strings for each card value</z><z id="t1504367384" t="nathanmarz forgot how this code works :/"><y>#</y><d>2017-09-02</d><h>15:49</h><w>nathanmarz</w>forgot how this code works :/</z><z id="t1504367403" t="nathanmarz in this case parser would work"><y>#</y><d>2017-09-02</d><h>15:50</h><w>nathanmarz</w>in this case <code>parser</code> would work</z><z id="t1504367485" t="hmaurer Mmh. Out of curiosity, is view the only (shipped with Specter) infraction to the invariant (= (select path structure) (select path (transform path identity structure))) ?"><y>#</y><d>2017-09-02</d><h>15:51</h><w>hmaurer</w>Mmh. Out of curiosity, is <code>view</code> the only (shipped with Specter) infraction to the invariant
<pre>(= (select path structure) (select path (transform path identity structure)))
</pre>
?</z><z id="t1504367525" t="hmaurer When thinking of navigation as “diving into structure” it seems that this invariant should hold; I am a bit bothered that view does not maintain it with transform"><y>#</y><d>2017-09-02</d><h>15:52</h><w>hmaurer</w>When thinking of navigation as “diving into structure” it seems that this invariant should hold; I am a bit bothered that <code>view</code> does not maintain it with transform</z><z id="t1504367535" t="hmaurer but I am probably just being picky 😄"><y>#</y><d>2017-09-02</d><h>15:52</h><w>hmaurer</w>but I am probably just being picky <b>😄</b></z><z id="t1504367621" t="nathanmarz also transformed , nil-&gt;val"><y>#</y><d>2017-09-02</d><h>15:53</h><w>nathanmarz</w>also <code>transformed</code>, <code>nil-&gt;val</code></z><z id="t1504367639" t="nathanmarz here&apos;s a better example of view transform use case: (transform [(view vec) ALL] (ichar-with-attrs prompt-attrs) prompt)"><y>#</y><d>2017-09-02</d><h>15:53</h><w>nathanmarz</w>here&apos;s a better example of <code>view</code> transform use case: <code>(transform [(view vec) ALL] (ichar-with-attrs prompt-attrs) prompt)</code></z><z id="t1504367679" t="nathanmarz a &quot;prompt&quot; string is converted to a vector of characters with each character wrapped in a map also containing rendering attributes like color, font, etc."><y>#</y><d>2017-09-02</d><h>15:54</h><w>nathanmarz</w>a &quot;prompt&quot; string is converted to a vector of characters with each character wrapped in a map also containing rendering attributes like color, font, etc.</z><z id="t1504367747" t="nathanmarz could also do (transform ALL (ichar-with-attrs prompt-attrs) (vec prompt)) , but the style with view would be useful if needed to do that transformation if had something like a map of prompts"><y>#</y><d>2017-09-02</d><h>15:55</h><w>nathanmarz</w>could also do <code>(transform ALL (ichar-with-attrs prompt-attrs) (vec prompt))</code>, but the style with <code>view</code> would be useful if needed to do that transformation if had something like a map of prompts</z><z id="t1504367843" t="nathanmarz invariants like that are important for monads where it really does affect the utility of the monad"><y>#</y><d>2017-09-02</d><h>15:57</h><w>nathanmarz</w>invariants like that are important for monads where it really does affect the utility of the monad</z><z id="t1504367865" t="nathanmarz other than the traversal order thing I mentioned, invariants like that aren&apos;t needed for navigation"><y>#</y><d>2017-09-02</d><h>15:57</h><w>nathanmarz</w>other than the traversal order thing I mentioned, invariants like that aren&apos;t needed for navigation</z><z id="t1504367923" t="hmaurer I was hoping to use such invariants to better understand what navigators can and can’t do"><y>#</y><d>2017-09-02</d><h>15:58</h><w>hmaurer</w>I was hoping to use such invariants to better understand what navigators can and can’t do</z><z id="t1504367936" t="hmaurer But this discussion was very helpful 🙂"><y>#</y><d>2017-09-02</d><h>15:58</h><w>hmaurer</w>But this discussion was very helpful <b>🙂</b></z><z id="t1504367957" t="nathanmarz you could try reading the source code of navigators in specter"><y>#</y><d>2017-09-02</d><h>15:59</h><w>nathanmarz</w>you could try reading the source code of navigators in specter</z><z id="t1504367964" t="nathanmarz view is one of the simplest"><y>#</y><d>2017-09-02</d><h>15:59</h><w>nathanmarz</w><code>view</code> is one of the simplest</z><z id="t1504368127" t="nathanmarz navigators are just functions, so they have all the power a function has"><y>#</y><d>2017-09-02</d><h>16:02</h><w>nathanmarz</w>navigators are just functions, so they have all the power a function has</z><z id="t1504368209" t="hmaurer @nathanmarz of course, but I assume that if I want other people to be able to use the navigators I write they should follow some expected behaviours"><y>#</y><d>2017-09-02</d><h>16:03</h><w>hmaurer</w>@nathanmarz of course, but I assume that if I want other people to be able to use the navigators I write they should follow some expected behaviours</z><z id="t1504368228" t="hmaurer so as not to force them to completely swap their mental model around on every new navigator they encounter"><y>#</y><d>2017-09-02</d><h>16:03</h><w>hmaurer</w>so as not to force them to completely swap their mental model around on every new navigator they encounter</z><z id="t1504368243" t="hmaurer I might be overthinking the issue though; I’ll dig into the source-code!"><y>#</y><d>2017-09-02</d><h>16:04</h><w>hmaurer</w>I might be overthinking the issue though; I’ll dig into the source-code!</z><z id="t1504368397" t="nathanmarz the only types of navigators I&apos;ve encountered are &quot;subvalue&quot; (e.g. keypath, nthpath, META, ALL), &quot;substructure&quot; (e.g. srange, submap, subset), &quot;filter&quot; (e.g. pred, selected?), and &quot;view&quot; (e.g. view, nil-&gt;val, transformed)"><y>#</y><d>2017-09-02</d><h>16:06</h><w>nathanmarz</w>the only types of navigators I&apos;ve encountered are &quot;subvalue&quot; (e.g. keypath, nthpath, META, ALL), &quot;substructure&quot; (e.g. srange, submap, subset), &quot;filter&quot; (e.g. pred, selected?), and &quot;view&quot; (e.g. view, nil-&gt;val, transformed)</z><z id="t1504368425" t="nathanmarz index-nav is an interesting example of a &quot;subvalue&quot; navigator because it navigates you to an implicit value"><y>#</y><d>2017-09-02</d><h>16:07</h><w>nathanmarz</w><code>index-nav</code> is an interesting example of a &quot;subvalue&quot; navigator because it navigates you to an implicit value</z><z id="t1504368854" t="hmaurer @nathanmarz oh that’s interesting indeed. The doc on index-nav is missing from the wiki by the way"><y>#</y><d>2017-09-02</d><h>16:14</h><w>hmaurer</w>@nathanmarz oh that’s interesting indeed. The doc on <code>index-nav</code> is missing from the wiki by the way</z><z id="t1504368860" t="hmaurer Quick question: what is a “rich nav”?"><y>#</y><d>2017-09-02</d><h>16:14</h><w>hmaurer</w>Quick question: what is a “rich nav”?</z><z id="t1504369620" t="nathanmarz @hmaurer yea the wiki is not up to date"><y>#</y><d>2017-09-02</d><h>16:27</h><w>nathanmarz</w>@hmaurer yea the wiki is not up to date</z><z id="t1504369632" t="nathanmarz the API docs are the most up to date, but the wiki has more examples"><y>#</y><d>2017-09-02</d><h>16:27</h><w>nathanmarz</w>the API docs are the most up to date, but the wiki has more examples</z><z id="t1504369652" t="nathanmarz richnav exposes the full navigator interface when defining navigators"><y>#</y><d>2017-09-02</d><h>16:27</h><w>nathanmarz</w><code>richnav</code> exposes the full navigator interface when defining navigators</z><z id="t1504369672" t="nathanmarz https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L3"><y>#</y><d>2017-09-02</d><h>16:27</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L3" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L3</a></z><z id="t1504369691" t="nathanmarz many navigators use defrichnav purely as an optimization"><y>#</y><d>2017-09-02</d><h>16:28</h><w>nathanmarz</w>many navigators use <code>defrichnav</code> purely as an optimization</z><z id="t1504369731" t="nathanmarz defnav wraps next-fn and puts vals in closure to pass along when it&apos;s called"><y>#</y><d>2017-09-02</d><h>16:28</h><w>nathanmarz</w><code>defnav</code> wraps <code>next-fn</code> and puts <code>vals</code> in closure to pass along when it&apos;s called</z><z id="t1504369750" t="nathanmarz with defrichnav you can avoid all that allocation/indirection by passing the vals yourself"><y>#</y><d>2017-09-02</d><h>16:29</h><w>nathanmarz</w>with <code>defrichnav</code> you can avoid all that allocation/indirection by passing the <code>vals</code> yourself</z><z id="t1504369776" t="nathanmarz unfortunately clojure doesn&apos;t optimize this case with inlining and neither does the JVM"><y>#</y><d>2017-09-02</d><h>16:29</h><w>nathanmarz</w>unfortunately clojure doesn&apos;t optimize this case with inlining and neither does the JVM</z><z id="t1504369790" t="nathanmarz although in theory a compiler could do it"><y>#</y><d>2017-09-02</d><h>16:29</h><w>nathanmarz</w>although in theory a compiler could do it</z><z id="t1504369842" t="nathanmarz so I do it manually for some cases where that optimization makes a difference – basically I try to do it wherever the navigation itself is very cheap so extra overhead will have noticeable performance impact"><y>#</y><d>2017-09-02</d><h>16:30</h><w>nathanmarz</w>so I do it manually for some cases where that optimization makes a difference – basically I try to do it wherever the navigation itself is very cheap so extra overhead will have noticeable performance impact</z><z id="t1504369891" t="nathanmarz btw vals in that interface refers to &quot;collected vals&quot; collected with VAL , collect , and collect-one"><y>#</y><d>2017-09-02</d><h>16:31</h><w>nathanmarz</w>btw <code>vals</code> in that interface refers to &quot;collected vals&quot; collected with <code>VAL</code>, <code>collect</code>, and <code>collect-one</code></z><z id="t1504648456" t="dadair How does Spectre compare in performance for recursively (and exhaustively) walking large trees (e.g., against clojure.walk/prewalk )? Looked at posted benchmarks but didn&apos;t see any for walking trees"><y>#</y><d>2017-09-05</d><h>21:54</h><w>dadair</w>How does Spectre compare in performance for recursively (and exhaustively) walking large trees (e.g., against <code>clojure.walk/prewalk</code>)? Looked at posted benchmarks but didn&apos;t see any for walking trees</z><z id="t1504649372" t="nathanmarz @dadair specter destroys the performance of anything in vanilla clojure for anything involving compound or recursive data structures"><y>#</y><d>2017-09-05</d><h>22:09</h><w>nathanmarz</w>@dadair specter destroys the performance of anything in vanilla clojure for anything involving compound or recursive data structures</z><z id="t1504649399" t="nathanmarz clojure.walk is a very brute force approach forcing you to traverse parts of data structures you don&apos;t care about (like map keys, key/value pairs)"><y>#</y><d>2017-09-05</d><h>22:09</h><w>nathanmarz</w><code>clojure.walk</code> is a very brute force approach forcing you to traverse parts of data structures you don&apos;t care about (like map keys, key/value pairs)</z><z id="t1504649429" t="nathanmarz with specter you can make traversals that perform dramatically better"><y>#</y><d>2017-09-05</d><h>22:10</h><w>nathanmarz</w>with specter you can make traversals that perform dramatically better</z><z id="t1504649453" t="nathanmarz even just in replicating clojure.walk/postwalk semantics specter is 40% better Benchmark: walker vs. clojure.walk version (150000 iterations) Avg(ms) vs best Code 959.39 1.00 (transform (walker number?) inc data) 1347.1 1.40 (transform (walker-old number?) inc data) "><y>#</y><d>2017-09-05</d><h>22:10</h><w>nathanmarz</w>even just in replicating <code>clojure.walk/postwalk</code> semantics specter is 40% better
<pre>Benchmark: walker vs. clojure.walk version (150000 iterations)

Avg(ms)		vs best		Code
959.39 		 1.00 		 (transform (walker number?) inc data)
1347.1 		 1.40 		 (transform (walker-old number?) inc data)
</pre></z><z id="t1504649537" t="nathanmarz the implementation of walker is instructive for making your own recursive paths (def ^{:doc &quot;Navigate the data structure until reaching a value for which `afn` returns truthy. Has same semantics as clojure.walk.&quot;} walker (recursive-path [afn] p (cond-path (pred afn) STAY coll? [ALL p] ))) "><y>#</y><d>2017-09-05</d><h>22:12</h><w>nathanmarz</w>the implementation of <code>walker</code> is instructive for making your own recursive paths
<pre>(def
  ^{:doc &quot;Navigate the data structure until reaching
          a value for which `afn` returns truthy. Has
          same semantics as clojure.walk.&quot;}
  walker
  (recursive-path [afn] p
    (cond-path (pred afn) STAY
               coll? [ALL p]
               )))
</pre></z><z id="t1504649677" t="dadair awesome, I&apos;ll take a look at spectre. I have a prewalk running in ~28ms that I need to cut down as much as possible"><y>#</y><d>2017-09-05</d><h>22:14</h><w>dadair</w>awesome, I&apos;ll take a look at spectre. I have a prewalk running in ~28ms that I need to cut down as much as possible</z><z id="t1504723967" t="dadair Hi again! Just trying to grasp navigation and collection a bit better. Let&apos;s say I have a recursive structure like so: {:root {:name &quot;/&quot; :children {:a {:name &quot;a&quot; :children {&lt;recursive&gt;}} :b {:name &quot;b&quot; :children {&lt;recursive&gt;}}}}} I&apos;d like to augment each &quot;node&quot; with the direct path to take to that node: {:root {:name &quot;/&quot; :ref [:root] :children {:a {:name &quot;a&quot; :ref [:root :children :a] :children {&lt;recursive&gt;}} :b {:name &quot;b&quot; :ref [:root :children :b] :children {&lt;recursive&gt;}}}}} How would this work with mixing recursive-path and collect ?"><y>#</y><d>2017-09-06</d><h>18:52</h><w>dadair</w>Hi again! Just trying to grasp navigation and collection a bit better. Let&apos;s say I have a recursive structure like so:
<pre>{:root {:name &quot;/&quot;
           :children {:a {:name &quot;a&quot; :children {&lt;recursive&gt;}}
                            :b {:name &quot;b&quot; :children {&lt;recursive&gt;}}}}}
</pre>
I&apos;d like to augment each &quot;node&quot; with the direct path to take to that node:
<pre>{:root {:name &quot;/&quot;
           :ref [:root]
           :children {:a {:name &quot;a&quot; :ref [:root :children :a] :children {&lt;recursive&gt;}}
                            :b {:name &quot;b&quot; :ref [:root :children :b] :children {&lt;recursive&gt;}}}}}
</pre>
How would this work with mixing <code>recursive-path</code> and <code>collect</code>?</z><z id="t1504727287" t="nathanmarz @dadair you can do that example like this: (def data {:root {:name &quot;/&quot; :children {:a {:name &quot;a&quot;} :b {:name &quot;b&quot;}}}}) (def nodes-with-path (recursive-path [] p (continue-then-stay (putval :children) (must :children) ALL (collect-one FIRST) LAST p))) (transform [(putval :root) :root nodes-with-path :ref] (fn [&amp; args] (butlast args)) data) "><y>#</y><d>2017-09-06</d><h>19:48</h><w>nathanmarz</w>@dadair you can do that example like this:
<pre>(def data
 {:root {:name &quot;/&quot;
         :children {:a {:name &quot;a&quot;}
                    :b {:name &quot;b&quot;}}}})


(def nodes-with-path
  (recursive-path [] p
    (continue-then-stay
      (putval :children)
      (must :children)
      ALL
      (collect-one FIRST)
      LAST
      p)))

(transform [(putval :root) :root nodes-with-path :ref] (fn [&amp; args] (butlast args)) data)
</pre></z><z id="t1504727357" t="hmaurer @nathanmarz that’s very cool"><y>#</y><d>2017-09-06</d><h>19:49</h><w>hmaurer</w>@nathanmarz that’s very cool</z><z id="t1504727360" t="hmaurer 😱"><y>#</y><d>2017-09-06</d><h>19:49</h><w>hmaurer</w><b>😱</b></z><z id="t1504727588" t="hmaurer @nathanmarz completely uninformed question: are there similarities between Specter and Gremlin?"><y>#</y><d>2017-09-06</d><h>19:53</h><w>hmaurer</w>@nathanmarz completely uninformed question: are there similarities between Specter and Gremlin?</z><z id="t1504727600" t="hmaurer (even though their intended use-cases are quite different)"><y>#</y><d>2017-09-06</d><h>19:53</h><w>hmaurer</w>(even though their intended use-cases are quite different)</z><z id="t1504729408" t="nathanmarz @hmaurer I&apos;m not very familiar with Gremlin"><y>#</y><d>2017-09-06</d><h>20:23</h><w>nathanmarz</w>@hmaurer I&apos;m not very familiar with Gremlin</z><z id="t1504729490" t="dadair thanks @nathanmarz that helps!"><y>#</y><d>2017-09-06</d><h>20:24</h><w>dadair</w>thanks @nathanmarz that helps!</z><z id="t1504817863" t="dadair Would compiling recursive paths give any benefit? I&apos;ve tried a compiled-transform with comp-paths for the above path vector and don&apos;t see any performance benefits (using criterium to get means)"><y>#</y><d>2017-09-07</d><h>20:57</h><w>dadair</w>Would compiling recursive paths give any benefit? I&apos;ve tried a <code>compiled-transform</code> with <code>comp-paths</code> for the above path vector and don&apos;t see any performance benefits (using criterium to get means)</z><z id="t1504820737" t="nathanmarz @dadair no that&apos;s not necessary anymore"><y>#</y><d>2017-09-07</d><h>21:45</h><w>nathanmarz</w>@dadair no that&apos;s not necessary anymore</z><z id="t1504820744" t="nathanmarz since 0.11.0 specter does inline compilation/caching"><y>#</y><d>2017-09-07</d><h>21:45</h><w>nathanmarz</w>since 0.11.0 specter does inline compilation/caching</z><z id="t1504820814" t="nathanmarz feel free to paste your path if you&apos;d like tips on performance"><y>#</y><d>2017-09-07</d><h>21:46</h><w>nathanmarz</w>feel free to paste your path if you&apos;d like tips on performance</z><z id="t1504820894" t="dadair it&apos;s the exact path you provided in the code block above. It&apos;s improved my app performance quite substantially already, I was just curious of compilation would make it faster as I know the path beforehand"><y>#</y><d>2017-09-07</d><h>21:48</h><w>dadair</w>it&apos;s the exact path you provided in the code block above. It&apos;s improved my app performance quite substantially already, I was just curious of compilation would make it faster as I know the path beforehand</z><z id="t1504820923" t="nathanmarz ah"><y>#</y><d>2017-09-07</d><h>21:48</h><w>nathanmarz</w>ah</z><z id="t1504820929" t="nathanmarz yea that path&apos;s performance could be improved"><y>#</y><d>2017-09-07</d><h>21:48</h><w>nathanmarz</w>yea that path&apos;s performance could be improved</z><z id="t1504821022" t="nathanmarz or rather that transform"><y>#</y><d>2017-09-07</d><h>21:50</h><w>nathanmarz</w>or rather that transform</z><z id="t1504821031" t="nathanmarz (def terminal2 (richnav [afn] (select* [this vals structure next-fn] (i/throw-illegal &quot;&apos;terminal2&apos; should only be used in multi-transform&quot;)) (transform* [this vals structure next-fn] (afn vals structure)))) "><y>#</y><d>2017-09-07</d><h>21:50</h><w>nathanmarz</w><pre>(def terminal2
  (richnav [afn]
    (select* [this vals structure next-fn]
      (i/throw-illegal &quot;&apos;terminal2&apos; should only be used in multi-transform&quot;))
    (transform* [this vals structure next-fn]
      (afn vals structure))))
</pre></z><z id="t1504821067" t="nathanmarz (multi-transform [(putval :root) :root nodes-with-path :ref (terminal2 (fn [vals _] vals))] data)"><y>#</y><d>2017-09-07</d><h>21:51</h><w>nathanmarz</w><code>(multi-transform [(putval :root) :root nodes-with-path :ref (terminal2 (fn [vals _] vals))] data)</code></z><z id="t1504821077" t="nathanmarz try that"><y>#</y><d>2017-09-07</d><h>21:51</h><w>nathanmarz</w>try that</z><z id="t1504821134" t="nathanmarz avoids the apply on the transform-fn and the butlast call"><y>#</y><d>2017-09-07</d><h>21:52</h><w>nathanmarz</w>avoids the <code>apply</code> on the transform-fn and the <code>butlast</code> call</z><z id="t1504821223" t="dadair is terminal2 on 1.0.3 ?"><y>#</y><d>2017-09-07</d><h>21:53</h><w>dadair</w>is terminal2 on <code>1.0.3</code>?</z><z id="t1504821234" t="nathanmarz no"><y>#</y><d>2017-09-07</d><h>21:53</h><w>nathanmarz</w>no</z><z id="t1504821244" t="nathanmarz I should probably add something like that into a future version"><y>#</y><d>2017-09-07</d><h>21:54</h><w>nathanmarz</w>I should probably add something like that into a future version</z><z id="t1504821276" t="nathanmarz that&apos;s a variant of terminal which is in specter"><y>#</y><d>2017-09-07</d><h>21:54</h><w>nathanmarz</w>that&apos;s a variant of <code>terminal</code> which is in specter</z><z id="t1504821472" t="dadair yeah that improved it quite a bit again: prewalk: 27ms, transform: 5.4ms, multi-transform: 1.3ms"><y>#</y><d>2017-09-07</d><h>21:57</h><w>dadair</w>yeah that improved it quite a bit again: <code>prewalk: 27ms, transform: 5.4ms, multi-transform: 1.3ms</code></z><z id="t1504821479" t="dadair this is awesome thank you"><y>#</y><d>2017-09-07</d><h>21:57</h><w>dadair</w>this is awesome thank you</z><z id="t1504821486" t="nathanmarz very nice"><y>#</y><d>2017-09-07</d><h>21:58</h><w>nathanmarz</w>very nice</z><z id="t1504821492" t="nathanmarz that&apos;s probably close to optimal"><y>#</y><d>2017-09-07</d><h>21:58</h><w>nathanmarz</w>that&apos;s probably close to optimal</z><z id="t1504821548" t="dadair I&apos;ve also replaced a tree-seq &gt; group-by &gt; get pipeline with: (def nodes-without-path (sp/recursive-path [] p (sp/continue-then-stay (sp/must :children) sp/ALL sp/LAST p))) (defn find-vals [root type] (sp/select [:root nodes-without-path (fn [x] (= type (-&gt; x :descriptor :type)))] root)) any performance tips there?"><y>#</y><d>2017-09-07</d><h>21:59</h><w>dadair</w>I&apos;ve also replaced a <code>tree-seq &gt; group-by &gt; get</code> pipeline with:
<pre>(def nodes-without-path
  (sp/recursive-path [] p
                     (sp/continue-then-stay
                      (sp/must :children)
                      sp/ALL
                      sp/LAST
                      p)))

(defn find-vals [root type]
  (sp/select [:root nodes-without-path (fn [x] (= type (-&gt; x :descriptor :type)))] root))
</pre>
any performance tips there?</z><z id="t1504821610" t="nathanmarz no, that seems good"><y>#</y><d>2017-09-07</d><h>22:00</h><w>nathanmarz</w>no, that seems good</z><z id="t1504821632" t="dadair also, when the predicate matches, that node will be a leaf, if that adds some performance considerations"><y>#</y><d>2017-09-07</d><h>22:00</h><w>dadair</w>also, when the predicate matches, that node will be a leaf, if that adds some performance considerations</z><z id="t1504821684" t="nathanmarz oh, you can replace ALL LAST with MAP-VALS"><y>#</y><d>2017-09-07</d><h>22:01</h><w>nathanmarz</w>oh, you can replace <code>ALL LAST</code> with <code>MAP-VALS</code></z><z id="t1504821690" t="nathanmarz that will be a big performance boost"><y>#</y><d>2017-09-07</d><h>22:01</h><w>nathanmarz</w>that will be a big performance boost</z><z id="t1504821860" t="nathanmarz as for the last property you said, you should be able to change the path to reflect that"><y>#</y><d>2017-09-07</d><h>22:04</h><w>nathanmarz</w>as for the last property you said, you should be able to change the path to reflect that</z><z id="t1504821879" t="nathanmarz basically to only navigate to leaves, not to every intermediate node"><y>#</y><d>2017-09-07</d><h>22:04</h><w>nathanmarz</w>basically to only navigate to leaves, not to every intermediate node</z><z id="t1504821907" t="nathanmarz depends on how you detect a leaf"><y>#</y><d>2017-09-07</d><h>22:05</h><w>nathanmarz</w>depends on how you detect a leaf</z><z id="t1504821922" t="nathanmarz non-existence of :children key, or just :children key with empty map?"><y>#</y><d>2017-09-07</d><h>22:05</h><w>nathanmarz</w>non-existence of <code>:children</code> key, or just <code>:children</code> key with empty map?</z><z id="t1504822058" t="dadair I was going to say :children with empty map but that&apos;s not necessarily true actually, it&apos;s more that certain nodes have types (-&gt; node :descriptor :type) that reflect leaf &quot;value&quot; nodes, but internally they may have :children for sub-values"><y>#</y><d>2017-09-07</d><h>22:07</h><w>dadair</w>I was going to say <code>:children</code> with empty map but that&apos;s not necessarily true actually, it&apos;s more that certain nodes have <code>types</code> <code>(-&gt; node :descriptor :type)</code> that reflect leaf &quot;value&quot; nodes, but internally they may have <code>:children</code> for sub-values</z><z id="t1504822077" t="dadair I could check if the type is in a known set of types"><y>#</y><d>2017-09-07</d><h>22:07</h><w>dadair</w>I could check if the type is in a known set of types</z><z id="t1504822092" t="nathanmarz it would look like:"><y>#</y><d>2017-09-07</d><h>22:08</h><w>nathanmarz</w>it would look like:</z><z id="t1504822096" t="nathanmarz (def leaf-nodes (recursive-path [] p (if-path leaf-node? STAY [:children MAP-VALS p] ))) "><y>#</y><d>2017-09-07</d><h>22:08</h><w>nathanmarz</w><pre>(def leaf-nodes
  (recursive-path [] p
    (if-path leaf-node?
      STAY
      [:children MAP-VALS p]
      )))
</pre></z><z id="t1504822102" t="nathanmarz just fill in leaf-node?"><y>#</y><d>2017-09-07</d><h>22:08</h><w>nathanmarz</w>just fill in <code>leaf-node?</code></z><z id="t1504822354" t="dadair Great I&apos;ll give that a try, thanks! Specter is awesome, thanks for open sourcing it!"><y>#</y><d>2017-09-07</d><h>22:12</h><w>dadair</w>Great I&apos;ll give that a try, thanks! Specter is awesome, thanks for open sourcing it!</z><z id="t1505039986" t="andrea.crotti I am trying to go recursively through a hiccup data structure"><y>#</y><d>2017-09-10</d><h>10:39</h><w>andrea.crotti</w>I am trying to go recursively through a hiccup data structure</z><z id="t1505040008" t="andrea.crotti something like this (def nested [:div {:id &quot;hello&quot;} [:a {:href &quot;&quot;} :welcome]]) "><y>#</y><d>2017-09-10</d><h>10:40</h><w>andrea.crotti</w>something like this
<pre>(def nested
  [:div {:id &quot;hello&quot;}
   [:a {:href &quot;&quot;} :welcome]])
</pre></z><z id="t1505040035" t="andrea.crotti and simply replace automaticaly (using the tongue library) every known symbol with its translation"><y>#</y><d>2017-09-10</d><h>10:40</h><w>andrea.crotti</w>and simply replace automaticaly (using the tongue library) every known symbol with its translation</z><z id="t1505040081" t="andrea.crotti so given this dictionary (def dicts &quot;List of all the words/sentences that need localization&quot; {:en {:welcome &quot;Welcome&quot;} :it {:welcome &quot;Benvenuto&quot;}}) "><y>#</y><d>2017-09-10</d><h>10:41</h><w>andrea.crotti</w>so given this dictionary
<pre>(def dicts
  &quot;List of all the words/sentences that need localization&quot;
  {:en {:welcome &quot;Welcome&quot;}
   :it {:welcome &quot;Benvenuto&quot;}})

</pre></z><z id="t1505040091" t="andrea.crotti I just tried this first (s/transform [s/ALL] #(do (print %) (if (contains? dicts %) (translate :en %) %)) nested) "><y>#</y><d>2017-09-10</d><h>10:41</h><w>andrea.crotti</w>I just tried this first
<pre>(s/transform
 [s/ALL]
 #(do
    (print %)
    (if (contains? dicts %)
      (translate :en %)
      %))
 nested)
</pre></z><z id="t1505040134" t="andrea.crotti but it doesn&apos;t actually check :welcome, I also tried to follow the recursive example in the docs (s/transform (s/subselect TreeValues) #(do (print %) (if (contains? dicts %) (translate :en %) %)) nested) "><y>#</y><d>2017-09-10</d><h>10:42</h><w>andrea.crotti</w>but it doesn&apos;t actually check :welcome, I also tried to follow the recursive example in the docs
<pre>(s/transform
 (s/subselect TreeValues)
 #(do
    (print %)
    (if (contains? dicts %)
      (translate :en %)
      %))
 nested)
</pre></z><z id="t1505040140" t="andrea.crotti but it looks like it&apos;s the same thing"><y>#</y><d>2017-09-10</d><h>10:42</h><w>andrea.crotti</w>but it looks like it&apos;s the same thing</z><z id="t1505040152" t="andrea.crotti is it actually possible to do this somehow?"><y>#</y><d>2017-09-10</d><h>10:42</h><w>andrea.crotti</w>is it actually possible to do this somehow?</z><z id="t1505042222" t="nathanmarz @andrea.crotti yes, that&apos;s easy"><y>#</y><d>2017-09-10</d><h>11:17</h><w>nathanmarz</w>@andrea.crotti yes, that&apos;s easy</z><z id="t1505042263" t="nathanmarz where can the target keywords reside? only map values or also in arbitrary vector values or map keys?"><y>#</y><d>2017-09-10</d><h>11:17</h><w>nathanmarz</w>where can the target keywords reside? only map values or also in arbitrary vector values or map keys?</z><z id="t1505042389" t="andrea.crotti I think only in nested vectors "><y>#</y><d>2017-09-10</d><h>11:19</h><w>andrea.crotti</w>I think only in nested vectors </z><z id="t1505042452" t="andrea.crotti Since it&apos;s html text really"><y>#</y><d>2017-09-10</d><h>11:20</h><w>andrea.crotti</w>Since it&apos;s html text really</z><z id="t1505042536" t="nathanmarz (def TreeValues (recursive-path [] p (if-path vector? [ALL p] STAY ))) (def nested [:div {:id &quot;hello&quot;} [:a {:href &quot;&quot;} :welcome]]) (def dicts {:en {:welcome &quot;Welcome&quot;} :it {:welcome &quot;Benvenuto&quot;}}) (let [dict (:en dicts)] (transform [TreeValues #(contains? dict %)] dict nested)) "><y>#</y><d>2017-09-10</d><h>11:22</h><w>nathanmarz</w><pre>(def TreeValues
  (recursive-path [] p
    (if-path vector?
      [ALL p]
      STAY
      )))

(def nested
  [:div {:id &quot;hello&quot;}
   [:a {:href &quot;&quot;} :welcome]])

(def dicts
  {:en {:welcome &quot;Welcome&quot;}
   :it {:welcome &quot;Benvenuto&quot;}})

(let [dict (:en dicts)]
  (transform [TreeValues #(contains? dict %)] dict nested))
</pre></z><z id="t1505042556" t="nathanmarz that&apos;s one way to do it"><y>#</y><d>2017-09-10</d><h>11:22</h><w>nathanmarz</w>that&apos;s one way to do it</z><z id="t1505042636" t="nathanmarz you can make it more precise by making a recursive path that doesn&apos;t go to the first 2 elements of vectors, so that you don&apos;t inadvertently translate the node type if something like :div is used in the dictionary"><y>#</y><d>2017-09-10</d><h>11:23</h><w>nathanmarz</w>you can make it more precise by making a recursive path that doesn&apos;t go to the first 2 elements of vectors, so that you don&apos;t inadvertently translate the node type if something like <code>:div</code> is used in the dictionary</z><z id="t1505053022" t="andrea.crotti Ah nice thanks I&apos;ll try it out"><y>#</y><d>2017-09-10</d><h>14:17</h><w>andrea.crotti</w>Ah nice thanks I&apos;ll try it out</z><z id="t1505122980" t="sandbags I&apos;m not grokking navigators for maps. I have a map like {:a {:x {:y {:z ...}}} :b {:x {:y {:z ...}}} :c {:x {:y {:z ...}}}} and I want to transform the value of :z for all keys in the map :a , :b , :c etc... but every permutation I try gets me something along the lines of Error: Vector&apos;s key for assoc must be a number"><y>#</y><d>2017-09-11</d><h>09:43</h><w>sandbags</w>I&apos;m not grokking navigators for maps. I have a map like <code>{:a {:x {:y {:z ...}}} :b {:x {:y {:z ...}}} :c {:x {:y {:z ...}}}}</code> and I want to transform the value of <code>:z</code> for all keys in the map <code>:a</code>, <code>:b</code>, <code>:c</code> etc... but every permutation I try gets me something along the lines of <code>Error: Vector&apos;s key for assoc must be a number</code></z><z id="t1505123081" t="sandbags i think the problem is about my root map being processed as a vector of key-pairs but i am finding it hard to understand what ids going on (it might help to understand that I do not visualise very well)"><y>#</y><d>2017-09-11</d><h>09:44</h><w>sandbags</w>i think the problem is about my root map being processed as a vector of key-pairs but i am finding it hard to understand what ids going on (it might help to understand that I do not visualise very well)</z><z id="t1505123123" t="sandbags reaching in via a fixed keypath [:a :x :y :z] is okay, but how to put the * at the beginning..."><y>#</y><d>2017-09-11</d><h>09:45</h><w>sandbags</w>reaching in via a fixed keypath <code>[:a :x :y :z]</code> is okay, but how to put the <code>*</code> at the beginning...</z><z id="t1505131155" t="sandbags hrmm... okay i&apos;m not sure what i am doing differently now to earlier but:"><y>#</y><d>2017-09-11</d><h>11:59</h><w>sandbags</w>hrmm... okay i&apos;m not sure what i am doing differently now to earlier but:</z><z id="t1505131171" t="sandbags (nav/transform [nav/MAP-VALS :exits nav/ALL :available] #(not %) {:foo {:exits [{:to :bar :available true}]} :bar {:exits [{:to :foo :available false}]}})"><y>#</y><d>2017-09-11</d><h>11:59</h><w>sandbags</w><code>(nav/transform [nav/MAP-VALS :exits nav/ALL :available] #(not %) {:foo {:exits [{:to :bar :available true}]} :bar {:exits [{:to :foo :available false}]}})</code></z><z id="t1505131203" t="sandbags works and is, structurally, my use case"><y>#</y><d>2017-09-11</d><h>12:00</h><w>sandbags</w>works and is, structurally, my use case</z><z id="t1505131623" t="sandbags I will confess I am still feel quit uncertain about my use of these navigators"><y>#</y><d>2017-09-11</d><h>12:07</h><w>sandbags</w>I will confess I am still feel quit uncertain about my use of these navigators</z><z id="t1505131733" t="levitanong @sandbags this should work for the data structure you posted (transform [MAP-VALS :x :y :z] (fn [z] (* 2 z)) {:a {:x {:y {:z 2}}} :b {:x {:y {:z 3}}} :c {:x {:y {:z 4}}}}"><y>#</y><d>2017-09-11</d><h>12:08</h><w>levitanong</w>@sandbags this should work for the data structure you posted
<code>(transform [MAP-VALS :x :y :z] (fn [z] (* 2 z)) {:a {:x {:y {:z 2}}} :b {:x {:y {:z 3}}} :c {:x {:y {:z 4}}}}</code></z><z id="t1505131793" t="sandbags @levitanong i may have been making some kind of transliteration mistake as that kind of approach didn&apos;t work when i tried it, but yes - thanks. And the example I posted about is my actual use case (structurally at least)"><y>#</y><d>2017-09-11</d><h>12:09</h><w>sandbags</w>@levitanong i may have been making some kind of transliteration mistake as that kind of approach didn&apos;t work when i tried it, but yes - thanks. And the example I posted about is my actual use case (structurally at least)</z><z id="t1505131870" t="levitanong @sandbags Well I’m glad things are working for you now. 😁"><y>#</y><d>2017-09-11</d><h>12:11</h><w>levitanong</w>@sandbags Well I’m glad things are working for you now. <b>😁</b></z><z id="t1505131885" t="sandbags yes, thanks for your help"><y>#</y><d>2017-09-11</d><h>12:11</h><w>sandbags</w>yes, thanks for your help</z><z id="t1505131909" t="sandbags i think a key problem i have (I have something called Aphantasia) is I struggle to visualise what is going on in the navigators"><y>#</y><d>2017-09-11</d><h>12:11</h><w>sandbags</w>i think a key problem i have (I have something called Aphantasia) is I struggle to visualise what is going on in the navigators</z><z id="t1505133074" t="hmaurer @sandbags ah; sounds like there is room to develop a visualization app for navigators then! 🙂"><y>#</y><d>2017-09-11</d><h>12:31</h><w>hmaurer</w>@sandbags ah; sounds like there is room to develop a visualization app for navigators then! <b>🙂</b></z><z id="t1505133094" t="sandbags or some kind of tutorial with some visualisations, yes"><y>#</y><d>2017-09-11</d><h>12:31</h><w>sandbags</w>or some kind of tutorial with some visualisations, yes</z><z id="t1505133103" t="hmaurer yes, that’s what I meant"><y>#</y><d>2017-09-11</d><h>12:31</h><w>hmaurer</w>yes, that’s what I meant</z><z id="t1505133111" t="hmaurer an interactive tutorial"><y>#</y><d>2017-09-11</d><h>12:31</h><w>hmaurer</w>an interactive tutorial</z><z id="t1505133591" t="levitanong @hmaurer @sandbags Now there’s an idea. 🤔"><y>#</y><d>2017-09-11</d><h>12:39</h><w>levitanong</w>@hmaurer @sandbags Now there’s an idea. <b>🤔</b></z><z id="t1505133645" t="hmaurer @levitanong something a bit like http://rxmarbles.com/"><y>#</y><d>2017-09-11</d><h>12:40</h><w>hmaurer</w>@levitanong something a bit like <a href="http://rxmarbles.com/" target="_blank">http://rxmarbles.com/</a></z><z id="t1505133723" t="michaelwfogleman I like http://www.learndatalogtoday.org/ - not really visualizable but good for grokking a DSL"><y>#</y><d>2017-09-11</d><h>12:42</h><w>michaelwfogleman</w>I like <a href="http://www.learndatalogtoday.org/" target="_blank">http://www.learndatalogtoday.org/</a> - not really visualizable but good for grokking a DSL</z><z id="t1505134301" t="nathanmarz @sandbags I&apos;d never heard of aphantasia before, reading about it just blew my mind"><y>#</y><d>2017-09-11</d><h>12:51</h><w>nathanmarz</w>@sandbags I&apos;d never heard of aphantasia before, reading about it just blew my mind</z><z id="t1505134336" t="nathanmarz had no idea that was something that could differ between people"><y>#</y><d>2017-09-11</d><h>12:52</h><w>nathanmarz</w>had no idea that was something that could differ between people</z><z id="t1505134364" t="nathanmarz a visualization is a good idea, I put some thoughts here https://github.com/nathanmarz/specter/issues/56#issuecomment-328519037"><y>#</y><d>2017-09-11</d><h>12:52</h><w>nathanmarz</w>a visualization is a good idea, I put some thoughts here <a href="https://github.com/nathanmarz/specter/issues/56#issuecomment-328519037" target="_blank">https://github.com/nathanmarz/specter/issues/56#issuecomment-328519037</a></z><z id="t1505134397" t="nathanmarz do you think that visualize-path command would be helpful?"><y>#</y><d>2017-09-11</d><h>12:53</h><w>nathanmarz</w>do you think that <code>visualize-path</code> command would be helpful?</z><z id="t1505134703" t="michaelwfogleman @nathanmarz Yes!"><y>#</y><d>2017-09-11</d><h>12:58</h><w>michaelwfogleman</w>@nathanmarz Yes!</z><z id="t1505134721" t="michaelwfogleman (Even for those of us without aphantasia) 🙂"><y>#</y><d>2017-09-11</d><h>12:58</h><w>michaelwfogleman</w>(Even for those of us without aphantasia) <b>🙂</b></z><z id="t1505134736" t="michaelwfogleman Hadn&apos;t seen that issue, subscribing in case I can help..."><y>#</y><d>2017-09-11</d><h>12:58</h><w>michaelwfogleman</w>Hadn&apos;t seen that issue, subscribing in case I can help...</z><z id="t1505134790" t="nathanmarz comments and ideas are welcome on that issue"><y>#</y><d>2017-09-11</d><h>12:59</h><w>nathanmarz</w>comments and ideas are welcome on that issue</z><z id="t1505134812" t="nathanmarz and contributions, of course"><y>#</y><d>2017-09-11</d><h>13:00</h><w>nathanmarz</w>and contributions, of course</z><z id="t1505134837" t="nathanmarz the specter wiki is in its own repository if anyone wants to contribute https://github.com/nathanmarz/specter-wiki"><y>#</y><d>2017-09-11</d><h>13:00</h><w>nathanmarz</w>the specter wiki is in its own repository if anyone wants to contribute <a href="https://github.com/nathanmarz/specter-wiki" target="_blank">https://github.com/nathanmarz/specter-wiki</a></z><z id="t1505134883" t="hmaurer I’ll try to tackle this when I have some time. It could be an interesting opportunity to write an interactive doc"><y>#</y><d>2017-09-11</d><h>13:01</h><w>hmaurer</w>I’ll try to tackle this when I have some time. It could be an interesting opportunity to write an interactive doc</z><z id="t1505134903" t="hmaurer good project to get my hands on ClojureScript 🙂"><y>#</y><d>2017-09-11</d><h>13:01</h><w>hmaurer</w>good project to get my hands on ClojureScript <b>🙂</b></z><z id="t1505134929" t="michaelwfogleman @nathanmarz Do you know off the top of your head which functions / macros etc. aren&apos;t documented or need more explanation? I&apos;m happy to write explanations for the ones I understand."><y>#</y><d>2017-09-11</d><h>13:02</h><w>michaelwfogleman</w>@nathanmarz Do you know off the top of your head which functions / macros etc. aren&apos;t documented or need more explanation? I&apos;m happy to write explanations for the ones I understand.</z><z id="t1505135085" t="nathanmarz looks like almost everything added since 0.13.0"><y>#</y><d>2017-09-11</d><h>13:04</h><w>nathanmarz</w>looks like almost everything added since 0.13.0</z><z id="t1505135092" t="nathanmarz https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><y>#</y><d>2017-09-11</d><h>13:04</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md" target="_blank">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></z><z id="t1505135205" t="nathanmarz nthpath , MAP-KEYS , BEFORE-ELEM , AFTER-ELEM , NONE-ELEM , NAME , NAMESPACE , map-key , set-elem , before-index , index-nav , INDEXED-VALS"><y>#</y><d>2017-09-11</d><h>13:06</h><w>nathanmarz</w><code>nthpath</code>, <code>MAP-KEYS</code>, <code>BEFORE-ELEM</code>, <code>AFTER-ELEM</code>, <code>NONE-ELEM</code>, <code>NAME</code>, <code>NAMESPACE</code>, <code>map-key</code>, <code>set-elem</code>, <code>before-index</code>, <code>index-nav</code>, <code>INDEXED-VALS</code></z><z id="t1505135248" t="nathanmarz plus eachnav , the improvements to keypath /`must`, and the extension of many navigators to work with strings"><y>#</y><d>2017-09-11</d><h>13:07</h><w>nathanmarz</w>plus <code>eachnav</code>, the improvements to <code>keypath</code>/`must`, and the extension of many navigators to work with strings</z><z id="t1505139003" t="michaelwfogleman @nathanmarz Can you give an example of transforming with INDEXED-VALS?"><y>#</y><d>2017-09-11</d><h>14:10</h><w>michaelwfogleman</w>@nathanmarz Can you give an example of transforming with INDEXED-VALS?</z><z id="t1505140069" t="nathanmarz @michaelwfogleman there&apos;s some examples in the tests https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L1620"><y>#</y><d>2017-09-11</d><h>14:27</h><w>nathanmarz</w>@michaelwfogleman there&apos;s some examples in the tests <a href="https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L1620" target="_blank">https://github.com/nathanmarz/specter/blob/master/test/com/rpl/specter/core_test.cljc#L1620</a></z><z id="t1505145493" t="michaelwfogleman @nathanmarz About to push a big pull request for the wiki, did almost everything you listed save for eachnav and the improvement to keypath/must, but also did pred= and co, and traversed"><y>#</y><d>2017-09-11</d><h>15:58</h><w>michaelwfogleman</w>@nathanmarz About to push a big pull request for the wiki, did almost everything you listed save for eachnav and the improvement to keypath/must, but also did pred= and co, and traversed</z><z id="t1505149342" t="hmaurer that was fast"><y>#</y><d>2017-09-11</d><h>17:02</h><r>hmaurer</r>that was fast</z><z id="t1505154296" t="michaelwfogleman Thanks! 🙂 I mostly adapted the tests and docstrings"><y>#</y><d>2017-09-11</d><h>18:24</h><r>michaelwfogleman</r>Thanks! <b>🙂</b> I mostly adapted the tests and docstrings</z><z id="t1505160688" t="nathanmarz @michaelwfogleman merged it in, thanks!"><y>#</y><d>2017-09-11</d><h>20:11</h><w>nathanmarz</w>@michaelwfogleman merged it in, thanks!</z><z id="t1505205876" t="sandbags @nathanmarz i only found out the name for it myself a few months ago. i&apos;ve known i was different for about 20 years but always assumed it was just me as nobody else ever seemed able to relate"><y>#</y><d>2017-09-12</d><h>08:44</h><w>sandbags</w>@nathanmarz i only found out the name for it myself a few months ago. i&apos;ve known i was different for about 20 years but always assumed it was just me as nobody else ever seemed able to relate</z><z id="t1505205899" t="sandbags it turns out something like 2% of the population are somewhere on the spectrum in terms of low-no visualisation"><y>#</y><d>2017-09-12</d><h>08:44</h><w>sandbags</w>it turns out something like 2% of the population are somewhere on the spectrum in terms of low-no visualisation</z><z id="t1505205917" t="sandbags i have a little, enough to confuse the issue but not enough to be useful ... some people have none at all"><y>#</y><d>2017-09-12</d><h>08:45</h><w>sandbags</w>i have a little, enough to confuse the issue but not enough to be useful ... some people have none at all</z><z id="t1505218779" t="nathanmarz @sandbags crazy stuff, got me thinking a lot about how people can experience life differently"><y>#</y><d>2017-09-12</d><h>12:19</h><w>nathanmarz</w>@sandbags crazy stuff, got me thinking a lot about how people can experience life differently</z><z id="t1505218835" t="nathanmarz fyi, someone on twitter pointed me to this facebook group for people with aphantasia https://www.facebook.com/groups/204603509580186/?fref=mentions"><y>#</y><d>2017-09-12</d><h>12:20</h><w>nathanmarz</w>fyi, someone on twitter pointed me to this facebook group for people with aphantasia <a href="https://www.facebook.com/groups/204603509580186/?fref=mentions" target="_blank">https://www.facebook.com/groups/204603509580186/?fref=mentions</a></z><z id="t1505218954" t="hmaurer I am impressed you manage to do your job as a programmer/engineer with aphantasia. Visualisation is such an important thing for me"><y>#</y><d>2017-09-12</d><h>12:22</h><w>hmaurer</w>I am impressed you manage to do your job as a programmer/engineer with aphantasia. Visualisation is such an important thing for me</z><z id="t1505218983" t="hmaurer I cannot phantom how I would be able to work with abstract concepts without an ability to visualise them in one way or another"><y>#</y><d>2017-09-12</d><h>12:23</h><w>hmaurer</w>I cannot phantom how I would be able to work with abstract concepts without an ability to visualise them in one way or another</z><z id="t1505230567" t="sandbags I&apos;ve never found it a problem with abstract concepts, perhaps more so with the details in fact!"><y>#</y><d>2017-09-12</d><h>15:36</h><w>sandbags</w>I&apos;ve never found it a problem with abstract concepts, perhaps more so with the details in fact!</z><z id="t1505234636" t="nha To me it looks like some “specter exercises” would be better suited for learning specter first, and the visualisation part could come in later for more advanced use-cases, when there is lots of data/nested keywords etc. At work we have dev helpers to trim or pprint data structures to files and use diff (or meld) to compare them since it’s no use printing them in Emacs (too big). But I did not need all that to learn how to manipulate data in Clojure. For learning Clojure I used simple examples, easy exercises (I remember http://clojurekoans.com/ being helpful for Clojure). I have yet to play with https://github.com/gdeer81/specter-koans by the way. In the meantime my use of specter is fairly limited."><y>#</y><d>2017-09-12</d><h>16:43</h><w>nha</w>To me it looks like some “specter exercises” would be better suited for learning specter first, and the visualisation part could come in later for more advanced use-cases, when there is lots of data/nested keywords etc.

At work we have dev helpers to trim or pprint data structures to files and use diff (or meld) to compare them since it’s no use printing them in Emacs (too big). But I did not need all that to learn how to manipulate data in Clojure.

For learning Clojure I used simple examples, easy exercises (I remember <a href="http://clojurekoans.com/" target="_blank">http://clojurekoans.com/</a> being helpful for Clojure). I have yet to play with <a href="https://github.com/gdeer81/specter-koans" target="_blank">https://github.com/gdeer81/specter-koans</a> by the way. In the meantime my use of specter is fairly limited.</z><z id="t1505234962" t="nathanmarz yea, specter is naturally suited for learning via a series of progressively more difficult use cases"><y>#</y><d>2017-09-12</d><h>16:49</h><w>nathanmarz</w>yea, specter is naturally suited for learning via a series of progressively more difficult use cases</z><z id="t1505238307" t="gdeer81 Sorry I dropped the ball on writing the specter-koans. I get distracted easily"><y>#</y><d>2017-09-12</d><h>17:45</h><w>gdeer81</w>Sorry I dropped the ball on writing the specter-koans. I get distracted easily</z><z id="t1505264979" t="lvh I’m stuck writing a selector: I’d like to recursively walk down nested maps, and, if I get a choice, deepest first. So, for: {&quot;a&quot; {&quot;b&quot; {&quot;c&quot; 1}}} I’d get {&quot;c&quot; 1} , {&quot;b&quot; {&quot;c&quot; 1}} , {&quot;a&quot; {&quot;b&quot; {&quot;c&quot; 1}}} . I’ve been messing around with recursive-path but haven’t gotten far."><y>#</y><d>2017-09-13</d><h>01:09</h><w>lvh</w>I’m stuck writing a selector: I’d like to recursively walk down nested maps, and, if I get a choice, deepest first. So, for:

<pre>{&quot;a&quot; {&quot;b&quot; {&quot;c&quot; 1}}}
</pre>

I’d get <code>{&quot;c&quot; 1}</code>, <code>{&quot;b&quot; {&quot;c&quot; 1}}</code>, <code>{&quot;a&quot; {&quot;b&quot; {&quot;c&quot; 1}}}</code>. I’ve been messing around with recursive-path but haven’t gotten far.</z><z id="t1505265166" t="lvh writing the nested traversal that just grabs the values at the leaves is easy: (sr/recursive-path [] p (sr/cond-path map? (sr/stay-then-continue [p sr/MAP-VALS]) sr/STAY sr/STAY)) "><y>#</y><d>2017-09-13</d><h>01:12</h><w>lvh</w>writing the nested traversal that just grabs the values at the leaves is easy:

<pre>(sr/recursive-path
   [] p
   (sr/cond-path
    map? (sr/stay-then-continue [p sr/MAP-VALS])
    sr/STAY sr/STAY))
</pre></z><z id="t1505265450" t="lvh This is almost what I want: (def tree-vals (sr/recursive-path [] p (sr/if-path map? [sr/VAL sr/MAP-VALS p] sr/STAY))) is almost what I want: it just returns the 1 too"><y>#</y><d>2017-09-13</d><h>01:17</h><w>lvh</w>This is almost what I want:

<pre>(def tree-vals
  (sr/recursive-path
   [] p
   (sr/if-path map?
    [sr/VAL sr/MAP-VALS p]
    sr/STAY)))
</pre>

is almost what I want: it just returns the <code>1</code> too</z><z id="t1505265508" t="lvh (sr/NONE still selects nil; and I’m not sure how to say “ok you’re done now” — I don’t think it’s STOP, because that just stops navigation entirely, right?)"><y>#</y><d>2017-09-13</d><h>01:18</h><w>lvh</w>(sr/NONE still selects nil; and I’m not sure how to say “ok you’re done now” — I don’t think it’s STOP, because that just stops navigation entirely, right?)</z><z id="t1505282895" t="lvh Got it: (def tree-vals (sr/recursive-path [] p (sr/if-path map? (sr/continue-then-stay [sr/MAP-VALS p])))) "><y>#</y><d>2017-09-13</d><h>06:08</h><w>lvh</w>Got it:
<pre>(def tree-vals
  (sr/recursive-path
   [] p
   (sr/if-path map? (sr/continue-then-stay [sr/MAP-VALS p]))))
</pre></z><z id="t1505301383" t="nathanmarz @lvh you can omit the [] in continue-then-stay"><y>#</y><d>2017-09-13</d><h>11:16</h><w>nathanmarz</w>@lvh you can omit the <code>[]</code> in <code>continue-then-stay</code></z><z id="t1505301394" t="nathanmarz no performance difference, just a little nicer"><y>#</y><d>2017-09-13</d><h>11:16</h><w>nathanmarz</w>no performance difference, just a little nicer</z><z id="t1505312908" t="lvh Ah, thanks :)"><y>#</y><d>2017-09-13</d><h>14:28</h><w>lvh</w>Ah, thanks :)</z><z id="t1505739194" t="michaelwfogleman @nathanmarz: Just pushed a PR for documentation of multiple arguments, wrapping up eachnav/keypath/must. If anything else needs documenting let me know and I&apos;ll try to take a stab at it 🙂"><y>#</y><d>2017-09-18</d><h>12:53</h><w>michaelwfogleman</w>@nathanmarz: Just pushed a PR for documentation of multiple arguments, wrapping up eachnav/keypath/must. If anything else needs documenting let me know and I&apos;ll try to take a stab at it <b>🙂</b></z><z id="t1505740597" t="michaelwfogleman Also did a PR for recursive-path"><y>#</y><d>2017-09-18</d><h>13:16</h><r>michaelwfogleman</r>Also did a PR for recursive-path</z><z id="t1505742623" t="nathanmarz @michaelwfogleman awesome, thanks! I left a couple comments"><y>#</y><d>2017-09-18</d><h>13:50</h><w>nathanmarz</w>@michaelwfogleman awesome, thanks! I left a couple comments</z><z id="t1505754548" t="nathanmarz @michaelwfogleman something else that&apos;s pretty undocumented is the com.rpl.specter.zipper namespace"><y>#</y><d>2017-09-18</d><h>17:09</h><w>nathanmarz</w>@michaelwfogleman something else that&apos;s pretty undocumented is the <code>com.rpl.specter.zipper</code> namespace</z><z id="t1505769278" t="michaelwfogleman @nathanmarz Would you want a separate section of the docs for that?"><y>#</y><d>2017-09-18</d><h>21:14</h><w>michaelwfogleman</w>@nathanmarz Would you want a separate section of the docs for that?</z><z id="t1505769850" t="nathanmarz @michaelwfogleman yea, definitely"><y>#</y><d>2017-09-18</d><h>21:24</h><w>nathanmarz</w>@michaelwfogleman yea, definitely</z><z id="t1505769893" t="nathanmarz those are infrequently needed so putting them with rest of docs would be confusing to new users"><y>#</y><d>2017-09-18</d><h>21:24</h><w>nathanmarz</w>those are infrequently needed so putting them with rest of docs would be confusing to new users</z></g><g id="s15"><z id="t1505862016" t="michaelwfogleman @nathanmarz https://github.com/nathanmarz/specter-wiki/pull/7"><y>#</y><d>2017-09-19</d><h>23:00</h><w>michaelwfogleman</w>@nathanmarz <a href="https://github.com/nathanmarz/specter-wiki/pull/7" target="_blank">https://github.com/nathanmarz/specter-wiki/pull/7</a></z><z id="t1505863508" t="nathanmarz @michaelwfogleman the zipper data structure is an implementation detail, I don&apos;t think showing those belongs in the documentation"><y>#</y><d>2017-09-19</d><h>23:25</h><w>nathanmarz</w>@michaelwfogleman the zipper data structure is an implementation detail, I don&apos;t think showing those belongs in the documentation</z><z id="t1505863578" t="nathanmarz with zipper usage you always do the following steps: 1. navigate to zipper, 2. navigate with zippers to whatever you want to change 3. navigate using NODE or NODE-SEQ to the actual value for updates"><y>#</y><d>2017-09-19</d><h>23:26</h><w>nathanmarz</w>with zipper usage you always do the following steps: 1. navigate to zipper, 2. navigate with zippers to whatever you want to change 3. navigate using <code>NODE</code> or <code>NODE-SEQ</code> to the actual value for updates</z><z id="t1505863651" t="nathanmarz e.g. (transform [VECTOR-ZIP DOWN RIGHT RIGHT NODE] inc [1 2 3 4 5]) ; =&gt; [1 2 4 4 5]"><y>#</y><d>2017-09-19</d><h>23:27</h><w>nathanmarz</w>e.g. <code>(transform [VECTOR-ZIP DOWN RIGHT RIGHT NODE] inc [1 2 3 4 5]) ; =&gt; [1 2 4 4 5]</code></z><z id="t1505863747" t="nathanmarz also here&apos;s an example of NODE-SEQ for you: (setval [VECTOR-ZIP DOWN RIGHT RIGHT NODE-SEQ] [:a :b :c] [1 2 3 4 5]) ;; =&gt; [1 2 :a :b :c 4 5] "><y>#</y><d>2017-09-19</d><h>23:29</h><w>nathanmarz</w>also here&apos;s an example of <code>NODE-SEQ</code> for you:
<pre>(setval [VECTOR-ZIP DOWN RIGHT RIGHT NODE-SEQ] [:a :b :c] [1 2 3 4 5])
;; =&gt; [1 2 :a :b :c 4 5]
</pre></z><z id="t1505912707" t="michaelwfogleman @nathanmarz Thanks for the example!"><y>#</y><d>2017-09-20</d><h>13:05</h><w>michaelwfogleman</w>@nathanmarz Thanks for the example!</z><z id="t1505912724" t="michaelwfogleman The overview is helpful too... I&apos;ve not really used zippers before"><y>#</y><d>2017-09-20</d><h>13:05</h><w>michaelwfogleman</w>The overview is helpful too... I&apos;ve not really used zippers before</z><z id="t1505912749" t="michaelwfogleman For the part you don&apos;t think I should include - are you saying the example zipper?"><y>#</y><d>2017-09-20</d><h>13:05</h><w>michaelwfogleman</w>For the part you don&apos;t think I should include - are you saying the example zipper?</z><z id="t1505912752" t="michaelwfogleman &quot;Let&apos;s also define a sample zipper that we can work with in the examples below. (def data [1 [[2 3 4] 5 6] 7 [8 9]]) (def data-zipper (zip/vector-zip data)) &quot;"><y>#</y><d>2017-09-20</d><h>13:05</h><w>michaelwfogleman</w>&quot;Let&apos;s also define a sample zipper that we can work with in the examples below.

<pre>(def data [1 [[2 3 4] 5 6] 7 [8 9]])
(def data-zipper (zip/vector-zip data))
</pre>&quot;</z><z id="t1505913126" t="michaelwfogleman I added the example of NODE-SEQ that you gave me, as well as a few others to compare to selecting and also using NODE instead"><y>#</y><d>2017-09-20</d><h>13:12</h><w>michaelwfogleman</w>I added the example of NODE-SEQ that you gave me, as well as a few others to compare to selecting and also using NODE instead</z><z id="t1505913679" t="nathanmarz @michaelwfogleman yea, I wouldn&apos;t include data-zipper"><y>#</y><d>2017-09-20</d><h>13:21</h><w>nathanmarz</w>@michaelwfogleman yea, I wouldn&apos;t include <code>data-zipper</code></z><z id="t1505913694" t="nathanmarz that should all be encapsulated in the paths"><y>#</y><d>2017-09-20</d><h>13:21</h><w>nathanmarz</w>that should all be encapsulated in the paths</z><z id="t1505913728" t="michaelwfogleman OK, I think I&apos;ve got what you are saying! 🙂"><y>#</y><d>2017-09-20</d><h>13:22</h><w>michaelwfogleman</w>OK, I think I&apos;ve got what you are saying! <b>🙂</b></z><z id="t1505914099" t="michaelwfogleman Cool, just pushed a new version - let me know if that&apos;s not what you had in mind, or you see anything else 🙂"><y>#</y><d>2017-09-20</d><h>13:28</h><w>michaelwfogleman</w>Cool, just pushed a new version - let me know if that&apos;s not what you had in mind, or you see anything else <b>🙂</b></z><z id="t1505914276" t="nathanmarz I still see zipper data structures printed out as results to the examples"><y>#</y><d>2017-09-20</d><h>13:31</h><w>nathanmarz</w>I still see zipper data structures printed out as results to the examples</z><z id="t1505914302" t="nathanmarz like for (S/select-any [SZ/VECTOR-ZIP SZ/DOWN] data)"><y>#</y><d>2017-09-20</d><h>13:31</h><w>nathanmarz</w>like for <code>(S/select-any [SZ/VECTOR-ZIP SZ/DOWN] data)</code></z><z id="t1505914977" t="michaelwfogleman Got it, I see what you&apos;re saying now, that does make it a lot neater. I pushed a new version and also added your comment about the three steps - I can remove that but I found what you said useful 🙂"><y>#</y><d>2017-09-20</d><h>13:42</h><w>michaelwfogleman</w>Got it, I see what you&apos;re saying now, that does make it a lot neater. I pushed a new version and also added your comment about the three steps - I can remove that but I found what you said useful <b>🙂</b></z><z id="t1505938888" t="pataprogramming I’m wrestling with figuring out recursive paths. Specifically, I’m processing and transforming some JSON-LD. I’d like to perform some transformations at any level of the tree, with arbitrary nesting. To simplify, consider a map where keys are primitive strings and values can be a primitive, a nested map, or a vector of nested maps. A standard transformation might be: if a map has a key jkl:mno equal to wibble , add a new key jkl:123 equal to whammy . Here’s a test map: {&quot;abc:def&quot;: [{&quot;abc:ghi&quot;: {&quot;jkl:mno&quot;: &quot;womble&quot;, &quot;jkl:qrs&quot;: 12345}}, {&quot;abc:tuv&quot;: {&quot;jkl:mno&quot;: &quot;wibble&quot;, &quot;abc:def&quot;: {&quot;abc:ghi&quot;: [{&quot;jkl:mno&quot;: &quot;wibble&quot;, &quot;jkl:qrs&quot;: 0 }, {&quot;jkl:qrs&quot;: 20}]}}}], &quot;abc:wxy&quot;: {&quot;abc:def&quot;: {&quot;jkl:mno&quot;: &quot;wibble&quot;}}}"><y>#</y><d>2017-09-20</d><h>20:21</h><w>pataprogramming</w>I’m wrestling with figuring out recursive paths. Specifically, I’m processing and transforming some JSON-LD.  I’d like to perform some transformations at any level of the tree, with arbitrary nesting. To simplify, consider a map where keys are primitive strings and values can be a primitive, a nested map, or a vector of nested maps. 

A standard transformation might be: if a map has a key <code>jkl:mno</code> equal to <code>wibble</code>, add a new key <code>jkl:123</code> equal to <code>whammy</code>.  Here’s a test map:

<pre>{&quot;abc:def&quot;: [{&quot;abc:ghi&quot;: {&quot;jkl:mno&quot;: &quot;womble&quot;,
                          &quot;jkl:qrs&quot;: 12345}},
             {&quot;abc:tuv&quot;: {&quot;jkl:mno&quot;: &quot;wibble&quot;,
                          &quot;abc:def&quot;: {&quot;abc:ghi&quot;: [{&quot;jkl:mno&quot;: &quot;wibble&quot;,
                                                   &quot;jkl:qrs&quot;: 0 },
                                                  {&quot;jkl:qrs&quot;: 20}]}}}],
 &quot;abc:wxy&quot;: {&quot;abc:def&quot;: {&quot;jkl:mno&quot;: &quot;wibble&quot;}}}</pre></z><z id="t1505939087" t="pataprogramming walker terminates as soon as it matches, so it’s clear a recursive path is needed. Is recursive-path the right one to be using, or is this a job for a extend-protocolpath providing implementations for vectors and maps?"><y>#</y><d>2017-09-20</d><h>20:24</h><w>pataprogramming</w><code>walker</code> terminates as soon as it matches, so it’s clear a recursive path is needed. Is <code>recursive-path</code> the right one to be using, or is this a job for a <code>extend-protocolpath</code> providing implementations for vectors and maps?</z><z id="t1505939470" t="pataprogramming Some of the maps are sorted-maps , as well, to influence the serialization when the JSON is written out, so just providing an implementation for clojure.lang.PersistentHashMap won’t cut it in the latter case."><y>#</y><d>2017-09-20</d><h>20:31</h><w>pataprogramming</w>Some of the maps are <code>sorted-maps</code>, as well, to influence the serialization when the JSON is written out, so just providing an implementation for <code>clojure.lang.PersistentHashMap</code> won’t cut it  in the latter case.</z><z id="t1505940891" t="nathanmarz @pataprogramming use recursive-path"><y>#</y><d>2017-09-20</d><h>20:54</h><w>nathanmarz</w>@pataprogramming use <code>recursive-path</code></z><z id="t1505940894" t="nathanmarz I&apos;ll show you how"><y>#</y><d>2017-09-20</d><h>20:54</h><w>nathanmarz</w>I&apos;ll show you how</z><z id="t1505940895" t="nathanmarz one sec"><y>#</y><d>2017-09-20</d><h>20:54</h><w>nathanmarz</w>one sec</z><z id="t1505941281" t="nathanmarz (def data {&quot;abc:def&quot; [{&quot;abc:ghi&quot; {&quot;jkl:mno&quot; &quot;womble&quot;, &quot;jkl:qrs&quot; 12345}}, {&quot;abc:tuv&quot; {&quot;jkl:mno&quot; &quot;wibble&quot;, &quot;abc:def&quot; {&quot;abc:ghi&quot; [{&quot;jkl:mno&quot; &quot;wibble&quot;, &quot;jkl:qrs&quot; 0 }, {&quot;jkl:qrs&quot; 20}]}}}], &quot;abc:wxy&quot; {&quot;abc:def&quot; {&quot;jkl:mno&quot; &quot;wibble&quot;}}}) (def MY-WALKER (recursive-path [] p (continue-then-stay (cond-path map? [MAP-VALS p] sequential? [ALL p] )))) (setval [MY-WALKER map? (selected? (keypath &quot;jkl:mno&quot;) (pred= &quot;wibble&quot;)) (keypath &quot;jkl:123&quot;)] &quot;whammy&quot; data) "><y>#</y><d>2017-09-20</d><h>21:01</h><w>nathanmarz</w><pre>(def data
  {&quot;abc:def&quot; [{&quot;abc:ghi&quot; {&quot;jkl:mno&quot; &quot;womble&quot;,
                          &quot;jkl:qrs&quot; 12345}},
               {&quot;abc:tuv&quot; {&quot;jkl:mno&quot; &quot;wibble&quot;,
                            &quot;abc:def&quot; {&quot;abc:ghi&quot; [{&quot;jkl:mno&quot; &quot;wibble&quot;,
                                                     &quot;jkl:qrs&quot; 0 },
                                                    {&quot;jkl:qrs&quot; 20}]}}}],
   &quot;abc:wxy&quot; {&quot;abc:def&quot; {&quot;jkl:mno&quot; &quot;wibble&quot;}}})


(def MY-WALKER
  (recursive-path [] p
    (continue-then-stay
      (cond-path
        map? [MAP-VALS p]
        sequential? [ALL p]
        ))))

(setval [MY-WALKER map? (selected? (keypath &quot;jkl:mno&quot;) (pred= &quot;wibble&quot;)) (keypath &quot;jkl:123&quot;)] &quot;whammy&quot; data)
</pre></z><z id="t1505943701" t="pataprogramming @nathanmarz: Oh, great, thanks! cond-path is what I didn’t know I was groping for. And that example also helps make it clear how to use self-sym , which I wasn’t quite grokking."><y>#</y><d>2017-09-20</d><h>21:41</h><w>pataprogramming</w>@nathanmarz: Oh, great, thanks! <code>cond-path</code> is what I didn’t know I was groping for. And that example also helps make it clear how to use <code>self-sym</code>, which I wasn’t quite grokking.</z><z id="t1505943880" t="pataprogramming Major kudos for specter, by the way. It’s a brilliant library."><y>#</y><d>2017-09-20</d><h>21:44</h><w>pataprogramming</w>Major kudos for specter, by the way. It’s a brilliant library.</z><z id="t1505943913" t="nathanmarz happy to hear you&apos;re getting good use out of it"><y>#</y><d>2017-09-20</d><h>21:45</h><w>nathanmarz</w>happy to hear you&apos;re getting good use out of it</z><z id="t1506078830" t="nha I have a recursive-path walker in the works, but I am hitting a not on a particular prismatic/shema record. In particular, s/if returns a record with two paths I would like to explore (say, left and right). I know how to extract them from the record but not how to navigate to both of them: (def ^:private PATH-SCHEMA-WALKER (recursive-path [] p (cond-path (fn [v] (instance? schema.core.ConditionalSchema v)) [ALL (collect-one FIRST) LAST p] ;; how do I walk left and right here? (fn [v] (cond (primitive-schema? v) false (map? v) true ;; this is a real path :default false)) [ALL (collect-one FIRST) LAST p] (fn [v] true) STAY))) Here is my attempt above, but I don&apos;t know what to put for the first path. Here is how I can extract the schemas: (if (instance? schema.core.ConditionalSchema x) (let [[p+s1 s2] (:preds-and-schemas (s/if map? {:first :schema} {:second :schema}) )] {:s1 (second p+s1) :s2 s2}) x ) "><y>#</y><d>2017-09-22</d><h>11:13</h><w>nha</w>I have a recursive-path walker in the works, but I am hitting a not on a particular prismatic/shema record. In particular, <code>s/if</code> returns a record with two paths I would like to explore (say, left and right). I know how to extract them from the record but not how to navigate to both of them: 
<pre>(def ^:private PATH-SCHEMA-WALKER
  (recursive-path [] p
                  (cond-path
                    (fn [v]
                      (instance? schema.core.ConditionalSchema v))
                    [ALL (collect-one FIRST) LAST p] ;; how do I walk left and right here?

                    (fn [v]
                      (cond
                        (primitive-schema? v) false
                        (map? v) true ;; this is a real path
                        :default false))
                    [ALL (collect-one FIRST) LAST p]

                    (fn [v] true) STAY)))
</pre>
Here is my attempt above, but I don&apos;t know what to put for the first path. Here is how I can extract the schemas:
<pre>(if (instance? schema.core.ConditionalSchema x)
    (let [[p+s1 s2] (:preds-and-schemas (s/if map?
                                          {:first :schema} {:second :schema})
                                        )]
      {:s1 (second p+s1) :s2 s2})
    x
    )
</pre></z><z id="t1506085418" t="nathanmarz @nha to walk multiple paths the general answer is to use multi-path , e.g. (multi-path :left :right)"><y>#</y><d>2017-09-22</d><h>13:03</h><w>nathanmarz</w>@nha to walk multiple paths the general answer is to use <code>multi-path</code>, e.g. <code>(multi-path :left :right)</code></z><z id="t1506086021" t="nha Will try, thanks simple_smile "><y>#</y><d>2017-09-22</d><h>13:13</h><w>nha</w>Will try, thanks <b>simple_smile</b> </z><z id="t1506086761" t="nathanmarz @nha btw instead of (fn [v] true) for default case you can just write STAY"><y>#</y><d>2017-09-22</d><h>13:26</h><w>nathanmarz</w>@nha btw instead of <code>(fn [v] true)</code> for default case you can just write <code>STAY</code></z><z id="t1506131248" t="sophiago Does Specter have known issues with OpenJDK7? I&apos;ve never used it myself, but just noticed an error on a Travis build."><y>#</y><d>2017-09-23</d><h>01:47</h><w>sophiago</w>Does Specter have known issues with OpenJDK7? I&apos;ve never used it myself, but just noticed an error on a Travis build.</z><z id="t1506133051" t="nathanmarz @sophiago I haven&apos;t tested it on that, I&apos;d have to see the error to have an idea of whether that&apos;s related to Specter or not"><y>#</y><d>2017-09-23</d><h>02:17</h><w>nathanmarz</w>@sophiago I haven&apos;t tested it on that, I&apos;d have to see the error to have an idea of whether that&apos;s related to Specter or not</z><z id="t1506133523" t="sophiago The error was Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: com/rpl/specter/Util : Unsupported major.minor version 52.0, compiling:(com/rpl/specter/impl.cljc:1:1) . Let me know if you want me to file an issue."><y>#</y><d>2017-09-23</d><h>02:25</h><w>sophiago</w>The error was <code>Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: com/rpl/specter/Util : Unsupported major.minor version 52.0, compiling:(com/rpl/specter/impl.cljc:1:1)</code>. Let me know if you want me to file an issue.</z><z id="t1506133568" t="sophiago (I understand that&apos;s not particularly informative)"><y>#</y><d>2017-09-23</d><h>02:26</h><w>sophiago</w>(I understand that&apos;s not particularly informative)</z><z id="t1506134104" t="sophiago Oh, that was a fast Googling. I guess it just means the jar was built in 8 and I&apos;m trying to run it in 7."><y>#</y><d>2017-09-23</d><h>02:35</h><w>sophiago</w>Oh, that was a fast Googling. I guess it just means the jar was built in 8 and I&apos;m trying to run it in 7.</z><z id="t1506134191" t="sophiago I&apos;m also on the 1.9 alpha, although I don&apos;t think that should factor in. I&apos;m getting the jar straight from Maven."><y>#</y><d>2017-09-23</d><h>02:36</h><w>sophiago</w>I&apos;m also on the 1.9 alpha, although I don&apos;t think that should factor in. I&apos;m getting the jar straight from Maven.</z><z id="t1506135700" t="nathanmarz yea that&apos;s cause the java code was compiled to a different version"><y>#</y><d>2017-09-23</d><h>03:01</h><w>nathanmarz</w>yea that&apos;s cause the java code was compiled to a different version</z><z id="t1506135703" t="nathanmarz not a specter issue"><y>#</y><d>2017-09-23</d><h>03:01</h><w>nathanmarz</w>not a specter issue</z><z id="t1506138806" t="sophiago Sorry, could you please clarify? If I&apos;m just having Lein pull it from Maven then how would I control how it&apos;s built?"><y>#</y><d>2017-09-23</d><h>03:53</h><w>sophiago</w>Sorry, could you please clarify? If I&apos;m just having Lein pull it from Maven then how would I control how it&apos;s built?</z><z id="t1506158837" t="nathanmarz @sophiago specter has a little bit of java code so the jar contains a couple classfiles"><y>#</y><d>2017-09-23</d><h>09:27</h><w>nathanmarz</w>@sophiago specter has a little bit of java code so the jar contains a couple classfiles</z><z id="t1506158876" t="nathanmarz you can try building specter yourself by checking out the project and running lein jar or lein install"><y>#</y><d>2017-09-23</d><h>09:27</h><w>nathanmarz</w>you can try building specter yourself by checking out the project and running <code>lein jar</code> or <code>lein install</code></z><z id="t1506160090" t="sophiago In that case, I think I&apos;ll just drop support for OpenJDK7. I think for libraries that&apos;s an appropriate expectation now that JDK9 is out. I&apos;m not sure if this is something you&apos;d want to mention in your documentation, though (I will in mine). All other Clojure libraries I use support it."><y>#</y><d>2017-09-23</d><h>09:48</h><w>sophiago</w>In that case, I think I&apos;ll just drop support for OpenJDK7. I think for libraries that&apos;s an appropriate expectation now that JDK9 is out. I&apos;m not sure if this is something you&apos;d want to mention in your documentation, though (I will in mine). All other Clojure libraries I use support it.</z><z id="t1506398579" t="Nick Drew Java 9 has support for jars with multiple versions of class files. might be a handy way to preserve backward compatibility @U173SEFUN "><y>#</y><d>2017-09-26</d><h>04:02</h><r>Nick Drew</r>Java 9 has support for jars with multiple versions of class files. might be a handy way to preserve backward compatibility @U173SEFUN </z><z id="t1506381109" t="chromalchemy If I my navigation leads to a vector of strings, how do I continue to navigate the strings as whole values instead of splicing into charachter subsequences? (select [ALL FIRST] [&quot;aaa&quot; &quot;bbb&quot; &quot;ccc&quot;]) gives [&quot;a&quot; &quot;b&quot; &quot;c&quot;] instead of [&quot;aaa&quot;]"><y>#</y><d>2017-09-25</d><h>23:11</h><w>chromalchemy</w>If I my navigation leads to a vector of strings, how do I continue to navigate the strings as whole values instead of splicing into charachter subsequences?  <code>(select [ALL FIRST] [&quot;aaa&quot; &quot;bbb&quot; &quot;ccc&quot;]) </code> gives <code>[&quot;a&quot; &quot;b&quot; &quot;c&quot;]</code> instead of <code>[&quot;aaa&quot;]</code></z><z id="t1506381179" t="chromalchemy Using keypath on a list of maps gave me the vector of strings, and I want to use srange on it..."><y>#</y><d>2017-09-25</d><h>23:12</h><w>chromalchemy</w>Using <code>keypath</code> on a list of maps gave me the vector of strings, and I want to use <code>srange</code> on it...</z><z id="t1506389954" t="nathanmarz @chromalchemy if you have a vector of strings and just want to navigate to the first one, it&apos;s just FIRST"><y>#</y><d>2017-09-26</d><h>01:39</h><w>nathanmarz</w>@chromalchemy if you have a vector of strings and just want to navigate to the first one, it&apos;s just <code>FIRST</code></z><z id="t1506390002" t="nathanmarz keypath won&apos;t work on lists, but nthpath will"><y>#</y><d>2017-09-26</d><h>01:40</h><w>nathanmarz</w><code>keypath</code> won&apos;t work on lists, but <code>nthpath</code> will</z><z id="t1506707235" t="teawaterwire Hi there, I&apos;m having trouble doing the following: ;; Considering this map m (def m {:a 3 :b {10 {:c 3} 2 {:d 4} 20 {:c 5}}}) ;; I&apos;d like to remove entries in the :b map if ;; the key is &lt; 15 ;; and ;; the value doesn&apos;t contain :d ;; so it&apos;s like: ; {:a 3 ; :b {2 {:d 4} ; 20 {:c 5}}} "><y>#</y><d>2017-09-29</d><h>17:47</h><w>teawaterwire</w>Hi there, I&apos;m having trouble doing the following: 
<pre>;; Considering this map m
(def m {:a 3
        :b {10 {:c 3}
            2 {:d 4}
            20 {:c 5}}})
;; I&apos;d like to remove entries in the :b map if 
;; the key is &lt; 15
;; and 
;; the value doesn&apos;t contain :d 
;; so it&apos;s like:
; {:a 3
;  :b {2 {:d 4}
;      20 {:c 5}}}
</pre></z><z id="t1506707416" t="teawaterwire I managed to do it with (sp/setval [:b sp/ALL (fn [[k v]] (and (&lt; k 15) (not (contains? v :d))))] sp/NONE m) but I guess there could be a more elegant solution?"><y>#</y><d>2017-09-29</d><h>17:50</h><w>teawaterwire</w>I managed to do it with <code>(sp/setval [:b sp/ALL (fn [[k v]] (and (&lt; k 15) (not (contains? v :d))))] sp/NONE m)</code> but I guess there could be a more elegant solution?</z><z id="t1506710365" t="nathanmarz here&apos;s a way that doesn&apos;t use any anonymous functions: (setval [:b ALL (not-selected? LAST (must :d)) FIRST (pred&lt; 15)] NONE m) "><y>#</y><d>2017-09-29</d><h>18:39</h><w>nathanmarz</w>here&apos;s a way that doesn&apos;t use any anonymous functions:
<pre>(setval
  [:b
   ALL
   (not-selected? LAST (must :d))
   FIRST
   (pred&lt; 15)]
  NONE
  m)
</pre></z><z id="t1506711577" t="teawaterwire Amazing, thanks! I tried something with not-selected? but I got stuck at: (setval [:b (not-selected? MAP-VALS (must :d)) MAP-KEYS (pred&lt; 15)] NONE m) "><y>#</y><d>2017-09-29</d><h>18:59</h><w>teawaterwire</w>Amazing, thanks!
I tried something with <code>not-selected?</code> but I got stuck at:
<pre>(setval
 [:b
  (not-selected? MAP-VALS (must :d))
  MAP-KEYS
  (pred&lt; 15)]
 NONE
 m)
</pre></z><z id="t1506711922" t="nathanmarz that not-selected? call is a filter on the map as a whole"><y>#</y><d>2017-09-29</d><h>19:05</h><w>nathanmarz</w>that <code>not-selected?</code> call is a filter on the map as a whole</z><z id="t1506712009" t="nathanmarz using ALL lets you test both conditions on the same entry"><y>#</y><d>2017-09-29</d><h>19:06</h><w>nathanmarz</w>using <code>ALL</code> lets you test both conditions on the same entry</z><z id="t1506713327" t="teawaterwire Neat 👍"><y>#</y><d>2017-09-29</d><h>19:28</h><w>teawaterwire</w>Neat <b>👍</b></z><z id="t1506823463" t="michaelwfogleman I just found myself writing a helper function, (defn match-path [p] (if-path p STAY)) - is there a more idiomatic way to do that, or is that sensible (TM)?"><y>#</y><d>2017-10-01</d><h>02:04</h><w>michaelwfogleman</w>I just found myself writing a helper function, (defn match-path [p] (if-path p STAY)) - is there a more idiomatic way to do that, or is that sensible (TM)?</z><z id="t1506851982" t="nathanmarz @michaelwfogleman that&apos;s selected?"><y>#</y><d>2017-10-01</d><h>09:59</h><w>nathanmarz</w>@michaelwfogleman that&apos;s <code>selected?</code></z><z id="t1506852031" t="nathanmarz also, that would be a very unperformant way to implement selected? , since it would force recompilation of that subpath every single time the callsite is invoked"><y>#</y><d>2017-10-01</d><h>10:00</h><w>nathanmarz</w>also, that would be a very unperformant way to implement <code>selected?</code>, since it would force recompilation of that subpath every single time the callsite is invoked</z><z id="t1506852051" t="nathanmarz (defdynamicnav match-path [p] (if-path p STAY)) fixes it"><y>#</y><d>2017-10-01</d><h>10:00</h><w>nathanmarz</w><code>(defdynamicnav match-path [p] (if-path p STAY))</code> fixes it</z><z id="t1506877152" t="michaelwfogleman Got it, thanks! I don&apos;t think we&apos;ve documented defdynamicnav and defrichnav, anything I&apos;m missing? I&apos;ll try to make a PR at some point"><y>#</y><d>2017-10-01</d><h>16:59</h><w>michaelwfogleman</w>Got it, thanks! I don&apos;t think we&apos;ve documented defdynamicnav and defrichnav, anything I&apos;m missing? I&apos;ll try to make a PR at some point</z><z id="t1506879175" t="michaelwfogleman Then again that may be above my pay grade... 🙂"><y>#</y><d>2017-10-01</d><h>17:32</h><w>michaelwfogleman</w>Then again that may be above my pay grade... <b>🙂</b></z><z id="t1506879693" t="michaelwfogleman Ah it&apos;s in the inline caching implementation doc - had not read that"><y>#</y><d>2017-10-01</d><h>17:41</h><w>michaelwfogleman</w>Ah it&apos;s in the inline caching implementation doc - had not read that</z><z id="t1506893700" t="nathanmarz yea, that would be a good one to document"><y>#</y><d>2017-10-01</d><h>21:35</h><w>nathanmarz</w>yea, that would be a good one to document</z><z id="t1506944187" t="michaelwfogleman Have a basic PR submitted, just pointing to the inline caching doc- nothing for defrichnav"><y>#</y><d>2017-10-02</d><h>11:36</h><w>michaelwfogleman</w>Have a basic PR submitted, just pointing to the inline caching doc- nothing for defrichnav</z><z id="t1507210683" t="hkjels Can I use specter to get the path of some deeply nested key using a predicate? Say I want the path to the last value that’s brown here: {:a &quot;foo&quot; :b :_ :c {:d &quot;brown&quot; :e &quot;bar&quot;} :f [{:g &quot;pale&quot; :h &quot;brown&quot; :i {:j &quot;ale&quot; :k [{:l &quot;brown&quot;} {:l &quot;brown&quot;}]}}]}"><y>#</y><d>2017-10-05</d><h>13:38</h><w>hkjels</w>Can I use <code>specter</code> to get the path of some deeply nested key using a predicate?
Say I want the path to the last value that’s <code>brown</code> here:
<code>{:a &quot;foo&quot; :b :_ :c {:d &quot;brown&quot; :e &quot;bar&quot;} :f [{:g &quot;pale&quot; :h &quot;brown&quot; :i {:j &quot;ale&quot; :k [{:l &quot;brown&quot;} {:l &quot;brown&quot;}]}}]}</code></z><z id="t1507211956" t="nathanmarz @hkjels yes, you use recursive-path and collect-one"><y>#</y><d>2017-10-05</d><h>13:59</h><w>nathanmarz</w>@hkjels yes, you use <code>recursive-path</code> and <code>collect-one</code></z><z id="t1507211960" t="nathanmarz a related example here: https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure"><y>#</y><d>2017-10-05</d><h>13:59</h><w>nathanmarz</w>a related example here: <a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure" target="_blank">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure</a></z><z id="t1507212895" t="hkjels @nathanmarz thanks! I’ll give that a shot Looks like a really good lib"><y>#</y><d>2017-10-05</d><h>14:14</h><w>hkjels</w>@nathanmarz thanks! I’ll give that a shot
Looks like a really good lib</z><z id="t1507220763" t="michaelwfogleman @nathanmarz: Just pushed a new version of PR with mutual recursion and the building blocks we&apos;ve been working on - could use an assist coming up with a better example for mutually recursive paths"><y>#</y><d>2017-10-05</d><h>16:26</h><w>michaelwfogleman</w>@nathanmarz: Just pushed a new version of PR with mutual recursion and the building blocks we&apos;ve been working on - could use an assist coming up with a better example for mutually recursive paths</z><z id="t1507226009" t="nathanmarz @michaelwfogleman I only ever made a mutually recursive path once... and it&apos;s way too involved to use as an example"><y>#</y><d>2017-10-05</d><h>17:53</h><w>nathanmarz</w>@michaelwfogleman I only ever made a mutually recursive path once... and it&apos;s way too involved to use as an example</z><z id="t1507226042" t="nathanmarz I think just showing the basics of how mutually recursive paths would be structured is sufficient"><y>#</y><d>2017-10-05</d><h>17:54</h><w>nathanmarz</w>I think just showing the basics of how mutually recursive paths would be structured is sufficient</z><z id="t1507231324" t="gdeer81 speaking of examples, if anyone has any interesting ones that they want me to turn into a specter koan, just open an issue and paste it in https://github.com/gdeer81/specter-koans/issues"><y>#</y><d>2017-10-05</d><h>19:22</h><w>gdeer81</w>speaking of examples, if anyone has any interesting ones that they want me to turn into a specter koan, just open an issue and paste it in <a href="https://github.com/gdeer81/specter-koans/issues" target="_blank">https://github.com/gdeer81/specter-koans/issues</a></z><z id="t1507231379" t="gdeer81 or you can just paste your scratchpad and I can mine it for any good nuggets"><y>#</y><d>2017-10-05</d><h>19:22</h><w>gdeer81</w>or you can just paste your scratchpad and I can mine it for any good nuggets</z><z id="t1507242319" t="michaelwfogleman @nathanmarz In that case, the PR should be either pretty close or good to go 🙂"><y>#</y><d>2017-10-05</d><h>22:25</h><w>michaelwfogleman</w>@nathanmarz In that case, the PR should be either pretty close or good to go <b>🙂</b></z><z id="t1507303961" t="gdeer81 is AFTER-ELEM used in selections or is just primarily used with setval ? I want to make sure my koans cover possible use cases unless it doesn&apos;t make sense."><y>#</y><d>2017-10-06</d><h>15:32</h><w>gdeer81</w>is <code>AFTER-ELEM</code> used in selections or is just primarily used with <code>setval</code> ? I want to make sure my koans cover possible use cases unless it doesn&apos;t make sense.</z><z id="t1507304674" t="gdeer81 also, I watched the talk and was excited about specter keeping the collection type the same so I was surprised when I saw this (setval AFTER-ELEM 2 #{1 2}) =&gt; (1 2 2)"><y>#</y><d>2017-10-06</d><h>15:44</h><w>gdeer81</w>also, I watched the talk and was excited about specter keeping the collection type the same so I was surprised when I saw this <code>(setval AFTER-ELEM 2 #{1 2}) =&gt; (1 2 2)</code></z><z id="t1507304703" t="gdeer81 the set was turned into a list"><y>#</y><d>2017-10-06</d><h>15:45</h><w>gdeer81</w>the set was turned into a list</z><z id="t1507304943" t="gdeer81 it does the same thing for a map"><y>#</y><d>2017-10-06</d><h>15:49</h><w>gdeer81</w>it does the same thing for a map</z><z id="t1507305010" t="gdeer81 I tried to pass a k/v pair to AFTER-ELEM as two args and go a wrong number of args error"><y>#</y><d>2017-10-06</d><h>15:50</h><w>gdeer81</w>I tried to pass a k/v pair to AFTER-ELEM as two args and go a wrong number of args error</z><z id="t1507305343" t="gdeer81 when I put the k/v pair as a map it just turned the original map into a vector, added it to a list and then added my k/v argument as a separate map in the list like this: (setval AFTER-ELEM {:friend &quot;Mary&quot;} {:name &quot;Paul&quot;}) =&gt; ([:name &quot;Paul&quot;] {:friend &quot;Mary&quot;}) so since the result isn&apos;t treated like a map you don&apos;t need k/v pair balance (setval AFTER-ELEM &quot;Mary&quot; {:name &quot;Paul&quot;}) =&gt; ([:name &quot;Paul&quot;] &quot;Mary&quot;)"><y>#</y><d>2017-10-06</d><h>15:55</h><w>gdeer81</w>when I put the k/v pair as a map it just turned the original map into a vector, added it to a list and then added my k/v argument as a separate map in the list like this: <code>(setval AFTER-ELEM {:friend &quot;Mary&quot;} {:name &quot;Paul&quot;}) =&gt; ([:name &quot;Paul&quot;] {:friend &quot;Mary&quot;})</code> so since the result isn&apos;t treated like a map you don&apos;t need k/v pair balance <code>(setval AFTER-ELEM &quot;Mary&quot; {:name &quot;Paul&quot;}) =&gt; ([:name &quot;Paul&quot;] &quot;Mary&quot;)</code></z><z id="t1507305462" t="gdeer81 I just want to make sure I&apos;m not documenting nonsense cases"><y>#</y><d>2017-10-06</d><h>15:57</h><w>gdeer81</w>I just want to make sure I&apos;m not documenting nonsense cases</z><z id="t1507305554" t="nathanmarz @gdeer81 AFTER-ELEM is only intended for transformations"><y>#</y><d>2017-10-06</d><h>15:59</h><w>nathanmarz</w>@gdeer81 <code>AFTER-ELEM</code> is only intended for transformations</z><z id="t1507305574" t="nathanmarz it doesn&apos;t make sense in the context of a set"><y>#</y><d>2017-10-06</d><h>15:59</h><w>nathanmarz</w>it doesn&apos;t make sense in the context of a set</z><z id="t1507305586" t="nathanmarz to add a single element to a set most efficiently use NONE-ELEM"><y>#</y><d>2017-10-06</d><h>15:59</h><w>nathanmarz</w>to add a single element to a set most efficiently use <code>NONE-ELEM</code></z><z id="t1507305612" t="nathanmarz likewise, it doesn&apos;t make sense in the context of a map"><y>#</y><d>2017-10-06</d><h>16:00</h><w>nathanmarz</w>likewise, it doesn&apos;t make sense in the context of a map</z><z id="t1507305616" t="nathanmarz for a map, just use keypath"><y>#</y><d>2017-10-06</d><h>16:00</h><w>nathanmarz</w>for a map, just use <code>keypath</code></z><z id="t1507305664" t="gdeer81 I figured that was the case"><y>#</y><d>2017-10-06</d><h>16:01</h><w>gdeer81</w>I figured that was the case</z><z id="t1507306290" t="gdeer81 so for each navigation I&apos;m trying to document intended use and collection types"><y>#</y><d>2017-10-06</d><h>16:11</h><w>gdeer81</w>so for each navigation I&apos;m trying to document intended use and collection types</z><z id="t1507306371" t="nathanmarz cool, that&apos;s good"><y>#</y><d>2017-10-06</d><h>16:12</h><w>nathanmarz</w>cool, that&apos;s good</z><z id="t1507306378" t="nathanmarz would be a good thing to add to the docstrings too"><y>#</y><d>2017-10-06</d><h>16:12</h><w>nathanmarz</w>would be a good thing to add to the docstrings too</z><z id="t1507306469" t="gdeer81 ha or even the spec, &quot;spec error: you shouldn&apos;t be using this on a set&quot;"><y>#</y><d>2017-10-06</d><h>16:14</h><w>gdeer81</w>ha or even the spec, &quot;spec error: you shouldn&apos;t be using this on a set&quot;</z><z id="t1507319425" t="michaelwfogleman Does Specter have specs? I didn&apos;t think it did"><y>#</y><d>2017-10-06</d><h>19:50</h><w>michaelwfogleman</w>Does Specter have specs? I didn&apos;t think it did</z><z id="t1507319441" t="michaelwfogleman I&apos;m pretty new to specs but I&apos;d be willing to help spec Specter if that&apos;s of interest"><y>#</y><d>2017-10-06</d><h>19:50</h><w>michaelwfogleman</w>I&apos;m pretty new to specs but I&apos;d be willing to help spec Specter if that&apos;s of interest</z><z id="t1507321654" t="michaelwfogleman Yeah, took another look and pretty sure it doesn&apos;t, since it&apos;s on 1.8.0 and there&apos;s no files included"><y>#</y><d>2017-10-06</d><h>20:27</h><w>michaelwfogleman</w>Yeah, took another look and pretty sure it doesn&apos;t, since it&apos;s on 1.8.0 and there&apos;s no files included</z><z id="t1507323596" t="gdeer81 @nathanmarz (let [my-vec ^{:author &quot;Gary&quot;} [1 2 3]] (meta (select ALL-WITH-META my-vec))) returns nil , am I doing something wrong or is this a bug?"><y>#</y><d>2017-10-06</d><h>20:59</h><w>gdeer81</w>@nathanmarz <code>(let [my-vec ^{:author &quot;Gary&quot;} [1 2 3]] (meta (select ALL-WITH-META my-vec)))</code> returns nil , am I doing something wrong or is this a bug?</z><z id="t1507326363" t="michaelwfogleman @gdeer81 @nathanmarz I took a look, it looks like meta is preserved with a transform but not with the select implementation, you can see it in the code too"><y>#</y><d>2017-10-06</d><h>21:46</h><w>michaelwfogleman</w>@gdeer81 @nathanmarz I took a look, it looks like meta is preserved with a transform but not with the select implementation, you can see it in the code too</z><z id="t1507326372" t="michaelwfogleman (let [my-num ^{:author &quot;Gary&quot;} [1]] (meta (transform ALL-WITH-META inc my-num)))"><y>#</y><d>2017-10-06</d><h>21:46</h><w>michaelwfogleman</w>(let [my-num ^{:author &quot;Gary&quot;} [1]] (meta (transform ALL-WITH-META inc my-num)))</z><z id="t1507326383" t="michaelwfogleman (defnav ^{:doc &quot;Same as ALL, except maintains metadata on the structure.&quot;} ALL-WITH-META [] (select* [this structure next-fn] (n/all-select structure next-fn)) (transform* [this structure next-fn] (let [m (meta structure) res (n/all-transform structure next-fn)] (if (some? res) (with-meta res m) ))))"><y>#</y><d>2017-10-06</d><h>21:46</h><w>michaelwfogleman</w>(defnav
  ^{:doc &quot;Same as ALL, except maintains metadata on the structure.&quot;}
  ALL-WITH-META
  []
  (select* [this structure next-fn]
    (n/all-select structure next-fn))
  (transform* [this structure next-fn]
    (let [m (meta structure)
          res (n/all-transform structure next-fn)]
      (if (some? res)
        (with-meta res m)
        ))))</z><z id="t1507326414" t="michaelwfogleman I think I can file a patch 🙂"><y>#</y><d>2017-10-06</d><h>21:46</h><w>michaelwfogleman</w>I think I can file a patch <b>🙂</b></z><z id="t1507326484" t="nathanmarz there&apos;s no metadata to maintain on select, since it navigates into the subvalues"><y>#</y><d>2017-10-06</d><h>21:48</h><w>nathanmarz</w>there&apos;s no metadata to maintain on select, since it navigates into the subvalues</z><z id="t1507326514" t="nathanmarz that nav purely exists for transforms, especially for codewalker"><y>#</y><d>2017-10-06</d><h>21:48</h><w>nathanmarz</w>that nav purely exists for transforms, especially for <code>codewalker</code></z><z id="t1507326804" t="michaelwfogleman @nathanmarz Ah, looks like this one isn&apos;t in the docs either, I&apos;ll submit a pr for it"><y>#</y><d>2017-10-06</d><h>21:53</h><w>michaelwfogleman</w>@nathanmarz Ah, looks like this one isn&apos;t in the docs either, I&apos;ll submit a pr for it</z><z id="t1507327266" t="gdeer81 I&apos;m going to stick to creating koans for the things documented in the wiki until I&apos;m more attuned with the code"><y>#</y><d>2017-10-06</d><h>22:01</h><w>gdeer81</w>I&apos;m going to stick to creating koans for the things documented in the wiki until I&apos;m more attuned with the code</z><z id="t1507329604" t="michaelwfogleman Sent in a PR, and a few related to a new issue I opened about undocumented vars: https://github.com/nathanmarz/specter-wiki/issues/17"><y>#</y><d>2017-10-06</d><h>22:40</h><w>michaelwfogleman</w>Sent in a PR, and a few related to a new issue I opened about undocumented vars: <a href="https://github.com/nathanmarz/specter-wiki/issues/17" target="_blank">https://github.com/nathanmarz/specter-wiki/issues/17</a></z><z id="t1507331650" t="james Hi everyone, I made a screencast to introduce Specter to newcomers: https://www.youtube.com/watch?v=rh5J4vacG98"><y>#</y><d>2017-10-06</d><h>23:14</h><w>james</w>Hi everyone, I made a screencast to introduce Specter to newcomers: <a href="https://www.youtube.com/watch?v=rh5J4vacG98" target="_blank">https://www.youtube.com/watch?v=rh5J4vacG98</a></z><z id="t1507333117" t="michaelwfogleman I&apos;ve watched a bunch of your older videos, awesome to see one on Specter! Keep them coming! 🙂"><y>#</y><d>2017-10-06</d><h>23:38</h><r>michaelwfogleman</r>I&apos;ve watched a bunch of your older videos, awesome to see one on Specter! Keep them coming! <b>🙂</b></z><z id="t1507343311" t="drewverlee This is awesome"><y>#</y><d>2017-10-07</d><h>02:28</h><r>drewverlee</r>This is awesome</z><z id="t1507343293" t="gdeer81 ha, I love when I find holes in my understanding of how the code works. my new obsession is INDEXED-VALS on its own as a select it totally makes sense, but change it to a transform and compose it with another navigator and you blow my cognitive budget. I thought this code was going to return the collection unchanged (setval [INDEXED-VALS FIRST] 0 [1 2 3]) but to achieve that result you have to pass it length - 1 instead of 0"><y>#</y><d>2017-10-07</d><h>02:28</h><w>gdeer81</w>ha, I love when I find holes in my understanding of how the code works. my new obsession is <code>INDEXED-VALS</code> on its own as a select it totally makes sense, but change it to a transform and compose it with another navigator and you blow my cognitive budget. I thought this code was going to return the collection unchanged <code>(setval [INDEXED-VALS FIRST] 0 [1 2 3])</code> but to achieve that result you have to pass it length - 1 instead of 0</z><z id="t1507344199" t="drewverlee So, i’m sure this has come up before. But i can’t find any discussion on it. Possible because its a nonsense idea. But isn’t HTML a deeply nested structure? Couldn’t Specter be used to manipulate it? Actual, come to think of it, is there any overlap in concept to something like jquery?"><y>#</y><d>2017-10-07</d><h>02:43</h><w>drewverlee</w>So, i’m sure this has come up before. But i can’t find any discussion on it. Possible because its a nonsense idea. But isn’t HTML a deeply nested structure? Couldn’t Specter be used to manipulate it? Actual, come to think of it, is there any overlap in concept to something like jquery?</z><z id="t1507344324" t="drewverlee Also is there a way to just navigate to something based not on the path but based off some predicate? like any map with the key :foo"><y>#</y><d>2017-10-07</d><h>02:45</h><w>drewverlee</w>Also is there a way to just navigate to something based not on the path but based off some predicate? like any map with the key :foo</z><z id="t1507344362" t="drewverlee um, yea. its called walker"><y>#</y><d>2017-10-07</d><h>02:46</h><w>drewverlee</w>um, yea. its called walker</z><z id="t1507345082" t="gdeer81 I just realized that (setval [INDEXED-VALS FIRST] 0 [1 2 3]) actually reverses the collection"><y>#</y><d>2017-10-07</d><h>02:58</h><w>gdeer81</w>I just realized that <code>(setval [INDEXED-VALS FIRST] 0 [1 2 3])</code> actually reverses the collection</z><z id="t1507345420" t="gdeer81 well anyway, I&apos;m going to put it in as a koan so it will be interesting to see how many people come to the channel to ask about this one ha"><y>#</y><d>2017-10-07</d><h>03:03</h><w>gdeer81</w>well anyway, I&apos;m going to put it in as a koan so it will be interesting to see how many people come to the channel to ask about this one ha</z><z id="t1507401525" t="nathanmarz @james Great screencast! I&apos;ll add it as a link to the readme"><y>#</y><d>2017-10-07</d><h>18:38</h><w>nathanmarz</w>@james Great screencast! I&apos;ll add it as a link to the readme</z><z id="t1507401628" t="nathanmarz @drewverlee yea, Specter is perfect for manipulating HTML"><y>#</y><d>2017-10-07</d><h>18:40</h><w>nathanmarz</w>@drewverlee yea, Specter is perfect for manipulating HTML</z><z id="t1507401659" t="nathanmarz it would be easy to make compound navigators to re-create the various query capabilities of jquery"><y>#</y><d>2017-10-07</d><h>18:40</h><w>nathanmarz</w>it would be easy to make compound navigators to re-create the various query capabilities of jquery</z><z id="t1507416160" t="james @nathanmarz Thanks!"><y>#</y><d>2017-10-07</d><h>22:42</h><w>james</w>@nathanmarz Thanks!</z><z id="t1507533010" t="hkjels @james really good introduction! Thank you"><y>#</y><d>2017-10-09</d><h>07:10</h><w>hkjels</w>@james really good introduction! Thank you</z><z id="t1507533131" t="hkjels are you by any chance going to make one on how to use Specter recursively as well 😆"><y>#</y><d>2017-10-09</d><h>07:12</h><w>hkjels</w>are you by any chance going to make one on how to use Specter recursively as well <b>😆</b></z><z id="t1507533209" t="schmee @hkjels I know it’s not a screencast, but have you seen https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively ?"><y>#</y><d>2017-10-09</d><h>07:13</h><w>schmee</w>@hkjels I know it’s not a screencast, but have you seen <a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively" target="_blank">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively</a>?</z><z id="t1507533266" t="hkjels yeah. It’s just not as easy to take in as a screencast when I have to kids running around"><y>#</y><d>2017-10-09</d><h>07:14</h><w>hkjels</w>yeah. It’s just not as easy to take in as a screencast when I have to kids running around</z><z id="t1507546129" t="hkjels I’ve come to a point where I’m trying things at random 😡"><y>#</y><d>2017-10-09</d><h>10:48</h><w>hkjels</w>I’ve come to a point where I’m trying things at random  <b>😡</b></z><z id="t1507547734" t="hkjels I’d really appreciate it if someone could explain what I’m doing wrong here: https://gist.github.com/hkjels/2bad9d432eb77c68e5dc31dc5df9f63f"><y>#</y><d>2017-10-09</d><h>11:15</h><w>hkjels</w>I’d really appreciate it if someone could explain what I’m doing wrong here:
<a href="https://gist.github.com/hkjels/2bad9d432eb77c68e5dc31dc5df9f63f" target="_blank">https://gist.github.com/hkjels/2bad9d432eb77c68e5dc31dc5df9f63f</a></z><z id="t1507556835" t="schmee @hkjels I’m not sure exactly what’s wrong but one thing is that you are not using your recursive path (`p`) anywhere"><y>#</y><d>2017-10-09</d><h>13:47</h><w>schmee</w>@hkjels I’m not sure exactly what’s wrong but one thing is that you are not using your recursive path (`p`) anywhere</z><z id="t1507557723" t="hkjels OK. I need to have another look at the docs"><y>#</y><d>2017-10-09</d><h>14:02</h><w>hkjels</w>OK. I need to have another look at the docs</z><z id="t1507574341" t="michaelwfogleman @hjkels Tried to take a look but I&apos;m not sure exactly what you want - it might help to write a test to validate the output"><y>#</y><d>2017-10-09</d><h>18:39</h><w>michaelwfogleman</w>@hjkels Tried to take a look but I&apos;m not sure exactly what you want - it might help to write a test to validate the output</z><z id="t1507605854" t="gdeer81 parinfer is a blessing and a curse"><y>#</y><d>2017-10-10</d><h>03:24</h><w>gdeer81</w>parinfer is a blessing and a curse</z><z id="t1507609326" t="gdeer81 latest version of the koans are up with all unparameterized and parameterized navigators covered"><y>#</y><d>2017-10-10</d><h>04:22</h><w>gdeer81</w>latest version of the koans are up with all unparameterized and parameterized navigators covered</z><z id="t1507647916" t="gdeer81 next step is covering the rest of the core macros in depth. I had a real chicken and egg problem when deciding how to organize the koans. it&apos;s like do I say &quot;look at select [ALL] ignore what ALL means, but here&apos;s what select returns vs select-one or do I say look what [ALL] does, it does something different if used with select setval and transform but just know that no matter what you&apos;re doing, it gives you all the things&quot;"><y>#</y><d>2017-10-10</d><h>15:05</h><w>gdeer81</w>next step is covering the rest of the core macros in depth. I had a real chicken and egg problem when deciding how to organize the koans. it&apos;s like do I say &quot;look at <code>select [ALL]</code> ignore what <code>ALL</code> means, but here&apos;s what <code>select</code> returns vs <code>select-one</code> or do I say look what <code>[ALL]</code> does, it does something different if used with <code>select</code> <code>setval</code> and <code>transform</code> but just know that no matter what you&apos;re doing, it gives you all the things&quot;</z><z id="t1507650913" t="nathanmarz @gdeer81 in my mind I find the easiest mental model is distinguishing between subvalue, substructure, filter, and view navigators"><y>#</y><d>2017-10-10</d><h>15:55</h><w>nathanmarz</w>@gdeer81 in my mind I find the easiest mental model is distinguishing between subvalue, substructure, filter, and view navigators</z><z id="t1507650953" t="nathanmarz subvalue navs I just imagine as taking me to subvalues of a data structure, and the operation (e.g. select, transform) just says what to do when I get there"><y>#</y><d>2017-10-10</d><h>15:55</h><w>nathanmarz</w>subvalue navs I just imagine as taking me to subvalues of a data structure, and the operation (e.g. select, transform) just says what to do when I get there</z><z id="t1507651035" t="nathanmarz one example that would be good for the koans to illustrate what an operation does is (select-any ALL data)"><y>#</y><d>2017-10-10</d><h>15:57</h><w>nathanmarz</w>one example that would be good for the koans to illustrate what an operation does is <code>(select-any ALL data)</code></z><z id="t1507651354" t="gdeer81 @nathanmarz like this? https://github.com/gdeer81/specter-koans/blob/55686414f70c8ba739c84bafffb88173b7ee9f9d/src/koans/01_selection.clj#L50"><y>#</y><d>2017-10-10</d><h>16:02</h><w>gdeer81</w>@nathanmarz like this? <a href="https://github.com/gdeer81/specter-koans/blob/55686414f70c8ba739c84bafffb88173b7ee9f9d/src/koans/01_selection.clj#L50" target="_blank">https://github.com/gdeer81/specter-koans/blob/55686414f70c8ba739c84bafffb88173b7ee9f9d/src/koans/01_selection.clj#L50</a></z><z id="t1507651627" t="gdeer81 After watching @james screencast I think you&apos;re right, the first thing that needs to be discussed is the concept of subvalues, substructures, filters, and views"><y>#</y><d>2017-10-10</d><h>16:07</h><w>gdeer81</w>After watching @james screencast I think you&apos;re right, the first thing that needs to be discussed is the concept of subvalues, substructures, filters, and views</z><z id="t1507651742" t="gdeer81 in koan 1 I kept running into it when illustrating navigation but never made it a first class concept"><y>#</y><d>2017-10-10</d><h>16:09</h><w>gdeer81</w>in koan 1 I kept running into it when illustrating navigation but never made it a first class concept</z><z id="t1507651801" t="nathanmarz ah yea, that&apos;s good"><y>#</y><d>2017-10-10</d><h>16:10</h><w>nathanmarz</w>ah yea, that&apos;s good</z><z id="t1507651840" t="nathanmarz a series with select-any , select-first , select-one , and select-one! to show the subtle differences would be good too"><y>#</y><d>2017-10-10</d><h>16:10</h><w>nathanmarz</w>a series with <code>select-any</code>, <code>select-first</code>, <code>select-one</code>, and <code>select-one!</code> to show the subtle differences would be good too</z><z id="t1507651996" t="gdeer81 Yeah, I think I can flesh out the rest of koan 1 to operate on the same data structure, the trick is finding one that&apos;s complex enough to be interesting but not so unwieldy that it ruins the learning experience"><y>#</y><d>2017-10-10</d><h>16:13</h><w>gdeer81</w>Yeah, I think I can flesh out the rest of koan 1 to operate on the same data structure, the trick is finding one that&apos;s complex enough to be interesting but not so unwieldy that it ruins the learning experience</z><z id="t1507652104" t="gdeer81 I&apos;ve started mining github for examples by searching for repos where people have hand-written map-vals"><y>#</y><d>2017-10-10</d><h>16:15</h><w>gdeer81</w>I&apos;ve started mining github for examples by searching for repos where people have hand-written <code>map-vals</code></z><z id="t1507652351" t="gdeer81 another one people seem to grok easily is product data. even ones with complex hierarchies"><y>#</y><d>2017-10-10</d><h>16:19</h><w>gdeer81</w>another one people seem to grok easily is product data. even ones with complex hierarchies</z><z id="t1507652384" t="nathanmarz I would start simple before getting to anything too compound"><y>#</y><d>2017-10-10</d><h>16:19</h><w>nathanmarz</w>I would start simple before getting to anything too compound</z><z id="t1507652425" t="gdeer81 okay, I&apos;ll save it for the advanced koans then"><y>#</y><d>2017-10-10</d><h>16:20</h><w>gdeer81</w>okay, I&apos;ll save it for the advanced koans then</z><z id="t1507652445" t="nathanmarz if you want to make &quot;challenge koans&quot; towards the end, paths that require subselect are usually pretty challenging"><y>#</y><d>2017-10-10</d><h>16:20</h><w>nathanmarz</w>if you want to make &quot;challenge koans&quot; towards the end, paths that require <code>subselect</code> are usually pretty challenging</z><z id="t1507652865" t="gdeer81 yeah, when I did the parameterized navigators koan and I got to subselect, I just copied and pasted the example from the wiki"><y>#</y><d>2017-10-10</d><h>16:27</h><w>gdeer81</w>yeah, when I did the parameterized navigators koan and I got to subselect, I just copied and pasted the example from the wiki</z><z id="t1507652895" t="gdeer81 it hurt my brain trying to think of a practical example that would work"><y>#</y><d>2017-10-10</d><h>16:28</h><w>gdeer81</w>it hurt my brain trying to think of a practical example that would work</z><z id="t1507662961" t="gdeer81 after playing with subselect a bit I&apos;m starting to get it. basically for transforms you want to use a function that takes a collection and returns a collection. a lot of these seem tricky in isolation but once you start understanding when you would use them, they become more intuitive"><y>#</y><d>2017-10-10</d><h>19:16</h><w>gdeer81</w>after playing with <code>subselect</code> a bit I&apos;m starting to get it. basically for transforms you want to use a function that takes a collection and returns a collection. a lot of these seem tricky in isolation but once you start understanding when you would use them, they become more intuitive</z><z id="t1507669073" t="gdeer81 my next endeavor is using specter with reframe. most reframe events have pretty small effects like &quot;add this string to the todos vector&quot; but someone once said that you don&apos;t need to have a deeply nested data structure to get the benefits of specter. so if anything I will get to play around with visualizing specter transformations with refrisk"><y>#</y><d>2017-10-10</d><h>20:57</h><w>gdeer81</w>my next endeavor is using specter with reframe.  most reframe events have pretty small effects like &quot;add this string to the todos vector&quot; but someone once said that you don&apos;t need to have a deeply nested data structure to get the benefits of specter. so if anything I will get to play around with visualizing specter transformations with refrisk</z><z id="t1507670513" t="nathanmarz @gdeer81 a visualizer of navigation would be a tremendous addition to the project"><y>#</y><d>2017-10-10</d><h>21:21</h><w>nathanmarz</w>@gdeer81 a visualizer of navigation would be a tremendous addition to the project</z><z id="t1507670523" t="nathanmarz I think that would really help people get over the learning curve"><y>#</y><d>2017-10-10</d><h>21:22</h><w>nathanmarz</w>I think that would really help people get over the learning curve</z><z id="t1507673531" t="gdeer81 awesome I was able to get reframe events and subscriptions to use specter but refrisk doesn&apos;t show enough detail to visualize the transformation. Back to the drawing board"><y>#</y><d>2017-10-10</d><h>22:12</h><w>gdeer81</w>awesome I was able to get reframe events and subscriptions to use specter but refrisk doesn&apos;t show enough detail to visualize the transformation. Back to the drawing board</z><z id="t1507673732" t="gdeer81 I am pretty happy I got specter working with re-frame, even though I&apos;m doing anything mind blowing (reg-sub :counter (fn [db _] (specter/select-any [:counter] db))) gets the current count of the counter and (reg-event-db :inc-counter (fn [db _] (specter/transform [:counter] inc db)) increases the counter this is wired up to a div subscribed to the count and a button to dispatch the :inc-counter event"><y>#</y><d>2017-10-10</d><h>22:15</h><w>gdeer81</w>I am pretty happy I got specter working with re-frame, even though I&apos;m doing anything mind blowing <code>(reg-sub :counter  (fn [db _] (specter/select-any [:counter] db)))</code> gets the current count of the counter and <code>(reg-event-db :inc-counter (fn [db _] (specter/transform [:counter] inc db))</code> increases the counter this is wired up to a div subscribed to the count and a button to dispatch the :inc-counter event</z><z id="t1507674044" t="gdeer81 and of course the db is just {counter 0} but I wanted to get it working before I went too crazy with the nesting"><y>#</y><d>2017-10-10</d><h>22:20</h><w>gdeer81</w>and of course the db is just <code>{counter 0}</code> but I wanted to get it working before I went too crazy with the nesting</z><z id="t1507674221" t="gdeer81 tonight I&apos;ll explore the re-frame library that gives you undo capabilities since that will probably keep track of before/after app db state which would be helpful with the visualization"><y>#</y><d>2017-10-10</d><h>22:23</h><w>gdeer81</w>tonight I&apos;ll explore the re-frame library that gives you undo capabilities since that will probably keep track of before/after app db state which would be helpful with the visualization</z><z id="t1507678073" t="michaelwfogleman @nathanmarz Venturing into the code with an initial commit of a regex navigator - I just have select working - might need an assist with the transform implementation"><y>#</y><d>2017-10-10</d><h>23:27</h><w>michaelwfogleman</w>@nathanmarz Venturing into the code with an initial commit of a regex navigator  - I just have select working - might need an assist with the transform implementation</z><z id="t1507679538" t="nathanmarz @michaelwfogleman a regex can match many substrings, so your implementation doesn&apos;t look right"><y>#</y><d>2017-10-10</d><h>23:52</h><w>nathanmarz</w>@michaelwfogleman a regex can match many substrings, so your implementation doesn&apos;t look right</z><z id="t1507679636" t="nathanmarz I&apos;m not sure what replacement facilities are available in the regex api"><y>#</y><d>2017-10-10</d><h>23:53</h><w>nathanmarz</w>I&apos;m not sure what replacement facilities are available in the regex api</z><z id="t1507711260" t="hkjels I’m starting to get a feel for recursive-path now, but I don’t see how I can solve my problem with it. I want to pluck all the parents of a particular map based on a predicate for that map. The way I see it, I’ll either have to start the search from the leaves of my tree or remove branches as it goes. The latter would require that I keep track of my tree with some local-state, so it doesn’t seem idiomatic to specter?"><y>#</y><d>2017-10-11</d><h>08:41</h><w>hkjels</w>I’m starting to get a feel for <code>recursive-path</code> now, but I don’t see how I can solve my problem with it.
I want to pluck all the parents of a particular map based on a predicate for that map.
The way I see it, I’ll either have to start the search from the leaves of my tree or remove branches as it goes.
The latter would require that I keep track of my tree with some local-state, so it doesn’t seem idiomatic to specter?</z><z id="t1507711455" t="hkjels https://gist.github.com/hkjels/2bad9d432eb77c68e5dc31dc5df9f63f"><y>#</y><d>2017-10-11</d><h>08:44</h><w>hkjels</w><a href="https://gist.github.com/hkjels/2bad9d432eb77c68e5dc31dc5df9f63f" target="_blank">https://gist.github.com/hkjels/2bad9d432eb77c68e5dc31dc5df9f63f</a></z><z id="t1507711503" t="hkjels This current solution will select the correct maps, but if I try to collect the previous result, that will happen for “bar” as well"><y>#</y><d>2017-10-11</d><h>08:45</h><w>hkjels</w>This current solution will select the correct maps, but if I try to collect the previous result, that will happen for “bar” as well</z><z id="t1507720198" t="hkjels Almost at a solution now"><y>#</y><d>2017-10-11</d><h>11:09</h><w>hkjels</w>Almost at a solution now</z><z id="t1507720301" t="hkjels Can I do a transformation from within a recursive-path macro"><y>#</y><d>2017-10-11</d><h>11:11</h><w>hkjels</w>Can I do a transformation from within a recursive-path macro</z><z id="t1507720313" t="hkjels is that frowned upon?"><y>#</y><d>2017-10-11</d><h>11:11</h><w>hkjels</w>is that frowned upon?</z><z id="t1507735913" t="nathanmarz @hkjels not entitely clear on what you&apos;re trying to do. Are you just trying to remove the children of all nodes matching a certain name?"><y>#</y><d>2017-10-11</d><h>15:31</h><w>nathanmarz</w>@hkjels not entitely clear on what you&apos;re trying to do. Are you just trying to remove the children of all nodes matching a certain name?</z><z id="t1507738008" t="hkjels @nathanmarz I’m trying to retrieve all the parent nodes of nodes where the predicate is true and leave out all the children"><y>#</y><d>2017-10-11</d><h>16:06</h><w>hkjels</w>@nathanmarz I’m trying to retrieve all the parent nodes of nodes where the predicate is true and leave out all the children</z><z id="t1507738041" t="hkjels of those nodes"><y>#</y><d>2017-10-11</d><h>16:07</h><w>hkjels</w>of those nodes</z><z id="t1507738298" t="nathanmarz @hkjels so in this case you want to navigate to the parents of nodes with name &quot;qux&quot;?"><y>#</y><d>2017-10-11</d><h>16:11</h><w>nathanmarz</w>@hkjels so in this case you want to navigate to the parents of nodes with name &quot;qux&quot;?</z><z id="t1507738383" t="hkjels yeah"><y>#</y><d>2017-10-11</d><h>16:13</h><w>hkjels</w>yeah</z><z id="t1507738549" t="nathanmarz looks like this: (def data {:name &quot;foo&quot; :children [{:name &quot;bar&quot; :children []} {:name &quot;baz&quot; :children [{:name &quot;qux&quot; :children [{:name &quot;NO!&quot; :children []}]}]} {:name &quot;hello&quot; :children [{:name &quot;world&quot; :children [{:name &quot;qux&quot; :children [{:name &quot;NO!&quot; :children []}]}]}]}]}) (def NODES (recursive-path [] p (continue-then-stay :children ALL p))) (defn nodes-with-child [name] (path NODES (selected? :children ALL :name (pred= name))) ) (select (nodes-with-child &quot;qux&quot;) data) "><y>#</y><d>2017-10-11</d><h>16:15</h><w>nathanmarz</w>looks like this:
<pre>(def data
  {:name &quot;foo&quot;
   :children
   [{:name &quot;bar&quot;
     :children []}
    {:name &quot;baz&quot;
     :children
     [{:name &quot;qux&quot;
       :children
       [{:name &quot;NO!&quot;
         :children
         []}]}]}
    {:name &quot;hello&quot;
     :children
     [{:name &quot;world&quot;
       :children
       [{:name &quot;qux&quot;
         :children
         [{:name &quot;NO!&quot;
           :children
           []}]}]}]}]})

(def NODES
  (recursive-path [] p
    (continue-then-stay :children ALL p)))

(defn nodes-with-child [name]
  (path NODES (selected? :children ALL :name (pred= name)))
  )

(select (nodes-with-child &quot;qux&quot;) data)
</pre></z><z id="t1507738575" t="nathanmarz easiest way to do a recursive navigation is first make a path that navigates to every node, then do whatever filtering you need on top of that"><y>#</y><d>2017-10-11</d><h>16:16</h><w>nathanmarz</w>easiest way to do a recursive navigation is first make a path that navigates to every node, then do whatever filtering you need on top of that</z><z id="t1507739216" t="hkjels Nice tip! There’s still the issue where children of the selected node is in the structure"><y>#</y><d>2017-10-11</d><h>16:26</h><w>hkjels</w>Nice tip!
There’s still the issue where children of the selected node is in the structure</z><z id="t1507739347" t="nathanmarz if you want the results without children then specify that in your selection"><y>#</y><d>2017-10-11</d><h>16:29</h><w>nathanmarz</w>if you want the results without children then specify that in your selection</z><z id="t1507739394" t="nathanmarz (select [(nodes-with-child &quot;qux&quot;) (transformed :children (constantly NONE))] data)"><y>#</y><d>2017-10-11</d><h>16:29</h><w>nathanmarz</w><code>(select [(nodes-with-child &quot;qux&quot;) (transformed :children (constantly NONE))] data)</code></z><z id="t1507746888" t="hkjels That short-circuits the walk on the node prior to the one where the predicate is true"><y>#</y><d>2017-10-11</d><h>18:34</h><r>hkjels</r>That short-circuits the walk on the node prior to the one where the predicate is true</z><z id="t1507740431" t="Chris Dewar-English I want to cherry-pick a set of values from different parts of a nested structure. Is that a reasonable thing to try to do with Specter?"><y>#</y><d>2017-10-11</d><h>16:47</h><w>Chris Dewar-English</w>I want to cherry-pick a set of values from different parts of a nested structure.  Is that a reasonable thing to try to do with Specter?</z><z id="t1507740530" t="nathanmarz yes"><y>#</y><d>2017-10-11</d><h>16:48</h><w>nathanmarz</w>yes</z><z id="t1507740687" t="Chris Dewar-English I currently use get-in and map over the keywords to get to each value. It works fine, but what is the principle behind doing that with specter?"><y>#</y><d>2017-10-11</d><h>16:51</h><w>Chris Dewar-English</w>I currently use <code>get-in</code> and map over the keywords to get to each value.  It works fine, but what is the principle behind doing that with specter?</z><z id="t1507740807" t="Chris Dewar-English In this sample dataset https://pastebin.com/MgtqLCXg"><y>#</y><d>2017-10-11</d><h>16:53</h><w>Chris Dewar-English</w>In this sample dataset <a href="https://pastebin.com/MgtqLCXg" target="_blank">https://pastebin.com/MgtqLCXg</a></z><z id="t1507740876" t="nathanmarz if you want to get all the summaries, it&apos;s (select [(keypath &quot;issues&quot;) ALL (keypath &quot;fields&quot; &quot;summary&quot;)] data)"><y>#</y><d>2017-10-11</d><h>16:54</h><w>nathanmarz</w>if you want to get all the summaries, it&apos;s <code>(select [(keypath &quot;issues&quot;) ALL (keypath &quot;fields&quot; &quot;summary&quot;)] data)</code></z><z id="t1507740948" t="Chris Dewar-English I would like to pull multiple values, i.e. from issues/id, issues/key, issues/fields/summary, issues/fields/project/name"><y>#</y><d>2017-10-11</d><h>16:55</h><w>Chris Dewar-English</w>I would like to pull multiple values, i.e. from issues/id, issues/key, issues/fields/summary, issues/fields/project/name</z><z id="t1507740977" t="Chris Dewar-English I&apos;m not sure all those selects make sense in a single navigator do they?"><y>#</y><d>2017-10-11</d><h>16:56</h><w>Chris Dewar-English</w>I&apos;m not sure all those selects make sense in a single navigator do they?</z><z id="t1507740981" t="nathanmarz how do you want the results structured?"><y>#</y><d>2017-10-11</d><h>16:56</h><w>nathanmarz</w>how do you want the results structured?</z><z id="t1507741025" t="Chris Dewar-English I&apos;m essentially trying to flatten the JSON data into CSV."><y>#</y><d>2017-10-11</d><h>16:57</h><w>Chris Dewar-English</w>I&apos;m essentially trying to flatten the JSON data into CSV.</z><z id="t1507741060" t="Chris Dewar-English And cherry-pick just the values I need."><y>#</y><d>2017-10-11</d><h>16:57</h><w>Chris Dewar-English</w>And cherry-pick just the values I need.</z><z id="t1507741079" t="nathanmarz (select [(keypath &quot;issues&quot;) ALL (collect-one (keypath &quot;id&quot;)) (keypath &quot;fields&quot;) (collect-one (keypath &quot;summary&quot;)) (keypath &quot;project&quot; &quot;name&quot;)] data)"><y>#</y><d>2017-10-11</d><h>16:57</h><w>nathanmarz</w><code>(select [(keypath &quot;issues&quot;) ALL (collect-one (keypath &quot;id&quot;)) (keypath &quot;fields&quot;) (collect-one (keypath &quot;summary&quot;)) (keypath &quot;project&quot; &quot;name&quot;)] data)</code></z><z id="t1507741107" t="nathanmarz that will get everything you need as a vector in that order"><y>#</y><d>2017-10-11</d><h>16:58</h><w>nathanmarz</w>that will get everything you need as a vector in that order</z><z id="t1507741123" t="Chris Dewar-English Ok, so drill down to the end element, but collect the values as you go?"><y>#</y><d>2017-10-11</d><h>16:58</h><w>Chris Dewar-English</w>Ok, so drill down to the end element, but collect the values as you go?</z><z id="t1507741158" t="nathanmarz yes"><y>#</y><d>2017-10-11</d><h>16:59</h><w>nathanmarz</w>yes</z><z id="t1507741184" t="nathanmarz if you&apos;re doing a lot of navigation by string keys, it may be worth creating an implicit navigator for strings as is done for keywords https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1161"><y>#</y><d>2017-10-11</d><h>16:59</h><w>nathanmarz</w>if you&apos;re doing a lot of navigation by string keys, it may be worth creating an implicit navigator for strings as is done for keywords <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1161" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1161</a></z><z id="t1507741202" t="nathanmarz then you can write (select [&quot;issues&quot; ALL (collect-one &quot;id&quot;) ..."><y>#</y><d>2017-10-11</d><h>17:00</h><w>nathanmarz</w>then you can write <code>(select [&quot;issues&quot; ALL (collect-one &quot;id&quot;) ...</code></z><z id="t1507741252" t="Chris Dewar-English That part is ok, the string keys are turned into keywords using Cheshire when it parses"><y>#</y><d>2017-10-11</d><h>17:00</h><w>Chris Dewar-English</w>That part is ok, the string keys are turned into keywords using Cheshire when it parses</z><z id="t1507741291" t="Chris Dewar-English Regarding using collect... I&apos;ve just assumed collect-one was only applicable when doing a transform. I didn&apos;t realise it would just contain the final elements!"><y>#</y><d>2017-10-11</d><h>17:01</h><w>Chris Dewar-English</w>Regarding using <code>collect...</code> I&apos;ve just assumed <code>collect-one</code> was only applicable when doing a transform. I didn&apos;t realise it would just contain the final elements!</z><z id="t1507741313" t="nathanmarz yep, that&apos;s the only behavior that makes sense for select codepath"><y>#</y><d>2017-10-11</d><h>17:01</h><w>nathanmarz</w>yep, that&apos;s the only behavior that makes sense for <code>select</code> codepath</z><z id="t1507741364" t="Chris Dewar-English Good stuff. Thank you, Nathan."><y>#</y><d>2017-10-11</d><h>17:02</h><w>Chris Dewar-English</w>Good stuff. Thank you, Nathan.</z><z id="t1507755978" t="gdeer81 okay, I think I&apos;ve found an interesting data structure for learning; koan 4 will be about writing transformations to facilitate a space-shooter game. this makes the examples like this easier to read (transform [ALL (collect-one :velocity) #(:enemy? %) :y] (fn [velocity current-y] (* velocity current-y)) entities)"><y>#</y><d>2017-10-11</d><h>21:06</h><w>gdeer81</w>okay, I think I&apos;ve found an interesting data structure for learning; koan 4 will be about writing transformations to facilitate a space-shooter game. this makes the examples like this easier to read <code>(transform [ALL (collect-one :velocity) #(:enemy? %) :y] (fn [velocity current-y] (* velocity current-y)) entities)</code></z><z id="t1507756193" t="gdeer81 this transformation obviously takes all the entity maps and updates every enemy&apos;s y coordinate by its velocity"><y>#</y><d>2017-10-11</d><h>21:09</h><w>gdeer81</w>this transformation obviously takes all the entity maps and updates every enemy&apos;s y coordinate by its velocity</z><z id="t1507756356" t="gdeer81 that can process about 5k maps in sub-miliseconds (caveat: i&apos;m using time as my micro-benchmark tool)"><y>#</y><d>2017-10-11</d><h>21:12</h><w>gdeer81</w>that can process about 5k maps in sub-miliseconds (caveat: i&apos;m using <code>time</code> as my micro-benchmark tool)</z><z id="t1507760430" t="nathanmarz @gdeer81 cool, that sounds nice and tangible"><y>#</y><d>2017-10-11</d><h>22:20</h><w>nathanmarz</w>@gdeer81 cool, that sounds nice and tangible</z><z id="t1507761381" t="gdeer81 differences in decisions about how you want to manipulate the game objects easily illustrate subtle differences in navigations"><y>#</y><d>2017-10-11</d><h>22:36</h><w>gdeer81</w>differences in decisions about how you want to manipulate the game objects easily illustrate subtle differences in navigations</z><z id="t1507762103" t="michaelwfogleman @nathanmarz: Perhaps what you are thinking of is using re-seq? (re-seq #&quot;.&quot; &quot;abc&quot;) (&quot;a&quot; &quot;b&quot; &quot;c&quot;)"><y>#</y><d>2017-10-11</d><h>22:48</h><w>michaelwfogleman</w>@nathanmarz: Perhaps what you are thinking of is using re-seq? (re-seq #&quot;.&quot;  &quot;abc&quot;)
(&quot;a&quot; &quot;b&quot; &quot;c&quot;)</z><z id="t1507762115" t="michaelwfogleman (re-seq #&quot;abc+&quot; &quot;abc&quot;) (&quot;abc&quot;)"><y>#</y><d>2017-10-11</d><h>22:48</h><w>michaelwfogleman</w>(re-seq #&quot;abc+&quot;  &quot;abc&quot;)
(&quot;abc&quot;)</z><z id="t1507762566" t="nathanmarz @michaelwfogleman yea, that looks right"><y>#</y><d>2017-10-11</d><h>22:56</h><w>nathanmarz</w>@michaelwfogleman yea, that looks right</z><z id="t1507762699" t="michaelwfogleman ok cool"><y>#</y><d>2017-10-11</d><h>22:58</h><w>michaelwfogleman</w>ok cool</z><z id="t1507762743" t="michaelwfogleman going to try and poke at the transform"><y>#</y><d>2017-10-11</d><h>22:59</h><w>michaelwfogleman</w>going to try and poke at the transform</z><z id="t1507774970" t="gdeer81 can you do transforms on records? I&apos;m getting an error that specter can&apos;t create an empty record"><y>#</y><d>2017-10-12</d><h>02:22</h><w>gdeer81</w>can you do transforms on records? I&apos;m getting an error that specter can&apos;t create an empty record</z><z id="t1507775535" t="gdeer81 oh no, I think I tried to get too clever"><y>#</y><d>2017-10-12</d><h>02:32</h><w>gdeer81</w>oh no, I think I tried to get too clever</z><z id="t1507915786" t="michaelwfogleman @nathanmarz Do you have a sense of a transform implementation that&apos;s similar to what needs to be done for the Regex navigator?"><y>#</y><d>2017-10-13</d><h>17:29</h><w>michaelwfogleman</w>@nathanmarz Do you have a sense of a transform implementation that&apos;s similar to what needs to be done for the Regex navigator?</z><z id="t1507916858" t="nathanmarz @michaelwfogleman no, the implementation will be fairly specific to that navigator"><y>#</y><d>2017-10-13</d><h>17:47</h><w>nathanmarz</w>@michaelwfogleman no, the implementation will be fairly specific to that navigator</z><z id="t1507916883" t="nathanmarz needs to run replace matching substrings with result of running next-fn on the substring"><y>#</y><d>2017-10-13</d><h>17:48</h><w>nathanmarz</w>needs to run replace matching substrings with result of running <code>next-fn</code> on the substring</z><z id="t1507917216" t="nathanmarz looks like Pattern/split and some of the functions in Matcher should be able to be used to implement it"><y>#</y><d>2017-10-13</d><h>17:53</h><w>nathanmarz</w>looks like <code>Pattern/split</code> and some of the functions in <code>Matcher</code> should be able to be used to implement it</z><z id="t1507918548" t="michaelwfogleman Makes sense, I&apos;ll look into it"><y>#</y><d>2017-10-13</d><h>18:15</h><w>michaelwfogleman</w>Makes sense, I&apos;ll look into it</z><z id="t1507948173" t="aisamu Hi! Is it possible to collect a value of every &quot;branch&quot; separately instead of all of them? I&apos;m trying to get all possible get-in path vectors for a given nested map (preferably excluding :root ): (magic {:root {:a {:b 1 :c 2} :d {:e 1 :f 2}}}) =&gt; [[:a :b] [:a :c] [:d :e] [:d :f]]` The best I could manage so far was this: (select [MAP-VALS (collect MAP-KEYS) MAP-VALS MAP-KEYS] {:root {:a {:b 1 :c 2} :d {:e 1 :f 2}}}) =&gt; [[[:a :d] :b] [[:a :d] :c] [[:a :d] :e] [[:a :d] :f]] ...which is almost there, but collect grabs all the branches&apos; values at every step. I could massage that second structure into what I need, but I suspect there is a nicer way of approaching this 🙂"><y>#</y><d>2017-10-14</d><h>02:29</h><w>aisamu</w>Hi!
Is it possible to <code>collect</code> a value of every &quot;branch&quot; separately instead of all of them?

I&apos;m trying to get all possible <code>get-in</code> path vectors for a given nested map (preferably excluding <code>:root</code>):
<pre>(magic {:root {:a {:b 1 :c 2} :d {:e 1 :f 2}}})
 =&gt; [[:a :b] [:a :c] [:d :e] [:d :f]]`
</pre>
The best I could manage so far was this:
<pre>(select [MAP-VALS (collect MAP-KEYS) MAP-VALS MAP-KEYS]
        {:root {:a {:b 1 :c 2} :d {:e 1 :f 2}}})
=&gt; [[[:a :d] :b] [[:a :d] :c] [[:a :d] :e] [[:a :d] :f]]
</pre>
...which is almost there, but <code>collect</code> grabs all the branches&apos; values at every step.
I could massage that second structure into what I need, but I suspect there is a nicer way of approaching this <b>🙂</b></z><z id="t1507999032" t="nathanmarz @aisamu it&apos;s like this: (def data {:root {:a {:b 1 :c 2} :d {:e 1 :f 2}}}) (select [:root ALL (collect-one FIRST) LAST MAP-KEYS] data) "><y>#</y><d>2017-10-14</d><h>16:37</h><w>nathanmarz</w>@aisamu it&apos;s like this:
<pre>(def data {:root {:a {:b 1 :c 2} :d {:e 1 :f 2}}})

(select [:root ALL (collect-one FIRST) LAST MAP-KEYS] data)
</pre></z><z id="t1507999118" t="nathanmarz if your data is recursive, this example is instructive for how to collect all the paths (which can be arbitrary/varying lengths): https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure"><y>#</y><d>2017-10-14</d><h>16:38</h><w>nathanmarz</w>if your data is recursive, this example is instructive for how to collect all the paths (which can be arbitrary/varying lengths): <a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure" target="_blank">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure</a></z><z id="t1508002080" t="aisamu Thanks! That makes a lot of sense!"><y>#</y><d>2017-10-14</d><h>17:28</h><w>aisamu</w>Thanks! That makes a lot of sense!</z><z id="t1508151626" t="hkjels Is it possible to start a search from a trees leaves? Or select the deepest nested match only?"><y>#</y><d>2017-10-16</d><h>11:00</h><w>hkjels</w>Is it possible to start a search from a trees leaves?
Or select the deepest nested match only?</z><z id="t1508167890" t="borkdude I have a data structure like {:foo [{:bar #{:a x}} {:bar #{:b c}]} and I want to filter :foo by some predicate. Now I’m using (update m :foo filter-fn) where filter-fn is something like (filter coll pred) . How do I write this using Specter? Does it have some filter functionality?"><y>#</y><d>2017-10-16</d><h>15:31</h><w>borkdude</w>I have a data structure like <code>{:foo [{:bar #{:a x}} {:bar #{:b c}]}</code> and I want to filter <code>:foo</code> by some predicate. Now I’m using <code>(update m :foo filter-fn)</code> where <code>filter-fn</code> is something like <code>(filter coll pred)</code>. 
How do I write this using Specter? Does it have some filter functionality?</z><z id="t1508168659" t="nathanmarz @hkjels you could do something like that with zippers, but there&apos;s probably a better way"><y>#</y><d>2017-10-16</d><h>15:44</h><w>nathanmarz</w>@hkjels you could do something like that with zippers, but there&apos;s probably a better way</z><z id="t1508168715" t="nathanmarz for deepest match, you could do select with putval at every recursive step, and then choose longest result at end"><y>#</y><d>2017-10-16</d><h>15:45</h><w>nathanmarz</w>for deepest match, you could do <code>select</code> with <code>putval</code> at every recursive step, and then choose longest result at end</z><z id="t1508168782" t="nathanmarz @borkdude that looks like (setval [:foo ALL remove-fn?] NONE data)"><y>#</y><d>2017-10-16</d><h>15:46</h><w>nathanmarz</w>@borkdude that looks like <code>(setval [:foo ALL remove-fn?] NONE data)</code></z><z id="t1508168859" t="borkdude ah great"><y>#</y><d>2017-10-16</d><h>15:47</h><w>borkdude</w>ah great</z><z id="t1508168891" t="borkdude so setting NONE is semantically equivalent to removing an element in Specter"><y>#</y><d>2017-10-16</d><h>15:48</h><w>borkdude</w>so setting NONE is semantically equivalent to removing an element in Specter</z><z id="t1508169099" t="nathanmarz yes"><y>#</y><d>2017-10-16</d><h>15:51</h><w>nathanmarz</w>yes</z><z id="t1508169268" t="hkjels @nathanmarz I was overcomplicating it. I realized that I always need the fift level or deeper, so a simple predicate solved it"><y>#</y><d>2017-10-16</d><h>15:54</h><w>hkjels</w>@nathanmarz I was overcomplicating it. I realized that I always need the fift level or deeper, so a simple predicate solved it</z><z id="t1508169473" t="borkdude Maybe there should be a Specter course on Clojure Academy 🙂"><y>#</y><d>2017-10-16</d><h>15:57</h><w>borkdude</w>Maybe there should be a Specter course on Clojure Academy <b>🙂</b></z><z id="t1508169929" t="borkdude Almost what I want: (def data {:foo [{:bar [:a]} {:bar [:a :b]} {:bar [:c]}]}) (setval [:foo ALL :bar #(seq (set/intersection #{:a} (set %)))] NONE data) ;;=&gt; {:foo [{} {} {:bar [:c]}]} "><y>#</y><d>2017-10-16</d><h>16:05</h><w>borkdude</w>Almost what I want:
<pre>(def data {:foo [{:bar [:a]}
                 {:bar [:a :b]}
                 {:bar [:c]}]})

(setval
 [:foo ALL :bar
  #(seq (set/intersection #{:a}
                          (set %)))]
 NONE
 data) ;;=&gt; {:foo [{} {} {:bar [:c]}]}
</pre></z><z id="t1508169934" t="borkdude but I want to get rid of the empty maps"><y>#</y><d>2017-10-16</d><h>16:05</h><w>borkdude</w>but I want to get rid of the empty maps</z><z id="t1508170002" t="borkdude This works: (setval [:foo ALL #(seq (set/intersection #{:a} (set (:bar %))))] NONE data) "><y>#</y><d>2017-10-16</d><h>16:06</h><w>borkdude</w>This works:
<pre>(setval
 [:foo ALL
  #(seq (set/intersection #{:a}
                          (set (:bar %))))]
 NONE
 data)
</pre></z><z id="t1508170076" t="hkjels More learning-material would be great. I saw one of your talks on Specter yesterday @nathanmarz and was really impressed by your presentation skills"><y>#</y><d>2017-10-16</d><h>16:07</h><w>hkjels</w>More learning-material would be great. I saw one of your talks on Specter yesterday @nathanmarz and was really impressed by your presentation skills</z><z id="t1508170092" t="hkjels well done"><y>#</y><d>2017-10-16</d><h>16:08</h><w>hkjels</w>well done</z><z id="t1508170221" t="borkdude actually it doesn’t work yet, hang on"><y>#</y><d>2017-10-16</d><h>16:10</h><w>borkdude</w>actually it doesn’t work yet, hang on</z><z id="t1508170251" t="borkdude the predicate should be reversed, so with empty? 🙂"><y>#</y><d>2017-10-16</d><h>16:10</h><w>borkdude</w>the predicate should be reversed, so with <code>empty?</code> <b>🙂</b></z><z id="t1508170478" t="borkdude How do I update two paths in parallel, e.g. {:foo 1 :bar 2} , (transform [#{:foo :bar} inc]) , is this possible?"><y>#</y><d>2017-10-16</d><h>16:14</h><w>borkdude</w>How do I update two paths in parallel, e.g. <code>{:foo 1 :bar 2}</code>, <code>(transform [#{:foo :bar} inc])</code>, is this possible?</z><z id="t1508170727" t="borkdude ah, multi-path"><y>#</y><d>2017-10-16</d><h>16:18</h><w>borkdude</w>ah, multi-path</z><z id="t1508174461" t="nathanmarz @borkdude for your empty map issue: (setval [:foo ALL (multi-path [:bar (selected? ALL (pred= :a))] empty?)] NONE data) "><y>#</y><d>2017-10-16</d><h>17:21</h><w>nathanmarz</w>@borkdude for your empty map issue:
<pre>(setval
  [:foo
   ALL
   (multi-path
     [:bar (selected? ALL (pred= :a))]
     empty?)]
  NONE
  data)
</pre></z><z id="t1508174474" t="nathanmarz @hkjels thanks"><y>#</y><d>2017-10-16</d><h>17:21</h><w>nathanmarz</w>@hkjels thanks</z><z id="t1508174497" t="nathanmarz the wiki is much better nowadays and there was a screencast released recently"><y>#</y><d>2017-10-16</d><h>17:21</h><w>nathanmarz</w>the wiki is much better nowadays and there was a screencast released recently</z><z id="t1508174503" t="nathanmarz linked on the readme"><y>#</y><d>2017-10-16</d><h>17:21</h><w>nathanmarz</w>linked on the readme</z><z id="t1508175260" t="borkdude @nathanmarz that’s awesome"><y>#</y><d>2017-10-16</d><h>17:34</h><w>borkdude</w>@nathanmarz that’s awesome</z><z id="t1508176137" t="borkdude @nathanmarz If I understand correctly, the function empty? is a selector for the path :bar , after the right path has been applied, so it removes the empty map?"><y>#</y><d>2017-10-16</d><h>17:48</h><w>borkdude</w>@nathanmarz If I understand correctly, the function <code>empty?</code> is a selector for the path <code>:bar</code>, after the right path has been applied, so it removes the empty map?</z><z id="t1508176442" t="borkdude On the wiki it says: for transforms it applies in order"><y>#</y><d>2017-10-16</d><h>17:54</h><w>borkdude</w>On the wiki it says: for transforms it applies in order</z><z id="t1508176520" t="nathanmarz empty? is a filter run after removal of :bar values matching the first path"><y>#</y><d>2017-10-16</d><h>17:55</h><w>nathanmarz</w>empty? is a filter run after removal of :bar values matching the first path</z><z id="t1508176788" t="borkdude ah now I get it, I read it wrong, as if :bar and (selected? ....) were both paths, but empty? itself is a “path” on the value returned by the previous path"><y>#</y><d>2017-10-16</d><h>17:59</h><w>borkdude</w>ah now I get it, I read it wrong, as if <code>:bar</code> and <code>(selected? ....)</code> were both paths, but <code>empty?</code> itself is a “path” on the value returned by the previous path</z><z id="t1508176842" t="nathanmarz yea, that&apos;s right"><y>#</y><d>2017-10-16</d><h>18:00</h><w>nathanmarz</w>yea, that&apos;s right</z><z id="t1508176996" t="nathanmarz that&apos;s also much more efficient than the set intersection approach"><y>#</y><d>2017-10-16</d><h>18:03</h><w>nathanmarz</w>that&apos;s also much more efficient than the set intersection approach</z><z id="t1508177091" t="borkdude and because selected? stops the navigation, what is returned is the empty map, because no key-vals have been selected because pred= returned false"><y>#</y><d>2017-10-16</d><h>18:04</h><w>borkdude</w>and because selected? stops the navigation, what is returned is the empty map, because no key-vals have been selected because pred= returned false</z><z id="t1508177109" t="borkdude correct?"><y>#</y><d>2017-10-16</d><h>18:05</h><w>borkdude</w>correct?</z><z id="t1508177140" t="borkdude those are patterns worth remembering"><y>#</y><d>2017-10-16</d><h>18:05</h><w>borkdude</w>those are patterns worth remembering</z><z id="t1508177632" t="nathanmarz well, selected? is run on the value of :bar"><y>#</y><d>2017-10-16</d><h>18:13</h><w>nathanmarz</w>well, selected? is run on the value of <code>:bar</code></z><z id="t1508177644" t="nathanmarz it selects any vectors that have :a in them"><y>#</y><d>2017-10-16</d><h>18:14</h><w>nathanmarz</w>it selects any vectors that have <code>:a</code> in them</z><z id="t1508177670" t="nathanmarz which is then set to NONE , removing the key/val pair from the map"><y>#</y><d>2017-10-16</d><h>18:14</h><w>nathanmarz</w>which is then set to <code>NONE</code>, removing the key/val pair from the map</z><z id="t1508177682" t="nathanmarz then empty? is run, removing any maps from the vector that are now empty"><y>#</y><d>2017-10-16</d><h>18:14</h><w>nathanmarz</w>then empty? is run, removing any maps from the vector that are now empty</z><z id="t1508178123" t="borkdude well, I need to check for multiple values, so I need the intersection, like this: (setval [:foo ALL (multi-path [:bar (selected? #(empty? (set/intersection #{:a :b} %)))] empty?)] NONE data) "><y>#</y><d>2017-10-16</d><h>18:22</h><w>borkdude</w>well, I need to check for multiple values, so I need the intersection, like this:
<pre>(setval
 [:foo
  ALL
  (multi-path
   [:bar (selected? #(empty? (set/intersection #{:a :b} %)))]
   empty?)]
 NONE
 data)
</pre></z><z id="t1508178252" t="nathanmarz you can do [:bar (selected? ALL #{:a :b})]"><y>#</y><d>2017-10-16</d><h>18:24</h><w>nathanmarz</w>you can do <code>[:bar (selected? ALL #{:a :b})]</code></z><z id="t1508178271" t="nathanmarz there&apos;s also no point to using selected? with only a function"><y>#</y><d>2017-10-16</d><h>18:24</h><w>nathanmarz</w>there&apos;s also no point to using <code>selected?</code> with only a function</z><z id="t1508178287" t="nathanmarz sets are implicit filter predicates in specter"><y>#</y><d>2017-10-16</d><h>18:24</h><w>nathanmarz</w>sets are implicit filter predicates in specter</z><z id="t1508178296" t="nathanmarz interpreted equivalent to a clojure function"><y>#</y><d>2017-10-16</d><h>18:24</h><w>nathanmarz</w>interpreted equivalent to a clojure function</z><z id="t1508252287" t="borkdude This code does what I want: (def data (let [inner-data [{:bar #{:a}} {:bar #{:a :b}} {:bar #{:c}}]] {:a inner-data :b inner-data})) (setval [(multi-path :a :b) ALL (multi-path [:bar (selected? ALL (comp not #{:a :b}))] empty?)] NONE data) but not in the case of nil or {} , then it adds keys with nil"><y>#</y><d>2017-10-17</d><h>14:58</h><w>borkdude</w>This code does what I want:
<pre>(def data (let [inner-data [{:bar #{:a}}
                            {:bar #{:a :b}}
                            {:bar #{:c}}]]
            {:a inner-data
             :b inner-data}))

(setval
 [(multi-path :a :b)
  ALL
  (multi-path
   [:bar (selected? ALL
                    (comp not #{:a :b}))]
   empty?)]
 NONE
 data)
</pre>
but not in the case of <code>nil</code> or <code>{}</code>, then it adds keys with nil</z><z id="t1508252370" t="nathanmarz @borkdude nil or {} for what?"><y>#</y><d>2017-10-17</d><h>14:59</h><w>nathanmarz</w>@borkdude nil or {} for what?</z><z id="t1508252374" t="nathanmarz the inner maps?"><y>#</y><d>2017-10-17</d><h>14:59</h><w>nathanmarz</w>the inner maps?</z><z id="t1508252385" t="borkdude the result, {:a nil, :b nil}"><y>#</y><d>2017-10-17</d><h>14:59</h><w>borkdude</w>the result, <code>{:a nil, :b nil}</code></z><z id="t1508252439" t="nathanmarz not following"><y>#</y><d>2017-10-17</d><h>15:00</h><w>nathanmarz</w>not following</z><z id="t1508252457" t="borkdude (setval [(multi-path :a :b) ALL (multi-path [:bar (selected? ALL (comp not #{:a :b}))] empty?)] NONE nil) "><y>#</y><d>2017-10-17</d><h>15:00</h><w>borkdude</w><pre>(setval
 [(multi-path :a :b)
  ALL
  (multi-path
   [:bar (selected? ALL
                    (comp not #{:a :b}))]
   empty?)]
 NONE
 nil)
</pre></z><z id="t1508252468" t="nathanmarz ah"><y>#</y><d>2017-10-17</d><h>15:01</h><w>nathanmarz</w>ah</z><z id="t1508252474" t="borkdude ;;=&gt; {:a nil, :b nil}"><y>#</y><d>2017-10-17</d><h>15:01</h><w>borkdude</w><code>;;=&gt; {:a nil, :b nil}</code></z><z id="t1508252481" t="nathanmarz you can use (multi-path (must :a) (must :b))"><y>#</y><d>2017-10-17</d><h>15:01</h><w>nathanmarz</w>you can use <code>(multi-path (must :a) (must :b))</code></z><z id="t1508252501" t="borkdude ah, a new construct… going to the wiki 🙂"><y>#</y><d>2017-10-17</d><h>15:01</h><w>borkdude</w>ah, a new construct… going to the wiki <b>🙂</b></z><z id="t1508252543" t="borkdude when do you not want the behavior of must ?"><y>#</y><d>2017-10-17</d><h>15:02</h><w>borkdude</w>when do you not want the behavior of <code>must</code>?</z><z id="t1508252596" t="borkdude I mean, why is it not the default"><y>#</y><d>2017-10-17</d><h>15:03</h><w>borkdude</w>I mean, why is it not the default</z><z id="t1508252663" t="nathanmarz i&apos;ve found the need to definitely navigate to a key is far more common"><y>#</y><d>2017-10-17</d><h>15:04</h><w>nathanmarz</w>i&apos;ve found the need to definitely navigate to a key is far more common</z><z id="t1508252665" t="nathanmarz and it&apos;s faster"><y>#</y><d>2017-10-17</d><h>15:04</h><w>nathanmarz</w>and it&apos;s faster</z><z id="t1508252695" t="nathanmarz also (update {} :a identity) ;; =&gt; {:a nil}"><y>#</y><d>2017-10-17</d><h>15:04</h><w>nathanmarz</w>also <code>(update {} :a identity) ;; =&gt; {:a nil}</code></z><z id="t1508252781" t="borkdude ah"><y>#</y><d>2017-10-17</d><h>15:06</h><w>borkdude</w>ah</z><z id="t1508257112" t="borkdude Still I find the code incredibly hard to read compared to normal Clojure…"><y>#</y><d>2017-10-17</d><h>16:18</h><w>borkdude</w>Still I find the code incredibly hard to read compared to normal Clojure…</z><z id="t1508257128" t="nathanmarz Specter 1.0.4 released"><y>#</y><d>2017-10-17</d><h>16:18</h><w>nathanmarz</w>Specter 1.0.4 released</z><z id="t1508257161" t="borkdude Congrats on the new release"><y>#</y><d>2017-10-17</d><h>16:19</h><w>borkdude</w>Congrats on the new release</z><z id="t1508259290" t="jeaye @nathanmarz Do you recommend using specter in lieu of clojure.core fns always? Or perhaps only when either 1) it&apos;s known to be faster; 2) it provides a much more robust solution;"><y>#</y><d>2017-10-17</d><h>16:54</h><w>jeaye</w>@nathanmarz Do you recommend using specter in lieu of clojure.core fns always? Or perhaps only when either 1) it&apos;s known to be faster; 2) it provides a much more robust solution;</z><z id="t1508259444" t="jeaye Based on the benchmarks, it looks like specter isn&apos;t always faster. On a team, this makes it harder to bring in, since one can&apos;t just say &quot;We&apos;re using specter for data access now; it&apos;s faster and more robust.&quot; Unfortunately, the ruleset of when to use it (i.e. get-in seems slow, transform is very fast, unless you&apos;re doing a mapv ) is complex, then makes it much more expensive to adopt and learn."><y>#</y><d>2017-10-17</d><h>16:57</h><w>jeaye</w>Based on the benchmarks, it looks like specter isn&apos;t always faster. On a team, this makes it harder to bring in, since one can&apos;t just say &quot;We&apos;re using specter for data access now; it&apos;s faster and more robust.&quot; Unfortunately, the ruleset of when to use it (i.e. <code>get-in</code> seems slow, <code>transform</code> is very fast, unless you&apos;re doing a <code>mapv</code>) is complex, then makes it much more expensive to adopt and learn.</z><z id="t1508260047" t="nathanmarz @jeaye I use it always when it&apos;s more elegant than trying to do it in vanilla Clojure"><y>#</y><d>2017-10-17</d><h>17:07</h><w>nathanmarz</w>@jeaye I use it always when it&apos;s more elegant than trying to do it in vanilla Clojure</z><z id="t1508260240" t="nathanmarz the overhead is generally quite small even for cases where the vanilla Clojure is just as elegant"><y>#</y><d>2017-10-17</d><h>17:10</h><w>nathanmarz</w>the overhead is generally quite small even for cases where the vanilla Clojure is just as elegant</z><z id="t1508260259" t="nathanmarz the notable exception is (select-any [:a :b :c] data) vs. (-&gt; data :a :b :c)"><y>#</y><d>2017-10-17</d><h>17:10</h><w>nathanmarz</w>the notable exception is <code>(select-any [:a :b :c] data)</code> vs. <code>(-&gt; data :a :b :c)</code></z><z id="t1508260316" t="nathanmarz I do believe it&apos;s possible to eliminate most of the overhead for that with additional work on Specter"><y>#</y><d>2017-10-17</d><h>17:11</h><w>nathanmarz</w>I do believe it&apos;s possible to eliminate most of the overhead for that with additional work on Specter</z><z id="t1508260361" t="nathanmarz though for a case like that I would do the latter expression in my own code since it&apos;s elegant"><y>#</y><d>2017-10-17</d><h>17:12</h><w>nathanmarz</w>though for a case like that I would do the latter expression in my own code since it&apos;s elegant</z><z id="t1508261243" t="jeaye Word. Thanks for the info and congrats on the 1.0.4 release."><y>#</y><d>2017-10-17</d><h>17:27</h><w>jeaye</w>Word. Thanks for the info and congrats on the 1.0.4 release.</z><z id="t1508262119" t="tanzoniteblack is there a way to use specter to select only distinct values (besides the obvious of (distinct (specter/select apath structure)) which requires looping through the final result)"><y>#</y><d>2017-10-17</d><h>17:41</h><w>tanzoniteblack</w>is there a way to use specter to select only distinct values (besides the obvious of <code>(distinct (specter/select apath structure))</code> which requires looping through the final result)</z><z id="t1508262174" t="tanzoniteblack (not that this is really a huge performance hit, but just curious)"><y>#</y><d>2017-10-17</d><h>17:42</h><w>tanzoniteblack</w>(not that this is really a huge performance hit, but just curious)</z><z id="t1508262457" t="nathanmarz @tanzoniteblack you can do (into #{} (traverse apath structure))"><y>#</y><d>2017-10-17</d><h>17:47</h><w>nathanmarz</w>@tanzoniteblack you can do <code>(into #{} (traverse apath structure))</code></z><z id="t1508262463" t="nathanmarz that&apos;s the fastest"><y>#</y><d>2017-10-17</d><h>17:47</h><w>nathanmarz</w>that&apos;s the fastest</z><z id="t1508262475" t="tanzoniteblack not the same though, since set&apos;s don&apos;t retain the order (which is important in this case)"><y>#</y><d>2017-10-17</d><h>17:47</h><w>tanzoniteblack</w>not the same though, since set&apos;s don&apos;t retain the order (which is important in this case)</z><z id="t1508262518" t="tanzoniteblack (which I didn&apos;t specify in my question 🙂 , but distinct does retain the order, which is a useful property in my case)"><y>#</y><d>2017-10-17</d><h>17:48</h><w>tanzoniteblack</w>(which I didn&apos;t specify in my question <b>🙂</b> , but <code>distinct</code> does retain the order, which is a useful property in my case)</z><z id="t1508262697" t="nathanmarz distinct is the easiest, though traverse just returns a reducible so you can do it faster if needed"><y>#</y><d>2017-10-17</d><h>17:51</h><w>nathanmarz</w><code>distinct</code> is the easiest, though <code>traverse</code> just returns a reducible so you can do it faster if needed</z><z id="t1508262722" t="nathanmarz reduce over the traverse return to add into a vector while keeping a mutable set in scope in order to not append duplicates"><y>#</y><d>2017-10-17</d><h>17:52</h><w>nathanmarz</w><code>reduce</code> over the <code>traverse</code> return to add into a vector while keeping a mutable set in scope in order to not append duplicates</z><z id="t1508262768" t="tanzoniteblack thanks"><y>#</y><d>2017-10-17</d><h>17:52</h><w>tanzoniteblack</w>thanks</z><z id="t1508262811" t="nathanmarz actually (into [] (distinct) (traverse apath structure)) might be equivalent to that"><y>#</y><d>2017-10-17</d><h>17:53</h><w>nathanmarz</w>actually <code>(into [] (distinct) (traverse apath structure))</code> might be equivalent to that</z><z id="t1508262877" t="nathanmarz yea it is: user=&gt; (into [] (distinct) (traverse ALL [1 2 3 4 5 2 1 7])) [1 2 3 4 5 7] "><y>#</y><d>2017-10-17</d><h>17:54</h><w>nathanmarz</w>yea it is:
<pre>user=&gt; (into [] (distinct) (traverse ALL [1 2 3 4 5 2 1 7]))
[1 2 3 4 5 7]
</pre></z><z id="t1508262916" t="tanzoniteblack nice to know I can use traverse with transducers"><y>#</y><d>2017-10-17</d><h>17:55</h><w>tanzoniteblack</w>nice to know I can use <code>traverse</code> with transducers</z><z id="t1508262950" t="nathanmarz you can also make a specter-based transducer with traverse-all"><y>#</y><d>2017-10-17</d><h>17:55</h><w>nathanmarz</w>you can also make a specter-based transducer with <code>traverse-all</code></z><z id="t1508266998" t="borkdude @nathanmarz When you do a multi-path over an ALL , will it iterate multiple times over the sequence? My code now looks like this: (setval [(multi-path (must :report) (must :highlights)) ALL (multi-path [:pico #(not (some (set picos) %))] ;; if key is removed, remove the map entirely (comp not :pico))] NONE results) "><y>#</y><d>2017-10-17</d><h>19:03</h><w>borkdude</w>@nathanmarz When you do a multi-path over an <code>ALL</code>, will it iterate multiple times over the sequence? My code now looks like this:
<pre>(setval
      [(multi-path (must :report) (must :highlights))
       ALL
       (multi-path
        [:pico
         #(not (some (set picos) %))]
        ;; if key is removed, remove the map entirely
        (comp not :pico))]
      NONE
      results)
</pre></z><z id="t1508267035" t="borkdude but I could have used just a filter/remove function on the ALL"><y>#</y><d>2017-10-17</d><h>19:03</h><w>borkdude</w>but I could have used just a filter/remove function on the ALL</z><z id="t1508267230" t="borkdude I could imagine that specter fuses these operations"><y>#</y><d>2017-10-17</d><h>19:07</h><w>borkdude</w>I could imagine that specter fuses these operations</z><z id="t1508267585" t="nathanmarz that does not iterate over any sequence multiple times"><y>#</y><d>2017-10-17</d><h>19:13</h><w>nathanmarz</w>that does not iterate over any sequence multiple times</z></g><g id="s16"><z id="t1508267650" t="borkdude I think this is more readable though: (transform [(multi-path (must :report) (must :highlights))] #(remove (fn [m] (not (some (set picos) (:pico m)))) %) results) "><y>#</y><d>2017-10-17</d><h>19:14</h><w>borkdude</w>I think this is more readable though:
<pre>(transform
      [(multi-path (must :report) (must :highlights))]
      #(remove
        (fn [m]
          (not (some (set picos) (:pico m)))) %)
      results)
</pre></z><z id="t1508267666" t="borkdude but good to know it doesn’t iterate multiple times"><y>#</y><d>2017-10-17</d><h>19:14</h><w>borkdude</w>but good to know it doesn’t iterate multiple times</z><z id="t1508267965" t="nathanmarz @borkdude the specter version can be done much simpler: (setval [(multi-path (must :report) (must :highlights)) ALL (selected? :pico ALL (pred (set picos)))] NONE results) "><y>#</y><d>2017-10-17</d><h>19:19</h><w>nathanmarz</w>@borkdude the specter version can be done much simpler:
<pre>(setval
  [(multi-path (must :report) (must :highlights))
   ALL
   (selected? :pico ALL (pred (set picos)))]
  NONE
  results)
</pre></z><z id="t1508268096" t="borkdude nice!"><y>#</y><d>2017-10-17</d><h>19:21</h><w>borkdude</w>nice!</z><z id="t1508269159" t="borkdude The problem is that I need something slightly different: (def picos [:a :b]) (def results {:highlights [{:pico [:a]} ;; keep {:pico [:a :b]} ;; keep {:pico [:c]} ;; drop {:pico [:c :d]} ;; drop {:pico [:c :a]}]}) ;;keep (transform [(multi-path (must :report) (must :highlights))] #(remove (fn [m] (not (some (set picos) (:pico m)))) %) results) ;;=&gt; {:highlights ({:pico [:a]} {:pico [:a :b]} {:pico [:c :a]})} "><y>#</y><d>2017-10-17</d><h>19:39</h><w>borkdude</w>The problem is that  I need something slightly different:

<pre>(def picos [:a :b])
(def results {:highlights [{:pico [:a]}    ;; keep
                           {:pico [:a :b]} ;; keep
                           {:pico [:c]}    ;; drop
                           {:pico [:c :d]} ;; drop
                           {:pico [:c :a]}]}) ;;keep

(transform
 [(multi-path (must :report) (must :highlights))]
 #(remove
   (fn [m]
     (not (some (set picos) (:pico m)))) %)
 results) ;;=&gt; {:highlights ({:pico [:a]} {:pico [:a :b]} {:pico [:c :a]})}
</pre></z><z id="t1508269200" t="borkdude so something like (selected? :pico ANY (pred (comp not (set picos))))"><y>#</y><d>2017-10-17</d><h>19:40</h><w>borkdude</w>so something like <code>(selected? :pico ANY (pred (comp not (set picos))))</code></z><z id="t1508269209" t="borkdude but I didn’t find something like ANY"><y>#</y><d>2017-10-17</d><h>19:40</h><w>borkdude</w>but I didn’t find something like <code>ANY</code></z><z id="t1508269587" t="nathanmarz ah you just need (not-selected? ALL (set picos))"><y>#</y><d>2017-10-17</d><h>19:46</h><w>nathanmarz</w>ah you just need <code>(not-selected? ALL (set picos))</code></z><z id="t1508269631" t="borkdude that works"><y>#</y><d>2017-10-17</d><h>19:47</h><w>borkdude</w>that works</z><z id="t1508269675" t="nathanmarz btw, the pred is only there for performance, and is only needed if picos is a local variable"><y>#</y><d>2017-10-17</d><h>19:47</h><w>nathanmarz</w>btw, the <code>pred</code> is only there for performance, and is only needed if <code>picos</code> is a local variable</z><z id="t1508269910" t="borkdude in my original code it is a local"><y>#</y><d>2017-10-17</d><h>19:51</h><w>borkdude</w>in my original code it is a local</z><z id="t1508270383" t="nathanmarz the specter version will also preserve the sequence type"><y>#</y><d>2017-10-17</d><h>19:59</h><w>nathanmarz</w>the specter version will also preserve the sequence type</z><z id="t1508270421" t="borkdude yes, that’s a bonus"><y>#</y><d>2017-10-17</d><h>20:00</h><w>borkdude</w>yes, that’s a bonus</z><z id="t1508270444" t="nathanmarz also will only convert picos to a set once, instead of for every element"><y>#</y><d>2017-10-17</d><h>20:00</h><w>nathanmarz</w>also will only convert <code>picos</code> to a set once, instead of for every element</z><z id="t1508270475" t="borkdude What is the explanation of this result? I don’t understand selected? and not-selected? well enough. (select [(selected? ALL odd?)] [1 2 3]) ;;=&gt; [[1 2 3]]"><y>#</y><d>2017-10-17</d><h>20:01</h><w>borkdude</w>What is the explanation of this result? I don’t understand <code>selected?</code> and <code>not-selected?</code> well enough.
<code>(select [(selected? ALL odd?)] [1 2 3]) ;;=&gt; [[1 2 3]]</code></z><z id="t1508270523" t="nathanmarz selected? stays navigated if the path selects at least one value"><y>#</y><d>2017-10-17</d><h>20:02</h><w>nathanmarz</w><code>selected?</code> stays navigated if the path selects at least one value</z><z id="t1508270545" t="nathanmarz in this case it&apos;s run on the root, and it is true"><y>#</y><d>2017-10-17</d><h>20:02</h><w>nathanmarz</w>in this case it&apos;s run on the root, and it is true</z><z id="t1508270558" t="nathanmarz so it selects the root [1 2 3]"><y>#</y><d>2017-10-17</d><h>20:02</h><w>nathanmarz</w>so it selects the root <code>[1 2 3]</code></z><z id="t1508270565" t="borkdude ah, that’s it"><y>#</y><d>2017-10-17</d><h>20:02</h><w>borkdude</w>ah, that’s it</z><z id="t1508270773" t="borkdude so with a local I need (pred (set picos)) and then it will substitute the value of the expression?"><y>#</y><d>2017-10-17</d><h>20:06</h><w>borkdude</w>so with a local I need <code>(pred (set picos))</code> and then it will substitute the value of the expression?</z><z id="t1508271261" t="nathanmarz the pred in that case avoids a runtime conversion from an implicit navigator (a set) to a navigator"><y>#</y><d>2017-10-17</d><h>20:14</h><w>nathanmarz</w>the <code>pred</code> in that case avoids a runtime conversion from an implicit navigator (a set) to a navigator</z><z id="t1508271332" t="nathanmarz sets are implicitly wrapped in pred , but if the value at a spot is dynamic, then specter cannot know that until runtime"><y>#</y><d>2017-10-17</d><h>20:15</h><w>nathanmarz</w>sets are implicitly wrapped in <code>pred</code>, but if the value at a spot is dynamic, then specter cannot know that until runtime</z><z id="t1508271376" t="nathanmarz it&apos;s not a huge deal, but it is a protocol invocation"><y>#</y><d>2017-10-17</d><h>20:16</h><w>nathanmarz</w>it&apos;s not a huge deal, but it is a protocol invocation</z><z id="t1508339550" t="levitanong This is weird. on 1.0.3, while firing up my repl, I got a: java.lang.RuntimeException: Unable to resolve symbol: richnav in this context, compiling:(com/rpl/specter.cljc:62:6) "><y>#</y><d>2017-10-18</d><h>15:12</h><w>levitanong</w>This is weird. on 1.0.3, while firing up my repl, I got a:
<pre>java.lang.RuntimeException: Unable to resolve symbol: richnav in this context, compiling:(com/rpl/specter.cljc:62:6)
</pre></z><z id="t1508339559" t="levitanong what could this be?"><y>#</y><d>2017-10-18</d><h>15:12</h><w>levitanong</w>what could this be?</z><z id="t1508358477" t="nathanmarz @levitanong is this clj or cljs?"><y>#</y><d>2017-10-18</d><h>20:27</h><w>nathanmarz</w>@levitanong is this clj or cljs?</z><z id="t1508358713" t="levitanong @nathanmarz clj. Disappeared when I updated to 1.0.4 lol"><y>#</y><d>2017-10-18</d><h>20:31</h><w>levitanong</w>@nathanmarz clj. Disappeared when I updated to 1.0.4 lol</z><z id="t1508359921" t="nathanmarz ok"><y>#</y><d>2017-10-18</d><h>20:52</h><w>nathanmarz</w>ok</z><z id="t1508368901" t="gdeer81 the same thing happened to me when I was righting the specter-koans. it was because I started writing the koans in version 0.13.0 and picked it up again after the 1.0 release so my project.clj was sorely out of date. all was well after I bumped the specter version"><y>#</y><d>2017-10-18</d><h>23:21</h><w>gdeer81</w>the same thing happened to me when I was righting the specter-koans. it was because I started writing the koans in version 0.13.0 and picked it up again after the 1.0 release so my project.clj was sorely out of date. all was well after I bumped the specter version</z><z id="t1508385216" t="kishanov Hi there. How do I do the following transformation with specter: (let [data {:a {:val 15} :b {:val 18}}] (-&gt;&gt; data (map (fn [[k v]] [k (assoc v :key (name k))])) (into {})))"><y>#</y><d>2017-10-19</d><h>03:53</h><w>kishanov</w>Hi there. How do I do the following transformation with specter: <pre>(let [data {:a {:val 15}
            :b {:val 18}}]

  (-&gt;&gt; data
       (map (fn [[k v]]
              [k (assoc v :key (name k))]))
       (into {})))</pre></z><z id="t1508385268" t="kishanov i.e. is it possible to capture arguments in transform path and path them to transformation function?"><y>#</y><d>2017-10-19</d><h>03:54</h><w>kishanov</w>i.e. is it possible to capture arguments in <code>transform</code> path and path them to transformation function?</z><z id="t1508386222" t="nathanmarz @kishanov yes, with value collection"><y>#</y><d>2017-10-19</d><h>04:10</h><w>nathanmarz</w>@kishanov yes, with value collection</z><z id="t1508386226" t="nathanmarz (transform [ALL (collect-one FIRST NAME) LAST :key] (fn [n _] n) data) "><y>#</y><d>2017-10-19</d><h>04:10</h><w>nathanmarz</w><pre>(transform [ALL (collect-one FIRST NAME) LAST :key]
  (fn [n _] n)
  data)
</pre></z><z id="t1508386414" t="kishanov thnx @nathanmarz. Will the same approach work if I want to capture more then 1 value from the path? Ultimately I’m looking for the analog of “Capture groups” in instar"><y>#</y><d>2017-10-19</d><h>04:13</h><w>kishanov</w>thnx @nathanmarz. Will the same approach work if I want to capture more then 1 value from the path? Ultimately I’m looking for the analog of “Capture groups” in instar</z><z id="t1508386436" t="nathanmarz yes, you can capture as many values as you want"><y>#</y><d>2017-10-19</d><h>04:13</h><w>nathanmarz</w>yes, you can capture as many values as you want</z><z id="t1508386457" t="nathanmarz each collect /`collect-one` call produces an extra argument to the transform function, in the order in which they&apos;re called"><y>#</y><d>2017-10-19</d><h>04:14</h><w>nathanmarz</w>each <code>collect</code>/`collect-one` call produces an extra argument to the transform function, in the order in which they&apos;re called</z><z id="t1508386478" t="kishanov nice, thanks!"><y>#</y><d>2017-10-19</d><h>04:14</h><w>kishanov</w>nice, thanks!</z><z id="t1509243163" t="eoliphant Hi i just discovered specter, it’s awesome. I have a quick question. I’m trying to add a map to a list of maps., but setval treats it as a collection and adding each k-v pair. Like so: testmap =&gt; {:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;}]} (s/setval [:b s/END] {:id 5 :a 6} testmap) =&gt; {:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;} [:id 5] [:a 6]]} How do I get around this?"><y>#</y><d>2017-10-29</d><h>02:12</h><w>eoliphant</w>Hi i just discovered specter, it’s awesome.  I have a quick question.  I’m trying to add a map to a list of maps., but setval treats it as a collection and adding each k-v pair.  Like so:

<pre>testmap
=&gt; {:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;}]}
(s/setval [:b s/END] {:id 5
                      :a 6} testmap)
=&gt; {:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;} [:id 5] [:a 6]]}
</pre>

How do I get around this?</z><z id="t1509243515" t="michaelwfogleman Not sure if this is the idiomatic way but does this do what you&apos;re looking for?"><y>#</y><d>2017-10-29</d><h>02:18</h><r>michaelwfogleman</r>Not sure if this is the idiomatic way but does this do what you&apos;re looking for?</z><z id="t1509243517" t="michaelwfogleman (def test-map {:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;}]}) (transform [:b END] #(conj % {:id 5 :a 6}) test-map) "><y>#</y><d>2017-10-29</d><h>02:18</h><r>michaelwfogleman</r><pre>(def test-map {:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;}]})
(transform [:b END] #(conj % {:id 5 :a 6}) test-map) </pre></z><z id="t1509243530" t="michaelwfogleman That returns {:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;} {:id 5, :a 6}]} for me"><y>#</y><d>2017-10-29</d><h>02:18</h><r>michaelwfogleman</r>That returns <pre>{:a &quot;a&quot;, :b [{:id 1, :str &quot;1&quot;} {:id 2, :str &quot;2&quot;} {:id 3, :str &quot;2&quot;} {:id 5, :a 6}]}</pre> for me</z><z id="t1509243608" t="eoliphant ah pass a function that returns it"><y>#</y><d>2017-10-29</d><h>02:20</h><r>eoliphant</r>ah pass a function that returns it</z><z id="t1509243615" t="eoliphant ok cool thanks will give that a shot"><y>#</y><d>2017-10-29</d><h>02:20</h><r>eoliphant</r>ok cool thanks will give that a shot</z><z id="t1509243633" t="michaelwfogleman I also don&apos;t think I needed end there"><y>#</y><d>2017-10-29</d><h>02:20</h><r>michaelwfogleman</r>I also don&apos;t think I needed end there</z><z id="t1509243642" t="michaelwfogleman (transform [:b] #(conj % {:id 5 :a 6}) test-map)"><y>#</y><d>2017-10-29</d><h>02:20</h><r>michaelwfogleman</r><pre>(transform [:b] #(conj % {:id 5 :a 6}) test-map)</pre></z><z id="t1509243647" t="michaelwfogleman that should do the same"><y>#</y><d>2017-10-29</d><h>02:20</h><r>michaelwfogleman</r>that should do the same</z><z id="t1509243654" t="michaelwfogleman since a vector gets added to the end anyway"><y>#</y><d>2017-10-29</d><h>02:20</h><r>michaelwfogleman</r>since a vector gets added to the end anyway</z><z id="t1509244572" t="eoliphant hey i just tried this too (s/setval [:b s/END] [{:id 5 :a 6}] testmap) seems to work"><y>#</y><d>2017-10-29</d><h>02:36</h><r>eoliphant</r>hey i just tried this too

<pre>(s/setval [:b s/END] [{:id 5
                      :a 6}] testmap)
</pre>
seems to work</z><z id="t1509245186" t="michaelwfogleman Ah yeah! 🙂"><y>#</y><d>2017-10-29</d><h>02:46</h><r>michaelwfogleman</r>Ah yeah! <b>🙂</b></z><z id="t1509245188" t="michaelwfogleman Nice! 🙂"><y>#</y><d>2017-10-29</d><h>02:46</h><r>michaelwfogleman</r>Nice! <b>🙂</b></z><z id="t1509248329" t="nathanmarz @eoliphant use AFTER-ELEM to append a single element to a sequence"><y>#</y><d>2017-10-29</d><h>03:38</h><w>nathanmarz</w>@eoliphant use <code>AFTER-ELEM</code> to append a single element to a sequence</z><z id="t1509248350" t="nathanmarz (setval [:b AFTER-ELEM] {:id 5 :a 6} testmap)"><y>#</y><d>2017-10-29</d><h>03:39</h><w>nathanmarz</w><code>(setval [:b AFTER-ELEM] {:id 5 :a 6} testmap)</code></z><z id="t1509248366" t="nathanmarz that&apos;s more efficient than using END for this use case"><y>#</y><d>2017-10-29</d><h>03:39</h><w>nathanmarz</w>that&apos;s more efficient than using <code>END</code> for this use case</z><z id="t1509266013" t="schmee this Specter snippet works, but I think it’s a bit of a code smell to have both cond-path and a cond in my transformation function. This being Specter, I suspect that there is a better way to do it 🙂 (def DATA-WALKER (s/recursive-path [] p (s/cond-path map? (s/continue-then-stay s/MAP-VALS p) seq? (s/continue-then-stay s/ALL p)))) (defn simplify [m] (s/transform DATA-WALKER #(cond (sequential? %) (vec %) (map? %) (into {} %)) m)) Any suggestions?"><y>#</y><d>2017-10-29</d><h>08:33</h><w>schmee</w>this Specter snippet works, but I think it’s a bit of a code smell to have both <code>cond-path</code> and a <code>cond</code> in my transformation function. This being Specter, I suspect that there is a better way to do it <b>🙂</b>
<pre>(def DATA-WALKER
  (s/recursive-path [] p
    (s/cond-path
      map? (s/continue-then-stay s/MAP-VALS p)
      seq? (s/continue-then-stay s/ALL p))))

(defn simplify [m]
  (s/transform
    DATA-WALKER
    #(cond
       (sequential? %) (vec %)
       (map? %) (into {} %))
    m))
</pre>
Any suggestions?</z><z id="t1509266039" t="schmee I’ve looked at multi-transform , but I haven’t figured out how to use it with recursive paths"><y>#</y><d>2017-10-29</d><h>08:33</h><w>schmee</w>I’ve looked at <code>multi-transform</code>, but I haven’t figured out how to use it with recursive paths</z><z id="t1509284301" t="nathanmarz @schmee multi-transform version would be (multi-transform [DATA-WALKER (if-path map? (terminal #(into {} %)) (terminal vec))] m)"><y>#</y><d>2017-10-29</d><h>13:38</h><w>nathanmarz</w>@schmee <code>multi-transform</code> version would be <code>(multi-transform [DATA-WALKER (if-path map? (terminal #(into {} %)) (terminal vec))] m)</code></z><z id="t1509284336" t="nathanmarz you don&apos;t need the cond since after DATA-WALKER it&apos;s either map? or seq?"><y>#</y><d>2017-10-29</d><h>13:38</h><w>nathanmarz</w>you don&apos;t need the <code>cond</code> since after <code>DATA-WALKER</code> it&apos;s either <code>map?</code> or <code>seq?</code></z><z id="t1509293901" t="schmee nice, thank you! 😄"><y>#</y><d>2017-10-29</d><h>16:18</h><w>schmee</w>nice, thank you! <b>😄</b></z><z id="t1509331192" t="eoliphant hi i’ve got a quick path/select question. In the following code (def testdata {:a {:b [{:c :d} {:e :f} {:g :h}]}}) I’d like to select out :f based on the fact that I know the {:e :f} map’s index I get this far (s/select [:a :b (s/srange 1 2)] testdata) But can’t figure out what to add to the rest of the path"><y>#</y><d>2017-10-30</d><h>02:39</h><w>eoliphant</w>hi i’ve got a quick path/select question.  In the following code
<pre>(def testdata {:a
               {:b [{:c :d}
                    {:e :f}
                    {:g :h}]}})
</pre>
I’d like to select out <code>:f</code> based on the fact that I know the <code>{:e :f}</code> map’s index
I get this far <code>(s/select [:a :b (s/srange 1 2)] testdata)</code>  But can’t figure out what to add to the rest of the path</z><z id="t1509332301" t="nathanmarz @eoliphant use (nthpath 1)"><y>#</y><d>2017-10-30</d><h>02:58</h><w>nathanmarz</w>@eoliphant use <code>(nthpath 1)</code></z><z id="t1509332746" t="eoliphant ah.. yeah that does it. thanks!"><y>#</y><d>2017-10-30</d><h>03:05</h><w>eoliphant</w>ah.. yeah that does it.  thanks!</z><z id="t1509333933" t="nathanmarz @eoliphant worth skimming through this page to see all the navigators that come with specter https://github.com/nathanmarz/specter/wiki/List-of-Navigators"><y>#</y><d>2017-10-30</d><h>03:25</h><w>nathanmarz</w>@eoliphant worth skimming through this page to see all the navigators that come with specter <a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators</a></z><z id="t1509371923" t="eoliphant hi @nathanmarz yeah re-read them after your help on that one. I’d skimmed them before I started coding and really ‘got it’ lol. Really great tool. I’ve used lenses in Scala, which cover some of what Specter does. Clojure just makes everything better lol. Specter is a much needed bit of special sauce, I’m working on a pretty complex dynamic forms app, that needs a lot of deep structure querying/manipulation, spent the past 2 days ripping out all of my existing code for use cases that Specter covers"><y>#</y><d>2017-10-30</d><h>13:58</h><w>eoliphant</w>hi @nathanmarz yeah re-read them after your help on that one.  I’d skimmed them before I started coding and really ‘got it’ lol.  Really great tool.  I’ve used lenses in Scala, which cover some of what Specter does. Clojure just makes everything better lol.  Specter is a much needed bit of special sauce,  I’m working on a pretty complex dynamic forms app, that needs a lot of deep structure querying/manipulation, spent the past 2 days ripping out all of my existing code for use cases that Specter covers</z><z id="t1509373885" t="nathanmarz @eoliphant great to hear"><y>#</y><d>2017-10-30</d><h>14:31</h><w>nathanmarz</w>@eoliphant great to hear</z><z id="t1509414724" t="eoliphant is there a something like a ‘move’ macro/operation? I’m picking my way through the use of recursive-path, etc. Basically, I’ve a use case where I need to find a node in a tree, save its current value, delete it from its current location, find a target node, then insert the saved node before or after the target. Once I get the recursive locator stuff working, it seems like I’d need a select and two transforms, or a select and a multi-transform, is that more or less correct?"><y>#</y><d>2017-10-31</d><h>01:52</h><w>eoliphant</w>is there a something like a ‘move’ macro/operation?  I’m picking my way through the use of recursive-path, etc. Basically, I’ve a use case where I need to find a node in a tree, save its current value, delete it from its current location, find a target node, then insert the saved node before or after the target.  Once I get the recursive locator stuff working, it seems like I’d need a select and two transforms, or a select and a multi-transform, is that more or less correct?</z><z id="t1509417111" t="nathanmarz best way to do something like that would be combining multi-transform and collect-one"><y>#</y><d>2017-10-31</d><h>02:31</h><w>nathanmarz</w>best way to do something like that would be combining <code>multi-transform</code> and  <code>collect-one</code></z><z id="t1509417204" t="nathanmarz depends on the use case though, some could require zippers"><y>#</y><d>2017-10-31</d><h>02:33</h><w>nathanmarz</w>depends on the use case though, some could require zippers</z><z id="t1509417216" t="nathanmarz would need to see specifically what you&apos;re trying to do"><y>#</y><d>2017-10-31</d><h>02:33</h><w>nathanmarz</w>would need to see specifically what you&apos;re trying to do</z><z id="t1509457919" t="eoliphant hi @nathanmarz sure, here’s a simplified example (def fakeform {:formdef {:form/id 1 :form/groups [{:group/id 2 :group/type :page :group/fields [{:field/id 3 :field/name :fieldone} {:field/id 4 :field/name :fieldtwo} {:field/id 5 :field/name :fieldthree}] :group/subgroups [{:group/id 6 :group/type :section :group/fields [{:field/id 7 :field/name :fieldfour}]}]}]}}) I’d like to approach simple transforms like “move the map identified by :field/id 3 after the one identified by :field/id 4 ” (which I can do with a srange/reverse, etc) as well as more arbitrarily complex ones like “move the map identified by :field/id 3 after the one identified by :field/id 7 ” in a consistent manner"><y>#</y><d>2017-10-31</d><h>13:51</h><w>eoliphant</w>hi @nathanmarz sure, here’s a simplified example

<pre>(def fakeform {:formdef {:form/id 1
                         :form/groups [{:group/id 2
                                        :group/type :page
                                        :group/fields [{:field/id 3
                                                        :field/name :fieldone}
                                                       {:field/id 4
                                                        :field/name :fieldtwo}
                                                       {:field/id 5
                                                        :field/name :fieldthree}]
                                        :group/subgroups  [{:group/id 6
                                                            :group/type :section
                                                            :group/fields [{:field/id 7
                                                                            :field/name :fieldfour}]}]}]}})
</pre>

I’d like to approach simple transforms like “move the map identified by <code>:field/id 3</code> after the one identified by <code>:field/id 4</code>” (which I can do with a srange/reverse, etc) as well as more arbitrarily complex ones like “move the map identified by <code>:field/id 3</code> after the one identified by <code>:field/id 7</code>” in a consistent manner</z><z id="t1509459357" t="nathanmarz @eoliphant you can do this with a helper path that navigates you to a zipper pointing to the desired node"><y>#</y><d>2017-10-31</d><h>14:15</h><w>nathanmarz</w>@eoliphant you can do this with a helper path that navigates you to a zipper pointing to the desired node</z><z id="t1509459365" t="nathanmarz (point-to 3)"><y>#</y><d>2017-10-31</d><h>14:16</h><w>nathanmarz</w><code>(point-to 3)</code></z><z id="t1509459393" t="nathanmarz then you could do (select-any [(point-to 3) zip/NODE] fakeform) to get the value for 3"><y>#</y><d>2017-10-31</d><h>14:16</h><w>nathanmarz</w>then you could do <code>(select-any [(point-to 3) zip/NODE] fakeform)</code> to get the value for 3</z><z id="t1509459414" t="nathanmarz (setval [(point-to 3) zip/NODE-SEQ] [] fakeform) to remove 3"><y>#</y><d>2017-10-31</d><h>14:16</h><w>nathanmarz</w><code>(setval [(point-to 3) zip/NODE-SEQ] [] fakeform)</code> to remove 3</z><z id="t1509459470" t="nathanmarz and (setval [(point-to 7] zip/INNER-RIGHT] [value-for-3] fakeform) to finish the move"><y>#</y><d>2017-10-31</d><h>14:17</h><w>nathanmarz</w>and <code>(setval [(point-to 7] zip/INNER-RIGHT] [value-for-3] fakeform)</code> to finish the move</z><z id="t1509459492" t="nathanmarz actually you could combine the retrieval of 3&apos;s value with removal using replace-in"><y>#</y><d>2017-10-31</d><h>14:18</h><w>nathanmarz</w>actually you could combine the retrieval of 3&apos;s value with removal using <code>replace-in</code></z><z id="t1509459527" t="nathanmarz https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers"><y>#</y><d>2017-10-31</d><h>14:18</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers" target="_blank">https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers</a></z><z id="t1509459532" t="eoliphant Ok will give that a shot, so point-to will be my recursive-path based helper?"><y>#</y><d>2017-10-31</d><h>14:18</h><w>eoliphant</w>Ok will give that a shot, so <code>point-to</code> will be my recursive-path based helper?</z><z id="t1509459568" t="nathanmarz yes"><y>#</y><d>2017-10-31</d><h>14:19</h><w>nathanmarz</w>yes</z><z id="t1509459579" t="eoliphant gotcha, will play around with it"><y>#</y><d>2017-10-31</d><h>14:19</h><w>eoliphant</w>gotcha, will play around with it</z><z id="t1509459592" t="eoliphant thanks!"><y>#</y><d>2017-10-31</d><h>14:19</h><w>eoliphant</w>thanks!</z><z id="t1509634906" t="borkdude Hmm, why does this print tuples instead of single values? (setval [ALL #_(multi-path :target/source ) :target/neighbours ALL first (fn [v] (println “is this the first?” v) v) (pred #{“medline”})] NONE [{:target/source “not” :target/neighbours [[“medline” 1] [“not 2”]]} {:target/source “medline” :target/neighbours [[“medline” 1] [“not 2&quot;]]} {:target/source “medline” :target/neighbours [[“medline” 1] [“not 2”]]} ]) "><y>#</y><d>2017-11-02</d><h>15:01</h><w>borkdude</w>Hmm, why does this print tuples instead of single values?
<pre>(setval
   [ALL
    #_(multi-path :target/source )
    :target/neighbours ALL first (fn [v]
                                   (println “is this the first?” v)
                                   v)
    (pred #{“medline”})]
   NONE
   [{:target/source “not” :target/neighbours [[“medline” 1] [“not 2”]]}
    {:target/source “medline” :target/neighbours [[“medline” 1] [“not 2&quot;]]}
    {:target/source “medline” :target/neighbours [[“medline” 1] [“not 2”]]}
    ])
</pre></z><z id="t1509634992" t="borkdude ALL (every map value), :target/neighbours (vector of tuples), ALL (every tuple), first … oh I see"><y>#</y><d>2017-11-02</d><h>15:03</h><w>borkdude</w><code>ALL</code> (every map value), <code>:target/neighbours</code> (vector of tuples), <code>ALL</code> (every tuple), <code>first</code> … oh I see</z><z id="t1509635012" t="borkdude first is acting as a predicate?"><y>#</y><d>2017-11-02</d><h>15:03</h><w>borkdude</w><code>first</code> is acting as a predicate?</z><z id="t1509635226" t="borkdude ah, FIRST , doh…"><y>#</y><d>2017-11-02</d><h>15:07</h><w>borkdude</w>ah, <code>FIRST</code>, doh…</z><z id="t1509637128" t="borkdude I have trouble writing this in specter: ;; only x and y are allowed [{:name &quot;x&quot; :rels [&quot;x&quot; &quot;y&quot;]} ;=&gt; fine, keep as is {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot; &quot;z&quot;]} ;=&gt; keep only allowed rels: {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot;]} {:name &quot;y&quot; :rels [&quot;z&quot;]} ;=&gt; no allowed rels, remove map completely {:name &quot;z&quot; :rels [&quot;x&quot; &quot;y&quot;]}] ;=&gt; disallowed name, remove completely ;;=&gt; [{:name &quot;x&quot; :rels [&quot;x&quot; &quot;y&quot;]} {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot;]}] as a single setval using multi-path and not-selected? . I know it must be possible…"><y>#</y><d>2017-11-02</d><h>15:38</h><w>borkdude</w>I have trouble writing this in specter:
<pre>;; only x and y are allowed
  [{:name &quot;x&quot; :rels [&quot;x&quot; &quot;y&quot;]} ;=&gt; fine, keep as is
   {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot; &quot;z&quot;]} ;=&gt; keep only allowed rels: {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot;]}
   {:name &quot;y&quot; :rels [&quot;z&quot;]} ;=&gt; no allowed rels, remove map completely
   {:name &quot;z&quot; :rels [&quot;x&quot; &quot;y&quot;]}] ;=&gt; disallowed name, remove completely
  ;;=&gt;
  [{:name &quot;x&quot; :rels [&quot;x&quot; &quot;y&quot;]}
   {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot;]}]
  </pre>
as a single <code>setval</code> using <code>multi-path</code> and <code>not-selected?</code>. I know it must be possible…</z><z id="t1509637583" t="nathanmarz @borkdude (setval [ALL (transformed [:rels ALL (pred (complement #{&quot;x&quot; &quot;y&quot;}))] (fn [_] NONE)) (selected? (multi-path (not-selected? :name #{&quot;x&quot; &quot;y&quot;}) (not-selected? :rels ALL #{&quot;x&quot; &quot;y&quot;}))) ] NONE data) "><y>#</y><d>2017-11-02</d><h>15:46</h><w>nathanmarz</w>@borkdude 
<pre>(setval [ALL
         (transformed [:rels ALL (pred (complement #{&quot;x&quot; &quot;y&quot;}))] (fn [_] NONE))
         (selected?
          (multi-path
            (not-selected? :name #{&quot;x&quot; &quot;y&quot;})
            (not-selected? :rels ALL #{&quot;x&quot; &quot;y&quot;})))
         ]
  NONE
  data)
</pre></z><z id="t1509637679" t="nathanmarz you can also do (setval [ALL (transformed [:rels ALL (pred (complement #{&quot;x&quot; &quot;y&quot;}))] (fn [_] NONE)) (selected? (multi-path (not-selected? :name #{&quot;x&quot; &quot;y&quot;}) [:rels empty?])) ] NONE data) "><y>#</y><d>2017-11-02</d><h>15:47</h><w>nathanmarz</w>you can also do
<pre>(setval [ALL
         (transformed [:rels ALL (pred (complement #{&quot;x&quot; &quot;y&quot;}))] (fn [_] NONE))
         (selected?
          (multi-path
            (not-selected? :name #{&quot;x&quot; &quot;y&quot;})
            [:rels empty?]))
         ]
  NONE
  data)
</pre></z><z id="t1509637963" t="borkdude cool, cool, thanks!"><y>#</y><d>2017-11-02</d><h>15:52</h><w>borkdude</w>cool, cool, thanks!</z><z id="t1509638300" t="nathanmarz @borkdude looking at it again you don&apos;t need the transformed : (setval [ALL (multi-path [:rels ALL (pred (complement #{&quot;x&quot; &quot;y&quot;}))] (selected? (multi-path (not-selected? :name #{&quot;x&quot; &quot;y&quot;}) [:rels empty?])))] NONE data) "><y>#</y><d>2017-11-02</d><h>15:58</h><w>nathanmarz</w>@borkdude looking at it again you don&apos;t need the <code>transformed</code>:
<pre>(setval [ALL
         (multi-path
          [:rels ALL (pred (complement #{&quot;x&quot; &quot;y&quot;}))]
          (selected?
           (multi-path
             (not-selected? :name #{&quot;x&quot; &quot;y&quot;})
             [:rels empty?])))]
  NONE
  data)
</pre></z><z id="t1509638357" t="borkdude ah, that one makes even more sense"><y>#</y><d>2017-11-02</d><h>15:59</h><w>borkdude</w>ah, that one makes even more sense</z><z id="t1509638532" t="borkdude More readable too. Wasn’t familiar with transformed yet"><y>#</y><d>2017-11-02</d><h>16:02</h><w>borkdude</w>More readable too. Wasn’t familiar with <code>transformed</code> yet</z><z id="t1509638760" t="borkdude Eh, wait, I didn’t know complement exists either, I always do comp not f 🙂"><y>#</y><d>2017-11-02</d><h>16:06</h><w>borkdude</w>Eh, wait, I didn’t know <code>complement</code> exists either, I always do <code>comp not f</code> <b>🙂</b></z><z id="t1509638791" t="nathanmarz transformed has same semantics as view , useful when doing multiple distinct transforms in one traversal"><y>#</y><d>2017-11-02</d><h>16:06</h><w>nathanmarz</w><code>transformed</code> has same semantics as <code>view</code>, useful when doing multiple distinct transforms in one traversal</z><z id="t1509638842" t="nathanmarz or for manipulating the results of a select in one go"><y>#</y><d>2017-11-02</d><h>16:07</h><w>nathanmarz</w>or for manipulating the results of a <code>select</code> in one go</z><z id="t1509642526" t="borkdude @nathanmarz Does this make sense? I mean the pred thing in the let . I’m not really sure when to wrap a function in pred . (defn keep-allowed-relations [user-profile relations] (let [disallowed? (pred #(not (allowed-source? user-profile %)))] (setval [ALL (multi-path [:target/neighbours ALL (selected? FIRST disallowed?)] (selected? (multi-path [:target/neighbours empty?] (selected? :target/source disallowed?) )))] NONE relations))) "><y>#</y><d>2017-11-02</d><h>17:08</h><w>borkdude</w>@nathanmarz Does this make sense? I mean the <code>pred</code> thing in the <code>let</code>. I’m not really sure when to wrap a function in <code>pred</code>.

<pre>(defn keep-allowed-relations [user-profile relations]
  (let [disallowed? (pred #(not (allowed-source? user-profile %)))]
    (setval
     [ALL
      (multi-path
       [:target/neighbours ALL
        (selected? FIRST
                   disallowed?)]
       (selected?
        (multi-path
         [:target/neighbours empty?]
         (selected? :target/source disallowed?)
         )))]
     NONE
     relations)))
</pre></z><z id="t1509642528" t="borkdude but it works"><y>#</y><d>2017-11-02</d><h>17:08</h><w>borkdude</w>but it works</z><z id="t1509642734" t="borkdude little simplification: (setval [ALL (multi-path [:target/neighbours ALL (selected? FIRST disallowed?)] (selected? (multi-path [:target/neighbours empty?] [:target/source disallowed?] )))] NONE relations))) "><y>#</y><d>2017-11-02</d><h>17:12</h><w>borkdude</w>little simplification:
<pre>(setval
     [ALL
      (multi-path
       [:target/neighbours ALL
        (selected? FIRST
                   disallowed?)]
       (selected?
        (multi-path
         [:target/neighbours empty?]
         [:target/source disallowed?]
         )))]
     NONE
     relations)))
</pre></z><z id="t1509642873" t="borkdude This is what I meant with, it must be possible with only selected? and multi-path 🙂"><y>#</y><d>2017-11-02</d><h>17:14</h><w>borkdude</w>This is what I meant with, it must be possible with only <code>selected?</code> and <code>multi-path</code> <b>🙂</b></z><z id="t1509643023" t="borkdude (my data looks a little different, hence the variation with FIRST )"><y>#</y><d>2017-11-02</d><h>17:17</h><w>borkdude</w>(my data looks a little different, hence the variation with <code>FIRST</code>)</z><z id="t1509645203" t="nathanmarz @borkdude that&apos;s fine though it will be slightly more efficient to use pred in the path declaration rather than outside it"><y>#</y><d>2017-11-02</d><h>17:53</h><w>nathanmarz</w>@borkdude that&apos;s fine though it will be slightly more efficient to use <code>pred</code> in the path declaration rather than outside it</z><z id="t1509645231" t="nathanmarz that way specter knows statically it&apos;s a compiled navigator and doesn&apos;t have to do an instance? check at runtime"><y>#</y><d>2017-11-02</d><h>17:53</h><w>nathanmarz</w>that way specter knows statically it&apos;s a compiled navigator and doesn&apos;t have to do an <code>instance?</code> check at runtime</z><z id="t1509645236" t="nathanmarz but that&apos;s not a big deal"><y>#</y><d>2017-11-02</d><h>17:53</h><w>nathanmarz</w>but that&apos;s not a big deal</z><z id="t1509645272" t="nathanmarz wrapping with pred in the let is much better than not, in which case specter would have to do a protocol invocation to convert function -&gt; navigator every time that callsite is invoked"><y>#</y><d>2017-11-02</d><h>17:54</h><w>nathanmarz</w>wrapping with <code>pred</code> in the <code>let</code> is much better than not, in which case specter would have to do a protocol invocation to convert function -&gt; navigator every time that callsite is invoked</z><z id="t1509722833" t="borkdude So, this works: (def data ;; only x and y are allowed [{:name &quot;x&quot; :rels [&quot;x&quot; &quot;y&quot;]} ;=&gt; fine, keep as is {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot; &quot;z&quot;]} ;=&gt; keep only allowed rels: {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot;]} {:name &quot;y&quot; :rels [&quot;z&quot;]} ;=&gt; no allowed rels, remove map completely {:name &quot;z&quot; :rels [&quot;x&quot; &quot;y&quot;]}] ;=&gt; disallowed name, remove completely ) (def disallowed? (complement #{&quot;x&quot; &quot;y&quot;})) (setval [ALL (multi-path [:rels ALL (pred disallowed?)] (selected? (multi-path [:rels empty?] [:name (pred disallowed?)])))] NONE data) I was wondering if it’s possible to first express [:name (pred disallowed?)] , since it might be cheaper to look at the name first. Then it doesn’t have to process the :rels . E.g. (setval [ALL (multi-path (selected? :name disallowed?) [:rels ALL disallowed?] (selected? :rels empty?))] NONE data) But this triggers a ClassCastException probably because NONE is treated as a map or something."><y>#</y><d>2017-11-03</d><h>15:27</h><w>borkdude</w>So, this works:
<pre>(def data ;; only x and y are allowed
  [{:name &quot;x&quot; :rels [&quot;x&quot; &quot;y&quot;]} ;=&gt; fine, keep as is
   {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot; &quot;z&quot;]} ;=&gt; keep only allowed rels: {:name &quot;y&quot; :rels [&quot;x&quot; &quot;y&quot;]}
   {:name &quot;y&quot; :rels [&quot;z&quot;]} ;=&gt; no allowed rels, remove map completely
   {:name &quot;z&quot; :rels [&quot;x&quot; &quot;y&quot;]}] ;=&gt; disallowed name, remove completely
  )

(def disallowed? (complement #{&quot;x&quot; &quot;y&quot;}))

(setval
 [ALL
  (multi-path
   [:rels ALL
    (pred disallowed?)]
   (selected?
    (multi-path
     [:rels empty?]
     [:name (pred disallowed?)])))]
 NONE
 data)
</pre>
I was wondering if it’s possible to first express <code>[:name (pred disallowed?)]</code>, since it might be cheaper to look at the name first. Then it doesn’t have to process the <code>:rels</code>. E.g.
<pre>(setval
 [ALL
  (multi-path
   (selected? :name disallowed?)
   [:rels ALL disallowed?]
   (selected? :rels empty?))]
 NONE
 data)
</pre>
But this triggers a <code>ClassCastException</code> probably because <code>NONE</code> is treated as a map or something.</z><z id="t1509722984" t="borkdude When I replace NONE with {} it kind of works. Maybe Specter paths should be able to play nicely with NONE ?"><y>#</y><d>2017-11-03</d><h>15:29</h><w>borkdude</w>When I replace <code>NONE</code> with <code>{}</code> it kind of works. Maybe Specter paths should be able to play nicely with <code>NONE</code>?</z><z id="t1509723160" t="borkdude This works: (setval [ALL (multi-path (selected? :name disallowed?) [#(not= NONE %) :rels ALL disallowed?] (selected? #(not= NONE %) :rels empty?))] NONE data) "><y>#</y><d>2017-11-03</d><h>15:32</h><w>borkdude</w>This works:
<pre>(setval
 [ALL
  (multi-path
   (selected? :name disallowed?)
   [#(not= NONE %) :rels ALL disallowed?]
   (selected? #(not= NONE %) :rels empty?))]
 NONE
 data)
</pre></z><z id="t1509723237" t="borkdude (defn SOME? [x] (not= NONE x)) (setval [ALL (multi-path (selected? :name disallowed?) [(pred SOME?) :rels ALL disallowed?] (selected? (pred SOME?) :rels empty?))] NONE data) "><y>#</y><d>2017-11-03</d><h>15:33</h><w>borkdude</w><pre>(defn SOME? [x]
  (not= NONE x))

(setval
 [ALL
  (multi-path
   (selected? :name disallowed?)
   [(pred SOME?) :rels ALL disallowed?]
   (selected? (pred SOME?) :rels empty?))]
 NONE
 data)
</pre></z><z id="t1509723357" t="borkdude I quite like the last solution. It almost reads literally like my requirement: - drop when the name is disallowed - drop all :rels that are disallowed - drop when no :rels are left"><y>#</y><d>2017-11-03</d><h>15:35</h><w>borkdude</w>I quite like the last solution. It almost reads literally like my requirement:
- drop when the name is disallowed
- drop all <code>:rels</code> that are disallowed
- drop when no <code>:rels</code> are left</z><z id="t1509724184" t="nathanmarz when you remove an element from a sequence, then future navigation in the same path will start at NONE"><y>#</y><d>2017-11-03</d><h>15:49</h><w>nathanmarz</w>when you remove an element from a sequence, then future navigation in the same path will start at <code>NONE</code></z><z id="t1509724216" t="nathanmarz that&apos;s the correct behavior from Specter, and getting a ClassCastException is expected and desired"><y>#</y><d>2017-11-03</d><h>15:50</h><w>nathanmarz</w>that&apos;s the correct behavior from Specter, and getting a ClassCastException is expected and desired</z><z id="t1509724243" t="nathanmarz that solution with SOME? is fine"><y>#</y><d>2017-11-03</d><h>15:50</h><w>nathanmarz</w>that solution with <code>SOME?</code> is fine</z><z id="t1509724252" t="nathanmarz you don&apos;t need the pred around SOME?"><y>#</y><d>2017-11-03</d><h>15:50</h><w>nathanmarz</w>you don&apos;t need the <code>pred</code> around <code>SOME?</code></z><z id="t1509724258" t="nathanmarz but you should have it around disallowed?"><y>#</y><d>2017-11-03</d><h>15:50</h><w>nathanmarz</w>but you should have it around <code>disallowed?</code></z><z id="t1509724268" t="nathanmarz or define disallowed? as (pred (complement ...))"><y>#</y><d>2017-11-03</d><h>15:51</h><w>nathanmarz</w>or define <code>disallowed?</code> as <code>(pred (complement ...))</code></z><z id="t1509724291" t="borkdude I’m not sure why it’s desired? Navigating to NONE could semantically be treated as a dead end?"><y>#</y><d>2017-11-03</d><h>15:51</h><w>borkdude</w>I’m not sure why it’s desired? Navigating to <code>NONE</code> could semantically be treated as a dead end?</z><z id="t1509724308" t="nathanmarz actually nvm, you don&apos;t need it around disallowed? since it&apos;s defined globally"><y>#</y><d>2017-11-03</d><h>15:51</h><w>nathanmarz</w>actually nvm, you don&apos;t need it around <code>disallowed?</code> since it&apos;s defined globally</z><z id="t1509724355" t="nathanmarz the element in the sequence was removed, so it&apos;s navigated to the &quot;void&quot;, represented consistently in Specter as NONE"><y>#</y><d>2017-11-03</d><h>15:52</h><w>nathanmarz</w>the element in the sequence was removed, so it&apos;s navigated to the &quot;void&quot;, represented consistently in Specter as <code>NONE</code></z><z id="t1509724364" t="borkdude well, in my ‘real’ code, disallowed is not able to be defined globally, but that’s why I wrapped it in a pred in the let. Now I don’t understand why I don’t need the pred around SOME? , because it’s a global?"><y>#</y><d>2017-11-03</d><h>15:52</h><w>borkdude</w>well, in my ‘real’ code, disallowed is not able to be defined globally, but that’s why I wrapped it in a <code>pred</code> in the let. Now I don’t understand why I don’t need the <code>pred</code> around <code>SOME?</code>, because it’s a global?</z><z id="t1509724381" t="nathanmarz multi-path always executes every subpath in order"><y>#</y><d>2017-11-03</d><h>15:53</h><w>nathanmarz</w><code>multi-path</code> always executes every subpath in order</z><z id="t1509724389" t="nathanmarz SOME? is statically known to be a function"><y>#</y><d>2017-11-03</d><h>15:53</h><w>nathanmarz</w><code>SOME?</code> is statically known to be a function</z><z id="t1509724400" t="nathanmarz so specter can figure that out at &quot;compile-time&quot;"><y>#</y><d>2017-11-03</d><h>15:53</h><w>nathanmarz</w>so specter can figure that out at &quot;compile-time&quot;</z><z id="t1509724403" t="borkdude ok, so Specter intentionally allows navigating to NONE, so the user can do something with this?"><y>#</y><d>2017-11-03</d><h>15:53</h><w>borkdude</w>ok, so Specter intentionally allows navigating to NONE, so the user can do something with this?</z><z id="t1509724423" t="nathanmarz AFTER-ELEM and BEFORE-ELEM navigate to NONE"><y>#</y><d>2017-11-03</d><h>15:53</h><w>nathanmarz</w><code>AFTER-ELEM</code> and <code>BEFORE-ELEM</code> navigate to <code>NONE</code></z><z id="t1509724449" t="borkdude cool! so maybe Specter could use a primitive like SOME?"><y>#</y><d>2017-11-03</d><h>15:54</h><w>borkdude</w>cool! so maybe Specter could use a primitive like <code>SOME?</code></z><z id="t1509724467" t="borkdude I’m fine with my own for now"><y>#</y><d>2017-11-03</d><h>15:54</h><w>borkdude</w>I’m fine with my own for now</z><z id="t1509724497" t="nathanmarz needing that function is very esoteric"><y>#</y><d>2017-11-03</d><h>15:54</h><w>nathanmarz</w>needing that function is very esoteric</z><z id="t1509724525" t="nathanmarz btw a better way to implement it is (defn SOME? [v] (not (identical? NONE v)))"><y>#</y><d>2017-11-03</d><h>15:55</h><w>nathanmarz</w>btw a better way to implement it is <code>(defn SOME? [v] (not (identical? NONE v)))</code></z><z id="t1509724570" t="borkdude because eventually = will dispatch to that anyway"><y>#</y><d>2017-11-03</d><h>15:56</h><w>borkdude</w>because eventually <code>=</code> will dispatch to that anyway</z><z id="t1509724642" t="nathanmarz yea, avoids some overhead"><y>#</y><d>2017-11-03</d><h>15:57</h><w>nathanmarz</w>yea, avoids some overhead</z><z id="t1509724742" t="borkdude cool, I learned something 🙂"><y>#</y><d>2017-11-03</d><h>15:59</h><w>borkdude</w>cool, I learned something <b>🙂</b></z><z id="t1509725350" t="borkdude Hack which makes SOME? obsolete: (alter-var-root #&apos;com.rpl.specter.impl/NONE (fn [_] {})) (setval [ALL (multi-path (selected? :name disallowed?) [:rels ALL disallowed?] (selected? :rels empty?))] NONE data) "><y>#</y><d>2017-11-03</d><h>16:09</h><w>borkdude</w>Hack which makes <code>SOME?</code> obsolete:
<pre>(alter-var-root #&apos;com.rpl.specter.impl/NONE (fn [_] {}))

(setval
 [ALL
  (multi-path
   (selected? :name disallowed?)
   [:rels ALL disallowed?]
   (selected? :rels empty?))]
 NONE
 data)
</pre></z><z id="t1509725472" t="borkdude AFTER-ELEM and BEFORE-ELEM still work"><y>#</y><d>2017-11-03</d><h>16:11</h><w>borkdude</w><code>AFTER-ELEM</code> and <code>BEFORE-ELEM</code> still work</z><z id="t1509725611" t="borkdude hmm, but this is going to break other stuff probably, because it seems that Clojure uses a singleton object for representing the empty hash-map"><y>#</y><d>2017-11-03</d><h>16:13</h><w>borkdude</w>hmm, but this is going to break other stuff probably, because it seems that Clojure uses a singleton object for representing the empty hash-map</z><z id="t1509725643" t="borkdude (identical? (hash-map) (hash-map)) ;;=&gt; true"><y>#</y><d>2017-11-03</d><h>16:14</h><w>borkdude</w><code>(identical? (hash-map) (hash-map)) ;;=&gt; true</code></z><z id="t1509725666" t="nathanmarz yea lol"><y>#</y><d>2017-11-03</d><h>16:14</h><w>nathanmarz</w>yea lol</z><z id="t1509725727" t="nathanmarz becomes very hard to set values to empty maps"><y>#</y><d>2017-11-03</d><h>16:15</h><w>nathanmarz</w>becomes very hard to set values to empty maps</z><z id="t1509725892" t="borkdude This could work though: (def my-NONE {::NONE true}) (alter-var-root #&apos;com.rpl.specter.impl/NONE (fn [_] my-NONE)) (defn SOME? [x] (not (identical? NONE x))) ;; no SOME? needed (setval [ALL (multi-path (selected? :name disallowed?) [:rels ALL disallowed?] (selected? :rels empty?))] NONE data) (setval AFTER-ELEM 3 [1 2]) (setval BEFORE-ELEM 3 [1 2]) since (identical? {::NONE true} {::NONE true}) ;;=&gt; false"><y>#</y><d>2017-11-03</d><h>16:18</h><w>borkdude</w>This could work though:
<pre>(def my-NONE {::NONE true})
(alter-var-root #&apos;com.rpl.specter.impl/NONE (fn [_] my-NONE))

(defn SOME? [x]
  (not (identical? NONE x)))

;; no SOME? needed

(setval
 [ALL
  (multi-path
   (selected? :name disallowed?)
   [:rels ALL disallowed?]
   (selected? :rels empty?))]
 NONE
 data)

(setval AFTER-ELEM 3 [1 2])
(setval BEFORE-ELEM 3 [1 2])
</pre>
since <code>(identical? {::NONE true} {::NONE true}) ;;=&gt; false</code></z><z id="t1509726364" t="borkdude Don’t know if there is anything against changing this implementation detail?"><y>#</y><d>2017-11-03</d><h>16:26</h><w>borkdude</w>Don’t know if there is anything against changing this implementation detail?</z><z id="t1509726372" t="borkdude Could make life with NONE somewhat easier"><y>#</y><d>2017-11-03</d><h>16:26</h><w>borkdude</w>Could make life with NONE somewhat easier</z><z id="t1509727476" t="nathanmarz no, it&apos;s better to error when trying to navigate on NONE"><y>#</y><d>2017-11-03</d><h>16:44</h><w>nathanmarz</w>no, it&apos;s better to error when trying to navigate on <code>NONE</code></z><z id="t1509727580" t="nathanmarz this code makes NONE magically &quot;work&quot; for map navigators"><y>#</y><d>2017-11-03</d><h>16:46</h><w>nathanmarz</w>this code makes <code>NONE</code> magically &quot;work&quot; for map navigators</z><z id="t1509727591" t="nathanmarz but it will still fail for all the other navigators"><y>#</y><d>2017-11-03</d><h>16:46</h><w>nathanmarz</w>but it will still fail for all the other navigators</z><z id="t1509727670" t="nathanmarz better to handle it explicitly in code like this"><y>#</y><d>2017-11-03</d><h>16:47</h><w>nathanmarz</w>better to handle it explicitly in code like this</z><z id="t1509727687" t="borkdude ok"><y>#</y><d>2017-11-03</d><h>16:48</h><w>borkdude</w>ok</z><z id="t1509727729" t="borkdude Looking at the vanilla Clojure (which I didn’t write prior to writing Specter), it’s comparable length wise: https://gist.github.com/borkdude/5f9a4ae710217e893a9462ff90b6cac3#file-specter-clj-L20"><y>#</y><d>2017-11-03</d><h>16:48</h><w>borkdude</w>Looking at the vanilla Clojure (which I didn’t write prior to writing Specter), it’s comparable length wise:
<a href="https://gist.github.com/borkdude/5f9a4ae710217e893a9462ff90b6cac3#file-specter-clj-L20" target="_blank">https://gist.github.com/borkdude/5f9a4ae710217e893a9462ff90b6cac3#file-specter-clj-L20</a></z><z id="t1509727838" t="nathanmarz it changes all the vectors to seqs"><y>#</y><d>2017-11-03</d><h>16:50</h><w>nathanmarz</w>it changes all the vectors to seqs</z><z id="t1509727856" t="borkdude true. in this case I didn’t need the vectors much longer as it went out as JSON anyway"><y>#</y><d>2017-11-03</d><h>16:50</h><w>borkdude</w>true. in this case I didn’t need the vectors much longer as it went out as JSON anyway</z><z id="t1509727950" t="nathanmarz length isn&apos;t always the best metric of code quality"><y>#</y><d>2017-11-03</d><h>16:52</h><w>nathanmarz</w>length isn&apos;t always the best metric of code quality</z><z id="t1509727976" t="nathanmarz besides maintaining types, I find the Specter version far more readable"><y>#</y><d>2017-11-03</d><h>16:52</h><w>nathanmarz</w>besides maintaining types, I find the Specter version far more readable</z><z id="t1509727994" t="nathanmarz pretty much read left to right instead of having lots of nested expressions"><y>#</y><d>2017-11-03</d><h>16:53</h><w>nathanmarz</w>pretty much read left to right instead of having lots of nested expressions</z><z id="t1509728596" t="borkdude Running a poll… 🙂 https://twitter.com/borkdude/status/926493766441226240"><y>#</y><d>2017-11-03</d><h>17:03</h><w>borkdude</w>Running a poll… <b>🙂</b> <a href="https://twitter.com/borkdude/status/926493766441226240" target="_blank">https://twitter.com/borkdude/status/926493766441226240</a></z><z id="t1509729531" t="borkdude The Clojure version appears to be twice as fast (running 100k times with time, keep wrapped in doall , I know, not a robust profiling tool, but still?)"><y>#</y><d>2017-11-03</d><h>17:18</h><w>borkdude</w>The Clojure version appears to be twice as fast (running 100k times with time, <code>keep</code> wrapped in <code>doall</code>, I know, not a robust profiling tool, but still?)</z><z id="t1509729640" t="borkdude Around 200ms for Clojure and 400ms for Specter"><y>#</y><d>2017-11-03</d><h>17:20</h><w>borkdude</w>Around 200ms for Clojure and 400ms for Specter</z><z id="t1509729770" t="nathanmarz there&apos;s probably a bunch of micro-optimizations that can be done"><y>#</y><d>2017-11-03</d><h>17:22</h><w>nathanmarz</w>there&apos;s probably a bunch of micro-optimizations that can be done</z><z id="t1509729850" t="nathanmarz empty? is slow on vectors"><y>#</y><d>2017-11-03</d><h>17:24</h><w>nathanmarz</w><code>empty?</code> is slow on vectors</z><z id="t1509729880" t="borkdude Could try seq"><y>#</y><d>2017-11-03</d><h>17:24</h><w>borkdude</w>Could try <code>seq</code></z><z id="t1509729881" t="nathanmarz #(= 0 (.length ^IPersistentVector v)) is fastest way I&apos;ve found"><y>#</y><d>2017-11-03</d><h>17:24</h><w>nathanmarz</w>#(= 0 (.length ^IPersistentVector v)) is fastest way I&apos;ve found</z><z id="t1509729895" t="borkdude oh no wait, that’s the opposite 😛"><y>#</y><d>2017-11-03</d><h>17:24</h><w>borkdude</w>oh no wait, that’s the opposite <b>😛</b></z><z id="t1509729902" t="borkdude ok"><y>#</y><d>2017-11-03</d><h>17:25</h><w>borkdude</w>ok</z><z id="t1509729942" t="nathanmarz can also change to: (setval [ALL (if-path (selected? :name disallowed?) STAY (multi-path [:rels ALL disallowed?] (selected? :rels empty?)))] NONE data) "><y>#</y><d>2017-11-03</d><h>17:25</h><w>nathanmarz</w>can also change to:
<pre>(setval
 [ALL
  (if-path (selected? :name disallowed?)
   STAY
   (multi-path
    [:rels ALL disallowed?]
    (selected? :rels empty?)))]
 NONE
 data)
</pre></z><z id="t1509729953" t="nathanmarz so it stops doing work after removing on first condition"><y>#</y><d>2017-11-03</d><h>17:25</h><w>nathanmarz</w>so it stops doing work after removing on first condition</z><z id="t1509729979" t="borkdude ah"><y>#</y><d>2017-11-03</d><h>17:26</h><w>borkdude</w>ah</z><z id="t1509730003" t="nathanmarz #(-&gt; % :name disallowed?) might be faster"><y>#</y><d>2017-11-03</d><h>17:26</h><w>nathanmarz</w><code>#(-&gt; % :name disallowed?)</code> might be faster</z><z id="t1509730084" t="nathanmarz same with #(-&gt; % :rels empty?)"><y>#</y><d>2017-11-03</d><h>17:28</h><w>nathanmarz</w>same with <code>#(-&gt; % :rels empty?)</code></z><z id="t1509730186" t="borkdude (def my-empty? (fn [v] (= 0 (.length ^clojure.lang.IPersistentVector v)))) (time (dotimes [i 100000] (setval [ALL (if-path #(-&gt; % :name disallowed?) STAY (multi-path [:rels ALL disallowed?] #(-&gt; % :rels my-empty?)))] NONE data))) Shaves off roughly 80ms"><y>#</y><d>2017-11-03</d><h>17:29</h><w>borkdude</w><pre>(def my-empty? (fn [v] (= 0 (.length ^clojure.lang.IPersistentVector v))))

(time
 (dotimes [i 100000]
   (setval
    [ALL
     (if-path #(-&gt; % :name disallowed?)
              STAY
              (multi-path
               [:rels ALL disallowed?]
               #(-&gt; % :rels my-empty?)))]
    NONE
    data)))
</pre>
Shaves off roughly 80ms</z><z id="t1509730364" t="nathanmarz since specter version maintains types and clojure version constructs a different type, it&apos;s hard to say how much of difference comes from that"><y>#</y><d>2017-11-03</d><h>17:32</h><w>nathanmarz</w>since specter version maintains types and clojure version constructs a different type, it&apos;s hard to say how much of difference comes from that</z><z id="t1509732932" t="nathanmarz @borkdude the inner call to remove is also not realizing the full computation"><y>#</y><d>2017-11-03</d><h>18:15</h><w>nathanmarz</w>@borkdude the inner call to <code>remove</code> is also not realizing the full computation</z><z id="t1509732956" t="nathanmarz should wrap that in doall to make comparison fair"><y>#</y><d>2017-11-03</d><h>18:15</h><w>nathanmarz</w>should wrap that in <code>doall</code> to make comparison fair</z><z id="t1509734307" t="borkdude @nathanmarz yes, did that, yields about 20ms extra"><y>#</y><d>2017-11-03</d><h>18:38</h><w>borkdude</w>@nathanmarz yes, did that, yields about 20ms extra</z><z id="t1509735039" t="tanzoniteblack (defn vanilla [] (doall (keep (fn [m] (if-not (disallowed? (:name m)) (if-let [new-rels (doall (seq (remove disallowed? (:rels m))))] (assoc m :rels new-rels)))) data))) making this non-lazy (and measured with criterium) Evaluation count : 558918 in 6 samples of 93153 calls. Execution time mean : 1.115634 µs Execution time std-deviation : 37.921802 ns Execution time lower quantile : 1.082254 µs ( 2.5%) Execution time upper quantile : 1.172033 µs (97.5%) Overhead used : 1.603741 ns This specter version: (defn specter-v2 [] (setval [ALL (if-path #(-&gt; % :name disallowed?) STAY (multi-path [:rels ALL disallowed?] #(-&gt; % :rels empty?)))] NONE data)) also measured with criterium: Evaluation count : 344118 in 6 samples of 57353 calls. Execution time mean : 1.732753 µs Execution time std-deviation : 12.525124 ns Execution time lower quantile : 1.716643 µs ( 2.5%) Execution time upper quantile : 1.744641 µs (97.5%) Overhead used : 1.603741 ns "><y>#</y><d>2017-11-03</d><h>18:50</h><w>tanzoniteblack</w><pre>(defn vanilla []
  (doall (keep
          (fn [m]
            (if-not (disallowed? (:name m))
              (if-let [new-rels (doall (seq (remove disallowed? (:rels m))))]
                (assoc m :rels new-rels))))
          data)))</pre> making this non-lazy (and measured with criterium) <pre>Evaluation count : 558918 in 6 samples of 93153 calls.
             Execution time mean : 1.115634 µs
    Execution time std-deviation : 37.921802 ns
   Execution time lower quantile : 1.082254 µs ( 2.5%)
   Execution time upper quantile : 1.172033 µs (97.5%)
                   Overhead used : 1.603741 ns
</pre>

This specter version: <pre>(defn specter-v2 []
  (setval [ALL
           (if-path #(-&gt; % :name disallowed?)
                    STAY
                    (multi-path [:rels ALL disallowed?]
                                #(-&gt; % :rels empty?)))]
          NONE
          data))</pre> also measured with criterium: <pre>Evaluation count : 344118 in 6 samples of 57353 calls.
             Execution time mean : 1.732753 µs
    Execution time std-deviation : 12.525124 ns
   Execution time lower quantile : 1.716643 µs ( 2.5%)
   Execution time upper quantile : 1.744641 µs (97.5%)
                   Overhead used : 1.603741 ns
</pre></z><z id="t1509735081" t="tanzoniteblack so yeah...still faster with the hand-written clojure, but no where near as much as it was when factoring in the fact that one was lazy and the other not before"><y>#</y><d>2017-11-03</d><h>18:51</h><w>tanzoniteblack</w>so yeah...still faster with the hand-written clojure, but no where near as much as it was when factoring in the fact that one was lazy and the other not before</z><z id="t1509735131" t="tanzoniteblack so...meh. Unless performance is absolutely critical to you, then it&apos;s just a style preference here? And if performance is absolutely critical...then always measure very carefully whatever you&apos;re doing"><y>#</y><d>2017-11-03</d><h>18:52</h><w>tanzoniteblack</w>so...meh. Unless performance is absolutely critical to you, then it&apos;s just a style preference here? And if performance is absolutely critical...then always measure very carefully whatever you&apos;re doing</z><z id="t1509745999" t="borkdude @tanzoniteblack That criterium benchmark doesn’t draw a very different picture than what I already had"><y>#</y><d>2017-11-03</d><h>21:53</h><w>borkdude</w>@tanzoniteblack That criterium benchmark doesn’t draw a very different picture than what I already had</z><z id="t1509746065" t="borkdude I had roughly 350ms for specter, 220 for clojure (x 1.5), criterium: x 1.55"><y>#</y><d>2017-11-03</d><h>21:54</h><w>borkdude</w>I had roughly 350ms for specter, 220 for clojure (x 1.5), criterium: x 1.55</z><z id="t1509746081" t="borkdude but thanks for measuring"><y>#</y><d>2017-11-03</d><h>21:54</h><w>borkdude</w>but thanks for measuring</z><z id="t1509746096" t="tanzoniteblack 🙂 wasn&apos;t saying my numbers were different then yours, I just couldn&apos;t find hard numbers for your final versions to directly compare, so decided to play with it myself"><y>#</y><d>2017-11-03</d><h>21:54</h><w>tanzoniteblack</w><b>🙂</b> wasn&apos;t saying my numbers were different then yours, I just couldn&apos;t find hard numbers for your final versions to directly compare, so decided to play with it myself</z><z id="t1509746115" t="borkdude cool"><y>#</y><d>2017-11-03</d><h>21:55</h><w>borkdude</w>cool</z><z id="t1509746157" t="tanzoniteblack also, I didn&apos;t see much of a difference between your custom empty and directly using empty? when measured with criterium. Don&apos;t remember the exact numbers, but only like 50-100 nanoseconds difference with the different empties swapped? Something within the realm of measuring error with the final result being in microseconds, anyways"><y>#</y><d>2017-11-03</d><h>21:55</h><w>tanzoniteblack</w>also, I didn&apos;t see much of a difference between your custom empty and directly using <code>empty?</code> when measured with criterium. Don&apos;t remember the exact numbers, but only like 50-100 nanoseconds difference with the different empties swapped? Something within the realm of measuring error with the final result being in microseconds, anyways</z><z id="t1509746164" t="tanzoniteblack (just as an FYI)"><y>#</y><d>2017-11-03</d><h>21:56</h><w>tanzoniteblack</w>(just as an FYI)</z><z id="t1509746393" t="borkdude Oh look, Alex wrote a transducers version too: https://gist.github.com/borkdude/5f9a4ae710217e893a9462ff90b6cac3#gistcomment-2247156"><y>#</y><d>2017-11-03</d><h>21:59</h><w>borkdude</w>Oh look, Alex wrote a transducers version too: <a href="https://gist.github.com/borkdude/5f9a4ae710217e893a9462ff90b6cac3#gistcomment-2247156" target="_blank">https://gist.github.com/borkdude/5f9a4ae710217e893a9462ff90b6cac3#gistcomment-2247156</a></z><z id="t1509746419" t="borkdude which is also slower than the non-transducer version"><y>#</y><d>2017-11-03</d><h>22:00</h><w>borkdude</w>which is also slower than the non-transducer version</z><z id="t1510323314" t="michaelwfogleman Not sure if this has been mentioned before, but this library for string manipulation could be powerful to combine with Specter usage! https://github.com/funcool/cuerdas"><y>#</y><d>2017-11-10</d><h>14:15</h><w>michaelwfogleman</w>Not sure if this has been mentioned before, but this library for string manipulation could be powerful to combine with Specter usage! <a href="https://github.com/funcool/cuerdas" target="_blank">https://github.com/funcool/cuerdas</a></z><z id="t1510337027" t="gdeer81 Oh great, now every library is going to be the missing X library."><y>#</y><d>2017-11-10</d><h>18:03</h><w>gdeer81</w>Oh great, now every library is going to be the missing  X library.</z><z id="t1510337079" t="gdeer81 I&apos;m going to update Marginalia&apos;s tag line to say &quot;The missing clojure literate programming documentation library&quot;"><y>#</y><d>2017-11-10</d><h>18:04</h><w>gdeer81</w>I&apos;m going to update Marginalia&apos;s tag line to say &quot;The missing clojure literate programming documentation library&quot;</z><z id="t1510337758" t="gdeer81 but it does look like an interesting library. and if you had some heavily nested text, it would be a powerful combo with Specter"><y>#</y><d>2017-11-10</d><h>18:15</h><w>gdeer81</w>but it does look like an interesting library. and if you had some heavily nested text, it would be a powerful combo with Specter</z><z id="t1510400447" t="borkdude Cuerdas looks great. It has one issue with DCE in Google Closure though"><y>#</y><d>2017-11-11</d><h>11:40</h><w>borkdude</w>Cuerdas looks great. It has one issue with DCE in Google Closure though</z><z id="t1510400948" t="borkdude The issue is it adds 47kb / 19kb to your file size. Might be fine, but if you use only one or two functions…"><y>#</y><d>2017-11-11</d><h>11:49</h><w>borkdude</w>The issue is it adds 47kb / 19kb to your file size. Might be fine, but if you use only one or two functions…</z><z id="t1510580990" t="hkjels Are sorted-maps not supported?"><y>#</y><d>2017-11-13</d><h>13:49</h><w>hkjels</w>Are sorted-maps not supported?</z><z id="t1510583585" t="nathanmarz @hkjels they are... why do you ask?"><y>#</y><d>2017-11-13</d><h>14:33</h><w>nathanmarz</w>@hkjels they are... why do you ask?</z><z id="t1510589280" t="hkjels My bad. Messed up a navigator"><y>#</y><d>2017-11-13</d><h>16:08</h><w>hkjels</w>My bad. Messed up a navigator</z><z id="t1510609024" t="ul Hey folks, i&apos;m investigating options for organizing state in my client app. I want DB-like experience, but existing solutions are still not convincing, including DataScript. How do you think, is it viable to use just normalized maps and query/update them with Specter? Is it easy to emulate joins with Specter?"><y>#</y><d>2017-11-13</d><h>21:37</h><w>ul</w>Hey folks, i&apos;m investigating options for organizing state in my client app. I want DB-like experience, but existing solutions are still not convincing, including DataScript. How do you think, is it viable to use just normalized maps and query/update them with Specter? Is it easy to emulate joins with Specter?</z><z id="t1510609417" t="nathanmarz @ul joins are not in the scope of specter, but otherwise specter is very helpful for managing state"><y>#</y><d>2017-11-13</d><h>21:43</h><w>nathanmarz</w>@ul joins are not in the scope of specter, but otherwise specter is very helpful for managing state</z><z id="t1510609465" t="nathanmarz since it&apos;s so elegant to handle data structures of arbitrary complexity, it gives you the freedom to model your data in the best possible way"><y>#</y><d>2017-11-13</d><h>21:44</h><w>nathanmarz</w>since it&apos;s so elegant to handle data structures of arbitrary complexity, it gives you the freedom to model your data in the best possible way</z><z id="t1510612816" t="ul I see at least two pros on that way: 1. My data will be highly explorable outside main query mechanics (because it will stay just Clojure datastructures) 2. It will be friendly to reactive approach I use: Specter queries will fit perfectly into reactive formulas, and with proper data organization will trigger not much redundant recalculations."><y>#</y><d>2017-11-13</d><h>22:40</h><w>ul</w>I see at least two pros on that way:
1. My data will be highly explorable outside main query mechanics (because it will stay just Clojure datastructures)
2. It will be friendly to reactive approach I use: Specter queries will fit perfectly into reactive formulas, and with proper data organization will trigger not much redundant recalculations.</z><z id="t1510860282" t="nathanmarz Released Specter 1.0.5 https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><y>#</y><d>2017-11-16</d><h>19:24</h><w>nathanmarz</w>Released Specter 1.0.5 <a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md" target="_blank">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></z><z id="t1510881991" t="michaelwfogleman @nathanmarz Just curious, why did you decide against having numbers convert to index-nav?"><y>#</y><d>2017-11-17</d><h>01:26</h><w>michaelwfogleman</w>@nathanmarz Just curious, why did you decide against having numbers convert to index-nav?</z><z id="t1510885414" t="nathanmarz so that (select-any 0 {0 &quot;a&quot;}) would work"><y>#</y><d>2017-11-17</d><h>02:23</h><w>nathanmarz</w>so that <code>(select-any 0 {0 &quot;a&quot;})</code> would work</z><z id="t1510885460" t="nathanmarz it matches semantics with clojure&apos;s update-in and get-in , and it&apos;s less cases to remember for a user"><y>#</y><d>2017-11-17</d><h>02:24</h><w>nathanmarz</w>it matches semantics with clojure&apos;s <code>update-in</code> and <code>get-in</code>, and it&apos;s less cases to remember for a user</z><z id="t1510921353" t="michaelwfogleman makes sense! 🙂"><y>#</y><d>2017-11-17</d><h>12:22</h><w>michaelwfogleman</w>makes sense! <b>🙂</b></z><z id="t1510924993" t="nathanmarz @michaelwfogleman I&apos;m also considering this https://github.com/nathanmarz/specter/issues/234"><y>#</y><d>2017-11-17</d><h>13:23</h><w>nathanmarz</w>@michaelwfogleman I&apos;m also considering this <a href="https://github.com/nathanmarz/specter/issues/234" target="_blank">https://github.com/nathanmarz/specter/issues/234</a></z><z id="t1511302919" t="johanatan hi, i have a normalized map say: version -&gt; entity_1 -&gt; entity_2 and I want to transform it into: entity_1 -&gt; version -&gt; entity_2 . what is the best way to do this using specter?"><y>#</y><d>2017-11-21</d><h>22:21</h><w>johanatan</w>hi, i have a normalized map say: <code>version -&gt; entity_1 -&gt; entity_2</code> and I want to transform it into: <code>entity_1 -&gt; version -&gt; entity_2</code>. what is the best way to do this using specter?</z><z id="t1511302934" t="johanatan [this is a map of maps of maps]"><y>#</y><d>2017-11-21</d><h>22:22</h><w>johanatan</w>[this is a map of maps of maps]</z><z id="t1511303665" t="johanatan for example: input: {1 {&quot;e1&quot; {&quot;p1&quot; nil &quot;p2&quot; 9} &quot;e2&quot; {&quot;p3&quot; nil &quot;p4&quot; 6}} 2 {&quot;e1&quot; {&quot;p6&quot; nil &quot;p7&quot; nil}}} output: {&quot;e1&quot; {1 {&quot;p1&quot; nil &quot;p2&quot; 9} 2 {&quot;p6&quot; nil &quot;p7&quot; nil}} &quot;e2&quot; {1 {&quot;p3&quot; nil, &quot;p4&quot; 6}}} "><y>#</y><d>2017-11-21</d><h>22:34</h><w>johanatan</w>for example:

input:
<pre>{1 {&quot;e1&quot; {&quot;p1&quot; nil &quot;p2&quot; 9} &quot;e2&quot; {&quot;p3&quot; nil &quot;p4&quot; 6}} 2 {&quot;e1&quot; {&quot;p6&quot; nil &quot;p7&quot; nil}}}
</pre>

output:
<pre>{&quot;e1&quot; {1 {&quot;p1&quot; nil &quot;p2&quot; 9} 2 {&quot;p6&quot; nil &quot;p7&quot; nil}} &quot;e2&quot; {1 {&quot;p3&quot; nil, &quot;p4&quot; 6}}}
</pre></z><z id="t1511303962" t="nathanmarz @johanatan specter won&apos;t help that much with that since you&apos;re basically making a whole new data structure"><y>#</y><d>2017-11-21</d><h>22:39</h><w>nathanmarz</w>@johanatan specter won&apos;t help that much with that since you&apos;re basically making a whole new data structure</z><z id="t1511303996" t="nathanmarz specter is for when you&apos;re changing part of a data structure, or changing many pieces the same way within the overall structure"><y>#</y><d>2017-11-21</d><h>22:39</h><w>nathanmarz</w>specter is for when you&apos;re changing part of a data structure, or changing many pieces the same way within the overall structure</z><z id="t1511304038" t="johanatan well, i could do it with a transform/collect/map combo"><y>#</y><d>2017-11-21</d><h>22:40</h><w>johanatan</w>well, i could do it with a transform/collect/map combo</z><z id="t1511304046" t="johanatan but that isn&apos;t much better than just doing it by hand in pure clj"><y>#</y><d>2017-11-21</d><h>22:40</h><w>johanatan</w>but that isn&apos;t much better than just doing it by hand in pure clj</z><z id="t1511304188" t="johanatan but i fail to see how in principle the &quot;whole&quot; isn&apos;t just an all-encompassing &quot;part&quot;"><y>#</y><d>2017-11-21</d><h>22:43</h><w>johanatan</w>but i fail to see how in principle the &quot;whole&quot; isn&apos;t just an all-encompassing &quot;part&quot;</z><z id="t1511304227" t="johanatan i.e., with any transformation-based language (say e.g. XSLT) changing the whole is just changing like changing a part where the part == the whole"><y>#</y><d>2017-11-21</d><h>22:43</h><w>johanatan</w>i.e., with any transformation-based language (say e.g. XSLT) changing the whole is just changing like changing a part where the part == the whole</z><z id="t1511304302" t="johanatan in other words, it probably is possible with specter (and I would wager that the ultimate solution to it ends up being rather elegant once discovered) but the solution, like many (most?) in specter, is elusive and mind-bending to try to arrive at"><y>#</y><d>2017-11-21</d><h>22:45</h><w>johanatan</w>in other words, it probably is possible with specter (and I would wager that the ultimate solution to it ends up being rather elegant once discovered) but the solution, like many (most?) in specter, is elusive and mind-bending to try to arrive at</z><z id="t1511304426" t="nathanmarz I don&apos;t think there&apos;s an elegant specter solution to this"><y>#</y><d>2017-11-21</d><h>22:47</h><w>nathanmarz</w>I don&apos;t think there&apos;s an elegant specter solution to this</z><z id="t1511304445" t="nathanmarz this is a total restructuring"><y>#</y><d>2017-11-21</d><h>22:47</h><w>nathanmarz</w>this is a total restructuring</z><z id="t1511304466" t="nathanmarz that it&apos;s still a map -&gt; map -&gt; map afterwards is deceiving"><y>#</y><d>2017-11-21</d><h>22:47</h><w>nathanmarz</w>that it&apos;s still a map -&gt; map -&gt; map afterwards is deceiving</z><z id="t1511304527" t="johanatan you may be right. 🙂"><y>#</y><d>2017-11-21</d><h>22:48</h><w>johanatan</w>you may be right. <b>🙂</b></z><z id="t1511304543" t="johanatan at least i know to not spend too much time searching for it lol"><y>#</y><d>2017-11-21</d><h>22:49</h><w>johanatan</w>at least i know to not spend too much time searching for it lol</z><z id="t1511304627" t="nathanmarz it is an interesting use case"><y>#</y><d>2017-11-21</d><h>22:50</h><w>nathanmarz</w>it is an interesting use case</z><z id="t1511305725" t="johanatan this works: (apply deep-merge (for [[version events] in] (specter/transform [specter/MAP-VALS] #(do {version %}) events))) "><y>#</y><d>2017-11-21</d><h>23:08</h><w>johanatan</w>this works:
<pre>(apply deep-merge (for [[version events] in] (specter/transform [specter/MAP-VALS] #(do {version %}) events)))
</pre></z><z id="t1511305752" t="johanatan where deep-merge is defined as: (defn deep-merge [&amp; vals] (if (every? map? vals) (apply merge-with deep-merge vals) (last vals))) "><y>#</y><d>2017-11-21</d><h>23:09</h><w>johanatan</w>where <code>deep-merge</code> is defined as:
<pre>(defn deep-merge
  [&amp; vals]
  (if (every? map? vals)
    (apply merge-with deep-merge vals)
    (last vals)))
</pre></z><z id="t1511468798" t="madstap Where specter isn&apos;t that well suited for this kind of transformation, there&apos;s this cool lib I remember seeing that should be perfect. https://github.com/disalvjn/faconne"><y>#</y><d>2017-11-23</d><h>20:26</h><r>madstap</r>Where specter isn&apos;t that well suited for this kind of transformation, there&apos;s this cool lib I remember seeing that should be perfect.  <a href="https://github.com/disalvjn/faconne" target="_blank">https://github.com/disalvjn/faconne</a></z><z id="t1511468848" t="madstap The same thing in faconne (require &apos;[faconne.core :as fac]) (def f (fac/transformer {v {e1 {e2 x}}} {e1 {v {e2 x}}})) "><y>#</y><d>2017-11-23</d><h>20:27</h><r>madstap</r>The same thing in faconne
<pre>(require &apos;[faconne.core :as fac])

(def f (fac/transformer {v {e1 {e2 x}}} {e1 {v {e2 x}}}))
</pre></z><z id="t1511305792" t="johanatan That&apos;s probably about as good/elegant as can be expected..."><y>#</y><d>2017-11-21</d><h>23:09</h><w>johanatan</w>That&apos;s probably about as good/elegant as can be expected...</z><z id="t1511627751" t="benstox Hello, a very beginner question here. Say I have a data structure like this and I want to select all the foods that have 3 pieces of cheese in them: (def kitchen {:foods [{:type :sandwich :ingredients [{:type :bread :quantity 3} {:type :cheese :quantity 2} {:type :meatball :quantity 5}]} {:type :sandwich :ingredients [{:type :bread :quantity 2} {:type :cheese :quantity 3} {:type :ham :quantity 2}]} {:type :quiche :ingredients [{:type :egg :quantity 5} {:type :cheese :quantity 5}]}]}) That is, I expect to return the ham sandwich and the quiche. I understand how I could use Specter to navigate to all the quantities of cheese that are greater than 3: (select [:foods ALL :ingredients ALL #(= (:type %) :cheese) :quantity #(&gt;= % 3)] kitchen) but what I really want to do is this: (defn three-cheese-food? [food] (-&gt;&gt; food (:ingredients) (some (fn [ingredient] (and (= (:type ingredient) :cheese) (&gt;= (:quantity ingredient) 3)))))) (filter three-cheese-food? (:foods kitchen)) Can I use Specter to do the work done in my filtering and three-cheese-food? function? Thanks!"><y>#</y><d>2017-11-25</d><h>16:35</h><w>benstox</w>Hello, a very beginner question here. Say I have a data structure like this and I want to select all the foods that have 3 pieces of cheese in them:
<pre>(def kitchen {:foods [{:type :sandwich :ingredients [{:type :bread :quantity 3}
                                                     {:type :cheese :quantity 2}
                                                     {:type :meatball :quantity 5}]}
                      {:type :sandwich :ingredients [{:type :bread :quantity 2}
                                                     {:type :cheese :quantity 3}
                                                     {:type :ham :quantity 2}]}
                      {:type :quiche :ingredients [{:type :egg :quantity 5}
                                                   {:type :cheese :quantity 5}]}]})
</pre>
That is, I expect to return the ham sandwich and the quiche.
I understand how I could use Specter to navigate to all the quantities of cheese that are greater than 3:
<pre>(select [:foods ALL :ingredients ALL #(= (:type %) :cheese) :quantity #(&gt;= % 3)] kitchen)
</pre>
but what I really want to do is this:
<pre>(defn three-cheese-food? [food]
  (-&gt;&gt; food
    (:ingredients)
    (some
      (fn [ingredient]
        (and
          (= (:type ingredient) :cheese)
          (&gt;= (:quantity ingredient) 3))))))

(filter three-cheese-food? (:foods kitchen))
</pre>
Can I use Specter to do the work done in my filtering and <code>three-cheese-food?</code> function? Thanks!</z><z id="t1511630810" t="nathanmarz @benstox yes, use selected?"><y>#</y><d>2017-11-25</d><h>17:26</h><w>nathanmarz</w>@benstox yes, use <code>selected?</code></z><z id="t1511630814" t="nathanmarz (select [:foods ALL (selected? :ingredients ALL #(= :cheese (:type %)) :quantity (pred&gt;= 3))] kitchen) "><y>#</y><d>2017-11-25</d><h>17:26</h><w>nathanmarz</w><pre>(select [:foods
         ALL
         (selected? :ingredients ALL #(= :cheese (:type %)) :quantity (pred&gt;= 3))]
  kitchen)
</pre></z><z id="t1511631176" t="benstox Ah, selected? ! That was the piece I was missing. Thanks!"><y>#</y><d>2017-11-25</d><h>17:32</h><w>benstox</w>Ah, <code>selected?</code>! That was the piece I was missing. Thanks!</z><z id="t1511631503" t="benstox And the pred&gt;= too."><y>#</y><d>2017-11-25</d><h>17:38</h><w>benstox</w>And the <code>pred&gt;=</code> too.</z><z id="t1511637450" t="benstox Is there a Specter-y way to add multiple conditions to the filtering? I thought of this: (select [:foods ALL (selected? :ingredients ALL #(= :cheese (:type %)) (multi-path [:quantity (pred&gt;= 3)] [:quality (pred&gt;= 10)]))]) But this seems to act like an OR when what I want is an AND."><y>#</y><d>2017-11-25</d><h>19:17</h><w>benstox</w>Is there a Specter-y way to add multiple conditions to the filtering? I thought of this:
<pre>(select [:foods
         ALL
         (selected? :ingredients ALL #(= :cheese (:type %)) (multi-path [:quantity (pred&gt;= 3)]
                                                                        [:quality (pred&gt;= 10)]))])
</pre>
But this seems to act like an OR when what I want is an AND.</z><z id="t1511639842" t="swizzard i&apos;m having a tough time requiring specter in a lumo repl:"><y>#</y><d>2017-11-25</d><h>19:57</h><w>swizzard</w>i&apos;m having a tough time requiring specter in a lumo repl:</z><z id="t1511639844" t="swizzard cljs.user=&gt; (require &apos;[com.rpl.specter :as s :refer-macros [select transform]]) Could not require com.rpl.specter.navs in file com/rpl/specter.cljc Could not require com.rpl.specter in file com/rpl/specter/navs.cljc (new) Function.cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:1928:72) Function.cljs.analyzer.error.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:2539:92) Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5849:145) Object.cljs.js.load_macros (NO_SOURCE_FILE &lt;embedded&gt;:5883:41) (NO_SOURCE_FILE &lt;embedded&gt;:5883:374) Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5838:1) Object.cljs.js.load_macros (NO_SOURCE_FILE &lt;embedded&gt;:5883:41) (NO_SOURCE_FILE &lt;embedded&gt;:5905:316) (NO_SOURCE_FILE &lt;embedded&gt;:5918:218) Invalid regular expression: /\.js$/: Stack overflow String.replace (NO_SOURCE_FILE &lt;anonymous&gt;) Object.clojure.string.replace_all (NO_SOURCE_FILE &lt;embedded&gt;:1959:385) Object.clojure.string.replace (NO_SOURCE_FILE &lt;embedded&gt;:1962:191) (Object.cljs$stacktrace$remove_ext) (Object.cljs$stacktrace$mapped_line_column_call) (Object.cljs$stacktrace$mapped_frame) Function.&lt;anonymous&gt; (evalmachine.&lt;anonymous&gt;:512:24) Function.cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:771:157) Function.cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$2 (NO_SOURCE_FILE &lt;embedded&gt;:770:188) Function.cljs.core.apply.cljs$core$IFn$_invoke$arity$2 (NO_SOURCE_FILE &lt;embedded&gt;:783:244) "><y>#</y><d>2017-11-25</d><h>19:57</h><w>swizzard</w><pre>cljs.user=&gt; (require &apos;[com.rpl.specter :as s :refer-macros [select transform]])
Could not require com.rpl.specter.navs in file com/rpl/specter.cljc
Could not require com.rpl.specter in file com/rpl/specter/navs.cljc
         (new)
         Function.cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:1928:72)
         Function.cljs.analyzer.error.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:2539:92)
         Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5849:145)
         Object.cljs.js.load_macros (NO_SOURCE_FILE &lt;embedded&gt;:5883:41)
         (NO_SOURCE_FILE &lt;embedded&gt;:5883:374)
         Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5838:1)
         Object.cljs.js.load_macros (NO_SOURCE_FILE &lt;embedded&gt;:5883:41)
         (NO_SOURCE_FILE &lt;embedded&gt;:5905:316)
         (NO_SOURCE_FILE &lt;embedded&gt;:5918:218)

Invalid regular expression: /\.js$/: Stack overflow
         String.replace (NO_SOURCE_FILE &lt;anonymous&gt;)
         Object.clojure.string.replace_all (NO_SOURCE_FILE &lt;embedded&gt;:1959:385)
         Object.clojure.string.replace (NO_SOURCE_FILE &lt;embedded&gt;:1962:191)
         (Object.cljs$stacktrace$remove_ext)
         (Object.cljs$stacktrace$mapped_line_column_call)
         (Object.cljs$stacktrace$mapped_frame)
         Function.&lt;anonymous&gt; (evalmachine.&lt;anonymous&gt;:512:24)
         Function.cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:771:157)
         Function.cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$2 (NO_SOURCE_FILE &lt;embedded&gt;:770:188)
         Function.cljs.core.apply.cljs$core$IFn$_invoke$arity$2 (NO_SOURCE_FILE &lt;embedded&gt;:783:244)
</pre></z><z id="t1511640397" t="nathanmarz @benstox selected? is true if it navigates to at least one value, so multi-path in a selected? acts like an or"><y>#</y><d>2017-11-25</d><h>20:06</h><w>nathanmarz</w>@benstox <code>selected?</code> is true if it navigates to at least one value, so <code>multi-path</code> in a <code>selected?</code> acts like an or</z><z id="t1511640438" t="nathanmarz for multiple conditions just use multiple selected? or multiple predicates in the path, e.g. [#(...) #(...) (selected? ...)]"><y>#</y><d>2017-11-25</d><h>20:07</h><w>nathanmarz</w>for multiple conditions just use multiple <code>selected?</code> or multiple predicates in the path, e.g. <code>[#(...) #(...) (selected? ...)]</code></z><z id="t1511640492" t="nathanmarz @swizzard don&apos;t know anything about lumo, you&apos;ll probably have better luck in #clojurescript"><y>#</y><d>2017-11-25</d><h>20:08</h><w>nathanmarz</w>@swizzard don&apos;t know anything about lumo, you&apos;ll probably have better luck in #clojurescript</z><z id="t1511640504" t="swizzard fair enough, thanks"><y>#</y><d>2017-11-25</d><h>20:08</h><w>swizzard</w>fair enough, thanks</z><z id="t1511642582" t="drowsy @benstox I wrote a small lib to tackle such a selection more declarative: https://github.com/IamDrowsy/ebenbild"><y>#</y><d>2017-11-25</d><h>20:43</h><w>drowsy</w>@benstox I wrote a small lib to tackle such a selection more declarative: <a href="https://github.com/IamDrowsy/ebenbild" target="_blank">https://github.com/IamDrowsy/ebenbild</a></z><z id="t1511642662" t="drowsy in your case (like {:type :cheese :quantity #(&gt;= % 3) :quality #(&gt;= % 10)}) would work"><y>#</y><d>2017-11-25</d><h>20:44</h><w>drowsy</w>in your case <code>(like {:type :cheese :quantity #(&gt;= % 3) :quality #(&gt;= % 10)})</code> would work</z><z id="t1511642708" t="drowsy it returns a predicate that can be used directly in a specter path"><y>#</y><d>2017-11-25</d><h>20:45</h><w>drowsy</w>it returns a predicate that can be used directly in a specter path</z><z id="t1511647893" t="benstox @nathanmarz Okay, makes sense. Thanks! @drowsy Interesting! I’ll try your library out."><y>#</y><d>2017-11-25</d><h>22:11</h><w>benstox</w>@nathanmarz Okay, makes sense. Thanks!
@drowsy Interesting! I’ll try your library out.</z><z id="t1511948027" t="plamen Hello Nathan, 1. Specter is an amazing library, thank you for providing it! 2. Couple of questions around recursion: In the following map, I do currently a lot of transformations using reduce/reduce-kv, loops, assoc-in/update-in etc., but as I started to rewrite the manipulations using Specter, the code got of course more readable and consistent. {:name ’A :info ... :parameters ... :backend {:package-name “a”} :inputs {’IA {:connector :csv :endpoint ... :variables {’iax {:name ’ix :type :double :rank 0} ’iay {:name ’iy :type :double :rank 2}}} ’IB {:... ... :variables {’ibx {...} ’iby {...}} }} :variables {’Avx { ’Avy {...} ’Avz {:name “Avz” :backend {:package-name “a.avz” :array-layout :column-major :array-memory :off-heap} :type :record :variables {’Avzx {...} ’Avzy {...} ’Avzz {... :name ’Avzz :backend {:package-name “a.avz.avzz”}}}}}} Now - in recursion scenarios like in adding a key :name with value the key of the map itself (where select result and transformation target are the same) like input: :variables {’iax {:type :double :rank 0} ’iay {:type :double :rank 2}} output: :variables {’iax {:name ’ix :type :double :rank 0} ’iay {:name ’iy :type :double :rank 2}} everything works, but I probably miss some documentation or understanding to do recursion involving values from nodes from an upper or dispatching on values from a lower level. Examples: - how do I create recursively the entry :backend {:package-name ???} - where ??? is the path of :name to the selected/trasfomed map (as in the manually added package names in ’A ’Avz and ’Avzz) - while in this case not touching :variables maps starting at the :inputs key in one case? - or transforming both :variables paths (starting at :variables AND :inputs)? - is there a way to collect on the go the current depth of recursion in Specter (or path?) in that same transformation query? - is there a way to dispatch (or do separate transformation over the structure), but whose input can be in higher level than the tranformation target (e.g. can I select/transform the variable ’Avzx based on a :backend value in ’Avz)? - is there a way to dispatch (or do separate transformation over the structure), but whose input can be in lower level than the tranformation target (e.g. can I select/transform the variable ’Avz based on a [:backend :array-layout] and [:backend :array-memory] values in ’Avz)? In all the questions my main problem is less how to solve it outside of Specter, but how to select and recurse where selection/collection come from other nodes that the transformation target."><y>#</y><d>2017-11-29</d><h>09:33</h><w>plamen</w>Hello Nathan,

1. Specter is an amazing library, thank you for providing it!
2. Couple of questions around recursion:

In the following map, I do currently a lot of transformations using reduce/reduce-kv, loops, assoc-in/update-in etc., but as I started to rewrite the manipulations using Specter, the code got of course more readable and consistent.
 
{:name       ’A
 :info       ...
 :parameters ...
 :backend    {:package-name “a”}
 :inputs     {’IA {:connector :csv
                   :endpoint  ...
                   :variables {’iax {:name ’ix
                                     :type :double
                                     :rank 0}
                               ’iay {:name ’iy
                                     :type :double
                                     :rank 2}}}
              ’IB {:...       ...
                   :variables {’ibx {...}
                               ’iby {...}}
                   }}
 :variables  {’Avx {
              ’Avy {...}
              ’Avz {:name      “Avz”
                    :backend   {:package-name “a.avz”
					            :array-layout :column-major
								:array-memory :off-heap}
                    :type      :record
                    :variables {’Avzx {...}
                                ’Avzy {...}
								’Avzz {...
								       :name ’Avzz
								       :backend {:package-name “a.avz.avzz”}}}}}}

Now - in recursion scenarios like in adding a key :name with value the key of the map itself (where select result and transformation target are the same) like
input:
                   :variables {’iax {:type :double
                                     :rank 0}
                               ’iay {:type :double
                                     :rank 2}}
output:
                   :variables {’iax {:name ’ix
                                     :type :double
                                     :rank 0}
                               ’iay {:name ’iy
                                     :type :double
                                     :rank 2}}

everything works, but I probably miss some documentation or understanding to do recursion involving values from nodes from an upper or dispatching on values from a lower level. Examples:
- how do I create recursively the entry 
    :backend   {:package-name ???} 
	- where ??? is the path of :name to the selected/trasfomed map (as in the manually added package names in ’A ’Avz and ’Avzz)
	- while in this case not touching :variables maps starting at the :inputs key in one case?
	- or transforming both :variables paths (starting at :variables AND :inputs)?
- is there a way to collect on the go the current depth of recursion in Specter (or path?) in that same transformation query?
- is there a way to dispatch (or do separate transformation over the structure), but whose input can be in higher level than the tranformation target (e.g. can I select/transform the variable ’Avzx based on a :backend value in ’Avz)? 
- is there a way to dispatch (or do separate transformation over the structure), but whose input can be in lower level than the tranformation target (e.g. can I select/transform the variable ’Avz based on a [:backend :array-layout] and [:backend :array-memory] values in ’Avz)? 

In all the questions my main problem is less how to solve it outside of Specter, but how to select and recurse where selection/collection come from other nodes that the transformation target.</z><z id="t1511967540" t="nathanmarz for collecting a path as you go, look at https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure"><y>#</y><d>2017-11-29</d><h>14:59</h><w>nathanmarz</w>for collecting a path as you go, look at <a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure" target="_blank">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure</a></z><z id="t1511967566" t="nathanmarz by collecting a path as you go like that, you can compute the recursion depth"><y>#</y><d>2017-11-29</d><h>14:59</h><w>nathanmarz</w>by collecting a path as you go like that, you can compute the recursion depth</z><z id="t1511967644" t="nathanmarz if you use a multi-transform , you could dispatch the transformation function like: (if-path [:backend (pred= :a)] (terminal transformer1) (terminal transformer2)) "><y>#</y><d>2017-11-29</d><h>15:00</h><w>nathanmarz</w>if you use a <code>multi-transform</code>, you could dispatch the transformation function like:
<pre>(if-path [:backend (pred= :a)]
  (terminal transformer1)
  (terminal transformer2))
</pre></z><z id="t1511967750" t="nathanmarz I&apos;m not sure what you mean by your last question, it would help if you simplified your example and showed desired input/output"><y>#</y><d>2017-11-29</d><h>15:02</h><w>nathanmarz</w>I&apos;m not sure what you mean by your last question, it would help if you simplified your example and showed desired input/output</z><z id="t1511968055" t="plamen Hello Nathan, a lot of thanks for the reply! Will implement what you just showed to me first and will come back to the last questions with simplification again."><y>#</y><d>2017-11-29</d><h>15:07</h><w>plamen</w>Hello Nathan, a lot of thanks for the reply! Will implement what you just showed to me first and will come back to the last questions with simplification again.</z><z id="t1511992886" t="plamen ok, the answers added a lot of light to my questions 2,3 and 4, but I still struggle with 1. I simplified it to:"><y>#</y><d>2017-11-29</d><h>22:01</h><w>plamen</w>ok, the answers added a lot of light to my questions 2,3 and 4, but I still struggle with 1. I simplified it to:</z><z id="t1511992897" t="plamen how to transform the map of maps"><y>#</y><d>2017-11-29</d><h>22:01</h><w>plamen</w>how to transform the map of maps</z><z id="t1511992903" t="plamen {:name “root” :a {:name “a” :i 1 :j {:name “j” :m :test} :k 2} 😛 {:name “b” :m {:name “m” :n :test}}}"><y>#</y><d>2017-11-29</d><h>22:01</h><w>plamen</w>{:name “root”
 :a    {:name “a”
        :i    1
        :j    {:name “j”
               :m    :test}
        :k    2}
 <b>😛</b>    {:name “b”
        :m    {:name “m”
               :n    :test}}}</z><z id="t1511992941" t="plamen (instead of a smiley, a keyword 😛 should be in the text…)"><y>#</y><d>2017-11-29</d><h>22:02</h><w>plamen</w>(instead of a smiley, a keyword <b>😛</b> should be in the text…)</z><z id="t1511992959" t="plamen (instead of a smiley, a keyword “:b” should be in the text…)"><y>#</y><d>2017-11-29</d><h>22:02</h><w>plamen</w>(instead of a smiley, a keyword “:b” should be in the text…)</z><z id="t1511992969" t="plamen to the map"><y>#</y><d>2017-11-29</d><h>22:02</h><w>plamen</w>to the map</z><z id="t1511992975" t="plamen {:name “root” :package “root” :a {:name “a” :package “root.a” :i 1 :j {:name “j” :package “root.a.j” :m :test} :k 2} 😛 {:name “b” :package “root.b” :m {:name “m” :package “root.b.m” :n :test}}}"><y>#</y><d>2017-11-29</d><h>22:02</h><w>plamen</w>{:name “root”
 :package “root”
 :a    {:name “a”
        :package “root.a”
        :i    1
        :j    {:name “j”
               :package “root.a.j”
               :m    :test}
        :k    2}
 <b>😛</b>    {:name “b”
        :package “root.b”
        :m    {:name “m”
               :package “root.b.m”
               :n    :test}}}</z><z id="t1511992984" t="plamen (instead of a smiley, a keyword “:b” should be in the text…)"><y>#</y><d>2017-11-29</d><h>22:03</h><w>plamen</w>(instead of a smiley, a keyword “:b” should be in the text…)</z><z id="t1511993125" t="plamen sorry for the lack of formatting - learning to use slack"><y>#</y><d>2017-11-29</d><h>22:05</h><w>plamen</w>sorry for the lack of formatting - learning to use slack</z><z id="t1511993132" t="plamen here again: how to trasform"><y>#</y><d>2017-11-29</d><h>22:05</h><w>plamen</w>here again: how to trasform</z><z id="t1511993136" t="plamen {:name &quot;root&quot; :a {:name &quot;a&quot; :i 1 :j {:name &quot;j&quot; :m :test} :k 2} :b {:name &quot;b&quot; :m {:name &quot;m&quot; :n :test}}}"><y>#</y><d>2017-11-29</d><h>22:05</h><w>plamen</w><pre>{:name &quot;root&quot;
 :a    {:name &quot;a&quot;
        :i    1
        :j    {:name &quot;j&quot;
               :m    :test}
        :k    2}
 :b    {:name &quot;b&quot;
        :m    {:name &quot;m&quot;
               :n    :test}}}</pre></z><z id="t1511993140" t="plamen into"><y>#</y><d>2017-11-29</d><h>22:05</h><w>plamen</w>into</z><z id="t1511993150" t="plamen {:name &quot;root&quot; :package &quot;root&quot; :a {:name &quot;a&quot; :package &quot;root.a&quot; :i 1 :j {:name &quot;j&quot; :package &quot;root.a.j&quot; :m :test} :k 2} :b {:name &quot;b&quot; :package &quot;root.b&quot; :m {:name &quot;m&quot; :package &quot;root.b.m&quot; :n :test}}}"><y>#</y><d>2017-11-29</d><h>22:05</h><w>plamen</w><pre>{:name &quot;root&quot;
 :package &quot;root&quot;
 :a    {:name &quot;a&quot;
        :package &quot;root.a&quot;
        :i    1
        :j    {:name &quot;j&quot;
               :package &quot;root.a.j&quot;
               :m    :test}
        :k    2}
 :b    {:name &quot;b&quot;
        :package &quot;root.b&quot;
        :m    {:name &quot;m&quot;
               :package &quot;root.b.m&quot;
               :n    :test}}}</pre></z><z id="t1511993215" t="plamen where the :package is constructed recursively from the path defined by the :name values"><y>#</y><d>2017-11-29</d><h>22:06</h><w>plamen</w>where the <pre>:package</pre> is constructed recursively from the path defined by the <pre>:name</pre> values</z><z id="t1511993296" t="plamen any help is greatly appreciated"><y>#</y><d>2017-11-29</d><h>22:08</h><w>plamen</w>any help is greatly appreciated</z><z id="t1511993975" t="nathanmarz @plamen here&apos;s one way to do it: (def NODES-WITH-PATH (recursive-path [] p [(collect-one :name) (continue-then-stay MAP-VALS map? p) ])) (transform [NODES-WITH-PATH :package] (fn [&amp; args] (let [path (butlast args)] (clojure.string/join &quot;.&quot; path) )) data ) "><y>#</y><d>2017-11-29</d><h>22:19</h><w>nathanmarz</w>@plamen here&apos;s one way to do it:
<pre>(def NODES-WITH-PATH
  (recursive-path [] p
    [(collect-one :name)
     (continue-then-stay MAP-VALS map? p)
     ]))

(transform [NODES-WITH-PATH :package]
  (fn [&amp; args]
    (let [path (butlast args)]
      (clojure.string/join &quot;.&quot; path)
      ))
  data
  )
</pre></z><z id="t1511994794" t="plamen now starting to understand the benefit of continue-than-stay/stay-then-continue in combination with recursive-path. This was very enlightening (while I discovered Specter 2 days ago and still noob in it, spend may be 3 hours in bending with ALL/FIRST/LAST/p/collect-one for keys/values/recursion and always ended up either missing something from the path or ending in the value of the path key instead of the actual map etc…). A lot of thanks for taking time for my questions! Now everything is explained."><y>#</y><d>2017-11-29</d><h>22:33</h><w>plamen</w>now starting to understand the benefit of continue-than-stay/stay-then-continue in combination with recursive-path. This was very enlightening (while I discovered Specter 2 days ago and still noob in it, spend may be 3 hours in bending with ALL/FIRST/LAST/p/collect-one for keys/values/recursion and always ended up either missing something from the path or ending in the value of the path key instead of the actual map etc…). A lot of thanks for taking time for my questions! Now everything is explained.</z><z id="t1511995111" t="plamen Amazing!"><y>#</y><d>2017-11-29</d><h>22:38</h><w>plamen</w>Amazing!</z><z id="t1511995207" t="nathanmarz sure thing"><y>#</y><d>2017-11-29</d><h>22:40</h><w>nathanmarz</w>sure thing</z><z id="t1512074467" t="eoliphant Hi, I have the following data (def testtree {:form/id 1 :form/name &quot;Test Form&quot; :form/description &quot;My Description&quot; :form/version 1 :form/groups [{:group/id 2 :group/title &quot;Page 1&quot; :group/type :page :group/layout :vertical :group/fields []} {:group/id 4 :group/title &quot;Page 1&quot; :group/type :page :group/layout :vertical :group/fields []}]} ) to insert a new map in form/groups I’m doing the following: (sp/setval [:form/groups ;sp/ALL (sp/srange-dynamic (fn [x] (first (keep-indexed #(when (= (:group/id %2) 2) %1) x))) (fn [x] (first (keep-indexed #(when (= (:group/id %2) 2) %1) x))) )] [ {:group/id 4 :group/title &quot;Inserted&quot;}] testtree ) Which generally does what I want, but I’m just wondering if there’s any cleaner (more specterish) way to compute the indicies for the srange-dynamic"><y>#</y><d>2017-11-30</d><h>20:41</h><w>eoliphant</w>Hi, I have the following data
<pre>(def testtree    {:form/id 1
                  :form/name &quot;Test Form&quot;
                  :form/description &quot;My Description&quot;
                  :form/version 1
                  :form/groups [{:group/id    2
                                 :group/title  &quot;Page 1&quot;
                                 :group/type   :page
                                 :group/layout :vertical
                                 :group/fields []}
                                {:group/id    4
                                 :group/title  &quot;Page 1&quot;
                                 :group/type   :page
                                 :group/layout :vertical
                                 :group/fields []}]}
  )
</pre>

to insert a new map in <code>form/groups</code> I’m doing the following:
<pre>(sp/setval [:form/groups
            ;sp/ALL 
            (sp/srange-dynamic
              (fn [x] (first (keep-indexed #(when (= (:group/id %2) 2) %1) x)))
              (fn [x] (first (keep-indexed #(when (= (:group/id %2) 2) %1) x)))
              )]
          [ {:group/id 4
            :group/title &quot;Inserted&quot;}]
           testtree )
</pre>

Which generally does what I want, but I’m just wondering if there’s any cleaner (more specterish) way to compute the indicies for the srange-dynamic</z><z id="t1512076729" t="nathanmarz @eoliphant you&apos;re trying to insert before the map with :group/id=2 , regardless of where it is in that sequence?"><y>#</y><d>2017-11-30</d><h>21:18</h><w>nathanmarz</w>@eoliphant you&apos;re trying to insert before the map with <code>:group/id=2</code>, regardless of where it is in that sequence?</z><z id="t1512076888" t="eoliphant yes exactyl"><y>#</y><d>2017-11-30</d><h>21:21</h><w>eoliphant</w>yes exactyl</z><z id="t1512077177" t="nathanmarz you can factor out that sort of navigation like this: (defn ^:direct-nav before-index-dynamic [p] (path (srange-dynamic (fn [aseq] (first (keep-indexed (fn [i e] (if (p e) i)) aseq))) (end-fn [_ s] s)) BEFORE-ELEM)) "><y>#</y><d>2017-11-30</d><h>21:26</h><w>nathanmarz</w>you can factor out that sort of navigation like this:
<pre>(defn ^:direct-nav before-index-dynamic [p]
  (path
    (srange-dynamic
      (fn [aseq] (first (keep-indexed (fn [i e] (if (p e) i)) aseq)))
      (end-fn [_ s] s))
    BEFORE-ELEM))
</pre></z><z id="t1512077207" t="nathanmarz then you can use it like this: user=&gt; (setval (before-index-dynamic #(= % 2)) :a [1 2 4 9 2 10]) [1 :a 2 4 9 2 10] "><y>#</y><d>2017-11-30</d><h>21:26</h><w>nathanmarz</w>then you can use it like this:
<pre>user=&gt; (setval (before-index-dynamic #(= % 2)) :a [1 2 4 9 2 10])
[1 :a 2 4 9 2 10]
</pre></z><z id="t1512077225" t="eoliphant ah gotcha. Yes that’s much cleaner 🙂"><y>#</y><d>2017-11-30</d><h>21:27</h><w>eoliphant</w>ah gotcha.  Yes that’s much cleaner <b>🙂</b></z><z id="t1512077227" t="eoliphant thanks"><y>#</y><d>2017-11-30</d><h>21:27</h><w>eoliphant</w>thanks</z><z id="t1512077256" t="nathanmarz using end-fn also avoids computing the index twice"><y>#</y><d>2017-11-30</d><h>21:27</h><w>nathanmarz</w>using <code>end-fn</code> also avoids computing the index twice</z><z id="t1512077283" t="eoliphant yeah that’s cool, that was annoying me as well"><y>#</y><d>2017-11-30</d><h>21:28</h><w>eoliphant</w>yeah that’s cool, that was annoying me as well</z><z id="t1512077830" t="eoliphant it’s funny, I first started playing with specter a month or 2 ago and it kind of gave me a migraine lol. But sometimes you have to step away, and come back. Just picked it back up this morning and blew through a couple scenarios quite easily"><y>#</y><d>2017-11-30</d><h>21:37</h><w>eoliphant</w>it’s funny, I first started playing with specter a month or 2 ago and it kind of gave me a migraine lol.  But sometimes you have to step away, and come back.  Just picked it back up this morning and blew through a couple scenarios quite easily</z><z id="t1512078004" t="nathanmarz any new way of thinking takes time to learn"><y>#</y><d>2017-11-30</d><h>21:40</h><w>nathanmarz</w>any new way of thinking takes time to learn</z><z id="t1512078017" t="nathanmarz eventually it becomes really easy"><y>#</y><d>2017-11-30</d><h>21:40</h><w>nathanmarz</w>eventually it becomes really easy</z><z id="t1512079582" t="eoliphant yeah definitely grokking it better now. One more quick question, this data structure is for an interactive form builder. So as you can see a group has fields, etc. There will cases where say you move a field from one group to another. Is there a way to ‘move’ something from one path to another, or do the delete and add together, kind of transactionally?"><y>#</y><d>2017-11-30</d><h>22:06</h><w>eoliphant</w>yeah definitely grokking it better now.  One more quick question, this data structure is for an interactive form builder.  So as you can see a group has fields, etc.  There will cases where say you move a field from one group to another.  Is there a way to ‘move’ something from one path to another, or do the delete and add together, kind of transactionally?</z><z id="t1512080129" t="nathanmarz index-nav can be used to move an element from one location in a sequence to another"><y>#</y><d>2017-11-30</d><h>22:15</h><w>nathanmarz</w><code>index-nav</code> can be used to move an element from one location in a sequence to another</z><z id="t1512080149" t="nathanmarz otherwise you&apos;ll have to do removal and addition separately"><y>#</y><d>2017-11-30</d><h>22:15</h><w>nathanmarz</w>otherwise you&apos;ll have to do removal and addition separately</z><z id="t1512080649" t="eoliphant Ok, will give that a whirl"><y>#</y><d>2017-11-30</d><h>22:24</h><w>eoliphant</w>Ok, will give that a whirl</z><z id="t1512331857" t="eoliphant hi, i have a quick question. I want to recursively search for an element in a data-structure (maps, that have lists, that have maps, etc), then do a setval before/after the element i found so I have this test data structure #:designer{:cur-form-def #:form{:id #uuid&quot;4979e704-5047-48cf-bfe3-fdf9ca58bae8&quot;, :name &quot;New Form&quot;, :description &quot;Description&quot;, :version 1, :groups [#:group{:id #uuid&quot;d865ab2f-d114-4853-9a37-592a2c941152&quot;, :title &quot;Page 1&quot;, :type :page, :layout :vertical, :subgroups [#:group{:id #uuid&quot;237a7f3e-702e-4b63-8b4e-5df4da205e22&quot;, :name &quot;row1&quot;, :type :row, :layout :horizontal, :fields [#:field{:id #uuid&quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;, :name :newfield, :label &quot;New Fuekd&quot;, :type :text}]}]}]}} And I want to find the :newfield by its id and jam a new map in the containing vector after :newfield so I do the following: (sp/setval [:designer/cur-form-def :form/groups sp/ALL (sp/walker #(= (:field/id %) #uuid &quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;)) sp/AFTER-ELEM ] [{:test :newfield}] appdb) which gives me this: #:designer{:cur-form-def #:form{:id #uuid&quot;4979e704-5047-48cf-bfe3-fdf9ca58bae8&quot;, :name &quot;New Form&quot;, :description &quot;Description&quot;, :version 1, :groups [#:group{:id #uuid&quot;d865ab2f-d114-4853-9a37-592a2c941152&quot;, :title &quot;Page 1&quot;, :type :page, :layout :vertical, :subgroups [#:group{:id #uuid&quot;237a7f3e-702e-4b63-8b4e-5df4da205e22&quot;, :name &quot;row1&quot;, :type :row, :layout :horizontal, :fields [([:field/id #uuid&quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;] [:field/name :newfield] [:field/label &quot;New Fuekd&quot;] [:field/type :text] The walker selector worked fine, but now :group/fields has gone from a vector with a single map to a vector, that has a single list of k/v pairs including the new one. So I’m obviously doing somethign wrong lol. When if leave off the AFTER-ELEM, the map is set as one would expect but replaces the one that was ‘found’ I’ve figured that I need to ‘go up/out’ of the map to get back to the vector, at this point, just not sure how"><y>#</y><d>2017-12-03</d><h>20:10</h><w>eoliphant</w>hi, i have a quick question.  I want to recursively search for an element in a data-structure (maps, that have lists, that have maps, etc), then do a setval before/after the element i found

so I have this test data structure
<pre>#:designer{:cur-form-def #:form{:id #uuid&quot;4979e704-5047-48cf-bfe3-fdf9ca58bae8&quot;,
                                :name &quot;New Form&quot;,
                                :description &quot;Description&quot;,
                                :version 1,
                                :groups [#:group{:id #uuid&quot;d865ab2f-d114-4853-9a37-592a2c941152&quot;,
                                                 :title &quot;Page 1&quot;,
                                                 :type :page,
                                                 :layout :vertical,
                                                 :subgroups [#:group{:id #uuid&quot;237a7f3e-702e-4b63-8b4e-5df4da205e22&quot;,
                                                                     :name &quot;row1&quot;,
                                                                     :type :row,
                                                                     :layout :horizontal,
                                                                     :fields [#:field{:id #uuid&quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;,
                                                                                      :name :newfield,
                                                                                      :label &quot;New Fuekd&quot;,
                                                                                      :type :text}]}]}]}}
</pre>

And I want to find the :newfield by its id and jam a new map in the containing vector after :newfield

so I do the following:

<pre>(sp/setval [:designer/cur-form-def
            :form/groups
            sp/ALL
            (sp/walker #(= (:field/id %) #uuid &quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;))
            sp/AFTER-ELEM
            ] [{:test :newfield}] appdb)
</pre>
which gives me this:

<pre>#:designer{:cur-form-def #:form{:id #uuid&quot;4979e704-5047-48cf-bfe3-fdf9ca58bae8&quot;,
                                :name &quot;New Form&quot;,
                                :description &quot;Description&quot;,
                                :version 1,
                                :groups [#:group{:id #uuid&quot;d865ab2f-d114-4853-9a37-592a2c941152&quot;,
                                                 :title &quot;Page 1&quot;,
                                                 :type :page,
                                                 :layout :vertical,
                                                 :subgroups [#:group{:id #uuid&quot;237a7f3e-702e-4b63-8b4e-5df4da205e22&quot;,
                                                                     :name &quot;row1&quot;,
                                                                     :type :row,
                                                                     :layout :horizontal,
                                                                     :fields [([:field/id
                                                                                #uuid&quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;]
                                                                               [:field/name :newfield]
                                                                               [:field/label &quot;New Fuekd&quot;]
                                                                               [:field/type :text]
</pre>
The walker selector worked fine, but now :group/fields has gone from a vector with a single map to a vector, that has a single list of k/v pairs including the new one.  So I’m obviously doing somethign wrong lol.  When if leave off the AFTER-ELEM, the map is set as one would expect but replaces the one that was ‘found’

I’ve figured that I need to ‘go up/out’ of the map to get back to the vector, at this point, just not sure how</z><z id="t1512335049" t="nathanmarz @eoliphant you need to do something similar to what I showed you before with before-index-dynamic , except navigate after the index of the target element"><y>#</y><d>2017-12-03</d><h>21:04</h><w>nathanmarz</w>@eoliphant you need to do something similar to what I showed you before with <code>before-index-dynamic</code>, except navigate after the index of the target element</z><z id="t1512335131" t="nathanmarz you could also use zippers for this task, see https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers"><y>#</y><d>2017-12-03</d><h>21:05</h><w>nathanmarz</w>you could also use zippers for this task, see <a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers" target="_blank">https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers</a></z><z id="t1512337621" t="eoliphant hmm, ok so would it be something more like creating a recursive-path navigator instead of using walker?"><y>#</y><d>2017-12-03</d><h>21:47</h><w>eoliphant</w>hmm, ok so would it be something more like creating a recursive-path navigator instead of using walker?</z><z id="t1512337635" t="nathanmarz definitely"><y>#</y><d>2017-12-03</d><h>21:47</h><w>nathanmarz</w>definitely</z><z id="t1512337678" t="nathanmarz make a recursive path navigating to every &quot;group&quot; map, then navigate from there to the position next to your target element"><y>#</y><d>2017-12-03</d><h>21:47</h><w>nathanmarz</w>make a recursive path navigating to every &quot;group&quot; map, then navigate from there to the position next to your target element</z><z id="t1512337737" t="nathanmarz there are really very few cases that justify the use of walker"><y>#</y><d>2017-12-03</d><h>21:48</h><w>nathanmarz</w>there are really very few cases that justify the use of <code>walker</code></z><z id="t1512337806" t="nathanmarz it traverses map keys, map key/value pairs, dives into record fields, all of which causes it to be much slower than necessary as well as lead to surprising bugs"><y>#</y><d>2017-12-03</d><h>21:50</h><w>nathanmarz</w>it traverses map keys, map key/value pairs, dives into record fields, all of which causes it to be much slower than necessary as well as lead to surprising bugs</z><z id="t1512337953" t="eoliphant ok cool, that’s ironically sort of what I was thinking 🙂"><y>#</y><d>2017-12-03</d><h>21:52</h><w>eoliphant</w>ok cool, that’s ironically sort of what I was thinking <b>🙂</b></z><z id="t1512338022" t="eoliphant and i see your point, walker is quick-and-dirty but far from optimal since I know specifically what I need to ’walk;"><y>#</y><d>2017-12-03</d><h>21:53</h><w>eoliphant</w>and i see your point, walker is quick-and-dirty but far from optimal since I know specifically what I need to ’walk;</z><z id="t1512342824" t="eoliphant hi, I’m trying something like this: (def find-field (sp/recursive-path [uuid] p (sp/cond-path (sp/keypath :group/subgroups) [sp/ALL p] (sp/keypath :group/fields) [sp/ALL p] #(= (:field/id %) uuid) sp/STAY))) and calling it like so (sp/select [:designer/cur-form-def :form/groups (find-field #uuid &quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot; ) ] appdb) I’ve tried it with and without the keypath call but I’m getting a “Don’t know how to create ISeq from: clojure.lang.Keyword ” in both cases"><y>#</y><d>2017-12-03</d><h>23:13</h><w>eoliphant</w>hi, I’m trying something like this:

<pre>(def find-field
  (sp/recursive-path [uuid] p
                     (sp/cond-path
                       (sp/keypath :group/subgroups) [sp/ALL p]
                       (sp/keypath :group/fields) [sp/ALL p]
                       #(= (:field/id %) uuid) sp/STAY)))
</pre>
and calling it like so
<pre>(sp/select [:designer/cur-form-def
            :form/groups
            (find-field #uuid &quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot; )
            ]
            appdb)
</pre>

I’ve tried it with and without the <code>keypath</code> call but I’m getting a “Don’t know how to create ISeq from: clojure.lang.Keyword  ” in both cases</z><z id="t1512346164" t="nathanmarz @eoliphant a few things"><y>#</y><d>2017-12-04</d><h>00:09</h><w>nathanmarz</w>@eoliphant a few things</z><z id="t1512346172" t="nathanmarz you&apos;re misunderstanding cond-path and keypath"><y>#</y><d>2017-12-04</d><h>00:09</h><w>nathanmarz</w>you&apos;re misunderstanding <code>cond-path</code> and <code>keypath</code></z><z id="t1512346179" t="nathanmarz a condition is true if it selects anything"><y>#</y><d>2017-12-04</d><h>00:09</h><w>nathanmarz</w>a condition is true if it selects anything</z><z id="t1512346195" t="nathanmarz keypath always selects something, so it&apos;s pointless to be a condition on its own"><y>#</y><d>2017-12-04</d><h>00:09</h><w>nathanmarz</w><code>keypath</code> always selects something, so it&apos;s pointless to be a condition on its own</z><z id="t1512346259" t="nathanmarz you&apos;re also trying to navigate the maps and find the field in the submap at the same time, which isn&apos;t the right approach"><y>#</y><d>2017-12-04</d><h>00:10</h><w>nathanmarz</w>you&apos;re also trying to navigate the maps and find the field in the submap at the same time, which isn&apos;t the right approach</z><z id="t1512346305" t="nathanmarz instead do something like: (def NODES (recursive-path [] p (continue-then-stay :subgroups ALL)))"><y>#</y><d>2017-12-04</d><h>00:11</h><w>nathanmarz</w>instead do something like: <code>(def NODES (recursive-path [] p (continue-then-stay :subgroups ALL)))</code></z><z id="t1512346348" t="nathanmarz then from there you can do (transform [NODES :fields ..."><y>#</y><d>2017-12-04</d><h>00:12</h><w>nathanmarz</w>then from there you can do <code>(transform [NODES :fields ...</code></z><z id="t1512351419" t="eoliphant hmm ok, will give that a shot, yeah i’d just tossed in keypath in trying to figure out why it wasn’t working. originally it was just (sp/cond-path :group/subgroups [ALL p] but ok i think I see understand it a little better will break it out"><y>#</y><d>2017-12-04</d><h>01:36</h><w>eoliphant</w>hmm ok, will give that a shot, yeah i’d just tossed in keypath in trying to figure out why it wasn’t working.  originally it was just  
<pre>(sp/cond-path
  :group/subgroups [ALL p]
</pre>

but ok i think I see understand it a little better will break it out</z><z id="t1512358231" t="eoliphant ok. so after banging my head for a bit because i’d mistyped the key in NODES function lol, I’ve got everything working, needs some cleanup, but basically this: (sp/setval [:designer/cur-form-def :form/groups sp/ALL NODES :group/fields #(some? %) (before-index-dynamic #(= (:field/id %) #uuid &quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;)) ] [{:new :field}] appdb) Will add {:new field} before the field with the matching id. so good there. However, had to do a bit of hacking because not all :group/* maps have group/fields , This was initially blowing up the before-index.. function as specter would dutifully provide a nil. So I added the some? check. That works, in terms of the field getting inserted, though I’m sure it’s not the best way, but the other thing is that the newly returned data structure adds a {:group/fields nil} to groups that didn’t have one, which surprised me as I thought the some? check would prevent that. So I’m thinking the recursive path function should weed out groups that don’t have :group/fields?"><y>#</y><d>2017-12-04</d><h>03:30</h><w>eoliphant</w>ok.  so after banging my head for a bit because i’d mistyped the key in NODES function lol, I’ve got everything working, needs some cleanup, but basically this:
<pre>(sp/setval [:designer/cur-form-def
            :form/groups
            sp/ALL
            NODES
            :group/fields
            #(some? %)
            (before-index-dynamic #(= (:field/id %) #uuid &quot;b9a2c9ea-2647-48d3-ab26-4c2a115d7b6f&quot;))

            ]
           [{:new :field}]
           appdb)
</pre>

Will add <code>{:new field}</code> before the field with the matching id.  so good there.  However, had to do a bit of hacking because not all <code>:group/*</code> maps have <code>group/fields</code>,   This was initially blowing up the <code>before-index..</code> function as specter would dutifully provide a nil.  So I added the <code>some?</code> check.  That works, in terms of the field getting inserted, though I’m sure it’s not the best way, but the other thing is that the newly returned data structure adds a <code>{:group/fields nil}</code> to groups that didn’t have one, which surprised me as I thought the some? check would prevent that.    So I’m thinking the recursive path function should weed out groups that don’t have :group/fields?</z><z id="t1512391752" t="nathanmarz @eoliphant ah you just need before-index-dynamic to navigate nowhere if there&apos;s no match"><y>#</y><d>2017-12-04</d><h>12:49</h><w>nathanmarz</w>@eoliphant ah you just need <code>before-index-dynamic</code> to navigate nowhere if there&apos;s no match</z><z id="t1512391757" t="nathanmarz this does the trick: (defn ^:direct-nav before-index-dynamic [p] (path (srange-dynamic (fn [aseq] (if-let [i (first (keep-indexed (fn [i e] (if (p e) i)) aseq))] i (count aseq) )) (end-fn [aseq s] (if (= s (count aseq)) s (inc s)))) (complement empty?) BEFORE-ELEM )) "><y>#</y><d>2017-12-04</d><h>12:49</h><w>nathanmarz</w>this does the trick:
<pre>(defn ^:direct-nav before-index-dynamic [p]
  (path
    (srange-dynamic
      (fn [aseq]
        (if-let [i (first (keep-indexed (fn [i e] (if (p e) i)) aseq))]
          i
          (count aseq)
          ))
      (end-fn [aseq s]
        (if (= s (count aseq)) s (inc s))))
    (complement empty?)
    BEFORE-ELEM
    ))
</pre></z></g><g id="s17"><z id="t1512391864" t="nathanmarz if you only want to navigate to a value in a map if the key exists, then do (must :somekey)"><y>#</y><d>2017-12-04</d><h>12:51</h><w>nathanmarz</w>if you only want to navigate to a value in a map if the key exists, then do <code>(must :somekey)</code></z><z id="t1512397180" t="eoliphant ah yeah. ok so even in my example just (must :group/fields), obviated the need for the (some? ..) and gave the proper result, will mess around with the path function as well to see what makes more sense"><y>#</y><d>2017-12-04</d><h>14:19</h><w>eoliphant</w>ah yeah.  ok so even in my example just (must :group/fields), obviated the need for the (some? ..) and gave the proper result, will mess around with the path function as well to see what makes more sense</z><z id="t1512654011" t="mbertheau How would I do (filterv #(-&gt; % :id nil?) foo) with specter? Or would I not?"><y>#</y><d>2017-12-07</d><h>13:40</h><w>mbertheau</w>How would I do <code>(filterv #(-&gt; % :id nil?) foo)</code> with specter? Or would I not?</z><z id="t1512654430" t="nathanmarz @mbertheau two approaches: (select [ALL #(-&gt; % :id nil?)] foo) "><y>#</y><d>2017-12-07</d><h>13:47</h><w>nathanmarz</w>@mbertheau two approaches:
<pre>(select [ALL #(-&gt; % :id nil?)] foo)
</pre></z><z id="t1512654445" t="nathanmarz (setval [ALL #(-&gt; % :id some?)] NONE foo) "><y>#</y><d>2017-12-07</d><h>13:47</h><w>nathanmarz</w><pre>(setval [ALL #(-&gt; % :id some?)] NONE foo)
</pre></z><z id="t1512654459" t="nathanmarz the first always returns a vector, the second maintains the type of whatever foo is"><y>#</y><d>2017-12-07</d><h>13:47</h><w>nathanmarz</w>the first always returns a vector, the second maintains the type of whatever <code>foo</code> is</z><z id="t1512655610" t="mbertheau @nathanmarz I&apos;m just starting out with specter - thanks for helping me up the initial learning curve!"><y>#</y><d>2017-12-07</d><h>14:06</h><w>mbertheau</w>@nathanmarz I&apos;m just starting out with specter - thanks for helping me up the initial learning curve!</z><z id="t1512656084" t="nathanmarz sure, no problem"><y>#</y><d>2017-12-07</d><h>14:14</h><w>nathanmarz</w>sure, no problem</z><z id="t1513173190" t="mbjarland Hi @nathanmarz, now this might be a noob question, but how would I go about getting rid of the following warning when building my lein project (which has specter in the depenendency graph): WARNING: any? already refers to: #&apos;clojure.core/any? in namespace: com.rpl.specter.impl, being replaced by: #&apos;com.rpl.specter.impl/any? "><y>#</y><d>2017-12-13</d><h>13:53</h><w>mbjarland</w>Hi @nathanmarz, now this might be a noob question, but how would I go about getting rid of the following warning when building my lein project (which has specter in the depenendency graph): 
<pre>WARNING: any? already refers to: #&apos;clojure.core/any? in namespace: com.rpl.specter.impl, being replaced by: #&apos;com.rpl.specter.impl/any?
</pre></z><z id="t1513173198" t="mbjarland clojure 1.9.0"><y>#</y><d>2017-12-13</d><h>13:53</h><w>mbjarland</w>clojure 1.9.0</z><z id="t1513173249" t="nathanmarz @mbjarland ah i&apos;ll need to release a new version that renames those functions"><y>#</y><d>2017-12-13</d><h>13:54</h><w>nathanmarz</w>@mbjarland ah i&apos;ll need to release a new version that renames those functions</z><z id="t1513173265" t="mbjarland I&apos;m using midje for testing which in turn pulls in marick/suchwow which in turn pulls in specter 0.13.0...ah ok"><y>#</y><d>2017-12-13</d><h>13:54</h><w>mbjarland</w>I&apos;m using midje for testing which in turn pulls in marick/suchwow which in turn pulls in specter 0.13.0...ah ok</z><z id="t1513173304" t="mbjarland do you want the dependency graph or any other details from my side?"><y>#</y><d>2017-12-13</d><h>13:55</h><w>mbjarland</w>do you want the dependency graph or any other details from my side?</z><z id="t1513173330" t="nathanmarz no, that&apos;s fine"><y>#</y><d>2017-12-13</d><h>13:55</h><w>nathanmarz</w>no, that&apos;s fine</z><z id="t1513173361" t="nathanmarz you&apos;ll need to open an issue with midje to update its dependencies"><y>#</y><d>2017-12-13</d><h>13:56</h><w>nathanmarz</w>you&apos;ll need to open an issue with midje to update its dependencies</z><z id="t1513173372" t="nathanmarz looks like it&apos;s really outdated"><y>#</y><d>2017-12-13</d><h>13:56</h><w>nathanmarz</w>looks like it&apos;s really outdated</z><z id="t1513173408" t="mbjarland would be glad to, though it might be worth waiting until you do your update before creating the ticket"><y>#</y><d>2017-12-13</d><h>13:56</h><w>mbjarland</w>would be glad to, though it might be worth waiting until you do your update before creating the ticket</z><z id="t1513173446" t="nathanmarz just checked, that function no longer exists in specter codebase so there are no warnings with latest version"><y>#</y><d>2017-12-13</d><h>13:57</h><w>nathanmarz</w>just checked, that function no longer exists in specter codebase so there are no warnings with latest version</z><z id="t1513173476" t="mbjarland ha, ok I&apos;ll create a ticket now then"><y>#</y><d>2017-12-13</d><h>13:57</h><w>mbjarland</w>ha, ok I&apos;ll create a ticket now then</z><z id="t1513173505" t="nathanmarz oh apparently I knew about and fixed this a long time ago: https://github.com/nathanmarz/specter/blob/master/CHANGES.md#0131"><y>#</y><d>2017-12-13</d><h>13:58</h><w>nathanmarz</w>oh apparently I knew about and fixed this a long time ago: <a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md#0131" target="_blank">https://github.com/nathanmarz/specter/blob/master/CHANGES.md#0131</a></z><z id="t1513173505" t="mbjarland unfortunate fact"><y>#</y><d>2017-12-13</d><h>13:58</h><w>mbjarland</w>unfortunate fact</z><z id="t1513173530" t="mbjarland suchwow (which is the immediate dep of midje) has not changed since the 6.0.0 version which midje is using"><y>#</y><d>2017-12-13</d><h>13:58</h><w>mbjarland</w>suchwow (which is the immediate dep of midje) has not changed since the 6.0.0 version which midje is using</z><z id="t1513173559" t="mbjarland this brings to mind Rich&apos;s talk about dependency hell..."><y>#</y><d>2017-12-13</d><h>13:59</h><w>mbjarland</w>this brings to mind Rich&apos;s talk about dependency hell...</z><z id="t1513173685" t="mbjarland so I would have to file a ticket with suchwow and once they update, file a ticket with midje?"><y>#</y><d>2017-12-13</d><h>14:01</h><w>mbjarland</w>so I would have to file a ticket with suchwow and once they update, file a ticket with midje?</z><z id="t1513175071" t="nathanmarz @mbjarland yea, it&apos;s an annoying problem with the jvm"><y>#</y><d>2017-12-13</d><h>14:24</h><w>nathanmarz</w>@mbjarland yea, it&apos;s an annoying problem with the jvm</z><z id="t1513175085" t="nathanmarz but yes, that would be the approach to use"><y>#</y><d>2017-12-13</d><h>14:24</h><w>nathanmarz</w>but yes, that would be the approach to use</z><z id="t1513175105" t="nathanmarz it would probably be a lot faster for you to just fork the projects yourself in the meantime"><y>#</y><d>2017-12-13</d><h>14:25</h><w>nathanmarz</w>it would probably be a lot faster for you to just fork the projects yourself in the meantime</z><z id="t1513175252" t="mbjarland there is an existing PR on suchwow: https://github.com/marick/suchwow/pull/9"><y>#</y><d>2017-12-13</d><h>14:27</h><w>mbjarland</w>there is an existing PR on suchwow: 
<a href="https://github.com/marick/suchwow/pull/9" target="_blank">https://github.com/marick/suchwow/pull/9</a></z><z id="t1513175371" t="mbjarland I created a ticket and referenced the pr, now we wait"><y>#</y><d>2017-12-13</d><h>14:29</h><w>mbjarland</w>I created a ticket and referenced the pr, now we wait</z><z id="t1513175386" t="mbjarland https://github.com/marick/suchwow/issues/10"><y>#</y><d>2017-12-13</d><h>14:29</h><w>mbjarland</w><a href="https://github.com/marick/suchwow/issues/10" target="_blank">https://github.com/marick/suchwow/issues/10</a></z><z id="t1513178453" t="abdullahibra @nathanmarz (select [ALL (selected? :p1 ALL :name (pred= &quot;wow&quot;))] data) =&gt; this expression check for &quot;wow&quot; word, what if i want to check multiple different words"><y>#</y><d>2017-12-13</d><h>15:20</h><w>abdullahibra</w>@nathanmarz (select [ALL (selected? :p1 ALL :name (pred= &quot;wow&quot;))] data) =&gt; this expression check for &quot;wow&quot; word, what if i want to check multiple  different words</z><z id="t1513178481" t="abdullahibra for example: all contains &quot;wow&quot; or contains &quot;good&quot;"><y>#</y><d>2017-12-13</d><h>15:21</h><w>abdullahibra</w>for example:
all contains &quot;wow&quot; or contains &quot;good&quot;</z><z id="t1513178574" t="abdullahibra (or (pred= &quot;wow&quot;) (pred= &quot;good&quot;)) ?"><y>#</y><d>2017-12-13</d><h>15:22</h><w>abdullahibra</w>(or (pred= &quot;wow&quot;) (pred= &quot;good&quot;)) ?</z><z id="t1513179643" t="nathanmarz @abdullahibra replace (pred= &quot;wow&quot;) with #{&quot;wow&quot; &quot;good&quot;}"><y>#</y><d>2017-12-13</d><h>15:40</h><w>nathanmarz</w>@abdullahibra replace <code>(pred= &quot;wow&quot;)</code> with <code>#{&quot;wow&quot; &quot;good&quot;}</code></z><z id="t1513179658" t="abdullahibra great"><y>#</y><d>2017-12-13</d><h>15:40</h><w>abdullahibra</w>great</z><z id="t1513179767" t="abdullahibra what if i want to use custom function rather than match string? maybe regexp matcher for example"><y>#</y><d>2017-12-13</d><h>15:42</h><w>abdullahibra</w>what if i want to use custom function rather than match string? maybe regexp matcher for example</z><z id="t1513179794" t="nathanmarz @abdullahibra you can insert any clojure function into a path"><y>#</y><d>2017-12-13</d><h>15:43</h><w>nathanmarz</w>@abdullahibra you can insert any clojure function into a path</z><z id="t1513179834" t="nathanmarz if it returns nil or false, it ceases navigation there"><y>#</y><d>2017-12-13</d><h>15:43</h><w>nathanmarz</w>if it returns nil or false, it ceases navigation there</z><z id="t1513179870" t="nathanmarz regexes are also natively supported, they navigate to every substring match"><y>#</y><d>2017-12-13</d><h>15:44</h><w>nathanmarz</w>regexes are also natively supported, they navigate to every substring match</z><z id="t1513179875" t="abdullahibra #{&quot;wow&quot; (fn [s] (re-find #&quot;[g|G]ood&quot; s))} this is right?"><y>#</y><d>2017-12-13</d><h>15:44</h><w>abdullahibra</w>#{&quot;wow&quot; (fn [s] (re-find #&quot;[g|G]ood&quot; s))} this is right?</z><z id="t1513179892" t="nathanmarz so (selected? #&quot;aaa&quot;) would act as a filter"><y>#</y><d>2017-12-13</d><h>15:44</h><w>nathanmarz</w>so <code>(selected? #&quot;aaa&quot;)</code> would act as a filter</z><z id="t1513179912" t="nathanmarz no, sets are interpreted just like a function"><y>#</y><d>2017-12-13</d><h>15:45</h><w>nathanmarz</w>no, sets are interpreted just like a function</z><z id="t1513179920" t="nathanmarz (since sets are functions in clojure)"><y>#</y><d>2017-12-13</d><h>15:45</h><w>nathanmarz</w>(since sets are functions in clojure)</z><z id="t1513179982" t="nathanmarz you would want either (fn [s] (or (= &quot;wow&quot; %) (re-find ...))) or (selected? (multi-path (pred= &quot;wow&quot;) #&quot;[g|G]ood&quot;))"><y>#</y><d>2017-12-13</d><h>15:46</h><w>nathanmarz</w>you would want either <code>(fn [s] (or (= &quot;wow&quot; %) (re-find ...)))</code> or <code>(selected? (multi-path (pred= &quot;wow&quot;) #&quot;[g|G]ood&quot;))</code></z><z id="t1513180008" t="nathanmarz multi-path within a selected? functions like an or"><y>#</y><d>2017-12-13</d><h>15:46</h><w>nathanmarz</w><code>multi-path</code> within a <code>selected?</code> functions like an <code>or</code></z><z id="t1513180028" t="nathanmarz you may wish to look through https://github.com/nathanmarz/specter/wiki/List-of-Navigators"><y>#</y><d>2017-12-13</d><h>15:47</h><w>nathanmarz</w>you may wish to look through <a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators</a></z><z id="t1513180090" t="abdullahibra that&apos;s really cool"><y>#</y><d>2017-12-13</d><h>15:48</h><w>abdullahibra</w>that&apos;s really cool</z><z id="t1513180094" t="abdullahibra thanks man for this"><y>#</y><d>2017-12-13</d><h>15:48</h><w>abdullahibra</w>thanks man for this</z><z id="t1513182633" t="abdullahibra for this data: [{:s1 &quot;cool&quot; :p1 [{:name &quot;hello&quot; :sen &quot;good&quot;} {:name &quot;world&quot;, :sen &quot;nothing&quot;}]}, {:s2 &quot;cool2&quot; :p1 [{:name &quot;wow&quot;, :sen &quot;fine&quot;} {:name &quot;world&quot;,, :sen &quot;none&quot;}]}]"><y>#</y><d>2017-12-13</d><h>16:30</h><w>abdullahibra</w>for this data: [{:s1 &quot;cool&quot; :p1 [{:name &quot;hello&quot; :sen &quot;good&quot;} {:name &quot;world&quot;, :sen &quot;nothing&quot;}]},  {:s2 &quot;cool2&quot; :p1 [{:name &quot;wow&quot;, :sen &quot;fine&quot;} {:name &quot;world&quot;,, :sen &quot;none&quot;}]}]</z><z id="t1513182804" t="abdullahibra @nathanmarz helped me to extract all hash maps which match &quot;wow&quot; or regexp, and for multiple words i would like to do this: (selected? (apply multi-path [#&quot;regexp1&quot; #&quot;regexp2&quot;])) and what if i want to match two cases in the same time, so i want to catch the :name which has regexp and :sen which has also regexp"><y>#</y><d>2017-12-13</d><h>16:33</h><w>abdullahibra</w>@nathanmarz helped me to extract all hash maps which match &quot;wow&quot; or regexp, and for multiple words i would like to do this:
(selected? (apply multi-path [#&quot;regexp1&quot; #&quot;regexp2&quot;])) and what if i want to match two cases in the same time, so i want to catch the :name which has regexp and :sen which has also regexp</z><z id="t1513182877" t="nathanmarz don&apos;t do (apply multi-path ...)"><y>#</y><d>2017-12-13</d><h>16:34</h><w>nathanmarz</w>don&apos;t do <code>(apply multi-path ...)</code></z><z id="t1513182881" t="abdullahibra why ?"><y>#</y><d>2017-12-13</d><h>16:34</h><w>abdullahibra</w>why ?</z><z id="t1513182892" t="nathanmarz inefficient and unecessary"><y>#</y><d>2017-12-13</d><h>16:34</h><w>nathanmarz</w>inefficient and unecessary</z><z id="t1513182905" t="nathanmarz to match multiple cases just put multiple conditions consecutive in the path"><y>#</y><d>2017-12-13</d><h>16:35</h><w>nathanmarz</w>to match multiple cases just put multiple conditions consecutive in the path</z><z id="t1513182907" t="abdullahibra what if i have big list of regexp?"><y>#</y><d>2017-12-13</d><h>16:35</h><w>abdullahibra</w>what if i have big list of regexp?</z><z id="t1513182973" t="abdullahibra what i would like to get any hash map which match any from regexp-list1 and regexp-list2 from two different paths"><y>#</y><d>2017-12-13</d><h>16:36</h><w>abdullahibra</w>what i would like to get any hash map which match any from regexp-list1 and regexp-list2 from two different paths</z><z id="t1513182990" t="abdullahibra one path from :name and other from :sen"><y>#</y><d>2017-12-13</d><h>16:36</h><w>abdullahibra</w>one path from :name and other from :sen</z><z id="t1513183061" t="nathanmarz you can do the (apply multi-path some-list) but there will be ways to optimize that if you have perf problems"><y>#</y><d>2017-12-13</d><h>16:37</h><w>nathanmarz</w>you can do the <code>(apply multi-path some-list)</code> but there will be ways to optimize that if you have perf problems</z><z id="t1513183167" t="nathanmarz (selected? (multi-path :key1 :key2) (multi-path (pred= &quot;wow&quot;) #&quot;some-regex&quot;))"><y>#</y><d>2017-12-13</d><h>16:39</h><w>nathanmarz</w><code>(selected? (multi-path :key1 :key2) (multi-path (pred= &quot;wow&quot;) #&quot;some-regex&quot;))</code></z><z id="t1513183192" t="nathanmarz that would check that either :key1 or :key2 is either &quot;wow&quot; or matches that regex"><y>#</y><d>2017-12-13</d><h>16:39</h><w>nathanmarz</w>that would check that either :key1 or :key2 is either &quot;wow&quot; or matches that regex</z><z id="t1513183212" t="abdullahibra i got this"><y>#</y><d>2017-12-13</d><h>16:40</h><w>abdullahibra</w>i got this</z><z id="t1513183233" t="abdullahibra but if i would like to match :name is &quot;wow&quot; AND :sen is &quot;good&quot;"><y>#</y><d>2017-12-13</d><h>16:40</h><w>abdullahibra</w>but if i would like to match :name is &quot;wow&quot; AND :sen is &quot;good&quot;</z><z id="t1513183261" t="abdullahibra so i don&apos;t get match for :name &quot;wow&quot; and :sen &quot;nothing&quot;"><y>#</y><d>2017-12-13</d><h>16:41</h><w>abdullahibra</w>so i don&apos;t get match for :name &quot;wow&quot; and :sen &quot;nothing&quot;</z><z id="t1513183272" t="nathanmarz [#(= &quot;wow&quot; (:name %)) #(= &quot;good&quot; (:sen %))]"><y>#</y><d>2017-12-13</d><h>16:41</h><w>nathanmarz</w><code>[#(= &quot;wow&quot; (:name %)) #(= &quot;good&quot; (:sen %))]</code></z><z id="t1513183296" t="abdullahibra without multipath ?"><y>#</y><d>2017-12-13</d><h>16:41</h><w>abdullahibra</w>without multipath ?</z><z id="t1513183355" t="nathanmarz multi-path navigates to multiple paths"><y>#</y><d>2017-12-13</d><h>16:42</h><w>nathanmarz</w><code>multi-path</code> navigates to multiple paths</z><z id="t1513183385" t="nathanmarz for &quot;and&quot;, it&apos;s just multiple navigators in a row, for &quot;or&quot; it&apos;s (selected? (multi-path ...))"><y>#</y><d>2017-12-13</d><h>16:43</h><w>nathanmarz</w>for &quot;and&quot;, it&apos;s just multiple navigators in a row, for &quot;or&quot; it&apos;s <code>(selected? (multi-path ...))</code></z><z id="t1513183399" t="abdullahibra ah okay got this"><y>#</y><d>2017-12-13</d><h>16:43</h><w>abdullahibra</w>ah okay got this</z><z id="t1513183455" t="nathanmarz these are just how those concepts emerge from navigation"><y>#</y><d>2017-12-13</d><h>16:44</h><w>nathanmarz</w>these are just how those concepts emerge from navigation</z><z id="t1513252190" t="abdullahibra hi guys"><y>#</y><d>2017-12-14</d><h>11:49</h><w>abdullahibra</w>hi guys</z><z id="t1513252194" t="abdullahibra for this data:"><y>#</y><d>2017-12-14</d><h>11:49</h><w>abdullahibra</w>for this data:</z><z id="t1513252204" t="abdullahibra [{:s1 &quot;cool&quot;, :p1 [{:name &quot;hello&quot;, :sen &quot;good&quot;} {:name &quot;world&quot;, :sen &quot;nothing&quot;}]} {:s2 &quot;cool2&quot;, :p1 [{:name &quot;wow&quot;, :sen &quot;fine&quot;} {:name &quot;world&quot;, :sen &quot;none&quot;}]}][{:s1 &quot;cool&quot;, :p1 [{:name &quot;hello&quot;, :sen &quot;good&quot;} {:name &quot;world&quot;, :sen &quot;nothing&quot;}]}]"><y>#</y><d>2017-12-14</d><h>11:50</h><w>abdullahibra</w>[{:s1 &quot;cool&quot;, :p1 [{:name &quot;hello&quot;, :sen &quot;good&quot;} {:name &quot;world&quot;, :sen &quot;nothing&quot;}]} {:s2 &quot;cool2&quot;, :p1 [{:name &quot;wow&quot;, :sen &quot;fine&quot;} {:name &quot;world&quot;, :sen &quot;none&quot;}]}][{:s1 &quot;cool&quot;, :p1 [{:name &quot;hello&quot;, :sen &quot;good&quot;} {:name &quot;world&quot;, :sen &quot;nothing&quot;}]}]</z><z id="t1513252236" t="abdullahibra i want to get only hash maps which contain :name &quot;world&quot; and :sen &quot;nothing&quot;"><y>#</y><d>2017-12-14</d><h>11:50</h><w>abdullahibra</w>i want to get only hash maps which contain :name &quot;world&quot; and :sen &quot;nothing&quot;</z><z id="t1513252252" t="abdullahibra i have tried:"><y>#</y><d>2017-12-14</d><h>11:50</h><w>abdullahibra</w>i have tried:</z><z id="t1513252255" t="abdullahibra (select [ALL (selected? :p1 ALL (multi-path :token :sen) [#(= &quot;world&quot; (:name %)) #(= &quot;nothing&quot; (:sen %))])] data)"><y>#</y><d>2017-12-14</d><h>11:50</h><w>abdullahibra</w>(select [ALL (selected? :p1 ALL (multi-path :token :sen) [#(= &quot;world&quot; (:name %)) #(= &quot;nothing&quot; (:sen %))])] data)</z><z id="t1513252303" t="abdullahibra @nathanmarz"><y>#</y><d>2017-12-14</d><h>11:51</h><w>abdullahibra</w>@nathanmarz</z><z id="t1513256497" t="nathanmarz @abdullahibra (select [ALL (selected? :p1 ALL #(= (:name %) &quot;world&quot;) #(= (:sen %) &quot;nothing&quot;))] data)"><y>#</y><d>2017-12-14</d><h>13:01</h><w>nathanmarz</w>@abdullahibra <code>(select [ALL (selected? :p1 ALL #(= (:name %) &quot;world&quot;) #(= (:sen %) &quot;nothing&quot;))] data)</code></z><z id="t1513259569" t="abdullahibra thanks man 🙂 , your video is very worthwhile i have watched it"><y>#</y><d>2017-12-14</d><h>13:52</h><w>abdullahibra</w>thanks man <b>🙂</b>, your video is very worthwhile i have watched it</z><z id="t1513261612" t="nathanmarz @abdullahibra thanks"><y>#</y><d>2017-12-14</d><h>14:26</h><w>nathanmarz</w>@abdullahibra thanks</z><z id="t1513261639" t="nathanmarz it&apos;s pretty out of date though, my blog post is the best introductory resource"><y>#</y><d>2017-12-14</d><h>14:27</h><w>nathanmarz</w>it&apos;s pretty out of date though, my blog post is the best introductory resource</z><z id="t1513261674" t="benstox Hi there, a question about walkers. If I have a data structure like this and I want to get all the leaves that have more than just whitespace in them, but still return the structure where they live: (def structure [ &quot;leaf1&quot; &quot;\n&quot; {:contents [ {:contents [&quot;leaf3&quot;]} {:contents [ {:contents [ &quot;leaf5&quot; &quot;leaf6&quot; &quot;\n&quot;]}]} &quot;\n&quot; {:contents [ &quot;\n&quot; &quot;\n&quot;]}]} {:contents [ &quot;leaf2&quot; {:contents []}]} &quot;leaf4&quot;]) So I’d hope to return a structure like this: [ &quot;leaf1&quot; {:contents [ {:contents [&quot;leaf3&quot;]} {:contents [ {:contents [ &quot;leaf5&quot; &quot;leaf6&quot;]}]}]} {:contents [&quot;leaf2&quot;]} &quot;leaf4&quot;] I can get all the right leaves but not the structure with this: (select [(walker #(and (string? %) (re-find #&quot;\S&quot; %)))] structure) I thought maybe filterer would be the right tool for this but couldn’t get it to work. Am I going about this the right way?"><y>#</y><d>2017-12-14</d><h>14:27</h><w>benstox</w>Hi there, a question about walkers. If I have a data structure like this and I want to get all the leaves that have more than just whitespace in them, but still return the structure where they live:
<pre>(def structure [
  &quot;leaf1&quot;
  &quot;\n&quot;
  {:contents [
    {:contents [&quot;leaf3&quot;]}
    {:contents [
      {:contents [
        &quot;leaf5&quot;
        &quot;leaf6&quot;
        &quot;\n&quot;]}]}
    &quot;\n&quot;
    {:contents [
      &quot;\n&quot;
      &quot;\n&quot;]}]}
  {:contents [
    &quot;leaf2&quot;
    {:contents []}]}
  &quot;leaf4&quot;])
</pre>
So I’d hope to return a structure like this:
<pre>[
  &quot;leaf1&quot;
  {:contents [
    {:contents [&quot;leaf3&quot;]}
    {:contents [
      {:contents [
        &quot;leaf5&quot;
        &quot;leaf6&quot;]}]}]}
  {:contents [&quot;leaf2&quot;]}
  &quot;leaf4&quot;]
</pre>
I can get all the right leaves but not the structure with this:
<pre>(select [(walker #(and (string? %) (re-find #&quot;\S&quot; %)))] structure)
</pre>
I thought maybe <code>filterer</code> would be the right tool for this but couldn’t get it to work. Am I going about this the right way?</z><z id="t1513263665" t="nathanmarz @benstox the right approach is to do a transform and remove elements that have whitespace"><y>#</y><d>2017-12-14</d><h>15:01</h><w>nathanmarz</w>@benstox the right approach is to do a <code>transform</code> and remove elements that have whitespace</z><z id="t1513263675" t="nathanmarz don&apos;t use walker"><y>#</y><d>2017-12-14</d><h>15:01</h><w>nathanmarz</w>don&apos;t use <code>walker</code></z><z id="t1513263896" t="nathanmarz (def NODES (recursive-path [] p (continue-then-stay (cond-path vector? [ALL p] map? [MAP-VALS p]) ))) (defn whitespace? [s] (= &quot;\n&quot; s)) (setval [NODES (if-path string? whitespace? empty?)] NONE structure) "><y>#</y><d>2017-12-14</d><h>15:04</h><w>nathanmarz</w><pre>(def NODES
  (recursive-path [] p
    (continue-then-stay
      (cond-path vector? [ALL p]
                 map? [MAP-VALS p])
      )))

(defn whitespace? [s] (= &quot;\n&quot; s))

(setval [NODES (if-path string? whitespace? empty?)] NONE structure)
</pre></z><z id="t1513263943" t="nathanmarz just fill in whitespace? with a complete implementation"><y>#</y><d>2017-12-14</d><h>15:05</h><w>nathanmarz</w>just fill in <code>whitespace?</code> with a complete implementation</z><z id="t1513264106" t="benstox I see. Thanks a lot! I’ll try something like that."><y>#</y><d>2017-12-14</d><h>15:08</h><w>benstox</w>I see. Thanks a lot! I’ll try something like that.</z><z id="t1513298680" t="jrheard hi, specter rookie here, i’m sure there’s a simple way to do this:"><y>#</y><d>2017-12-15</d><h>00:44</h><w>jrheard</w>hi, specter rookie here, i’m sure there’s a simple way to do this:</z><z id="t1513298693" t="jrheard i have a grid , which is a vector of vectors of values; those values are either numbers or nil"><y>#</y><d>2017-12-15</d><h>00:44</h><w>jrheard</w>i have a <code>grid</code>, which is a vector of vectors of values; those values are either numbers or nil</z><z id="t1513298717" t="jrheard i’d like to write a specter query that gets me the indexes of all non-nil elements in grid"><y>#</y><d>2017-12-15</d><h>00:45</h><w>jrheard</w>i’d like to write a specter query that gets me the indexes of all non-nil elements in <code>grid</code></z><z id="t1513298756" t="jrheard i can get the non-nil elements themselves by doing (select [ALL ALL (comp not nil?)] (@app-state :grid)) which gives me eg (8 2 3 5 7)"><y>#</y><d>2017-12-15</d><h>00:45</h><w>jrheard</w>i can get the non-nil elements themselves by doing
<pre>(select [ALL ALL (comp not nil?)]
                  (@app-state :grid))
</pre>
which gives me eg <code>(8 2 3 5 7)</code></z><z id="t1513298775" t="jrheard but i’d like instead to be given eg ([5 3] [2 2] [3 1] [6 1] [4 2]) or whatever"><y>#</y><d>2017-12-15</d><h>00:46</h><w>jrheard</w>but i’d like instead to be given eg <code>([5 3] [2 2] [3 1] [6 1] [4 2])</code> or whatever</z><z id="t1513298798" t="jrheard i.e. a list of the locations of those non-nil values in the grid, encoded as x-y pairs"><y>#</y><d>2017-12-15</d><h>00:46</h><w>jrheard</w>i.e. a list of the locations of those non-nil values in the grid, encoded as x-y pairs</z><z id="t1513299046" t="jrheard the vanilla clojure code i have to do this is (apply concat (for [x (range (count grid))] (for [y (range (count (grid x))) :when (not (nil? (get-in grid [x y])))] [x y])))) , but i have a comment above it saying “; xxx is there a way to do this in specter”, so here i am 🙂 thanks!"><y>#</y><d>2017-12-15</d><h>00:50</h><w>jrheard</w>the vanilla clojure code i have to do this is <pre>(apply concat
         (for [x (range (count grid))]
           (for [y (range (count (grid x)))
                 :when (not (nil? (get-in grid [x y])))]
             [x y]))))</pre>, but i have a comment above it saying “; xxx is there a way to do this in specter”, so here i am <b>🙂</b> thanks!</z><z id="t1513305827" t="nathanmarz @jrheard like this: (select [INDEXED-VALS (collect-one FIRST) LAST INDEXED-VALS (selected? LAST some?) FIRST] grid)"><y>#</y><d>2017-12-15</d><h>02:43</h><w>nathanmarz</w>@jrheard like this: <code>(select [INDEXED-VALS (collect-one FIRST) LAST INDEXED-VALS (selected? LAST some?) FIRST] grid)</code></z><z id="t1513305859" t="nathanmarz will be a lot faster than that clojure code too"><y>#</y><d>2017-12-15</d><h>02:44</h><w>nathanmarz</w>will be a lot faster than that clojure code too</z><z id="t1513343621" t="mbjarland @nathanmarz The dependency chain we discussed yesterday is a step closer to completion, the pull request on suchwow was accepted, I&apos;ve created a ticket on midje and we&apos;re waiting for build to get deployed to clojars for suchwow ( https://github.com/marick/Midje/issues/427 )"><y>#</y><d>2017-12-15</d><h>13:13</h><w>mbjarland</w>@nathanmarz The dependency chain we discussed yesterday is a step closer to completion, the pull request on suchwow was accepted, I&apos;ve created a ticket on midje and we&apos;re waiting for build to get deployed to clojars for suchwow (<a href="https://github.com/marick/Midje/issues/427" target="_blank">https://github.com/marick/Midje/issues/427</a>)</z><z id="t1513361990" t="nathanmarz @mbjarland ok, that&apos;s good"><y>#</y><d>2017-12-15</d><h>18:19</h><w>nathanmarz</w>@mbjarland ok, that&apos;s good</z><z id="t1513362016" t="nathanmarz btw, have you tried just overriding the dependency with the latest version? should make the warning go away"><y>#</y><d>2017-12-15</d><h>18:20</h><w>nathanmarz</w>btw, have you tried just overriding the dependency with the latest version? should make the warning go away</z><z id="t1513362931" t="mbjarland @nathanmarz no haven’t done that yet and really, it’s just a warning during a test run so not that big a deal to begin with. I’m happy to wait for the transitive chain to percolate up to midje"><y>#</y><d>2017-12-15</d><h>18:35</h><w>mbjarland</w>@nathanmarz no haven’t done that yet and really, it’s just a warning during a test run so not that big a deal to begin with. I’m happy to wait for the transitive chain to percolate up to midje</z><z id="t1513377035" t="jrheard thanks! that does give the same results, excellent"><y>#</y><d>2017-12-15</d><h>22:30</h><w>jrheard</w>thanks! that does give the same results, excellent</z><z id="t1513377074" t="jrheard i don’t yet understand what the collecting-values is system is / how it works, will read the docs more closely!"><y>#</y><d>2017-12-15</d><h>22:31</h><w>jrheard</w>i don’t yet understand what the collecting-values is system is / how it works, will read the docs more closely!</z><z id="t1513377180" t="jrheard the README makes it look pretty clear, i think i’ve just gotta play around with specter some more to build up some muscle memory and get to a point where this feels more natural 🙂"><y>#</y><d>2017-12-15</d><h>22:33</h><w>jrheard</w>the README makes it look pretty clear, i think i’ve just gotta play around with specter some more to build up some muscle memory and get to a point where this feels more natural <b>🙂</b></z><z id="t1513377287" t="jrheard the examples at https://github.com/nathanmarz/specter/wiki/List-of-Navigators#collect are v helpful"><y>#</y><d>2017-12-15</d><h>22:34</h><w>jrheard</w>the examples at <a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#collect" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#collect</a> are v helpful</z><z id="t1513378055" t="nathanmarz @jrheard collected values are a vector that is passed along through navigation"><y>#</y><d>2017-12-15</d><h>22:47</h><w>nathanmarz</w>@jrheard collected values are a vector that is passed along through navigation</z><z id="t1513378069" t="nathanmarz you can see the interface here: https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L3"><y>#</y><d>2017-12-15</d><h>22:47</h><w>nathanmarz</w>you can see the interface here: <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L3" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L3</a></z><z id="t1513378088" t="jrheard and the result of the selection is basically (concat collected-values value-you-navigated-to) ?"><y>#</y><d>2017-12-15</d><h>22:48</h><w>jrheard</w>and the result of the selection is basically (concat collected-values value-you-navigated-to) ?</z><z id="t1513378127" t="nathanmarz yes"><y>#</y><d>2017-12-15</d><h>22:48</h><w>nathanmarz</w>yes</z><z id="t1513378130" t="jrheard sick"><y>#</y><d>2017-12-15</d><h>22:48</h><w>jrheard</w>sick</z><z id="t1513378132" t="nathanmarz conj , not concat"><y>#</y><d>2017-12-15</d><h>22:48</h><w>nathanmarz</w><code>conj</code>, not <code>concat</code></z><z id="t1513378134" t="jrheard aha"><y>#</y><d>2017-12-15</d><h>22:48</h><w>jrheard</w>aha</z><z id="t1513378150" t="jrheard right, i follow"><y>#</y><d>2017-12-15</d><h>22:49</h><w>jrheard</w>right, i follow</z><z id="t1513378153" t="jrheard thanks! 🙂"><y>#</y><d>2017-12-15</d><h>22:49</h><w>jrheard</w>thanks! <b>🙂</b></z><z id="t1513378184" t="jrheard thanks again for the help with my grid example, i wouldn’t have come up with that specter code but it makes a lot of sense to me now!"><y>#</y><d>2017-12-15</d><h>22:49</h><w>jrheard</w>thanks again for the help with my grid example, i wouldn’t have come up with that specter code but it makes a lot of sense to me now!</z><z id="t1513378218" t="nathanmarz here&apos;s where it happens: https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L285"><y>#</y><d>2017-12-15</d><h>22:50</h><w>nathanmarz</w>here&apos;s where it happens: <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L285" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L285</a></z><z id="t1513378238" t="jrheard niice"><y>#</y><d>2017-12-15</d><h>22:50</h><w>jrheard</w>niice</z><z id="t1513452476" t="jrheard is there a natural way to use srange , like, backward?"><y>#</y><d>2017-12-16</d><h>19:27</h><w>jrheard</w>is there a natural way to use <code>srange</code>, like, backward?</z><z id="t1513452484" t="jrheard begin unreasonably long context dump for which i am greatly sorry: again, i have a 2d grid of values that are integers or nil"><y>#</y><d>2017-12-16</d><h>19:28</h><w>jrheard</w>begin unreasonably long context dump for which i am greatly sorry:
again, i have a 2d grid of values that are integers or nil</z><z id="t1513452520" t="jrheard i need to start at a particular x,y point on the grid and get the values seen as you walk four steps in each of the cardinal directions from that x,y point"><y>#</y><d>2017-12-16</d><h>19:28</h><w>jrheard</w>i need to start at a particular x,y point on the grid and get the values seen as you walk four steps in each of the cardinal directions from that x,y point</z><z id="t1513452545" t="jrheard i call these “runs”, they’re related to the logic of this game i’m programming"><y>#</y><d>2017-12-16</d><h>19:29</h><w>jrheard</w>i call these “runs”, they’re related to the logic of this game i’m programming</z><z id="t1513452558" t="jrheard so far, getting the right run and the down run is pretty straightforward:"><y>#</y><d>2017-12-16</d><h>19:29</h><w>jrheard</w>so far, getting the right run and the down run is pretty straightforward:</z><z id="t1513452569" t="jrheard (let [x 6 y 8] {:right-run (select [(srange (inc x) (+ x MAX-RUN-LENGTH)) ALL y] (@app-state :grid)) :down-run (select [x (srange (inc y) (+ y MAX-RUN-LENGTH)) ALL] (@app-state :grid)) })"><y>#</y><d>2017-12-16</d><h>19:29</h><w>jrheard</w><pre>(let [x 6
        y 8]
    {:right-run (select [(srange (inc x) (+ x MAX-RUN-LENGTH)) ALL
                         y]
                        (@app-state :grid))
     :down-run (select [x
                        (srange (inc y) (+ y MAX-RUN-LENGTH)) ALL]
                       (@app-state :grid))
     })</pre></z><z id="t1513452629" t="jrheard but i’m having trouble figuring out how to do the left and up runs"><y>#</y><d>2017-12-16</d><h>19:30</h><w>jrheard</w>but i’m having trouble figuring out how to do the left and up runs</z><z id="t1513452696" t="jrheard i could do it by hand in each of those cases - eg, if you’re going left, then in that situation you do (srange (- x MAX-RUN-LENGTH) x)"><y>#</y><d>2017-12-16</d><h>19:31</h><w>jrheard</w>i could do it by hand in each of those cases - eg, if you’re going left, then in that situation you do <code>(srange (- x MAX-RUN-LENGTH) x)</code></z><z id="t1513452725" t="jrheard maybe that’s just the sanest thing to do here"><y>#</y><d>2017-12-16</d><h>19:32</h><w>jrheard</w>maybe that’s just the sanest thing to do here</z><z id="t1513452783" t="jrheard my preexisting clojure code involved a function (find-runs [x y xdir ydir]), with invocations like (find-runs x y 0 -1) , and so inside that function you’ve got a single bit of run-finding code that can handle any of the four cardinal directions"><y>#</y><d>2017-12-16</d><h>19:33</h><w>jrheard</w>my preexisting clojure code involved a function (find-runs [x y xdir ydir]), with invocations like <code>(find-runs x y 0 -1)</code>, and so inside that function you’ve got a single bit of run-finding code that can handle any of the four cardinal directions</z><z id="t1513452830" t="jrheard but it looks like if i want to specterize this code, the sanest thing is to write four specter select calls by hand, rather than reimplement (find-runs x y xdir ydir) in a way that uses a single select call whose path is heavily parameterized? apologies if any of this is foolish / obvious / doesn’t make any sense"><y>#</y><d>2017-12-16</d><h>19:33</h><w>jrheard</w>but it looks like if i want to specterize this code, the sanest thing is to write four specter <code>select</code> calls by hand, rather than reimplement <code>(find-runs x y xdir ydir)</code> in a way that uses a single <code>select</code> call whose path is heavily parameterized? apologies if any of this is foolish / obvious / doesn’t make any sense</z><z id="t1513452919" t="jrheard preexisting implementation of find-runs in case it’s helpful:"><y>#</y><d>2017-12-16</d><h>19:35</h><w>jrheard</w>preexisting implementation of <code>find-runs</code> in case it’s helpful:</z><z id="t1513452923" t="jrheard (reduce (fn [[run-length run-sum] num-steps-in-direction] ; Find the position of the cell we&apos;re currently examining. (let [run-x (+ x (* xdir num-steps-in-direction)) run-y (+ y (* ydir num-steps-in-direction))] (if (or (not (cell-is-on-grid grid run-x run-y)) (nil? (get-in grid [run-x run-y]))) ; If the cell&apos;s value is nil or this position is off the grid, the run is over. (reduced [run-length run-sum]) ; Otherwise, record this cell&apos;s value and continue following the run. [(inc run-length) (+ run-sum (get-in grid [run-x run-y]))]))) [0 0] (map inc (range)))"><y>#</y><d>2017-12-16</d><h>19:35</h><w>jrheard</w><pre>(reduce (fn [[run-length run-sum] num-steps-in-direction]
     ; Find the position of the cell we&apos;re currently examining.
     (let [run-x (+ x (* xdir num-steps-in-direction))
           run-y (+ y (* ydir num-steps-in-direction))]
       (if (or (not (cell-is-on-grid grid run-x run-y))
               (nil? (get-in grid [run-x run-y])))
         ; If the cell&apos;s value is nil or this position is off the grid, the run is over.
         (reduced [run-length run-sum])
         ; Otherwise, record this cell&apos;s value and continue following the run.
         [(inc run-length)
          (+ run-sum (get-in grid [run-x run-y]))])))
   [0 0]
   (map inc (range)))</pre></z><z id="t1513452998" t="jrheard the end goal here is to come up with a “run”, which is essentially [(count run-values) (apply + run-values)]"><y>#</y><d>2017-12-16</d><h>19:36</h><w>jrheard</w>the end goal here is to come up with a “run”, which is essentially <code>[(count run-values) (apply + run-values)]</code></z><z id="t1513453083" t="jrheard and again, the main problem i’m having trouble with is figuring out whether it’s sanely possible to write a single select call that’s parameterized on x , y , xdir , and ydir , or if that select call would be too grody and i should instead write four single-purpose select calls by hand"><y>#</y><d>2017-12-16</d><h>19:38</h><w>jrheard</w>and again, the main problem i’m having trouble with is figuring out whether it’s sanely possible to write a single <code>select</code> call that’s parameterized on <code>x</code>, <code>y</code>, <code>xdir</code>, and <code>ydir</code>, or if that <code>select</code> call would be too grody and i should instead write four single-purpose <code>select</code> calls by hand</z><z id="t1513453114" t="jrheard i’ll do the by-hand approach for now, this is a toy project and doesn’t matter, but thanks in advance for your time and advice! 🙂"><y>#</y><d>2017-12-16</d><h>19:38</h><w>jrheard</w>i’ll do the by-hand approach for now, this is a toy project and doesn’t matter, but thanks in advance for your time and advice! <b>🙂</b></z><z id="t1513453709" t="jrheard here’s what i ended up with: (defn grid-range [start end direction] (srange (max start 0) (min end (if (= direction :horizontal) GRID-WIDTH GRID-HEIGHT)))) (let [x 6 y 4] {:right-run (select [(grid-range (inc x) (+ x MAX-RUN-LENGTH) :horizontal) ALL y] (@app-state :grid)) :down-run (select [x (grid-range (inc y) (+ y MAX-RUN-LENGTH) :vertical) ALL] (@app-state :grid)) :left-run (select [(grid-range (- x (dec MAX-RUN-LENGTH)) x :horizontal) ALL y] (@app-state :grid)) :up-run (select [x (grid-range (- y (dec MAX-RUN-LENGTH)) y :vertical) ALL] (@app-state :grid))}) the sanest way i can think to clean it up is to make a function like eg (get-run-selector-path x y :left) , which is implemented with just a cond with four branches, and the :left branch looks like [(grid-range (- x (dec MAX-RUN-LENGTH)) x :horizontal) ALL y] , etc; maybe there’s a saner thing to do here though?"><y>#</y><d>2017-12-16</d><h>19:48</h><w>jrheard</w>here’s what i ended up with: 
<pre>(defn grid-range [start end direction]
  (srange (max start 0)
          (min end (if (= direction :horizontal)
                     GRID-WIDTH
                     GRID-HEIGHT))))

(let [x 6
      y 4]
  {:right-run (select [(grid-range (inc x) (+ x MAX-RUN-LENGTH) :horizontal) ALL
                       y]
                      (@app-state :grid))
   :down-run  (select [x
                       (grid-range (inc y) (+ y MAX-RUN-LENGTH) :vertical) ALL]
                      (@app-state :grid))
   :left-run  (select [(grid-range (- x (dec MAX-RUN-LENGTH)) x :horizontal) ALL
                       y]
                      (@app-state :grid))
   :up-run    (select [x
                       (grid-range (- y (dec MAX-RUN-LENGTH)) y :vertical) ALL]
                      (@app-state :grid))})
</pre>
the sanest way i can think to clean it up is to make a function like eg <code>(get-run-selector-path x y :left)</code>, which is implemented with just a <code>cond</code> with four branches, and the <code>:left</code> branch looks  like <code>[(grid-range (- x (dec MAX-RUN-LENGTH)) x :horizontal) ALL y]</code>, etc; maybe there’s a saner thing to do here though?</z><z id="t1513454076" t="jrheard all this is further complicated by the fact that i’d like all the runs’ values to be in order based on their direction from the origin cell because a “run” just means “a series of values in a row, in each cardinal direction, starting at this cell but excluding this cell’s value, with maximum length 4, stopping as soon as you see your first nil”."><y>#</y><d>2017-12-16</d><h>19:54</h><w>jrheard</w>all this is further complicated by the fact that i’d like all the runs’ values to be in order based on their direction from the origin cell because a “run” just means “a series of values in a row, in each cardinal direction, starting at this cell but excluding this cell’s value, with maximum length 4, stopping as soon as you see your first nil”.</z><z id="t1513454122" t="jrheard so i’ll need to end up reversing left-run and up-run and then call (take-until nil the-run) on each of my four runs. and at the end of the day i’m like, maybe the end result in specter will be insane and i should just stick with my preexisting implementation, which is looking way better now that i’m comparing the two? and if so, that’s totally cool. again, sorry for the wall of text!"><y>#</y><d>2017-12-16</d><h>19:55</h><w>jrheard</w>so i’ll need to end up reversing <code>left-run</code> and <code>up-run</code> and then call <code>(take-until nil the-run)</code> on each of my four runs. and at the end of the day i’m like, maybe the end result in specter will be insane and i should just stick with my preexisting implementation, which is looking way better now that i’m comparing the two? and if so, that’s totally cool. again, sorry for the wall of text!</z><z id="t1513454636" t="jrheard in case it’s helpful, the game board looks like this: http://jrheard.com/quinto/ the “make a move” button has the AI detect the highest-scoring possible move and make it. there isn’t yet a way for the user to make a move, and there isn’t yet a visible score or any explanation of how the game works. the game’s basically scrabble but for numbers, the goal is to make “runs” of numbers that sum up to a multiple of five, it’s called quinto, my friend found it at goodwill and it seems like basically zero people in the world have ever played it"><y>#</y><d>2017-12-16</d><h>20:03</h><w>jrheard</w>in case it’s helpful, the game board looks like this: <a href="http://jrheard.com/quinto/" target="_blank">http://jrheard.com/quinto/</a>

the “make a move” button has the AI detect the highest-scoring possible move and make it. there isn’t yet a way for the user to make a move, and there isn’t yet a visible score or any explanation of how the game works. the game’s basically scrabble but for numbers, the goal is to make “runs” of numbers that sum up to a multiple of five, it’s called quinto, my friend found it at goodwill and it seems like basically zero people in the world have ever played it</z><z id="t1513460315" t="nathanmarz @jrheard your use case is probably best handled with matrix-specific navigators"><y>#</y><d>2017-12-16</d><h>21:38</h><w>nathanmarz</w>@jrheard your use case is probably best handled with matrix-specific navigators</z><z id="t1513460360" t="nathanmarz here&apos;s an excerpt from some code I have: (defnav matrix-elem [row col] (select* [this structure next-fn] (next-fn (-&gt; structure :rows (nth row) (nth col))) ) (transform* [this structure next-fn] (let [rows (:rows structure) r (nth rows row) new-elem (next-fn (nth r col))] (-&gt;Matrix (assoc rows row (assoc r col new-elem))) ))) "><y>#</y><d>2017-12-16</d><h>21:39</h><w>nathanmarz</w>here&apos;s an excerpt from some code I have:
<pre>(defnav matrix-elem [row col]
  (select* [this structure next-fn]
    (next-fn (-&gt; structure :rows (nth row) (nth col)))
    )
  (transform* [this structure next-fn]
    (let [rows (:rows structure)
          r (nth rows row)
          new-elem (next-fn (nth r col))]
      (-&gt;Matrix (assoc rows row (assoc r col new-elem)))
      )))
</pre></z><z id="t1513460398" t="nathanmarz you could also make a &quot;submat&quot; navigator that navigates you to a submatrix"><y>#</y><d>2017-12-16</d><h>21:39</h><w>nathanmarz</w>you could also make a &quot;submat&quot; navigator that navigates you to a submatrix</z><z id="t1513460491" t="nathanmarz then you could do something like (select [(submat 4 2 8 2) ALL ALL] mat) to get the &quot;down run&quot;"><y>#</y><d>2017-12-16</d><h>21:41</h><w>nathanmarz</w>then you could do something like <code>(select [(submat 4 2 8 2) ALL ALL] mat)</code> to get the &quot;down run&quot;</z><z id="t1513460833" t="nathanmarz for a less flexible approach you could have a submat-elems function like so: (defnav matrix-elem [row col] (select* [this structure next-fn] (next-fn (-&gt; structure(nth row) (nth col))) ) (transform* [this structure next-fn] (let [rows (:rows structure) r (nth rows row) new-elem (next-fn (nth r col))] (assoc rows row (assoc r col new-elem)) ))) (defn ^:direct-nav submat-elems [row col row2 col2] (reduce multi-path (for [r (range row (inc row2)) c (range col (inc col2))] (matrix-elem r c) ))) (def data [[1 2 3 4] [5 6 7 8] [9 :a :b :c] [:d :e :f :g]]) (select (submat-elems 1 1 3 1) data) ;; =&gt; [6 :a :e] "><y>#</y><d>2017-12-16</d><h>21:47</h><w>nathanmarz</w>for a less flexible approach you could have a <code>submat-elems</code> function like so:
<pre>(defnav matrix-elem [row col]
  (select* [this structure next-fn]
    (next-fn (-&gt; structure(nth row) (nth col)))
    )
  (transform* [this structure next-fn]
    (let [rows (:rows structure)
          r (nth rows row)
          new-elem (next-fn (nth r col))]
      (assoc rows row (assoc r col new-elem))
      )))

(defn ^:direct-nav submat-elems [row col row2 col2]
  (reduce
    multi-path
    (for [r (range row (inc row2))
          c (range col (inc col2))]
      (matrix-elem r c)
      )))

(def data
  [[1   2   3   4]
   [5   6   7   8]
   [9   :a  :b  :c]
   [:d  :e  :f  :g]])

(select (submat-elems 1 1 3 1) data)
;; =&gt; [6 :a :e]
</pre></z><z id="t1513460910" t="nathanmarz technically you don&apos;t really need matrix-elem and can just use nthpath"><y>#</y><d>2017-12-16</d><h>21:48</h><w>nathanmarz</w>technically you don&apos;t really need <code>matrix-elem</code> and can just use <code>nthpath</code></z><z id="t1513477024" t="jrheard thanks nathan! i’ll take a closer look at this tomorrow, much appreciated! 🙂"><y>#</y><d>2017-12-17</d><h>02:17</h><w>jrheard</w>thanks nathan! i’ll take a closer look at this tomorrow, much appreciated! <b>🙂</b></z><z id="t1513549956" t="jrheard that absolutely did what i wanted - i added bounds checking and added my desired reversing behavior when row2 &lt; row or col2 &lt; col, and ended up with this, which i haven’t tested thoroughly but seems to be correct so far:"><y>#</y><d>2017-12-17</d><h>22:32</h><w>jrheard</w>that absolutely did what i wanted - i added bounds checking and added my desired reversing behavior when row2 &lt; row or col2 &lt; col, and ended up with this, which i haven’t tested thoroughly but seems to be correct so far:</z><z id="t1513549960" t="jrheard (defn ^:direct-nav grid-values [x1 y1 x2 y2] (if (g/cell-is-on-grid x1 y1) (let [x2 (bound-between x2 0 (dec GRID-WIDTH)) y2 (bound-between y2 0 (dec GRID-HEIGHT))] (reduce multi-path (for [x (if (&lt; x1 x2) (range x1 (inc x2)) (reverse (range x2 (inc x1)))) y (if (&lt; y1 y2) (range y1 (inc y2)) (reverse (range y2 (inc y1))))] (nthpath x y)))) STOP))"><y>#</y><d>2017-12-17</d><h>22:32</h><w>jrheard</w><pre>(defn ^:direct-nav grid-values
  [x1 y1 x2 y2]
  (if (g/cell-is-on-grid x1 y1)
    (let [x2 (bound-between x2 0 (dec GRID-WIDTH))
          y2 (bound-between y2 0 (dec GRID-HEIGHT))]

      (reduce
        multi-path
        (for [x (if (&lt; x1 x2)
                  (range x1 (inc x2))
                  (reverse (range x2 (inc x1))))
              y (if (&lt; y1 y2)
                  (range y1 (inc y2))
                  (reverse (range y2 (inc y1))))]
          (nthpath x y))))

    STOP))</pre></z><z id="t1513549969" t="jrheard thanks so much for your help, i really appreciate it!"><y>#</y><d>2017-12-17</d><h>22:32</h><w>jrheard</w>thanks so much for your help, i really appreciate it!</z><z id="t1513550541" t="jrheard final usage ends up looking like this, replacing my reduce from earlier: (fn [xdir ydir] (let [values-in-direction (select (grid-values (+ x xdir) (+ y ydir) (+ x (* xdir MAX-RUN-LENGTH)) (+ y (* ydir MAX-RUN-LENGTH))) grid) run-values (take-while (comp not nil?) values-in-direction)] [(count run-values) (apply + run-values)]))"><y>#</y><d>2017-12-17</d><h>22:42</h><w>jrheard</w>final usage ends up looking like this, replacing my reduce from earlier:
<pre>(fn [xdir ydir]
   (let [values-in-direction (select (grid-values (+ x xdir)
                                                  (+ y ydir)
                                                  (+ x (* xdir MAX-RUN-LENGTH))
                                                  (+ y (* ydir MAX-RUN-LENGTH)))
                                     grid)
         run-values (take-while (comp not nil?) values-in-direction)]
     [(count run-values) (apply + run-values)]))</pre></z><z id="t1513550569" t="jrheard seems to be way slower than my previous reduce implementation though, dang - likely some mistake on my end, will profile"><y>#</y><d>2017-12-17</d><h>22:42</h><w>jrheard</w>seems to be way slower than my previous reduce implementation though, dang - likely some mistake on my end, will profile</z><z id="t1513551325" t="jrheard ok yeah now my program spends 88% of its time in com.rpl.specter.impl.mk_dynamic_path_maker"><y>#</y><d>2017-12-17</d><h>22:55</h><w>jrheard</w>ok yeah now my program spends 88% of its time in com.rpl.specter.impl.mk_dynamic_path_maker</z><z id="t1513551432" t="jrheard the specterized code above is awesome though, i really like it way more than my handrolled reduce from yesterday - it untangles the computation into its component parts (first get a list of up to 5 values in this direction, then drop everything after and including the first nil, then count the values and sum them)"><y>#</y><d>2017-12-17</d><h>22:57</h><w>jrheard</w>the specterized code above is awesome though, i really like it way more than my handrolled reduce from yesterday - it untangles the computation into its component parts (first get a list of up to 5 values in this direction, then drop everything after and including the first nil, then count the values and sum them)</z><z id="t1513551440" t="jrheard whereas my previous code did all those things at once"><y>#</y><d>2017-12-17</d><h>22:57</h><w>jrheard</w>whereas my previous code did all those things at once</z><z id="t1513551461" t="jrheard so i remain a big fan of specter and also remain appreciative of your help, but am not sure how to proceed performancewise"><y>#</y><d>2017-12-17</d><h>22:57</h><w>jrheard</w>so i remain a big fan of specter and also remain appreciative of your help, but am not sure how to proceed performancewise</z><z id="t1513551483" t="jrheard it’s the weekend, this is a toy project and non-urgent, no rush on a reply 🙂 thanks!"><y>#</y><d>2017-12-17</d><h>22:58</h><w>jrheard</w>it’s the weekend, this is a toy project and non-urgent, no rush on a reply <b>🙂</b> thanks!</z><z id="t1513551857" t="jrheard if it’s helpful, a screenshot of the profile data: https://www.evernote.com/shard/s11/sh/73bf32be-7f86-414d-adcb-d61279942fd2/b3618565f1ea939f (percentages shown are different because i’ve filtered for com.rpl.specter, i believe)"><y>#</y><d>2017-12-17</d><h>23:04</h><w>jrheard</w>if it’s helpful, a screenshot of the profile data: <a href="https://www.evernote.com/shard/s11/sh/73bf32be-7f86-414d-adcb-d61279942fd2/b3618565f1ea939f" target="_blank">https://www.evernote.com/shard/s11/sh/73bf32be-7f86-414d-adcb-d61279942fd2/b3618565f1ea939f</a> (percentages shown are different because i’ve filtered for com.rpl.specter, i believe)</z><z id="t1513552080" t="jrheard and the profile itself (55MB): http://jrheard.com/quinto_specter_profile"><y>#</y><d>2017-12-17</d><h>23:08</h><w>jrheard</w>and the profile itself (55MB): <a href="http://jrheard.com/quinto_specter_profile" target="_blank">http://jrheard.com/quinto_specter_profile</a></z><z id="t1513552225" t="nathanmarz @jrheard it would be a lot faster as a first-class navigator"><y>#</y><d>2017-12-17</d><h>23:10</h><w>nathanmarz</w>@jrheard it would be a lot faster as a first-class navigator</z><z id="t1513552245" t="nathanmarz implementation would be similar to ALL , except in two dimensions"><y>#</y><d>2017-12-17</d><h>23:10</h><w>nathanmarz</w>implementation would be similar to <code>ALL</code>, except in two dimensions</z><z id="t1513552319" t="nathanmarz it would be easy to also avoid needing to do two nth per element, since you can do every matching value in a row one after another"><y>#</y><d>2017-12-17</d><h>23:11</h><w>nathanmarz</w>it would be easy to also avoid needing to do two <code>nth</code> per element, since you can do every matching value in a row one after another</z><z id="t1513552377" t="jrheard interesting, thanks for the tip! i’ll read through the docs and investigate that line of attack"><y>#</y><d>2017-12-17</d><h>23:12</h><w>jrheard</w>interesting, thanks for the tip! i’ll read through the docs and investigate that line of attack</z><z id="t1513553489" t="jrheard hm, can’t tell if this is a foolish question - would the implementation actually look more like srange rather than all ? the main difference i see is that srange takes arguments start and end , and my thing will also take arguments (`x1`, y1 , x2 , y2 )"><y>#</y><d>2017-12-17</d><h>23:31</h><w>jrheard</w>hm, can’t tell if this is a foolish question - would the implementation actually look more like <code>srange</code> rather than <code>all</code>? the main difference i see is that srange takes arguments <code>start</code> and <code>end</code>, and my thing will also take arguments (`x1`, <code>y1</code>, <code>x2</code>, <code>y2</code>)</z><z id="t1513553531" t="jrheard also, i notice that ALL uses doseqres ( https://github.com/nathanmarz/specter/blob/5efafd2d9bc2714fd87ff81b1268ae6f88256a81/src/clj/com/rpl/specter/util_macros.clj#L3 ) - should i figure out what doseqres does, or can i safely ignore it?"><y>#</y><d>2017-12-17</d><h>23:32</h><w>jrheard</w>also, i notice that <code>ALL</code> uses <code>doseqres</code> ( <a href="https://github.com/nathanmarz/specter/blob/5efafd2d9bc2714fd87ff81b1268ae6f88256a81/src/clj/com/rpl/specter/util_macros.clj#L3" target="_blank">https://github.com/nathanmarz/specter/blob/5efafd2d9bc2714fd87ff81b1268ae6f88256a81/src/clj/com/rpl/specter/util_macros.clj#L3</a> ) - should i figure out what doseqres does, or can i safely ignore it?</z><z id="t1513554475" t="nathanmarz @jrheard I mean it&apos;s going to be similar in function, navigating to many subvalues of a data structure"><y>#</y><d>2017-12-17</d><h>23:47</h><w>nathanmarz</w>@jrheard I mean it&apos;s going to be similar in function, navigating to many subvalues of a data structure</z><z id="t1513554486" t="jrheard gotcha"><y>#</y><d>2017-12-17</d><h>23:48</h><w>jrheard</w>gotcha</z><z id="t1513554486" t="nathanmarz implementation-wise it will be very different"><y>#</y><d>2017-12-17</d><h>23:48</h><w>nathanmarz</w>implementation-wise it will be very different</z><z id="t1513555158" t="jrheard i ended up with this, it’s 4-5x faster than the previous specter approach but still roughly (no benchmarks collected, going solely on how the app feels to use) 1.5-2x slower than the reduce approach. it’s also kind of hideous but that’s my fault: (defnav grid-values-2 [x1 y1 x2 y2] (select* [this structure next-fn] (assert (or (= x1 x2) (= y1 y2))) (next-fn (if (cell-is-on-grid x1 y1) (let [x2 (bound-between x2 0 (dec GRID-WIDTH)) y2 (bound-between y2 0 (dec GRID-HEIGHT))] (if (= x1 x2) (let [column (nth structure x1)] (if (&lt; y1 y2) (subvec column y1 (inc y2)) (reverse (subvec column y2 (inc y1))))) (for [x (if (&lt; x1 x2) (range x1 (inc x2)) (reverse (range x2 (inc x1))))] (-&gt; structure (nth x) (nth y1))))) []))) (transform* [this structure next-fn] ; punting on this for now (assert false)))"><y>#</y><d>2017-12-17</d><h>23:59</h><w>jrheard</w>i ended up with this, it’s 4-5x faster than the previous specter approach but still roughly (no benchmarks collected, going solely on how the app feels to use)  1.5-2x slower than the reduce approach. it’s also kind of hideous but that’s my fault:
<pre>(defnav
  grid-values-2
  [x1 y1 x2 y2]
  (select* [this structure next-fn]
           (assert (or (= x1 x2)
                       (= y1 y2)))

           (next-fn
             (if (cell-is-on-grid x1 y1)
               (let [x2 (bound-between x2 0 (dec GRID-WIDTH))
                     y2 (bound-between y2 0 (dec GRID-HEIGHT))]
                 (if (= x1 x2)
                   (let [column (nth structure x1)]
                     (if (&lt; y1 y2)
                       (subvec column y1 (inc y2))
                       (reverse (subvec column y2 (inc y1)))))

                   (for [x (if (&lt; x1 x2)
                             (range x1 (inc x2))
                             (reverse (range x2 (inc x1))))]
                     (-&gt; structure
                         (nth x)
                         (nth y1)))))
               [])))

  (transform* [this structure next-fn]
              ; punting on this for now
              (assert false)))</pre></z><z id="t1513555209" t="jrheard i’m sure there’s a better and faster way to express this, will stare at it until something comes to mind 😄"><y>#</y><d>2017-12-18</d><h>00:00</h><w>jrheard</w>i’m sure there’s a better and faster way to express this, will stare at it until something comes to mind <b>😄</b></z><z id="t1513555953" t="jrheard hell, sometimes the performance seems noticeably slower, sometimes it seems precisely the same or even faster"><y>#</y><d>2017-12-18</d><h>00:12</h><w>jrheard</w>hell, sometimes the performance seems noticeably slower, sometimes it seems precisely the same or even faster</z><z id="t1513556402" t="jrheard perf is actually pretty acceptable when run through advanced compliation, nice"><y>#</y><d>2017-12-18</d><h>00:20</h><w>jrheard</w>perf is actually pretty acceptable when run through advanced compliation, nice</z><z id="t1513557115" t="jrheard benchmarking stuff now; as you’d expect, that code runs pretty fast ( [:attrs nil] 1400 ms in 1000000 runs) when x1 != x2"><y>#</y><d>2017-12-18</d><h>00:31</h><w>jrheard</w>benchmarking stuff now; as you’d expect, that code runs pretty fast (<del>35ms in 1000000 runs) when x1 = x2, but about 50x slower (</del>1400 ms in 1000000 runs) when x1 != x2</z><z id="t1513557182" t="jrheard so the codepath i need to focus on optimizing is (for [x (if (&lt; x1 x2) (range x1 (inc x2)) (reverse (range x2 (inc x1))))] (-&gt; data (nth x) (nth y1))) . hm - i’m actually not sure how to do this in a more performant way - the ranges and reverses don’t seem to be the issue afaict, it’s just the bit where we have to use nth to index into each column and then call nth on that column to find our value"><y>#</y><d>2017-12-18</d><h>00:33</h><w>jrheard</w>so the codepath i need to focus on optimizing is <pre>(for [x (if (&lt; x1 x2)
          (range x1 (inc x2))
          (reverse (range x2 (inc x1))))]
  (-&gt; data
      (nth x)
      (nth y1)))</pre> . hm - i’m actually not sure how to do this in a more performant way - the ranges and reverses don’t seem to be the issue afaict, it’s just the bit where we have to use nth to index into each column and then call nth on that column to find our value</z><z id="t1513562021" t="nathanmarz @jrheard the select* codepath should call next-fn on each grid cell, rather than calling next-fn on a sequence of cells"><y>#</y><d>2017-12-18</d><h>01:53</h><w>nathanmarz</w>@jrheard the <code>select*</code> codepath should call <code>next-fn</code> on each grid cell, rather than calling <code>next-fn</code> on a sequence of cells</z><z id="t1513562027" t="nathanmarz that will be a lot more performant"><y>#</y><d>2017-12-18</d><h>01:53</h><w>nathanmarz</w>that will be a lot more performant</z><z id="t1513562031" t="jrheard o nice, i’ll try that"><y>#</y><d>2017-12-18</d><h>01:53</h><w>jrheard</w>o nice, i’ll try that</z><z id="t1513562065" t="nathanmarz be sure to read the spec for select* : https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L6"><y>#</y><d>2017-12-18</d><h>01:54</h><w>nathanmarz</w>be sure to read the spec for <code>select*</code>: <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L6" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/protocols.cljc#L6</a></z><z id="t1513562125" t="jrheard will do, thanks!"><y>#</y><d>2017-12-18</d><h>01:55</h><w>jrheard</w>will do, thanks!</z><z id="t1513569512" t="jrheard hm, that may have caused a speedup but not a drastic one"><y>#</y><d>2017-12-18</d><h>03:58</h><w>jrheard</w>hm, that may have caused a speedup but not a drastic one</z><z id="t1513569527" t="jrheard ended up with this: (defnav grid-values [x1 y1 x2 y2] (select* [this structure next-fn] (assert (or (= x1 x2) (= y1 y2))) (if (not (cell-is-on-grid x1 y1)) ; If your starting cell isn&apos;t on the grid, you get nothing. [] (let [x2 (bound-between x2 0 (dec GRID-WIDTH)) y2 (bound-between y2 0 (dec GRID-HEIGHT))] (if (= x1 x2) (let [column (nth structure x1)] (doseq [value (if (&lt; y1 y2) (subvec column y1 (inc y2)) (reverse (subvec column y2 (inc y1))))] (next-fn value))) (doseq [x (if (&lt; x1 x2) (range x1 (inc x2)) (reverse (range x2 (inc x1))))] (next-fn (-&gt; structure (nth x) (nth y1))))))))"><y>#</y><d>2017-12-18</d><h>03:58</h><w>jrheard</w>ended up with this:
<pre>(defnav
  grid-values
  [x1 y1 x2 y2]
  (select* [this structure next-fn]
           (assert (or (= x1 x2)
                       (= y1 y2)))

           (if (not (cell-is-on-grid x1 y1))
             ; If your starting cell isn&apos;t on the grid, you get nothing.
             []

             (let [x2 (bound-between x2 0 (dec GRID-WIDTH))
                   y2 (bound-between y2 0 (dec GRID-HEIGHT))]

               (if (= x1 x2)
                 (let [column (nth structure x1)]
                   (doseq [value (if (&lt; y1 y2)
                                 (subvec column y1 (inc y2))
                                 (reverse (subvec column y2 (inc y1))))]
                     (next-fn value)))

                 (doseq [x (if (&lt; x1 x2)
                           (range x1 (inc x2))
                           (reverse (range x2 (inc x1))))]
                   (next-fn
                     (-&gt; structure
                         (nth x)
                         (nth y1))))))))</pre></z><z id="t1513569538" t="jrheard i noticed i had to use doseq rather than for - presumably next-fn is side-effecty?"><y>#</y><d>2017-12-18</d><h>03:58</h><w>jrheard</w>i noticed i had to use <code>doseq</code> rather than <code>for</code> - presumably <code>next-fn</code> is side-effecty?</z><z id="t1513569542" t="jrheard nbd, just interesting"><y>#</y><d>2017-12-18</d><h>03:59</h><w>jrheard</w>nbd, just interesting</z><z id="t1513569644" t="jrheard the only other perf thing i can think of is: rather than having grid be a 2d array, have it be a 1d array that’s primarily accessed via some function like (get-cell grid x y) , so most consumers don’t treat it like a 1d array, but certain places like select* can treat it like a 1d array and perhaps get a speedup"><y>#</y><d>2017-12-18</d><h>04:00</h><w>jrheard</w>the only other perf thing i can think of is: rather than having <code>grid</code> be a 2d array, have it be a 1d array that’s primarily accessed via some function like <code>(get-cell grid x y)</code>, so most consumers don’t treat it like a 1d array, but certain places like <code>select*</code> can treat it like a 1d array and perhaps get a speedup</z><z id="t1513569651" t="jrheard which, i think i just have to try and see what happens, and benchmark before and after"><y>#</y><d>2017-12-18</d><h>04:00</h><w>jrheard</w>which, i think i just have to try and see what happens, and benchmark before and after</z><z id="t1513569724" t="nathanmarz doseq is not very fast"><y>#</y><d>2017-12-18</d><h>04:02</h><w>nathanmarz</w><code>doseq</code> is not very fast</z><z id="t1513569727" t="nathanmarz neither is reverse"><y>#</y><d>2017-12-18</d><h>04:02</h><w>nathanmarz</w>neither is <code>reverse</code></z><z id="t1513569731" t="jrheard is there anything less drastic that you’d recommend i try instead, or is this (doseq [x (if (&lt; x1 x2) (range x1 (inc x2)) (reverse (range x2 (inc x1))))] (next-fn (-&gt; structure (nth x) (nth y1)))) unimproveable?"><y>#</y><d>2017-12-18</d><h>04:02</h><w>jrheard</w>is there anything less drastic that you’d recommend i try instead, or is this
<pre>(doseq [x (if (&lt; x1 x2)
           (range x1 (inc x2))
           (reverse (range x2 (inc x1))))]
   (next-fn
     (-&gt; structure
         (nth x)
         (nth y1))))</pre> unimproveable?</z><z id="t1513569754" t="jrheard i’ve benchmarked the reverse codepath and it doesn’t seem noticeably slower, it seems to really be the two-nths situation afaict"><y>#</y><d>2017-12-18</d><h>04:02</h><w>jrheard</w>i’ve benchmarked the <code>reverse</code> codepath and it doesn’t seem noticeably slower, it seems to really be the two-nths situation afaict</z><z id="t1513569769" t="nathanmarz also, you&apos;re making two nth calls per element, when you could do one nth call per row"><y>#</y><d>2017-12-18</d><h>04:02</h><w>nathanmarz</w>also, you&apos;re making two <code>nth</code> calls per element, when you could do one <code>nth</code> call per row</z><z id="t1513569770" t="jrheard reverse is always getting a list of at most five items fwiw"><y>#</y><d>2017-12-18</d><h>04:02</h><w>jrheard</w>reverse is always getting a list of at most five items fwiw</z><z id="t1513569778" t="jrheard hm"><y>#</y><d>2017-12-18</d><h>04:02</h><w>jrheard</w>hm</z><z id="t1513569802" t="jrheard i see how i can do one nth call in the case where i’m just doing down the Y axis - eg going from x=4,y=4 to x=4,y=8, and getting all those values"><y>#</y><d>2017-12-18</d><h>04:03</h><w>jrheard</w>i see how i can do one <code>nth</code> call in the case where i’m just doing down the Y axis - eg going from x=4,y=4 to x=4,y=8, and getting all those values</z><z id="t1513569818" t="jrheard but i don’t see how i can do it if i’m going down the x axis, eg x=4,y=4 to x=8, y=4"><y>#</y><d>2017-12-18</d><h>04:03</h><w>jrheard</w>but i don’t see how i can do it if i’m going down the x axis, eg x=4,y=4 to x=8, y=4</z><z id="t1513569878" t="jrheard i extremely agree with you that the two nth calls seem to be the culprit - is there some obvious better way of doing things that i’m not seeing?"><y>#</y><d>2017-12-18</d><h>04:04</h><w>jrheard</w>i extremely agree with you that the two <code>nth</code> calls seem to be the culprit - is there some obvious better way of doing things that i’m not seeing?</z><z id="t1513569901" t="nathanmarz calling range is also materializing an additional sequence that isn&apos;t necessary"><y>#</y><d>2017-12-18</d><h>04:05</h><w>nathanmarz</w>calling <code>range</code> is also materializing an additional sequence that isn&apos;t necessary</z><z id="t1513569929" t="nathanmarz the fastest way to do this is probably with just loop"><y>#</y><d>2017-12-18</d><h>04:05</h><w>nathanmarz</w>the fastest way to do this is probably with just <code>loop</code></z><z id="t1513569990" t="jrheard (fwiw, in my second-to-most-recent snippet, there’s an if with two paths - the (= x1 x2) path is pretty fast, and it still has the range and reverse )"><y>#</y><d>2017-12-18</d><h>04:06</h><w>jrheard</w>(fwiw, in my second-to-most-recent snippet, there’s an <code>if</code> with two paths - the <code>(= x1 x2)</code> path is pretty fast, and it still has the <code>range</code> and <code>reverse</code>)</z><z id="t1513569997" t="jrheard loop’s a great idea! i forgot it existed 🙂"><y>#</y><d>2017-12-18</d><h>04:06</h><w>jrheard</w>loop’s a great idea! i forgot it existed <b>🙂</b></z><z id="t1513570002" t="jrheard i’ll try loop in the morning, thanks nathan!"><y>#</y><d>2017-12-18</d><h>04:06</h><w>jrheard</w>i’ll try loop in the morning, thanks nathan!</z><z id="t1513618488" t="jrheard started benchmarking things (just sloppily using cljs’s built-in simple-benchmark , nothing fancy). i have a pick-move function that i’m calling 50 times, which causes this navigator codepath to be executed about a jillion times. when i call next-fn a single time on the whole sequence, i see timings of about 9300ms for my benchmark. when i call next-fn multiple times, once per each item of the sequence, i see the same timings. this is probably because the sequence is always going to be at most five items long - i imagine that if calling next-fn once per item tends to give a speedup, perhaps the speedup is more obvious if you’re doing it on a ton of items as opposed to five? (i should also note that i’m not using advanced compilation while gathering this data)"><y>#</y><d>2017-12-18</d><h>17:34</h><w>jrheard</w>started benchmarking things (just sloppily using cljs’s built-in <code>simple-benchmark</code>, nothing fancy). i have a <code>pick-move</code> function that i’m calling 50 times, which causes this navigator codepath to be executed about a jillion times.
when i call <code>next-fn</code> a single time on the whole sequence, i see timings of about 9300ms for my benchmark.
when i call <code>next-fn</code> multiple times, once per each item of the sequence, i see the same timings.
this is probably because the sequence is always going to be at most five items long - i imagine that if calling <code>next-fn</code> once per item tends to give a speedup, perhaps the speedup is more obvious if you’re doing it on a ton of items as opposed to five?
(i should also note that i’m not using advanced compilation while gathering this data)</z><z id="t1513618520" t="jrheard i switched my slow, two-`nth`-calls doseq with range and reverse to a handrolled loop , and that brought me down from 9300ms to 7200ms, which is a good start!"><y>#</y><d>2017-12-18</d><h>17:35</h><w>jrheard</w>i switched my slow, two-`nth`-calls <code>doseq</code> with <code>range</code> and <code>reverse</code> to a handrolled <code>loop</code>, and that brought me down from 9300ms to 7200ms, which is a good start!</z><z id="t1513618557" t="jrheard i still wish i could figure out a way to not have to do two nth calls - the only one i can think of is to switch from having a 2d vector to having a 1d vector, and measuring the before-and-after"><y>#</y><d>2017-12-18</d><h>17:35</h><w>jrheard</w>i still wish i could figure out a way to not have to do two <code>nth</code> calls - the only one i can think of is to switch from having a 2d vector to having a 1d vector, and measuring the before-and-after</z><z id="t1513618596" t="jrheard at this point i’m mainly digging into this just to satisfy my curiosity, perf’s acceptable for my toy app but i’d like to see if the 1d vector approach causes a huge speed boost, none at all, or somewhere inbetween; i’ll post the results later today when i’m done, and then i will stop spamming this channel 🙂"><y>#</y><d>2017-12-18</d><h>17:36</h><w>jrheard</w>at this point i’m mainly digging into this just to satisfy my curiosity, perf’s acceptable for my toy app but i’d like to see if the 1d vector approach causes a huge speed boost, none at all, or somewhere inbetween; i’ll post the results later today when i’m done, and then i will stop spamming this channel <b>🙂</b></z><z id="t1513620376" t="jrheard huh, basically zero speedup! my base benchmark timings are different for this one because i used a different board/hand combination to test the 2d vs 1d vector implementations; the 2d vector implementation had a benchmark time of 3100ms-3300ms, and so did the 1d vector implementation (presumably because vectors are implemented under the hood as trees, and so a 1d vector doesn’t guarantee you a contiguous block of memory)"><y>#</y><d>2017-12-18</d><h>18:06</h><w>jrheard</w>huh, basically zero speedup! my base benchmark timings are different for this one because i used a different board/hand combination to test the 2d vs 1d vector implementations; the 2d vector implementation had a benchmark time of 3100ms-3300ms, and so did the 1d vector implementation (presumably because vectors are implemented under the hood as trees, and so a 1d vector doesn’t guarantee you a contiguous block of memory)</z><z id="t1513620493" t="jrheard so i guess this is as good as it’s gonna get; my thing still spends most of its time making those two nth calls, and i don’t see how that can be avoided if you’ve got a 2d vector of values, the first dimension holds the columns, and you’re trying to select all the values from eg x=4,y=4 to x=8,y=4. it seems to me that you have to call nth two times in that situation, unless i’m missing something"><y>#</y><d>2017-12-18</d><h>18:08</h><w>jrheard</w>so i guess this is as good as it’s gonna get; my thing still spends most of its time making those two <code>nth</code> calls, and i don’t see how that can be avoided if you’ve got a 2d vector of values, the first dimension holds the columns, and you’re trying to select all the values from eg x=4,y=4 to x=8,y=4. it seems to me that you have to call <code>nth</code> two times in that situation, unless i’m missing something</z><z id="t1513620529" t="jrheard but anyway this has been very interesting and educational for me but no longer has much to do with specter. my app’s specter-related perf seems to be as good as it’s going to get for this query, so again, thanks for all the help and for building this great tool!"><y>#</y><d>2017-12-18</d><h>18:08</h><w>jrheard</w>but anyway this has been very interesting and educational for me but no longer has much to do with specter. my app’s specter-related perf seems to be as good as it’s going to get for this query, so again, thanks for all the help and for building this great tool!</z><z id="t1513624215" t="nathanmarz yea, for up and down it&apos;s two nth calls per element, but for left and right it&apos;s less"><y>#</y><d>2017-12-18</d><h>19:10</h><w>nathanmarz</w>yea, for up and down it&apos;s two <code>nth</code> calls per element, but for left and right it&apos;s less</z><z id="t1513624254" t="jrheard right exactly"><y>#</y><d>2017-12-18</d><h>19:10</h><w>jrheard</w>right exactly</z><z id="t1513624272" t="jrheard the one-`nth`-call-and-then-`subvec` dimension is super fast, the two-`nth`-calls-per-element one is 50x slower, and it seems like that’s just a fact of life"><y>#</y><d>2017-12-18</d><h>19:11</h><w>jrheard</w>the one-`nth`-call-and-then-`subvec` dimension is super fast, the two-`nth`-calls-per-element one is 50x slower, and it seems like that’s just a fact of life</z><z id="t1513624274" t="jrheard oh well!"><y>#</y><d>2017-12-18</d><h>19:11</h><w>jrheard</w>oh well!</z><z id="t1513699734" t="mbjarland @nathanmarz apropos our conversation about warnings under clojure 1.9.0, a new version of midje has been released with an updated (direct) dep on specter: [midje &quot;1.9.1&quot; :scope &quot;test&quot;] [com.rpl/specter &quot;1.0.4&quot; :scope &quot;test&quot; :exclusions [[org.clojure/clojure] [org.clojure/clojurescript]]] [riddley &quot;0.1.12&quot; :scope &quot;test&quot;] the warnings are gone and the related issue on midje ( https://github.com/marick/Midje/issues/427 ) closed"><y>#</y><d>2017-12-19</d><h>16:08</h><w>mbjarland</w>@nathanmarz apropos our conversation about warnings under clojure 1.9.0, a new version of midje has been released with an updated (direct) dep on specter: 
<pre>[midje &quot;1.9.1&quot; :scope &quot;test&quot;]
   [com.rpl/specter &quot;1.0.4&quot; :scope &quot;test&quot; :exclusions [[org.clojure/clojure] [org.clojure/clojurescript]]]
     [riddley &quot;0.1.12&quot; :scope &quot;test&quot;]
</pre>
the warnings are gone and the related issue on midje (<a href="https://github.com/marick/Midje/issues/427" target="_blank">https://github.com/marick/Midje/issues/427</a>) closed</z><z id="t1513703930" t="nathanmarz @mbjarland great"><y>#</y><d>2017-12-19</d><h>17:18</h><w>nathanmarz</w>@mbjarland great</z><z id="t1513704628" t="rafael Hi. Don&apos;t know if this is the right forum, I have a newbie specter question."><y>#</y><d>2017-12-19</d><h>17:30</h><w>rafael</w>Hi. Don&apos;t know if this is the right forum, I have a newbie specter question.</z><z id="t1513704675" t="rafael I wanted to filter out elements not matching the path for a transform call."><y>#</y><d>2017-12-19</d><h>17:31</h><w>rafael</w>I wanted to filter out elements not matching the path for a <code>transform</code> call.</z><z id="t1513704698" t="rafael It&apos;s easier to explain in code. The following (specter/transform [specter/ALL (specter/must :a) (specter/must :b)] str [{:a {:b 10}} {:a {:z 42}}]) returns [{:a {:b &quot;10&quot;}} {:a {:z 42}}]"><y>#</y><d>2017-12-19</d><h>17:31</h><w>rafael</w>It&apos;s easier to explain in code. The following <code>(specter/transform [specter/ALL (specter/must :a) (specter/must :b)] str [{:a {:b 10}} {:a {:z 42}}])</code> returns <code>[{:a {:b &quot;10&quot;}} {:a {:z 42}}]</code></z><z id="t1513704720" t="rafael It called the transformation function for an element matching the path and returned the rest unchanged."><y>#</y><d>2017-12-19</d><h>17:32</h><w>rafael</w>It called the transformation function for an element matching the path and returned the rest unchanged.</z><z id="t1513704747" t="rafael I&apos;m wondering if is there anything I can do to make a similar call return [{:a {:b &quot;10&quot;}}] instead?"><y>#</y><d>2017-12-19</d><h>17:32</h><w>rafael</w>I&apos;m wondering if is there anything I can do to make a similar call return <code>[{:a {:b &quot;10&quot;}}]</code> instead?</z><z id="t1513704773" t="rafael (filtering out the non-matching {:a {:b 10}} element)"><y>#</y><d>2017-12-19</d><h>17:32</h><w>rafael</w>(filtering out the non-matching <code>{:a {:b 10}}</code> element)</z><z id="t1513705274" t="tanzoniteblack @rafael if you want to do a select and a transform in the same operation, you probably want to do select to get only the value you want returned and then use the view selector to make your transformation ( https://github.com/nathanmarz/specter/wiki/List-of-Navigators#view )"><y>#</y><d>2017-12-19</d><h>17:41</h><w>tanzoniteblack</w>@rafael if you want to do a select and a transform in the same operation, you probably want to do <code>select</code> to get only the value you want returned and then use the <code>view</code> selector to make your transformation (<a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#view" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#view</a>)</z><z id="t1513705365" t="tanzoniteblack i.e. how I think of it: transform is for modifying in place a piece of a structure; select is for pulling out specific information I want from a structure; and select with the view selector is for doing both selecting only a piece and applying a transformation"><y>#</y><d>2017-12-19</d><h>17:42</h><w>tanzoniteblack</w>i.e. how I think of it: <code>transform</code> is for modifying in place a piece of a structure; <code>select</code> is for pulling out specific information I want from a structure; and <code>select</code> with the <code>view</code> selector is for doing both selecting only a piece and applying a transformation</z><z id="t1513705400" t="rafael Thanks @tanzoniteblack. I&apos;m trying it out now"><y>#</y><d>2017-12-19</d><h>17:43</h><w>rafael</w>Thanks @tanzoniteblack. I&apos;m trying it out now</z><z id="t1513705523" t="rafael Naively applying view to the example above gets me: (specter/select [specter/ALL (specter/must :a) (specter/must :b) (specter/view str)] [{:a {:b 10}} {:a {:z 42}}]) =&gt; [&quot;10&quot;]"><y>#</y><d>2017-12-19</d><h>17:45</h><w>rafael</w>Naively applying view to the example above gets me:
<pre>(specter/select [specter/ALL (specter/must :a) (specter/must :b) (specter/view str)] [{:a {:b 10}} {:a {:z 42}}])</pre>
<pre>=&gt; [&quot;10&quot;]</pre></z><z id="t1513705551" t="rafael I wonder if is there a way to get [{:a {:b &quot;10&quot;}}] in the result."><y>#</y><d>2017-12-19</d><h>17:45</h><w>rafael</w>I wonder if is there a way to get <code>[{:a {:b &quot;10&quot;}}]</code> in the result.</z><z id="t1513705600" t="tanzoniteblack https://github.com/nathanmarz/specter/wiki/List-of-Navigators#transformed might do that?"><y>#</y><d>2017-12-19</d><h>17:46</h><w>tanzoniteblack</w><a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#transformed" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#transformed</a> might do that?</z><z id="t1513705601" t="rafael It would perfectly fine to chain a call to select and a another to transform , or whatever, but even then I&apos;m having a hard time coming up with the right incantation 🙂"><y>#</y><d>2017-12-19</d><h>17:46</h><w>rafael</w>It would perfectly fine to chain a call to <code>select</code> and a another to <code>transform</code>, or whatever, but even then I&apos;m having a hard time coming up with the right incantation <b>🙂</b></z><z id="t1513705618" t="tanzoniteblack not actually sure off the top of my head, sorry"><y>#</y><d>2017-12-19</d><h>17:46</h><w>tanzoniteblack</w>not actually sure off the top of my head, sorry</z><z id="t1513705662" t="rafael No worries, thanks for the help. I&apos;m checking out transformed now"><y>#</y><d>2017-12-19</d><h>17:47</h><w>rafael</w>No worries, thanks for the help. I&apos;m checking out <code>transformed</code> now</z><z id="t1513706060" t="tanzoniteblack (specter/select [(specter/filterer (specter/must :a) (specter/must :b)) specter/ALL (specter/transformed [:a :b] str)] [{:a {:b 10}} {:a {:z 42}}]) @rafael that appears to do what I think you want?"><y>#</y><d>2017-12-19</d><h>17:54</h><w>tanzoniteblack</w><pre>(specter/select [(specter/filterer (specter/must :a) (specter/must :b)) 
                                            specter/ALL
                                            (specter/transformed [:a :b] str)]
                                           [{:a {:b 10}} {:a {:z 42}}])</pre> @rafael that appears to do what I think you want?</z><z id="t1513706105" t="tanzoniteblack filterer removes all items that don&apos;t have :b key inside the value at the :a key, and then for each item in that list, we&apos;re going to reach into the path :a then :b and run the function str"><y>#</y><d>2017-12-19</d><h>17:55</h><w>tanzoniteblack</w><code>filterer</code> removes all items that don&apos;t have <code>:b</code> key inside the value at the <code>:a</code> key, and then for each item in that list, we&apos;re going to reach into the path <code>:a</code> then <code>:b</code> and run the function <code>str</code></z><z id="t1513706118" t="tanzoniteblack probably not more efficient then the manual way of doing it? But no idea"><y>#</y><d>2017-12-19</d><h>17:55</h><w>tanzoniteblack</w>probably not more efficient then the manual way of doing it? But no idea</z><z id="t1513706248" t="rafael The output looks right. I&apos;m trying to digest it before applying to my real use case (which deals with a structure a bit more complicated than the example). Efficiency is not super important for my use case, I&apos;m reaching for specter for the terseness in dealing with a deeply nested structure, so it should be alright"><y>#</y><d>2017-12-19</d><h>17:57</h><w>rafael</w>The output looks right. I&apos;m trying to digest it before applying to my real use case (which deals with a structure a bit more complicated than the example). Efficiency is not super important for my use case, I&apos;m reaching for specter for the terseness in dealing with a deeply nested structure, so it should be alright</z><z id="t1513706774" t="nathanmarz @tanzoniteblack you&apos;re looking for not-selected?"><y>#</y><d>2017-12-19</d><h>18:06</h><w>nathanmarz</w>@tanzoniteblack you&apos;re looking for <code>not-selected?</code></z><z id="t1513706782" t="nathanmarz (setval [ALL (not-selected? (must :a :b))] NONE data) "><y>#</y><d>2017-12-19</d><h>18:06</h><w>nathanmarz</w><pre>(setval [ALL (not-selected? (must :a :b))] NONE data)
</pre></z><z id="t1513706961" t="rafael With not-selected and setval the complete example would then be: (-&gt;&gt; data (S/setval [S/ALL (S/not-selected? (S/must :a :b))] S/NONE) (S/transform [S/ALL (S/must :a :b)] str)) ?"><y>#</y><d>2017-12-19</d><h>18:09</h><w>rafael</w>With <code>not-selected</code> and <code>setval</code> the complete example would then be:
<pre>(-&gt;&gt; data
       (S/setval [S/ALL (S/not-selected? (S/must :a :b))] S/NONE)
       (S/transform [S/ALL (S/must :a :b)] str))
</pre>?</z><z id="t1513707090" t="nathanmarz yea, that would work"><y>#</y><d>2017-12-19</d><h>18:11</h><w>nathanmarz</w>yea, that would work</z><z id="t1513707113" t="nathanmarz for second part you don&apos;t need must anymore since they&apos;re guaranteed to be there by first part"><y>#</y><d>2017-12-19</d><h>18:11</h><w>nathanmarz</w>for second part you don&apos;t need <code>must</code> anymore since they&apos;re guaranteed to be there by first part</z><z id="t1513707167" t="rafael Cool, now off to apply it to the real use case 🙂"><y>#</y><d>2017-12-19</d><h>18:12</h><w>rafael</w>Cool, now off to apply it to the real use case <b>🙂</b></z><z id="t1513712366" t="rafael Hi again. When applying to my actual use case things turned out to be more complicated. There are multiple S/ALL where we want to remove non-matching elements. Again, a code example is probably easier to explain: (def data [{:a [{:b 10}]} {:a [{:b 20} {:z 42}]}]) (-&gt;&gt; data (S/setval [S/ALL (S/not-selected? (S/must :a) S/ALL (S/must :b))] S/NONE) (S/transform [S/ALL :a S/ALL :b] str)) results in =&gt; [{:a [{:b &quot;10&quot;}]} {:a [{:b &quot;20&quot;} {:z 42, :b &quot;&quot;}]}] but I wanted [{:a [{:b &quot;10&quot;}]} {:a [{:b &quot;20&quot;}]}]"><y>#</y><d>2017-12-19</d><h>19:39</h><w>rafael</w>Hi again. When applying to my actual use case things turned out to be more complicated. There are multiple S/ALL where we want to remove non-matching elements. Again, a code example is probably easier to explain:
<pre>(def data [{:a [{:b 10}]} {:a [{:b 20} {:z 42}]}])

  (-&gt;&gt; data
       (S/setval [S/ALL (S/not-selected? (S/must :a) S/ALL (S/must :b))] S/NONE)
       (S/transform [S/ALL :a S/ALL :b] str))
</pre>
results in 
<pre>=&gt; [{:a [{:b &quot;10&quot;}]} {:a [{:b &quot;20&quot;} {:z 42, :b &quot;&quot;}]}]
</pre>
but I wanted <code>[{:a [{:b &quot;10&quot;}]} {:a [{:b &quot;20&quot;}]}]</code></z><z id="t1513712392" t="rafael (it&apos;s a similar example to above, but with one extra nested sequence)"><y>#</y><d>2017-12-19</d><h>19:39</h><w>rafael</w>(it&apos;s a similar example to above, but with one extra nested sequence)</z><z id="t1513712416" t="rafael I could get the output I wanted with an extra setval : (-&gt;&gt; data (S/setval [S/ALL (S/not-selected? (S/must :a) S/ALL (S/must :b))] S/NONE) (S/setval [S/ALL (S/must :a) S/ALL (S/not-selected? (S/must :b))] S/NONE) (S/transform [S/ALL :a S/ALL :b] str)) "><y>#</y><d>2017-12-19</d><h>19:40</h><w>rafael</w>I could get the output I wanted with an extra <code>setval</code>:
<pre>(-&gt;&gt; data
       (S/setval [S/ALL (S/not-selected? (S/must :a) S/ALL (S/must :b))] S/NONE)
       (S/setval [S/ALL (S/must :a) S/ALL (S/not-selected? (S/must :b))] S/NONE)
       (S/transform [S/ALL :a S/ALL :b] str))
</pre></z><z id="t1513712428" t="rafael This works, but I was wondering if there is any way of reducing the duplication"><y>#</y><d>2017-12-19</d><h>19:40</h><w>rafael</w>This works, but I was wondering if there is any way of reducing the duplication</z><z id="t1513713587" t="nathanmarz @rafael (setval [ALL :a ALL (transformed (must :b) str) (not-selected? (must :b))] NONE data)"><y>#</y><d>2017-12-19</d><h>19:59</h><w>nathanmarz</w>@rafael <code>(setval [ALL :a ALL (transformed (must :b) str) (not-selected? (must :b))] NONE data)</code></z><z id="t1513713674" t="nathanmarz do you also want to remove top level maps that don&apos;t have any inner maps under :a with :b ?"><y>#</y><d>2017-12-19</d><h>20:01</h><w>nathanmarz</w>do you also want to remove top level maps that don&apos;t have any inner maps under <code>:a</code> with <code>:b</code>?</z><z id="t1513713840" t="rafael Ideally yeah, If data is (def data [{:a [{:b 10}]} {:a [{:b 20} {:z 42}]} {:a [{:z 42}]}]) then I also need to remove the last {:a [{:z 42}]}"><y>#</y><d>2017-12-19</d><h>20:04</h><w>rafael</w>Ideally yeah, If data is <code>(def data [{:a [{:b 10}]} {:a [{:b 20} {:z 42}]} {:a [{:z 42}]}])</code> then I also need to remove the last <code>{:a [{:z 42}]}</code></z><z id="t1513713973" t="rafael (trying to understand your suggestion above... thank&apos;s for taking the time to help)"><y>#</y><d>2017-12-19</d><h>20:06</h><w>rafael</w>(trying to understand your suggestion above... thank&apos;s for taking the time to help)</z><z id="t1513714413" t="nathanmarz @rafael this does the trick: (defdynamicnav with-matching [path] (if-path path path (terminal-val NONE) )) (transform [ALL (with-matching (must :a)) ALL (with-matching (must :b)) ] str data) "><y>#</y><d>2017-12-19</d><h>20:13</h><w>nathanmarz</w>@rafael this does the trick:
<pre>(defdynamicnav with-matching [path]
  (if-path path
    path
    (terminal-val NONE)
    ))

(transform
  [ALL
   (with-matching (must :a))
   ALL
   (with-matching (must :b))
   ]
  str
  data)
</pre></z><z id="t1513714438" t="rafael Wow"><y>#</y><d>2017-12-19</d><h>20:13</h><w>rafael</w>Wow</z><z id="t1513714751" t="nathanmarz even better:"><y>#</y><d>2017-12-19</d><h>20:19</h><w>nathanmarz</w>even better:</z><z id="t1513714755" t="nathanmarz (defdynamicnav with-matching [path] (if-path path (multi-path path (if-path path STOP (terminal-val NONE))) (terminal-val NONE) )) (defdynamicnav with-non-empty [path] (multi-path path (if-path empty? (terminal-val NONE))) ) (transform [ALL (with-matching (must :a)) (with-non-empty ALL) (with-matching (must :b)) ] str data) "><y>#</y><d>2017-12-19</d><h>20:19</h><w>nathanmarz</w><pre>(defdynamicnav with-matching [path]
  (if-path path
    (multi-path path (if-path path STOP (terminal-val NONE)))
    (terminal-val NONE)
    ))

(defdynamicnav with-non-empty [path]
  (multi-path path (if-path empty? (terminal-val NONE)))
  )

(transform
  [ALL
   (with-matching (must :a))
   (with-non-empty ALL)
   (with-matching (must :b))
   ]
  str
  data)
</pre></z><z id="t1513714867" t="nathanmarz with [{:a [{:b 10}]} {:a [{:q 20} {:z 42}]}] that removes the second map completely"><y>#</y><d>2017-12-19</d><h>20:21</h><w>nathanmarz</w>with <code>[{:a [{:b 10}]} {:a [{:q 20} {:z 42}]}]</code> that removes the second map completely</z><z id="t1513714913" t="nathanmarz you can read about dynamic navs here: https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation"><y>#</y><d>2017-12-19</d><h>20:21</h><w>nathanmarz</w>you can read about dynamic navs here: <a href="https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation" target="_blank">https://github.com/nathanmarz/specter/wiki/Specter&apos;s-inline-caching-implementation</a></z><z id="t1513714919" t="nathanmarz they&apos;re similar to macros"><y>#</y><d>2017-12-19</d><h>20:21</h><w>nathanmarz</w>they&apos;re similar to macros</z><z id="t1513715206" t="rafael Looks like I have a lot of reading to do. Thanks"><y>#</y><d>2017-12-19</d><h>20:26</h><w>rafael</w>Looks like I have a lot of reading to do. Thanks</z><z id="t1513715238" t="nathanmarz actually this is a more flexible implementation I think: (defdynamicnav with-matching [path] (if-path path (multi-path path (if-path path STOP (terminal-val NONE))) (terminal-val NONE) )) (defn ^:direct-nav ensure-pred [pred-fn] (path (stay-then-continue (if-path (pred pred-fn) STOP (terminal-val NONE))))) (transform [ALL (with-matching (must :a)) (ensure-pred #(-&gt; % empty? not)) ALL (with-matching (must :b)) ] str data) "><y>#</y><d>2017-12-19</d><h>20:27</h><w>nathanmarz</w>actually this is a more flexible implementation I think:
<pre>(defdynamicnav with-matching [path]
  (if-path path
    (multi-path path (if-path path STOP (terminal-val NONE)))
    (terminal-val NONE)
    ))

(defn ^:direct-nav ensure-pred [pred-fn]
  (path (stay-then-continue (if-path (pred pred-fn) STOP (terminal-val NONE)))))

(transform
  [ALL
   (with-matching (must :a))
   (ensure-pred #(-&gt; % empty? not))
   ALL
   (with-matching (must :b))
   ]
  str
  data)
</pre></z><z id="t1513715261" t="nathanmarz I may add some variant of these into specter"><y>#</y><d>2017-12-19</d><h>20:27</h><w>nathanmarz</w>I may add some variant of these into specter</z><z id="t1513715831" t="nathanmarz I think this is the simplest solution: (defdynamicnav ensure-matching* [path] (multi-path path (if-path path STOP (terminal-val NONE)))) (def ensure-matching (eachnav ensure-matching*)) (transform [ALL (ensure-matching (must :a) ALL (must :b)) ] str data) "><y>#</y><d>2017-12-19</d><h>20:37</h><w>nathanmarz</w>I think this is the simplest solution:
<pre>(defdynamicnav ensure-matching* [path]
  (multi-path path (if-path path STOP (terminal-val NONE))))

(def ensure-matching (eachnav ensure-matching*))
    
(transform
  [ALL
   (ensure-matching (must :a) ALL (must :b))
   ]
  str
  data)
</pre></z><z id="t1513868348" t="rafael The ensure-matching solution above worked for us, thanks."><y>#</y><d>2017-12-21</d><h>14:59</h><w>rafael</w>The <code>ensure-matching</code> solution above worked for us, thanks.</z><z id="t1513868391" t="rafael We also found the need for another defdynamicnav, I&apos;m posting it here in case anyone finds it helpful: (specter/defdynamicnav look-ahead [path] (specter/if-path path specter/STAY (specter/terminal-val specter/NONE))) "><y>#</y><d>2017-12-21</d><h>14:59</h><w>rafael</w>We also found the need for another defdynamicnav, I&apos;m posting it here in case anyone finds it helpful:
<pre>(specter/defdynamicnav look-ahead [path]
  (specter/if-path path specter/STAY (specter/terminal-val specter/NONE)))
</pre></z><z id="t1513868440" t="rafael It is used like this: (transform [ALL (schema-check/look-ahead (must :a))] str [{:a 1 :b 1} {:x 2 :b 2}]) evaluates to =&gt; [&quot;{:a 1, :b 1}&quot;]"><y>#</y><d>2017-12-21</d><h>15:00</h><w>rafael</w>It is used like this:
<pre>(transform [ALL (schema-check/look-ahead (must :a))] str [{:a 1 :b 1} {:x 2 :b 2}])</pre>
evaluates to <code>=&gt;  [&quot;{:a 1, :b 1}&quot;]</code></z><z id="t1513868496" t="rafael Another example: (transform [ALL (schema-check/look-ahead (must :a)) :b] str [{:a 1 :b 1} {:x 2 :b 2}]) =&gt; [{:a 1, :b &quot;1&quot;}]"><y>#</y><d>2017-12-21</d><h>15:01</h><w>rafael</w>Another example:
<pre>(transform [ALL (schema-check/look-ahead (must :a)) :b] str [{:a 1 :b 1} {:x 2 :b 2}])</pre>
<pre>=&gt; [{:a 1, :b &quot;1&quot;}]</pre></z><z id="t1513868681" t="nathanmarz @rafael cool"><y>#</y><d>2017-12-21</d><h>15:04</h><w>nathanmarz</w>@rafael cool</z><z id="t1513868709" t="nathanmarz I opened an issue to add functionality like this into Specter https://github.com/nathanmarz/specter/issues/240"><y>#</y><d>2017-12-21</d><h>15:05</h><w>nathanmarz</w>I opened an issue to add functionality like this into Specter <a href="https://github.com/nathanmarz/specter/issues/240" target="_blank">https://github.com/nathanmarz/specter/issues/240</a></z><z id="t1513908510" t="npetryk Can someone help me understand why (setval (filterer even?) [:example] (range 0 10)) =&gt; (:example 1 3 5 7 9) whereas (setval (filterer even?) [] (range 0 10)) =&gt; (nil 1 3 5 7 9) , yet (setval (filterer even?) [NONE] (range 0 10)) =&gt; (1 3 5 7 9)"><y>#</y><d>2017-12-22</d><h>02:08</h><w>npetryk</w>Can someone help me understand why <code>(setval (filterer even?) [:example] (range 0 10)) =&gt; (:example 1 3 5 7 9)</code> whereas <code>(setval (filterer even?) [] (range 0 10)) =&gt; (nil 1 3 5 7 9)</code>, yet <code>(setval (filterer even?) [NONE] (range 0 10)) =&gt; (1 3 5 7 9)</code></z><z id="t1513908556" t="npetryk being able to resize a subselection is really beautiful, but this special case of resizing it to zero seems a bit odd, and I dont quite understand why it happens"><y>#</y><d>2017-12-22</d><h>02:09</h><w>npetryk</w>being able to resize a subselection is really beautiful, but this special case of resizing it to zero seems a bit odd, and I dont quite understand why it happens</z><z id="t1513908616" t="npetryk I would expect replacing a sequence with an empty sequence would remove all elements, rather than leaving a nil in the first matching spot"><y>#</y><d>2017-12-22</d><h>02:10</h><w>npetryk</w>I would expect replacing a sequence with an empty sequence would remove all elements, rather than leaving a <code>nil</code> in the first matching spot</z><z id="t1513912821" t="nathanmarz @npetryk looks like a bug"><y>#</y><d>2017-12-22</d><h>03:20</h><w>nathanmarz</w>@npetryk looks like a bug</z><z id="t1513912845" t="nathanmarz try (setval (filterer even?) nil (range 0 10))"><y>#</y><d>2017-12-22</d><h>03:20</h><w>nathanmarz</w>try <code>(setval (filterer even?) nil (range 0 10))</code></z><z id="t1513913115" t="nathanmarz fixed for next version: https://github.com/nathanmarz/specter/commit/7b646ca566bb3bdd362d43a348c2fe00457438b2"><y>#</y><d>2017-12-22</d><h>03:25</h><w>nathanmarz</w>fixed for next version: <a href="https://github.com/nathanmarz/specter/commit/7b646ca566bb3bdd362d43a348c2fe00457438b2" target="_blank">https://github.com/nathanmarz/specter/commit/7b646ca566bb3bdd362d43a348c2fe00457438b2</a></z><z id="t1514044070" t="npetryk Thanks!"><y>#</y><d>2017-12-23</d><h>15:47</h><r>npetryk</r>Thanks!</z><z id="t1513953181" t="plamen Hello, I again have a nested map in the form:"><y>#</y><d>2017-12-22</d><h>14:33</h><w>plamen</w>Hello,

I again have a nested map in the form:</z><z id="t1513953198" t="plamen {... ... ’A {:type :double} :variables {... ... ’A {:type :int} ’C {:type :double} :variables {... ... ’B {:type :double :formula “A + C”} ... ... } ... ...}} I also recursively traverse it and apply transformations to variables and other nodes (the map is an AST of a DSL) (defn process-var-list [ast] (transform [NODES-VARIABLES :variables MAP-VALS] (fn [var] ; do something to var ) ast)) `(def NODES-VARIABLES (recursive-path [] p (cond-path (must :variables) (continue-then-stay :variables MAP-VALS map? p))))"><y>#</y><d>2017-12-22</d><h>14:33</h><w>plamen</w><pre>{... ...
 ’A {:type :double}
 :variables {... ...
             ’A {:type :int}
			 ’C {:type :double}
             :variables {... ...
			             ’B {:type :double
						     :formula “A + C”}
						 ... ...
			             }
		     ... ...}}

I also recursively traverse it and apply transformations to variables and other nodes (the map is an AST of a DSL)
						 
</pre>(defn process-var-list [ast]
  (transform [NODES-VARIABLES :variables MAP-VALS]
             (fn [var]
               ; do something to var
               )
             ast))
			 
<code></code>`(def NODES-VARIABLES
  (recursive-path [] p
                  (cond-path (must :variables)
                             (continue-then-stay :variables MAP-VALS map? p))))</z><z id="t1513953252" t="plamen In ‘process-vars’ I have access only to the current node which works for most transformations I need. Now if in that DSL I would like to provide variable scope/visibility rules like in Java for example, where the localness of a variable is directly mapped to the depth of it’s definition over the :variables subbranches, I would need to have access not only to var, but to the root of the datastructure AFTER it has been processed in a previous step. That means I can’t just pass ast as a second parameter, because it would have the original state only before any transformation through Specter. collect I think would also not help me in that situation."><y>#</y><d>2017-12-22</d><h>14:34</h><w>plamen</w>In ‘process-vars’ I have access only to the current node which works for most transformations I need. Now if in that DSL I would like to provide variable scope/visibility rules like in Java for example, where the localness of a variable is directly mapped to the depth of it’s definition over the :variables subbranches, I would need to have access not only to var, but to the root of the datastructure AFTER it has been processed in a previous step. That means I can’t just pass ast as a second parameter, because it would have the original state only before any transformation through Specter. collect I think would also not help me in that situation.</z><z id="t1513953259" t="plamen So 1. how one can pass not only the currently selected path element, but the whole structure as well in the already modified state on each invocation of the transform function? 2. if I would like that in the context of where variable B is definied, I would like to have access to variable A in the ast, then I should be able to get to the upper and recursively to all further upper levels up to the root from the current node transformed to access the variables defined there. I know how to do it in Clojure without specter, but how with Specter? (for example to pull the types of variables A and C for calculating B) 3. outside of Specter I have a lot of variable and other dependency analysis (essentially expressions/filters over topological sorts of the variables), but is there an idiomatic way to do it in Specter? Any hints would be very helpful"><y>#</y><d>2017-12-22</d><h>14:34</h><w>plamen</w>So 
1. how one can pass not only the currently selected path element, but the whole structure as well in the already modified state on each invocation of the transform function?
2. if I would like that in the context of where variable B is definied, I would like to have access to variable A in the ast, then I should be able to get to the upper and recursively to all further upper levels up to the root from the current node transformed to access the variables defined there. I know how to do it in Clojure without specter, but how with Specter? (for example to pull the types of variables A and C for calculating B)
3. outside of Specter I have a lot of variable and other dependency analysis (essentially expressions/filters over topological sorts of the variables), but is there an idiomatic way to do it in Specter?

Any hints would be very helpful</z><z id="t1513955795" t="nathanmarz @plamen don&apos;t understand what you&apos;re asking about getting root of data structure after it&apos;s been processed"><y>#</y><d>2017-12-22</d><h>15:16</h><w>nathanmarz</w>@plamen don&apos;t understand what you&apos;re asking about getting root of data structure after it&apos;s been processed</z><z id="t1513955842" t="nathanmarz it would help if you simplified your examples to get at the heart of your questions"><y>#</y><d>2017-12-22</d><h>15:17</h><w>nathanmarz</w>it would help if you simplified your examples to get at the heart of your questions</z><z id="t1513956138" t="plamen Hello Nathan, what I mean is that in the transform function I have as parameter only the current node in the tree as it gets recursed. I would like to pass in addition to it the whole structure so that I can walk it inside the transform function, but not in it’s inital state, but in it’s current (probably already processed state from previous steps in the recursion - my question is probably related to not knowing when exactly the transformation function is applied to the nodes - does first a walk happen in which paths get constructed, then the list is processed, or is it just as in the recursion - step by step depth first, or post-walk or…?) I hope this makes more sense."><y>#</y><d>2017-12-22</d><h>15:22</h><w>plamen</w>Hello Nathan, what I mean is that in the transform function I have as parameter only the current node in the tree as it gets recursed. I would like to pass in addition to it the whole structure so that I can walk it inside the transform function, but not in it’s inital state, but in it’s current (probably already processed state from previous steps in the recursion - my question is probably related to not knowing when exactly the transformation function is applied to the nodes - does first a walk happen in which paths get constructed, then the list is processed, or is it just as in the recursion - step by step depth first, or post-walk or…?) I hope this makes more sense.</z><z id="t1513956262" t="plamen (not sure how to make the question simpler as the map with nested :variables keys consisting of lists of other such maps is the simplest one I can think of related to it. This is why I make the analogy with an abstract syntax tree/depth in the tree and variable scope/visibility as in languages like Java/C#)"><y>#</y><d>2017-12-22</d><h>15:24</h><w>plamen</w>(not sure how to make the question simpler as the map with nested :variables keys consisting of lists of other such maps is the simplest one I can think of related to it. This is why I make the analogy with an abstract syntax tree/depth in the tree and variable scope/visibility as in languages like Java/C#)</z><z id="t1513956308" t="plamen (it is actually not an AST, but more of a types tree)"><y>#</y><d>2017-12-22</d><h>15:25</h><w>plamen</w>(it is actually not an AST, but more of a types tree)</z><z id="t1513956384" t="plamen so, in the (defn process-var-list [ast] (transform [NODES-VARIABLES :variables MAP-VALS] (fn [var] ; do something to var ) ast))"><y>#</y><d>2017-12-22</d><h>15:26</h><w>plamen</w>so, in the (defn process-var-list [ast]
 (transform [NODES-VARIABLES :variables MAP-VALS]
            (fn [var]
              ; do something to var
              )
            ast))</z><z id="t1513956462" t="plamen if I rewrite it to"><y>#</y><d>2017-12-22</d><h>15:27</h><w>plamen</w>if I rewrite it to</z><z id="t1513956464" t="plamen (defn process-var [var] ;do something and return the transformed var node) (defn process-var-list [ast] (transform [NODES-VARIABLES :variables MAP-VALS] process-var ast))"><y>#</y><d>2017-12-22</d><h>15:27</h><w>plamen</w>(defn process-var [var]
  ;do something and return the transformed var node)
  
(defn process-var-list [ast]
  (transform [NODES-VARIABLES :variables MAP-VALS]
             process-var
             ast))</z><z id="t1513956544" t="plamen what I mean is that in my understanding to achieve what I ask for in 1., passing ’ast as an additional argument to ’process-var would pass the inital state of ’ast before the recursion and possible transformation inside it happened?"><y>#</y><d>2017-12-22</d><h>15:29</h><w>plamen</w>what I mean is that in my understanding to achieve what I ask for in 1., passing ’ast as an additional argument to ’process-var would pass the inital state of ’ast before the recursion and possible transformation inside it happened?</z><z id="t1513956761" t="plamen what I need is that during the recursion, during the invocation from Specter of the function ’process-var, inside ’process-var I get as parameter the ’ast as processed up to there. (which is possible only in pre-walk, but not post-walk, but this is also the point - I don’t know how to control or know when the invocation of ’process-var actually happens)"><y>#</y><d>2017-12-22</d><h>15:32</h><w>plamen</w>what I need is that during the recursion, during the invocation from Specter of the function ’process-var, inside ’process-var I get as parameter the ’ast as processed up to there. (which is possible only in pre-walk, but not post-walk, but this is also the point - I don’t know how to control or know when the invocation of ’process-var actually happens)</z><z id="t1513956825" t="plamen (sorry - the “possibility” in the “pre-/post-walk” part of the last sentence is wrong)"><y>#</y><d>2017-12-22</d><h>15:33</h><w>plamen</w>(sorry - the “possibility” in the “pre-/post-walk” part of the last sentence is wrong)</z><z id="t1513956887" t="plamen Does that make more sense?"><y>#</y><d>2017-12-22</d><h>15:34</h><w>plamen</w>Does that make more sense?</z><z id="t1513957153" t="plamen or in other words which is probably more visual - how to transform"><y>#</y><d>2017-12-22</d><h>15:39</h><w>plamen</w>or in other words which is probably more visual - how to transform</z><z id="t1513957159" t="plamen {... ... ’A {:type :double} :variables {... ... ’A {:type :int} ’C {:type :double} :variables {... ... ’B {:type :double :formula “A + C”} ... ... } ... ...}}"><y>#</y><d>2017-12-22</d><h>15:39</h><w>plamen</w>{... ...
 ’A {:type :double}
 :variables {... ...
             ’A {:type :int}
			 ’C {:type :double}
             :variables {... ...
			             ’B {:type :double
						     :formula “A + C”}
						 ... ...
			             }
		     ... ...}}</z><z id="t1513957160" t="plamen into"><y>#</y><d>2017-12-22</d><h>15:39</h><w>plamen</w>into</z><z id="t1513957170" t="plamen {... ... ’A {:type :double} ’D {:type :string} :variables {... ... ’A {:type :int} ’C {:type :double} :variables {... ... ’B {:type :double :uses [[:variables ’A] [:variables ’B]] :sees [’D [:variables ’A] [:variables ’B]] :formula “A + C”} ... ... } ... ...}}"><y>#</y><d>2017-12-22</d><h>15:39</h><w>plamen</w>{... ...
 ’A {:type :double}
 ’D {:type :string}
 :variables {... ...
             ’A {:type :int}
			 ’C {:type :double}
             :variables {... ...
			             ’B {:type :double
						     :uses [[:variables ’A] [:variables ’B]]
							 :sees [’D [:variables ’A] [:variables ’B]]
						     :formula “A + C”}
						 ... ...
			             }
		     ... ...}}</z><z id="t1513957241" t="plamen where the vectors in :uses and :sees are either a path in a map as in ’get-in or may be even a Specter path if that’s possible easy."><y>#</y><d>2017-12-22</d><h>15:40</h><w>plamen</w>where the vectors in :uses and :sees are either a path in a map as in ’get-in or may be even a Specter path if that’s possible easy.</z><z id="t1513957274" t="plamen (this is more about 2. and 3.)"><y>#</y><d>2017-12-22</d><h>15:41</h><w>plamen</w>(this is more about 2. and 3.)</z><z id="t1513957294" t="plamen about question 1. another example"><y>#</y><d>2017-12-22</d><h>15:41</h><w>plamen</w>about question 1. another example</z><z id="t1513957318" t="nathanmarz so when you process var 1 and then var 2, you want the var 2 transform fn to get the updated ast from processing var 1?"><y>#</y><d>2017-12-22</d><h>15:41</h><w>nathanmarz</w>so when you process var 1 and then var 2, you want the var 2 transform fn to get the updated ast from processing var 1?</z><z id="t1513957350" t="plamen yes"><y>#</y><d>2017-12-22</d><h>15:42</h><w>plamen</w>yes</z><z id="t1513957353" t="plamen exactly"><y>#</y><d>2017-12-22</d><h>15:42</h><w>plamen</w>exactly</z><z id="t1513957361" t="plamen as in"><y>#</y><d>2017-12-22</d><h>15:42</h><w>plamen</w>as in</z><z id="t1513957365" t="plamen initial tree"><y>#</y><d>2017-12-22</d><h>15:42</h><w>plamen</w>initial tree</z><z id="t1513957367" t="plamen {... ... ’A {:type :double} :variables {... ... ’A {} ’C {} :variables {... ... ’B {:type :double :formula “A + C”} ... ... } ... ...}}"><y>#</y><d>2017-12-22</d><h>15:42</h><w>plamen</w>{... ...
 ’A {:type :double}
 :variables {... ...
             ’A {}
			 ’C {}
             :variables {... ...
			             ’B {:type :double
						     :formula “A + C”}
						 ... ...
			             }
		     ... ...}}</z><z id="t1513957385" t="plamen when transforming ’A I can add {:type :int} to it"><y>#</y><d>2017-12-22</d><h>15:43</h><w>plamen</w>when transforming ’A I can add {:type :int} to it</z><z id="t1513957415" t="nathanmarz I do exactly that with my graph navigators"><y>#</y><d>2017-12-22</d><h>15:43</h><w>nathanmarz</w>I do exactly that with my graph navigators</z><z id="t1513957426" t="plamen and in the next recursion step when I process ’B, the :type values of ’A and ’C are already visible to the invocation of the transform function"><y>#</y><d>2017-12-22</d><h>15:43</h><w>plamen</w>and in the next recursion step when I process ’B, the :type values of ’A and ’C are already visible to the invocation of the transform function</z><z id="t1513957439" t="nathanmarz my navigators don&apos;t navigate directly to a node, but to a pair of [graph node-id]"><y>#</y><d>2017-12-22</d><h>15:43</h><w>nathanmarz</w>my navigators don&apos;t navigate directly to a node, but to a pair of <code>[graph node-id]</code></z><z id="t1513957451" t="plamen I know how to do it outside of Specter, but specter gives me much more concise way"><y>#</y><d>2017-12-22</d><h>15:44</h><w>plamen</w>I know how to do it outside of Specter, but specter gives me much more concise way</z><z id="t1513957457" t="plamen yes"><y>#</y><d>2017-12-22</d><h>15:44</h><w>plamen</w>yes</z></g><g id="s18"><z id="t1513957459" t="nathanmarz so when I do TOPSORT , it navigates to [graph node-id] in topological order, with each step having the updates form previous steps"><y>#</y><d>2017-12-22</d><h>15:44</h><w>nathanmarz</w>so when I do <code>TOPSORT</code>, it navigates to <code>[graph node-id]</code> in topological order, with each step having the updates form previous steps</z><z id="t1513957479" t="nathanmarz I believe you can do something similar for your use case with zippers"><y>#</y><d>2017-12-22</d><h>15:44</h><w>nathanmarz</w>I believe you can do something similar for your use case with zippers</z><z id="t1513957488" t="nathanmarz look at com.rpl.specter.zipper"><y>#</y><d>2017-12-22</d><h>15:44</h><w>nathanmarz</w>look at com.rpl.specter.zipper</z><z id="t1513957493" t="plamen in my normal clj code I also on each step have something like [root-node local-path-in-the-recursion]"><y>#</y><d>2017-12-22</d><h>15:44</h><w>plamen</w>in my normal clj code I also on each step have something like [root-node local-path-in-the-recursion]</z><z id="t1513957507" t="plamen exactlyt"><y>#</y><d>2017-12-22</d><h>15:45</h><w>plamen</w>exactlyt</z><z id="t1513957509" t="plamen -t"><y>#</y><d>2017-12-22</d><h>15:45</h><w>plamen</w>-t</z><z id="t1513957514" t="nathanmarz https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers"><y>#</y><d>2017-12-22</d><h>15:45</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers" target="_blank">https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers</a></z><z id="t1513957575" t="plamen I even did’t tought about zippers, as in normal Clj I achieve it without them. Thank you for the big hint!"><y>#</y><d>2017-12-22</d><h>15:46</h><w>plamen</w>I even did’t tought about zippers, as in normal Clj I achieve it without them. Thank you for the big hint!</z><z id="t1513957597" t="nathanmarz zippers are an advanced form of navigation"><y>#</y><d>2017-12-22</d><h>15:46</h><w>nathanmarz</w>zippers are an advanced form of navigation</z><z id="t1513957607" t="plamen so when I do TOPSORT , it navigates to [graph node-id] in topological order, with each step having the updates form previous step - was exactly what I was looking it"><y>#</y><d>2017-12-22</d><h>15:46</h><w>plamen</w>so when I do <code>TOPSORT</code>, it navigates to <code>[graph node-id]</code> in topological order, with each step having the updates form previous step - was exactly what I was looking it</z><z id="t1513957611" t="plamen it=at"><y>#</y><d>2017-12-22</d><h>15:46</h><w>plamen</w>it=at</z><z id="t1513957615" t="nathanmarz more indirect but can do things you can&apos;t with regular navigators"><y>#</y><d>2017-12-22</d><h>15:46</h><w>nathanmarz</w>more indirect but can do things you can&apos;t with regular navigators</z><z id="t1513957625" t="nathanmarz at the cost of increased overhead"><y>#</y><d>2017-12-22</d><h>15:47</h><w>nathanmarz</w>at the cost of increased overhead</z><z id="t1513957628" t="plamen will read"><y>#</y><d>2017-12-22</d><h>15:47</h><w>plamen</w>will read</z><z id="t1513957662" t="plamen yes - the overhead is not that important for me as it will be used in a compilation phase, where not the compilation, but the runtime is important"><y>#</y><d>2017-12-22</d><h>15:47</h><w>plamen</w>yes - the overhead is not that important for me as it will be used in a compilation phase, where not the compilation, but the runtime is important</z><z id="t1513957913" t="plamen while the topological order is important for me, because without it - no chance for correct code generation. but needed to ask first about step 1 and then to think how to overlay the order on top of it in Specter."><y>#</y><d>2017-12-22</d><h>15:51</h><w>plamen</w>while the topological order is important for me, because without it - no chance for correct code generation. but needed to ask first about step 1 and then to think how to overlay the order on top of it in Specter.</z><z id="t1513958514" t="plamen reading the doc it looks to me that I have to solve couple of things (and rewire the brain a bit for using zippers)"><y>#</y><d>2017-12-22</d><h>16:01</h><w>plamen</w>reading the doc it looks to me that I have to solve couple of things (and rewire the brain a bit for using zippers)</z><z id="t1513958559" t="plamen 1. I need to create a specter/zip constructor for nested maps and vectors which can be used from Specter"><y>#</y><d>2017-12-22</d><h>16:02</h><w>plamen</w>1. I need to create a specter/zip constructor for nested maps and vectors which can be used from Specter</z><z id="t1513958716" t="plamen 2. not sure if I read it correctly from the examples, but all S/transform invoke a function with the node itself, but not with the zipper, so how would I navigate back to an upper level if the transform function (in the examples - inc) receives only the current value?"><y>#</y><d>2017-12-22</d><h>16:05</h><w>plamen</w>2. not sure if I read it correctly from the examples, but all S/transform invoke a function with the node itself, but not with the zipper, so how would I navigate back to an upper level if the transform function (in the examples - inc) receives only the current value?</z><z id="t1513958824" t="plamen what I mean - from the examples the line (S/transform [SZ/VECTOR-ZIP SZ/DOWN SZ/NODE] inc data) invokes ’inc only with the value of the current node, but how would one consult upper nodes from inside ’inc?"><y>#</y><d>2017-12-22</d><h>16:07</h><w>plamen</w>what I mean - from the examples the line (S/transform [SZ/VECTOR-ZIP SZ/DOWN SZ/NODE] inc data) invokes ’inc only with the value of the current node, but how would one consult upper nodes from inside ’inc?</z><z id="t1513959239" t="plamen 3. not sure yet how to do the recursion as the zip paths are to specific ‘coordinates’. I could using normal clojure recursion where on each node I construct a new zipper and walk/transform from there. Is this the right line of tought?"><y>#</y><d>2017-12-22</d><h>16:13</h><w>plamen</w>3. not sure yet how to do the recursion as the zip paths are to specific ‘coordinates’. I could using normal clojure recursion where on each node I construct a new zipper and walk/transform from there. Is this the right line of tought?</z><z id="t1513960583" t="nathanmarz yea, on second thought zippers won&apos;t be enough for what you want to do"><y>#</y><d>2017-12-22</d><h>16:36</h><w>nathanmarz</w>yea, on second thought zippers won&apos;t be enough for what you want to do</z><z id="t1513960692" t="nathanmarz you need a custom navigator that understands the data structure as a whole"><y>#</y><d>2017-12-22</d><h>16:38</h><w>nathanmarz</w>you need a custom navigator that understands the data structure as a whole</z><z id="t1513960698" t="nathanmarz to do something like the TOPSORT I described"><y>#</y><d>2017-12-22</d><h>16:38</h><w>nathanmarz</w>to do something like the <code>TOPSORT</code> I described</z><z id="t1513960852" t="nathanmarz for reference, my TOPSORT code looks like this: (defn- multi-anchor-path-select [graph getter next-fn] (doseqres NONE [anchor (getter graph)] (next-fn [graph anchor]))) (defn- multi-anchor-path-transform [graph getter next-fn] (reduce (fn [graph node-id] (-&gt; [graph node-id] next-fn first)) graph (getter graph))) (defnav multi-anchor-path [getter] (select* [this graph next-fn] (multi-anchor-path-select graph getter next-fn)) (transform* [this graph next-fn] (multi-anchor-path-transform graph getter next-fn))) (def TOPSORT (multi-anchor-path topsort)) "><y>#</y><d>2017-12-22</d><h>16:40</h><w>nathanmarz</w>for reference, my <code>TOPSORT</code> code looks like this:
<pre>(defn- multi-anchor-path-select [graph getter next-fn]
  (doseqres NONE [anchor (getter graph)]
    (next-fn [graph anchor])))


(defn- multi-anchor-path-transform [graph getter next-fn]
  (reduce (fn [graph node-id]
            (-&gt; [graph node-id] next-fn first))
          graph
          (getter graph)))

(defnav multi-anchor-path [getter]
  (select* [this graph next-fn]
    (multi-anchor-path-select graph getter next-fn))
  (transform* [this graph next-fn]
    (multi-anchor-path-transform graph getter next-fn)))

(def TOPSORT (multi-anchor-path topsort))
</pre></z><z id="t1513960938" t="nathanmarz this is built on top of loom https://github.com/aysylu/loom"><y>#</y><d>2017-12-22</d><h>16:42</h><w>nathanmarz</w>this is built on top of loom <a href="https://github.com/aysylu/loom" target="_blank">https://github.com/aysylu/loom</a></z><z id="t1513965845" t="plamen Thank you for the direction, Nathan! I tought it is something trivial 🙂 Now I need to rethink"><y>#</y><d>2017-12-22</d><h>18:04</h><w>plamen</w>Thank you for the direction, Nathan! I tought it is something trivial <b>🙂</b> Now I need to rethink</z><z id="t1513965859" t="plamen And for taking time again for my questions!"><y>#</y><d>2017-12-22</d><h>18:04</h><w>plamen</w>And for taking time again for my questions!</z><z id="t1514133244" t="jvuillermet Hello, given a collection like this one [:set1 :set2 :submit :set1 :submit :se2 :set3] I want a function that returns the items immediately before each :submit if no :submit in the coll, I need an empty coll result user=&gt; (-&gt;&gt; [:set1 :set2 :submit :set1 :submit :se2 :set3] (partition-by #(= :submit %)) butlast (remove #(= (list :submit) %)) (map last)) (:set2 :set1) is my current solution using partition-by . Is there a way to do that with specter ? (or a better way in clojure for that matter, but I’m mainly interested in the specter version)"><y>#</y><d>2017-12-24</d><h>16:34</h><w>jvuillermet</w>Hello, given a collection like this one <code>[:set1 :set2 :submit :set1 :submit :se2 :set3]</code>
I want a function that returns the items immediately before each <code>:submit</code> 
if no <code>:submit</code> in the coll, I need an empty coll result

<pre>user=&gt; (-&gt;&gt; [:set1 :set2 :submit :set1 :submit :se2 :set3] (partition-by #(= :submit %)) butlast (remove #(= (list :submit) %)) (map last))
(:set2 :set1)</pre>
is my current solution using <code>partition-by</code>.

Is there a way to do that with specter ? (or a better way in clojure for that matter, but I’m mainly interested in the specter version)</z><z id="t1514144823" t="nathanmarz @jvuillermet this is similar: user=&gt; (select [(continuous-subseqs #(not= :submit %)) LAST] data) [:set2 :set1 :set3] "><y>#</y><d>2017-12-24</d><h>19:47</h><w>nathanmarz</w>@jvuillermet this is similar:
<pre>user=&gt; (select [(continuous-subseqs #(not= :submit %)) LAST] data)
[:set2 :set1 :set3]
</pre></z><z id="t1514144860" t="nathanmarz With https://github.com/nathanmarz/specter/issues/236 you could get exactly the same behavior"><y>#</y><d>2017-12-24</d><h>19:47</h><w>nathanmarz</w>With <a href="https://github.com/nathanmarz/specter/issues/236" target="_blank">https://github.com/nathanmarz/specter/issues/236</a> you could get exactly the same behavior</z><z id="t1514838555" t="mbjarland how would I go about calculating the sum of the string lengths in the following data structure (oh and yes, Nathan, I did cave in and pull in specter into my project, the convenience is just too alluring): [{:delim [&quot;-&quot;]} {:align :L} {:delim [&quot;-&quot; :F &quot;-&quot;]} {:align :R} {:delim [&quot;-&quot;]}] I’m assuming using: (specter/traverse-all [ALL :delim ALL string?]) together with transduce would somehow do the trick? the answer from the above data structure should be 4 as there are 4 strings of length 1 in the :delim maps in the exapmle"><y>#</y><d>2018-01-01</d><h>20:29</h><w>mbjarland</w>how would I go about calculating the sum of the string lengths in the following data structure (oh and yes, Nathan, I did cave in and pull in specter into my project, the convenience is just too alluring): 
<pre>[{:delim [&quot;-&quot;]} {:align :L} {:delim [&quot;-&quot; :F &quot;-&quot;]} {:align :R} {:delim [&quot;-&quot;]}]
</pre>
I’m assuming using: 
<pre>(specter/traverse-all [ALL :delim ALL string?])
</pre>
together with transduce would somehow do the trick?

the answer from the above data structure should be <code>4</code> as there are 4 strings of length 1 in the <code>:delim</code> maps in the exapmle</z><z id="t1514838662" t="mbjarland I suspect I’m just not friendly enough with transducers and am tripping over myself here"><y>#</y><d>2018-01-01</d><h>20:31</h><w>mbjarland</w>I suspect I’m just not friendly enough with transducers and am tripping over myself here</z><z id="t1514839121" t="mbjarland one way would be to step out from specter and do: (reduce + (map count (specter/select [ALL :delim ALL string?] my-d))) but I figured there might be some way of being even terser here"><y>#</y><d>2018-01-01</d><h>20:38</h><w>mbjarland</w>one way would be to step out from specter and do: 
<pre>(reduce + 
        (map count 
          (specter/select [ALL :delim ALL string?] my-d)))
</pre>
but I figured there might be some way of being even terser here</z><z id="t1514839460" t="nathanmarz @mbjarland this works: (reduce + (traverse [ALL :delim ALL string? (view count)] data))"><y>#</y><d>2018-01-01</d><h>20:44</h><w>nathanmarz</w>@mbjarland this works: <code>(reduce + (traverse [ALL :delim ALL string? (view count)] data))</code></z><z id="t1514839489" t="nathanmarz using view lets you avoid needing transducers to make this efficient"><y>#</y><d>2018-01-01</d><h>20:44</h><w>nathanmarz</w>using <code>view</code> lets you avoid needing transducers to make this efficient</z><z id="t1514886672" t="mbjarland view …suspected there was something like this in there. Specter is awesome"><y>#</y><d>2018-01-02</d><h>09:51</h><w>mbjarland</w><code>view</code>…suspected there was something like this in there. Specter is awesome</z><z id="t1514903736" t="nathanmarz Specter 1.1.0 released https://groups.google.com/forum/#!topic/clojure/_VOAYtRkuNc"><y>#</y><d>2018-01-02</d><h>14:35</h><w>nathanmarz</w>Specter 1.1.0 released <a href="https://groups.google.com/forum/#!topic/clojure/_VOAYtRkuNc" target="_blank">https://groups.google.com/forum/#!topic/clojure/_VOAYtRkuNc</a></z><z id="t1514949985" t="mbjarland if I wanted to do a chain of transformations and wanted to avoid writing: (let [data (transform ... data) data (transform ... data) ...] ) how would I go about that?"><y>#</y><d>2018-01-03</d><h>03:26</h><w>mbjarland</w>if I wanted to do a chain of transformations and wanted to avoid writing: 
<pre>(let [data (transform ... data)
      data (transform ... data)
        ...] )
</pre>
how would I go about that?</z><z id="t1514953467" t="nathanmarz @mbjarland either (-&gt;&gt; data (transform ...) (transform ...)) or use multi-transform"><y>#</y><d>2018-01-03</d><h>04:24</h><w>nathanmarz</w>@mbjarland either <code>(-&gt;&gt; data (transform ...) (transform ...))</code> or use <code>multi-transform</code></z><z id="t1514953513" t="nathanmarz i prefer the former except where paths share a lot of structure"><y>#</y><d>2018-01-03</d><h>04:25</h><w>nathanmarz</w>i prefer the former except where paths share a lot of structure</z><z id="t1515092388" t="wcohen is specter the proper tool for long/wide data transformations, analogous to R’s reshape2? in other words, conversions from something like: {{:id 1 :year 2016 :val foo} {:id 1 :year 2017 :val bar} {:id 2 :year 2016 :val abc} {:id 2 :year 2017 :val def}} to something like: {{:id 1 :2016 foo :2017 bar} {:id 2 :2016 abc :2017 def}}"><y>#</y><d>2018-01-04</d><h>18:59</h><w>wcohen</w>is specter the proper tool for long/wide data transformations, analogous to R’s reshape2?
in other words, conversions from something like:
<pre>{{:id 1 :year 2016 :val foo}
{:id 1 :year 2017 :val bar}
{:id 2 :year 2016 :val abc}
{:id 2 :year 2017 :val def}}</pre>

to something like:
<pre>{{:id 1 :2016 foo :2017 bar}
{:id 2 :2016 abc :2017 def}}</pre></z><z id="t1515092529" t="nathanmarz @wcohen no, that&apos;s not what specter&apos;s for"><y>#</y><d>2018-01-04</d><h>19:02</h><w>nathanmarz</w>@wcohen no, that&apos;s not what specter&apos;s for</z><z id="t1515093442" t="wcohen thanks!"><y>#</y><d>2018-01-04</d><h>19:17</h><w>wcohen</w>thanks!</z><z id="t1515238426" t="chromalchemy What&apos;s a good way to conditionally add/remove a value based on whether it&apos;s already in a collection? Basically like assoc or dissoc for vectors, based on value instead of index. Example: If :a is not it in [:b :c] , add it, else remove it."><y>#</y><d>2018-01-06</d><h>11:33</h><w>chromalchemy</w>What&apos;s a good way to conditionally add/remove a value based on whether it&apos;s already in a collection? Basically like <code>assoc</code> or <code>dissoc</code> for vectors, based on value instead of index. Example: If <code>:a</code> is not it  in <code>[:b :c]</code>, add it, else remove it.</z><z id="t1515238520" t="chromalchemy I want to reach for if-path but don&apos;t think I can use setval with that to conditionally set :a or NONE"><y>#</y><d>2018-01-06</d><h>11:35</h><w>chromalchemy</w>I want to reach for <code>if-path</code> but don&apos;t think I can use <code>setval</code> with that to conditionally set <code>:a</code> or <code>NONE</code></z><z id="t1515238689" t="chromalchemy Or should I just stick to using maps?"><y>#</y><d>2018-01-06</d><h>11:38</h><w>chromalchemy</w>Or should I just stick to using maps?</z><z id="t1515239077" t="chromalchemy I&apos;m trying to filter some items on some keywords, and I wanted to avoid having {:a true :b false} or {:a nil :b :nil} cluttering my data up. I feel like map values are redundant, because I can get boolean truthiness by testing for the presence of keywords (in maps at least)."><y>#</y><d>2018-01-06</d><h>11:44</h><w>chromalchemy</w>I&apos;m trying to filter some items on some keywords, and I wanted to avoid having <code>{:a true :b false}</code> or <code>{:a nil :b :nil}</code> cluttering my data up. I feel like map values are redundant, because I can get boolean truthiness by testing for the presence of keywords (in maps at least).</z><z id="t1515240549" t="chromalchemy Probably I should use a set instead of a vector. But don&apos;t think that deserializes from Firebase properly, which is what I&apos;m using for persistence."><y>#</y><d>2018-01-06</d><h>12:09</h><w>chromalchemy</w>Probably I should use a set instead of a vector. But don&apos;t think that deserializes from Firebase properly, which is what I&apos;m using for persistence.</z><z id="t1515241402" t="schmee @chromalchemy I think you can use https://github.com/nathanmarz/specter/wiki/List-of-Macros#multi-transform for this"><y>#</y><d>2018-01-06</d><h>12:23</h><w>schmee</w>@chromalchemy I think you can use <a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#multi-transform" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Macros#multi-transform</a> for this</z><z id="t1515245287" t="chromalchemy @nathanmarz Thank. Can I use multi-transform with if-path ?"><y>#</y><d>2018-01-06</d><h>13:28</h><w>chromalchemy</w>@nathanmarz Thank. Can I use <code>multi-transform</code> with <code>if-path</code>?</z><z id="t1515245306" t="chromalchemy instead of multi-path in the examples..."><y>#</y><d>2018-01-06</d><h>13:28</h><w>chromalchemy</w>instead of <code>multi-path</code> in the examples...</z><z id="t1515245328" t="chromalchemy right now I&apos;m hung up on: (select (if-path (= 1 2) ; false condition [ALL (pred= :a)] [ALL (pred= :c)]) [:a :b :c]) =&gt; [:a]"><y>#</y><d>2018-01-06</d><h>13:28</h><w>chromalchemy</w>right now I&apos;m hung up on:
<pre>(select
    (if-path (= 1 2) ; false condition
      [ALL (pred= :a)]
      [ALL (pred= :c)])
    [:a :b :c])
=&gt; [:a]</pre></z><z id="t1515245422" t="chromalchemy Doesn&apos;t seem to want to return the second path, based on the negative condition"><y>#</y><d>2018-01-06</d><h>13:30</h><w>chromalchemy</w>Doesn&apos;t seem to want to return the second path, based on the negative condition</z><z id="t1515245459" t="chromalchemy Oh I think I see. It must be a conditional-path, not a generic condition..."><y>#</y><d>2018-01-06</d><h>13:30</h><w>chromalchemy</w>Oh I think I see. It must be a conditional-path, not a generic condition...</z><z id="t1515247914" t="chromalchemy This is working! (multi-transform (if-path [ ALL (pred= :a)] [ ALL (pred= :a) (terminal-val NONE)] [ BEFORE-ELEM (terminal-val :a)]) [:a :b :c])"><y>#</y><d>2018-01-06</d><h>14:11</h><w>chromalchemy</w>This is working! <pre>(multi-transform
  (if-path
    [ ALL (pred= :a)]
    [ ALL (pred= :a) (terminal-val NONE)]
    [ BEFORE-ELEM (terminal-val :a)])
  [:a :b :c])</pre></z><z id="t1515248085" t="chromalchemy Do you think I am barking up the wrong tree performance-wise to use keywords in vectors this way? The set of keywords will be pretty small, so I hope sequential lookup with (pred=) is not too big a drag."><y>#</y><d>2018-01-06</d><h>14:14</h><w>chromalchemy</w>Do you think I am barking up the wrong tree performance-wise to use keywords in vectors this way? The set of keywords will be pretty small, so I hope sequential lookup with <code>(pred=)</code> is not too big a drag.</z><z id="t1515248175" t="nathanmarz @chromalchemy if ordering isn&apos;t important, then using a set or multi-set would be much more natural"><y>#</y><d>2018-01-06</d><h>14:16</h><w>nathanmarz</w>@chromalchemy if ordering isn&apos;t important, then using a set or multi-set would be much more natural</z><z id="t1515274448" t="schmee hmm… am I doing something wrong here or is this supposed to work? user=&gt; (def data {:a [:x] :b [:x :x] :c [:x :x :x]}) #&apos;user/data user=&gt; (select [MAP-VALS (view count)] data) [1 2 3] user=&gt; (reduce + (traverse [MAP-VALS (view count)] data)) 6 user=&gt; (transduce (traverse-all [MAP-VALS (view count)]) + 0 data) ClassCastException clojure.lang.Keyword cannot be cast to java.util.Map$Entry clojure.lang.APersistentMap$ValSeq.first (APersistentMap.java:234) "><y>#</y><d>2018-01-06</d><h>21:34</h><w>schmee</w>hmm… am I doing something wrong here or is this supposed to work?
<pre>user=&gt; (def data {:a [:x] :b [:x :x] :c [:x :x :x]})
#&apos;user/data
user=&gt; (select [MAP-VALS (view count)] data)
[1 2 3]
user=&gt; (reduce + (traverse [MAP-VALS (view count)] data))
6
user=&gt; (transduce (traverse-all [MAP-VALS (view count)]) + 0 data)
ClassCastException clojure.lang.Keyword cannot be cast to java.util.Map$Entry  clojure.lang.APersistentMap$ValSeq.first (APersistentMap.java:234)
</pre></z><z id="t1515278318" t="nathanmarz traverse-all runs on each item of sequential input"><y>#</y><d>2018-01-06</d><h>22:38</h><w>nathanmarz</w><code>traverse-all</code>  runs on each item of sequential input</z><z id="t1515278337" t="nathanmarz @schmee which is why is has the -all suffix"><y>#</y><d>2018-01-06</d><h>22:38</h><w>nathanmarz</w>@schmee which is why is has the <code>-all</code> suffix</z><z id="t1515278471" t="nathanmarz that&apos;s generally what transducers do"><y>#</y><d>2018-01-06</d><h>22:41</h><w>nathanmarz</w>that&apos;s generally what transducers do</z><z id="t1515278632" t="schmee ok, I think I see the difference now"><y>#</y><d>2018-01-06</d><h>22:43</h><w>schmee</w>ok, I think I see the difference now</z><z id="t1515278814" t="schmee so traverse-all can be transduced but traverse is reducible but not transducible?"><y>#</y><d>2018-01-06</d><h>22:46</h><w>schmee</w>so <code>traverse-all</code> can be transduced but <code>traverse</code> is reducible but not transducible?</z><z id="t1515278841" t="schmee if that makes any sense"><y>#</y><d>2018-01-06</d><h>22:47</h><w>schmee</w>if that makes any sense</z><z id="t1515279023" t="nathanmarz traverse-all creates a transducer"><y>#</y><d>2018-01-06</d><h>22:50</h><w>nathanmarz</w><code>traverse-all</code> creates a transducer</z><z id="t1515279030" t="nathanmarz traverse returns a reducible object"><y>#</y><d>2018-01-06</d><h>22:50</h><w>nathanmarz</w><code>traverse</code> returns a reducible object</z><z id="t1515279064" t="nathanmarz traverse-all exists to integrate specter with transducers"><y>#</y><d>2018-01-06</d><h>22:51</h><w>nathanmarz</w><code>traverse-all</code> exists to integrate specter with transducers</z><z id="t1515282440" t="schmee gotcha, thanks for clarifying :+1:"><y>#</y><d>2018-01-06</d><h>23:47</h><w>schmee</w>gotcha, thanks for clarifying <b>:+1:</b></z><z id="t1515337319" t="alexisvincent Specter is AWESOME"><y>#</y><d>2018-01-07</d><h>15:01</h><w>alexisvincent</w>Specter is AWESOME</z><z id="t1515366843" t="alexisvincent I replaced 14 lines of knarly clojure code with 3 lines of Specter calls. @nathanmarz this library makes a huge difference! Thanks! Super impressive engineering"><y>#</y><d>2018-01-07</d><h>23:14</h><w>alexisvincent</w>I replaced 14 lines of knarly clojure code with 3 lines of Specter calls. @nathanmarz this library makes a huge difference! Thanks! Super impressive engineering</z><z id="t1515370648" t="nathanmarz @alexisvincent great to hear"><y>#</y><d>2018-01-08</d><h>00:17</h><w>nathanmarz</w>@alexisvincent great to hear</z><z id="t1515401957" t="aaelony New to Specter. I&apos;m scraping http://docs.h2o.ai/h2o/latest-stable/h2o-docs/rest-api-reference.html to build a vector of maps where each map will have a key for :http-verb, :rest-path :inputs and outputs. Another challenge is that the html appears to be in 4 conceptual sections, 1) a section of a href links with rest endpoints, 2) a section of h2 headings with the http-verb and rest endpoint followed by a table with Input and Output, 3) a section of a href links with schema nouns, and 4) a final section of h2 headings with schema noun name followed by a table of keys and their descriptions. How might I keep the four sections separate, before combining them? I&apos;m also unclear if I should use select , collect , codewalker , or continue-then-stay to collect and surface nested pieces of information. Thanks in advance."><y>#</y><d>2018-01-08</d><h>08:59</h><w>aaelony</w>New to Specter. I&apos;m scraping <a href="http://docs.h2o.ai/h2o/latest-stable/h2o-docs/rest-api-reference.html" target="_blank">http://docs.h2o.ai/h2o/latest-stable/h2o-docs/rest-api-reference.html</a> to build a vector of maps where each map will have a key for :http-verb, :rest-path :inputs and outputs.   Another challenge is that the html appears to be in 4 conceptual sections, 1) a section of a href links with rest endpoints, 2) a section of h2 headings with the http-verb and rest endpoint followed by a table with Input and Output, 3) a section of a href links with schema nouns, and 4) a final section of h2 headings with schema noun name followed by a table of keys and their descriptions.  How might I keep the four sections separate, before combining them?  I&apos;m also unclear if I should use <code>select</code>, <code>collect</code>, <code>codewalker</code>, or <code>continue-then-stay</code> to collect and surface nested pieces of information.    Thanks in advance.</z><z id="t1515402257" t="aaelony https://pastebin.com/q0RQzLic"><y>#</y><d>2018-01-08</d><h>09:04</h><w>aaelony</w><a href="https://pastebin.com/q0RQzLic" target="_blank">https://pastebin.com/q0RQzLic</a></z><z id="t1515422775" t="nathanmarz @aaelony you&apos;re going to have to be more specific"><y>#</y><d>2018-01-08</d><h>14:46</h><w>nathanmarz</w>@aaelony you&apos;re going to have to be more specific</z><z id="t1515422813" t="nathanmarz you want to use specter to extract information out of html?"><y>#</y><d>2018-01-08</d><h>14:46</h><w>nathanmarz</w>you want to use specter to extract information out of html?</z><z id="t1515422843" t="nathanmarz can you paste a sample of the html you&apos;re scraping, and what you want as output?"><y>#</y><d>2018-01-08</d><h>14:47</h><w>nathanmarz</w>can you paste a sample of the html you&apos;re scraping, and what you want as output?</z><z id="t1515429574" t="aaelony ok, let me take some time to formulate a better question."><y>#</y><d>2018-01-08</d><h>16:39</h><w>aaelony</w>ok, let me take some time to formulate a better question.</z><z id="t1515442843" t="aaelony hi @nathanmarz, here is the code in clojure that I&apos;m wondering how to produce in Specter."><y>#</y><d>2018-01-08</d><h>20:20</h><w>aaelony</w>hi @nathanmarz, here is the code in clojure that I&apos;m wondering how to produce in Specter.</z><z id="t1515442845" t="aaelony (ns testing (:require [net.cgrand.enlive-html :as html] [org.httpkit.client :as http] [clojure.string :as str] )) (-&gt;&gt; (html/html-snippet (:body @(http/get &quot;&quot; {:insecure false}))) (filterv #(= (:tag %) :html)) first :content (filterv #(= (:tag %) :body)) first :content (filterv #(= (:tag %) :div)) first :content (filterv #(= (:tag %) :h2)) (mapv #(let [[verb endpoint] (-&gt; % :content first (str/split #&quot; &quot;) ) inputs (if endpoint (re-seq #&quot;\{(.*?)\}&quot; endpoint)) ] {:verb verb :endpoint endpoint :inputs inputs} )) (filterv #(or (= (:verb %) &quot;GET&quot;) (= (:verb %) &quot;POST&quot;) (= (:verb %) &quot;DELETE&quot;) (= (:verb %) &quot;HEAD&quot;))) ) "><y>#</y><d>2018-01-08</d><h>20:20</h><w>aaelony</w><pre>(ns testing 
      (:require [net.cgrand.enlive-html :as html]                                                                                                                                                                                                                                  
            [org.httpkit.client :as http]                                                                                                                                                                                                                                      
            [clojure.string :as str] ))

(-&gt;&gt; (html/html-snippet
(:body @(http/get &quot;&quot;
{:insecure false})))
(filterv #(= (:tag %) :html))
first
:content
(filterv #(= (:tag %) :body))
first
:content
(filterv #(= (:tag %) :div))
first
:content
(filterv #(= (:tag %) :h2))
(mapv #(let [[verb endpoint] (-&gt; %
:content
first
(str/split #&quot; &quot;)
)
inputs (if endpoint
(re-seq #&quot;\{(.*?)\}&quot; endpoint))
]
{:verb verb :endpoint endpoint :inputs inputs}
))
(filterv #(or (= (:verb %) &quot;GET&quot;)
(= (:verb %) &quot;POST&quot;)
(= (:verb %) &quot;DELETE&quot;)
(= (:verb %) &quot;HEAD&quot;)))
)
</pre></z><z id="t1515457933" t="nathanmarz @aaelony with specter it would be something like: (defn first-matching-tag [tag] (path (filterer #(= (:tag %) tag)) FIRST)) (select [(first-matching-tag :html) :content (first-matching-tag :div) :content (first-matching-tag :h2) ALL :content FIRST (view #(str/split #&quot; &quot;)) (fn [[verb _]] (#{&quot;GET&quot; &quot;POST&quot; &quot;DELETE&quot; &quot;HEAD&quot;} verb)) ] data) "><y>#</y><d>2018-01-09</d><h>00:32</h><w>nathanmarz</w>@aaelony with specter it would be something like:
<pre>(defn first-matching-tag [tag]
  (path (filterer #(= (:tag %) tag)) FIRST))

(select
  [(first-matching-tag :html)
   :content
   (first-matching-tag :div)
   :content
   (first-matching-tag :h2)
   ALL
   :content
   FIRST
   (view #(str/split #&quot; &quot;))
   (fn [[verb _]] (#{&quot;GET&quot; &quot;POST&quot; &quot;DELETE&quot; &quot;HEAD&quot;} verb))
   
  ]
 data)
</pre></z><z id="t1515457952" t="nathanmarz plus a little extra code to do that processing of &quot;inputs&quot; in your code"><y>#</y><d>2018-01-09</d><h>00:32</h><w>nathanmarz</w>plus a little extra code to do that processing of &quot;inputs&quot; in your code</z><z id="t1515459231" t="aaelony Thank-you, @nathanmarz. Looks more elegant and concise. I was unaware of the path macro. I’ll need to look into it. Eager to understand Specter better."><y>#</y><d>2018-01-09</d><h>00:53</h><w>aaelony</w>Thank-you, @nathanmarz. Looks more elegant and concise. I was unaware of the path macro. I’ll need to look into it. Eager to understand Specter better.</z><z id="t1515459310" t="nathanmarz @aaelony select , transform etc. implicitly use that macro"><y>#</y><d>2018-01-09</d><h>00:55</h><w>nathanmarz</w>@aaelony <code>select</code>, <code>transform</code> etc. implicitly use that macro</z><z id="t1515459338" t="nathanmarz path is the heart of what makes specter work"><y>#</y><d>2018-01-09</d><h>00:55</h><w>nathanmarz</w><code>path</code> is the heart of what makes specter work</z><z id="t1515459606" t="aaelony any reason why path instead of select in this case?"><y>#</y><d>2018-01-09</d><h>01:00</h><w>aaelony</w>any reason why path instead of select in this case?</z><z id="t1515459731" t="nathanmarz first-matching-tag returns a navigator to be composed with rest of path"><y>#</y><d>2018-01-09</d><h>01:02</h><w>nathanmarz</w><code>first-matching-tag</code> returns a navigator to be composed with rest of path</z><z id="t1515459748" t="nathanmarz select invokes a navigator on a piece of data"><y>#</y><d>2018-01-09</d><h>01:02</h><w>nathanmarz</w><code>select</code> invokes a navigator on a piece of data</z><z id="t1515465874" t="aaelony got it. thanks again"><y>#</y><d>2018-01-09</d><h>02:44</h><w>aaelony</w>got it. thanks again</z><z id="t1515710127" t="phreed Is there a way to do mutual navigation? A use would be to update one structure with data from another."><y>#</y><d>2018-01-11</d><h>22:35</h><w>phreed</w>Is there a way to do mutual navigation? A use would be to update one structure with data from another.</z><z id="t1515712537" t="nathanmarz @phreed do you have an example of a transformation of this sort?"><y>#</y><d>2018-01-11</d><h>23:15</h><w>nathanmarz</w>@phreed do you have an example of a transformation of this sort?</z><z id="t1515713752" t="phreed The general idea is seen in the &apos;reduce&apos; macro where one navigation is done over the collection and the reducing function navigates over and updates the accumulator. If the accumulator were implemented as a zipper the position would persist. In the large, assume I have a database for which I have just received a message on a relevant topic with which I want to update my database. I will navigate the message and use the information found there to navigate the database. There would be some collect object shared between the two navigators. The database could be a graph."><y>#</y><d>2018-01-11</d><h>23:35</h><w>phreed</w>The general idea is seen in the &apos;reduce&apos; macro where one navigation is done over the collection and the reducing function navigates over and updates the accumulator. If the accumulator were implemented as a zipper the position would persist.
In the large, assume I have a database for which I have just received a message on a relevant topic with which I want to update my database. I will navigate the message and use the information found there to navigate the database.
There would be some collect object shared between the two navigators.
The database could be a graph.</z><z id="t1515714237" t="nathanmarz @phreed you can use collect and collect-one to collect additional information about the data structure during navigation"><y>#</y><d>2018-01-11</d><h>23:43</h><w>nathanmarz</w>@phreed you can use <code>collect</code> and <code>collect-one</code> to collect additional information about the data structure during navigation</z><z id="t1515714257" t="nathanmarz either as additional arguments to the transform function or returned with the navigated values in select"><y>#</y><d>2018-01-11</d><h>23:44</h><w>nathanmarz</w>either as additional arguments to the transform function or returned with the navigated values in <code>select</code></z><z id="t1515714304" t="nathanmarz there&apos;s an example of doing that with a recursive data structure here: https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure"><y>#</y><d>2018-01-11</d><h>23:45</h><w>nathanmarz</w>there&apos;s an example of doing that with a recursive data structure here: <a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure" target="_blank">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure</a></z><z id="t1515717018" t="phreed @nathanmarz Yes I have been using the collect twins with select which constructs a seq. I will take a look at the example."><y>#</y><d>2018-01-12</d><h>00:30</h><w>phreed</w>@nathanmarz Yes I have been using the collect twins with select which constructs a seq. I will take a look at the example.</z><z id="t1515745296" t="schmee is there a way to make transform halt after the first successful navigation, something like transform-one ?"><y>#</y><d>2018-01-12</d><h>08:21</h><w>schmee</w>is there a way to make <code>transform</code> halt after the first successful navigation, something like <code>transform-one</code>?</z><z id="t1515745306" t="schmee I’m thinking about this case: user=&gt; (def a [{:name &quot;foo&quot; :id 1} {:name &quot;bar&quot; :id 2}]) #&apos;user/a user=&gt; (transform [ALL (selected? :id (pred= 2))] #(assoc % :name &quot;not-foo&quot;) a) [{:id 1 :name &quot;foo&quot;} {:id 2 :name &quot;not-foo&quot;}]"><y>#</y><d>2018-01-12</d><h>08:21</h><w>schmee</w>I’m thinking about this case: <pre>user=&gt; (def a [{:name &quot;foo&quot; :id 1} {:name &quot;bar&quot; :id 2}])
#&apos;user/a
user=&gt; (transform [ALL (selected? :id (pred= 2))] #(assoc % :name &quot;not-foo&quot;) a)
[{:id 1 :name &quot;foo&quot;} {:id 2 :name &quot;not-foo&quot;}]</pre></z><z id="t1515745348" t="schmee since ids are unique, there will only be one element selected so there is no need to check the rest of the elements once it has been found"><y>#</y><d>2018-01-12</d><h>08:22</h><w>schmee</w>since ids are unique, there will only be one element selected so there is no need to check the rest of the elements once it has been found</z><z id="t1515745545" t="schmee I don’t know if that makes any sense 😄"><y>#</y><d>2018-01-12</d><h>08:25</h><w>schmee</w>I don’t know if that makes any sense <b>😄</b></z><z id="t1515766371" t="nathanmarz @schmee no, nothing like that currently"><y>#</y><d>2018-01-12</d><h>14:12</h><w>nathanmarz</w>@schmee no, nothing like that currently</z><z id="t1515766422" t="nathanmarz this idea might be applicable to that kind of behavior: https://github.com/nathanmarz/specter/issues/121"><y>#</y><d>2018-01-12</d><h>14:13</h><w>nathanmarz</w>this idea might be applicable to that kind of behavior: <a href="https://github.com/nathanmarz/specter/issues/121" target="_blank">https://github.com/nathanmarz/specter/issues/121</a></z><z id="t1515767602" t="schmee yeah that seems to be it, I’ll keep an eye on that issue 👍"><y>#</y><d>2018-01-12</d><h>14:33</h><w>schmee</w>yeah that seems to be it, I’ll keep an eye on that issue <b>👍</b></z><z id="t1515883787" t="mbjarland how would I move a piece of a data structure (nested maps and vectors) from one path to another? Seems transform points at a path and changes the value at that path using a function. Would it be a select followed by a setval or is there a one-liner?"><y>#</y><d>2018-01-13</d><h>22:49</h><w>mbjarland</w>how would I move a piece of a data structure (nested maps and vectors)  from one path to another? Seems transform points at a path and changes the value at that path using a function. Would it be a <code>select</code> followed by a <code>setval</code> or is there a one-liner?</z><z id="t1515884227" t="mbjarland let me rephrase that because the case is more complex, how would I go from: {:layout [{:repeat [:a]} {:delim [&quot; &quot;]} {:repeat [:b]}], :apply-for [:odd :even]} to {:layout [{:repeat [:a] :apply-for :odd} {:delim [&quot; &quot;]} {:repeat [:b] :apply-for :even}]} where there are as many elements in the :apply-for vector as there are :repeat maps in be before structure. So we are matching by index and moving the :odd and :even to the corresponding :repeat map"><y>#</y><d>2018-01-13</d><h>22:57</h><w>mbjarland</w>let me rephrase that because the case is more complex, how would I go from: 
<pre>{:layout    [{:repeat [:a]}
             {:delim [&quot; &quot;]}
             {:repeat [:b]}],
 :apply-for [:odd :even]}
</pre>
to
<pre>{:layout    [{:repeat [:a] :apply-for :odd}
             {:delim [&quot; &quot;]}
             {:repeat [:b] :apply-for :even}]}
</pre>
where there are as many elements in the <code>:apply-for</code> vector as there are <code>:repeat</code> maps in be before structure. So we are matching by index and moving the <code>:odd</code> and <code>:even</code> to the corresponding <code>:repeat</code> map</z><z id="t1515884345" t="mbjarland I get the feeling I might have to select the vector and then do a stateful transform call where the transform function would pull items from the vector one-by-one, but let me know if there is some better way"><y>#</y><d>2018-01-13</d><h>22:59</h><w>mbjarland</w>I get the feeling I might have to select the vector and then do a stateful <code>transform</code> call where the transform function would pull items from the vector one-by-one, but let me know if there is some better way</z><z id="t1515886595" t="nathanmarz @mbjarland use subselect"><y>#</y><d>2018-01-13</d><h>23:36</h><w>nathanmarz</w>@mbjarland use <code>subselect</code></z><z id="t1515886608" t="nathanmarz (let [af (:apply-for data)] (-&gt;&gt; data (setval [:layout (subselect ALL #(contains? % :repeat) :apply-for) ] af) (setval :apply-for NONE) )) "><y>#</y><d>2018-01-13</d><h>23:36</h><w>nathanmarz</w><pre>(let [af (:apply-for data)]
  (-&gt;&gt; data
       (setval [:layout
                (subselect
                  ALL
                  #(contains? % :repeat)
                  :apply-for)
                ]
                af)
       (setval :apply-for NONE)
       ))
</pre></z><z id="t1515939901" t="mbjarland @nathanmarz wow…that is some kung-fu. Am I reading that right that we are essentially selecting a bunch of nodes in the datastructure as targets for the setval and then assigning using a vector and out comes the transformed data structure? That is perhaps the coolest statement I’ve seen so far from specter. I rewrote the subseelct path as (subselect ALL (pred :repeat) :apply-for) , seems to do the same thing. Naturally the reward for an awesome answer is another question…is there a way in specter to select the node after a node we match in a vector, i.e. assume a vector: [:a :b :c :d :e 1 :f :g] and I would like to select the item after :e"><y>#</y><d>2018-01-14</d><h>14:25</h><w>mbjarland</w>@nathanmarz wow…that is some kung-fu. Am I reading that right that we are essentially selecting a bunch of nodes in the datastructure as targets for the setval and then assigning using a vector and out comes the transformed data structure? That is perhaps the coolest statement I’ve seen so far from specter. I rewrote the subseelct path as <code>(subselect ALL (pred :repeat) :apply-for)</code>, seems to do the same thing. Naturally the reward for an awesome answer is another question…is there a way in specter to select the node after a node we match in a vector, i.e. assume a vector: 
<pre>[:a :b :c :d :e 1 :f :g]
</pre>
and I would like to select the item after <code>:e</code></z><z id="t1515940163" t="nathanmarz subselect lets you manipulate an arbitrary selection path as a sequence, where changes to the sequence apply at the original locations"><y>#</y><d>2018-01-14</d><h>14:29</h><w>nathanmarz</w><code>subselect</code> lets you manipulate an arbitrary selection path as a sequence, where changes to the sequence apply at the original locations</z><z id="t1515940212" t="nathanmarz @mbjarland you can do that with zippers"><y>#</y><d>2018-01-14</d><h>14:30</h><w>nathanmarz</w>@mbjarland you can do that with zippers</z><z id="t1515940231" t="nathanmarz also possible with srange-dynamic"><y>#</y><d>2018-01-14</d><h>14:30</h><w>nathanmarz</w>also possible with <code>srange-dynamic</code></z><z id="t1515940250" t="nathanmarz or you can make a custom navigator"><y>#</y><d>2018-01-14</d><h>14:30</h><w>nathanmarz</w>or you can make a custom navigator</z><z id="t1516205242" t="jeremys Hey guys I have been scratching my head for some time now. I want to operate the following transformation : [&quot;toto&quot; {:tag tag-to-unwrap :content [&quot;titi&quot; &quot;tutu&quot;]} {:tag tag-to-unwrap :content [&quot;toto&quot;]}] ;=&gt; [&quot;toto&quot; &quot;titi&quot; &quot;tutu&quot; &quot;toto&quot;] Right now with: (transform [ALL XML-ZIP NEXT-WALK NODE map? #(= :tag-to-unwrap (:tag %))] :content [&quot;toto&quot; {:tag tag-to-unwrap :content [&quot;titi&quot; &quot;tutu&quot;]} {:tag tag-to-unwrap :content [&quot;toto&quot;]}]) I get [&quot;toto&quot; [&quot;titi&quot; &quot;tutu&quot;] [&quot;toto&quot;]] Can I get specter to “splice” the vectors [&quot;titi&quot; &quot;tutu&quot;] and [&quot;toto&quot;] in the result?"><y>#</y><d>2018-01-17</d><h>16:07</h><w>jeremys</w>Hey guys I have been scratching my head for some time now. I want to operate the following transformation :
<pre>[&quot;toto&quot;
{:tag tag-to-unwrap :content [&quot;titi&quot; &quot;tutu&quot;]}
{:tag tag-to-unwrap :content [&quot;toto&quot;]}]
;=&gt;
[&quot;toto&quot; &quot;titi&quot; &quot;tutu&quot; &quot;toto&quot;]
</pre>
Right now with:
<pre>(transform [ALL XML-ZIP NEXT-WALK NODE map? #(= :tag-to-unwrap (:tag %))]
:content
[&quot;toto&quot;
{:tag tag-to-unwrap :content [&quot;titi&quot; &quot;tutu&quot;]}
{:tag tag-to-unwrap :content [&quot;toto&quot;]}])
</pre>
I get
<pre>[&quot;toto&quot; [&quot;titi&quot; &quot;tutu&quot;] [&quot;toto&quot;]]</pre>
Can I get specter to “splice” the vectors <code>[&quot;titi&quot; &quot;tutu&quot;]</code>and <code>[&quot;toto&quot;]</code>in the result?</z><z id="t1516206004" t="nathanmarz @jeremys with what&apos;s built-in you can do something like this: (require &apos;[com.rpl.specter.zipper :as z]) (def data [&quot;toto&quot; {:tag :a :content [&quot;titi&quot; &quot;tutu&quot;]} {:tag :a :content [&quot;toto&quot;]}] ) (transform [z/VECTOR-ZIP z/DOWN z/NEXT-WALK (selected? z/NODE map?) z/NODE-SEQ] #(select [FIRST :content ALL] %) data) "><y>#</y><d>2018-01-17</d><h>16:20</h><w>nathanmarz</w>@jeremys with what&apos;s built-in you can do something like this:
<pre>(require &apos;[com.rpl.specter.zipper :as z])

(def data
  [&quot;toto&quot;
    {:tag :a :content [&quot;titi&quot; &quot;tutu&quot;]}
    {:tag :a :content [&quot;toto&quot;]}]
  )

(transform
  [z/VECTOR-ZIP
   z/DOWN
   z/NEXT-WALK
   (selected? z/NODE map?)
   z/NODE-SEQ]
  #(select [FIRST :content ALL] %)
  data)
</pre></z><z id="t1516206070" t="nathanmarz it&apos;s also pretty easy to make an ALL-SEQ navigator which navigates to each element as a 1 element sequence, and then you could do: (transform [ALL-SEQ (selected? FIRST map?)] #(select [FIRST :content ALL] %) data ) "><y>#</y><d>2018-01-17</d><h>16:21</h><w>nathanmarz</w>it&apos;s also pretty easy to make an <code>ALL-SEQ</code> navigator which navigates to each element as a 1 element sequence, and then you could do:
<pre>(transform [ALL-SEQ (selected? FIRST map?)]
  #(select [FIRST :content ALL] %)
  data
  )
</pre></z><z id="t1516206165" t="nathanmarz technically this would work: (def ALL-SEQ (path z/VECTOR-ZIP z/DOWN z/NEXT-WALK z/NODE-SEQ))"><y>#</y><d>2018-01-17</d><h>16:22</h><w>nathanmarz</w>technically this would work: <code>(def ALL-SEQ (path z/VECTOR-ZIP z/DOWN z/NEXT-WALK z/NODE-SEQ))</code></z><z id="t1516206174" t="nathanmarz though you could make it more efficient with a custom navigator"><y>#</y><d>2018-01-17</d><h>16:22</h><w>nathanmarz</w>though you could make it more efficient with a custom navigator</z><z id="t1516206346" t="nathanmarz another solution: (transform (continuous-subseqs map?) #(select [ALL :content ALL] %) data ) "><y>#</y><d>2018-01-17</d><h>16:25</h><w>nathanmarz</w>another solution:
<pre>(transform (continuous-subseqs map?)
  #(select [ALL :content ALL] %)
  data
  )
</pre></z><z id="t1516206467" t="jeremys Thx @nathanmarz I’ll take a look and see what I can come up with."><y>#</y><d>2018-01-17</d><h>16:27</h><w>jeremys</w>Thx @nathanmarz I’ll take a look and see what I can come up with.</z><z id="t1516276307" t="jose hi, first of all, I&apos;m really enjoying specter and how easy makes many things, but I have a case where I&apos;m thinking that maybe is better to not use specter. I have a map where I want to remove and rename some keys. e.g. with specter: (-&gt;&gt; {:id 1 :data_val 5 :bad nil} (s/select-one (s/submap [:id :data_val])) (s/transform [s/MAP-KEYS] #(case % :data_val :value %)) and without (-&gt; {:id 1 :data_val 5 :bad nil} (select-keys [:id :data_val]) (clojure.set/rename-keys {:data_val :value})) what do you think? makes sense to use specter here? Is there a better way to do it with specter?"><y>#</y><d>2018-01-18</d><h>11:51</h><w>jose</w>hi, first of all, I&apos;m really enjoying specter and how easy makes many things, but I have a case where I&apos;m thinking that maybe is better to not use specter. I have a map where I want to remove and rename some keys.
e.g. with specter:
<pre>(-&gt;&gt; {:id 1 :data_val 5 :bad nil}
    (s/select-one (s/submap [:id :data_val]))
    (s/transform [s/MAP-KEYS] #(case % :data_val :value %))
</pre>
and without
<pre>(-&gt; {:id 1 :data_val 5 :bad nil}
    (select-keys [:id :data_val])
    (clojure.set/rename-keys {:data_val :value}))
</pre>
what do you think? makes sense to use specter here? Is there a better way to do it with specter?</z><z id="t1516285512" t="souenzzo Almost the same perf I think that w/o spec is more readable, in this case. (time (doseq [i (range 1000000)] (-&gt;&gt; {:id 1 :data_val 5 :bad nil} (s/select-one (s/submap [:id :data_val])) (s/transform [s/MAP-KEYS] #(case % :data_val :value %))))) &quot;Elapsed time: 1031.939844 msecs&quot; =&gt; nil (time (doseq [i (range 1000000)] (-&gt; {:id 1 :data_val 5 :bad nil} (select-keys [:id :data_val]) (clojure.set/rename-keys {:data_val :value})))) &quot;Elapsed time: 1794.127254 msecs&quot; "><y>#</y><d>2018-01-18</d><h>14:25</h><r>souenzzo</r>Almost the same perf
I think that w/o spec is more readable, in this case.
<pre>(time
  (doseq [i (range 1000000)]
    (-&gt;&gt; {:id 1 :data_val 5 :bad nil}
         (s/select-one (s/submap [:id :data_val]))
         (s/transform [s/MAP-KEYS] #(case % :data_val :value %)))))
&quot;Elapsed time: 1031.939844 msecs&quot;
=&gt; nil
(time
  (doseq [i (range 1000000)]
    (-&gt; {:id 1 :data_val 5 :bad nil}
        (select-keys [:id :data_val])
        (clojure.set/rename-keys {:data_val :value}))))
&quot;Elapsed time: 1794.127254 msecs&quot;
</pre></z><z id="t1516286101" t="souenzzo Mine is a bit faster. And has data/explicit params. (let [n 10000000] (prn &quot;specter&quot;) (time (doseq [i (range n)] (-&gt;&gt; {:id 1 :data_val 5 :bad nil} (s/select-one (s/submap [:id :data_val])) (s/transform [s/MAP-KEYS] #(case % :data_val :value %))))) (prn &quot;@souenzzo&quot;) (time (doseq [i (range n)] (let [from-&gt;to {:data_val :value :id :id}] (reduce-kv (fn [acc k v] (if (contains? from-&gt;to k) (assoc acc (from-&gt;to k) v) acc)) {} {:id 1 :data_val 5 :bad nil}))))) "><y>#</y><d>2018-01-18</d><h>14:35</h><r>souenzzo</r>Mine is a bit faster. And has data/explicit params.
<pre>(let [n 10000000]
  (prn &quot;specter&quot;)
  (time
    (doseq [i (range n)]
      (-&gt;&gt; {:id 1 :data_val 5 :bad nil}
           (s/select-one (s/submap [:id :data_val]))
           (s/transform [s/MAP-KEYS] #(case % :data_val :value %)))))
  (prn &quot;@souenzzo&quot;)
  (time
    (doseq [i (range n)]
      (let [from-&gt;to {:data_val :value
                      :id       :id}]
        (reduce-kv (fn [acc k v]
                     (if (contains? from-&gt;to k)
                       (assoc acc (from-&gt;to k) v)
                       acc)) {} {:id 1 :data_val 5 :bad nil})))))
</pre></z><z id="t1516310934" t="jose @U2J4FRT2T thanks for your example, didn&apos;t know about reduce-kv"><y>#</y><d>2018-01-18</d><h>21:28</h><r>jose</r>@U2J4FRT2T thanks for your example, didn&apos;t know about reduce-kv</z><z id="t1516378336" t="jeremys Hey guys, I wanted to share how I am finally going about “splicing” some tags in a html tree. I realize I hadn’t properly formulated my problem... Anyway here’s the code: (require &apos;[com.rpl.specter :as sp]) (require &apos;[com.rpl.specter.zipper :as spz]) (require &apos;[clojure.zip :as zip]) (def tag-to-unwrap :tag-to-unwrap) (defn tag-to-unwrap? [t] (= (:tag t) tag-to-unwrap)) (defn tag?-to-unwrap? [t] (and (map? t) (tag-to-unwrap? t))) (def TAGS-TO-UNWRAP (sp/path [spz/XML-ZIP spz/NEXT-WALK (sp/selected? [spz/NODE tag?-to-unwrap?])])) (defn unwrap [zipper] (let [cs (zip/children zipper) zipper (reduce zip/insert-right zipper (reverse cs))] (zip/remove zipper))) (defn splice-doc [doc] (sp/transform TAGS-TO-UNWRAP unwrap doc)) (splice-doc {:tag :body :content [&quot;toto&quot; {:tag tag-to-unwrap :content [&quot;titi&quot; &quot;tutu&quot;]} {:tag :div :content [{:tag tag-to-unwrap :content [&quot;toto in a div&quot;]}]}]}) ;=&gt; {:tag :body, :content [&quot;toto&quot; &quot;titi&quot; &quot;tutu&quot; {:tag :div, :content [&quot;toto in a div&quot;]}]} "><y>#</y><d>2018-01-19</d><h>16:12</h><w>jeremys</w>Hey guys, I wanted to share how I am finally going about “splicing” some tags in a html tree. I realize I hadn’t properly formulated my problem... Anyway here’s the code:
<pre>(require &apos;[com.rpl.specter :as sp])
(require &apos;[com.rpl.specter.zipper :as spz])
(require &apos;[clojure.zip :as zip])

(def tag-to-unwrap :tag-to-unwrap)
(defn tag-to-unwrap? [t] (= (:tag t) tag-to-unwrap))
(defn tag?-to-unwrap? [t] (and (map? t) (tag-to-unwrap? t)))

(def TAGS-TO-UNWRAP (sp/path [spz/XML-ZIP spz/NEXT-WALK
(sp/selected? [spz/NODE tag?-to-unwrap?])]))

(defn unwrap [zipper]
(let [cs (zip/children zipper)
zipper (reduce zip/insert-right zipper (reverse cs))]
(zip/remove zipper)))

(defn splice-doc [doc]
(sp/transform TAGS-TO-UNWRAP unwrap doc))

(splice-doc
{:tag :body
:content [&quot;toto&quot;
{:tag tag-to-unwrap :content [&quot;titi&quot; &quot;tutu&quot;]}
{:tag :div
:content [{:tag tag-to-unwrap :content [&quot;toto in a div&quot;]}]}]})
;=&gt;
{:tag :body, :content [&quot;toto&quot; &quot;titi&quot; &quot;tutu&quot; {:tag :div, :content [&quot;toto in a div&quot;]}]}
</pre></z><z id="t1516378342" t="jeremys cheers"><y>#</y><d>2018-01-19</d><h>16:12</h><w>jeremys</w>cheers</z><z id="t1516830137" t="dadair Given add-ref and parse-tree in the following snippet, is there a way to combine this pair of transform/traverse into a single traversal (to improve performance by not requiring a multi-pass of a large datastructure?) (def NODE (sp/recursive-path [] p (sp/continue-then-stay (sp/must :children) sp/MAP-VALS p))) (def terminal2 (sp/richnav [afn] (sp/select* [this vals structure next-fn] (throw (Exception. &quot;&apos;terminal2&apos; should only be used in multi-transform&quot;))) (sp/transform* [this vals structure next-fn] (afn vals structure)))) (def nodes-with-refs (sp/recursive-path [] p (sp/continue-then-stay (sp/putval :children) (sp/must :children) sp/ALL (sp/collect-one sp/FIRST) sp/LAST p))) (defn add-ref [root] (sp/multi-transform [(sp/putval :root) :root nodes-with-refs :ref (terminal2 (fn [vals _] (ref/unparse vals)))] root)) (defn parse-tree [root] (reduce (fn [result item] (if-let [parsed (parse-node item)] (conj result parsed) result)) [] (sp/traverse [:root :children MAP-VALS NODE] root))) (-&gt;&gt; test-segment ;; potentially large datastructure with form {:root {:name &quot;root&quot; .. :children {..}}} add-ref ;; add path down the tree to each node in the tree, e.g., &quot;/a/b/c&quot; where A, B, C are nodes with names a, b, c parse-tree) "><y>#</y><d>2018-01-24</d><h>21:42</h><w>dadair</w>Given <code>add-ref</code> and <code>parse-tree</code> in the following snippet, is there a way to combine this pair of transform/traverse into a single traversal (to improve performance by not requiring a multi-pass of a large datastructure?)

<pre>(def NODE
    (sp/recursive-path [] p
                       (sp/continue-then-stay
                        (sp/must :children)
                        sp/MAP-VALS
                        p)))

  (def terminal2
    (sp/richnav [afn]
                (sp/select* [this vals structure next-fn]
                            (throw (Exception. &quot;&apos;terminal2&apos; should only be used in multi-transform&quot;)))
                (sp/transform* [this vals structure next-fn]
                               (afn vals structure))))

  (def nodes-with-refs
    (sp/recursive-path [] p
                       (sp/continue-then-stay
                        (sp/putval :children)
                        (sp/must :children)
                        sp/ALL
                        (sp/collect-one sp/FIRST)
                        sp/LAST
                        p)))

  (defn add-ref [root]
    (sp/multi-transform
     [(sp/putval :root)
      :root
      nodes-with-refs
      :ref
      (terminal2 (fn [vals _] (ref/unparse vals)))]
     root))

  (defn parse-tree [root]
    (reduce
     (fn [result item]
       (if-let [parsed (parse-node item)]
         (conj result parsed)
         result))
     []
     (sp/traverse [:root :children MAP-VALS NODE] root)))

  (-&gt;&gt; test-segment ;; potentially large datastructure with form {:root {:name &quot;root&quot; .. :children {..}}}
       add-ref ;; add path down the tree to each node in the tree, e.g., &quot;/a/b/c&quot; where A, B, C are nodes with names a, b, c
       parse-tree)
</pre></z><z id="t1516830373" t="nathanmarz @dadair can you just collect the path in parse-tree ?"><y>#</y><d>2018-01-24</d><h>21:46</h><w>nathanmarz</w>@dadair can you just collect the path in <code>parse-tree</code>?</z><z id="t1516830422" t="nathanmarz besides that, the latest release adds vtransform which eliminate the need for you to do multi-transform with custom terminal2"><y>#</y><d>2018-01-24</d><h>21:47</h><w>nathanmarz</w>besides that, the latest release adds <code>vtransform</code> which eliminate the need for you to do <code>multi-transform</code> with custom <code>terminal2</code></z><z id="t1516830497" t="nathanmarz you might benefit here from a new vselect which navigates to [collected-vals navigated-value]"><y>#</y><d>2018-01-24</d><h>21:48</h><w>nathanmarz</w>you might benefit here from a new <code>vselect</code> which navigates to <code>[collected-vals navigated-value]</code></z><z id="t1516831538" t="dadair Thanks for pointing out vtransform , cleans up the code! I’m not quite sure how I would go about collecting the path in parse-tree, and passing those collected values into the reducing function."><y>#</y><d>2018-01-24</d><h>22:05</h><w>dadair</w>Thanks for pointing out <code>vtransform</code>, cleans up the code! I’m not quite sure how I would go about collecting the path in parse-tree, and passing those collected values into the reducing function.</z><z id="t1516831682" t="dadair hmm, are you suggesting that I could change the sp/traverse call to a vselect , and then item in the reduce would be [collected navigated] ?"><y>#</y><d>2018-01-24</d><h>22:08</h><w>dadair</w>hmm, are you suggesting that I could change the <code>sp/traverse</code> call to a <code>vselect</code>, and then <code>item</code> in the reduce would be <code>[collected navigated]</code>?</z><z id="t1516842391" t="nathanmarz @dadair yes, that&apos;s right"><y>#</y><d>2018-01-25</d><h>01:06</h><w>nathanmarz</w>@dadair yes, that&apos;s right</z><z id="t1516842441" t="nathanmarz would add a vtraverse as well"><y>#</y><d>2018-01-25</d><h>01:07</h><w>nathanmarz</w>would add a <code>vtraverse</code> as well</z><z id="t1516842447" t="nathanmarz will probably do those for next release"><y>#</y><d>2018-01-25</d><h>01:07</h><w>nathanmarz</w>will probably do those for next release</z><z id="t1516842512" t="nathanmarz but for now you can collect the path just like you&apos;re doing in nodes-with-refs and then parse it out of item when doing the traverse"><y>#</y><d>2018-01-25</d><h>01:08</h><w>nathanmarz</w>but for now you can collect the path just like you&apos;re doing in <code>nodes-with-refs</code> and then parse it out of <code>item</code> when doing the <code>traverse</code></z><z id="t1516843780" t="dadair Ok thank you I’ll give that a try"><y>#</y><d>2018-01-25</d><h>01:29</h><w>dadair</w>Ok thank you I’ll give that a try</z><z id="t1516923359" t="schmee is there a more specter-y way to write (view (juxt :color :symbol)) ?"><y>#</y><d>2018-01-25</d><h>23:35</h><w>schmee</w>is there a more specter-y way to write <code>(view (juxt :color :symbol))</code>?</z><z id="t1516923789" t="nathanmarz @schmee looks good to me"><y>#</y><d>2018-01-25</d><h>23:43</h><w>nathanmarz</w>@schmee looks good to me</z><z id="t1516924198" t="schmee is there something I can use in place of ??? to make this true? user=&gt; stuff [{:color :red :symbol :moon} {:color :green :symbol :gear} {:color :yellow :symbol :star} {:color :blue :symbol :planet}] user=&gt; (= (select (??? :color :symbol) stuff) [[:red :green :yellow :blue] [:moon :gear :star :planet]]) "><y>#</y><d>2018-01-25</d><h>23:49</h><w>schmee</w>is there something I can use in place of ??? to make this true?
<pre>user=&gt; stuff
[{:color :red :symbol :moon} {:color :green :symbol :gear} {:color :yellow :symbol :star} {:color :blue :symbol :planet}]
user=&gt; (= (select (??? :color :symbol) stuff) [[:red :green :yellow :blue] [:moon :gear :star :planet]])
</pre></z><z id="t1516924251" t="schmee feels like a multi-select"><y>#</y><d>2018-01-25</d><h>23:50</h><w>schmee</w>feels like a <code>multi-select</code></z><z id="t1516926773" t="nathanmarz well, this will do it but it&apos;s better to just do it as two selects (select (multi-path (subselect ALL :color) (subselect ALL :symbol)) stuff)"><y>#</y><d>2018-01-26</d><h>00:32</h><w>nathanmarz</w>well, this will do it but it&apos;s better to just do it as two selects <code>(select (multi-path (subselect ALL :color) (subselect ALL :symbol)) stuff)</code></z><z id="t1517409170" t="cperrone Hi Nathan and all, I posted the problem in the #beginner channel, but someone suggested that I ask here. (I actually played with specter a bit (love it) but this is well beyond my current abilities). At its simplest level, let’s say I have a ‘dumb’ container component, e.g.: (defn my-component [content] [:div content]) … and a (possibly arbitrarily nested) tree structure, e.g. (def tree [[&quot;a&quot; [&quot;b&quot; &quot;c&quot; &quot;d&quot;]] &quot;e&quot;]) What approach would you use to walk the tree, plug-in the component and its content to return something like this? (def result [:div [:div &quot;a&quot; [:div &quot;b&quot;] [:div &quot;c&quot;] [:div &quot;d&quot;]] [:div &quot;e&quot;]]) (My naive implementation has the component recursively calling itself on the children, which I really don’t want.) Thanks so much in advance!"><y>#</y><d>2018-01-31</d><h>14:32</h><w>cperrone</w>Hi Nathan and all, I posted the problem in the #beginner channel, but someone suggested that I ask here. (I actually played with specter a bit (love it) but this is well beyond my current abilities).
At its simplest level, let’s say I have a ‘dumb’ container component, e.g.:
<pre>(defn my-component [content]
[:div content])</pre>
… and a (possibly arbitrarily nested) tree structure, e.g.
<pre>(def tree [[&quot;a&quot; [&quot;b&quot; &quot;c&quot; &quot;d&quot;]] &quot;e&quot;])</pre> 
What approach would you use to walk the tree, plug-in the component and its content to return something like this?
<pre>(def result [:div
             [:div &quot;a&quot;
              [:div &quot;b&quot;]
              [:div &quot;c&quot;]
              [:div &quot;d&quot;]]
             [:div &quot;e&quot;]])</pre>
(My naive implementation has the component recursively calling itself on the children, which I really don’t want.)
Thanks so much in advance!</z><z id="t1517409598" t="nathanmarz @cperrone what exactly are the rules you want to follow for the transformation?"><y>#</y><d>2018-01-31</d><h>14:39</h><w>nathanmarz</w>@cperrone what exactly are the rules you want to follow for the transformation?</z><z id="t1517409639" t="nathanmarz looks like you wrap leaf values in :div , except for the case of &quot;a&quot;"><y>#</y><d>2018-01-31</d><h>14:40</h><w>nathanmarz</w>looks like you wrap leaf values in <code>:div</code>, except for the case of <code>&quot;a&quot;</code></z><z id="t1517409645" t="nathanmarz which wraps it and the children"><y>#</y><d>2018-01-31</d><h>14:40</h><w>nathanmarz</w>which wraps it and the children</z><z id="t1517409651" t="nathanmarz but &quot;b&quot; doesn&apos;t follow that same rule"><y>#</y><d>2018-01-31</d><h>14:40</h><w>nathanmarz</w>but <code>&quot;b&quot;</code> doesn&apos;t follow that same rule</z><z id="t1517409870" t="cperrone Let me think. In this case, a contains b c d (which are siblings), e is at the same level of a"><y>#</y><d>2018-01-31</d><h>14:44</h><w>cperrone</w>Let me think. In this case, a contains b c d (which are siblings), e is at the same level of a</z><z id="t1517410391" t="cperrone So the rule (I think) is the same. my-component should be able to “render” its content recursively. An input map with nested :children vector may work as well, if it makes it easier. The crux of the problem is that the container wraps arbitrary content (which may include child containers)."><y>#</y><d>2018-01-31</d><h>14:53</h><w>cperrone</w>So the rule (I think) is the same. my-component should be able to “render” its content recursively. An input map with nested :children vector may work as well, if it makes it easier. The crux of the problem is that the container wraps arbitrary content (which may include child containers).</z><z id="t1517411075" t="nathanmarz @cperrone this is pretty close to what you want: (defn my-component [node] `[:div ~(:val node) "><y>#</y><d>2018-01-31</d><h>15:04</h><w>nathanmarz</w>@cperrone this is pretty close to what you want:
<pre>(defn my-component [node]
  `[:div ~(:val node) </pre></z><z id="t1517411160" t="cperrone oh man, thank you so much. My kid just arrived, so I need to take a break, but I’ll definitely play with it later on."><y>#</y><d>2018-01-31</d><h>15:06</h><w>cperrone</w>oh man, thank you so much. My kid just arrived, so I need to take a break, but I’ll definitely play with it later on.</z><z id="t1517411166" t="nathanmarz sure thing"><y>#</y><d>2018-01-31</d><h>15:06</h><w>nathanmarz</w>sure thing</z><z id="t1517411198" t="nathanmarz the key is to have a consistent and regular structure to your data"><y>#</y><d>2018-01-31</d><h>15:06</h><w>nathanmarz</w>the key is to have a consistent and regular structure to your data</z><z id="t1517411292" t="cperrone yes, indeed. I love how declarative specter is by the way. It’s easy to see what’s going on. Ok, gotta go, but thank you again!"><y>#</y><d>2018-01-31</d><h>15:08</h><w>cperrone</w>yes, indeed. I love how declarative specter is by the way. It’s easy to see what’s going on. Ok, gotta go, but thank you again!</z><z id="t1517703611" t="justinlee I use specter to manipulate my state object in the front end. I’m curious: is there a way to apply multiple specter transformations to an atom atomically? If I were doing this with the normal swap! function I’d just wrap all the transformations in a fn . But I’m not sure how to do that with specter. (I’m asking because I’m worried that applying multiple specter transformations to a reagent atom might cause me grief, given that components get re-rendered in response to updates. So far, I’m not 100% this is a real problem, because I think reagent batches updates, but I’m still curious.)"><y>#</y><d>2018-02-04</d><h>00:20</h><w>justinlee</w>I use specter to manipulate my state object in the front end.  I’m curious: is there a way to apply multiple specter transformations to an atom atomically?  If I were doing this with the normal <code>swap!</code> function I’d just wrap all the transformations in a <code>fn</code>.  But I’m not sure how to do that with specter.  (I’m asking because I’m worried that applying multiple specter transformations to a reagent atom might cause me grief, given that components get re-rendered in response to updates.  So far, I’m not 100% this is a real problem, because I think reagent batches updates, but I’m still curious.)</z><z id="t1517704135" t="nathanmarz @lee.justin.m yes you can use multi-transform for that"><y>#</y><d>2018-02-04</d><h>00:28</h><w>nathanmarz</w>@lee.justin.m yes you can use <code>multi-transform</code> for that</z><z id="t1517704170" t="nathanmarz e.g. (multi-transform [ATOM (multi-path [:a (terminal inc)] [:b (terminal dec)])] state-object)"><y>#</y><d>2018-02-04</d><h>00:29</h><w>nathanmarz</w>e.g. <code>(multi-transform [ATOM (multi-path [:a (terminal inc)] [:b (terminal dec)])] state-object)</code></z><z id="t1517704186" t="justinlee @nathanmarz super thanks!"><y>#</y><d>2018-02-04</d><h>00:29</h><w>justinlee</w>@nathanmarz super thanks!</z><z id="t1517704271" t="justinlee oh i hadn’t seen this list-of-macros page. there are all kinds of goodies here."><y>#</y><d>2018-02-04</d><h>00:31</h><w>justinlee</w>oh i hadn’t seen this list-of-macros page.  there are all kinds of goodies here.</z><z id="t1517704548" t="nathanmarz definitely worth skimming through the wiki"><y>#</y><d>2018-02-04</d><h>00:35</h><w>nathanmarz</w>definitely worth skimming through the wiki</z><z id="t1517704552" t="nathanmarz it&apos;s mostly up to date nowadays"><y>#</y><d>2018-02-04</d><h>00:35</h><w>nathanmarz</w>it&apos;s mostly up to date nowadays</z><z id="t1517775803" t="justinlee @nathanmarz Just following up on the example you just used in #clojure, could you explain this: (def data {:a [:x :y] :b [:x :y]}) (select [ALL (collect-one FIRST) LAST] data) ;; -&gt; [[:a [:x :y]] [:b [:x :y]]] ;; The next statement will distribute the :a and :b (select [ALL (collect-one FIRST) LAST ALL] data) ;; -≥ [[:a :x] [:a :y] [:b :x] [:b :y]] ;; But this, which applies the same selector to the intermediate result, does not (select [ALL] [[:a [:x :y]] [:b [:x :y]]]) ;; -&gt; [[:a [:x :y]] [:b [:x :y]]] "><y>#</y><d>2018-02-04</d><h>20:23</h><w>justinlee</w>@nathanmarz Just following up on the example you just used in #clojure, could you explain this: <pre>(def data 
  {:a [:x :y]
   :b [:x :y]})
(select [ALL (collect-one FIRST) LAST] data)
;; -&gt; [[:a [:x :y]] [:b [:x :y]]]

;; The next statement will distribute the :a and :b
(select [ALL (collect-one FIRST) LAST ALL] data)
;; -≥ [[:a :x] [:a :y] [:b :x] [:b :y]]

;; But this, which applies the same selector to the intermediate result, does not
(select [ALL] [[:a [:x :y]] [:b [:x :y]]])
;; -&gt; [[:a [:x :y]] [:b [:x :y]]]
</pre></z><z id="t1517776160" t="schmee @justinlee collecting variables is a special thing, search for “collect” in the readme for an explanation: https://github.com/nathanmarz/specter"><y>#</y><d>2018-02-04</d><h>20:29</h><w>schmee</w>@justinlee collecting variables is a special thing, search for “collect” in the readme for an explanation: <a href="https://github.com/nathanmarz/specter" target="_blank">https://github.com/nathanmarz/specter</a></z><z id="t1517776318" t="justinlee @schmee thanks yea i read that and the docs for collect and collect-one but i can’t for the life of me figure out how they alter the ALL selector in the context of a select"><y>#</y><d>2018-02-04</d><h>20:31</h><w>justinlee</w>@schmee thanks yea i read that and the docs for <code>collect</code> and <code>collect-one</code> but i can’t for the life of me figure out how they alter the <code>ALL</code> selector in the context of a <code>select</code></z><z id="t1517776375" t="justinlee there is some reference to adding a value to the ‘collected values’ but I haven’t seen how the collected values are used in selectors like ALL (though I understand how they are used in the transform example when you need an argument to the transforming function"><y>#</y><d>2018-02-04</d><h>20:32</h><w>justinlee</w>there is some reference to adding a value to the ‘collected values’ but I haven’t seen how the collected values are used in selectors like <code>ALL</code> (though I understand how they are used in the <code>transform</code> example when you need an argument to the transforming function</z><z id="t1517776470" t="schmee user=&gt; (select [ALL (collect-one FIRST) LAST] data) [[:a [:x :y]] [:b [:x :y]]] user=&gt; (select [ALL (collect-one FIRST) (collect-one FIRST) LAST] data) [[:a :a [:x :y]] [:b :b [:x :y]]] "><y>#</y><d>2018-02-04</d><h>20:34</h><w>schmee</w><pre>user=&gt; (select [ALL (collect-one FIRST) LAST] data)
[[:a [:x :y]] [:b [:x :y]]]
user=&gt; (select [ALL (collect-one FIRST) (collect-one FIRST) LAST] data)
[[:a :a [:x :y]] [:b :b [:x :y]]]
</pre></z><z id="t1517776495" t="schmee looks to me like select just calls vector on the collected arguments + the value(s) you’ve navigated to"><y>#</y><d>2018-02-04</d><h>20:34</h><w>schmee</w>looks to me like <code>select</code> just calls <code>vector</code> on the collected arguments + the value(s) you’ve navigated to</z><z id="t1517776763" t="justinlee Yea I guess that’s it. I’m not sure why it does that. 🙂 com.rpl.specter=&gt; (select [(putval &quot;a&quot;) ALL] [1 2 3]) [[&quot;a&quot; 1] [&quot;a&quot; 2] [&quot;a&quot; 3]] com.rpl.specter=&gt; (select [(putval &quot;a&quot;) FIRST] [1 2 3]) [[&quot;a&quot; 1]] com.rpl.specter=&gt; (select [(putval &quot;a&quot;) (putval &quot;b&quot;) ALL] [1 2 3]) [[&quot;a&quot; &quot;b&quot; 1] [&quot;a&quot; &quot;b&quot; 2] [&quot;a&quot; &quot;b&quot; 3]]"><y>#</y><d>2018-02-04</d><h>20:39</h><w>justinlee</w>Yea I guess that’s it.  I’m not sure why it does that.  <b>🙂</b>  <pre>com.rpl.specter=&gt; (select [(putval &quot;a&quot;) ALL] [1 2 3])
[[&quot;a&quot; 1] [&quot;a&quot; 2] [&quot;a&quot; 3]]
com.rpl.specter=&gt; (select [(putval &quot;a&quot;) FIRST] [1 2 3])
[[&quot;a&quot; 1]]
com.rpl.specter=&gt; (select [(putval &quot;a&quot;) (putval &quot;b&quot;) ALL] [1 2 3])
[[&quot;a&quot; &quot;b&quot; 1] [&quot;a&quot; &quot;b&quot; 2] [&quot;a&quot; &quot;b&quot; 3]]</pre></z><z id="t1517778849" t="nathanmarz @lee.justin.m this is the code that creates that behavior: https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L294"><y>#</y><d>2018-02-04</d><h>21:14</h><w>nathanmarz</w>@lee.justin.m this is the code that creates that behavior: <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L294" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L294</a></z><z id="t1517778903" t="justinlee got it thanks. that makes sense."><y>#</y><d>2018-02-04</d><h>21:15</h><w>justinlee</w>got it thanks.  that makes sense.</z><z id="t1517853354" t="phreed Which macro provides the ability to select nodes from a tree whose subpath matches a pattern? e.g. Given (def foo {&quot;a1&quot; {:z :c1, :d &quot;e1&quot;} &quot;a2&quot; {:z :c2, :d &quot;e2&quot;}}) (select [ALL (magic [VAL :z :c1])] foo) &gt; {&quot;a1&quot; {:z :c1, :d &quot;e1&quot;} } What is the magic macro? Should I be using transform instead of select?"><y>#</y><d>2018-02-05</d><h>17:55</h><w>phreed</w>Which macro provides the ability to select nodes from a tree whose subpath matches a pattern?
e.g. Given 
(def foo {&quot;a1&quot; {:z :c1, :d &quot;e1&quot;}
               &quot;a2&quot; {:z :c2, :d &quot;e2&quot;}}) 
(select [ALL (magic [VAL :z :c1])] foo)
&gt; {&quot;a1&quot; {:z :c1, :d &quot;e1&quot;} }
What is the magic macro?
Should I be using transform instead of select?</z><z id="t1517854159" t="nathanmarz @phreed you&apos;re looking to filter submaps that don&apos;t contain a key-value pair [:z :c1] ?"><y>#</y><d>2018-02-05</d><h>18:09</h><w>nathanmarz</w>@phreed you&apos;re looking to filter submaps that don&apos;t contain a key-value pair <code>[:z :c1]</code>?</z><z id="t1517854386" t="phreed @nathanmarz yes, I think that is right."><y>#</y><d>2018-02-05</d><h>18:13</h><w>phreed</w>@nathanmarz yes, I think that is right.</z><z id="t1517854400" t="nathanmarz the basic pattern for that is (setval &lt;path&gt; NONE data)"><y>#</y><d>2018-02-05</d><h>18:13</h><w>nathanmarz</w>the basic pattern for that is <code>(setval &lt;path&gt; NONE data)</code></z><z id="t1517854406" t="nathanmarz in this case (setval [MAP-VALS (not-selected? :z (pred= :c1))] NONE foo)"><y>#</y><d>2018-02-05</d><h>18:13</h><w>nathanmarz</w>in this case <code>(setval [MAP-VALS (not-selected? :z (pred= :c1))] NONE foo)</code></z><z id="t1517854430" t="phreed yes, pruning the tree with setval does the trick."><y>#</y><d>2018-02-05</d><h>18:13</h><w>phreed</w>yes, pruning the tree with setval does the trick.</z><z id="t1517856652" t="phreed I am looking at the documentation for not-selected? it appears to take only one argument, a path. What is going on here (not-selected? :z (pred= :c1)) that looks like two arguments. Is it equivalent to (not-selected? [:z (pred= :c1)]) ?"><y>#</y><d>2018-02-05</d><h>18:50</h><w>phreed</w>I am looking at the documentation for <code>not-selected?</code> it appears to take only one argument, a path. What is going on here <code>(not-selected? :z (pred= :c1))</code> that looks like two arguments. Is it equivalent to <code>(not-selected? [:z (pred= :c1)])</code> ?</z><z id="t1517857094" t="nathanmarz @phreed yes, those are equivalent"><y>#</y><d>2018-02-05</d><h>18:58</h><w>nathanmarz</w>@phreed yes, those are equivalent</z><z id="t1517857118" t="nathanmarz similarly the path [:a :b :c] is the same as [[:a] [[:b]] :c]"><y>#</y><d>2018-02-05</d><h>18:58</h><w>nathanmarz</w>similarly the path <code>[:a :b :c]</code> is the same as <code>[[:a] [[:b]] :c]</code></z><z id="t1517857178" t="nathanmarz a path is just a composition of navigators"><y>#</y><d>2018-02-05</d><h>18:59</h><w>nathanmarz</w>a path is just a composition of navigators</z><z id="t1517857201" t="nathanmarz a vector in a path is interpreted as a path"><y>#</y><d>2018-02-05</d><h>19:00</h><w>nathanmarz</w>a vector in a path is interpreted as a path</z><z id="t1517933559" t="jamescroft Hi, I have a nested data structure like in the snippet above. I can select all the nodes of a specified type, but I’m having trouble updating them. I want the index of the node I am updating within the transform function. Any pointers on how to do this? Thanks"><y>#</y><d>2018-02-06</d><h>16:12</h><w>jamescroft</w>Hi, I have a nested data structure like in the snippet above.  I can select all the nodes of a specified type, but I’m having trouble updating them.  I want the index of the node I am updating within the transform function.  Any pointers on how to do this?  Thanks</z><z id="t1517934833" t="nathanmarz @jamescroft you can do that with subselect and a slightly modified NODES"><y>#</y><d>2018-02-06</d><h>16:33</h><w>nathanmarz</w>@jamescroft you can do that with <code>subselect</code> and a slightly modified <code>NODES</code></z><z id="t1517934835" t="nathanmarz (def NODES (recursive-path [] p (stay-then-continue (must :nodes) ALL p))) (transform [(subselect NODES #(= &quot;a&quot; (:type %)) :index) (view count)] range data) "><y>#</y><d>2018-02-06</d><h>16:33</h><w>nathanmarz</w><pre>(def NODES (recursive-path [] p (stay-then-continue (must :nodes) ALL p)))
(transform [(subselect NODES #(= &quot;a&quot; (:type %)) :index) (view count)] range data)
</pre></z><z id="t1517935296" t="jamescroft @nathanmarz great thanks! I wouldn’t have got there on my own!"><y>#</y><d>2018-02-06</d><h>16:41</h><w>jamescroft</w>@nathanmarz great thanks! I wouldn’t have got there on my own!</z><z id="t1517935501" t="nathanmarz sure thing"><y>#</y><d>2018-02-06</d><h>16:45</h><w>nathanmarz</w>sure thing</z><z id="t1517935524" t="nathanmarz I highly recommend skimming through https://github.com/nathanmarz/specter/wiki/List-of-Navigators to learn what&apos;s available"><y>#</y><d>2018-02-06</d><h>16:45</h><w>nathanmarz</w>I highly recommend skimming through <a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators</a> to learn what&apos;s available</z><z id="t1518531331" t="nathanmarz Handy cheat sheet contributed by @djebbz https://github.com/nathanmarz/specter/wiki/Cheat-Sheet"><y>#</y><d>2018-02-13</d><h>14:15</h><w>nathanmarz</w>Handy cheat sheet contributed by @djebbz <a href="https://github.com/nathanmarz/specter/wiki/Cheat-Sheet" target="_blank">https://github.com/nathanmarz/specter/wiki/Cheat-Sheet</a></z><z id="t1518562261" t="johanatan hi, if i&apos;m transform over [specter/MAP-VALS :some-key] and inside my transform i want/need to access the KEY-VAL corresponding to the particular MAP-VAL that i&apos;m in, is that possible? or do these cases always degenerate into a case of [specter/ALL] with drilling down required inside the transform-fn"><y>#</y><d>2018-02-13</d><h>22:51</h><w>johanatan</w>hi, if i&apos;m <code>transform</code> over <code>[specter/MAP-VALS :some-key]</code> and inside my transform i want/need to access the KEY-VAL corresponding to the particular MAP-VAL that i&apos;m in, is that possible? or do these cases always degenerate into a case of <code>[specter/ALL]</code> with drilling down required inside the transform-fn</z><z id="t1518564602" t="nathanmarz @johanatan accessing the key while transforming a map val is expressed as (transform [ALL (collect-one FIRST) LAST] ...)"><y>#</y><d>2018-02-13</d><h>23:30</h><w>nathanmarz</w>@johanatan accessing the key while transforming a map val is expressed as <code>(transform [ALL (collect-one FIRST) LAST] ...)</code></z><z id="t1518564628" t="johanatan ah, nice. what would be the signature be for capturing the key and the value?"><y>#</y><d>2018-02-13</d><h>23:30</h><w>johanatan</w>ah, nice. what would be the signature be for capturing the key and the value?</z><z id="t1518564635" t="johanatan just [[k v]] ?"><y>#</y><d>2018-02-13</d><h>23:30</h><w>johanatan</w>just <code>[[k v]]</code> ?</z><z id="t1518564666" t="johanatan [the transform-fn signature that is]"><y>#</y><d>2018-02-13</d><h>23:31</h><w>johanatan</w>[the transform-fn signature that is]</z><z id="t1518564736" t="johanatan and also can you have additional filters (such as the kwd in my example) after the LAST ?"><y>#</y><d>2018-02-13</d><h>23:32</h><w>johanatan</w>and also can you have additional filters (such as the kwd in my example) after the <code>LAST</code> ?</z><z id="t1518567459" t="nathanmarz @johanatan of course, navigators are infinitely composable"><y>#</y><d>2018-02-14</d><h>00:17</h><w>nathanmarz</w>@johanatan of course, navigators are infinitely composable</z><z id="t1518567491" t="nathanmarz will be easier to show you the most elegant approach if you give an example of the input and desired output"><y>#</y><d>2018-02-14</d><h>00:18</h><w>nathanmarz</w>will be easier to show you the most elegant approach if you give an example of the input and desired output</z><z id="t1518612369" t="cperrone Hi @nathanmarz and all, I’m beginning to use Specter everywhere 🙂 . I’m still struggling with some admittedly basic recursion/tree transformation though. For example, here’s my input: (def tree [0 [1] [2 [3]]]) The tree is arbitrarily nested, each node is a vector of type [root &amp; children] (e.g. [0] is the tree root, [1] and [2] its immediate children, [1] and [2] are siblings). My goal is to transform the tree into the following structure. In other words, each node under the root becomes an :li item. Also if a node has children, I’d like to “wrap” them with a :ul container. It should be simple, but I can’t get my head around it yet. But maybe you can help me on this one? [:ul [:li {:id &quot;1&quot;}] [:li {:id &quot;2&quot;} [:ul [:li {:id &quot;3&quot;}]]]]"><y>#</y><d>2018-02-14</d><h>12:46</h><w>cperrone</w>Hi @nathanmarz and all,  I’m beginning to use Specter everywhere <b>🙂</b>. I’m still struggling with some admittedly basic recursion/tree transformation though. For example, here’s my input:
<pre>(def tree [0
                 [1]
                 [2 [3]]])
</pre>
The tree is arbitrarily nested, each node is a vector of type <pre>[root &amp; children]</pre> (e.g. [0] is the tree root, [1] and [2] its immediate children, [1] and [2] are siblings). My goal is to transform the tree into the following structure. In other words, each node under the root becomes an :li item. Also if a node has children, I’d like to “wrap” them with a :ul container. It should be simple, but I can’t get my head around it yet. But maybe you can help me on this one?
<pre>[:ul
       [:li {:id &quot;1&quot;}]
       [:li {:id &quot;2&quot;}
        [:ul
         [:li {:id &quot;3&quot;}]]]]</pre></z><z id="t1518617629" t="nathanmarz @cperrone here&apos;s one way to do it: (def tree [0 [1] [2 [3]]]) (def NODE-CHILDREN (path INDEXED-VALS #(not= 0 (first %)) LAST)) (def NODES (recursive-path [] p (continue-then-stay NODE-CHILDREN p))) (defn wrap [children id _] (if (empty? children) [:li {:id id}] [:li {:id id} (setval BEFORE-ELEM :ul children)] ) ) (nth (transform [NODES (collect NODE-CHILDREN) (collect-one FIRST) ] wrap tree ) 2) "><y>#</y><d>2018-02-14</d><h>14:13</h><w>nathanmarz</w>@cperrone here&apos;s one way to do it:
<pre>(def tree [0
            [1]
            [2 [3]]])

(def NODE-CHILDREN
  (path INDEXED-VALS #(not= 0 (first %)) LAST))

(def NODES (recursive-path [] p
             (continue-then-stay
              NODE-CHILDREN
              p)))

(defn wrap [children id _]
  (if (empty? children)
    [:li {:id id}]
    [:li {:id id} (setval BEFORE-ELEM :ul children)]
    )
  )

(nth
  (transform
    [NODES
     (collect NODE-CHILDREN)
     (collect-one FIRST)
     ]
    wrap
    tree
    )
  2)
</pre></z><z id="t1518619365" t="cperrone ah brilliant, thank you @nathanmarz. I much appreciate it. I suspected I needed to collect values along the way, but I wasn’t sure how (I need to play more with that). Great answer. Would this be more typical of a zipper use, by the way? At some stage I wondered if walking with (defn my-zipper [v] (z/zipper next rest my-make-node v)) (obviously then wrapped by the specter zipper :D) would have been easier for this case."><y>#</y><d>2018-02-14</d><h>14:42</h><w>cperrone</w>ah brilliant, thank you @nathanmarz. I much appreciate it. I suspected I needed to collect values along the way, but I wasn’t sure how (I need to play more with that). Great answer. Would this be more typical of a zipper use, by the way? At some stage I wondered if walking with  <pre>(defn my-zipper [v]
  (z/zipper next rest my-make-node v))</pre> (obviously then wrapped by the specter zipper :D) would have been easier for this case.</z><z id="t1518621727" t="nathanmarz @cperrone zippers aren&apos;t needed in this case"><y>#</y><d>2018-02-14</d><h>15:22</h><w>nathanmarz</w>@cperrone zippers aren&apos;t needed in this case</z><z id="t1518621757" t="nathanmarz it&apos;s best to avoid using zippers since they add a lot of overhead"><y>#</y><d>2018-02-14</d><h>15:22</h><w>nathanmarz</w>it&apos;s best to avoid using zippers since they add a lot of overhead</z><z id="t1518621869" t="cperrone I’m still studying your approach to the problem, in particular, I was surprised by the setval within the transform fn"><y>#</y><d>2018-02-14</d><h>15:24</h><w>cperrone</w>I’m still studying your approach to the problem, in particular, I was surprised by the setval within the transform fn</z><z id="t1518622046" t="nathanmarz your use case does two things: wrap in :li and wrap in :ul"><y>#</y><d>2018-02-14</d><h>15:27</h><w>nathanmarz</w>your use case does two things: wrap in <code>:li</code> and wrap in <code>:ul</code></z><z id="t1518622076" t="nathanmarz the inner setval prepends to a vector without changing the type (as cons would do)"><y>#</y><d>2018-02-14</d><h>15:27</h><w>nathanmarz</w>the inner setval prepends to a vector without changing the type (as <code>cons</code> would do)</z><z id="t1518622216" t="cperrone yes. I guess I also need to check the result of the overall transform “before” you take the nth index."><y>#</y><d>2018-02-14</d><h>15:30</h><w>cperrone</w>yes. I guess I also need to check the result of the overall transform “before” you take the nth index.</z><z id="t1518622269" t="nathanmarz yea, the handling of the root is special with how you laid out the problem"><y>#</y><d>2018-02-14</d><h>15:31</h><w>nathanmarz</w>yea, the handling of the root is special with how you laid out the problem</z><z id="t1518622436" t="cperrone yes, maybe some slight tweaking on the input could help (as it’s often the case)"><y>#</y><d>2018-02-14</d><h>15:33</h><w>cperrone</w>yes, maybe some slight tweaking on the input could help (as it’s often the case)</z><z id="t1518622493" t="nathanmarz if you have the control, then making the structure of the data as consistent as possible helps a lot"><y>#</y><d>2018-02-14</d><h>15:34</h><w>nathanmarz</w>if you have the control, then making the structure of the data as consistent as possible helps a lot</z><z id="t1518622534" t="cperrone eh eh I do. I though I was consistent though. [root children children] all the way no?"><y>#</y><d>2018-02-14</d><h>15:35</h><w>cperrone</w>eh eh I do. I though I was consistent though. [root children children] all the way no?</z><z id="t1518622565" t="nathanmarz yea, in this case it&apos;s the output that&apos;s slightly inconsistent"><y>#</y><d>2018-02-14</d><h>15:36</h><w>nathanmarz</w>yea, in this case it&apos;s the output that&apos;s slightly inconsistent</z><z id="t1518622583" t="cperrone true, the wrapping is slightly tricky"><y>#</y><d>2018-02-14</d><h>15:36</h><w>cperrone</w>true, the wrapping is slightly tricky</z><z id="t1518622683" t="cperrone i read somewhere that zippers are pretty lightweight by the way… I don’t particularly like the imperative navigation that it often leads to though."><y>#</y><d>2018-02-14</d><h>15:38</h><w>cperrone</w>i read somewhere that zippers are pretty lightweight by the way… I don’t particularly like the imperative navigation that it often leads to though.</z><z id="t1518622774" t="nathanmarz &quot;lightweight&quot; is relative"><y>#</y><d>2018-02-14</d><h>15:39</h><w>nathanmarz</w>&quot;lightweight&quot; is relative</z><z id="t1518622800" t="nathanmarz compared to a straight reduce it&apos;s not"><y>#</y><d>2018-02-14</d><h>15:40</h><w>nathanmarz</w>compared to a straight <code>reduce</code> it&apos;s not</z><z id="t1518622822" t="nathanmarz it&apos;s not just performance, they also add conceptual overhead"><y>#</y><d>2018-02-14</d><h>15:40</h><w>nathanmarz</w>it&apos;s not just performance, they also add conceptual overhead</z><z id="t1518622823" t="cperrone ah ah I guess so, especially in clojurescript, everything counts, so it’s a matter of tradeoffs"><y>#</y><d>2018-02-14</d><h>15:40</h><w>cperrone</w>ah ah I guess so, especially in clojurescript, everything counts, so it’s a matter of tradeoffs</z><z id="t1518622832" t="cperrone indeed"><y>#</y><d>2018-02-14</d><h>15:40</h><w>cperrone</w>indeed</z><z id="t1518994021" t="Peter Wilkins Hi @nathanmarz and all. I&apos;m stuck on a (probably) simple one. I have this xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt; &lt;book&gt; &lt;frontmatter/&gt; &lt;chapter name=&quot;Introduction&quot;&gt; &lt;para&gt;Here is the intro&lt;/para&gt; &lt;para&gt;Another paragraph&lt;/para&gt; &lt;/chapter&gt; &lt;chapter name=&quot;Conclusion&quot;&gt; &lt;para&gt;All done now&lt;/para&gt; &lt;/chapter&gt; &lt;/book&gt;"><y>#</y><d>2018-02-18</d><h>22:47</h><w>Peter Wilkins</w>Hi @nathanmarz and all. I&apos;m stuck on a (probably) simple one. I have this xml:
<pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt;
&lt;book&gt;
&lt;frontmatter/&gt;
&lt;chapter name=&quot;Introduction&quot;&gt;
    &lt;para&gt;Here is the intro&lt;/para&gt;
    &lt;para&gt;Another paragraph&lt;/para&gt;
&lt;/chapter&gt;
&lt;chapter name=&quot;Conclusion&quot;&gt;
    &lt;para&gt;All done now&lt;/para&gt;
&lt;/chapter&gt;
&lt;/book&gt;</pre></z><z id="t1518994049" t="Peter Wilkins the Challenge is to get the string content from chapter elements with attr name = &quot;Introduction&quot; ; using thread last (time (-&gt;&gt; [doc] (mapcat :content) (filter #(= :chapter (:tag %))) (filter #(= &quot;Introduction&quot; (get-in % [:attrs :name]))) (mapcat :content) (filter #(= :para (:tag %))) (mapcat :content) (filter string?))) ; transducers and compose (time (eduction (comp (mapcat :content) (filter (comp (partial = :chapter) :tag)) (filter (comp (partial = &quot;Introduction&quot;) :attrs :name)) (mapcat :content) (filter (comp (partial = :para) :tag)) (mapcat :content) (filter string?)) [doc])) ; specter: this isn&apos;t correct yet... (select [:content ALL (filterer :tag #(= % :chapter)) (filterer :attrs :name #(= % &quot;Introduction&quot;)) :content ALL (filterer :tag #(= % :para)) :content ALL string?] doc)"><y>#</y><d>2018-02-18</d><h>22:47</h><w>Peter Wilkins</w>the Challenge is to get the string content from chapter elements with attr name = &quot;Introduction&quot;

; using thread last
<pre>(time (-&gt;&gt; [doc]
           (mapcat :content)
           (filter #(= :chapter (:tag %)))
           (filter #(= &quot;Introduction&quot; (get-in % [:attrs :name])))
           (mapcat :content)
           (filter #(= :para (:tag %)))
           (mapcat :content)
           (filter string?)))</pre>

; transducers and compose
<pre>(time (eduction
        (comp
          (mapcat :content)
          (filter (comp (partial = :chapter) :tag))
          (filter (comp (partial = &quot;Introduction&quot;) :attrs :name))
          (mapcat :content)
          (filter (comp (partial = :para) :tag))
          (mapcat :content)
          (filter string?))
        [doc]))</pre>

; specter: this isn&apos;t correct yet...
<pre>(select [:content ALL
         (filterer :tag #(= % :chapter))
         (filterer :attrs :name #(= % &quot;Introduction&quot;))
         :content ALL
         (filterer :tag #(= % :para))
         :content ALL
         string?] doc)</pre></z><z id="t1518995039" t="nathanmarz @poppetew I think you&apos;re looking for selected? rather than filterer ?"><y>#</y><d>2018-02-18</d><h>23:03</h><w>nathanmarz</w>@poppetew I think you&apos;re looking for <code>selected?</code> rather than <code>filterer</code>?</z><z id="t1518995043" t="nathanmarz (select [:content ALL (selected? :tag (pred= :chapter)) (selected? :attrs :name (pred= &quot;Introduction&quot;)) :content ALL (selected? :tag (pred= :para)) :content ALL string?] doc) "><y>#</y><d>2018-02-18</d><h>23:04</h><w>nathanmarz</w><pre>(select [:content
         ALL
         (selected? :tag (pred= :chapter))
         (selected? :attrs :name (pred= &quot;Introduction&quot;))
         :content
         ALL
         (selected? :tag (pred= :para))
         :content
         ALL
         string?]
  doc)
</pre></z><z id="t1518995068" t="nathanmarz pred= is also slightly nicer than doing #(= % ...)"><y>#</y><d>2018-02-18</d><h>23:04</h><w>nathanmarz</w><code>pred=</code> is also slightly nicer than doing <code>#(= % ...)</code></z><z id="t1519029721" t="Peter Wilkins thanks:+1:"><y>#</y><d>2018-02-19</d><h>08:42</h><w>Peter Wilkins</w>thanks:+1:</z><z id="t1519070210" t="pepe selected? is the navigator I was looking for, but was blind to see it. Thank you very much!"><y>#</y><d>2018-02-19</d><h>19:56</h><w>pepe</w><code>selected?</code> is the navigator I was looking for, but was blind to see it. Thank you very much!</z><z id="t1519213701" t="Nikolay Artamonov Hi all! Is it possible to get removed (via NONE ) element, for example: (sr/setval [:elems (sr/filterer (sr/must :id) (sr/pred= 1)) sr/FIRST] sr/NONE {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]}) =&gt; {:elems [{:id 2, :name &quot;B&quot;}]} I want to get not only whole structure but also removed one: {:id 1 :name &quot;A&quot;} ."><y>#</y><d>2018-02-21</d><h>11:48</h><w>Nikolay Artamonov</w>Hi all! Is it possible to get removed (via <code>NONE</code>) element, for example:

<pre>(sr/setval [:elems
            (sr/filterer (sr/must :id) (sr/pred= 1))
            sr/FIRST] sr/NONE {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]})
=&gt; {:elems [{:id 2, :name &quot;B&quot;}]}
</pre>

I want to get not only whole structure but also removed one: <code>{:id 1 :name &quot;A&quot;}</code>.</z><z id="t1519219572" t="schmee @nartamonov you can use transform instead, like this: user=&gt; (sr/transform #_=&gt; [:elems (sr/filterer (sr/must :id) (sr/pred= 1)) sr/FIRST] #_=&gt; (fn [x] (println x) sr/NONE) #_=&gt; {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]}) {:id 1, :name A} {:elems [{:id 2 :name &quot;B&quot;}]}"><y>#</y><d>2018-02-21</d><h>13:26</h><w>schmee</w>@nartamonov you can use transform instead, like this:
<pre>user=&gt; (sr/transform
  #_=&gt;  [:elems (sr/filterer (sr/must :id) (sr/pred= 1)) sr/FIRST]
  #_=&gt;  (fn [x] (println x) sr/NONE)
  #_=&gt;  {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]})
{:id 1, :name A}
{:elems [{:id 2 :name &quot;B&quot;}]}</pre></z><z id="t1519219612" t="schmee if you return NONE from the transformation function it will remove the element just like setval"><y>#</y><d>2018-02-21</d><h>13:26</h><w>schmee</w>if you return <code>NONE</code> from the transformation function it will remove the element just like setval</z><z id="t1519219730" t="schmee also, replace-in might be of help: https://github.com/nathanmarz/specter/wiki/List-of-Macros#replace-in"><y>#</y><d>2018-02-21</d><h>13:28</h><w>schmee</w>also, <code>replace-in</code> might be of help: <a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#replace-in" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Macros#replace-in</a></z><z id="t1519219881" t="schmee actually, replace-in is perfect: user=&gt; (sr/replace-in #_=&gt; [:elems (sr/filterer (sr/must :id) (sr/pred= 1)) sr/FIRST] #_=&gt; (fn [x] [sr/NONE x]) #_=&gt; {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]}) [{:elems [{:id 2 :name &quot;B&quot;}]} ([:id 1] [:name &quot;A&quot;])] "><y>#</y><d>2018-02-21</d><h>13:31</h><w>schmee</w>actually, <code>replace-in</code> is perfect:
<pre>user=&gt; (sr/replace-in
  #_=&gt;  [:elems (sr/filterer (sr/must :id) (sr/pred= 1)) sr/FIRST]
  #_=&gt;  (fn [x] [sr/NONE x])
  #_=&gt;  {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]})
[{:elems [{:id 2 :name &quot;B&quot;}]} ([:id 1] [:name &quot;A&quot;])]
</pre></z><z id="t1519220163" t="souenzzo @nartamonov path works equally in select and setval , so you can do something like it: (let [data {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]} path [:elems ALL (if-path [:id #{1}] STAY)]] {:data (setval path NONE data) :removed (select path data)}) replace-in is a option too"><y>#</y><d>2018-02-21</d><h>13:36</h><w>souenzzo</w>@nartamonov <code>path</code> works equally in <code>select</code> and <code>setval</code>, so you can do something like it:
<pre>(let [data {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]}
      path [:elems ALL (if-path [:id #{1}] STAY)]]
  {:data    (setval path NONE data)
   :removed (select path data)})
</pre>
<code>replace-in</code> is a option too</z><z id="t1519220896" t="Nikolay Artamonov @schmee Thanks, it works almost as I want. If instead x we use [x] then we&apos;ll get exactly the same structure (hashmap) that was removed: (sr/replace-in [:elems (sr/filterer (sr/must :id) (sr/pred= 1)) sr/FIRST] (fn [x] [sr/NONE [x]]) {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]}) =&gt; [{:elems [{:id 2, :name &quot;B&quot;}]} ({:id 1, :name &quot;A&quot;})] Though, don&apos;t understand why..."><y>#</y><d>2018-02-21</d><h>13:48</h><w>Nikolay Artamonov</w>@schmee Thanks, it works almost as I want. If instead <code>x</code> we use <code>[x]</code> then we&apos;ll get exactly the same structure (hashmap) that was removed:

<pre>(sr/replace-in
    [:elems (sr/filterer (sr/must :id) (sr/pred= 1)) sr/FIRST]
    (fn [x] [sr/NONE [x]])
    {:elems [{:id 1 :name &quot;A&quot;} {:id 2 :name &quot;B&quot;}]})
=&gt; [{:elems [{:id 2, :name &quot;B&quot;}]} ({:id 1, :name &quot;A&quot;})]
</pre>

Though, don&apos;t understand why...</z><z id="t1519220974" t="schmee ahh, sorry, I missed that the hash map changed into a seq, good that you found the solution"><y>#</y><d>2018-02-21</d><h>13:49</h><w>schmee</w>ahh, sorry, I missed that the hash map changed into a seq, good that you found the solution</z><z id="t1519221065" t="schmee the reason is that the second element in the vector gets added to a sequence of return values, so if you have just a hash map it will be changed into a seq first, ie: user=&gt; (seq {:id 1, :name &quot;A&quot;}) ([:id 1] [:name &quot;A&quot;]) "><y>#</y><d>2018-02-21</d><h>13:51</h><w>schmee</w>the reason is that the second element in the vector gets added to a sequence of return values, so if you have just a hash map it will be changed into a seq first, ie:
<pre>user=&gt; (seq {:id 1, :name &quot;A&quot;})
([:id 1] [:name &quot;A&quot;])
</pre></z><z id="t1519221083" t="schmee vs user=&gt; (seq [{:id 1, :name &quot;A&quot;}]) ({:id 1 :name &quot;A&quot;}) "><y>#</y><d>2018-02-21</d><h>13:51</h><w>schmee</w>vs
<pre>user=&gt; (seq [{:id 1, :name &quot;A&quot;}])
({:id 1 :name &quot;A&quot;})
</pre></z><z id="t1519221242" t="Nikolay Artamonov Now I see, thank you! 🙂"><y>#</y><d>2018-02-21</d><h>13:54</h><w>Nikolay Artamonov</w>Now I see, thank you! <b>🙂</b></z><z id="t1519242670" t="johanatan hi, is it possible to specter/transform a k/v pair in a map to another map and then have that merged with the original siblings?"><y>#</y><d>2018-02-21</d><h>19:51</h><w>johanatan</w>hi, is it possible to <code>specter/transform</code> a k/v pair in a map to another map and then have that merged with the original siblings?</z><z id="t1519242789" t="nathanmarz @johanatan you can use the submap navigator for that"><y>#</y><d>2018-02-21</d><h>19:53</h><w>nathanmarz</w>@johanatan you can use the <code>submap</code> navigator for that</z><z id="t1519242800" t="johanatan ah, ok. thx"><y>#</y><d>2018-02-21</d><h>19:53</h><w>johanatan</w>ah, ok. thx</z><z id="t1519253056" t="spieden was just reaching for clojure.walk and learned recursive-path and cond-path instead — wasn’t disappointed =)"><y>#</y><d>2018-02-21</d><h>22:44</h><w>spieden</w>was just reaching for <code>clojure.walk</code> and learned <code>recursive-path</code> and <code>cond-path</code> instead — wasn’t disappointed =)</z><z id="t1519262816" t="steveb8n I’m struggling to understand compact . in the example, shouldn’t the :c that has a value be left alone?"><y>#</y><d>2018-02-22</d><h>01:26</h><w>steveb8n</w>I’m struggling to understand <code>compact</code>. in the example, shouldn’t the :c that has a value be left alone?</z><z id="t1519262821" t="steveb8n (setval [ALL :a (compact :c)] NONE [{:a {:b 1 :c 2}} {:a {:b 1 :c nil}}]) =&gt; [{:a {:b 1}} {:a {:b 1}}]"><y>#</y><d>2018-02-22</d><h>01:27</h><w>steveb8n</w><pre>(setval [ALL :a (compact :c)] 
        NONE
        [{:a {:b 1 :c 2}}
         {:a {:b 1 :c nil}}])</pre>

=&gt; 
<pre>[{:a {:b 1}} {:a {:b 1}}]</pre></z><z id="t1519262868" t="steveb8n the docstring says that it only applies when the value is empty. that is exactly what I want but I’m missing how to make that work"><y>#</y><d>2018-02-22</d><h>01:27</h><w>steveb8n</w>the docstring says that it only applies when the value is empty. that is exactly what I want but I’m missing how to make that work</z><z id="t1519265491" t="nathanmarz @steveb8n compact applies to the value being navigated on, in this case the submaps"><y>#</y><d>2018-02-22</d><h>02:11</h><w>nathanmarz</w>@steveb8n <code>compact</code> applies to the value being navigated on, in this case the submaps</z><z id="t1519265529" t="nathanmarz e.g. (setval [ALL :a (compact :c)] NONE [{:a {:c 2}} {:a {:b 1 :c nil}}]) ;; =&gt; [{} {:a {:b 1}}] "><y>#</y><d>2018-02-22</d><h>02:12</h><w>nathanmarz</w>e.g.
<pre>(setval [ALL :a (compact :c)] 
        NONE
        [{:a {:c 2}}
         {:a {:b 1 :c nil}}])
;; =&gt; [{} {:a {:b 1}}]
</pre></z><z id="t1519265755" t="steveb8n That makes sense. Reading that expression it makes sense that it unconditionally removes the value. "><y>#</y><d>2018-02-22</d><h>02:15</h><w>steveb8n</w>That makes sense. Reading that expression it makes  sense that it unconditionally removes the value. </z><z id="t1519265855" t="steveb8n But what if I want to conditionally remove it i.e. when value is nil. Is there an idiomatic way to do that? The docstring suggests that behaviour, hence my confusion."><y>#</y><d>2018-02-22</d><h>02:17</h><w>steveb8n</w>But what if I want to conditionally remove it i.e. when value is nil. Is there an idiomatic way to do that? The docstring suggests that behaviour, hence my confusion.</z><z id="t1519266035" t="steveb8n I can write a transform fn or conditional navigation but wonder if you would use compact or some other elegance for that as well?"><y>#</y><d>2018-02-22</d><h>02:20</h><w>steveb8n</w>I can write a transform fn or conditional navigation but wonder if you would use compact or some other elegance for that as well?</z><z id="t1519266092" t="steveb8n And thanks 🙂 "><y>#</y><d>2018-02-22</d><h>02:21</h><w>steveb8n</w>And thanks <b>🙂</b> </z><z id="t1519266741" t="nathanmarz @steveb8n it&apos;s just (setval [ALL :a :c nil?] NONE data)"><y>#</y><d>2018-02-22</d><h>02:32</h><w>nathanmarz</w>@steveb8n it&apos;s just <code>(setval [ALL :a :c nil?] NONE data)</code></z><z id="t1519267112" t="steveb8n Ok. That works. Thanks again"><y>#</y><d>2018-02-22</d><h>02:38</h><w>steveb8n</w>Ok. That works. Thanks again</z><z id="t1519321940" t="sashton i’m just trying out specter. what’s the best way to select-keys at various levels of a tree: ;; input {:a {:aa 1 :ab 2 :ac 3} :b {:ba 10 :ba 11} :c {:ca 100}} ;; desired output {:a {:aa 1 :ab 2} :c {:ca 100}} "><y>#</y><d>2018-02-22</d><h>17:52</h><w>sashton</w>i’m just trying out specter.
what’s the best way to select-keys at various levels of a tree:
<pre>;; input
{:a {:aa 1 :ab 2 :ac 3}
 :b {:ba 10 :ba 11}
 :c {:ca 100}}

;; desired output
{:a {:aa 1 :ab 2}
 :c {:ca 100}}
</pre></z><z id="t1519322145" t="nathanmarz @sashton to maintain the structure of the input, select what to remove rather than what to keep: (setval (multi-path :b [:a :ac]) NONE data) "><y>#</y><d>2018-02-22</d><h>17:55</h><w>nathanmarz</w>@sashton to maintain the structure of the input, select what to remove rather than what to keep:
<pre>(setval (multi-path :b [:a :ac]) NONE data)
</pre></z><z id="t1519322311" t="sashton thanks @nathanmarz. is remove the only option? the data i’m looking at has lots of extra fields which i’m not interested in. while i could list all the fields to delete, it might get tedious."><y>#</y><d>2018-02-22</d><h>17:58</h><w>sashton</w>thanks @nathanmarz. is remove the only option? the data i’m looking at has lots of extra fields which i’m not interested in. while i could list all the fields to delete, it might get tedious.</z><z id="t1519322338" t="nathanmarz there&apos;s also the submap navigator which for selects is equivalent to select-keys"><y>#</y><d>2018-02-22</d><h>17:58</h><w>nathanmarz</w>there&apos;s also the <code>submap</code> navigator which for selects is equivalent to <code>select-keys</code></z><z id="t1519322521" t="nathanmarz though it currently changes sorted maps to unsorted maps if used in a select https://github.com/nathanmarz/specter/issues/235"><y>#</y><d>2018-02-22</d><h>18:02</h><w>nathanmarz</w>though it currently changes sorted maps to unsorted maps if used in a <code>select</code> <a href="https://github.com/nathanmarz/specter/issues/235" target="_blank">https://github.com/nathanmarz/specter/issues/235</a></z><z id="t1519322802" t="nathanmarz this is how you could go about doing it with submap : (defdynamicnav viewed [path viewnav] (transformed path (fn [s] (select-any viewnav s))) ) (select-any [(viewed :a (submap [:aa :ab])) (submap [:a :c])] data) "><y>#</y><d>2018-02-22</d><h>18:06</h><w>nathanmarz</w>this is how you could go about doing it with <code>submap</code>:
<pre>(defdynamicnav viewed [path viewnav]
  (transformed path (fn [s] (select-any viewnav s)))
  )

(select-any [(viewed :a (submap [:aa :ab])) (submap [:a :c])] data)
</pre></z><z id="t1519330025" t="sashton thanks again. that works"><y>#</y><d>2018-02-22</d><h>20:07</h><w>sashton</w>thanks again. that works</z><z id="t1519455966" t="kurt-o-sys I have a nested structure, combining vectors and maps like this: [{:__type &quot;some_type&quot; :mykey 1 :date #inst&quot;...&quot; :subs [{__type &quot;another_type&quot; :typekey &quot;value&quot;} {__type &quot;another_type&quot;}] :onesub {:__type &quot;random_type&quot; :subkey 2}]} What I would like to do is tranform some keys of all maps of a certain type (the transformation is always the same). So, for example, what I would like to do something like (with the previous map as m ): (resolve-values {&quot;some_type&quot; [:date :name] &quot;random_type&quot; [:another_key]} m) which would transform all :date and :name values of maps which have a :__type &quot;some_type&quot; entry and all :another_key values of maps which have a :__type &quot;random_type entry"><y>#</y><d>2018-02-24</d><h>07:06</h><w>kurt-o-sys</w>I have a nested structure, combining vectors and maps like this:
<pre>[{:__type &quot;some_type&quot;
  :mykey 1
  :date    #inst&quot;...&quot;
  :subs [{__type &quot;another_type&quot;
          :typekey &quot;value&quot;}
         {__type &quot;another_type&quot;}]
  :onesub {:__type &quot;random_type&quot;
           :subkey 2}]}
</pre>
What I would like to do is tranform some keys of all maps of a certain type (the transformation is always the same). So, for example, what I would like to do something like (with the previous map as <code>m</code>):
<code>(resolve-values {&quot;some_type&quot; [:date :name] &quot;random_type&quot; [:another_key]} m)</code>
which would transform all <code>:date</code> and <code>:name</code> values of maps which have a <code>:__type &quot;some_type&quot;</code> entry and all <code>:another_key</code> values of maps which have a <code>:__type &quot;random_type</code> entry</z><z id="t1519456004" t="kurt-o-sys how would I do that using specter (I guess specter is the best way to do it 🙂 )"><y>#</y><d>2018-02-24</d><h>07:06</h><w>kurt-o-sys</w>how would I do that using <code>specter</code> (I guess specter is the best way to do it <b>🙂</b> )</z><z id="t1519456069" t="kurt-o-sys it has to be some recursive path, but I can&apos;t really figure out how it would look like, so: (specter/transform [....?] resolve m)"><y>#</y><d>2018-02-24</d><h>07:07</h><w>kurt-o-sys</w>it has to be some recursive path, but I can&apos;t really figure out how it would look like, so:
<code>(specter/transform [....?] resolve m)</code></z><z id="t1519456102" t="kurt-o-sys with resolve the function to apply to the values that have to be transformed, but what is ...? ?"><y>#</y><d>2018-02-24</d><h>07:08</h><w>kurt-o-sys</w>with <code>resolve</code> the function to apply to the values that have to be transformed, but what is <code>...?</code>?</z><z id="t1519479995" t="kurt-o-sys so, this is what I came up with so far for one type: (defn type-map-path [__type] (specter/recursive-path [] p [(specter/walker #(= (:__type %) __type)) (specter/stay-then-continue [specter/ALL p])])) (def SOME-TYPE-MAP-PATH (type-map-path &quot;some_type&quot;)) (def SOME-TYPE-KEYS-PATH (specter/multi-path :date :name)) "><y>#</y><d>2018-02-24</d><h>13:46</h><w>kurt-o-sys</w>so, this is what I came up with so far for one type:
<pre>(defn type-map-path [__type]
	(specter/recursive-path [] p
                        [(specter/walker #(= (:__type %) __type))
                         (specter/stay-then-continue [specter/ALL p])]))

(def SOME-TYPE-MAP-PATH (type-map-path &quot;some_type&quot;))
(def SOME-TYPE-KEYS-PATH (specter/multi-path :date :name))
</pre></z><z id="t1519480058" t="kurt-o-sys Just wondering looping and walking several times would bring much benefit over trying to make multi-path work for different __type s"><y>#</y><d>2018-02-24</d><h>13:47</h><w>kurt-o-sys</w>Just wondering looping and walking several times would bring much benefit over trying to make <code>multi-path</code> work for different <code>__type</code>s</z><z id="t1519483166" t="nathanmarz @kurt-o-sys this is a better way to do it: (def MAPS (recursive-path [] p (cond-path map? (continue-then-stay MAP-VALS p) coll? [ALL p]) )) (transform [MAPS #(= (:__type %) &quot;another_type&quot;)] resolve data) "><y>#</y><d>2018-02-24</d><h>14:39</h><w>nathanmarz</w>@kurt-o-sys this is a better way to do it:
<pre>(def MAPS
  (recursive-path [] p
    (cond-path
      map? (continue-then-stay MAP-VALS p)
      coll? [ALL p])
    ))

(transform [MAPS #(= (:__type %) &quot;another_type&quot;)] resolve data)
</pre></z><z id="t1519483201" t="nathanmarz walker is very wasteful in this case, since it traverses into map keys and key/value pairs"><y>#</y><d>2018-02-24</d><h>14:40</h><w>nathanmarz</w><code>walker</code> is very wasteful in this case, since it traverses into map keys and key/value pairs</z><z id="t1519483219" t="nathanmarz this is a much more efficient way to navigate your data structure that leverages the structure of your data"><y>#</y><d>2018-02-24</d><h>14:40</h><w>nathanmarz</w>this is a much more efficient way to navigate your data structure that leverages the structure of your data</z><z id="t1519483766" t="kurt-o-sys oh, nice, thx!"><y>#</y><d>2018-02-24</d><h>14:49</h><w>kurt-o-sys</w>oh, nice, thx!</z><z id="t1519487048" t="kurt-o-sys I&apos;m starting to really fall in love with specter 😛"><y>#</y><d>2018-02-24</d><h>15:44</h><w>kurt-o-sys</w>I&apos;m starting to really fall in love with specter <b>😛</b></z><z id="t1519507501" t="yogidevbear Hi everyone. I&apos;m trying to add Specter to a lein clojure project. I&apos;ve added [com.rpl/specter &quot;1.1.0&quot;] to my dependencies and (:require [com.rpl.specter]) to my ns. I&apos;m getting the following error in my ns thought: FileNotFoundException Could not locate com/rpl/specter__init.class or com/rpl/specter.clj on classpath. clojure.lang.RT.load (RT.java:463) ."><y>#</y><d>2018-02-24</d><h>21:25</h><w>yogidevbear</w>Hi everyone. I&apos;m trying to add Specter to a lein clojure project. I&apos;ve added <code>[com.rpl/specter &quot;1.1.0&quot;]</code> to my dependencies and <code>(:require [com.rpl.specter])</code> to my ns. I&apos;m getting the following error in my ns thought: <code>FileNotFoundException Could not locate com/rpl/specter__init.class or com/rpl/specter.clj on classpath.  clojure.lang.RT.load (RT.java:463)</code>.</z><z id="t1519507767" t="schmee @yogidevbear are you in a REPL?"><y>#</y><d>2018-02-24</d><h>21:29</h><w>schmee</w>@yogidevbear are you in a REPL?</z><z id="t1519508355" t="yogidevbear I&apos;m working from within ProtoREPL doing inline evaluation inside atom io"><y>#</y><d>2018-02-24</d><h>21:39</h><w>yogidevbear</w>I&apos;m working from within ProtoREPL doing inline evaluation inside atom io</z><z id="t1519508993" t="schmee okay, I don’t know how that works unfortunately"><y>#</y><d>2018-02-24</d><h>21:49</h><w>schmee</w>okay, I don’t know how that works unfortunately</z><z id="t1519509003" t="schmee try running lein deps inside your project and see if that helps"><y>#</y><d>2018-02-24</d><h>21:50</h><w>schmee</w>try running <code>lein deps</code> inside your project and see if that helps</z><z id="t1519509079" t="yogidevbear No luck"><y>#</y><d>2018-02-24</d><h>21:51</h><w>yogidevbear</w>No luck</z><z id="t1519509079" t="nathanmarz @yogidevbear you&apos;re best off asking in #clojurescript"><y>#</y><d>2018-02-24</d><h>21:51</h><w>nathanmarz</w>@yogidevbear you&apos;re best off asking in #clojurescript</z><z id="t1519509098" t="yogidevbear Hmmm, but I&apos;m not using ClojureScript"><y>#</y><d>2018-02-24</d><h>21:51</h><w>yogidevbear</w>Hmmm, but I&apos;m not using ClojureScript</z><z id="t1519509126" t="nathanmarz oh sorry, misunderstood"><y>#</y><d>2018-02-24</d><h>21:52</h><w>nathanmarz</w>oh sorry, misunderstood</z><z id="t1519509143" t="nathanmarz does it work from lein repl ?"><y>#</y><d>2018-02-24</d><h>21:52</h><w>nathanmarz</w>does it work from <code>lein repl</code>?</z><z id="t1519509322" t="yogidevbear Yup, seems to work if I do (use &apos;com.rpl.specter) from within lein repl"><y>#</y><d>2018-02-24</d><h>21:55</h><w>yogidevbear</w>Yup, seems to work if I do <code>(use &apos;com.rpl.specter)</code> from within <code>lein repl</code></z><z id="t1519509339" t="nathanmarz have you tried restarting protorepl?"><y>#</y><d>2018-02-24</d><h>21:55</h><w>nathanmarz</w>have you tried restarting protorepl?</z><z id="t1519509384" t="yogidevbear I&apos;ll give that a try"><y>#</y><d>2018-02-24</d><h>21:56</h><w>yogidevbear</w>I&apos;ll give that a try</z><z id="t1519509399" t="yogidevbear would it be worth clearing out my .m2 folder too?"><y>#</y><d>2018-02-24</d><h>21:56</h><w>yogidevbear</w>would it be worth clearing out my <code>.m2</code> folder too?</z><z id="t1519509468" t="nathanmarz doubtful given that it&apos;s working with a regular repl"><y>#</y><d>2018-02-24</d><h>21:57</h><w>nathanmarz</w>doubtful given that it&apos;s working with a regular repl</z><z id="t1519509605" t="yogidevbear Fair point 🙂"><y>#</y><d>2018-02-24</d><h>22:00</h><w>yogidevbear</w>Fair point <b>🙂</b></z><z id="t1520006534" t="frenata If I want to select some substructure out of a nested map, rather than just the leaves, what&apos;s the best way to do that with specter? IE, I have {:foo 1 :bar {:baz 2 :bat 3}} , and I want to select out {:bar {:baz 2}} . New to the library and just poking around. Thought subselect or filterer might work, but at least the way I&apos;m using them they aren&apos;t quite right."><y>#</y><d>2018-03-02</d><h>16:02</h><w>frenata</w>If I want to select some substructure out of a nested map, rather than just the leaves, what&apos;s the best way to do that with specter?
IE, I have <code>{:foo 1 :bar {:baz 2 :bat 3}}</code>, and I want to select out <code>{:bar {:baz 2}}</code>.

New to the library and just poking around. Thought <code>subselect</code> or <code>filterer</code> might work, but at least the way I&apos;m using them they aren&apos;t quite right.</z><z id="t1520007537" t="nathanmarz @andrew354 it depends on the use case, but generally the most straightforward approach is to remove what you don&apos;t want"><y>#</y><d>2018-03-02</d><h>16:18</h><w>nathanmarz</w>@andrew354 it depends on the use case, but generally the most straightforward approach is to remove what you don&apos;t want</z><z id="t1520007541" t="nathanmarz (setval (multi-path :foo [:bar :bat]) NONE data) "><y>#</y><d>2018-03-02</d><h>16:19</h><w>nathanmarz</w><pre>(setval (multi-path :foo [:bar :bat]) NONE data)
</pre></z><z id="t1520007641" t="frenata Ah, so naming the paths of things you want to get rid of."><y>#</y><d>2018-03-02</d><h>16:20</h><w>frenata</w>Ah, so naming the paths of things you want to get rid of.</z><z id="t1520007662" t="frenata Unfortunately I think in my actual use-case, I want to keep a fairly small part of the structure, but I&apos;ll see if this approach will work."><y>#</y><d>2018-03-02</d><h>16:21</h><w>frenata</w>Unfortunately I think in my actual use-case, I want to keep a fairly small part of the structure, but I&apos;ll see if this approach will work.</z><z id="t1520007843" t="nathanmarz @andrew354 another approach that explicitly selects the keys you want:"><y>#</y><d>2018-03-02</d><h>16:24</h><w>nathanmarz</w>@andrew354 another approach that explicitly selects the keys you want:</z><z id="t1520007850" t="nathanmarz (defdynamicnav viewed [path viewnav] (transformed path #(select-any viewnav %))) (select-any [(submap [:bar]) (viewed :bar (submap [:baz]))] data) "><y>#</y><d>2018-03-02</d><h>16:24</h><w>nathanmarz</w><pre>(defdynamicnav viewed [path viewnav]
  (transformed path #(select-any viewnav %)))

(select-any [(submap [:bar]) (viewed :bar (submap [:baz]))] data)
</pre></z><z id="t1520007928" t="frenata Interesting. I may try both approaches and see what is most clear."><y>#</y><d>2018-03-02</d><h>16:25</h><w>frenata</w>Interesting. I may try both approaches and see what is most clear.</z><z id="t1520007939" t="nathanmarz could make a helper that takes in a list of keyword paths and produces the navigation"><y>#</y><d>2018-03-02</d><h>16:25</h><w>nathanmarz</w>could make a helper that takes in a list of keyword paths and produces the navigation</z><z id="t1520007960" t="nathanmarz e.g. (select-any (keep-keyword-paths [:bar :baz]) data)"><y>#</y><d>2018-03-02</d><h>16:26</h><w>nathanmarz</w>e.g. <code>(select-any (keep-keyword-paths [:bar :baz]) data)</code></z><z id="t1520008139" t="schmee I think that viewed with a bit of polish could go into specter core 🙂"><y>#</y><d>2018-03-02</d><h>16:28</h><w>schmee</w>I think that <code>viewed</code> with a bit of polish could go into specter core <b>🙂</b></z><z id="t1520035708" t="frenata btw, thanks @nathanmarz, the second approach worked out really nicely."><y>#</y><d>2018-03-03</d><h>00:08</h><w>frenata</w>btw, thanks @nathanmarz, the second approach worked out really nicely.</z><z id="t1520431025" t="hkjels Can I use specter to create a matrix from a tree? Meaning that the first column will be populated with duplicates for all childrens children and so on"><y>#</y><d>2018-03-07</d><h>13:57</h><w>hkjels</w>Can I use specter to create a matrix from a tree? Meaning that the first column will be populated with duplicates for all childrens children and so on</z><z id="t1520432044" t="nathanmarz @hkjels it would likely be helpful for traversing the tree in the order you want"><y>#</y><d>2018-03-07</d><h>14:14</h><w>nathanmarz</w>@hkjels it would likely be helpful for traversing the tree in the order you want</z><z id="t1520432085" t="nathanmarz the code would look something like (reduce build-my-matrix empty-matrix (traverse &lt;path&gt; my-tree))"><y>#</y><d>2018-03-07</d><h>14:14</h><w>nathanmarz</w>the code would look something like <code>(reduce build-my-matrix empty-matrix (traverse &lt;path&gt; my-tree))</code></z><z id="t1520432798" t="hkjels Nice, I’ll give it a go"><y>#</y><d>2018-03-07</d><h>14:26</h><w>hkjels</w>Nice, I’ll give it a go</z></g><g id="s19"><z id="t1520608721" t="razum2um is there a way to express this better? =&gt; (transform [(if-path [#(contains? % :loc)] [:loc ALL])] inc {:x 1}) {:x 1} =&gt; (transform [(if-path [#(contains? % :loc)] [:loc ALL])] inc {:loc [1]}) {:loc [2]} don’t want extra key after simple =&gt; (transform [:loc ALL] inc {:x 1}) {:x 1, :loc nil} "><y>#</y><d>2018-03-09</d><h>15:18</h><w>razum2um</w>is there a way to express this better?
<pre>=&gt; (transform [(if-path [#(contains? % :loc)] [:loc ALL])] inc {:x 1})
{:x 1}
=&gt; (transform [(if-path [#(contains? % :loc)] [:loc ALL])] inc {:loc [1]})
{:loc [2]}
</pre>
don’t want extra key after simple
<pre>=&gt; (transform [:loc ALL] inc {:x 1})
{:x 1, :loc nil}
</pre></z><z id="t1520609231" t="nathanmarz @razum2um (transform [(must :loc) ALL] inc data) "><y>#</y><d>2018-03-09</d><h>15:27</h><w>nathanmarz</w>@razum2um 
<pre>(transform [(must :loc) ALL] inc data)
</pre></z><z id="t1520609779" t="razum2um thanks!"><y>#</y><d>2018-03-09</d><h>15:36</h><r>razum2um</r>thanks!</z><z id="t1520609909" t="razum2um @nathanmarz btw, I had an idea about the vector as a forth program, did you think about this?"><y>#</y><d>2018-03-09</d><h>15:38</h><w>razum2um</w>@nathanmarz btw, I had an idea about the vector as a forth program, did you think about this?</z><z id="t1520611095" t="nathanmarz @razum2um no, what do you mean?"><y>#</y><d>2018-03-09</d><h>15:58</h><w>nathanmarz</w>@razum2um no, what do you mean?</z><z id="t1520611275" t="razum2um currently the library api interface looks convenient but adhoc, I feel there shoud be case out there which cannot fit into vector. I thought we could imagine the traversal as “bytecodes” steps to the lib (interpretator)"><y>#</y><d>2018-03-09</d><h>16:01</h><w>razum2um</w>currently the library api interface looks convenient but adhoc, I feel there shoud be case out there which cannot fit into vector. I thought we could imagine the traversal as “bytecodes” steps to the lib (interpretator)</z><z id="t1520611383" t="razum2um I understand implementing VM for data traversal is not easy 😅 but just wanted to share this"><y>#</y><d>2018-03-09</d><h>16:03</h><w>razum2um</w>I understand implementing VM for data traversal is not easy <b>😅</b>  but just wanted to share this</z><z id="t1520611423" t="razum2um just on the spot: e.g. in this way we could even allow some recursion steps in traversal"><y>#</y><d>2018-03-09</d><h>16:03</h><w>razum2um</w>just on the spot: e.g. in this way we could even allow some recursion steps in traversal</z><z id="t1520611613" t="razum2um example2: my request above in this approach could look like (transform [:loc &gt;nil? &lt;STOP ALL] inc {:x 1}) where &gt;nil? puts on stack if loc return value is nit &lt;STOP pops and shortcuts path if last val was true"><y>#</y><d>2018-03-09</d><h>16:06</h><w>razum2um</w>example2: my request above in this approach could look like <code>(transform [:loc &gt;nil? &lt;STOP ALL] inc {:x 1})</code> where <code>&gt;nil?</code> puts on stack if <code>loc</code> return value is nit <code>&lt;STOP</code> pops and shortcuts path if last val was true</z><z id="t1520611667" t="nathanmarz that would increase the complexity of specter by 1000x"><y>#</y><d>2018-03-09</d><h>16:07</h><w>nathanmarz</w>that would increase the complexity of specter by 1000x</z><z id="t1520611679" t="razum2um yeah 🙂"><y>#</y><d>2018-03-09</d><h>16:07</h><w>razum2um</w>yeah <b>🙂</b></z><z id="t1520611690" t="nathanmarz specter is not a language, it&apos;s just an interface and an efficient method for composing them"><y>#</y><d>2018-03-09</d><h>16:08</h><w>nathanmarz</w>specter is not a language, it&apos;s just an interface and an efficient method for composing them</z><z id="t1520611723" t="nathanmarz there&apos;s no known use cases it doesn&apos;t handle, so there&apos;s no reason to do something like that"><y>#</y><d>2018-03-09</d><h>16:08</h><w>nathanmarz</w>there&apos;s no known use cases it doesn&apos;t handle, so there&apos;s no reason to do something like that</z><z id="t1520611725" t="razum2um don’t push you, just wanted to hear your thoughts"><y>#</y><d>2018-03-09</d><h>16:08</h><w>razum2um</w>don’t push you, just wanted to hear your thoughts</z><z id="t1520611750" t="razum2um thanks for your efforts btw :+1:"><y>#</y><d>2018-03-09</d><h>16:09</h><w>razum2um</w>thanks for your efforts btw <b>:+1:</b></z><z id="t1520611789" t="razum2um is it ok if I’ll PR to the readme.md with must example?"><y>#</y><d>2018-03-09</d><h>16:09</h><w>razum2um</w>is it ok if I’ll PR to the readme.md with <code>must</code> example?</z><z id="t1520611831" t="nathanmarz sure thing"><y>#</y><d>2018-03-09</d><h>16:10</h><w>nathanmarz</w>sure thing</z><z id="t1520611876" t="nathanmarz not sure what to do with the readme, it&apos;s kind of just a random exploration of different kinds of manipulations"><y>#</y><d>2018-03-09</d><h>16:11</h><w>nathanmarz</w>not sure what to do with the readme, it&apos;s kind of just a random exploration of different kinds of manipulations</z><z id="t1520611942" t="nathanmarz I don&apos;t think making that section longer than it already is will improve things"><y>#</y><d>2018-03-09</d><h>16:12</h><w>nathanmarz</w>I don&apos;t think making that section longer than it already is will improve things</z><z id="t1520611951" t="nathanmarz the wiki is pretty good nowadays"><y>#</y><d>2018-03-09</d><h>16:12</h><w>nathanmarz</w>the wiki is pretty good nowadays</z><z id="t1520611956" t="nathanmarz so I just point people there"><y>#</y><d>2018-03-09</d><h>16:12</h><w>nathanmarz</w>so I just point people there</z><z id="t1520611989" t="nathanmarz and to answer your question about recursion, see https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively"><y>#</y><d>2018-03-09</d><h>16:13</h><w>nathanmarz</w>and to answer your question about recursion, see <a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively" target="_blank">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively</a></z><z id="t1520612663" t="razum2um hm, yes, I think now it’s quite too special example for readme.. but here is the point (from wiki) &gt; Note that must stops navigation I think there should be a list with such “stopping” things, wdyt?"><y>#</y><d>2018-03-09</d><h>16:24</h><w>razum2um</w>hm, yes, I think now it’s quite too special example for readme..
but here is the point (from wiki)
&gt; Note that must stops navigation
I think there should be a list with such “stopping” things, wdyt?</z><z id="t1520612895" t="razum2um still, here you are https://github.com/nathanmarz/specter/pull/249"><y>#</y><d>2018-03-09</d><h>16:28</h><w>razum2um</w>still, here you are <a href="https://github.com/nathanmarz/specter/pull/249" target="_blank">https://github.com/nathanmarz/specter/pull/249</a></z><z id="t1520613110" t="razum2um I think we have ~300 people here and readme should represent most common used cases. e.g. in same format as in clojuredocs (crowd-examples, maybe on same engine, afair it’s oss)"><y>#</y><d>2018-03-09</d><h>16:31</h><w>razum2um</w>I think we have ~300 people here and readme should represent most common used cases. e.g. in same format as in clojuredocs (crowd-examples, maybe on same engine, afair it’s oss)</z><z id="t1520613899" t="nathanmarz @razum2um this is the categorization I use when thinking of navigators: https://github.com/nathanmarz/specter/wiki/Cheat-Sheet"><y>#</y><d>2018-03-09</d><h>16:44</h><w>nathanmarz</w>@razum2um this is the categorization I use when thinking of navigators: <a href="https://github.com/nathanmarz/specter/wiki/Cheat-Sheet" target="_blank">https://github.com/nathanmarz/specter/wiki/Cheat-Sheet</a></z><z id="t1520613965" t="razum2um yeah, saw it. is there any other stopping word like must ?"><y>#</y><d>2018-03-09</d><h>16:46</h><w>razum2um</w>yeah, saw it. is there any other stopping word like <code>must</code>?</z><z id="t1520614008" t="nathanmarz ALL , MAP-KEYS , MAP-VALS will stop if there&apos;s nothing in the collection"><y>#</y><d>2018-03-09</d><h>16:46</h><w>nathanmarz</w><code>ALL</code>, <code>MAP-KEYS</code>, <code>MAP-VALS</code> will stop if there&apos;s nothing in the collection</z><z id="t1520614011" t="nathanmarz STOP explicitly stops"><y>#</y><d>2018-03-09</d><h>16:46</h><w>nathanmarz</w><code>STOP</code> explicitly stops</z><z id="t1520614019" t="nathanmarz terminal navigators explicitly stop"><y>#</y><d>2018-03-09</d><h>16:46</h><w>nathanmarz</w><code>terminal</code> navigators explicitly stop</z><z id="t1520614047" t="nathanmarz set-elem and map-key stop if the elem/key isn&apos;t there"><y>#</y><d>2018-03-09</d><h>16:47</h><w>nathanmarz</w><code>set-elem</code> and <code>map-key</code> stop if the elem/key isn&apos;t there</z><z id="t1520614052" t="razum2um ok, thanks :+1:"><y>#</y><d>2018-03-09</d><h>16:47</h><w>razum2um</w>ok, thanks <b>:+1:</b></z><z id="t1520614071" t="nathanmarz FIRST /`LAST` stop if the sequence is empty"><y>#</y><d>2018-03-09</d><h>16:47</h><w>nathanmarz</w><code>FIRST</code>/`LAST` stop if the sequence is empty</z><z id="t1520871599" t="mbjarland How would I go about selecting a specific node in a vector of vectors structure like the following: [:html {} [:body {} [:table {} [:tr {} [:th {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} &quot;Task Name&quot;] [:th {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} &quot;Description&quot;]] [:tr {} [:td {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} [:a {:shape &quot;rect&quot;, :href &quot;Tasks/unpack.html&quot;} &quot;GUnzip/BUnzip2/UnXZ&quot;]] [:td {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} [:p {} &quot;Expands a file packed using GZip, BZip2 or XZ.&quot;]]] i.e. I would like to check the :href value on the second to last row and if it matches a predicate, return the string on the last row. Mainly I&apos;m confused in general about how to write paths against vectors with some kind of predicate logic for which paths to traverse and which to not"><y>#</y><d>2018-03-12</d><h>16:19</h><w>mbjarland</w>How would I go about selecting a specific node in a vector of vectors structure like the following: 
<pre>[:html
 {}
 [:body
  {}
  [:table
   {}
   [:tr {} [:th {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} &quot;Task Name&quot;] [:th {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} &quot;Description&quot;]]
   [:tr
    {}
    [:td {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} [:a {:shape &quot;rect&quot;, :href &quot;Tasks/unpack.html&quot;} &quot;GUnzip/BUnzip2/UnXZ&quot;]]
    [:td {:colspan &quot;1&quot;, :rowspan &quot;1&quot;} [:p {} &quot;Expands a file packed using GZip, BZip2 or XZ.&quot;]]]
</pre>
i.e. I would like to check the <code>:href</code> value on the second to last row and if it matches a predicate, return the string on the last row. Mainly I&apos;m confused in general about how to write paths against vectors with some kind of predicate logic for which paths to traverse and which to not</z><z id="t1520871645" t="mbjarland don&apos;t need a complete answer, just need to understand which navigator to use in a case like this"><y>#</y><d>2018-03-12</d><h>16:20</h><w>mbjarland</w>don&apos;t need a complete answer, just need to understand which navigator to use in a case like this</z><z id="t1520871786" t="mbjarland somehow traverse to the first elems of vectors in the structure and if they match (in order) :html , :body , :table :tr then check a predicate against the first :td and collect string from the second :td if predicate matches"><y>#</y><d>2018-03-12</d><h>16:23</h><w>mbjarland</w>somehow traverse to the first elems of vectors in the structure and if they match (in order) <code>:html</code>, <code>:body</code>, <code>:table</code> <code>:tr</code> then check a predicate against the first <code>:td</code> and collect string from the second <code>:td</code> if predicate matches</z><z id="t1520872234" t="mbjarland ok figured out a solution, a tad ugly but it works: (defn tag? [name] (fn [vec] (and (vector? vec) (= (first vec) name)))) and (spctr/select [spctr/ALL (tag? :body) spctr/ALL (tag? :table) spctr/ALL (tag? :tr) ... etc] data) "><y>#</y><d>2018-03-12</d><h>16:30</h><w>mbjarland</w>ok figured out a solution, a tad ugly but it works: 
<pre>(defn tag? [name]
  (fn [vec]
    (and (vector? vec) (= (first vec) name))))
</pre>
and 
<pre>(spctr/select 
  [spctr/ALL (tag? :body) spctr/ALL (tag? :table) spctr/ALL (tag? :tr) ... etc]
  data)
</pre></z><z id="t1520874429" t="nathanmarz @mbjarland you can capture more structure with this: (defdynamicnav tags-traversal [&amp; tags] (mapcat (fn [t] [ALL (tag? t)] tags)) ) "><y>#</y><d>2018-03-12</d><h>17:07</h><w>nathanmarz</w>@mbjarland you can capture more structure with this:
<pre>(defdynamicnav tags-traversal [&amp; tags]
  (mapcat (fn [t] [ALL (tag? t)] tags))
  )
</pre></z><z id="t1520874458" t="nathanmarz and then do (select [(tags-traversal :body :table :tr) ...] data)"><y>#</y><d>2018-03-12</d><h>17:07</h><w>nathanmarz</w>and then do <code>(select [(tags-traversal :body :table :tr) ...] data)</code></z><z id="t1520882803" t="mbjarland @nathanmarz : ) for once I wasn&apos;t far off then! Thanks, that is indeed cleaner"><y>#</y><d>2018-03-12</d><h>19:26</h><w>mbjarland</w>@nathanmarz : ) for once I wasn&apos;t far off then! Thanks, that is indeed cleaner</z><z id="t1520885559" t="nathanmarz @mbjarland btw, here&apos;s a better way to implement those: (defn tag? [name] (pred (fn [vec] (and (vector? vec) (= (first vec) name))))) (defdynamicnav tags-traversal [&amp; tags] (let [late-tag? (late-resolved-fn tag?)] (mapcat (fn [t] [ALL (late-tag? t)]) tags) )) "><y>#</y><d>2018-03-12</d><h>20:12</h><w>nathanmarz</w>@mbjarland btw, here&apos;s a better way to implement those:
<pre>(defn tag? [name]
  (pred
    (fn [vec]
      (and (vector? vec) (= (first vec) name)))))

(defdynamicnav tags-traversal [&amp; tags]
  (let [late-tag? (late-resolved-fn tag?)]
    (mapcat (fn [t] [ALL (late-tag? t)]) tags)
    ))
</pre></z><z id="t1520885593" t="nathanmarz adding pred to return of tag? increases performance by avoiding a runtime conversion from function to navigator"><y>#</y><d>2018-03-12</d><h>20:13</h><w>nathanmarz</w>adding <code>pred</code> to return of <code>tag?</code> increases performance by avoiding a runtime conversion from function to navigator</z><z id="t1520885635" t="nathanmarz the late-resolved-fn call in tags-traversal allows that dynamicnav to handle dynamic parameters correctly (e.g. (tags-traversal :html some-local) )"><y>#</y><d>2018-03-12</d><h>20:13</h><w>nathanmarz</w>the <code>late-resolved-fn</code> call in <code>tags-traversal</code> allows that dynamicnav to handle dynamic parameters correctly (e.g. <code>(tags-traversal :html some-local)</code>)</z><z id="t1520885706" t="mbjarland ok well that brings us back to the normal cycle of “no there’s a much better way to do that” : ) many thanks, will noodle on this"><y>#</y><d>2018-03-12</d><h>20:15</h><w>mbjarland</w>ok well that brings us back to the normal cycle of “no there’s a much better way to do that” : ) 
many thanks, will noodle on this</z><z id="t1520887205" t="mbjarland ok last one…how would I select the “rest” of a vector starting at an index…`srange` and srange-dynamic do not seem to do quite this from what I understand"><y>#</y><d>2018-03-12</d><h>20:40</h><w>mbjarland</w>ok last one…how would I select the “rest” of a vector starting at an index…`srange` and <code>srange-dynamic</code> do not seem to do quite this from what I understand</z><z id="t1520888879" t="nathanmarz @mbjarland do you know the index before the select happens?"><y>#</y><d>2018-03-12</d><h>21:07</h><w>nathanmarz</w>@mbjarland do you know the index before the <code>select</code> happens?</z><z id="t1520892334" t="mbjarland yes"><y>#</y><d>2018-03-12</d><h>22:05</h><w>mbjarland</w>yes</z><z id="t1520892339" t="mbjarland index is fixed"><y>#</y><d>2018-03-12</d><h>22:05</h><w>mbjarland</w>index is fixed</z><z id="t1520892354" t="mbjarland essentially it’s (rest (rest coll))"><y>#</y><d>2018-03-12</d><h>22:05</h><w>mbjarland</w>essentially it’s <code>(rest (rest coll))</code></z><z id="t1520894522" t="nathanmarz @mbjarland is this what you need? (defn subrest [i] (srange-dynamic (fn [_] i) (fn [s] (count s)))) (transform (subrest 2) reverse [1 2 3 4 5 6]) ;; =&gt; [1 2 6 5 4 3] "><y>#</y><d>2018-03-12</d><h>22:42</h><w>nathanmarz</w>@mbjarland is this what you need?
<pre>(defn subrest [i]
  (srange-dynamic (fn [_] i) (fn [s] (count s))))

(transform (subrest 2) reverse [1 2 3 4 5 6])
;; =&gt; [1 2 6 5 4 3]
</pre></z><z id="t1520947281" t="mbjarland @nathanmarz well I do believe that is exactly what I need. Thanks again!"><y>#</y><d>2018-03-13</d><h>13:21</h><w>mbjarland</w>@nathanmarz well I do believe that is exactly what I need. Thanks again!</z><z id="t1521203680" t="Marcus Pemer Hi - my first question to this channel, hope you all are doing well. I am processing some CSV input - fairly large file with four types of records in them. All records are grouped with a header line and they are separated with blank (empty) lines. I have come up with the following attempt to use Specter for the transformation: (let [data (-&gt;&gt; ;; my data comes in as text from a csv file (csv/parse-csv (slurp &quot;some-file-name.csv&quot;) ;; group by number of elements and remove group of empty rows (dissoc (group-by count csv) 1) ;; remove trailing empty cells within records (setval [MAP-VALS ALL LAST empty?] NONE) ;; prepare fields that will become map keys (transform [MAP-VALS FIRST ALL] keify) ;; turn the groups into maps (transform [MAP-VALS] sc/mappify) ;; lastly, read our data fields (transform [MAP-VALS ALL ALL] read-field) )] (def a-records (get data 6)) (def b-records (get data 7)) (def c-records (get data 11)) (def d-records (get data 15))) While this works for my immediate needs, I find myself navigating to MAP-VALS over and over again, thinking this can probably be done in a more elegant way. Is there a way in Specter to group the four transformations (setval + 3 transforms) into a sub-select of some sort? Should I even care about this type of optimization?"><y>#</y><d>2018-03-16</d><h>12:34</h><w>Marcus Pemer</w>Hi - my first question to this channel, hope you all are doing well. I am processing some CSV input - fairly large file with four types of records in them. All records are grouped with a header line and they are separated with blank (empty) lines. I have come up with the following attempt to use Specter for the transformation:

<pre>(let [data (-&gt;&gt;
            ;; my data comes in as text from a csv file
            (csv/parse-csv (slurp &quot;some-file-name.csv&quot;)
            ;; group by number of elements and remove group of empty rows
            (dissoc (group-by count csv) 1)
            ;; remove trailing empty cells within records
            (setval [MAP-VALS ALL LAST empty?] NONE)
            ;; prepare fields that will become map keys
            (transform [MAP-VALS FIRST ALL] keify)
            ;; turn the groups into maps
            (transform [MAP-VALS] sc/mappify)
            ;; lastly, read our data fields
            (transform [MAP-VALS ALL ALL] read-field)
            )]
  (def a-records (get data 6))
  (def b-records (get data 7))
  (def c-records (get data 11))
  (def d-records (get data 15)))
</pre>

While this works for my immediate needs, I find myself navigating to MAP-VALS over and over again, thinking this can probably be done in a more elegant way. Is there a way in Specter to group the four transformations (setval + 3 transforms) into a sub-select of some sort? Should I even care about this type of optimization?</z><z id="t1521204298" t="drowsy @marcus165 There is multi-transform with multi-path to group setval and transform together. (multi-transform [MAP-VALS (multi-path [ALL LAST empty? (terminal-val NONE)] [FIRST ALL (terminal keify)] [(terminal sc/mappify)] [ALL ALL (terminal read-file)])])"><y>#</y><d>2018-03-16</d><h>12:44</h><w>drowsy</w>@marcus165 There is multi-transform with multi-path to group setval and transform together. <pre>(multi-transform [MAP-VALS (multi-path [ALL LAST empty? (terminal-val NONE)]
                                       [FIRST ALL (terminal keify)]
                                       [(terminal sc/mappify)]
                                       [ALL ALL (terminal read-file)])])</pre></z><z id="t1521204512" t="Marcus Pemer awesome - thank you @drowsy!"><y>#</y><d>2018-03-16</d><h>12:48</h><w>Marcus Pemer</w>awesome - thank you @drowsy!</z><z id="t1521501687" t="phreed I want to navigate through a data structure having at the top a hash-map. What is the best way to start off a traverse-all into such a structure? (into [] (sr/traverse-all [:foo sr/ALL :bar]) [{:foo [{:bar &quot;one&quot; :baz &quot;two&quot;} {:bar &quot;three&quot; :biz &quot;four&quot;} ] :bing 5}]) Enclosing the object in a vector seems to work. Is that the recommended way to handle this?"><y>#</y><d>2018-03-19</d><h>23:21</h><w>phreed</w>I want to navigate through a data structure having at the top a hash-map. What is the best way to start off a <code>traverse-all</code> into such a structure?
  (into [] (sr/traverse-all [:foo sr/ALL :bar]) [{:foo [{:bar &quot;one&quot; :baz &quot;two&quot;} {:bar &quot;three&quot; :biz &quot;four&quot;} ] :bing 5}])
Enclosing the object in a vector seems to work. Is that the recommended way to handle this?</z><z id="t1521508039" t="nathanmarz @phreed traverse-all is for integrating specter with transducers, which is not what you want in this case"><y>#</y><d>2018-03-20</d><h>01:07</h><w>nathanmarz</w>@phreed <code>traverse-all</code> is for integrating specter with transducers, which is not what you want in this case</z><z id="t1521508058" t="nathanmarz that can just be done with select : (select [:foo ALL :bar] {:foo [{:bar &quot;one&quot; :baz &quot;two&quot;} {:bar &quot;three&quot; :biz &quot;four&quot;} ] :bing 5})"><y>#</y><d>2018-03-20</d><h>01:07</h><w>nathanmarz</w>that can just be done with <code>select</code>: <code>(select [:foo ALL :bar] {:foo [{:bar &quot;one&quot; :baz &quot;two&quot;} {:bar &quot;three&quot; :biz &quot;four&quot;} ] :bing 5})</code></z><z id="t1521508109" t="nathanmarz traverse is useful when you want a non-vector data structure back without materializing any intermediate data structure, e.g.: (into #{} (traverse [:foo ALL :bar] {:foo [{:bar &quot;one&quot; :baz &quot;two&quot;} {:bar &quot;three&quot; :biz &quot;four&quot;} ] :bing 5})) "><y>#</y><d>2018-03-20</d><h>01:08</h><w>nathanmarz</w><code>traverse</code> is useful when you want a non-vector data structure back without materializing any intermediate data structure, e.g.:
<pre>(into #{} (traverse [:foo ALL :bar] {:foo [{:bar &quot;one&quot; :baz &quot;two&quot;} {:bar &quot;three&quot; :biz &quot;four&quot;} ] :bing 5}))
</pre></z><z id="t1521555393" t="phreed Actually I do want to integrate with other transducers, the example I gave is contrived. I guess the issue is what does it mean to take a step with a single record?"><y>#</y><d>2018-03-20</d><h>14:16</h><w>phreed</w>Actually I do want to integrate with other transducers, the example I gave is contrived. I guess the issue is what does it mean to take a step with a single record?</z><z id="t1521556245" t="nathanmarz @phreed transducers operate over collections"><y>#</y><d>2018-03-20</d><h>14:30</h><w>nathanmarz</w>@phreed transducers operate over collections</z><z id="t1521556324" t="nathanmarz if you show a more complete example of your use case would be easier to help"><y>#</y><d>2018-03-20</d><h>14:32</h><w>nathanmarz</w>if you show a more complete example of your use case would be easier to help</z><z id="t1521689916" t="pablore how would i write a deep-merge-right with specter?"><y>#</y><d>2018-03-22</d><h>03:38</h><w>pablore</w>how would i write a deep-merge-right with specter?</z><z id="t1521696156" t="nathanmarz @pablore that&apos;s outside the scope of specter"><y>#</y><d>2018-03-22</d><h>05:22</h><w>nathanmarz</w>@pablore that&apos;s outside the scope of specter</z><z id="t1521738147" t="pablore Thats too bad. I have a very ugly solution and thought maybe with specter I could get a more readable one"><y>#</y><d>2018-03-22</d><h>17:02</h><r>pablore</r>Thats too bad. I have a very ugly solution and thought maybe with specter I could get a more readable one</z><z id="t1521805186" t="Peter Wilkins Hello - noob question. I&apos;m trying to use transform to reverse the values in a map: (transform [ALL :average] reverse [{:average 0.14479934967087002} {:average 0.7736362292522883} {:average 0.6189089834018306} {:average 0.6188565442780262}]) but I get Don&apos;t know how to create ISeq from: java.lang.Double"><y>#</y><d>2018-03-23</d><h>11:39</h><w>Peter Wilkins</w>Hello - noob question. I&apos;m trying to use transform to reverse the values in a map:
<pre>(transform [ALL :average]
   reverse
            [{:average 0.14479934967087002}
             {:average 0.7736362292522883}
             {:average 0.6189089834018306}
             {:average 0.6188565442780262}])</pre>
but I get Don&apos;t know how to create ISeq from: java.lang.Double</z><z id="t1521807826" t="nathanmarz @poppetew that&apos; because you&apos;re navigating to the individual values, so reverse is being applied to each of them"><y>#</y><d>2018-03-23</d><h>12:23</h><w>nathanmarz</w>@poppetew that&apos; because you&apos;re navigating to the individual values, so <code>reverse</code> is being applied to each of them</z><z id="t1521807832" t="nathanmarz the correct way to do that is: (transform (subselect ALL :average) reverse [{:average 0.14479934967087002} {:average 0.7736362292522883} {:average 0.6189089834018306} {:average 0.6188565442780262}]) "><y>#</y><d>2018-03-23</d><h>12:23</h><w>nathanmarz</w>the correct way to do that is:
<pre>(transform (subselect ALL :average)
   reverse
   [{:average 0.14479934967087002}
    {:average 0.7736362292522883}
    {:average 0.6189089834018306}
    {:average 0.6188565442780262}])
</pre></z><z id="t1521807847" t="nathanmarz subselect lets you manipulate an arbitrary selection as a sequence, with changes applied at the original locations"><y>#</y><d>2018-03-23</d><h>12:24</h><w>nathanmarz</w><code>subselect</code> lets you manipulate an arbitrary selection as a sequence, with changes applied at the original locations</z><z id="t1521809068" t="Peter Wilkins magic - thanks"><y>#</y><d>2018-03-23</d><h>12:44</h><w>Peter Wilkins</w>magic - thanks</z><z id="t1522239258" t="axrs Hi all 🙂 Is it possible to transform a collection and update in-place? For a simplified example, say I have a vector of [1 2 3 4 5 ...] . The first iteration happens on index 0 first (`value 1 in this case`) and adds 10 to the value to give 11 and updates the collection [11 2 3 4 5...] . The second iteration happens on index 1 (value 2 ), but uses an updated collection, i.e. [11 2 3 4 5 ...] ."><y>#</y><d>2018-03-28</d><h>12:14</h><w>axrs</w>Hi all <b>🙂</b> 
Is it possible to transform a collection and update in-place? For a simplified example, say I have a vector of <code>[1 2 3 4 5 ...]</code>. 
The first iteration happens on index 0 first (`value 1 in this case`)  and adds 10 to the value to give 11 and updates the collection <code>[11 2 3 4 5...]</code>.
The second iteration happens on index 1 (value <code>2</code>), but uses an updated collection, i.e. <code>[11 2 3 4 5 ...]</code>.</z><z id="t1522240461" t="axrs I suppose what I need is a transient transform"><y>#</y><d>2018-03-28</d><h>12:34</h><w>axrs</w>I suppose what I need is a transient transform</z><z id="t1522257875" t="nathanmarz @axrs not sure what you mean"><y>#</y><d>2018-03-28</d><h>17:24</h><w>nathanmarz</w>@axrs not sure what you mean</z><z id="t1522257922" t="nathanmarz you want the entire collection passed to the update function?"><y>#</y><d>2018-03-28</d><h>17:25</h><w>nathanmarz</w>you want the entire collection passed to the update function?</z><z id="t1522275129" t="axrs hmm. Not quite. using sp/VAL I can get the entire collection. I&apos;m updating a single key for each map in a vector. As the transformation moves through the maps, they use values from a previous map entry to perform a calculation and provide a result. (def col [{:a 1} {:a 5} {:a 9}]) My transformation for each map entry would be 1. Get the previous map value for :a 2. Multiply that by 2 and add 8 3. Add to the current map value for :a 4. persist back into collection"><y>#</y><d>2018-03-28</d><h>22:12</h><w>axrs</w>hmm. Not quite. using sp/VAL I can get the entire collection. I&apos;m updating a single key for each map in a vector. As the transformation moves through the maps, they use values from a previous map entry to perform a calculation and provide a result.

<code>(def col [{:a 1} {:a 5} {:a 9}])</code>

My transformation for each map entry would be
1. Get the previous map value for :a
2. Multiply that by 2 and add 8
3. Add to the current map value for :a
4. persist back into collection</z><z id="t1522275291" t="axrs As a rough approximation. The actual calculation for the new value is more involved, but it requires an updated col as the transformation moves through"><y>#</y><d>2018-03-28</d><h>22:14</h><w>axrs</w>As a rough approximation. The actual calculation for the new value is more involved, but it requires an updated <code>col</code> as the transformation moves through</z><z id="t1522276193" t="nathanmarz @axrs that&apos;s a perfect use case for zipper navigators"><y>#</y><d>2018-03-28</d><h>22:29</h><w>nathanmarz</w>@axrs that&apos;s a perfect use case for zipper navigators</z><z id="t1522276196" t="nathanmarz (require &apos;[com.rpl.specter.zipper :as z]) (transform [z/VECTOR-ZIP z/DOWN z/NEXT z/NEXT-WALK (collect-one z/PREV z/NODE :a) z/NODE :a] (fn [v curr] (+ curr (* 2 v) 8)) col) "><y>#</y><d>2018-03-28</d><h>22:29</h><w>nathanmarz</w><pre>(require &apos;[com.rpl.specter.zipper :as z])
(transform
  [z/VECTOR-ZIP
   z/DOWN
   z/NEXT
   z/NEXT-WALK
   (collect-one z/PREV z/NODE :a)
   z/NODE
   :a]
  (fn [v curr]
    (+ curr (* 2 v) 8))
  col)
</pre></z><z id="t1522276451" t="axrs Ooo. That&apos;s a lot to consume, but looks like it would do the job. Thanks @nathanmarz, I&apos;ll have a look into it"><y>#</y><d>2018-03-28</d><h>22:34</h><w>axrs</w>Ooo. That&apos;s a lot to consume, but looks like it would do the job. Thanks @nathanmarz, I&apos;ll have a look into it</z><z id="t1522276563" t="nathanmarz this will be helpful for you https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers"><y>#</y><d>2018-03-28</d><h>22:36</h><w>nathanmarz</w>this will be helpful for you <a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers" target="_blank">https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers</a></z><z id="t1522447413" t="spieden trying to recursively remove map entries with nil values. here’s a start on the path: (def nil-map-entries (spr/recursive-path [] p (spr/cond-path #(and (instance? MapEntry %) (nil? (val %))) spr/STAY #(coll? %) [spr/ALL p]))) although i can select them with this, transforming doesn’t seem to match on them: (spr/select [nil-map-entries] {:foo nil :bar :bam}) =&gt; [[:foo nil]] (spr/transform [nil-map-entries] (constantly spr/NONE) {:foo nil :bar :bam}) =&gt; {:foo nil, :bar :bam} never experienced this kind of incongruity"><y>#</y><d>2018-03-30</d><h>22:03</h><w>spieden</w>trying to recursively remove map entries with nil values. here’s a start on the path: <pre>(def nil-map-entries
  (spr/recursive-path [] p
    (spr/cond-path
      #(and (instance? MapEntry %)
            (nil? (val %)))
      spr/STAY

      #(coll? %)
      [spr/ALL p])))
</pre> although i can select them with this, transforming doesn’t seem to match on them: <pre>(spr/select [nil-map-entries] {:foo nil :bar :bam})
=&gt; [[:foo nil]]
(spr/transform [nil-map-entries] (constantly spr/NONE) {:foo nil :bar :bam})
=&gt; {:foo nil, :bar :bam}</pre> never experienced this kind of incongruity</z><z id="t1522448458" t="nathanmarz @spieden specter navigates to vector for map entries on transform, not MapEntry object"><y>#</y><d>2018-03-30</d><h>22:20</h><w>nathanmarz</w>@spieden specter navigates to vector for map entries on transform, not <code>MapEntry</code> object</z><z id="t1522448522" t="nathanmarz I suggest handling maps separately from other collections in your path, which will make navigation more explicit and remove the need to check the type"><y>#</y><d>2018-03-30</d><h>22:22</h><w>nathanmarz</w>I suggest handling maps separately from other collections in your path, which will make navigation more explicit and remove the need to check the type</z><z id="t1522449682" t="spieden ahh"><y>#</y><d>2018-03-30</d><h>22:41</h><w>spieden</w>ahh</z><z id="t1522449694" t="spieden ok thanks! @nathanmarz"><y>#</y><d>2018-03-30</d><h>22:41</h><w>spieden</w>ok thanks! @nathanmarz</z><z id="t1522450155" t="spieden here’s what i wound up with, for posterity: (def nil-map-entries (spr/recursive-path [] p (spr/cond-path map? [spr/ALL (spr/if-path #(nil? (second %)) spr/STAY p)] #(coll? %) [spr/ALL p]))) (spr/transform [nil-map-entries] (constantly spr/NONE) {:foo {:baz nil} :bar :bam}) =&gt; {:foo {}, :bar :bam}"><y>#</y><d>2018-03-30</d><h>22:49</h><w>spieden</w>here’s what i wound up with, for posterity: <pre>(def nil-map-entries
  (spr/recursive-path [] p
    (spr/cond-path
      map?
      [spr/ALL (spr/if-path #(nil? (second %))
                            spr/STAY
                            p)]

      #(coll? %)
      [spr/ALL p])))</pre> <pre>(spr/transform [nil-map-entries] (constantly spr/NONE) {:foo {:baz nil} :bar :bam})
=&gt; {:foo {}, :bar :bam}</pre></z><z id="t1522470239" t="nathanmarz @spieden this is a more flexible way to approach that: (def MAP-NODES (recursive-path [] p (cond-path map? (stay-then-continue MAP-VALS p) coll? [ALL p] ))) (setval [MAP-NODES MAP-VALS nil?] NONE {:foo {:baz nil} :bar :bam}) "><y>#</y><d>2018-03-31</d><h>04:23</h><w>nathanmarz</w>@spieden this is a more flexible way to approach that:
<pre>(def MAP-NODES
  (recursive-path [] p
    (cond-path
      map? (stay-then-continue MAP-VALS p)
      coll? [ALL p]
      )))

(setval [MAP-NODES MAP-VALS nil?] NONE {:foo {:baz nil} :bar :bam})
</pre></z><z id="t1522470282" t="nathanmarz MAP-NODES could then be used for other things besides nil filtering"><y>#</y><d>2018-03-31</d><h>04:24</h><w>nathanmarz</w><code>MAP-NODES</code> could then be used for other things besides nil filtering</z><z id="t1522470550" t="spieden indeed! thanks"><y>#</y><d>2018-03-31</d><h>04:29</h><w>spieden</w>indeed! thanks</z><z id="t1522749466" t="Marcus Pemer I came across an interesting cunundrum this weekend and my initial attempts to find answers in the documentation has come up short. Hopefully someone on this channel will have a better grasp on things than I do. Suppose I had a three-layer data structure of maps. I would like to run a transformation on the leaves, similar to this: (transform [MAP-VALS MAP-VALS :b] str/capitalize {:top-key-a {:middle-key-aa {:a &quot;a&quot; :b &quot;b&quot; :c &quot;c&quot;} :middle-key-ab {:a &quot;a&quot; :b &quot;b&quot; :c &quot;c&quot;}} :top-key-b {:middle-key-ba {:a &quot;x&quot; :b &quot;y&quot; :c &quot;z&quot;} :middle-key-bb {:a &quot;u&quot; :b &quot;v&quot; :c &quot;w&quot;}}}) Which yields: {:top-key-a {:middle-key-aa {:a &quot;a&quot;, :b &quot;B&quot;, :c &quot;c&quot;}, :middle-key-ab {:a &quot;a&quot;, :b &quot;B&quot;, :c &quot;c&quot;}}, :top-key-b {:middle-key-ba {:a &quot;z&quot;, :b &quot;Y&quot;, :c &quot;z&quot;}, :middle-key-bb {:a &quot;u&quot;, :b &quot;V&quot;, :c &quot;w&quot;}}} Now, suppose I want to run a slightly more complex transformation on the leaves. Instead of running str/capitalize , which only takes the element itself as input, I would like to run my own custom function that takes the element to be transformed along with the ancestor keys following the path to the element. In this case I would like my transformation function to take :top-key-n and :middle-key-xy . The actual invocations of my transform function would then look something like this: (my-xform :top-key-a :middle-key-aa :b &quot;b&quot;) (my-xform :top-key-a :middle-key-ab :b &quot;b&quot;) (my-xform :top-key-b :middle-key-ba :b &quot;y&quot;) (my-xform :top-key-b :middle-key-bb :b &quot;v&quot;) Is there an idiomatic way to achieve this in Specter? Any advice appreciated."><y>#</y><d>2018-04-03</d><h>09:57</h><w>Marcus Pemer</w>I came across an interesting cunundrum this weekend and my initial attempts to find answers in the documentation has come up short. Hopefully someone on this channel will have a better grasp on things than I do.

Suppose I had a three-layer data structure of maps. I would like to run a transformation on the leaves, similar to this:
<pre>(transform [MAP-VALS MAP-VALS :b] str/capitalize
           {:top-key-a
            {:middle-key-aa {:a &quot;a&quot; :b &quot;b&quot; :c &quot;c&quot;}
             :middle-key-ab {:a &quot;a&quot; :b &quot;b&quot; :c &quot;c&quot;}}
            :top-key-b
            {:middle-key-ba {:a &quot;x&quot; :b &quot;y&quot; :c &quot;z&quot;}
             :middle-key-bb {:a &quot;u&quot; :b &quot;v&quot; :c &quot;w&quot;}}})
</pre>
Which yields:
<pre>{:top-key-a
 {:middle-key-aa {:a &quot;a&quot;, :b &quot;B&quot;, :c &quot;c&quot;},
  :middle-key-ab {:a &quot;a&quot;, :b &quot;B&quot;, :c &quot;c&quot;}},
 :top-key-b
 {:middle-key-ba {:a &quot;z&quot;, :b &quot;Y&quot;, :c &quot;z&quot;},
  :middle-key-bb {:a &quot;u&quot;, :b &quot;V&quot;, :c &quot;w&quot;}}}
</pre>

Now, suppose I want to run a slightly more complex transformation on the leaves. Instead of running <code>str/capitalize</code>, which only takes the element itself as input, I would like to run my own custom function that takes the element to be transformed along with the ancestor keys following the path to the element. In this case I would like my transformation function to take <code>:top-key-n</code> and <code>:middle-key-xy</code>. The actual invocations of my transform function would then look something like this:
<pre>(my-xform :top-key-a :middle-key-aa :b &quot;b&quot;)
(my-xform :top-key-a :middle-key-ab :b &quot;b&quot;)
(my-xform :top-key-b :middle-key-ba :b &quot;y&quot;)
(my-xform :top-key-b :middle-key-bb :b &quot;v&quot;)
</pre>
Is there an idiomatic way to achieve this in Specter? Any advice appreciated.</z><z id="t1522757667" t="drowsy @marcus165 not sure if it&apos;s the most idiomatic way, but you can use collect / collect-one to collect the keys on the way."><y>#</y><d>2018-04-03</d><h>12:14</h><w>drowsy</w>@marcus165 not sure if it&apos;s the most idiomatic way, but you can use <code>collect</code> / <code>collect-one</code> to collect the keys on the way.</z><z id="t1522757695" t="drowsy You can even use a recursive path here to climb down arbitrary nested maps"><y>#</y><d>2018-04-03</d><h>12:14</h><w>drowsy</w>You can even use a recursive path here to climb down arbitrary nested maps</z><z id="t1522757738" t="drowsy (def MAP-KV-NODES (recursive-path [] p (cond-path map? [ALL (collect-one FIRST) LAST p] :else STAY))) (transform [MAP-KV-NODES] myx-form data)"><y>#</y><d>2018-04-03</d><h>12:15</h><w>drowsy</w><pre>(def MAP-KV-NODES
  (recursive-path [] p
     (cond-path
       map? [ALL (collect-one FIRST) LAST p]
       :else STAY)))
(transform [MAP-KV-NODES] myx-form data)</pre></z><z id="t1522757848" t="drowsy slightly tricky part is, that you need to navigate to the key/value pairs of a map using ALL , collect the key with FIRST and navigate to its val with LAST"><y>#</y><d>2018-04-03</d><h>12:17</h><w>drowsy</w>slightly tricky part is, that you need to navigate to the key/value pairs of a map using <code>ALL</code>, collect the key with <code>FIRST</code> and navigate to its val with <code>LAST</code></z><z id="t1522760322" t="nathanmarz @marcus165 @drowsy yes, value collection is the idiomatic way to do that"><y>#</y><d>2018-04-03</d><h>12:58</h><w>nathanmarz</w>@marcus165 @drowsy yes, value collection is the idiomatic way to do that</z><z id="t1522760485" t="nathanmarz can easily make a wrapper around [ALL (collect-one FIRST) LAST] so you can do (transform [MY-MAP-VALS MY-MAP-VALS MAP-VALS] (fn [top middle v] ...) data)"><y>#</y><d>2018-04-03</d><h>13:01</h><w>nathanmarz</w>can easily make a wrapper around <code>[ALL (collect-one FIRST) LAST]</code> so you can do <code>(transform [MY-MAP-VALS MY-MAP-VALS MAP-VALS] (fn [top middle v] ...) data)</code></z><z id="t1522761141" t="Marcus Pemer Thank you @drowsy and @nathanmarz - that helped; I am now both enlightened and unblocked."><y>#</y><d>2018-04-03</d><h>13:12</h><w>Marcus Pemer</w>Thank you @drowsy and @nathanmarz - that helped; I am now both enlightened and unblocked.</z><z id="t1522761871" t="nathanmarz @marcus784 take a look at &quot;Value Collection&quot; under https://github.com/nathanmarz/specter/wiki/Cheat-Sheet to see all the things you can do with collected values"><y>#</y><d>2018-04-03</d><h>13:24</h><w>nathanmarz</w>@marcus784 take a look at &quot;Value Collection&quot; under <a href="https://github.com/nathanmarz/specter/wiki/Cheat-Sheet" target="_blank">https://github.com/nathanmarz/specter/wiki/Cheat-Sheet</a> to see all the things you can do with collected values</z><z id="t1522828972" t="Marcus Pemer Thank you @nathanmarz - after looking at the main readme.md I found a section that clearly documents this as well - this paragraph says it all: &gt; When doing more involved transformations, you often find you lose context when navigating deep within a data structure and need information &quot;up&quot; the data structure to perform the transformation. Specter solves this problem by allowing you to collect values during navigation to use in the transform function. In retrospect I don&apos;t know how I missed it. Thanks again."><y>#</y><d>2018-04-04</d><h>08:02</h><w>Marcus Pemer</w>Thank you @nathanmarz - after looking at the main readme.md I found a section that clearly documents this as well - this paragraph says it all:

&gt; When doing more involved transformations, you often find you lose context when navigating deep within a data structure and need information &quot;up&quot; the data structure to perform the transformation. Specter solves this problem by allowing you to collect values during navigation to use in the transform function.

In retrospect I don&apos;t know how I missed it. Thanks again.</z><z id="t1522868895" t="levitanong @nathanmarz is there any plan to publish 1.1.1-SNAPSHOT in clojars?"><y>#</y><d>2018-04-04</d><h>19:08</h><w>levitanong</w>@nathanmarz is there any plan to publish 1.1.1-SNAPSHOT in clojars?</z><z id="t1522869930" t="nathanmarz @levitanong just published it"><y>#</y><d>2018-04-04</d><h>19:25</h><w>nathanmarz</w>@levitanong just published it</z><z id="t1522869993" t="levitanong Thanks @nathanmarz !"><y>#</y><d>2018-04-04</d><h>19:26</h><w>levitanong</w>Thanks @nathanmarz !</z><z id="t1522880604" t="justinlee I’m having an issue in my reagent project where I’m getting atom updates unexpectedly. I tried to debug this issue by creating an Error object in my add-watch and printing out the stack trace, but the stack bottoms out at this line: com.rpl.specter.impl.combine_two_navs.com.rpl.specter.impl.t_com$rpl$specter$$rpl$specter$protocols$RichNavigator$transform_STAR_$arity$4 () Any idea why I’m losing stack context beyond this line? I’d really like to figure out where in my code I’m calling specter that is doing this, but it is hard. I wasn’t expecting specter to be async."><y>#</y><d>2018-04-04</d><h>22:23</h><w>justinlee</w>I’m having an issue in my reagent project where I’m getting atom updates unexpectedly.  I tried to debug this issue by creating an Error object in my add-watch and printing out the stack trace, but the stack bottoms out at this line: <pre>com.rpl.specter.impl.combine_two_navs.com.rpl.specter.impl.t_com$rpl$specter$$rpl$specter$protocols$RichNavigator$transform_STAR_$arity$4 ()</pre>  Any idea why I’m losing stack context beyond this line?  I’d really like to figure out where in my code I’m calling specter that is doing this, but it is hard.  I wasn’t expecting specter to be async.</z><z id="t1522881250" t="nathanmarz @lee.justin.m there&apos;s nothing async or lazy about specter"><y>#</y><d>2018-04-04</d><h>22:34</h><w>nathanmarz</w>@lee.justin.m there&apos;s nothing async or lazy about specter</z><z id="t1522881291" t="nathanmarz whenever i have an error with an unexpected stack trace I look to see if I&apos;m inadvertently using laziness somewhere"><y>#</y><d>2018-04-04</d><h>22:34</h><w>nathanmarz</w>whenever i have an error with an unexpected stack trace I look to see if I&apos;m inadvertently using laziness somewhere</z><z id="t1522881327" t="nathanmarz e.g. if you&apos;re doing (map #(transform ...) aseq) and not realizing the result until later on"><y>#</y><d>2018-04-04</d><h>22:35</h><w>nathanmarz</w>e.g. if you&apos;re doing <code>(map #(transform ...) aseq)</code> and not realizing the result until later on</z><z id="t1522881553" t="justinlee thanks @nathanmarz. i’m probably misunderstanding something about laziness, but wouldn’t i see the lazy function at the bottom of the stack instead of seeing specter at the bottom? that’s the part that is confusing me."><y>#</y><d>2018-04-04</d><h>22:39</h><w>justinlee</w>thanks @nathanmarz.  i’m probably misunderstanding something about laziness, but wouldn’t i see the lazy function at the bottom of the stack instead of seeing specter at the bottom?  that’s the part that is confusing me.</z><z id="t1522881579" t="justinlee hm, now that i’m saying this out loud, maybe its because i’m in a go block? that can shear stack traces."><y>#</y><d>2018-04-04</d><h>22:39</h><w>justinlee</w>hm, now that i’m saying this out loud, maybe its because i’m in a go block?  that can shear stack traces.</z><z id="t1522882033" t="nathanmarz not sure, I don&apos;t use core.async"><y>#</y><d>2018-04-04</d><h>22:47</h><w>nathanmarz</w>not sure, I don&apos;t use core.async</z><z id="t1522882704" t="justinlee ah yea that was it. the one piece of async code that doesn’t log. too bad my little stacktrace trick doesn’t work across async boundaries. sorry for the noise."><y>#</y><d>2018-04-04</d><h>22:58</h><w>justinlee</w>ah yea that was it.  the one piece of async code that doesn’t log. too bad my little stacktrace trick doesn’t work across async boundaries.  sorry for the noise.</z><z id="t1522946416" t="frenata Having a weird issue where specter is failing only inside a cljs cider repl connection. Fine everywhere else: in the browser, in clj cider connections, and in a figwheel repl. Entirely possible this isn&apos;t especially specter related but I&apos;m stumped."><y>#</y><d>2018-04-05</d><h>16:40</h><w>frenata</w>Having a weird issue where specter is failing only inside a cljs cider repl connection. Fine everywhere else: in the browser, in clj cider connections, and in a figwheel repl. Entirely possible this isn&apos;t especially specter related but I&apos;m stumped.</z><z id="t1523043663" t="justinlee are there any tricks to bringing the size of specter down? it adds 178k before gzipping, which is a bit painful"><y>#</y><d>2018-04-06</d><h>19:41</h><w>justinlee</w>are there any tricks to bringing the size of specter down?  it adds 178k before gzipping, which is a bit painful</z><z id="t1523044529" t="nathanmarz @lee.justin.m the navigators are completely independent from each other, so you could fork the project and remove any navigators you don&apos;t use"><y>#</y><d>2018-04-06</d><h>19:55</h><w>nathanmarz</w>@lee.justin.m the navigators are completely independent from each other, so you could fork the project and remove any navigators you don&apos;t use</z><z id="t1523044575" t="justinlee @nathanmarz ah cool that’s good to know down the line. i’ll still use it even it if is 178k 🙂"><y>#</y><d>2018-04-06</d><h>19:56</h><w>justinlee</w>@nathanmarz ah cool that’s good to know down the line.  i’ll still use it even it if is 178k <b>🙂</b></z><z id="t1523044606" t="nathanmarz I don&apos;t really use cljs, but I was under the impression it did that kind of dead code elimination automatically"><y>#</y><d>2018-04-06</d><h>19:56</h><w>nathanmarz</w>I don&apos;t really use cljs, but I was under the impression it did that kind of dead code elimination automatically</z><z id="t1523044639" t="justinlee DCE is a black art. hard to say what it is doing"><y>#</y><d>2018-04-06</d><h>19:57</h><w>justinlee</w>DCE is a black art.  hard to say what it is doing</z><z id="t1523044656" t="justinlee maybe it already is doing dce"><y>#</y><d>2018-04-06</d><h>19:57</h><w>justinlee</w>maybe it already is doing dce</z><z id="t1523065297" t="zlrth I have a datastructure that&apos;s a combination of maps and vectors, with various amounts of nesting: [{:user &quot;matt&quot; :docs [{:fulltext &quot;the text&quot; :url &quot;&quot; :fragments []} ;; more docs ]} ;; more maps ] I want to update the data structure like so [{:user &quot;matt&quot; :docs [{:fulltext &quot;the text&quot; :url &quot;&quot; :fragments [{:date &quot;2018&quot; :text &quot;the &quot;} {:date &quot;2017&quot; :text &quot;text&quot;}]} ;; more docs ]} ;; more maps ] I want to do: &quot;select the map with the key-value pair :user and &quot;matt&quot; , then in the :doc vector, select the map with the kv pair :fulltext and &quot;the text&quot; and conj these two maps&quot;"><y>#</y><d>2018-04-07</d><h>01:41</h><w>zlrth</w>I have a datastructure that&apos;s a combination of maps and vectors, with various amounts of nesting:
<pre>[{:user &quot;matt&quot;
  :docs [{:fulltext &quot;the text&quot;
          :url &quot;&quot;
          :fragments []}
         ;; more docs
         ]}
 ;; more maps
 ]</pre>

I want to update the data structure like so

<pre>[{:user &quot;matt&quot;
  :docs [{:fulltext &quot;the text&quot;
          :url &quot;&quot;
          :fragments [{:date &quot;2018&quot; :text &quot;the &quot;}
                      {:date &quot;2017&quot; :text &quot;text&quot;}]}
         ;; more docs
         ]}
 ;; more maps
 ]</pre>

I want to do: &quot;select the map with the key-value pair <code>:user</code> and <code>&quot;matt&quot;</code>, then in the <code>:doc</code> vector, select the map with the kv pair <code>:fulltext</code> and <code>&quot;the text&quot;</code> and conj these two maps&quot;</z><z id="t1523065946" t="zlrth I skimmed the Navigators docs, and couldn&apos;t find &quot;select the map containing the kv-pair.&quot; I suspect that I&apos;m trying to do something not idiomatic. In theory, I could make this data structure entirely out of nested maps--then this would be trivial--but i don&apos;t know if i can guarantee that a map will have a unique key."><y>#</y><d>2018-04-07</d><h>01:52</h><w>zlrth</w>I skimmed the Navigators docs, and couldn&apos;t find &quot;select the map containing the kv-pair.&quot; I suspect that I&apos;m trying to do something not idiomatic. In theory, I could make this data structure entirely out of nested maps--then this would be trivial--but i don&apos;t know if i can guarantee that a map will have a unique key.</z><z id="t1523074193" t="nathanmarz @mfm looks like this: (defn map-with-kv [k v] (path ALL #(= v (get % k)))) (setval [(map-with-kv :user &quot;matt&quot;) :docs (map-with-kv :fulltext &quot;the text&quot;) :fragments END ] [{:date &quot;2018&quot; :text &quot;the &quot;} {:date &quot;2017&quot; :text &quot;text&quot;}] data) "><y>#</y><d>2018-04-07</d><h>04:09</h><w>nathanmarz</w>@mfm looks like this:
<pre>(defn map-with-kv [k v]
  (path ALL #(= v (get % k))))

(setval
  [(map-with-kv :user &quot;matt&quot;)
   :docs
   (map-with-kv :fulltext &quot;the text&quot;)
   :fragments
   END
   ]
  [{:date &quot;2018&quot; :text &quot;the &quot;}
   {:date &quot;2017&quot; :text &quot;text&quot;}]
  data)
</pre></z><z id="t1523103436" t="zlrth ah, thank you @nathanmarz!"><y>#</y><d>2018-04-07</d><h>12:17</h><w>zlrth</w>ah, thank you @nathanmarz!</z><z id="t1523839544" t="steveh2018 Nathan, new to clojure, needed get-in but will now pursue specter. Can it navigate through ref boundaries in deeply nested combos of maps and vectors?"><y>#</y><d>2018-04-16</d><h>00:45</h><w>steveh2018</w>Nathan, new to clojure, needed  get-in but will now pursue specter. Can it navigate through ref boundaries in deeply nested combos of maps and vectors?</z><z id="t1523841512" t="nathanmarz @steveh2009 yes, no problem"><y>#</y><d>2018-04-16</d><h>01:18</h><w>nathanmarz</w>@steveh2009 yes, no problem</z><z id="t1523841554" t="nathanmarz for navigating into refs you&apos;d need to make your own navigator, but that is very easy – just use ATOM as an example: https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1081"><y>#</y><d>2018-04-16</d><h>01:19</h><w>nathanmarz</w>for navigating into refs you&apos;d need to make your own navigator, but that is very easy – just use <code>ATOM</code> as an example: <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1081" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1081</a></z><z id="t1523841811" t="steveh2018 Fantastic. Off to YouTube to see your talks."><y>#</y><d>2018-04-16</d><h>01:23</h><w>steveh2018</w>Fantastic. Off to YouTube to see your talks.</z><z id="t1523911227" t="tanzoniteblack Is there a way I can implement take-while via specter? Specifically, I (eventually down a path) have a sequence of items, and I want to take every item up to (and including) a certain value. Example: [{:id :a} {:id :b} {:id :c} {:id :d}] ;; up to (&amp; including) index: :c ;; ==&gt; [{:id :a} {:id :b} {:id :c}] current implementation using split-with : (let [[steps-before steps-after] (split-with #(not= (:id %) :c) [{:id :a} {:id :b} {:id :c} {:id :d}])] (concat steps-before (take 1 steps-after))) "><y>#</y><d>2018-04-16</d><h>20:40</h><w>tanzoniteblack</w>Is there a way I can implement take-while via specter? Specifically, I (eventually down a path) have a sequence of items, and I want to take every item up to (and including) a certain value.

Example:
<pre>[{:id :a} {:id :b} {:id :c} {:id :d}]
;; up to (&amp; including) index: :c
;; ==&gt; [{:id :a} {:id :b} {:id :c}]
</pre>

current implementation using <code>split-with</code>:

<pre>(let [[steps-before steps-after] (split-with #(not= (:id %) :c) [{:id :a} {:id :b} {:id :c} {:id :d}])]
     (concat steps-before (take 1 steps-after)))
</pre></z><z id="t1523911512" t="nathanmarz @tanzoniteblack you could do it with srange-dynamic"><y>#</y><d>2018-04-16</d><h>20:45</h><w>nathanmarz</w>@tanzoniteblack you could do it with <code>srange-dynamic</code></z><z id="t1523911542" t="tanzoniteblack thanks"><y>#</y><d>2018-04-16</d><h>20:45</h><w>tanzoniteblack</w>thanks</z><z id="t1523911943" t="nathanmarz @tanzoniteblack with https://github.com/nathanmarz/specter/issues/236 it could be done more efficiently/directly"><y>#</y><d>2018-04-16</d><h>20:52</h><w>nathanmarz</w>@tanzoniteblack with <a href="https://github.com/nathanmarz/specter/issues/236" target="_blank">https://github.com/nathanmarz/specter/issues/236</a> it could be done more efficiently/directly</z><z id="t1524084808" t="spieden is there a way to splice a sequence into another starting at a specific index with specter? e.g. (spr/setval [(spr/before-index 1)] [:a :b] [:x :y]) =&gt; [:x [:a :b] :y] ; want: [:x :a :b :y]"><y>#</y><d>2018-04-18</d><h>20:53</h><w>spieden</w>is there a way to splice a sequence into another starting at a specific index with specter? e.g. <pre>(spr/setval [(spr/before-index 1)] [:a :b] [:x :y])
=&gt; [:x [:a :b] :y]
; want: [:x :a :b :y]</pre></z><z id="t1524085473" t="drowsy @spieden you can use srange to navigate to a subcollection."><y>#</y><d>2018-04-18</d><h>21:04</h><w>drowsy</w>@spieden you can use <code>srange</code> to navigate to a subcollection.</z><z id="t1524085478" t="drowsy (setval [(srange 1 1)] [:a :b] [:x :y]) =&gt; [:x :a :b :y]"><y>#</y><d>2018-04-18</d><h>21:04</h><w>drowsy</w><pre>(setval [(srange 1 1)] [:a :b] [:x :y]) =&gt; [:x :a :b :y]</pre></z><z id="t1524085496" t="spieden cool thanks! @drowsy"><y>#</y><d>2018-04-18</d><h>21:04</h><w>spieden</w>cool thanks! @drowsy</z><z id="t1524085539" t="drowsy in this case you are navigating to an empty subcollection in the middle and replacing it with something nonempty"><y>#</y><d>2018-04-18</d><h>21:05</h><w>drowsy</w>in this case you are navigating to an empty subcollection in the middle and replacing it with something nonempty</z><z id="t1524085794" t="spieden yes i had that idea in my head from using sets at some point but didn’t know to look for"><y>#</y><d>2018-04-18</d><h>21:09</h><w>spieden</w>yes i had that idea in my head from using sets at some point but didn’t know to look for</z><z id="t1524085808" t="spieden s/to/what to/"><y>#</y><d>2018-04-18</d><h>21:10</h><w>spieden</w>s/to/what to/</z><z id="t1524209460" t="levitanong @nathanmarz https://github.com/nathanmarz/specter/blob/0ceda2115120cbe99ac9b600fce8d94e4575d236/src/clj/com/rpl/specter/impl.cljc#L910 It seems that this line can’t get deadcode eliminated, so any project that includes specter will always be including cljs.pprint in advanced optimization. Any chance this can be handled differently?"><y>#</y><d>2018-04-20</d><h>07:31</h><w>levitanong</w>@nathanmarz <a href="https://github.com/nathanmarz/specter/blob/0ceda2115120cbe99ac9b600fce8d94e4575d236/src/clj/com/rpl/specter/impl.cljc#L910" target="_blank">https://github.com/nathanmarz/specter/blob/0ceda2115120cbe99ac9b600fce8d94e4575d236/src/clj/com/rpl/specter/impl.cljc#L910</a>
It seems that this line can’t get deadcode eliminated, so any project that includes specter will always be including <code>cljs.pprint</code> in advanced optimization. Any chance this can be handled differently?</z><z id="t1524240180" t="nathanmarz @levitanong I&apos;ll have to think about that one"><y>#</y><d>2018-04-20</d><h>16:03</h><w>nathanmarz</w>@levitanong I&apos;ll have to think about that one</z><z id="t1524240184" t="nathanmarz can you open an issue for it?"><y>#</y><d>2018-04-20</d><h>16:03</h><w>nathanmarz</w>can you open an issue for it?</z><z id="t1524240959" t="levitanong @nathanmarz Will do!"><y>#</y><d>2018-04-20</d><h>16:15</h><w>levitanong</w>@nathanmarz Will do!</z><z id="t1524241144" t="levitanong @nathanmarz done https://github.com/nathanmarz/specter/issues/254"><y>#</y><d>2018-04-20</d><h>16:19</h><w>levitanong</w>@nathanmarz done <a href="https://github.com/nathanmarz/specter/issues/254" target="_blank">https://github.com/nathanmarz/specter/issues/254</a></z><z id="t1524497486" t="nathanmarz Released Specter 1.1.1 https://github.com/nathanmarz/specter/blob/master/CHANGES.md"><y>#</y><d>2018-04-23</d><h>15:31</h><w>nathanmarz</w>Released Specter 1.1.1 <a href="https://github.com/nathanmarz/specter/blob/master/CHANGES.md" target="_blank">https://github.com/nathanmarz/specter/blob/master/CHANGES.md</a></z><z id="t1524673532" t="souenzzo There is something like (if-not-path test-path get-path)"><y>#</y><d>2018-04-25</d><h>16:25</h><w>souenzzo</w>There is something like <code>(if-not-path test-path get-path)</code></z><z id="t1524673816" t="nathanmarz @souenzzo (defdynamicnav if-not-path [cond-path path] (if-path cond-path STOP path)) "><y>#</y><d>2018-04-25</d><h>16:30</h><w>nathanmarz</w>@souenzzo 
<pre>(defdynamicnav if-not-path [cond-path path]
  (if-path cond-path STOP path))
</pre></z><z id="t1525399370" t="soulflyer I&apos;m trying to use specter/zipper to create a custom zipper. I have the clojure.zip/zipper working ok, but when I attempt to wrap it using specter/zipper I get this error: anh-front.tree&gt; (def tz (specter-tree-zip test-tree)) #object[TypeError TypeError: anh_front.tree.specter_tree_zip.call is not a function] nil Heres the code, I have clojure.zip required as zip and specter.zip required as sz (defn tree-zip &quot;Returns a zipper for tree elements given a root element&quot; [root] (zip/zipper (complement string?) (fn [node] (if (:expanded node) (seq (:children node)))) (fn [node children] (assoc node :children (and children (apply vector children)))) root)) (def specter-tree-zip (sz/zipper tree-zip)) Any idea what I have done wrong?"><y>#</y><d>2018-05-04</d><h>02:02</h><w>soulflyer</w>I&apos;m trying to use <code>specter/zipper</code> to create a custom zipper. I have the <code>clojure.zip/zipper</code> working ok, but when I attempt to wrap it using specter/zipper I get this error:
<pre>anh-front.tree&gt; (def tz (specter-tree-zip test-tree))
#object[TypeError TypeError: anh_front.tree.specter_tree_zip.call is not a function]
nil</pre>
Heres the code, I have <code>clojure.zip</code> required as <code>zip</code> and <code>specter.zip</code> required as <code>sz</code>
<pre>(defn tree-zip
  &quot;Returns a zipper for tree elements given a root element&quot;
  [root]
  (zip/zipper (complement string?)
              (fn [node] (if (:expanded node)
                           (seq (:children node))))
              (fn [node children]
                (assoc node :children (and children (apply vector children))))
              root))

(def specter-tree-zip (sz/zipper tree-zip))</pre>
Any idea what I have done wrong?</z><z id="t1525400165" t="nathanmarz @soulflyer sz/zipper returns a navigator, not a function"><y>#</y><d>2018-05-04</d><h>02:16</h><w>nathanmarz</w>@soulflyer <code>sz/zipper</code> returns a navigator, not a function</z><z id="t1525400175" t="nathanmarz you use it in a path to navigate to the zipper object"><y>#</y><d>2018-05-04</d><h>02:16</h><w>nathanmarz</w>you use it in a path to navigate to the zipper object</z><z id="t1525400197" t="nathanmarz e.g. (transform [specter-tree-zip sz/DOWN ..."><y>#</y><d>2018-05-04</d><h>02:16</h><w>nathanmarz</w>e.g. <code>(transform [specter-tree-zip sz/DOWN ...</code></z><z id="t1525400545" t="soulflyer ah, that makes sense. I wrongly assumed I could just drop it in where I had used clojure.zip/zipper Thanks!"><y>#</y><d>2018-05-04</d><h>02:22</h><w>soulflyer</w>ah, that makes sense. I wrongly assumed I could just drop it in where I had used <code>clojure.zip/zipper</code> Thanks!</z><z id="t1525479892" t="chromalchemy I am trying to do this: (select (srange 0 3) (select [ALL (selected? pred)] collection)) Is there a way to pop back up to a view of the collection before selecting each node through ALL, idiomatically in one path, instead of using two functions and nesting one? I&apos;m assuming there would be a transducer-like performance benefit to this, am I right? Alternatively, can srange be used after ALL to still filter the root nodes in the collection?"><y>#</y><d>2018-05-05</d><h>00:24</h><w>chromalchemy</w>I am trying to do this:
<pre>(select (srange 0 3) (select [ALL (selected? pred)] collection))</pre>
Is there a way to pop back up to a view of the collection before selecting each node through ALL, idiomatically in one path, instead of using two functions and nesting one? I&apos;m assuming there would be a transducer-like performance benefit to this, am I right?

Alternatively, can <code>srange</code> be used after <code>ALL</code> to still filter the root nodes in the collection?</z><z id="t1525480204" t="chromalchemy Also, is there a way to do side effects in the middle of a compound path like [path1 (side-effect-fn) path2] Or would it better to collect the necessary value for the side effect, then use a transform fn: (transform [path1 collect path2] #(do (side-effect-fn %1) (main-fn %2)) collection)"><y>#</y><d>2018-05-05</d><h>00:30</h><w>chromalchemy</w>Also, is there a way to do side effects in the middle of a compound path like <code>[path1 (side-effect-fn) path2]</code> Or would it better to collect the necessary value for the side effect, then use a transform fn: <pre>(transform [path1 collect path2] #(do (side-effect-fn %1) (main-fn %2)) collection)</pre></z><z id="t1525482706" t="nathanmarz @chromalchemy that first path is best written as (select-any [(filterer pred) (srange 0 3)] collection)"><y>#</y><d>2018-05-05</d><h>01:11</h><w>nathanmarz</w>@chromalchemy that first path is best written as <code>(select-any [(filterer pred) (srange 0 3)] collection)</code></z><z id="t1525482734" t="nathanmarz the definition of filterer is instructive: https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1137"><y>#</y><d>2018-05-05</d><h>01:12</h><w>nathanmarz</w>the definition of <code>filterer</code> is instructive: <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1137" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1137</a></z><z id="t1525482850" t="nathanmarz you could do side effects in a path with something like: (defn side-effect [f] (view (fn [v] (f v) v))) "><y>#</y><d>2018-05-05</d><h>01:14</h><w>nathanmarz</w>you could do side effects in a path with something like:
<pre>(defn side-effect [f]
  (view (fn [v] (f v) v)))
</pre></z><z id="t1525482860" t="nathanmarz seems weird to me though to do something like that"><y>#</y><d>2018-05-05</d><h>01:14</h><w>nathanmarz</w>seems weird to me though to do something like that</z><z id="t1525486659" t="chromalchemy @nathanmarz Thank you. I will get to know subselect and select-any ."><y>#</y><d>2018-05-05</d><h>02:17</h><w>chromalchemy</w>@nathanmarz Thank you. I will get to know <code>subselect</code> and <code>select-any</code>.</z><z id="t1525650235" t="jfntn Can specter do a recursive map traversal, collecting every value and its path?"><y>#</y><d>2018-05-06</d><h>23:43</h><w>jfntn</w>Can specter do a recursive map traversal, collecting every value and its path?</z><z id="t1525658904" t="nathanmarz @jfntn yes there&apos;s an example of that on https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure"><y>#</y><d>2018-05-07</d><h>02:08</h><w>nathanmarz</w>@jfntn yes there&apos;s an example of that on <a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure" target="_blank">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#find-the-index-route-of-a-value-within-a-data-structure</a></z><z id="t1525663132" t="jfntn Thank you, I should have seen that! Handed up rolling my own it will be interesting to compare perf here"><y>#</y><d>2018-05-07</d><h>03:18</h><r>jfntn</r>Thank you, I should have seen that! Handed up rolling my own it will be interesting to compare perf here</z><z id="t1525794321" t="jjttjj I have a vector of maps: [{:a 1} {:b 2 :d 4} {:c 3} {:d 4}] and I want to find the map where :c = 3 and insert another map {:x 100} before it, resulting in [{:a 1} {:b 2 :d 4} {:x 100} {:c 3} {:d 4}] What&apos;s the best way to accomplish this in specter?"><y>#</y><d>2018-05-08</d><h>15:45</h><w>jjttjj</w>I have a vector of maps: <pre>[{:a 1} {:b 2 :d 4} {:c 3} {:d 4}]</pre> and I want to find the map where :c = 3 and insert another map {:x 100} before it, resulting in <pre>[{:a 1} {:b 2 :d 4} {:x 100} {:c 3} {:d 4}]</pre> What&apos;s the best way to accomplish this in specter?</z><z id="t1525794403" t="jjttjj (I don&apos;t know the index I need to insert at, just the keys in the map I need to insert before )"><y>#</y><d>2018-05-08</d><h>15:46</h><w>jjttjj</w>(I don&apos;t know the index I need to insert at, just the keys in the map I need to insert before )</z><z id="t1525794559" t="jjttjj I&apos;ve been messing with INDEXED-VALS and trying to collect the index and then insert the new map, but I&apos;m having trouble getting this to work and am not sure this is the right line of thinking or if there&apos;s a better way"><y>#</y><d>2018-05-08</d><h>15:49</h><w>jjttjj</w>I&apos;ve been messing with INDEXED-VALS and trying to collect the index and then insert the new map, but I&apos;m having trouble getting this to work and am not sure this is the right line of thinking or if there&apos;s a better way</z><z id="t1525795533" t="nathanmarz @jjttjj I would do that with a select followed by a transform: (if-let [i (select-first [INDEXED-VALS (selected? LAST :c (pred= 3)) FIRST)] data)] (setval (before-index i) {:x 100} data)) "><y>#</y><d>2018-05-08</d><h>16:05</h><w>nathanmarz</w>@jjttjj I would do that with a select followed by a transform:

<pre>(if-let [i (select-first [INDEXED-VALS (selected? LAST :c (pred= 3)) FIRST)] data)]
  (setval (before-index i) {:x 100} data))
</pre></z><z id="t1525795561" t="nathanmarz you can also do it in a single operation using zippers"><y>#</y><d>2018-05-08</d><h>16:06</h><w>nathanmarz</w>you can also do it in a single operation using zippers</z><z id="t1525795601" t="nathanmarz https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers"><y>#</y><d>2018-05-08</d><h>16:06</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers" target="_blank">https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers</a></z><z id="t1525795604" t="jjttjj cool, that one works, thanks!"><y>#</y><d>2018-05-08</d><h>16:06</h><w>jjttjj</w>cool, that one works, thanks!</z><z id="t1525845264" t="soulflyer I&apos;m seeing a difference in the behaviour of a specter recursive-path example (found on stack overflow) in the clojure repl and the clojurescript repl . It works as expected in clojure but throws an error in clojurescript. In clojure I get this: user&gt; (def data {:items [{:name &quot;Washing machine&quot; :subparts [{:name &quot;Ballast&quot; :weight 1} {:name &quot;Hull&quot; :weight 2}]}]}) #&apos;user/data user&gt; (require &apos;[com.rpl.specter :as specter]) nil user&gt; (specter/select [(specter/recursive-path [] p [(specter/walker :name) (specter/stay-then-continue [:subparts p])]) :name] data) [&quot;Washing machine&quot; &quot;Ballast&quot; &quot;Hull&quot;] user&gt; user&gt; (def data {:items [{:name &quot;Washing machine&quot; :subparts [{:name &quot;Ballast&quot; :weight 1} {:name &quot;Hull&quot; :weight 2}]}]}) #&apos;user/data user&gt; (require &apos;[com.rpl.specter :as specter]) nil user&gt; (specter/select [(specter/recursive-path [] p [(specter/walker :name) (specter/stay-then-continue [:subparts p])]) :name] data) [&quot;Washing machine&quot; &quot;Ballast&quot; &quot;Hull&quot;] user&gt; whereas the same code tried under clojurescript throws an error Unable to resolve var p : anh-front.tree&gt; (require &apos;[com.rpl.specter :as specter]) nil anh-front.tree&gt; (def data {:items [{:name &quot;Washing machine&quot; :subparts [{:name &quot;Ballast&quot; :weight 1} {:name &quot;Hull&quot; :weight 2}]}]}) #&apos;anh-front.tree/data anh-front.tree&gt; (specter/select [(specter/recursive-path [] p [(specter/walker :name) (specter/stay-then-continue [:subparts p])]) :name] data) ---- Could not Analyze &lt;cljs form&gt; line:1 column:1 ---- Unable to resolve var: p in this context at line 1 &lt;cljs repl&gt; 1 (specter/select ^--- 2 [(specter/recursive-path [] p 3 [(specter/walker :name) (specter/stay-then-continue [:subparts p])]) 4 :name] 5 data) ---- Analysis Error ---- nil anh-front.tree&gt; Is there something special needed to get recursive-path to play nicely with clojurescript?"><y>#</y><d>2018-05-09</d><h>05:54</h><w>soulflyer</w>I&apos;m seeing a difference in the behaviour of a specter <code>recursive-path</code> example (found on stack overflow) in the <code>clojure repl</code> and the <code>clojurescript repl</code>. It works as expected in clojure but throws an error in clojurescript. In clojure I get this:
<pre>user&gt; (def data
  {:items [{:name &quot;Washing machine&quot;
            :subparts [{:name &quot;Ballast&quot; :weight 1}
                       {:name &quot;Hull&quot; :weight 2}]}]}) 
#&apos;user/data
user&gt; (require &apos;[com.rpl.specter :as specter])
nil
user&gt; (specter/select
  [(specter/recursive-path [] p
     [(specter/walker :name) (specter/stay-then-continue [:subparts p])])
   :name]
  data)
[&quot;Washing machine&quot; &quot;Ballast&quot; &quot;Hull&quot;]
user&gt; user&gt; (def data
  {:items [{:name &quot;Washing machine&quot;
            :subparts [{:name &quot;Ballast&quot; :weight 1}
                       {:name &quot;Hull&quot; :weight 2}]}]})
#&apos;user/data
user&gt; (require &apos;[com.rpl.specter :as specter])
nil
user&gt; (specter/select
  [(specter/recursive-path [] p
     [(specter/walker :name) (specter/stay-then-continue [:subparts p])])
   :name]
  data)
[&quot;Washing machine&quot; &quot;Ballast&quot; &quot;Hull&quot;]
user&gt; </pre>
whereas the same code tried under clojurescript throws an error <code>Unable to resolve var p</code>:
<pre>anh-front.tree&gt; (require &apos;[com.rpl.specter :as specter])
nil
anh-front.tree&gt; (def data
  {:items [{:name &quot;Washing machine&quot;
            :subparts [{:name &quot;Ballast&quot; :weight 1}
                       {:name &quot;Hull&quot; :weight 2}]}]})
#&apos;anh-front.tree/data
anh-front.tree&gt; (specter/select
  [(specter/recursive-path [] p
     [(specter/walker :name) (specter/stay-then-continue [:subparts p])])
   :name]
  data)
----  Could not Analyze  &lt;cljs form&gt;   line:1  column:1  ----

  Unable to resolve var: p in this context at line 1 &lt;cljs repl&gt;

  1                (specter/select
                   ^--- 
  2  [(specter/recursive-path [] p
  3     [(specter/walker :name) (specter/stay-then-continue [:subparts p])])
  4   :name]
  5  data)

----  Analysis Error  ----
nil
anh-front.tree&gt; </pre>
Is there something special needed to get recursive-path to play nicely with clojurescript?</z><z id="t1525845322" t="soulflyer example pulled from: https://stackoverflow.com/questions/42889373/recursive-map-query-using-specter"><y>#</y><d>2018-05-09</d><h>05:55</h><r>soulflyer</r>example pulled from: <a href="https://stackoverflow.com/questions/42889373/recursive-map-query-using-specter" target="_blank">https://stackoverflow.com/questions/42889373/recursive-map-query-using-specter</a></z><z id="t1525868970" t="nathanmarz @soulflyer does it work if you refactor the recursive-path definition out of the select with a let or def?"><y>#</y><d>2018-05-09</d><h>12:29</h><w>nathanmarz</w>@soulflyer does it work if you refactor the recursive-path definition out of the select with a let or def?</z><z id="t1525872115" t="souenzzo Doing a cljsbuild with advanced May 09, 2018 1:13:26 PM com.google.javascript.jscomp.LoggerErrorManager printSummary WARNING: 1 error(s), 0 warning(s) ERROR: JSC_DUPLICATE_PARAM. Parse error. Duplicate parameter name &quot;G__13210_13216&quot; at /workspace/my-cool-project/target/cljsbuild-compiler-0/com/rpl/specter/impl.js line 543 : 32 [31mCompiling [&quot;resources/public/javascript/main.js&quot;] failed.[0m java.lang.Exception: Closure compilation failed It&apos;s a random error. Tryied to build again and it passes. Has anyone else ever had this problem? Using: [com.rpl/specter &quot;1.1.0&quot;] [org.clojure/clojurescript &quot;1.10.238&quot;] https://github.com/nathanmarz/specter/blob/1.1.0/src/clj/com/rpl/specter/impl.cljc#L543"><y>#</y><d>2018-05-09</d><h>13:21</h><w>souenzzo</w>Doing a cljsbuild with advanced
<pre>May 09, 2018 1:13:26 PM com.google.javascript.jscomp.LoggerErrorManager printSummary
WARNING: 1 error(s), 0 warning(s)
ERROR: JSC_DUPLICATE_PARAM. Parse error. Duplicate parameter name &quot;G__13210_13216&quot; at /workspace/my-cool-project/target/cljsbuild-compiler-0/com/rpl/specter/impl.js line 543 : 32
[31mCompiling [&quot;resources/public/javascript/main.js&quot;] failed.[0m
java.lang.Exception: Closure compilation failed
</pre>
It&apos;s a random error. Tryied to build again and it passes. Has anyone else ever had this problem?
Using: <code>[com.rpl/specter &quot;1.1.0&quot;] [org.clojure/clojurescript &quot;1.10.238&quot;]</code>
<a href="https://github.com/nathanmarz/specter/blob/1.1.0/src/clj/com/rpl/specter/impl.cljc#L543" target="_blank">https://github.com/nathanmarz/specter/blob/1.1.0/src/clj/com/rpl/specter/impl.cljc#L543</a></z><z id="t1525872381" t="soulflyer @nathanmarz yes, seems to work fine if I use def ."><y>#</y><d>2018-05-09</d><h>13:26</h><w>soulflyer</w>@nathanmarz yes, seems to work fine if I use <code>def</code>.</z><z id="t1525933461" t="soulflyer I&apos;m having trouble figuring out how to navigate to an entry that could have a variable number of steps. An individual navigate/transform is easy enough and looks something like this: (sp/transform [(node-named &quot;2002&quot;) :children (node-named &quot;01&quot;) :expanded] invert test-tree) However I need to be able to provide a path that could have from 1 to 4 entries. In the above example it would be [&quot;2002&quot; &quot;01&quot;] . What would be the best way to approach this? I tried building the navigator with for in a let statement like this: (defn toggle [tree path] (let [nav (conj (vec (interpose :children (for [p path] (conj (seq [p]) &apos;node-named )))) :expanded)] (sp/transform nav invert tree))) But although this gives me a value for nav that looks exactly right, running it throws Not a navigator errors"><y>#</y><d>2018-05-10</d><h>06:24</h><w>soulflyer</w>I&apos;m having trouble figuring out how to navigate to an entry that could have a variable number of steps. An individual navigate/transform  is easy enough and looks something like this:<pre>(sp/transform [(node-named &quot;2002&quot;) :children (node-named &quot;01&quot;) :expanded] invert test-tree)</pre>
However I need to be able to provide a path that could have from 1 to 4 entries. In the above example it would be <code>[&quot;2002&quot; &quot;01&quot;]</code>. What would be the best way to approach this?
I tried building the navigator with <code>for</code> in a <code>let</code> statement like this:<pre>(defn toggle [tree path]
  (let [nav (conj
              (vec
                (interpose :children (for [p path] (conj (seq [p]) &apos;node-named ))))
              :expanded)]
    (sp/transform nav invert tree)))
</pre>
But although this gives me a value for <code>nav</code> that looks exactly right, running it throws <code>Not a navigator</code> errors</z><z id="t1525933461" t="soulflyer I&apos;m having trouble figuring out how to navigate to an entry that could have a variable number of steps. An individual navigate/transform is easy enough and looks something like this: (sp/transform [(node-named &quot;2002&quot;) :children (node-named &quot;01&quot;) :expanded] invert test-tree) However I need to be able to provide a path that could have from 1 to 4 entries. In the above example it would be [&quot;2002&quot; &quot;01&quot;] . What would be the best way to approach this? I tried building the navigator with for in a let statement like this: (defn toggle [tree path] (let [nav (conj (vec (interpose :children (for [p path] (conj (seq [p]) &apos;node-named )))) :expanded)] (sp/transform nav invert tree))) But although this gives me a value for nav that looks exactly right, running it throws Not a navigator errors"><y>#</y><d>2018-05-10</d><h>06:24</h><w>soulflyer</w>I&apos;m having trouble figuring out how to navigate to an entry that could have a variable number of steps. An individual navigate/transform  is easy enough and looks something like this:<pre>(sp/transform [(node-named &quot;2002&quot;) :children (node-named &quot;01&quot;) :expanded] invert test-tree)</pre>
However I need to be able to provide a path that could have from 1 to 4 entries. In the above example it would be <code>[&quot;2002&quot; &quot;01&quot;]</code>. What would be the best way to approach this?
I tried building the navigator with <code>for</code> in a <code>let</code> statement like this:<pre>(defn toggle [tree path]
  (let [nav (conj
              (vec
                (interpose :children (for [p path] (conj (seq [p]) &apos;node-named ))))
              :expanded)]
    (sp/transform nav invert tree)))
</pre>
But although this gives me a value for <code>nav</code> that looks exactly right, running it throws <code>Not a navigator</code> errors</z><z id="t1525933607" t="soulflyer where node-named invert and test-tree are: (defn node-named [n] (sp/walker #(= (:name %) n))) (defn invert [b] (if b false true)) (def test-tree {:name &quot;root&quot; :focus [&quot;root&quot;] :expanded true :children [{:name &quot;2000&quot; :expanded true :children [{:name &quot;01&quot; :expanded true :children [{:name &quot;project-1&quot;} {:name &quot;project-2&quot;}]} {:name &quot;02&quot; :expanded true :children [{:name &quot;project-5&quot;} {:name &quot;project-6&quot;}]}]} {:name &quot;2002&quot; :expanded false :children [{:name &quot;01&quot; :expanded false :children []}]}]})"><y>#</y><d>2018-05-10</d><h>06:26</h><r>soulflyer</r>where <code>node-named</code> <code>invert</code> and <code>test-tree</code> are:<pre>(defn node-named [n]
  (sp/walker #(= (:name %) n)))

(defn invert [b]
  (if b false true))

(def test-tree
  {:name &quot;root&quot;
   :focus [&quot;root&quot;]
   :expanded true
   :children [{:name &quot;2000&quot;
               :expanded true
               :children [{:name &quot;01&quot;
                           :expanded true
                           :children [{:name &quot;project-1&quot;}
                                      {:name &quot;project-2&quot;}]}
                          {:name &quot;02&quot;
                           :expanded true
                           :children [{:name &quot;project-5&quot;}
                                      {:name &quot;project-6&quot;}]}]}
              {:name &quot;2002&quot;
               :expanded false
               :children [{:name &quot;01&quot;
                           :expanded false
                           :children []}]}]})</pre></z><z id="t1525939292" t="schmee try something like this: (defn navigator [strs] (path (mapcat (fn [s] [:children ALL #(= (:name %) s)]) strs))) "><y>#</y><d>2018-05-10</d><h>08:01</h><r>schmee</r>try something like this: 
<pre>(defn navigator [strs]
  (path (mapcat (fn [s] [:children ALL #(= (:name %) s)]) strs)))
</pre></z><z id="t1525939620" t="schmee also, the invert function can be replaced with the core function not 🙂"><y>#</y><d>2018-05-10</d><h>08:07</h><r>schmee</r>also, the <code>invert</code> function can be replaced with the core function <code>not</code> <b>🙂</b></z><z id="t1525941542" t="soulflyer @U3L6TFEJF That looks promising, thanks. I&apos;m getting the right node back now. Just got to massage it a bit to toggle :expanded. Which I will do with not 😳"><y>#</y><d>2018-05-10</d><h>08:39</h><r>soulflyer</r>@U3L6TFEJF That looks promising, thanks. I&apos;m getting the right node back now. Just got to massage it a bit to toggle :expanded. Which I will do with <code>not</code><b>😳</b></z><z id="t1525941592" t="schmee remember that you can compose paths with a simple vector: (transform [(navigator [&quot;2000&quot; &quot;01&quot;]) :expanded] not test-tree)"><y>#</y><d>2018-05-10</d><h>08:39</h><r>schmee</r>remember that you can compose paths with a simple vector: <pre>(transform [(navigator [&quot;2000&quot; &quot;01&quot;]) :expanded] not test-tree)</pre></z><z id="t1525942217" t="soulflyer yup, got it working now. Still waiting for the ah-ha moment with specter, but it is doing some useful things even though often I&apos;m not entirely sure why...."><y>#</y><d>2018-05-10</d><h>08:50</h><r>soulflyer</r>yup, got it working now. Still waiting for the ah-ha moment with specter, but it is doing some useful things even though often I&apos;m not entirely sure why....</z><z id="t1525945030" t="schmee stick with it! 🙂 like anything worth learning it takes practice but the payoff is worth it IMO"><y>#</y><d>2018-05-10</d><h>09:37</h><r>schmee</r>stick with it! <b>🙂</b> like anything worth learning it takes practice but the payoff is worth it IMO</z><z id="t1525945042" t="schmee you can always ask here if you get stuck :+1:"><y>#</y><d>2018-05-10</d><h>09:37</h><r>schmee</r>you can always ask here if you get stuck <b>:+1:</b></z><z id="t1526458197" t="montanonic I&apos;m new to Specter and trying to figure out how to express finding all of the numbers in deeply nested data, except for those that are nested within maps (at any depth) containing a particular value. Finding all the numbers is totally easy, (traverse (walker number?) data) , it&apos;s the filtering out part that I&apos;m struggling with."><y>#</y><d>2018-05-16</d><h>08:09</h><w>montanonic</w>I&apos;m new to Specter and trying to figure out how to express finding all of the numbers in deeply nested data, except for those that are nested within maps (at any depth) containing a particular value.

Finding all the numbers is totally easy, <code>(traverse (walker number?) data)</code>, it&apos;s the filtering out part that I&apos;m struggling with.</z><z id="t1526478924" t="nathanmarz @montanonic if you truly want to do a blind walk (including into map keys, key/value pairs) then you can do it like this: (def my-walker (recursive-path [afn] p (cond-path (pred afn) STAY map? [(not-selected? :key (pred= :val)) ALL p] coll? [ALL p] ))) "><y>#</y><d>2018-05-16</d><h>13:55</h><w>nathanmarz</w>@montanonic if you truly want to do a blind walk (including into map keys, key/value pairs) then you can do it like this:
<pre>(def my-walker
  (recursive-path [afn] p
    (cond-path (pred afn) STAY
               map? [(not-selected? :key (pred= :val)) ALL p]
               coll? [ALL p]
               )))
</pre></z><z id="t1526478978" t="nathanmarz if you have any structure to your data, I highly recommend making a path tailored as such"><y>#</y><d>2018-05-16</d><h>13:56</h><w>nathanmarz</w>if you have any structure to your data, I highly recommend making a path tailored as such</z><z id="t1526497573" t="montanonic The problem I&apos;m solving is just a for-fun code challenge with a pathologically nested data set; I&apos;m not sure how &quot;structured&quot; it is. Thanks for your help! I&apos;m going to need to spend a bit of time to understand what&apos;s going on there, particularly map? [(not-selected? :key (pred= :val)) ALL p]"><y>#</y><d>2018-05-16</d><h>19:06</h><w>montanonic</w>The problem I&apos;m solving is just a for-fun code challenge with a pathologically nested data set; I&apos;m not sure how &quot;structured&quot; it is. Thanks for your help! I&apos;m going to need to spend a bit of time to understand what&apos;s going on there, particularly <code>map? [(not-selected? :key (pred= :val)) ALL p]</code></z><z id="t1526498320" t="montanonic @nathanmarz Can you elaborate more on :key and :val in that code? Did you intend them to just be stand-ins? I also don&apos;t, in this case, need to consider map keys, only values."><y>#</y><d>2018-05-16</d><h>19:18</h><w>montanonic</w>@nathanmarz Can you elaborate more on <code>:key</code> and <code>:val</code> in that code? Did you intend them to just be stand-ins?

I also don&apos;t, in this case, need to consider map keys, only values.</z><z id="t1526498502" t="nathanmarz @montanonic yes, those are stand-ins"><y>#</y><d>2018-05-16</d><h>19:21</h><w>nathanmarz</w>@montanonic yes, those are stand-ins</z><z id="t1526498511" t="nathanmarz this is better: (def my-walker (recursive-path [afn avoid-key avoid-value] p (cond-path (pred afn) STAY map? [(not-selected? (keypath avoid-key) (pred= avoid-value)) MAP-VALS p] coll? [ALL p] ))) "><y>#</y><d>2018-05-16</d><h>19:21</h><w>nathanmarz</w>this is better:
<pre>(def my-walker
  (recursive-path [afn avoid-key avoid-value] p
    (cond-path (pred afn) STAY
               map? [(not-selected? (keypath avoid-key) (pred= avoid-value)) MAP-VALS p]
               coll? [ALL p]
               )))
</pre></z><z id="t1526498550" t="nathanmarz avoiding parts of data structures that are irrelevant makes a big impact on performance, and also avoids bugs"><y>#</y><d>2018-05-16</d><h>19:22</h><w>nathanmarz</w>avoiding parts of data structures that are irrelevant makes a big impact on performance, and also avoids bugs</z><z id="t1526498574" t="nathanmarz https://github.com/nathanmarz/specter/wiki/Cheat-Sheet is a good resource for learning what those navigators are"><y>#</y><d>2018-05-16</d><h>19:22</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/wiki/Cheat-Sheet" target="_blank">https://github.com/nathanmarz/specter/wiki/Cheat-Sheet</a> is a good resource for learning what those navigators are</z><z id="t1526498581" t="montanonic Since I&apos;m not concerned about the values of the keys themselves, would"><y>#</y><d>2018-05-16</d><h>19:23</h><w>montanonic</w>Since I&apos;m not concerned about the values of the keys themselves, would</z><z id="t1526498588" t="montanonic [(not-selected? (pred= avoid-value)) MAP-VALS p]"><y>#</y><d>2018-05-16</d><h>19:23</h><w>montanonic</w><code>[(not-selected? (pred= avoid-value)) MAP-VALS p]</code></z><z id="t1526498594" t="montanonic also work? sans (keypath avoid-key)"><y>#</y><d>2018-05-16</d><h>19:23</h><w>montanonic</w>also work? sans <code> (keypath avoid-key)</code></z><z id="t1526498627" t="montanonic Thanks for that resource! I&apos;ve been reading all the wiki pages repeatedly; they are very good; I just found my use-case to be one of the ones that was harder to figure out from them"><y>#</y><d>2018-05-16</d><h>19:23</h><w>montanonic</w>Thanks for that resource! I&apos;ve been reading all the wiki pages repeatedly; they are very good; I just found my use-case to be one of the ones that was harder to figure out from them</z><z id="t1526498649" t="nathanmarz if you&apos;re avoiding maps which contain a specific value for any key, then do [(not-selected? MAP-VALS (pred= avoid-value)) MAP-VALS p]"><y>#</y><d>2018-05-16</d><h>19:24</h><w>nathanmarz</w>if you&apos;re avoiding maps which contain a specific value for any key, then do <code>[(not-selected? MAP-VALS (pred= avoid-value)) MAP-VALS p]</code></z><z id="t1526498691" t="montanonic Okay, wonderful. Thank you!"><y>#</y><d>2018-05-16</d><h>19:24</h><w>montanonic</w>Okay, wonderful. Thank you!</z><z id="t1526498707" t="montanonic I think that makes total sense"><y>#</y><d>2018-05-16</d><h>19:25</h><w>montanonic</w>I think that makes total sense</z><z id="t1526498734" t="nathanmarz with practice this becomes very easy"><y>#</y><d>2018-05-16</d><h>19:25</h><w>nathanmarz</w>with practice this becomes very easy</z><z id="t1526498831" t="montanonic Wow, totally works. That&apos;s super great. I was struggling to figure out how to filter values, but I can see how selected and not-selected? help with that. Super!"><y>#</y><d>2018-05-16</d><h>19:27</h><w>montanonic</w>Wow, totally works. That&apos;s super great. I was struggling to figure out how to filter values, but I can see how <code>selected</code> and <code>not-selected?</code> help with that. Super!</z><z id="t1526505815" t="montanonic Is there a better way to collect multiple keys than: [ALL (collect-one :a) (collect-one :b) (collect-one :c)] , etc..?"><y>#</y><d>2018-05-16</d><h>21:23</h><w>montanonic</w>Is there a better way to collect multiple keys than: <code>[ALL (collect-one :a) (collect-one :b) (collect-one :c)]</code>, etc..?</z><z id="t1526505994" t="tanzoniteblack @montanonic (specter/collect (specter/multi-path :a :b :c))"><y>#</y><d>2018-05-16</d><h>21:26</h><w>tanzoniteblack</w>@montanonic <code>(specter/collect (specter/multi-path :a :b :c))</code></z><z id="t1526506008" t="montanonic Great! thanks 🙂"><y>#</y><d>2018-05-16</d><h>21:26</h><w>montanonic</w>Great! thanks <b>🙂</b></z><z id="t1526506028" t="tanzoniteblack (specter/select [specter/ALL (specter/collect (specter/multi-path :a :b :c))] [{:a &quot;cat&quot; :b &quot;dog&quot; :c &quot;c&quot;} {:a 1 :b 2 :c 3}]) ==&gt; [[[&quot;cat&quot; &quot;dog&quot; &quot;c&quot;] {:a &quot;cat&quot;, :b &quot;dog&quot;, :c &quot;c&quot;}] [[1 2 3] {:a 1, :b 2, :c 3}]]"><y>#</y><d>2018-05-16</d><h>21:27</h><w>tanzoniteblack</w><pre>(specter/select [specter/ALL (specter/collect (specter/multi-path :a :b :c))]
                [{:a &quot;cat&quot; :b &quot;dog&quot; :c &quot;c&quot;}
                 {:a 1 :b 2 :c 3}])</pre> ==&gt; <pre>[[[&quot;cat&quot; &quot;dog&quot; &quot;c&quot;] {:a &quot;cat&quot;, :b &quot;dog&quot;, :c &quot;c&quot;}]
 [[1 2 3] {:a 1, :b 2, :c 3}]]</pre></z><z id="t1526506044" t="tanzoniteblack thanks for asking, I&apos;d never actually tried that before"><y>#</y><d>2018-05-16</d><h>21:27</h><w>tanzoniteblack</w>thanks for asking, I&apos;d never actually tried that before</z><z id="t1526507157" t="nathanmarz @montanonic @tanzoniteblack can also use eachnav : (select-any [((eachnav collect-one) :a :b :c) :d] {:a 1 :b 2 :c 3 :d 4}) ;; =&gt; [1 2 3 4] "><y>#</y><d>2018-05-16</d><h>21:45</h><w>nathanmarz</w>@montanonic @tanzoniteblack can also use <code>eachnav</code>:
<pre>(select-any [((eachnav collect-one) :a :b :c) :d] {:a 1 :b 2 :c 3 :d 4})
;; =&gt; [1 2 3 4]
</pre></z><z id="t1526514103" t="montanonic Is there a more efficient or idiomatic way to do this with specter? (every? #(= 2 %) (select [MAP-VALS] coll)) That is: tell me if all of the values in a coll that is a map are equal to some value, in this case 2 ."><y>#</y><d>2018-05-16</d><h>23:41</h><w>montanonic</w>Is there a more efficient or idiomatic way to do this with specter?

<code>(every? #(= 2 %) (select [MAP-VALS] coll))</code>

That is: tell me if all of the values in a <code>coll</code> that is a map are equal to some value, in this case <code>2</code>.</z><z id="t1526515919" t="nathanmarz you could make it slightly more efficient with a version of every? that uses reduce"><y>#</y><d>2018-05-17</d><h>00:11</h><w>nathanmarz</w>you could make it slightly more efficient with a version of <code>every?</code> that uses reduce</z><z id="t1526515945" t="nathanmarz then you could use traverse : (every-reduce? #(= 2 %) (traverse [MAP-VALS] coll))"><y>#</y><d>2018-05-17</d><h>00:12</h><w>nathanmarz</w>then you could use <code>traverse</code>: <code>(every-reduce? #(= 2 %) (traverse [MAP-VALS] coll))</code></z><z id="t1526515958" t="nathanmarz traverse doesn&apos;t materialize any intermediate data structure"><y>#</y><d>2018-05-17</d><h>00:12</h><w>nathanmarz</w><code>traverse</code> doesn&apos;t materialize any intermediate data structure</z><z id="t1526516045" t="nathanmarz on second thought this is a much better approach: (not (selected-any? [MAP-VALS #(not= 2 %)] coll)) "><y>#</y><d>2018-05-17</d><h>00:14</h><w>nathanmarz</w>on second thought this is a much better approach:
<pre>(not (selected-any? [MAP-VALS #(not= 2 %)] coll))
</pre></z><z id="t1526516574" t="montanonic ahhh, nice. That&apos;s a good one"><y>#</y><d>2018-05-17</d><h>00:22</h><w>montanonic</w>ahhh, nice. That&apos;s a good one</z><z id="t1526565392" t="Casey Are there any projects with source available that use specter heavily? Would like to see how specter is used at large in a project"><y>#</y><d>2018-05-17</d><h>13:56</h><w>Casey</w>Are there any projects with source available that use specter heavily? Would like to see how specter is used at large in a project</z><z id="t1526566749" t="nathanmarz @ramblurr not that I&apos;m aware of, but at the end of this presentation I showed some of the ways I use it in production for manipulating dags https://www.youtube.com/watch?v=VTCy_DkAJGk]"><y>#</y><d>2018-05-17</d><h>14:19</h><w>nathanmarz</w>@ramblurr not that I&apos;m aware of, but at the end of this presentation I showed some of the ways I use it in production for manipulating dags <a href="https://www.youtube.com/watch?v=VTCy_DkAJGk]" target="_blank">https://www.youtube.com/watch?v=VTCy_DkAJGk]</a></z><z id="t1526567903" t="Casey thanks @nathanmarz"><y>#</y><d>2018-05-17</d><h>14:38</h><w>Casey</w>thanks @nathanmarz</z><z id="t1526683102" t="sophiago Question: I have a simple transform expression with a recursive navigator very similar to the one in the example that I&apos;m using in a macro to navigate to every symbol in an AST and replace parts of certain ones (unfortunately converting to and from strings and using regex since I only need to replace part of these symbols). I&apos;d also like it to jump one level up in the AST from each match, or more precisely group of matches with the same substring, and wrap it in a list at that point. Can anyone recommend a starting point for thinking about defining a relative path with specter like this? I would ideally like to avoid the perf overhead of two separate transform s."><y>#</y><d>2018-05-18</d><h>22:38</h><w>sophiago</w>Question: I have a simple <code>transform</code> expression with a recursive navigator very similar to the one in the example that I&apos;m using in a macro to navigate to every symbol in an AST and replace parts of certain ones (unfortunately converting to and from strings and using regex since I only need to replace part of these symbols). I&apos;d also like it to jump one level up in the AST from each match, or more precisely group of matches with the same substring, and wrap it in a list at that point. Can anyone recommend a starting point for thinking about defining a relative path with specter like this? I would ideally like to avoid the perf overhead of two separate <code>transform</code>s.</z><z id="t1526683764" t="sophiago Oh, and this also ignores the issue of wanting to group together multiple occurrences of the same substring. So the symbol added in the second transform should only ever be one, but the predicate would have to be modified to match on the collection above all other collections that contain that exact substring."><y>#</y><d>2018-05-18</d><h>22:49</h><w>sophiago</w>Oh, and this also ignores the issue of wanting to group together multiple occurrences of the same substring. So the symbol added in the second <code>transform</code> should only ever be one, but the predicate would have to be modified to match on the collection above all other collections that contain that exact substring.</z><z id="t1526684025" t="nathanmarz @sophiago that first one can be simplified to (setval [TREE NAME #&quot;p[1-9]&quot;] &quot;p&quot; (macroexpand x))"><y>#</y><d>2018-05-18</d><h>22:53</h><w>nathanmarz</w>@sophiago that first one can be simplified to <code>(setval [TREE NAME #&quot;p[1-9]&quot;] &quot;p&quot; (macroexpand x))</code></z><z id="t1526684086" t="sophiago @nathanmarz ah, thanks. I wrote this very late last night and was thinking I should have been able to do something like that"><y>#</y><d>2018-05-18</d><h>22:54</h><w>sophiago</w>@nathanmarz ah, thanks. I wrote this very late last night and was thinking I should have been able to do something like that</z><z id="t1526684124" t="sophiago I just posted an example of what that transform does with what I hope is a slightly better description of what I&apos;d like to add to it"><y>#</y><d>2018-05-18</d><h>22:55</h><w>sophiago</w>I just posted an example of what that <code>transform</code> does with what I hope is a slightly better description of what I&apos;d like to add to it</z><z id="t1526684197" t="sophiago (I also omitted mentioning I&apos;m using a fork of the compiler where the result would actually be valid...i.e. nested function literals where % shadow one another if necessary)"><y>#</y><d>2018-05-18</d><h>22:56</h><w>sophiago</w>(I also omitted mentioning I&apos;m using a fork of the compiler where the result would actually be valid...i.e. nested function literals where <code>%</code> shadow one another if necessary)</z><z id="t1526684236" t="nathanmarz not understanding what you&apos;re trying to do with that second transform"><y>#</y><d>2018-05-18</d><h>22:57</h><w>nathanmarz</w>not understanding what you&apos;re trying to do with that second transform</z><z id="t1526684264" t="sophiago Let me provide a more succinct and precise example"><y>#</y><d>2018-05-18</d><h>22:57</h><w>sophiago</w>Let me provide a more succinct and precise example</z><z id="t1526684326" t="sophiago There&apos;s one place in the macroexpansion above where the bound variable occurs twice: (*&apos;(long (. Math pow 10 (first p__13958#))) (second p__13958#))"><y>#</y><d>2018-05-18</d><h>22:58</h><w>sophiago</w>There&apos;s one place in the macroexpansion above where the bound variable occurs twice: <code>(*&apos;(long (. Math pow 10 (first p__13958#))) (second p__13958#))</code></z><z id="t1526684383" t="sophiago So, ideally in the same transform , I&apos;d like that to become: (fn* [p__13958#] (*&apos;(long (. Math pow 10 (first p__13958#))) (second p__13958#))"><y>#</y><d>2018-05-18</d><h>22:59</h><w>sophiago</w>So, ideally in the same <code>transform</code>, I&apos;d like that to become: <code>(fn* [p__13958#] (*&apos;(long (. Math pow 10 (first p__13958#))) (second p__13958#))</code></z><z id="t1526684441" t="sophiago The cases where the bound variables only appear once are simpler, although I&apos;m still unsure how to handle them in one pass with Specter"><y>#</y><d>2018-05-18</d><h>23:00</h><w>sophiago</w>The cases where the bound variables only appear once are simpler, although I&apos;m still unsure how to handle them in one pass with Specter</z><z id="t1526684466" t="nathanmarz so you want to collect every unique symbol starting with &quot;p&quot; and wrap the expression with (fn* [&lt;collected p&apos;s&gt;] ...) ?"><y>#</y><d>2018-05-18</d><h>23:01</h><w>nathanmarz</w>so you want to collect every unique symbol starting with &quot;p&quot; and wrap the expression with <code>(fn* [&lt;collected p&apos;s&gt;] ...)</code>?</z><z id="t1526684576" t="sophiago Yes, but only wrap the deepest subexpression where the symbols are exactly the same. But the numerals will never repeat in the input, so saying exact substrings is good enough."><y>#</y><d>2018-05-18</d><h>23:02</h><w>sophiago</w>Yes, but only wrap the deepest subexpression where the symbols are exactly the same. But the numerals will never repeat in the input, so saying exact substrings is good enough.</z><z id="t1526684630" t="nathanmarz for wrapping once you identify the subexpression you can do it like: (transform (collect TREE symbol? (selected? NAME #&quot;p[1-9]&quot;)) (fn [psyms expr] `(fn* ["><y>#</y><d>2018-05-18</d><h>23:03</h><w>nathanmarz</w>for wrapping once you identify the subexpression you can do it like:
<pre>(transform (collect TREE symbol? (selected? NAME #&quot;p[1-9]&quot;))
  (fn [psyms expr]
    `(fn* [</pre></z><z id="t1526684645" t="nathanmarz assuming TREE goes to every leaf"><y>#</y><d>2018-05-18</d><h>23:04</h><w>nathanmarz</w>assuming <code>TREE</code> goes to every leaf</z><z id="t1526684662" t="sophiago TREE goes to every coll currently"><y>#</y><d>2018-05-18</d><h>23:04</h><w>sophiago</w><code>TREE</code> goes to every coll currently</z><z id="t1526684675" t="nathanmarz as for &quot;deepest subexpression where the symbols are exactly the same&quot; that sounds like a more involved algorithm"><y>#</y><d>2018-05-18</d><h>23:04</h><w>nathanmarz</w>as for &quot;deepest subexpression where the symbols are exactly the same&quot; that sounds like a more involved algorithm</z><z id="t1526684695" t="nathanmarz the same &quot;p&quot; symbol could exist deeply nested across multiple branches"><y>#</y><d>2018-05-18</d><h>23:04</h><w>nathanmarz</w>the same &quot;p&quot; symbol could exist deeply nested across multiple branches</z><z id="t1526684702" t="sophiago Right, that&apos;s much more involved than simple one list up."><y>#</y><d>2018-05-18</d><h>23:05</h><w>sophiago</w>Right, that&apos;s much more involved than simple one list up.</z><z id="t1526684821" t="sophiago I can make some assumptions based on what would constitute valid input. For example, how px_foo means foo will always be the same for every x. Similarly, for each x: they&apos;ll be grouped together as far as depth in the entire AST (not sure whether that makes sense)."><y>#</y><d>2018-05-18</d><h>23:07</h><w>sophiago</w>I can make some assumptions based on what would constitute valid input. For example, how px_foo means foo will always be the same for every x. Similarly, for each x: they&apos;ll be grouped together as far as depth in the entire AST (not sure whether that makes sense).</z><z id="t1526684905" t="nathanmarz not really"><y>#</y><d>2018-05-18</d><h>23:08</h><w>nathanmarz</w>not really</z><z id="t1526684907" t="sophiago So both those in the example I pulled out started with p3. There would never be a p3 at a higher level of nesting or below the level where there&apos;s a p4. I&apos;m struggling for language to describe that. Like the &quot;x&quot; in &quot;px&quot; is monotonic with AST depth?"><y>#</y><d>2018-05-18</d><h>23:08</h><w>sophiago</w>So both those in the example I pulled out started with p3. There would never be a p3 at a higher level of nesting or below the level where there&apos;s a p4. I&apos;m struggling for language to describe that. Like the &quot;x&quot; in &quot;px&quot; is monotonic with AST depth?</z><z id="t1526684976" t="nathanmarz you mean the depth of the root of the subexpression containing all instances of pn is monotonic with n?"><y>#</y><d>2018-05-18</d><h>23:09</h><w>nathanmarz</w>you mean the depth of the root of the subexpression containing all instances of pn is monotonic with n?</z><z id="t1526684977" t="sophiago So when you mentioned multiple branches, I can actually ignore that. It&apos;s only a matter of variance in the number of lists you&apos;d need to jump up for the symbols to be in the same one."><y>#</y><d>2018-05-18</d><h>23:09</h><w>sophiago</w>So when you mentioned multiple branches, I can actually ignore that. It&apos;s only a matter of variance in the number of lists you&apos;d need to jump up for the symbols to be in the same one.</z><z id="t1526685027" t="sophiago &quot;depth of the root of the subexpression containing all instances of pn is monotonic with n&quot; =&gt; I believe this is exactly what I&apos;m stating"><y>#</y><d>2018-05-18</d><h>23:10</h><w>sophiago</w>&quot;depth of the root of the subexpression containing all instances of pn is monotonic with n&quot; =&gt; I believe this is exactly what I&apos;m stating</z><z id="t1526685057" t="sophiago Just some confusion over your use of the term &quot;root&quot;"><y>#</y><d>2018-05-18</d><h>23:10</h><w>sophiago</w>Just some confusion over your use of the term &quot;root&quot;</z><z id="t1526685126" t="nathanmarz the difference between: [:a [1 [2]] [1 [2]]] [:a [1 1] [[2] [2]]] "><y>#</y><d>2018-05-18</d><h>23:12</h><w>nathanmarz</w>the difference between:
<pre>[:a [1 [2]] [1 [2]]]

[:a [1 1] [[2] [2]]]
</pre></z><z id="t1526685144" t="nathanmarz in the first, the root for both is [:a [1 [2]] [1 [2]]]"><y>#</y><d>2018-05-18</d><h>23:12</h><w>nathanmarz</w>in the first, the root for both is <code>[:a [1 [2]] [1 [2]]]</code></z><z id="t1526685163" t="nathanmarz in the second, the root for &quot;1&quot; is [1 1] and for &quot;2&quot; [[2] [2]]"><y>#</y><d>2018-05-18</d><h>23:12</h><w>nathanmarz</w>in the second, the root for &quot;1&quot; is <code>[1 1]</code> and for &quot;2&quot; <code>[[2] [2]]</code></z><z id="t1526685169" t="nathanmarz is that what you&apos;re getting at?"><y>#</y><d>2018-05-18</d><h>23:12</h><w>nathanmarz</w>is that what you&apos;re getting at?</z><z id="t1526685185" t="sophiago Yes. You can assume it&apos;s like your second example."><y>#</y><d>2018-05-18</d><h>23:13</h><w>sophiago</w>Yes. You can assume it&apos;s like your second example.</z><z id="t1526685256" t="sophiago To backtrack a bit (no pun intended) in (setval [TREE NAME #&quot;p[1-9]&quot;] &quot;p&quot; (macroexpand x)) will &quot;p&quot; be made into a symbol or do I need to add that?"><y>#</y><d>2018-05-18</d><h>23:14</h><w>sophiago</w>To backtrack a bit (no pun intended) in <code>(setval [TREE NAME #&quot;p[1-9]&quot;] &quot;p&quot; (macroexpand x))</code> will &quot;p&quot; be made into a symbol or do I need to add that?</z><z id="t1526685281" t="sophiago I hate treating symbols as strings, but seems unavoidable here 😕"><y>#</y><d>2018-05-18</d><h>23:14</h><w>sophiago</w>I hate treating symbols as strings, but seems unavoidable here <b>😕</b></z><z id="t1526685365" t="sophiago To be clear, the transformation at that level is p3__13962# =&gt; p__13962#"><y>#</y><d>2018-05-18</d><h>23:16</h><w>sophiago</w>To be clear, the transformation at that level is p3__13962# =&gt; p__13962#</z><z id="t1526685716" t="nathanmarz it replaces the substring within the symbol"><y>#</y><d>2018-05-18</d><h>23:21</h><w>nathanmarz</w>it replaces the substring within the symbol</z><z id="t1526685732" t="nathanmarz behind the scenes NAME is extracting the string for the symbol&apos;s name, manipulating it, and then reconstructing the symbol"><y>#</y><d>2018-05-18</d><h>23:22</h><w>nathanmarz</w>behind the scenes <code>NAME</code> is extracting the string for the symbol&apos;s name, manipulating it, and then reconstructing the symbol</z><z id="t1526685778" t="sophiago Oh, that&apos;s awesome. Such a common pain point."><y>#</y><d>2018-05-18</d><h>23:22</h><w>sophiago</w>Oh, that&apos;s awesome. Such a common pain point.</z><z id="t1526685830" t="nathanmarz as for the subexpression identification part, that seems more involved"><y>#</y><d>2018-05-18</d><h>23:23</h><w>nathanmarz</w>as for the subexpression identification part, that seems more involved</z><z id="t1526685836" t="sophiago Also, in your second example, shouldn&apos;t [ be either {:tag :a, :attrs {:href &quot;/cdn-cgi/l/email-protection&quot;, :class &quot;__cf_email__&quot;, :data-cfemail &quot;f38db3&quot;}, :content (&quot;[email protected]&quot;)} or {:tag :a, :attrs {:href &quot;/cdn-cgi/l/email-protection&quot;, :class &quot;__cf_email__&quot;, :data-cfemail &quot;403e00&quot;}, :content (&quot;[email protected]&quot;)} ?"><y>#</y><d>2018-05-18</d><h>23:23</h><w>sophiago</w>Also, in your second example, shouldn&apos;t <code>[</code> be either <code>{:tag :a, :attrs {:href &quot;/cdn-cgi/l/email-protection&quot;, :class &quot;__cf_email__&quot;, :data-cfemail &quot;f38db3&quot;}, :content (&quot;[email protected]&quot;)}</code> or <code>{:tag :a, :attrs {:href &quot;/cdn-cgi/l/email-protection&quot;, :class &quot;__cf_email__&quot;, :data-cfemail &quot;403e00&quot;}, :content (&quot;[email protected]&quot;)}</code>?</z><z id="t1526685870" t="sophiago into or vec , I&apos;d have to look"><y>#</y><d>2018-05-18</d><h>23:24</h><w>sophiago</w><code>into</code> or <code>vec</code>, I&apos;d have to look</z><z id="t1526685885" t="nathanmarz /cdn-cgi/l/email-protection within [] uniques and puts all the symbols into a vector"><y>#</y><d>2018-05-18</d><h>23:24</h><w>nathanmarz</w><a href="/cdn-cgi/l/email-protection" target="_blank">/cdn-cgi/l/email-protection</a> within <code>[]</code> uniques and puts all the symbols into a vector</z><z id="t1526685915" t="sophiago Oh, I assumed you&apos;d end up with a set inside a vector"><y>#</y><d>2018-05-18</d><h>23:25</h><w>sophiago</w>Oh, I assumed you&apos;d end up with a set inside a vector</z><z id="t1526685928" t="nathanmarz that would be if you did ~psyms"><y>#</y><d>2018-05-18</d><h>23:25</h><w>nathanmarz</w>that would be if you did <code>~psyms</code></z><z id="t1526686094" t="sophiago I don&apos;t want to belabor that point, but you&apos;re saying psyms would evaluate to a set? My assumption was it would be like: [(set [&quot;foo&quot; &quot;foo&quot;])] =&gt; [#{&quot;foo&quot;}]"><y>#</y><d>2018-05-18</d><h>23:28</h><w>sophiago</w>I don&apos;t want to belabor that point, but you&apos;re saying <code>psyms</code> would evaluate to a set? My assumption was it would be like: <code>[(set [&quot;foo&quot; &quot;foo&quot;])]</code> =&gt; <code>[#{&quot;foo&quot;}]</code></z><z id="t1526686281" t="sophiago Also, I think depending on how your navigator in the second example works I may just be able to just apply another transform on TREE to expr to replace the values and that&apos;s all I need."><y>#</y><d>2018-05-18</d><h>23:31</h><w>sophiago</w>Also, I think depending on how your navigator in the second example works I may just be able to just apply another <code>transform</code> on <code>TREE</code> to <code>expr</code> to replace the values and that&apos;s all I need.</z><z id="t1526686435" t="nathanmarz oops meant to write ~(set psyms)"><y>#</y><d>2018-05-18</d><h>23:33</h><w>nathanmarz</w>oops meant to write <code>~(set psyms)</code></z><z id="t1526686463" t="sophiago Oh, okay. That makes more sense"><y>#</y><d>2018-05-18</d><h>23:34</h><w>sophiago</w>Oh, okay. That makes more sense</z><z id="t1526686504" t="sophiago I&apos;m thinking through what a navigator for even this example would need to look like. It is a bit more involved than I initially assumed"><y>#</y><d>2018-05-18</d><h>23:35</h><w>sophiago</w>I&apos;m thinking through what a navigator for even this example would need to look like. It is a bit more involved than I initially assumed</z><z id="t1526686644" t="sophiago For it to work top-down in one traversal, it would have to backtrack after it either reaches the next x in depth or the bottom of the tree. That&apos;s the only way to make sure it adds in each symbol in a fn* [..] at the correct level."><y>#</y><d>2018-05-18</d><h>23:37</h><w>sophiago</w>For it to work top-down in one traversal, it would have to backtrack after it either reaches the next x in depth or the bottom of the tree. That&apos;s the only way to make sure it adds in each symbol in a <code>fn* [..]</code> at the correct level.</z><z id="t1526686680" t="nathanmarz I&apos;ve done similar things with dags before"><y>#</y><d>2018-05-18</d><h>23:38</h><w>nathanmarz</w>I&apos;ve done similar things with dags before</z><z id="t1526686709" t="sophiago This all comes down to me not understanding Specter well enough to hack it out at this level of complexity"><y>#</y><d>2018-05-18</d><h>23:38</h><w>sophiago</w>This all comes down to me not understanding Specter well enough to hack it out at this level of complexity</z><z id="t1526686737" t="nathanmarz in that algorithm each node has an id, and I look at the list of node ids to the root from everything I&apos;m trying to find the lowest common root for"><y>#</y><d>2018-05-18</d><h>23:38</h><w>nathanmarz</w>in that algorithm each node has an id, and I look at the list of node ids to the root from everything I&apos;m trying to find the lowest common root for</z><z id="t1526686798" t="sophiago I can&apos;t tell whether that means it would work for my purposes as stands or not"><y>#</y><d>2018-05-18</d><h>23:39</h><w>sophiago</w>I can&apos;t tell whether that means it would work for my purposes as stands or not</z><z id="t1526686843" t="nathanmarz you could do it with multiple passes by annotating a generated id metadata to all subexpressions, then find the path of ids to each instance of &quot;p&quot; symbols"><y>#</y><d>2018-05-18</d><h>23:40</h><w>nathanmarz</w>you could do it with multiple passes by annotating a generated id metadata to all subexpressions, then find the path of ids to each instance of &quot;p&quot; symbols</z><z id="t1526686864" t="nathanmarz then with the paths its easy to identify which subexpressions to target in another pass"><y>#</y><d>2018-05-18</d><h>23:41</h><w>nathanmarz</w>then with the paths its easy to identify which subexpressions to target in another pass</z><z id="t1526686886" t="sophiago Oh, the problem with your example is when to stop recursing on expr because if I replace all the way down I&apos;ll screw up the next match"><y>#</y><d>2018-05-18</d><h>23:41</h><w>sophiago</w>Oh, the problem with your example is when to stop recursing on <code>expr</code> because if I replace all the way down I&apos;ll screw up the next match</z><z id="t1526686999" t="sophiago It does seem like multiple passes might be a good start. Then I can refactor to combine them. It&apos;s much easier if I can just have the navigator stop at the next px it sees."><y>#</y><d>2018-05-18</d><h>23:43</h><w>sophiago</w>It does seem like multiple passes might be a good start. Then I can refactor to combine them. It&apos;s much easier if I can just have the navigator stop at the next px it sees.</z><z id="t1526687071" t="sophiago Another way to break it down would be to apply the second transform before the first and use just two passes. Then it can add in the bindings at common roots and eliminate the numerals in symbols in the next pass."><y>#</y><d>2018-05-18</d><h>23:44</h><w>sophiago</w>Another way to break it down would be to apply the second <code>transform</code> before the first and use just two passes. Then it can add in the bindings at common roots and eliminate the numerals in symbols in the next pass.</z><z id="t1526687089" t="sophiago That seems to make the most sense from how I&apos;m grokking it now"><y>#</y><d>2018-05-18</d><h>23:44</h><w>sophiago</w>That seems to make the most sense from how I&apos;m grokking it now</z><z id="t1526690938" t="sophiago I&apos;m just trying to get a feel for picking out the roots by applying it to input that just uses literal variables, e.g. %1 , rather than an actual literal. But having it also expand -&gt;&gt; is making me unsure whether I&apos;m placing all the functions correctly. Regardless, they definitely should not be all stacked at the top in order of the transform calls like that."><y>#</y><d>2018-05-19</d><h>00:48</h><w>sophiago</w>I&apos;m just trying to get a feel for picking out the roots by applying it to input that just uses literal variables, e.g. <code>%1</code>, rather than an actual literal. But having it also expand <code>-&gt;&gt;</code> is making me unsure whether I&apos;m placing all the functions correctly. Regardless, they definitely should not be all stacked at the top in order of the <code>transform</code> calls like that.</z><z id="t1526691871" t="nathanmarz it doesn&apos;t identify common roots"><y>#</y><d>2018-05-19</d><h>01:04</h><w>nathanmarz</w>it doesn&apos;t identify common roots</z><z id="t1526691913" t="nathanmarz that snippet was just to show doing a transformation that wraps after identifying the expression to wrap"><y>#</y><d>2018-05-19</d><h>01:05</h><w>nathanmarz</w>that snippet was just to show doing a transformation that wraps after identifying the expression to wrap</z><z id="t1526692684" t="sophiago Okay, gotcha. I would think the way I&apos;m recursing on it would at least update at the next level up, though. Right now they&apos;re at the top-level. I may just be confused by the expanded -&gt;&gt; though..."><y>#</y><d>2018-05-19</d><h>01:18</h><w>sophiago</w>Okay, gotcha. I would think the way I&apos;m recursing on it would at least update at the next level up, though. Right now they&apos;re at the top-level. I may just be confused by the expanded <code>-&gt;&gt;</code> though...</z><z id="t1526693040" t="sophiago Yup, it&apos;s the expansion of -&gt;&gt; that&apos;s throwing me. I&apos;ll pay around with this and probably come back when I have something that works but seems could be more efficient. Thanks, @nathanmarz !"><y>#</y><d>2018-05-19</d><h>01:24</h><w>sophiago</w>Yup, it&apos;s the expansion of <code>-&gt;&gt;</code> that&apos;s throwing me. I&apos;ll pay around with this and probably come back when I have something that works but seems could be more efficient. Thanks, @nathanmarz !</z><z id="t1526752664" t="sophiago I&apos;m still a bit confused about a navigator for this. I&apos;m currently calling transform in multiple passes for each pattern and figure I can bypass having to find common root bindings by enforcing linearity but, e.g. (subselect TREE symbol? (selected? NAME pattern)) , navigates to a vector containing the first symbol matching the pattern rather than the coll containing that symbol."><y>#</y><d>2018-05-19</d><h>17:57</h><w>sophiago</w>I&apos;m still a bit confused about a navigator for this. I&apos;m currently calling <code>transform</code> in multiple passes for each pattern and figure I can bypass having to find common root bindings by enforcing linearity but, e.g. <code>(subselect TREE symbol? (selected? NAME pattern))</code>, navigates to a vector containing the first symbol matching the pattern rather than the coll containing that symbol.</z><z id="t1526752959" t="nathanmarz subselect navigates to the result of running select on that path"><y>#</y><d>2018-05-19</d><h>18:02</h><w>nathanmarz</w><code>subselect</code> navigates to the result of running <code>select</code> on that path</z><z id="t1526752961" t="nathanmarz (select-any (subselect ALL :a even?) [{:a 1} {:a 2} {:a 4}]) ;; =&gt; [2 4] (transform (subselect ALL :a even?) reverse [{:a 1} {:a 2} {:a 4}]) ;; =&gt; [{:a 1} {:a 4} {:a 2}] "><y>#</y><d>2018-05-19</d><h>18:02</h><w>nathanmarz</w><pre>(select-any (subselect ALL :a even?) [{:a 1} {:a 2} {:a 4}])
;; =&gt; [2 4]

(transform (subselect ALL :a even?) reverse [{:a 1} {:a 2} {:a 4}])
;; =&gt; [{:a 1} {:a 4} {:a 2}]
</pre></z><z id="t1526753086" t="sophiago Sorry, seems I misread the docs. Is there a navigator that will act like contains? on lists?"><y>#</y><d>2018-05-19</d><h>18:04</h><w>sophiago</w>Sorry, seems I misread the docs. Is there a navigator that will act like <code>contains?</code> on lists?</z><z id="t1526753136" t="nathanmarz contains? doesn&apos;t work on lists"><y>#</y><d>2018-05-19</d><h>18:05</h><w>nathanmarz</w><code>contains?</code> doesn&apos;t work on lists</z><z id="t1526753140" t="nathanmarz since it&apos;s not keyed"><y>#</y><d>2018-05-19</d><h>18:05</h><w>nathanmarz</w>since it&apos;s not keyed</z><z id="t1526753167" t="sophiago I know. I suppose like some"><y>#</y><d>2018-05-19</d><h>18:06</h><w>sophiago</w>I know. I suppose like <code>some</code></z><z id="t1526753180" t="nathanmarz you mean something like (selected? ALL even?) ?"><y>#</y><d>2018-05-19</d><h>18:06</h><w>nathanmarz</w>you mean something like <code>(selected? ALL even?)</code> ?</z><z id="t1526753288" t="sophiago I suppose if I could replace even? with a pattern and then navigate to top-most coll containing the pattern?"><y>#</y><d>2018-05-19</d><h>18:08</h><w>sophiago</w>I suppose if I could replace <code>even?</code> with a pattern and then navigate to top-most coll containing the pattern?</z><z id="t1526753326" t="sophiago I&apos;m realizing using let bindings for linearity throws a wrench in that, but I should be able to figure it out. Seems easier than finding common roots."><y>#</y><d>2018-05-19</d><h>18:08</h><w>sophiago</w>I&apos;m realizing using <code>let</code> bindings for linearity throws a wrench in that, but I should be able to figure it out. Seems easier than finding common roots.</z><z id="t1526753533" t="sophiago I would think I could just do (collect TREE (selected? symbol? NAME pattern)) where TREE navigates to every coll, but then it just stops at the top level every time."><y>#</y><d>2018-05-19</d><h>18:12</h><w>sophiago</w>I would think I could just do <code>(collect TREE (selected? symbol? NAME pattern))</code> where <code>TREE</code> navigates to every coll, but then it just stops at the top level every time.</z><z id="t1526754402" t="nathanmarz if TREE navigates to collections, then that selected? clause will always fail"><y>#</y><d>2018-05-19</d><h>18:26</h><w>nathanmarz</w>if <code>TREE</code> navigates to collections, then that <code>selected?</code> clause will always fail</z><z id="t1526754486" t="sophiago Ah, well that does seem to be what&apos;s happening. You&apos;re implying I could have it navigate to every item? I was thinking maybe I should just use a zipper and then could specify relative paths once a pattern is matched."><y>#</y><d>2018-05-19</d><h>18:28</h><w>sophiago</w>Ah, well that does seem to be what&apos;s happening. You&apos;re implying I could have it navigate to every item? I was thinking maybe I should just use a zipper and then could specify relative paths once a pattern is matched.</z><z id="t1526754492" t="nathanmarz user=&gt; (setval (selected? symbol?) :replaced [&apos;a 2 &apos;b]) [a 2 b] user=&gt; (setval (selected? ALL symbol?) :replaced [&apos;a 2 &apos;b]) :replaced "><y>#</y><d>2018-05-19</d><h>18:28</h><w>nathanmarz</w><pre>user=&gt; (setval (selected? symbol?) :replaced [&apos;a 2 &apos;b])
[a 2 b]
user=&gt; (setval (selected? ALL symbol?) :replaced [&apos;a 2 &apos;b])
:replaced
</pre></z><z id="t1526754627" t="sophiago If I can combine zipper navigators with regular ones then it would seem something like [TREE symbol? NAME pattern z/UP] might be the simplest way to do this."><y>#</y><d>2018-05-19</d><h>18:30</h><w>sophiago</w>If I can combine zipper navigators with regular ones then it would seem something like <code>[TREE symbol? NAME pattern z/UP]</code> might be the simplest way to do this.</z><z id="t1526754911" t="nathanmarz https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers"><y>#</y><d>2018-05-19</d><h>18:35</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers" target="_blank">https://github.com/nathanmarz/specter/wiki/Using-Specter-With-Zippers</a></z><z id="t1526754982" t="sophiago Yup, reading now."><y>#</y><d>2018-05-19</d><h>18:36</h><w>sophiago</w>Yup, reading now.</z><z id="t1526755279" t="sophiago I&apos;m just uncertain whether zipper navigators can be combined with regular ones. It&apos;d be much easier in this case than using predfns."><y>#</y><d>2018-05-19</d><h>18:41</h><w>sophiago</w>I&apos;m just uncertain whether zipper navigators can be combined with regular ones. It&apos;d be much easier in this case than using predfns.</z><z id="t1526755366" t="sophiago The answer would seem to be no based on the examples"><y>#</y><d>2018-05-19</d><h>18:42</h><w>sophiago</w>The answer would seem to be no based on the examples</z><z id="t1526756756" t="nathanmarz zipper navigators operate on zipper data structures"><y>#</y><d>2018-05-19</d><h>19:05</h><w>nathanmarz</w>zipper navigators operate on zipper data structures</z><z id="t1526756792" t="nathanmarz use navigators like VECTOR-ZIP and NODE to navigate in and out of zippers"><y>#</y><d>2018-05-19</d><h>19:06</h><w>nathanmarz</w>use navigators like <code>VECTOR-ZIP</code> and <code>NODE</code> to navigate in and out of zippers</z><z id="t1526757524" t="sophiago The structure that zippers return doesn&apos;t seem to make them ideal for use with transform though. I&apos;m having some luck with [ALL seq? (fn [x] some #(= % (symbol pattern)) x)] : on the first pass it at least matches the seq immediately above the pattern."><y>#</y><d>2018-05-19</d><h>19:18</h><w>sophiago</w>The structure that zippers return doesn&apos;t seem to make them ideal for use with <code>transform</code> though. I&apos;m having some luck with <code>[ALL seq? (fn [x] some #(= % (symbol pattern)) x)]</code>: on the first pass it at least matches the <code>seq</code> immediately above the pattern.</z><z id="t1526758093" t="nathanmarz you generally don&apos;t navigate to a zipper data structure for the transform fn, you use NODE to navigate into the value the zipper is currently pointing at"><y>#</y><d>2018-05-19</d><h>19:28</h><w>nathanmarz</w>you generally don&apos;t navigate to a zipper data structure for the transform fn, you use <code>NODE</code> to navigate into the value the zipper is currently pointing at</z></g><g id="s20"><z id="t1526758397" t="sophiago If I use NODE then it again locates the pattern rather than the seq containing the pattern, though."><y>#</y><d>2018-05-19</d><h>19:33</h><w>sophiago</w>If I use <code>NODE</code> then it again locates the pattern rather than the <code>seq</code> containing the pattern, though.</z><z id="t1526758432" t="sophiago So (select [SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) NODE] (list (list &apos;% &apos;foo))) =&gt; [%] rather than (% foo)"><y>#</y><d>2018-05-19</d><h>19:33</h><w>sophiago</w>So <code>(select [SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) NODE] (list (list &apos;% &apos;foo)))</code> =&gt; <code>[%]</code> rather than <code>(% foo)</code></z><z id="t1526758546" t="sophiago And if I use (select [SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) UP] (list (list &apos;% &apos;foo))) then it&apos;s not really in a form that I can call transform on."><y>#</y><d>2018-05-19</d><h>19:35</h><w>sophiago</w>And if I use <code>(select [SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) UP] (list (list &apos;% &apos;foo)))</code> then it&apos;s not really in a form that I can call <code>transform</code> on.</z><z id="t1526758625" t="sophiago I really just want something like [TREE symbol? NAME #&quot;%&quot;] except navigating to the seq containing the pattern."><y>#</y><d>2018-05-19</d><h>19:37</h><w>sophiago</w>I really just want something like <code>[TREE symbol? NAME #&quot;%&quot;]</code> except navigating to the seq containing the pattern.</z><z id="t1526758818" t="sophiago Obviously I can call ffirst on the zipper version, but that doesn&apos;t really help if I want to transform it preserving the structure it&apos;s in."><y>#</y><d>2018-05-19</d><h>19:40</h><w>sophiago</w>Obviously I can call <code>ffirst</code> on the zipper version, but that doesn&apos;t really help if I want to transform it preserving the structure it&apos;s in.</z><z id="t1526763562" t="nathanmarz @sophiago how is [SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) UP NODE] not exactly what you want?"><y>#</y><d>2018-05-19</d><h>20:59</h><w>nathanmarz</w>@sophiago how is <code>[SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) UP NODE]</code> not exactly what you want?</z><z id="t1526763572" t="nathanmarz it navigates to (% foo)"><y>#</y><d>2018-05-19</d><h>20:59</h><w>nathanmarz</w>it navigates to <code>(% foo)</code></z><z id="t1526763667" t="nathanmarz user=&gt; (transform [SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) UP NODE] #_=&gt; (fn [expr] #_=&gt; `(:wrapped ~expr)) #_=&gt; &apos;(+ 1 (% foo))) (+ 1 (:wrapped (% foo))) "><y>#</y><d>2018-05-19</d><h>21:01</h><w>nathanmarz</w><pre>user=&gt; (transform [SEQ-ZIP (find-first #(= % (symbol &quot;%&quot;))) UP NODE]
  #_=&gt;   (fn [expr]
  #_=&gt;     `(:wrapped ~expr))
  #_=&gt;   &apos;(+ 1 (% foo)))
(+ 1 (:wrapped (% foo)))
</pre></z><z id="t1526763710" t="sophiago I think I neglected to try that combination 😕"><y>#</y><d>2018-05-19</d><h>21:01</h><w>sophiago</w>I think I neglected to try that combination <b>😕</b></z><z id="t1526763719" t="sophiago One sec, I&apos;m trying it in the transform"><y>#</y><d>2018-05-19</d><h>21:01</h><w>sophiago</w>One sec, I&apos;m trying it in the <code>transform</code></z><z id="t1526763906" t="sophiago I think that&apos;s it 🙂"><y>#</y><d>2018-05-19</d><h>21:05</h><w>sophiago</w>I think that&apos;s it <b>🙂</b></z><z id="t1526763995" t="sophiago Oh, it&apos;s missing patterns inside let bindings. I knew that would be an issue when I decided on linearity"><y>#</y><d>2018-05-19</d><h>21:06</h><w>sophiago</w>Oh, it&apos;s missing patterns inside let bindings. I knew that would be an issue when I decided on linearity</z><z id="t1526764278" t="sophiago I think it may just work out that the bindings are at common roots as long as I call setval separately instead of from inside transform"><y>#</y><d>2018-05-19</d><h>21:11</h><w>sophiago</w>I think it may just work out that the bindings are at common roots as long as I call <code>setval</code> separately instead of from inside <code>transform</code></z><z id="t1526764625" t="nathanmarz fyi you can rewrite the transform like this: (transform [SEQ-ZIP (find-first #(= % (symbol pattern))) UP NODE (transformed [TREE symbol? NAME (re-pattern pattern)] (fn [_] (str fresh-var)))] #(list `fn* [fresh-var] %) x) "><y>#</y><d>2018-05-19</d><h>21:17</h><w>nathanmarz</w>fyi you can rewrite the <code>transform</code> like this:
<pre>(transform
  [SEQ-ZIP
   (find-first #(= % (symbol pattern)))
   UP
   NODE
   (transformed [TREE symbol? NAME (re-pattern pattern)]
     (fn [_] (str fresh-var)))]
  #(list `fn* [fresh-var] %)
  x)
</pre></z><z id="t1526765531" t="sophiago Yeah, the common roots issue is difficult and I can&apos;t get around it by using let bindings with linearity. But there&apos;s something deeper to say about what structures allow this navigator to finds them anyway and structures that cause trouble. Like I have one where a bound variable repeats and it&apos;s wrapped correctly and one where it&apos;s not. I tend to think the latter could be solved with destructuring in the example."><y>#</y><d>2018-05-19</d><h>21:32</h><w>sophiago</w>Yeah, the common roots issue is difficult and I can&apos;t get around it by using let bindings with linearity. But there&apos;s something deeper to say about what structures allow this navigator to finds them anyway and structures that cause trouble. Like I have one where a bound variable repeats and it&apos;s wrapped correctly and one where it&apos;s not. I tend to think the latter could be solved with destructuring in the example.</z><z id="t1526765804" t="sophiago I think it actually comes down to currying. The one where it doesn&apos;t naturally find a root needs to be a binary function for map-indexed . Calling first and second after interleaving and partitioning to use plain map creates the same type of structure."><y>#</y><d>2018-05-19</d><h>21:36</h><w>sophiago</w>I think it actually comes down to currying. The one where it doesn&apos;t naturally find a root needs to be a binary function for <code>map-indexed</code>. Calling <code>first</code> and <code>second</code> after interleaving and partitioning to use plain <code>map</code> creates the same type of structure.</z><z id="t1526993315" t="flowthing So I have a map like this: {&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}} . I need to transform &quot;foo&quot; , but I need to collect some of the map keys (`&quot;2018-05-22&quot;` and :A ) along the way for the transformation function and I can&apos;t quite figure out how to do it."><y>#</y><d>2018-05-22</d><h>12:48</h><w>flowthing</w>So I have a map like this: <code>{&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}}</code>. I need to transform <code>&quot;foo&quot;</code>, but I need to collect some of the map keys (`&quot;2018-05-22&quot;` and <code>:A</code>) along the way for the transformation function and I can&apos;t quite figure out how to do it.</z><z id="t1526998732" t="nathanmarz @flowthing How do you need to navigate to &quot;foo&quot;? Recursively?"><y>#</y><d>2018-05-22</d><h>14:18</h><w>nathanmarz</w>@flowthing How do you need to navigate to &quot;foo&quot;? Recursively?</z><z id="t1526998972" t="flowthing With MAP-VALS . Basically, I&apos;m doing something like this: (specter/transform [specter/MAP-VALS specter/MAP-VALS specter/MAP-VALS] (fn [&amp; args] ,,,) {&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}}) And I&apos;m wondering whether I can write the path such that the transformation fn gets &quot;2018-05-22&quot; and :A as arguments (in addition to &quot;foo&quot; )."><y>#</y><d>2018-05-22</d><h>14:22</h><w>flowthing</w>With <code>MAP-VALS</code>. Basically, I&apos;m doing something like this:

<pre>(specter/transform [specter/MAP-VALS specter/MAP-VALS specter/MAP-VALS] (fn [&amp; args] ,,,) {&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}})
</pre>

And I&apos;m wondering whether I can write the path such that the transformation fn gets <code>&quot;2018-05-22&quot;</code> and <code>:A</code> as arguments (in addition to <code>&quot;foo&quot;</code>).</z><z id="t1526999151" t="nathanmarz @flowthing yes, you want to make use of collection navigators"><y>#</y><d>2018-05-22</d><h>14:25</h><w>nathanmarz</w>@flowthing yes, you want to make use of collection navigators</z><z id="t1526999153" t="nathanmarz (def MAP-VALS+ (path ALL (collect-one FIRST) LAST)) (transform [MAP-VALS+ MAP-VALS+ MAP-VALS] (fn [k1 k2 v] [k1 k2 v] ) {&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}}) "><y>#</y><d>2018-05-22</d><h>14:25</h><w>nathanmarz</w><pre>(def MAP-VALS+ (path ALL (collect-one FIRST) LAST))
(transform [MAP-VALS+ MAP-VALS+ MAP-VALS]
  (fn [k1 k2 v]
    [k1 k2 v]
    )
  {&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}})
</pre></z><z id="t1526999821" t="flowthing Perfect, thank you!"><y>#</y><d>2018-05-22</d><h>14:37</h><w>flowthing</w>Perfect, thank you!</z><z id="t1526999883" t="flowthing I couldn&apos;t figure out how to compose MAP-VALS+ myself."><y>#</y><d>2018-05-22</d><h>14:38</h><w>flowthing</w>I couldn&apos;t figure out how to compose <code>MAP-VALS+</code> myself.</z><z id="t1527033801" t="sophiago @nathanmarz ironically enough I needed to also write a version of the macro I was struggling with over the weekend that does just stack the lambda bindings at the top of the AST and replaces all instances of corresponding locals. I did this as before by calling setval from inside transform , which I get the sense is not an ideal way to use Specter, but don&apos;t fully understand how you rewrote it to use transformed inside the navigator."><y>#</y><d>2018-05-23</d><h>00:03</h><w>sophiago</w>@nathanmarz ironically enough I needed to also write a version of the macro I was struggling with over the weekend that does just stack the lambda bindings at the top of the AST and replaces all instances of corresponding locals. I did this as before by calling <code>setval</code> from inside <code>transform</code>, which I get the sense is not an ideal way to use Specter, but don&apos;t fully understand how you rewrote it to use <code>transformed</code> inside the navigator.</z><z id="t1527042259" t="nathanmarz @sophiago it&apos;ll be easier to understand the navigators if you play with them on toy examples"><y>#</y><d>2018-05-23</d><h>02:24</h><w>nathanmarz</w>@sophiago it&apos;ll be easier to understand the navigators if you play with them on toy examples</z><z id="t1527042905" t="sophiago True. I tell myself I&apos;m testing these on the simplest functions, but they&apos;re still macros doing fairly heavy source transformation. It seems clear the issue here is that I&apos;m trying to apply transformed directly to a symbol, and only the first one that matches as well, rather than in example you gave where it&apos;s one level up from the node in a zipper."><y>#</y><d>2018-05-23</d><h>02:35</h><w>sophiago</w>True. I tell myself I&apos;m testing these on the simplest functions, but they&apos;re still macros doing fairly heavy source transformation. It seems clear the issue here is that I&apos;m trying to apply <code>transformed</code> directly to a symbol, and only the first one that matches as well, rather than in example you gave where it&apos;s one level up from the node in a zipper.</z><z id="t1527043124" t="sophiago I suppose it&apos;s just the combination of learning what&apos;s essentially a whole DSL and wanting to use it immediately given how well it fits so many of my problems. For example, it would seem calling setval from inside transform as in the first example shouldn&apos;t cause a significant hit in perf, but I&apos;d have to actually look at your macros or at least reread the wiki page about caching to make that judgment for sure. At least your docs are quite good 🙂"><y>#</y><d>2018-05-23</d><h>02:38</h><w>sophiago</w>I suppose it&apos;s just the combination of learning what&apos;s essentially a whole DSL and wanting to use it immediately given how well it fits so many of my problems. For example, it would seem calling <code>setval</code> from inside <code>transform</code> as in the first example shouldn&apos;t cause a significant hit in perf, but I&apos;d have to actually look at your macros or at least reread the wiki page about caching to make that judgment for sure. At least your docs are quite good <b>🙂</b></z><z id="t1527106169" t="huthayfa hello guys, I am new to specter library. does anyone of you know which function is used to navigate the entire data structure tree and manipulate specific key"><y>#</y><d>2018-05-23</d><h>20:09</h><w>huthayfa</w>hello guys, I am new to specter library. does anyone of you know which function is used to navigate the entire data structure tree and manipulate specific key</z><z id="t1527106280" t="huthayfa without providing a path to the key"><y>#</y><d>2018-05-23</d><h>20:11</h><w>huthayfa</w>without providing a path to the key</z><z id="t1527106287" t="tanzoniteblack @huthayfa.ainqawi that&apos;s a little vague, can you give a minimal example of what you&apos;re working with and what you&apos;re trying to get to?"><y>#</y><d>2018-05-23</d><h>20:11</h><w>tanzoniteblack</w>@huthayfa.ainqawi that&apos;s a little vague, can you give a minimal example of what you&apos;re working with and what you&apos;re trying to get to?</z><z id="t1527106335" t="huthayfa { &quot;key&quot;: &quot;hsq.contentjsonsample.sampleKey&quot;, &quot;value&quot;: { &quot;links&quot;:[{&quot;text&quot;:&quot;anytext&quot;,&quot;url&quot;:&quot; http://nowhere.com &quot;,&quot;precedence&quot;:&quot;1&quot;},{&quot;text&quot;:&quot;anytext&quot;,&quot;url&quot;:&quot; http://nowhere.com &quot;,&quot;precedence&quot;:&quot;2&quot;}], &quot;misc&quot;:[{&quot;key&quot;:&quot;keyName&quot;,&quot;value&quot;:&quot;valuessssssss&quot;},{&quot;key&quot;:&quot;keyName&quot;,&quot;value&quot;:&quot;valuessssssss&quot;}], &quot;assets&quot;:[{&quot;name&quot;:&quot;facebooklogo&quot;,&quot;location&quot;:&quot;/s3/cmb/facebooklogo.png&quot;,&quot;type&quot;:&quot;image&quot;},{&quot;name&quot;:&quot;mypdf&quot;,&quot;location&quot;:&quot;/pdfLocation&quot;,&quot;type&quot;:&quot;pdf&quot;}], }, &quot;language&quot;:&quot;EN&quot;, &quot;shortName&quot;: &quot;my Sample Json key&quot;, &quot;description&quot;: &quot;my Sample Json key explain why this key&quot; }"><y>#</y><d>2018-05-23</d><h>20:12</h><w>huthayfa</w>{
            &quot;key&quot;: &quot;hsq.contentjsonsample.sampleKey&quot;,
            &quot;value&quot;: {
               &quot;links&quot;:[{&quot;text&quot;:&quot;anytext&quot;,&quot;url&quot;:&quot;<a href="http://nowhere.com" target="_blank">http://nowhere.com</a>&quot;,&quot;precedence&quot;:&quot;1&quot;},{&quot;text&quot;:&quot;anytext&quot;,&quot;url&quot;:&quot;<a href="http://nowhere.com" target="_blank">http://nowhere.com</a>&quot;,&quot;precedence&quot;:&quot;2&quot;}],
               &quot;misc&quot;:[{&quot;key&quot;:&quot;keyName&quot;,&quot;value&quot;:&quot;valuessssssss&quot;},{&quot;key&quot;:&quot;keyName&quot;,&quot;value&quot;:&quot;valuessssssss&quot;}],
               &quot;assets&quot;:[{&quot;name&quot;:&quot;facebooklogo&quot;,&quot;location&quot;:&quot;/s3/cmb/facebooklogo.png&quot;,&quot;type&quot;:&quot;image&quot;},{&quot;name&quot;:&quot;mypdf&quot;,&quot;location&quot;:&quot;/pdfLocation&quot;,&quot;type&quot;:&quot;pdf&quot;}],
             },
            &quot;language&quot;:&quot;EN&quot;,
            &quot;shortName&quot;: &quot;my Sample Json key&quot;,
            &quot;description&quot;: &quot;my Sample Json key explain why this key&quot;
          }</z><z id="t1527106366" t="huthayfa wherever there is assets key, I want to manipulate it"><y>#</y><d>2018-05-23</d><h>20:12</h><w>huthayfa</w>wherever there is assets key, I want to manipulate it</z><z id="t1527106379" t="tanzoniteblack I suspect you want https://github.com/nathanmarz/specter/wiki/List-of-Navigators#walker"><y>#</y><d>2018-05-23</d><h>20:12</h><w>tanzoniteblack</w>I suspect you want <a href="https://github.com/nathanmarz/specter/wiki/List-of-Navigators#walker" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Navigators#walker</a></z><z id="t1527106484" t="tanzoniteblack that said, walker is generally something I consider a &quot;I have no idea what data&apos;s coming in, and I have no control over the format, and I&apos;m ok with accidentally manipulating other keys that just happen to be called that&quot;, which is pretty heavy handed &amp; crude"><y>#</y><d>2018-05-23</d><h>20:14</h><w>tanzoniteblack</w>that said, <code>walker</code> is generally something I consider a &quot;I have no idea what data&apos;s coming in, and I have no control over the format, and I&apos;m ok with accidentally manipulating other keys that just happen to be called that&quot;, which is pretty heavy handed &amp; crude</z><z id="t1527106529" t="tanzoniteblack so if you can narrow your path down to more (like, assets will always be inside a map stored at links , or something) it can help to prevent random bugs"><y>#</y><d>2018-05-23</d><h>20:15</h><w>tanzoniteblack</w>so if you can narrow your path down to more (like, <code>assets</code> will always be inside a map stored at <code>links</code>, or something) it can help to prevent random bugs</z><z id="t1527106544" t="schmee you don’t need specter for this, you can use update from core: (update your-map :assets update-fn)"><y>#</y><d>2018-05-23</d><h>20:15</h><w>schmee</w>you don’t need specter for this, you can use <code>update</code> from core: <code>(update your-map :assets update-fn)</code></z><z id="t1527106577" t="tanzoniteblack @schmee update will only do it if you are directly manipulating a map, not if you need to find a map nested in a bigger data structure"><y>#</y><d>2018-05-23</d><h>20:16</h><w>tanzoniteblack</w>@schmee <code>update</code> will only do it if you are directly manipulating a map, not if you need to find a map nested in a bigger data structure</z><z id="t1527106589" t="huthayfa @schmee does update do a nested map search"><y>#</y><d>2018-05-23</d><h>20:16</h><w>huthayfa</w>@schmee does update do a nested map search</z><z id="t1527106589" t="tanzoniteblack (or multiple maps nested in a bigger structure)"><y>#</y><d>2018-05-23</d><h>20:16</h><w>tanzoniteblack</w>(or multiple maps nested in a bigger structure)</z><z id="t1527106646" t="schmee well, you need to specify what this larger data structure looks like in order to get a sensible answer"><y>#</y><d>2018-05-23</d><h>20:17</h><w>schmee</w>well, you need to specify what this larger data structure looks like in order to get a sensible answer</z><z id="t1527106683" t="huthayfa I don&apos;t know where the assets happen in the structure, maybe at second or third level"><y>#</y><d>2018-05-23</d><h>20:18</h><w>huthayfa</w>I don&apos;t know where the assets happen in the structure, maybe at second or third level</z><z id="t1527106690" t="huthayfa it depends on the jsonSchema"><y>#</y><d>2018-05-23</d><h>20:18</h><w>huthayfa</w>it depends on the jsonSchema</z><z id="t1527107099" t="nathanmarz @huthayfa.ainqawi this code will run on every nested assets key with a walk that descends into all collections and map values (but not map keys): (def NESTED-MAPS (recursive-path [] p (cond-path map? (continue-then-stay MAP-VALS p) coll? [ALL p] ))) (transform [NESTED-MAPS (must &quot;assets&quot;)] my-transform-fn data) "><y>#</y><d>2018-05-23</d><h>20:24</h><w>nathanmarz</w>@huthayfa.ainqawi this code will run on every nested assets key with a walk that descends into all collections and map values (but not map keys):
<pre>(def NESTED-MAPS
  (recursive-path [] p
    (cond-path map? (continue-then-stay MAP-VALS p)
               coll? [ALL p]
               )))

(transform [NESTED-MAPS (must &quot;assets&quot;)] my-transform-fn data)
</pre></z><z id="t1527107289" t="huthayfa so the value returned from the NESTED-MAPS will replace the current value, right ?"><y>#</y><d>2018-05-23</d><h>20:28</h><w>huthayfa</w>so the value returned from the NESTED-MAPS will replace the current value, right ?</z><z id="t1527107336" t="huthayfa @nathanmarz"><y>#</y><d>2018-05-23</d><h>20:28</h><w>huthayfa</w>@nathanmarz</z><z id="t1527107450" t="huthayfa oh sorry, I didn&apos;t see my-transform-fn"><y>#</y><d>2018-05-23</d><h>20:30</h><w>huthayfa</w>oh sorry, I didn&apos;t see my-transform-fn</z><z id="t1527107465" t="huthayfa @nathanmarz thank you so much"><y>#</y><d>2018-05-23</d><h>20:31</h><w>huthayfa</w>@nathanmarz thank you so much</z><z id="t1527196608" t="huthayfa is there a function to collect the path to a given key"><y>#</y><d>2018-05-24</d><h>21:16</h><w>huthayfa</w>is there a function to collect the path to a given key</z><z id="t1527196928" t="huthayfa if i have map like this {&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot;}}}, I want to collect the path to target-key which is [properties assets target-key]"><y>#</y><d>2018-05-24</d><h>21:22</h><w>huthayfa</w>if i have map like this {&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot;}}}, I want to collect the path to target-key which is [properties assets target-key]</z><z id="t1527196944" t="huthayfa is there a function in specter that does this"><y>#</y><d>2018-05-24</d><h>21:22</h><w>huthayfa</w>is there a function in specter that does this</z><z id="t1527199122" t="nathanmarz @huthayfa.ainqawi use the collect navigators"><y>#</y><d>2018-05-24</d><h>21:58</h><w>nathanmarz</w>@huthayfa.ainqawi use the <code>collect</code> navigators</z><z id="t1527199155" t="nathanmarz someone just asked this recently"><y>#</y><d>2018-05-24</d><h>21:59</h><w>nathanmarz</w>someone just asked this recently</z><z id="t1527199164" t="nathanmarz here&apos;s a code example: (def MAP-VALS+ (path ALL (collect-one FIRST) LAST)) (transform [MAP-VALS+ MAP-VALS+ MAP-VALS] (fn [k1 k2 v] [k1 k2 v] ) {&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}}) "><y>#</y><d>2018-05-24</d><h>21:59</h><w>nathanmarz</w>here&apos;s a code example:
<pre>(def MAP-VALS+ (path ALL (collect-one FIRST) LAST))
(transform [MAP-VALS+ MAP-VALS+ MAP-VALS]
  (fn [k1 k2 v]
    [k1 k2 v]
    )
  {&quot;2018-05-22&quot; {:A {123 &quot;foo&quot;}}})
</pre></z><z id="t1527201154" t="huthayfa @nathanmarz how do I select the target key"><y>#</y><d>2018-05-24</d><h>22:32</h><w>huthayfa</w>@nathanmarz how do I select the target key</z><z id="t1527208411" t="nathanmarz @huthayfa.ainqawi it&apos;ll be easier to help you if you give an example of the input and output you want"><y>#</y><d>2018-05-25</d><h>00:33</h><w>nathanmarz</w>@huthayfa.ainqawi it&apos;ll be easier to help you if you give an example of the input and output you want</z><z id="t1527213654" t="huthayfa @nathanmarz input {&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot;}}} output: [properties assets target-key]"><y>#</y><d>2018-05-25</d><h>02:00</h><w>huthayfa</w>@nathanmarz input  {&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot;}}}  output: [properties assets target-key]</z><z id="t1527213690" t="huthayfa input ({&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot;}}}, target-key) output: [properties assets target-key]"><y>#</y><d>2018-05-25</d><h>02:01</h><w>huthayfa</w>input  ({&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot;}}}, target-key)   output: [properties assets target-key]</z><z id="t1527216147" t="nathanmarz @huthayfa.ainqawi that input isn&apos;t well formed"><y>#</y><d>2018-05-25</d><h>02:42</h><w>nathanmarz</w>@huthayfa.ainqawi that input isn&apos;t well formed</z><z id="t1527218427" t="huthayfa input ({&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot; &quot;value&quot;}}}, target-key) nested map"><y>#</y><d>2018-05-25</d><h>03:20</h><w>huthayfa</w>input  ({&quot;properties&quot;: { &quot;assets&quot;: {&quot;target-key&quot; &quot;value&quot;}}}, target-key) nested map</z><z id="t1527252214" t="fmn Hi, how do you navigate data structures with specter lazily? What I&apos;m trying to do is select the first item with matching predicate like this: (-&gt;&gt; very-long-vector (transform [ALL] my-fn) (select-first [ALL my-pred?])) I believe doing that won&apos;t be very efficient since specter will &quot;realize&quot; each step"><y>#</y><d>2018-05-25</d><h>12:43</h><w>fmn</w>Hi, how do you navigate data structures with specter lazily? What I&apos;m trying to do is select the first item with matching predicate like this:

<pre>(-&gt;&gt; very-long-vector
     (transform [ALL] my-fn)
     (select-first [ALL my-pred?]))
</pre>

I believe doing that won&apos;t be very efficient since specter will &quot;realize&quot; each step</z><z id="t1527254580" t="nathanmarz @funyako.funyao156 there is no lazy computation with specter"><y>#</y><d>2018-05-25</d><h>13:23</h><w>nathanmarz</w>@funyako.funyao156 there is no lazy computation with specter</z><z id="t1527254614" t="nathanmarz but if you do (select-first [ALL (view my-fn) my-pred?] very-long-vector) it will stop traversing the vector as soon as my-pred? is satisfied"><y>#</y><d>2018-05-25</d><h>13:23</h><w>nathanmarz</w>but if you do <code>(select-first [ALL (view my-fn) my-pred?] very-long-vector)</code> it will stop traversing the vector as soon as <code>my-pred?</code> is satisfied</z><z id="t1527255791" t="fmn @nathanmarz so the select-first behave similar to (first (filter pred ...)) in terms of &quot;lazy like&quot; ? Thanks!"><y>#</y><d>2018-05-25</d><h>13:43</h><w>fmn</w>@nathanmarz so the <code>select-first</code> behave similar to <code>(first (filter pred ...))</code> in terms of &quot;lazy like&quot; ? Thanks!</z><z id="t1527258007" t="nathanmarz @funyako.funyao156 it works via early termination"><y>#</y><d>2018-05-25</d><h>14:20</h><w>nathanmarz</w>@funyako.funyao156 it works via early termination</z><z id="t1527258041" t="nathanmarz it uses reduced /`reduced?` under the hood"><y>#</y><d>2018-05-25</d><h>14:20</h><w>nathanmarz</w>it uses <code>reduced</code>/`reduced?` under the hood</z><z id="t1527258152" t="fmn @nathanmarz Thanks alot for answering me! Last one, sorry if I ask a lot. How do you return default value using select-first if no matching element found, for example: (select-first [ALL keyword? (nil-&gt;val :foo/bar)] [1 2 3]) That still return a nil."><y>#</y><d>2018-05-25</d><h>14:22</h><w>fmn</w>@nathanmarz Thanks alot for answering me! Last one, sorry if I ask a lot. How do you return default value using <code>select-first</code> if no matching element found, for example:

<pre>(select-first [ALL keyword? (nil-&gt;val :foo/bar)] [1 2 3])
</pre>

That still return a nil.</z><z id="t1527258481" t="nathanmarz that code never gets to the nil-&gt;val navigator since keyword? filters everything out"><y>#</y><d>2018-05-25</d><h>14:28</h><w>nathanmarz</w>that code never gets to the <code>nil-&gt;val</code> navigator since <code>keyword?</code> filters everything out</z><z id="t1527258501" t="nathanmarz you can just do (or (select-first [ALL keyword?] [1 2 3]) :foo/bar)"><y>#</y><d>2018-05-25</d><h>14:28</h><w>nathanmarz</w>you can just do <code>(or (select-first [ALL keyword?] [1 2 3]) :foo/bar)</code></z><z id="t1527258548" t="fmn Right, silly me. Sorry I ask alot! Thanks again!"><y>#</y><d>2018-05-25</d><h>14:29</h><w>fmn</w>Right, silly me. Sorry I ask alot! Thanks again!</z><z id="t1527258624" t="nathanmarz no problem, that&apos;s what this channel is for"><y>#</y><d>2018-05-25</d><h>14:30</h><w>nathanmarz</w>no problem, that&apos;s what this channel is for</z><z id="t1527258764" t="nathanmarz @huthayfa.ainqawi user=&gt; (def MAP-VALS+ (path ALL (collect-one FIRST) LAST)) #&apos;user/MAP-VALS+ user=&gt; (select-any [MAP-VALS+ MAP-VALS+ MAP-KEYS] {&quot;properties&quot; { &quot;assets&quot; {&quot;target-key&quot; &quot;value&quot;}}}) [&quot;properties&quot; &quot;assets&quot; &quot;target-key&quot;] "><y>#</y><d>2018-05-25</d><h>14:32</h><w>nathanmarz</w>@huthayfa.ainqawi 
<pre>user=&gt; (def MAP-VALS+ (path ALL (collect-one FIRST) LAST))
#&apos;user/MAP-VALS+
user=&gt; (select-any [MAP-VALS+ MAP-VALS+ MAP-KEYS] {&quot;properties&quot; { &quot;assets&quot; {&quot;target-key&quot; &quot;value&quot;}}})
[&quot;properties&quot; &quot;assets&quot; &quot;target-key&quot;]
</pre></z><z id="t1527709062" t="johanatan has anyone tried 1.1.1 w/ deps.edn and lumo ?"><y>#</y><d>2018-05-30</d><h>19:37</h><w>johanatan</w>has anyone tried 1.1.1 w/ deps.edn and lumo ?</z><z id="t1527709081" t="johanatan I am getting: Could not require com.rpl.specter.navs in file com/rpl/specter.cljc (new) Function.cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:2024:72) Function.cljs.analyzer.error.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:2639:92) Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5954:145) Function.cljs.js.load_deps.cljs$core$IFn$_invoke$arity$7 (NO_SOURCE_FILE &lt;embedded&gt;:5965:119) (NO_SOURCE_FILE &lt;embedded&gt;:5965:570) Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5943:1) Function.cljs.js.load_deps.cljs$core$IFn$_invoke$arity$7 (NO_SOURCE_FILE &lt;embedded&gt;:5965:119) (NO_SOURCE_FILE &lt;embedded&gt;:5965:570) Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5943:1) Maximum call stack size exceeded (NO_SOURCE_FILE &lt;embedded&gt;:6625:177) (NO_SOURCE_FILE &lt;embedded&gt;:6120:138) (NO_SOURCE_FILE &lt;embedded&gt;:6010:425) (NO_SOURCE_FILE &lt;embedded&gt;:6024:218) (NO_SOURCE_FILE &lt;embedded&gt;:5968:270) (NO_SOURCE_FILE &lt;embedded&gt;:5947:36) (NO_SOURCE_FILE &lt;embedded&gt;:6120:138) (NO_SOURCE_FILE &lt;embedded&gt;:6010:425) (NO_SOURCE_FILE &lt;embedded&gt;:6024:218) (NO_SOURCE_FILE &lt;embedded&gt;:5968:270) when I do so."><y>#</y><d>2018-05-30</d><h>19:38</h><w>johanatan</w>I am getting:

<pre>Could not require com.rpl.specter.navs in file com/rpl/specter.cljc
	 (new)
	 Function.cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:2024:72)
	 Function.cljs.analyzer.error.cljs$core$IFn$_invoke$arity$3 (NO_SOURCE_FILE &lt;embedded&gt;:2639:92)
	 Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5954:145)
	 Function.cljs.js.load_deps.cljs$core$IFn$_invoke$arity$7 (NO_SOURCE_FILE &lt;embedded&gt;:5965:119)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5965:570)
	 Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5943:1)
	 Function.cljs.js.load_deps.cljs$core$IFn$_invoke$arity$7 (NO_SOURCE_FILE &lt;embedded&gt;:5965:119)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5965:570)
	 Function.cljs.js.require.cljs$core$IFn$_invoke$arity$5 (NO_SOURCE_FILE &lt;embedded&gt;:5943:1)

Maximum call stack size exceeded
	 (NO_SOURCE_FILE &lt;embedded&gt;:6625:177)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6120:138)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6010:425)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6024:218)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5968:270)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5947:36)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6120:138)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6010:425)
	 (NO_SOURCE_FILE &lt;embedded&gt;:6024:218)
	 (NO_SOURCE_FILE &lt;embedded&gt;:5968:270)
</pre>

when I do so.</z><z id="t1527711727" t="nathanmarz @johanatan don&apos;t see how that would have anything to do with specter, #tools-deps is probably a better place to ask"><y>#</y><d>2018-05-30</d><h>20:22</h><w>nathanmarz</w>@johanatan don&apos;t see how that would have anything to do with specter, #tools-deps is probably a better place to ask</z><z id="t1527711760" t="johanatan well specter is the only dep that this method is failing for"><y>#</y><d>2018-05-30</d><h>20:22</h><w>johanatan</w>well specter is the only dep that this method is failing for</z><z id="t1527711767" t="johanatan have you tried it?"><y>#</y><d>2018-05-30</d><h>20:22</h><w>johanatan</w>have you tried it?</z><z id="t1527711783" t="johanatan apparently the lib needs to be cljs self-host compatible (not sure if specter is)"><y>#</y><d>2018-05-30</d><h>20:23</h><w>johanatan</w>apparently the lib needs to be cljs self-host compatible (not sure if specter is)</z><z id="t1527711923" t="nathanmarz ah, well that would explain it"><y>#</y><d>2018-05-30</d><h>20:25</h><w>nathanmarz</w>ah, well that would explain it</z><z id="t1527711937" t="nathanmarz https://github.com/nathanmarz/specter/issues/136"><y>#</y><d>2018-05-30</d><h>20:25</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/issues/136" target="_blank">https://github.com/nathanmarz/specter/issues/136</a></z><z id="t1527712707" t="johanatan @nathanmarz thx!"><y>#</y><d>2018-05-30</d><h>20:38</h><w>johanatan</w>@nathanmarz thx!</z><z id="t1527712724" t="johanatan do you have any plan to fix it? should I create an issue to track it?"><y>#</y><d>2018-05-30</d><h>20:38</h><w>johanatan</w>do you have any plan to fix it? should I create an issue to track it?</z><z id="t1527714517" t="nathanmarz that is the issue to track it"><y>#</y><d>2018-05-30</d><h>21:08</h><w>nathanmarz</w>that is the issue to track it</z><z id="t1527714529" t="nathanmarz no plans to fix it since I don&apos;t use clojurescript"><y>#</y><d>2018-05-30</d><h>21:08</h><w>nathanmarz</w>no plans to fix it since I don&apos;t use clojurescript</z><z id="t1527714544" t="nathanmarz a pull request for it would be welcome though"><y>#</y><d>2018-05-30</d><h>21:09</h><w>nathanmarz</w>a pull request for it would be welcome though</z><z id="t1527717812" t="johanatan oh, sorry. i thought that was on the planck project (didn&apos;t look at the url)"><y>#</y><d>2018-05-30</d><h>22:03</h><w>johanatan</w>oh, sorry. i thought that was on the planck project (didn&apos;t look at the url)</z><z id="t1527948246" t="punit-naik Hi Guys! I was just starting out with Specter. I had a few questions. 1. Are there error-handling functions implemented inside specter? Can I get errors as to where my navigator failed? 2. Can it work with lazy seqs? Will the laziness be preserved? 3. Can we use reducers in setval ?"><y>#</y><d>2018-06-02</d><h>14:04</h><w>punit-naik</w>Hi Guys! I was just starting out with Specter. I had a few questions.
1. Are there error-handling functions implemented inside specter? Can I get errors as to where my navigator failed?
2. Can it work with lazy seqs? Will the laziness be preserved?
3. Can we use reducers in <code>setval</code>?</z><z id="t1527948582" t="nathanmarz @punit-naik there&apos;s no particular error handling done by specter"><y>#</y><d>2018-06-02</d><h>14:09</h><w>nathanmarz</w>@punit-naik there&apos;s no particular error handling done by specter</z><z id="t1527948594" t="nathanmarz I can usually tell where I messed up a path by looking at the stack trace"><y>#</y><d>2018-06-02</d><h>14:09</h><w>nathanmarz</w>I can usually tell where I messed up a path by looking at the stack trace</z><z id="t1527950024" t="punit-naik So when I run (transform [ALL :a] inc [{:a 1 :b 2} {:a 2 :b 1} {:b 3}]) , I get a very simple Nullpointer exception which is because the nil case is not handled by the inc fn. But don&apos;t you think one should get a more detailed exception like :a key not found at index 2 ?"><y>#</y><d>2018-06-02</d><h>14:33</h><r>punit-naik</r>So when I run <code>(transform [ALL :a] inc [{:a 1 :b 2} {:a 2 :b 1} {:b 3}])</code>, I get a very simple <code>Nullpointer exception</code> which is because the <code>nil</code> case is not handled by the <code>inc</code> fn. But don&apos;t you think one should get a more detailed exception like <code>:a key not found at index 2</code>?</z><z id="t1527948642" t="nathanmarz specter will never produce a lazy output"><y>#</y><d>2018-06-02</d><h>14:10</h><w>nathanmarz</w>specter will never produce a lazy output</z><z id="t1527951659" t="punit-naik I tried running (def x (lazy-seq [1 2 3 4])) (time (cons (inc (first x)) (rest x))) and (time (transform FIRST inc x)) and the running times for them were 0.08 msecs and 0.5 msecs . Is this a considerable enough difference? So is specter indeed evaluating the entire lazy list?"><y>#</y><d>2018-06-02</d><h>15:00</h><r>punit-naik</r>I tried running <code>(def x (lazy-seq [1 2 3 4])) (time (cons (inc (first x)) (rest x)))</code> and <code>(time (transform FIRST inc x))</code> and the running times for them were <code>0.08 msecs</code> and <code>0.5 msecs</code>. Is this a considerable enough difference? So is specter indeed evaluating the entire lazy list?</z><z id="t1527948687" t="nathanmarz though using select-first can accomplish many of the same things since it terminates navigation as soon as it encounters a matching value"><y>#</y><d>2018-06-02</d><h>14:11</h><w>nathanmarz</w>though using <code>select-first</code> can accomplish many of the same things since it terminates navigation as soon as it encounters a matching value</z><z id="t1527948695" t="nathanmarz don&apos;t know what you mean by #3"><y>#</y><d>2018-06-02</d><h>14:11</h><w>nathanmarz</w>don&apos;t know what you mean by #3</z><z id="t1527948695" t="nathanmarz don&apos;t know what you mean by #3"><y>#</y><d>2018-06-02</d><h>14:11</h><w>nathanmarz</w>don&apos;t know what you mean by #3</z><z id="t1527951816" t="punit-naik What I meant was, is there a way to perform reduce using navigators? I am thinking of using select for this. Am I correct?"><y>#</y><d>2018-06-02</d><h>15:03</h><r>punit-naik</r>What I meant was, is there a way to perform <code>reduce</code> using  navigators? I am thinking of using <code>select</code> for this. Am I correct?</z><z id="t1527952478" t="nathanmarz @punit-naik the most efficient way to reduce over navigated values is with traverse"><y>#</y><d>2018-06-02</d><h>15:14</h><w>nathanmarz</w>@punit-naik the most efficient way to reduce over navigated values is with <code>traverse</code></z><z id="t1527952496" t="nathanmarz https://github.com/nathanmarz/specter/wiki/List-of-Macros#traverse"><y>#</y><d>2018-06-02</d><h>15:14</h><w>nathanmarz</w><a href="https://github.com/nathanmarz/specter/wiki/List-of-Macros#traverse" target="_blank">https://github.com/nathanmarz/specter/wiki/List-of-Macros#traverse</a></z><z id="t1527952542" t="nathanmarz timing a single invocation tells you absolutely nothing, since neither specter nor the jvm have had a chance to optimize that callsite"><y>#</y><d>2018-06-02</d><h>15:15</h><w>nathanmarz</w>timing a single invocation tells you absolutely nothing, since neither specter nor the jvm have had a chance to optimize that callsite</z><z id="t1527952561" t="nathanmarz use criterium for benchmarking"><y>#</y><d>2018-06-02</d><h>15:16</h><w>nathanmarz</w>use criterium for benchmarking</z><z id="t1527952614" t="nathanmarz I think you want (transform [ALL (must :a)] inc [{:a 1 :b 2} {:a 2 :b 1} {:b 3}]) for that code"><y>#</y><d>2018-06-02</d><h>15:16</h><w>nathanmarz</w>I think you want <code>(transform [ALL (must :a)] inc [{:a 1 :b 2} {:a 2 :b 1} {:b 3}])</code> for that code</z><z id="t1527952858" t="punit-naik Okay but I if I just forget to use must . The error stack-trace seems pretty unhelpful in that case no?"><y>#</y><d>2018-06-02</d><h>15:20</h><r>punit-naik</r>Okay but I if I just forget to use <code>must</code>. The error stack-trace seems pretty unhelpful in that case no?</z><z id="t1527952873" t="nathanmarz your path says to navigate to that key"><y>#</y><d>2018-06-02</d><h>15:21</h><w>nathanmarz</w>your path says to navigate to that key</z><z id="t1527952894" t="nathanmarz it&apos;s doing exactly what you instructed"><y>#</y><d>2018-06-02</d><h>15:21</h><w>nathanmarz</w>it&apos;s doing exactly what you instructed</z><z id="t1527952948" t="nathanmarz it&apos;s like doing (update {} :a inc)"><y>#</y><d>2018-06-02</d><h>15:22</h><w>nathanmarz</w>it&apos;s like doing <code>(update {} :a inc)</code></z><z id="t1527953076" t="punit-naik okay."><y>#</y><d>2018-06-02</d><h>15:24</h><w>punit-naik</w>okay.</z><z id="t1528000547" t="montanonic If I have a map, how would I transform MAP-VALS but also passing the key corresponding to the val to the function? The issue is that if I just use ALL , it also transforms the keys, which I don&apos;t want; but if I use MAP-VALS , then I lose the context of the key. I realize that with I can just use map to achieve this without Specter, but then I&apos;d have to use (into {}) to get it back to a map. I&apos;m transforming the map a lot, so this is undesirable."><y>#</y><d>2018-06-03</d><h>04:35</h><w>montanonic</w>If I have a map, how would I transform <code>MAP-VALS</code> but also passing the key corresponding to the val to the function? The issue is that if I just use <code>ALL</code>, it also transforms the keys, which I don&apos;t want; but if I use <code>MAP-VALS</code>, then I lose the context of the key. I realize that with I can just use <code>map</code> to achieve this without Specter, but then I&apos;d have to use <code>(into {})</code> to get it back to a map. I&apos;m transforming the map a lot, so this is undesirable.</z><z id="t1528001445" t="nathanmarz @montanonic the pattern for that is (transform [ALL (collect-one FIRST) LAST] (fn [k v] ...) data)"><y>#</y><d>2018-06-03</d><h>04:50</h><w>nathanmarz</w>@montanonic the pattern for that is <code>(transform [ALL (collect-one FIRST) LAST] (fn [k v] ...) data)</code></z><z id="t1528001500" t="montanonic Ahh, nice. Thanks!"><y>#</y><d>2018-06-03</d><h>04:51</h><w>montanonic</w>Ahh, nice. Thanks!</z><z id="t1528208122" t="daveliepmann Hi folks. I have a map and want to transform it to a nested map by applying a function to the key. A contrived example would be {&quot;ab&quot; 5, &quot;az&quot; 10} would become {&quot;a&quot; {&quot;b&quot; 5, &quot;z 10} . I don&apos;t see a way to do this with transform —am I missing something?"><y>#</y><d>2018-06-05</d><h>14:15</h><w>daveliepmann</w>Hi folks. I have a map and want to <code>transform</code> it to a nested map by applying a function to the key. A contrived example would be <code>{&quot;ab&quot; 5, &quot;az&quot; 10}</code> would become <code>{&quot;a&quot; {&quot;b&quot; 5, &quot;z 10}</code>. I don&apos;t see a way to do this with <code>transform</code>—am I missing something?</z><z id="t1528208470" t="nathanmarz @daveliepmann that&apos;s a restructure of the entire data structure, so specter won&apos;t be better than just doing it without"><y>#</y><d>2018-06-05</d><h>14:21</h><w>nathanmarz</w>@daveliepmann that&apos;s a restructure of the entire data structure, so specter won&apos;t be better than just doing it without</z><z id="t1528208540" t="nathanmarz specter lets you target a precise part of a data structure and only change that part, which isn&apos;t the case here"><y>#</y><d>2018-06-05</d><h>14:22</h><w>nathanmarz</w>specter lets you target a precise part of a data structure and only change that part, which isn&apos;t the case here</z><z id="t1528208580" t="daveliepmann I had that suspicion, but it helps to hear it from the source. Thanks! 🙂"><y>#</y><d>2018-06-05</d><h>14:23</h><w>daveliepmann</w>I had that suspicion, but it helps to hear it from the source. Thanks! <b>🙂</b></z><z id="t1528306057" t="jeremyraines hi folks, wondering if someone can help me understand why the following are not equivalent"><y>#</y><d>2018-06-06</d><h>17:27</h><w>jeremyraines</w>hi folks, wondering if someone can help me understand why the following are not equivalent</z><z id="t1528306133" t="jeremyraines where the contents of the atom foo are exactly the vec returned from the first expression"><y>#</y><d>2018-06-06</d><h>17:28</h><w>jeremyraines</w>where the contents of the atom <code>foo</code> are exactly the vec returned from the first expression</z><z id="t1528306270" t="nathanmarz @jeremyraines filterer takes in a subpath and keeps elements for which that path navigates to at least one value"><y>#</y><d>2018-06-06</d><h>17:31</h><w>nathanmarz</w>@jeremyraines <code>filterer</code> takes in a subpath and keeps elements for which that path navigates to at least one value</z><z id="t1528306277" t="nathanmarz :bar always navigates"><y>#</y><d>2018-06-06</d><h>17:31</h><w>nathanmarz</w><code>:bar</code> always navigates</z><z id="t1528306297" t="nathanmarz you can do (sp/select [sp/ATOM (sp/filterer (pred :bar)) sp/ALL] foo)"><y>#</y><d>2018-06-06</d><h>17:31</h><w>nathanmarz</w>you can do <code>(sp/select [sp/ATOM (sp/filterer (pred :bar)) sp/ALL] foo)</code></z><z id="t1528306321" t="jeremyraines ah, got it. Thank you!"><y>#</y><d>2018-06-06</d><h>17:32</h><w>jeremyraines</w>ah, got it.  Thank you!</z><z id="t1528307713" t="currentoor @nathanmarz I just started playing with specter, it’s been on my list for a while. I’m mad at myself for not using this work of art sooner! Just wanted to say thanks for making this and you’re doing God’s work! 😄"><y>#</y><d>2018-06-06</d><h>17:55</h><w>currentoor</w>@nathanmarz I just started playing with specter, it’s been on my list for a while. I’m mad at myself for not using this work of art sooner! Just wanted to say thanks for making this and you’re doing God’s work! <b>😄</b></z><z id="t1528307884" t="nathanmarz @currentoor thanks :)"><y>#</y><d>2018-06-06</d><h>17:58</h><w>nathanmarz</w>@currentoor thanks :)</z><z id="t1528307913" t="currentoor dealing the salesforce API just got a whole lot easier (and more fun)!"><y>#</y><d>2018-06-06</d><h>17:58</h><w>currentoor</w>dealing the salesforce API just got a whole lot easier (and more fun)!</z><z id="t1528320559" t="sophiago I modified the map-key-walker example from the wiki page on recursive navigators so that it will look inside vectors as well as maps, but ideally i&apos;d like to navigate to the inverse so I can delete all other key-value pairs and leave the ones selected with the structure they were nested in."><y>#</y><d>2018-06-06</d><h>21:29</h><w>sophiago</w>I modified the <code>map-key-walker</code> example from the wiki page on recursive navigators so that it will look inside vectors as well as maps, but ideally i&apos;d like to navigate to the inverse so I can delete all other key-value pairs and leave the ones selected with the structure they were nested in.</z><z id="t1528327104" t="nathanmarz @sophiago you&apos;re trying to do too much in those paths"><y>#</y><d>2018-06-06</d><h>23:18</h><w>nathanmarz</w>@sophiago you&apos;re trying to do too much in those paths</z><z id="t1528327141" t="nathanmarz don&apos;t navigate to both all the recursive maps and to a specific key in the same path"><y>#</y><d>2018-06-06</d><h>23:19</h><w>nathanmarz</w>don&apos;t navigate to both all the recursive maps and to a specific key in the same path</z><z id="t1528327154" t="nathanmarz have one path that navigates to all the maps and then navigate to the key from there"><y>#</y><d>2018-06-06</d><h>23:19</h><w>nathanmarz</w>have one path that navigates to all the maps and then navigate to the key from there</z><z id="t1528327175" t="nathanmarz (def data {:baz &quot;qux&quot;, :locals [{:locals &quot;foo&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]}) (def MAP-NODES (recursive-path [] p (cond-path map? (continue-then-stay MAP-VALS p) coll? [ALL p] ))) (transform MAP-NODES #(select-keys % [:locals]) data) "><y>#</y><d>2018-06-06</d><h>23:19</h><w>nathanmarz</w><pre>(def data {:baz &quot;qux&quot;, :locals [{:locals &quot;foo&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})

(def MAP-NODES
  (recursive-path [] p
   (cond-path map? (continue-then-stay MAP-VALS p)
              coll? [ALL p]
              )))

(transform MAP-NODES #(select-keys % [:locals]) data)
</pre></z><z id="t1528327185" t="nathanmarz not sure what you mean by &quot;inverse&quot;"><y>#</y><d>2018-06-06</d><h>23:19</h><w>nathanmarz</w>not sure what you mean by &quot;inverse&quot;</z><z id="t1528327210" t="nathanmarz you mean get rid of all &quot;:locals&quot; keys in all maps?"><y>#</y><d>2018-06-06</d><h>23:20</h><w>nathanmarz</w>you mean get rid of all &quot;:locals&quot; keys in all maps?</z><z id="t1528327362" t="sophiago No, I meant select for every k-v pair where the key is not the one specified. I figured using a navigator like that with (setval [..] NONE ..) would be the easiest way to preserve structure."><y>#</y><d>2018-06-06</d><h>23:22</h><w>sophiago</w>No, I meant select for every k-v pair where the key is not the one specified. I figured using a navigator like that with <code>(setval [..] NONE ..)</code> would be the easiest way to preserve structure.</z><z id="t1528327404" t="nathanmarz that&apos;s just [ALL (selected? FIRST #(not= % k)) LAST]"><y>#</y><d>2018-06-06</d><h>23:23</h><w>nathanmarz</w>that&apos;s just <code>[ALL (selected? FIRST #(not= % k)) LAST]</code></z><z id="t1528327476" t="sophiago Ah. Okay, thanks. I don&apos;t think that&apos;s even necessary now, though. I was fairly close to your solution in some of the navigators I tried, but not quite 😛"><y>#</y><d>2018-06-06</d><h>23:24</h><w>sophiago</w>Ah. Okay, thanks. I don&apos;t think that&apos;s even necessary now, though. I was fairly close to your solution in some of the navigators I tried, but not quite <b>😛</b></z><z id="t1528327636" t="sophiago I&apos;m still having trouble with your version of MAP-NODES and a full ast from tools.analyzer.jvm though"><y>#</y><d>2018-06-06</d><h>23:27</h><w>sophiago</w>I&apos;m still having trouble with your version of <code>MAP-NODES</code> and a full ast from <code>tools.analyzer.jvm</code> though</z><z id="t1528327780" t="sophiago Right, it still doesn&apos;t search bottom-up meaning it will prune branches that still contain the keys I&apos;m looking for, e.g. (def data {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]}) returns an empty map."><y>#</y><d>2018-06-06</d><h>23:29</h><w>sophiago</w>Right, it still doesn&apos;t search bottom-up meaning it will prune branches that still contain the keys I&apos;m looking for, e.g. <code>(def data {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})</code> returns an empty map.</z><z id="t1528327845" t="sophiago So that works as well as my second example above, but still fails on the same case"><y>#</y><d>2018-06-06</d><h>23:30</h><w>sophiago</w>So that works as well as my second example above, but still fails on the same case</z><z id="t1528327912" t="sophiago I&apos;m realizing just how difficult it is to do breadth-first search in Clojure 😕"><y>#</y><d>2018-06-06</d><h>23:31</h><w>sophiago</w>I&apos;m realizing just how difficult it is to do breadth-first search in Clojure <b>😕</b></z><z id="t1528327986" t="sophiago I mean, I can return the elements of a tree in breadth-first order but can&apos;t figure out how to transform it in that order."><y>#</y><d>2018-06-06</d><h>23:33</h><w>sophiago</w>I mean, I can return the elements of a tree in breadth-first order but can&apos;t figure out how to transform it in that order.</z><z id="t1528328755" t="sophiago This is what I&apos;m going for with a lengthy example you&apos;d want to pretty-print: https://gist.github.com/Sophia-Gold/d48be3ec125a453de7cec2033a465ef8"><y>#</y><d>2018-06-06</d><h>23:45</h><w>sophiago</w>This is what I&apos;m going for with a lengthy example you&apos;d want to pretty-print: <a href="https://gist.github.com/Sophia-Gold/d48be3ec125a453de7cec2033a465ef8" target="_blank">https://gist.github.com/Sophia-Gold/d48be3ec125a453de7cec2033a465ef8</a></z><z id="t1528328823" t="sophiago But really, the tiny examples in my second paste above cover the problem. In case it wasn&apos;t clear, it was working on the first structure and failing on the second."><y>#</y><d>2018-06-06</d><h>23:47</h><w>sophiago</w>But really, the tiny examples in my second paste above cover the problem. In case it wasn&apos;t clear, it was working on the first structure and failing on the second.</z><z id="t1528333649" t="nathanmarz @sophiago it&apos;s a lot easier if your maps have more information about what they represent"><y>#</y><d>2018-06-07</d><h>01:07</h><w>nathanmarz</w>@sophiago it&apos;s a lot easier if your maps have more information about what they represent</z><z id="t1528333670" t="nathanmarz this would be a way to do it, though it&apos;s not very efficient: (def data {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot; :k &quot;v&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]}) (def MAP-NODES (recursive-path [] p (cond-path map? (stay-then-continue MAP-VALS p) coll? [ALL p] ))) (transform [MAP-NODES (not-selected? MAP-VALS MAP-NODES (must :locals))] #(select-keys % [:locals]) data) "><y>#</y><d>2018-06-07</d><h>01:07</h><w>nathanmarz</w>this would be a way to do it, though it&apos;s not very efficient:
<pre>(def data {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot; :k &quot;v&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})

(def MAP-NODES
  (recursive-path [] p
   (cond-path map? (stay-then-continue MAP-VALS p)
              coll? [ALL p]
              )))

(transform
  [MAP-NODES
   (not-selected?
     MAP-VALS
     MAP-NODES
     (must :locals))]
  #(select-keys % [:locals])
  data)
</pre></z><z id="t1528333822" t="sophiago Unfortunately, I don&apos;t have control over data representation in this case. But I think we&apos;re converging on something similar. I&apos;m trying something like this: (setval [MAP-NODES #(and (not= :locals (first %)) (not (coll? (second %))))] NONE {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})"><y>#</y><d>2018-06-07</d><h>01:10</h><w>sophiago</w>Unfortunately, I don&apos;t have control over data representation in this case. But I think we&apos;re converging on something similar. I&apos;m trying something like this: <code>(setval [MAP-NODES #(and (not= :locals (first %)) (not (coll? (second %))))] NONE {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})</code></z><z id="t1528334127" t="nathanmarz this is a cleaner way to write that: (setval [MAP-NODES ALL (not-selected? FIRST (pred= :locals)) LAST (complement coll?)] NONE data) "><y>#</y><d>2018-06-07</d><h>01:15</h><w>nathanmarz</w>this is a cleaner way to write that:
<pre>(setval
  [MAP-NODES
   ALL
   (not-selected? FIRST (pred= :locals))
   LAST
   (complement coll?)]
  NONE
  data)
</pre></z><z id="t1528334178" t="nathanmarz if you want to get rid of the empty map you can do this: (def data {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot; :k &quot;v&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]}) (def MAP-NODES (recursive-path [] p (cond-path map? (stay-then-continue MAP-VALS p) coll? [(compact ALL p)] ))) (setval [MAP-NODES ALL (not-selected? FIRST (pred= :locals)) LAST (complement coll?)] NONE data) "><y>#</y><d>2018-06-07</d><h>01:16</h><w>nathanmarz</w>if you want to get rid of the empty map you can do this:
<pre>(def data {:baz &quot;qux&quot;, :env [{:locals &quot;foo&quot; :k &quot;v&quot;} {:locals &quot;bar&quot;} {:baz &quot;qux&quot;}]})

(def MAP-NODES
  (recursive-path [] p
   (cond-path map? (stay-then-continue MAP-VALS p)
              coll? [(compact ALL p)]
              )))

(setval
  [MAP-NODES
   ALL
   (not-selected? FIRST (pred= :locals))
   LAST
   (complement coll?)]
  NONE
  data)
</pre></z><z id="t1528334265" t="sophiago Nice. I think this might be what I&apos;m looking for"><y>#</y><d>2018-06-07</d><h>01:17</h><w>sophiago</w>Nice. I think this might be what I&apos;m looking for</z><z id="t1528334594" t="sophiago Okay, yeah I think that&apos;s good enough I can follow it from here. compact is being called on a keyword at some point in the traversal of a full ast, but I probably want to clean up the results further. Thanks yet again, @nathanmarz"><y>#</y><d>2018-06-07</d><h>01:23</h><w>sophiago</w>Okay, yeah I think that&apos;s good enough I can follow it from here. <code>compact</code> is being called on a keyword at some point in the traversal of a full ast, but I probably want to clean up the results further. Thanks yet again, @nathanmarz</z><z id="t1528334731" t="sophiago I should probably think about contributing to your docs if you think this is a common enough use case. I would think Specter is ideal for working with tools.analyzer and in fact there was one Jira ticket for the latter related to Ridley."><y>#</y><d>2018-06-07</d><h>01:25</h><w>sophiago</w>I should probably think about contributing to your docs if you think this is a common enough use case. I would think Specter is ideal for working with <code>tools.analyzer</code> and in fact there was one Jira ticket for the latter related to Ridley.</z><z id="t1528491920" t="sophiago @nathanmarz sorry, one more thing I&apos;m stuck on with the navigators above: I&apos;d like the macros that call them to stop at any keys in not-selected? , :locals in this example, rather than just skipping them and navigating deeper. It would seem I just need to move the not-selected? navigators into recursive-path so navigation stops there and setval will only apply the other predicates to elements above it, but that doesn&apos;t seem to be working for me, even using separate macros."><y>#</y><d>2018-06-08</d><h>21:05</h><w>sophiago</w>@nathanmarz sorry, one more thing I&apos;m stuck on with the navigators above: I&apos;d like the macros that call them to stop at any keys in <code>not-selected?</code>, <code>:locals</code> in this example, rather than just skipping them and navigating deeper. It would seem I just need to move the <code>not-selected?</code> navigators into <code>recursive-path</code> so navigation stops there and <code>setval</code> will only apply the other predicates to elements above it, but that doesn&apos;t seem to be working for me, even using separate macros.</z><z id="t1528492584" t="nathanmarz @sophiago you want it to stop navigation at map values whose key is not :locals ?"><y>#</y><d>2018-06-08</d><h>21:16</h><w>nathanmarz</w>@sophiago you want it to stop navigation at map values whose key is not <code>:locals</code>?</z><z id="t1528492647" t="sophiago The opposite. Stop recursive navigation into the value of that key."><y>#</y><d>2018-06-08</d><h>21:17</h><w>sophiago</w>The opposite. Stop recursive navigation into the value of that key.</z><z id="t1528492660" t="nathanmarz so stop navigation at any map?"><y>#</y><d>2018-06-08</d><h>21:17</h><w>nathanmarz</w>so stop navigation at any map?</z><z id="t1528492675" t="nathanmarz or stop navigation at maps with a :locals key?"><y>#</y><d>2018-06-08</d><h>21:17</h><w>nathanmarz</w>or stop navigation at maps with a <code>:locals</code> key?</z><z id="t1528492800" t="sophiago So if I have {:foo &quot;bar&quot; :env [{:locals &quot;baz&quot;} {:locals {:baz &quot;qux&quot;}}]} I can use a macro like setval above and not have it delete {:baz &quot;qux&quot;}"><y>#</y><d>2018-06-08</d><h>21:20</h><w>sophiago</w>So if I have <code>{:foo &quot;bar&quot; :env [{:locals &quot;baz&quot;} {:locals {:baz &quot;qux&quot;}}]}</code> I can use a macro like <code>setval</code> above and not have it delete <code>{:baz &quot;qux&quot;}</code></z><z id="t1528492839" t="sophiago I&apos;ve been playing with it and it seems to come down to how I compose predicates in recursive paths"><y>#</y><d>2018-06-08</d><h>21:20</h><w>sophiago</w>I&apos;ve been playing with it and it seems to come down to how I compose predicates in recursive paths</z><z id="t1528492872" t="nathanmarz ok, so basically don&apos;t recurse into :locals"><y>#</y><d>2018-06-08</d><h>21:21</h><w>nathanmarz</w>ok, so basically don&apos;t recurse into <code>:locals</code></z><z id="t1528492892" t="sophiago Yes"><y>#</y><d>2018-06-08</d><h>21:21</h><w>sophiago</w>Yes</z><z id="t1528492908" t="sophiago And more generally, I just want to decouple the recursion from the predicates I&apos;m composing"><y>#</y><d>2018-06-08</d><h>21:21</h><w>sophiago</w>And more generally, I just want to decouple the recursion from the predicates I&apos;m composing</z><z id="t1528493012" t="nathanmarz (def maps-with-key-stop (recursive-path [k] p (cond-path map? (if-path (must k) STAY (stay-then-continue MAP-VALS p)) coll? (compact ALL p) ))) (setval [(maps-with-key-stop :locals) ALL (not-selected? FIRST (pred= :locals)) LAST (complement coll?)] NONE data) "><y>#</y><d>2018-06-08</d><h>21:23</h><w>nathanmarz</w><pre>(def maps-with-key-stop
  (recursive-path [k] p
    (cond-path map? (if-path (must k)
                      STAY
                      (stay-then-continue MAP-VALS p))
               coll? (compact ALL p)
               )))

(setval
  [(maps-with-key-stop :locals)
   ALL
   (not-selected? FIRST (pred= :locals))
   LAST
   (complement coll?)]
  NONE
  data)
</pre></z><z id="t1528493046" t="sophiago Oh, I did not try something like that"><y>#</y><d>2018-06-08</d><h>21:24</h><w>sophiago</w>Oh, I did not try something like that</z><z id="t1528493052" t="sophiago Let me give it a test"><y>#</y><d>2018-06-08</d><h>21:24</h><w>sophiago</w>Let me give it a test</z><z id="t1528493139" t="nathanmarz actually you probably want (def maps-with-key-stop (recursive-path [k] p (cond-path map? (stay-then-continue ALL (not-selected? FIRST (pred= k)) LAST p) coll? (compact ALL p) ))) "><y>#</y><d>2018-06-08</d><h>21:25</h><w>nathanmarz</w>actually you probably want
<pre>(def maps-with-key-stop
  (recursive-path [k] p
    (cond-path map? (stay-then-continue
                      ALL
                      (not-selected? FIRST (pred= k))
                      LAST
                      p)
               coll? (compact ALL p)
               )))
</pre></z><z id="t1528493176" t="sophiago That looks more like what I was trying"><y>#</y><d>2018-06-08</d><h>21:26</h><w>sophiago</w>That looks more like what I was trying</z><z id="t1528493356" t="sophiago I think I actually want this: (def maps-with-key-stop (recursive-path [k] p (cond-path map? (stay-then-continue ALL (not-selected? FIRST (pred= k)) ALL p) coll? [ALL p])))"><y>#</y><d>2018-06-08</d><h>21:29</h><w>sophiago</w>I think I actually want this:<pre>(def maps-with-key-stop
  (recursive-path [k] p
    (cond-path map? (stay-then-continue
                      ALL
                      (not-selected? FIRST (pred= k))
                      ALL
                      p)
               coll? [ALL p])))</pre></z><z id="t1528493614" t="sophiago Except I&apos;m trying to get the k to be a collection and apply isn&apos;t giving the same results"><y>#</y><d>2018-06-08</d><h>21:33</h><w>sophiago</w>Except I&apos;m trying to get the <code>k</code> to be a collection and <code>apply</code> isn&apos;t giving the same results</z><z id="t1528493727" t="sophiago Oh, that&apos;s what eachnav is for, right?"><y>#</y><d>2018-06-08</d><h>21:35</h><w>sophiago</w>Oh, that&apos;s what <code>eachnav</code> is for, right?</z><z id="t1528499094" t="nathanmarz that&apos;s not what eachnav is for"><y>#</y><d>2018-06-08</d><h>23:04</h><w>nathanmarz</w>that&apos;s not what <code>eachnav</code> is for</z><z id="t1528499137" t="nathanmarz @sophiago I think you want: (def maps-with-key-stop (recursive-path [kset] p (cond-path map? (stay-then-continue ALL (not-selected? FIRST (pred kset)) LAST p) coll? [ALL p] ))) "><y>#</y><d>2018-06-08</d><h>23:05</h><w>nathanmarz</w>@sophiago I think you want:
<pre>(def maps-with-key-stop
  (recursive-path [kset] p
    (cond-path map? (stay-then-continue
                      ALL
                      (not-selected? FIRST (pred kset))
                      LAST
                      p)
               coll? [ALL p]
               )))
</pre></z><z id="t1528499560" t="sophiago Thanks, that works! Just a bit more verbose when I call it. I still have the first issue where it doesn&apos;t seem to be recursing inside other colls, though."><y>#</y><d>2018-06-08</d><h>23:12</h><w>sophiago</w>Thanks, that works! Just a bit more verbose when I call it. I still have the first issue where it doesn&apos;t seem to be recursing inside other colls, though.</z><z id="t1528499697" t="sophiago And I have to delete the extra predicate argument from the first cond or none of these have worked. That seems to make sense to me: I don&apos;t actually want (complement coll?) added to the path if the key does match."><y>#</y><d>2018-06-08</d><h>23:14</h><w>sophiago</w>And I have to delete the extra predicate argument from the first cond or none of these have worked. That seems to make sense to me: I don&apos;t actually want <code>(complement coll?)</code> added to the path if the key does match.</z><z id="t1528727056" t="ben.mumford what is the more elegant way to extract a value from a nested data structure and then apply a transform to it?"><y>#</y><d>2018-06-11</d><h>14:24</h><w>ben.mumford</w>what is the more elegant way to extract a value from a nested data structure and then apply a transform to it?</z><z id="t1528727143" t="ben.mumford my use case is that i have lots of different types of input data structures and i want to normalise them so that i can compose and compare them"><y>#</y><d>2018-06-11</d><h>14:25</h><w>ben.mumford</w>my use case is that i have lots of different types of input data structures and i want to normalise them so that i can compose and compare them</z><z id="t1528727410" t="ben.mumford so what i&apos;m doing is for each input object creating a new output object where each field is calculated using a select then a transform (so i guess question 2 is does this make specter a good fit for my use case as i&apos;m not modifying a pre-existing data structure)"><y>#</y><d>2018-06-11</d><h>14:30</h><w>ben.mumford</w>so what i&apos;m doing is for each input object creating a new output object where each field is calculated using a select then a transform (so i guess question 2 is does this make specter a good fit for my use case as i&apos;m not modifying a pre-existing data structure)</z><z id="t1528732274" t="nathanmarz @ben.mumford620 you can use view or transformed at the end of the path to the select operation"><y>#</y><d>2018-06-11</d><h>15:51</h><w>nathanmarz</w>@ben.mumford620 you can use <code>view</code> or <code>transformed</code> at the end of the path to the select operation</z><z id="t1528734457" t="jsa-aerial Would spectre be the &apos;natural/goto&apos; thing for taking a nested data structure and a &apos;key&apos; and replace any occurance of it with a value? Where &apos;key&apos; would most probably be literally a keyword (or possibly string)?"><y>#</y><d>2018-06-11</d><h>16:27</h><w>jsa-aerial</w>Would spectre be the &apos;natural/goto&apos; thing for taking a nested data structure and a &apos;key&apos; and replace any occurance of it with a value?  Where &apos;key&apos; would most probably be literally a keyword (or possibly string)?</z><z id="t1528737378" t="nathanmarz @jsa-aerial yes, that&apos;s a bread and butter use case"><y>#</y><d>2018-06-11</d><h>17:16</h><w>nathanmarz</w>@jsa-aerial yes, that&apos;s a bread and butter use case</z><z id="t1528737426" t="nathanmarz walker is the lazy way to do that, but if your data has any structure to it whatsoever it&apos;s better to make a precise path"><y>#</y><d>2018-06-11</d><h>17:17</h><w>nathanmarz</w><code>walker</code> is the lazy way to do that, but if your data has any structure to it whatsoever it&apos;s better to make a precise path</z><z id="t1528737449" t="nathanmarz much higher performance + much less bug prone"><y>#</y><d>2018-06-11</d><h>17:17</h><w>nathanmarz</w>much higher performance + much less bug prone</z><z id="t1528741522" t="jsa-aerial @nathanmarz OK, sounds promising. The data will have quite a lot of structure and the &apos;paths&apos; (there will typically be several such &apos;keys&apos;) will basically not be known ahead of time. So, this basically involves &apos;search&apos; and replace. Why would non precise path and walker tend to be more &apos;bug prone&apos;??"><y>#</y><d>2018-06-11</d><h>18:25</h><w>jsa-aerial</w>@nathanmarz OK, sounds promising. The data will have quite a lot of structure and the &apos;paths&apos; (there will typically be several such &apos;keys&apos;) will basically not be known ahead of time. So, this basically involves &apos;search&apos; and replace. Why would non precise path and <code>walker</code> tend to be more &apos;bug prone&apos;??</z><z id="t1528742166" t="nathanmarz walker will descend everywhere including places you don&apos;t expect, like records, map keys, etc."><y>#</y><d>2018-06-11</d><h>18:36</h><w>nathanmarz</w><code>walker</code> will descend everywhere including places you don&apos;t expect, like records, map keys, etc.</z><z id="t1528742262" t="jsa-aerial But if the &apos;key&apos; can basically be anywhere, that would seem to be the &apos;right thing&apos;, correct?"><y>#</y><d>2018-06-11</d><h>18:37</h><r>jsa-aerial</r>But if the &apos;key&apos; can basically be anywhere, that would seem to be the &apos;right thing&apos;, correct?</z><z id="t1528742177" t="jsa-aerial Actually, ALL almost looks like exactly what is needed here. Except it returns [k v] for map elements"><y>#</y><d>2018-06-11</d><h>18:36</h><w>jsa-aerial</w>Actually, ALL almost looks like exactly what is needed here. Except it returns [k v] for map elements</z><z id="t1528742269" t="nathanmarz here&apos;s a variation of walker that doesn&apos;t descend into map keys / key/value pairs (def my-walker (recursive-path [afn] p (cond-path (pred afn) STAY map? [MAP-VALS p] coll? [ALL p] ))) "><y>#</y><d>2018-06-11</d><h>18:37</h><w>nathanmarz</w>here&apos;s a variation of <code>walker</code> that doesn&apos;t descend into map keys / key/value pairs
<pre>(def my-walker
  (recursive-path [afn] p
    (cond-path (pred afn) STAY
               map? [MAP-VALS p]
               coll? [ALL p]
               )))
</pre></z><z id="t1528742306" t="nathanmarz if your data is truly completely unstructured, then walker is more appropriate"><y>#</y><d>2018-06-11</d><h>18:38</h><w>nathanmarz</w>if your data is truly completely unstructured, then <code>walker</code> is more appropriate</z><z id="t1528742323" t="nathanmarz though even then, it&apos;s better to make a variation that doesn&apos;t navigate to key/value pairs"><y>#</y><d>2018-06-11</d><h>18:38</h><w>nathanmarz</w>though even then, it&apos;s better to make a variation that doesn&apos;t navigate to key/value pairs</z><z id="t1528742354" t="nathanmarz e.g. (def my-walker (recursive-path [afn] p (cond-path (pred afn) STAY map? [(multi-path MAP-VALS MAP-KEYS) p] coll? [ALL p] ))) "><y>#</y><d>2018-06-11</d><h>18:39</h><w>nathanmarz</w>e.g.
<pre>(def my-walker
  (recursive-path [afn] p
    (cond-path (pred afn) STAY
               map? [(multi-path MAP-VALS MAP-KEYS) p]
               coll? [ALL p]
               )))
</pre></z><z id="t1528742357" t="jsa-aerial I think we have a semantic issue here - you are using &apos;structured&apos; in a special way - not just to indicate a lot of structure in the data"><y>#</y><d>2018-06-11</d><h>18:39</h><w>jsa-aerial</w>I think we have a semantic issue here - you are using &apos;structured&apos; in a special way - not just to indicate a lot of structure in the data</z><z id="t1528742393" t="nathanmarz by structure I mean that the organization of the data is precise and well-understood"><y>#</y><d>2018-06-11</d><h>18:39</h><w>nathanmarz</w>by structure I mean that the organization of the data is precise and well-understood</z><z id="t1528742430" t="jsa-aerial Something like this {:a ::some-key ....} can occur and should become {:a &lt;the-value-for-::some-key&gt; ...}"><y>#</y><d>2018-06-11</d><h>18:40</h><w>jsa-aerial</w>Something like this {:a ::some-key ....} can occur and should become {:a &lt;the-value-for-::some-key&gt; ...}</z><z id="t1528742524" t="jsa-aerial It&apos;s precise, it is just not fully known up front. And these &apos;keys&apos; can occur in all sorts of places. Basically, these structures will be &quot;parameterized&quot; vega-lite specifications."><y>#</y><d>2018-06-11</d><h>18:42</h><w>jsa-aerial</w>It&apos;s precise, it is just not fully known up front. And these &apos;keys&apos; can occur in all sorts of places. Basically, these structures will be &quot;parameterized&quot; vega-lite specifications.</z><z id="t1528742557" t="nathanmarz if the paths to what you care about aren&apos;t known in advance, then I would call it unstructured"><y>#</y><d>2018-06-11</d><h>18:42</h><w>nathanmarz</w>if the paths to what you care about aren&apos;t known in advance, then I would call it unstructured</z><z id="t1528742589" t="nathanmarz if you know it will never occur in a map key, then it&apos;s best your path reflect that"><y>#</y><d>2018-06-11</d><h>18:43</h><w>nathanmarz</w>if you know it will never occur in a map key, then it&apos;s best your path reflect that</z><z id="t1528742603" t="nathanmarz or if you know any other constraints, those should be included in the path"><y>#</y><d>2018-06-11</d><h>18:43</h><w>nathanmarz</w>or if you know any other constraints, those should be included in the path</z><z id="t1528742604" t="jsa-aerial OK, that is fine - now I know what you mean by that, it would seem walker is the way to go"><y>#</y><d>2018-06-11</d><h>18:43</h><w>jsa-aerial</w>OK, that is fine - now I know what you mean by that, it would seem <code>walker</code> is the way to go</z><z id="t1528742690" t="jsa-aerial Yeah, those sorts of constraints and assumptions cannot be relied upon in this sort of scenario."><y>#</y><d>2018-06-11</d><h>18:44</h><w>jsa-aerial</w>Yeah, those sorts of constraints and assumptions cannot be relied upon in this sort of scenario.</z><z id="t1528742846" t="jsa-aerial There are constraints and requirements in vega-lite data specs, but here the idea is to use a basic layout as a template which will have these &apos;keys&apos; replaced by values for specific cases and these &apos;keys&apos; could be standing in for both VL keys and/or values."><y>#</y><d>2018-06-11</d><h>18:47</h><w>jsa-aerial</w>There are constraints and requirements in vega-lite data specs, but here the idea is to use a basic layout as a template which will have these &apos;keys&apos; replaced by values for specific cases and these &apos;keys&apos; could be standing in for both VL keys and/or values.</z><z id="t1528743046" t="jsa-aerial Hmmmm ALL maybe could still work if it is just called recursively on any [k v] pair returned"><y>#</y><d>2018-06-11</d><h>18:50</h><w>jsa-aerial</w>Hmmmm ALL maybe could still work if it is just called recursively on any [k v] pair returned</z><z id="t1528757888" t="currentoor is it generally frowned upon to use setval inside of a transform-fn in a transform call?"><y>#</y><d>2018-06-11</d><h>22:58</h><w>currentoor</w>is it generally frowned upon to use <code>setval</code> inside of a <code>transform-fn</code> in a transform call?</z><z id="t1528807974" t="nathanmarz @currentoor when that comes up I find that there&apos;s usually a better way to express the overall computation, though not always"><y>#</y><d>2018-06-12</d><h>12:52</h><w>nathanmarz</w>@currentoor when that comes up I find that there&apos;s usually a better way to express the overall computation, though not always</z><z id="t1528842435" t="currentoor thanks!"><y>#</y><d>2018-06-12</d><h>22:27</h><w>currentoor</w>thanks!</z><z id="t1528946585" t="nathanmarz @jsa-aerial with walker it&apos;s: (let [replacements {:b 77 :x :xxx}] (transform [(walker (complement coll?)) #(contains? replacements %)] replacements data )) "><y>#</y><d>2018-06-14</d><h>03:23</h><w>nathanmarz</w>@jsa-aerial with <code>walker</code> it&apos;s:
<pre>(let [replacements {:b 77 :x :xxx}]
  (transform [(walker (complement coll?)) #(contains? replacements %)]
    replacements
    data
    ))
</pre></z><z id="t1528946600" t="nathanmarz better than doing recursion manually in my opinion"><y>#</y><d>2018-06-14</d><h>03:23</h><w>nathanmarz</w>better than doing recursion manually in my opinion</z><z id="t1528952990" t="jsa-aerial 💯 ah..."><y>#</y><d>2018-06-14</d><h>05:09</h><w>jsa-aerial</w><b>💯</b> ah...</z><z id="t1528989860" t="lispyclouds Hello, I have the following structure"><y>#</y><d>2018-06-14</d><h>15:24</h><w>lispyclouds</w>Hello, I have the following structure</z><z id="t1528989935" t="lispyclouds and a function (get-details) which does url -&gt; [detailed-url1, detailed-url2 …]"><y>#</y><d>2018-06-14</d><h>15:25</h><w>lispyclouds</w>and a function <code>(get-details)</code> which does <code>url -&gt; [detailed-url1, detailed-url2 …]</code></z><z id="t1528989953" t="lispyclouds What i need is the following"><y>#</y><d>2018-06-14</d><h>15:25</h><w>lispyclouds</w>What i need is the following</z><z id="t1528990019" t="lispyclouds This is what Im using currently (defn categorized-urls [] (-&gt;&gt; (input) (transform [ALL MAP-VALS ALL MAP-VALS ALL] get-details) (transform [ALL MAP-VALS ALL MAP-VALS] flatten))) "><y>#</y><d>2018-06-14</d><h>15:26</h><w>lispyclouds</w>This is what Im using currently
<pre>(defn categorized-urls []
  (-&gt;&gt; (input)
       (transform [ALL MAP-VALS ALL MAP-VALS ALL] get-details)
       (transform [ALL MAP-VALS ALL MAP-VALS] flatten)))
</pre></z><z id="t1528990036" t="lispyclouds Is there a better way?"><y>#</y><d>2018-06-14</d><h>15:27</h><w>lispyclouds</w>Is there a better way?</z><z id="t1528990181" t="lispyclouds The input structure is pretty huge and its taking a while to execute this. Was wondering there might be a better way than twice transforms."><y>#</y><d>2018-06-14</d><h>15:29</h><w>lispyclouds</w>The input structure is pretty huge and its taking a while to execute this. Was wondering there might be a better way than twice transforms.</z><z id="t1528990979" t="nathanmarz @rahul080327 this will speed it up: (defn categorized-urls [input] (multi-transform [ALL MAP-VALS ALL MAP-VALS (multi-path [ALL (terminal get-details)] (terminal #(into [] (mapcat identity) %)))] input)) "><y>#</y><d>2018-06-14</d><h>15:42</h><w>nathanmarz</w>@rahul080327 this will speed it up:
<pre>(defn categorized-urls [input]
  (multi-transform
    [ALL
     MAP-VALS
     ALL
     MAP-VALS
     (multi-path
       [ALL (terminal get-details)]
       (terminal #(into [] (mapcat identity) %)))]
    input))
</pre></z><z id="t1528990994" t="nathanmarz traverses the data structure once instead of twice"><y>#</y><d>2018-06-14</d><h>15:43</h><w>nathanmarz</w>traverses the data structure once instead of twice</z><z id="t1528991290" t="lispyclouds Ahan thanks a lot @nathanmarz superb 😃"><y>#</y><d>2018-06-14</d><h>15:48</h><w>lispyclouds</w>Ahan thanks a lot @nathanmarz superb <b>😃</b></z><z id="t1529275017" t="luke.defeo Hello, am i able to use spectres navigation to define what im looking for but return a structure several layers up, say for example i have the following data (def ctx [ { :id &quot;blah&quot; :name &quot;News2&quot; :rules [[&quot;&quot; &quot;sport&quot; &quot;sport&quot;] [&quot;&quot; &quot;messages&quot;]]} { :name &quot;News&quot; :rules [[&quot;&quot; &quot;sport&quot;] [&quot;&quot; &quot;messages&quot;]]} { :name &quot;monitoring&quot; :rules [[&quot;new-relic&quot;] [&quot;stack driver&quot;]]}]) And navigation : (select-first [ALL :rules ALL ALL #(= % &quot;stack driver&quot;)] ctx) This will return the string “stack driver” is possible it returns its outer record { :name &quot;monitoring&quot; :rules [[&quot;new-relic&quot;] [&quot;stack driver&quot;]]} "><y>#</y><d>2018-06-17</d><h>22:36</h><w>luke.defeo</w>Hello, am i able to use spectres navigation to define what im looking for  but return a structure several layers up, say for example i have the following data

<pre>(def ctx [
          {
           :id    &quot;blah&quot;
           :name  &quot;News2&quot;
           :rules [[&quot;&quot; &quot;sport&quot; &quot;sport&quot;]
                   [&quot;&quot; &quot;messages&quot;]]}
          {
           :name  &quot;News&quot;
           :rules [[&quot;&quot; &quot;sport&quot;]
                   [&quot;&quot; &quot;messages&quot;]]}
          {
           :name  &quot;monitoring&quot;
           :rules [[&quot;new-relic&quot;]
                   [&quot;stack driver&quot;]]}])
</pre>
 And navigation :
<pre>(select-first [ALL :rules ALL ALL #(= % &quot;stack driver&quot;)] ctx)
</pre>

This will return the string “stack driver” is possible it returns its outer record 
<pre>{
           :name  &quot;monitoring&quot;
           :rules [[&quot;new-relic&quot;]
                   [&quot;stack driver&quot;]]}
</pre></z><z id="t1529275621" t="manas_marthi Hi Nathan, are there any sample data sets to try select and transform"><y>#</y><d>2018-06-17</d><h>22:47</h><w>manas_marthi</w>Hi Nathan, are there any sample data sets to try select and transform</z><z id="t1529275757" t="nathanmarz @luke.defeo use selected? for that"><y>#</y><d>2018-06-17</d><h>22:49</h><w>nathanmarz</w>@luke.defeo use <code>selected?</code> for that</z><z id="t1529275759" t="nathanmarz (select-first [ALL (selected? :rules ALL ALL #(= % &quot;stack driver&quot;))] ctx)"><y>#</y><d>2018-06-17</d><h>22:49</h><w>nathanmarz</w><code>(select-first [ALL (selected? :rules ALL ALL #(= % &quot;stack driver&quot;))] ctx)</code></z><z id="t1529275824" t="nathanmarz @manas.marthi you can use anything"><y>#</y><d>2018-06-17</d><h>22:50</h><w>nathanmarz</w>@manas.marthi you can use anything</z><z id="t1529275842" t="nathanmarz e.g. parse some html into a clojure data structure"><y>#</y><d>2018-06-17</d><h>22:50</h><w>nathanmarz</w>e.g. parse some html into a clojure data structure</z><z id="t1529275867" t="nathanmarz or just make up small toy examples like in the documentation"><y>#</y><d>2018-06-17</d><h>22:51</h><w>nathanmarz</w>or just make up small toy examples like in the documentation</z><z id="t1529276577" t="luke.defeo @nathanmarz thanks a lot"><y>#</y><d>2018-06-17</d><h>23:02</h><w>luke.defeo</w>@nathanmarz thanks a lot</z><z id="t1529276943" t="manas_marthi @nathanmarz thank you!"><y>#</y><d>2018-06-17</d><h>23:09</h><w>manas_marthi</w>@nathanmarz thank you!</z><z id="t1529533354" t="montanonic Any one-liner that can &quot;explode&quot; values while keeping things flat? Roughly speaking, like flatmap. Example: turning {:a 1 :b 2} into {:a 1 :b 2 &quot;a&quot; 1 &quot;b&quot; 2 &apos;a 1 &apos;b 2} , the keys get mapped to a set of new keys, but retain their original values, and the whole is returned as a single flat map."><y>#</y><d>2018-06-20</d><h>22:22</h><w>montanonic</w>Any one-liner that can &quot;explode&quot; values while keeping things flat? Roughly speaking, like flatmap.

Example: turning <code>{:a 1 :b 2}</code> into <code>{:a 1 :b 2 &quot;a&quot; 1 &quot;b&quot; 2 &apos;a 1 &apos;b 2}</code>, the keys get mapped to a set of new keys, but retain their original values, and the whole is returned as a single flat map.</z><z id="t1529534982" t="montanonic https://github.com/nathanmarz/specter/issues/82#issuecomment-215098107 is close, but not structure-preserving, and passes the arguments inside of an additional vector (which is fine but ideally should be left an implementation detail)."><y>#</y><d>2018-06-20</d><h>22:49</h><w>montanonic</w><a href="https://github.com/nathanmarz/specter/issues/82#issuecomment-215098107" target="_blank">https://github.com/nathanmarz/specter/issues/82#issuecomment-215098107</a> is close, but not structure-preserving, and passes the arguments inside of an additional vector (which is fine but ideally should be left an implementation detail).</z><z id="t1529542620" t="nathanmarz @montanonic you would need a new navigator for that"><y>#</y><d>2018-06-21</d><h>00:57</h><w>nathanmarz</w>@montanonic you would need a new navigator for that</z><z id="t1529542681" t="nathanmarz fleshing out ALL-ELEM-SEQ from that issue to be structure preserving would work"><y>#</y><d>2018-06-21</d><h>00:58</h><w>nathanmarz</w>fleshing out <code>ALL-ELEM-SEQ</code> from that issue to be structure preserving would work</z><z id="t1529850164" t="pepe Hello, I have this data: [{:id 0} {:id 1} {:id 2 :parent-id 1 :val 1} {:id 3 :parent-id 1 :val 1} {:id 4 :parent-id 2 :val 2} {:id 5 :parent-id 3 :val 2} {:id 6 :parent-id 3 :val 2} {:id 7 :parent-id 0 :val 100} {:id 8 :parent-id 7 :val 200} {:id 9 :parent-id 6 :val 3}] And I would like to traverse all the :val for :id = 1 and all its descendants. Is it possible with specter?"><y>#</y><d>2018-06-24</d><h>14:22</h><w>pepe</w>Hello, I have this data: 

<pre>[{:id 0}
 {:id 1}
 {:id 2 :parent-id 1 :val 1}
 {:id 3 :parent-id 1 :val 1}
 {:id 4 :parent-id 2 :val 2}
 {:id 5 :parent-id 3 :val 2}
 {:id 6 :parent-id 3 :val 2}
 {:id 7 :parent-id 0 :val 100}
 {:id 8 :parent-id 7 :val 200}
 {:id 9 :parent-id 6 :val 3}]</pre>

And I would like to traverse all the :val for :id = 1 and all its descendants. Is it possible with specter?</z><z id="t1529854161" t="nathanmarz @pepe yes, you can do it with zippers"><y>#</y><d>2018-06-24</d><h>15:29</h><w>nathanmarz</w>@pepe yes, you can do it with zippers</z><z id="t1529854203" t="pepe Is it that I have to first compose the tree first then?"><y>#</y><d>2018-06-24</d><h>15:30</h><w>pepe</w>Is it that I have to first compose the tree first then?</z><z id="t1529854341" t="nathanmarz no"><y>#</y><d>2018-06-24</d><h>15:32</h><w>nathanmarz</w>no</z><z id="t1529854343" t="nathanmarz one sec I&apos;ll show you"><y>#</y><d>2018-06-24</d><h>15:32</h><w>nathanmarz</w>one sec I&apos;ll show you</z><z id="t1529854653" t="nathanmarz @pepe (use &apos;com.rpl.specter) (require &apos;[com.rpl.specter.zipper :as z]) (def data [{:id 0} {:id 1} {:id 2 :parent-id 1 :val 1} {:id 3 :parent-id 1 :val 1} {:id 4 :parent-id 2 :val 2} {:id 5 :parent-id 3 :val 2} {:id 6 :parent-id 3 :val 2} {:id 7 :parent-id 0 :val 100} {:id 8 :parent-id 7 :val 200} {:id 9 :parent-id 6 :val 3}]) (def TO-GRAPH (path z/VECTOR-ZIP z/DOWN)) (defn to-node [id] (z/find-first #(= (:id %) id)) ) (def CHILDREN (path (collect-one z/NODE :id) z/LEFTMOST z/NEXT-WALK (collect-one z/NODE :parent-id) (collected? [id1 id2] (= id1 id2)) DISPENSE )) (def DESCENDANTS (recursive-path [] p (stay-then-continue CHILDREN p))) (select [TO-GRAPH (to-node 1) DESCENDANTS z/NODE (must :val)] data) "><y>#</y><d>2018-06-24</d><h>15:37</h><w>nathanmarz</w>@pepe
<pre>(use &apos;com.rpl.specter)
(require &apos;[com.rpl.specter.zipper :as z])

(def data
  [{:id 0}
   {:id 1}
   {:id 2 :parent-id 1 :val 1}
   {:id 3 :parent-id 1 :val 1}
   {:id 4 :parent-id 2 :val 2}
   {:id 5 :parent-id 3 :val 2}
   {:id 6 :parent-id 3 :val 2}
   {:id 7 :parent-id 0 :val 100}
   {:id 8 :parent-id 7 :val 200}
   {:id 9 :parent-id 6 :val 3}])

(def TO-GRAPH (path z/VECTOR-ZIP z/DOWN))
(defn to-node [id]
  (z/find-first #(= (:id %) id))
  )

(def CHILDREN
  (path
    (collect-one z/NODE :id)
    z/LEFTMOST
    z/NEXT-WALK
    (collect-one z/NODE :parent-id)
    (collected? [id1 id2] (= id1 id2))
    DISPENSE
    ))

(def DESCENDANTS (recursive-path [] p (stay-then-continue CHILDREN p)))

(select [TO-GRAPH (to-node 1) DESCENDANTS z/NODE (must :val)] data)
</pre></z><z id="t1529854667" t="nathanmarz that said, it&apos;s a really bad representation for a tree"><y>#</y><d>2018-06-24</d><h>15:37</h><w>nathanmarz</w>that said, it&apos;s a really bad representation for a tree</z><z id="t1529854831" t="pepe You mean my data? Yeah, some legacy stuff. I will try it and report back. Thank you very much for help!"><y>#</y><d>2018-06-24</d><h>15:40</h><r>pepe</r>You mean my data? Yeah, some legacy stuff. I will try it and report back. Thank you very much for help!</z><z id="t1529856422" t="pepe On some bigger trees I am getting Maximum call stack size exceeded in CLJS. Indeed this representation is bad 😞"><y>#</y><d>2018-06-24</d><h>16:07</h><r>pepe</r>On some bigger trees I am getting  Maximum call stack size exceeded in CLJS. Indeed this representation is bad <b>😞</b></z><z id="t1529858183" t="pepe The thing as always, is that those data I am receiving from API. The call stack is exceeded in the recursive-path"><y>#</y><d>2018-06-24</d><h>16:36</h><w>pepe</w>The thing as always, is that those data I am receiving from API. The call stack is exceeded in the recursive-path</z><z id="t1529866559" t="nathanmarz @pepe you can do better with custom navigators rather than zippers"><y>#</y><d>2018-06-24</d><h>18:55</h><w>nathanmarz</w>@pepe you can do better with custom navigators rather than zippers</z><z id="t1529866623" t="nathanmarz see defnav"><y>#</y><d>2018-06-24</d><h>18:57</h><w>nathanmarz</w>see <code>defnav</code></z><z id="t1529866683" t="nathanmarz navigate to pair of [list-of-nodes index] , and then make custom CHILDREN navigator that does the search for indices that are direct children of currently navigated index"><y>#</y><d>2018-06-24</d><h>18:58</h><w>nathanmarz</w>navigate to pair of <code>[list-of-nodes index]</code>, and then make custom <code>CHILDREN</code> navigator that does the search for indices that are direct children of currently navigated index</z><z id="t1529907296" t="pepe Thank you very much! I think it is little bit over my Specter-fu, but I will try."><y>#</y><d>2018-06-25</d><h>06:14</h><r>pepe</r>Thank you very much! I think it is little bit over my Specter-fu, but I will try.</z><z id="t1529925507" t="nathanmarz @pepe looks like (use &apos;com.rpl.specter) (def data [{:id 0} {:id 1} {:id 2 :parent-id 1 :val 1} {:id 3 :parent-id 1 :val 1} {:id 4 :parent-id 2 :val 2} {:id 5 :parent-id 3 :val 2} {:id 6 :parent-id 3 :val 2} {:id 7 :parent-id 0 :val 100} {:id 8 :parent-id 7 :val 200} {:id 9 :parent-id 6 :val 3}]) (defn- node-index [graph id] (select-first [INDEXED-VALS (selected? LAST :id (pred= id)) FIRST] graph )) (defnav to-node [id] (select* [this graph next-fn] (if-let [i (node-index graph id)] (next-fn [graph i]) NONE )) (transform* [this graph next-fn] (if-let [i (node-index graph id)] (first (next-fn [graph i])) graph ))) (defn- child-indices [graph id] (select [INDEXED-VALS (selected? LAST :parent-id (pred= id)) FIRST] graph )) (defnav CHILDREN [] (select* [this [graph i] next-fn] (let [id (-&gt; graph (nth i) :id) child-i (child-indices graph id)] (if (empty? child-i) NONE (doseq [i child-i] (next-fn [graph i]) )))) (transform* [this [graph i] next-fn] (let [id (-&gt; graph (nth i) :id) child-i (child-indices graph id)] (if (empty? child-i) [graph i] [(reduce (fn [graph ci] (first (next-fn [graph ci]))) graph child-i ) i] )))) (defnav NODE [] (select* [this [graph i] next-fn] (next-fn (nth graph i)) ) (transform* [this [graph i] next-fn] [(transform (nthpath i) next-fn graph) i] )) (def DESCENDANTS (recursive-path [] p (stay-then-continue CHILDREN p))) "><y>#</y><d>2018-06-25</d><h>11:18</h><w>nathanmarz</w>@pepe looks like
<pre>(use &apos;com.rpl.specter)

(def data
  [{:id 0}
   {:id 1}
   {:id 2 :parent-id 1 :val 1}
   {:id 3 :parent-id 1 :val 1}
   {:id 4 :parent-id 2 :val 2}
   {:id 5 :parent-id 3 :val 2}
   {:id 6 :parent-id 3 :val 2}
   {:id 7 :parent-id 0 :val 100}
   {:id 8 :parent-id 7 :val 200}
   {:id 9 :parent-id 6 :val 3}])

(defn- node-index [graph id]
  (select-first
    [INDEXED-VALS
     (selected? LAST :id (pred= id))
     FIRST]
    graph
    ))

(defnav to-node [id]
  (select* [this graph next-fn]
    (if-let [i (node-index graph id)]
      (next-fn [graph i])
      NONE
      ))
  (transform* [this graph next-fn]
    (if-let [i (node-index graph id)]
      (first (next-fn [graph i]))
      graph
      )))

(defn- child-indices [graph id]
  (select
    [INDEXED-VALS
     (selected? LAST :parent-id (pred= id))
     FIRST]
    graph
    ))

(defnav CHILDREN []
  (select* [this [graph i] next-fn]
    (let [id (-&gt; graph (nth i) :id)
          child-i (child-indices graph id)]
      (if (empty? child-i)
        NONE
        (doseq [i child-i]
          (next-fn [graph i])
          ))))
  (transform* [this [graph i] next-fn]
    (let [id (-&gt; graph (nth i) :id)
          child-i (child-indices graph id)]
      (if (empty? child-i)
        [graph i]
        [(reduce
          (fn [graph ci] (first (next-fn [graph ci])))
          graph
          child-i
          )
         i]
         ))))

(defnav NODE []
  (select* [this [graph i] next-fn]
    (next-fn (nth graph i))
    )
  (transform* [this [graph i] next-fn]
    [(transform (nthpath i) next-fn graph) i]
    ))

(def DESCENDANTS (recursive-path [] p (stay-then-continue CHILDREN p)))
</pre></z><z id="t1529931150" t="pepe @U173SEFUN thank you very much for your time. I can&apos;t imagine coming with something like this myself. I will report back, how it works for me."><y>#</y><d>2018-06-25</d><h>12:52</h><r>pepe</r>@U173SEFUN thank you very much for your time. I can&apos;t imagine coming with something like this myself. I will report back, how it works for me.</z><z id="t1530012911" t="pepe I got to try it today and it again gives me Maximum call stack exceeded on around 1000 nodes. It seems I have to go recursive 🙂 . Still thank you very much, I have learned a lot from your code!"><y>#</y><d>2018-06-26</d><h>11:35</h><r>pepe</r>I got to try it today and it again gives me Maximum call stack exceeded on around 1000 nodes. It seems I have to go recursive <b>🙂</b>. Still thank you very much, I have learned a lot from your code!</z><z id="t1529932554" t="firstclassfunc Morning. I am trying to convert the hiccup output from instaparse into an associative structure. Is specter a good solution for converting [:entity ([:name &quot;J&quot;] [:locations ([:address [:slot &quot;slot0&quot;] [:port &quot;1&quot;]] [:address [:slot &quot;slot1&quot;] [:port &quot;2&quot;]] [:address [:slot &quot;slot2&quot;] [:port &quot;3&quot;]] [:address [:slot &quot;slot3&quot;] [:port &quot;4&quot;]] [:address [:slot &quot;slot4&quot;] [:port &quot;5&quot;]] [:address [:slot &quot;slot5&quot;] [:port &quot;6&quot;]])])] into {:entity [{:name &quot;J&quot;} {:locations [{:address {:slot &quot;slot0&quot; :port &quot;1&quot;}} {:address {:slot &quot;slot1&quot; :port &quot;2&quot;}} {:address {:slot &quot;slot2&quot; :port &quot;3&quot;}} {:address {:slot &quot;slot3&quot; :port &quot;4&quot;}} {:address {:slot &quot;slot4&quot; :port &quot;5&quot;}} {:address {:slot &quot;slot5&quot; :port &quot;6&quot;}}]}]} ?"><y>#</y><d>2018-06-25</d><h>13:15</h><w>firstclassfunc</w>Morning. I am trying to convert the <code>hiccup</code> output from <code>instaparse</code> into an associative structure. Is <code>specter</code> a good solution for converting <pre>[:entity
 ([:name &quot;J&quot;]
  [:locations
   ([:address [:slot &quot;slot0&quot;] [:port &quot;1&quot;]]
    [:address [:slot &quot;slot1&quot;] [:port &quot;2&quot;]]
    [:address [:slot &quot;slot2&quot;] [:port &quot;3&quot;]]
    [:address [:slot &quot;slot3&quot;] [:port &quot;4&quot;]]
    [:address [:slot &quot;slot4&quot;] [:port &quot;5&quot;]]
    [:address [:slot &quot;slot5&quot;] [:port &quot;6&quot;]])])]</pre>  into <pre>{:entity 
   [{:name &quot;J&quot;}
    {:locations 
     [{:address {:slot &quot;slot0&quot; :port &quot;1&quot;}} 
      {:address {:slot &quot;slot1&quot; :port &quot;2&quot;}}
      {:address {:slot &quot;slot2&quot; :port &quot;3&quot;}}
      {:address {:slot &quot;slot3&quot; :port &quot;4&quot;}}
      {:address {:slot &quot;slot4&quot; :port &quot;5&quot;}}
      {:address {:slot &quot;slot5&quot; :port &quot;6&quot;}}]}]}</pre>?</z><z id="t1529932832" t="nathanmarz @firstclassfunc is the transformation vector -&gt; map and list -&gt; vector for all reachable vectors and lists?"><y>#</y><d>2018-06-25</d><h>13:20</h><w>nathanmarz</w>@firstclassfunc is the transformation vector -&gt; map and list -&gt; vector for all reachable vectors and lists?</z><z id="t1529932861" t="firstclassfunc yes"><y>#</y><d>2018-06-25</d><h>13:21</h><w>firstclassfunc</w>yes</z><z id="t1529933352" t="nathanmarz oh it&apos;s a little more complicated"><y>#</y><d>2018-06-25</d><h>13:29</h><w>nathanmarz</w>oh it&apos;s a little more complicated</z><z id="t1529933387" t="nathanmarz since the :slot and :port vectors get combined into a single map"><y>#</y><d>2018-06-25</d><h>13:29</h><w>nathanmarz</w>since the <code>:slot</code> and <code>:port</code> vectors get combined into a single map</z><z id="t1529933406" t="firstclassfunc ok well it can be done in multiple steps.."><y>#</y><d>2018-06-25</d><h>13:30</h><w>firstclassfunc</w>ok well it can be done in multiple steps..</z><z id="t1529933428" t="nathanmarz but the general structure is (def NODES (recursive-path [] p (if-path coll? (continue-then-stay ALL p) ))) (multi-transform [NODES (if-path vector? (terminal vec-&gt;map) (terminal vec) )] data ) "><y>#</y><d>2018-06-25</d><h>13:30</h><w>nathanmarz</w>but the general structure is
<pre>(def NODES
  (recursive-path [] p
    (if-path coll?
      (continue-then-stay ALL p)
      )))

(multi-transform
  [NODES
   (if-path vector?
     (terminal vec-&gt;map)
     (terminal vec)
     )]
  data
  )
</pre></z><z id="t1529933436" t="nathanmarz you fill in the vec-&gt;map function"><y>#</y><d>2018-06-25</d><h>13:30</h><w>nathanmarz</w>you fill in the <code>vec-&gt;map</code> function</z><z id="t1529933450" t="firstclassfunc ah cool. Thanks so much (y)"><y>#</y><d>2018-06-25</d><h>13:30</h><w>firstclassfunc</w>ah cool. Thanks so much (y)</z><z id="t1529983930" t="vigilancetech Can anyone tell me why I&apos;m getting: WARNING: Use of undeclared Var hello-world.core/ALL....?? Here&apos;s a repo that demos the error for me: https://github.com/vigilancetech-com/hello-world"><y>#</y><d>2018-06-26</d><h>03:32</h><w>vigilancetech</w>Can anyone tell me why I&apos;m getting: WARNING: Use of undeclared Var hello-world.core/ALL....??   Here&apos;s a repo that demos the error for me:

<a href="https://github.com/vigilancetech-com/hello-world" target="_blank">https://github.com/vigilancetech-com/hello-world</a></z><z id="t1530001434" t="pepe Both ALL and END needs to have namespace so in your case sp/ALL sp/END"><y>#</y><d>2018-06-26</d><h>08:23</h><r>pepe</r>Both ALL and END needs to have namespace so in your case sp/ALL sp/END</z><z id="t1530023933" t="vigilancetech ah! That&apos;s it! Thank you! It was my misperception that the leading macro (select, transform, setval, etc...) processed those kind of like keywords and not that they were functions in and of themselves."><y>#</y><d>2018-06-26</d><h>14:38</h><r>vigilancetech</r>ah!   That&apos;s it!   Thank you!  It was my misperception that the leading macro (select, transform, setval, etc...) processed those kind of like keywords and not that they were functions in and of themselves.</z><z id="t1530192636" t="zalky Hi all, can anyone help explain the difference between selected? and filterer ? Bit hazy on the difference."><y>#</y><d>2018-06-28</d><h>13:30</h><w>zalky</w>Hi all, can anyone help explain the difference between <code>selected?</code> and <code>filterer</code>? Bit hazy on the difference.</z><z id="t1530193131" t="zalky Oh, hmm... nm, I think I figured it out."><y>#</y><d>2018-06-28</d><h>13:38</h><w>zalky</w>Oh, hmm... nm, I think I figured it out.</z><z id="t1530297233" t="Bravi why isn’t this library in core? 😄"><y>#</y><d>2018-06-29</d><h>18:33</h><w>Bravi</w>why isn’t this library in core? <b>😄</b></z><z id="t1530297240" t="Bravi this is so powerful!"><y>#</y><d>2018-06-29</d><h>18:34</h><w>Bravi</w>this is so powerful!</z><z id="t1530297343" t="Bravi something I would have written in JS like this: userGroups .map(group =&gt; ({ ...group, users: group.users .map( user =&gt; &amp;&amp; user.profileViews &amp;&amp; user.profileViews.count &gt; 0 ? ({...user, profileViews: { ...user.profileViews, count: user.profileViews.count + 1, }}) : user ) })); managed to write using specter like this (transform [ALL :users ALL #(:online %) :profile-views :count (partial &lt; 0)] inc) "><y>#</y><d>2018-06-29</d><h>18:35</h><w>Bravi</w>something I would have written in JS like this:
<pre>userGroups
  .map(group =&gt; ({
    ...group,
    users: group.users
      .map( user =&gt;  &amp;&amp; user.profileViews &amp;&amp; user.profileViews.count &gt; 0
            ? ({...user,
                profileViews: {
                  ...user.profileViews,
                  count: user.profileViews.count + 1,
                }})
            : user
          )
  }));
</pre>
managed to write using specter like this
<pre>(transform [ALL :users ALL #(:online %) :profile-views :count (partial &lt; 0)] inc)
</pre></z><z id="t1530628940" t="pepe And you only scratched the surface in your example. I am doing things with it, I strongly believe are almost impossible in other langs/libs. And I still consider myself Specter newbie 🙂"><y>#</y><d>2018-07-03</d><h>14:42</h><r>pepe</r>And you only scratched the surface in your example. I am doing things with it, I strongly believe are almost impossible in other langs/libs. And I still consider myself Specter newbie <b>🙂</b></z><z id="t1530714318" t="Bravi would you mind posting some examples please? I’m struggling to find some good examples / solutions to problems"><y>#</y><d>2018-07-04</d><h>14:25</h><r>Bravi</r>would you mind posting some examples please? I’m struggling to find some good examples / solutions to problems</z><z id="t1530298838" t="nathanmarz @bravilogy https://groups.google.com/forum/#!searchin/clojure/contribute$20specter%7Csort:date/clojure/qN1UPMVQmaM/uVUYENF6BwAJ"><y>#</y><d>2018-06-29</d><h>19:00</h><w>nathanmarz</w>@bravilogy <a href="https://groups.google.com/forum/#!searchin/clojure/contribute$20specter%7Csort:date/clojure/qN1UPMVQmaM/uVUYENF6BwAJ" target="_blank">https://groups.google.com/forum/#!searchin/clojure/contribute$20specter%7Csort:date/clojure/qN1UPMVQmaM/uVUYENF6BwAJ</a></z><z id="t1530395164" t="jsa-aerial say you have a map { ... K V} and you are transforming the map via ALL with a transform function which returns NONE for V, strictly speaking you return [K NONE]. This seems to remove the [K V] pair entirely (exactly what I would like) but I can&apos;t find anything in the documentation indicating that this is the intended behavior. There are things addressing map KEYS being xformed to NONE for removal, but nothing about values. Is this intended behavior that can be counted on in future?"><y>#</y><d>2018-06-30</d><h>21:46</h><w>jsa-aerial</w>say you have a map { ... K V} and you are transforming the map via ALL with a transform function which returns NONE for V, strictly speaking you return [K NONE]. This seems to remove the [K V] pair entirely (exactly what I would like) but I can&apos;t find anything in the documentation indicating that this is the intended behavior. There are things addressing map KEYS being xformed to NONE for removal, but nothing about values. Is this intended behavior that can be counted on in future?</z><z id="t1530407091" t="nathanmarz @jsa-aerial yes, that&apos;s intended behavior"><y>#</y><d>2018-07-01</d><h>01:04</h><w>nathanmarz</w>@jsa-aerial yes, that&apos;s intended behavior</z><z id="t1530890688" t="jsa-aerial suppose you do not have a fixed (literal) path for things like setval, transform, etc. So, you have something like (transform [ATOM (apply keypath ks)] inc db) . Does the &apos;This macro will do inline compilation and caching of the path.&apos; still apply in this sort of situation? If not, is it still comparable in performance to update-in?"><y>#</y><d>2018-07-06</d><h>15:24</h><w>jsa-aerial</w>suppose you do not have a fixed (literal) path for things like setval, transform, etc. So, you have something like <code>(transform [ATOM (apply keypath ks)] inc db)</code>. Does the &apos;This macro will do inline compilation and caching of the path.&apos; still apply in this sort of situation? If not, is it still comparable in performance to update-in?</z><z id="t1530890711" t="jsa-aerial @nathanmarz ^^^"><y>#</y><d>2018-07-06</d><h>15:25</h><w>jsa-aerial</w>@nathanmarz ^^^</z><z id="t1530898649" t="nathanmarz @jsa-aerial since ks is not static, you pay the cost of the apply and the keypath expansion on every invocation"><y>#</y><d>2018-07-06</d><h>17:37</h><w>nathanmarz</w>@jsa-aerial since <code>ks</code> is not static, you pay the cost of the <code>apply</code> and the <code>keypath</code> expansion on every invocation</z><z id="t1530898699" t="nathanmarz not sure how it will compare to update-in but there will be a noticeable performance hit"><y>#</y><d>2018-07-06</d><h>17:38</h><w>nathanmarz</w>not sure how it will compare to <code>update-in</code> but there will be a noticeable performance hit</z><z id="t1531181532" t="jsa-aerial Adventures in CLJS now... I require [com.rpl.specter :as sp] and require-macros [com.rpl.specter.macros :refer [select-one transform setval]] . When trying to compile, the following is issued: &apos;Invalid :refer, macro com.rpl.specter.macros/setval does not exist&apos;."><y>#</y><d>2018-07-10</d><h>00:12</h><w>jsa-aerial</w>Adventures in CLJS now... I require <code>[com.rpl.specter :as sp]</code> and require-macros <code>[com.rpl.specter.macros :refer [select-one transform setval]]</code>.  When trying to compile, the following is issued: &apos;Invalid :refer, macro com.rpl.specter.macros/setval does not exist&apos;.</z><z id="t1531181548" t="jsa-aerial I am using figwheel"><y>#</y><d>2018-07-10</d><h>00:12</h><w>jsa-aerial</w>I am using figwheel</z><z id="t1531181577" t="jsa-aerial Anyone using Specter in CLJS land have any ideas?"><y>#</y><d>2018-07-10</d><h>00:12</h><w>jsa-aerial</w>Anyone using Specter in CLJS land have any ideas?</z><z id="t1531181724" t="jsa-aerial OK, it looking further in the doc, I see the CLJS incantation. Let me try that and see if it makes this go away."><y>#</y><d>2018-07-10</d><h>00:15</h><w>jsa-aerial</w>OK, it looking further in the doc, I see the CLJS incantation. Let me try that and see if it makes this go away.</z><z id="t1531181897" t="jsa-aerial Yes, that fixes it. Sorry for the noise."><y>#</y><d>2018-07-10</d><h>00:18</h><w>jsa-aerial</w>Yes, that fixes it. Sorry for the noise.</z><z id="t1531223656" t="souenzzo Require from com.rpl.specter. this namespace .macros is not used anymore"><y>#</y><d>2018-07-10</d><h>11:54</h><w>souenzzo</w>Require from com.rpl.specter. this namespace .macros is not used anymore</z><z id="t1531226615" t="Bravi @jsa-aerial I always use sp/select-one , sp/ALL and etc"><y>#</y><d>2018-07-10</d><h>12:43</h><w>Bravi</w>@jsa-aerial I always use <code>sp/select-one</code>, <code>sp/ALL</code> and etc</z><z id="t1531226619" t="Bravi in cljs"><y>#</y><d>2018-07-10</d><h>12:43</h><w>Bravi</w>in cljs</z><z id="t1531232150" t="jsa-aerial @bravilogy That&apos;s what I do in CLJ - always namspace qualified for everything. But I thought you needed to explicitly name the macros in a require-macros or :refer-macros them for them to be available in CLJS land. Since macros are expanded and such in the JVM (well unless you are using self hosted) I admit I don&apos;t really understand the implementation details of how they are made available in CLJS."><y>#</y><d>2018-07-10</d><h>14:15</h><w>jsa-aerial</w>@bravilogy That&apos;s what I do in CLJ - always namspace qualified for everything. But I thought you needed to explicitly name the macros in a require-macros or :refer-macros them for them to be available in CLJS land. Since macros are expanded and such in the JVM (well unless you are using self hosted) I admit I don&apos;t really understand the implementation details of how they are made available in CLJS.</z><z id="t1531232684" t="Bravi yeah I was just implying the fact that specter works differently in cljs, hence I don’t investigate any further than that 😄 haha. i just namespace them all"><y>#</y><d>2018-07-10</d><h>14:24</h><w>Bravi</w>yeah I was just implying the fact that specter works differently in cljs, hence I don’t investigate any further than that <b>😄</b> haha. i just namespace them all</z><z id="t1531234366" t="jsa-aerial Well, other than pulling in the macro stuff (which is anything in cljs land) all the specter code I am using works exactly as in clojure. Very cool!"><y>#</y><d>2018-07-10</d><h>14:52</h><w>jsa-aerial</w>Well, other than pulling in the macro stuff (which is anything in cljs land) all the specter code I am using works exactly as in clojure. Very cool!</z><z id="t1531234386" t="jsa-aerial No &apos;porting&apos; at all - just use!"><y>#</y><d>2018-07-10</d><h>14:53</h><w>jsa-aerial</w>No &apos;porting&apos; at all - just use!</z><z id="t1531343002" t="funkrider hi - as a cljs noob I want to try out specter at the repl. I am using (require &apos;[com.rpl.specter :as sp]) and then if i try to invoke a test using: (sp/select [sp/ALL] [1 2]) i get a big nasty error about No protocol method ImplicitNav.implicit-nav defined for type com.rpl.specter/t_com$specter79300: [object Object]]"><y>#</y><d>2018-07-11</d><h>21:03</h><w>funkrider</w>hi - as a cljs noob I want to try out specter at the repl. I am using <code>(require &apos;[com.rpl.specter :as sp])</code> and then if i try to invoke a test using: <code>(sp/select [sp/ALL] [1 2])</code>   i get a big nasty error about <code>No protocol method ImplicitNav.implicit-nav defined for type com.rpl.specter/t_com$specter79300: [object Object]]</code></z><z id="t1531343011" t="funkrider Any help would be most appreciated"><y>#</y><d>2018-07-11</d><h>21:03</h><w>funkrider</w>Any help would be most appreciated</z><z id="t1531343590" t="nathanmarz @ian.davies works fine for me"><y>#</y><d>2018-07-11</d><h>21:13</h><w>nathanmarz</w>@ian.davies works fine for me</z><z id="t1531343653" t="nathanmarz try doing it from a checkout of specter from github"><y>#</y><d>2018-07-11</d><h>21:14</h><w>nathanmarz</w>try doing it from a checkout of specter from github</z><z id="t1531343672" t="nathanmarz run ./scripts/cljs-repl.sh"><y>#</y><d>2018-07-11</d><h>21:14</h><w>nathanmarz</w>run <code>./scripts/cljs-repl.sh</code></z><z id="t1531381492" t="pepe I did not know about this. It is cool."><y>#</y><d>2018-07-12</d><h>07:44</h><r>pepe</r>I did not know about this. It is cool.</z><z id="t1531344386" t="funkrider oh ok ill give it a go. Thanks @nathanmarz"><y>#</y><d>2018-07-11</d><h>21:26</h><w>funkrider</w>oh ok ill give it a go. Thanks @nathanmarz</z><z id="t1531406365" t="vigilancetech I got this strange situation: I&apos;m using specter from clojurescript (hoplon) to build up a map in a function which when I feed it by hand works fine, but when I map values into it, it munges the map up. Is mapping it making it try and do the operations in parallel somehow? If so, how would I serialize them?"><y>#</y><d>2018-07-12</d><h>14:39</h><w>vigilancetech</w>I got this strange situation:  I&apos;m using specter from clojurescript (hoplon) to build up a map in a function which when I feed it by hand works fine, but when I map values into it, it munges the map up.   Is mapping it making it try and do the operations in parallel somehow?   If so, how would I serialize them?</z><z id="t1531406986" t="nathanmarz @vigilancetech can you show the code?"><y>#</y><d>2018-07-12</d><h>14:49</h><w>nathanmarz</w>@vigilancetech can you show the code?</z><z id="t1531407131" t="vigilancetech (defn stow-effect! [dev effect] (let [x (sp/setval [:lights (id-&gt;type dev) (id-&gt;key dev)] effect (:root @ui-state)) y (sp/setval [:lights :all (id-&gt;key dev)] effect x)] ;(s/set-ui-state! @conn y) ;; there&apos;s some kind of issue with multi-processing here (reset! ui-state (sp/setval [:root] y @ui-state)))) "><y>#</y><d>2018-07-12</d><h>14:52</h><w>vigilancetech</w><pre>(defn stow-effect! [dev effect]
  (let [x (sp/setval [:lights (id-&gt;type dev) (id-&gt;key dev)] effect (:root @ui-state))
        y (sp/setval [:lights :all (id-&gt;key dev)] effect x)]
    ;(s/set-ui-state! @conn y)
    ;; there&apos;s some kind of issue with multi-processing here
    (reset! ui-state (sp/setval [:root] y @ui-state))))
</pre></z><z id="t1531407153" t="vigilancetech (defn checkbox-checked [device-type] (let [x (map vals (sp/select [(n-device-records device-type) (sp/submap [:id :effect])] @data))] (map #(apply stow-effect! %) x) x)) "><y>#</y><d>2018-07-12</d><h>14:52</h><w>vigilancetech</w><pre>(defn checkbox-checked [device-type]
  (let [x (map vals (sp/select [(n-device-records device-type) (sp/submap [:id :effect])] @data))]
    (map #(apply stow-effect! %) x)
    x))
</pre></z><z id="t1531407328" t="vigilancetech when I feed it with the second function it makes multiple :root tags, but when I feed it by hand it works properly making only one"><y>#</y><d>2018-07-12</d><h>14:55</h><w>vigilancetech</w>when I feed it with the second function it makes multiple :root tags, but when I feed it by hand it works properly making only one</z><z id="t1531407704" t="nathanmarz what is n-device-records , id-&gt;type , id-&gt;key ?"><y>#</y><d>2018-07-12</d><h>15:01</h><w>nathanmarz</w>what is <code>n-device-records</code>, <code>id-&gt;type</code>, <code>id-&gt;key</code>?</z><z id="t1531407806" t="nathanmarz and what do you mean by &quot;makes multiple :root tags&quot;?"><y>#</y><d>2018-07-12</d><h>15:03</h><w>nathanmarz</w>and what do you mean by &quot;makes multiple :root tags&quot;?</z><z id="t1531408557" t="nathanmarz doesn&apos;t look like (map #(apply stow-effect! %) x) will do anything"><y>#</y><d>2018-07-12</d><h>15:15</h><w>nathanmarz</w>doesn&apos;t look like <code>(map #(apply stow-effect! %) x)</code> will do anything</z><z id="t1531408562" t="nathanmarz since map is lazy"><y>#</y><d>2018-07-12</d><h>15:16</h><w>nathanmarz</w>since <code>map</code> is lazy</z><z id="t1531408937" t="vigilancetech cljs.user&gt; (s/set-ui-state! @d/conn nil ) nil cljs.user&gt; (s/get-ui-state @d/conn) nil cljs.user&gt; @d/ui-state {:root nil} cljs.user&gt; (d/checkbox-checked :fan) ((&quot;Fan 0&quot; &quot;roll&quot;) (&quot;Fan 1&quot; &quot;static_color&quot;) (&quot;Fan 2&quot; &quot;none&quot;) (&quot;Fan 3&quot; &quot;none&quot;) (&quot;Fan 4&quot; &quot;none&quot;) (&quot;Fan 5&quot; &quot;none&quot;)) cljs.user&gt; @d/ui-state {:root nil} cljs.user&gt; (s/get-ui-state @d/conn) nil cljs.user&gt; @d/ui-state {:root nil} cljs.user&gt; (d/stow-effect! &quot;Fan 0&quot; &quot;roll&quot;) {:root {:lights {:all {:Fan_0 &quot;roll&quot;}, :fan {:Fan_0 &quot;roll&quot;}}}} cljs.user&gt; @d/ui-state {:root {:lights {:all {:Fan_0 &quot;roll&quot;}, :fan {:Fan_0 &quot;roll&quot;}}}} cljs.user&gt; (d/stow-effect! &quot;Fan 1&quot; &quot;static_color&quot;) {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}}}} cljs.user&gt; (d/stow-effect! &quot;Fan 2&quot; &quot;none&quot;) {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}}}} cljs.user&gt; (d/stow-effect! &quot;Strip 0&quot; &quot;police&quot;) {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Strip_0 &quot;police&quot;}, :strip {:Strip_0 &quot;police&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}}}} cljs.user&gt; (s/set-ui-state! @d/conn nil ) nil cljs.user&gt; (s/get-ui-state @d/conn) nil cljs.user&gt; @d/ui-state {:root nil} cljs.user&gt; (map #(apply d/stow-effect! %) &apos;((&quot;Fan 0&quot; &quot;roll&quot;) (&quot;Fan 1&quot; &quot;static_color&quot;) (&quot;Fan 2&quot; &quot;none&quot;) (&quot;Fan 3&quot; &quot;none&quot;) (&quot;Fan 4&quot; &quot;none&quot;) (&quot;Fan 5&quot; &quot;none&quot;))) ({:root {:lights {:all {:Fan_0 &quot;roll&quot;}, :fan {:Fan_0 &quot;roll&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_3 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_3 &quot;none&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_5 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_5 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}}}}) cljs.user&gt; "><y>#</y><d>2018-07-12</d><h>15:22</h><w>vigilancetech</w><pre>cljs.user&gt; (s/set-ui-state! @d/conn nil )
nil
cljs.user&gt; (s/get-ui-state @d/conn)
nil
cljs.user&gt; @d/ui-state
{:root nil}
cljs.user&gt; (d/checkbox-checked :fan)
((&quot;Fan 0&quot; &quot;roll&quot;) (&quot;Fan 1&quot; &quot;static_color&quot;) (&quot;Fan 2&quot; &quot;none&quot;) (&quot;Fan 3&quot; &quot;none&quot;) (&quot;Fan 4&quot; &quot;none&quot;) (&quot;Fan 5&quot; &quot;none&quot;))
cljs.user&gt; @d/ui-state
{:root nil}
cljs.user&gt; (s/get-ui-state @d/conn)
nil
cljs.user&gt; @d/ui-state
{:root nil}
cljs.user&gt; (d/stow-effect! &quot;Fan 0&quot; &quot;roll&quot;)
{:root {:lights {:all {:Fan_0 &quot;roll&quot;}, :fan {:Fan_0 &quot;roll&quot;}}}}
cljs.user&gt; @d/ui-state
{:root {:lights {:all {:Fan_0 &quot;roll&quot;}, :fan {:Fan_0 &quot;roll&quot;}}}}
cljs.user&gt; (d/stow-effect! &quot;Fan 1&quot; &quot;static_color&quot;)
{:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}}}}
cljs.user&gt; (d/stow-effect! &quot;Fan 2&quot; &quot;none&quot;)
{:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}}}}
cljs.user&gt; (d/stow-effect! &quot;Strip 0&quot; &quot;police&quot;)
{:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Strip_0 &quot;police&quot;}, :strip {:Strip_0 &quot;police&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}}}}
cljs.user&gt; (s/set-ui-state! @d/conn nil )
nil
cljs.user&gt; (s/get-ui-state @d/conn)
nil
cljs.user&gt; @d/ui-state
{:root nil}
cljs.user&gt; (map #(apply d/stow-effect! %) &apos;((&quot;Fan 0&quot; &quot;roll&quot;) (&quot;Fan 1&quot; &quot;static_color&quot;) (&quot;Fan 2&quot; &quot;none&quot;) (&quot;Fan 3&quot; &quot;none&quot;) (&quot;Fan 4&quot; &quot;none&quot;) (&quot;Fan 5&quot; &quot;none&quot;)))
({:root {:lights {:all {:Fan_0 &quot;roll&quot;}, :fan {:Fan_0 &quot;roll&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_3 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_3 &quot;none&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}}}} {:root {:lights {:all {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_5 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}, :fan {:Fan_0 &quot;roll&quot;, :Fan_1 &quot;static_color&quot;, :Fan_2 &quot;none&quot;, :Fan_5 &quot;none&quot;, :Fan_4 &quot;none&quot;, :Fan_3 &quot;none&quot;}}}})
cljs.user&gt; 
</pre></z><z id="t1531408996" t="nathanmarz the repl realizes lazy sequences when it prints it"><y>#</y><d>2018-07-12</d><h>15:23</h><w>nathanmarz</w>the repl realizes lazy sequences when it prints it</z><z id="t1531409037" t="nathanmarz the way you wrote checkbox-checked will not"><y>#</y><d>2018-07-12</d><h>15:23</h><w>nathanmarz</w>the way you wrote <code>checkbox-checked</code> will not</z><z id="t1531409055" t="nathanmarz better to write that sort of code with doseq"><y>#</y><d>2018-07-12</d><h>15:24</h><w>nathanmarz</w>better to write that sort of code with <code>doseq</code></z><z id="t1531409126" t="vigilancetech ah, okay"><y>#</y><d>2018-07-12</d><h>15:25</h><w>vigilancetech</w>ah, okay</z><z id="t1531409139" t="vigilancetech think that&apos;ll fix the multiple :root tag thing?"><y>#</y><d>2018-07-12</d><h>15:25</h><w>vigilancetech</w>think that&apos;ll fix the multiple :root tag thing?</z></g><g id="s21"><z id="t1531409202" t="nathanmarz don&apos;t know what you mean by that"><y>#</y><d>2018-07-12</d><h>15:26</h><w>nathanmarz</w>don&apos;t know what you mean by that</z><z id="t1531409223" t="nathanmarz or what those other function references are"><y>#</y><d>2018-07-12</d><h>15:27</h><w>nathanmarz</w>or what those other function references are</z><z id="t1531409338" t="vigilancetech (defn n-device-records [type] [:lights sp/ALL #(= (:type %) type)])"><y>#</y><d>2018-07-12</d><h>15:28</h><w>vigilancetech</w>(defn n-device-records [type] [:lights sp/ALL #(= (:type %) type)])</z><z id="t1531409367" t="vigilancetech (defn id-&gt;key [id] (keyword (st/replace id \space \_)))"><y>#</y><d>2018-07-12</d><h>15:29</h><w>vigilancetech</w>(defn id-&gt;key [id] (keyword (st/replace id \space \_)))</z><z id="t1531409413" t="vigilancetech (defn id-&gt;type [id] (let [x (st/split (st/lower-case id) #&quot; &quot;)] (keyword (if (&gt; (count x) 2) (str (first x) \_ (second x)) (first x))))) "><y>#</y><d>2018-07-12</d><h>15:30</h><w>vigilancetech</w><pre>(defn id-&gt;type [id] (let [x (st/split (st/lower-case id) #&quot; &quot;)]
                      (keyword (if (&gt; (count x) 2)
                                 (str (first x) \_ (second x))
                                 (first x)))))

</pre></z><z id="t1531409473" t="vigilancetech n-device-records navigates to all the records for a certain type of device. The others just convert from a string to a (spaceless) tag"><y>#</y><d>2018-07-12</d><h>15:31</h><w>vigilancetech</w>n-device-records navigates to all the records for a certain type of device.  The others just convert from a string to a (spaceless) tag</z><z id="t1531409542" t="vigilancetech thing is when I feed stow-effect! by hand, it builds ui-state properly with only one root tag, but when I map the values in, it screws it up, appending multiple root tags"><y>#</y><d>2018-07-12</d><h>15:32</h><w>vigilancetech</w>thing is when I feed stow-effect! by hand, it builds ui-state properly with only one root tag, but when I map the values in, it screws it up, appending multiple root tags</z><z id="t1531409825" t="vigilancetech could that be a specter thing? Or does that have something to do with map parallelizing the operation?"><y>#</y><d>2018-07-12</d><h>15:37</h><w>vigilancetech</w>could that be a specter thing?  Or does that have something to do with map parallelizing the operation?</z><z id="t1531409894" t="alexyakushev In fact, map can&apos;t &quot;parallelize&quot; anything."><y>#</y><d>2018-07-12</d><h>15:38</h><w>alexyakushev</w>In fact, map can&apos;t &quot;parallelize&quot; anything.</z><z id="t1531409908" t="alexyakushev Try replacing map with mapv , would it work?"><y>#</y><d>2018-07-12</d><h>15:38</h><w>alexyakushev</w>Try replacing <code>map</code> with <code>mapv</code>, would it work?</z><z id="t1531410070" t="vigilancetech nope, same thing"><y>#</y><d>2018-07-12</d><h>15:41</h><w>vigilancetech</w>nope, same thing</z><z id="t1531410831" t="nathanmarz where is it appending multiple root tags?"><y>#</y><d>2018-07-12</d><h>15:53</h><w>nathanmarz</w>where is it appending multiple root tags?</z><z id="t1531410877" t="vigilancetech when I do: (mapv #(apply d/stow-effect! %) &apos;((&quot;Fan 0&quot; &quot;roll&quot;) (&quot;Fan 1&quot; &quot;static_color&quot;) (&quot;Fan 2&quot; &quot;none&quot;) (&quot;Fan 3&quot; &quot;none&quot;) (&quot;Fan 4&quot; &quot;none&quot;) (&quot;Fan 5&quot; &quot;none&quot;))) "><y>#</y><d>2018-07-12</d><h>15:54</h><w>vigilancetech</w>when I do:
<pre>(mapv #(apply d/stow-effect! %) &apos;((&quot;Fan 0&quot; &quot;roll&quot;) (&quot;Fan 1&quot; &quot;static_color&quot;) (&quot;Fan 2&quot; &quot;none&quot;) (&quot;Fan 3&quot; &quot;none&quot;) (&quot;Fan 4&quot; &quot;none&quot;) (&quot;Fan 5&quot; &quot;none&quot;)))
</pre></z><z id="t1531410899" t="vigilancetech the result has multiple root tags, but if I feed those values in by hand, it works correctly, with only one root tag"><y>#</y><d>2018-07-12</d><h>15:54</h><w>vigilancetech</w>the result has multiple root tags, but if I feed those values in by hand, it works correctly, with only one root tag</z><z id="t1531410978" t="vigilancetech its supposed to be {:root {:lights {:all {all records} {:fan {fan devices} :strip {strip devices.}}}}}"><y>#</y><d>2018-07-12</d><h>15:56</h><w>vigilancetech</w>its supposed to be {:root {:lights {:all {all records} {:fan {fan devices} :strip {strip devices.}}}}}</z><z id="t1531411047" t="nathanmarz by result you mean the value of the atom ui-state ?"><y>#</y><d>2018-07-12</d><h>15:57</h><w>nathanmarz</w>by result you mean the value of the atom <code>ui-state</code>?</z><z id="t1531411060" t="vigilancetech yes"><y>#</y><d>2018-07-12</d><h>15:57</h><w>vigilancetech</w>yes</z><z id="t1531411089" t="nathanmarz what does it look like before and after?"><y>#</y><d>2018-07-12</d><h>15:58</h><w>nathanmarz</w>what does it look like before and after?</z><z id="t1531411110" t="vigilancetech the results are in the code display above."><y>#</y><d>2018-07-12</d><h>15:58</h><w>vigilancetech</w>the results are in the code display above.</z><z id="t1531411177" t="nathanmarz I think you&apos;re reading the repl wrong"><y>#</y><d>2018-07-12</d><h>15:59</h><w>nathanmarz</w>I think you&apos;re reading the repl wrong</z><z id="t1531411183" t="nathanmarz the sequence there is the result of map"><y>#</y><d>2018-07-12</d><h>15:59</h><w>nathanmarz</w>the sequence there is the result of <code>map</code></z><z id="t1531411195" t="nathanmarz which is showing the iterative changes to ui-state"><y>#</y><d>2018-07-12</d><h>15:59</h><w>nathanmarz</w>which is showing the iterative changes to <code>ui-state</code></z><z id="t1531411202" t="nathanmarz the final value in that sequence is the final value of ui-state"><y>#</y><d>2018-07-12</d><h>16:00</h><w>nathanmarz</w>the final value in that sequence is the final value of <code>ui-state</code></z><z id="t1531411217" t="alexyakushev I&apos;d suggest you minimize the reproducible case, it&apos;s really hard to follow without the context and the CLJS at hand."><y>#</y><d>2018-07-12</d><h>16:00</h><w>alexyakushev</w>I&apos;d suggest you minimize the reproducible case, it&apos;s really hard to follow without the context and the CLJS at hand.</z><z id="t1531411255" t="vigilancetech oh, so maybe it IS working and the repl is just printing out intermediate results"><y>#</y><d>2018-07-12</d><h>16:00</h><w>vigilancetech</w>oh, so maybe it IS working and the repl is just printing out intermediate results</z><z id="t1531411298" t="nathanmarz just do @ui-state"><y>#</y><d>2018-07-12</d><h>16:01</h><w>nathanmarz</w>just do <code>@ui-state</code></z><z id="t1531411301" t="vigilancetech yup, you&apos;re right. When I check ui-state its correct. Thanks. That had me baffled"><y>#</y><d>2018-07-12</d><h>16:01</h><w>vigilancetech</w>yup, you&apos;re right.   When I check ui-state its correct.   Thanks.  That had me baffled</z><z id="t1531411333" t="vigilancetech seems like most (lisp) repls I&apos;ve used before only show the final return value"><y>#</y><d>2018-07-12</d><h>16:02</h><w>vigilancetech</w>seems like most (lisp) repls I&apos;ve used before only show the final return value</z><z id="t1531411362" t="alexyakushev Since you are doing map , you get the list of values anyway."><y>#</y><d>2018-07-12</d><h>16:02</h><w>alexyakushev</w>Since you are doing <code>map</code>, you get the list of values anyway.</z><z id="t1531411396" t="alexyakushev The final form of stow-effect! is a reset! call"><y>#</y><d>2018-07-12</d><h>16:03</h><w>alexyakushev</w>The final form of <code>stow-effect!</code> is a <code>reset!</code> call</z><z id="t1531411413" t="alexyakushev reset! sets a new value for an atom and returns that value too"><y>#</y><d>2018-07-12</d><h>16:03</h><w>alexyakushev</w><code>reset!</code> sets a new value for an atom and returns that value too</z><z id="t1531411475" t="vigilancetech so that&apos;s where the accumulation is happening; yeah, makes sense now, since I&apos;m taking the side effect of that map rather than its result"><y>#</y><d>2018-07-12</d><h>16:04</h><w>vigilancetech</w>so that&apos;s where the accumulation is happening; yeah, makes sense now, since I&apos;m taking the side effect of that map rather than its result</z><z id="t1531411484" t="alexyakushev Yep"><y>#</y><d>2018-07-12</d><h>16:04</h><w>alexyakushev</w>Yep</z><z id="t1531411498" t="alexyakushev Also, if you need map for side effects only, you can use run! instead"><y>#</y><d>2018-07-12</d><h>16:04</h><w>alexyakushev</w>Also, if you need <code>map</code> for side effects only, you can use <code>run!</code> instead</z><z id="t1531411510" t="alexyakushev That&apos;s like mapc in Lisp"><y>#</y><d>2018-07-12</d><h>16:05</h><w>alexyakushev</w>That&apos;s like <code>mapc</code> in Lisp</z><z id="t1531411513" t="nathanmarz btw, you can clean up this code with ATOM and view navigators"><y>#</y><d>2018-07-12</d><h>16:05</h><w>nathanmarz</w>btw, you can clean up this code with <code>ATOM</code> and <code>view</code> navigators</z><z id="t1531411559" t="vigilancetech yeah, I&apos;m a total noob to specter (and only slightly less so to clojure)"><y>#</y><d>2018-07-12</d><h>16:05</h><w>vigilancetech</w>yeah, I&apos;m a total noob to specter (and only slightly less so to clojure)</z><z id="t1531411618" t="vigilancetech thanks guys! Really loving this tool"><y>#</y><d>2018-07-12</d><h>16:06</h><w>vigilancetech</w>thanks guys!   Really loving this tool</z><z id="t1531440605" t="idiomancy hi!"><y>#</y><d>2018-07-13</d><h>00:10</h><w>idiomancy</w>hi!</z><z id="t1531441003" t="idiomancy I picked up specter to play with hiccup, and I&apos;m trying to form compound keys by grabbing the keys of sub elements within the data. essentially, given [[:div.row [:div.column {:key &quot;A&quot;}] [:div.column {:key &quot;B&quot;}]] [:div.row [:div.culumn {:key &quot;C&quot;}] [:div.column {:key &quot;D&quot;}]]] I want [[:div.row {:key &quot;AB&quot;} [:div.column {:key &quot;A&quot;}] [:div.column {:key &quot;B&quot;}]] [:div.row {:key &quot;CD&quot;} [:div.culumn {:key &quot;C&quot;}] [:div.column {:key &quot;D&quot;}]]] I&apos;ll be working on this myself, but if anyone has any ideas, this is effing crazy to write with handrolled clojure, and it seems like the perfect specter magic trick from what I&apos;ve seen in the videos"><y>#</y><d>2018-07-13</d><h>00:16</h><w>idiomancy</w>I picked up specter to play with hiccup, and I&apos;m trying to form compound keys by grabbing the keys of sub elements within the data.

essentially, given
<pre>[[:div.row
  [:div.column {:key &quot;A&quot;}]
  [:div.column {:key &quot;B&quot;}]]
 [:div.row
  [:div.culumn {:key &quot;C&quot;}]
  [:div.column {:key &quot;D&quot;}]]]
</pre>

I want

<pre>[[:div.row {:key &quot;AB&quot;}
  [:div.column {:key &quot;A&quot;}]
  [:div.column {:key &quot;B&quot;}]]
 [:div.row {:key &quot;CD&quot;}
  [:div.culumn {:key &quot;C&quot;}]
  [:div.column {:key &quot;D&quot;}]]]
</pre>

I&apos;ll be working on this myself, but if anyone has any ideas, this is effing crazy to write with handrolled clojure, and it seems like the perfect specter magic trick from what I&apos;ve seen in the videos</z><z id="t1531443029" t="nathanmarz @idiomancy (def data [[:div.row [:div.column {:key &quot;A&quot;}] [:div.column {:key &quot;B&quot;}]] [:div.row [:div.culumn {:key &quot;C&quot;}] [:div.column {:key &quot;D&quot;}]]]) (transform [ALL (collect ALL coll? (nthpath 1) :key) (before-index 1)] (fn [keys _] {:key (apply str keys)}) data ) "><y>#</y><d>2018-07-13</d><h>00:50</h><w>nathanmarz</w>@idiomancy 
<pre>(def data
  [[:div.row
    [:div.column {:key &quot;A&quot;}]
    [:div.column {:key &quot;B&quot;}]]
   [:div.row
    [:div.culumn {:key &quot;C&quot;}]
    [:div.column {:key &quot;D&quot;}]]])

(transform
  [ALL
   (collect ALL coll? (nthpath 1) :key)
   (before-index 1)]
  (fn [keys _] {:key (apply str keys)})
  data
  )
</pre></z><z id="t1531443058" t="idiomancy oooh, man. No way."><y>#</y><d>2018-07-13</d><h>00:50</h><w>idiomancy</w>oooh, man.  No way.</z><z id="t1531443132" t="idiomancy It was gonna take me a while to figure out that &quot;collect&quot; navigator, I think 😆"><y>#</y><d>2018-07-13</d><h>00:52</h><w>idiomancy</w>It was gonna take me a while to figure out that &quot;collect&quot; navigator, I think <b>😆</b></z><z id="t1531443136" t="idiomancy that&apos;s amazing!"><y>#</y><d>2018-07-13</d><h>00:52</h><w>idiomancy</w>that&apos;s amazing!</z><z id="t1531443191" t="nathanmarz the cheat sheet is handy for finding navigators you need https://github.com/nathanmarz/specter/wiki/Cheat-Sheet"><y>#</y><d>2018-07-13</d><h>00:53</h><w>nathanmarz</w>the cheat sheet is handy for finding navigators you need <a href="https://github.com/nathanmarz/specter/wiki/Cheat-Sheet" target="_blank">https://github.com/nathanmarz/specter/wiki/Cheat-Sheet</a></z><z id="t1531443193" t="idiomancy let me spend a couple hours reverse engineering this. thanks, @nathanmarz"><y>#</y><d>2018-07-13</d><h>00:53</h><w>idiomancy</w>let me spend a couple hours reverse engineering this.  thanks, @nathanmarz</z><z id="t1531493324" t="denik I asked this in the #clojure channel and wondering if specter could be a solution: https://clojurians.slack.com/archives/C03S1KBA2/p1531346207000010"><y>#</y><d>2018-07-13</d><h>14:48</h><w>denik</w>I asked this in the #clojure channel and wondering if specter could be a solution: <a href="https://clojurians.slack.com/archives/C03S1KBA2/p1531346207000010" target="_blank">https://clojurians.slack.com/archives/C03S1KBA2/p1531346207000010</a></z><z id="t1531493415" t="denik the reason clojure.spec doesn’t work for this case is because spec tries to conform everything. The ebooks I looked at are highly inconsistent. I think what I’m looking for more like a data matcher, rather than a parser"><y>#</y><d>2018-07-13</d><h>14:50</h><w>denik</w>the reason clojure.spec doesn’t work for this case is because spec tries to conform everything. The ebooks I looked at are highly inconsistent. I think what I’m looking for more like a data matcher, rather than a parser</z><z id="t1531494239" t="nathanmarz @denik don&apos;t understand the output you&apos;re looking for"><y>#</y><d>2018-07-13</d><h>15:03</h><w>nathanmarz</w>@denik don&apos;t understand the output you&apos;re looking for</z><z id="t1531494278" t="nathanmarz {:class &quot;indent&quot; :content &quot;key lesson 1&quot;} does not match {:class &quot;indent&quot; :content &quot;key lesson 1&quot;}"><y>#</y><d>2018-07-13</d><h>15:04</h><w>nathanmarz</w><code>{:class &quot;indent&quot; :content &quot;key lesson 1&quot;}</code> does not match <code>{:class &quot;indent&quot; :content &quot;key lesson 1&quot;}</code></z><z id="t1531494288" t="nathanmarz and there&apos;s no &quot;key lesson 3&quot; in your input"><y>#</y><d>2018-07-13</d><h>15:04</h><w>nathanmarz</w>and there&apos;s no <code>&quot;key lesson 3&quot;</code> in your input</z><z id="t1531494379" t="denik @nathanmarz start at “START HERE” and match multiple :class fields, in this case indent and indent1 but ignore these items before( and after with the stop condition to )"><y>#</y><d>2018-07-13</d><h>15:06</h><w>denik</w>@nathanmarz start at “START HERE” and match multiple <code>:class</code> fields, in this case <code>indent</code> and <code>indent1</code> but ignore these items before( and after with the stop condition <code>to</code> )</z><z id="t1531494444" t="nathanmarz and you only want to keep items that match the :filter predicate?"><y>#</y><d>2018-07-13</d><h>15:07</h><w>nathanmarz</w>and you only want to keep items that match the <code>:filter</code> predicate?</z><z id="t1531494506" t="denik yes, but only when they were found between from and to sequentially"><y>#</y><d>2018-07-13</d><h>15:08</h><w>denik</w>yes, but only when they were found between <code>from</code> and <code>to</code> sequentially</z><z id="t1531494797" t="nathanmarz you can do it with specter like this: (defn start-index [data] ;; fill in ) (def end-index (end-fn [data start-index] ;; fill in )) (select [(srange-dynamic start-index end-index) ALL (selected? (multi-path #(= &quot;START HERE&quot; (:class %)) #(= &quot;bl&quot; (:class %)) )) ] data) "><y>#</y><d>2018-07-13</d><h>15:13</h><w>nathanmarz</w>you can do it with specter like this:
<pre>(defn start-index [data]
    ;; fill in
  )

(def end-index
  (end-fn [data start-index]
    ;; fill in
    ))


(select
  [(srange-dynamic start-index end-index)
   ALL
   (selected?
    (multi-path
      #(= &quot;START HERE&quot; (:class %))
      #(= &quot;bl&quot; (:class %))
      ))
   ]
  data)
</pre></z><z id="t1531494807" t="nathanmarz but really this is better done with a parser"><y>#</y><d>2018-07-13</d><h>15:13</h><w>nathanmarz</w>but really this is better done with a parser</z><z id="t1531494841" t="nathanmarz I&apos;m not very familiar with what spec is capable of, but this is real easy with monadic parser"><y>#</y><d>2018-07-13</d><h>15:14</h><w>nathanmarz</w>I&apos;m not very familiar with what spec is capable of, but this is real easy with monadic parser</z><z id="t1531494942" t="denik thank you!"><y>#</y><d>2018-07-13</d><h>15:15</h><r>denik</r>thank you!</z><z id="t1531494951" t="denik here’s what that looks like in spec (require &apos;[clojure.spec.alpha :as s] &apos;[clojure.pprint :as pp]) (def ebook [{:class &quot;indent&quot; :content &quot;ignore&quot;} {:class &quot;indent&quot; :content &quot;ignore&quot;} {:class &quot;START HERE&quot; :content &quot;Key Lessons&quot;} {:class &quot;indent&quot; :content &quot;ignore&quot;} {:class &quot;indent1&quot; :content &quot;ignore&quot;} {:class &quot;bl&quot; :content &quot;key lesson 1&quot;} {:class &quot;bl&quot; :content &quot;key lesson 2&quot;} {:class &quot;indent3&quot; :content &quot;ignore&quot;}]) (s/def ::ebook-tree (s/and (s/cat :ignore (s/* (s/and map? #(= &quot;ignore&quot; (:content %)))) :start (s/and map? #(= (:class %) &quot;START HERE&quot;)) :body (s/* (s/alt :ignore (s/and map? #(= &quot;ignore&quot; (:content %))) :item (s/and map? #(= &quot;bl&quot; (:class %))))) :end (s/and map? #(= &quot;indent3&quot; (:class %)))) (s/conformer (fn [{:keys [start body]}] (assoc start :children (for [[tag item] body :when (not= tag :ignore)] item)))))) (pp/pprint (s/conform ::ebook-tree ebook)) "><y>#</y><d>2018-07-13</d><h>15:15</h><r>denik</r>here’s what that looks like in spec
<pre>(require &apos;[clojure.spec.alpha :as s]
         &apos;[clojure.pprint :as pp])

(def ebook
  [{:class &quot;indent&quot; :content &quot;ignore&quot;}
   {:class &quot;indent&quot; :content &quot;ignore&quot;}
   {:class &quot;START HERE&quot; :content &quot;Key Lessons&quot;}
   {:class &quot;indent&quot; :content &quot;ignore&quot;}
   {:class &quot;indent1&quot; :content &quot;ignore&quot;}
   {:class &quot;bl&quot; :content &quot;key lesson 1&quot;}
   {:class &quot;bl&quot; :content &quot;key lesson 2&quot;}
   {:class &quot;indent3&quot; :content &quot;ignore&quot;}])

(s/def
  ::ebook-tree
  (s/and
    (s/cat
     :ignore (s/* (s/and map? #(= &quot;ignore&quot; (:content %))))
     :start (s/and map? #(= (:class %) &quot;START HERE&quot;))
     :body (s/* (s/alt
                 :ignore (s/and map? #(= &quot;ignore&quot; (:content %)))
                 :item (s/and map? #(= &quot;bl&quot; (:class %)))))
     :end (s/and map? #(= &quot;indent3&quot; (:class %))))
    (s/conformer
     (fn [{:keys [start body]}]
       (assoc start :children (for [[tag item] body
                                    :when (not= tag :ignore)]
                                item))))))

(pp/pprint
 (s/conform ::ebook-tree ebook))
</pre></z><z id="t1531495027" t="nathanmarz with https://github.com/nathanmarz/specter/issues/236 you could do it more easily with specter"><y>#</y><d>2018-07-13</d><h>15:17</h><w>nathanmarz</w>with <a href="https://github.com/nathanmarz/specter/issues/236" target="_blank">https://github.com/nathanmarz/specter/issues/236</a> you could do it more easily with specter</z><z id="t1531496774" t="denik @nathanmarz I think that’s exactly what I’m looking for."><y>#</y><d>2018-07-13</d><h>15:46</h><w>denik</w>@nathanmarz I think that’s exactly what I’m looking for.</z><z id="t1531670969" t="igrishaev Hi! In specter, is there a possibility to perform an upsert operation? For example, I’ve got a vector of maps like this: [{:id 1 :name &quot;John&quot;} {:id 2 :name &quot;Jim&quot;} {:id 3 :name &quot;Jane&quot;}] Now a new map arrives and, depending on its id I need either to update (merge) it with an existing map or append it to the end of the vector. I now how to implement both insert/update separately, but a single transform/setval api call would be much more preferable."><y>#</y><d>2018-07-15</d><h>16:09</h><w>igrishaev</w>Hi! In specter, is there a possibility to perform an upsert operation? For example, I’ve got a vector of maps like this:
<pre>[{:id 1 :name &quot;John&quot;}
 {:id 2 :name &quot;Jim&quot;}
 {:id 3 :name &quot;Jane&quot;}]
</pre>
Now a new map arrives and, depending on its id I need either to update (merge) it with an existing map or append it to the end of the vector. I now how to implement both insert/update separately, but a single <code>transform/setval</code> api call would be much more preferable.</z><z id="t1531671048" t="igrishaev As I see it, the only thing I don’t understand is how to compose a transformation path."><y>#</y><d>2018-07-15</d><h>16:10</h><w>igrishaev</w>As I see it, the only thing I don’t understand is how to compose a transformation path.</z><z id="t1531683306" t="nathanmarz @igrishaev you can do it with a single path with zippers; (require &apos;[com.rpl.specter.zipper :as z]) (def truefn (constantly true)) (def target (recursive-path [id] p (cond-path [z/NODE #(= (:id %) id)] [z/NODE (submap nil)] (not-selected? z/NEXT) [z/INNER-RIGHT AFTER-ELEM] truefn [z/NEXT p] ))) (defn upsert [data n] (setval [z/VECTOR-ZIP z/DOWN (target (:id n))] n data)) (upsert data {:id 1 :name &quot;Joze&quot;}) ;; =&gt; [{:id 1, :name &quot;Joze&quot;} {:id 2, :name &quot;Jim&quot;} {:id 3, :name &quot;Jane&quot;}] (upsert data {:id 0 :name &quot;Joze&quot;}) ;; =&gt; [{:id 1, :name &quot;John&quot;} {:id 2, :name &quot;Jim&quot;} {:id 3, :name &quot;Jane&quot;} {:id 0, :name &quot;Joze&quot;}] "><y>#</y><d>2018-07-15</d><h>19:35</h><w>nathanmarz</w>@igrishaev you can do it with a single path with zippers;
<pre>(require &apos;[com.rpl.specter.zipper :as z])

(def truefn (constantly true))

(def target
  (recursive-path [id] p
    (cond-path
      [z/NODE #(= (:id %) id)]
      [z/NODE (submap nil)]

      (not-selected? z/NEXT)
      [z/INNER-RIGHT AFTER-ELEM]

      truefn
      [z/NEXT p]
      )))

(defn upsert [data n]
  (setval [z/VECTOR-ZIP z/DOWN (target (:id n))] n data))

(upsert data {:id 1 :name &quot;Joze&quot;})
;; =&gt; [{:id 1, :name &quot;Joze&quot;} {:id 2, :name &quot;Jim&quot;} {:id 3, :name &quot;Jane&quot;}]
(upsert data {:id 0 :name &quot;Joze&quot;})
;; =&gt; [{:id 1, :name &quot;John&quot;} {:id 2, :name &quot;Jim&quot;} {:id 3, :name &quot;Jane&quot;} {:id 0, :name &quot;Joze&quot;}]
</pre></z><z id="t1531683326" t="nathanmarz but I would do it like this: (defn upsert [data n] (let [[data2 new] (replace-in [ALL #(= (:id %) (:id n)) (submap nil)] (fn [_] [n nil]) data)] (if (nil? new) (setval AFTER-ELEM n data) data2 ))) "><y>#</y><d>2018-07-15</d><h>19:35</h><w>nathanmarz</w>but I would do it like this:
<pre>(defn upsert [data n]
  (let [[data2 new] (replace-in [ALL #(= (:id %) (:id n)) (submap nil)]
                      (fn [_] [n nil])
                      data)]
    (if (nil? new)
      (setval AFTER-ELEM n data)
      data2
      )))
</pre></z><z id="t1531726308" t="igrishaev thank you @nathanmarz, this combo looks solid!"><y>#</y><d>2018-07-16</d><h>07:31</h><w>igrishaev</w>thank you @nathanmarz, this combo looks solid!</z><z id="t1531733087" t="igrishaev here is my final version to upsert into the re-frame database: (defn upsert [db path key-eq new] (letfn [(map-eq? [old] (= (get new key-eq) (get old key-eq))) (updater [old] [(merge old new)])] (let [full-path (conj path s/ALL map-eq?) [db2 updated?] (s/replace-in full-path updater db)] (if updated? db2 (s/setval (conj path s/AFTER-ELEM) new db))))) "><y>#</y><d>2018-07-16</d><h>09:24</h><w>igrishaev</w>here is my final version to upsert into the re-frame database:
<pre>(defn upsert [db path key-eq new]
  (letfn [(map-eq? [old] (= (get new key-eq) (get old key-eq)))
          (updater [old] [(merge old new)])]
    (let [full-path (conj path s/ALL map-eq?)
          [db2 updated?] (s/replace-in full-path updater db)]
      (if updated?
        db2
        (s/setval (conj path s/AFTER-ELEM) new db)))))
</pre></z><z id="t1531743431" t="alexyakushev @igrishaev FWIW, I had a problem very similar to yours, and for it I implemented a simple custom data structure that keeps values in a vector and a map simultaneously. It implements all IPersistentMap methods, and assoc works as the upsert."><y>#</y><d>2018-07-16</d><h>12:17</h><w>alexyakushev</w>@igrishaev FWIW, I had a problem very similar to yours, and for it I implemented a simple custom data structure that keeps values in a vector and a map simultaneously. It implements all IPersistentMap methods, and <code>assoc</code> works as the upsert.</z><z id="t1531744669" t="nathanmarz @igrishaev fyi, use the path macro for composing paths instead of conj"><y>#</y><d>2018-07-16</d><h>12:37</h><w>nathanmarz</w>@igrishaev fyi, use the <code>path</code> macro for composing paths instead of <code>conj</code></z><z id="t1531744672" t="nathanmarz will be much faster"><y>#</y><d>2018-07-16</d><h>12:37</h><w>nathanmarz</w>will be much faster</z><z id="t1531744716" t="igrishaev thank you, will check that out"><y>#</y><d>2018-07-16</d><h>12:38</h><w>igrishaev</w>thank you, will check that out</z><z id="t1531744771" t="igrishaev in my case, path is a vector to the actual data subset, say [:tasks :completed]"><y>#</y><d>2018-07-16</d><h>12:39</h><w>igrishaev</w>in my case, <code>path</code> is a vector to the actual data subset, say <code>[:tasks :completed]</code></z><z id="t1531744953" t="nathanmarz yea, you should pass that in as (path :tasks :completed)"><y>#</y><d>2018-07-16</d><h>12:42</h><w>nathanmarz</w>yea, you should pass that in as <code>(path :tasks :completed)</code></z><z id="t1531745015" t="nathanmarz path uses inline caching to minimize runtime compilation of paths"><y>#</y><d>2018-07-16</d><h>12:43</h><w>nathanmarz</w><code>path</code> uses inline caching to minimize runtime compilation of paths</z><z id="t1531745090" t="igrishaev If I have a vector like [:foo :bar] , how can I apply it the the path macro then?"><y>#</y><d>2018-07-16</d><h>12:44</h><w>igrishaev</w>If I have a vector like <code>[:foo :bar]</code>, how can I apply it the the <code>path</code> macro then?</z><z id="t1531746164" t="nathanmarz (path :foo :bar)"><y>#</y><d>2018-07-16</d><h>13:02</h><w>nathanmarz</w><code>(path :foo :bar)</code></z><z id="t1531747093" t="igrishaev sure, but what if both foo and bar come as a vector?"><y>#</y><d>2018-07-16</d><h>13:18</h><w>igrishaev</w>sure, but what if both foo and bar come as a vector?</z><z id="t1531747120" t="igrishaev as a func argument in my case"><y>#</y><d>2018-07-16</d><h>13:18</h><w>igrishaev</w>as a func argument in my case</z><z id="t1531747206" t="nathanmarz if it&apos;s dynamic, then declare them using path , not as a vector"><y>#</y><d>2018-07-16</d><h>13:20</h><w>nathanmarz</w>if it&apos;s dynamic, then declare them using <code>path</code>, not as a vector</z><z id="t1531747227" t="nathanmarz (upsert db (path :foo :bar) ...)"><y>#</y><d>2018-07-16</d><h>13:20</h><w>nathanmarz</w><code>(upsert db (path :foo :bar) ...)</code></z><z id="t1531747322" t="igrishaev the problem is I don’t know in advance what subset of the main db will be used."><y>#</y><d>2018-07-16</d><h>13:22</h><w>igrishaev</w>the problem is I don’t know in advance what subset of the main db will be used.</z><z id="t1531747383" t="igrishaev I supposed a user passes an initial path as a vector, then I build the full transformation path"><y>#</y><d>2018-07-16</d><h>13:23</h><w>igrishaev</w>I supposed a user passes an initial path as a vector, then I build the full transformation path</z><z id="t1531748255" t="nathanmarz ultimately it&apos;s an optimization"><y>#</y><d>2018-07-16</d><h>13:37</h><w>nathanmarz</w>ultimately it&apos;s an optimization</z><z id="t1531748274" t="nathanmarz if your users declare their paths using path it will be faster, but if they use vectors it will still work"><y>#</y><d>2018-07-16</d><h>13:37</h><w>nathanmarz</w>if your users declare their paths using <code>path</code> it will be faster, but if they use vectors it will still work</z><z id="t1531748450" t="igrishaev ok, so if a user passes smth like (path :foo :bar) as an initial path, how can I extend it?"><y>#</y><d>2018-07-16</d><h>13:40</h><w>igrishaev</w>ok, so if a user passes smth like <code>(path :foo :bar)</code> as an initial path, how can I extend it?</z><z id="t1531748567" t="nathanmarz with path"><y>#</y><d>2018-07-16</d><h>13:42</h><w>nathanmarz</w>with <code>path</code></z><z id="t1531748595" t="nathanmarz e.g. (path passed-in-user-path ALL)"><y>#</y><d>2018-07-16</d><h>13:43</h><w>nathanmarz</w>e.g. <code>(path passed-in-user-path ALL)</code></z><z id="t1531748617" t="igrishaev oh, I see now, thanks"><y>#</y><d>2018-07-16</d><h>13:43</h><w>igrishaev</w>oh, I see now, thanks</z><z id="t1531816126" t="roklenarcic I often have to transform map&apos;s values but I need value&apos;s key to do the transformation, so MAP-VALS doesn&apos;t cut it"><y>#</y><d>2018-07-17</d><h>08:28</h><w>roklenarcic</w>I often have to transform map&apos;s values but I need value&apos;s key to do the transformation, so <code>MAP-VALS</code> doesn&apos;t cut it</z><z id="t1531816132" t="roklenarcic How do I solve this?"><y>#</y><d>2018-07-17</d><h>08:28</h><w>roklenarcic</w>How do I solve this?</z><z id="t1531816168" t="roklenarcic ALL (collect FIRST) LAST ?"><y>#</y><d>2018-07-17</d><h>08:29</h><w>roklenarcic</w><code>ALL (collect FIRST) LAST</code>?</z><z id="t1531816688" t="roklenarcic This case comes up all the time. I want to decide which path to take based on key, but I want to transform value."><y>#</y><d>2018-07-17</d><h>08:38</h><w>roklenarcic</w>This case comes up all the time. I want to decide which path to take based on key, but I want to transform value.</z><z id="t1531817751" t="pepe @roklenarcic ALL returns [k v] vector on map so (transform ALL (fn [[k v]] (if (= k :a) [k (inc v)] [k (dec v)])) {:a 1 :b 2}) works"><y>#</y><d>2018-07-17</d><h>08:55</h><w>pepe</w>@roklenarcic ALL returns [k v] vector on map so <code>(transform ALL (fn [[k v]] (if (= k :a) [k (inc v)] [k (dec v)])) {:a 1 :b 2})</code> works</z><z id="t1531820160" t="roklenarcic I know that one, but I hoped for a shorter solution."><y>#</y><d>2018-07-17</d><h>09:36</h><w>roklenarcic</w>I know that one, but I hoped for a shorter solution.</z><z id="t1531823266" t="pepe Ok. Have you looked at if-path cond-path?"><y>#</y><d>2018-07-17</d><h>10:27</h><w>pepe</w>Ok. Have you looked at if-path cond-path?</z><z id="t1531834132" t="roklenarcic that&apos;s about the same amount of code"><y>#</y><d>2018-07-17</d><h>13:28</h><w>roklenarcic</w>that&apos;s about the same amount of code</z><z id="t1531834202" t="nathanmarz @roklenarcic it will be easier to help you if you show the input/output of the transformation you want to do"><y>#</y><d>2018-07-17</d><h>13:30</h><w>nathanmarz</w>@roklenarcic it will be easier to help you if you show the input/output of the transformation you want to do</z><z id="t1531834370" t="roklenarcic Already solved it"><y>#</y><d>2018-07-17</d><h>13:32</h><w>roklenarcic</w>Already solved it</z><z id="t1531834414" t="roklenarcic (transform [ALL (collect-one FIRST) LAST ALL] map-fn result-of-group-by)"><y>#</y><d>2018-07-17</d><h>13:33</h><w>roklenarcic</w><code>(transform [ALL (collect-one FIRST) LAST ALL] map-fn result-of-group-by)</code></z><z id="t1531834453" t="roklenarcic allows me to have map-fn of two arguments that processes lists in group-by map-of-vectors"><y>#</y><d>2018-07-17</d><h>13:34</h><w>roklenarcic</w>allows me to have map-fn of two arguments that processes lists in group-by map-of-vectors</z><z id="t1532356811" t="roklenarcic what&apos;s the fastest way to drop certain indexes in a vector? e.g. given vector [:a :b :c :d] and indexes [0 2] I should get [:b :d]"><y>#</y><d>2018-07-23</d><h>14:40</h><w>roklenarcic</w>what&apos;s the fastest way to drop certain indexes in a vector? e.g. given vector <code>[:a :b :c :d]</code> and indexes <code>[0 2]</code> I should get <code>[:b :d]</code></z><z id="t1532357364" t="nathanmarz @roklenarcic you&apos;re best off doing that with a reduce"><y>#</y><d>2018-07-23</d><h>14:49</h><w>nathanmarz</w>@roklenarcic you&apos;re best off doing that with a reduce</z><z id="t1532357395" t="nathanmarz each (setval (nthpath i) NONE data) invocation is O(n), and INDEXED-VALS doesn&apos;t currently support removal via NONE"><y>#</y><d>2018-07-23</d><h>14:49</h><w>nathanmarz</w>each <code>(setval (nthpath i) NONE data)</code> invocation is O(n), and <code>INDEXED-VALS</code> doesn&apos;t currently support removal via <code>NONE</code></z><z id="t1532357413" t="roklenarcic since you&apos;re here, how important is precompiling routes now?"><y>#</y><d>2018-07-23</d><h>14:50</h><w>roklenarcic</w>since you&apos;re here, how important is precompiling routes now?</z><z id="t1532357462" t="nathanmarz completely unnecessary"><y>#</y><d>2018-07-23</d><h>14:51</h><w>nathanmarz</w>completely unnecessary</z><z id="t1532357469" t="nathanmarz the inline compiler handles all cases"><y>#</y><d>2018-07-23</d><h>14:51</h><w>nathanmarz</w>the inline compiler handles all cases</z><z id="t1532357511" t="roklenarcic thx"><y>#</y><d>2018-07-23</d><h>14:51</h><w>roklenarcic</w>thx</z><z id="t1532415336" t="steveb8n anyone ever seen an error like this before at compile time? java.lang.StackOverflowError, compiling:(com/rpl/specter/util_macros.clj:61:29 I’m seeing it when using Specter in Datomic Ions"><y>#</y><d>2018-07-24</d><h>06:55</h><w>steveb8n</w>anyone ever seen an error like this before at compile time? <code>java.lang.StackOverflowError, compiling:(com/rpl/specter/util_macros.clj:61:29</code> I’m seeing it when using Specter in Datomic Ions</z><z id="t1532417142" t="steveb8n scratch that. It appears to be a side-effect of a dependencies problem"><y>#</y><d>2018-07-24</d><h>07:25</h><w>steveb8n</w>scratch that. It appears to be a side-effect of a dependencies problem</z><z id="t1532426365" t="Petrus Theron I&apos;m learning Specter and trying to parse an XML response I got from Twilio. I&apos;m not super-familiar with Clojure zippers in general, but I suspect it&apos;ll be cleaner &amp; faster with Specter. I&apos;ve stumbled onto the S/collect function, but I&apos;m having a hard time fetching &quot;sibling&quot; nodes when dealing with a shape like this: {:tag :TwilioResponse, :attrs nil, :content [{:tag :Call, :attrs nil, :content [{:tag :AnsweredBy, :attrs nil, :content nil} {:tag :PriceUnit, :attrs nil, :content [&quot;USD&quot;]} {:tag :From, :attrs nil, :content [&quot;+2787...&quot;]} {:tag :To, :attrs nil, :content [&quot;+2776...&quot;]} }]}]} How do I ask Specter to collect the deepest :tag and :content values in the structure, but only if the parent :tag is :TwilioResponse, with a :Call parent under :tag? I managed to get what I want by doing the following, but it feels like there must be a cleaner way to refer to parents/siblings: (-&gt;&gt; my-parsed-xml (S/select-one [(S/collect-one :content S/FIRST :content) :tag (S/pred= :TwilioResponse)]) first (map (juxt :tag (comp first :content)))) "><y>#</y><d>2018-07-24</d><h>09:59</h><w>Petrus Theron</w>I&apos;m learning Specter and trying to parse an XML response I got from Twilio. I&apos;m not super-familiar with Clojure zippers in general, but I suspect it&apos;ll be cleaner &amp; faster with Specter. I&apos;ve stumbled onto the <code>S/collect</code> function, but I&apos;m having a hard time fetching &quot;sibling&quot; nodes when dealing with a shape like this:

<pre>{:tag :TwilioResponse,
 :attrs nil,
 :content [{:tag :Call,
            :attrs nil,
            :content [{:tag :AnsweredBy, :attrs nil, :content nil}
                      {:tag :PriceUnit, :attrs nil, :content [&quot;USD&quot;]}
                      {:tag :From, :attrs nil, :content [&quot;+2787...&quot;]}
                      {:tag :To, :attrs nil, :content [&quot;+2776...&quot;]}
}]}]}
</pre>

How do I ask Specter to collect the deepest <code>:tag</code> and <code>:content</code> values in the structure, but only if the parent <code>:tag</code> is :TwilioResponse, with a <code>:Call</code> parent under :tag?

I managed to get what I want by doing the following, but it feels like there must be a cleaner way to refer to parents/siblings:
<pre>(-&gt;&gt; my-parsed-xml (S/select-one [(S/collect-one :content S/FIRST :content)
                        :tag (S/pred= :TwilioResponse)])
         first
         (map (juxt :tag (comp first :content))))
</pre></z><z id="t1532436243" t="nathanmarz @petrus not totally clear on what you want"><y>#</y><d>2018-07-24</d><h>12:44</h><w>nathanmarz</w>@petrus not totally clear on what you want</z><z id="t1532451566" t="Petrus Theron if I restructure the response as a nested map (assuming no dupes) {:TwilioResponse {:Call {:AnsweredBy nil :PriceUnit [&quot;USD&quot;] ...}} I&apos;d be done with a (get-in [:TwilioResponse :Call]]) , which I can do with with a few functions, but I&apos;m hoping this can be cleanly done with a Specter select and XML zippers."><y>#</y><d>2018-07-24</d><h>16:59</h><r>Petrus Theron</r>if I restructure the response as a nested map (assuming no dupes) <code>{:TwilioResponse {:Call {:AnsweredBy nil :PriceUnit [&quot;USD&quot;] ...}}</code> I&apos;d be done with a <code>(get-in [:TwilioResponse :Call]])</code>, which I can do with with a few functions, but I&apos;m hoping this can be cleanly done with a Specter select and XML zippers.</z><z id="t1532436272" t="nathanmarz you want nodes in this tree that have a parent tag of :Call and grandparent tag of :TwilioResponse ?"><y>#</y><d>2018-07-24</d><h>12:44</h><w>nathanmarz</w>you want nodes in this tree that have a parent tag of <code>:Call</code> and grandparent tag of <code>:TwilioResponse</code>?</z><z id="t1532436305" t="nathanmarz can this substructure exist at any depth, or only starting at the root?"><y>#</y><d>2018-07-24</d><h>12:45</h><w>nathanmarz</w>can this substructure exist at any depth, or only starting at the root?</z><z id="t1532451912" t="nathanmarz @petrus is this what you&apos;re looking for? (select-first [#(= :TwilioResponse (:tag %)) :content ALL #(= :Call (:tag %)) :content] data) "><y>#</y><d>2018-07-24</d><h>17:05</h><w>nathanmarz</w>@petrus is this what you&apos;re looking for?
<pre>(select-first
  [#(= :TwilioResponse (:tag %))
   :content
   ALL
   #(= :Call (:tag %))
   :content]
  data)
</pre></z><z id="t1532452048" t="nathanmarz or this? (select [#(= :TwilioResponse (:tag %)) :content ALL #(= :Call (:tag %)) :content ALL (collect-one :tag) :content (view first)] data) "><y>#</y><d>2018-07-24</d><h>17:07</h><w>nathanmarz</w>or this?
<pre>(select
  [#(= :TwilioResponse (:tag %))
   :content
   ALL
   #(= :Call (:tag %))
   :content
   ALL
   (collect-one :tag)
   :content
   (view first)]
  data)
</pre></z><z id="t1532452241" t="Petrus Theron yes, thanks @U173SEFUN! 🙂 exactly right after a call to (into {} ...) (assume no duplicate tags). Is there a cleaner way to &quot;walk&quot; the XML tree {:tag .. :content ...} layout so that {:tag :x :content :y} becomes [:x :y] or {:x :y} ?"><y>#</y><d>2018-07-24</d><h>17:10</h><r>Petrus Theron</r>yes, thanks @U173SEFUN! <b>🙂</b> exactly right after a call to <code>(into {} ...)</code> (assume no duplicate tags).

Is there a cleaner way to &quot;walk&quot; the XML tree <code>{:tag .. :content ...}</code> layout so that <code>{:tag :x :content :y}</code> becomes <code>[:x :y]</code> or <code>{:x :y}</code>?</z><z id="t1532452616" t="nathanmarz you can factor out any composition of navigators as its own navigator"><y>#</y><d>2018-07-24</d><h>17:16</h><w>nathanmarz</w>you can factor out any composition of navigators as its own navigator</z><z id="t1532452626" t="nathanmarz e.g. (def tag+content (path (collect-one :tag) :content (view first))) (select [#(= :TwilioResponse (:tag %)) :content ALL #(= :Call (:tag %)) :content ALL tag+content] data) "><y>#</y><d>2018-07-24</d><h>17:17</h><w>nathanmarz</w>e.g.
<pre>(def tag+content
  (path
    (collect-one :tag)
    :content
    (view first)))

(select
  [#(= :TwilioResponse (:tag %))
   :content
   ALL
   #(= :Call (:tag %))
   :content
   ALL
   tag+content]
  data)
</pre></z><z id="t1532452811" t="Petrus Theron Would a recursive-path walker be cleaner for transforming the general {:tag :content [{:tag ... :content [...]]} shape returned by clojure.xml/parse in general, then selecting a simpler nested path from there?"><y>#</y><d>2018-07-24</d><h>17:20</h><r>Petrus Theron</r>Would a <code>recursive-path</code> walker be cleaner for transforming the general <code>{:tag :content [{:tag ... :content [...]]}</code> shape returned by <code>clojure.xml/parse</code> in general, then selecting a simpler nested path from there?</z><z id="t1532452720" t="nathanmarz if you want to navigate to the pair, you can use subselect + multi-path"><y>#</y><d>2018-07-24</d><h>17:18</h><w>nathanmarz</w>if you want to navigate to the pair, you can use subselect + multi-path</z><z id="t1532452730" t="nathanmarz (select [#(= :TwilioResponse (:tag %)) :content ALL #(= :Call (:tag %)) :content ALL (subselect (multi-path :tag [:content (view first)]))] data) "><y>#</y><d>2018-07-24</d><h>17:18</h><w>nathanmarz</w><pre>(select
  [#(= :TwilioResponse (:tag %))
   :content
   ALL
   #(= :Call (:tag %))
   :content
   ALL
   (subselect (multi-path :tag [:content (view first)]))]
  data)
</pre></z><z id="t1532452870" t="nathanmarz if you want to maintain the general structure, then yes"><y>#</y><d>2018-07-24</d><h>17:21</h><w>nathanmarz</w>if you want to maintain the general structure, then yes</z><z id="t1532517772" t="Petrus Theron Thanks for feedback @nathanmarz. I sent your Specter talk to a friend and he commented: &quot;I didn&apos;t know Vin Diesel was into Clojure.&quot; 😄"><y>#</y><d>2018-07-25</d><h>11:22</h><w>Petrus Theron</w>Thanks for feedback @nathanmarz. I sent your Specter talk to a friend and he commented: &quot;I didn&apos;t know Vin Diesel was into Clojure.&quot; <b>😄</b></z><z id="t1532524510" t="nathanmarz 😂"><y>#</y><d>2018-07-25</d><h>13:15</h><w>nathanmarz</w><b>😂</b></z><z id="t1532632069" t="roklenarcic I have a double nested map like {:a {:b 1}} and I need get all tuples key1, key2, value where value fits a predicate"><y>#</y><d>2018-07-26</d><h>19:07</h><w>roklenarcic</w>I have a double nested map like <code>{:a {:b 1}}</code> and I need  get all tuples key1, key2, value where value fits a predicate</z><z id="t1532632086" t="roklenarcic Is there some way I can do this?"><y>#</y><d>2018-07-26</d><h>19:08</h><w>roklenarcic</w>Is there some way I can do this?</z><z id="t1532633690" t="nathanmarz @roklenarcic (def m {:a {:b 1 :c 2} :d {:e 3 :f 4}}) (def VALS-WITH-KEY (path ALL (collect-one FIRST) LAST)) (select [VALS-WITH-KEY VALS-WITH-KEY even?] m) "><y>#</y><d>2018-07-26</d><h>19:34</h><w>nathanmarz</w>@roklenarcic 
<pre>(def m {:a {:b 1 :c 2} :d {:e 3 :f 4}})
(def VALS-WITH-KEY (path ALL (collect-one FIRST) LAST))
(select [VALS-WITH-KEY VALS-WITH-KEY even?] m)
</pre></z><z id="t1532634267" t="roklenarcic hm I really need to experiment with subpaths more"><y>#</y><d>2018-07-26</d><h>19:44</h><w>roklenarcic</w>hm I really need to experiment with subpaths more</z><z id="t1532634285" t="roklenarcic thanks"><y>#</y><d>2018-07-26</d><h>19:44</h><w>roklenarcic</w>thanks</z><z id="t1532634442" t="roklenarcic using path operator is good for performance?"><y>#</y><d>2018-07-26</d><h>19:47</h><w>roklenarcic</w>using path operator is good for performance?</z><z id="t1532634955" t="nathanmarz yes"><y>#</y><d>2018-07-26</d><h>19:55</h><w>nathanmarz</w>yes</z><z id="t1532712887" t="alexisvincent Hi there, was wondering if you have a way of selecting a submap with a predicate on map keys or value. Perhaps something like the reverse of ALL for map entries?"><y>#</y><d>2018-07-27</d><h>17:34</h><w>alexisvincent</w>Hi there, was wondering if you have a way of selecting a submap with a predicate on map keys or value. Perhaps something like the reverse of ALL for map entries?</z><z id="t1532713102" t="alexisvincent For example (select [ALL (comp even? second)] {:a 1 :b 2 :c 3}) in this case to get back the submap {:b 2} rather then the list of entries. But as a path, so that it can be composed"><y>#</y><d>2018-07-27</d><h>17:38</h><w>alexisvincent</w>For example <pre>(select [ALL (comp even? second)] {:a 1 :b 2 :c 3})</pre> in this case to get back the submap {:b 2} rather then the list of entries. But as a path, so that it can be composed</z><z id="t1532714270" t="nathanmarz @alexisvincent one common way to do that would be to do the inverse using setval , e.g. (setval [MAP-VALS odd?] NONE {:a 1 :b 2 :c 3})"><y>#</y><d>2018-07-27</d><h>17:57</h><w>nathanmarz</w>@alexisvincent one common way to do that would be to do the inverse using <code>setval</code>, e.g. <code>(setval [MAP-VALS odd?] NONE {:a 1 :b 2 :c 3})</code></z><z id="t1532714348" t="alexisvincent Thanks Nathan! But what I’m really trying to achieve is to construct a path, that I can compose to access deeper things in the map."><y>#</y><d>2018-07-27</d><h>17:59</h><w>alexisvincent</w>Thanks Nathan! But what I’m really trying to achieve is to construct a path, that I can compose to access deeper things in the map.</z><z id="t1532714520" t="alexisvincent Is it possible for instance to make a navigator that takes a list of entries and transforms it to a map, such that it still works with the reconstruction process?"><y>#</y><d>2018-07-27</d><h>18:02</h><w>alexisvincent</w>Is it possible for instance to make a navigator that takes a list of entries and transforms it to a map, such that it still works with the reconstruction process?</z><z id="t1532714984" t="nathanmarz not sure what you mean by that"><y>#</y><d>2018-07-27</d><h>18:09</h><w>nathanmarz</w>not sure what you mean by that</z><z id="t1532714991" t="nathanmarz do you have a representative example?"><y>#</y><d>2018-07-27</d><h>18:09</h><w>nathanmarz</w>do you have a representative example?</z><z id="t1532727258" t="razum2um Hi, I started using collect but find it a bit awkward, passing 2 args into modify-fn: (def data {18 [{:rate 30} {:rate 15}], 50 [{:rate 35}]}) (transform [MAP-VALS (collect ALL :rate)] (fn [xs _] (average xs)) data) ;; ok (transform [MAP-VALS (collect ALL :rate)] average data) ArityException Wrong number of args (2) passed to: user/average is there a more concise version of 2nd line (dont want to change average arity only for specter)?"><y>#</y><d>2018-07-27</d><h>21:34</h><w>razum2um</w>Hi, I started using <code>collect</code> but find it a bit awkward, passing 2 args into modify-fn:
<pre>(def data {18 [{:rate 30} {:rate 15}], 50 [{:rate 35}]})
(transform [MAP-VALS (collect ALL :rate)] (fn [xs _] (average xs)) data) ;; ok
(transform [MAP-VALS (collect ALL :rate)] average data)
ArityException Wrong number of args (2) passed to: user/average
</pre>
is there a more concise version of 2nd line (dont want to change average arity only for specter)?</z><z id="t1532728438" t="nathanmarz @razum2um no, that&apos;s pretty idiomatic"><y>#</y><d>2018-07-27</d><h>21:53</h><w>nathanmarz</w>@razum2um no, that&apos;s pretty idiomatic</z><z id="t1533182206" t="vigilancetech so now with the latest version of specter, what is one supposed to do regarding using path, comp-paths, etc..? I think I&apos;m having problems with its and javelin&apos;s macros not playing well together."><y>#</y><d>2018-08-02</d><h>03:56</h><w>vigilancetech</w>so now with the latest version of specter, what is one supposed to do regarding using path, comp-paths, etc..?   I think I&apos;m having problems with its and javelin&apos;s macros not playing well together.</z><z id="t1533208610" t="nathanmarz @vigilancetech just use path"><y>#</y><d>2018-08-02</d><h>11:16</h><w>nathanmarz</w>@vigilancetech just use <code>path</code></z><z id="t1533300887" t="miikka So I&apos;m pretty new to Specter, but I&apos;m trying to navigate a vector like [{:id 1, :value 2} {:id 2, :value 1}] by :id . (I know that this would be ideally a map, but it&apos;s not for now.) [MAP-VALS #(= x (:id %))] seems to work, but how do I define a navigator so that it&apos;s reusable?"><y>#</y><d>2018-08-03</d><h>12:54</h><w>miikka</w>So I&apos;m pretty new to Specter, but I&apos;m trying to navigate a vector like <code>[{:id 1, :value 2} {:id 2, :value 1}]</code> by <code>:id</code>. (I know that this would be ideally a map, but it&apos;s not for now.) <code>[MAP-VALS #(= x (:id %))]</code> seems to work, but how do I define a navigator so that it&apos;s reusable?</z><z id="t1533300912" t="miikka Is this the right way to do it? (defn by-id [id] (specter/path [specter/MAP-VALS #(= (:id %) id)])) "><y>#</y><d>2018-08-03</d><h>12:55</h><w>miikka</w>Is this the right way to do it?
<pre>(defn by-id [id] (specter/path [specter/MAP-VALS #(= (:id %) id)]))
</pre></z><z id="t1533301621" t="miikka uh, that should be ALL , not MAP-VALS"><y>#</y><d>2018-08-03</d><h>13:07</h><w>miikka</w>uh, that should be <code>ALL</code>, not <code>MAP-VALS</code></z><z id="t1533309562" t="nathanmarz @miikka yes, that&apos;s exactly right"><y>#</y><d>2018-08-03</d><h>15:19</h><w>nathanmarz</w>@miikka yes, that&apos;s exactly right</z><z id="t1533335174" t="vigilancetech anyone have an idea why I&apos;d be getting this error in 1.1.1 but not 1.1.0? WARNING: Use of undeclared Var cljs.core/MapEntry at line 84 /home/kevin/.boot/cache/tmp/home/kevin/0work/jbog/guardian-dashboard/cul/v9pufs/index.html.out/com/rpl/specter/navs.cljc I just erased .boot/cache and recompiled and the same error is there"><y>#</y><d>2018-08-03</d><h>22:26</h><w>vigilancetech</w>anyone have an idea why I&apos;d be getting this error in 1.1.1 but not 1.1.0?

<pre>WARNING: Use of undeclared Var cljs.core/MapEntry at line 84 /home/kevin/.boot/cache/tmp/home/kevin/0work/jbog/guardian-dashboard/cul/v9pufs/index.html.out/com/rpl/specter/navs.cljc
</pre>

I just erased .boot/cache and recompiled and the same error is there</z><z id="t1533337571" t="nathanmarz @vigilancetech that&apos;s related to a change in ClojureScript 1.10"><y>#</y><d>2018-08-03</d><h>23:06</h><w>nathanmarz</w>@vigilancetech that&apos;s related to a change in ClojureScript 1.10</z><z id="t1533337575" t="nathanmarz you should upgrade your cljs"><y>#</y><d>2018-08-03</d><h>23:06</h><w>nathanmarz</w>you should upgrade your cljs</z><z id="t1533740380" t="souenzzo I need to add a item( :NEW ) before a pred ( map? ) just on first match. exaple: [:foo :bar {} {}] into [:foo :bar :NEW {} {}] I&apos;m using mapcat and a atom to say if it&apos;s the first match. There is a simpler way to do that?"><y>#</y><d>2018-08-08</d><h>14:59</h><w>souenzzo</w>I need to add a item( <code>:NEW</code> ) before a pred ( <code>map?</code> ) just on first match.
exaple:  <code>[:foo :bar {} {}]</code> into <code>[:foo :bar :NEW {} {}]</code> 
I&apos;m using mapcat and a <code>atom</code> to say if it&apos;s the first match.
There is a simpler way to do that?</z><z id="t1533740867" t="souenzzo There is BEFORE-ELEM but can&apos;t understand how to compose it."><y>#</y><d>2018-08-08</d><h>15:07</h><w>souenzzo</w>There is <code>BEFORE-ELEM</code> but can&apos;t understand how to compose it.</z><z id="t1533740884" t="nathanmarz @souenzzo you can do something like: (defn index-matching [p] (fn [s] (select-first [INDEXED-VALS (selected? LAST (pred p)) FIRST] s) )) (setval [(srange-dynamic (index-matching map?) (end-fn [_ i] i)) BEFORE-ELEM] :NEW [:foo :bar {} {}] ) "><y>#</y><d>2018-08-08</d><h>15:08</h><w>nathanmarz</w>@souenzzo you can do something like:
<pre>(defn index-matching [p]
  (fn [s]
    (select-first [INDEXED-VALS (selected? LAST (pred p)) FIRST] s)
    ))

(setval
  [(srange-dynamic (index-matching map?) (end-fn [_ i] i))
   BEFORE-ELEM]
  :NEW
  [:foo :bar {} {}]
  )
</pre></z><z id="t1533740921" t="nathanmarz probably want to modify it a little to handle the case where nothing matches the predicate"><y>#</y><d>2018-08-08</d><h>15:08</h><w>nathanmarz</w>probably want to modify it a little to handle the case where nothing matches the predicate</z><z id="t1533757421" t="jsa-aerial suppose, you have a transform ALL function which makes substitutions that may themselves need to have substitutions and so reapply the transform on result until no more substitutions involved. Is the obvious soln such as (-&gt;&gt; x (iterate xform) (drop-while (comp not test)) first) still the &apos;right&apos; way to do this with specter? Or is there an even more idiomatic way?"><y>#</y><d>2018-08-08</d><h>19:43</h><w>jsa-aerial</w>suppose, you have a transform ALL function which makes substitutions that may themselves need to have substitutions and so reapply the transform on result until no more substitutions involved. Is the obvious soln such as <code>(-&gt;&gt; x (iterate xform) (drop-while (comp not test)) first)</code> still the &apos;right&apos; way to do this with specter? Or is there an even more idiomatic way?</z><z id="t1533758185" t="nathanmarz @jsa-aerial you could always do something like: (def iterated-path (recursive-path [test] p (stay-then-continue (pred test) p ))) (transform (iterated-path #(&lt; % 10)) inc 1) ;; =&gt; 10 "><y>#</y><d>2018-08-08</d><h>19:56</h><w>nathanmarz</w>@jsa-aerial you could always do something like:
<pre>(def iterated-path
  (recursive-path [test] p
    (stay-then-continue
      (pred test)
      p
      )))
(transform (iterated-path #(&lt; % 10)) inc 1)
;; =&gt; 10
</pre></z><z id="t1533759047" t="jsa-aerial @nathanmarz that looks very interesting - let me take a hack with that. Thanks!"><y>#</y><d>2018-08-08</d><h>20:10</h><w>jsa-aerial</w>@nathanmarz that looks very interesting - let me take a hack with that. Thanks!</z><z id="t1533759384" t="jsa-aerial Hmmmm, actually the test needs the last two values. Basically let x1 and x2 be the last two values, iterate until (= x1 x2)."><y>#</y><d>2018-08-08</d><h>20:16</h><w>jsa-aerial</w>Hmmmm, actually the test needs the last two values. Basically let x1 and x2 be the last two values, iterate until (= x1 x2).</z><z id="t1533760014" t="nathanmarz @jsa-aerial (def FIXED-POINT-PATH (recursive-path [] p [(collect-one STAY) (multi-path [DISPENSE STAY] [(collect-one STAY) (if-path (collected? [a b] (= a b)) STOP [DISPENSE p] )]) ])) (defn f [a] (min (inc a) 10)) (transform [:a FIXED-POINT-PATH] f {:a 1 :b 2}) ;; =&gt; {:a 10 :b 2} "><y>#</y><d>2018-08-08</d><h>20:26</h><w>nathanmarz</w>@jsa-aerial 
<pre>(def FIXED-POINT-PATH
  (recursive-path [] p
    [(collect-one STAY)
     (multi-path
       [DISPENSE STAY]
       [(collect-one STAY)
        (if-path (collected? [a b] (= a b))
          STOP
          [DISPENSE p]
          )])
     ]))

(defn f [a] (min (inc a) 10))
(transform [:a FIXED-POINT-PATH] f {:a 1 :b 2})
;; =&gt; {:a 10 :b 2}
</pre></z><z id="t1533760038" t="nathanmarz that&apos;s an interesting one"><y>#</y><d>2018-08-08</d><h>20:27</h><w>nathanmarz</w>that&apos;s an interesting one</z><z id="t1533760117" t="nathanmarz actually can shorten the definition like this: (def FIXED-POINT-PATH (recursive-path [] p [(collect-one STAY) (multi-path [DISPENSE STAY] [(collect-one STAY) (if-path (collected? [a b] (not= a b)) [DISPENSE p] )]) ])) "><y>#</y><d>2018-08-08</d><h>20:28</h><w>nathanmarz</w>actually can shorten the definition like this:
<pre>(def FIXED-POINT-PATH
  (recursive-path [] p
    [(collect-one STAY)
     (multi-path
       [DISPENSE STAY]
       [(collect-one STAY)
        (if-path (collected? [a b] (not= a b))
          [DISPENSE p]
          )])
     ]))
</pre></z><z id="t1533760236" t="nathanmarz I&apos;d probably just write that in regular clojure though"><y>#</y><d>2018-08-08</d><h>20:30</h><w>nathanmarz</w>I&apos;d probably just write that in regular clojure though</z><z id="t1533760253" t="nathanmarz using loop"><y>#</y><d>2018-08-08</d><h>20:30</h><w>nathanmarz</w>using <code>loop</code></z><z id="t1533760860" t="jsa-aerial I think it will be instructive to study these two - even though for the particular case in question the solution actually looks simpler in straight clojure"><y>#</y><d>2018-08-08</d><h>20:41</h><w>jsa-aerial</w>I think it will be instructive to study these two - even though for the particular case in question the solution actually looks simpler in straight clojure</z><z id="t1533760978" t="nathanmarz for sure"><y>#</y><d>2018-08-08</d><h>20:42</h><w>nathanmarz</w>for sure</z><z id="t1533942033" t="blak3mill3r Does anyone know of any extant attempts at a specter visualization tool?"><y>#</y><d>2018-08-10</d><h>23:00</h><w>blak3mill3r</w>Does anyone know of any extant attempts at a <code>specter</code> visualization tool?</z><z id="t1533942052" t="blak3mill3r I want one and I think I have a good idea for how to do it..."><y>#</y><d>2018-08-10</d><h>23:00</h><w>blak3mill3r</w>I want one and I think I have a good idea for how to do it...</z><z id="t1533950285" t="nathanmarz @blak3mill3r what do you have in mind?"><y>#</y><d>2018-08-11</d><h>01:18</h><w>nathanmarz</w>@blak3mill3r what do you have in mind?</z><z id="t1534018734" t="blak3mill3r @nathanmarz an electron window that pretty-prints some data and highlights the parts that a path selects, combined with some repl tools along the lines of https://github.com/dgrnbrg/spyscope ... so you would eval #s/show (select [ALL :a MAP-VALS] something) and then see something pretty-printed with some parts of it highlighted"><y>#</y><d>2018-08-11</d><h>20:18</h><w>blak3mill3r</w>@nathanmarz an <code>electron</code> window that pretty-prints some data and highlights the parts that a path selects, combined with some repl tools along the lines of <a href="https://github.com/dgrnbrg/spyscope" target="_blank">https://github.com/dgrnbrg/spyscope</a> ... so you would eval <code>#s/show (select [ALL :a MAP-VALS] something)</code> and then see <code>something</code> pretty-printed with some parts of it highlighted</z><z id="t1534019410" t="nathanmarz @blak3mill3r that would be cool, especially if it showed the sequence of steps in a path in an interactive way"><y>#</y><d>2018-08-11</d><h>20:30</h><w>nathanmarz</w>@blak3mill3r that would be cool, especially if it showed the sequence of steps in a path in an interactive way</z><z id="t1534500031" t="mmer Simple question - I want to collect a set of keys from a nested map (but not all the keys - is there a simple way to do this?"><y>#</y><d>2018-08-17</d><h>10:00</h><w>mmer</w>Simple question - I want to collect a set of keys from a nested map (but not all the keys - is there a simple way to do this?</z><z id="t1534510547" t="nathanmarz @mmer if you just want to filter by a predicate you can do (select [MAP-KEYS even?] {1 :a 2 :b 3 :c 4 :d}) ;; =&gt; [2 4]"><y>#</y><d>2018-08-17</d><h>12:55</h><w>nathanmarz</w>@mmer if you just want to filter by a predicate you can do <code>(select [MAP-KEYS even?] {1 :a 2 :b 3 :c 4 :d}) ;; =&gt; [2 4]</code></z><z id="t1534512322" t="mmer Thanks"><y>#</y><d>2018-08-17</d><h>13:25</h><w>mmer</w>Thanks</z><z id="t1534512518" t="mmer As always happens with this - getting back into using after a while can be brain twisting - I want to do a conditional collect. I want to collect something based on a child map containing a certain key"><y>#</y><d>2018-08-17</d><h>13:28</h><w>mmer</w>As always happens with this - getting back into using after a while can be brain twisting - I want to do a conditional collect.  I want to collect something based on a child map containing a certain key</z><z id="t1534512636" t="mmer Also is there an easy way to select a map entry that has a certain key no matter where in a deeply nested data structure it is?"><y>#</y><d>2018-08-17</d><h>13:30</h><w>mmer</w>Also is there an easy way to select a map entry that has a certain key no matter where in a deeply nested data structure it is?</z><z id="t1534514047" t="nathanmarz @mmer do you have specific examples of what you&apos;re trying to do? It varies depending on the specifics"><y>#</y><d>2018-08-17</d><h>13:54</h><w>nathanmarz</w>@mmer do you have specific examples of what you&apos;re trying to do? It varies depending on the specifics</z><z id="t1534514497" t="mmer I am working over a yaml datastructure. I would like collect the name of the yaml item if the structure contains an item called &quot;tag&quot; , I also need the content of the tag."><y>#</y><d>2018-08-17</d><h>14:01</h><w>mmer</w>I am working over a yaml datastructure.  I would like collect the name of the yaml item if the structure contains an item called &quot;tag&quot; ,  I also need the content of the tag.</z><z id="t1534514579" t="mmer Interesting side point - until you asked this question I was unaware of the nastiness of the extra vectors as inmost case specter just did what I expected! --fantastic. Just these odd cases"><y>#</y><d>2018-08-17</d><h>14:02</h><w>mmer</w>Interesting side point - until you asked this question I was unaware of the nastiness of the extra vectors as inmost case specter just did what I expected! --fantastic.  Just these odd cases</z><z id="t1534515063" t="nathanmarz @mmer is that map in the input supposed to be a vector?"><y>#</y><d>2018-08-17</d><h>14:11</h><w>nathanmarz</w>@mmer is that map in the input supposed to be a vector?</z><z id="t1534515089" t="nathanmarz and by nested anywhere inside, you mean any one of those inner vectors could repeat the top-level structure?"><y>#</y><d>2018-08-17</d><h>14:11</h><w>nathanmarz</w>and by nested anywhere inside, you mean any one of those inner vectors could repeat the top-level structure?</z><z id="t1534515232" t="mmer The input structure could be contained anywhere in a larger structure and yes that should be a map - sorry"><y>#</y><d>2018-08-17</d><h>14:13</h><w>mmer</w>The input structure could be contained anywhere in a larger structure and yes that should be a map - sorry</z><z id="t1534517480" t="nathanmarz @mmer do you have an example of a more deeply nested structure?"><y>#</y><d>2018-08-17</d><h>14:51</h><w>nathanmarz</w>@mmer do you have an example of a more deeply nested structure?</z><z id="t1534517631" t="mmer Not sure I can share that - don&apos;t worry about it I will keep going. I am making progress in other areas. Thanks."><y>#</y><d>2018-08-17</d><h>14:53</h><w>mmer</w>Not sure I can share that - don&apos;t worry about it I will keep going.  I am making progress in other areas.  Thanks.</z><z id="t1535114633" t="roklenarcic I tend to use keywords as navigators for maps: (transform [:a :b ... . It works but is it correct? Are there downsides to this"><y>#</y><d>2018-08-24</d><h>12:43</h><w>roklenarcic</w>I tend to use keywords as navigators for maps: <code>(transform [:a :b ...</code>. It works but is it correct? Are there downsides to this</z><z id="t1535163103" t="idiomancy hoookay, trying to make a navigator path that selects the first value of every vector in a nested map of vectors like"><y>#</y><d>2018-08-25</d><h>02:11</h><w>idiomancy</w>hoookay, trying to make a navigator path that selects the first value of every vector in a nested map of vectors like</z><z id="t1535163110" t="idiomancy"><y>#</y><d>2018-08-25</d><h>02:11</h><w>idiomancy</w></z><z id="t1535163162" t="idiomancy i gather that I need a recursive path, and its straight blowin my mind"><y>#</y><d>2018-08-25</d><h>02:12</h><w>idiomancy</w>i gather that I need a recursive path, and its straight blowin my mind</z><z id="t1535163895" t="idiomancy hmm"><y>#</y><d>2018-08-25</d><h>02:24</h><w>idiomancy</w>hmm</z><z id="t1535163932" t="idiomancy"><y>#</y><d>2018-08-25</d><h>02:25</h><w>idiomancy</w></z><z id="t1535164471" t="idiomancy damn. thought this would work"><y>#</y><d>2018-08-25</d><h>02:34</h><w>idiomancy</w>damn.  thought this would work</z><z id="t1535164526" t="idiomancy"><y>#</y><d>2018-08-25</d><h>02:35</h><w>idiomancy</w></z><z id="t1535164537" t="idiomancy but it just blows up and says it exceeds recursion depth"><y>#</y><d>2018-08-25</d><h>02:35</h><w>idiomancy</w>but it just blows up and says it exceeds recursion depth</z><z id="t1535179777" t="nathanmarz @roklenarcic if you want to navigate to the value for a keyword, then that&apos;s always the best way"><y>#</y><d>2018-08-25</d><h>06:49</h><w>nathanmarz</w>@roklenarcic if you want to navigate to the value for a keyword, then that&apos;s always the best way</z><z id="t1535179824" t="nathanmarz there is also must which only navigates if the key exists"><y>#</y><d>2018-08-25</d><h>06:50</h><w>nathanmarz</w>there is also <code>must</code> which only navigates if the key exists</z><z id="t1535179990" t="nathanmarz @idiomancy change VECTOR-NODES to ALL in the definition"><y>#</y><d>2018-08-25</d><h>06:53</h><w>nathanmarz</w>@idiomancy change VECTOR-NODES to ALL in the definition</z><z id="t1535314654" t="idiomancy sorry for the delayed response but omg it works! thanks @nathanmarz!"><y>#</y><d>2018-08-26</d><h>20:17</h><w>idiomancy</w>sorry for the delayed response but omg it works!  thanks @nathanmarz!</z><z id="t1535334910" t="euccastro I just want to say specter is amazing. After seeing a couple examples and just trying out wild guesses in a pet project everything is working as I expected"><y>#</y><d>2018-08-27</d><h>01:55</h><w>euccastro</w>I just want to say specter is amazing.  After seeing a couple examples and just trying out wild guesses in a pet project everything is working as I expected</z><z id="t1535487003" t="jose I&apos;m trying to write a recursive navigator and I don&apos;t understand why this it&apos;s not working: (s/transform (s/recursive-path [] p (s/cond-path string? s/STAY map-entry? [s/ALL p] map? [s/ALL p])) keyword {&quot;A&quot; {&quot;B&quot; &quot;C&quot;} &quot;X&quot; 1}) "><y>#</y><d>2018-08-28</d><h>20:10</h><w>jose</w>I&apos;m trying to write a recursive navigator and I don&apos;t understand why this it&apos;s not working:
<pre>(s/transform (s/recursive-path [] p (s/cond-path
                                        string? s/STAY
                                        map-entry? [s/ALL p]
                                        map? [s/ALL p]))
               keyword
               {&quot;A&quot; {&quot;B&quot; &quot;C&quot;} &quot;X&quot; 1})
</pre></z><z id="t1535495312" t="jose by not working, I mean that nothing is transformed, but if instead of transform I use select I get [&quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;X&quot;] as I was expecting"><y>#</y><d>2018-08-28</d><h>22:28</h><w>jose</w>by not working, I mean that nothing is transformed, but if instead of <code>transform</code> I use <code>select</code> I get
<pre>[&quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;X&quot;]
</pre>
as I was expecting</z><z id="t1535518951" t="nathanmarz @jlle ALL on maps during transform navigates to vectors for map entries"><y>#</y><d>2018-08-29</d><h>05:02</h><w>nathanmarz</w>@jlle <code>ALL</code> on maps during transform navigates to vectors for map entries</z><z id="t1535518987" t="nathanmarz replace map? and map-entry? lines with coll? to fix it"><y>#</y><d>2018-08-29</d><h>05:03</h><w>nathanmarz</w>replace map? and map-entry? lines with coll? to fix it</z><z id="t1535540962" t="jose @nathanmarz that was the piece I was missing, thanks for the info"><y>#</y><d>2018-08-29</d><h>11:09</h><w>jose</w>@nathanmarz that was the piece I was missing, thanks for the info</z><z id="t1535540969" t="jose My transformation is a bit more complex, what I&apos;m trying to do is to transform all the string to keywords, except for the map values where the map key matches some condition. Easier to understand with an example:"><y>#</y><d>2018-08-29</d><h>11:09</h><w>jose</w>My transformation is a bit more complex, what I&apos;m trying to do is to transform all the string to keywords, except for the map values where the map key matches some condition. Easier to understand with an example:</z><z id="t1535541013" t="jose"><y>#</y><d>2018-08-29</d><h>11:10</h><w>jose</w></z><z id="t1535541045" t="jose which returns {:X &quot;Y&quot;, :Z 1, :I {:X &quot;Z&quot;}} I found that the transformation fails in cases like this: {&quot;X&quot; &quot;Y&quot; &quot;I&quot; [&quot;X&quot; &quot;Z&quot;]} so I updated the transformation function to:"><y>#</y><d>2018-08-29</d><h>11:10</h><w>jose</w>which returns <code>{:X &quot;Y&quot;, :Z 1, :I {:X &quot;Z&quot;}}</code>
I found that the transformation fails in cases like this: <code>{&quot;X&quot; &quot;Y&quot; &quot;I&quot; [&quot;X&quot; &quot;Z&quot;]}</code>
so I updated the transformation function to:</z><z id="t1535541080" t="jose"><y>#</y><d>2018-08-29</d><h>11:11</h><w>jose</w></z><z id="t1535561846" t="nathanmarz @jlle don&apos;t handle the map entry case separately, hande it on map? case as [ALL (if-path [FIRST (pred= &quot;X&quot;)] FIRST ALL) p]"><y>#</y><d>2018-08-29</d><h>16:57</h><w>nathanmarz</w>@jlle don&apos;t handle the map entry case separately, hande it on map? case as <code>[ALL (if-path [FIRST (pred= &quot;X&quot;)] FIRST ALL) p]</code></z><z id="t1535569637" t="jose right, that&apos;s a better solution, thanks a lot for the tip"><y>#</y><d>2018-08-29</d><h>19:07</h><w>jose</w>right, that&apos;s a better solution, thanks a lot for the tip</z><z id="t1535729364" t="benzap I figured it out!"><y>#</y><d>2018-08-31</d><h>15:29</h><w>benzap</w>I figured it out!</z><z id="t1535751820" t="idiomancy hmm, interesting. I&apos;m trying to select the meta from some objects and use that in a transformation step. It seems like when I put meta in the path, it acts as an identity function, returning the same values"><y>#</y><d>2018-08-31</d><h>21:43</h><w>idiomancy</w>hmm, interesting.  I&apos;m trying to select the meta from some objects and use that in a transformation step.  It seems like when I put meta in the path, it acts as an identity function, returning the same values</z><z id="t1535752022" t="idiomancy oh, I see. there&apos;s a specific META navigator"><y>#</y><d>2018-08-31</d><h>21:47</h><w>idiomancy</w>oh, I see.  there&apos;s a specific <code>META</code> navigator</z><z id="t1535754514" t="idiomancy Okay. So, for each element in this collection, I want to take its metadata key if it has metadata, or the key will be in a map as the second element of the list. so, data looks like this: [^{:key &quot;hello&quot;} [:div] [:div {:key &quot;world&quot;}] [:div [:subdiv]]] I want to select the keys, if they exist, for each. So, something like (s/select [s/ALL (s/if-path [s/META :key] [s/META :key] [#(&lt; 1 (count %)) (s/nthpath 1) map? :key])] [^{:key &quot;hello&quot;} [:div] [:div {:key &quot;world&quot;}] [:div [:subdiv]]]) =&gt; [&quot;hello&quot; &quot;world&quot; nil] but if-path isn&apos;t doing what I thought. if-path tests the first element, and if it succeeds, uses that path for all of the elements. How do I do what I&apos;m trying to do?"><y>#</y><d>2018-08-31</d><h>22:28</h><w>idiomancy</w>Okay.  So, for each element in this collection, I want to take its metadata key if it has metadata, or the key will be in a map as the second element of the list.

so, data looks like this:
<pre>[^{:key &quot;hello&quot;} [:div]
                          [:div {:key &quot;world&quot;}]
                          [:div [:subdiv]]]
</pre>

I want to select the keys, if they exist, for each.  So, something like
<pre>(s/select 
  [s/ALL
   (s/if-path [s/META :key]
              [s/META :key]
              [#(&lt; 1 (count %)) (s/nthpath 1) map? :key])]
  [^{:key &quot;hello&quot;} [:div] 
                   [:div {:key &quot;world&quot;}]
                   [:div [:subdiv]]])
=&gt; [&quot;hello&quot; &quot;world&quot; nil]
</pre>

but if-path isn&apos;t doing what I thought.  if-path tests the first element, and if it succeeds, uses that path for all of the elements.

How do I do what I&apos;m trying to do?</z><z id="t1535755498" t="idiomancy I ended up doing it with a multi-path and a filter for now... is there a better way?"><y>#</y><d>2018-08-31</d><h>22:44</h><w>idiomancy</w>I ended up doing it with a multi-path and a filter for now... is there a better way?</z><z id="t1535755592" t="idiomancy [s/ALL (s/multi-path [s/META :key] [#(&lt; 1 (count %)) (s/nthpath 1) map? :key]) some?] and then I just manually select the first element of the path returned collect, because I don&apos;t know how to bring it back to a single element 😂"><y>#</y><d>2018-08-31</d><h>22:46</h><w>idiomancy</w><pre>[s/ALL
 (s/multi-path [s/META :key]
               [#(&lt; 1 (count %))
                (s/nthpath 1)
                map? :key])
 some?]
</pre>

and then I just manually select the first element of the path returned collect, because I don&apos;t know how to bring it back to a single element <b>😂</b></z><z id="t1535782792" t="nathanmarz @idiomancy if-path&apos;s condition is true if the path selects at least one element"><y>#</y><d>2018-09-01</d><h>06:19</h><w>nathanmarz</w>@idiomancy if-path&apos;s condition is true if the path selects at least one element</z><z id="t1535782824" t="nathanmarz since META and keywords always navigate to exactly one value, your condition is always true"><y>#</y><d>2018-09-01</d><h>06:20</h><w>nathanmarz</w>since META and keywords always navigate to exactly one value, your condition is always true</z><z id="t1535782873" t="nathanmarz you want the condition path [META (must :key)]"><y>#</y><d>2018-09-01</d><h>06:21</h><w>nathanmarz</w>you want the condition path <code>[META (must :key)]</code></z><z id="t1535804668" t="idiomancy Thanks! And thanks for the incredible library :star-struck: I&apos;m so addicted!"><y>#</y><d>2018-09-01</d><h>12:24</h><w>idiomancy</w>Thanks!  And thanks for the incredible library <b>:star-struck:</b>  I&apos;m so addicted!</z><z id="t1535940639" t="unbalanced specific and general question. General question: where does one go to level up in specter? I feel like I&apos;ve already tapped out on talks/tutorials and I know I&apos;m only scratching the surface. Case in point -- Specific question: given (def contrived-data {:time 1535940129129 :data [{:a [{:start 389 :stop 456}]} {:b [{:start 113 :stop 889}]}]}) I&apos;m attempting to sort by :start . It&apos;s blessedly simple to select the values via (sm/select [:data s/ALL s/MAP-VALS s/ALL :start] contrived-data) my intuition to do the operation would be (sm/transform [:data s/ALL s/MAP-VALS s/ALL :start] sort contrived-data) but I realized my thinking may have gone awry somewhere along the way"><y>#</y><d>2018-09-03</d><h>02:10</h><w>unbalanced</w>specific and general question.
General question: where does one go to level up in specter?  I feel like I&apos;ve already tapped out on talks/tutorials and I know I&apos;m only scratching the surface.  Case in point --
Specific question:

given

<pre>(def contrived-data {:time 1535940129129
                       :data [{:a [{:start 389
                                    :stop  456}]}
                              {:b [{:start 113
                                    :stop  889}]}]})</pre>

I&apos;m attempting to sort by <code>:start</code>.  It&apos;s blessedly simple to select the values via

<pre>(sm/select [:data s/ALL s/MAP-VALS s/ALL :start] contrived-data)</pre>

my intuition to do the operation would be

<pre>(sm/transform [:data s/ALL s/MAP-VALS s/ALL :start] sort contrived-data)</pre>

but I realized my thinking may have gone awry somewhere along the way</z><z id="t1535940832" t="nathanmarz @goomba what do you want the result of that transform to be?"><y>#</y><d>2018-09-03</d><h>02:13</h><w>nathanmarz</w>@goomba what do you want the result of that transform to be?</z><z id="t1535940979" t="unbalanced"><y>#</y><d>2018-09-03</d><h>02:16</h><w>unbalanced</w></z><z id="t1535940984" t="unbalanced sorry, should&apos;ve posted that"><y>#</y><d>2018-09-03</d><h>02:16</h><w>unbalanced</w>sorry, should&apos;ve posted that</z><z id="t1535941002" t="unbalanced as in, :b should come first because its :start value is lower"><y>#</y><d>2018-09-03</d><h>02:16</h><w>unbalanced</w>as in, <code>:b</code> should come first because its <code>:start</code> value is lower</z><z id="t1535941056" t="nathanmarz what if the inner collection has multiple :start values?"><y>#</y><d>2018-09-03</d><h>02:17</h><w>nathanmarz</w>what if the inner collection has multiple <code>:start</code> values?</z><z id="t1535941063" t="nathanmarz use the lowest?"><y>#</y><d>2018-09-03</d><h>02:17</h><w>nathanmarz</w>use the lowest?</z><z id="t1535941078" t="unbalanced sure 😅"><y>#</y><d>2018-09-03</d><h>02:17</h><w>unbalanced</w>sure <b>😅</b></z><z id="t1535941092" t="unbalanced hadn&apos;t thought that far ahead with my contrived example"><y>#</y><d>2018-09-03</d><h>02:18</h><w>unbalanced</w>hadn&apos;t thought that far ahead with my contrived example</z><z id="t1535941132" t="unbalanced it&apos;s the fact that the keys :a and :b &quot;pre-fix&quot; the data makes any sort of normal update-in /`sort-by` completely unusable, at least with any sort of elegance/performance"><y>#</y><d>2018-09-03</d><h>02:18</h><w>unbalanced</w>it&apos;s the fact that the keys <code>:a</code> and <code>:b</code> &quot;pre-fix&quot; the data makes any sort of normal <code>update-in</code>/`sort-by` completely unusable, at least with any sort of elegance/performance</z><z id="t1535941152" t="unbalanced but I encounter this problem all the time"><y>#</y><d>2018-09-03</d><h>02:19</h><w>unbalanced</w>but I encounter this problem all the time</z><z id="t1535941338" t="nathanmarz you can use something like (fn [m] (reduce min (traverse [MAP-VALS ALL :start] m)) for a &quot;keyfn&quot; to sort-by"><y>#</y><d>2018-09-03</d><h>02:22</h><w>nathanmarz</w>you can use something like <code>(fn [m] (reduce min (traverse [MAP-VALS ALL :start] m))</code> for a &quot;keyfn&quot; to <code>sort-by</code></z><z id="t1535941396" t="nathanmarz and then (transform :data #(sort-by keyfn %) data)"><y>#</y><d>2018-09-03</d><h>02:23</h><w>nathanmarz</w>and then <code>(transform :data #(sort-by keyfn %) data)</code></z><z id="t1535941495" t="nathanmarz beware that sort-by will change that vector to a list"><y>#</y><d>2018-09-03</d><h>02:24</h><w>nathanmarz</w>beware that <code>sort-by</code> will change that vector to a list</z><z id="t1535941515" t="unbalanced ohhhh mannn that is cooooolllllll 😄"><y>#</y><d>2018-09-03</d><h>02:25</h><w>unbalanced</w>ohhhh mannn that is cooooolllllll <b>😄</b></z><z id="t1535941631" t="unbalanced thank you! how did you... well, I guess because you wrote it, I would&apos;ve thought to use select instead of traverse"><y>#</y><d>2018-09-03</d><h>02:27</h><w>unbalanced</w>thank you! how did you... well, I guess because you wrote it, I would&apos;ve thought to use <code>select</code> instead of <code>traverse</code></z><z id="t1535941689" t="nathanmarz always use traverse if all you&apos;ll be doing is a reduce over the result"><y>#</y><d>2018-09-03</d><h>02:28</h><w>nathanmarz</w>always use <code>traverse</code> if all you&apos;ll be doing is a <code>reduce</code> over the result</z><z id="t1535941714" t="nathanmarz more efficient since no intermediate list is materialized"><y>#</y><d>2018-09-03</d><h>02:28</h><w>nathanmarz</w>more efficient since no intermediate list is materialized</z><z id="t1535941805" t="unbalanced 🙏 fantastic. Thanks again."><y>#</y><d>2018-09-03</d><h>02:30</h><w>unbalanced</w><b>🙏</b> fantastic.  Thanks again.</z><z id="t1536020268" t="unbalanced forgive the neophyte inquiriry, I&apos;m attempting to emulate (update-in {} [:a :b :c] (fnil concat []) [1 2 3])"><y>#</y><d>2018-09-04</d><h>00:17</h><w>unbalanced</w>forgive the neophyte inquiriry, I&apos;m attempting to emulate
<pre>(update-in {} [:a :b :c] (fnil concat [])  [1 2 3])</pre></z><z id="t1536020284" t="unbalanced for practice I&apos;m just trying it on one nested value"><y>#</y><d>2018-09-04</d><h>00:18</h><w>unbalanced</w>for practice I&apos;m just trying it on one nested value</z><z id="t1536020301" t="unbalanced (setval [:a NIL-&gt;VECTOR END] [1 2 3] {})"><y>#</y><d>2018-09-04</d><h>00:18</h><w>unbalanced</w><pre>(setval [:a NIL-&gt;VECTOR END] [1 2 3] {})</pre></z><z id="t1536021833" t="unbalanced ah I see... so the above is working it&apos;s when I&apos;m dealing with a vector-as-a-key that it&apos;s an issue"><y>#</y><d>2018-09-04</d><h>00:43</h><w>unbalanced</w>ah I see... so the above is working it&apos;s when I&apos;m dealing with a vector-as-a-key that it&apos;s an issue</z><z id="t1536021852" t="unbalanced (setval [:a (must [:b :c]) NIL-&gt;VECTOR END] [1 2 3] {:a {}})"><y>#</y><d>2018-09-04</d><h>00:44</h><w>unbalanced</w><pre>(setval [:a (must [:b :c]) NIL-&gt;VECTOR END] [1 2 3] {:a {}})</pre></z><z id="t1536023568" t="unbalanced current working work around... not pretty but it works"><y>#</y><d>2018-09-04</d><h>01:12</h><w>unbalanced</w>current working work around... not pretty but it works</z><z id="t1536023610" t="unbalanced"><y>#</y><d>2018-09-04</d><h>01:13</h><w>unbalanced</w></z><z id="t1536039253" t="nathanmarz @goomba I think you want (must :b :c) or (apply must [:b :c])"><y>#</y><d>2018-09-04</d><h>05:34</h><w>nathanmarz</w>@goomba I think you want <code>(must :b :c)</code> or <code>(apply must [:b :c])</code></z><z id="t1536094253" t="unbalanced hmm well no luck so far but my guess is in general I&apos;m still not a high enough level specter yet"><y>#</y><d>2018-09-04</d><h>20:50</h><w>unbalanced</w>hmm well no luck so far but my guess is in general I&apos;m still not a high enough level specter yet</z><z id="t1536094289" t="unbalanced you don&apos;t happen to know @nathanmarz of any open source projects that are making good use of your library do you? Would love to see more examples"><y>#</y><d>2018-09-04</d><h>20:51</h><w>unbalanced</w>you don&apos;t happen to know @nathanmarz of any open source projects that are making good use of your library do you?  Would love to see more examples</z><z id="t1536094349" t="unbalanced I&apos;m always getting so close to what I want to do but just always missing a piece"><y>#</y><d>2018-09-04</d><h>20:52</h><w>unbalanced</w>I&apos;m always getting so close to what I want to do but just always missing a piece</z><z id="t1536094357" t="unbalanced for instance, navigating to the maximum of a set of elements"><y>#</y><d>2018-09-04</d><h>20:52</h><w>unbalanced</w>for instance, navigating to the maximum of a set of elements</z><z id="t1536094435" t="unbalanced (select [MAP-VALS :index MAX] {:a {:index 0} :b {:index 1}}) ... I should be able to write or figure out MAX but sadly just not there yet"><y>#</y><d>2018-09-04</d><h>20:53</h><w>unbalanced</w><pre>(select [MAP-VALS :index MAX] {:a {:index 0} :b {:index 1}})</pre> ... I should be able to write or figure out <code>MAX</code> but sadly just not there yet</z><z id="t1536094504" t="unbalanced of course that&apos;s simple enough to do with other functions but just trying to learn to think in specter haha"><y>#</y><d>2018-09-04</d><h>20:55</h><w>unbalanced</w>of course that&apos;s simple enough to do with other functions but just trying to learn to think in specter haha</z><z id="t1536096442" t="nathanmarz @goomba I don&apos;t really keep track of how specter is used by other open source projects"><y>#</y><d>2018-09-04</d><h>21:27</h><w>nathanmarz</w>@goomba I don&apos;t really keep track of how specter is used by other open source projects</z><z id="t1536096464" t="nathanmarz you can try doing a github search"><y>#</y><d>2018-09-04</d><h>21:27</h><w>nathanmarz</w>you can try doing a github search</z><z id="t1536096473" t="unbalanced no problemo... working through some of your examples"><y>#</y><d>2018-09-04</d><h>21:27</h><w>unbalanced</w>no problemo... working through some of your examples</z><z id="t1536096500" t="nathanmarz MAX would have to be done with defnav"><y>#</y><d>2018-09-04</d><h>21:28</h><w>nathanmarz</w><code>MAX</code> would have to be done with <code>defnav</code></z><z id="t1536238512" t="roklenarcic Hm, I have two predicates and sequence. I would like to select items starting with an element that satisfies predicate1, up to an element that specifies predicate2."><y>#</y><d>2018-09-06</d><h>12:55</h><w>roklenarcic</w>Hm, I have two predicates and sequence. I would like to select items starting with an element that satisfies predicate1, up to an element that specifies predicate2.</z><z id="t1536238551" t="roklenarcic I&apos;m a bit of a newbie when it comes to working subsequences with specter"><y>#</y><d>2018-09-06</d><h>12:55</h><w>roklenarcic</w>I&apos;m a bit of a newbie when it comes to working subsequences with specter</z><z id="t1536239181" t="nathanmarz @roklenarcic you would need https://github.com/nathanmarz/specter/issues/236 to do that"><y>#</y><d>2018-09-06</d><h>13:06</h><w>nathanmarz</w>@roklenarcic you would need <a href="https://github.com/nathanmarz/specter/issues/236" target="_blank">https://github.com/nathanmarz/specter/issues/236</a> to do that</z><z id="t1536239242" t="nathanmarz you could make your own version of continuous-subseqs with the generalized behavior, it&apos;s not very complicated"><y>#</y><d>2018-09-06</d><h>13:07</h><w>nathanmarz</w>you could make your own version of continuous-subseqs with the generalized behavior, it&apos;s not very complicated</z><z id="t1536239287" t="roklenarcic Fortunately this isn&apos;t nested in some other selector so I&apos;ll just use drop-while, take-while"><y>#</y><d>2018-09-06</d><h>13:08</h><w>roklenarcic</w>Fortunately this isn&apos;t nested in some other selector so I&apos;ll just use drop-while, take-while</z><z id="t1536247576" t="bruno.bonacci Hi, is there any way in Specter to have a something like a mapcat ?? For example I’d like to denormalize a map like this: {:a 1 :b [&quot;a&quot; &quot;b&quot;]} into {:a 1 :b &quot;a&quot;} {:a 1 :b &quot;b&quot;} same as (mapcat (fn [{:keys [b] :as m}] (map #(assoc m :b %) b)) [{:a 1 :b [&quot;a&quot; &quot;b&quot;]} {:a 2 :b [&quot;c&quot; &quot;d&quot;]}]) ;;=&gt; &apos;({:a 1, :b &quot;a&quot;} {:a 1, :b &quot;b&quot;} {:a 2, :b &quot;c&quot;} {:a 2, :b &quot;d&quot;}) But I havent found a way to concatenate the result and remove the extra ’() in one step. (transform [ALL] (fn [{:keys [b] :as m}] (map #(assoc m :b %) b)) [{:a 1 :b [&quot;a&quot; &quot;b&quot;]} {:a 2 :b [&quot;c&quot; &quot;d&quot;]}]) ;;=&gt; [({:a 1, :b &quot;a&quot;} {:a 1, :b &quot;b&quot;}) ;; ({:a 2, :b &quot;c&quot;} {:a 2, :b &quot;d&quot;})] "><y>#</y><d>2018-09-06</d><h>15:26</h><w>bruno.bonacci</w>Hi,
is there any way in Specter to have a something like a <code>mapcat</code>??
For example I’d like to denormalize a map like this:
<pre>{:a 1 :b [&quot;a&quot; &quot;b&quot;]}
</pre>
into
<pre>{:a 1 :b &quot;a&quot;}
{:a 1 :b &quot;b&quot;}
</pre>

same as

<pre>(mapcat (fn [{:keys [b] :as m}]
          (map #(assoc m :b %) b))
        [{:a 1 :b [&quot;a&quot; &quot;b&quot;]} {:a 2 :b [&quot;c&quot; &quot;d&quot;]}])
;;=&gt; &apos;({:a 1, :b &quot;a&quot;} {:a 1, :b &quot;b&quot;} {:a 2, :b &quot;c&quot;} {:a 2, :b &quot;d&quot;})
</pre>
But I havent found a way to concatenate the result and remove
the extra ’() in one step.

<pre>(transform [ALL]
           (fn [{:keys [b] :as m}]
             (map #(assoc m :b %) b))
           [{:a 1 :b [&quot;a&quot; &quot;b&quot;]} {:a 2 :b [&quot;c&quot; &quot;d&quot;]}])
;;=&gt; [({:a 1, :b &quot;a&quot;} {:a 1, :b &quot;b&quot;})
;;    ({:a 2, :b &quot;c&quot;} {:a 2, :b &quot;d&quot;})]

</pre></z><z id="t1536247583" t="bruno.bonacci any idea?"><y>#</y><d>2018-09-06</d><h>15:26</h><w>bruno.bonacci</w>any idea?</z><z id="t1536254578" t="nathanmarz @bruno.bonacci you can do something like: (transform ALL (fn [[m b]] (assoc m :b b)) (select [ALL VAL :b ALL] data)) "><y>#</y><d>2018-09-06</d><h>17:22</h><w>nathanmarz</w>@bruno.bonacci you can do something like:
<pre>(transform ALL
  (fn [[m b]] (assoc m :b b))
  (select [ALL VAL :b ALL] data))
</pre></z><z id="t1536254635" t="nathanmarz having two ALL&apos;s in a select can act like mapcat"><y>#</y><d>2018-09-06</d><h>17:23</h><w>nathanmarz</w>having two ALL&apos;s in a select can act like mapcat</z><z id="t1536254801" t="bruno.bonacci ok, I understand what you are doing here. The select is creating a projection with the info and the transform is producing the final maps."><y>#</y><d>2018-09-06</d><h>17:26</h><w>bruno.bonacci</w>ok, I understand what you are doing here. The <code>select</code> is creating a projection with the info and the <code>transform</code> is producing the final maps.</z><z id="t1536254839" t="bruno.bonacci interesting approach, thanks."><y>#</y><d>2018-09-06</d><h>17:27</h><w>bruno.bonacci</w>interesting approach, thanks.</z><z id="t1536254875" t="nathanmarz with a modified view you could do it in a single select"><y>#</y><d>2018-09-06</d><h>17:27</h><w>nathanmarz</w>with a modified <code>view</code> you could do it in a single <code>select</code></z><z id="t1536254951" t="nathanmarz just by passing the collected vals into the view fn"><y>#</y><d>2018-09-06</d><h>17:29</h><w>nathanmarz</w>just by passing the collected vals into the view fn</z><z id="t1536255027" t="bruno.bonacci got it, thanks"><y>#</y><d>2018-09-06</d><h>17:30</h><w>bruno.bonacci</w>got it, thanks</z><z id="t1536255837" t="bruno.bonacci Sorry, view doesn’t seem to be affected by the collection of values"><y>#</y><d>2018-09-06</d><h>17:43</h><w>bruno.bonacci</w>Sorry, <code>view</code> doesn’t seem to be affected by the collection of values</z><z id="t1536255876" t="bruno.bonacci (select [ALL VAL (view pr-str)] (range 5)) =&gt; [[0 &quot;0&quot;] [1 &quot;1&quot;] [2 &quot;2&quot;] [3 &quot;3&quot;] [4 &quot;4&quot;]]"><y>#</y><d>2018-09-06</d><h>17:44</h><w>bruno.bonacci</w><code>(select [ALL VAL (view pr-str)] (range 5)) =&gt; [[0 &quot;0&quot;] [1 &quot;1&quot;] [2 &quot;2&quot;] [3 &quot;3&quot;] [4 &quot;4&quot;]]</code></z><z id="t1536255922" t="bruno.bonacci i was expecting that the view function would receive also the collected values"><y>#</y><d>2018-09-06</d><h>17:45</h><w>bruno.bonacci</w>i was expecting that the <code>view</code> function would receive also the collected values</z><z id="t1536255968" t="bruno.bonacci here it appears it only receives the value in the navigation path"><y>#</y><d>2018-09-06</d><h>17:46</h><w>bruno.bonacci</w>here it appears it only receives the value in the navigation path</z><z id="t1536256247" t="nathanmarz that&apos;s correct, that&apos;s why I said with a modified view"><y>#</y><d>2018-09-06</d><h>17:50</h><w>nathanmarz</w>that&apos;s correct, that&apos;s why I said with a modified <code>view</code></z><z id="t1536256487" t="nathanmarz (defrichnav cview [afn] (select* [this vals structure next-fn] (next-fn vals (apply afn (conj vals structure)))) (transform* [this vals structure next-fn] (next-fn vals (apply afn (conj vals structure))))) "><y>#</y><d>2018-09-06</d><h>17:54</h><w>nathanmarz</w><pre>(defrichnav cview [afn]
  (select* [this vals structure next-fn]
    (next-fn vals (apply afn (conj vals structure))))
  (transform* [this vals structure next-fn]
    (next-fn vals (apply afn (conj vals structure)))))
</pre></z><z id="t1536256549" t="bruno.bonacci :+1: Thanks"><y>#</y><d>2018-09-06</d><h>17:55</h><w>bruno.bonacci</w><b>:+1:</b> Thanks</z><z id="t1536671025" t="miikka When should I use nthpath and when index-nav ?"><y>#</y><d>2018-09-11</d><h>13:03</h><w>miikka</w>When should I use <code>nthpath</code> and when <code>index-nav</code>?</z><z id="t1536672989" t="nathanmarz @miikka nthpath navigates to the value for the index, index-nav navigates to the actual index"><y>#</y><d>2018-09-11</d><h>13:36</h><w>nathanmarz</w>@miikka <code>nthpath</code> navigates to the value for the index, <code>index-nav</code> navigates to the actual index</z><z id="t1536672999" t="nathanmarz take a look at the examples on the wiki"><y>#</y><d>2018-09-11</d><h>13:36</h><w>nathanmarz</w>take a look at the examples on the wiki</z><z id="t1536673000" t="miikka Ah"><y>#</y><d>2018-09-11</d><h>13:36</h><w>miikka</w>Ah</z><z id="t1536863450" t="idiomancy does anyone know how I would select a slice of elements within a sequence between two values? I&apos;m slicing a datomic query, and I want everything between :find and :when , so: [:find ?id . :where [?id :app/type :type/form]] =&gt; [?id .] [:find [?tid ...] :where [?tid :app/type :type/task]] =&gt; [[?tid ...]] "><y>#</y><d>2018-09-13</d><h>18:30</h><w>idiomancy</w>does anyone know how I would select a slice of elements within a sequence between two values?

I&apos;m slicing a datomic query, and I want everything between <code>:find</code> and <code>:when</code>, so:

<pre>[:find ?id . :where [?id :app/type :type/form]]
=&gt; [?id .]

[:find  [?tid ...] :where [?tid :app/type :type/task]]
=&gt; [[?tid ...]]
</pre></z><z id="t1536863625" t="idiomancy I guess I could use srange-dynamic"><y>#</y><d>2018-09-13</d><h>18:33</h><w>idiomancy</w>I guess I could use srange-dynamic</z><z id="t1536896556" t="nathanmarz @idiomancy yes, srange-dynamic would work for that"><y>#</y><d>2018-09-14</d><h>03:42</h><w>nathanmarz</w>@idiomancy yes, srange-dynamic would work for that</z><z id="t1536924737" t="mpenet how would you write a transform that modifies every string value in a tree? I have yet to check the doc but I figured I might just ask here in the meanwhile 😛"><y>#</y><d>2018-09-14</d><h>11:32</h><w>mpenet</w>how would you write a transform that modifies every string value in a tree? I have yet to check the doc but I figured I might just ask here in the meanwhile <b>😛</b></z><z id="t1536924825" t="schmee (transform (walker string?) your-fn your-coll)"><y>#</y><d>2018-09-14</d><h>11:33</h><w>schmee</w><code>(transform (walker string?) your-fn your-coll)</code></z><z id="t1536924839" t="schmee not the most efficient way but gets the job done"><y>#</y><d>2018-09-14</d><h>11:33</h><w>schmee</w>not the most efficient way but gets the job done</z><z id="t1536924879" t="schmee if you need performance, write your own recursive navigator: https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#a-basic-example"><y>#</y><d>2018-09-14</d><h>11:34</h><w>schmee</w>if you need performance, write your own recursive navigator: <a href="https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#a-basic-example" target="_blank">https://github.com/nathanmarz/specter/wiki/Using-Specter-Recursively#a-basic-example</a></z><z id="t1536924897" t="mpenet reading that at the moment, that seems like what I am looking for indeed. thanks"><y>#</y><d>2018-09-14</d><h>11:34</h><w>mpenet</w>reading that at the moment, that seems like what I am looking for indeed. thanks</z><z id="t1536927010" t="Petrus Theron Has anyone used Specter for Matrix algebra? I&apos;m dealing with Kalman filtering N streams of data, and I have to do all this ceremony around assigning an index to each sensor value, multiplying some matrixes together that are really about (premature) index-based optimization, then I have to un-index them again - basically, lensing."><y>#</y><d>2018-09-14</d><h>12:10</h><w>Petrus Theron</w>Has anyone used Specter for Matrix algebra? I&apos;m dealing with Kalman filtering N streams of data, and I have to do all this ceremony around assigning an index to each sensor value, multiplying some matrixes together that are really about (premature) index-based optimization, then I have to un-index them again - basically, lensing.</z><z id="t1536929470" t="nathanmarz @petrus I&apos;ve done some stuff with matrices"><y>#</y><d>2018-09-14</d><h>12:51</h><w>nathanmarz</w>@petrus I&apos;ve done some stuff with matrices</z><z id="t1536929546" t="nathanmarz you&apos;ll want custom navigators for them to do anything sophisticated"><y>#</y><d>2018-09-14</d><h>12:52</h><w>nathanmarz</w>you&apos;ll want custom navigators for them to do anything sophisticated</z><z id="t1536929588" t="nathanmarz e.g. a &quot;submat&quot; navigator that navigates to an arbitrary sub-matrix"><y>#</y><d>2018-09-14</d><h>12:53</h><w>nathanmarz</w>e.g. a &quot;submat&quot; navigator that navigates to an arbitrary sub-matrix</z><z id="t1536929609" t="nathanmarz &quot;row&quot; and &quot;col&quot; navigators can be useful too"><y>#</y><d>2018-09-14</d><h>12:53</h><w>nathanmarz</w>&quot;row&quot; and &quot;col&quot; navigators can be useful too</z><z id="t1537458429" t="okocim I’m a complete novice with specter (fired it up about a day ago), but I’m liking it so far. One thing that strikes me about the library is that it lends itself very well when you’re trying to simulate an “update in place” of a complex data structure. However, when I’m trying to completely change the shape of one data structure into a different structure (e.g. for transformation at a contract boundary), I find myself fighting with it a bit more. Am I right in my thinking that this is more suited for changing values in an existing data structure, or was this library also intended to help reshape data structures, and I’m not yet understanding which of the helpers are used for that. What I’ve been doing to date is calling select and collecting the values that I’m interested in, and then simply arranging the collected values into whatever shape I need. Is that the right approach?"><y>#</y><d>2018-09-20</d><h>15:47</h><w>okocim</w>I’m a complete novice with specter (fired it up about a day ago), but I’m liking it so far.  One thing that strikes me about the library is that it lends itself very well when you’re trying to simulate an “update in place” of a complex data structure. However, when I’m trying to completely change the shape of one data structure into a different structure (e.g. for transformation at a contract boundary), I find myself fighting with it a bit more.

Am I right in my thinking that this is more suited for changing values in an existing data structure, or was this library also intended to help reshape data structures, and I’m not yet understanding which of the helpers are used for that.

What I’ve been doing to date is calling <code>select</code> and collecting the values that I’m interested in, and then simply arranging the collected values into whatever shape I need. Is that the right approach?</z><z id="t1537463128" t="nathanmarz @okocim you have it right, specter excels at doing partial changes of a data structure"><y>#</y><d>2018-09-20</d><h>17:05</h><w>nathanmarz</w>@okocim you have it right, specter excels at doing partial changes of a data structure</z><z id="t1537463155" t="nathanmarz if you&apos;re restructuring the whole thing, specter probably won&apos;t help that much"><y>#</y><d>2018-09-20</d><h>17:05</h><w>nathanmarz</w>if you&apos;re restructuring the whole thing, specter probably won&apos;t help that much</z><z id="t1537468338" t="okocim @nathanmarz Thanks for confirming, and thanks for the library. The partial update use-case is the one that I primarily used this for, and it really does feel like you’re providing a piece that’s missing in core clojure 👍"><y>#</y><d>2018-09-20</d><h>18:32</h><w>okocim</w>@nathanmarz Thanks for confirming, and thanks for the library. The partial update use-case is the one that I primarily used this for, and it really does feel like you’re providing a piece that’s missing in core clojure <b>👍</b></z><z id="t1537720314" t="Joshua Suskalo Hey, so I&apos;m working with specter a bit, and one problem that I&apos;ve noticed has come up several times which I feel has to have a normal solution, is that when I use transform there&apos;s no way to set the value if there is none already there. The solution I&apos;ve had to use on several occasions is this: (let [value (select-first [:path :to :val] structure) value (update-fn value) structure (setval [:path :to :val] value structure)] structure) And this feels wrong on many levels, not the least of which because if structure is an atom, and I use ATOM in the path, that means that the operation is no longer atomic."><y>#</y><d>2018-09-23</d><h>16:31</h><w>Joshua Suskalo</w>Hey, so I&apos;m working with specter a bit, and one problem that I&apos;ve noticed has come up several times which I feel has to have a normal solution, is that when I use <code>transform</code> there&apos;s no way to set the value if there is none already there. The solution I&apos;ve had to use on several occasions is this:
<pre>(let [value (select-first [:path :to :val] structure)
      value (update-fn value)
      structure (setval [:path :to :val] value structure)]
  structure)
</pre>
And this feels wrong on many levels, not the least of which because if <code>structure</code> is an atom, and I use <code>ATOM</code> in the path, that means that the operation is no longer atomic.</z><z id="t1537720519" t="Joshua Suskalo Everything else I&apos;ve used in specter always feels like a great addition to Clojure, but this one hiccup is something that I&apos;ve run into enough times that it almost makes me want to express this instead using a normal swap!"><y>#</y><d>2018-09-23</d><h>16:35</h><w>Joshua Suskalo</w>Everything else I&apos;ve used in specter always feels like a great addition to Clojure, but this one hiccup is something that I&apos;ve run into enough times that it almost makes me want to express this instead using a normal <code>swap!</code></z><z id="t1537721607" t="jsa-aerial I&apos;m a bit confused. This sort of thing (sp/transform [sp/ATOM key-path] update-fn db)) works just fine for me whether the final key exists or not. Also there is sp/BEGINNING and friends, which all work fine as well."><y>#</y><d>2018-09-23</d><h>16:53</h><w>jsa-aerial</w>I&apos;m a bit confused. This sort of thing <code>(sp/transform [sp/ATOM key-path] update-fn db))</code> works just fine for me whether the final key exists or not. Also there is sp/BEGINNING and friends, which all work fine as well.</z></g><g id="s22"><z id="t1537721629" t="jsa-aerial @suskeyhose ^^^^"><y>#</y><d>2018-09-23</d><h>16:53</h><w>jsa-aerial</w>@suskeyhose ^^^^</z><z id="t1537721668" t="Joshua Suskalo Really? I&apos;m not getting the function called at all with an example. Just a moment and I can give you the example that I&apos;m running."><y>#</y><d>2018-09-23</d><h>16:54</h><w>Joshua Suskalo</w>Really? I&apos;m not getting the function called at all with an example. Just a moment and I can give you the example that I&apos;m running.</z><z id="t1537721747" t="jsa-aerial Yeah, works great - if it didn&apos;t, I would be hurting"><y>#</y><d>2018-09-23</d><h>16:55</h><w>jsa-aerial</w>Yeah, works great - if it didn&apos;t, I would be hurting</z><z id="t1537721761" t="Joshua Suskalo Hmm. Well now it&apos;s working on the small example. Curious why it&apos;s not working in my larger code."><y>#</y><d>2018-09-23</d><h>16:56</h><w>Joshua Suskalo</w>Hmm. Well now it&apos;s working on the small example. Curious why it&apos;s not working in my larger code.</z><z id="t1537721781" t="jsa-aerial likely something else is happening"><y>#</y><d>2018-09-23</d><h>16:56</h><w>jsa-aerial</w>likely something else is happening</z><z id="t1537721885" t="jsa-aerial Further, yielding sp/NONE for the value removes the element (for example, k/v pair in a map) which is really wonderful"><y>#</y><d>2018-09-23</d><h>16:58</h><w>jsa-aerial</w>Further, yielding sp/NONE for the value removes the element (for example, k/v pair in a map) which is really wonderful</z><z id="t1537722255" t="Joshua Suskalo Yeah, I&apos;ve used that a few times, which is fantastic"><y>#</y><d>2018-09-23</d><h>17:04</h><w>Joshua Suskalo</w>Yeah, I&apos;ve used that a few times, which is fantastic</z><z id="t1537722877" t="Joshua Suskalo Okay, so the example in my code which this is working with is like this: (transform [ATOM ::ds/rate-limits ::ds/endpoint-specific-rate-limits {::ds/action :create-message ::ds/major-variable {::ds/major-variable-type ::ds/channel-id ::ds/major-variable-value &quot;286241942356885504&quot;}}] #(println %) (atom #:discljord.specs{:rate-limits #:discljord.specs{:endpoint-specific-rate-limits {}}, :channel (a/chan 100), :token &quot;TOKEN&quot;})) The println doesn&apos;t get called at all"><y>#</y><d>2018-09-23</d><h>17:14</h><w>Joshua Suskalo</w>Okay, so the example in my code which this is working with is like this:
<pre>(transform [ATOM
            ::ds/rate-limits
            ::ds/endpoint-specific-rate-limits
            {::ds/action :create-message
             ::ds/major-variable {::ds/major-variable-type ::ds/channel-id
                                  ::ds/major-variable-value &quot;286241942356885504&quot;}}]
           #(println %)
           (atom #:discljord.specs{:rate-limits #:discljord.specs{:endpoint-specific-rate-limits {}}, :channel (a/chan 100), :token &quot;TOKEN&quot;}))
</pre>
The println doesn&apos;t get called at all</z><z id="t1537722933" t="Joshua Suskalo (transform [:key {:doesnt-exist :blah}] #(do (println %) :blah) {:key {}}) here&apos;s a minimal example"><y>#</y><d>2018-09-23</d><h>17:15</h><w>Joshua Suskalo</w><pre>(transform [:key {:doesnt-exist :blah}] #(do (println %) :blah) {:key {}})
</pre>
here&apos;s a minimal example</z><z id="t1537722941" t="Joshua Suskalo so apparently I can&apos;t use a map as a key and have it work"><y>#</y><d>2018-09-23</d><h>17:15</h><w>Joshua Suskalo</w>so apparently I can&apos;t use a map as a key and have it work</z><z id="t1537723154" t="Joshua Suskalo user&gt; (select-first [{:blah :blah}] {{:blah :blah} :blah}) nil user&gt; (transform [{:blah :blah}] #(do (println %) :blah2) {{:blah :blah} :blah}) {{:blah :blah} :blah} Here&apos;s some more stuff from my repl session which shows a more minimal case of failure."><y>#</y><d>2018-09-23</d><h>17:19</h><w>Joshua Suskalo</w><pre>user&gt; (select-first [{:blah :blah}] {{:blah :blah} :blah})
nil
user&gt; (transform [{:blah :blah}] #(do (println %) :blah2) {{:blah :blah} :blah})
{{:blah :blah} :blah}
</pre>
Here&apos;s some more stuff from my repl session which shows a more minimal case of failure.</z><z id="t1537723395" t="schmee AFAIK using maps as paths doesn’t do anything"><y>#</y><d>2018-09-23</d><h>17:23</h><w>schmee</w>AFAIK using maps as paths doesn’t do anything</z><z id="t1537723496" t="Joshua Suskalo Yeah, that&apos;s the problem. I have need of using a map as a key, and if specter can&apos;t select or transform paths with maps, then I&apos;m kind of screwed."><y>#</y><d>2018-09-23</d><h>17:24</h><w>Joshua Suskalo</w>Yeah, that&apos;s the problem. I have need of using a map as a key, and if specter can&apos;t select or transform paths with maps, then I&apos;m kind of screwed.</z><z id="t1537723504" t="Joshua Suskalo And just have to go back to traditional data manipulation"><y>#</y><d>2018-09-23</d><h>17:25</h><w>Joshua Suskalo</w>And just have to go back to traditional data manipulation</z><z id="t1537724035" t="jsa-aerial Well, you could try sp/map-key which maybe will work - but you are still not screwed. But you will need to create a custom navigator : https://github.com/nathanmarz/specter/wiki/Cheat-Sheet#custom-navigators"><y>#</y><d>2018-09-23</d><h>17:33</h><w>jsa-aerial</w>Well, you could try sp/map-key which maybe will work - but you are still not screwed. But you will need to create a custom navigator : <a href="https://github.com/nathanmarz/specter/wiki/Cheat-Sheet#custom-navigators" target="_blank">https://github.com/nathanmarz/specter/wiki/Cheat-Sheet#custom-navigators</a></z><z id="t1537724047" t="jsa-aerial @suskeyhose ^^^"><y>#</y><d>2018-09-23</d><h>17:34</h><w>jsa-aerial</w>@suskeyhose ^^^</z><z id="t1537724089" t="Joshua Suskalo Okay, thanks. I&apos;ll take a look at it"><y>#</y><d>2018-09-23</d><h>17:34</h><w>Joshua Suskalo</w>Okay, thanks. I&apos;ll take a look at it</z><z id="t1537725595" t="nathanmarz @suskeyhose if you want to use a map as a key wrap it in keypath"><y>#</y><d>2018-09-23</d><h>17:59</h><w>nathanmarz</w>@suskeyhose if you want to use a map as a key wrap it in <code>keypath</code></z><z id="t1537725603" t="Joshua Suskalo oh, thanks!"><y>#</y><d>2018-09-23</d><h>18:00</h><w>Joshua Suskalo</w>oh, thanks!</z><z id="t1537725630" t="nathanmarz keypath is the navigator that&apos;s implicitly used by keywords in paths"><y>#</y><d>2018-09-23</d><h>18:00</h><w>nathanmarz</w><code>keypath</code> is the navigator that&apos;s implicitly used by keywords in paths</z><z id="t1537725665" t="Joshua Suskalo Ah, okay. Well that&apos;s exactly the behavior that I&apos;d wanted, so that&apos;s exactly it. Thanks so much!"><y>#</y><d>2018-09-23</d><h>18:01</h><w>Joshua Suskalo</w>Ah, okay. Well that&apos;s exactly the behavior that I&apos;d wanted, so that&apos;s exactly it. Thanks so much!</z><z id="t1537726498" t="schmee out of curiosity, is it possible to provide custom implicit navigators?"><y>#</y><d>2018-09-23</d><h>18:14</h><w>schmee</w>out of curiosity, is it possible to provide custom implicit navigators?</z><z id="t1537727891" t="nathanmarz @schmee yes, through the ImplicitNav protocol"><y>#</y><d>2018-09-23</d><h>18:38</h><w>nathanmarz</w>@schmee yes, through the <code>ImplicitNav</code> protocol</z><z id="t1537727919" t="nathanmarz see https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1188"><y>#</y><d>2018-09-23</d><h>18:38</h><w>nathanmarz</w>see <a href="https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1188" target="_blank">https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter.cljc#L1188</a></z><z id="t1537976325" t="Logan Powell 👋 new guy here. I hope my question is simple: I&apos;m looking for a way to map a function to a specific set of indices within a collection. For example: (transform [ALL MAP-VALS [1 3 5]] inc [0 1 2 3 4 5 6]) ;; wishful thinking =&gt; [0 2 2 4 4 6 6] is such a thing straight-forward in specter ?"><y>#</y><d>2018-09-26</d><h>15:38</h><w>Logan Powell</w><b>👋</b> new guy here. I hope my question is simple: I&apos;m looking for a way to map a function to a specific set of indices within a collection. For example:
<pre>(transform [ALL MAP-VALS [1 3 5]] inc [0 1 2 3 4 5 6])
;; wishful thinking =&gt; [0 2 2 4 4 6 6]
</pre>
is such a thing straight-forward in <code>specter</code>?</z><z id="t1537980627" t="drowsy @loganpowell something like (transform [INDEXED-VALS (selected? FIRST #{1 3 5}) LAST] inc [0 1 2 3 4 5 6]) works. Not sure if it&apos;s the best solution though."><y>#</y><d>2018-09-26</d><h>16:50</h><w>drowsy</w>@loganpowell something like <code>(transform [INDEXED-VALS (selected? FIRST #{1 3 5}) LAST] inc [0 1 2 3 4 5 6])</code> works. Not sure if it&apos;s the best solution though.</z><z id="t1537981601" t="Logan Powell @drowsy Thank you thank you"><y>#</y><d>2018-09-26</d><h>17:06</h><w>Logan Powell</w>@drowsy Thank you thank you</z><z id="t1537982764" t="Logan Powell works like a charm!"><y>#</y><d>2018-09-26</d><h>17:26</h><w>Logan Powell</w>works like a charm!</z><z id="t1537983558" t="schmee @loganpowell shorter and faster version: user=&gt; (transform (multi-path 1 3 5) inc [0 1 2 3 4 5 6]) [0 2 2 4 4 6 6] "><y>#</y><d>2018-09-26</d><h>17:39</h><w>schmee</w>@loganpowell shorter and faster version:
<pre>user=&gt; (transform (multi-path 1 3 5) inc [0 1 2 3 4 5 6])
[0 2 2 4 4 6 6]
</pre></z><z id="t1537983588" t="Logan Powell @schmee Boom! Thank you!"><y>#</y><d>2018-09-26</d><h>17:39</h><w>Logan Powell</w>@schmee Boom! Thank you!</z><z id="t1538015210" t="idiomancy is there a version of nil-&gt;val that also responds to :com.rpl.specter.impl/NONE ? The navigator I&apos;m building is &quot;if element 1is a hash-map, select that. if not, insert a hash-map between element 0 and element 1 and select that&quot;"><y>#</y><d>2018-09-27</d><h>02:26</h><w>idiomancy</w>is there a version of nil-&gt;val that also responds to <code>:com.rpl.specter.impl/NONE</code>?  The navigator I&apos;m building is &quot;if element 1is a hash-map, select that.  if not, insert a hash-map between element 0 and element 1 and select that&quot;</z><z id="t1538045947" t="nathanmarz @idiomancy that path can be expressed like: (transform (if-path [1 map?] 1 [(before-index 1) (view (constantly {}))] ) transform-fn data) "><y>#</y><d>2018-09-27</d><h>10:59</h><w>nathanmarz</w>@idiomancy that path can be expressed like:
<pre>(transform 
  (if-path [1 map?]
    1
    [(before-index 1) (view (constantly {}))]
    )
  transform-fn
  data)
</pre></z><z id="t1538046924" t="idiomancy holy crap that works."><y>#</y><d>2018-09-27</d><h>11:15</h><w>idiomancy</w>holy crap that works.</z><z id="t1538046947" t="idiomancy man, thats crazy, was landing on like 30 variations of that that didn&apos;t work"><y>#</y><d>2018-09-27</d><h>11:15</h><w>idiomancy</w>man, thats crazy,  was landing on like 30 variations of that that didn&apos;t work</z><z id="t1538431424" t="schmee I have two selects that only differ in the argument to must : (select [ALL ALL (selected? (must x))] board) , where x is :color and :robot"><y>#</y><d>2018-10-01</d><h>22:03</h><w>schmee</w>I have two selects that only differ in the argument to <code>must</code>: <code>(select [ALL ALL (selected? (must x))] board)</code>, where <code>x</code> is <code>:color</code> and <code>:robot</code></z><z id="t1538431477" t="schmee any way to combine the two into one or should I just do them separately?"><y>#</y><d>2018-10-01</d><h>22:04</h><w>schmee</w>any way to combine the two into one or should I just do them separately?</z><z id="t1538432113" t="tanzoniteblack if you want to do 1 call that returns both, you could probably do (selected? (multi-path (must :color) (must :robot))) ?"><y>#</y><d>2018-10-01</d><h>22:15</h><w>tanzoniteblack</w>if you want to do 1 call that returns both, you could probably do <code>(selected? (multi-path (must :color) (must :robot)))</code>?</z><z id="t1538432235" t="tanzoniteblack probably could also do (must (multi-path :color :robot)) ?"><y>#</y><d>2018-10-01</d><h>22:17</h><w>tanzoniteblack</w>probably could also do <code>(must (multi-path :color :robot))</code>?</z><z id="t1538432400" t="schmee oh sorry, I forgot to mention that I would like to get the results in two different arrays, sort of like this: user=&gt; (select [(multi-path (filterer odd?) (filterer even?))] (range 10)) [[1 3 5 7 9] [0 2 4 6 8]] "><y>#</y><d>2018-10-01</d><h>22:20</h><w>schmee</w>oh sorry, I forgot to mention that I would like to get the results in two different arrays, sort of like this:
<pre>user=&gt; (select [(multi-path (filterer odd?) (filterer even?))] (range 10))
[[1 3 5 7 9] [0 2 4 6 8]]
</pre></z><z id="t1538432549" t="schmee I have a vague recollection that I’ve asked this question before, and that the answer was no 😄"><y>#</y><d>2018-10-01</d><h>22:22</h><w>schmee</w>I have a vague recollection that I’ve asked this question before, and that the answer was no <b>😄</b></z><z id="t1538433415" t="nathanmarz @schmee yea, there&apos;s no way to do that"><y>#</y><d>2018-10-01</d><h>22:36</h><w>nathanmarz</w>@schmee yea, there&apos;s no way to do that</z><z id="t1538433456" t="nathanmarz besides doing (multi-path (subselect ...) (subselect ...)) , but that&apos;s no more efficient than just doing two select &apos;s"><y>#</y><d>2018-10-01</d><h>22:37</h><w>nathanmarz</w>besides doing <code>(multi-path (subselect ...) (subselect ...))</code>, but that&apos;s no more efficient than just doing two <code>select</code>&apos;s</z><z id="t1538433983" t="idiomancy hmm. can anyone think of a way to say &quot;every element after the first element&quot; without knowing the length of the sequence in advance? like a rest or drop 1 navigator?"><y>#</y><d>2018-10-01</d><h>22:46</h><w>idiomancy</w>hmm. can anyone think of a way to say &quot;every element after the first element&quot; without knowing the length of the sequence in advance?  like a <code>rest</code> or <code>drop 1</code> navigator?</z><z id="t1538434128" t="idiomancy hmm, maybe something with not-selected"><y>#</y><d>2018-10-01</d><h>22:48</h><w>idiomancy</w>hmm, maybe something with <code>not-selected</code></z><z id="t1538434632" t="nathanmarz @idiomancy you can do that with srange-dynamic or INDEXED-VALS"><y>#</y><d>2018-10-01</d><h>22:57</h><w>nathanmarz</w>@idiomancy you can do that with <code>srange-dynamic</code> or <code>INDEXED-VALS</code></z><z id="t1538434657" t="idiomancy gotcha, yeah that makes sense"><y>#</y><d>2018-10-01</d><h>22:57</h><w>idiomancy</w>gotcha, yeah that makes sense</z><z id="t1538434782" t="idiomancy so something like (def REST [(spr/srange-dynamic #(do 1) #(count %)) spr/ALL])"><y>#</y><d>2018-10-01</d><h>22:59</h><w>idiomancy</w>so something like <code>(def REST [(spr/srange-dynamic #(do 1) #(count %)) spr/ALL])</code></z><z id="t1538436473" t="nathanmarz @idiomancy yes"><y>#</y><d>2018-10-01</d><h>23:27</h><w>nathanmarz</w>@idiomancy yes</z><z id="t1538436517" t="nathanmarz actually (def REST (path (srange-dynamic #(do 1) count) ALL)) is better"><y>#</y><d>2018-10-01</d><h>23:28</h><w>nathanmarz</w>actually <code>(def REST (path (srange-dynamic #(do 1) count) ALL))</code> is better</z><z id="t1538436556" t="nathanmarz more efficient to use when constructing paths dynamically"><y>#</y><d>2018-10-01</d><h>23:29</h><w>nathanmarz</w>more efficient to use when constructing paths dynamically</z><z id="t1538436605" t="idiomancy huh, interesting! Thanks for the tip! So, what do you mean by &quot;dynamically&quot; here? Is there some way to construct them at compile time instead?"><y>#</y><d>2018-10-01</d><h>23:30</h><w>idiomancy</w>huh, interesting!  Thanks for the tip!  So, what do you mean by &quot;dynamically&quot; here?  Is there some way to construct them at compile time instead?</z><z id="t1538436729" t="idiomancy nvm, referring to the documentation now"><y>#</y><d>2018-10-01</d><h>23:32</h><w>idiomancy</w>nvm, referring to the documentation now</z><z id="t1538436737" t="idiomancy again, thanks!"><y>#</y><d>2018-10-01</d><h>23:32</h><w>idiomancy</w>again, thanks!</z><z id="t1538823480" t="kingcode I am trying to set values at different indexes within a flat vector in once call, e.g. [0 0 0 0] =&gt; [0 1 0 3]. I tried (setval [(nthpath 1)(nthpath 3)] [1 3] [0 0 0 0]) but got a runtime exc….What should I use instead? Thanks in advance.."><y>#</y><d>2018-10-06</d><h>10:58</h><w>kingcode</w>I am trying to set values at different indexes within a flat vector in once call, e.g. [0 0 0 0] =&gt; [0 1 0 3]. I tried
<code>(setval [(nthpath 1)(nthpath 3)] [1 3] [0 0 0 0])</code>
but got a runtime exc….What should I use instead?
Thanks in advance..</z><z id="t1538829743" t="nathanmarz @kingcode there&apos;s two approaches: (setval (subselect (multi-path 1 3)) [1 3] [0 0 0 0]) or (multi-transform (multi-path [1 (terminal-val 1)] [3 (terminal-val 3)]) [0 0 0 0]) "><y>#</y><d>2018-10-06</d><h>12:42</h><w>nathanmarz</w>@kingcode there&apos;s two approaches:
<pre>(setval (subselect (multi-path 1 3)) [1 3] [0 0 0 0])
</pre>
or
<pre>(multi-transform
  (multi-path
    [1 (terminal-val 1)]
    [3 (terminal-val 3)])
  [0 0 0 0])
</pre></z><z id="t1538829743" t="nathanmarz @kingcode there&apos;s two approaches: (setval (subselect (multi-path 1 3)) [1 3] [0 0 0 0]) or (multi-transform (multi-path [1 (terminal-val 1)] [3 (terminal-val 3)]) [0 0 0 0]) "><y>#</y><d>2018-10-06</d><h>12:42</h><w>nathanmarz</w>@kingcode there&apos;s two approaches:
<pre>(setval (subselect (multi-path 1 3)) [1 3] [0 0 0 0])
</pre>
or
<pre>(multi-transform
  (multi-path
    [1 (terminal-val 1)]
    [3 (terminal-val 3)])
  [0 0 0 0])
</pre></z><z id="t1539014607" t="manas_marthi Hi Nathan, if I have a vector of vectors with index &amp; new-values,or a vector of maps with index &amp; new-value pairs, then how do I rewrite the above. please advise.. thank you"><y>#</y><d>2018-10-08</d><h>16:03</h><r>manas_marthi</r>Hi Nathan, if I have a vector of vectors with index &amp; new-values,or a vector of maps with index &amp; new-value pairs, then how do I rewrite the above. please advise.. thank you</z><z id="t1539025991" t="nathanmarz do you have an example input/output of what you&apos;re trying to do?"><y>#</y><d>2018-10-08</d><h>19:13</h><r>nathanmarz</r>do you have an example input/output of what you&apos;re trying to do?</z><z id="t1539089080" t="manas_marthi I am thinking of this data input vec: [:a :b :c ... :m ... :z] A map of indices and new values { 2 :c2 12 :m2 25 :z2 } Or a map of old value new value pairs { :c :c2 :m :m2 :z :z2 } output vec: [:a :b :c2 ... :m2 ... :z2] "><y>#</y><d>2018-10-09</d><h>12:44</h><r>manas_marthi</r>I am thinking of this data
<pre>input vec: [:a  :b  :c ... :m ... :z]

A map of indices and new values
{
 2 :c2
 12 :m2
 25 :z2
}
Or a map of old value new value pairs
{
 :c :c2
 :m :m2
 :z :z2
}

output vec: [:a  :b  :c2 ... :m2 ... :z2] </pre></z><z id="t1539090336" t="manas_marthi Essentially how to deal with the scenario when I have a lot of values to be replaced and not just a handful of indices that can be hardcoded in the multipath selector expression.."><y>#</y><d>2018-10-09</d><h>13:05</h><r>manas_marthi</r>Essentially how to deal with the scenario when I have a lot of values to be replaced and not just a handful of indices that can be hardcoded in the multipath selector expression..</z><z id="t1539101201" t="nathanmarz for the latter you can do (transform [ALL #(contains? replacements %)] replacements data)"><y>#</y><d>2018-10-09</d><h>16:06</h><r>nathanmarz</r>for the latter you can do <code>(transform [ALL #(contains? replacements %)] replacements data)</code></z><z id="t1539101223" t="nathanmarz for the first I would just do that with a reduce"><y>#</y><d>2018-10-09</d><h>16:07</h><r>nathanmarz</r>for the first I would just do that with a <code>reduce</code></z><z id="t1539167572" t="manas_marthi Noted thank you"><y>#</y><d>2018-10-10</d><h>10:32</h><r>manas_marthi</r>Noted thank you</z><z id="t1538829762" t="nathanmarz the second is more efficient"><y>#</y><d>2018-10-06</d><h>12:42</h><w>nathanmarz</w>the second is more efficient</z><z id="t1538829768" t="kingcode Thank you @nathanmarz!"><y>#</y><d>2018-10-06</d><h>12:42</h><w>kingcode</w>Thank you @nathanmarz!</z><z id="t1538829799" t="kingcode Looking forward to learn and use more of this great library:)"><y>#</y><d>2018-10-06</d><h>12:43</h><w>kingcode</w>Looking forward to learn and use more of this great library:)</z><z id="t1539007626" t="darwin Hi, I&apos;m probably being bitten by https://github.com/nathanmarz/specter/commit/e7abb2b5384b0b64d871fb347be7c34a15473eb2 any ideas how to rewrite this to work around the issue? https://github.com/binaryage/dirac/blob/master/src/implant/dirac/implant/automation/reps.cljs#L46-L51"><y>#</y><d>2018-10-08</d><h>14:07</h><w>darwin</w>Hi, I&apos;m probably being bitten by <a href="https://github.com/nathanmarz/specter/commit/e7abb2b5384b0b64d871fb347be7c34a15473eb2" target="_blank">https://github.com/nathanmarz/specter/commit/e7abb2b5384b0b64d871fb347be7c34a15473eb2</a>
any ideas how to rewrite this to work around the issue?
<a href="https://github.com/binaryage/dirac/blob/master/src/implant/dirac/implant/automation/reps.cljs#L46-L51" target="_blank">https://github.com/binaryage/dirac/blob/master/src/implant/dirac/implant/automation/reps.cljs#L46-L51</a></z><z id="t1539008029" t="darwin confirmed, running with specter from master resolved the issue"><y>#</y><d>2018-10-08</d><h>14:13</h><w>darwin</w>confirmed, running with specter from master resolved the issue</z><z id="t1539616221" t="Logan Powell How might I pull the key/value pairs out of a map like this?"><y>#</y><d>2018-10-15</d><h>15:10</h><w>Logan Powell</w>How might I pull the key/value pairs out of a map like this?</z><z id="t1539617227" t="Logan Powell Is there some sort of &quot;lift&quot; functionality?"><y>#</y><d>2018-10-15</d><h>15:27</h><w>Logan Powell</w>Is there some sort of &quot;lift&quot; functionality?</z><z id="t1539617439" t="Logan Powell Figured it out!"><y>#</y><d>2018-10-15</d><h>15:30</h><w>Logan Powell</w>Figured it out!</z><z id="t1539617702" t="nathanmarz @loganpowell this is a more efficient and more concise way to express that subexpression: (into {} (traverse [:g MAP-VALS] mix-me-in))"><y>#</y><d>2018-10-15</d><h>15:35</h><w>nathanmarz</w>@loganpowell this is a more efficient and more concise way to express that subexpression: <code>(into {} (traverse [:g MAP-VALS] mix-me-in))</code></z><z id="t1539617780" t="Logan Powell Thank you @nathanmarz 🙏 and thank you for Specter! 😍"><y>#</y><d>2018-10-15</d><h>15:36</h><w>Logan Powell</w>Thank you @nathanmarz <b>🙏</b> and thank you for Specter! <b>😍</b></z><z id="t1539804686" t="Logan Powell 👋 I&apos;m assuming this isn&apos;t the most elegant solution, but I&apos;m trying to compose multiple specter functions together..."><y>#</y><d>2018-10-17</d><h>19:31</h><w>Logan Powell</w><b>👋</b> I&apos;m assuming this isn&apos;t the most elegant solution, but I&apos;m trying to compose multiple <code>specter</code> functions together...</z><z id="t1539804733" t="Logan Powell The reason for all the map manipulation is due to how go contexts rearrange PersistentArrayMap"><y>#</y><d>2018-10-17</d><h>19:32</h><w>Logan Powell</w>The reason for all the map manipulation is due to how <code>go</code> contexts rearrange <code>PersistentArrayMap</code></z><z id="t1539804772" t="Logan Powell btw, this works, but I was wondering if I&apos;m &quot;doing it wrong&quot;"><y>#</y><d>2018-10-17</d><h>19:32</h><w>Logan Powell</w>btw, this works, but I was wondering if I&apos;m &quot;doing it wrong&quot;</z><z id="t1539814383" t="nathanmarz @loganpowell would be more elegant with multi-transform"><y>#</y><d>2018-10-17</d><h>22:13</h><w>nathanmarz</w>@loganpowell would be more elegant with <code>multi-transform</code></z><z id="t1539814490" t="nathanmarz though I don&apos;t understand the point of the #(into {} %) part"><y>#</y><d>2018-10-17</d><h>22:14</h><w>nathanmarz</w>though I don&apos;t understand the point of the <code>#(into {} %)</code> part</z><z id="t1539814506" t="nathanmarz why use linked maps in the first place if you&apos;re just going to convert to a regular map?"><y>#</y><d>2018-10-17</d><h>22:15</h><w>nathanmarz</w>why use linked maps in the first place if you&apos;re just going to convert to a regular map?</z><z id="t1539814831" t="Logan Powell Thank you! I&apos;ll look into mult-transform. The map manipulation is a necessary evil in the black-magic of a go block"><y>#</y><d>2018-10-17</d><h>22:20</h><w>Logan Powell</w>Thank you! I&apos;ll look into mult-transform. The map manipulation is a necessary evil in the black-magic of a go block</z><z id="t1540556209" t="roklenarcic here&apos;s a simple transformation: I want to delete all map entries where value is empty string"><y>#</y><d>2018-10-26</d><h>12:16</h><w>roklenarcic</w>here&apos;s a simple transformation: I want to delete all map entries where value is empty string</z><z id="t1540556233" t="roklenarcic tried with compact and transform function that transforms &quot;&quot; values to nil"><y>#</y><d>2018-10-26</d><h>12:17</h><w>roklenarcic</w>tried with compact and transform function that transforms &quot;&quot; values to nil</z><z id="t1540556239" t="roklenarcic but that doesn&apos;t remove the key"><y>#</y><d>2018-10-26</d><h>12:17</h><w>roklenarcic</w>but that doesn&apos;t remove the key</z><z id="t1540556427" t="roklenarcic nvm figured it out: (setval [MAP-VALS (pred= &quot;&quot;)] NONE {:a &quot;&quot; :b 5})"><y>#</y><d>2018-10-26</d><h>12:20</h><w>roklenarcic</w>nvm figured it out: <code>(setval [MAP-VALS (pred= &quot;&quot;)] NONE {:a &quot;&quot; :b 5})</code></z><z id="t1540633712" t="fmn What is the efficient way to do reduction after some transformation? Currently I&apos;m doing it like this: (reduce merge {} (traverse (view to-map-fn) xs))"><y>#</y><d>2018-10-27</d><h>09:48</h><w>fmn</w>What is the efficient way to do reduction after some transformation?

Currently I&apos;m doing it like this: <code>(reduce merge {} (traverse (view to-map-fn) xs))</code></z><z id="t1540646531" t="nathanmarz @funyako.funyao156 traverse is efficient way to do reduction of a selection of subvalues"><y>#</y><d>2018-10-27</d><h>13:22</h><w>nathanmarz</w>@funyako.funyao156 <code>traverse</code> is efficient way to do reduction of a selection of subvalues</z><z id="t1540646567" t="nathanmarz that particular snippet doesn&apos;t really do anything, it&apos;s the same as (merge {} (to-map-fn xs))"><y>#</y><d>2018-10-27</d><h>13:22</h><w>nathanmarz</w>that particular snippet doesn&apos;t really do anything, it&apos;s the same as <code>(merge {} (to-map-fn xs))</code></z><z id="t1540653737" t="fmn @nathanmarz Thank you!"><y>#</y><d>2018-10-27</d><h>15:22</h><w>fmn</w>@nathanmarz Thank you!</z><z id="t1540884496" t="schmee is there a better way to construct this path? maybe something involving recursive-path ? (defn tag-path [&amp; tag-names] (apply concat (interpose [ALL] (map #(vector (selected? :tag (pred= %)) :value) tag-names)))) "><y>#</y><d>2018-10-30</d><h>07:28</h><w>schmee</w>is there a better way to construct this path? maybe something involving <code>recursive-path</code>?
<pre>(defn tag-path [&amp; tag-names]
  (apply
    concat
    (interpose
      [ALL]
      (map
        #(vector (selected? :tag (pred= %)) :value)
        tag-names))))
</pre></z><z id="t1540884611" t="schmee (tag-path &quot;EA&quot; &quot;C1&quot;) =&gt; [(selected? :tag (pred= &quot;EA&quot;)) :value ALL (selected? :tag (pred= &quot;C1&quot;)) :value] "><y>#</y><d>2018-10-30</d><h>07:30</h><w>schmee</w><pre>(tag-path &quot;EA&quot; &quot;C1&quot;) =&gt; [(selected? :tag (pred= &quot;EA&quot;)) :value ALL (selected? :tag (pred= &quot;C1&quot;)) :value]
</pre></z><z id="t1540904148" t="nathanmarz @schmee dynamic navs will dramatically increase performance when tag-path is called with dynamic params (eg. a local variable)"><y>#</y><d>2018-10-30</d><h>12:55</h><w>nathanmarz</w>@schmee dynamic navs will dramatically increase performance when <code>tag-path</code> is called with dynamic params (eg. a local variable)</z><z id="t1540904152" t="nathanmarz (defdynamicnav tag-path [&amp; tag-names] (let [late-pred= (late-resolved-fn pred=)] (apply concat (interpose [ALL] (map #(vector (selected? :tag (late-pred= %)) :value) tag-names) )))) "><y>#</y><d>2018-10-30</d><h>12:55</h><w>nathanmarz</w><pre>(defdynamicnav tag-path [&amp; tag-names]
  (let [late-pred= (late-resolved-fn pred=)]
    (apply
      concat
      (interpose
        [ALL]
        (map
          #(vector (selected? :tag (late-pred= %)) :value)
          tag-names)
          ))))
</pre></z><z id="t1540904211" t="nathanmarz things like this are where you get huge speedup: (defn f [a data] (select (tag-path a &quot;b&quot;) data) ) "><y>#</y><d>2018-10-30</d><h>12:56</h><w>nathanmarz</w>things like this are where you get huge speedup:
<pre>(defn f [a data]
  (select (tag-path a &quot;b&quot;) data)
  )
</pre></z><z id="t1540904295" t="schmee nice! I haven’t delved into dynamic navs yet, I’ll check them out!"><y>#</y><d>2018-10-30</d><h>12:58</h><w>schmee</w>nice! I haven’t delved into dynamic navs yet, I’ll check them out!</z><z id="t1540904311" t="schmee but would you say that is an OK way to write the tag-path function?"><y>#</y><d>2018-10-30</d><h>12:58</h><w>schmee</w>but would you say that is an OK way to write the <code>tag-path</code> function?</z><z id="t1540904332" t="schmee with all the interpose and apply and whatnot…"><y>#</y><d>2018-10-30</d><h>12:58</h><w>schmee</w>with all the interpose and apply and whatnot…</z><z id="t1540904339" t="nathanmarz not very much documentation on them, just this https://github.com/nathanmarz/specter/wiki/Specter%27s-inline-caching-implementation"><y>#</y><d>2018-10-30</d><h>12:58</h><w>nathanmarz</w>not very much documentation on them, just this <a href="https://github.com/nathanmarz/specter/wiki/Specter%27s-inline-caching-implementation" target="_blank">https://github.com/nathanmarz/specter/wiki/Specter%27s-inline-caching-implementation</a></z><z id="t1540904350" t="nathanmarz yes, it&apos;s fine"><y>#</y><d>2018-10-30</d><h>12:59</h><w>nathanmarz</w>yes, it&apos;s fine</z><z id="t1540904363" t="nathanmarz all that logic only ever executes once per callsite"><y>#</y><d>2018-10-30</d><h>12:59</h><w>nathanmarz</w>all that logic only ever executes once per callsite</z><z id="t1540904366" t="nathanmarz because of dynamicnav"><y>#</y><d>2018-10-30</d><h>12:59</h><w>nathanmarz</w>because of dynamicnav</z><z id="t1540904387" t="schmee excellent, thanks for the help as always"><y>#</y><d>2018-10-30</d><h>12:59</h><w>schmee</w>excellent, thanks for the help as always</z><z id="t1540904449" t="nathanmarz you&apos;ve now delved into the most advanced part of specter ;)"><y>#</y><d>2018-10-30</d><h>13:00</h><w>nathanmarz</w>you&apos;ve now delved into the most advanced part of specter ;)</z><z id="t1540904459" t="nathanmarz let me know if you have questions"><y>#</y><d>2018-10-30</d><h>13:00</h><w>nathanmarz</w>let me know if you have questions</z><z id="t1540904478" t="schmee will do!"><y>#</y><d>2018-10-30</d><h>13:01</h><w>schmee</w>will do!</z><z id="t1540935474" t="schmee is there any way to get access to collected values in view ?"><y>#</y><d>2018-10-30</d><h>21:37</h><w>schmee</w>is there any way to get access to collected values in <code>view</code>?</z><z id="t1540936939" t="nathanmarz @schmee no, but it&apos;s easy to make a custom navigator with that functionality"><y>#</y><d>2018-10-30</d><h>22:02</h><w>nathanmarz</w>@schmee no, but it&apos;s easy to make a custom navigator with that functionality</z><z id="t1540936943" t="nathanmarz see defrichnav"><y>#</y><d>2018-10-30</d><h>22:02</h><w>nathanmarz</w>see <code>defrichnav</code></z><z id="t1540939009" t="schmee 👍"><y>#</y><d>2018-10-30</d><h>22:36</h><w>schmee</w><b>👍</b></z><z id="t1540995537" t="npetryk Hey @nathanmarz, in a few of your blog posts you mention using specter for some pretty interesting graph stuff. I was interested in making specialized navigators for https://jsonapi.org/ and thought some examples of defining navigators for &quot;specialized&quot; domains might be helpful. Do you have any more information / examples about your graph implementation?"><y>#</y><d>2018-10-31</d><h>14:18</h><w>npetryk</w>Hey @nathanmarz, in a few of your blog posts you mention using specter for some pretty interesting graph stuff. I was interested in making specialized navigators for <a href="https://jsonapi.org/" target="_blank">https://jsonapi.org/</a> and thought some examples of defining navigators for &quot;specialized&quot; domains might be helpful. Do you have any more information / examples about your graph implementation?</z><z id="t1540995613" t="npetryk IDK if ur familiar with the spec but the most kludgey thing it requires me to do is to hold onto the top level document, or some kind of id -&gt; entity index, while I&apos;m navigating through the tree structure w/ specter"><y>#</y><d>2018-10-31</d><h>14:20</h><w>npetryk</w>IDK if ur familiar with the spec but the most kludgey thing it requires me to do is to hold onto the top level document, or some kind of id -&gt; entity index, while I&apos;m navigating through the tree structure w/ specter</z><z id="t1540995707" t="npetryk I&apos;m handling that by attaching metadata onto the things I&apos;m navigating into, but like I said, its a little kludgy"><y>#</y><d>2018-10-31</d><h>14:21</h><w>npetryk</w>I&apos;m handling that by attaching metadata onto the things I&apos;m navigating into, but like I said, its a little kludgy</z><z id="t1540996495" t="nathanmarz @npetryk my graph navigators are specifically for dag&apos;s"><y>#</y><d>2018-10-31</d><h>14:34</h><w>nathanmarz</w>@npetryk my graph navigators are specifically for dag&apos;s</z><z id="t1540996511" t="nathanmarz TOPSORT is like ALL but visits nodes in topological order"><y>#</y><d>2018-10-31</d><h>14:35</h><w>nathanmarz</w><code>TOPSORT</code> is like <code>ALL</code> but visits nodes in topological order</z><z id="t1541000519" t="jsa-aerial Wow. This looks to be exactly what I will be needing in rewriting a DAG transformer! Specter is awesome! 💯"><y>#</y><d>2018-10-31</d><h>15:41</h><r>jsa-aerial</r>Wow. This looks to be exactly what I will be needing in rewriting a DAG transformer! Specter is awesome! <b>💯</b></z><z id="t1540996546" t="nathanmarz REVERSE-TOPSORT is the same but opposite order"><y>#</y><d>2018-10-31</d><h>14:35</h><w>nathanmarz</w><code>REVERSE-TOPSORT</code> is the same but opposite order</z><z id="t1540996559" t="nathanmarz CHILDREN goes from node to all children"><y>#</y><d>2018-10-31</d><h>14:35</h><w>nathanmarz</w><code>CHILDREN</code> goes from node to all children</z><z id="t1540996567" t="nathanmarz likewise PARENTS , DESCENDANTS"><y>#</y><d>2018-10-31</d><h>14:36</h><w>nathanmarz</w>likewise <code>PARENTS</code>, <code>DESCENDANTS</code></z><z id="t1540996591" t="nathanmarz NODE goes from a pointer to a node (which the aforementioned ones navigate you to) to the value for that node"><y>#</y><d>2018-10-31</d><h>14:36</h><w>nathanmarz</w><code>NODE</code> goes from a pointer to a node (which the aforementioned ones navigate you to) to the value for that node</z><z id="t1540996616" t="nathanmarz node-nav navigates to a specific node"><y>#</y><d>2018-10-31</d><h>14:36</h><w>nathanmarz</w><code>node-nav</code> navigates to a specific node</z><z id="t1540996678" t="nathanmarz and then a couple navigators for navigating to sub-dag&apos;s, with metadata and ids on nodes used to determine how to attach the transformed sub-dag into the parent dag"><y>#</y><d>2018-10-31</d><h>14:37</h><w>nathanmarz</w>and then a couple navigators for navigating to sub-dag&apos;s, with metadata and ids on nodes used to determine how to attach the transformed sub-dag into the parent dag</z><z id="t1540996729" t="nathanmarz there&apos;s a few more but those are the main ones"><y>#</y><d>2018-10-31</d><h>14:38</h><w>nathanmarz</w>there&apos;s a few more but those are the main ones</z><z id="t1540996830" t="nathanmarz for navigating a tree you probably don&apos;t need custom navigator implementations, just a few composite navigators using recursive-path"><y>#</y><d>2018-10-31</d><h>14:40</h><w>nathanmarz</w>for navigating a tree you probably don&apos;t need custom navigator implementations, just a few composite navigators using <code>recursive-path</code></z><z id="t1540996835" t="nathanmarz if you have some examples I can walk you through it"><y>#</y><d>2018-10-31</d><h>14:40</h><w>nathanmarz</w>if you have some examples I can walk you through it</z><z id="t1540998612" t="npetryk Thanks! https://github.com/nathanmarz/specter/issues/241 also gave me some insight. It looks like that instead of passing [graph node-id] around I can just pass my tree &quot;context&quot; as metadata on individual nodes. The bit about reducing in the transform is also helpful for when I need to make updates to my tree"><y>#</y><d>2018-10-31</d><h>15:10</h><w>npetryk</w>Thanks! <a href="https://github.com/nathanmarz/specter/issues/241" target="_blank">https://github.com/nathanmarz/specter/issues/241</a> also gave me some insight. It looks like that instead of passing <code>[graph node-id]</code> around I can just pass my tree &quot;context&quot; as metadata on individual nodes. The bit about reducing in the transform is also helpful for when I need to make updates to my tree</z><z id="t1541062823" t="miikka FYI, I&apos;m getting &quot;Maximum call stack exceeded&quot; from specter&apos;s Subvec coerce-path implementation"><y>#</y><d>2018-11-01</d><h>09:00</h><w>miikka</w>FYI, I&apos;m getting &quot;Maximum call stack exceeded&quot; from specter&apos;s Subvec coerce-path implementation</z><z id="t1541062862" t="miikka Hmm, looking at the changelog, maybe I should try 1.1.2-SNAPSHOT"><y>#</y><d>2018-11-01</d><h>09:01</h><w>miikka</w>Hmm, looking at the changelog, maybe I should try 1.1.2-SNAPSHOT</z><z id="t1541063125" t="miikka Yeah that helps."><y>#</y><d>2018-11-01</d><h>09:05</h><w>miikka</w>Yeah that helps.</z><z id="t1541063679" t="miikka What&apos;s missing from the above is that the problem happened with latest ClojureScript master but not with the latest release (1.10.339)."><y>#</y><d>2018-11-01</d><h>09:14</h><w>miikka</w>What&apos;s missing from the above is that the problem happened with latest ClojureScript master but not with the latest release (1.10.339).</z><z id="t1541063828" t="miikka @nathanmarz Could you do a release soon with the subvec fix? So that I can easily update to the next ClojureScript release once it&apos;s out? 😎"><y>#</y><d>2018-11-01</d><h>09:17</h><w>miikka</w>@nathanmarz Could you do a release soon with the subvec fix? So that I can easily update to the next ClojureScript release once it&apos;s out? <b>😎</b></z><z id="t1541122915" t="nathanmarz ok, released 1.1.2 https://clojars.org/com.rpl/specter"><y>#</y><d>2018-11-02</d><h>01:41</h><w>nathanmarz</w>ok, released 1.1.2 <a href="https://clojars.org/com.rpl/specter" target="_blank">https://clojars.org/com.rpl/specter</a></z><z id="t1541142812" t="miikka thanks!"><y>#</y><d>2018-11-02</d><h>07:13</h><w>miikka</w>thanks!</z><z id="t1541577450" t="pepe Hello. With latest shadow-cljs and clojurescript I am getting theese warnings: ------ WARNING #1 -------------------------------------------------------------- File: com/rpl/specter.cljc:1275:19 -------------------------------------------------------------------------------- 1272 | ns (namespace structure)] 1273 | (cond (keyword? structure) (keyword ns new-name) 1274 | (symbol? structure) (symbol ns new-name) 1275 | :else (i/throw-illegal &quot;NAME can only be used on symbols or keywords - &quot; structure) -------------------------^------------------------------------------------------ Use of undeclared Var com.rpl.specter/java -------------------------------------------------------------------------------- 1276 | )))) 1277 | 1278 | (defnav ^{:doc &quot;Navigates to the namespace portion of the keyword or symbol&quot;} 1279 | NAMESPACE -------------------------------------------------------------------------------- ------ WARNING #2 -------------------------------------------------------------- File: com/rpl/specter.cljc:1288:19 -------------------------------------------------------------------------------- 1285 | new-ns (next-fn (namespace structure))] 1286 | (cond (keyword? structure) (keyword new-ns name) 1287 | (symbol? structure) (symbol new-ns name) 1288 | :else (i/throw-illegal &quot;NAMESPACE can only be used on symbols or keywords - &quot; structure) -------------------------^------------------------------------------------------ Use of undeclared Var com.rpl.specter/java -------------------------------------------------------------------------------- 1289 | )))) 1290 | 1291 | (defdynamicnav 1292 | ^{:doc &quot;Adds the result of running select with the given path on the -------------------------------------------------------------------------------- "><y>#</y><d>2018-11-07</d><h>07:57</h><w>pepe</w>Hello. With latest shadow-cljs and clojurescript I am getting theese warnings:
<pre>------ WARNING #1 --------------------------------------------------------------
 File: com/rpl/specter.cljc:1275:19
--------------------------------------------------------------------------------
1272 |           ns (namespace structure)]
1273 |       (cond (keyword? structure) (keyword ns new-name)
1274 |             (symbol? structure) (symbol ns new-name)
1275 |             :else (i/throw-illegal &quot;NAME can only be used on symbols or keywords - &quot; structure)
-------------------------^------------------------------------------------------
 Use of undeclared Var com.rpl.specter/java
--------------------------------------------------------------------------------
1276 |             ))))
1277 | 
1278 | (defnav ^{:doc &quot;Navigates to the namespace portion of the keyword or symbol&quot;}
1279 |   NAMESPACE
--------------------------------------------------------------------------------

------ WARNING #2 --------------------------------------------------------------
 File: com/rpl/specter.cljc:1288:19
--------------------------------------------------------------------------------
1285 |           new-ns (next-fn (namespace structure))]
1286 |       (cond (keyword? structure) (keyword new-ns name)
1287 |             (symbol? structure) (symbol new-ns name)
1288 |             :else (i/throw-illegal &quot;NAMESPACE can only be used on symbols or keywords - &quot; structure)
-------------------------^------------------------------------------------------
 Use of undeclared Var com.rpl.specter/java
--------------------------------------------------------------------------------
1289 |             ))))
1290 | 
1291 | (defdynamicnav
1292 |   ^{:doc &quot;Adds the result of running select with the given path on the
--------------------------------------------------------------------------------
</pre></z><z id="t1541577510" t="pepe I had some warnings about js in my project, so I think it is connected to the new type interence in latest clojurescript"><y>#</y><d>2018-11-07</d><h>07:58</h><w>pepe</w>I had some warnings about <code>js</code> in my project, so I think it is connected to the new type interence in latest clojurescript</z><z id="t1541597242" t="nathanmarz @pepe the cljs throw-illegal is: (defn throw-illegal [&amp; args] (throw (js/Error. (apply str args))))) "><y>#</y><d>2018-11-07</d><h>13:27</h><w>nathanmarz</w>@pepe the cljs <code>throw-illegal</code> is:
<pre>(defn throw-illegal [&amp; args]
     (throw (js/Error. (apply str args)))))
</pre></z><z id="t1541597262" t="nathanmarz there&apos;s no var named java in the specter source"><y>#</y><d>2018-11-07</d><h>13:27</h><w>nathanmarz</w>there&apos;s no var named <code>java</code> in the specter source</z><z id="t1541597264" t="nathanmarz sounds like a cljs issue"><y>#</y><d>2018-11-07</d><h>13:27</h><w>nathanmarz</w>sounds like a cljs issue</z><z id="t1541597750" t="pepe I was looking into the code also, and have not found anything. Thank you! I will try to investigate it."><y>#</y><d>2018-11-07</d><h>13:35</h><w>pepe</w>I was looking into the code also, and have not found anything. Thank you! I will try to investigate it.</z><z id="t1541689207" t="lxsli Hi, I have this: (transform [ALL] (fn [[k v]] [k (transform [ALL] (fn [[k1 v1]] [k1 (resolver-key k k1)]) v)]) rs)) With rs like: {:Entry {:foo _ :bar _} ...} I get my result: {:Entry {:foo :Entry-foo :bar :Entry-bar} ...}"><y>#</y><d>2018-11-08</d><h>15:00</h><w>lxsli</w>Hi, I have this:
<pre>(transform [ALL] (fn [[k v]] [k (transform [ALL] (fn [[k1 v1]] [k1 (resolver-key k k1)]) v)]) rs))</pre>

With rs like:
<pre>{:Entry {:foo _ :bar _} ...}</pre>

I get my result:
<pre>{:Entry {:foo :Entry-foo :bar :Entry-bar} ...}</pre></z><z id="t1541689259" t="lxsli It feels like if there was a way to use MAP-VALS but collect the key as I did so, that would be easier?"><y>#</y><d>2018-11-08</d><h>15:00</h><w>lxsli</w>It feels like if there was a way to use MAP-VALS but collect the key as I did so, that would be easier?</z><z id="t1541689492" t="nathanmarz @lxsi you want to use value collection for this: (def MAP-VALS-WITH-KEY (path ALL (collect-one FIRST) LAST)) (transform [MAP-VALS-WITH-KEY MAP-VALS-WITH-KEY] (fn [k1 k2 _] (resolver-key k1 k2)) data) "><y>#</y><d>2018-11-08</d><h>15:04</h><w>nathanmarz</w>@lxsi you want to use value collection for this:
<pre>(def MAP-VALS-WITH-KEY (path ALL (collect-one FIRST) LAST))
(transform [MAP-VALS-WITH-KEY MAP-VALS-WITH-KEY] (fn [k1 k2 _] (resolver-key k1 k2)) data)
</pre></z><z id="t1541689522" t="lxsli Sweet, thank you!"><y>#</y><d>2018-11-08</d><h>15:05</h><w>lxsli</w>Sweet, thank you!</z><z id="t1541770517" t="wilkerlucio @nathanmarz we can check by the output that its using the clj version, so its a fact that the JS out is using the CLJ version, macros sometimes are confusing on CLJS side, IME what works best is separate clj and cljs macros in different namespaces (both been .clj ) and conditionally import then, this usually works with the least surprises"><y>#</y><d>2018-11-09</d><h>13:35</h><w>wilkerlucio</w>@nathanmarz we can check by the output that its using the clj version, so its a fact that the JS out is using the CLJ version, macros sometimes are confusing on CLJS side, IME what works best is separate clj and cljs macros in different namespaces (both been <code>.clj</code>) and conditionally import then, this usually works with the least surprises</z><z id="t1541770548" t="wilkerlucio example code in pathom doing this: https://github.com/wilkerlucio/pathom/blob/master/src/com/wsscode/pathom/connect.cljc#L9-L12"><y>#</y><d>2018-11-09</d><h>13:35</h><w>wilkerlucio</w>example code in pathom doing this: <a href="https://github.com/wilkerlucio/pathom/blob/master/src/com/wsscode/pathom/connect.cljc#L9-L12" target="_blank">https://github.com/wilkerlucio/pathom/blob/master/src/com/wsscode/pathom/connect.cljc#L9-L12</a></z><z id="t1541786583" t="Logan Powell 👋 Hi everyone, can anyone tell me how to :require individual navigators? (e.g., MAP-KEYS )"><y>#</y><d>2018-11-09</d><h>18:03</h><w>Logan Powell</w><b>👋</b> Hi everyone, can anyone tell me how to <code>:require</code> individual navigators? (e.g., <code>MAP-KEYS</code>)</z><z id="t1541786594" t="Logan Powell in clojurescript"><y>#</y><d>2018-11-09</d><h>18:03</h><w>Logan Powell</w>in clojurescript</z><z id="t1541787738" t="Logan Powell It seems to work using (:require [com.rpl.specter :refer [MAP-VALS MAP-KEYS] :refer-macros [select transform traverse setval]]) but Intellij no likey, no big deal as long as I&apos;m not &quot;doing it wrong&quot; ™"><y>#</y><d>2018-11-09</d><h>18:22</h><w>Logan Powell</w>It seems to work using
<pre>(:require [com.rpl.specter   :refer [MAP-VALS MAP-KEYS]  :refer-macros [select transform traverse setval]])
</pre>
but Intellij no likey, no big deal as long as I&apos;m not &quot;doing it wrong&quot; <b>™</b></z><z id="t1541788039" t="jsa-aerial Are you doing this in Clojure or ClojureScript? If the former the :refer-macros does not make sense. If the latter (cljs), then this looks correct. In Clojure you can just refer the macros in the :refer vector."><y>#</y><d>2018-11-09</d><h>18:27</h><w>jsa-aerial</w>Are you doing this in Clojure or ClojureScript? If the former the :refer-macros does not make sense. If the latter (cljs), then this looks correct. In Clojure you can just refer the macros in the :refer vector.</z><z id="t1541788052" t="Logan Powell cljs, yes"><y>#</y><d>2018-11-09</d><h>18:27</h><w>Logan Powell</w>cljs, yes</z><z id="t1541788085" t="jsa-aerial Not sure how intellij (Cursive??) works with CLJS..."><y>#</y><d>2018-11-09</d><h>18:28</h><w>jsa-aerial</w>Not sure how intellij (Cursive??) works with CLJS...</z><z id="t1541788093" t="Logan Powell Cursive, yes"><y>#</y><d>2018-11-09</d><h>18:28</h><w>Logan Powell</w>Cursive, yes</z><z id="t1541788116" t="jsa-aerial I don&apos;t use Cursive, but in emacs I do that sort of thing all the time with no problems"><y>#</y><d>2018-11-09</d><h>18:28</h><w>jsa-aerial</w>I don&apos;t use Cursive, but in emacs I do that sort of thing all the time with no problems</z><z id="t1541788124" t="Logan Powell sweet"><y>#</y><d>2018-11-09</d><h>18:28</h><w>Logan Powell</w>sweet</z><z id="t1541788127" t="Logan Powell in cljs?"><y>#</y><d>2018-11-09</d><h>18:28</h><w>Logan Powell</w>in cljs?</z><z id="t1541788132" t="jsa-aerial Yes, in cljs"><y>#</y><d>2018-11-09</d><h>18:28</h><w>jsa-aerial</w>Yes, in cljs</z><z id="t1541788136" t="Logan Powell thank you sir"><y>#</y><d>2018-11-09</d><h>18:28</h><w>Logan Powell</w>thank you sir</z><z id="t1541788161" t="jsa-aerial So, it probably is some limitation / issue with Cursive and CLJS"><y>#</y><d>2018-11-09</d><h>18:29</h><w>jsa-aerial</w>So, it probably is some limitation / issue with Cursive and CLJS</z><z id="t1541788180" t="Logan Powell yep, no worries, as long as I&apos;m not doing it incorrectly 😉"><y>#</y><d>2018-11-09</d><h>18:29</h><w>Logan Powell</w>yep, no worries, as long as I&apos;m not doing it incorrectly <b>😉</b></z><z id="t1542452845" t="martinklepsch are there any known issues with specter and CLJS? Getting the following when running cljs.analyzer on the specter code: com/rpl/specter.cljc - root cause: clojure.lang.ExceptionInfo Unable to resolve var: coll? in this context at line 1449 specter/com/rpl/specter.cljc "><y>#</y><d>2018-11-17</d><h>11:07</h><w>martinklepsch</w>are there any known issues with specter and CLJS? Getting the following when running cljs.analyzer on the specter code:

<pre>com/rpl/specter.cljc - root cause: clojure.lang.ExceptionInfo Unable to resolve var: coll? in this context at line 1449 specter/com/rpl/specter.cljc
</pre></z><z id="t1542467458" t="nathanmarz @martinklepsch there&apos;s currently this issue but I think it&apos;s unrelated https://github.com/nathanmarz/specter/issues/267"><y>#</y><d>2018-11-17</d><h>15:10</h><w>nathanmarz</w>@martinklepsch there&apos;s currently this issue but I think it&apos;s unrelated <a href="https://github.com/nathanmarz/specter/issues/267" target="_blank">https://github.com/nathanmarz/specter/issues/267</a></z><z id="t1542470749" t="jsa-aerial @martinklepsch Is cljdoc on using cljs later than 1.10.238? That is the version I am using and that code works just fine. I just checked and the current release is 1.10.439(!!) The one I&apos;m using is only a few months old. Seems to be changing at a crazy rate. Let me see what happens if I try the newest version."><y>#</y><d>2018-11-17</d><h>16:05</h><w>jsa-aerial</w>@martinklepsch Is cljdoc on using cljs later than 1.10.238?  That is the version I am using and that code works just fine. I just checked and the current release is 1.10.439(!!) The one I&apos;m using is only a few months old. Seems to be changing at a crazy rate. Let me see what happens if I try the newest version.</z><z id="t1542471717" t="jsa-aerial @nathanmarz @martinklepsch OK, somewhere along the line in those 201 new releases something has changed and causes regressions. Using the latest cljs the code compiles ok (no errors / warning and signals successful completion) but fails immediately when trying to run it with this:"><y>#</y><d>2018-11-17</d><h>16:21</h><w>jsa-aerial</w>@nathanmarz @martinklepsch OK, somewhere along the line in those 201 new releases something has changed and causes regressions. Using the latest cljs the code compiles ok (no errors / warning and signals successful completion) but fails immediately when trying to run it with this:</z><z id="t1542471732" t="jsa-aerial #object[RangeError RangeError: Maximum call stack size exceeded] cljs.core/build-subvec (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:5908:25) cljs$core$IWithMeta$_with_meta$arity$2 (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:5793:28) cljs.core/-with-meta (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:686:21) cljs.core/with-meta (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:2059:8) cljs.core/vec (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:5662:6) com$rpl$specter$impl$CoercePath$coerce_path$arity$1 (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:180:27) com.rpl.specter.impl/coerce-path (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:155:17) com$rpl$specter$impl$CoercePath$coerce_path$arity$1 (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:180:14) com$rpl$specter$impl$coerce_path (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:155:17) aerial.hanami.core&gt; "><y>#</y><d>2018-11-17</d><h>16:22</h><w>jsa-aerial</w><pre>#object[RangeError RangeError: Maximum call stack size exceeded]
   cljs.core/build-subvec (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:5908:25)
   cljs$core$IWithMeta$_with_meta$arity$2 (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:5793:28)
   cljs.core/-with-meta (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:686:21)
   cljs.core/with-meta (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:2059:8)
   cljs.core/vec (jar:file:/home/jsa/.m2/repository/org/clojure/clojurescript/1.10.439/clojurescript-1.10.439.jar!/cljs/core.cljs:5662:6)
   com$rpl$specter$impl$CoercePath$coerce_path$arity$1 (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:180:27)
   com.rpl.specter.impl/coerce-path (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:155:17)
   com$rpl$specter$impl$CoercePath$coerce_path$arity$1 (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:180:14)
   com$rpl$specter$impl$coerce_path (jar:file:/home/jsa/.m2/repository/com/rpl/specter/1.1.1/specter-1.1.1.jar!/com/rpl/specter/impl.cljc:155:17)
aerial.hanami.core&gt; 
</pre></z><z id="t1542471842" t="jsa-aerial I think I will try a mini binary search to try to pin point in which release cljs was broken (or less likely, &apos;fixed&apos; something that was broken but causes regressions)"><y>#</y><d>2018-11-17</d><h>16:24</h><w>jsa-aerial</w>I think I will try a mini binary search to try to pin point in which release cljs was broken (or less likely, &apos;fixed&apos; something that was broken but causes regressions)</z><z id="t1542472497" t="jsa-aerial OK, didn&apos;t take long. Despite a couple hundred point increments, the releases go from 1.10.439 to 1.10.339 as a first jump. 1.10.339 works fine. So, 1.10.439 is what is broken. It has a very large number of differences across &apos;changes&apos;, &apos;enhancements&apos;, and &apos;fixes&apos;. So, it is not too surprising it went off the rails..."><y>#</y><d>2018-11-17</d><h>16:34</h><w>jsa-aerial</w>OK, didn&apos;t take long. Despite a couple hundred point increments, the releases go from 1.10.439 to 1.10.339 as a first jump. 1.10.339 works fine. So, 1.10.439 is what is broken. It has a very large number of differences across &apos;changes&apos;, &apos;enhancements&apos;, and &apos;fixes&apos;. So, it is not too surprising it went off the rails...</z><z id="t1542472915" t="jsa-aerial Just to finish, the actual releases go 1.10.238 -&gt; 1.10.312 (a lot of &apos;fixes&apos;) -&gt; 1.10.329 (a few &apos;fixes&apos;) -&gt; 1.10.339 (just a transit-clj version bump) -&gt; 1.10.439"><y>#</y><d>2018-11-17</d><h>16:41</h><w>jsa-aerial</w>Just to finish, the actual releases go 1.10.238 -&gt; 1.10.312 (a lot of &apos;fixes&apos;) -&gt; 1.10.329 (a few &apos;fixes&apos;) -&gt; 1.10.339 (just a transit-clj version bump) -&gt; 1.10.439</z><z id="t1542473054" t="jsa-aerial Likely &apos;goats&apos;/culprits: CLJS-2805: Bump tools.reader to 1.3.0 , Align ClojureScript AST to tools.analyzer , CLJS-2442: set and vec performance enhancements . Those last two definitely smell bad given where the problems here are manifesting..."><y>#</y><d>2018-11-17</d><h>16:44</h><w>jsa-aerial</w>Likely &apos;goats&apos;/culprits: <code>CLJS-2805: Bump tools.reader to 1.3.0</code>, <code>Align ClojureScript AST to tools.analyzer</code>, <code>CLJS-2442: set and vec performance enhancements</code>.  Those last two definitely smell bad given where the problems here are manifesting...</z><z id="t1542473245" t="martinklepsch @jsa-aerial that&apos;s very interesting, thanks for digging in"><y>#</y><d>2018-11-17</d><h>16:47</h><w>martinklepsch</w>@jsa-aerial that&apos;s very interesting, thanks for digging in</z><z id="t1542473435" t="martinklepsch I previously had another problem with the analyzer (turned out it was my fault) but I think if you could create a minimal repro how the analyzer fails with specter that would be very interesting to #cljs-dev"><y>#</y><d>2018-11-17</d><h>16:50</h><w>martinklepsch</w>I previously had another problem with the analyzer (turned out it was my fault) but I think if you could create a minimal repro how the analyzer fails with specter that would be very interesting to #cljs-dev</z><z id="t1542473445" t="martinklepsch https://gist.github.com/martinklepsch/9f885feb061ec3f03f365e22d0d9bf5b#old-description-ignore-this"><y>#</y><d>2018-11-17</d><h>16:50</h><w>martinklepsch</w><a href="https://gist.github.com/martinklepsch/9f885feb061ec3f03f365e22d0d9bf5b#old-description-ignore-this" target="_blank">https://gist.github.com/martinklepsch/9f885feb061ec3f03f365e22d0d9bf5b#old-description-ignore-this</a></z><z id="t1542473465" t="martinklepsch ☝️ you can take a look at this for how this could look"><y>#</y><d>2018-11-17</d><h>16:51</h><w>martinklepsch</w><b>☝️</b> you can take a look at this for how this could look</z><z id="t1542473527" t="martinklepsch the analyze-file call would need to be pointed at com/rpl/specter.cljc and you&apos;d need to add specter to the :deps map."><y>#</y><d>2018-11-17</d><h>16:52</h><w>martinklepsch</w>the analyze-file call would need to be pointed at <code>com/rpl/specter.cljc</code> and you&apos;d need to add specter to the <code>:deps</code> map.</z><z id="t1542473853" t="martinklepsch btw, I also get the coll? issue in 1.10.339"><y>#</y><d>2018-11-17</d><h>16:57</h><w>martinklepsch</w>btw, I also get the <code>coll?</code> issue in 1.10.339</z><z id="t1542474226" t="jsa-aerial @martinklepsch just to be clear - I do not get any analyzer problem in my code with any of those releases. So, I can&apos;t make that repo. So, if it is still happening with 1.10.339 I would suggest going back further to try to isolate that. For me, the error happens at runtime and since it occurs in vec , I would guess those &apos;enhancements&apos; to set and vec for performance are the problem."><y>#</y><d>2018-11-17</d><h>17:03</h><w>jsa-aerial</w>@martinklepsch just to be clear - I do not get any analyzer problem in my code with any of those releases. So, I can&apos;t make that repo. So, if it is still happening with 1.10.339 I would suggest going back further to try to isolate that. For me, the error happens at runtime and since it occurs in <code>vec</code>, I would guess those &apos;enhancements&apos; to <code>set</code> and <code>vec</code> for performance are the problem.</z><z id="t1542474369" t="jsa-aerial @martinklepsch one other thing of note: I have another repo (Saite) which uses Hanami (the one causing cljdoc bogus analyzer error) which sails through cljdoc just fine. So, maybe there is something wrong in the way cljdoc sets up the analyzer for this?"><y>#</y><d>2018-11-17</d><h>17:06</h><w>jsa-aerial</w>@martinklepsch one other thing of note: I have another repo (Saite) which uses Hanami (the one causing cljdoc bogus analyzer error) which sails through cljdoc just fine. So, maybe there is something wrong in the way cljdoc sets up the analyzer for this?</z><z id="t1542474439" t="jsa-aerial To be clear: Both of those use the specter lib in question, and both use it in exactly the same way."><y>#</y><d>2018-11-17</d><h>17:07</h><w>jsa-aerial</w>To be clear: Both of those use the specter lib in question, and both use it in exactly the same way.</z><z id="t1542494582" t="martinklepsch Interesting, can you provide dependency coordinates for both of these projects so I can compare? 🙂"><y>#</y><d>2018-11-17</d><h>22:43</h><w>martinklepsch</w>Interesting, can you provide dependency coordinates for both of these projects so I can compare? <b>🙂</b></z><z id="t1542566253" t="jsa-aerial Not sure what &apos;dependency coordinates&apos; means. Maybe the repo URLs?"><y>#</y><d>2018-11-18</d><h>18:37</h><r>jsa-aerial</r>Not sure what &apos;dependency coordinates&apos; means. Maybe the repo URLs?</z><z id="t1542566285" t="jsa-aerial https://github.com/jsa-aerial/hanami"><y>#</y><d>2018-11-18</d><h>18:38</h><r>jsa-aerial</r><a href="https://github.com/jsa-aerial/hanami" target="_blank">https://github.com/jsa-aerial/hanami</a></z><z id="t1542566311" t="jsa-aerial https://github.com/jsa-aerial/saite"><y>#</y><d>2018-11-18</d><h>18:38</h><r>jsa-aerial</r><a href="https://github.com/jsa-aerial/saite" target="_blank">https://github.com/jsa-aerial/saite</a></z><z id="t1543414897" t="Marc O&apos;Morain 👋 Hi there. I’m looking for a way to author a specter path that can select a string or vector of strings. My data looks like this: (emails for the postal library). (def m1 {:to [&quot; I want to collect all email addresses in the message, using specter/select"><y>#</y><d>2018-11-28</d><h>14:21</h><w>Marc O'Morain</w><b>👋</b>

Hi there. I’m looking for a way to author a specter path that can select a string or vector of strings.

My data looks like this: (emails for the <code>postal</code> library).

<pre>(def m1 {:to [&quot;</pre>

I want to collect all email addresses in the message, using <code>specter/select</code></z><z id="t1543415411" t="Marc O&apos;Morain I ended up with: (defn- has-recipients? &quot;True if this email has any recipients&quot; [message] (s/selected-any? [(s/multi-path :to :cc :bcc) (s/if-path sequential? s/ALL some?)] message)) "><y>#</y><d>2018-11-28</d><h>14:30</h><w>Marc O'Morain</w>I ended up with:

<pre>(defn- has-recipients?
  &quot;True if this email has any recipients&quot;
  [message]
  (s/selected-any? [(s/multi-path :to :cc :bcc)
                    (s/if-path sequential? s/ALL some?)]
                   message))
</pre></z><z id="t1543419881" t="nathanmarz @marc-omorain that&apos;s perfect"><y>#</y><d>2018-11-28</d><h>15:44</h><w>nathanmarz</w>@marc-omorain that&apos;s perfect</z><z id="t1543419915" t="Marc O&apos;Morain Thanks!"><y>#</y><d>2018-11-28</d><h>15:45</h><w>Marc O'Morain</w>Thanks!</z><z id="t1544788328" t="Timo Freiberg hey everyone, i&apos;m trying to use specter to build a tree-structure of nested maps and struggling with what kinds of values are allowed in the path in setval"><y>#</y><d>2018-12-14</d><h>11:52</h><w>Timo Freiberg</w>hey everyone, i&apos;m trying to use specter to build a tree-structure of nested maps and struggling with what kinds of values are allowed in the path in <code>setval</code></z><z id="t1544788419" t="Timo Freiberg my pre-specter implementation just uses (update-in tree [:field1 field1-val ...] (fnil conj #{}) key-of-entity)"><y>#</y><d>2018-12-14</d><h>11:53</h><w>Timo Freiberg</w>my pre-specter implementation just uses <code>(update-in tree [:field1 field1-val ...] (fnil conj #{}) key-of-entity)</code></z><z id="t1544788549" t="Timo Freiberg so in the end i get a big map like {:field1 {&quot;1&quot; {:field2 {nil {:field3 {&quot;B&quot; {..}}}}} &quot;2&quot; {:field2 {nil {:field3 {&quot;C&quot; {..}}}}}}} "><y>#</y><d>2018-12-14</d><h>11:55</h><w>Timo Freiberg</w>so in the end i get a big map like
<pre>{:field1 {&quot;1&quot; {:field2 {nil {:field3 {&quot;B&quot; {..}}}}}
          &quot;2&quot; {:field2 {nil {:field3 {&quot;C&quot; {..}}}}}}}
</pre></z><z id="t1544788606" t="Timo Freiberg my problem is that some values are nil and some values are hashmaps themselves. and specter doesn&apos;t seem to use nil and hashmaps in the path of setval"><y>#</y><d>2018-12-14</d><h>11:56</h><w>Timo Freiberg</w>my problem is that some values are <code>nil</code> and some values are hashmaps themselves. and specter doesn&apos;t seem to use <code>nil</code> and hashmaps in the path of <code>setval</code></z><z id="t1544788618" t="Timo Freiberg i already replaced nil with a :empty , that solved that problem"><y>#</y><d>2018-12-14</d><h>11:56</h><w>Timo Freiberg</w>i already replaced <code>nil</code> with a <code>:empty</code>, that solved that problem</z><z id="t1544788707" t="Timo Freiberg but i rely on the hashmap values for equality. my current plan for a workaround is represent that data as a sorted string and hope i can get a canonical representation working"><y>#</y><d>2018-12-14</d><h>11:58</h><w>Timo Freiberg</w>but i rely on the hashmap values for equality. my current plan for a workaround is represent that data as a sorted string and hope i can get a canonical representation working</z><z id="t1544788833" t="Timo Freiberg maybe someone can help me with this problem or confirm that specter doesn&apos;t use nil or hashmaps/hashsets as map keys in setval ?"><y>#</y><d>2018-12-14</d><h>12:00</h><w>Timo Freiberg</w>maybe someone can help me with this problem or confirm that specter doesn&apos;t use <code>nil</code> or hashmaps/hashsets as map keys in <code>setval</code>?</z><z id="t1544789049" t="Timo Freiberg example: (S/setval [:field1 &quot;1&quot; :field2 :empty :field3 &quot;A&quot; :field4 (S/multi-path :c #{:a :b} {:a #{:b :c}})] &quot;ID&quot; {}) ;; =&gt; {:field1 {&quot;1&quot; {:field2 {:empty {:field3 {&quot;A&quot; {:field4 {:c &quot;ID&quot;}}}}}}}} I&apos;d like for the paths #{:a :b} and {:a #{:b :c}} to also be created"><y>#</y><d>2018-12-14</d><h>12:04</h><w>Timo Freiberg</w>example:
<pre>(S/setval [:field1 &quot;1&quot;
           :field2 :empty
           :field3 &quot;A&quot;
           :field4 (S/multi-path
                    :c
                    #{:a :b}
                    {:a #{:b :c}})]
          &quot;ID&quot;
          {})
;; =&gt; {:field1 {&quot;1&quot; {:field2 {:empty {:field3 {&quot;A&quot; {:field4 {:c &quot;ID&quot;}}}}}}}}
</pre>

I&apos;d like for the paths <code>#{:a :b}</code> and <code>{:a #{:b :c}}</code> to also be created</z><z id="t1544801596" t="nathanmarz @timo.freiberg if you want to use a map as a key, wrap it in the keypath navigator"><y>#</y><d>2018-12-14</d><h>15:33</h><w>nathanmarz</w>@timo.freiberg if you want to use a map as a key, wrap it in the <code>keypath</code> navigator</z><z id="t1544801630" t="nathanmarz only basic types like keywords, strings, and numbers are automatically inferred use keypath navigation"><y>#</y><d>2018-12-14</d><h>15:33</h><w>nathanmarz</w>only basic types like keywords, strings, and numbers are automatically inferred use <code>keypath</code> navigation</z><z id="t1544801641" t="nathanmarz see this for a complete listing of navigators available to you: https://github.com/nathanmarz/specter/wiki/Cheat-Sheet"><y>#</y><d>2018-12-14</d><h>15:34</h><w>nathanmarz</w>see this for a complete listing of navigators available to you: <a href="https://github.com/nathanmarz/specter/wiki/Cheat-Sheet" target="_blank">https://github.com/nathanmarz/specter/wiki/Cheat-Sheet</a></z><z id="t1544803324" t="Timo Freiberg awesome, that did it"><y>#</y><d>2018-12-14</d><h>16:02</h><w>Timo Freiberg</w>awesome, that did it</z><z id="t1545057357" t="ro6 Today I found myself using assoc-in on the ex-data inside an exception while keeping the rest of the info the same, then re-forming and re-throwing. It definitely felt like a &quot;Specter-shaped&quot; problem. Is this the sort of thing Specter could do (or already does)? If so, what would be the approach to implementing a navigator for a closed data object like an IExceptionInfo ?"><y>#</y><d>2018-12-17</d><h>14:35</h><w>ro6</w>Today I found myself using <code>assoc-in</code> on the <code>ex-data</code> inside an exception while keeping the rest of the info the same, then re-forming and re-throwing. It definitely felt like a &quot;Specter-shaped&quot; problem. Is this the sort of thing Specter could do (or already does)? If so, what would be the approach to implementing a navigator for a closed data object like an <code>IExceptionInfo</code>?</z><z id="t1545057493" t="nathanmarz @robert.mather.rmm you can make customer navigators with defnav"><y>#</y><d>2018-12-17</d><h>14:38</h><w>nathanmarz</w>@robert.mather.rmm you can make customer navigators with <code>defnav</code></z><z id="t1545057538" t="nathanmarz though for that i think the best approach would be something like the new datafy stuff"><y>#</y><d>2018-12-17</d><h>14:38</h><w>nathanmarz</w>though for that i think the best approach would be something like the new datafy stuff</z><z id="t1545057569" t="nathanmarz where you can turn the closed object into regular clojure data, navigate it normally, and then at the end convert it back"><y>#</y><d>2018-12-17</d><h>14:39</h><w>nathanmarz</w>where you can turn the closed object into regular clojure data, navigate it normally, and then at the end convert it back</z><z id="t1545057623" t="nathanmarz so something like this would be ideal: (transform [DATAFY :some-field ALL] inc some-obj) , where DATAFY would do the conversion both ways"><y>#</y><d>2018-12-17</d><h>14:40</h><w>nathanmarz</w>so something like this would be ideal: <code>(transform [DATAFY :some-field ALL] inc some-obj)</code>, where <code>DATAFY</code> would do the conversion both ways</z><z id="t1545290109" t="puzzler Is there a protocol that &quot;goes the other way&quot; for datafy? I agree that&apos;s a good idea, if so."><y>#</y><d>2018-12-20</d><h>07:15</h><w>puzzler</w>Is there a protocol that &quot;goes the other way&quot; for datafy?  I agree that&apos;s a good idea, if so.</z><z id="t1545310377" t="nathanmarz @puzzler doesn&apos;t look like it, so it would have to be independently defined"><y>#</y><d>2018-12-20</d><h>12:52</h><w>nathanmarz</w>@puzzler doesn&apos;t look like it, so it would have to be independently defined</z><z id="t1545340632" t="aaelony If anyone is looking for a nasty data structure to play with Specter, I think I’ve found one here: “ https://pricing.us-east-1.amazonaws.com/offers/v1.0/aws/AmazonEC2/current/index.json ”"><y>#</y><d>2018-12-20</d><h>21:17</h><w>aaelony</w>If anyone is looking for a nasty data structure to play with Specter, I think I’ve found one here: “<a href="https://pricing.us-east-1.amazonaws.com/offers/v1.0/aws/AmazonEC2/current/index.json" target="_blank">https://pricing.us-east-1.amazonaws.com/offers/v1.0/aws/AmazonEC2/current/index.json</a>”</z><z id="t1545342230" t="idiomancy Alright so I have a hell of a difficult one and specter would be perfect for this... but it is a bear. so AWS&apos;s nosql, DynamoDB, stores records in this wonky schema&apos;d format. Heres an example. The key indicates how the record should be transformed. Essentially the leaf values are S and N, for strings and numbers respectively. I want to traverse recursively and replace the {:type-key val} with just the val. which involves crazy collection between recursed layers 😮"><y>#</y><d>2018-12-20</d><h>21:43</h><w>idiomancy</w>Alright so I have a hell of a difficult one and specter would be perfect for this... but it is a bear.

so AWS&apos;s nosql, DynamoDB, stores records in this wonky schema&apos;d format.

Heres an example.   The key indicates how the record should be transformed.  Essentially the leaf values are S and N, for strings and numbers respectively.
I want to traverse recursively and replace the {:type-key val} with just the val.  which involves crazy collection between recursed layers <b>😮</b></z><z id="t1545342246" t="idiomancy"><y>#</y><d>2018-12-20</d><h>21:44</h><w>idiomancy</w></z><z id="t1545342400" t="idiomancy is that even possible?"><y>#</y><d>2018-12-20</d><h>21:46</h><w>idiomancy</w>is that even possible?</z><z id="t1545344647" t="idiomancy I ended up just doing it with regular recursion"><y>#</y><d>2018-12-20</d><h>22:24</h><w>idiomancy</w>I ended up just doing it with regular recursion</z><z id="t1545344662" t="idiomancy it recursively called specter"><y>#</y><d>2018-12-20</d><h>22:24</h><w>idiomancy</w>it recursively called specter</z><z id="t1545350437" t="nathanmarz @idiomancy you could use walker"><y>#</y><d>2018-12-21</d><h>00:00</h><w>nathanmarz</w>@idiomancy you could use <code>walker</code></z><z id="t1545350459" t="nathanmarz (defn target? [o] (and (map? o) (= 1 (count o)) (#{:S :N} (-&gt; o first first)))) (transform (walker target?) #(-&gt; % last last) data) "><y>#</y><d>2018-12-21</d><h>00:00</h><w>nathanmarz</w><pre>(defn target? [o] (and (map? o) (= 1 (count o)) (#{:S :N} (-&gt; o first first))))
(transform (walker target?) #(-&gt; % last last) data)
</pre></z><z id="t1545350557" t="idiomancy hahaha, you bloody wizard you! let me try it out"><y>#</y><d>2018-12-21</d><h>00:02</h><w>idiomancy</w>hahaha, you bloody wizard you!  let me try it out</z><z id="t1545350723" t="nathanmarz using cond-path you could do it more precisely"><y>#</y><d>2018-12-21</d><h>00:05</h><w>nathanmarz</w>using <code>cond-path</code> you could do it more precisely</z><z id="t1545350727" t="nathanmarz definitely an annoying data format"><y>#</y><d>2018-12-21</d><h>00:05</h><w>nathanmarz</w>definitely an annoying data format</z><z id="t1545759070" t="nlessa Hi, I found an old discussion about defining a nav like this. But it seems something wrong with the GROUP-BY definition."><y>#</y><d>2018-12-25</d><h>17:31</h><w>nlessa</w>Hi, I found an old discussion about defining a nav like this. But it seems something wrong with the GROUP-BY definition.</z><z id="t1545759254" t="nlessa"><y>#</y><d>2018-12-25</d><h>17:34</h><w>nlessa</w></z><z id="t1545761757" t="nathanmarz @nlessa it hasn&apos;t been possible to compile path without parameters since 0.13.0"><y>#</y><d>2018-12-25</d><h>18:15</h><w>nathanmarz</w>@nlessa it hasn&apos;t been possible to compile path without parameters since 0.13.0</z><z id="t1545761790" t="nathanmarz now you would do (defn group-by-nav [f] (path (group-by-view f) ALL LAST)))"><y>#</y><d>2018-12-25</d><h>18:16</h><w>nathanmarz</w>now you would do <code>(defn group-by-nav [f] (path (group-by-view f) ALL LAST)))</code></z><z id="t1545761847" t="nlessa Hum, OK. thanks @nathanmarz!!"><y>#</y><d>2018-12-25</d><h>18:17</h><w>nlessa</w>Hum, OK. thanks @nathanmarz!!</z><z id="t1546291527" t="johanatan hi, is it possible to collect two levels of map keys in the process of navigating to a third level in a nested map ?"><y>#</y><d>2019-12-31</d><h>21:25</h><w>johanatan</w>hi, is it possible to <code>collect</code> two levels of map keys in the process of navigating to a third level in a nested map ?</z><z id="t1546291569" t="johanatan so, i have {:a {:b {:c :d}}} and i want to map /`transform` over {:c :d} but while retaining the context [:a :b] ."><y>#</y><d>2019-12-31</d><h>21:26</h><w>johanatan</w>so, i have <code>{:a {:b {:c :d}}}</code> and i want to <code>map</code>/`transform` over <code>{:c :d}</code> but while retaining the context <code>[:a :b]</code>.</z><z id="t1546291608" t="johanatan (specter/collect specter/MAP-KEYS specter/MAP-KEYS) gives the error &quot;Don&apos;t know how to create ISeq from clojure.lang.Keyword&quot;."><y>#</y><d>2019-12-31</d><h>21:26</h><w>johanatan</w><code>(specter/collect specter/MAP-KEYS specter/MAP-KEYS)</code> gives the error &quot;Don&apos;t know how to create ISeq from clojure.lang.Keyword&quot;.</z><z id="t1546291628" t="johanatan thanks in advance!"><y>#</y><d>2019-12-31</d><h>21:27</h><w>johanatan</w>thanks in advance!</z><z id="t1546378643" t="nathanmarz @johanatan just use multiple collect calls: (select [ALL (collect-one FIRST) LAST ALL (collect-one FIRST) LAST] {:a {:b {:c :d}}}) ;; =&gt; [[:a :b {:c :d}]] "><y>#</y><d>2019-01-01</d><h>21:37</h><w>nathanmarz</w>@johanatan just use multiple collect calls:
<pre>(select [ALL (collect-one FIRST) LAST ALL (collect-one FIRST) LAST] {:a {:b {:c :d}}})
;; =&gt; [[:a :b {:c :d}]]
</pre></z><z id="t1546378702" t="johanatan Ah, I guess I’m confused why you can’t use MAP-KEYS?"><y>#</y><d>2019-01-01</d><h>21:38</h><w>johanatan</w>Ah, I guess I’m confused why you can’t use MAP-KEYS?</z><z id="t1546378745" t="johanatan (For either the collection or the navigation)"><y>#</y><d>2019-01-01</d><h>21:39</h><w>johanatan</w>(For either the collection or the navigation)</z><z id="t1546380064" t="nathanmarz MAP-KEYS navigates you to each key of the map"><y>#</y><d>2019-01-01</d><h>22:01</h><w>nathanmarz</w><code>MAP-KEYS</code> navigates you to each key of the map</z><z id="t1546380077" t="nathanmarz so navigating MAP-KEYS again will navigate you to the keys of the keys"><y>#</y><d>2019-01-01</d><h>22:01</h><w>nathanmarz</w>so navigating <code>MAP-KEYS</code> again will navigate you to the keys of the keys</z><z id="t1546380096" t="nathanmarz since the first set of keys are keywords you get that error"><y>#</y><d>2019-01-01</d><h>22:01</h><w>nathanmarz</w>since the first set of keys are keywords you get that error</z><z id="t1546451253" t="johanatan Oh, I meant MAP-VALS instead of ALL/LAST in your example "><y>#</y><d>2019-01-02</d><h>17:47</h><w>johanatan</w>Oh, I meant MAP-VALS instead of ALL/LAST in your example </z><z id="t1546456711" t="nathanmarz @johanatan because it needs to collect the key"><y>#</y><d>2019-01-02</d><h>19:18</h><w>nathanmarz</w>@johanatan because it needs to collect the key</z><z id="t1546456963" t="johanatan Ah, got it. Thx "><y>#</y><d>2019-01-02</d><h>19:22</h><w>johanatan</w>Ah, got it. Thx </z><z id="t1546804993" t="zlrth i have some xml: &apos;({:tag :CategoryName_1, :attrs {}, :content (&quot;cats&quot;)} {:tag :CategoryId_1, :attrs {}, :content (&quot;cat260062&quot;)} {:tag :Items, :attrs {}, :content ({:tag :ItemId, :attrs {}, :content (&quot;1000388464506500&quot;)} {:tag :ItemId, :attrs {}, :content (&quot;1000388464506405&quot;)})}) that i&apos;d like to turn into into this map: {:CategoryName_1 &quot;cats&quot;, :CategoryId_1 &quot;cat260062&quot;, :Items [&quot;1000388464506500&quot; &quot;1000388464506405&quot;]} that is, for recursive :content s, i&apos;d like them collected into a vector, and for non-recursive, their tags and contents are key value pairs"><y>#</y><d>2019-01-06</d><h>20:03</h><w>zlrth</w>i have some xml:
<pre>&apos;({:tag :CategoryName_1, :attrs {}, :content (&quot;cats&quot;)}
  {:tag :CategoryId_1, :attrs {}, :content (&quot;cat260062&quot;)}
  {:tag :Items,
   :attrs {},
   :content
   ({:tag :ItemId, :attrs {}, :content (&quot;1000388464506500&quot;)}
    {:tag :ItemId, :attrs {}, :content (&quot;1000388464506405&quot;)})})
</pre>
that i&apos;d like to turn into into this map:
<pre>{:CategoryName_1 &quot;cats&quot;, :CategoryId_1 &quot;cat260062&quot;, :Items [&quot;1000388464506500&quot; &quot;1000388464506405&quot;]}
</pre>
that is, for recursive <code>:content</code>s, i&apos;d like them collected into a vector, and for non-recursive, their tags and contents are key value pairs</z><z id="t1546805085" t="zlrth the following works, but i&apos;m using glue code to compensate for my lack of specter experience: (let [top-level-tags [:CategoryName_1 :CategoryId_1] xml &apos;({:tag :CategoryName_1, :attrs {}, :content (&quot;cats&quot;)} {:tag :CategoryId_1, :attrs {}, :content (&quot;cat260062&quot;)} {:tag :Items, :attrs {}, :content ({:tag :ItemId, :attrs {}, :content (&quot;1000388464506500&quot;)} {:tag :ItemId, :attrs {}, :content (&quot;1000388464506405&quot;)})}) map-by-tags (group-by :tag xml) top-level (sp/transform [sp/MAP-VALS] (fn [v] (-&gt; v first :content first)) (select-keys map-by-tags top-level-tags)) Items (sp/select [:Items sp/ALL :content sp/ALL :content sp/FIRST] map-by-tags)] (merge top-level {:Items Items})) "><y>#</y><d>2019-01-06</d><h>20:04</h><w>zlrth</w>the following works, but i&apos;m using glue code to compensate for my lack of specter experience:
<pre>(let [top-level-tags [:CategoryName_1 :CategoryId_1]
      xml &apos;({:tag :CategoryName_1, :attrs {}, :content (&quot;cats&quot;)}
            {:tag :CategoryId_1, :attrs {}, :content (&quot;cat260062&quot;)}
            {:tag :Items,
             :attrs {},
             :content
             ({:tag :ItemId, :attrs {}, :content (&quot;1000388464506500&quot;)}
              {:tag :ItemId, :attrs {}, :content (&quot;1000388464506405&quot;)})})
      map-by-tags (group-by :tag xml)
      top-level (sp/transform
                  [sp/MAP-VALS]
                  (fn [v] (-&gt; v first :content first))
                  (select-keys map-by-tags top-level-tags))
      Items (sp/select
             [:Items sp/ALL :content sp/ALL :content sp/FIRST]
             map-by-tags)]
  (merge top-level {:Items Items}))
</pre></z><z id="t1546805295" t="zlrth i didn&apos;t find an example in the docs of &quot;collecting a deeper value and putting it upward&quot;, but that could be my user error. i would thank you very much for tips!"><y>#</y><d>2019-01-06</d><h>20:08</h><w>zlrth</w>i didn&apos;t find an example in the docs of &quot;collecting a deeper value and putting it upward&quot;, but that could be my user error. i would thank you very much for tips!</z><z id="t1546812127" t="zlrth ok i have something i&apos;m happier with via cond-path and collect . why is the third element of the :Items vector the complete {:tag :Items ... map?"><y>#</y><d>2019-01-06</d><h>22:02</h><w>zlrth</w>ok i have something i&apos;m happier with via <code>cond-path</code> and <code>collect</code>. why is the third element of the <code>:Items</code> vector the complete <code>{:tag :Items ...</code> map?</z><z id="t1546870633" t="nathanmarz @mfm you can do that like this: (def CONTENT-WALKER (recursive-path [] p [ALL (if-path map? [:content p] STAY )])) (into {} (select [ALL (collect-one :tag) :content (subselect CONTENT-WALKER) (if-path #(= 1 (count %)) FIRST STAY) ] data) ) "><y>#</y><d>2019-01-07</d><h>14:17</h><w>nathanmarz</w>@mfm you can do that like this:
<pre>(def CONTENT-WALKER
  (recursive-path [] p
    [ALL
     (if-path map?
       [:content p]
       STAY
       )]))

(into {}
  (select
    [ALL
     (collect-one :tag)
     :content
     (subselect CONTENT-WALKER)
     (if-path #(= 1 (count %)) FIRST STAY)
     ]
    data)
    )
</pre></z><z id="t1546870661" t="zlrth thank you!"><y>#</y><d>2019-01-07</d><h>14:17</h><w>zlrth</w>thank you!</z><z id="t1547120473" t="roklenarcic I&apos;m having problems expressing the following: I want to find an element in the vector, and edit that, but if it doesn&apos;t exist I want to add a default element to the vector"><y>#</y><d>2019-01-10</d><h>11:41</h><w>roklenarcic</w>I&apos;m having problems expressing the following: I want to find an element in the vector, and edit that, but if it doesn&apos;t exist I want to add a default element to the vector</z><z id="t1547135577" t="nathanmarz @roklenarcic you can do this: (multi-transform [(if-path [ALL (pred= :a)] [ALL (pred= :a) (terminal-val :c)] [AFTER-ELEM (terminal-val :DEFAULT)] )] [:b :a :b]) "><y>#</y><d>2019-01-10</d><h>15:52</h><w>nathanmarz</w>@roklenarcic you can do this:
<pre>(multi-transform
  [(if-path [ALL (pred= :a)]
     [ALL (pred= :a) (terminal-val :c)]
     [AFTER-ELEM (terminal-val :DEFAULT)]
     )]
  [:b :a :b])
</pre></z><z id="t1547135586" t="nathanmarz can probably do it more efficiently with a custom navigator"><y>#</y><d>2019-01-10</d><h>15:53</h><w>nathanmarz</w>can probably do it more efficiently with a custom navigator</z><z id="t1547505633" t="lexwin Wow @nathanmarz, I came here looking for exactly this answer."><y>#</y><d>2019-01-14</d><h>22:40</h><w>lexwin</w>Wow @nathanmarz, I came here looking for exactly this answer.</z><z id="t1547510368" t="souenzzo (select-one ALL [:a :b]) Execution error (IllegalArgumentException) at com.rpl.specter.impl/compiled-select-one*$result-fn (impl.cljc:375). More than one element found in structure: :b (select-one ALL [:a nil]) Execution error (IllegalArgumentException) at com.rpl.specter.impl/compiled-select-one*$result-fn (impl.cljc:375). More than one element found in structure: https://github.com/nathanmarz/specter/blob/7790213b163b07ef830fdbb1745fffcda61d40f6/src/clj/com/rpl/specter/impl.cljc#L379 Here should be (pr-str structure) to better error messages."><y>#</y><d>2019-01-14</d><h>23:59</h><w>souenzzo</w><pre>(select-one ALL [:a :b])

Execution error (IllegalArgumentException) at com.rpl.specter.impl/compiled-select-one*$result-fn (impl.cljc:375).
More than one element found in structure: :b
(select-one ALL [:a nil])

Execution error (IllegalArgumentException) at com.rpl.specter.impl/compiled-select-one*$result-fn (impl.cljc:375).
More than one element found in structure:
</pre>
<a href="https://github.com/nathanmarz/specter/blob/7790213b163b07ef830fdbb1745fffcda61d40f6/src/clj/com/rpl/specter/impl.cljc#L379" target="_blank">https://github.com/nathanmarz/specter/blob/7790213b163b07ef830fdbb1745fffcda61d40f6/src/clj/com/rpl/specter/impl.cljc#L379</a>
Here should be <code>(pr-str structure)</code> to better error messages.</z><z id="t1547511641" t="fmn How do you translate this vanilla clj function to a specter one? (defn web-server-config [config] (let [{:keys [port] :as config} (:web-server config) port (if (pos-int? port) port 8080)] (assoc config :port port))) I can easily got it working with this, but I&apos;m just wondering if there&apos;s a better way to do it with specter: (defn web-server-config [config] (-&gt;&gt; config (sp/transform [:web-server :port] #(if (pos-int? %) % 8080)) (sp/select-one [:web-server (sp/nil-&gt;val {})]))) "><y>#</y><d>2019-01-15</d><h>00:20</h><w>fmn</w>How do you translate this vanilla clj function to a specter one?

<pre>(defn web-server-config
  [config]
  (let [{:keys [port] :as config} (:web-server config)
        port                      (if (pos-int? port) port 8080)]
    (assoc config :port port)))
</pre>

I can easily got it working with this, but I&apos;m just wondering if there&apos;s a better way to do it with specter:

<pre>(defn web-server-config
  [config]
  (-&gt;&gt; config
       (sp/transform [:web-server :port] #(if (pos-int? %) % 8080))
       (sp/select-one [:web-server (sp/nil-&gt;val {})])))
</pre></z><z id="t1547529975" t="nathanmarz @funyako.funyao156 you can do it in one line like this: (select-any [:web-server (nil-&gt;val {}) (transformed [:port (complement pos-int?)] (fn [_] 8000)) ] config) "><y>#</y><d>2019-01-15</d><h>05:26</h><w>nathanmarz</w>@funyako.funyao156 you can do it in one line like this:
<pre>(select-any
  [:web-server
   (nil-&gt;val {})
   (transformed [:port (complement pos-int?)] (fn [_] 8000))
   ]
  config)
</pre></z><z id="t1547529979" t="nathanmarz not a big difference"><y>#</y><d>2019-01-15</d><h>05:26</h><w>nathanmarz</w>not a big difference</z><z id="t1547631099" t="fmn @nathanmarz thank you!"><y>#</y><d>2019-01-16</d><h>09:31</h><w>fmn</w>@nathanmarz thank you!</z><z id="t1548162865" t="phil Hey, all. In discovery phase and stuck on one already: given [[&quot;1&quot; &quot;2&quot;] [&quot;3&quot; &quot;4&quot;] [nil &quot;6&quot;]] , how would I get back 6? In other words find seq where the first value is nil and return the second value?"><y>#</y><d>2019-01-22</d><h>13:14</h><w>phil</w>Hey, all. In discovery phase and stuck on one already: given <code>[[&quot;1&quot; &quot;2&quot;] [&quot;3&quot; &quot;4&quot;] [nil &quot;6&quot;]]</code>, how would I get back 6? In other words find seq where the first value is <code>nil</code> and return the second value?</z><z id="t1548163234" t="schmee @phil here is one way to do it: user=&gt; a [[&quot;1&quot; &quot;2&quot;] [&quot;3&quot; &quot;4&quot;] [nil &quot;6&quot;]] user=&gt; (select-one [ALL (selected? FIRST (pred= nil)) 1] a) &quot;6&quot;"><y>#</y><d>2019-01-22</d><h>13:20</h><w>schmee</w>@phil here is one way to do it:
<pre>user=&gt; a
[[&quot;1&quot; &quot;2&quot;] [&quot;3&quot; &quot;4&quot;] [nil &quot;6&quot;]]

user=&gt; (select-one [ALL (selected? FIRST (pred= nil)) 1] a)
&quot;6&quot;</pre></z><z id="t1548163313" t="phil @schmee Thanks."><y>#</y><d>2019-01-22</d><h>13:21</h><w>phil</w>@schmee Thanks.</z><z id="t1548247804" t="phil Is moving stuff within a complex structure generally something you would do in one op or in a fetch, delete, insert treo?"><y>#</y><d>2019-01-23</d><h>12:50</h><w>phil</w>Is moving stuff within a complex structure generally something you would do in one op or in a fetch, delete, insert treo?</z><z id="t1548253110" t="nathanmarz @phil probably the latter, but depends on the use case"><y>#</y><d>2019-01-23</d><h>14:18</h><w>nathanmarz</w>@phil probably the latter, but depends on the use case</z><z id="t1548360785" t="okocim Question about updating a list of lists: If I have the following structure: [[?x :a/b ?y] [?y :b/c ?z] ;; I WANT TO NAVIGATE HERE FOR INSERTION [?z :d/e ?a]] where I want to insert: [[?z :x/y &quot;FOO&quot;] [?z :x/k &quot;BAR&quot;]] resulting in: [[?x :a/b ?y] [?y :b/c ?z] [?z :x/y &quot;FOO&quot;] [?z :x/k &quot;BAR&quot;] [?z :d/e ?a]] What is the path, and does that require transform? or replace-in? I’m trying to use [S/ALL (S/pred= &apos;[?y :b/c ?z]) S/AFTER-ELEM] for my path with a transform But that’s not working. I can’t assure the index of the insertion point will always be the same"><y>#</y><d>2019-01-24</d><h>20:13</h><w>okocim</w>Question about updating a list of lists:

If I have the following structure:
<pre>[[?x :a/b ?y]
 [?y :b/c ?z]
 ;; I WANT TO NAVIGATE HERE FOR INSERTION
 [?z :d/e ?a]]
</pre>
where I want to insert:
<pre>[[?z :x/y &quot;FOO&quot;]
 [?z :x/k &quot;BAR&quot;]]
</pre>

resulting in:
<pre>[[?x :a/b ?y]
 [?y :b/c ?z]
 [?z :x/y &quot;FOO&quot;]
 [?z :x/k &quot;BAR&quot;]
 [?z :d/e ?a]]
</pre>

What is the path, and does that require transform? or replace-in?
I’m trying to use

<pre>[S/ALL
 (S/pred= &apos;[?y :b/c ?z])
 S/AFTER-ELEM]
</pre>

for my path with a transform But that’s not working.
I can’t assure the  index of the insertion point will always be the same</z><z id="t1548362406" t="schmee @okocim here’s a kludgy two-step solution: user=&gt; a [[?x :a/b ?y] [?y :b/c ?z] [?z :d/e ?a]] user=&gt; b [[?z :x/y &quot;FOO&quot;] [?z :x/k &quot;BAR&quot;]] user=&gt; (def i (select-one [INDEXED-VALS (selected? LAST (pred= &apos;[?y :b/c ?z])) FIRST] a)) #&apos;user/i user=&gt; (setval [(srange i (inc i)) END] b a) [[?x :a/b ?y] [?y :b/c ?z] [?z :x/y &quot;FOO&quot;] [?z :x/k &quot;BAR&quot;] [?z :d/e ?a]]"><y>#</y><d>2019-01-24</d><h>20:40</h><w>schmee</w>@okocim here’s a kludgy two-step solution:
<pre>user=&gt; a
[[?x :a/b ?y] [?y :b/c ?z] [?z :d/e ?a]]

user=&gt; b
[[?z :x/y &quot;FOO&quot;] [?z :x/k &quot;BAR&quot;]]

user=&gt; (def i (select-one [INDEXED-VALS (selected? LAST (pred= &apos;[?y :b/c ?z])) FIRST] a))
#&apos;user/i

user=&gt; (setval [(srange i (inc i)) END] b a)
[[?x :a/b ?y]
 [?y :b/c ?z]
 [?z :x/y &quot;FOO&quot;]
 [?z :x/k &quot;BAR&quot;]
 [?z :d/e ?a]]</pre></z><z id="t1548362548" t="okocim Thanks, I’ll take it for now. It is a bit fumbly, but I think I can cordon that off until I can come up with something better"><y>#</y><d>2019-01-24</d><h>20:42</h><w>okocim</w>Thanks, I’ll take it for now. It is a bit fumbly, but I think I can cordon that off until I can come up with something better</z><z id="t1548363424" t="schmee If you find something cleaner post it here!"><y>#</y><d>2019-01-24</d><h>20:57</h><w>schmee</w>If you find something cleaner post it here!</z><z id="t1548363488" t="okocim I will. I was headed down the path of doing the two steps (find the index and splice-in) when you posted this, so thank you. I will be happy to return the favor if I can."><y>#</y><d>2019-01-24</d><h>20:58</h><w>okocim</w>I will. I was headed down the path of doing the two steps (find the index and splice-in) when you posted this, so thank you.  I will be happy to return the favor if I can.</z><z id="t1548411518" t="twashing I have a set of nested records. In my structure, I want to STAY on the i. the value nodes with :bar keys, that are ii. not seqable? and iii. not of type myns.Foo. But I can’t seem to get the recursive navigator correctly. Any ideas here? (def a #myns.Foo{:bar #myns.Foo{:bar (#myns.Foo{:bar :a :x 1 :y 2} :b :c :d)}}) (def b (recursive-path [] p (cond-path seqable? [ALL p] [:matcher (comp clojure.core/not parser-combinator?)] (continue-then-stay ALL p) [:matcher (comp clojure.core/not seqable?)] [ALL p]))) (select b a) "><y>#</y><d>2019-01-25</d><h>10:18</h><w>twashing</w>I have a set of nested records.

In my structure, I want to STAY on the i. the value nodes with :bar keys, that are ii. not seqable? and iii. not of type myns.Foo.

But I can’t seem to get the recursive navigator correctly. Any ideas here?

<pre>(def a #myns.Foo{:bar #myns.Foo{:bar (#myns.Foo{:bar :a :x 1 :y 2} :b :c :d)}})

(def b (recursive-path
         [] p
         (cond-path
           seqable? [ALL p]
           [:matcher (comp clojure.core/not parser-combinator?)] (continue-then-stay ALL p)
           [:matcher (comp clojure.core/not seqable?)] [ALL p])))

(select b a)
</pre></z><z id="t1548429836" t="nathanmarz @twashing it would be more clear if you showed desired input and output"><y>#</y><d>2019-01-25</d><h>15:23</h><w>nathanmarz</w>@twashing it would be more clear if you showed desired input and output</z><z id="t1548452635" t="twashing Hey @nathanmarz, absolutely. So I’m trying to find the recursive-path that gives me the output in *B, given the input from A*."><y>#</y><d>2019-01-25</d><h>21:43</h><w>twashing</w>Hey @nathanmarz, absolutely. So I’m trying to find the <code>recursive-path</code> that gives me the output in *B, given the input from A*.</z><z id="t1548452636" t="twashing ;; A input structure (defrecord Foo [bar]) (def a #user.Foo{:bar #user.Foo{:bar &apos;(#user.Foo{:bar :a :x 1 :y 2} :b :c :d)}}) ;; B output :a ;; (the i. the value nodes with :bar keys, that are ii. not seqable? and iii. not of type myns.Foo) "><y>#</y><d>2019-01-25</d><h>21:43</h><w>twashing</w><pre>;; A input structure
(defrecord Foo [bar])
(def a #user.Foo{:bar #user.Foo{:bar &apos;(#user.Foo{:bar :a :x 1 :y 2} :b :c :d)}})

;; B output 
:a ;; (the i. the value nodes with :bar keys, that are ii. not seqable? and iii. not of type myns.Foo)
</pre></z><z id="t1548455437" t="nathanmarz @twashing is this what you&apos;re looking for? (def MY-WALKER (recursive-path [] p (cond-path #(instance? Foo %) [:bar p] seqable? [ALL #(instance? Foo %) p] STAY STAY ))) "><y>#</y><d>2019-01-25</d><h>22:30</h><w>nathanmarz</w>@twashing is this what you&apos;re looking for?
<pre>(def MY-WALKER
  (recursive-path [] p
    (cond-path
      #(instance? Foo %) [:bar p]
      seqable? [ALL #(instance? Foo %) p]
      STAY STAY
      )))
</pre></z><z id="t1548455919" t="twashing @nathanmarz Hmm, if I put this into my repl, I get an empty result set."><y>#</y><d>2019-01-25</d><h>22:38</h><w>twashing</w>@nathanmarz Hmm, if I put this into my repl, I get an empty result set.</z><z id="t1548455948" t="twashing (use &apos;com.rpl.specter) (defrecord Foo [bar]) (def a #user.Foo{:bar #user.Foo{:bar &apos;(#user.Foo{:bar :a :x 1 :y 2} :b :c :d)}}) (def MY-WALKER (recursive-path [] p (cond-path #(instance? Foo %) [:bar p] seqable? [ALL #(instance? Foo %) p] STAY STAY))) (select MY-WALKER a) ;; [] - empty result set returned "><y>#</y><d>2019-01-25</d><h>22:39</h><w>twashing</w><pre>(use &apos;com.rpl.specter)

(defrecord Foo [bar])

(def a #user.Foo{:bar #user.Foo{:bar &apos;(#user.Foo{:bar :a :x 1 :y 2} :b :c :d)}})

(def MY-WALKER
  (recursive-path [] p
    (cond-path
      #(instance? Foo %) [:bar p]
      seqable? [ALL #(instance? Foo %) p]
      STAY STAY)))

(select MY-WALKER a)

;; [] - empty result set returned
</pre></z><z id="t1548455959" t="twashing It’s a tricky one."><y>#</y><d>2019-01-25</d><h>22:39</h><w>twashing</w>It’s a tricky one.</z><z id="t1548457236" t="nathanmarz @twashing probably because you meant to do (def a #user.Foo{:bar #user.Foo{:bar (#user.Foo{:bar :a :x 1 :y 2} :b :c :d)}}) ?"><y>#</y><d>2019-01-25</d><h>23:00</h><w>nathanmarz</w>@twashing probably because you meant to do <code>(def a #user.Foo{:bar #user.Foo{:bar (#user.Foo{:bar :a :x 1 :y 2} :b :c :d)}})</code> ?</z><z id="t1548457586" t="twashing Ah ok."><y>#</y><d>2019-01-25</d><h>23:06</h><w>twashing</w>Ah ok.</z><z id="t1548457611" t="twashing Didn’t realise the reader macro stopped the list from being eval’d… Cool."><y>#</y><d>2019-01-25</d><h>23:06</h><w>twashing</w>Didn’t realise the reader macro stopped the list from being eval’d… Cool.</z><z id="t1548457767" t="twashing Cheers mate. I think I have a better understanding of the semantics of if-path and cond-path ."><y>#</y><d>2019-01-25</d><h>23:09</h><w>twashing</w>Cheers mate. I think I have a better understanding of the semantics of <code>if-path</code> and <code>cond-path</code>.</z><z id="t1548457859" t="twashing Although STAY STAY (to capture the leaves) is still a bit foggy.. used as both a predicate and navigator."><y>#</y><d>2019-01-25</d><h>23:10</h><w>twashing</w>Although <code>STAY STAY</code> (to capture the leaves) is still a bit foggy.. used as both a predicate and navigator.</z><z id="t1548457872" t="twashing Thanks for a great library!"><y>#</y><d>2019-01-25</d><h>23:11</h><w>twashing</w>Thanks for a great library!</z><z id="t1548459275" t="nathanmarz @twashing An if-path /`cond-path` condition is &quot;true&quot; if it navigates to at least one value"><y>#</y><d>2019-01-25</d><h>23:34</h><w>nathanmarz</w>@twashing An <code>if-path</code>/`cond-path` condition is &quot;true&quot; if it navigates to at least one value</z><z id="t1548459283" t="nathanmarz so STAY is the navigation equivalent of true"><y>#</y><d>2019-01-25</d><h>23:34</h><w>nathanmarz</w>so <code>STAY</code> is the navigation equivalent of <code>true</code></z><z id="t1548459365" t="twashing Gotcha 👍 :skin-tone-5:"><y>#</y><d>2019-01-25</d><h>23:36</h><w>twashing</w>Gotcha <b>👍</b><b>:skin-tone-5:</b></z><z id="t1548906162" t="steveb8n I’m having trouble with a recursive requirement. Here’s the example: (-&gt;&gt; {:gender :male :type :person :name &quot;Luke&quot; :mother {:gender :female :type :person :name &quot;Padme&quot;} :friends [{:gender :male :type :person :name &quot;Han&quot;} {:gender :male :type :person :name &quot;Chewbacca&quot;}] :mentors {:type :group :people [{:gender :male :type :person :name &quot;Obiwan&quot;} {:gender :male :type :person :name &quot;Yoda&quot;}]}} (select [(recursive-path [] p (if-path (fn [v] (and (map? v) (:gender v))) (continue-then-stay (multi-path [(must :friends) ALL] [MAP-VALS #(:gender %)]) p)))])) =&gt; [{:gender :male, :type :person, :name &quot;Han&quot;} {:gender :male, :type :person, :name &quot;Chewbacca&quot;} {:gender :female, :type :person, :name &quot;Padme&quot;} {:gender :male, :type :person, :name &quot;Luke&quot;, :mother {:gender :female, :type :person, :name &quot;Padme&quot;}, :friends [{:gender :male, :type :person, :name &quot;Han&quot;} {:gender :male, :type :person, :name &quot;Chewbacca&quot;}], :mentors {:type :group, :people [{:gender :male, :type :person, :name &quot;Obiwan&quot;} {:gender :male, :type :person, :name &quot;Yoda&quot;}]}}] How can I get it to also return the mentors? They are :persons as well"><y>#</y><d>2019-01-31</d><h>03:42</h><w>steveb8n</w>I’m having trouble with a recursive requirement. Here’s the example:
<pre>(-&gt;&gt; {:gender :male
        :type    :person
        :name    &quot;Luke&quot;
        :mother  {:gender :female
                  :type :person
                  :name &quot;Padme&quot;}
        :friends [{:gender :male
                   :type :person
                   :name &quot;Han&quot;}
                  {:gender :male
                   :type :person
                   :name &quot;Chewbacca&quot;}]
        :mentors {:type   :group
                  :people [{:gender :male
                            :type :person
                            :name &quot;Obiwan&quot;}
                           {:gender :male
                            :type :person
                            :name &quot;Yoda&quot;}]}}
       (select [(recursive-path [] p
                                (if-path (fn [v] (and (map? v) (:gender v)))
                                         (continue-then-stay (multi-path [(must :friends) ALL]
                                                                         [MAP-VALS #(:gender %)])
                                                             p)))]))
</pre>
=&gt;
<pre>[{:gender :male, :type :person, :name &quot;Han&quot;}
 {:gender :male, :type :person, :name &quot;Chewbacca&quot;}
 {:gender :female, :type :person, :name &quot;Padme&quot;}
 {:gender :male,
  :type :person,
  :name &quot;Luke&quot;,
  :mother {:gender :female, :type :person, :name &quot;Padme&quot;},
  :friends [{:gender :male, :type :person, :name &quot;Han&quot;} {:gender :male, :type :person, :name &quot;Chewbacca&quot;}],
  :mentors {:type :group,
            :people [{:gender :male, :type :person, :name &quot;Obiwan&quot;} {:gender :male, :type :person, :name &quot;Yoda&quot;}]}}]
</pre>

How can I get it to also return the mentors? They are :persons as well</z><z id="t1548906362" t="steveb8n multi-path only seems to support 2 variations. I guess another way of asking this is how can I combine the selections of 3 paths into 1?"><y>#</y><d>2019-01-31</d><h>03:46</h><w>steveb8n</w>multi-path only seems to support 2 variations. I guess another way of asking this is how can I combine the selections of 3 paths into 1?</z><z id="t1548914227" t="steveb8n One way would be to use a clojure.walk to extract all :person maps and wrap that in a specter nav (maybe view). I can’t use specter/walker because it stops on matches in each branch so it would only return 1 mentor. ideally I’d like some specter native nav composition but can’t see how."><y>#</y><d>2019-01-31</d><h>05:57</h><w>steveb8n</w>One way would be to use a clojure.walk to extract all :person maps and wrap that in a specter nav (maybe view). I can’t use specter/walker because it stops on matches in each branch so it would only return 1 mentor. ideally I’d like some specter native nav composition but can’t see how.</z><z id="t1548920080" t="nathanmarz @steveb8n I think you&apos;re looking for: (def PEOPLE (recursive-path [] p (continue-then-stay (multi-path (must :mother) (must :father) [(must :friends) ALL] [(must :mentors) :people ALL] ) p ))) "><y>#</y><d>2019-01-31</d><h>07:34</h><w>nathanmarz</w>@steveb8n I think you&apos;re looking for:
<pre>(def PEOPLE
  (recursive-path [] p
    (continue-then-stay
      (multi-path
        (must :mother)
        (must :father)
        [(must :friends) ALL]
        [(must :mentors) :people ALL]
        )
      p
      )))
</pre></z><z id="t1548920110" t="steveb8n thanks. let me try that"><y>#</y><d>2019-01-31</d><h>07:35</h><r>steveb8n</r>thanks. let me try that</z><z id="t1548920216" t="steveb8n awesome. works like a charm."><y>#</y><d>2019-01-31</d><h>07:36</h><r>steveb8n</r>awesome. works like a charm.</z><z id="t1550297424" t="vigilancetech any idea why I&apos;d be getting this? ------ WARNING #1 -------------------------------------------------------------- File: com/rpl/specter.cljc:1275:19 -------------------------------------------------------------------------------- 1272 | ns (namespace structure)] 1273 | (cond (keyword? structure) (keyword ns new-name) 1274 | (symbol? structure) (symbol ns new-name) 1275 | :else (i/throw-illegal &quot;NAME can only be used on symbols or keywords - &quot; st ructure) -------------------------^------------------------------------------------------ Use of undeclared Var com.rpl.specter/java -------------------------------------------------------------------------------- 1276 | )))) 1277 | 1278 | (defnav ^{:doc &quot;Navigates to the namespace portion of the keyword or symbol&quot;} 1279 | NAMESPACE -------------------------------------------------------------------------------- ------ WARNING #2 -------------------------------------------------------------- File: com/rpl/specter.cljc:1288:19 -------------------------------------------------------------------------------- 1285 | new-ns (next-fn (namespace structure))] 1286 | (cond (keyword? structure) (keyword new-ns name) 1287 | (symbol? structure) (symbol new-ns name) 1288 | :else (i/throw-illegal &quot;NAMESPACE can only be used on symbols or keywords - &quot; structure) -------------------------^------------------------------------------------------ Use of undeclared Var com.rpl.specter/java -------------------------------------------------------------------------------- 1289 | )))) 1290 | 1291 | (defdynamicnav 1292 | ^{:doc &quot;Adds the result of running select with the given path on the -------------------------------------------------------------------------------- "><y>#</y><d>2019-02-16</d><h>06:10</h><w>vigilancetech</w>any idea why I&apos;d be getting this?

<pre>------ WARNING #1 --------------------------------------------------------------
 File: com/rpl/specter.cljc:1275:19
--------------------------------------------------------------------------------
1272 |           ns (namespace structure)]
1273 |       (cond (keyword? structure) (keyword ns new-name)
1274 |             (symbol? structure) (symbol ns new-name)
1275 |             :else (i/throw-illegal &quot;NAME can only be used on symbols or keywords - &quot; st
ructure)
-------------------------^------------------------------------------------------
 Use of undeclared Var com.rpl.specter/java
--------------------------------------------------------------------------------
1276 |             ))))
1277 |
1278 | (defnav ^{:doc &quot;Navigates to the namespace portion of the keyword or symbol&quot;}
1279 |   NAMESPACE
--------------------------------------------------------------------------------

------ WARNING #2 --------------------------------------------------------------
 File: com/rpl/specter.cljc:1288:19
--------------------------------------------------------------------------------
1285 |           new-ns (next-fn (namespace structure))]
1286 |       (cond (keyword? structure) (keyword new-ns name)
1287 |             (symbol? structure) (symbol new-ns name)
1288 |             :else (i/throw-illegal &quot;NAMESPACE can only be used on symbols or keywords -
 &quot; structure)
-------------------------^------------------------------------------------------
 Use of undeclared Var com.rpl.specter/java
--------------------------------------------------------------------------------
1289 |             ))))
1290 |
1291 | (defdynamicnav
1292 |   ^{:doc &quot;Adds the result of running select with the given path on the
--------------------------------------------------------------------------------
</pre></z><z id="t1550297463" t="vigilancetech this is a project under shadow-cljs"><y>#</y><d>2019-02-16</d><h>06:11</h><w>vigilancetech</w>this is a project under shadow-cljs</z><z id="t1550303780" t="vigilancetech okay, I got it to go away by running the latest snapshot. Any idea when that version will be un-snapshotted so my program doesn&apos;t break again here in a few weeks?"><y>#</y><d>2019-02-16</d><h>07:56</h><w>vigilancetech</w>okay, I got it to go away by running the latest snapshot.   Any idea when that version will be un-snapshotted so my program doesn&apos;t break again here in a few weeks?</z><z id="t1550543636" t="axrs Is it possible to insert a value after a predicate match with specter? I thought AFTER-ELEM would work, but it converts map to a sequence ([:spec :test-2] :inserted) Something like: (sp/setval [sp/ALL (comp (partial = :test-2) :spec) sp/AFTER] :inserted [{:spec :test} {:spec :test-2} {:spec :test-3}]) I&apos;m looking for the result to be: [{:spec :test} {:spec :test-2} :inserted {:spec :test-3}]"><y>#</y><d>2019-02-19</d><h>02:33</h><w>axrs</w>Is it possible to insert a value after a predicate match with specter? I thought <code>AFTER-ELEM</code> would work, but it converts map to a sequence <code>([:spec :test-2] :inserted)</code>

Something like:
<pre>(sp/setval 
  [sp/ALL (comp (partial = :test-2) :spec) sp/AFTER] 
  :inserted 
  [{:spec :test} {:spec :test-2} {:spec :test-3}])
</pre>
I&apos;m looking for the result to be:
<code>[{:spec :test} {:spec :test-2} :inserted {:spec :test-3}]</code></z><z id="t1550582437" t="nathanmarz @axrs ALL navigates you into the value, so you&apos;re no longer in the context of the sequence"><y>#</y><d>2019-02-19</d><h>13:20</h><w>nathanmarz</w>@axrs <code>ALL</code> navigates you into the value, so you&apos;re no longer in the context of the sequence</z><z id="t1550582461" t="nathanmarz you can accomplish your goal by using the zipper navigators"><y>#</y><d>2019-02-19</d><h>13:21</h><w>nathanmarz</w>you can accomplish your goal by using the zipper navigators</z><z id="t1550749704" t="roklenarcic Is there some way to say STAY if SUBPATH 1 and SUBPATH 2 match"><y>#</y><d>2019-02-21</d><h>11:48</h><w>roklenarcic</w>Is there some way to say <code>STAY if SUBPATH 1 and SUBPATH 2 match</code></z><z id="t1550749723" t="roklenarcic I cannot find a way to check if two subpaths are both present"><y>#</y><d>2019-02-21</d><h>11:48</h><w>roklenarcic</w>I cannot find a way to check if two subpaths are both present</z><z id="t1550749756" t="roklenarcic to implement collecting an item if prop1 = x and prop2 = y"><y>#</y><d>2019-02-21</d><h>11:49</h><w>roklenarcic</w>to implement collecting an item if prop1 = x and prop2 = y</z><z id="t1550750653" t="roklenarcic used multiple selected? to accomplish that"><y>#</y><d>2019-02-21</d><h>12:04</h><w>roklenarcic</w>used multiple <code>selected?</code> to accomplish that</z><z id="t1550788186" t="eoliphant hi I’m trying to figure out how exactly INDEXED-VALS works. Like the example . For say [0 1 2 3 4] , I want to move say the 3 at index 3, to say the 0th or some other index. The select is clear to me, basically like map-indexed . But I’m not quite grokking what’s happening in the setval example. This looks like it would do something like set all the indicies to 0. (sp/setval [sp/INDEXED-VALS sp/FIRST] 0 [0 1 2 3 4]) but say (sp/setval [sp/INDEXED-VALS sp/FIRST 2] 0 [0 1 2 3 4]) would move 2 to the front of the list. That’s obviously not how it works lol"><y>#</y><d>2019-02-21</d><h>22:29</h><w>eoliphant</w>hi I’m trying to figure out how exactly INDEXED-VALS works.  Like the example .  For say <code>[0 1 2 3 4]</code>, I want to move say the 3 at index 3, to say the 0th or some other index.  The select is clear to me, basically like <code>map-indexed</code>.  But I’m not quite grokking what’s happening in the <code>setval</code> example.

This looks like it would do something like set all the indicies to 0.   <code>(sp/setval [sp/INDEXED-VALS sp/FIRST] 0 [0 1 2 3 4])</code>  but say <code>(sp/setval [sp/INDEXED-VALS sp/FIRST 2] 0 [0 1 2 3 4])</code> would move 2 to the front of the list.  That’s obviously not how it works lol</z><z id="t1550789866" t="nathanmarz it traverses the values in order, so it moves them all to index 0 in order, having the effect of reversing the vector"><y>#</y><d>2019-02-21</d><h>22:57</h><w>nathanmarz</w>it traverses the values in order, so it moves them all to index 0 in order, having the effect of reversing the vector</z><z id="t1550789877" t="nathanmarz you can move just one particular value like this: user=&gt; (setval [INDEXED-VALS (selected? LAST (pred= 3)) FIRST] 0 [0 1 2 3 4]) [3 0 1 2 4] "><y>#</y><d>2019-02-21</d><h>22:57</h><w>nathanmarz</w>you can move just one particular value like this:
<pre>user=&gt; (setval [INDEXED-VALS (selected? LAST (pred= 3)) FIRST] 0 [0 1 2 3 4])
[3 0 1 2 4]
</pre></z><z id="t1550789912" t="nathanmarz but index-nav is better for moving one value at a specific position: user=&gt; (setval (index-nav 3) 0 [0 1 2 3 4]) [3 0 1 2 4] "><y>#</y><d>2019-02-21</d><h>22:58</h><w>nathanmarz</w>but <code>index-nav</code> is better for moving one value at a specific position:
<pre>user=&gt; (setval (index-nav 3) 0 [0 1 2 3 4])
[3 0 1 2 4]
</pre></z><z id="t1550794692" t="eoliphant gotcha that makes sense., thanks!"><y>#</y><d>2019-02-22</d><h>00:18</h><w>eoliphant</w>gotcha that makes sense., thanks!</z><z id="t1551174468" t="miikka We tried to use (transiorm [ALL] ...) with Instaparse&apos;s AutoFlattenSeq, but the results are in reverse order – probably because if you into into an empty AutoFlattenSeq, it behaves like a linked list and the results are in the reverse order."><y>#</y><d>2019-02-26</d><h>09:47</h><w>miikka</w>We tried to use <code>(transiorm [ALL] ...)</code> with Instaparse&apos;s AutoFlattenSeq, but the results are in reverse order – probably because if you <code>into</code> into an empty AutoFlattenSeq, it behaves like a linked list and the results are in the reverse order.</z><z id="t1551174529" t="miikka We solved it by making a custom navigator with (transform* [this structure next-fn] (map next-fn structure)) – we do not care about preserving the type – but I&apos;m wondering if there&apos;s a way to make ALL work with AutoFlattenSeq?"><y>#</y><d>2019-02-26</d><h>09:48</h><w>miikka</w>We solved it by making  a custom navigator with <code>(transform* [this structure next-fn] (map next-fn structure))</code> – we do not care about preserving the type – but I&apos;m wondering if there&apos;s a way to make <code>ALL</code> work with AutoFlattenSeq?</z><z id="t1551183998" t="nathanmarz @miikka yes, you can extend com.rpl.specter.navs/AllTransformProtocol"><y>#</y><d>2019-02-26</d><h>12:26</h><w>nathanmarz</w>@miikka yes, you can extend <code>com.rpl.specter.navs/AllTransformProtocol</code></z><z id="t1551197018" t="miikka Ah, thanks"><y>#</y><d>2019-02-26</d><h>16:03</h><w>miikka</w>Ah, thanks</z><z id="t1551437844" t="lxsli Nathan are you writing a book on how to use Specter? Because I&apos;d buy the hell out of that"><y>#</y><d>2019-03-01</d><h>10:57</h><w>lxsli</w>Nathan are you writing a book on how to use Specter? Because I&apos;d buy the hell out of that</z><z id="t1551454781" t="nathanmarz @alee thanks, but I&apos;m done writing books for awhile..."><y>#</y><d>2019-03-01</d><h>15:39</h><w>nathanmarz</w>@alee thanks, but I&apos;m done writing books for awhile...</z></g><g id="s23"><z id="t1551665502" t="idiomancy any libraries out there for navigating core.async channels with specter?"><y>#</y><d>2019-03-04</d><h>02:11</h><w>idiomancy</w>any libraries out there for navigating core.async channels with specter?</z><z id="t1551702953" t="akond does specter handle refs the way it handles atoms?"><y>#</y><d>2019-03-04</d><h>12:35</h><w>akond</w>does specter handle refs the way it handles atoms?</z><z id="t1551702976" t="akond i mean how do i change a ref?"><y>#</y><d>2019-03-04</d><h>12:36</h><w>akond</w>i mean how do i change a ref?</z><z id="t1551704146" t="akond (dosync (alter storage #(setval [...] (merge-with + field offset) %))) does the job, but maybe there is a nicer way to do this?"><y>#</y><d>2019-03-04</d><h>12:55</h><w>akond</w><pre>(dosync
    (alter storage #(setval [...] (merge-with + field offset) %)))</pre>
does the job, but maybe there is a nicer way to do this?</z><z id="t1551739788" t="nathanmarz @akond there&apos;s no built-in navigator for refs"><y>#</y><d>2019-03-04</d><h>22:49</h><w>nathanmarz</w>@akond there&apos;s no built-in navigator for refs</z><z id="t1551739791" t="nathanmarz you&apos;d have to make your own"><y>#</y><d>2019-03-04</d><h>22:49</h><w>nathanmarz</w>you&apos;d have to make your own</z><z id="t1551761781" t="akond is there a reason for not having one or it just happend?"><y>#</y><d>2019-03-05</d><h>04:56</h><w>akond</w>is there a reason for not having one or it just happend?</z><z id="t1551776015" t="sogaiu @alee perhaps you are already familiar with the following? https://leanpub.com/specter/read"><y>#</y><d>2019-03-05</d><h>08:53</h><w>sogaiu</w>@alee perhaps you are already familiar with the following?  <a href="https://leanpub.com/specter/read" target="_blank">https://leanpub.com/specter/read</a></z><z id="t1551776163" t="lxsli @sogaiu yes, I&apos;m afraid I didn&apos;t find it very useful. It&apos;s not finished by any stretch - it doesn&apos;t cover many of the navigators or even the macros"><y>#</y><d>2019-03-05</d><h>08:56</h><w>lxsli</w>@sogaiu yes, I&apos;m afraid I didn&apos;t find it very useful. It&apos;s not finished by any stretch - it doesn&apos;t cover many of the navigators or even the macros</z><z id="t1551776211" t="lxsli I&apos;m unconvinced that digging into the internals is the best way to understand it either"><y>#</y><d>2019-03-05</d><h>08:56</h><w>lxsli</w>I&apos;m unconvinced that digging into the internals is the best way to understand it either</z><z id="t1551776459" t="lxsli I&apos;m most interested in a cookbook. For example one of my questions is &quot;how much should I do in one Specter call?&quot;. I&apos;ve had more luck composing calls than building super-paths so far. Dynamic paths seem very powerful, I&apos;d like to see some examples of those. Same for multi-path. I have yet to figure out when to use STAY, CONTINUE etc. Just about getting the hang of collection."><y>#</y><d>2019-03-05</d><h>09:00</h><w>lxsli</w>I&apos;m most interested in a cookbook. For example one of my questions is &quot;how much should I do in one Specter call?&quot;. I&apos;ve had more luck composing calls than building super-paths so far.
Dynamic paths seem very powerful, I&apos;d like to see some examples of those. Same for multi-path.
I have yet to figure out when to use STAY, CONTINUE etc. Just about getting the hang of collection.</z><z id="t1551780463" t="sogaiu @alee when working on a port to clojure clr, i found that the tests were quite extensive. have you had a look at those? fwiw, i&apos;m definitely not a seasoned specter user :)"><y>#</y><d>2019-03-05</d><h>10:07</h><w>sogaiu</w>@alee when working on a port to clojure clr, i found that the tests were quite extensive.  have you had a look at those?  fwiw, i&apos;m definitely not a seasoned specter user :)</z><z id="t1551780589" t="lxsli I&apos;ll check them out when I have time, good idea"><y>#</y><d>2019-03-05</d><h>10:09</h><w>lxsli</w>I&apos;ll check them out when I have time, good idea</z><z id="t1555053697" t="lxsli java.lang.UnsupportedOperationException: Can&apos;t create empty: user_api.records.FrobRec at user_api.records.FrobRec.empty(records.clj:367) at clojure.core$empty.invokeStatic(core.clj:5247) at clojure.core$empty.invoke(core.clj:5241) at com.rpl.specter.navs$eval2165$fn__2170.invoke(navs.cljc:372) at com.rpl.specter.navs$eval2099$fn__2113$G__2090__2120.invoke(navs.cljc:222) at com.rpl.specter$reify__2852.transform_STAR_(specter.cljc:718) ... Anything that can be done about this? For now I&apos;m just passing (into {} rec) instead of simply rec"><y>#</y><d>2019-04-12</d><h>07:21</h><w>lxsli</w><pre>java.lang.UnsupportedOperationException: Can&apos;t create empty: user_api.records.FrobRec
	at user_api.records.FrobRec.empty(records.clj:367)
	at clojure.core$empty.invokeStatic(core.clj:5247)
	at clojure.core$empty.invoke(core.clj:5241)
	at com.rpl.specter.navs$eval2165$fn__2170.invoke(navs.cljc:372)
	at com.rpl.specter.navs$eval2099$fn__2113$G__2090__2120.invoke(navs.cljc:222)
	at com.rpl.specter$reify__2852.transform_STAR_(specter.cljc:718)
    ...</pre>

Anything that can be done about this? For now I&apos;m just passing <code>(into {} rec)</code> instead of simply <code>rec</code></z><z id="t1555088261" t="nathanmarz what&apos;s your path?"><y>#</y><d>2019-04-12</d><h>16:57</h><w>nathanmarz</w>what&apos;s your path?</z><z id="t1557115377" t="theeternalpulse If I am doing a transform with multi/path how can I refer to the las tthing selected before that path for example (multi-transform [LAST (multi-path [:a (terminal #_something-here-to-reference-LAST-object)] [:b (terminal dec)])] [1 2 3 4 5 {:a 1 :b 5 :c nil}])"><y>#</y><d>2019-05-06</d><h>04:02</h><w>theeternalpulse</w>If I am doing a transform with multi/path how can I refer to the las tthing selected before that path for example
<pre>(multi-transform [LAST
                    (multi-path [:a (terminal #_something-here-to-reference-LAST-object)]
                                [:b (terminal dec)])]
                   [1 2 3 4 5 {:a 1 :b 5 :c nil}])</pre></z><z id="t1557115409" t="theeternalpulse how can In the terminal statement can I say &quot;give me the LAST from the previous selector before I started branching off&quot;"><y>#</y><d>2019-05-06</d><h>04:03</h><w>theeternalpulse</w>how can In the terminal statement can I say &quot;give me the LAST from the previous selector before I started branching off&quot;</z><z id="t1557115986" t="theeternalpulse do I have ot just have a path that is like [(terminal #(update % :a some-fn (:c %)...)"><y>#</y><d>2019-05-06</d><h>04:13</h><w>theeternalpulse</w>do I have ot just have a path that is like <code>[(terminal #(update % :a some-fn (:c %)...)</code></z><z id="t1557116151" t="theeternalpulse (multi-transform [LAST (multi-path [(terminal #(update % :a + (:b %)))] [:b (terminal dec)] [:c (terminal-val 123)])] [1 2 3 4 5 {:a 1 :b 5 :c nil}]) seems to work but wonder if there&apos;s a more specter way of doing that"><y>#</y><d>2019-05-06</d><h>04:15</h><r>theeternalpulse</r><pre>(multi-transform [LAST
                    (multi-path [(terminal #(update % :a + (:b %)))]
                                [:b (terminal dec)]
                                [:c (terminal-val 123)])]
                   [1 2 3 4 5 {:a 1 :b 5 :c nil}])</pre>
seems to work but wonder if there&apos;s a more specter way of doing that</z><z id="t1557148796" t="nathanmarz @theeternalpulse use one of the value collection navs, like collect or collect-one"><y>#</y><d>2019-05-06</d><h>13:19</h><w>nathanmarz</w>@theeternalpulse use one of the value collection navs, like <code>collect</code> or <code>collect-one</code></z><z id="t1557152528" t="theeternalpulse Ah I see, now that makes the subsequent multipath fns have to take two arguments"><y>#</y><d>2019-05-06</d><h>14:22</h><w>theeternalpulse</w>Ah I see, now that makes the subsequent multipath fns have to take two arguments</z><z id="t1557154955" t="theeternalpulse no I tried it, nice solution, need to read through these again, (multi-transform [LAST (multi-path [(collect-one :b) :a (terminal +)] [:b (terminal dec)] [:c (terminal-val 123)])] [1 2 3 4 5 {:a 1 :b 5 :c nil}])"><y>#</y><d>2019-05-06</d><h>15:02</h><w>theeternalpulse</w>no I tried it, nice solution, need to read through these again, <pre>(multi-transform [LAST
                    (multi-path
                     [(collect-one :b) :a (terminal +)]
                     [:b (terminal dec)]
                     [:c (terminal-val 123)])]
                   [1 2 3 4 5 {:a 1 :b 5 :c nil}])</pre></z><z id="t1558890665" t="Joshua Suskalo Is there an equivalent to select-keys? I&apos;m currently trying to translate some of my vanilla clojure code to using specter (great library by the way, I use it in almost all my projects), and trying to navigate to a view of all the values in a map where the key for it is contained in some collection seems to me to be a not-uncommon usecase. I&apos;ve tried a couple of solutions for it, from using (apply multi-path (map keypath coll)) to (filterer (comp set-name first)) and no matter what I do, the performance is always at least twice as poor as just calling select-keys . I&apos;ve been perusing the docs, but nothing is jumping out at me."><y>#</y><d>2019-05-26</d><h>17:11</h><w>Joshua Suskalo</w>Is there an equivalent to select-keys? I&apos;m currently trying to translate some of my vanilla clojure code to using specter (great library by the way, I use it in almost all my projects), and trying to navigate to a view of all the values in a map where the key for it is contained in some collection seems to me to be a not-uncommon usecase. I&apos;ve tried a couple of solutions for it, from using <code>(apply multi-path (map keypath coll))</code> to <code>(filterer (comp set-name first))</code> and no matter what I do, the performance is always at least twice as poor as just calling <code>select-keys</code>. I&apos;ve been perusing the docs, but nothing is jumping out at me.</z><z id="t1558891897" t="Joshua Suskalo I see that submap is what I was looking for"><y>#</y><d>2019-05-26</d><h>17:31</h><w>Joshua Suskalo</w>I see that <code>submap</code> is what I was looking for</z><z id="t1558892017" t="Joshua Suskalo submap has much more acceptable performance, being only slightly slower than the select-keys implementation. Again, thanks for the library!"><y>#</y><d>2019-05-26</d><h>17:33</h><w>Joshua Suskalo</w><code>submap</code> has much more acceptable performance, being only slightly slower than the <code>select-keys</code> implementation. Again, thanks for the library!</z><z id="t1559002056" t="nathanmarz @suskeyhose thanks, glad you&apos;re finding it useful"><y>#</y><d>2019-05-28</d><h>00:07</h><w>nathanmarz</w>@suskeyhose thanks, glad you&apos;re finding it useful</z><z id="t1559766329" t="lvh Is there a way to run specter but without eval being called ever (I&apos;m trying to get it working under Graal -- and for my recursive path, closed-code still ends up getting called, and that relies on eval even when using select* )"><y>#</y><d>2019-06-05</d><h>20:25</h><w>lvh</w>Is there a way to run specter but without eval being called ever (I&apos;m trying to get it working under Graal -- and for my recursive path, closed-code still ends up getting called, and that relies on eval even when using <code>select*</code>)</z><z id="t1559767596" t="nathanmarz @lvh if you avoid all the macros eval won&apos;t be called"><y>#</y><d>2019-06-05</d><h>20:46</h><w>nathanmarz</w>@lvh if you avoid all the macros eval won&apos;t be called</z><z id="t1559767601" t="nathanmarz recursive-path calls down to path"><y>#</y><d>2019-06-05</d><h>20:46</h><w>nathanmarz</w><code>recursive-path</code> calls down to <code>path</code></z><z id="t1559767613" t="nathanmarz which is what generates code that calls eval"><y>#</y><d>2019-06-05</d><h>20:46</h><w>nathanmarz</w>which is what generates code that calls eval</z><z id="t1559767706" t="nathanmarz recursive-path is just a helper, so you could probably construct a recursive path with no dynamic parameters by making your own helper"><y>#</y><d>2019-06-05</d><h>20:48</h><w>nathanmarz</w><code>recursive-path</code> is just a helper, so you could probably construct a recursive path with no dynamic parameters by making your own helper</z><z id="t1560886499" t="lvh Is there a way to &quot;prime&quot; a navigator applied to a data structure? Context: I have a data structure which I&apos;ll be calling setval on a pile of times, always with different values but always at the same locations, so I&apos;m wondering if there are efficiency gains to be had by only navigating once and then reusing that. Disclaimer: I don&apos;t understand the caching magic at all so maybe specter is essentially already doing that?"><y>#</y><d>2019-06-18</d><h>19:34</h><w>lvh</w>Is there a way to &quot;prime&quot; a navigator applied to a data structure? Context: I have a data structure which I&apos;ll be calling setval on a pile of times, always with different values but always at the same locations, so I&apos;m wondering if there are efficiency gains to be had by only navigating once and then reusing that. Disclaimer: I don&apos;t understand the caching magic at all so maybe specter is essentially already doing that?</z><z id="t1560898069" t="nathanmarz @lvh the inline compiler is already ensuring that the most optimal path possible is used for all runs of the callsite after the first"><y>#</y><d>2019-06-18</d><h>22:47</h><w>nathanmarz</w>@lvh the inline compiler is already ensuring that the most optimal path possible is used for all runs of the callsite after the first</z><z id="t1560898121" t="nathanmarz you can tighten things up for certain cases by using ^:direct-nav"><y>#</y><d>2019-06-18</d><h>22:48</h><w>nathanmarz</w>you can tighten things up for certain cases by using <code>^:direct-nav</code></z><z id="t1560902038" t="lvh Awesome, thanks :)"><y>#</y><d>2019-06-18</d><h>23:53</h><w>lvh</w>Awesome, thanks :)</z><z id="t1562423725" t="oskarkv I don&apos;t understand compact . 😛"><y>#</y><d>2019-07-06</d><h>14:35</h><w>oskarkv</w>I don&apos;t understand <code>compact</code>. <b>😛</b></z><z id="t1562425255" t="oskarkv Can anyone explain this? &gt; (s/setval (s/regex-nav #&quot;(?&lt;=( |^))[a-z]&quot;) &quot;_&quot; &quot;hello world&quot;) &quot;_ello _orld&quot; &gt; (s/select (s/regex-nav #&quot;(?&lt;=( |^))[a-z]&quot;) &quot;hello world&quot;) [[&quot;h&quot; &quot;&quot;] [&quot;e&quot; &quot;&quot;] [&quot;l&quot; &quot;&quot;] [&quot;l&quot; &quot;&quot;] [&quot;o&quot; &quot;&quot;] [&quot;w&quot; &quot; &quot;] [&quot;o&quot; &quot;&quot;] [&quot;r&quot; &quot;&quot;] [&quot;l&quot; &quot;&quot;] [&quot;d&quot; &quot;&quot;]] "><y>#</y><d>2019-07-06</d><h>15:00</h><w>oskarkv</w>Can anyone explain this?
<pre>&gt; (s/setval (s/regex-nav #&quot;(?&lt;=( |^))[a-z]&quot;) &quot;_&quot; &quot;hello world&quot;)
&quot;_ello _orld&quot;
&gt; (s/select (s/regex-nav #&quot;(?&lt;=( |^))[a-z]&quot;) &quot;hello world&quot;)
[[&quot;h&quot; &quot;&quot;] [&quot;e&quot; &quot;&quot;] [&quot;l&quot; &quot;&quot;] [&quot;l&quot; &quot;&quot;] [&quot;o&quot; &quot;&quot;] [&quot;w&quot; &quot; &quot;] [&quot;o&quot; &quot;&quot;] [&quot;r&quot; &quot;&quot;] [&quot;l&quot; &quot;&quot;] [&quot;d&quot; &quot;&quot;]]
</pre></z><z id="t1562426324" t="oskarkv Oh, it&apos;s because re-seq looks at &quot;hello world&quot;, then &quot;ello world&quot;, etc."><y>#</y><d>2019-07-06</d><h>15:18</h><w>oskarkv</w>Oh, it&apos;s because <code>re-seq</code> looks at &quot;hello world&quot;, then &quot;ello world&quot;, etc.</z><z id="t1562437326" t="currentoor what can you do with the result of traverse that you can’t do with the result of select ?"><y>#</y><d>2019-07-06</d><h>18:22</h><w>currentoor</w>what can you do with the result of <code>traverse</code> that you can’t do with the result of <code>select</code>?</z><z id="t1562521732" t="currentoor also, is there a simple way, given a sequence, to remove the first match and leave the rest?"><y>#</y><d>2019-07-07</d><h>17:48</h><w>currentoor</w>also, is there a simple way, given a sequence, to remove the first match and leave the rest?</z><z id="t1562521750" t="currentoor (specter/setval [specter/ALL (specter/pred= 1)] specter/NONE [1 2 1 3])"><y>#</y><d>2019-07-07</d><h>17:49</h><w>currentoor</w><code>(specter/setval [specter/ALL (specter/pred= 1)] specter/NONE [1 2 1 3])</code></z><z id="t1562521757" t="currentoor this removes all the matches"><y>#</y><d>2019-07-07</d><h>17:49</h><w>currentoor</w>this removes all the matches</z><z id="t1562526392" t="oskarkv @currentoor In that case you can do (s/setval [(s/filterer (s/pred= 1)) s/FIRST] s/NONE [1 2 1 3])"><y>#</y><d>2019-07-07</d><h>19:06</h><w>oskarkv</w>@currentoor In that case you can do <code>(s/setval [(s/filterer (s/pred= 1)) s/FIRST] s/NONE [1 2 1 3])</code></z><z id="t1562526406" t="currentoor cool thanks!"><y>#</y><d>2019-07-07</d><h>19:06</h><w>currentoor</w>cool thanks!</z><z id="t1562526502" t="oskarkv Or, hm it doesn&apos;t work as I expected"><y>#</y><d>2019-07-07</d><h>19:08</h><w>oskarkv</w>Or, hm it doesn&apos;t work as I expected</z><z id="t1562526759" t="oskarkv game.core&gt; (s/setval [(s/filterer (s/pred= 1)) s/FIRST] s/NONE [1 2 1 3]) [1 2 3] I would expect [2 1 3] out"><y>#</y><d>2019-07-07</d><h>19:12</h><w>oskarkv</w><pre>game.core&gt; (s/setval [(s/filterer (s/pred= 1)) s/FIRST] s/NONE [1 2 1 3])
[1 2 3]
</pre>
I would expect <code>[2 1 3]</code> out</z><z id="t1562526774" t="oskarkv @currentoor Did you notice?"><y>#</y><d>2019-07-07</d><h>19:12</h><w>oskarkv</w>@currentoor Did you notice?</z><z id="t1562526868" t="currentoor yeah i would too"><y>#</y><d>2019-07-07</d><h>19:14</h><w>currentoor</w>yeah i would too</z><z id="t1562526892" t="currentoor but actually i just need to remove one occurrence of an element"><y>#</y><d>2019-07-07</d><h>19:14</h><w>currentoor</w>but actually i just need to remove one occurrence of an element</z><z id="t1562526896" t="currentoor so this works"><y>#</y><d>2019-07-07</d><h>19:14</h><w>currentoor</w>so this works</z><z id="t1562526899" t="oskarkv hehe"><y>#</y><d>2019-07-07</d><h>19:14</h><w>oskarkv</w>hehe</z><z id="t1562549711" t="nathanmarz @currentoor traverse is more efficient than select if you just want to reduce over the navigated values"><y>#</y><d>2019-07-08</d><h>01:35</h><w>nathanmarz</w>@currentoor <code>traverse</code> is more efficient than <code>select</code> if you just want to reduce over the navigated values</z><z id="t1562851234" t="ben.mumford given a nested data structure (values could be strings, nil, vectors of maps or maps) what is the best way to prune the tree so that nil entries, empty map entries, empty vectors are removed?"><y>#</y><d>2019-07-11</d><h>13:20</h><w>ben.mumford</w>given a nested data structure (values could be strings, nil, vectors of maps or maps) what is the best way to prune the tree so that nil entries, empty map entries, empty vectors are removed?</z><z id="t1562851309" t="ben.mumford (do-something {:a {:aa 1} :b {:ba -1 :bb 2 :bc nil :bd &quot;&quot; :be [] :bf {} :bg {:bga nil} :bh [nil] :bi [{}] :bj [{:bja nil}]} :c nil :d &quot;&quot; :e [] :f {} :g {:ga nil} :h [nil] :i [{}] :j [{:ja nil}]} =&gt; {:a {:aa 1} :b {:ba -1 :bb 2}} "><y>#</y><d>2019-07-11</d><h>13:21</h><w>ben.mumford</w><pre>(do-something {:a {:aa 1}                                             
     :b {:ba -1                                             
         :bb 2                                              
         :bc nil
         :bd &quot;&quot;
         :be []
         :bf {}
         :bg {:bga nil}
         :bh [nil]
         :bi [{}]
         :bj [{:bja nil}]}
     :c nil
     :d &quot;&quot;
     :e []
     :f {}
     :g {:ga nil}
     :h [nil]
     :i [{}]
     :j [{:ja nil}]}
=&gt;
{:a {:aa 1} 
     :b {:ba -1 
         :bb 2}}
</pre></z><z id="t1562851369" t="ben.mumford any help would be much appreciated 🙂"><y>#</y><d>2019-07-11</d><h>13:22</h><w>ben.mumford</w>any help would be much appreciated <b>🙂</b></z><z id="t1562869459" t="nathanmarz @ben.mumford620 here&apos;s how to do that: (def COMPACTED-VALS-PATH (recursive-path [] p (continue-then-stay (cond-path map? [(compact MAP-VALS) p] vector? [(compact ALL) p] )))) (setval [COMPACTED-VALS-PATH #(or (nil? %) (= &quot;&quot; %))] NONE data) "><y>#</y><d>2019-07-11</d><h>18:24</h><w>nathanmarz</w>@ben.mumford620 here&apos;s how to do that:
<pre>(def COMPACTED-VALS-PATH
  (recursive-path [] p
    (continue-then-stay
      (cond-path
        map? [(compact MAP-VALS) p]
        vector? [(compact ALL) p]
        ))))
        
(setval [COMPACTED-VALS-PATH #(or (nil? %) (= &quot;&quot; %))] NONE data)
</pre></z><z id="t1562916366" t="ben.mumford cheers pal"><y>#</y><d>2019-07-12</d><h>07:26</h><r>ben.mumford</r>cheers pal</z><z id="t1562869556" t="nathanmarz you can insert a MAP-VALS at the start of the path to make sure the top-level data structure stays an empty map instead of becoming NONE if everything gets compacted"><y>#</y><d>2019-07-11</d><h>18:25</h><w>nathanmarz</w>you can insert a <code>MAP-VALS</code> at the start of the path to make sure the top-level data structure stays an empty map instead of becoming NONE if everything gets compacted</z><z id="t1562869673" t="dharrigan that&apos;s pretty awesome"><y>#</y><d>2019-07-11</d><h>18:27</h><w>dharrigan</w>that&apos;s pretty awesome</z><z id="t1563360405" t="donavan Hi, just started using Specter and so far it&apos;s been amazing. Replaced my naive handwritten code in less lines and it was faster! One issue I&apos;m having though relates to CLJS not supporting apply with more than 21 args for IFn here: https://github.com/clojure/clojurescript/blob/master/src/main/cljs/cljs/core.cljs#L2054 and defdynamicnav via multi-path whose var has meta (though I suspect the IFn limitation would be hit without MetaFn anyway). So this is maybe an abuse of multi-path but I would like to dynamically create a collection of paths that may be bigger than the 21 count limit. Before I manually chunk the paths and apply them in stages I was wondering if anyone had noticed this before and had a simple workaround. Or maybe chunking the paths is the simple workaround..."><y>#</y><d>2019-07-17</d><h>10:46</h><w>donavan</w>Hi, just started using Specter and so far it&apos;s been amazing. Replaced my naive handwritten code in less lines and it was faster!

One issue I&apos;m having though relates to CLJS not supporting <code>apply</code> with more than 21 args for <code>IFn</code> here: <a href="https://github.com/clojure/clojurescript/blob/master/src/main/cljs/cljs/core.cljs#L2054" target="_blank">https://github.com/clojure/clojurescript/blob/master/src/main/cljs/cljs/core.cljs#L2054</a> and <code>defdynamicnav</code> via <code>multi-path</code> whose var has meta (though I suspect the <code>IFn</code> limitation would be hit without <code>MetaFn</code> anyway).

So this is maybe an abuse of <code>multi-path</code> but I would like to dynamically create a collection of paths that may be bigger than the 21 count limit. Before I manually chunk the paths and apply them in stages I was wondering if anyone had noticed this before and had a simple workaround. Or maybe chunking the paths is the simple workaround...</z><z id="t1563361090" t="donavan Actually I can just reduce over the paths as that is what would happen with (apply multi-path... anyway!"><y>#</y><d>2019-07-17</d><h>10:58</h><r>donavan</r>Actually I can just reduce over the paths as that is what would happen with <code>(apply multi-path...</code> anyway!</z><z id="t1563890114" t="oskarkv I want to make a function that is kind of like merge-with , but recursive, i.e. if I call this function, let&apos;s call it f , like (f + {:a {:b 1 :c 2} :b {:d 4 :e 5}} {:a {:b 3 :c 3} :b {:d 5 :e 5}}) I want the output {:a {:b 4 :c 5} :b {:d 9 :e 10}} Can specter help with that? I don&apos;t see how, but it&apos;s very possible I&apos;m wrong."><y>#</y><d>2019-07-23</d><h>13:55</h><w>oskarkv</w>I want to make a function that is kind of like <code>merge-with</code>, but recursive, i.e. if I call this function, let&apos;s call it <code>f</code>, like
<pre>(f + {:a {:b 1 :c 2} :b {:d 4 :e 5}} {:a {:b 3 :c 3} :b {:d 5 :e 5}})</pre>
I want the output <code>{:a {:b 4 :c 5} :b {:d 9 :e 10}}</code>
Can specter help with that? I don&apos;t see how, but it&apos;s very possible I&apos;m wrong.</z><z id="t1563891772" t="oskarkv It was not too hard to write without specter, so I doubt specter will help much either way 😛"><y>#</y><d>2019-07-23</d><h>14:22</h><w>oskarkv</w>It was not too hard to write without specter, so I doubt specter will help much either way <b>😛</b></z><z id="t1563894823" t="oskarkv It would be cool if transform could take several structures, like map does, and apply the function to all the elements of all the structures."><y>#</y><d>2019-07-23</d><h>15:13</h><w>oskarkv</w>It would be cool if <code>transform</code> could take several structures, like map does, and apply the function to all the elements of all the structures.</z><z id="t1563895059" t="oskarkv Then my function would be trivial with specter 😛"><y>#</y><d>2019-07-23</d><h>15:17</h><w>oskarkv</w>Then my function would be trivial with specter <b>😛</b></z><z id="t1565109577" t="jsa-aerial I think I&apos;m confused."><y>#</y><d>2019-08-06</d><h>16:39</h><w>jsa-aerial</w>I think I&apos;m confused.</z><z id="t1565110540" t="nathanmarz filterer navigates to a sequence of all &quot;locations&quot; in the sequence matching the predicate"><y>#</y><d>2019-08-06</d><h>16:55</h><w>nathanmarz</w><code>filterer</code> navigates to a sequence of all &quot;locations&quot; in the sequence matching the predicate</z><z id="t1565110553" t="nathanmarz with index 0 being the first location, index 1 being the second, and so on"><y>#</y><d>2019-08-06</d><h>16:55</h><w>nathanmarz</w>with index 0 being the first location, index 1 being the second, and so on</z><z id="t1565110572" t="nathanmarz transformations to the sequence navigated to by filterer can only affect those locations"><y>#</y><d>2019-08-06</d><h>16:56</h><w>nathanmarz</w>transformations to the sequence navigated to by <code>filterer</code> can only affect those locations</z><z id="t1565110611" t="nathanmarz increasing the size of the sequence just causes indexes past the last location to be ignored"><y>#</y><d>2019-08-06</d><h>16:56</h><w>nathanmarz</w>increasing the size of the sequence just causes indexes past the last location to be ignored</z><z id="t1565110646" t="nathanmarz there&apos;s a special case for when you reduce the size of the sequence to set the removed locations to NONE"><y>#</y><d>2019-08-06</d><h>16:57</h><w>nathanmarz</w>there&apos;s a special case for when you reduce the size of the sequence to set the removed locations to <code>NONE</code></z><z id="t1565111741" t="jsa-aerial Hmmmm, OK. So, there is no &apos;obvious / out of the box&apos; way to insert? Using a combo of index-vals and before-index works fine, is that the &apos;right way&apos; to do this?"><y>#</y><d>2019-08-06</d><h>17:15</h><w>jsa-aerial</w>Hmmmm, OK. So, there is no &apos;obvious / out of the box&apos; way to insert? Using a combo of <code>index-vals</code> and <code>before-index</code> works fine, is that the &apos;right way&apos; to do this?</z><z id="t1565112583" t="nathanmarz zipper navigators are good for this use case"><y>#</y><d>2019-08-06</d><h>17:29</h><w>nathanmarz</w>zipper navigators are good for this use case</z><z id="t1565112609" t="nathanmarz com.rpl.specter.zipper"><y>#</y><d>2019-08-06</d><h>17:30</h><w>nathanmarz</w><code>com.rpl.specter.zipper</code></z><z id="t1565112808" t="nathanmarz user=&gt; (setval [z/VECTOR-ZIP (z/find-first #(= &quot;b&quot; %)) z/INNER-LEFT] [77] [&quot;a&quot; &quot;b&quot; &quot;c&quot;]) [&quot;a&quot; 77 &quot;b&quot; &quot;c&quot;] "><y>#</y><d>2019-08-06</d><h>17:33</h><w>nathanmarz</w><pre>user=&gt; (setval [z/VECTOR-ZIP (z/find-first #(= &quot;b&quot; %)) z/INNER-LEFT] [77] [&quot;a&quot; &quot;b&quot; &quot;c&quot;])
[&quot;a&quot; 77 &quot;b&quot; &quot;c&quot;]
</pre></z><z id="t1565114369" t="jsa-aerial 😮"><y>#</y><d>2019-08-06</d><h>17:59</h><w>jsa-aerial</w><b>😮</b></z><z id="t1565114442" t="jsa-aerial Presumably that is much more efficient as well?"><y>#</y><d>2019-08-06</d><h>18:00</h><w>jsa-aerial</w>Presumably that is much more efficient as well?</z><z id="t1565117954" t="nathanmarz unclear"><y>#</y><d>2019-08-06</d><h>18:59</h><w>nathanmarz</w>unclear</z><z id="t1565117968" t="nathanmarz zippers do have overhead"><y>#</y><d>2019-08-06</d><h>18:59</h><w>nathanmarz</w>zippers do have overhead</z><z id="t1565118005" t="nathanmarz the com.rpl.specter.zipper namespace is not totally fleshed out, so there are other navigators that could be added to make it more efficient"><y>#</y><d>2019-08-06</d><h>19:00</h><w>nathanmarz</w>the <code>com.rpl.specter.zipper</code> namespace is not totally fleshed out, so there are other navigators that could be added to make it more efficient</z><z id="t1565118030" t="nathanmarz such as the zipper equivalent of before-index instead of doing INNER-LEFT"><y>#</y><d>2019-08-06</d><h>19:00</h><w>nathanmarz</w>such as the zipper equivalent of <code>before-index</code> instead of doing <code>INNER-LEFT</code></z><z id="t1565118354" t="lellis Hi All, i have a question. Why when use this symbol ’[?e :a true] inside a select nav its resolve to [?e :a G__161070]? ex: (select [ALL (pred #(= (log/spy %) (log/spy &apos;[?e true])))] [&apos;[?e true]]) return []."><y>#</y><d>2019-08-06</d><h>19:05</h><w>lellis</w>Hi All, i have a question. Why when use this symbol ’[?e :a  true] inside a select nav its resolve to [?e :a  G__161070]? ex: <code>(select [ALL (pred #(= (log/spy %) (log/spy &apos;[?e true])))]  [&apos;[?e true]])</code> return [].</z><z id="t1565736635" t="puzzler Is there a variant of select that returns a lazy sequence instead of a vector? I&apos;ve tried things like (sequence (traverse ...)) but that doesn&apos;t work."><y>#</y><d>2019-08-13</d><h>22:50</h><w>puzzler</w>Is there a variant of select that returns a lazy sequence instead of a vector? I&apos;ve tried things like (sequence (traverse ...)) but that doesn&apos;t work.</z><z id="t1565738665" t="puzzler No, I need a lazy sequence because I&apos;m producing a potentially large return value for a library API, and I don&apos;t know how people will consume it. But thanks for the info. I didn&apos;t realize select-first had early termination, since doc says it is no more efficient that select."><y>#</y><d>2019-08-13</d><h>23:24</h><w>puzzler</w>No, I need a lazy sequence because I&apos;m producing a potentially large return value for a library API, and I don&apos;t know how people will consume it. But thanks for the info. I didn&apos;t realize select-first had early termination, since doc says it is no more efficient that select.</z><z id="t1565739049" t="puzzler For use case where you are substituting an existing get-in call where you want a nil return value, would you use select-first, select-one, or would you use select-any and then call its return value with a function to convert NONE to nil?"><y>#</y><d>2019-08-13</d><h>23:30</h><w>puzzler</w>For use case where you are substituting an existing get-in call where you want  a nil return value, would you use select-first, select-one, or would you use select-any and then call its return value with a function to convert NONE to nil?</z><z id="t1565740000" t="puzzler Or maybe just use select-any and stick (nil-&gt;val nil) at the end of the navigator?"><y>#</y><d>2019-08-13</d><h>23:46</h><w>puzzler</w>Or maybe just use select-any and stick (nil-&gt;val nil) at the end of the navigator?</z><z id="t1565740297" t="puzzler Ah, select-any returns nil in that particular case anyway. Never mind."><y>#</y><d>2019-08-13</d><h>23:51</h><w>puzzler</w>Ah, select-any returns nil in that particular case anyway. Never mind.</z><z id="t1565742794" t="nathanmarz @puzzler select-one is the same as select-first except it enforces that your path navigates to at most one value"><y>#</y><d>2019-08-14</d><h>00:33</h><w>nathanmarz</w>@puzzler <code>select-one</code> is the same as <code>select-first</code> except it enforces that your path navigates to at most one value</z><z id="t1565742994" t="nathanmarz corrected the wiki entry on select-first , thanks for letting me know"><y>#</y><d>2019-08-14</d><h>00:36</h><w>nathanmarz</w>corrected the wiki entry on <code>select-first</code>, thanks for letting me know</z><z id="t1565743122" t="nathanmarz you probably want select-one for your use case"><y>#</y><d>2019-08-14</d><h>00:38</h><w>nathanmarz</w>you probably want <code>select-one</code> for your use case</z><z id="t1565758920" t="puzzler I recall a time when you sketched out a navigator for transforming a nested map in such a way that on the way out, it would recursively delete any keys with empty maps. I can&apos;t find it in the slack logs. Do you by any chance have a handy pointer to that?"><y>#</y><d>2019-08-14</d><h>05:02</h><w>puzzler</w>I recall a time when you sketched out a navigator for transforming a nested map in such a way that on the way out, it would recursively delete any keys with empty maps. I can&apos;t find it in the slack logs. Do you by any chance have a handy pointer to that?</z><z id="t1565770202" t="ben.mumford i asked a similar question here and on SO and posted nathan&apos;s answer: https://stackoverflow.com/a/57002777/1185536"><y>#</y><d>2019-08-14</d><h>08:10</h><w>ben.mumford</w>i asked a similar question here and on SO and posted nathan&apos;s answer: <a href="https://stackoverflow.com/a/57002777/1185536" target="_blank">https://stackoverflow.com/a/57002777/1185536</a></z><z id="t1565770334" t="puzzler I saw that, but it looks like the answers are all about scanning through a whole nested map structure removing nil leaves. That&apos;s not really what I want. I want things to get removed if the output of the transformation is NONE, and that causes its map to be empty, and so on."><y>#</y><d>2019-08-14</d><h>08:12</h><w>puzzler</w>I saw that, but it looks like the answers are all about scanning through a whole nested map structure removing nil leaves. That&apos;s not really what I want. I want things to get removed if the output of the transformation is NONE, and that causes its map to be empty, and so on.</z><z id="t1565770448" t="puzzler So something like: (setval (keypath-remove-empties :a :c :d) NONE {:b 1, :a {:c {:d 0}}}) gives back {:b 1}"><y>#</y><d>2019-08-14</d><h>08:14</h><w>puzzler</w>So something like: (setval (keypath-remove-empties :a :c :d) NONE {:b 1, :a {:c {:d 0}}}) gives back {:b 1}</z><z id="t1565773135" t="schmee @puzzler I believe you’re looking for compact ? user=&gt; (sp/setval (sp/compact :a :c :d) sp/NONE {:b 1, :a {:c {:d 0}}}) {:b 1} "><y>#</y><d>2019-08-14</d><h>08:58</h><w>schmee</w>@puzzler I believe you’re looking for <code>compact</code>?
<pre>user=&gt; (sp/setval (sp/compact :a :c :d) sp/NONE {:b 1, :a {:c {:d 0}}})
{:b 1}
</pre></z><z id="t1565782054" t="puzzler @schmee Yes, thanks!"><y>#</y><d>2019-08-14</d><h>11:27</h><w>puzzler</w>@schmee Yes, thanks!</z><z id="t1565786929" t="nathanmarz you probably don&apos;t want to return NONE if the top-level structure becomes empty, so something like (setval [:a (compact :c :d)] NONE data) is generally the pattern to use"><y>#</y><d>2019-08-14</d><h>12:48</h><w>nathanmarz</w>you probably don&apos;t want to return NONE if the top-level structure becomes empty, so something like <code>(setval [:a (compact :c :d)] NONE data)</code> is generally the pattern to use</z><z id="t1565792334" t="lxsli I&apos;ve finally figured out why I can&apos;t use filterer after MAP-KEYS; it expects a sequence where MAP-KEYS navigates to a view of many keyword (for me) elements"><y>#</y><d>2019-08-14</d><h>14:18</h><w>lxsli</w>I&apos;ve finally figured out why I can&apos;t use <code>filterer</code> after MAP-KEYS; it expects a sequence where MAP-KEYS navigates to a view of many keyword (for me) elements</z><z id="t1565792414" t="lxsli Which is better: (setval [MAP-KEYS #(#{&quot;a&quot;} (namespace %))] NONE mymap) or: (setval [(filterer [FIRST NAMESPACE #{&quot;a&quot;}]) MAP-KEYS] NONE mymap) please?"><y>#</y><d>2019-08-14</d><h>14:20</h><w>lxsli</w>Which is better: <code>(setval [MAP-KEYS #(#{&quot;a&quot;} (namespace %))] NONE mymap)</code>
or: <code>(setval [(filterer [FIRST NAMESPACE #{&quot;a&quot;}]) MAP-KEYS] NONE mymap)</code> please?</z><z id="t1565792430" t="lxsli or y&apos;know something else"><y>#</y><d>2019-08-14</d><h>14:20</h><w>lxsli</w>or y&apos;know something else</z><z id="t1565792741" t="lxsli The difference seems more substantial when using select ; the latter form allows me to get the whole entries whereas the former has irrevocably descended to the keys"><y>#</y><d>2019-08-14</d><h>14:25</h><w>lxsli</w>The difference seems more substantial when using <code>select</code>; the latter form allows me to get the whole entries whereas the former has irrevocably descended to the keys</z><z id="t1565792788" t="lxsli My initial attempt btw was something like (setval [MAP-KEYS (filterer NAMESPACE #{&quot;a&quot;})] NONE mymap)"><y>#</y><d>2019-08-14</d><h>14:26</h><w>lxsli</w>My initial attempt btw was something like <code>(setval [MAP-KEYS (filterer NAMESPACE #{&quot;a&quot;})] NONE mymap)</code></z><z id="t1565797375" t="nathanmarz @alee you can also do (setval [MAP-KEYS (selected? NAMESPACE (pred= &quot;a&quot;))] NONE mymap)"><y>#</y><d>2019-08-14</d><h>15:42</h><w>nathanmarz</w>@alee you can also do <code>(setval [MAP-KEYS (selected? NAMESPACE (pred= &quot;a&quot;))] NONE mymap)</code></z><z id="t1565853350" t="lxsli Cracking, thank you!"><y>#</y><d>2019-08-15</d><h>07:15</h><w>lxsli</w>Cracking, thank you!</z><z id="t1566217831" t="Pragyan Tripathi I am trying to write a merge method to generate CSS styles dynamically. This method should take breakpoints, and styles param and generates a map which can be used for styling using stylefy. I am trying to do this using specter, but unable to get desired results. The method should work as follows: (def breakpoints [320 600 1280]) (def style {:padding-top [&quot;20px&quot; &quot;30px&quot; &quot;40px&quot; &quot;50px&quot;] :margin &quot;30px&quot; }) (merge-style breakpoints style) The output should look like the following: {:padding-top &quot;20px&quot; :margin &quot;30px&quot; ::stylefy/media {{:min-width &quot;320px&quot;} {:padding-top &quot;30px&quot;} {:min-width &quot;600px&quot;} {:padding-top &quot;40px&quot;} {:min-width &quot;1280px&quot;} {:padding-top &quot;50px&quot;}} } "><y>#</y><d>2019-08-19</d><h>12:30</h><w>Pragyan Tripathi</w>I am trying to write a merge method to generate CSS styles dynamically. This method should take breakpoints, and styles param and generates a map which can be used for styling using stylefy.

I am trying to do this using specter, but unable to get desired results. The method should work as follows:

<pre>(def breakpoints [320 600 1280])
(def style {:padding-top [&quot;20px&quot; &quot;30px&quot; &quot;40px&quot; &quot;50px&quot;]
            :margin &quot;30px&quot;
           })

(merge-style breakpoints style)
</pre>
The output should look like the following:

<pre>{:padding-top &quot;20px&quot;
 :margin &quot;30px&quot;
 ::stylefy/media {{:min-width &quot;320px&quot;} {:padding-top &quot;30px&quot;}
                  {:min-width &quot;600px&quot;} {:padding-top &quot;40px&quot;}
                  {:min-width &quot;1280px&quot;} {:padding-top &quot;50px&quot;}}
 }
</pre></z><z id="t1566219430" t="Pragyan Tripathi The code I have written till now is as follows: (defn merge-style [breakpoints style] (let [media-queries (s/transform [s/ALL] #(hash-map :min-width (str %1 &quot;px&quot;)) breakpoints)] breakpoints)) "><y>#</y><d>2019-08-19</d><h>12:57</h><w>Pragyan Tripathi</w>The code I have written till now is as follows:
<pre>(defn merge-style
  [breakpoints style]
  (let [media-queries (s/transform [s/ALL] #(hash-map :min-width (str %1 &quot;px&quot;)) breakpoints)]
  breakpoints))
</pre></z><z id="t1566369135" t="Pragyan Tripathi @U3L6TFEJF Thanks a lot for the suggestions. I have been able to solve the problem I had with following method: (defn- get-media-queries [breakpoints styles] (let [base-style (s/transform [s/MAP-VALS] #(%1 0) styles) styles-maps (s/setval [s/MAP-VALS empty?] s/NONE (s/setval [s/MAP-VALS s/FIRST] s/NONE styles)) styles-list (map (fn [[key val]] (map #(hash-map key %1) val)) styles-maps) styles-final (apply vdu/merge-maps styles-list) breaks (map #(hash-map :min-width %1) breakpoints) styles-merged (into {} (mapv vector breaks styles-final)) ] (assoc base-style ::stylefy/media styles-merged))) "><y>#</y><d>2019-08-21</d><h>06:32</h><r>Pragyan Tripathi</r>@U3L6TFEJF Thanks a lot for the suggestions. I have been able to solve the problem I had with following method:
<pre>(defn- get-media-queries
  [breakpoints styles]
  (let [base-style (s/transform [s/MAP-VALS] #(%1 0) styles)
        styles-maps (s/setval [s/MAP-VALS empty?] s/NONE (s/setval [s/MAP-VALS s/FIRST] s/NONE styles))
        styles-list (map (fn [[key val]] (map #(hash-map key %1) val)) styles-maps)
        styles-final (apply vdu/merge-maps styles-list)
        breaks (map #(hash-map :min-width %1) breakpoints)
        styles-merged (into {} (mapv vector breaks styles-final))
        ]
    (assoc base-style ::stylefy/media styles-merged)))
</pre></z><z id="t1566219492" t="Pragyan Tripathi As I am a beginner in clojurescript. I am finding it hard to solve this in functional way using specter."><y>#</y><d>2019-08-19</d><h>12:58</h><w>Pragyan Tripathi</w>As I am a beginner in clojurescript. I am finding it hard to solve this in functional way using specter.</z><z id="t1566220042" t="schmee creating new data structures out of two existing ones it not really something Specter is suited for, it is better suited for transformations of an existing data structure"><y>#</y><d>2019-08-19</d><h>13:07</h><w>schmee</w>creating new data structures out of two existing ones it not really something Specter is suited for, it is better suited for transformations of an existing data structure</z><z id="t1566220057" t="schmee this is probably easier to solve with regular Clojure code"><y>#</y><d>2019-08-19</d><h>13:07</h><w>schmee</w>this is probably easier to solve with regular Clojure code</z><z id="t1566220561" t="Pragyan Tripathi got it. I am trying to learn specter so may be that’s why I thinking in those terms all the time. Will figure out a way to in normal clojure code. Thanks."><y>#</y><d>2019-08-19</d><h>13:16</h><w>Pragyan Tripathi</w>got it. I am trying to learn specter so may be that’s why I thinking in those terms all the time. Will figure out a way to in normal clojure code. Thanks.</z><z id="t1566467177" t="Petrus Theron Can Specter emit reductions over a lensed collection? E.g. (something-specter [ALL :amount (reducer +)] [{:amount 10.0M} {:amount 20.0M} ...]) =&gt; [{:amount 10.0M} {:amount 30.0M} ...]"><y>#</y><d>2019-08-22</d><h>09:46</h><w>Petrus Theron</w>Can Specter emit reductions over a lensed collection? E.g. <code>(something-specter [ALL :amount (reducer +)] [{:amount 10.0M} {:amount 20.0M} ...]) =&gt; [{:amount 10.0M} {:amount 30.0M} ...]</code></z><z id="t1566467224" t="Petrus Theron E.g. w/o Specter: (reductions (fn [[latest acc] [when amount]] [when (+ acc amount)]) [0 0.0M] (zipmap (range 10) (range 10))) =&gt; ([0 0.0M] [0 0.0M] [7 7.0M] [1 8.0M] [4 12.0M] [6 18.0M] [3 21.0M] [2 23.0M] [9 32.0M] [5 37.0M] [8 45.0M]) "><y>#</y><d>2019-08-22</d><h>09:47</h><w>Petrus Theron</w>E.g. w/o Specter:
<pre>(reductions
    (fn [[latest acc] [when amount]]
      [when (+ acc amount)])
    [0 0.0M]
    (zipmap (range 10) (range 10)))
=&gt; ([0 0.0M] [0 0.0M] [7 7.0M] [1 8.0M] [4 12.0M] [6 18.0M] [3 21.0M] [2 23.0M] [9 32.0M] [5 37.0M] [8 45.0M])
</pre></z><z id="t1566474904" t="lxsli @petrus Could traversed be what you&apos;re after?"><y>#</y><d>2019-08-22</d><h>11:55</h><w>lxsli</w>@petrus Could <code>traversed</code> be what you&apos;re after?</z><z id="t1566477572" t="Petrus Theron Thanks @U9MDWLP5Y traversed looks like it might work 🙂 (select-any (traversed ALL +) [1 2 3 4])"><y>#</y><d>2019-08-22</d><h>12:39</h><r>Petrus Theron</r>Thanks @U9MDWLP5Y <code>traversed</code> looks like it might work <b>🙂</b> <code>(select-any (traversed ALL +) [1 2 3 4])</code></z><z id="t1566474945" t="lxsli Alternatively you might get mileage out of collect"><y>#</y><d>2019-08-22</d><h>11:55</h><w>lxsli</w>Alternatively you might get mileage out of <code>collect</code></z><z id="t1566474967" t="lxsli Not an expert myself so no promises"><y>#</y><d>2019-08-22</d><h>11:56</h><w>lxsli</w>Not an expert myself so no promises</z><z id="t1567103740" t="jvtrigueros I&apos;m trying to use specter to help me generate a map structure that can be converted to an XML string using clojure.data.xml . With a map function, I can do this: (mapv (fn [[k v]] {:tag k :content [v]}) {:A 1 :B 2 :C 3}) ;; =&gt; [{:tag :A, :content [1]} {:tag :B, :content [2]} {:tag :C, :content [3]}] I tried to do something similar with transform : (r/transform r/ALL (fn [[k v]] {:tag k :content [v]}) {:A 1 :B 2 :C 3}) ;; Execution error (UnsupportedOperationException) at com.rpl.specter.navs/eval18222$fn (navs.cljc:124). nth not supported on this type: PersistentArrayMap I don&apos;t understand the error that specter is giving me. Is it possible to do what I want to do with specter?"><y>#</y><d>2019-08-29</d><h>18:35</h><w>jvtrigueros</w>I&apos;m trying to use specter to help me generate a map structure that can be converted to an XML string using <code>clojure.data.xml</code>. With a map function, I can do this:
<pre>(mapv (fn [[k v]] {:tag k :content [v]})
      {:A 1
       :B 2
       :C 3})
;; =&gt; [{:tag :A, :content [1]} {:tag :B, :content [2]} {:tag :C, :content [3]}]
</pre>
I tried to do something similar with <code>transform</code>:
<pre>(r/transform
  r/ALL
  (fn [[k v]] {:tag k :content [v]})
  {:A 1
   :B 2
   :C 3})
;; Execution error (UnsupportedOperationException) at com.rpl.specter.navs/eval18222$fn (navs.cljc:124).
nth not supported on this type: PersistentArrayMap
</pre>
I don&apos;t understand the error that specter is giving me. Is it possible to do what I want to do with specter?</z><z id="t1567107553" t="nathanmarz @jvtrigueros transform replaces navigated vals and otherwise leaves the structure the same"><y>#</y><d>2019-08-29</d><h>19:39</h><w>nathanmarz</w>@jvtrigueros transform replaces navigated vals and otherwise leaves the structure the same</z><z id="t1567107575" t="nathanmarz since you are navigating to key/value pairs, it&apos;s expecting you to replace the key/value pairs with key/value pairs"><y>#</y><d>2019-08-29</d><h>19:39</h><w>nathanmarz</w>since you are navigating to key/value pairs, it&apos;s expecting you to replace the key/value pairs with key/value pairs</z><z id="t1567107583" t="jvtrigueros I see"><y>#</y><d>2019-08-29</d><h>19:39</h><w>jvtrigueros</w>I see</z><z id="t1567107599" t="nathanmarz for this particular use case specter isn&apos;t really relevant"><y>#</y><d>2019-08-29</d><h>19:39</h><w>nathanmarz</w>for this particular use case specter isn&apos;t really relevant</z><z id="t1567107775" t="jvtrigueros I understand, I&apos;m using specter to select values in a deeply nested XML tree which worked great. I was trying to use it to generate the XML map datastructure as well. I can simply do the mapv operation as the input map is fairly flat."><y>#</y><d>2019-08-29</d><h>19:42</h><w>jvtrigueros</w>I understand, I&apos;m using specter to select values in a deeply nested XML tree which worked great. I was trying to use it to generate the XML map datastructure as well.

I can simply do the <code>mapv</code> operation as the input map is fairly flat.</z><z id="t1571957952" t="Ani Banerjee Does specter work with integer valued keys in int-map? Any issues to expect compared to keyword based maps?"><y>#</y><d>2019-10-24</d><h>22:59</h><w>Ani Banerjee</w>Does specter work with integer valued keys in int-map? Any issues to expect compared to keyword based maps?</z><z id="t1571958082" t="Ani Banerjee More context: I have a map of entities, which are all indexed by an integer id. The value is a map with attributes {1 {:name &quot;foo&quot; :type &quot;a&quot;} 2 {:name &quot;bar&quot; :type &quot;b&quot;}}"><y>#</y><d>2019-10-24</d><h>23:01</h><w>Ani Banerjee</w>More context: I have a map of entities, which are all indexed by an integer id. The value is a map with attributes
<pre>{1 {:name &quot;foo&quot; :type &quot;a&quot;} 
  2 {:name &quot;bar&quot; :type &quot;b&quot;}}</pre></z><z id="t1571970941" t="nathanmarz @eerjree yes, it works fine"><y>#</y><d>2019-10-25</d><h>02:35</h><w>nathanmarz</w>@eerjree yes, it works fine</z><z id="t1572111423" t="Trevor Hi folks, what would be the best way to change this: [ {:name &quot;a&quot; :args [1 2 3]} {:name &quot;a&quot; :args [5 6 7]} {:name &quot;b&quot; :args [1]} ] into this: { :name &quot;a&quot; :arg-list [ [1 2 3] [5 6 7]] :name &quot;b&quot; :arg-list [[1]] } I want to take a vector of maps which have a bunch of duplicate :name values with different vectors of :args and map the :names to a vector of vectors of their args. I&apos;m using Spectre for most of the json transformations, but I&apos;m new to clojure and this transformation is non-obvious to me."><y>#</y><d>2019-10-26</d><h>17:37</h><w>Trevor</w>Hi folks, what would be the best way to change this:

<pre>[
{:name &quot;a&quot; :args [1 2 3]}
{:name &quot;a&quot; :args [5 6 7]}
{:name &quot;b&quot; :args [1]}
]
</pre>

into this:
<pre>{
:name &quot;a&quot; :arg-list [ [1 2 3] [5 6 7]]
:name &quot;b&quot; :arg-list [[1]]
}
</pre>

I want to take a vector of maps which have a bunch of duplicate <code>:name</code> values with different vectors of <code>:args</code> and map the <code>:names</code> to a vector of vectors of their args.

I&apos;m using Spectre for most of the json transformations, but I&apos;m new to clojure and this transformation is non-obvious to me.</z><z id="t1572183964" t="nathanmarz @trevor670 that&apos;s best done with a reduce"><y>#</y><d>2019-10-27</d><h>13:46</h><w>nathanmarz</w>@trevor670 that&apos;s best done with a reduce</z><z id="t1572183972" t="nathanmarz specter can help with the reducing function"><y>#</y><d>2019-10-27</d><h>13:46</h><w>nathanmarz</w>specter can help with the reducing function</z><z id="t1572183974" t="nathanmarz (reduce (fn [res m] (setval [(keypath (:name m)) :args-list NIL-&gt;VECTOR AFTER-ELEM] (:args m) res)) {} data) "><y>#</y><d>2019-10-27</d><h>13:46</h><w>nathanmarz</w><pre>(reduce
 (fn [res m]
  (setval [(keypath (:name m))
           :args-list
           NIL-&gt;VECTOR
           AFTER-ELEM]
    (:args m)
    res))
  {}
  data)
</pre></z><z id="t1572208554" t="Trevor Thanks @nathanmarz! I&apos;m really new to clojure and found it so surprising that (map fn coll) doesnt preserve the original map! changes vectors to lists and lazy sequences! Very confusing for a beginner! While it might lead to some gaps in understanding idiomatic clojure, I&apos;ve been finding spectre a lot easier to read and understand (from the perspective of a new learner) and things behave how I would expect them too! Thanks for making Spectre!"><y>#</y><d>2019-10-27</d><h>20:35</h><w>Trevor</w>Thanks @nathanmarz! I&apos;m really new to clojure and found it so surprising that (map fn coll) doesnt preserve the original map! changes vectors to lists and lazy sequences! Very confusing for a beginner! While it might lead to some gaps in understanding idiomatic clojure, I&apos;ve been finding spectre a lot easier to read and understand (from the perspective of a new learner) and things behave how I would expect them too! Thanks for making Spectre!</z><z id="t1572216544" t="sogaiu @trevor670 fwiw, i also experienced confusion initially, but once i focused on the distinction between collections and sequences, things started to make a lot more sense to me."><y>#</y><d>2019-10-27</d><h>22:49</h><w>sogaiu</w>@trevor670 fwiw, i also experienced confusion initially, but once i focused on the distinction between collections and sequences, things started to make a lot more sense to me.</z><z id="t1572221217" t="Trevor Interesting, I&apos;ll keep that in mind!"><y>#</y><d>2019-10-28</d><h>00:06</h><r>Trevor</r>Interesting, I&apos;ll keep that in mind!</z><z id="t1572217768" t="Ani Banerjee @nathanmarz Need some help with a recursive query: I have a map of maps which which stores top-level entities and entity details: (def process-db {:process {:p1 {:name &quot;P1&quot;} :p2 {:name &quot;P2&quot;}} :process-flow {:pf1 {:process_id :p1} :pf2 {:process_id :p2}}}) I want to get the process :name navigating from a process-flow-id. (select [:process-flow MAP-VALS :process_id] process-db) =&gt; [:p1 :p2] How do I write a select query that &quot;loops back&quot; to process-db, and does a lookup on [:process MAP-VALS :name]"><y>#</y><d>2019-10-27</d><h>23:09</h><w>Ani Banerjee</w>@nathanmarz Need some help with a recursive query: I have a map of maps which which stores top-level entities and entity details:
<pre>(def process-db {:process {:p1 {:name &quot;P1&quot;} :p2 {:name &quot;P2&quot;}}
                 :process-flow {:pf1 {:process_id :p1} :pf2 {:process_id :p2}}})
</pre>
I want to get the process :name navigating from a process-flow-id.
<pre>(select [:process-flow MAP-VALS :process_id] process-db)
=&gt; [:p1 :p2]
</pre>
How do I write a select query that &quot;loops back&quot; to process-db, and does a lookup on <pre>[:process MAP-VALS :name]</pre></z><z id="t1574196048" t="mikerod When navigating within a structure is there any way to get access to the “current path” you are navigated to?"><y>#</y><d>2019-11-19</d><h>20:40</h><w>mikerod</w>When navigating within a structure is there any way to get access to the “current path” you are navigated to?</z><z id="t1574196063" t="mikerod I’ve found plenty of sort of related topics, but nothing I’m sure is the same thing I’m looking for"><y>#</y><d>2019-11-19</d><h>20:41</h><w>mikerod</w>I’ve found plenty of sort of related topics, but nothing I’m sure is the same thing I’m looking for</z><z id="t1574196166" t="nathanmarz no, that&apos;s currently not possible"><y>#</y><d>2019-11-19</d><h>20:42</h><w>nathanmarz</w>no, that&apos;s currently not possible</z><z id="t1574196196" t="mikerod thanks, that’s what I was thinking based on related issues I have found"><y>#</y><d>2019-11-19</d><h>20:43</h><w>mikerod</w>thanks, that’s what I was thinking based on related issues I have found</z><z id="t1574694992" t="wegi Hi, when I use specter in emacs with the cider-repl all macros like transform and select are marked as &quot;unable to resolve symbol&quot;. I used :refer :all in the require call. It works when i evaluate it, but the lines with the functions are still marked by cider."><y>#</y><d>2019-11-25</d><h>15:16</h><w>wegi</w>Hi, when I use specter in emacs with the cider-repl all macros like transform and select are marked as &quot;unable to resolve symbol&quot;. I used :refer :all in the require call. It works when i evaluate it, but the lines with the functions are still marked by cider.</z><z id="t1574694999" t="wegi Maybe somebody else had the same problem."><y>#</y><d>2019-11-25</d><h>15:16</h><w>wegi</w>Maybe somebody else had the same problem.</z><z id="t1574783206" t="jsa-aerial Never had any problem like that. I never :refer :all always use :as sp for the require so don&apos;t know if that is the issue"><y>#</y><d>2019-11-26</d><h>15:46</h><w>jsa-aerial</w>Never had any problem like that.  I never <code>:refer :all</code>  always use <code>:as sp</code> for the require so don&apos;t know if that is the issue</z><z id="t1575283969" t="lxsli I have a similar issue with clojure-lsp in vim because many of Specter&apos;s macros are defined with macros. Not a Specter issue but tooling."><y>#</y><d>2019-12-02</d><h>10:52</h><w>lxsli</w>I have a similar issue with clojure-lsp in vim because many of Specter&apos;s macros are defined with macros. Not a Specter issue but tooling.</z><z id="t1575283988" t="lxsli @wegi"><y>#</y><d>2019-12-02</d><h>10:53</h><w>lxsli</w>@wegi</z><z id="t1575284463" t="wegi Jeah thanks. Figured as much. If you use emacs you can define the known macros in the.jokerrc"><y>#</y><d>2019-12-02</d><h>11:01</h><w>wegi</w>Jeah thanks. Figured as much. If you use emacs you can define the known macros in the.jokerrc</z><z id="t1576678105" t="roklenarcic hm here;’s a question, let’s say you have a predicate that will, given 2 values (key and value) tell you if you need to remove this map entry, how would you transform a map to drop those entries"><y>#</y><d>2019-12-18</d><h>14:08</h><w>roklenarcic</w>hm here;’s a question, let’s say you have a predicate that will, given 2 values (key and value) tell you if you need to remove this map entry, how would you transform a map to drop those entries</z><z id="t1576678130" t="roklenarcic I tried ` [(collect-one MAP-KEYS) MAP-VALS] "><y>#</y><d>2019-12-18</d><h>14:08</h><w>roklenarcic</w>I tried `
<pre>[(collect-one MAP-KEYS) MAP-VALS]</pre>
</z><z id="t1576678158" t="roklenarcic but that doesn’t work since collect-one’s select must return a single value"><y>#</y><d>2019-12-18</d><h>14:09</h><w>roklenarcic</w>but that doesn’t work since collect-one’s select must return a single value</z><z id="t1576705909" t="nathanmarz @roklenarcic the pattern for that is (setval [ALL (fn [[k v]] ...)] NONE my-map)"><y>#</y><d>2019-12-18</d><h>21:51</h><w>nathanmarz</w>@roklenarcic the pattern for that is <code>(setval [ALL (fn [[k v]] ...)] NONE my-map)</code></z><z id="t1576706474" t="roklenarcic so any function can act as predicate in path? What’s the difference between that and using pred"><y>#</y><d>2019-12-18</d><h>22:01</h><w>roklenarcic</w>so any function can act as predicate in path? What’s the difference between that and using <code>pred</code></z><z id="t1576706629" t="nathanmarz a function in a path implicitly uses pred"><y>#</y><d>2019-12-18</d><h>22:03</h><w>nathanmarz</w>a function in a path implicitly uses <code>pred</code></z><z id="t1576706647" t="nathanmarz you can use pred manually for something like (pred :a)"><y>#</y><d>2019-12-18</d><h>22:04</h><w>nathanmarz</w>you can use <code>pred</code> manually for something like <code>(pred :a)</code></z><z id="t1576706679" t="nathanmarz :a by itself would navigate to :a , whereas (pred :a) would filter based on the value of :a"><y>#</y><d>2019-12-18</d><h>22:04</h><w>nathanmarz</w><code>:a</code> by itself would navigate to <code>:a</code>, whereas <code>(pred :a)</code> would filter based on the value of <code>:a</code></z><z id="t1576712055" t="roklenarcic ok thank you"><y>#</y><d>2019-12-18</d><h>23:34</h><w>roklenarcic</w>ok thank you</z><z id="t1576764964" t="donavan Has a form of collection that collects into a map been considered?"><y>#</y><d>2019-12-19</d><h>14:16</h><w>donavan</w>Has a form of collection that collects into a map been considered?</z><z id="t1576771147" t="nathanmarz @donavan I&apos;ve thought about that a little, but it would complicate the API and I don&apos;t really have any use cases for it"><y>#</y><d>2019-12-19</d><h>15:59</h><w>nathanmarz</w>@donavan I&apos;ve thought about that a little, but it would complicate the API and I don&apos;t really have any use cases for it</z><z id="t1576774670" t="donavan Good points. The only cases where I have wanted it are covered by with-fresh-collected I guess."><y>#</y><d>2019-12-19</d><h>16:57</h><r>donavan</r>Good points. The only cases where I have wanted it are covered by <code>with-fresh-collected</code> I guess.</z><z id="t1577824051" t="donavan This question https://github.com/redplanetlabs/specter/issues/287 got me thinking about how to solve the problem in the general case and I thought it would be nice to have a subselect like nav that allowed transformation to multiple values like srange. While this implementation is broken it better illustrates what I mean: (sp/defdynamicnav seqsubselect [&amp; path] (sp/late-bound-nav [late (sp/late-path path)] (select* [this structure next-fn] (next-fn (sp/compiled-select late structure))) (transform* [this structure next-fn] (let [select-result (sp/compiled-select late structure)] (reduce (fn [structure s] (i/srange-transform* structure s (inc s) next-fn)) structure (map #(.indexOf structure %) (reverse select-result))))))) (sp/transform [(seqsubselect [sp/ALL vector?])] (fn [structure] (mapcat (fn [x] (concat (filter odd? x) [(into [] (filter even? x))])) structure)) [:a [2 4 6] :b [5 6 7 8] :c [3 5 7] :d [1 2 3 4]]) ;; =&gt; [:a [2 4 6] :b 5 7 [6 8] :c 3 5 7 [] :d 1 3 [2 4]]"><y>#</y><d>2020-12-31</d><h>20:27</h><w>donavan</w>This question <a href="https://github.com/redplanetlabs/specter/issues/287" target="_blank">https://github.com/redplanetlabs/specter/issues/287</a> got me thinking about how to solve the problem in the general case and I thought it would be nice to have a subselect like nav that allowed transformation to multiple values like srange. While this implementation is broken it better illustrates what I mean:

<pre>(sp/defdynamicnav seqsubselect
  [&amp; path]
  (sp/late-bound-nav
   [late (sp/late-path path)]

   (select*
    [this structure next-fn]
    (next-fn (sp/compiled-select late structure)))

   (transform*
    [this structure next-fn]
    (let [select-result (sp/compiled-select late structure)]
      (reduce
       (fn [structure s]
         (i/srange-transform* structure s (inc s) next-fn))
       structure
       (map #(.indexOf structure %) (reverse select-result)))))))

(sp/transform
 [(seqsubselect
   [sp/ALL
    vector?])]
 (fn [structure]
   (mapcat
    (fn [x]
      (concat
       (filter odd? x)
       [(into [] (filter even? x))]))
    structure))
 [:a [2 4 6] :b [5 6 7 8] :c [3 5 7] :d [1 2 3 4]])

;; =&gt; [:a [2 4 6] :b 5 7 [6 8] :c 3 5 7 [] :d 1 3 [2 4]]</pre></z><z id="t1579548520" t="theeternalpulse Is there a general naming pattern for paths. For example I have this recursive path function (defn node-finder &quot;Generates a recursive-path finder that visits matching `pred-fn`&quot; [pred-fn] (recursive-path [] p (specter/cond-path pred-fn STAY map? [MAP-VALS p] vector? [ALL p]))) That generates a path that finds a key-value that matches a certain pattern. I&apos;m thinking node-finder should be node-path, should then the result be bound to something like FUNCTION-VALUE or FUNCTION-PATH? I&apos;m guessing the former seems more consistent with the naming of the core paths."><y>#</y><d>2020-01-20</d><h>19:28</h><w>theeternalpulse</w>Is there a general naming pattern for paths.  For example I have this recursive path function
<pre>(defn node-finder
  &quot;Generates a recursive-path finder that visits
  matching `pred-fn`&quot;
  [pred-fn]
  (recursive-path
    [] p
    (specter/cond-path
      pred-fn STAY
      map? [MAP-VALS p]
      vector? [ALL p])))</pre>
That generates a path that finds a key-value that matches a certain pattern.  I&apos;m thinking node-finder should be node-path, should then the result be bound to something like FUNCTION-VALUE or FUNCTION-PATH?  I&apos;m guessing the former seems more consistent with the naming of the core paths.</z><z id="t1579552158" t="nathanmarz I would call something like that matching-nodes"><y>#</y><d>2020-01-20</d><h>20:29</h><w>nathanmarz</w>I would call something like that <code>matching-nodes</code></z><z id="t1579574035" t="theeternalpulse the function or the bound resulting path"><y>#</y><d>2020-01-21</d><h>02:33</h><w>theeternalpulse</w>the function or the bound resulting path</z><z id="t1579612407" t="nathanmarz the function"><y>#</y><d>2020-01-21</d><h>13:13</h><w>nathanmarz</w>the function</z><z id="t1579612435" t="nathanmarz so it reads like (select [ALL (matching-nodes even?)] data)"><y>#</y><d>2020-01-21</d><h>13:13</h><w>nathanmarz</w>so it reads like <code>(select [ALL (matching-nodes even?)] data)</code></z><z id="t1579642616" t="theeternalpulse ah, great idea."><y>#</y><d>2020-01-21</d><h>21:36</h><w>theeternalpulse</w>ah, great idea.</z><z id="t1579862702" t="akond the documentation says i can have additional params to declarepath , but i can only see declarepath with only one param."><y>#</y><d>2020-01-24</d><h>10:45</h><w>akond</w>the documentation says i can have additional params to <code>declarepath</code>, but i can only see declarepath with only one param.</z><z id="t1579862730" t="akond (defmacro declarepath [name] `(def ~name (i/local-declarepath))) where is the other one?"><y>#</y><d>2020-01-24</d><h>10:45</h><w>akond</w><pre>(defmacro declarepath [name]
  `(def ~name (i/local-declarepath)))</pre>
where is the other one?</z><z id="t1579888622" t="nathanmarz @akond that wiki page was out of date"><y>#</y><d>2020-01-24</d><h>17:57</h><w>nathanmarz</w>@akond that wiki page was out of date</z><z id="t1579888631" t="nathanmarz those params are unnecessary now"><y>#</y><d>2020-01-24</d><h>17:57</h><w>nathanmarz</w>those params are unnecessary now</z><z id="t1580022394" t="akond @nathanmarz understood. is it possible then to create a parametrized navigator for say something like [:rations s/ALL (fn-&gt; :id (= id)) :day-rations] so that it looks like [(new-nav id)] instead?"><y>#</y><d>2020-01-26</d><h>07:06</h><w>akond</w>@nathanmarz understood. is it possible then to create a parametrized navigator for say something like <code>[:rations s/ALL (fn-&gt; :id (= id)) :day-rations]</code> so that it looks like <code>[(new-nav id)]</code> instead?</z><z id="t1580055545" t="nathanmarz sure"><y>#</y><d>2020-01-26</d><h>16:19</h><w>nathanmarz</w>sure</z><z id="t1580055551" t="nathanmarz (defn new-nav [id] (path :rations s/ALL (fn-&gt; :id (= id)) :day-rations))"><y>#</y><d>2020-01-26</d><h>16:19</h><w>nathanmarz</w><pre>(defn new-nav [id]
  (path :rations s/ALL (fn-&gt; :id (= id)) :day-rations))</pre></z><z id="t1580122051" t="akond thank you very much. i see that path is also undocumented."><y>#</y><d>2020-01-27</d><h>10:47</h><w>akond</w>thank you very much. i see that <code>path</code> is also undocumented.</z><z id="t1580405973" t="joshkh is this an okay place to ask for help with an example? i have a simple tree, and i would like to collect a value from each parent and combine it with a value on its direct descendants. for example: (def tree {:id 1 :value &quot;one&quot; :children [{:id 2 :value &quot;two&quot;} {:id 3 :value &quot;three&quot; :children [{:id 4 :value &quot;four&quot;}]}]}) where after a transformation, each child gets a :parent+myvalue key which is equal to (str (:value parent) (:value self)) (s/transform [...path] xfn tree) {:id 1 :value &quot;one&quot; :children [{:id 2 :value &quot;two&quot; :parent+myvalue &quot;onetwo&quot;} {:id 3 :value &quot;three&quot; :parent+myvalue &quot;onethree&quot; :children [{:id 4 :value &quot;four&quot; :parent+myvalue &quot;threefour&quot;}]}]} is Specter well suited for this, or should i just use core walk functions?"><y>#</y><d>2020-01-30</d><h>17:39</h><w>joshkh</w>is this an okay place to ask for help with an example? i have a simple tree, and i would like to collect a value from each parent and combine it with a value on its direct descendants. for example:
<pre>(def tree {:id       1
           :value    &quot;one&quot;
           :children [{:id    2
                       :value &quot;two&quot;}
                      {:id       3
                       :value    &quot;three&quot;
                       :children [{:id    4
                                   :value &quot;four&quot;}]}]})</pre>
where after a transformation, each child gets a <code>:parent+myvalue</code> key which is equal to <code>(str (:value parent) (:value self))</code>
<pre>(s/transform [...path] xfn tree)

{:id       1
 :value    &quot;one&quot;
 :children [{:id             2
             :value          &quot;two&quot;
             :parent+myvalue &quot;onetwo&quot;}
            {:id             3
             :value          &quot;three&quot;
             :parent+myvalue &quot;onethree&quot;
             :children       [{:id             4
                               :value          &quot;four&quot;
                               :parent+myvalue &quot;threefour&quot;}]}]}</pre>
is Specter well suited for this, or should i just use core walk functions?</z><z id="t1580406110" t="joshkh i suspect s/collect comes into play"><y>#</y><d>2020-01-30</d><h>17:41</h><w>joshkh</w>i suspect <code>s/collect</code> comes into play</z><z id="t1580407970" t="nathanmarz @joshkh this is the kind of stuff specter is very good at"><y>#</y><d>2020-01-30</d><h>18:12</h><w>nathanmarz</w>@joshkh this is the kind of stuff specter is very good at</z><z id="t1580407979" t="nathanmarz (def CHILDREN (path (must :children) ALL)) (def VALUE+CHILDREN (path (collect-one :value) CHILDREN)) (def WALKER (recursive-path [] p (continue-then-stay DISPENSE VALUE+CHILDREN ))) (transform [VALUE+CHILDREN WALKER (collect-one :value) :parent+myvalue] (fn [parent-value my-value _] (str parent-value my-value)) tree)"><y>#</y><d>2020-01-30</d><h>18:12</h><w>nathanmarz</w><pre>(def CHILDREN (path (must :children) ALL))
(def VALUE+CHILDREN (path (collect-one :value) CHILDREN))

(def WALKER
  (recursive-path [] p
    (continue-then-stay
      DISPENSE
      VALUE+CHILDREN
      )))

(transform [VALUE+CHILDREN WALKER (collect-one :value) :parent+myvalue]
  (fn [parent-value my-value _]
    (str parent-value my-value))
  tree)</pre></z><z id="t1580407986" t="nathanmarz that&apos;s one way to solve it"><y>#</y><d>2020-01-30</d><h>18:13</h><w>nathanmarz</w>that&apos;s one way to solve it</z><z id="t1580408107" t="joshkh aha, thanks for the working example. i always come back to specter after just long enough away to forget its paradigms 🙂"><y>#</y><d>2020-01-30</d><h>18:15</h><w>joshkh</w>aha, thanks for the working example. i always come back to specter after just long enough away to forget its paradigms <b>🙂</b></z><z id="t1580846820" t="richiardiandrea Hi specter folks it&apos;s been a while and I am rusty 😄 How do I navigate to all the vectors and makes sure that if they have only one element I unwrap it?"><y>#</y><d>2020-02-04</d><h>20:07</h><w>richiardiandrea</w>Hi specter folks it&apos;s been a while and I am rusty <b>😄</b>

How do I navigate to all the vectors and makes sure that if they have only one element I unwrap it?</z><z id="t1580846847" t="richiardiandrea so from (xf/one-item-vector-&gt;map {:data {:a [1 2 3] :b [{:foo :bar}]}}) to (xf/one-item-vector-&gt;map {:data {:a [1 2 3] :b {:foo :bar}}})"><y>#</y><d>2020-02-04</d><h>20:07</h><w>richiardiandrea</w>so from
<pre>(xf/one-item-vector-&gt;map {:data {:a [1 2 3] :b [{:foo :bar}]}})</pre>
to
<pre>(xf/one-item-vector-&gt;map {:data {:a [1 2 3] :b {:foo :bar}}})</pre></z><z id="t1580847193" t="richiardiandrea I think I am kind of missing how to drill down any map of maps"><y>#</y><d>2020-02-04</d><h>20:13</h><w>richiardiandrea</w>I think I am kind of missing how to drill down any map of maps</z><z id="t1580847200" t="richiardiandrea like in clojure.walk"><y>#</y><d>2020-02-04</d><h>20:13</h><w>richiardiandrea</w>like in <code>clojure.walk</code></z><z id="t1580885902" t="akond (let [data {:data {:a [1 2 3] :b [{:foo :bar}]}}] (is (= (s/transform (s/walker (every-pred vector? (fn-&gt; count (= 1)) )) first data) {:data {:a [1 2 3] :b {:foo :bar}}}))) "><y>#</y><d>2020-02-05</d><h>06:58</h><w>akond</w><pre>(let [data {:data {:a [1 2 3] :b [{:foo :bar}]}}]
 (is (= (s/transform (s/walker (every-pred vector? (fn-&gt; count (= 1)) )) first data)
      {:data {:a [1 2 3] :b {:foo :bar}}})))</pre>
</z><z id="t1581225469" t="richiardiandrea thanks a lot for answering!"><y>#</y><d>2020-02-09</d><h>05:17</h><r>richiardiandrea</r>thanks a lot for answering!</z><z id="t1580942365" t="steveb8n @akond thanks, I learned from that example too. a couple of questions: 1/ which lib does fn-&gt; come from? 2/ the docs for walker imply it stops navigation when the predicate is satisfied once but, when I add another match, it transforms that too. this is what I want but it seems to contradict the docstring. what am I missing?"><y>#</y><d>2020-02-05</d><h>22:39</h><w>steveb8n</w>@akond thanks, I learned from that example too. a couple of questions: 1/ which lib does fn-&gt; come from? 2/ the docs for walker imply it stops navigation when the predicate is satisfied once but, when I add another match, it transforms that too. this is what I want but it seems to contradict the docstring. what am I missing?</z><z id="t1580970334" t="akond fn-&gt; comes from plumbing: https://plumatic.github.io/plumbing/plumbing.core.html#var-fn-.3E"><y>#</y><d>2020-02-06</d><h>06:25</h><r>akond</r>fn-&gt; comes from plumbing: <a href="https://plumatic.github.io/plumbing/plumbing.core.html#var-fn-.3E" target="_blank">https://plumatic.github.io/plumbing/plumbing.core.html#var-fn-.3E</a></z><z id="t1580970378" t="akond docs might be not up to date"><y>#</y><d>2020-02-06</d><h>06:26</h><r>akond</r>docs might be not up to date</z><z id="t1582456257" t="jimi Can someone help me translates this function into a specter one? (defn get-component! [system component-key] (or (get system component-key) (-&gt;&gt; system (filter (fn [[current-key]] (and (vector? current-key) (= 2 (count current-key)) (= component-key (second current-key))))) (map val) (first)) (throw (ex-info &quot;missing component&quot; {:tag ::get-component! :component component-key}))))"><y>#</y><d>2020-02-23</d><h>11:10</h><w>jimi</w>Can someone help me translates this function into a specter one?
<pre>(defn get-component!
  [system component-key]
  (or (get system component-key)
      (-&gt;&gt; system
           (filter (fn [[current-key]]
                     (and (vector? current-key)
                          (= 2 (count current-key))
                          (= component-key (second current-key)))))
           (map val)
           (first))
      (throw (ex-info &quot;missing component&quot; {:tag ::get-component!
                                           :component component-key}))))</pre></z><z id="t1584487928" t="aengelberg Is there a navigator that navigates to the singleton subsequence containing each element of a collection? This would give the transformer the opportunity to turn one element into many elements, and “splice” them back into the parent collection."><y>#</y><d>2020-03-17</d><h>23:32</h><w>aengelberg</w>Is there a navigator that navigates to the singleton subsequence containing each element of a collection? This would give the transformer the opportunity to turn one element into many elements, and “splice” them back into the parent collection.</z><z id="t1584487971" t="aengelberg in other words, it would navigate to (srange 0 1) , then (srange 1 2) , etc"><y>#</y><d>2020-03-17</d><h>23:32</h><w>aengelberg</w>in other words, it would navigate to <code>(srange 0 1)</code>, then <code>(srange 1 2)</code>, etc</z><z id="t1584488344" t="aengelberg continuous-subseqs is close to what I want, but I want the subseqs to not be continuous"><y>#</y><d>2020-03-17</d><h>23:39</h><w>aengelberg</w><code>continuous-subseqs</code> is close to what I want, but I want the subseqs to not be continuous</z><z id="t1584517205" t="nathanmarz @aengelberg this issue would let you do that with continuous-subseqs https://github.com/redplanetlabs/specter/issues/236"><y>#</y><d>2020-03-18</d><h>07:40</h><w>nathanmarz</w>@aengelberg this issue would let you do that with <code>continuous-subseqs</code> <a href="https://github.com/redplanetlabs/specter/issues/236" target="_blank">https://github.com/redplanetlabs/specter/issues/236</a></z><z id="t1584517215" t="nathanmarz otherwise you&apos;d have to write a custom navigator"><y>#</y><d>2020-03-18</d><h>07:40</h><w>nathanmarz</w>otherwise you&apos;d have to write a custom navigator</z><z id="t1586133881" t="stuartrexking When navigating how do you ignore the first element? I&apos;m transforming a CSV and I want to ignore the header line."><y>#</y><d>2020-04-06</d><h>00:44</h><w>stuartrexking</w>When navigating how do you ignore the first element? I&apos;m transforming a CSV and I want to ignore the header line.</z><z id="t1586153943" t="stuartrexking Answered here https://github.com/redplanetlabs/specter/issues/288#issuecomment-609547864"><y>#</y><d>2020-04-06</d><h>06:19</h><w>stuartrexking</w>Answered here <a href="https://github.com/redplanetlabs/specter/issues/288#issuecomment-609547864" target="_blank">https://github.com/redplanetlabs/specter/issues/288#issuecomment-609547864</a></z><z id="t1586268926" t="narkisr Hi Specter team I&apos;m looking for a way to collect values in a multi-path: (select [MAP-VALS ATOM (multi-path MAP-KEYS [MAP-VALS MAP-VALS :ttl])] results) I&apos;m getting back: [&quot;4fcb9fdd4ef847aa9b0a906e3effcf3b&quot; 1586267405166 1586267416251 &quot;31a915847bff41a788c1c34521ffe7a9&quot; 1586265826511 &quot;5a6c3fc3a587437baf497f9c80c858ca&quot; 1586266864089 1586266891300] And id like to group the [MAP-VALS MAP-VALS :ttl] into a vector: [&quot;4fcb9fdd4ef847aa9b0a906e3effcf3b&quot; [1586267405166 1586267416251] &quot;31a915847bff41a788c1c34521ffe7a9&quot; [1586265826511] &quot;5a6c3fc3a587437baf497f9c80c858ca&quot; [1586266864089 1586266891300]] This is probably simple but using collect/VAL etc didn&apos;t work, what am I missing? 🙂"><y>#</y><d>2020-04-07</d><h>14:15</h><w>narkisr</w>Hi Specter team I&apos;m looking for a way to collect values in a multi-path:

<pre>(select [MAP-VALS ATOM (multi-path MAP-KEYS [MAP-VALS MAP-VALS :ttl])] results)      </pre>
I&apos;m getting back:

<pre>[&quot;4fcb9fdd4ef847aa9b0a906e3effcf3b&quot;                                                                             
 1586267405166
 1586267416251
 &quot;31a915847bff41a788c1c34521ffe7a9&quot;
 1586265826511
 &quot;5a6c3fc3a587437baf497f9c80c858ca&quot;
 1586266864089
 1586266891300]</pre>
And id like to group the [MAP-VALS MAP-VALS :ttl] into a vector:

<pre>[&quot;4fcb9fdd4ef847aa9b0a906e3effcf3b&quot;                                                                             
 [1586267405166 1586267416251]
 &quot;31a915847bff41a788c1c34521ffe7a9&quot;
 [1586265826511]
 &quot;5a6c3fc3a587437baf497f9c80c858ca&quot;
 [1586266864089 1586266891300]]</pre>
This is probably simple but using collect/VAL etc didn&apos;t work, what am I missing? <b>🙂</b></z><z id="t1586289018" t="nathanmarz @narkisr you can use subselect"><y>#</y><d>2020-04-07</d><h>19:50</h><w>nathanmarz</w>@narkisr you can use <code>subselect</code></z><z id="t1586358482" t="narkisr That worked thank you @nathanmarz"><y>#</y><d>2020-04-08</d><h>15:08</h><w>narkisr</w>That worked thank you @nathanmarz</z><z id="t1586359455" t="thom What&apos;s an efficient way to find a value that comes after (in a vector) something matched by a walker ? Should I just be matching one level up instead? For example, in [:foo [:bar [:arbitrarily-nested-stuff [:baz 42]]] if I was interested in the value 42 next to that deeply nested :baz?"><y>#</y><d>2020-04-08</d><h>15:24</h><w>thom</w>What&apos;s an efficient way to find a value that comes after (in a vector) something matched by a <code>walker</code>? Should I just be matching one level up instead? For example, in <code>[:foo [:bar [:arbitrarily-nested-stuff [:baz 42]]]</code> if I was interested in the value 42 next to that deeply nested :baz?</z><z id="t1586364754" t="nathanmarz @thom704 yea, you would want to match one level higher"><y>#</y><d>2020-04-08</d><h>16:52</h><w>nathanmarz</w>@thom704 yea, you would want to match one level higher</z><z id="t1586364811" t="thom I think I had a slightly wrong-headed zippers way of thinking about it where I could get to somewhere and then just navigate around arbitrarily"><y>#</y><d>2020-04-08</d><h>16:53</h><w>thom</w>I think I had a slightly wrong-headed zippers way of thinking about it where I could get to somewhere and then just navigate around arbitrarily</z><z id="t1586749652" t="nonrecursive hey hey 🙂 How would I return a map where all paths that don’t terminate in an integer have been pruned? Given: {:a {:b {:c 10 :d &quot;&quot;}} :f 5 :k [10] :m &quot;&quot; :x {:y {:z &quot;&quot;}}} I want: {:a {:b {:c 10}} :f 5 :k [10]}"><y>#</y><d>2020-04-13</d><h>03:47</h><w>nonrecursive</w>hey hey <b>🙂</b> How would I return a map where all paths that don’t terminate in an integer have been pruned?

Given:
<pre>{:a {:b {:c 10
         :d &quot;&quot;}}
 :f 5
 :k [10]
 :m &quot;&quot;
 :x {:y {:z &quot;&quot;}}}</pre>
I want:
<pre>{:a {:b {:c 10}}
 :f 5
 :k [10]}</pre></z><z id="t1586817384" t="nathanmarz @nonrecursive you can do that with a custom walker and compact : (def COMPACTING-WALKER (recursive-path [] p (cond-path map? [(compact MAP-VALS) p] coll? [(compact ALL) p] STAY STAY ))) (setval [COMPACTING-WALKER (complement number?)] NONE data ) "><y>#</y><d>2020-04-13</d><h>22:36</h><w>nathanmarz</w>@nonrecursive you can do that with a custom walker and <code>compact</code> :
<pre>(def COMPACTING-WALKER
  (recursive-path [] p
    (cond-path map? [(compact MAP-VALS) p]
               coll? [(compact ALL) p]
               STAY STAY
               )))

(setval [COMPACTING-WALKER (complement number?)]
  NONE
  data
  )</pre>
</z><z id="t1586878435" t="nonrecursive @nathan that worked beautifully, thanks for your help!"><y>#</y><d>2020-04-14</d><h>15:33</h><w>nonrecursive</w>@nathan that worked beautifully, thanks for your help!</z><z id="t1587147899" t="lvh What I have: (def m (-&gt; {} (assoc-in [:a :b :c :d] 1) (assoc-in [:x :y :z] 2))) (def INDEXED &quot;A path that visits v and collects k in [[k v], ...].&quot; [sr/ALL (sr/putval sr/FIRST) sr/LAST]) (def INDEXED-SEQ &quot;A selector that visits all elements of a seq, and collects their indices.&quot; [(sr/view #(map-indexed vector %)) INDEXED]) (def NESTED-PATHS (sr/recursive-path [] p (sr/cond-path map? [INDEXED p] coll? [INDEXED-SEQ p] sr/STAY sr/STAY))) (sr/select [NESTED-PATHS] m) ;; =&gt; [[:a :b :c :d 1] [:x :y :z 2]] What I would like (so I can peek/pop to destructure, since the &quot;path&quot; is separate from the final value): [[[:a :b :c :d] 1] [[:x :y :z] 2]] Of course I can just do that with last &amp; butlast but if there was a more efficient/elegant/different version I&apos;d love to know"><y>#</y><d>2020-04-17</d><h>18:24</h><w>lvh</w>What I have:

<pre>(def m (-&gt; {} (assoc-in [:a :b :c :d] 1) (assoc-in [:x :y :z] 2)))

(def INDEXED
  &quot;A path that visits v and collects k in [[k v], ...].&quot;
  [sr/ALL (sr/putval  sr/FIRST) sr/LAST])

(def INDEXED-SEQ
  &quot;A selector that visits all elements of a seq, and collects their indices.&quot;
  [(sr/view #(map-indexed vector %)) INDEXED])

(def NESTED-PATHS
  (sr/recursive-path
   [] p
   (sr/cond-path
    map? [INDEXED p]
    coll? [INDEXED-SEQ p]
    sr/STAY sr/STAY)))

(sr/select [NESTED-PATHS] m)
;; =&gt; [[:a :b :c :d 1] [:x :y :z 2]]</pre>
What I would like (so I can peek/pop to destructure, since the &quot;path&quot; is separate from the final value):

<pre>[[[:a :b :c :d] 1] [[:x :y :z] 2]]</pre>

Of course I can just do that with last &amp; butlast but if there was a more efficient/elegant/different version I&apos;d love to know</z><z id="t1587148728" t="lvh i could also solve this problem if I had a version of view that showed me the currently collected values"><y>#</y><d>2020-04-17</d><h>18:38</h><w>lvh</w>i could also solve this problem if I had a version of <code>view</code>  that showed me the currently collected values</z><z id="t1587322155" t="lvh Subtle variant of that: (def path-finder &quot;Finds the first entry matching `pred` in a deeply nested structure of maps and vectors, and collects the path on the way there.&quot; (sr/recursive-path [term-pred] p (sr/cond-path (sr/pred term-pred) sr/STAY map? [INDEXED p] coll? [INDEXED-SEQ p]))) (basically the same thing but with a predicate). This works fine (as expected when selecting): (sr/select (path-finder string?) {:a [&quot;x&quot;] :b {:c :d}}) ;; =&gt; [[:a 0 &quot;x&quot;]] But when transforming I get this unexpected behavior: (= (sr/transform [(path-finder string?)] (fn [&amp; path-and-val] (-&gt; path-and-val last str/upper-case)) {:a [&quot;x&quot;] :b {:c :d}}) (sr/transform [NESTED-PATHS string?] (fn [&amp; path-and-val] (-&gt; path-and-val last str/upper-case)) {:a [&quot;x&quot;] :b {:c :d}}) {:a &apos;([0 &quot;X&quot;]), :b {:c :d}}) Why is that zero there all of a sudden and how do I fix that?"><y>#</y><d>2020-04-19</d><h>18:49</h><w>lvh</w>Subtle variant of that:

<pre>(def path-finder
  &quot;Finds the first entry matching `pred` in a deeply nested structure of maps
  and vectors, and collects the path on the way there.&quot;
  (sr/recursive-path
   [term-pred] p
   (sr/cond-path
    (sr/pred term-pred) sr/STAY
    map? [INDEXED p]
    coll? [INDEXED-SEQ p])))</pre>
(basically the same thing but with a predicate). This works fine (as expected when selecting):

<pre>(sr/select
 (path-finder string?)
 {:a [&quot;x&quot;] :b {:c :d}})
;; =&gt; [[:a 0 &quot;x&quot;]]</pre>
But when transforming I get this unexpected behavior:

<pre>(= (sr/transform
    [(path-finder string?)]
    (fn [&amp; path-and-val] (-&gt; path-and-val last str/upper-case))
    {:a [&quot;x&quot;] :b {:c :d}})
   (sr/transform
    [NESTED-PATHS string?]
    (fn [&amp; path-and-val] (-&gt; path-and-val last str/upper-case))
    {:a [&quot;x&quot;] :b {:c :d}})
   {:a &apos;([0 &quot;X&quot;]), :b {:c :d}})</pre>
Why is that zero there all of a sudden and how do I fix that?</z><z id="t1588778966" t="Alex Ragone Hi everyone! I am trying to navigate a 4D array and would like to get all the indicies (the path to get there). How do I do that? So far I have the following (transform [ALL (collect-one INDEXED-VALS FIRST) ALL (collect-one INDEXED-VALS FIRST) ALL (collect-one INDEXED-VALS FIRST) ALL (collect-one INDEXED-VALS)] (fn [d1 d2 d3 d4 item] ...)) 4d-array)) But I don’t quite understand how the collect function works? Can anyone please help me? 🙂 Thank you."><y>#</y><d>2020-05-06</d><h>15:29</h><w>Alex Ragone</w>Hi everyone! I am trying to navigate a 4D array and would like to get all the indicies (the path to get there). How do I do that? So far I have the following
<pre>(transform [ALL (collect-one INDEXED-VALS FIRST)
              ALL (collect-one INDEXED-VALS FIRST)
              ALL (collect-one INDEXED-VALS FIRST)
              ALL (collect-one INDEXED-VALS)]
             (fn [d1 d2 d3 d4 item]
                 ...))
             4d-array))</pre>
But I don’t quite understand how the collect function works? Can anyone please help me? <b>🙂</b> Thank you.</z><z id="t1588794894" t="nathanmarz @ragonedk you want something more like: (transform [INDEXED-VALS (collect-one FIRST) LAST INDEXED-VALS (collect-one FIRST) LAST INDEXED-VALS (collect-one FIRST) LAST INDEXED-VALS (collect-one FIRST) LAST ] (fn [d1 d2 d3 d4 item] ) 4d-arr )"><y>#</y><d>2020-05-06</d><h>19:54</h><w>nathanmarz</w>@ragonedk you want something more like:
<pre>(transform [INDEXED-VALS
            (collect-one FIRST)
            LAST
            INDEXED-VALS
            (collect-one FIRST)
            LAST
            INDEXED-VALS
            (collect-one FIRST)
            LAST
            INDEXED-VALS
            (collect-one FIRST)
            LAST
            ]
  (fn [d1 d2 d3 d4 item]
    )
  4d-arr
  )</pre></z><z id="t1588794957" t="nathanmarz you can shorten that like this: (def ALL-AND-COLLECT-INDEX (path INDEXED-VALS (collect-one FIRST) LAST)) (transform [ALL-AND-COLLECT-INDEX ALL-AND-COLLECT-INDEX ALL-AND-COLLECT-INDEX ALL-AND-COLLECT-INDEX] (fn [d1 d2 d3 d4 item] ) 4d-arr )"><y>#</y><d>2020-05-06</d><h>19:55</h><w>nathanmarz</w>you can shorten that like this:
<pre>(def ALL-AND-COLLECT-INDEX (path INDEXED-VALS (collect-one FIRST) LAST))

(transform [ALL-AND-COLLECT-INDEX
            ALL-AND-COLLECT-INDEX
            ALL-AND-COLLECT-INDEX
            ALL-AND-COLLECT-INDEX]
  (fn [d1 d2 d3 d4 item]
    )
  4d-arr
  )</pre></z><z id="t1588795035" t="Alex Ragone Awesome, that worked! Thank you :)"><y>#</y><d>2020-05-06</d><h>19:57</h><w>Alex Ragone</w>Awesome, that worked! Thank you :)</z><z id="t1588803134" t="Joe Hello, I have a 9x9 matrix using nested vectors, and I want to pull out the top left &apos;subsquare&apos; , i.e. elements at [0-2, 0-2]. I got the results I wanted with (select [(srange 0 3) ALL (srange 0 3)] data) , but I don&apos;t understand the need for the ALL inbetween the two sranges . I was thinking the first srange would grab the first 3 vectors, and the second would grab the first 3 elements from each of them - what&apos;s the concept I&apos;m missing that means you need the ALL in the middle? Here&apos;s the data: (def data [[5 3 0 0 7 0 0 0 0] [6 0 0 1 9 5 0 0 0] [0 9 8 0 0 0 0 6 0] [8 0 0 0 6 0 0 0 3] [4 0 0 8 0 3 0 0 1] [7 0 0 0 2 0 0 0 6] [0 6 0 0 0 0 2 8 0] [0 0 0 4 1 9 0 0 5] [0 0 0 0 8 0 0 7 9]]) "><y>#</y><d>2020-05-06</d><h>22:12</h><w>Joe</w>Hello, I have a 9x9 matrix using nested vectors, and I want to pull out the top left &apos;subsquare&apos; , i.e. elements at [0-2, 0-2]. I got the results I wanted with <code>(select [(srange 0 3) ALL (srange 0 3)] data)</code> , but I don&apos;t understand the need for the <code>ALL</code> inbetween the two <code>sranges</code>. I was thinking the first srange would grab the first 3 vectors, and the second would grab the first 3 elements from each of them - what&apos;s the concept I&apos;m missing that means you need the <code>ALL</code> in the middle?
Here&apos;s the data:
<pre>(def data
  [[5 3 0 0 7 0 0 0 0]
   [6 0 0 1 9 5 0 0 0]
   [0 9 8 0 0 0 0 6 0]
   [8 0 0 0 6 0 0 0 3]
   [4 0 0 8 0 3 0 0 1]
   [7 0 0 0 2 0 0 0 6]
   [0 6 0 0 0 0 2 8 0]
   [0 0 0 4 1 9 0 0 5]
   [0 0 0 0 8 0 0 7 9]]) </pre></z><z id="t1588804625" t="nathanmarz @allaboutthatmace1789 srange navigates to a single subsequence, ALL navigates to each element"><y>#</y><d>2020-05-06</d><h>22:37</h><w>nathanmarz</w>@allaboutthatmace1789 <code>srange</code> navigates to a single subsequence, <code>ALL</code> navigates to each element</z><z id="t1588805542" t="Joe So the first srange gets to [[1 2 3 ,,,] [1 2 3 ,,,] [1 2 3 ,,,]] , you need the ALL to tell it grab every element [1 2 3 ,,,] [1 2 3 ,,,] [1 2 3 ,,,] , then for each of those elements the second srange gets the subseq of first 3 elements [1 2 3] [1 2 3] [1 2 3] - then wraps everything back up again?"><y>#</y><d>2020-05-06</d><h>22:52</h><w>Joe</w>So the first <code>srange</code> gets to <code>[[1 2 3 ,,,] [1 2 3 ,,,] [1 2 3 ,,,]]</code>, you need the <code>ALL</code> to tell it grab every element <code>[1 2 3 ,,,] [1 2 3 ,,,] [1 2 3 ,,,]</code>, then for each of those elements the second <code>srange</code> gets the subseq of first 3 elements <code>[1 2 3] [1 2 3] [1 2 3]</code> - then wraps everything back up again?</z><z id="t1588819496" t="nathanmarz in a select that would just return the individual elements"><y>#</y><d>2020-05-07</d><h>02:44</h><w>nathanmarz</w>in a select that would just return the individual elements</z><z id="t1588819522" t="nathanmarz in a transform it would change the values in their locations in which you navigated to them"><y>#</y><d>2020-05-07</d><h>02:45</h><w>nathanmarz</w>in a transform it would change the values in their locations in which you navigated to them</z><z id="t1589816742" t="mmer Hi a simple question but one that I have struggled to find an answer: I have a vector of maps and I want to return all the maps that contains a map entry that matches a particular value, for example all maps where :lang contains &quot;EN&quot;."><y>#</y><d>2020-05-18</d><h>15:45</h><w>mmer</w>Hi a simple question but one that I have struggled to find an answer:  I have a vector of maps and I want to return all the maps that contains a map entry that matches a particular value, for example all maps where :lang contains &quot;EN&quot;.</z><z id="t1589817714" t="spieden @mmer I believe (spr/select [spr/ALL #(= &quot;EN&quot; (:lang %))] v-of-m) should do it"><y>#</y><d>2020-05-18</d><h>16:01</h><w>spieden</w>@mmer I believe <code>(spr/select [spr/ALL #(= &quot;EN&quot; (:lang %))] v-of-m)</code> should do it</z><z id="t1589817771" t="mmer So obvious when you see it in front of you! Thanks @spieden"><y>#</y><d>2020-05-18</d><h>16:02</h><w>mmer</w>So obvious when you see it in front of you!  Thanks @spieden</z><z id="t1589817901" t="spieden @nathanmarz I&apos;m having an interesting issue combining transform and stay-then-continue . I&apos;m replacing a map with a string via transform, and then specter seems to try to navigate the new value like it&apos;s still a map and I get class java.lang.String cannot be cast to class clojure.lang.Associative from do-keypath-transform . Does that sound familiar at all?"><y>#</y><d>2020-05-18</d><h>16:05</h><w>spieden</w>@nathanmarz I&apos;m having an interesting issue combining <code>transform</code> and <code>stay-then-continue</code> . I&apos;m replacing a map with a string via transform, and then specter seems to try to navigate the new value like it&apos;s still a map and I get <code>class java.lang.String cannot be cast to class clojure.lang.Associative</code> from <code>do-keypath-transform</code> . Does that sound familiar at all?</z><z id="t1589920068" t="lvh I&apos;m confused: isn&apos;t that what stay then continue is supposed to do?"><y>#</y><d>2020-05-19</d><h>20:27</h><r>lvh</r>I&apos;m confused: isn&apos;t that what stay then continue is supposed to do?</z><z id="t1589920104" t="lvh how do you want to transform the map if you&apos;ve already stringified its contents? do you have a more complete toy example?"><y>#</y><d>2020-05-19</d><h>20:28</h><r>lvh</r>how do you want to transform the map if you&apos;ve already stringified its contents? do you have a more complete toy example?</z><z id="t1589920113" t="lvh i&apos;d assume you want postorder there"><y>#</y><d>2020-05-19</d><h>20:28</h><r>lvh</r>i&apos;d assume you want postorder there</z><z id="t1589920126" t="lvh ugh, sorry, I just read the backlog"><y>#</y><d>2020-05-19</d><h>20:28</h><r>lvh</r>ugh, sorry, I just read the backlog</z><z id="t1589920129" t="spieden Yeah that&apos;s what I ended up doing ⬇️"><y>#</y><d>2020-05-19</d><h>20:28</h><r>spieden</r>Yeah that&apos;s what I ended up doing <b>⬇️</b></z><z id="t1589920132" t="spieden :)"><y>#</y><d>2020-05-19</d><h>20:28</h><r>spieden</r>:)</z><z id="t1589817954" t="mmer There is another step to this: I have a vector of pairs of vectors. I want to add a value to the first vector based on a property in the second vector. Again a simple use case, and probably has a simple answer"><y>#</y><d>2020-05-18</d><h>16:05</h><w>mmer</w>There is another step to this:  I have a vector of pairs of vectors.  I want to add a value to the first vector based on a property in the second vector.  Again a simple use case, and probably has a simple answer</z><z id="t1589818335" t="spieden @mmer You&apos;d probably just handle all that inside your transform function"><y>#</y><d>2020-05-18</d><h>16:12</h><w>spieden</w>@mmer You&apos;d probably just handle all that inside your transform function</z><z id="t1589818419" t="mmer @spieden thanks, I was expecting to be able to pass the first vector to the transform function without having selected it based on the values in the second function."><y>#</y><d>2020-05-18</d><h>16:13</h><w>mmer</w>@spieden thanks,  I was expecting to be able to pass the first vector to the transform function without having selected it based on the values in the second function.</z><z id="t1589818481" t="spieden Ah hrm, well you can pass the whole tuple to the transform based on a value in the second"><y>#</y><d>2020-05-18</d><h>16:14</h><w>spieden</w>Ah hrm, well you can pass the whole tuple to the transform based on a value in the second</z><z id="t1589818494" t="spieden .. and then just transform the first vector in it and leave the other alone"><y>#</y><d>2020-05-18</d><h>16:14</h><w>spieden</w>.. and then just transform the first vector in it and leave the other alone</z><z id="t1589818523" t="mmer That makes sense"><y>#</y><d>2020-05-18</d><h>16:15</h><w>mmer</w>That makes sense</z><z id="t1589818568" t="spieden (spr/transform [spr/ALL #(fn [[_ v2]] (pred? v2)] transform-v1 vs)"><y>#</y><d>2020-05-18</d><h>16:16</h><w>spieden</w><code>(spr/transform [spr/ALL #(fn [[_ v2]] (pred? v2)] transform-v1 vs)</code></z><z id="t1589818707" t="mmer Thanks"><y>#</y><d>2020-05-18</d><h>16:18</h><w>mmer</w>Thanks</z><z id="t1589820070" t="spieden @nathanmarz Looks like switching to postorder via continue-then-stay did the trick!"><y>#</y><d>2020-05-18</d><h>16:41</h><w>spieden</w>@nathanmarz Looks like switching to postorder via <code>continue-then-stay</code> did the trick!</z><z id="t1589820094" t="spieden Many thanks for specter, as always -- not sure how I&apos;d accomplish this work I&apos;m doing without it"><y>#</y><d>2020-05-18</d><h>16:41</h><w>spieden</w>Many thanks for specter, as always -- not sure how I&apos;d accomplish this work I&apos;m doing without it</z><z id="t1590140081" t="Endre Bakken Stovner How do I select multiple things at different levels? "><y>#</y><d>2020-05-22</d><h>09:34</h><w>Endre Bakken Stovner</w>How do I select multiple things at different levels?

<pre></pre></z><z id="t1590140201" t="Endre Bakken Stovner Test data: (def testrules {:plot-quals {:out {:graph &quot;quals.svg&quot; :data &quot;quals.tsv&quot;},}, :samtools-index {:out &quot;bam/sorted.bam.bai&quot;,}, :samtools-sort {:out &quot;bam/sorted.bam&quot;}}) I want to get the first key and value of out. Was thinking it would start something like (select [(collect-one KEY) ALL ALL :out] testrules)"><y>#</y><d>2020-05-22</d><h>09:36</h><w>Endre Bakken Stovner</w>Test data:

<pre>(def testrules {:plot-quals {:out {:graph &quot;quals.svg&quot; :data &quot;quals.tsv&quot;},},
                :samtools-index {:out &quot;bam/sorted.bam.bai&quot;,},
                :samtools-sort {:out &quot;bam/sorted.bam&quot;}})</pre>
I want to get the first key and value of out. Was thinking it would start something like

<pre>(select [(collect-one KEY) ALL ALL :out] testrules)</pre></z><z id="t1590140353" t="Endre Bakken Stovner (select [(collect ALL) ALL :out] testrules) got me closer."><y>#</y><d>2020-05-22</d><h>09:39</h><r>Endre Bakken Stovner</r><pre>(select [(collect ALL) ALL :out] testrules)</pre>
got me closer.</z><z id="t1590157924" t="mmer (select [(collect-one FIRST FIRST) ALL LAST :out] testrules) yields [[:plot-quals {:graph &quot;quals.svg&quot;, :data &quot;quals.tsv&quot;}] [:plot-quals &quot;bam/sorted.bam.bai&quot;] [:plot-quals &quot;bam/sorted.bam&quot;]]"><y>#</y><d>2020-05-22</d><h>14:32</h><r>mmer</r><code>(select [(collect-one FIRST FIRST)  ALL LAST :out] testrules)</code> yields <code>[[:plot-quals {:graph &quot;quals.svg&quot;, :data &quot;quals.tsv&quot;}]</code>
 <code>[:plot-quals &quot;bam/sorted.bam.bai&quot;]</code>
 <code>[:plot-quals &quot;bam/sorted.bam&quot;]]</code></z><z id="t1590405657" t="Endre Bakken Stovner Working through the tutorials now, but thanks for helping me solve some immediate problems :)"><y>#</y><d>2020-05-25</d><h>11:20</h><r>Endre Bakken Stovner</r>Working through the tutorials now, but thanks for helping me solve some immediate problems :)</z><z id="t1591399618" t="dadair Can I use spectre to recursively transform java.util.HashMap of java.util.HashMaps to regular clojure maps?"><y>#</y><d>2020-06-05</d><h>23:26</h><w>dadair</w>Can I use spectre to recursively transform java.util.HashMap of java.util.HashMaps to regular clojure maps?</z><z id="t1591400677" t="dadair I&apos;m basically trying to go from the top here, where all the maps are java.util.HashMap, to the bottom, where all maps are IAssociative: {&quot;name&quot; &quot;foo&quot; &quot;children&quot; {&quot;bar&quot; {&quot;name&quot; &quot;bar&quot; &quot;children&quot; {}} &quot;baz&quot; {&quot;name&quot; &quot;baz&quot; &quot;children&quot; {&quot;quux&quot; {&quot;name&quot; &quot;quux&quot; &quot;children&quot; {}}}}}} ;;=&gt; (addition of `ref`, keywordize the keys, make standard IAssociative) {:name &quot;foo&quot; :children {:bar {:name &quot;bar&quot; :children {} :ref &quot;foo/bar&quot;} :baz {:name &quot;baz&quot; :children {:quux {:name &quot;quux&quot; :children {} :ref &quot;foo/baz/quux&quot;}} :ref &quot;foo/baz&quot;}} :ref &quot;foo&quot;}"><y>#</y><d>2020-06-05</d><h>23:44</h><w>dadair</w>I&apos;m basically trying to go from the top here, where all the maps are java.util.HashMap, to the bottom, where all maps are IAssociative:

<pre>{&quot;name&quot; &quot;foo&quot;
 &quot;children&quot; {&quot;bar&quot; {&quot;name&quot; &quot;bar&quot;
                    &quot;children&quot; {}}
             &quot;baz&quot; {&quot;name&quot; &quot;baz&quot;
                    &quot;children&quot; {&quot;quux&quot; {&quot;name&quot; &quot;quux&quot;
                                        &quot;children&quot; {}}}}}}

;;=&gt; (addition of `ref`, keywordize the keys, make standard IAssociative)

{:name &quot;foo&quot;
 :children {:bar {:name &quot;bar&quot;
                  :children {}
                  :ref &quot;foo/bar&quot;}
            :baz {:name &quot;baz&quot;
                  :children {:quux {:name &quot;quux&quot;
                                    :children {}
                                    :ref &quot;foo/baz/quux&quot;}}
                  :ref &quot;foo/baz&quot;}}
 :ref &quot;foo&quot;}</pre></z><z id="t1591400705" t="dadair Had an implementation using both clojure.walk and spectre, but want to do it in 1 pass, if possible"><y>#</y><d>2020-06-05</d><h>23:45</h><w>dadair</w>Had an implementation using both clojure.walk and spectre, but want to do it in 1 pass, if possible</z><z id="t1591401102" t="dadair I can select each with: (def HASH-MAPS (sp/recursive-path [] p (sp/stay-then-continue (sp/must &quot;children&quot;) sp/MAP-VALS p))) (clojure.pprint/pprint (sp/select [:root HASH-MAPS] {:root hm}))"><y>#</y><d>2020-06-05</d><h>23:51</h><w>dadair</w>I can select each with:
<pre>(def HASH-MAPS
    (sp/recursive-path
     []
     p
     (sp/stay-then-continue
      (sp/must &quot;children&quot;)
      sp/MAP-VALS
      p)))

  (clojure.pprint/pprint
   (sp/select
    [:root HASH-MAPS]
    {:root hm}))</pre></z><z id="t1591401115" t="dadair It&apos;s the transform in one pass that&apos;s getting me confused &gt;.&lt;"><y>#</y><d>2020-06-05</d><h>23:51</h><w>dadair</w>It&apos;s the transform in one pass that&apos;s getting me confused &gt;.&lt;</z><z id="t1591793361" t="mmer @dadair I was going to answer your question thinking it was simple, but then I realise the issue is that you need the name of parent key to be able to construct the ref. I had a similar issue when traversing a tree. It is as if you need to collect it on your way but I could never understand how to reference the collected value."><y>#</y><d>2020-06-10</d><h>12:49</h><w>mmer</w>@dadair I was going to answer your question thinking it was simple, but then I realise the issue is that you need the name of parent key to be able to construct the ref.  I had a similar issue when traversing a tree.  It is as if you need to collect it on your way but I could never understand how to reference the collected value.</z><z id="t1591923291" t="dadair I have a working solution if you’re interested,"><y>#</y><d>2020-06-12</d><h>00:54</h><w>dadair</w>I have a working solution if you’re interested,</z><z id="t1591923348" t="dadair It was more involved than I thought, but not so bad. Had to extend IKVReduce for Java.util.HashMaps and the map-vals spectre protocols, but all in all it’s pretty succinct code "><y>#</y><d>2020-06-12</d><h>00:55</h><w>dadair</w>It was more involved than I thought, but not so bad. Had to extend IKVReduce for Java.util.HashMaps and the map-vals spectre protocols, but all in all it’s pretty succinct code </z><z id="t1591923392" t="dadair I can post a gist maybe tomorrow "><y>#</y><d>2020-06-12</d><h>00:56</h><w>dadair</w>I can post a gist maybe tomorrow </z><z id="t1591928632" t="fmn Is there any performance benefit of using select-first over select-one ? My use case is to select the first one matching the path without considering if there&apos;s any duplicate in the collection."><y>#</y><d>2020-06-12</d><h>02:23</h><w>fmn</w>Is there any performance benefit of using <code>select-first</code>  over <code>select-one</code> ? My use case is to select the first one matching the path without considering if there&apos;s any duplicate in the collection.</z><z id="t1591978541" t="nathanmarz @funyako.funyao156 select-first will terminate navigation early if relevant"><y>#</y><d>2020-06-12</d><h>16:15</h><w>nathanmarz</w>@funyako.funyao156 select-first will terminate navigation early if relevant</z><z id="t1591978564" t="nathanmarz e.g. (select-first [ALL even?] data) will be faster than (select-one [ALL even?] data)"><y>#</y><d>2020-06-12</d><h>16:16</h><w>nathanmarz</w>e.g. <code>(select-first [ALL even?] data)</code> will be faster than <code>(select-one [ALL even?] data)</code></z><z id="t1592009417" t="fmn Thank you"><y>#</y><d>2020-06-13</d><h>00:50</h><w>fmn</w>Thank you</z><z id="t1592918834" t="Casey hey folks, given a vector of vectors of integers, and a separate vector of integers to remove, how can I remove all integers from the sub-vectors that are in the separate vector? (def to-remove [ 4 5 6 ]) (def coll [ [1 2 4] [3 5 8 ] [6] [] ]) (specter/transform [(specter/filterer not-empty) specter/ALL ..?.. ] specter/NONE coll) ;; =&gt; [ [1 2] [3 8] [] [] ]"><y>#</y><d>2020-06-23</d><h>13:27</h><w>Casey</w>hey folks, given a vector of vectors of integers, and a separate vector of integers to remove, how can I remove all integers from the sub-vectors that are in the separate vector?

<pre>(def to-remove [ 4 5 6 ])
(def coll [ [1 2 4] [3 5 8 ] [6] [] ])
(specter/transform [(specter/filterer not-empty) specter/ALL ..?.. ] specter/NONE coll)

;; =&gt; [ [1 2] [3 8] [] [] ]</pre></z><z id="t1592919594" t="Casey Seems like this works, is there a more efficient way to write it? (specter/setval [specter/ALL specter/ALL (fn [val] (some #(= val %) to-remove))] specter/NONE coll)"><y>#</y><d>2020-06-23</d><h>13:39</h><w>Casey</w>Seems like this works, is there a more efficient way to write it?

<pre>(specter/setval [specter/ALL specter/ALL (fn [val]  (some #(= val %) to-remove))] specter/NONE coll)</pre></z><z id="t1592932007" t="jsa-aerial Might be nicer if you made to-remove a set, then it is just (to-remove val) or replace fn form with #(to-remove %)"><y>#</y><d>2020-06-23</d><h>17:06</h><w>jsa-aerial</w>Might be nicer if you made <code>to-remove</code> a set, then it is just <code>(to-remove val)</code> or replace <code>fn</code> form with <code>#(to-remove %)</code></z><z id="t1592935258" t="avi Hi, sorry if this is a FAQ, but how can I navigate to a map, and then filter the entries in the map, based on certain nested values in the values?"><y>#</y><d>2020-06-23</d><h>18:00</h><w>avi</w>Hi, sorry if this is a FAQ, but how can I navigate to a map, and then filter the entries in the map, based on certain nested values in the values?</z><z id="t1592935283" t="avi Here’s what I’m doing in “plain old Clojure” (plus Medley) that I’m curious how to translate to Specter: (-&gt;&gt; (db/read &quot;db&quot;) (:technologies) (medley/filter-vals (fn [tech] (some (fn [rec] (rec &quot;ratified&quot;)) (get tech &quot;recommendations&quot;)))))"><y>#</y><d>2020-06-23</d><h>18:01</h><r>avi</r>Here’s what I’m doing in “plain old Clojure” (plus Medley) that I’m curious how to translate to Specter:

<pre>(-&gt;&gt; (db/read &quot;db&quot;)
     (:technologies)
     (medley/filter-vals
       (fn [tech] (some (fn [rec] (rec &quot;ratified&quot;))
                        (get tech &quot;recommendations&quot;)))))</pre></z><z id="t1592935286" t="avi Thanks!"><y>#</y><d>2020-06-23</d><h>18:01</h><r>avi</r>Thanks!</z><z id="t1592935462" t="phronmophobic not sure it&apos;s the most straightforward approach, but you could probably use: [:technology MAP-VALS] for the path. in your transform function: • return the original value to keep it • return spec/NONE to remove a value"><y>#</y><d>2020-06-23</d><h>18:04</h><r>phronmophobic</r>not sure it&apos;s the most straightforward approach, but you could probably use:
<pre>[:technology MAP-VALS]</pre>
for the path. in your transform function:
• return the original value to keep it
• return spec/NONE to remove a value</z><z id="t1592935488" t="avi Thanks! But I’m not looking to transform, just to query."><y>#</y><d>2020-06-23</d><h>18:04</h><r>avi</r>Thanks! But I’m not looking to transform, just to query.</z><z id="t1592935506" t="phronmophobic oh"><y>#</y><d>2020-06-23</d><h>18:05</h><r>phronmophobic</r>oh</z><z id="t1592935532" t="avi Yeah, I left if off but when I ran the above code, the last form in the thread-last form was keys"><y>#</y><d>2020-06-23</d><h>18:05</h><r>avi</r>Yeah, I left if off but when I ran the above code, the last form in the thread-last form was <code>keys</code></z><z id="t1592935601" t="phronmophobic [:technology MAP-VALS (fn [tech] (some (fn [rec] (rec &quot;ratified&quot;)) (get tech &quot;recommendations&quot;)))] "><y>#</y><d>2020-06-23</d><h>18:06</h><r>phronmophobic</r><pre>[:technology MAP-VALS (fn [tech] (some (fn [rec] (rec &quot;ratified&quot;))
                        (get tech &quot;recommendations&quot;)))]</pre>
</z><z id="t1592935621" t="avi interesting, I thought I tried that… I’ll try again, brb!"><y>#</y><d>2020-06-23</d><h>18:07</h><r>avi</r>interesting, I thought I tried that… I’ll try again, brb!</z><z id="t1592935653" t="phronmophobic i&apos;m not specter expert either ¯\(ツ)/¯"><y>#</y><d>2020-06-23</d><h>18:07</h><r>phronmophobic</r>i&apos;m not specter expert either ¯\(ツ)/¯</z><z id="t1592935689" t="avi Wait… that’ll navigate to the results of the predicate, right? But I want the map under :technologies , just filtered"><y>#</y><d>2020-06-23</d><h>18:08</h><r>avi</r>Wait… that’ll navigate to the results of the predicate, right? But I want the map under <code>:technologies</code>, just filtered</z><z id="t1592935821" t="avi I’m very new to Specter but I’d think it’d have something roughly equivalent to Medley’s filter-vals (which filters a map by applying a predicate to the vals in the map, and returns a map containing the matching entries)"><y>#</y><d>2020-06-23</d><h>18:10</h><r>avi</r>I’m very new to Specter but I’d think it’d have something roughly equivalent to Medley’s <code>filter-vals</code> (which filters a map by applying a predicate to the vals in the map, and returns a map containing the matching entries)</z><z id="t1592935845" t="avi (Or something equivalent to filter that I could use to the same effect)"><y>#</y><d>2020-06-23</d><h>18:10</h><r>avi</r>(Or something equivalent to <code>filter</code> that I could use to the same effect)</z><z id="t1592935873" t="phronmophobic https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#filterer"><y>#</y><d>2020-06-23</d><h>18:11</h><r>phronmophobic</r><a href="https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#filterer" target="_blank">https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#filterer</a></z><z id="t1592935904" t="avi Right! I tried that but had trouble with it. Thought maybe I just didn’t understand it. I’ll try again… brb"><y>#</y><d>2020-06-23</d><h>18:11</h><r>avi</r>Right! I tried that but had trouble with it. Thought maybe I just didn’t understand it. I’ll try again… brb</z><z id="t1592935932" t="phronmophobic imo, specter is much more useful if you&apos;re transforming or setting data in a deeply nested data structure. if you&apos;re just drilling into a nested data structure, I usually just use the normal clojure functions"><y>#</y><d>2020-06-23</d><h>18:12</h><r>phronmophobic</r>imo, specter is much more useful if you&apos;re transforming or setting data in a deeply nested data structure. if you&apos;re just drilling into a nested data structure, I usually just use the normal clojure functions</z><z id="t1592935952" t="avi that makes sense."><y>#</y><d>2020-06-23</d><h>18:12</h><r>avi</r>that makes sense.</z><z id="t1592935974" t="avi But I’d like to build up my own intuition as to when to use Specter, by seeing what it’s like to use it in cases like this"><y>#</y><d>2020-06-23</d><h>18:12</h><r>avi</r>But I’d like to build up my own intuition as to when to use Specter, by seeing what it’s like to use it in cases like this</z><z id="t1592936000" t="phronmophobic 👍"><y>#</y><d>2020-06-23</d><h>18:13</h><r>phronmophobic</r><b>👍</b></z><z id="t1592936026" t="avi Also, I had to walk a Clojure newbie through the above code and it was non-trivial to explain. I think the path concept could maybe be much more straightforward for folks new to Clojure and Lisps."><y>#</y><d>2020-06-23</d><h>18:13</h><r>avi</r>Also, I had to walk a Clojure newbie through the above code and it was non-trivial to explain. I think the path concept could maybe be much more straightforward for folks new to Clojure and Lisps.</z><z id="t1592936053" t="phronmophobic i&apos;m only a specter novice, so there&apos;s probably a very straightforward way to do it that I don&apos;t know about"><y>#</y><d>2020-06-23</d><h>18:14</h><r>phronmophobic</r>i&apos;m only a specter novice, so there&apos;s probably a very straightforward way to do it that I don&apos;t know about</z><z id="t1592936241" t="avi I hear ya, I have the same suspicion"><y>#</y><d>2020-06-23</d><h>18:17</h><r>avi</r>I hear ya, I have the same suspicion</z><z id="t1592936278" t="avi Trying this: (select [:technologies (filterer MAP-VALS &quot;recommendations&quot; ALL &quot;ratified&quot;) MAP-KEYS] db) getting: java.lang.ClassCastException: &quot;class java.lang.String cannot be cast to class java.util.Map$Entry…"><y>#</y><d>2020-06-23</d><h>18:17</h><r>avi</r>Trying this:

<pre>(select [:technologies
         (filterer MAP-VALS &quot;recommendations&quot; ALL &quot;ratified&quot;)
         MAP-KEYS]
        db)</pre>
getting: <code>java.lang.ClassCastException:  &quot;class java.lang.String cannot be cast to class java.util.Map$Entry…</code></z><z id="t1592936323" t="phronmophobic specter doesn&apos;t recognize strings as map keys like it does for keywords"><y>#</y><d>2020-06-23</d><h>18:18</h><r>phronmophobic</r>specter doesn&apos;t recognize strings as map keys like it does for keywords</z><z id="t1592936335" t="avi really?"><y>#</y><d>2020-06-23</d><h>18:18</h><r>avi</r>really?</z><z id="t1592936341" t="phronmophobic I think &quot;recommendations&quot; needs to be (keypath &quot;recommendations&quot;)"><y>#</y><d>2020-06-23</d><h>18:19</h><r>phronmophobic</r>I think &quot;recommendations&quot; needs to be (keypath &quot;recommendations&quot;)</z><z id="t1592936344" t="avi I thought i saw that work, one sec…"><y>#</y><d>2020-06-23</d><h>18:19</h><r>avi</r>I thought i saw that work, one sec…</z><z id="t1592936379" t="phronmophobic hmmm, maybe it does"><y>#</y><d>2020-06-23</d><h>18:19</h><r>phronmophobic</r>hmmm, maybe it does</z><z id="t1592936386" t="avi Yeah, this works: (select [:technologies MAP-VALS &quot;recommendations&quot; ALL] db)"><y>#</y><d>2020-06-23</d><h>18:19</h><r>avi</r>Yeah, this works: <code>(select [:technologies MAP-VALS &quot;recommendations&quot; ALL] db)</code></z><z id="t1592937943" t="phronmophobic filterer is complaining because it&apos;s turning the map into a sequence"><y>#</y><d>2020-06-23</d><h>18:45</h><r>phronmophobic</r>filterer is complaining because it&apos;s turning the map into a sequence</z><z id="t1592937950" t="phronmophobic maybe something like: (spec/select [:technologies (spec/filterer (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot;) ALL (spec/nthpath 0)] db)"><y>#</y><d>2020-06-23</d><h>18:45</h><r>phronmophobic</r>maybe something like:
<pre>(spec/select [:technologies
              (spec/filterer  (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot;)
              ALL
              (spec/nthpath 0)]
        db)</pre></z><z id="t1592938007" t="avi huh, that’s surprising. I wonder why it’s doing that. I’d think that’d be antithetical to Specter’s general behavior of leaving types as-is"><y>#</y><d>2020-06-23</d><h>18:46</h><r>avi</r>huh, that’s surprising. I wonder why it’s doing that. I’d think that’d be antithetical to Specter’s general behavior of leaving types as-is</z><z id="t1592938018" t="avi also: thank you!"><y>#</y><d>2020-06-23</d><h>18:46</h><r>avi</r>also: thank you!</z><z id="t1592938113" t="avi interesting… this “works”, but the result is incorrect: (select [:technologies (filterer (nthpath 1) &quot;recommendations&quot; ALL &quot;ratified&quot;) MAP-KEYS] db)"><y>#</y><d>2020-06-23</d><h>18:48</h><r>avi</r>interesting… this “works”, but the result is incorrect:

<pre>(select [:technologies
         (filterer (nthpath 1) &quot;recommendations&quot; ALL &quot;ratified&quot;)
         MAP-KEYS]
        db)</pre></z><z id="t1592938268" t="phronmophobic shoot"><y>#</y><d>2020-06-23</d><h>18:51</h><r>phronmophobic</r>shoot</z><z id="t1592938302" t="phronmophobic &gt; with the path yields anything other than an empty sequence."><y>#</y><d>2020-06-23</d><h>18:51</h><r>phronmophobic</r>&gt; with the path yields anything other than an empty sequence.</z><z id="t1592938308" t="phronmophobic the path is probably yielding false"><y>#</y><d>2020-06-23</d><h>18:51</h><r>phronmophobic</r>the path is probably yielding false</z><z id="t1592938324" t="avi the path in filterer ?"><y>#</y><d>2020-06-23</d><h>18:52</h><r>avi</r>the path in <code>filterer</code> ?</z><z id="t1592938329" t="phronmophobic right"><y>#</y><d>2020-06-23</d><h>18:52</h><r>phronmophobic</r>right</z><z id="t1592938332" t="avi I wouldn’t think so…?"><y>#</y><d>2020-06-23</d><h>18:52</h><r>avi</r>I wouldn’t think so…?</z><z id="t1592938338" t="avi why would it yield false?"><y>#</y><d>2020-06-23</d><h>18:52</h><r>avi</r>why would it yield false?</z><z id="t1592938348" t="avi I thought any path to something that doesn’t exist yields nil?"><y>#</y><d>2020-06-23</d><h>18:52</h><r>avi</r>I thought any path to something that doesn’t exist yields nil?</z><z id="t1592938349" t="phronmophobic or whatever is in the ratified key"><y>#</y><d>2020-06-23</d><h>18:52</h><r>phronmophobic</r>or whatever is in the ratified key</z><z id="t1592938372" t="phronmophobic does the ratified key exist even for unratified recommendations?"><y>#</y><d>2020-06-23</d><h>18:52</h><r>phronmophobic</r>does the ratified key exist even for unratified recommendations?</z></g><g id="s24"><z id="t1592938402" t="avi right. but most of the maps in the sequences that correspond to the &quot;recommendations&quot; keys do not have the key &quot;ratified&quot;; only a few do. I’m trying to find those technologies that have recommendations that have been ratified"><y>#</y><d>2020-06-23</d><h>18:53</h><r>avi</r>right. but most of the maps in the sequences that correspond to the &quot;recommendations&quot; keys do not have the key &quot;ratified&quot;; only a few do. I’m trying to find those technologies that have recommendations that have been ratified</z><z id="t1592938457" t="phronmophobic this seems to work: (def data {:technologies {0 {&quot;recommendations&quot; [{&quot;ratified&quot; true}]} 1 {&quot;recommendations&quot; [{&quot;ratified&quot; false}]} 2 {&quot;recommendations&quot; []}}}) (spec/select [:technologies (spec/filterer (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot; identity) spec/MAP-KEYS ;; ALL ;;(spec/nthpath 0) ] data)"><y>#</y><d>2020-06-23</d><h>18:54</h><r>phronmophobic</r>this seems to work:
<pre>(def data {:technologies
           {0 {&quot;recommendations&quot; [{&quot;ratified&quot; true}]}
            1 {&quot;recommendations&quot; [{&quot;ratified&quot; false}]}
            2 {&quot;recommendations&quot; []}}})

(spec/select [:technologies

              (spec/filterer  (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot; identity)
              spec/MAP-KEYS
              ;; ALL
              ;;(spec/nthpath 0)
              ]
             data)</pre></z><z id="t1592938493" t="phronmophobic the above will return [0]"><y>#</y><d>2020-06-23</d><h>18:54</h><r>phronmophobic</r>the above will return [0]</z><z id="t1592938500" t="avi it does!"><y>#</y><d>2020-06-23</d><h>18:55</h><r>avi</r>it does!</z><z id="t1592938507" t="avi I don’t get it though 🙃"><y>#</y><d>2020-06-23</d><h>18:55</h><r>avi</r>I don’t get it though <b>🙃</b></z><z id="t1592938536" t="avi why is the identity needed? what is it doing?"><y>#</y><d>2020-06-23</d><h>18:55</h><r>avi</r>why is the <code>identity</code> needed? what is it doing?</z><z id="t1592938587" t="phronmophobic so without identity and removing filterer: (def data {:technologies {0 {&quot;recommendations&quot; [{&quot;ratified&quot; true}]} 1 {&quot;recommendations&quot; [{&quot;ratified&quot; false}]} 2 {&quot;recommendations&quot; []}}}) (spec/select [:technologies ALL (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot; ;; spec/MAP-KEYS ;; ALL ;;(spec/nthpath 0) ] data)"><y>#</y><d>2020-06-23</d><h>18:56</h><r>phronmophobic</r>so without identity and removing filterer:
<pre>(def data {:technologies
           {0 {&quot;recommendations&quot; [{&quot;ratified&quot; true}]}
            1 {&quot;recommendations&quot; [{&quot;ratified&quot; false}]}
            2 {&quot;recommendations&quot; []}}})

(spec/select [:technologies
              ALL
              (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot; 
              ;; spec/MAP-KEYS
              ;; ALL
              ;;(spec/nthpath 0)
              ]
             data)</pre></z><z id="t1592938596" t="phronmophobic you get [true false]"><y>#</y><d>2020-06-23</d><h>18:56</h><r>phronmophobic</r>you get [true false]</z><z id="t1592938630" t="avi That’s not what I’m getting"><y>#</y><d>2020-06-23</d><h>18:57</h><r>avi</r>That’s not what I’m getting</z><z id="t1592938630" t="phronmophobic basically, it can navigate to the &quot;ratified&quot; key"><y>#</y><d>2020-06-23</d><h>18:57</h><r>phronmophobic</r>basically, it can navigate to the &quot;ratified&quot; key</z><z id="t1592938637" t="avi oh wait…"><y>#</y><d>2020-06-23</d><h>18:57</h><r>avi</r>oh wait…</z><z id="t1592938642" t="phronmophobic I also removed the filterer"><y>#</y><d>2020-06-23</d><h>18:57</h><r>phronmophobic</r>I also removed the filterer</z><z id="t1592938649" t="avi ah interesting"><y>#</y><d>2020-06-23</d><h>18:57</h><r>avi</r>ah interesting</z><z id="t1592938653" t="phronmophobic and the path exists if it can navigate there"><y>#</y><d>2020-06-23</d><h>18:57</h><r>phronmophobic</r>and the path exists if it can navigate there</z><z id="t1592938665" t="avi I see, you did that as a way to debug the filterer path?"><y>#</y><d>2020-06-23</d><h>18:57</h><r>avi</r>I see, you did that as a way to debug the filterer path?</z><z id="t1592938684" t="phronmophobic so filterer will keep paths that it can navigate to, even if the value it navigates to is falsey"><y>#</y><d>2020-06-23</d><h>18:58</h><r>phronmophobic</r>so filterer will keep paths that it can navigate to, even if the value it navigates to is falsey</z><z id="t1592938686" t="avi cool, that’s clever, makes sense!"><y>#</y><d>2020-06-23</d><h>18:58</h><r>avi</r>cool, that’s clever, makes sense!</z><z id="t1592938694" t="avi that’s… surprising"><y>#</y><d>2020-06-23</d><h>18:58</h><r>avi</r>that’s… surprising</z><z id="t1592938697" t="avi but, so be it"><y>#</y><d>2020-06-23</d><h>18:58</h><r>avi</r>but, so be it</z><z id="t1592938705" t="phronmophobic so identity is the simplest function that I can think of to filter based on truthiness"><y>#</y><d>2020-06-23</d><h>18:58</h><r>phronmophobic</r>so identity is the simplest function that I can think of to filter based on truthiness</z><z id="t1592938736" t="phronmophobic I think filterer has the right design, but it is a little surprising at first"><y>#</y><d>2020-06-23</d><h>18:58</h><r>phronmophobic</r>I think filterer has the right design, but it is a little surprising at first</z><z id="t1592938751" t="avi some? ?"><y>#</y><d>2020-06-23</d><h>18:59</h><r>avi</r><code>some?</code> ?</z><z id="t1592938789" t="phronmophobic (some? false) =&gt; true"><y>#</y><d>2020-06-23</d><h>18:59</h><r>phronmophobic</r><code>(some? false)</code> =&gt; true</z><z id="t1592938815" t="phronmophobic actually, boolean is probably clearer"><y>#</y><d>2020-06-23</d><h>19:00</h><r>phronmophobic</r>actually, <code>boolean</code> is probably clearer</z><z id="t1592938836" t="avi 😵"><y>#</y><d>2020-06-23</d><h>19:00</h><r>avi</r><b>😵</b></z><z id="t1592938839" t="phronmophobic (def data {:technologies {0 {&quot;recommendations&quot; [{&quot;ratified&quot; true}]} 1 {&quot;recommendations&quot; [{&quot;ratified&quot; false}]} 2 {&quot;recommendations&quot; []}}}) (spec/select [:technologies (spec/filterer (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot; boolean) spec/MAP-KEYS ] data)"><y>#</y><d>2020-06-23</d><h>19:00</h><r>phronmophobic</r><pre>(def data {:technologies
           {0 {&quot;recommendations&quot; [{&quot;ratified&quot; true}]}
            1 {&quot;recommendations&quot; [{&quot;ratified&quot; false}]}
            2 {&quot;recommendations&quot; []}}})

(spec/select [:technologies
              (spec/filterer  (spec/nthpath 1) &quot;recommendations&quot; spec/ALL &quot;ratified&quot; boolean)
              spec/MAP-KEYS
              ]
             data)</pre></z><z id="t1592938897" t="phronmophobic some? &apos;s doc string is correct: clojure.core/some? [x] Added in 1.6 Returns true if x is not nil, false otherwise."><y>#</y><d>2020-06-23</d><h>19:01</h><r>phronmophobic</r><code>some?</code>&apos;s doc string is correct:
<pre>clojure.core/some?
 [x]
Added in 1.6
  Returns true if x is not nil, false otherwise.</pre></z><z id="t1592938948" t="avi So some? is equivalent to (complement nil?) …. ?"><y>#</y><d>2020-06-23</d><h>19:02</h><r>avi</r>So <code>some?</code> is equivalent to <code>(complement nil?)</code>   …. ?</z><z id="t1592938988" t="avi Anyway, I still don’t quite get filterer — but a prerequisite to getting it is seeing what works. Which I’ve got now. Thank you so much!"><y>#</y><d>2020-06-23</d><h>19:03</h><r>avi</r>Anyway, I still don’t quite get <code>filterer</code> — but a prerequisite to getting it is seeing what works. Which I’ve got now. Thank you so much!</z><z id="t1592936998" t="Casey Is there away to setval on a path but only set the first matching value?"><y>#</y><d>2020-06-23</d><h>18:29</h><w>Casey</w>Is there away to setval on a path but only set the first matching value?</z><z id="t1592937265" t="Casey Using my example from before, if coll was (def coll [ [1 2 4] [3 5 8 4] [6] [] ]) I&apos;d like the result to be ;; =&gt; [ [1 2] [3 8 4] [] [] ] (that is, the 4 is only removed once)"><y>#</y><d>2020-06-23</d><h>18:34</h><w>Casey</w>Using my example from before, if coll was <code>(def coll [ [1 2 4] [3 5 8 4] [6] [] ])</code>   I&apos;d like the result to be <code>;; =&gt; [ [1 2] [3 8 4] [] [] ]</code>  (that is, the 4 is only removed once)</z><z id="t1592937324" t="Casey If I add a FIRST after the (fn ...) in the path, I get a Error: 4 is not ISeqable"><y>#</y><d>2020-06-23</d><h>18:35</h><w>Casey</w>If I add a <code>FIRST</code> after the <code>(fn ...)</code> in the path, I get a <code>Error: 4 is not ISeqable</code></z><z id="t1595853735" t="Vincent Cantin Hi. I am trying to collect all values which are associated to a keyword :tags in a hierarchy of maps. Is there an easy way to do that using Specter?"><y>#</y><d>2020-07-27</d><h>12:42</h><w>Vincent Cantin</w>Hi. I am trying to collect all values which are associated to a keyword <code>:tags</code> in a hierarchy of maps. Is there an easy way to do that using Specter?</z><z id="t1595855579" t="Vincent Cantin I tried this, but it does not walk into maps which have :tags : (s/select [(s/walker #(and (map? %) (contains? % :tags))) :tags s/ALL] {:a {:tags [1 {:tags [2]}]} :b {:tags [3]}}) ; =&gt; [1 {:tags [2]} 3]"><y>#</y><d>2020-07-27</d><h>13:12</h><w>Vincent Cantin</w>I tried this, but it does not walk into maps which have <code>:tags</code>:
<pre>(s/select [(s/walker #(and (map? %) (contains? % :tags))) :tags s/ALL]
          {:a {:tags [1 {:tags [2]}]}
           :b {:tags [3]}})
; =&gt; [1 {:tags [2]} 3]</pre></z><z id="t1595876002" t="nathanmarz @vincent.cantin easy to do with recursive-path user=&gt; (def data #_=&gt; {:a {:tags [1 {:tags [2]}]} #_=&gt; :b {:tags [3]}}) #&apos;user/data user=&gt; user=&gt; (def MY-WALKER #_=&gt; (recursive-path [] p #_=&gt; (continue-then-stay #_=&gt; (cond-path map? MAP-VALS #_=&gt; sequential? ALL) #_=&gt; p #_=&gt; ))) #&apos;user/MY-WALKER user=&gt; user=&gt; (select [MY-WALKER map? (must :tags) ALL] data) [2 1 {:tags [2]} 3] "><y>#</y><d>2020-07-27</d><h>18:53</h><w>nathanmarz</w>@vincent.cantin easy to do with <code>recursive-path</code>
<pre>user=&gt; (def data
  #_=&gt;   {:a {:tags [1 {:tags [2]}]}
  #_=&gt;    :b {:tags [3]}})
#&apos;user/data
user=&gt; 

user=&gt; (def MY-WALKER
  #_=&gt;   (recursive-path [] p
  #_=&gt;     (continue-then-stay
  #_=&gt;       (cond-path map? MAP-VALS
  #_=&gt;                  sequential? ALL)
  #_=&gt;       p
  #_=&gt;       )))
#&apos;user/MY-WALKER
user=&gt; 

user=&gt; (select [MY-WALKER map? (must :tags) ALL] data)
[2 1 {:tags [2]} 3]</pre>
</z><z id="t1595899775" t="Vincent Cantin @nathanmarz Thx"><y>#</y><d>2020-07-28</d><h>01:29</h><w>Vincent Cantin</w>@nathanmarz Thx</z><z id="t1597674113" t="mbertheau Hi! How would I go about sorting a sequence in specter, letting specter worry about creating the same sequence type?"><y>#</y><d>2020-08-17</d><h>14:21</h><w>mbertheau</w>Hi! How would I go about sorting a sequence in specter, letting specter worry about creating the same sequence type?</z><z id="t1597675137" t="phronmophobic how nested is your data? you might be able to get away with (into (empty coll) (sort coll))"><y>#</y><d>2020-08-17</d><h>14:38</h><r>phronmophobic</r>how nested is your data? you might be able to get away with <code>(into (empty coll) (sort coll))</code></z><z id="t1597771966" t="Vincent Cantin Assuming that we have a vector of hashmaps containing addresses, how to use specter to group them by :country , then by :city ? (I could do it without specter, but I am curious)"><y>#</y><d>2020-08-18</d><h>17:32</h><w>Vincent Cantin</w>Assuming that we have a vector of hashmaps containing addresses, how to use specter to group them by <code>:country</code>, then by <code>:city</code> ?
(I could do it without specter, but I am curious)</z><z id="t1597773926" t="isak (specter/select [(specter/transformed [] (partial group-by :country)) (specter/transformed [specter/MAP-VALS] (partial group-by :city))] addresses)"><y>#</y><d>2020-08-18</d><h>18:05</h><r>isak</r><pre>(specter/select [(specter/transformed [] (partial group-by :country))
                   (specter/transformed [specter/MAP-VALS] (partial group-by :city))]
                  addresses)</pre></z><z id="t1597773945" t="isak (i&apos;m kind of new, so maybe there is a smarter way)"><y>#</y><d>2020-08-18</d><h>18:05</h><r>isak</r>(i&apos;m kind of new, so maybe there is a smarter way)</z><z id="t1598189671" t="Vincent Cantin I noticed the s/view that could be used instead of s/transformed"><y>#</y><d>2020-08-23</d><h>13:34</h><r>Vincent Cantin</r>I noticed the <code>s/view</code> that could be used instead of <code>s/transformed</code></z><z id="t1598474703" t="fredmonroe im trying to make this: (def cells {:4 {:2 {:text &quot;fred&quot;, :datatype nil}}, :5 {:4 {:text &quot;bob&quot;, :datatype nil}}, :8 {:1 {:text &quot;fred&quot;, :datatype nil}}) become: [{:row 5 :col 5 :text &quot;bob&quot; :datattype nil}] so far i have this nav: (defn bob? [x] (= (:text x) &quot;bob&quot;)) (s/select [s/MAP-VALS s/MAP-VALS bob?] cells) which gives: [{:text &quot;bob&quot;, :datatype nil} i can&apos;t seem to figure out collect-*, putval and friends well enough to grab the keys along the path, appreciate any guidance anybody might have thank you"><y>#</y><d>2020-08-26</d><h>20:45</h><w>fredmonroe</w>im trying to make this:
<code>(def cells {:4 {:2 {:text &quot;fred&quot;, :datatype nil}}, :5 {:4 {:text &quot;bob&quot;, :datatype nil}}, :8 {:1 {:text &quot;fred&quot;, :datatype nil}})</code>

become:
<code>[{:row 5 :col 5 :text &quot;bob&quot; :datattype nil}]</code>

so far i have this nav:
<code>(defn bob? [x] (= (:text x) &quot;bob&quot;))</code>

<code>(s/select [s/MAP-VALS s/MAP-VALS bob?]  cells)</code>

which gives:
<code>[{:text &quot;bob&quot;, :datatype nil}</code>

i can&apos;t seem to figure out collect-*, putval and friends well enough to grab the keys along the path, appreciate any guidance anybody might have thank you</z><z id="t1598478954" t="arwakode Does this help? (sp/select [ALL (sp/collect-one [FIRST]) LAST ALL (sp/collect-one [FIRST]) LAST bob?] cells) "><y>#</y><d>2020-08-26</d><h>21:55</h><w>arwakode</w>Does this help?

<pre>(sp/select [ALL (sp/collect-one [FIRST]) LAST
              ALL (sp/collect-one [FIRST]) LAST
              bob?] cells)</pre>
</z><z id="t1598479003" t="arwakode I use ALL (sp/collect-one [FIRST]) LAST pattern to collect keys and continue on traversing."><y>#</y><d>2020-08-26</d><h>21:56</h><w>arwakode</w>I use <code>ALL (sp/collect-one [FIRST]) LAST</code> pattern to collect keys and continue on traversing.</z><z id="t1598479073" t="arwakode You get [[:5 :4 {:text &quot;bob&quot;, :datatype nil}]] which then i then guess you have to (map) to something to integrate into the the map at the third slot."><y>#</y><d>2020-08-26</d><h>21:57</h><w>arwakode</w>You get <code>[[:5 :4 {:text &quot;bob&quot;, :datatype nil}]]</code> which then i then guess you have to <code>(map)</code> to something to integrate into the the map at the third slot.</z><z id="t1598480240" t="fredmonroe YES thank you, you gave me a great insight there - by using MAP-VALS i was effectively stripping off access to the keys i needed to collect - i like the way you indented everything too - helps make clear how it works. thank you!"><y>#</y><d>2020-08-26</d><h>22:17</h><w>fredmonroe</w>YES thank you, you gave me a great insight there - by using MAP-VALS i was effectively stripping off access to the keys i needed to collect - i like the way you indented everything too - helps make clear how it works. thank you!</z><z id="t1599506171" t="Daniel Craig @nathanmarz Hi would you be interesting in presenting Specter for our meetup group? We’re the #mid-cities-meetup group based in Southlake Texas. We meet online every first Monday of the month and @johnjelinek and I are interested in learning about what Specter can do"><y>#</y><d>2020-09-07</d><h>19:16</h><w>Daniel Craig</w>@nathanmarz Hi would you be interesting in presenting Specter for our meetup group?  We’re the #mid-cities-meetup group based in Southlake Texas.  We meet online every first Monday of the month and @johnjelinek and I are interested in learning about what Specter can do</z><z id="t1599517901" t="nathanmarz @danielmartincraig don&apos;t have time unfortunately"><y>#</y><d>2020-09-07</d><h>22:31</h><w>nathanmarz</w>@danielmartincraig don&apos;t have time unfortunately</z><z id="t1599525335" t="Daniel Craig Ok thanks anyways"><y>#</y><d>2020-09-08</d><h>00:35</h><w>Daniel Craig</w>Ok thanks anyways</z><z id="t1599598993" t="Jeff Evans Is there any appetite for incorporating spec into Specter? Setting aside the tongue-twistedness of that combination…"><y>#</y><d>2020-09-08</d><h>21:03</h><w>Jeff Evans</w>Is there any appetite for incorporating <code>spec</code> into Specter?  Setting aside the tongue-twistedness of that combination…</z><z id="t1599623430" t="nathanmarz how so?"><y>#</y><d>2020-09-09</d><h>03:50</h><w>nathanmarz</w>how so?</z><z id="t1599655307" t="Petrus Theron How can I transform a nested data structure lazily and recursively with Specter, e.g. to recursively build out a tree with children given some roots? I read through the docs on Using Specter Recursively, but it&apos;s not obvious to me how to &quot;inject&quot; new values into the data structure while navigating."><y>#</y><d>2020-09-09</d><h>12:41</h><w>Petrus Theron</w>How can I transform a nested data structure lazily and recursively with Specter, e.g. to recursively build out a tree with children given some roots?

I read through the docs on Using Specter Recursively, but it&apos;s not obvious to me how to &quot;inject&quot; new values into the data structure while navigating.</z><z id="t1599668670" t="Jeff Evans Re: spec, was just thinking in terms of validating arguments to the macros. Although, that’s already happening in some places via: https://github.com/redplanetlabs/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L379"><y>#</y><d>2020-09-09</d><h>16:24</h><w>Jeff Evans</w>Re: spec, was just thinking in terms of validating arguments to the macros.  Although, that’s already happening in some places via: <a href="https://github.com/redplanetlabs/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L379" target="_blank">https://github.com/redplanetlabs/specter/blob/master/src/clj/com/rpl/specter/impl.cljc#L379</a></z><z id="t1599750408" t="unbalanced Hiya @nathanmarz! I was inspired by your recent hackernews article to try and jump into Specter again. I&apos;ve tried a few times in the path and... well, I&apos;m kind of thick, I think. Is there a most recent &quot;best way&quot; to learn Specter from the ground up?"><y>#</y><d>2020-09-10</d><h>15:06</h><w>unbalanced</w>Hiya @nathanmarz!  I was inspired by your recent hackernews article to try and jump into Specter again.  I&apos;ve tried a few times in the path and... well, I&apos;m kind of thick, I think.  Is there a most recent &quot;best way&quot; to learn Specter from the ground up?</z><z id="t1599751698" t="Jeff Evans did you see all the stuff listed here? https://github.com/redplanetlabs/specter"><y>#</y><d>2020-09-10</d><h>15:28</h><r>Jeff Evans</r>did you see all the stuff listed here?  <a href="https://github.com/redplanetlabs/specter" target="_blank">https://github.com/redplanetlabs/specter</a></z><z id="t1599767043" t="Jeff Evans Just noticed something interesting today. Having a dangling selected? (i.e. no more paths after it) works in clj but fails in cljs . (require &apos;[com.rpl.specter :as sp]) (sp/select [sp/ALL even? sp/selected?] [1 3 5]) # in clj =&gt; [] # in cljs Error: No protocol method ImplicitNav.implicit-nav defined for type cljs.core/MetaFn: [object Object]"><y>#</y><d>2020-09-10</d><h>19:44</h><w>Jeff Evans</w>Just noticed something interesting today.  Having a dangling <code>selected?</code> (i.e. no more paths after it) works in <code>clj</code> but fails in <code>cljs</code> .
<pre>(require &apos;[com.rpl.specter :as sp])
(sp/select [sp/ALL even? sp/selected?] [1 3 5])
# in clj
=&gt; []
# in cljs
Error: No protocol method ImplicitNav.implicit-nav defined for type cljs.core/MetaFn: [object Object]</pre></z><z id="t1599775045" t="nathanmarz @goomba the Learn Specter section on the github page is probably best place to start"><y>#</y><d>2020-09-10</d><h>21:57</h><w>nathanmarz</w>@goomba the Learn Specter section on the github page is probably best place to start</z><z id="t1599775181" t="nathanmarz @jeffrey.wayne.evans I guess MetaFn in cljs is not a function"><y>#</y><d>2020-09-10</d><h>21:59</h><w>nathanmarz</w>@jeffrey.wayne.evans I guess <code>MetaFn</code> in cljs is not a <code>function</code></z><z id="t1599775186" t="nathanmarz so the implicit nav doesn&apos;t kick in"><y>#</y><d>2020-09-10</d><h>21:59</h><w>nathanmarz</w>so the implicit nav doesn&apos;t kick in</z><z id="t1600190715" t="jsabeaudry Which predicate to use to only transform if the key is present? for example (transform [:a ?] inc {:b 2})"><y>#</y><d>2020-09-15</d><h>17:25</h><w>jsabeaudry</w>Which predicate to use to only transform if the key is present? for example <code>(transform [:a ?] inc {:b 2})</code></z><z id="t1600191552" t="phronmophobic must ? https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#must"><y>#</y><d>2020-09-15</d><h>17:39</h><w>phronmophobic</w><code>must</code> ? <a href="https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#must" target="_blank">https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#must</a></z><z id="t1600193493" t="jsabeaudry Yup, exactly! Thank you!"><y>#</y><d>2020-09-15</d><h>18:11</h><r>jsabeaudry</r>Yup, exactly! Thank you!</z><z id="t1600191668" t="phronmophobic &gt; (spec/transform [spec/ALL (spec/must :a)] inc [{:b 2} {:a 2}]) [{:b 2} {:a 3}]"><y>#</y><d>2020-09-15</d><h>17:41</h><w>phronmophobic</w><pre>&gt; (spec/transform [spec/ALL (spec/must :a)] inc [{:b 2}
                                                 {:a 2}])
[{:b 2} {:a 3}]</pre></z><z id="t1600992553" t="Jeff Evans Has anyone managed to use Specter in self-hosted CLJS?"><y>#</y><d>2020-09-25</d><h>00:09</h><w>Jeff Evans</w>Has anyone managed to use Specter in self-hosted CLJS?</z><z id="t1601037322" t="nathanmarz there&apos;s some tickets open for that"><y>#</y><d>2020-09-25</d><h>12:35</h><w>nathanmarz</w>there&apos;s some tickets open for that</z><z id="t1601037349" t="nathanmarz from what I recall there&apos;s some changes needed to the inline caching implementation to support bootstrap"><y>#</y><d>2020-09-25</d><h>12:35</h><w>nathanmarz</w>from what I recall there&apos;s some changes needed to the inline caching implementation to support bootstrap</z><z id="t1601037354" t="nathanmarz https://github.com/redplanetlabs/specter/issues/72"><y>#</y><d>2020-09-25</d><h>12:35</h><w>nathanmarz</w><a href="https://github.com/redplanetlabs/specter/issues/72" target="_blank">https://github.com/redplanetlabs/specter/issues/72</a></z><z id="t1601345025" t="jeaye Is there a more efficient way to do this (while keeping the recursive abilities)? (def ALL-RECURSIVE (recursive-path [] p (cond-path map? (stay-then-continue MAP-VALS p) coll? (stay-then-continue ALL p)))) (transform [ALL-RECURSIVE MAP-VALS (pred #(and (map? %) (contains? % :foo)))] :foo {:a {:foo :b}}) ; =&gt; {:a :b}"><y>#</y><d>2020-09-29</d><h>02:03</h><w>jeaye</w>Is there a more efficient way to do this (while keeping the recursive abilities)?

<pre>(def ALL-RECURSIVE (recursive-path [] p
                                   (cond-path
                                     map? (stay-then-continue MAP-VALS p)
                                     coll? (stay-then-continue ALL p))))
(transform [ALL-RECURSIVE MAP-VALS (pred #(and (map? %) (contains? % :foo)))]
           :foo
           {:a {:foo :b}}) ; =&gt; {:a :b}</pre></z><z id="t1601345762" t="Lucy Wang using walker? (transform [(walker (clojure.core/every-pred map? :foo))] :foo {:a {:foo :b}})"><y>#</y><d>2020-09-29</d><h>02:16</h><w>Lucy Wang</w>using walker?
<pre>(transform [(walker (clojure.core/every-pred map? :foo))]
           :foo
           {:a {:foo :b}})</pre></z><z id="t1601346661" t="jeaye I&apos;ll benchmark it."><y>#</y><d>2020-09-29</d><h>02:31</h><w>jeaye</w>I&apos;ll benchmark it.</z><z id="t1601346868" t="jeaye A bit slower, it seems. Mine was [:attrs nil] 13µs. I&apos;m doing some other things in the benchmark, which is why the numbers are higher than just benchmarking that one transform, but those things are constant across both tests."><y>#</y><d>2020-09-29</d><h>02:34</h><w>jeaye</w>A bit slower, it seems. Mine was <del>11µs. With the walker, it&apos;s </del>13µs. I&apos;m doing some other things in the benchmark, which is why the numbers are higher than just benchmarking that one transform, but those things are constant across both tests.</z><z id="t1601347056" t="jeaye Seems like your usage of every-pred is marginally faster than my and , though. 🙂"><y>#</y><d>2020-09-29</d><h>02:37</h><w>jeaye</w>Seems like your usage of <code>every-pred</code> is marginally faster than my <code>and</code>, though. <b>🙂</b></z><z id="t1601362253" t="Lucy Wang Or use meander (require &apos;[meander.epsilon :as m] &apos;[meander.strategy.epsilon :as m*]) (def replace-foo (m*/rewrite {:foo (m/some ?xs)} ?xs)) (def replace-all-foos (m*/until = (m*/bottom-up (m*/attempt replace-foo)))) (replace-all-foos {:a {:foo :b}}) "><y>#</y><d>2020-09-29</d><h>06:50</h><w>Lucy Wang</w>Or use meander
<pre>(require &apos;[meander.epsilon :as m]
         &apos;[meander.strategy.epsilon :as m*])

(def replace-foo
  (m*/rewrite
   {:foo (m/some ?xs)} ?xs))

(def replace-all-foos
  (m*/until =
    (m*/bottom-up
     (m*/attempt replace-foo))))

(replace-all-foos {:a {:foo :b}})</pre>
</z><z id="t1601875329" t="Patrick Farwick Is there a good way to get the value of a key that is the most deeply nested in a map? The map could have any level of nesting. So if I have {:a {:a 1 :b {:c 2 :d {:a {:e 4}}}}} I want {:e 4} but am having trouble getting there. Thanks"><y>#</y><d>2020-10-05</d><h>05:22</h><w>Patrick Farwick</w>Is there a good way to get the value of a key that is the most deeply nested in a map? The map could have any level of nesting.
So if I have <code>{:a {:a 1 :b {:c 2 :d {:a {:e 4}}}}}</code>
I want <code>{:e 4}</code> but am having trouble getting there. Thanks</z><z id="t1601914683" t="Jeff Evans you can use recursion. (def GET-E [(s/recursive-path [] p (s/if-path map? (s/if-path (s/must :e) (s/continue-then-stay [s/MAP-VALS p]) [s/MAP-VALS p]) s/STOP)) (s/submap [:e])]) (s/select GET-E {:a {:a 1 :b {:c 2 :d {:a {:e 4 :l 5}}}}}) =&gt; [{:e 4}]"><y>#</y><d>2020-10-05</d><h>16:18</h><w>Jeff Evans</w>you can use recursion.
<pre>(def GET-E [(s/recursive-path [] p
                    (s/if-path map?
                               (s/if-path (s/must :e) (s/continue-then-stay [s/MAP-VALS p]) [s/MAP-VALS p]) s/STOP)) (s/submap [:e])])

(s/select GET-E {:a {:a 1 :b {:c 2 :d {:a {:e 4 :l 5}}}}})
=&gt; [{:e 4}]</pre></z><z id="t1602062645" t="Petrus Theron How can I transform a map based on the key? E.g. (let [key-&gt;xf {:a inc, :b :dec}] (S/transform [?] key-&gt;xf {:a 10, :b 20, :c 30})) =&gt; {:a 11, :b 19, :c 30} I suspect I can use view or transformed for this, but not sure how. I found a FIND-KEYS navigator on SO that navigates to the values of matching keys, but it isn’t quite what I’m looking for: (def FIND-KEYS &quot;Like clojure.walk/postwalk but for Specter. Use as [FIND-KEYS (S/must :key)].&quot; (S/recursive-path [] p (S/cond-path map? (S/continue-then-stay [S/MAP-VALS p]) vector? [S/ALL p] S/STAY))) E.g. (S/select [FIND-KEYS (S/must :c)] {:a 123 :b {:c 456}}) =&gt; 456 I guess I can do it with a plain-old reduce-kv, but hoping I could do it with Specter: (defn transform-map [mappings m] (reduce-kv (fn [acc k vf] (if (contains? acc k) (update acc k vf) acc)) m mappings)) (transform-map {:a inc, :b dec} {:a 10, :b 20}) =&gt; {:a 11, :b 19}"><y>#</y><d>2020-10-07</d><h>09:24</h><w>Petrus Theron</w>How can I transform a map based on the key? E.g.
<pre>(let [key-&gt;xf {:a inc, :b :dec}]
  (S/transform [?] key-&gt;xf {:a 10, :b 20, :c 30}))
=&gt; {:a 11, :b 19, :c 30}</pre>
I suspect I can use <code>view</code> or <code>transformed</code> for this, but not sure how. I found a <code>FIND-KEYS</code> navigator on SO that navigates to the values of matching keys, but it isn’t quite what I’m looking for:
<pre>(def FIND-KEYS
  &quot;Like clojure.walk/postwalk but for Specter.
  Use as [FIND-KEYS (S/must :key)].&quot;
  (S/recursive-path [] p
    (S/cond-path map?
      (S/continue-then-stay [S/MAP-VALS p])
      vector? [S/ALL p]
      S/STAY)))</pre>
E.g.
<pre>(S/select [FIND-KEYS (S/must :c)] {:a 123 :b {:c 456}})
=&gt; 456</pre>
I guess I can do it with a plain-old reduce-kv, but hoping I could do it with Specter:
<pre>(defn transform-map
  [mappings m]
  (reduce-kv
    (fn [acc k vf]
      (if (contains? acc k)
        (update acc k vf)
        acc)) m mappings))

(transform-map {:a inc, :b dec} {:a 10, :b 20})
=&gt; {:a 11, :b 19}</pre></z><z id="t1602082300" t="Jeff Evans (def key-&gt;xf {:a inc :b dec :c identity}) (s/transform [s/ALL] (fn [entry] (let [[k v] entry] [k ((k key-&gt;xf) v)])) {:a 10, :b 20, :c 30}) =&gt; {:a 11, :b 19, :c 30}"><y>#</y><d>2020-10-07</d><h>14:51</h><w>Jeff Evans</w><pre>(def key-&gt;xf {:a inc :b dec :c identity})
(s/transform [s/ALL] (fn [entry] (let [[k v] entry] [k ((k key-&gt;xf) v)])) {:a 10, :b 20, :c 30})
=&gt; {:a 11, :b 19, :c 30}</pre></z><z id="t1602082337" t="Jeff Evans (`ALL` gives you key/value pairs in a vec)"><y>#</y><d>2020-10-07</d><h>14:52</h><w>Jeff Evans</w>(`ALL` gives you key/value pairs in a vec)</z><z id="t1602147585" t="Lucy Wang ☝️ IMHO the above code already lost the expressiveness people want to achieve by using specter"><y>#</y><d>2020-10-08</d><h>08:59</h><w>Lucy Wang</w><b>☝️</b> IMHO the above code already lost the expressiveness people want to achieve by using specter</z><z id="t1602626414" t="cjmurphy I also want to find particular keys and change their values, but in a recursive data structure. Here data just gets returned. Wanting to see the value [{:d 1} {:e 1}] be replaced by {:COUNTED 2} ."><y>#</y><d>2020-10-13</d><h>22:00</h><w>cjmurphy</w>I also want to find particular keys and change their values, but in a recursive data structure. Here <code>data</code> just gets returned. Wanting to see the value <code>[{:d 1} {:e 1}]</code> be replaced by <code>{:COUNTED 2}</code>.</z><z id="t1602646719" t="Lucy Wang (def map-walker (recursive-path [] p (cond-path map? [ALL p] [vector? FIRST #(= % :c)] LAST [vector?] [ALL p] ))) (let [data {:a 1 :b [{:z 1 :c [1 2 3]} {:c [{:d 1} {:e 1}]}]}] (transform [map-walker] #(array-map :COUNTED (count %)) data)) "><y>#</y><d>2020-10-14</d><h>03:38</h><w>Lucy Wang</w><pre>(def map-walker
    (recursive-path [] p
      (cond-path
       map?
       [ALL p]

       [vector? FIRST #(= % :c)]
       LAST

       [vector?]
       [ALL p]
       )))

(let [data {:a 1
            :b [{:z 1 :c [1 2 3]}
                {:c [{:d 1} {:e 1}]}]}]
  (transform [map-walker] #(array-map :COUNTED (count %)) data))</pre>
</z><z id="t1602649063" t="Lucy Wang The only downside is it would also transform a vector whose first element is :c as well"><y>#</y><d>2020-10-14</d><h>04:17</h><r>Lucy Wang</r>The only downside is it would also transform a vector whose first element is :c as well</z><z id="t1602657176" t="cjmurphy In reality there would never be such an element, because every vector has entities (maps) in it. Seems tricky compared to a solution not using specter. I honestly though the solution would be more straightforward than that. I just used being-counted-attributes rather than #(= % :c) , so #{:c} . Thank you @UP90Q48J3."><y>#</y><d>2020-10-14</d><h>06:32</h><r>cjmurphy</r>In reality there would never be such an element, because every vector has entities (maps) in it. Seems tricky compared to a solution not using specter. I honestly though the solution would be more straightforward than that. I just used <code>being-counted-attributes</code> rather than <code>#(= % :c)</code> , so <code>#{:c}</code> . Thank you @UP90Q48J3.</z><z id="t1602677707" t="Lucy Wang Yeah, for such cases you can simply write a recursive function instead of using specter, or combine specter with a recursive helper function."><y>#</y><d>2020-10-14</d><h>12:15</h><r>Lucy Wang</r>Yeah, for such cases you can simply write a recursive function instead of using specter, or combine specter with a recursive helper function.</z><z id="t1602646724" t="Lucy Wang @cjmurphy"><y>#</y><d>2020-10-14</d><h>03:38</h><w>Lucy Wang</w>@cjmurphy</z><z id="t1602704091" t="Jeff Evans well, I think I finally managed to get Specter working in cljs bootstrap: https://github.com/redplanetlabs/specter/issues/72"><y>#</y><d>2020-10-14</d><h>19:34</h><w>Jeff Evans</w>well, I think I finally managed to get Specter working in cljs bootstrap: <a href="https://github.com/redplanetlabs/specter/issues/72" target="_blank">https://github.com/redplanetlabs/specter/issues/72</a></z><z id="t1603288873" t="abdullahibra Hi everyone,"><y>#</y><d>2020-10-21</d><h>14:01</h><w>abdullahibra</w>Hi everyone,</z><z id="t1603288917" t="abdullahibra if i have a tree of nested lists with all keyword data type, what is the efficient pattern to select all sublists that start with specific keyword ?"><y>#</y><d>2020-10-21</d><h>14:01</h><w>abdullahibra</w>if i have a tree of nested lists with all keyword data type, what is the efficient pattern to select all sublists that start with specific keyword ?</z><z id="t1603288944" t="idiomancy can you give an example input output?"><y>#</y><d>2020-10-21</d><h>14:02</h><w>idiomancy</w>can you give an example input output?</z><z id="t1603289180" t="abdullahibra (:a (:x (:x :xoo) (:y (:ya :yay)) (:z (:t :till) (:y (:v :hello) (:h :world)))))"><y>#</y><d>2020-10-21</d><h>14:06</h><w>abdullahibra</w><pre>(:a
  (:x
   (:x :xoo) 
   (:y (:ya :yay))
   (:z (:t :till)
        (:y (:v :hello) (:h :world)))))</pre></z><z id="t1603289196" t="abdullahibra need to select all lists that starts with :y"><y>#</y><d>2020-10-21</d><h>14:06</h><w>abdullahibra</w>need to select all lists that starts with :y</z><z id="t1603289248" t="abdullahibra output (:y (:ya :yay)) (:y (:v :hello) (:h :world))"><y>#</y><d>2020-10-21</d><h>14:07</h><w>abdullahibra</w>output
<pre>(:y (:ya :yay))
(:y (:v :hello) (:h :world))</pre></z><z id="t1603296151" t="schmee @abdullahibra (def LISTS (recursive-path [] p (if-path list? (stay-then-continue ALL p) STOP))) user=&gt; (select [LISTS (selected? FIRST (pred= :y))] your-list) [(:y (:ya :yay)) (:y (:v :hello) (:h :world))])"><y>#</y><d>2020-10-21</d><h>16:02</h><w>schmee</w>@abdullahibra
<pre>(def LISTS
    (recursive-path [] p
      (if-path list?
        (stay-then-continue ALL p)
        STOP)))

  user=&gt; (select [LISTS (selected? FIRST (pred= :y))] your-list)
  [(:y (:ya :yay)) (:y (:v :hello) (:h :world))])</pre></z><z id="t1603297053" t="Lucy Wang or use walker (select [(walker (fn [x] (and (list? x) (= (first x) :y))))] &apos;(:a (:x (:x :xoo) (:y (:ya :yay)) (:z (:t :till) (:y (:v :hello) (:h :world)))))) ;; =&gt; [(:y (:ya :yay)) (:y (:v :hello) (:h :world))] "><y>#</y><d>2020-10-21</d><h>16:17</h><w>Lucy Wang</w>or use walker
<pre>(select [(walker (fn [x]
                   (and (list? x)
                        (= (first x) :y))))]
        &apos;(:a
         (:x
          (:x :xoo)
          (:y (:ya :yay))
          (:z (:t :till)
           (:y (:v :hello) (:h :world))))))
;; =&gt; [(:y (:ya :yay)) (:y (:v :hello) (:h :world))]</pre>
</z><z id="t1603297137" t="abdullahibra i have used tree-seq and filter based on some conditions and it&apos;s working, but it&apos;s worth to try those approaches too"><y>#</y><d>2020-10-21</d><h>16:18</h><w>abdullahibra</w>i have used tree-seq and filter based on some conditions and it&apos;s working, but it&apos;s worth to try those approaches too</z><z id="t1603821850" t="mathpunk I think I&apos;ve got a use case that specter might help, but I&apos;m brand new to it. I&apos;ve got data that looks like this: {:name &quot;Conditional Sections E2E Workflow&quot; :application {:name &quot;Conditional Sections&quot; :id &quot;someId&quot;}} There&apos;s nested maps, and any time there&apos;s an :id key in the map, I need to look up the value of :id in another map, and assoc that value in place."><y>#</y><d>2020-10-27</d><h>18:04</h><w>mathpunk</w>I think I&apos;ve got a use case that specter might help, but I&apos;m brand new to it. I&apos;ve got data that looks like this:
<pre>{:name &quot;Conditional Sections E2E Workflow&quot;
 :application {:name &quot;Conditional Sections&quot;
               :id &quot;someId&quot;}} </pre>
There&apos;s nested maps, and any time there&apos;s an <code>:id</code> key in the map, I need to look up the value of <code>:id</code> in another map, and assoc that value in place.</z><z id="t1603822171" t="mathpunk I&apos;m reading about navigators now... if y&apos;all have a pointer to the one/ones I need, I&apos;d appreciate it"><y>#</y><d>2020-10-27</d><h>18:09</h><w>mathpunk</w>I&apos;m reading about navigators now... if y&apos;all have a pointer to the one/ones I need, I&apos;d appreciate it</z><z id="t1603822295" t="idiomancy usually the best way to get help around here is to give a sample input and output. Someone will invariably take up the challenge as a little brain teaser to occupy themselves while they wait for their next meeting to start and post the answer"><y>#</y><d>2020-10-27</d><h>18:11</h><w>idiomancy</w>usually the best way to get help around here is to give a sample input and output.  Someone will invariably take up the challenge as a little brain teaser to occupy themselves while they wait for their next meeting to start and post the answer</z><z id="t1603822346" t="mathpunk I can do that, I&apos;ll find a good one"><y>#</y><d>2020-10-27</d><h>18:12</h><w>mathpunk</w>I can do that, I&apos;ll find a good one</z><z id="t1603823259" t="mathpunk Okay, suppose there is a map called state floating about, like shown. Here&apos;s the given data, and the desired data: {:state {&quot;FzPIxXKk&quot; {:name &quot;Conditional Sections E2E Workflow&quot; :id &quot;var&quot;}} :given {:name &quot;Conditional Sections E2E Workflow&quot; :application {:name &quot;Conditional Sections&quot; :id &quot;FzPIxXKk&quot;}} :desired {:name &quot;Conditional Sections E2E Workflow&quot; :application {:name &quot;Conditional Sections&quot; :id &quot;var&quot;}}} "><y>#</y><d>2020-10-27</d><h>18:27</h><w>mathpunk</w>Okay, suppose there is a map called <code>state</code> floating about, like shown. Here&apos;s the given data, and the desired data:
<pre>{:state {&quot;FzPIxXKk&quot; {:name &quot;Conditional Sections E2E Workflow&quot;
                          :id &quot;var&quot;}}
      :given {:name &quot;Conditional Sections E2E Workflow&quot;
              :application {:name &quot;Conditional Sections&quot;
                            :id &quot;FzPIxXKk&quot;}}
      :desired {:name &quot;Conditional Sections E2E Workflow&quot;
                :application {:name &quot;Conditional Sections&quot;
                              :id &quot;var&quot;}}}</pre>
</z><z id="t1603823363" t="mathpunk For reference, here is the brittle &quot;let&apos;s hope we got all the cases&quot; code I have for doing this: (defn return-with-id [exchange state] (assoc-in exchange [:required :id] (get (get state (get-in exchange [:required :id])) :id))) (defn return-with-application [exchange state] (assoc-in exchange [:required :application :id] (get (get state (get-in exchange [:required :application :id])) :id))) (defn return-with-parent [exchange state] (assoc-in exchange [:required :parent :id] (get (get state (get-in exchange [:required :parent :id])) :id))) (defn return-with-target [exchange state] (assoc-in exchange [:required :target :id] (get (get state (get-in exchange [:required :target :id])) :id))) (defn return [state exchange] (if (seq? exchange) (throw (Exception. &quot;Multiple requirements needed, invalidating my assumption about our data&quot;)) (cond-&gt; exchange (get state (get-in exchange [:required :id])) (return-with-id state) (get state (get-in exchange [:required :application :id])) (return-with-application state) (get state (get-in exchange [:required :target :id])) (return-with-target state) (get state (get-in exchange [:required :parent :id])) (return-with-parent state))))"><y>#</y><d>2020-10-27</d><h>18:29</h><w>mathpunk</w>For reference, here is the brittle &quot;let&apos;s hope we got all the cases&quot; code I have for doing this:
<pre>(defn return-with-id [exchange state]
  (assoc-in exchange [:required :id] (get (get state (get-in exchange [:required :id])) :id)))

(defn return-with-application [exchange state]
  (assoc-in exchange [:required :application :id] (get (get state (get-in exchange [:required :application :id])) :id)))

(defn return-with-parent [exchange state]
  (assoc-in exchange [:required :parent :id] (get (get state (get-in exchange [:required :parent :id])) :id)))

(defn return-with-target [exchange state]
  (assoc-in exchange [:required :target :id] (get (get state (get-in exchange [:required :target :id])) :id)))

(defn return [state exchange]
  (if (seq? exchange)
    (throw (Exception. &quot;Multiple requirements needed, invalidating my assumption about our data&quot;))
    (cond-&gt; exchange
      (get state (get-in exchange [:required :id])) (return-with-id state)
      (get state (get-in exchange [:required :application :id])) (return-with-application state)
      (get state (get-in exchange [:required :target :id])) (return-with-target state)
      (get state (get-in exchange [:required :parent :id])) (return-with-parent state))))</pre></z><z id="t1603823408" t="mathpunk I could replace those copypasta functions with one function that takes a path -- but it would still be, explicit paths."><y>#</y><d>2020-10-27</d><h>18:30</h><w>mathpunk</w>I could replace those copypasta functions with one function that takes a path -- but it would still be, explicit paths.</z><z id="t1603824150" t="mathpunk Then I&apos;d have, (defn update-with-path [state exchange path] (cond-&gt; exchange (get state (get-in exchange (concat [:required] path))) (assoc-in (concat [:required] path) (get (get state (get-in exchange (concat [:required] path))) :id)))) (defn return [state exchange] (if (seq? exchange) (throw (Exception. &quot;Multiple requirements needed, invalidating my assumption about our data&quot;)) (let [update-fn (partial update-with-path state)] (-&gt; exchange (update-fn [:id]) (update-fn [:application :id]) (update-fn [:target :id]) (update-fn [:parent :id])))))"><y>#</y><d>2020-10-27</d><h>18:42</h><w>mathpunk</w>Then I&apos;d have,
<pre>(defn update-with-path [state exchange path]
  (cond-&gt; exchange
    (get state (get-in exchange (concat [:required] path)))
    (assoc-in (concat [:required] path) (get (get state (get-in exchange (concat [:required] path))) :id))))

(defn return [state exchange]
  (if (seq? exchange)
    (throw (Exception. &quot;Multiple requirements needed, invalidating my assumption about our data&quot;))
    (let [update-fn (partial update-with-path state)]
      (-&gt; exchange
          (update-fn [:id])
          (update-fn [:application :id])
          (update-fn [:target :id])
          (update-fn [:parent :id])))))</pre></z><z id="t1603824215" t="mathpunk And hey, that does work: {:state {&quot;FzPIxXKk&quot; {:name &quot;Conditional Sections E2E Workflow&quot; :id &quot;var&quot;}} :given {:method &quot;POST&quot; :url &quot;&quot; :required {:name &quot;Conditional Sections E2E Workflow&quot; :application {:name &quot;Conditional Sections&quot; :id &quot;FzPIxXKk&quot;}}} ;; &lt;-- needs updating :result {:method &quot;POST&quot; :url &quot;&quot; :required {:name &quot;Conditional Sections E2E Workflow&quot; :application {:name &quot;Conditional Sections&quot; :id &quot;var&quot;}}}} ;; &lt;-- updated"><y>#</y><d>2020-10-27</d><h>18:43</h><w>mathpunk</w>And hey, that does work:
<pre>{:state {&quot;FzPIxXKk&quot; {:name &quot;Conditional Sections E2E Workflow&quot;
                     :id &quot;var&quot;}}
 :given {:method &quot;POST&quot;
         :url &quot;&quot;
         :required {:name &quot;Conditional Sections E2E Workflow&quot;
                    :application {:name &quot;Conditional Sections&quot;
                                  :id &quot;FzPIxXKk&quot;}}} ;; &lt;-- needs updating
 :result {:method &quot;POST&quot;
          :url &quot;&quot;
          :required {:name &quot;Conditional Sections E2E Workflow&quot;
                     :application {:name &quot;Conditional Sections&quot;
                                   :id &quot;var&quot;}}}} ;; &lt;-- updated</pre></z><z id="t1603824237" t="mathpunk but like i said, not generic, seems brittle, gotta know what paths to :id&apos;s exist in order to explicitly supply them"><y>#</y><d>2020-10-27</d><h>18:43</h><w>mathpunk</w>but like i said, not generic, seems brittle, gotta know what paths to :id&apos;s exist in order to explicitly supply them</z><z id="t1603826040" t="nathanmarz @mathpunk take a look at recursive-path , MAP-VALS , and stay-then-continue"><y>#</y><d>2020-10-27</d><h>19:14</h><w>nathanmarz</w>@mathpunk take a look at <code>recursive-path</code>, <code>MAP-VALS</code>, and <code>stay-then-continue</code></z><z id="t1603826057" t="nathanmarz you can define a navigator that goes to every nested map, and then from there do your lookup of the id"><y>#</y><d>2020-10-27</d><h>19:14</h><w>nathanmarz</w>you can define a navigator that goes to every nested map, and then from there do your lookup of the id</z><z id="t1603826107" t="nathanmarz e.g. (transform [ALL-MAPS (must :id)] (fn [id] (lookup-val-for-id id)) data)"><y>#</y><d>2020-10-27</d><h>19:15</h><w>nathanmarz</w>e.g. <code>(transform [ALL-MAPS (must :id)] (fn [id] (lookup-val-for-id id)) data)</code></z><z id="t1603826275" t="mathpunk great, thank you!"><y>#</y><d>2020-10-27</d><h>19:17</h><w>mathpunk</w>great, thank you!</z><z id="t1607705221" t="spieden Is it possible to extend the transform functionality to types other than the Clojure collections? I&apos;m seeking to transform a data structure that&apos;s in terms of some arbitrary Java classes."><y>#</y><d>2020-12-11</d><h>16:47</h><w>spieden</w>Is it possible to extend the <code>transform</code> functionality to types other than the Clojure collections? I&apos;m seeking to transform a data structure that&apos;s in terms of some arbitrary Java classes.</z><z id="t1607708459" t="spieden Looks like defrichnav is my friend :)"><y>#</y><d>2020-12-11</d><h>17:40</h><w>spieden</w>Looks like <code>defrichnav</code> is my friend :)</z><z id="t1607723141" t="Jeff Evans or defprotocolpath : https://github.com/redplanetlabs/specter/wiki/List-of-Macros#defprotocolpath"><y>#</y><d>2020-12-11</d><h>21:45</h><w>Jeff Evans</w>or <code>defprotocolpath</code>: <a href="https://github.com/redplanetlabs/specter/wiki/List-of-Macros#defprotocolpath" target="_blank">https://github.com/redplanetlabs/specter/wiki/List-of-Macros#defprotocolpath</a></z><z id="t1607724339" t="spieden Hmm, I see it takes params and one of them appears to be involved in the transform* implementation of a RichNavigator it creates, but I can&apos;t find any example usage of the latter."><y>#</y><d>2020-12-11</d><h>22:05</h><w>spieden</w>Hmm, I see it takes params and one of them appears to be involved in the <code>transform*</code> implementation of a <code>RichNavigator</code> it creates, but I can&apos;t find any example usage of the latter.</z><z id="t1607725593" t="spieden Seems like a different way to do recursion by dispatching by type?"><y>#</y><d>2020-12-11</d><h>22:26</h><w>spieden</w>Seems like a different way to do recursion by dispatching by type?</z><z id="t1608169473" t="Ronny Li Hi, if I have two maps with similar nesting and keys, can I use specter to perform an operation on both simultaneously? For example, multiply values that have the exact same keys? Basically I&apos;m looking for something like https://clojuredocs.org/clojure.core/merge-with but for an arbitrarily nested map"><y>#</y><d>2020-12-17</d><h>01:44</h><w>Ronny Li</w>Hi, if I have two maps with similar nesting and keys, can I use specter to perform an operation on both simultaneously? For example, multiply values that have the exact same keys?

Basically I&apos;m looking for something like <a href="https://clojuredocs.org/clojure.core/merge-with" target="_blank">https://clojuredocs.org/clojure.core/merge-with</a> but for an arbitrarily nested map</z><z id="t1608169691" t="Ronny Li Here&apos;s an example: {:price {&quot;TSLA&quot; {&quot;2020-11-01&quot; 400 &quot;2020-11-02&quot; 425 &quot;2020-11-03&quot; 420 &quot;2020-11-04&quot; 430 &quot;2020-11-05&quot; 430} &quot;GOOG&quot; {&quot;2020-11-01&quot; 500 &quot;2020-11-02&quot; 525 &quot;2020-11-03&quot; 520 &quot;2020-11-04&quot; 530 &quot;2020-11-05&quot; 530}}} {:weight {&quot;TSLA&quot; {&quot;2020-11-01&quot; 0.5 &quot;2020-11-02&quot; 0.6 &quot;2020-11-03&quot; 0.3 &quot;2020-11-04&quot; 0.4 &quot;2020-11-05&quot; 0.7} &quot;GOOG&quot; {&quot;2020-11-01&quot; 0.4 &quot;2020-11-02&quot; 0.425 &quot;2020-11-03&quot; 0.420 &quot;2020-11-04&quot; 0.43 &quot;2020-11-05&quot; 0.43}}} And my goal is to multiple :price and :weight together. How would I go about it with specter?"><y>#</y><d>2020-12-17</d><h>01:48</h><w>Ronny Li</w>Here&apos;s an example:
<pre>{:price {&quot;TSLA&quot;
    {&quot;2020-11-01&quot; 400
    &quot;2020-11-02&quot; 425
    &quot;2020-11-03&quot; 420
    &quot;2020-11-04&quot; 430
    &quot;2020-11-05&quot; 430}
    &quot;GOOG&quot;
    {&quot;2020-11-01&quot; 500
    &quot;2020-11-02&quot; 525
    &quot;2020-11-03&quot; 520
    &quot;2020-11-04&quot; 530
    &quot;2020-11-05&quot; 530}}}

{:weight {&quot;TSLA&quot;
    {&quot;2020-11-01&quot; 0.5
    &quot;2020-11-02&quot; 0.6
    &quot;2020-11-03&quot; 0.3
    &quot;2020-11-04&quot; 0.4
    &quot;2020-11-05&quot; 0.7}
    &quot;GOOG&quot;
    {&quot;2020-11-01&quot; 0.4
    &quot;2020-11-02&quot; 0.425
    &quot;2020-11-03&quot; 0.420
    &quot;2020-11-04&quot; 0.43
    &quot;2020-11-05&quot; 0.43}}}</pre>
And my goal is to multiple <code>:price</code> and <code>:weight</code> together. How would I go about it with specter?</z><z id="t1608553120" t="bruno.bonacci Hi, is there a way to distinguish between a path not found and a path-value with nil ? like get-in with default value? (get-in {&quot;foo&quot; nil} [&quot;foo&quot;] :not-found) ;;=&gt; nil (get-in {&quot;bar&quot; nil} [&quot;foo&quot;] :not-found) ;;=&gt; :not-found (select [&quot;foo&quot;] {&quot;foo&quot; nil}) ;;=&gt; [nil] (select [&quot;bar&quot;] {&quot;foo&quot; nil}) ;;=&gt; [nil]"><y>#</y><d>2020-12-21</d><h>12:18</h><w>bruno.bonacci</w>Hi,
is there a way to distinguish between a path not found and a path-value with <code>nil</code>? like <code>get-in</code> with default value?
<pre>(get-in {&quot;foo&quot; nil} [&quot;foo&quot;] :not-found) ;;=&gt; nil
(get-in {&quot;bar&quot; nil} [&quot;foo&quot;] :not-found) ;;=&gt; :not-found</pre>
<pre>(select [&quot;foo&quot;] {&quot;foo&quot; nil}) ;;=&gt; [nil]
(select [&quot;bar&quot;] {&quot;foo&quot; nil}) ;;=&gt; [nil]</pre></z><z id="t1608571760" t="nathanmarz [:attrs {:href &quot;/_/_/users/U0LCHMJTA&quot;}] use the must navigator"><y>#</y><d>2020-12-21</d><h>17:29</h><w>nathanmarz</w><a>@bruno.bonacci</a> use the <code>must</code> navigator</z><z id="t1608571829" t="bruno.bonacci ok, however must uses contains? which fails if it not a map"><y>#</y><d>2020-12-21</d><h>17:30</h><w>bruno.bonacci</w>ok, however <code>must</code> uses <code>contains?</code> which fails if it not a map</z><z id="t1608571889" t="bruno.bonacci so i have to put a guard predicate on every nesting to check that is a map"><y>#</y><d>2020-12-21</d><h>17:31</h><w>bruno.bonacci</w>so i have to put a guard predicate on every nesting to check that is a map</z><z id="t1608571956" t="bruno.bonacci like [(pred map?) (must &quot;foo&quot;) (pred map?) (must &quot;bar&quot;) (pred map?) (must &quot;baz&quot;)]"><y>#</y><d>2020-12-21</d><h>17:32</h><w>bruno.bonacci</w>like <code>[(pred map?) (must &quot;foo&quot;) (pred map?) (must &quot;bar&quot;) (pred map?) (must &quot;baz&quot;)]</code></z><z id="t1608572241" t="bruno.bonacci example: (get-in {&quot;foo&quot; 1} [&quot;foo&quot; &quot;bar&quot;] :not-found) ;;=&gt; :not-found (select [(must &quot;foo&quot;) (must &quot;bar&quot;)] {&quot;foo&quot; 1}) throws: Execution error (IllegalArgumentException) at com.rpl.specter.navs$fn$reify__33786/select_STAR_ (navs.cljc:655). contains? not supported on type: java.lang.Long"><y>#</y><d>2020-12-21</d><h>17:37</h><w>bruno.bonacci</w>example:
<code>(get-in {&quot;foo&quot; 1} [&quot;foo&quot; &quot;bar&quot;] :not-found) ;;=&gt; :not-found</code>
 <code>(select [(must &quot;foo&quot;) (must &quot;bar&quot;)] {&quot;foo&quot; 1})</code>
throws:

Execution error (IllegalArgumentException) at com.rpl.specter.navs$fn$reify__33786/select_STAR_ (navs.cljc:655).
contains? not supported on type: java.lang.Long</z><z id="t1608573634" t="nathanmarz personally I think it&apos;s a good thing specter throws an exception in that case"><y>#</y><d>2020-12-21</d><h>18:00</h><w>nathanmarz</w>personally I think it&apos;s a good thing specter throws an exception in that case</z><z id="t1608573644" t="nathanmarz but you can always write your own navigator with the more lenient behavior"><y>#</y><d>2020-12-21</d><h>18:00</h><w>nathanmarz</w>but you can always write your own navigator with the more lenient behavior</z><z id="t1608655486" t="denik Is there a way to use specter to traverse a nested map and return the key paths where a predicate on the value returns true?"><y>#</y><d>2020-12-22</d><h>16:44</h><w>denik</w>Is there a way to use specter to traverse a nested map and return the key paths where a predicate on the value returns true?</z><z id="t1608655623" t="denik for example, if the predicate is string? and this is the nested map {:a &quot;foo&quot; :b {:c {:d &quot;bar&quot;} :e 42}} it should return [[:a] [:b :c :d]]"><y>#</y><d>2020-12-22</d><h>16:47</h><w>denik</w>for example, if the predicate is <code>string?</code> and this is the nested map
<pre>{:a &quot;foo&quot; 
 :b {:c {:d &quot;bar&quot;}
     :e 42}}</pre>
it should return
<pre>[[:a]
 [:b :c :d]]</pre></z><z id="t1608660640" t="denik got it to work! the only part that’s missing now is to return :a and :x in a vector, like [[:a] [:x] [:b :c :d] [:b :f :y]] (do (defn paths-till-pred [v-pred data] (let [walker (recursive-path [] p (if-path map? [ALL (if-path [LAST v-pred] FIRST [(collect-one FIRST) ALL p])]))] (select walker data) )) (paths-till-pred string? {:a &quot;foo&quot; :x &quot;foo&quot; :b {:c {:d &quot;bar&quot;} :e 42 :f {:y &quot;baz&quot;}}})) =&gt; [:a :x [:b :c :d] [:b :f :y]]"><y>#</y><d>2020-12-22</d><h>18:10</h><w>denik</w>got it to work! the only part that’s missing now is to return <code>:a</code> and <code>:x</code> in a vector, like <code>[[:a] [:x] [:b :c :d] [:b :f :y]]</code>
<pre>(do
    (defn paths-till-pred [v-pred data]
      (let [walker (recursive-path [] p
                                   (if-path map?
                                            [ALL
                                             (if-path [LAST v-pred]
                                                      FIRST
                                                      [(collect-one FIRST) ALL p])]))]
        (select walker data)
        ))

    (paths-till-pred string? {:a &quot;foo&quot;
                             :x &quot;foo&quot;
                             :b {:c {:d &quot;bar&quot;}
                                 :e 42
                                 :f {:y &quot;baz&quot;}}}))
=&gt; [:a :x [:b :c :d] [:b :f :y]]</pre></z><z id="t1612921034" t="richiardiandrea Hi there long time no see 😄 I have a question, I have something like {:image_descriptors [{:image_id &quot;9ab5f0ec-cbe0-4cb1-bf5b-f178a7522693&quot;, :image_caption &quot;teat&quot;}]} And I want to convert keys to kebab and transform the image-id with a custom str-&gt;clj Is it possible to achieve that in one shot with multi-transform ? I cannot seem to have it working cause specter/MAP-KEYS gives me: (specter/multi-transform [specter/MAP-KEYS (specter/terminal utils/-&gt;memo-kebab-case-keyword)] {:image_descriptors [{:image_id &quot;9ab5f0ec-cbe0-4cb1-bf5b-f178a7522693&quot;, :image_caption &quot;teat&quot;}]}) =&gt; {:image-descriptors [{:image_id &quot;9ab5f0ec-cbe0-4cb1-bf5b-f178a7522693&quot;, :image_caption &quot;teat&quot;}]}"><y>#</y><d>2021-02-10</d><h>01:37</h><w>richiardiandrea</w>Hi there long time no see <b>😄</b>

I have a question, I have something like <code>{:image_descriptors [{:image_id &quot;9ab5f0ec-cbe0-4cb1-bf5b-f178a7522693&quot;, :image_caption &quot;teat&quot;}]}</code>

And I want to convert keys to kebab and transform the <code>image-id</code> with a custom <code>str-&gt;clj</code>

Is it possible to achieve that in one shot with <code>multi-transform</code>?

I cannot seem to have it working cause <code>specter/MAP-KEYS</code> gives me:

<pre>(specter/multi-transform [specter/MAP-KEYS (specter/terminal utils/-&gt;memo-kebab-case-keyword)]
  {:image_descriptors [{:image_id &quot;9ab5f0ec-cbe0-4cb1-bf5b-f178a7522693&quot;, :image_caption &quot;teat&quot;}]}) 

=&gt; {:image-descriptors [{:image_id &quot;9ab5f0ec-cbe0-4cb1-bf5b-f178a7522693&quot;, :image_caption &quot;teat&quot;}]}</pre></z><z id="t1613338918" t="nathanmarz [:attrs {:href &quot;/_/_/users/U0C8489U6&quot;}] you&apos;re looking for something like: (multi-transform [ALL (multi-path [FIRST (terminal utils/-&gt;memo-kebab-case-keyword)] [LAST ALL (map-key :image_id) (terminal ...)] )] data )"><y>#</y><d>2021-02-14</d><h>21:41</h><w>nathanmarz</w><a>@richiardiandrea</a> you&apos;re looking for something like:
<pre>(multi-transform
  [ALL
   (multi-path
     [FIRST (terminal utils/-&gt;memo-kebab-case-keyword)]
     [LAST ALL (map-key :image_id) (terminal ...)]
     )]
  data
  )</pre></z><z id="t1613492922" t="richiardiandrea cool I knew I could do it - it just did not click the right way 😄"><y>#</y><d>2021-02-16</d><h>16:28</h><r>richiardiandrea</r>cool I knew I could do it - it just did not click the right way <b>😄</b></z><z id="t1613709963" t="richiardiandrea is there a way to tell specter - don&apos;t stop navigation if a path is not met? I have (def TREE-VALS (specter/recursive-path [] p (specter/if-path sequential? [specter/ALL p] specter/STAY))) (defn strip-key-namespace &quot;Recursively strip out namespaces from keywords.&quot; [m] ;; see (specter/setval [TREE-VALS specter/MAP-KEYS specter/NAMESPACE] nil m)) But if the navigator does not find a keyword or a symbol with a namespace it won&apos;t go further... I am thinking of tweaking the recursive navigator there but I want to make sure I am not missing something."><y>#</y><d>2021-02-19</d><h>04:46</h><w>richiardiandrea</w>is there a way to tell specter - don&apos;t stop navigation if a path is not met?

I have
<pre>(def TREE-VALS
  (specter/recursive-path [] p
    (specter/if-path sequential?
	  [specter/ALL p]
	  specter/STAY)))

(defn strip-key-namespace
  &quot;Recursively strip out namespaces from keywords.&quot;
  [m]
  ;; see 
  (specter/setval [TREE-VALS specter/MAP-KEYS specter/NAMESPACE] nil m))</pre>
But if the navigator does not find a keyword or a symbol with a namespace it won&apos;t go further...

I am thinking of tweaking the recursive navigator there but I want to make sure I am not missing something.</z><z id="t1613752466" t="richiardiandrea ended up with a post walk (def POST-ORDER-TREE-VALS (specter/recursive-path [] p (specter/cond-path map? (specter/continue-then-stay [specter/MAP-VALS p]) sequential? [specter/ALL p] set? [specter/ALL p] specter/STAY))) (defn strip-key-namespace &quot;Recursively strip out namespaces from keywords.&quot; [m] ;; see (specter/setval [POST-ORDER-TREE-VALS specter/MAP-KEYS qualified-keyword? specter/NAMESPACE] nil m)) seems to work well in the tests"><y>#</y><d>2021-02-19</d><h>16:34</h><w>richiardiandrea</w>ended up with a post walk

<pre>(def POST-ORDER-TREE-VALS
  (specter/recursive-path [] p
    (specter/cond-path
     map? (specter/continue-then-stay [specter/MAP-VALS p])
     sequential? [specter/ALL p]
     set? [specter/ALL p]
     specter/STAY)))

(defn strip-key-namespace
  &quot;Recursively strip out namespaces from keywords.&quot;
  [m]
  ;; see 
  (specter/setval [POST-ORDER-TREE-VALS
                   specter/MAP-KEYS
                   qualified-keyword?
                   specter/NAMESPACE] nil m))</pre>
seems to work well in the tests</z><z id="t1613813673" t="mrchance Hi, I&apos;m trying to use specter in cljs, but I can&apos;t get it to work. Even for examples from the tutorial, I get: (setval {:a [1 2 3]} [:a s/END] [4 5]) Error: No protocol method ImplicitNav.implicit-nav defined for type cljs.core/PersistentArrayMap: {:a [1 2 3]} Am I doing something wrong?"><y>#</y><d>2021-02-20</d><h>09:34</h><w>mrchance</w>Hi, I&apos;m trying to use specter in cljs, but I can&apos;t get it to work. Even for examples from the tutorial, I get:
<pre>(setval {:a [1 2 3]} [:a s/END] [4 5])
Error: No protocol method ImplicitNav.implicit-nav defined for type cljs.core/PersistentArrayMap: {:a [1 2 3]}</pre>
Am I doing something wrong?</z><z id="t1613826410" t="Jeff Evans Looks like you did not require the namespace properly"><y>#</y><d>2021-02-20</d><h>13:06</h><w>Jeff Evans</w>Looks like you did not require the namespace properly</z><z id="t1613840524" t="mrchance I did require [com.rpl.specter :as s :refer-macros [setval]] , do I need more?"><y>#</y><d>2021-02-20</d><h>17:02</h><w>mrchance</w>I did require <code>[com.rpl.specter :as s :refer-macros [setval]]</code> , do I need more?</z><z id="t1613842347" t="Jeff Evans I think you don&apos;t want to use refer-macros. Use prefix qualification for setval. CLJS doesn&apos;t have access to macros at runtime."><y>#</y><d>2021-02-20</d><h>17:32</h><w>Jeff Evans</w>I think you don&apos;t want to use refer-macros. Use prefix qualification for setval. CLJS doesn&apos;t have access to macros at runtime.</z><z id="t1613852158" t="mrchance Hm, thanks for the support, I looked into it, but I don&apos;t think that&apos;s it, that&apos;s more or less exactly the line recommended in the spectre README... https://github.com/redplanetlabs/specter#clojurescript"><y>#</y><d>2021-02-20</d><h>20:15</h><w>mrchance</w>Hm, thanks for the support, I looked into it, but I don&apos;t think that&apos;s it, that&apos;s more or less exactly the line recommended in the spectre README... <a href="https://github.com/redplanetlabs/specter#clojurescript" target="_blank">https://github.com/redplanetlabs/specter#clojurescript</a></z><z id="t1613852457" t="Jeff Evans Oh actually, different problem. There is no implicit navigator for maps like that. Not sure where your snippet came from but it&apos;s not a valid navigator. See, ex: https://github.com/redplanetlabs/specter/pull/292"><y>#</y><d>2021-02-20</d><h>20:20</h><w>Jeff Evans</w>Oh actually, different problem. There is no implicit navigator for maps like that. Not sure where your snippet came from but it&apos;s not a valid navigator. See, ex: <a href="https://github.com/redplanetlabs/specter/pull/292" target="_blank">https://github.com/redplanetlabs/specter/pull/292</a></z><z id="t1613852578" t="mrchance The example is also taken verbatim from the readme... Maybe you could explain a bit how implicit navigators work and what they&apos;re needed for? I thought my path was pretty explicit :D"><y>#</y><d>2021-02-20</d><h>20:22</h><w>mrchance</w>The example is also taken verbatim from the readme... Maybe you could explain a bit how implicit navigators work and what they&apos;re needed for? I thought my path was pretty explicit :D</z><z id="t1613852631" t="mrchance Oh, nvm, I messed up the order 🙈"><y>#</y><d>2021-02-20</d><h>20:23</h><w>mrchance</w>Oh, nvm, I messed up the order <b>🙈</b></z><z id="t1613852637" t="Jeff Evans I don&apos;t see that in the readme"><y>#</y><d>2021-02-20</d><h>20:23</h><w>Jeff Evans</w>I don&apos;t see that in the readme</z><z id="t1613852638" t="mrchance You&apos;re right, that&apos;s just wrong"><y>#</y><d>2021-02-20</d><h>20:23</h><w>mrchance</w>You&apos;re right, that&apos;s just wrong</z><z id="t1613852649" t="mrchance (setval [:a END] [4 5] data) That&apos;s the example"><y>#</y><d>2021-02-20</d><h>20:24</h><w>mrchance</w><pre>(setval [:a END] [4 5] data)</pre>
That&apos;s the example</z><z id="t1613852741" t="mrchance Turns out, if you do it correctly, it works! Who would&apos;ve thought. Thank you for pointing it out, not sure how I overlooked that, stared at the line several times. Probably not having a good day 😅"><y>#</y><d>2021-02-20</d><h>20:25</h><w>mrchance</w>Turns out, if you do it correctly, it works! Who would&apos;ve thought. Thank you for pointing it out, not sure how I overlooked that, stared at the line several times. Probably not having a good day <b>😅</b></z><z id="t1613853607" t="Jeff Evans It happens :man-shrugging:"><y>#</y><d>2021-02-20</d><h>20:40</h><w>Jeff Evans</w>It happens <b>:man-shrugging:</b></z><z id="t1614642586" t="richiardiandrea Hi there, does empty &apos;s implementation currently work on records? I get: Exception in thread &quot;async-dispatch-6&quot; java.lang.UnsupportedOperationException: Can&apos;t create empty: appserver.lib.transport.data.Envelope at appserver.lib.transport.data.Envelope.empty(data.clj:66) at clojure.core$empty.invokeStatic(core.clj:5247) at clojure.core$empty.invoke(core.clj:5241) at com.rpl.specter.navs$eval4989$fn__4990.invoke(navs.cljc:363) at com.rpl.specter.navs$eval4923$fn__4924$G__4912__4931.invoke(navs.cljc:222) at com.rpl.specter$reify__5662.transform_STAR_(specter.cljc:707) at com.rpl.specter.impl$combine_two_navs$reify__3927.transform_STAR_(impl.cljc:200) at com.rpl.specter$fn__6212$fn$reify__6214.transform_STAR_(specter.cljc:1423) at com.rpl.specter.navs$if_transform.invokeStatic(navs.cljc:411) at com.rpl.specter.navs$if_transform.invoke(navs.cljc:410) at com.rpl.specter$fn__6185$fn$reify__6187.transform_STAR_(specter.cljc:1362) at com.rpl.specter.impl$cell_nav$reify__4213.transform_STAR_(impl.cljc:514) at com.rpl.specter.impl$combine_two_navs$reify__3927$fn__3933.invoke(impl.cljc:202) at com.rpl.specter$reify__5662$next_fn__5668.invoke(specter.cljc:698) at com.rpl.specter.navs$eval4967$fn__4968.invoke(navs.cljc:270) at com.rpl.specter.navs$eval4923$fn__4924$G__4912__4931.invoke(navs.cljc:222) at com.rpl.specter$reify__5662.transform_STAR_(specter.cljc:707) at com.rpl.specter.impl$combine_two_navs$reify__3927.transform_STAR_(impl.cljc:200) at com.rpl.specter$fn__6212$fn$reify__6214.transform_STAR_(specter.cljc:1423) at com.rpl.specter.navs$if_transform.invokeStatic(navs.cljc:411) at com.rpl.specter.navs$if_transform.invoke(navs.cljc:410) at com.rpl.specter$fn__6185$fn$reify__6187.transform_STAR_(specter.cljc:1362) at com.rpl.specter.impl$cell_nav$reify__4213.transform_STAR_(impl.cljc:514) at com.rpl.specter.impl$combine_two_navs$reify__3927.transform_STAR_(impl.cljc:200) at com.rpl.specter.impl$combine_two_navs$reify__3927.transform_STAR_(impl.cljc:200) at com.rpl.specter.impl$combine_two_navs$reify__3927.transform_STAR_(impl.cljc:200) at com.rpl.specter.impl$combine_two_navs$reify__3927.transform_STAR_(impl.cljc:200) at com.rpl.specter.impl$compiled_transform_STAR_.invokeStatic(impl.cljc:411) at com.rpl.specter.impl$compiled_transform_STAR_.invoke(impl.cljc:410) Difficult to understand where the problem is coming from but I am using something like this for traversing (def POST-ORDER-TREE-VALS (specter/recursive-path [] p (specter/cond-path map? (specter/continue-then-stay [specter/MAP-VALS p]) sequential? [specter/ALL p] set? [specter/ALL p] specter/STAY)))"><y>#</y><d>2021-03-01</d><h>23:49</h><w>richiardiandrea</w>Hi there, does <code>empty</code> &apos;s implementation currently work on records? I get:

<pre>Exception in thread &quot;async-dispatch-6&quot; java.lang.UnsupportedOperationException: Can&apos;t create empty: appserver.lib.transport.data.Envelope
	at appserver.lib.transport.data.Envelope.empty(data.clj:66)
	at clojure.core$empty.invokeStatic(core.clj:5247)
	at clojure.core$empty.invoke(core.clj:5241)
	at com.rpl.specter.navs$eval4989$fn__4990.invoke(navs.cljc:363)
	at com.rpl.specter.navs$eval4923$fn__4924$G__4912__4931.invoke(navs.cljc:222)
	at com.rpl.specter$reify__5662.transform_STAR_(specter.cljc:707)
	at com.rpl.specter.impl$combine_two_navs$reify__3927.transform_STAR_(impl.cljc:200)
	at com.rpl.specter$fn__6212$fn$reify__6214.transform_STAR_(specter.cljc:1423)
	at com.rpl.specter.navs$if_transform.invokeStatic(navs.cljc:411)
	at com.rpl.specter.navs$if_transform.invoke(navs.cljc:410)
	at com.rpl.specter$fn__6185$fn$reify__6187.transform_STAR_(specter.cljc:1362)
	at com.rpl.specter.impl$cell_nav$reify__4213.transform_STAR_(impl.cljc:514)
	at com.rpl.specter.impl$combine_two_navs$reify__3927$fn__3933.invoke(impl.cljc:202)
	at com.rpl.specter$reify__5662$next_fn__5668.invoke(specter.cljc:698)
	at com.rpl.specter.navs$eval4967$fn__4968.invoke(navs.cljc:270)
	at com.rpl.specter.navs$eval4923$fn__4924$G__4912__4931.invoke(navs.cljc:222)
	at com.rpl.specter$reify__5662.transform_STAR_(specter.cljc:707)
	at com.rpl.specter.impl$combine_two_navs$reify__3927.transform_STAR_(impl.cljc:200)
	at com.rpl.specter$fn__6212$fn$reify__6214.transform_STAR_(specter.cljc:1423)
	at com.rpl.specter.navs$if_transform.invokeStatic(navs.cljc:411)
	at com.rpl.specter.navs$if_transform.invoke(navs.cljc:410)
	at com.rpl.specter$fn__6185$fn$reify__6187.transform_STAR_(specter.cljc:1362)
	at com.rpl.specter.impl$cell_nav$reify__4213.transform_STAR_(impl.cljc:514)
	at com.rpl.specter.impl$combine_two_navs$reify__3927.transform_STAR_(impl.cljc:200)
	at com.rpl.specter.impl$combine_two_navs$reify__3927.transform_STAR_(impl.cljc:200)
	at com.rpl.specter.impl$combine_two_navs$reify__3927.transform_STAR_(impl.cljc:200)
	at com.rpl.specter.impl$combine_two_navs$reify__3927.transform_STAR_(impl.cljc:200)
	at com.rpl.specter.impl$compiled_transform_STAR_.invokeStatic(impl.cljc:411)
	at com.rpl.specter.impl$compiled_transform_STAR_.invoke(impl.cljc:410)</pre>
Difficult to understand where the problem is coming from but I am using something like this for traversing

<pre>(def POST-ORDER-TREE-VALS
  (specter/recursive-path [] p
    (specter/cond-path
     map? (specter/continue-then-stay [specter/MAP-VALS p])
     sequential? [specter/ALL p]
     set? [specter/ALL p]
     specter/STAY)))</pre></z><z id="t1614642748" t="richiardiandrea maybe that map? needs to become record? or something? Trying in the REPL"><y>#</y><d>2021-03-01</d><h>23:52</h><w>richiardiandrea</w>maybe that <code>map?</code> needs to become <code>record?</code> or something? Trying in the REPL</z><z id="t1614643277" t="richiardiandrea uhm, specter/select does actually return without throwing"><y>#</y><d>2021-03-02</d><h>00:01</h><w>richiardiandrea</w>uhm, <code>specter/select</code> does actually return without throwing</z><z id="t1614649915" t="richiardiandrea working around with (into {} ...) but please let me know if this is worth opening an issue ☝️"><y>#</y><d>2021-03-02</d><h>01:51</h><w>richiardiandrea</w>working around with <code>(into {} ...)</code> but please let me know if this is worth opening an issue <b>☝️</b></z><z id="t1614652885" t="nathanmarz [:attrs {:href &quot;/_/_/users/U0C8489U6&quot;}] MAP-VALS doesn&apos;t work on records"><y>#</y><d>2021-03-02</d><h>02:41</h><w>nathanmarz</w><a>@richiardiandrea</a> <code>MAP-VALS</code> doesn&apos;t work on records</z><z id="t1614652968" t="nathanmarz it&apos;s already based on a protocol, so it might be possible to make an implementation that works for records"><y>#</y><d>2021-03-02</d><h>02:42</h><w>nathanmarz</w>it&apos;s already based on a protocol, so it might be possible to make an implementation that works for records</z><z id="t1614652970" t="nathanmarz worth a ticket"><y>#</y><d>2021-03-02</d><h>02:42</h><w>nathanmarz</w>worth a ticket</z><z id="t1614700609" t="richiardiandrea https://github.com/redplanetlabs/specter/issues/303 Done thank you Nathan"><y>#</y><d>2021-03-02</d><h>15:56</h><r>richiardiandrea</r><a href="https://github.com/redplanetlabs/specter/issues/303" target="_blank">https://github.com/redplanetlabs/specter/issues/303</a>

Done thank you Nathan</z><z id="t1617129902" t="stopa Hey team, noob question (not quite sure how to search for above) I want to do the following: (def xs [{:name &quot;foo&quot; :x 1}] (def to-add-a {:name &quot;foo&quot; :x nil}) (def to-add-b {:name &quot;bar&quot; :x nil}) I want to updated xs , so a) If the record’s name matches, we do nothing: xs + to-add-a =&gt; [{:name &quot;foo&quot; :x 1}] b) but if the record does not exist, to append it: xs + to add-b =&gt; [{:name &quot;foo&quot; :x 1} {:name &quot;bar&quot; :x nil}] How could I achieve this with spectr?"><y>#</y><d>2021-03-30</d><h>18:45</h><w>stopa</w>Hey team, noob question (not quite sure how to search for above)

I want to do the following:
<pre>(def xs [{:name &quot;foo&quot; :x 1}]
(def to-add-a {:name &quot;foo&quot; :x nil})
(def to-add-b {:name &quot;bar&quot; :x nil})</pre>
I want to updated <code>xs</code>, so
a) If the record’s <code>name</code> matches, we do nothing:
<pre>xs + to-add-a =&gt; [{:name &quot;foo&quot; :x 1}]</pre>
b) but if the record does not exist, to append it:
<pre>xs + to add-b =&gt; [{:name &quot;foo&quot;  :x 1} {:name &quot;bar&quot; :x nil}]</pre>
How could I achieve this with spectr?</z><z id="t1617130475" t="nathanmarz [:attrs {:href &quot;/_/_/users/U0C5DE6RK&quot;}] this would be one way to do it: (defn add-record [all record] (setval [(not-selected? ALL :name (pred= (:name record))) AFTER-ELEM] record all))"><y>#</y><d>2021-03-30</d><h>18:54</h><w>nathanmarz</w><a>@stopachka</a> this would be one way to do it:
<pre>(defn add-record [all record]
  (setval [(not-selected? ALL :name (pred= (:name record)))
           AFTER-ELEM]
           record
           all))</pre></z><z id="t1617130511" t="stopa niice. Thanks [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] !"><y>#</y><d>2021-03-30</d><h>18:55</h><w>stopa</w>niice. Thanks <a>@nathanmarz</a>!</z><z id="t1617134890" t="stopa Okay, one more: Say I have (def name-&gt;objects {&quot;foo&quot;: [{:name &quot;foo&quot; :x 1]}) (def to-add-a {:name &quot;foo&quot; :x nil}) (def to-add-b {:name &quot;bar&quot; :x nil}) Now, I want to: a. Either append into existing: name-&gt;objects + to-add-a =&gt; {&quot;foo&quot; [{:name &quot;foo&quot; :x 1] {:name &quot;foo&quot; :x nil}]} b. Or create the key and plop itself in: name-&gt;objects + to-add-b =&gt; {&quot;foo&quot; [{:name &quot;foo&quot; :x 1}] &quot;bar&quot; {:name &quot;bar&quot; :x nil}} "><y>#</y><d>2021-03-30</d><h>20:08</h><w>stopa</w>Okay, one more:

Say I have

<pre>(def name-&gt;objects {&quot;foo&quot;: [{:name &quot;foo&quot; :x 1]})
(def to-add-a {:name &quot;foo&quot; :x nil})
(def to-add-b {:name &quot;bar&quot; :x nil})</pre>
Now,  I want to:
a. Either append into existing:
<pre>name-&gt;objects + to-add-a =&gt; {&quot;foo&quot; [{:name &quot;foo&quot; :x 1] {:name &quot;foo&quot; :x nil}]}</pre>
b. Or create the key and plop itself in:
<pre>name-&gt;objects + to-add-b =&gt; {&quot;foo&quot; [{:name &quot;foo&quot; :x 1}] &quot;bar&quot; {:name &quot;bar&quot; :x nil}}</pre>
</z><z id="t1617135089" t="stopa (s/setval [(:name object) s/AFTER-ELEM] object name-&gt;objects ) ^ wow, above did the trick. this is awesome! great work"><y>#</y><d>2021-03-30</d><h>20:11</h><w>stopa</w><pre>(s/setval
 [(:name object) s/AFTER-ELEM]
 object
 name-&gt;objects
 )</pre>
^ wow, above did the trick. this is awesome! great work</z><z id="t1617161142" t="nathanmarz you can control the created sequence type with NIL-&gt;VECTOR navigator"><y>#</y><d>2021-03-31</d><h>03:25</h><w>nathanmarz</w>you can control the created sequence type with <code>NIL-&gt;VECTOR</code> navigator</z><z id="t1617161158" t="nathanmarz and (keypath (:name object)) will execute faster"><y>#</y><d>2021-03-31</d><h>03:25</h><w>nathanmarz</w>and <code>(keypath (:name object))</code> will execute faster</z><z id="t1617161209" t="nathanmarz so the path woudl be [(keypath (:name object)) NIl-&gt;VECTOR AFTER-ELEM]"><y>#</y><d>2021-03-31</d><h>03:26</h><w>nathanmarz</w>so the path woudl be <code>[(keypath (:name object)) NIl-&gt;VECTOR AFTER-ELEM]</code></z><z id="t1617206580" t="stopa Nice!"><y>#</y><d>2021-03-31</d><h>16:03</h><w>stopa</w>Nice!</z><z id="t1617207173" t="Franco Gasperino In the case where a transform operation takes a collection of one type, but is expected to return a collection of a different type, is transform the correct idiom? (def data {:a {:required true} :b {:required false} :c {}}) (defn get-key-if-required [[k v]] (if (map? v) (let [r (:required v true)] (if (and (boolean? r) (true? r)) k nil)))) (map get-key-if-required data) =&gt; (:a nil :c) ; This does not work, likely expecting a map out (specter/transform [specter/ALL] get-key-if-required data)"><y>#</y><d>2021-03-31</d><h>16:12</h><w>Franco Gasperino</w>In the case where a transform operation takes a collection of one type, but is expected to return a collection of a different type, is transform the correct idiom?
<pre>(def data {:a {:required true} :b {:required false} :c {}})

(defn get-key-if-required [[k v]]
  (if (map? v)
    (let [r (:required v true)]
      (if (and (boolean? r) (true? r)) k nil))))

(map get-key-if-required data) =&gt; (:a nil :c)

; This does not work, likely expecting a map out
(specter/transform [specter/ALL] get-key-if-required data)</pre></z><z id="t1617207645" t="stopa Okay, more complicated one: data {:shelves {:name &quot;foo&quot; :books [{:id &quot;a&quot;} {:id &quot;b&quot;}]} Now, I want to do the following: shelf-task-a {:name &quot;foo&quot; :books [{:id &quot;a&quot;} {:id &quot;c&quot;}]} shelf-task-b {:name &quot;bar&quot; :books [{:id &quot;d&quot;}]} • Take shelf-task-a, if the shelf with that name exists, go into it’s books , otherwise create {:name x, :books []} • Then go into it’s :books , and for each book, if it exists, don’t add, otherwise append at the end I’m currently breaking this up into stages: (reduce (fn [data {:keys [found-book]}] (let [shelf-path [:shelves (s/not-selected? s/ALL #(= (:name %) shelf-name)) s/AFTER-ELEM] book-path [:shelves s/ALL #(= (:name %) shelf-name) :books s/NIL-&gt;VECTOR (s/not-selected? s/ALL #(= (:id %) (:id found-book))) s/AFTER-ELEM]] (-&gt;&gt; data (s/setval shelf-path {:name shelf-name}) (s/setval book-path found-book)))) data import-tasks) If you’d suggest something different am all ears 😄"><y>#</y><d>2021-03-31</d><h>16:20</h><w>stopa</w>Okay, more complicated one:

<pre>data {:shelves {:name &quot;foo&quot; :books [{:id &quot;a&quot;} {:id &quot;b&quot;}]}</pre>
Now, I want to do the following:

<pre>shelf-task-a {:name &quot;foo&quot; :books [{:id &quot;a&quot;} {:id &quot;c&quot;}]}
shelf-task-b {:name &quot;bar&quot; :books [{:id &quot;d&quot;}]}</pre>
• Take shelf-task-a, if the shelf with that name exists, go into it’s <code>books</code>, otherwise create <code>{:name x, :books []}</code>
• Then go into it’s <code>:books</code>, and for each book, if it exists, don’t add, otherwise append at the end
I’m currently breaking this up into stages:

<pre>(reduce
   (fn [data {:keys [found-book]}]
     (let [shelf-path [:shelves (s/not-selected? s/ALL #(= (:name %) shelf-name)) s/AFTER-ELEM]
           book-path  [:shelves s/ALL #(= (:name %) shelf-name) :books s/NIL-&gt;VECTOR 
                       (s/not-selected? s/ALL #(= (:id %) (:id found-book))) s/AFTER-ELEM]]
       (-&gt;&gt; data
            (s/setval shelf-path {:name shelf-name})
            (s/setval book-path found-book))))

   data
   import-tasks)</pre>
If you’d suggest something different am all ears <b>😄</b></z><z id="t1617416579" t="nathanmarz [:attrs {:href &quot;/_/_/users/U01RGC7177E&quot;}] navigators in a transform expect values to transform to the same concept. in the case of ALL on a map it expects the transform to return new key/value pair or NONE to remove"><y>#</y><d>2021-04-03</d><h>02:22</h><w>nathanmarz</w><a>@franco.gasperino</a> navigators in a <code>transform</code>  expect values to transform to the same concept. in the case of <code>ALL</code> on a map it expects the transform to return new key/value pair or <code>NONE</code> to remove</z><z id="t1617416587" t="nathanmarz you probably just want to use select"><y>#</y><d>2021-04-03</d><h>02:23</h><w>nathanmarz</w>you probably just want to use <code>select</code></z><z id="t1617416648" t="nathanmarz [:attrs {:href &quot;/_/_/users/U0C5DE6RK&quot;}] it would be a lot more efficient to build a set of existing book names first and then filter your append based on that"><y>#</y><d>2021-04-03</d><h>02:24</h><w>nathanmarz</w><a>@stopachka</a> it would be a lot more efficient to build a set of existing book names first and then filter your append based on that</z><z id="t1617599535" t="h0bbit Hello all! I’m new to specter and excited to learn how to use it properly. My question is: Is it possible to select the subset of data you want and then to transform it such that the output is just the transformed subset? And if so, how? To clarify, my understanding is as follows: transform is useful for transformations in deeply nested data, and will return the full data-structure back to me. select is useful for arbitrary data selection in a given structure and will only return the selected data. What I want is to select and also transform . We have deeply nested YAML files containing dependency data for our microservices. Each service defines what component it depends on, and exactly which tables/topics etc in that component it reads/writes to. I’m parsing this data to extract information from it and build dependency graphs. The parser in standard Clojure looks like this: (-&gt;&gt; yaml-data (mapcat :systems) (mapcat :containers) (map (juxt :name :dependencies)) (mapcat (fn [[c ds]] (map (fn [d] {:container c :dependency (:name d) :transports (:transport d) :entities (:data_entity d &apos;())}) ds)))) I rewrote this with specter like this: (-&gt;&gt; yaml-data (s/select [s/ALL :systems s/ALL :containers s/ALL (s/submap [:name :dependencies])]) (s/transform [s/ALL (s/collect-one :name) :dependencies s/ALL] (fn [c d] {:container c :dependency (:name d) :transports (:transport d) :entities (:data_entity d &apos;())})) (s/select [s/ALL :dependencies s/ALL])) The problem is that the specter version is more than 2X slower as compared to the previous version. I suspect it’s because the transform step has to re-stitch everything when I don’t need the stitching. What mistake am I making / How can I rewrite the pipeline?"><y>#</y><d>2021-04-05</d><h>05:12</h><w>h0bbit</w>Hello all!

I’m new to specter and excited to learn how to use it properly. My question is: Is it possible to <code>select</code> the subset of data you want and then to <code>transform</code> it such that the output is just the transformed subset? And if so, how?

To clarify, my understanding is as follows: <code>transform</code> is useful for transformations in deeply nested data, and will return the full data-structure back to me. <code>select</code> is useful for arbitrary data selection in a given structure and will only return the selected data. What I want is to <code>select</code> and also <code>transform</code>.

We have deeply nested YAML files containing dependency data for our microservices. Each service defines what component it depends on, and exactly which tables/topics etc in that component it reads/writes to. I’m parsing this data to extract information from it and build dependency graphs. The parser in standard Clojure looks like this:
<pre>(-&gt;&gt; yaml-data
       (mapcat :systems)
       (mapcat :containers)
       (map (juxt :name :dependencies))
       (mapcat (fn [[c ds]]
                 (map (fn [d] {:container c
                              :dependency (:name d)
                              :transports (:transport d)
                              :entities (:data_entity d &apos;())})
                      ds))))</pre>
I rewrote this with specter like this:
<pre>(-&gt;&gt; yaml-data
       (s/select [s/ALL :systems s/ALL :containers s/ALL (s/submap [:name :dependencies])])
       (s/transform [s/ALL (s/collect-one :name) :dependencies s/ALL]
                    (fn [c d]
                      {:container c
                       :dependency (:name d)
                       :transports (:transport d)
                       :entities (:data_entity d &apos;())}))
       (s/select [s/ALL :dependencies s/ALL]))</pre>
The problem is that the specter version is more than 2X slower as compared to the previous version. I suspect it’s because the <code>transform</code> step has to re-stitch everything when I don’t need the stitching. What mistake am I making / How can I rewrite the pipeline?</z><z id="t1617750674" t="nathanmarz [:attrs {:href &quot;/_/_/users/U051S5XR3&quot;}] you can replace the submap + transform with a transformed call, and then continue the select from there"><y>#</y><d>2021-04-06</d><h>23:11</h><w>nathanmarz</w><a>@h0bbit</a> you can replace the submap + transform with a <code>transformed</code> call, and then continue the select from there</z><z id="t1617750683" t="nathanmarz so it would end up being just one select"><y>#</y><d>2021-04-06</d><h>23:11</h><w>nathanmarz</w>so it would end up being just one <code>select</code></z><z id="t1617765903" t="h0bbit [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] : thanks, I rewrote it as follows: (s/select [s/ALL :systems s/ALL :containers s/ALL (s/transformed [(s/collect-one :name) :dependencies s/ALL] (fn [c d] {:container c :dependency (:name d) :transports (:transport d) :entities (:data_entity d &apos;())})) :dependencies s/ALL] yaml-data) This works correctly, but is still slower on criterium benchmarks (129.3 us for -&gt;&gt; version, 129.9 for same code with transduce instead of -&gt;&gt; , 193.7 us for this form above, 307.7 us for my previous select + transform + select version."><y>#</y><d>2021-04-07</d><h>03:25</h><w>h0bbit</w><a>@nathanmarz</a>: thanks, I rewrote it as follows:
<pre>(s/select [s/ALL :systems s/ALL :containers s/ALL
             (s/transformed [(s/collect-one :name) :dependencies s/ALL]
                            (fn [c d]
                              {:container c
                               :dependency (:name d)
                               :transports (:transport d)
                               :entities (:data_entity d &apos;())}))
             :dependencies s/ALL]
            yaml-data)</pre>
This works correctly, but is still slower on criterium benchmarks (129.3 us for <code>-&gt;&gt;</code> version, 129.9 for same code with <code>transduce</code> instead of <code>-&gt;&gt;</code> , 193.7 us for this form above, 307.7 us for my previous <code>select + transform + select</code> version.</z><z id="t1617766164" t="h0bbit I’ll continue to play some more with specter in this project, thank you for the work you’ve put into it and for releasing it to all of us!"><y>#</y><d>2021-04-07</d><h>03:29</h><w>h0bbit</w>I’ll continue to play some more with specter in this project, thank you for the work you’ve put into it and for releasing it to all of us!</z><z id="t1617827587" t="nathanmarz [:attrs {:href &quot;/_/_/users/U051S5XR3&quot;}] i would guess value collection is the source of the slowdown, as it causes the transform fn to be run with apply rather than a direct invoke"><y>#</y><d>2021-04-07</d><h>20:33</h><w>nathanmarz</w><a>@h0bbit</a> i would guess value collection is the source of the slowdown, as it causes the transform fn to be run with <code>apply</code> rather than a direct invoke</z><z id="t1617827595" t="nathanmarz for top-level transforms there&apos;s vtransform to avoid that"><y>#</y><d>2021-04-07</d><h>20:33</h><w>nathanmarz</w>for top-level transforms there&apos;s <code>vtransform</code> to avoid that</z><z id="t1617827609" t="nathanmarz would be pretty easy to make a vtransformed to accomplish the same thing for your use case"><y>#</y><d>2021-04-07</d><h>20:33</h><w>nathanmarz</w>would be pretty easy to make a <code>vtransformed</code> to accomplish the same thing for your use case</z><z id="t1617855383" t="h0bbit [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] : thanks for the tip, changing to vtransformed brings it down to 163.9 µs. The implementation code is beyond me at the moment, so I simply created the following in my namespace: (s/defdynamicnav vtransformed &quot;Navigates to a view of the current value by transforming it with the specified path and update-fn.&quot; [path update-fn] (s/late-bound-nav [late (s/late-path path) late-fn update-fn] (select* [this structure next-fn] (next-fn (s/compiled-vtransform late late-fn structure))) (transform* [this structure next-fn] (next-fn (s/compiled-vtransform late late-fn structure))))) Results are correct across all versions of the parser. Latest parser looks like this: (s/select [s/ALL :systems s/ALL :containers s/ALL (vtransformed [(s/collect-one :name) :dependencies s/ALL] (fn [[c] d] {:container c :dependency (:name d) :transports (:transport d) :entities (:data_entity d &apos;())})) :dependencies s/ALL] yaml-data)"><y>#</y><d>2021-04-08</d><h>04:16</h><w>h0bbit</w><a>@nathanmarz</a>: thanks for the tip, changing to <code>vtransformed</code> brings it down to 163.9 µs. The implementation code is beyond me at the moment, so I simply created the following in my namespace:
<pre>(s/defdynamicnav vtransformed
  &quot;Navigates to a view of the current value by transforming it with the
   specified path and update-fn.&quot;
  [path update-fn]
  (s/late-bound-nav [late (s/late-path path)
                     late-fn update-fn]
                    (select* [this structure next-fn]
                             (next-fn (s/compiled-vtransform late late-fn structure)))
                    (transform* [this structure next-fn]
                                (next-fn (s/compiled-vtransform late late-fn structure)))))</pre>
Results are correct across all versions of the parser. Latest parser looks like this:
<pre>(s/select [s/ALL :systems s/ALL :containers s/ALL
             (vtransformed [(s/collect-one :name) :dependencies s/ALL]
                           (fn [[c] d]
                              {:container c
                               :dependency (:name d)
                               :transports (:transport d)
                               :entities (:data_entity d &apos;())}))
             :dependencies s/ALL]
            yaml-data)</pre></z><z id="t1617859681" t="nathanmarz [:attrs {:href &quot;/_/_/users/U051S5XR3&quot;}] looking at it again it looks like you actually want a version of view that lets you look at collected values at the same time"><y>#</y><d>2021-04-08</d><h>05:28</h><w>nathanmarz</w><a>@h0bbit</a> looking at it again it looks like you actually want a version of <code>view</code> that lets you look at collected values at the same time</z><z id="t1617859769" t="nathanmarz then you could write: (s/select [s/ALL :systems s/ALL :containers s/ALL (s/collect-one :name) :dependencies s/ALL (my-view (fn [[c] d] {:container c :dependency (:name d) :transports (:transport d) :entities (:data_entity d &apos;())} ))] yaml-data)"><y>#</y><d>2021-04-08</d><h>05:29</h><w>nathanmarz</w>then you could write:
<pre>(s/select [s/ALL :systems s/ALL :containers s/ALL
           (s/collect-one :name) :dependencies s/ALL
           (my-view
             (fn [[c] d]
              {:container c
               :dependency (:name d)
               :transports (:transport d)
               :entities (:data_entity d &apos;())}
               ))]
           yaml-data)</pre></z><z id="t1617859918" t="nathanmarz my-view would be: (defrichnav my-view [afn] (select* [this vals structure next-fn] (next-fn [] (afn vals structure))) (transform* [this vals structure next-fn] (next-fn [] (afn vals structure)))) "><y>#</y><d>2021-04-08</d><h>05:31</h><w>nathanmarz</w><code>my-view</code> would be:
<pre>(defrichnav my-view
  [afn]
  (select* [this vals structure next-fn]
    (next-fn [] (afn vals structure)))
  (transform* [this vals structure next-fn]
    (next-fn [] (afn vals structure))))</pre>
</z><z id="t1617859989" t="nathanmarz seems like that should be much faster"><y>#</y><d>2021-04-08</d><h>05:33</h><w>nathanmarz</w>seems like that should be much faster</z><z id="t1617861922" t="h0bbit [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] : wow, that brought it down to 87.3 µs. Thanks. I have loads to learn and think about with this library!"><y>#</y><d>2021-04-08</d><h>06:05</h><w>h0bbit</w><a>@nathanmarz</a>: wow, that brought it down to 87.3 µs. Thanks. I have loads to learn and think about with this library!</z><z id="t1617861994" t="h0bbit I’ll study some more to get a better understanding of views and when to use them"><y>#</y><d>2021-04-08</d><h>06:06</h><w>h0bbit</w>I’ll study some more to get a better understanding of views and when to use them</z><z id="t1619051551" t="richiardiandrea Hi there, I reported this problem some time ago but I am now in need of a workaround because it keeps happening: UnsupportedOperationException Can&apos;t create empty: duct.database.sql.Boundary duct.database.sql.Boundary (sql.clj:4) clojure.core/empty (core.clj:5247) clojure.core/empty (core.clj:5241) com.rpl.specter.navs/eval3673/fn--3674 (navs.cljc:363) com.rpl.specter.navs/eval3607/fn--3608/G--3596--3615 (navs.cljc:222) com.rpl.specter/reify--4346 (specter.cljc:707) com.rpl.specter.impl/combine-two-navs/reify--2611 (impl.cljc:200) I was basically thinking of converting all the records before passing the payload to the specter functions...maybe as a specter transformation...is anybody doing this already? Is it a good idea?"><y>#</y><d>2021-04-22</d><h>00:32</h><w>richiardiandrea</w>Hi there, I reported this problem some time ago but I am now in need of a workaround because it keeps happening:

<pre>UnsupportedOperationException Can&apos;t create empty: duct.database.sql.Boundary
	duct.database.sql.Boundary (sql.clj:4)
	clojure.core/empty (core.clj:5247)
	clojure.core/empty (core.clj:5241)
	com.rpl.specter.navs/eval3673/fn--3674 (navs.cljc:363)
	com.rpl.specter.navs/eval3607/fn--3608/G--3596--3615 (navs.cljc:222)
	com.rpl.specter/reify--4346 (specter.cljc:707)
	com.rpl.specter.impl/combine-two-navs/reify--2611 (impl.cljc:200)</pre>
I was basically thinking of converting all the records before passing the payload to the specter functions...maybe as a <code>specter</code> transformation...is anybody doing this already? Is it a good idea?</z><z id="t1619052300" t="richiardiandrea or I need some starting point on fix https://github.com/redplanetlabs/specter/issues/303 I gave a quick read to the navigator implementations - I guess I would need a map-vals-transform implementation for my records? Can this be done in user land?"><y>#</y><d>2021-04-22</d><h>00:45</h><w>richiardiandrea</w>or I need some starting point on fix <a href="https://github.com/redplanetlabs/specter/issues/303" target="_blank">https://github.com/redplanetlabs/specter/issues/303</a>

I gave a quick read to the navigator implementations - I guess I would need a <code>map-vals-transform</code> implementation for my records? Can this be done in user land?</z><z id="t1619103046" t="Jeff Evans [:attrs {:href &quot;/_/_/users/U0C8489U6&quot;}] , here’s a starting point: https://github.com/redplanetlabs/specter/pull/306 would need to think more about weird corner cases and also investigate the CLJS side"><y>#</y><d>2021-04-22</d><h>14:50</h><w>Jeff Evans</w><a>@richiardiandrea</a>, here’s a starting point: <a href="https://github.com/redplanetlabs/specter/pull/306" target="_blank">https://github.com/redplanetlabs/specter/pull/306</a>

would need to think more about weird corner cases and also investigate the CLJS side</z><z id="t1619104678" t="richiardiandrea cool I can try this out right away 😄"><y>#</y><d>2021-04-22</d><h>15:17</h><r>richiardiandrea</r>cool I can try this out right away <b>😄</b></z><z id="t1619111212" t="Jeff Evans it occurs to me that supporting key transformation might make sense, like if you need to rename some keys within the same record. seems a bit odd to me, but maybe reasonable"><y>#</y><d>2021-04-22</d><h>17:06</h><w>Jeff Evans</w>it occurs to me that supporting key transformation might make sense, like if you need to rename some keys within the same record.  seems a bit odd to me, but maybe reasonable</z><z id="t1619220803" t="richiardiandrea yeah the problem is that I use specter in my logging code path so knowing the records all libraries are using (plus ours - quite a code base and I am new to it) might not be possible"><y>#</y><d>2021-04-23</d><h>23:33</h><r>richiardiandrea</r>yeah the problem is that I use specter in my logging code path so knowing the records all libraries are using (plus ours - quite a code base and I am new to it) might not be possible</z><z id="t1619221058" t="richiardiandrea I will be trying your branch with gitlib coordinate, please let me know if you are planning a rebase ok? 😄"><y>#</y><d>2021-04-23</d><h>23:37</h><r>richiardiandrea</r>I will be trying your branch with gitlib coordinate, please let me know if you are planning a rebase ok? <b>😄</b></z><z id="t1619221134" t="richiardiandrea oh, cannot do that because there is no deps.edn 😞"><y>#</y><d>2021-04-23</d><h>23:38</h><r>richiardiandrea</r>oh, cannot do that because there is no <code>deps.edn</code> <b>😞</b></z><z id="t1619221287" t="richiardiandrea forked your repo and will test it that way"><y>#</y><d>2021-04-23</d><h>23:41</h><r>richiardiandrea</r>forked your repo and will test it that way</z><z id="t1619221340" t="Jeff Evans Nathan reviews PRs very infrequently and I don&apos;t really plan on doing anything until that happens anyway"><y>#</y><d>2021-04-23</d><h>23:42</h><r>Jeff Evans</r>Nathan reviews PRs very infrequently and I don&apos;t really plan on doing anything until that happens anyway</z><z id="t1619221360" t="Jeff Evans But I&apos;d imagine you could do this protocol extension in your own namespace too"><y>#</y><d>2021-04-23</d><h>23:42</h><r>Jeff Evans</r>But I&apos;d imagine you could do this protocol extension in your own namespace too</z><z id="t1619221742" t="richiardiandrea oh ok that would be the best option, but I also want to improve the lib and at least test that your solution works 😉"><y>#</y><d>2021-04-23</d><h>23:49</h><r>richiardiandrea</r>oh ok that would be the best option, but I also want to improve the lib and at least test that your solution works <b>😉</b></z><z id="t1619221956" t="richiardiandrea Well...ok I don&apos;t think using gitlibs works...there is some java in there and I don&apos;t know if the new tooling deals with that"><y>#</y><d>2021-04-23</d><h>23:52</h><r>richiardiandrea</r>Well...ok I don&apos;t think using gitlibs works...there is some java in there and I don&apos;t know if the new tooling deals with that</z><z id="t1619222452" t="richiardiandrea built a jar and I can tell you it works like a charm 🎉"><y>#</y><d>2021-04-24</d><h>00:00</h><r>richiardiandrea</r>built a jar and I can tell you it works like a charm <b>🎉</b></z><z id="t1620067477" t="richiardiandrea Hi folks again 😄 How would I go if I wanted to set a key in a map that is missing? For instance I only want to add :foo nil if it&apos;s not already there"><y>#</y><d>2021-05-03</d><h>18:44</h><w>richiardiandrea</w>Hi folks again <b>😄</b>

How would I go if I wanted to set a key in a map that is missing?

For instance I only want to add <code>:foo nil</code> if it&apos;s not already there</z><z id="t1620068605" t="richiardiandrea this is what I have come up so far: (defn assoc-mode-nils &quot;Add nil to empty modes.&quot; [root] ;; Please do not remove this or you will break spec and frontend. (sp/transform [maps/POST-ORDER-TREE-VALS (sp/must :descriptor) (sp/pred #(= (:type %) enum/segmod-element-type-heart-lv-subsegment)) (sp/multi-path [(sp/keypath (keyword cmr.scoring/mode-function)) (sp/nil-&gt;val nil)] [(sp/keypath (keyword cmr.scoring/mode-edema)) (sp/nil-&gt;val nil)])] identity root))"><y>#</y><d>2021-05-03</d><h>19:03</h><w>richiardiandrea</w>this is what I have come up so far:

<pre>(defn assoc-mode-nils
  &quot;Add nil to empty modes.&quot;
  [root]
  ;; Please do not remove this or you will break spec and frontend.
  (sp/transform
   [maps/POST-ORDER-TREE-VALS
    (sp/must :descriptor)
    (sp/pred #(= (:type %) enum/segmod-element-type-heart-lv-subsegment))
    (sp/multi-path [(sp/keypath (keyword cmr.scoring/mode-function)) (sp/nil-&gt;val nil)]
                   [(sp/keypath (keyword cmr.scoring/mode-edema)) (sp/nil-&gt;val nil)])]
   identity
   root))</pre></z><z id="t1620075795" t="Jeff Evans (s/setval [(s/cond-path (s/not-selected? (s/map-key :a)) (s/keypath :a))] 2 {:a nil :b 4}) =&gt; {:a nil, :b 4} (s/setval [(s/cond-path (s/not-selected? (s/map-key :a)) (s/keypath :a))] 2 {:a 10 :b 4}) =&gt; {:a 10, :b 4} (s/setval [(s/cond-path (s/not-selected? (s/map-key :a)) (s/keypath :a))] 2 {:b 4}) =&gt; {:b 4, :a 2}"><y>#</y><d>2021-05-03</d><h>21:03</h><w>Jeff Evans</w><pre>(s/setval [(s/cond-path (s/not-selected? (s/map-key :a)) (s/keypath :a))] 2 {:a nil :b 4})
=&gt; {:a nil, :b 4}
(s/setval [(s/cond-path (s/not-selected? (s/map-key :a)) (s/keypath :a))] 2 {:a 10 :b 4})
=&gt; {:a 10, :b 4}
(s/setval [(s/cond-path (s/not-selected? (s/map-key :a)) (s/keypath :a))] 2 {:b 4})
=&gt; {:b 4, :a 2}</pre></z><z id="t1620075799" t="Jeff Evans not sure if there’s a better way"><y>#</y><d>2021-05-03</d><h>21:03</h><w>Jeff Evans</w>not sure if there’s a better way</z><z id="t1620153249" t="nathanmarz I would just make a new navigator for that"><y>#</y><d>2021-05-04</d><h>18:34</h><w>nathanmarz</w>I would just make a new navigator for that</z><z id="t1623012539" t="Joshua Suskalo Is there a way to perform a select that uses values from a selection to navigate? Like to select down one path, and then use the selected value to navigate down another?"><y>#</y><d>2021-06-06</d><h>20:48</h><w>Joshua Suskalo</w>Is there a way to perform a select that uses values from a selection to navigate? Like to select down one path, and then use the selected value to navigate down another?</z><z id="t1623013729" t="Joshua Suskalo Seems like collected? is what I was looking for."><y>#</y><d>2021-06-06</d><h>21:08</h><w>Joshua Suskalo</w>Seems like <code>collected?</code> is what I was looking for.</z><z id="t1623013889" t="Joshua Suskalo Actually, not quite. I&apos;d like to be able to refer to both the collected? values and the structure."><y>#</y><d>2021-06-06</d><h>21:11</h><w>Joshua Suskalo</w>Actually, not quite. I&apos;d like to be able to refer to both the <code>collected?</code> values and the structure.</z><z id="t1623014650" t="Joshua Suskalo Say for example I want to query this structure: {:guild {:a {:members [&quot;1234&quot;]}} :members {&quot;1234&quot; 1}} What I&apos;d like to do is select along [:guild :a :members ALL] and then use those values to then do [:members the-key] on the original structure."><y>#</y><d>2021-06-06</d><h>21:24</h><w>Joshua Suskalo</w>Say for example I want to query this structure:
<pre>{:guild {:a {:members [&quot;1234&quot;]}}
 :members {&quot;1234&quot; 1}}</pre>
What I&apos;d like to do is select along <code>[:guild :a :members ALL]</code> and then use those values to then do <code>[:members the-key]</code> on the original structure.</z><z id="t1623017352" t="Joshua Suskalo It looks like this can be done with some effort by using the transformed navigator"><y>#</y><d>2021-06-06</d><h>22:09</h><w>Joshua Suskalo</w>It looks like this can be done with some effort by using the <code>transformed</code> navigator</z><z id="t1623017519" t="Joshua Suskalo In this particular case, it would be done in this manner: (select-one [(transformed [(collect :guilds MAP-VALS :members ALL) :members] #(select-keys %2 %1)) :members MAP-VALS] structure)"><y>#</y><d>2021-06-06</d><h>22:11</h><w>Joshua Suskalo</w>In this particular case, it would be done in this manner:
<pre>(select-one [(transformed [(collect :guilds MAP-VALS :members ALL)
                           :members]
                          #(select-keys %2 %1))
             :members MAP-VALS]
            structure)</pre></z><z id="t1623115680" t="blak3mill3r transformed is, I think, the simplest way to do that"><y>#</y><d>2021-06-08</d><h>01:28</h><w>blak3mill3r</w><code>transformed</code> is, I think, the simplest way to do that</z><z id="t1623115710" t="blak3mill3r I&apos;d love to be wrong though"><y>#</y><d>2021-06-08</d><h>01:28</h><w>blak3mill3r</w>I&apos;d love to be wrong though</z><z id="t1623117921" t="blak3mill3r I tried to do it the other way around, start navigating from :members and then use selected? but I don&apos;t think that works."><y>#</y><d>2021-06-08</d><h>02:05</h><w>blak3mill3r</w>I tried to do it the other way around, start navigating from <code>:members</code> and then use <code>selected?</code> but I don&apos;t think that works.</z><z id="t1623118048" t="blak3mill3r I have settled for calling select twice in this case because I find the transformed approach a little harder to parse"><y>#</y><d>2021-06-08</d><h>02:07</h><w>blak3mill3r</w>I have settled for calling <code>select</code> twice in this case because I find the <code>transformed</code> approach a little harder to parse</z><z id="t1623118294" t="blak3mill3r I mean, compare your transformed solution to this:"><y>#</y><d>2021-06-08</d><h>02:11</h><w>blak3mill3r</w>I mean, compare your <code>transformed</code> solution to this:</z><z id="t1623118340" t="blak3mill3r (def structure {:guild {:a {:members [&quot;1234&quot; &quot;1235&quot;]} :b {:members [&quot;2345&quot;]}} :members {&quot;1234&quot; 1 &quot;2345&quot; 2 &quot;1235&quot; 3}}) (select [:members (submap (select [:guild :a :members ALL] structure))] structure) ;; =&gt; [{&quot;1234&quot; 1, &quot;1235&quot; 3}]"><y>#</y><d>2021-06-08</d><h>02:12</h><w>blak3mill3r</w><pre>(def structure
  {:guild {:a {:members [&quot;1234&quot; &quot;1235&quot;]}
           :b {:members [&quot;2345&quot;]}}
   :members {&quot;1234&quot; 1
             &quot;2345&quot; 2
             &quot;1235&quot; 3}})
(select [:members (submap
                   (select [:guild :a :members ALL] structure))]
        structure)
;; =&gt; [{&quot;1234&quot; 1, &quot;1235&quot; 3}]</pre></z><z id="t1623165063" t="Joshua Suskalo That makes sense. It just would be nice imo to be able to get those keys from the collected values in a navigator rather than having to make a second select operation."><y>#</y><d>2021-06-08</d><h>15:11</h><w>Joshua Suskalo</w>That makes sense. It just would be nice imo to be able to get those keys from the collected values in a navigator rather than having to make a second select operation.</z><z id="t1623197919" t="blak3mill3r I agree... selecting twice doesn&apos;t feel great. It breaks the composability of the navigator abstraction"><y>#</y><d>2021-06-09</d><h>00:18</h><w>blak3mill3r</w>I agree... selecting twice doesn&apos;t feel great. It breaks the composability of the navigator abstraction</z><z id="t1625235707" t="borkdude Hi. I&apos;ve found a way to monkey-patch specter to make it work with SCI (Clojure interpreter that can run in a native-image): https://github.com/borkdude/specter-sci"><y>#</y><d>2021-07-02</d><h>14:21</h><w>borkdude</w>Hi. I&apos;ve found a way to monkey-patch specter to make it work with SCI (Clojure interpreter that can run in a native-image):
<a href="https://github.com/borkdude/specter-sci" target="_blank">https://github.com/borkdude/specter-sci</a></z><z id="t1625241292" t="borkdude Made a proper CLI out of it now: https://github.com/borkdude/specter-cli"><y>#</y><d>2021-07-02</d><h>15:54</h><w>borkdude</w>Made a proper CLI out of it now:

<a href="https://github.com/borkdude/specter-cli" target="_blank">https://github.com/borkdude/specter-cli</a></z><z id="t1625269688" t="nathanmarz [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] cool stuff"><y>#</y><d>2021-07-02</d><h>23:48</h><w>nathanmarz</w><a>@borkdude</a> cool stuff</z><z id="t1625320951" t="borkdude I now uploaded pre-built binaries as well."><y>#</y><d>2021-07-03</d><h>14:02</h><w>borkdude</w>I now uploaded pre-built binaries as well.</z><z id="t1627508299" t="richiardiandrea Hi there, say I have maps that can look like this {:foos [{:xx 1} {:yy 2] :bar &quot;BAR&quot;} {:foos [#uuid &quot;xx&quot; #uuid &quot;yy&quot;] :bar &quot;BAR&quot;} {:foos [{} {}] :bar &quot;BAR&quot;} How can I trim the :foos if &quot;empty&quot; in specter?"><y>#</y><d>2021-07-28</d><h>21:38</h><w>richiardiandrea</w>Hi there, say I have maps that can look like this

<code>{:foos [{:xx 1} {:yy 2] :bar &quot;BAR&quot;}</code>

<code>{:foos [#uuid &quot;xx&quot; #uuid &quot;yy&quot;] :bar &quot;BAR&quot;}</code>

<code>{:foos [{} {}] :bar &quot;BAR&quot;}</code>

How can I trim the <code>:foos</code> if &quot;empty&quot; in specter?</z><z id="t1627508423" t="richiardiandrea tried [(sp/must :foos) (sp/pred #(every? empty? %)) (sp/terminal sp/NONE)] but it throws in case of #uuid"><y>#</y><d>2021-07-28</d><h>21:40</h><w>richiardiandrea</w>tried

<code>[(sp/must :foos) (sp/pred #(every? empty? %)) (sp/terminal sp/NONE)]</code>

but it throws in case of <code>#uuid</code></z><z id="t1627509838" t="isak [:attrs {:href &quot;/_/_/users/U0C8489U6&quot;}] you should just check for map? first in that pred. Example: (let [xs [{:foos [{:xx 1} {:yy 2}] :bar &quot;BAR&quot;} {:foos [#uuid &quot;123e4567-e89b-12d3-a456-426652340000&quot; #uuid &quot;123e4567-e89b-12d3-a456-426652340010&quot;] :bar &quot;BAR&quot;} {:foos [{} {}] :bar &quot;BAR&quot;}]] (sp/setval [sp/ALL (sp/must :foos) (sp/pred #(every? (fn [x] (and (map? x) (empty? x))) %))] sp/NONE xs)) =&gt; [{:foos [{:xx 1} {:yy 2}], :bar &quot;BAR&quot;} {:foos [#uuid&quot;123e4567-e89b-12d3-a456-426652340000&quot; #uuid&quot;123e4567-e89b-12d3-a456-426652340010&quot;], :bar &quot;BAR&quot;} {:bar &quot;BAR&quot;}]"><y>#</y><d>2021-07-28</d><h>22:03</h><w>isak</w><a>@richiardiandrea</a> you should just check for <code>map?</code> first in that pred. Example:
<pre>(let [xs [{:foos [{:xx 1} {:yy 2}] :bar &quot;BAR&quot;}
            {:foos [#uuid &quot;123e4567-e89b-12d3-a456-426652340000&quot; #uuid &quot;123e4567-e89b-12d3-a456-426652340010&quot;] :bar &quot;BAR&quot;}
            {:foos [{} {}] :bar &quot;BAR&quot;}]]
    (sp/setval 
      [sp/ALL (sp/must :foos) (sp/pred #(every? (fn [x] (and (map? x) (empty? x))) %))]
      sp/NONE
      xs))

=&gt; [{:foos [{:xx 1} {:yy 2}], :bar &quot;BAR&quot;}
 {:foos [#uuid&quot;123e4567-e89b-12d3-a456-426652340000&quot; #uuid&quot;123e4567-e89b-12d3-a456-426652340010&quot;], :bar &quot;BAR&quot;}
 {:bar &quot;BAR&quot;}]</pre></z><z id="t1627509903" t="richiardiandrea oh ok that makes sense - I was thinking there would be more specter magic I was missing instead"><y>#</y><d>2021-07-28</d><h>22:05</h><w>richiardiandrea</w>oh ok that makes sense - I was thinking there would be more specter magic I was missing instead</z><z id="t1627510166" t="isak This may be better, but depends what you are trying to do (adapted from a similar thing I needed): (def rec-node-path (sp/recursive-path [] p (sp/cond-path map? (sp/continue-then-stay sp/MAP-VALS p) vector? (sp/continue-then-stay sp/ALL p)))) (let [xs [{:foos [{:xx 1} {:yy 2}] :bar &quot;BAR&quot;} {:foos [#uuid &quot;123e4567-e89b-12d3-a456-426652340000&quot; #uuid &quot;123e4567-e89b-12d3-a456-426652340010&quot;] :bar &quot;BAR&quot;} {:foos [{} {}] :bar &quot;BAR&quot;}]] (sp/setval [sp/ALL :foos rec-node-path empty?] sp/NONE xs))"><y>#</y><d>2021-07-28</d><h>22:09</h><w>isak</w>This may be better, but depends what you are trying to do (adapted from a similar thing I needed):
<pre>(def rec-node-path
    (sp/recursive-path
      [] p
      (sp/cond-path 
        map? (sp/continue-then-stay sp/MAP-VALS p)
        vector? (sp/continue-then-stay sp/ALL p))))

  (let [xs [{:foos [{:xx 1} {:yy 2}] :bar &quot;BAR&quot;}
            {:foos [#uuid &quot;123e4567-e89b-12d3-a456-426652340000&quot; #uuid &quot;123e4567-e89b-12d3-a456-426652340010&quot;] :bar &quot;BAR&quot;}
            {:foos [{} {}] :bar &quot;BAR&quot;}]]
    (sp/setval [sp/ALL :foos rec-node-path empty?] sp/NONE xs))</pre></z><z id="t1627570389" t="richiardiandrea yeah I need to go recursive there, cause those :foos are representing entities that are &quot;fetched&quot; or not from the db"><y>#</y><d>2021-07-29</d><h>14:53</h><w>richiardiandrea</w>yeah I need to go recursive there, cause those <code>:foos</code> are representing entities that are &quot;fetched&quot; or not from the db</z><z id="t1627570437" t="richiardiandrea will play around but thank you so much for now"><y>#</y><d>2021-07-29</d><h>14:53</h><w>richiardiandrea</w>will play around but thank you so much for now</z><z id="t1628359305" t="stephenmhopper I have a sequence of arbitrary paths that I need to apply using specter/transform to a data structure in succession. Right now, I’m just using reduce and that code looks something like this: (reduce (fn [row path] (specter/transform path transform-fn row)) row paths) Does specter provide anything as an alternative to reduce in this case?"><y>#</y><d>2021-08-07</d><h>18:01</h><w>stephenmhopper</w>I have a sequence of arbitrary <code>paths</code> that I need to apply using <code>specter/transform</code> to a data structure in succession. Right now, I’m just using <code>reduce</code> and that code looks something like this:
<pre>(reduce
  (fn [row path]
    (specter/transform path transform-fn row))
  row
  paths)</pre>
Does specter provide anything as an alternative to <code>reduce</code> in this case?</z><z id="t1628379947" t="nathanmarz [:attrs {:href &quot;/_/_/users/U0M7A18V6&quot;}] check out multi-path"><y>#</y><d>2021-08-07</d><h>23:45</h><w>nathanmarz</w><a>@stephenmhopper</a> check out <code>multi-path</code></z><z id="t1628452982" t="stephenmhopper That’s what I needed. Thank you!"><y>#</y><d>2021-08-08</d><h>20:03</h><r>stephenmhopper</r>That’s what I needed. Thank you!</z><z id="t1628453099" t="manas_marthi [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] have you considered compiling this chat room questions into a &apos;specter recipes&apos; book?"><y>#</y><d>2021-08-08</d><h>20:04</h><w>manas_marthi</w><a>@nathanmarz</a> have you considered compiling this chat room questions into a &apos;specter recipes&apos; book?</z><z id="t1628456423" t="nathanmarz [:attrs {:href &quot;/_/_/users/U7ANZ2MTK&quot;}] not sure there&apos;s enough material for a whole book, but something like that could be a great blog post or wiki page"><y>#</y><d>2021-08-08</d><h>21:00</h><w>nathanmarz</w><a>@manas.marthi</a> not sure there&apos;s enough material for a whole book, but something like that could be a great blog post or wiki page</z><z id="t1628456450" t="nathanmarz I don&apos;t have time personally for that"><y>#</y><d>2021-08-08</d><h>21:00</h><w>nathanmarz</w>I don&apos;t have time personally for that</z><z id="t1628789324" t="richiardiandrea Hi folks, a question - can a multi-path share a path between its entries or in other words, can I cascade multi-path s?"><y>#</y><d>2021-08-12</d><h>17:28</h><w>richiardiandrea</w>Hi folks, a question - can a <code>multi-path</code> share a path between its entries or in other words, can I cascade <code>multi-path</code>s?</z><z id="t1628789407" t="richiardiandrea can I need to do some transformation at the top level but also many more that are recursive and would not like to duplicate paths (it&apos;s nice that multi-transform allows me to share but I can&apos;t share the recursive path I want to use)"><y>#</y><d>2021-08-12</d><h>17:30</h><w>richiardiandrea</w>can I need to do some transformation at the top level but also many more that are recursive and would not like to duplicate paths (it&apos;s nice that <code>multi-transform</code> allows me to share but I can&apos;t share the recursive path I want to use)</z><z id="t1628789482" t="richiardiandrea basically I would like to avoid repeating POST-ORDER-VALS below (sp/multi-transform (sp/multi-path [(sp/map-key :measurement-definition/type) (sp/terminal-val :measurement-type)] [(sp/collect-one (sp/must :measurement-definition/legacy) (sp/must :measurement-definition/api) (sp/must :measurement-definition/unit)) (sp/must :measurement-definition/unit) (sp/terminal (fn [current-unit collected-unit] (println &quot;!!!&quot; current-unit collected-unit) (or current-unit collected-unit)))] [lib.specter/POST-ORDER-VALS lib.specter/MAP-KEY-NAMESPACES (sp/terminal sp/NONE)] [lib.specter/POST-ORDER-VALS lib.specter/EMPTY-SEQUENCE (sp/terminal sp/NONE)] [lib.specter/POST-ORDER-VALS sp/MAP-VALS nil? (sp/terminal-val sp/NONE)]))"><y>#</y><d>2021-08-12</d><h>17:31</h><w>richiardiandrea</w>basically I would like to avoid repeating <code>POST-ORDER-VALS</code> below

<pre>(sp/multi-transform (sp/multi-path [(sp/map-key :measurement-definition/type) (sp/terminal-val :measurement-type)]
                                      [(sp/collect-one (sp/must :measurement-definition/legacy)
                                                       (sp/must :measurement-definition/api)
                                                       (sp/must :measurement-definition/unit))
                                       (sp/must :measurement-definition/unit)
                                       (sp/terminal (fn [current-unit collected-unit] (println &quot;!!!&quot; current-unit collected-unit) (or current-unit collected-unit)))]
                                      [lib.specter/POST-ORDER-VALS lib.specter/MAP-KEY-NAMESPACES (sp/terminal sp/NONE)]
                                      [lib.specter/POST-ORDER-VALS lib.specter/EMPTY-SEQUENCE (sp/terminal sp/NONE)]
                                      [lib.specter/POST-ORDER-VALS sp/MAP-VALS nil? (sp/terminal-val sp/NONE)]))</pre></z><z id="t1628801697" t="nathanmarz [:attrs {:href &quot;/_/_/users/U0C8489U6&quot;}] you can combine those three paths into [POST-ORDER-VALS (multi-path [MAP-KEY-NAMESPACES ...] [EMPTY-SEQUENCE ...] [MAP-VALS ...]]"><y>#</y><d>2021-08-12</d><h>20:54</h><w>nathanmarz</w><a>@richiardiandrea</a> you can combine those three paths into <code>[POST-ORDER-VALS (multi-path [MAP-KEY-NAMESPACES ...] [EMPTY-SEQUENCE ...] [MAP-VALS ...]]</code></z><z id="t1628801742" t="richiardiandrea oooo it&apos;s that simple lol"><y>#</y><d>2021-08-12</d><h>20:55</h><w>richiardiandrea</w>oooo it&apos;s that simple lol</z><z id="t1628801757" t="nathanmarz not strictly the same if the first path changes what POST-ORDER-VALS does, but it&apos;s probably what you need"><y>#</y><d>2021-08-12</d><h>20:55</h><w>nathanmarz</w>not strictly the same if the first path changes what <code>POST-ORDER-VALS</code> does, but it&apos;s probably what you need</z><z id="t1628801758" t="richiardiandrea oh wait"><y>#</y><d>2021-08-12</d><h>20:55</h><w>richiardiandrea</w>oh wait</z><z id="t1628801775" t="richiardiandrea yeah I tried that and it won&apos;t work for sp/collect-one"><y>#</y><d>2021-08-12</d><h>20:56</h><w>richiardiandrea</w>yeah I tried that and it won&apos;t work for <code>sp/collect-one</code></z><z id="t1628801795" t="richiardiandrea cause it will do post order and collect twice if I understand correctly"><y>#</y><d>2021-08-12</d><h>20:56</h><w>richiardiandrea</w>cause it will do post order and collect twice if I understand correctly</z><z id="t1628801823" t="nathanmarz do you have collect-one inside POST-ORDER-VALS or your other custom navs?"><y>#</y><d>2021-08-12</d><h>20:57</h><w>nathanmarz</w>do you have <code>collect-one</code> inside <code>POST-ORDER-VALS</code> or your other custom navs?</z><z id="t1628801841" t="nathanmarz as written here those three paths don&apos;t appear to have any value collection"><y>#</y><d>2021-08-12</d><h>20:57</h><w>nathanmarz</w>as written here those three paths don&apos;t appear to have any value collection</z><z id="t1628802330" t="richiardiandrea [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] well I am collecting a nested key from the top of the tree - that&apos;s why I left it out from the recursive navigator"><y>#</y><d>2021-08-12</d><h>21:05</h><w>richiardiandrea</w><a>@nathanmarz</a> well I am collecting a nested key from the top of the tree - that&apos;s why I left it out from the recursive navigator</z><z id="t1628802602" t="nathanmarz that collect-one is in an independent path"><y>#</y><d>2021-08-12</d><h>21:10</h><w>nathanmarz</w>that <code>collect-one</code> is in an independent path</z><z id="t1628802620" t="nathanmarz it needs to be collected at the start of combining those three paths"><y>#</y><d>2021-08-12</d><h>21:10</h><w>nathanmarz</w>it needs to be collected at the start of combining those three paths</z><z id="t1628802940" t="richiardiandrea gotcha, like this? (sp/multi-transform [(sp/collect-one (sp/must :measurement-definition/legacy) ...) POST-ORDER-VALS ... I will try that out, thanks!"><y>#</y><d>2021-08-12</d><h>21:15</h><w>richiardiandrea</w>gotcha, like this?
<pre>(sp/multi-transform [(sp/collect-one (sp/must :measurement-definition/legacy) ...)
                     POST-ORDER-VALS
                     ...</pre>
I will try that out, thanks!</z><z id="t1628805883" t="richiardiandrea yeah the problem with putting it at the top of the path is that all the terminal will be called with two (or more) collected params"><y>#</y><d>2021-08-12</d><h>22:04</h><w>richiardiandrea</w>yeah the problem with putting it at the top of the path is that all the <code>terminal</code> will be called with two (or more) collected params</z><z id="t1628805909" t="richiardiandrea I&apos;ll leave the duplication in the for now"><y>#</y><d>2021-08-12</d><h>22:05</h><w>richiardiandrea</w>I&apos;ll leave the duplication in the for now</z><z id="t1629414519" t="richiardiandrea Hi there, I was wondering if there was a way to achieve the following in specter... https://clojurians.slack.com/archives/C03S1KBA2/p1629413344191700"><y>#</y><d>2021-08-19</d><h>23:08</h><w>richiardiandrea</w>Hi there, I was wondering if there was a way to achieve the following in specter...

<a href="https://clojurians.slack.com/archives/C03S1KBA2/p1629413344191700" target="_blank">https://clojurians.slack.com/archives/C03S1KBA2/p1629413344191700</a></z><z id="t1629421244" t="nathanmarz [:attrs {:href &quot;/_/_/users/U0C8489U6&quot;}] it wouldn&apos;t be much different than doing it with vanilla clojure"><y>#</y><d>2021-08-20</d><h>01:00</h><w>nathanmarz</w><a>@richiardiandrea</a> it wouldn&apos;t be much different than doing it with vanilla clojure</z><z id="t1629421268" t="nathanmarz (setval [(view #(select-keys (keys m2) m1)) (submap nil)] m2 m1)"><y>#</y><d>2021-08-20</d><h>01:01</h><w>nathanmarz</w><code>(setval [(view #(select-keys (keys m2) m1)) (submap nil)] m2 m1)</code></z><z id="t1629421326" t="nathanmarz you could easily package that functionality into a custom navigator if you wanted to be able to compose it within other paths"><y>#</y><d>2021-08-20</d><h>01:02</h><w>nathanmarz</w>you could easily package that functionality into a custom navigator if you wanted to be able to compose it within other paths</z><z id="t1629995179" t="Joshua Suskalo $ clj -Sdeps &apos;{:deps {com.rpl/specter {:mvn/version &quot;1.1.3&quot;}}}&apos; Clojure 1.10.3 user=&gt; (use &apos;com.rpl.specter) nil user=&gt; (setval (compact :a :b :c) NONE {:a {:b {:c 1}}}) :com.rpl.specter.impl/NONE user=&gt; (multi-transform (compact :a :b :c (terminal-val NONE)) {:a {:b {:c 1}}}) Execution error (IllegalArgumentException) at com.rpl.specter.navs/if-transform (navs.cljc:412). Don&apos;t know how to create ISeq from: clojure.lang.Keyword Is this intended behavior? Is compact not designed to work with multi-transform?"><y>#</y><d>2021-08-26</d><h>16:26</h><w>Joshua Suskalo</w><pre>$ clj -Sdeps &apos;{:deps {com.rpl/specter {:mvn/version &quot;1.1.3&quot;}}}&apos;
Clojure 1.10.3
user=&gt; (use &apos;com.rpl.specter)
nil
user=&gt; (setval (compact :a :b :c) NONE {:a {:b {:c 1}}})
:com.rpl.specter.impl/NONE
user=&gt; (multi-transform (compact :a :b :c (terminal-val NONE)) {:a {:b {:c 1}}})
Execution error (IllegalArgumentException) at com.rpl.specter.navs/if-transform (navs.cljc:412).
Don&apos;t know how to create ISeq from: clojure.lang.Keyword</pre>
Is this intended behavior? Is compact not designed to work with multi-transform?</z><z id="t1630000372" t="Joshua Suskalo Also hey [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] I heard from borkdude that you&apos;ve started using clj-kondo. I use specter a lot, and I&apos;d be open to working on a proper config with support for hooks for a lot of the macros for making custom navigators. Would you be open to adding that properly to specter as resources, or should I be looking at making a pr in clj-kondo/config?"><y>#</y><d>2021-08-26</d><h>17:52</h><w>Joshua Suskalo</w>Also hey <a>@nathanmarz</a> I heard from borkdude that you&apos;ve started using clj-kondo. I use specter a lot, and I&apos;d be open to working on a proper config with support for hooks for a lot of the macros for making custom navigators. Would you be open to adding that properly to specter as resources, or should I be looking at making a pr in clj-kondo/config?</z><z id="t1630007480" t="nathanmarz [:attrs {:href &quot;/_/_/users/U5NCUG8NR&quot;}] that&apos;s just because of how compact works – it&apos;s trying to compact the result of terminal-val , which is NONE"><y>#</y><d>2021-08-26</d><h>19:51</h><w>nathanmarz</w><a>@suskeyhose</a> that&apos;s just because of how <code>compact</code> works – it&apos;s trying to compact the result of <code>terminal-val</code>, which is <code>NONE</code></z><z id="t1630007484" t="nathanmarz the error is because that&apos;s not a collection"><y>#</y><d>2021-08-26</d><h>19:51</h><w>nathanmarz</w>the error is because that&apos;s not a collection</z><z id="t1630007514" t="nathanmarz the way to write that would be: (multi-transform [:a (compact :b :c) (terminal-val NONE)] {:a {:b {:c 1}}})"><y>#</y><d>2021-08-26</d><h>19:51</h><w>nathanmarz</w>the way to write that would be: <code>(multi-transform [:a (compact :b :c) (terminal-val NONE)] {:a {:b {:c 1}}})</code></z><z id="t1630007548" t="nathanmarz I think it&apos;s better to add that to clj-kondo rather than specter"><y>#</y><d>2021-08-26</d><h>19:52</h><w>nathanmarz</w>I think it&apos;s better to add that to clj-kondo rather than specter</z><z id="t1630007697" t="Joshua Suskalo aaah, I see"><y>#</y><d>2021-08-26</d><h>19:54</h><w>Joshua Suskalo</w>aaah, I see</z><z id="t1630786206" t="oskarkv I want to filter a list based on nested values. Basically this (filter #(and (= (get-in % [:a :b]) 1) (= (get-in % [:a :c]) 2)) data) Can specter help me here?"><y>#</y><d>2021-09-04</d><h>20:10</h><w>oskarkv</w>I want to filter a list based on nested values. Basically this
<pre>(filter
 #(and (= (get-in % [:a :b]) 1)
       (= (get-in % [:a :c]) 2))
 data)</pre>
Can specter help me here?</z><z id="t1630788491" t="Joshua Suskalo It can help with performance here as it&apos;s faster than get-in"><y>#</y><d>2021-09-04</d><h>20:48</h><w>Joshua Suskalo</w>It can help with performance here as it&apos;s faster than <code>get-in</code></z><z id="t1630789030" t="Joshua Suskalo If I were to write this in specter natively it would look like this: (select [ALL (selected? (must :a :b) (pred= 1)) (selected? (must :a :c) (pred= 2))] data)"><y>#</y><d>2021-09-04</d><h>20:57</h><w>Joshua Suskalo</w>If I were to write this in specter natively it would look like this:
<pre>(select [ALL (selected? (must :a :b) (pred= 1)) (selected? (must :a :c) (pred= 2))] data)</pre></z><z id="t1630790154" t="oskarkv Thanks! But this not just filters, it has mapped :a over the data too. Can I use selected? before the :a without having to repeat the :a for both conditions somehow?"><y>#</y><d>2021-09-04</d><h>21:15</h><r>oskarkv</r>Thanks! But this not just filters, it has mapped <code>:a</code> over the data too. Can I use <code>selected?</code> before the <code>:a</code> without having to repeat the <code>:a</code> for both conditions somehow?</z><z id="t1630792377" t="Joshua Suskalo Ah, right, my mistake. Yes."><y>#</y><d>2021-09-04</d><h>21:52</h><r>Joshua Suskalo</r>Ah, right, my mistake. Yes.</z><z id="t1630792423" t="Joshua Suskalo I edited the example to be accurate."><y>#</y><d>2021-09-04</d><h>21:53</h><r>Joshua Suskalo</r>I edited the example to be accurate.</z><z id="t1631301493" t="johanatan hi, given two (nested) maps how could one a) verify that the same key structure exists in both and b) run some predicate (fn [v1 v2] ... ) that would compare the corresponding values at each key and short-circuit if any return false (returning false when short circuited and true only if entire walk proceeds to exhaustion) ?"><y>#</y><d>2021-09-10</d><h>19:18</h><w>johanatan</w>hi, given two (nested) maps how could one a) verify that the same key structure exists in both and b) run some predicate (fn [v1 v2] ... ) that would compare the corresponding values at each key and short-circuit if any return false (returning false when short circuited and true only if entire walk proceeds to exhaustion) ?</z><z id="t1631301612" t="johanatan (apologies if this has been asked before or is a basic question)"><y>#</y><d>2021-09-10</d><h>19:20</h><w>johanatan</w>(apologies if this has been asked before or is a basic question)</z><z id="t1631303688" t="Joshua Suskalo Sounds like you should just do a select on both structures and use clojure.math.combinatorics/cartesian-product to make a list of all the pairs of items and then use (every? the-pred product) to get your value"><y>#</y><d>2021-09-10</d><h>19:54</h><w>Joshua Suskalo</w>Sounds like you should just do a <code>select</code> on both structures and use <code>clojure.math.combinatorics/cartesian-product</code> to make a list of all the pairs of items and then use <code>(every? the-pred product)</code> to get your value</z><z id="t1631303903" t="Joshua Suskalo (require &apos;[clojure.math.combinatorics :as combo]) ;; requires the org.clojure/math.combinatorics contrib library (defn satisfies [pred &amp; seqs] (every? pred (apply combo/cartesian-product seqs))) (let [structure-1 {1 {:a :blah} 2 {:a :blah}} structure-2 [{:b :blah} {:b :blah}]] (satisfies = (select [MAP-VALS :a] structure-1) (select [ALL :b] structure-2)))) ;; =&gt; true"><y>#</y><d>2021-09-10</d><h>19:58</h><w>Joshua Suskalo</w><pre>(require &apos;[clojure.math.combinatorics :as combo]) ;; requires the org.clojure/math.combinatorics contrib library

(defn satisfies
  [pred &amp; seqs]
  (every? pred (apply combo/cartesian-product seqs)))

(let [structure-1 {1 {:a :blah} 2 {:a :blah}}
      structure-2 [{:b :blah} {:b :blah}]]
  (satisfies = (select [MAP-VALS :a] structure-1)
             (select [ALL :b] structure-2))))
;; =&gt; true</pre></z><z id="t1631304018" t="Joshua Suskalo You could do additional validation like ensuring that both selects return at least one value, or an equal number of values, or whatever, based on your needs."><y>#</y><d>2021-09-10</d><h>20:00</h><w>Joshua Suskalo</w>You could do additional validation like ensuring that both selects return at least one value, or an equal number of values, or whatever, based on your needs.</z><z id="t1631507217" t="johanatan that&apos;s close but not quite it. the keys need to match in both. in your example there is no correspondence between structure-1 and structure-2 since the keys do not overlap"><y>#</y><d>2021-09-13</d><h>04:26</h><w>johanatan</w>that&apos;s close but not quite it. the keys need to match in both. in your example there is no correspondence between structure-1 and structure-2 since the keys do not overlap</z><z id="t1631507356" t="johanatan i was thinking of a zipping the two structures into a sequence where each entry is a three-tuple of the following form: [materizlied_path, value_one, value_two] where either value_one or value_two could be nil when that structure does not have an entry for a specific path that the other one does."><y>#</y><d>2021-09-13</d><h>04:29</h><w>johanatan</w>i was thinking of a zipping the two structures into a sequence where each entry is a three-tuple of the following form:

[materizlied_path, value_one, value_two]

where either value_one or value_two could be nil when that structure does not have an entry for a specific path that the other one does.</z><z id="t1631507376" t="johanatan then the satisfies would make sure that no nil entries exist in any of those slots for my particular application"><y>#</y><d>2021-09-13</d><h>04:29</h><w>johanatan</w>then the <code>satisfies</code> would make sure that no <code>nil</code> entries exist in any of those slots for my particular application</z><z id="t1631547602" t="Joshua Suskalo Ah, that was unclear from your initial description of the problem. I don&apos;t believe specter has a way for you to get a pair of the actual path followed along with the value, which means you would likely need to generate a list of possible paths and iterate over them manually."><y>#</y><d>2021-09-13</d><h>15:40</h><w>Joshua Suskalo</w>Ah, that was unclear from your initial description of the problem. I don&apos;t believe specter has a way for you to get a pair of the actual path followed along with the value, which means you would likely need to generate a list of possible paths and iterate over them manually.</z><z id="t1631547689" t="Joshua Suskalo Specifically, you could have a way to generate a &quot;materialized path&quot; from each of the types of navigations which navigate to multiple items. Like ALL generating a sequence of paths with nth being called for each integer in (range 0 (count structure)), or MAP-VALS generating a sequence of the keys."><y>#</y><d>2021-09-13</d><h>15:41</h><w>Joshua Suskalo</w>Specifically, you could have a way to generate a &quot;materialized path&quot; from each of the types of navigations which navigate to multiple items. Like ALL generating a sequence of paths with nth being called for each integer in (range 0 (count structure)), or MAP-VALS generating a sequence of the keys.</z><z id="t1631554937" t="johanatan Pretty sure it wasn&apos;t &quot;unclear from my initial description&quot;. Please re-read. Pay particular attention to: a) verify that the same key structure exists in both"><y>#</y><d>2021-09-13</d><h>17:42</h><w>johanatan</w>Pretty sure it wasn&apos;t &quot;unclear from my initial description&quot;. Please re-read. Pay particular attention to: a) verify that the same key structure exists in both</z><z id="t1631554985" t="johanatan Ok, yes looks like a challenge wrt generating (or iterating) the paths but that seems surmountable."><y>#</y><d>2021-09-13</d><h>17:43</h><w>johanatan</w>Ok, yes looks like a challenge wrt generating (or iterating) the paths but that seems surmountable.</z><z id="t1631555081" t="johanatan Thanks for your help!"><y>#</y><d>2021-09-13</d><h>17:44</h><w>johanatan</w>Thanks for your help!</z><z id="t1631560584" t="Joshua Suskalo No problem! Might just be I read that different because even on re-reading it didn&apos;t seem clear to me. Definitely not a huge concern though, it got worked out! 🙂"><y>#</y><d>2021-09-13</d><h>19:16</h><w>Joshua Suskalo</w>No problem! Might just be I read that different because even on re-reading it didn&apos;t seem clear to me. Definitely not a huge concern though, it got worked out! <b>🙂</b></z><z id="t1631561548" t="johanatan btw, i just realized that i already have this keys-in function in my codebase (based on tree-seq ), so i probably don&apos;t really even need specter for this: https://dnaeon.github.io/clojure-map-ks-paths/"><y>#</y><d>2021-09-13</d><h>19:32</h><w>johanatan</w>btw, i just realized that i already have this <code>keys-in</code> function in my codebase (based on <code>tree-seq</code>), so i probably don&apos;t really even need specter for this:
<a href="https://dnaeon.github.io/clojure-map-ks-paths/" target="_blank">https://dnaeon.github.io/clojure-map-ks-paths/</a></z><z id="t1631561583" t="johanatan i can just get the key sequence paths for m1 and then call get-in for each of them on m2"><y>#</y><d>2021-09-13</d><h>19:33</h><w>johanatan</w>i can just get the key sequence paths for m1 and then call <code>get-in</code> for each of them on m2</z><z id="t1631572562" t="johanatan arguably not nearly as elegant as whatever the specter solution would be tho 🙂"><y>#</y><d>2021-09-13</d><h>22:36</h><w>johanatan</w>arguably not nearly as elegant as whatever the specter solution would be tho <b>🙂</b></z><z id="t1631574669" t="steveb8n Q: I’m using a multi-path in a recursive path similar to this example https://github.com/redplanetlabs/specter/wiki/Using-Specter-Recursively#recursively-navigate-to-every-map-in-a-map-of-maps I just discovered that my multi-path expression is working on jvm but not on javascript. The problem seems to be that I have 20 values in the multi-path. has anyone seen a limit of 20 in paths failing like this before?"><y>#</y><d>2021-09-13</d><h>23:11</h><w>steveb8n</w>Q: I’m using a multi-path in a recursive path similar to this example <a href="https://github.com/redplanetlabs/specter/wiki/Using-Specter-Recursively#recursively-navigate-to-every-map-in-a-map-of-maps" target="_blank">https://github.com/redplanetlabs/specter/wiki/Using-Specter-Recursively#recursively-navigate-to-every-map-in-a-map-of-maps</a>
I just discovered that my multi-path expression is working on jvm but not on javascript. The problem seems to be that I have 20 values in the multi-path. has anyone seen a limit of 20 in paths failing like this before?</z><z id="t1631574938" t="steveb8n I also discovered that 21 values in multi-path fails on cljs with “invalid arity” but not on jvm"><y>#</y><d>2021-09-13</d><h>23:15</h><r>steveb8n</r>I also discovered that 21 values in multi-path fails on cljs with “invalid arity” but not on jvm</z><z id="t1631575026" t="steveb8n I wonder if this is the reason? https://github.com/redplanetlabs/specter/blob/master/src/clj/com/rpl/specter/util_macros.clj#L18"><y>#</y><d>2021-09-13</d><h>23:17</h><r>steveb8n</r>I wonder if this is the reason? <a href="https://github.com/redplanetlabs/specter/blob/master/src/clj/com/rpl/specter/util_macros.clj#L18" target="_blank">https://github.com/redplanetlabs/specter/blob/master/src/clj/com/rpl/specter/util_macros.clj#L18</a></z><z id="t1631575148" t="steveb8n workaround: compose the multi-path out of other multi-paths"><y>#</y><d>2021-09-13</d><h>23:19</h><r>steveb8n</r>workaround: compose the multi-path out of other multi-paths</z><z id="t1631575771" t="steveb8n the bug is that the 20th entry is ignored when used in cljs. if there’s 19 entries then it is fine"><y>#</y><d>2021-09-13</d><h>23:29</h><r>steveb8n</r>the bug is that the 20th entry is ignored when used in cljs. if there’s 19 entries then it is fine</z><z id="t1631576652" t="steveb8n asking here before I log a bug, just so I know I’m not missing something stoopid"><y>#</y><d>2021-09-13</d><h>23:44</h><r>steveb8n</r>asking here before I log a bug, just so I know I’m not missing something stoopid</z><z id="t1631580161" t="steveb8n [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] do you care about edge case bugs like this?"><y>#</y><d>2021-09-14</d><h>00:42</h><r>steveb8n</r><a>@U173SEFUN</a> do you care about edge case bugs like this?</z><z id="t1631581106" t="johanatan i highly doubt that resource limitations of modern computers really justify that maximum being 20 . probably could be just fine with 127 or 1023"><y>#</y><d>2021-09-14</d><h>00:58</h><r>johanatan</r>i highly doubt that resource limitations of modern computers really justify that maximum being <code>20</code>. probably could be just fine with <code>127</code> or <code>1023</code></z><z id="t1631581121" t="johanatan and way more generous to users"><y>#</y><d>2021-09-14</d><h>00:58</h><r>johanatan</r>and way more generous to users</z><z id="t1631581136" t="johanatan just to throw my two cents in"><y>#</y><d>2021-09-14</d><h>00:58</h><r>johanatan</r>just to throw my two cents in</z><z id="t1631581143" t="johanatan 🙂"><y>#</y><d>2021-09-14</d><h>00:59</h><r>johanatan</r><b>🙂</b></z><z id="t1631581615" t="nathanmarz [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}] please file a bug report"><y>#</y><d>2021-09-14</d><h>01:06</h><r>nathanmarz</r><a>@U0510KXTU</a> please file a bug report</z><z id="t1631581646" t="steveb8n roger that. will do"><y>#</y><d>2021-09-14</d><h>01:07</h><r>steveb8n</r>roger that. will do</z><z id="t1631582281" t="steveb8n https://github.com/redplanetlabs/specter/issues/318"><y>#</y><d>2021-09-14</d><h>01:18</h><r>steveb8n</r><a href="https://github.com/redplanetlabs/specter/issues/318" target="_blank">https://github.com/redplanetlabs/specter/issues/318</a></z><z id="t1632133842" t="agh2o Hi, I was wondering if there is a way to do something along these lines: (specter/some-func [s/ALL s/ALL keyword?] [1 2 3] [(:akeyword true) (:akeyword false) (:akeyword false)]) =&gt; [(1 true) (2 false) (3 false)] Meaning navigate to a subsequnce and replace it with another sequence in place. I thought about using transform with a impure function that returns the next item on every call, but i&apos;m assuming there is a better way. thanks in advance :"><y>#</y><d>2021-09-20</d><h>10:30</h><w>agh2o</w>Hi, I was wondering if there is a way to do something along these lines:
<pre>(specter/some-func
  [s/ALL s/ALL keyword?]
  [1 2 3]
  [(:akeyword true) (:akeyword false) (:akeyword false)]) =&gt; [(1 true) (2 false) (3 false)]</pre>
Meaning navigate to a subsequnce and replace it with another sequence in place.
I thought about using transform with a impure function that returns the next item on every call, but i&apos;m assuming there is a better way.
thanks in advance :</z><z id="t1632141924" t="agh2o I&apos;m thinking, if the transform would optionally supply the index of the item to the given function. the function could be pure and give the next item..."><y>#</y><d>2021-09-20</d><h>12:45</h><w>agh2o</w>I&apos;m thinking, if the transform would optionally supply the index of the item to the given function. the function could be pure and give the next item...</z></g><g id="s25"><z id="t1632151506" t="nathanmarz [:attrs {:href &quot;/_/_/users/U02FP0U7J1W&quot;}] you&apos;re looking for subselect"><y>#</y><d>2021-09-20</d><h>15:25</h><w>nathanmarz</w><a>@idosilverwater</a> you&apos;re looking for <code>subselect</code></z><z id="t1632153684" t="agh2o great! thank you"><y>#</y><d>2021-09-20</d><h>16:01</h><w>agh2o</w>great! thank you</z><z id="t1633366281" t="chromalchemy How do you do something like and-path , comparable to if-path ? I want to use it selected? , to test if 2 paths have results. multi-path seems to behave more like an or-path navigator."><y>#</y><d>2021-10-04</d><h>16:51</h><w>chromalchemy</w>How do you do something like <code>and-path</code> , comparable to <code>if-path</code> ?  I want to use it  <code>selected?</code> , to test if 2 paths have results. <code>multi-path</code> seems to behave more like an <code>or-path</code> navigator.</z><z id="t1633382353" t="nathanmarz [:attrs {:href &quot;/_/_/users/U09D96P9B&quot;}] that would just be something like (if-path [:a even?] (if-path [:b odd?] STAY))"><y>#</y><d>2021-10-04</d><h>21:19</h><w>nathanmarz</w><a>@chromalchemy</a> that would just be something like <code>(if-path [:a even?] (if-path [:b odd?] STAY))</code></z><z id="t1633382410" t="nathanmarz should be straightforward to define a defdynamicnav called and-path that expands to that"><y>#</y><d>2021-10-04</d><h>21:20</h><w>nathanmarz</w>should be straightforward to define a <code>defdynamicnav</code> called <code>and-path</code> that expands to that</z><z id="t1633531619" t="chromalchemy Thanks! (selected? (multi-path :a :b) some?) Seems to kind of work also."><y>#</y><d>2021-10-06</d><h>14:46</h><w>chromalchemy</w>Thanks!  <code>(selected? (multi-path :a :b) some?)</code>  Seems to kind of work also.</z><z id="t1633598475" t="Quentin Le Guennec Hello, for some reason this doesn&apos;t work in specter: (sp/select-one [sp/FIRST key] {:a :b}) =&gt; [:a :b] Is there specter equivalent of clojure.core key / val?"><y>#</y><d>2021-10-07</d><h>09:21</h><w>Quentin Le Guennec</w>Hello, for some reason this doesn&apos;t work in specter:
<pre>(sp/select-one
 [sp/FIRST
  key]
 {:a :b}) =&gt; [:a :b]</pre>
Is there specter equivalent of clojure.core key / val?</z><z id="t1633623747" t="Joshua Suskalo you could use (view first)"><y>#</y><d>2021-10-07</d><h>16:22</h><w>Joshua Suskalo</w>you could use <code>(view first)</code></z><z id="t1633623778" t="Joshua Suskalo Although I&apos;m curious what your intention is for using FIRST on a map."><y>#</y><d>2021-10-07</d><h>16:22</h><w>Joshua Suskalo</w>Although I&apos;m curious what your intention is for using <code>FIRST</code> on a map.</z><z id="t1633623788" t="Joshua Suskalo Since maps are usually not in a predictable order."><y>#</y><d>2021-10-07</d><h>16:23</h><w>Joshua Suskalo</w>Since maps are usually not in a predictable order.</z><z id="t1634205040" t="Quentin Le Guennec [:attrs {:href &quot;/_/_/users/U5NCUG8NR&quot;}] thank you, I assume view key would work too."><y>#</y><d>2021-10-14</d><h>09:50</h><w>Quentin Le Guennec</w><a>@suskeyhose</a> thank you, I assume <code>view key</code> would work too.</z><z id="t1634205062" t="Quentin Le Guennec (it&apos;s always a one element map, that&apos;s why)"><y>#</y><d>2021-10-14</d><h>09:51</h><w>Quentin Le Guennec</w>(it&apos;s always a one element map, that&apos;s why)</z><z id="t1634205088" t="Quentin Le Guennec (some maps are in a predictable order, though)"><y>#</y><d>2021-10-14</d><h>09:51</h><w>Quentin Le Guennec</w>(some maps are in a predictable order, though)</z><z id="t1634218184" t="Joshua Suskalo yes"><y>#</y><d>2021-10-14</d><h>13:29</h><w>Joshua Suskalo</w>yes</z><z id="t1634218192" t="Joshua Suskalo fair enough"><y>#</y><d>2021-10-14</d><h>13:29</h><w>Joshua Suskalo</w>fair enough</z><z id="t1634548971" t="onetom is there a recommended naming scheme for custom paths? eg. https://github.com/redplanetlabs/specter/wiki/List-of-Macros#path shows: (def MY-PATH (path even?)) from which I would conclude that ALL-CAPS would signify a custom path, but that -PATH prefix feels a bit too verbose."><y>#</y><d>2021-10-18</d><h>09:22</h><w>onetom</w>is there a recommended naming scheme for custom paths?
eg. <a href="https://github.com/redplanetlabs/specter/wiki/List-of-Macros#path" target="_blank">https://github.com/redplanetlabs/specter/wiki/List-of-Macros#path</a> shows:
<pre>(def MY-PATH (path even?))</pre>
from which I would conclude that ALL-CAPS would signify a custom path, but that <code>-PATH</code> prefix feels a bit too verbose.</z><z id="t1635080736" t="chromalchemy [:attrs {:href &quot;/_/_/users/U086D6TBN&quot;}] I started using my-path= to distinguish paths from regular function defs. I think i picked this up from a Hoplon user who would use the “=” to distinguish derived (reactive) “formula” cells/atoms, from regular input (non-reactive) cells/atoms in the Javelin state management system. Javelin is a lens library, and is useful to encapsulate and name data reading and writing paths. I was also using Specter within Javelin cells. Seemed like a powerful combo to tame any hairy data model for front end use."><y>#</y><d>2021-10-24</d><h>13:05</h><w>chromalchemy</w><a>@onetom</a> I started using <code>my-path=</code> to distinguish paths from regular function defs.
I think i picked this up from a Hoplon user who would use the “=” to distinguish derived (reactive) “formula” cells/atoms, from regular input (non-reactive) cells/atoms in the Javelin state management system.
Javelin is a lens library, and is useful to encapsulate and name data reading and writing paths. I was also using Specter within Javelin cells. Seemed like a powerful combo to tame any hairy data model for front end use.</z><z id="t1635257189" t="onetom thanks, interesting idea! btw, i was also a hoplon user 😉 so how about parametric paths? those would also follow this convention? as we an see on https://github.com/redplanetlabs/specter/wiki/List-of-Navigators the unparameterized navigators are all-caps and the parameterized ones are just regular lower-kebab-case names, without any special convention."><y>#</y><d>2021-10-26</d><h>14:06</h><r>onetom</r>thanks, interesting idea!
btw, i was also a hoplon user <b>😉</b>
so how about parametric paths?
those would also follow this convention?
as we an see on <a href="https://github.com/redplanetlabs/specter/wiki/List-of-Navigators" target="_blank">https://github.com/redplanetlabs/specter/wiki/List-of-Navigators</a>
the unparameterized navigators are all-caps and the parameterized ones are just regular lower-kebab-case names, without any special convention.</z><z id="t1635257344" t="onetom (def a:b 123) =&gt; #&apos;user/a:b a:b =&gt; 123 maybe a colon somewhere could also be used as part of the notation..."><y>#</y><d>2021-10-26</d><h>14:09</h><r>onetom</r><pre>(def a:b 123)
=&gt; #&apos;user/a:b
a:b
=&gt; 123</pre>
maybe a colon somewhere could also be used as part of the notation...</z><z id="t1635257542" t="onetom ooor %path , like in REBOL! 🙂 and for parametric ones, it could be %path: ;D it would work, but it would also look quite cryptic..."><y>#</y><d>2021-10-26</d><h>14:12</h><r>onetom</r>ooor <code>%path</code>, like in REBOL! <b>🙂</b>
and for parametric ones, it could be <code>%path:</code> ;D
it would work, but it would also look quite cryptic...</z><z id="t1636137327" t="Stuart Can someone help explain to me how walker works. Below I&apos;m trying to exclude all maps and submaps that contain a value &quot;red&quot; (defn has-red? [x] (prn x) (cond (map? x) (nil? ((-&gt; x vals set) &quot;red&quot;)) :else false)) (let [j [{&quot;a&quot; 2 &quot;b&quot; 4 &quot;d&quot; &quot;green&quot; &quot;e&quot; [{&quot;z&quot; &quot;zzz&quot; &quot;y&quot; &quot;yyy&quot;}] &quot;c&quot; {&quot;d&quot; 5 &quot;e&quot; &quot;red&quot; &quot;g&quot; {&quot;h&quot; 9 &quot;i&quot; \a}} &quot;m&quot; {&quot;aa&quot; 99}} {&quot;sdfsdf&quot; &quot;gsdgdfgdfg&quot; &quot;fsf&quot; 979 &quot;d&quot; &quot;orange&quot; &quot;e&quot; [{&quot;z&quot; &quot;red&quot; &quot;y&quot; &quot;yyy&quot;} {&quot;jfoj&quot; &quot;purple&quot; &quot;fffj&quot; 5}] &quot;c&quot; {&quot;d&quot; 5 &quot;e&quot; &quot;purple&quot; &quot;g&quot; {&quot;h&quot; 9 &quot;i&quot; \a}} &quot;m&quot; {&quot;red&quot; 99}}]] (select (walker has-red?) j)) If I change has-red? to just return false . I get an empty vector, this makes sense, it also prints every key and value in the structure. If I just return true, then it prints the whole structure once and returns that.... Can I walk each element, and only returns those that has-red returns false for, that way dropping any sub maps that contain a value &quot;red&quot; ? What function should I be looking at ?"><y>#</y><d>2021-11-05</d><h>18:35</h><w>Stuart</w>Can someone help explain to me how <code>walker</code> works. Below I&apos;m trying to exclude all maps and submaps that contain a value <code>&quot;red&quot;</code>

<pre>(defn has-red? [x]
  (prn x)
  (cond (map? x) (nil? ((-&gt; x vals set) &quot;red&quot;))
        :else false))

(let [j [{&quot;a&quot; 2
          &quot;b&quot; 4
          &quot;d&quot; &quot;green&quot;
          &quot;e&quot; [{&quot;z&quot; &quot;zzz&quot;
                &quot;y&quot; &quot;yyy&quot;}]
          &quot;c&quot; {&quot;d&quot; 5
               &quot;e&quot; &quot;red&quot;
               &quot;g&quot; {&quot;h&quot; 9
                    &quot;i&quot; \a}}
          &quot;m&quot; {&quot;aa&quot; 99}}
         {&quot;sdfsdf&quot; &quot;gsdgdfgdfg&quot;
          &quot;fsf&quot; 979
          &quot;d&quot; &quot;orange&quot;
          &quot;e&quot; [{&quot;z&quot; &quot;red&quot;
                &quot;y&quot; &quot;yyy&quot;}
               {&quot;jfoj&quot; &quot;purple&quot;
                &quot;fffj&quot; 5}]
          &quot;c&quot; {&quot;d&quot; 5
               &quot;e&quot; &quot;purple&quot;
               &quot;g&quot; {&quot;h&quot; 9
                    &quot;i&quot; \a}}
          &quot;m&quot; {&quot;red&quot; 99}}]]
  (select (walker has-red?) j))</pre>
If I change <code>has-red?</code> to just return <code>false</code>. I get an empty vector, this makes sense, it also prints every key and value in the structure. If I just return true, then it prints the whole structure once and returns that....

Can I walk each element, and only returns those that <code>has-red</code> returns false for, that way dropping any sub maps that contain a value <code>&quot;red&quot;</code> ? What function should I be looking at ?</z><z id="t1638106015" t="lvh I&apos;m confused, isn&apos;t that (select (complement has-red?) x)?"><y>#</y><d>2021-11-28</d><h>13:26</h><w>lvh</w>I&apos;m confused, isn&apos;t that (select (complement has-red?) x)?</z><z id="t1639772614" t="jmv hey all, i&apos;m trying to write a transformation to replace all matching continuous subsequences with a new value. it looks like there is https://github.com/redplanetlabs/specter/issues/236 to simplify this, but i was wondering what&apos;s the best way to accomplish it today. as an explicit example, i&apos;m trying to do something like this: (def data [0 0 0 1 2 3 0 0 1 2 0 0 1 2 3]) (s/setval [???] :A data) ;; replace each continuous [1 2 3] with :A ;;=&gt; [0 0 0 :A 0 0 1 2 0 0 :A] "><y>#</y><d>2021-12-17</d><h>20:23</h><w>jmv</w>hey all, i&apos;m trying to write a transformation to replace all matching continuous subsequences with a new value. it looks like there is <a href="https://github.com/redplanetlabs/specter/issues/236" target="_blank">https://github.com/redplanetlabs/specter/issues/236</a> to simplify this, but i was wondering what&apos;s the best way to accomplish it today. as an explicit example, i&apos;m trying to do something like this:
<pre>(def data [0 0 0 1 2 3 0 0 1 2 0 0 1 2 3])
(s/setval [???] :A data) ;; replace each continuous [1 2 3] with :A
;;=&gt; [0 0 0 :A 0 0 1 2 0 0 :A]</pre>
</z><z id="t1639851470" t="nathanmarz [:attrs {:href &quot;/_/_/users/UDXEK491P&quot;}] that navigator improvement is needed for this use case"><y>#</y><d>2021-12-18</d><h>18:17</h><w>nathanmarz</w><a>@jmv305</a> that navigator improvement is needed for this use case</z><z id="t1639934906" t="jmv [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] i see that there&apos;s an abandoned attempt at implementation. is that something I could try to finish to get merged in? "><y>#</y><d>2021-12-19</d><h>17:28</h><r>jmv</r><a>@U173SEFUN</a> i see that there&apos;s an abandoned attempt at implementation. is that something I could try to finish to get merged in? </z><z id="t1639939654" t="nathanmarz I haven&apos;t been keeping up with PRs, so I would recommend just implementing a version for yourself."><y>#</y><d>2021-12-19</d><h>18:47</h><r>nathanmarz</r>I haven&apos;t been keeping up with PRs, so I would recommend just implementing a version for yourself.</z><z id="t1640022103" t="futurile I &apos;published&apos; a blog post on Specter which I would love feedback on. It says March, but actually (for various reasons) it was only published today. It&apos;s aimed for beginner/intermediates like me, so the examples might be too obvious for professional developers: http://www.futurile.net/2021/03/20/specter-nested-data-manipulation-for-clojure/"><y>#</y><d>2021-12-20</d><h>17:41</h><w>futurile</w>I &apos;published&apos; a blog post on Specter which I would love feedback on. It says March, but actually (for various reasons) it was only published today. It&apos;s aimed for beginner/intermediates like me, so the examples might be too obvious for professional developers: <a href="http://www.futurile.net/2021/03/20/specter-nested-data-manipulation-for-clojure/" target="_blank">http://www.futurile.net/2021/03/20/specter-nested-data-manipulation-for-clojure/</a></z><z id="t1640031048" t="nathanmarz [:attrs {:href &quot;/_/_/users/UV1JWR18U&quot;}] cool, I recommend posting to #news-and-articles"><y>#</y><d>2021-12-20</d><h>20:10</h><w>nathanmarz</w><a>@slgeorge</a> cool, I recommend posting to #news-and-articles</z><z id="t1640031527" t="james [:attrs {:href &quot;/_/_/users/UV1JWR18U&quot;}] Great introduction!"><y>#</y><d>2021-12-20</d><h>20:18</h><w>james</w><a>@slgeorge</a> Great introduction!</z><z id="t1640032659" t="futurile [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] : Thanks yes I&apos;ll post it. Will wait to see if there&apos;s any feedback. Hopefully no horrendous mistakes and fingers crossed covered the major use-cases for common usage."><y>#</y><d>2021-12-20</d><h>20:37</h><w>futurile</w><a>@nathanmarz</a>: Thanks yes I&apos;ll post it. Will wait to see if there&apos;s any feedback. Hopefully no horrendous mistakes and fingers crossed covered the major use-cases for common usage.</z><z id="t1640032734" t="futurile [:attrs {:href &quot;/_/_/users/U0186LK0G87&quot;}] : appreciated, spend ages trying to get my understanding right =-)"><y>#</y><d>2021-12-20</d><h>20:38</h><w>futurile</w><a>@johsgrd</a>: appreciated, spend ages trying to get my understanding right =-)</z><z id="t1640037209" t="steveb8n Q: I use Specter everywhere. The one area where I hit limitations has been runtime paths i.e. storing paths in a db and using them at runtime. Basically this isn’t possible without adding a data/dsl on top of each navigator. Has anyone else tried this or seen any clever solutions for this?"><y>#</y><d>2021-12-20</d><h>21:53</h><w>steveb8n</w>Q: I use Specter everywhere. The one area where I hit limitations has been runtime paths i.e. storing paths in a db and using them at runtime. Basically this isn’t possible without adding a data/dsl on top of each navigator. Has anyone else tried this or seen any clever solutions for this?</z><z id="t1640057825" t="nathanmarz [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}] In our internal version of specter we converted defnav , defrichnav , comp-navs , etc. to generate records rather than use reify like the open-source version does. This allows us to serialize navs/paths easily (e.g. using nippy). No plans to port this to the open-source version though."><y>#</y><d>2021-12-21</d><h>03:37</h><w>nathanmarz</w><a>@steveb8n</a> In our internal version of specter we converted <code>defnav</code> , <code>defrichnav</code> , <code>comp-navs</code>, etc. to generate records rather than use <code>reify</code> like the open-source version does. This allows us to serialize navs/paths easily (e.g. using nippy). No plans to port this to the open-source version though.</z><z id="t1640058130" t="steveb8n Good to know. Thanks. My brute force data-dsl works for now. I might try your tag-literal idea in future."><y>#</y><d>2021-12-21</d><h>03:42</h><r>steveb8n</r>Good to know. Thanks. My brute force data-dsl works for now. I might try your tag-literal idea in future.</z><z id="t1640178711" t="Wilson Velez Hi, I’m starting with specter and I have a question, I have this map {:a {:f-c &quot;a&quot; :p 3.3 :l 1} :b {:f-c &quot;b&quot; :p 6.7 :l 2}} that I want to transform it in [{:c &quot;a&quot; :pct 3.3} {:c &quot;b&quot; :pct 6.7}] (def ui {:alloc {:a {:f-c &quot;a&quot; :p 3.3 :l 1} :b {:f-c &quot;b&quot; :p 6.7 :l 2}}}) (s/transform :alloc #(into [] %) ui) =&gt; {:alloc [[:a {:f-c &quot;a&quot;, :p 3.3, :l 1}] [:b {:f-c &quot;b&quot;, :p 6.7, :l 2}]]} I haven’t been able to get the values of the internal maps in order to use their values and create a new structure what am I missing here?"><y>#</y><d>2021-12-22</d><h>13:11</h><w>Wilson Velez</w>Hi, I’m starting with specter and I have a question, I have this map  <code>{:a {:f-c &quot;a&quot; :p 3.3 :l 1} :b {:f-c &quot;b&quot; :p 6.7 :l 2}}</code> that I want to transform it in  <code>[{:c &quot;a&quot; :pct 3.3} {:c &quot;b&quot; :pct 6.7}]</code>
<pre>(def ui {:alloc {:a {:f-c &quot;a&quot; :p 3.3 :l 1} :b {:f-c &quot;b&quot; :p 6.7 :l 2}}})
(s/transform :alloc #(into [] %) ui) =&gt; {:alloc [[:a {:f-c &quot;a&quot;, :p 3.3, :l 1}] [:b {:f-c &quot;b&quot;, :p 6.7, :l 2}]]}</pre>
I haven’t been able to get the values of the internal maps in order to use their values and create a new structure
what am I missing here?</z><z id="t1641039772" t="Carlo I opened an issue/question on the behavior of ALL on strings: https://github.com/redplanetlabs/specter/issues/320"><y>#</y><d>2022-01-01</d><h>12:22</h><w>Carlo</w>I opened an issue/question on the behavior of <code>ALL</code> on strings:
<a href="https://github.com/redplanetlabs/specter/issues/320" target="_blank">https://github.com/redplanetlabs/specter/issues/320</a></z><z id="t1642790734" t="borkdude This CLI has specter built-in for selecting data."><y>#</y><d>2022-01-21</d><h>18:45</h><w>borkdude</w>This CLI has specter built-in for selecting data.</z><z id="t1643400033" t="denik Is there a way in specter to collect values based on a predicate, pass the values to a function that updates all of them (map-like fn signature) and replace the old values with the new ones?"><y>#</y><d>2022-01-28</d><h>20:00</h><w>denik</w>Is there a way in specter to collect values based on a predicate, pass the values to a function that updates all of them (map-like fn signature) and replace the old values with the new ones?</z><z id="t1643400254" t="denik (defn map-replace [pred transform-all x] ;; ... what would go here? ) (def d {:a 1 :b {:c 2 :d {:e 3}}}) (map-replace number? #(map inc %) d) ; =&gt; {:a 2 :b {:c 3 :d {:e 4}}}"><y>#</y><d>2022-01-28</d><h>20:04</h><w>denik</w><pre>(defn map-replace [pred transform-all x]
  ;; ... what would go here?
  )

(def d
  {:a 1
   :b {:c 2
       :d {:e 3}}})

(map-replace number? #(map inc %) d)
; =&gt; 
{:a 2
 :b {:c 3
     :d {:e 4}}}</pre></z><z id="t1643400360" t="denik of course the real world use-case is more complicated where some values of the map are I/O processes I need to run in parallel and block until all complete. this is why all of them need to be collected."><y>#</y><d>2022-01-28</d><h>20:06</h><w>denik</w>of course the real world use-case is more complicated where some values of the map are I/O processes I need to run in parallel and block until all complete. this is why all of them need to be collected.</z><z id="t1645442331" t="Kris C Is it possible to sort a sequence of nested maps with Specter? The sequence example: ( {:entity/id &quot;1&quot;, :entity/locations [ {:location/id &quot;101&quot;, :location/name &quot;1 First&quot;, :location/type :locationType/type1 } {:location/id &quot;102&quot;, :location/name &quot;1 Second&quot;, :location/type :locationType/type2 } {:location/id &quot;103&quot;, :location/name &quot;1 Third&quot;, :location/type :locationType/type3 }]} {:entity/id &quot;3&quot;, :entity/locations [ {:location/id &quot;301&quot;, :location/name &quot;3 First&quot;, :location/type :locationType/type1 } {:location/id &quot;302&quot;, :location/name &quot;3 Second&quot;, :location/type :locationType/type2 } {:location/id &quot;303&quot;, :location/name &quot;3 Third&quot;, :location/type :locationType/type3 }]} {:entity/id &quot;2&quot;, :entity/locations [ {:location/id &quot;201&quot;, :location/name &quot;2 First&quot;, :location/type :locationType/type1 } {:location/id &quot;202&quot;, :location/name &quot;2 Second&quot;, :location/type :locationType/type2 } {:location/id &quot;203&quot;, :location/name &quot;2 Third&quot;, :location/type :locationType/type3 }]} ) I want to sort it by :location/name of the :entity/locations element where :location/type is some value (e.g. :locationType/type3 ) So, if I sort it by :location/name where :locationType is :locationType/type3 I would get the sequence where the entities (`:entity/id`) would be in the following order: &quot;1&quot;,&quot;2&quot;,&quot;3&quot;."><y>#</y><d>2022-02-21</d><h>11:18</h><w>Kris C</w>Is it possible to sort a sequence of nested maps with Specter?

The sequence example:

<pre>(
 {:entity/id &quot;1&quot;,
  :entity/locations [
    {:location/id &quot;101&quot;,
      :location/name &quot;1 First&quot;,
      :location/type :locationType/type1
    }
    {:location/id &quot;102&quot;,
      :location/name &quot;1 Second&quot;,
      :location/type :locationType/type2
    }
    {:location/id &quot;103&quot;,
     :location/name &quot;1 Third&quot;,
     :location/type :locationType/type3
    }]}
 {:entity/id &quot;3&quot;,
  :entity/locations [
    {:location/id &quot;301&quot;,
     :location/name &quot;3 First&quot;,
     :location/type :locationType/type1
    }
    {:location/id &quot;302&quot;,
     :location/name &quot;3 Second&quot;,
     :location/type :locationType/type2
    }
    {:location/id &quot;303&quot;,
     :location/name &quot;3 Third&quot;,
     :location/type :locationType/type3
    }]}
 {:entity/id &quot;2&quot;,
  :entity/locations [
    {:location/id &quot;201&quot;,
     :location/name &quot;2 First&quot;,
     :location/type :locationType/type1
    }
    {:location/id &quot;202&quot;,
     :location/name &quot;2 Second&quot;,
     :location/type :locationType/type2
    }
    {:location/id &quot;203&quot;,
     :location/name &quot;2 Third&quot;,
     :location/type :locationType/type3
    }]}
)</pre>
I want to sort it by <code>:location/name</code> of the <code>:entity/locations</code> element where <code>:location/type</code> is some value (e.g. <code>:locationType/type3</code>)

So, if I sort it by <code>:location/name</code> where <code>:locationType</code> is <code>:locationType/type3</code> I would get the sequence where the entities (`:entity/id`) would be in the following order:  &quot;1&quot;,&quot;2&quot;,&quot;3&quot;.</z><z id="t1645486113" t="Joshua Suskalo There&apos;s a pr for this"><y>#</y><d>2022-02-21</d><h>23:28</h><w>Joshua Suskalo</w>There&apos;s a pr for this</z><z id="t1645486122" t="Joshua Suskalo well, kinda"><y>#</y><d>2022-02-21</d><h>23:28</h><w>Joshua Suskalo</w>well, kinda</z><z id="t1645486169" t="Joshua Suskalo You can do sort-by and use select as they keyfn"><y>#</y><d>2022-02-21</d><h>23:29</h><w>Joshua Suskalo</w>You can do sort-by and use <code>select</code> as they keyfn</z><z id="t1645516083" t="Kris C Ah, ok, I am doing that, but thought sorting might be possible via specter..."><y>#</y><d>2022-02-22</d><h>07:48</h><r>Kris C</r>Ah, ok, I am doing that, but thought sorting might be possible via specter...</z><z id="t1645544823" t="Joshua Suskalo There&apos;s a PR to add a SORTED navigator which gives you a sorted view over the data, but it wouldn&apos;t do what you&apos;re after here I don&apos;t think."><y>#</y><d>2022-02-22</d><h>15:47</h><r>Joshua Suskalo</r>There&apos;s a PR to add a <code>SORTED</code> navigator which gives you a sorted view over the data, but it wouldn&apos;t do what you&apos;re after here I don&apos;t think.</z><z id="t1645544836" t="Joshua Suskalo You could also use transform and then use sort as the transform function."><y>#</y><d>2022-02-22</d><h>15:47</h><r>Joshua Suskalo</r>You could also use <code>transform</code> and then use <code>sort</code> as the transform function.</z><z id="t1645547513" t="Kris C [:attrs {:href &quot;/_/_/users/U5NCUG8NR&quot;}] can you give me an example? I&apos;m pretty new with specter..."><y>#</y><d>2022-02-22</d><h>16:31</h><r>Kris C</r><a>@U5NCUG8NR</a> can you give me an example? I&apos;m pretty new with specter...</z><z id="t1645547616" t="Joshua Suskalo (transform [ALL :entity/locations] (partial sort-by :location/name) your-data) This would take each entity and sort its locations by their name."><y>#</y><d>2022-02-22</d><h>16:33</h><r>Joshua Suskalo</r><pre>(transform [ALL :entity/locations] (partial sort-by :location/name) your-data)</pre>
This would take each entity and sort its locations by their name.</z><z id="t1645547641" t="Joshua Suskalo Oh wait"><y>#</y><d>2022-02-22</d><h>16:34</h><r>Joshua Suskalo</r>Oh wait</z><z id="t1645547647" t="Joshua Suskalo I think I mistook your meaning"><y>#</y><d>2022-02-22</d><h>16:34</h><r>Joshua Suskalo</r>I think I mistook your meaning</z><z id="t1645547681" t="Joshua Suskalo You want to make something where the entities are sorted based on the :location/name of a location with a specific type."><y>#</y><d>2022-02-22</d><h>16:34</h><r>Joshua Suskalo</r>You want to make something where the entities are sorted based on the <code>:location/name</code> of a location with a specific type.</z><z id="t1645547687" t="Joshua Suskalo Give me a couple minutes, I can devise something for that."><y>#</y><d>2022-02-22</d><h>16:34</h><r>Joshua Suskalo</r>Give me a couple minutes, I can devise something for that.</z><z id="t1645547776" t="Joshua Suskalo Okay, so to start off with, there&apos;s a question I have about the data. Are the locations vectors going to include only one location for each location type?"><y>#</y><d>2022-02-22</d><h>16:36</h><r>Joshua Suskalo</r>Okay, so to start off with, there&apos;s a question I have about the data. Are the locations vectors going to include only one location for each location type?</z><z id="t1645547805" t="Joshua Suskalo And if so, is this data shaped like this because it got back this way from an API? Is there any way you could change it to a map from location types to these maps, instead of a vector?"><y>#</y><d>2022-02-22</d><h>16:36</h><r>Joshua Suskalo</r>And if so, is this data shaped like this because it got back this way from an API? Is there any way you could change it to a map from location types to these maps, instead of a vector?</z><z id="t1645547822" t="Joshua Suskalo (whether or not you can doesn&apos;t change if it&apos;s possible, only what&apos;s easier)"><y>#</y><d>2022-02-22</d><h>16:37</h><r>Joshua Suskalo</r>(whether or not you can doesn&apos;t change if it&apos;s possible, only what&apos;s easier)</z><z id="t1645547913" t="Kris C I cannot change the structure, this is the map I have to work with "><y>#</y><d>2022-02-22</d><h>16:38</h><r>Kris C</r>I cannot change the structure, this is the map I have to work with </z><z id="t1645547930" t="Joshua Suskalo is there a guarantee that there will only be one location of a given type?"><y>#</y><d>2022-02-22</d><h>16:38</h><r>Joshua Suskalo</r>is there a guarantee that there will only be one location of a given type?</z><z id="t1645548358" t="Joshua Suskalo (sort-by #(select-one [:entity/locations ALL (selected? :location/type (pred= the-type-to-select)) :location/name] %) the-data)"><y>#</y><d>2022-02-22</d><h>16:45</h><r>Joshua Suskalo</r><pre>(sort-by #(select-one [:entity/locations ALL (selected? :location/type (pred= the-type-to-select)) :location/name] %) the-data)</pre></z><z id="t1645548363" t="Joshua Suskalo This is how I would do it"><y>#</y><d>2022-02-22</d><h>16:46</h><r>Joshua Suskalo</r>This is how I would do it</z><z id="t1645576443" t="jsa-aerial I&apos;m not sure, but I think I may have stumbled across a bug in recursive paths (maybe just paths) wrt lazyseqs. Here is a small whittled down example. (def CM-NODES-2 (sp/recursive-path [] p (sp/cond-path #(and (map? %) (do (prn :MAP %) true)) [sp/ALL p] #(and (list? %) (do (prn :LIST %) true)) [sp/ALL p] #(and (vector? %) (do (prn :VECTOR1 %) true) (= (-&gt; (nth % 0) str) &quot;cm&quot;)) (sp/continue-then-stay sp/ALL p) #(and (vector? %) (do (prn :VECTOR2 %) true)) [sp/ALL p] #(and (seq? %) (do (prn :SEQ %) true) [sp/ALL p])))) (let [sq (map identity (range))] [(type sq) (seq? sq)]) =&gt; [cljs.core/LazySeq true] ;;; On JVM =&gt; [clojure.lang.LazySeq true] ;;; Same results of following on JVM or JS (cljs) (defn test-rpath-lazysq [specs] (sp/select CM-NODES-2 specs)) (test-rpath-lazysq (map identity &apos;[[one two three] [cm :a 1 :b2 :src &quot;&quot;]])) =&gt; [] (test-rpath-lazysq (vec (map identity &apos;[[one two three] [cm :a 1 :b2 :src &quot;&quot;]]))) :VECTOR1 [[one two three] [cm :a 1 :b2 :src &quot;&quot;]] :VECTOR2 [[one two three] [cm :a 1 :b2 :src &quot;&quot;]] :VECTOR1 [one two three] :VECTOR2 [one two three] :VECTOR1 [cm :a 1 :b2 :src &quot;&quot;] =&gt; [[cm :a 1 :b2 :src &quot;&quot;]]"><y>#</y><d>2022-02-23</d><h>00:34</h><w>jsa-aerial</w>I&apos;m not sure, but I think I may have stumbled across a bug in recursive paths (maybe just paths) wrt lazyseqs.  Here is a small whittled down example.

<pre>(def CM-NODES-2
  (sp/recursive-path
   [] p
   (sp/cond-path
    #(and (map? %) (do (prn :MAP %) true)) [sp/ALL p]
    #(and (list? %) (do (prn :LIST %) true)) [sp/ALL p]
    #(and (vector? %) (do (prn :VECTOR1 %) true)
          (= (-&gt; (nth % 0) str) &quot;cm&quot;)) (sp/continue-then-stay sp/ALL p)
    #(and (vector? %) (do (prn :VECTOR2 %) true)) [sp/ALL p]
    #(and (seq? %) (do (prn :SEQ %) true) [sp/ALL p]))))


(let [sq (map identity (range))]
  [(type sq) (seq? sq)])
=&gt; [cljs.core/LazySeq true]
;;; On JVM
=&gt; [clojure.lang.LazySeq true]

;;; Same results of following on JVM or JS (cljs)

(defn test-rpath-lazysq [specs]
  (sp/select
   CM-NODES-2
   specs))


(test-rpath-lazysq (map identity &apos;[[one two three] [cm :a 1 :b2 :src &quot;&quot;]]))
=&gt; []

(test-rpath-lazysq (vec (map identity &apos;[[one two three] [cm :a 1 :b2 :src &quot;&quot;]])))
:VECTOR1 [[one two three] [cm :a 1 :b2 :src &quot;&quot;]]
:VECTOR2 [[one two three] [cm :a 1 :b2 :src &quot;&quot;]]
:VECTOR1 [one two three]
:VECTOR2 [one two three]
:VECTOR1 [cm :a 1 :b2 :src &quot;&quot;]
=&gt; [[cm :a 1 :b2 :src &quot;&quot;]]</pre></z><z id="t1645576673" t="jsa-aerial Doesn&apos;t look like lazyseq is being dived into. But, could be a cockpit error on my part. Couldn&apos;t find anything specific about lazyseqs in paths though"><y>#</y><d>2022-02-23</d><h>00:37</h><w>jsa-aerial</w>Doesn&apos;t look like lazyseq is being dived into.  But, could be a cockpit error on my part.  Couldn&apos;t find anything specific about lazyseqs in paths though</z><z id="t1646185461" t="nathanmarz [:attrs {:href &quot;/_/_/users/U06C63VL4&quot;}] you just have a mismatched paren in your last condition"><y>#</y><d>2022-03-02</d><h>01:44</h><w>nathanmarz</w><a>@jsa-aerial</a> you just have a mismatched paren in your last condition</z><z id="t1646753954" t="borkdude Trying to get specter running from source with #babashka. Got something working https://github.com/babashka/babashka/issues/1203 (still some bugs to fix)"><y>#</y><d>2022-03-08</d><h>15:39</h><w>borkdude</w>Trying to get specter running from source with #babashka. Got something working <a href="https://github.com/babashka/babashka/issues/1203" target="_blank">https://github.com/babashka/babashka/issues/1203</a> (still some bugs to fix)</z><z id="t1647187229" t="borkdude OK, here we go! specter in #babashka, all specter&apos;s tests are passing! Install the latest dev preview: bash &lt;(curl ) --version 0.7.8-SNAPSHOT --dir . Then try this script: (require &apos;[babashka.deps :as deps]) (deps/add-deps &apos;{:deps {com.rpl/specter {:git/url &quot;&quot; :git/sha &quot;8ba809a2cd35d3b6f8c5287e6bd3b4e06e42f6dc&quot;}}}) (require &apos;[com.rpl.specter :as s]) (s/transform [(s/walker number?) odd?] inc {:a 1 :b [1 2 3]}) with: ./bb specter.clj and it should print: {:a 2, :b [2 2 4]} "><y>#</y><d>2022-03-13</d><h>16:00</h><w>borkdude</w>OK, here we go! specter in #babashka, all specter&apos;s tests are passing!

Install the latest dev preview:
<pre>bash &lt;(curl ) --version 0.7.8-SNAPSHOT --dir .</pre>
Then try this script:
<pre>(require &apos;[babashka.deps :as deps])

(deps/add-deps &apos;{:deps {com.rpl/specter {:git/url &quot;&quot;
                                         :git/sha &quot;8ba809a2cd35d3b6f8c5287e6bd3b4e06e42f6dc&quot;}}})

(require &apos;[com.rpl.specter :as s])

(s/transform [(s/walker number?) odd?] inc {:a 1 :b [1 2 3]})</pre>
with:
<pre>./bb specter.clj</pre>
and it should print:
<pre>{:a 2, :b [2 2 4]}</pre>
</z><z id="t1647187589" t="borkdude [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] I&apos;d love to contribute this back upstream, if you are open to this. The diff is fairly small: the JVM and CLJS code paths are unchanged, there are only a few extra :bb reader conditionals introduced. The diff: https://github.com/borkdude/specter/commit/8ba809a2cd35d3b6f8c5287e6bd3b4e06e42f6dc"><y>#</y><d>2022-03-13</d><h>16:06</h><w>borkdude</w><a>@nathanmarz</a> I&apos;d love to contribute this back upstream, if you are open to this. The diff is fairly small: the JVM and CLJS code paths are unchanged, there are only a few extra <code>:bb</code> reader conditionals introduced.

The diff: <a href="https://github.com/borkdude/specter/commit/8ba809a2cd35d3b6f8c5287e6bd3b4e06e42f6dc" target="_blank">https://github.com/borkdude/specter/commit/8ba809a2cd35d3b6f8c5287e6bd3b4e06e42f6dc</a></z><z id="t1647200166" t="borkdude The above is now available in babashka 0.7.8."><y>#</y><d>2022-03-13</d><h>19:36</h><w>borkdude</w>The above is now available in babashka 0.7.8.</z><z id="t1647220715" t="nathanmarz [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] Sure, that diff is simple enough. Please open a PR."><y>#</y><d>2022-03-14</d><h>01:18</h><w>nathanmarz</w><a>@borkdude</a> Sure, that diff is simple enough. Please open a PR.</z><z id="t1647252679" t="borkdude [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] Great! https://github.com/redplanetlabs/specter/pull/323"><y>#</y><d>2022-03-14</d><h>10:11</h><w>borkdude</w><a>@nathanmarz</a> Great! <a href="https://github.com/redplanetlabs/specter/pull/323" target="_blank">https://github.com/redplanetlabs/specter/pull/323</a></z><z id="t1647343972" t="borkdude [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] Thanks very much for the merge. Any plans on a new release 1.1.4 soon?"><y>#</y><d>2022-03-15</d><h>11:32</h><w>borkdude</w><a>@nathanmarz</a> Thanks very much for the merge. Any plans on a new release 1.1.4 soon?</z><z id="t1647625402" t="nathanmarz [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] just pushed 1.1.4 to clojars"><y>#</y><d>2022-03-18</d><h>17:43</h><w>nathanmarz</w><a>@borkdude</a> just pushed 1.1.4 to clojars</z><z id="t1647625697" t="borkdude [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] Awesome! Thanks!"><y>#</y><d>2022-03-18</d><h>17:48</h><w>borkdude</w><a>@nathanmarz</a> Awesome! Thanks!</z><z id="t1647627323" t="borkdude [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] I took the liberty to post it in the #announcements channel ;)"><y>#</y><d>2022-03-18</d><h>18:15</h><w>borkdude</w><a>@nathanmarz</a> I took the liberty to post it in the #announcements channel ;)</z><z id="t1648660280" t="fs42 Changing keys in a (nested) dict? (repost from datalog channel) When you receive data as json, and you have to transform it into nice looking entries to feed into your datalog-db, you&apos;ll have to translate those json keys as strings into clj keywords. What is the right tool to use to make those transformations the least painful? I&apos;ve been looking at (specter/setval (specter/keypath ...) but that doesn&apos;t seem to support nested key path. While (specter/setval [(specter/map-key ...) doesn&apos;t seem to support simple key substitution. Any suggestions/advise?"><y>#</y><d>2022-03-30</d><h>17:11</h><w>fs42</w>Changing keys in a (nested) dict? (repost from datalog channel)
When you receive data as json, and you have to transform it into nice looking entries to feed into your datalog-db, you&apos;ll have to translate those json keys as strings into clj keywords.
What is the right tool to use to make those transformations the least painful?
I&apos;ve been looking at (specter/setval (specter/keypath ...) but that doesn&apos;t seem to support nested key path.
While (specter/setval [(specter/map-key ...) doesn&apos;t seem to support simple key substitution.
Any suggestions/advise?</z><z id="t1648674305" t="steveb8n try walk/keywordize-keys"><y>#</y><d>2022-03-30</d><h>21:05</h><r>steveb8n</r>try walk/keywordize-keys</z><z id="t1648751242" t="fs42 Thanks for the suggestion - will do."><y>#</y><d>2022-03-31</d><h>18:27</h><r>fs42</r>Thanks for the suggestion - will do.</z><z id="t1649158274" t="jose I&apos;m a bit confused by the if-path cond-path semantics, looks like navigates to the path if the condition is not false (and considers nil a truthy value) is that correct? An example: (s/select (s/if-path [:a] :a s/STAY) {:b 2}) ;; =&gt; [nil] (s/select (s/if-path (comp boolean :a) :a s/STAY) {:b 2}) ;; =&gt; [{:b 2}] "><y>#</y><d>2022-04-05</d><h>11:31</h><w>jose</w>I&apos;m a bit confused by the <code>if-path</code> <code>cond-path</code> semantics, looks like navigates to the path if the condition is not false (and considers nil a truthy value) is that correct? An example:
<pre>(s/select (s/if-path [:a]
            :a
            s/STAY)
          {:b 2})
;; =&gt; [nil]

(s/select (s/if-path (comp boolean :a)
            :a
            s/STAY)
          {:b 2})
;; =&gt; [{:b 2}]</pre>
</z><z id="t1649181308" t="nathanmarz [:attrs {:href &quot;/_/_/users/U4NGX0FHN&quot;}] conditions in specter paths are based on whether the path navigates to anything or not"><y>#</y><d>2022-04-05</d><h>17:55</h><w>nathanmarz</w><a>@jlle</a> conditions in specter paths are based on whether the path navigates to anything or not</z><z id="t1649181316" t="nathanmarz has nothing to do with the navigated values themselves"><y>#</y><d>2022-04-05</d><h>17:55</h><w>nathanmarz</w>has nothing to do with the navigated values themselves</z><z id="t1649181335" t="nathanmarz STOP is &quot;false&quot; for paths"><y>#</y><d>2022-04-05</d><h>17:55</h><w>nathanmarz</w>STOP is &quot;false&quot; for paths</z><z id="t1649181356" t="nathanmarz keypath always navigates, so it&apos;s always considered &quot;true&quot;"><y>#</y><d>2022-04-05</d><h>17:55</h><w>nathanmarz</w>keypath always navigates, so it&apos;s always considered &quot;true&quot;</z><z id="t1649393611" t="onetom would it be possible to do the following sequence of multi-transform &amp; select-one in one step? that would allow me to package up this transform/select operation as a path (instead of a function), so it can be combined with further processing. (-&gt;&gt; {:cols [10 20 30] :rows [[1 2 3] [4 5 6]]} (sp/multi-transform [(collect-one :cols) :rows ALL (terminal (partial mapv +))]) (sp/select-one :rows)) =&gt; [[11 22 33] [14 25 36]] equivalent clojure code: (-&gt;&gt; {:cols [10 20 30] :rows [[1 2 3] [4 5 6]]} ((fn [{:keys [cols rows]}] (mapv (fn [cells] (mapv + cells cols)) rows)))) =&gt; [[11 22 33] [14 25 36]]"><y>#</y><d>2022-04-08</d><h>04:53</h><w>onetom</w>would it be possible to do the following sequence of <code>multi-transform</code> &amp; <code>select-one</code> in one step?
that would allow me to package up this transform/select operation as a path (instead of a function), so it can be combined with further processing.
<pre>(-&gt;&gt; {:cols [10 20 30]
        :rows [[1 2 3]
               [4 5 6]]}
       (sp/multi-transform
         [(collect-one :cols)
          :rows ALL (terminal (partial mapv +))])
       (sp/select-one :rows))
=&gt; [[11 22 33] [14 25 36]]</pre>
equivalent clojure code:
<pre>(-&gt;&gt; {:cols [10 20 30]
        :rows [[1 2 3]
               [4 5 6]]}
       ((fn [{:keys [cols rows]}]
          (mapv
            (fn [cells]
              (mapv + cells cols))
            rows))))
=&gt; [[11 22 33] [14 25 36]]</pre></z><z id="t1649394278" t="onetom in more abstract terms, i want to 1. select from the input structure 2. transform the selected part 3. combine the transformed part with another selected and transformed part of the original structure i can of course do all this in a regular clojure function, which i can compose with further select/transform operations via view , but do i have to?"><y>#</y><d>2022-04-08</d><h>05:04</h><r>onetom</r>in more abstract terms, i want to
1. select from the input structure
2. transform the selected part
3. combine the transformed part with another selected and transformed part of the original structure
i can of course do all this in a regular clojure function, which i can compose with further select/transform operations via <code>view</code>, but do i have to?</z><z id="t1649395016" t="onetom i have the feeling, that im missing some navigator, so i can do this kind of multi collection map operation. both view and transformed doesn&apos;t receive the collected values. terminal / vterminal does receive collected values, but also the currently navigated value too, so i have to wrap clojure.core functions to ignore that last argument. collected? receives all collected values, both individually or as a single vector, but it&apos;s return value is not used to replace the value, we are currently navigated to."><y>#</y><d>2022-04-08</d><h>05:16</h><r>onetom</r>i have the feeling, that im missing some navigator, so i can do this kind of multi collection <code>map</code> operation.

both <code>view</code> and <code>transformed</code> doesn&apos;t receive the collected values.

<code>terminal</code> / <code>vterminal</code> does receive collected values, but also the currently navigated value too, so i have to wrap <code>clojure.core</code> functions to ignore that last argument.

<code>collected?</code> receives all collected values, both individually or as a single vector, but it&apos;s return value is not used to replace the value, we are currently navigated to.</z><z id="t1649395079" t="onetom i think i wish for something like transformed-with-collected , so i can do the following: (-&gt;&gt; {:cols [10 20 30] :rows [[1 2 3] [4 5 6]]} (sp/select-one [(collect-one :cols) :rows (transformed-with-collected ALL (partial mapv +)) DISPENSE]))"><y>#</y><d>2022-04-08</d><h>05:17</h><r>onetom</r>i think i wish for something like <code>transformed-with-collected</code>, so i can do the following:
<pre>(-&gt;&gt; {:cols [10 20 30]
        :rows [[1 2 3]
               [4 5 6]]}
       (sp/select-one
         [(collect-one :cols)
          :rows 
          (transformed-with-collected ALL (partial mapv +))
          DISPENSE]))</pre></z><z id="t1650055043" t="r hey folks, a question. i have a set of paths that contain predicates, and a structure that i would like to transform to only contain those paths. it’s kind of the inverse of setval - i’d like to prune parts of the data that don’t match some navigators"><y>#</y><d>2022-04-15</d><h>20:37</h><w>r</w>hey folks, a question. i have a set of paths that contain predicates, and a structure that i would like to transform to only contain those paths. it’s kind of the inverse of <code>setval</code> - i’d like to prune parts of the data that don’t match some navigators</z><z id="t1650055073" t="r thoughts on how i might achieve this with specter?"><y>#</y><d>2022-04-15</d><h>20:37</h><r>r</r>thoughts on how i might achieve this with specter?</z><z id="t1650246937" t="nathanmarz [:attrs {:href &quot;/_/_/users/U013GG71CHL&quot;}] you&apos;re looking to use setval and NONE to remove values with a path that targets everything but the values you want to remain"><y>#</y><d>2022-04-18</d><h>01:55</h><w>nathanmarz</w><a>@robhanlon</a> you&apos;re looking to use <code>setval</code> and <code>NONE</code> to remove values with a path that targets everything but the values you want to remain</z><z id="t1650246942" t="nathanmarz compact may be relevant as well"><y>#</y><d>2022-04-18</d><h>01:55</h><w>nathanmarz</w><code>compact</code> may be relevant as well</z><z id="t1651779124" t="richiardiandrea Hi there, long time no see! Is there a way to navigate to non-existing keys (call it nilable-columns-names ) and set their value to nil if not yet populated?"><y>#</y><d>2022-05-05</d><h>19:32</h><w>richiardiandrea</w>Hi there, long time no see! Is there a way to navigate to non-existing keys (call it <code>nilable-columns-names</code>) and set their value to <code>nil</code>  if not yet populated?</z><z id="t1651780475" t="richiardiandrea Oh nvm, I ran into this https://github.com/redplanetlabs/specter/issues/221 And I am probably going to use reduce for that one"><y>#</y><d>2022-05-05</d><h>19:54</h><r>richiardiandrea</r>Oh nvm, I ran into this

<a href="https://github.com/redplanetlabs/specter/issues/221" target="_blank">https://github.com/redplanetlabs/specter/issues/221</a>

And I am probably going to use reduce for that one</z><z id="t1651790664" t="nathanmarz [:attrs {:href &quot;/_/_/users/U0C8489U6&quot;}] (transform (multi-path :a :b :c) identity data) will do that"><y>#</y><d>2022-05-05</d><h>22:44</h><w>nathanmarz</w><a>@richiardiandrea</a> <code>(transform (multi-path :a :b :c) identity data)</code> will do that</z><z id="t1652276892" t="pinkfrog Hi. I wonder if there is some update-in variant (in specter) that could well handle the case that when m is an empty map (see the following code snippet). ;; `m` is in the shape: {:a [ {:x [ 1,2,3 ,,,]} ;; {:x [ 5,6,7 ,,,]} ;; ,,, } ;; the key `:a` and `:x` are fixed. ;; i normally append number to certain [n1,n2,n3,,,] number list. ;; For example, append 6 to the 1st [numbers] list. (let [m {:a [{:x [1 2 3]} {:x [4 5]}]}] (update-in m [:a 1 :x] (fnil conj []) 6)) ;; The question is: ;; what if `m` is initially `{}`, or `{:a []}` ? ;; (update-in m [:a 0 :x] (fnil conj []) 6)) does not give the result: `{:a [{:x [6]}]} `"><y>#</y><d>2022-05-11</d><h>13:48</h><w>pinkfrog</w>Hi. I wonder if there is some <code>update-in</code> variant (in specter) that could well handle the case that when <code>m</code> is an empty map (see the following code snippet).
<pre>;; `m` is in the shape: {:a [ {:x [ 1,2,3 ,,,]} 
  ;;                            {:x [ 5,6,7 ,,,]}
  ;;                            ,,, }

  ;; the key `:a` and `:x` are fixed.  
  
  ;; i normally append number to certain [n1,n2,n3,,,] number list.
  ;; For example, append 6 to the 1st [numbers] list.
  (let [m {:a [{:x [1 2 3]}
               {:x [4 5]}]}]
    (update-in m [:a 1 :x] (fnil conj []) 6))

  ;; The question is:
  ;; what if `m` is initially `{}`, or `{:a []}` ? 
  ;; (update-in m [:a 0 :x] (fnil conj []) 6)) does not give the result: `{:a [{:x [6]}]}</pre>`</z><z id="t1652313922" t="chromalchemy Here is a version (multi-transform (multi-path [map? empty? :a (putval {}) :x NIL-&gt;VECTOR AFTER-ELEM (terminal-val 6)] [(must :a) vector? empty? BEFORE-ELEM (terminal-val {:x [6]})] [(must :a) vector? some? (nthpath 1) map? :x AFTER-ELEM (terminal-val 6)]) m) Of course you could set more complex data with terminal-val (like setval ), or swap out some of the navigation for clojure functions used with terminal (local transform function). And you could probably do it also with a normal cond + predicates, and a more simple navigation."><y>#</y><d>2022-05-12</d><h>00:05</h><w>chromalchemy</w>Here is a version
<pre>(multi-transform
  (multi-path
    [map? empty? :a (putval {}) :x NIL-&gt;VECTOR AFTER-ELEM (terminal-val 6)]
    [(must :a) vector? empty? BEFORE-ELEM (terminal-val {:x [6]})]
    [(must :a) vector? some? (nthpath 1) map? :x AFTER-ELEM  (terminal-val 6)])
  m)</pre>
Of course you could set more complex data with <code>terminal-val</code> (like <code>setval</code>), or swap out some of the navigation for clojure functions used with <code>terminal</code> (local transform function).
And you could probably do it also with a normal <code>cond</code> + predicates, and a more simple navigation.</z><z id="t1652437172" t="Benjamin some wip code of what I try to do: (def input {:ordering [:gem_value] :coll-meta {:eth_addr {:transform str} }}) (specter/transform [specter/ALL specter/ALL (specter/selected? (specter/view first) (:coll-meta input))] (fn [[k v]] [k ((-&gt; input :coll-meta k :transform) v)]) [{:eth_addr 10 :fo &quot;fo&quot; :bar 9}]) ;; [{:eth_addr &quot;10&quot;, :fo &quot;fo&quot;, :bar 9}] I like the user to define some transform function on keys. Maybe I&apos;m thinking to complicated?"><y>#</y><d>2022-05-13</d><h>10:19</h><w>Benjamin</w>some wip code of what I try to do:

<pre>(def
    input
    {:ordering [:gem_value]
     :coll-meta
     {:eth_addr
      {:transform str}
      }})

  (specter/transform
   [specter/ALL
    specter/ALL
    (specter/selected?
     (specter/view first)
     (:coll-meta input))]
   (fn [[k v]]
     [k ((-&gt; input :coll-meta k :transform) v)])
   [{:eth_addr 10 :fo &quot;fo&quot; :bar 9}])

  ;; [{:eth_addr &quot;10&quot;, :fo &quot;fo&quot;, :bar 9}]</pre>
I like the user to define some transform function on keys. Maybe I&apos;m thinking to complicated?</z><z id="t1652626123" t="chromalchemy Yeah, I usually find it more readable/composable to use a transform function in some kind of local context. In my example, I was trying to see how far I could get to set a single value via path syntax. I couldn’t quite get it on the middle condition."><y>#</y><d>2022-05-15</d><h>14:48</h><w>chromalchemy</w>Yeah, I usually find it more readable/composable to use a transform function in some kind of local context.  In my example, I was trying to see how far I could get to set a single value via path syntax. I couldn’t quite get it on the middle condition.</z><z id="t1652778468" t="kingmob OK, I’m trying Specter out, and I can’t figure out how to make this transform happen. I’ve got a two-level map containing some vecs of numbers, and I want to replace the middle level with the set intersection of the vecs. How do I make: (def example {&quot;top1&quot; {&quot;mid1&quot; [1 2 3] &quot;mid2&quot; [2 3 4] &quot;mid3&quot; [3 4 5]} &quot;top2&quot; {&quot;mid4&quot; [1 2 3] &quot;mid5&quot; [2 3 4] &quot;mid6&quot; [3 4 5]}}) turn into something like: {&quot;top1&quot; #{3} &quot;top2&quot; #{3}} ?"><y>#</y><d>2022-05-17</d><h>09:07</h><w>kingmob</w>OK, I’m trying Specter out, and I can’t figure out how to make this transform happen. I’ve got a two-level map containing some vecs of numbers, and I want to replace the middle level with the set intersection of the vecs.

How do I make:
<pre>(def example {&quot;top1&quot; {&quot;mid1&quot; [1 2 3]
                      &quot;mid2&quot; [2 3 4]
                      &quot;mid3&quot; [3 4 5]}
              &quot;top2&quot; {&quot;mid4&quot; [1 2 3]
                      &quot;mid5&quot; [2 3 4]
                      &quot;mid6&quot; [3 4 5]}})</pre>
turn into something like:
<pre>{&quot;top1&quot; #{3}
 &quot;top2&quot; #{3}}</pre>
?</z><z id="t1652778719" t="kingmob And how would I filter out some of the “mid*” keys if necessary?"><y>#</y><d>2022-05-17</d><h>09:11</h><w>kingmob</w>And how would I filter out some of the “mid*” keys if necessary?</z><z id="t1652780598" t="kingmob Closest I’ve come so far is something like: (transform [MAP-VALS] (fn [m] (-&gt;&gt; m (select MAP-VALS) (reduce (fn rf [s v] (set/intersection (set s) (set v)))))) example) but it takes two stages and feels un-Specter-y"><y>#</y><d>2022-05-17</d><h>09:43</h><w>kingmob</w>Closest I’ve come so far is something like:
<pre>(transform [MAP-VALS]
           (fn [m]
             (-&gt;&gt; m
                  (select MAP-VALS)
                  (reduce (fn rf [s v]
                            (set/intersection (set s) (set v))))))
           example)</pre>
but it takes two stages and feels un-Specter-y</z><z id="t1657766614" t="Lucy Wang my 2c: (defn shrink-inner-map [m] (-&gt;&gt; m (sp/select [sp/MAP-VALS (sp/view set)]) (apply clojure.set/intersection) )) (sp/transform [sp/MAP-VALS] shrink-inner-map example)"><y>#</y><d>2022-07-14</d><h>02:43</h><r>Lucy Wang</r>my 2c:
<pre>(defn shrink-inner-map [m]
    (-&gt;&gt; m
         (sp/select [sp/MAP-VALS (sp/view set)])
         (apply clojure.set/intersection)
         ))

  (sp/transform [sp/MAP-VALS] shrink-inner-map example)</pre></z><z id="t1652812726" t="isak (transform [MAP-VALS (collect MAP-VALS (view set))] (fn [sets _] (apply set/intersection sets)) example) [:attrs {:href &quot;/_/_/users/U10EC98F5&quot;}] ^ A little more spectery, I think, but maybe someone can do better."><y>#</y><d>2022-05-17</d><h>18:38</h><w>isak</w><pre>(transform
  [MAP-VALS (collect MAP-VALS (view set))]
  (fn [sets _] (apply set/intersection sets))
  example)</pre>
<a>@kingmob</a> ^ A little more spectery, I think, but maybe someone can do better.</z><z id="t1652843731" t="kingmob Thanks [:attrs {:href &quot;/_/_/users/U08JKUHA9&quot;}] . I feel like I need some mid-level documentation, something in-between a high-level overview, a list of examples, and the API reference. I haven&apos;t seen anything that explains collecting well to me. "><y>#</y><d>2022-05-18</d><h>03:15</h><w>kingmob</w>Thanks <a>@isak</a>. I feel like I need some mid-level documentation, something in-between a high-level overview, a list of examples, and the API reference. I haven&apos;t seen anything that explains collecting well to me. </z><z id="t1652892370" t="isak Yea I didn&apos;t see anything either. I had to experiment a little to understand it, and I think I&apos;m starting to now. This example may help a little: (def root {:level-1-foo {:level-2-bar {:data &quot;a&quot;} :level-2-baz {:data &quot;b&quot;}} :level-1-bar {:level-2-bar {:data &quot;c&quot;} :level-2-baz {:data &quot;d&quot;} :level-2-foo {:data &quot;e&quot;}} :level-1-baz {:level-2-bar {:data &quot;c&quot;} :level-2-baz {:data &quot;d&quot;}}}) (x/transform [(x/collect-one (x/view count)) ; root-count x/MAP-VALS (x/collect (x/view count)) ; level-1-entry-count x/MAP-VALS] (fn [root-count level-1-entry-count leaf] (assoc leaf :root-count root-count :level-1-entry-count level-1-entry-count)) root) ; =&gt; {:level-1-foo {:level-2-bar {:data &quot;a&quot;, :root-count 3, :level-1-entry-count [2]}, :level-2-baz {:data &quot;b&quot;, :root-count 3, :level-1-entry-count [2]}}, :level-1-bar {:level-2-bar {:data &quot;c&quot;, :root-count 3, :level-1-entry-count [3]}, :level-2-baz {:data &quot;d&quot;, :root-count 3, :level-1-entry-count [3]}, :level-2-foo {:data &quot;e&quot;, :root-count 3, :level-1-entry-count [3]}}, :level-1-baz {:level-2-bar {:data &quot;c&quot;, :root-count 3, :level-1-entry-count [2]}, :level-2-baz {:data &quot;d&quot;, :root-count 3, :level-1-entry-count [2]}}}"><y>#</y><d>2022-05-18</d><h>16:46</h><r>isak</r>Yea I didn&apos;t see anything either. I had to experiment a little to understand it, and I think I&apos;m starting to now. This example may help a little:

<pre>(def root
  {:level-1-foo {:level-2-bar {:data &quot;a&quot;}
                 :level-2-baz {:data &quot;b&quot;}}
   :level-1-bar {:level-2-bar {:data &quot;c&quot;}
                 :level-2-baz {:data &quot;d&quot;}
                 :level-2-foo {:data &quot;e&quot;}}
   :level-1-baz {:level-2-bar {:data &quot;c&quot;}
                 :level-2-baz {:data &quot;d&quot;}}})

(x/transform
  [(x/collect-one (x/view count)) ; root-count
   x/MAP-VALS
   (x/collect (x/view count))     ; level-1-entry-count
   x/MAP-VALS]
  (fn [root-count level-1-entry-count leaf]
    (assoc leaf 
      :root-count root-count
      :level-1-entry-count level-1-entry-count))
  root)

; =&gt;

{:level-1-foo {:level-2-bar {:data &quot;a&quot;, :root-count 3, :level-1-entry-count [2]},
               :level-2-baz {:data &quot;b&quot;, :root-count 3, :level-1-entry-count [2]}},
 :level-1-bar {:level-2-bar {:data &quot;c&quot;, :root-count 3, :level-1-entry-count [3]},
               :level-2-baz {:data &quot;d&quot;, :root-count 3, :level-1-entry-count [3]},
               :level-2-foo {:data &quot;e&quot;, :root-count 3, :level-1-entry-count [3]}},
 :level-1-baz {:level-2-bar {:data &quot;c&quot;, :root-count 3, :level-1-entry-count [2]},
               :level-2-baz {:data &quot;d&quot;, :root-count 3, :level-1-entry-count [2]}}}</pre></z><z id="t1652892541" t="isak So it looks like it is for when you want to transform nested nodes, and you want to carry context deeper in the tree. Each collect you do will increase the arity of the transform function, and the arguments are prepended left to right."><y>#</y><d>2022-05-18</d><h>16:49</h><r>isak</r>So it looks like it is for when you want to transform nested nodes, and you want to carry context deeper in the tree. Each <code>collect</code> you do will increase the arity of the transform function, and the arguments are prepended left to right.</z><z id="t1652934524" t="kingmob So collects take place at the position of the path so far. &gt; Each collect you do will increase the arity of the transform function, and the arguments are prepended left to right. It would be cool if they could be named, and then passed in as a map"><y>#</y><d>2022-05-19</d><h>04:28</h><r>kingmob</r>So collects take place at the position of the path so far.
&gt; Each <code>collect</code> you do will increase the arity of the transform function, and the arguments are prepended left to right.
It would be cool if they could be named, and then passed in as a map</z><z id="t1652935669" t="kingmob When would you use transformed over view ? Transformed takes a path relative to your current position, but wouldn’t it be easier to navigate normally and use view ?"><y>#</y><d>2022-05-19</d><h>04:47</h><w>kingmob</w>When would you use <code>transformed</code> over <code>view</code>? Transformed takes a path relative to your current position, but wouldn’t it be easier to navigate normally and use <code>view</code>?</z><z id="t1652937342" t="kingmob Does specter maintain sorted status? I.e., if I transform a sorted-map, should I get a sorted map back, or is that not part of the contract?"><y>#</y><d>2022-05-19</d><h>05:15</h><w>kingmob</w>Does specter maintain sorted status? I.e., if I <code>transform</code> a sorted-map, should I get a sorted map back, or is that not part of the contract?</z><z id="t1652938959" t="kingmob OK, maybe this is a dumb one, but how on earth do I filter a map based on the values, but retrieve the associated keys? E.g., I called frequencies , and want to filter out all keys whose val is 1. Is there a way to do this without using collect?"><y>#</y><d>2022-05-19</d><h>05:42</h><w>kingmob</w>OK, maybe this is a dumb one, but how on earth do I filter a map based on the values, but retrieve the associated keys? E.g., I called <code>frequencies</code>, and want to filter out all keys whose val is 1. Is there a way to do this without using collect?</z><z id="t1652939165" t="kingmob I tried (select [(view frequencies) ALL (pred #(&gt; (second %) 1))] my-data) but if I add MAP-KEYS to the path to get what I want, I get a blank ClassCastException with no message or trace. Addendum: I get a surprising number of super-unhelpful blank NPEs and ClassCastExceptions. Any message is better than none."><y>#</y><d>2022-05-19</d><h>05:46</h><w>kingmob</w>I tried
<pre>(select [(view frequencies) ALL (pred #(&gt; (second %) 1))]
        my-data)</pre>
but if I add MAP-KEYS to the path to get what I want, I get a blank ClassCastException with no message or trace.

Addendum: I get a surprising number of super-unhelpful blank NPEs and ClassCastExceptions. Any message is better than none.</z><z id="t1652940540" t="phronmophobic you should be able to just add (nthpath 0) to the end of your path"><y>#</y><d>2022-05-19</d><h>06:09</h><r>phronmophobic</r>you should be able to just add <code>(nthpath 0)</code> to the end of your path</z><z id="t1652940569" t="phronmophobic &gt; (specter/select [(specter/view frequencies) specter/ALL (specter/pred #(&gt; (second %) 1)) (specter/nthpath 0)] &quot;akdsfhaiohflaiseflakejhlkajsefhs9&quot;) [\a \e \f \h \i \j \k \l \s]"><y>#</y><d>2022-05-19</d><h>06:09</h><r>phronmophobic</r><pre>&gt; (specter/select [(specter/view frequencies) specter/ALL (specter/pred #(&gt; (second %) 1)) (specter/nthpath 0)]
                                                 &quot;akdsfhaiohflaiseflakejhlkajsefhs9&quot;)
[\a \e \f \h \i \j \k \l \s]</pre></z><z id="t1652940841" t="kingmob Thanks, that worked… but why does pred lose the MapEntry-ness of the elements? Why shouldn’t MAP-KEYS work there?"><y>#</y><d>2022-05-19</d><h>06:14</h><r>kingmob</r>Thanks, that worked… but why does pred lose the MapEntry-ness of the elements? Why shouldn’t MAP-KEYS work there?</z><z id="t1652941071" t="phronmophobic I don&apos;t think it does. I think MAP-KEYS expects a map"><y>#</y><d>2022-05-19</d><h>06:17</h><r>phronmophobic</r>I don&apos;t think it does. I think MAP-KEYS expects a map</z><z id="t1652941083" t="phronmophobic &gt; (type(first(specter/select [(specter/view frequencies) specter/ALL (specter/pred #(&gt; (second %) 1)) ] &quot;akdsfhaiohflaiseflakejhlkajsefhs9&quot;))) clojure.lang.MapEntry"><y>#</y><d>2022-05-19</d><h>06:18</h><r>phronmophobic</r><pre>&gt; (type(first(specter/select [(specter/view frequencies) specter/ALL (specter/pred #(&gt; (second %) 1)) ]
                                                        &quot;akdsfhaiohflaiseflakejhlkajsefhs9&quot;)))
clojure.lang.MapEntry</pre></z><z id="t1652941795" t="kingmob So ALL transforms it into MapEntries…but the doc for MAP-VALS say it’s faster than [ALL FIRST], which really makes it sound like it’s equivalent to it. I think I get it in this case, since we turn them into MapEntries and then use the pred on the MapEntry, which Clojure prtends is a 2-elt vec… How would I filter a map’s values but keep the navigator at the map level?"><y>#</y><d>2022-05-19</d><h>06:29</h><r>kingmob</r>So ALL transforms it into MapEntries…but the doc for MAP-VALS say it’s faster than [ALL FIRST], which really makes it sound like it’s equivalent to it. I think I get it in this case, since we turn them into MapEntries and then use the pred on the MapEntry, which Clojure prtends is a 2-elt vec…

How would I filter a map’s values but keep the navigator at the map level?</z><z id="t1654691501" t="rolt it&apos;s more like: you can view a map entry as a 2 element vec,. you can (and you should) use [MAP-VALS] instead of [ALL SECOND] (if it says FIRST in the doc it&apos;s a mistake, it would be equivalent to MAP-KEYS). To filter a map&apos;s value while staying at the map level you can use transformed or view: (sp/select [(sp/transformed [sp/MAP-VALS (sp/pred (complement your-pred)] (constantly sp/NONE))] data) (sp/select [(sp/view #(into {} (filter (comp your-pred val)) %))] data)"><y>#</y><d>2022-06-08</d><h>12:31</h><r>rolt</r>it&apos;s more like: you can view a map entry as a 2 element vec,. you can (and you should) use [MAP-VALS] instead of [ALL SECOND] (if it says FIRST in the doc it&apos;s a mistake, it would be equivalent to MAP-KEYS). To filter a map&apos;s value while staying at the map level you can use transformed or view:
<code>(sp/select [(sp/transformed [sp/MAP-VALS (sp/pred (complement your-pred)] (constantly sp/NONE))] data)</code>
<code>(sp/select [(sp/view #(into {} (filter (comp your-pred val)) %))] data)</code></z><z id="t1654755628" t="kingmob [:attrs {:href &quot;/_/_/users/U02F0C62TC1&quot;}] Thanks for responding. I appreciate it. But I think I’m going to pass on Specter. There’s some really cool core usefulness there, but I find it hard to debug (the NPEs really don’t help, those should be fixed), or figure out which navigators I need to solve a problem sometimes."><y>#</y><d>2022-06-09</d><h>06:20</h><r>kingmob</r><a>@U02F0C62TC1</a> Thanks for responding. I appreciate it. But I think I’m going to pass on Specter. There’s some really cool core usefulness there, but I find it hard to debug (the NPEs really don’t help, those should be fixed), or figure out which navigators I need to solve a problem sometimes.</z><z id="t1655309473" t="JaimeV I have a OpenAPI JSON file that I am trying to process. The resulting structure is not very clear to me, it looks like a nested collections and maps with no uniformity. Fortunately every node that I am interested has unique identifier. Is there a way to do a deep-search and extract the object at its place. I have tried [MAP-VALS ALL MAP-VALS key-pred] but it fails because the structure is not uniform. I trying to avoid the need to write specific navigators because I am sure I will miss a particular path."><y>#</y><d>2022-06-15</d><h>16:11</h><w>JaimeV</w>I have a OpenAPI JSON file that I am trying to process. The resulting structure is not very clear to me, it looks like a nested collections and maps with no uniformity. Fortunately every node that I am interested has unique identifier. Is there a way to do a deep-search and extract the  object at its place. I have tried [MAP-VALS ALL MAP-VALS key-pred] but it fails because the structure is not uniform. I trying to avoid the need to write specific navigators because I am sure I will miss a particular path.</z><z id="t1655396797" t="rolt if there are different levels of nesting, you can have a look at https://github.com/redplanetlabs/specter/wiki/Using-Specter-Recursively"><y>#</y><d>2022-06-16</d><h>16:26</h><r>rolt</r>if there are different levels of nesting, you can have a look at <a href="https://github.com/redplanetlabs/specter/wiki/Using-Specter-Recursively" target="_blank">https://github.com/redplanetlabs/specter/wiki/Using-Specter-Recursively</a></z><z id="t1655397062" t="rolt disclaimer: i barely ever used specter with recursion, I&apos;d probably use clojure.walk or clojure.zip for this kind of things"><y>#</y><d>2022-06-16</d><h>16:31</h><r>rolt</r>disclaimer: i barely ever used specter with recursion, I&apos;d probably use clojure.walk or clojure.zip for this kind of things</z><z id="t1657765256" t="Lucy Wang you need the walker navigator https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#walker"><y>#</y><d>2022-07-14</d><h>02:20</h><r>Lucy Wang</r>you need the <code>walker</code> navigator <a href="https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#walker" target="_blank">https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#walker</a></z><z id="t1655313377" t="JaimeV Is there a better way to write this: (defn get-element [id model] (let [id-match? #(= (:id %) id)] (or (select-one [:model :people ALL id-match?] model) (select-one [:model :softwareSystems ALL id-match?] model) (select-one [:model :softwareSystems ALL :containers ALL id-match?] model) (select-one [:model :softwareSystems ALL :containers ALL :components ALL id-match?] model))))"><y>#</y><d>2022-06-15</d><h>17:16</h><w>JaimeV</w>Is there a better way to write this:
<pre>(defn get-element [id model]
  (let [id-match? #(= (:id %) id)]
    (or (select-one [:model :people ALL id-match?] model)
        (select-one [:model :softwareSystems ALL id-match?] model)
        (select-one [:model :softwareSystems ALL :containers ALL id-match?] model)
        (select-one [:model :softwareSystems ALL :containers ALL :components ALL id-match?] model))))</pre></z><z id="t1655396861" t="rolt a single select-one with https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#multi-path maybe ?"><y>#</y><d>2022-06-16</d><h>16:27</h><r>rolt</r>a single <code>select-one</code> with <a href="https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#multi-path" target="_blank">https://github.com/redplanetlabs/specter/wiki/List-of-Navigators#multi-path</a> maybe ?</z><z id="t1655397761" t="rolt (select-first [:model (multi-path [:people ALL] [:softwareSystems ALL (multi-path [] [:containers ALL (multi-path [] [:components ALL])])]) #(= (:id %) id)])"><y>#</y><d>2022-06-16</d><h>16:42</h><r>rolt</r><code>(select-first [:model (multi-path [:people ALL] [:softwareSystems ALL (multi-path [] [:containers ALL (multi-path [] [:components ALL])])]) #(= (:id %) id)])</code></z><z id="t1655411425" t="borkdude #jet v0.2.18 now supports specter: $ echo &apos;{:a {:a 1}}&apos; | jet -t &apos;(s/transform [s/MAP-VALS s/MAP-VALS] inc)&apos; {:a {:a 2}}"><y>#</y><d>2022-06-16</d><h>20:30</h><w>borkdude</w>#jet v0.2.18 now supports specter:
<pre>$ echo &apos;{:a {:a 1}}&apos; | jet -t &apos;(s/transform [s/MAP-VALS s/MAP-VALS] inc)&apos;
{:a {:a 2}}</pre></z><z id="t1655442974" t="pdmct Hi, I am new to spectre and trying to use it to transform some ugly nested xml to a nicer edn format. I am stuck non trying to select values for keys that are in a map with a specific val (of a different key) [{:piTypes ({:piType &quot;10&quot;, ::name &quot;PI_TYPE_1&quot;}, {:piType &quot;20&quot;, :name &quot;PI_TYPE_2&quot;})] :piTypesCount ({:piTypeCount &quot;1&quot;, :name &quot;PI_TYPE_1&quot;} {:piTypeCount &quot;1&quot;, :name &quot;PI_TYPE_2&quot;})}] My question is: Is it possible with spectre to select piType value (ie. “10”) where :name == “PI_TYPE_1&quot; in the above example? or all maps with a given value? eg all maps containing k/v {:name “PI_TYPE_1”}?"><y>#</y><d>2022-06-17</d><h>05:16</h><w>pdmct</w>Hi, I am new to spectre and trying to use it to transform some ugly nested xml to a nicer edn format. I am stuck non trying to <code>select</code> values for keys that are in a map with a specific val (of a different key)
<pre>[{:piTypes
  ({:piType &quot;10&quot;,
    ::name &quot;PI_TYPE_1&quot;},
    {:piType &quot;20&quot;,
    :name &quot;PI_TYPE_2&quot;})]
  :piTypesCount
  ({:piTypeCount &quot;1&quot;,
    :name &quot;PI_TYPE_1&quot;}
   {:piTypeCount &quot;1&quot;,
    :name &quot;PI_TYPE_2&quot;})}]</pre>
My question is: Is it possible with spectre to select piType value (ie. “10”) where  :name == “PI_TYPE_1&quot; in the above example?
or all maps with a given value? eg all maps containing k/v  {:name “PI_TYPE_1”}?</z><z id="t1655446249" t="pdmct ok, working through this I have come up with (if the above structure is called ‘groups’: (defn select-maps [xrel m] ((clojure.set/index xrel (keys m)) m)) (select [ALL :piTypes ALL (pred #(select-maps (vector %) {:name &quot;PI_TYPE_1&quot;})) :piType] groups) =&gt; [&quot;10&quot;] is there a better way than this?"><y>#</y><d>2022-06-17</d><h>06:10</h><w>pdmct</w>ok, working through this I have come up with (if the above structure is called ‘groups’:
<pre>(defn select-maps [xrel m]
  ((clojure.set/index xrel (keys m)) m))

(select [ALL :piTypes ALL (pred #(select-maps (vector %) {:name &quot;PI_TYPE_1&quot;})) :piType] groups) =&gt; [&quot;10&quot;]</pre>
is there a better way than this?</z><z id="t1655452817" t="rolt [ALL :piTypes ALL (pred #(= &quot;PI_TYPE_1&quot; (:name %))) :piType]"><y>#</y><d>2022-06-17</d><h>08:00</h><r>rolt</r><code>[ALL :piTypes ALL (pred #(= &quot;PI_TYPE_1&quot; (:name %))) :piType]</code></z><z id="t1655452967" t="pdmct Thanks, yes that&apos;s an overly complex pred for what it is doing"><y>#</y><d>2022-06-17</d><h>08:02</h><r>pdmct</r>Thanks, yes that&apos;s an overly complex pred for what it is doing</z><z id="t1655451523" t="pdmct on a slightly related note. Suppose that I have 2 variations of a structure: (def one-child [{:a {:b {:c 2}}}]) (def two-children [{:a {:b [{:c 3}{:d 4}]}}]) (select [ALL :a :b (pred #(contains? % :c)) :c] one-child) =&gt; [2] (select [ALL :a :b ALL (pred #(contains? % :c)) :c] two-children) =&gt; [3] I want to select :c from both variations of these — when there are multiple children in a list I need to add the ALL navigator — what is the best way to determine whether the result at that point is a list or a map in this case and add the ALL into the selector? Is there a built-in method for dealing with this?"><y>#</y><d>2022-06-17</d><h>07:38</h><w>pdmct</w>on a slightly related note. Suppose that I have 2 variations of a structure:
<pre>(def one-child [{:a {:b {:c 2}}}])
(def two-children [{:a {:b [{:c 3}{:d 4}]}}])

(select [ALL :a :b (pred #(contains? % :c)) :c] one-child)
=&gt; [2]
(select [ALL :a :b ALL (pred #(contains? % :c)) :c] two-children)
=&gt; [3]</pre>
I want to select :c from both variations of these — when there are multiple children in a list I need to add the ALL navigator — what is the best way to determine whether the result at that point is a list or a map in this case and add the ALL into the selector?  Is there a built-in method for dealing with this?</z><z id="t1655452941" t="rolt you could use if-path or cond-path"><y>#</y><d>2022-06-17</d><h>08:02</h><r>rolt</r>you could use <code>if-path</code> or <code>cond-path</code></z><z id="t1655461134" t="pdmct thanks, will take a look at these"><y>#</y><d>2022-06-17</d><h>10:18</h><r>pdmct</r>thanks, will take a look at these</z><z id="t1656504194" t="hanDerPeder given [{:id 1 :some {:nested {:value 11}}} {:id 2 :some {:nested {:value 3}}}] I want to remove all top-level objects where [:some :nested :value] is greater than 10. How do I do that?"><y>#</y><d>2022-06-29</d><h>12:03</h><w>hanDerPeder</w>given
<pre>[{:id 1
    :some {:nested {:value 11}}}
   {:id 2
    :some {:nested {:value 3}}}]</pre>
I want to remove all top-level objects where <code>[:some :nested :value]</code> is greater than 10. How do I do that?</z><z id="t1656505023" t="hanDerPeder not correct: (transform (subselect ALL :some :nested :value #(&gt; % 10)) NONE data) gives: [{:id 1, :some {:nested {}}} {:id 2, :some {:nested {:value 3}}}] but I want: [{:id 2, :some {:nested {:value 3}}}] "><y>#</y><d>2022-06-29</d><h>12:17</h><w>hanDerPeder</w>not correct:
<pre>(transform
   (subselect ALL :some :nested :value #(&gt; % 10))
   NONE
   data)</pre>
gives:
<pre>[{:id 1, :some {:nested {}}} {:id 2, :some {:nested {:value 3}}}]</pre>
but I want:
<pre>[{:id 2, :some {:nested {:value 3}}}]</pre>
</z><z id="t1656505445" t="hanDerPeder this is close, but I feel I’m missing something (transform [ALL (fn [x] (&gt; (-&gt; x :some :nested :value) 10))] NONE data) =&gt; [nil {:id 2, :some {:nested {:value 3}}}]"><y>#</y><d>2022-06-29</d><h>12:24</h><w>hanDerPeder</w>this is close, but I feel I’m missing something
<pre>(transform
   [ALL (fn [x]
          (&gt; (-&gt; x :some :nested :value) 10))]
   NONE
   data)
=&gt; [nil {:id 2, :some {:nested {:value 3}}}]</pre></z><z id="t1656506043" t="hanDerPeder this does what i need: (setval [ALL (fn [x] (&gt; (-&gt; x :some :nested :value) 10))] NONE data) but I am expecting there to be something I can replace the function with. like: (setval [ALL (something [:some :nested :value #(&gt; % 10)])] NONE data)"><y>#</y><d>2022-06-29</d><h>12:34</h><w>hanDerPeder</w>this does what i need:
<pre>(setval
 [ALL (fn [x]
        (&gt; (-&gt; x :some :nested :value) 10))]
 NONE
 data)</pre>
but I am expecting there to be <code>something</code> I can replace the function with. like:
<pre>(setval
 [ALL (something [:some :nested :value #(&gt; % 10)])]
 NONE
 data)</pre></z><z id="t1656506376" t="rolt (setval (filterer :some :nested :value (pred&gt; 10)) [] data)"><y>#</y><d>2022-06-29</d><h>12:39</h><r>rolt</r><code>(setval (filterer :some :nested :value (pred&gt; 10)) [] data)</code></z><z id="t1656506555" t="hanDerPeder aha pred I see. why empty vector?"><y>#</y><d>2022-06-29</d><h>12:42</h><r>hanDerPeder</r>aha <code>pred</code> I see. why empty vector?</z><z id="t1656506626" t="rolt filterer works on a collection, it returns the filtered collection like filter"><y>#</y><d>2022-06-29</d><h>12:43</h><r>rolt</r>filterer works on a collection, it returns the filtered collection like filter</z><z id="t1656506671" t="rolt i don&apos;t think pred is necessary here, you can use your function directly"><y>#</y><d>2022-06-29</d><h>12:44</h><r>rolt</r>i don&apos;t think pred is necessary here, you can use your function directly</z><z id="t1656506831" t="hanDerPeder hmm, have to think on this. still don’t grok this. thanks!"><y>#</y><d>2022-06-29</d><h>12:47</h><r>hanDerPeder</r>hmm, have to think on this. still don’t grok this. thanks!</z><z id="t1656507025" t="rolt but i&apos;m surprised that (setval (subselect ALL :some :nested :value (pred&gt; 10)) [] data) doesn&apos;t work though"><y>#</y><d>2022-06-29</d><h>12:50</h><r>rolt</r>but i&apos;m surprised that <code>(setval (subselect ALL :some :nested :value (pred&gt; 10)) [] data)</code> doesn&apos;t work though</z><z id="t1656510415" t="rolt just though of something that you might prefer: (setval [ALL (if-path [:some :nested :value #(&gt; % 10)] STAY)] NONE data) . btw you could simply use filter/remove here, with selected-any? if you want to use specter for the path, or is it inside a nested structure too ?"><y>#</y><d>2022-06-29</d><h>13:46</h><r>rolt</r>just though of something that you might prefer: <code>(setval [ALL (if-path [:some :nested :value #(&gt; % 10)] STAY)] NONE data)</code>. btw you could simply use filter/remove here, with <code>selected-any?</code> if you want to use specter for the path, or is it inside a nested structure too ?</z><z id="t1656510520" t="rolt And even if the beginning is a path, it&apos;s just a select operation select-one (filterer :some :nested :value #(&lt; % 10))"><y>#</y><d>2022-06-29</d><h>13:48</h><r>rolt</r>And even if the beginning is a path, it&apos;s just a select operation <code>select-one (filterer :some :nested :value #(&lt; % 10))</code></z><z id="t1656618326" t="nathanmarz [:attrs {:href &quot;/_/_/users/U013U475882&quot;}] you&apos;re looking for selected?"><y>#</y><d>2022-06-30</d><h>19:45</h><w>nathanmarz</w><a>@peder.refsnes</a> you&apos;re looking for <code>selected?</code></z><z id="t1656673165" t="hanDerPeder thanks! :thumbsup:"><y>#</y><d>2022-07-01</d><h>10:59</h><r>hanDerPeder</r>thanks! <b>:thumbsup:</b></z><z id="t1656618328" t="nathanmarz (setval [ALL (selected? :some :nested :value (pred&gt; 10))] NONE data)"><y>#</y><d>2022-06-30</d><h>19:45</h><w>nathanmarz</w><code>(setval [ALL (selected? :some :nested :value (pred&gt; 10))] NONE data)</code></z><z id="t1656662740" t="Kris C [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] Thank you so much for specter! It makes my life easier 🙂 and you are absolutely right calling it &quot;Clojure&apos;s missing piece&quot;. Really, kudos for your excellent work! 👏"><y>#</y><d>2022-07-01</d><h>08:05</h><w>Kris C</w><a>@nathanmarz</a> Thank you so much for specter! It makes my life easier <b>🙂</b> and you are absolutely right calling it &quot;Clojure&apos;s missing piece&quot;. Really, kudos for your excellent work! <b>👏</b></z><z id="t1656817303" t="nathanmarz [:attrs {:href &quot;/_/_/users/U013100GJ14&quot;}] glad to hear"><y>#</y><d>2022-07-03</d><h>03:01</h><w>nathanmarz</w><a>@kristjan.cocev</a> glad to hear</z><z id="t1656851819" t="oskarkv I don&apos;t understand collect . When is it useful that the value is in a vector? I thought that maybe multiple collects in the path would add them to the vector, but for example (select [ALL (collect FIRST) (collect LAST)] {:a 1}) becomes [[[:a] [1] [:a 1]]] ."><y>#</y><d>2022-07-03</d><h>12:36</h><w>oskarkv</w>I don&apos;t understand <code>collect</code>. When is it useful that the value is in a vector? I thought that maybe multiple collects in the path would add them to the vector, but for example <code>(select [ALL (collect FIRST) (collect LAST)] {:a 1})</code> becomes <code>[[[:a] [1] [:a 1]]]</code>.</z><z id="t1656851949" t="oskarkv Oh, when the path given to collect results in multiple values."><y>#</y><d>2022-07-03</d><h>12:39</h><w>oskarkv</w>Oh, when the path given to <code>collect</code> results in multiple values.</z><z id="t1657607540" t="Benjamin Lets say I&apos;m into transducers is there a cheatsheet translating to specter. Also can i mix them?"><y>#</y><d>2022-07-12</d><h>06:32</h><w>Benjamin</w>Lets say I&apos;m into transducers is there a cheatsheet translating to specter. Also can i mix them?</z><z id="t1657608559" t="steveb8n my experience has been you want to use specter for single entity/map transforms and then compose those into chains of transducers. seems to be the best balance of readability and performance since specter (transform [ALL]…) isn’t really built for transducers"><y>#</y><d>2022-07-12</d><h>06:49</h><r>steveb8n</r>my experience has been you want to use specter for single entity/map transforms and then compose those into chains of transducers. seems to be the best balance of readability and performance since specter (transform [ALL]…) isn’t really built for transducers</z><z id="t1657608634" t="steveb8n that said, I haven’t benchmarked one vs the other. would be a fun way to learn the right answer"><y>#</y><d>2022-07-12</d><h>06:50</h><r>steveb8n</r>that said, I haven’t benchmarked one vs the other. would be a fun way to learn the right answer</z><z id="t1657608765" t="Benjamin :thumbsup:"><y>#</y><d>2022-07-12</d><h>06:52</h><r>Benjamin</r><b>:thumbsup:</b></z><z id="t1657673848" t="nathanmarz [:attrs {:href &quot;/_/_/users/U02CV2P4J6S&quot;}] check out traverse-all"><y>#</y><d>2022-07-13</d><h>00:57</h><w>nathanmarz</w><a>@benjamin.schwerdtner</a> check out <code>traverse-all</code></z><z id="t1657804344" t="Quentin Le Guennec Hello, is there a macro that combines transform + select , that is a macro that selects a path within the specified transform path without touching the original structure?"><y>#</y><d>2022-07-14</d><h>13:12</h><w>Quentin Le Guennec</w>Hello, is there a macro that combines <code>transform + select</code> , that is a macro that selects a path within the specified transform path without touching the original structure?</z><z id="t1658221036" t="rolt transformed within a select ? although you can just chain transform and select"><y>#</y><d>2022-07-19</d><h>08:57</h><r>rolt</r><code>transformed</code> within a select ? although you can just chain transform and select</z><z id="t1658387301" t="manas_marthi Hi Is Spector on maven central?"><y>#</y><d>2022-07-21</d><h>07:08</h><w>manas_marthi</w>Hi Is Spector on maven central?</z><z id="t1658747311" t="Prashant [:attrs {:href &quot;/_/_/users/U7ANZ2MTK&quot;}] It is available on https://mvnrepository.com/artifact/com.rpl/specter"><y>#</y><d>2022-07-25</d><h>11:08</h><r>Prashant</r><a>@U7ANZ2MTK</a> It is available on <a href="https://mvnrepository.com/artifact/com.rpl/specter" target="_blank">https://mvnrepository.com/artifact/com.rpl/specter</a></z><z id="t1658747428" t="Prashant https://clojars.org/com.rpl/specter already has maven specific info"><y>#</y><d>2022-07-25</d><h>11:10</h><r>Prashant</r><a href="https://clojars.org/com.rpl/specter" target="_blank">https://clojars.org/com.rpl/specter</a> already has maven specific info</z><z id="t1658756219" t="manas_marthi Hi ok. I just looked up https://search.maven.org/ . It is not there."><y>#</y><d>2022-07-25</d><h>13:36</h><r>manas_marthi</r>Hi ok. I just looked up <a href="https://search.maven.org/" target="_blank">https://search.maven.org/</a> . It is not there.</z><z id="t1658765527" t="Prashant This is the direct https://mvnrepository.com/artifact/com.rpl/specter"><y>#</y><d>2022-07-25</d><h>16:12</h><r>Prashant</r>This is the direct <a href="https://mvnrepository.com/artifact/com.rpl/specter" target="_blank">https://mvnrepository.com/artifact/com.rpl/specter</a></z><z id="t1658417723" t="Joshua Suskalo No, it&apos;s on clojars, which is where most clojure dependencies are stored. It&apos;s a maven repository you could add as a secondary repository."><y>#</y><d>2022-07-21</d><h>15:35</h><w>Joshua Suskalo</w>No, it&apos;s on clojars, which is where most clojure dependencies are stored. It&apos;s a maven repository you could add as a secondary repository.</z><z id="t1660869004" t="steveb8n Q: I always get stuck trying to do a transform with indexes i.e. like map-indexed. I can’t use INDEXED-VALS because I’m not trying to change ordering. What is the idiom here?"><y>#</y><d>2022-08-19</d><h>00:30</h><w>steveb8n</w>Q: I always get stuck trying to do a transform with indexes i.e. like map-indexed. I can’t use INDEXED-VALS because I’m not trying to change ordering. What is the idiom here?</z><z id="t1660899697" t="vimfun Hi, I am trying to transform some data, encountered some problem. (transform [(walker (fn [x] (when (instance? java.util.Map$Entry x) (let [[k v] x] (do (prn [k v]) (when (string? v) (re-matches #&quot;\d+&quot; v) ) ))))) (nthpath 1)] (fn [v] (Integer/parseInt v 10)) {:ind {:hanging &quot;1134&quot; :left &quot;1134&quot;}} ) ;; =&gt; {:ind {:hanging &quot;1134&quot; :left &quot;1134&quot;}} ;; Expected result: ;; {:ind {:hanging 1134 :left 1134}} Why transform not modify the value? Should I use recursive-path to do the work?"><y>#</y><d>2022-08-19</d><h>09:01</h><w>vimfun</w>Hi, I am trying to <code>transform</code> some data,  encountered some problem.

<pre>(transform [(walker (fn [x]
                      (when (instance? java.util.Map$Entry x)
                        (let [[k v] x]
                          (do (prn [k v])
                              (when (string? v)
                                (re-matches #&quot;\d+&quot; v)
                                )
                              ))))) (nthpath 1)]
           (fn [v] (Integer/parseInt v 10))
           {:ind {:hanging &quot;1134&quot; :left &quot;1134&quot;}}
           )
;; =&gt;      {:ind {:hanging &quot;1134&quot; :left &quot;1134&quot;}}

;; Expected result:
;;         {:ind {:hanging  1134  :left  1134}}</pre>
Why <code>transform</code> not modify the value?


Should I use <code>recursive-path</code> to do the work?</z><z id="t1660902832" t="rolt dev&gt; (select (walker (fn [x] (println x (type x)))) {:a 1}) {:a 1} clojure.lang.PersistentArrayMap [:a 1] clojure.lang.MapEntry :a clojure.lang.Keyword 1 java.lang.Long ;; =&gt; [] dev&gt; (transform (walker (fn [x] (println x (type x)))) (constantly nil) {:a 1}) {:a 1} clojure.lang.PersistentArrayMap [:a 1] clojure.lang.PersistentVector :a clojure.lang.Keyword 1 java.lang.Long ;; =&gt; {:a 1} looks like a bug"><y>#</y><d>2022-08-19</d><h>09:53</h><r>rolt</r><pre>dev&gt; (select (walker (fn [x] (println x (type x)))) {:a 1})
{:a 1} clojure.lang.PersistentArrayMap
[:a 1] clojure.lang.MapEntry
:a clojure.lang.Keyword
1 java.lang.Long
;; =&gt; []
dev&gt; (transform (walker (fn [x] (println x (type x)))) (constantly nil) {:a 1})
{:a 1} clojure.lang.PersistentArrayMap
[:a 1] clojure.lang.PersistentVector
:a clojure.lang.Keyword
1 java.lang.Long
;; =&gt; {:a 1}</pre>
looks like a bug</z><z id="t1660902894" t="rolt https://github.com/redplanetlabs/specter/issues/265"><y>#</y><d>2022-08-19</d><h>09:54</h><r>rolt</r><a href="https://github.com/redplanetlabs/specter/issues/265" target="_blank">https://github.com/redplanetlabs/specter/issues/265</a></z><z id="t1660905547" t="vimfun (transform (walker #(and (string? %) (re-matches #&quot;\d+&quot; %))) (fn [v] (Integer/parseInt v 10)) {:p {:pPr {:ind {:hanging &quot;1134&quot; :left &quot;1134&quot;}}}}) ;; =&gt; {:p {:pPr {:ind {:hanging 1134, :left 1134}}}} I use a simple walker . It works, now! Thanks."><y>#</y><d>2022-08-19</d><h>10:39</h><r>vimfun</r><pre>(transform (walker #(and (string? %) (re-matches #&quot;\d+&quot; %)))
             (fn [v]
               (Integer/parseInt v 10))
             {:p  {:pPr {:ind {:hanging &quot;1134&quot; :left &quot;1134&quot;}}}})
;; =&gt; {:p {:pPr {:ind {:hanging 1134, :left 1134}}}}</pre>
I use a simple <code>walker</code> . It works, now!

Thanks.</z><z id="t1661284677" t="nathanmarz [:attrs {:href &quot;/_/_/users/U0510KXTU&quot;}] you can still use INDEXED-VALS"><y>#</y><d>2022-08-23</d><h>19:57</h><w>nathanmarz</w><a>@steveb8n</a> you can still use <code>INDEXED-VALS</code></z><z id="t1661284735" t="nathanmarz (transform [INDEXED-VALS (collect-one FIRST) LAST] (fn [index v] ...) data)"><y>#</y><d>2022-08-23</d><h>19:58</h><w>nathanmarz</w><code>(transform [INDEXED-VALS (collect-one FIRST) LAST] (fn [index v] ...) data)</code></z><z id="t1661290841" t="steveb8n thanks [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] I’ll give this a try."><y>#</y><d>2022-08-23</d><h>21:40</h><r>steveb8n</r>thanks <a>@U173SEFUN</a> I’ll give this a try.</z><z id="t1661290888" t="steveb8n I’m sure this is a common blocker since the answer is non-obvious. I wonder if there’s a place in the docs where this could be mentioned?"><y>#</y><d>2022-08-23</d><h>21:41</h><r>steveb8n</r>I’m sure this is a common blocker since the answer is non-obvious. I wonder if there’s a place in the docs where this could be mentioned?</z><z id="t1661702239" t="Lidor Cohen Hello everyone 👋 , I&apos;m new to specter but I saw the talk and got really excited about the navigation abstraction that I had to try it out 😁 . As a small exercise to see that I&apos;m in the right direction: a navigator to all the leaves in a tree structure will look something like this: (walker #(not (col? %))) ?"><y>#</y><d>2022-08-28</d><h>15:57</h><w>Lidor Cohen</w>Hello everyone <b>👋</b>,
I&apos;m new to specter but I saw the talk and got really excited about the navigation abstraction that I had to try it out <b>😁</b>.
As a small exercise to see that I&apos;m in the right direction: a navigator to all the leaves in a tree structure will look something like this:
<pre>(walker #(not (col? %)))
</pre>
?</z><z id="t1661867828" t="Lidor Cohen anyone? 😅"><y>#</y><d>2022-08-30</d><h>13:57</h><r>Lidor Cohen</r>anyone? <b>😅</b></z><z id="t1662499400" t="FlavaDave https://github.com/latacora/eidolon"><y>#</y><d>2022-09-06</d><h>21:23</h><r>FlavaDave</r><a href="https://github.com/latacora/eidolon" target="_blank">https://github.com/latacora/eidolon</a></z><z id="t1662499426" t="FlavaDave there is a good example of what you wish to do in there"><y>#</y><d>2022-09-06</d><h>21:23</h><r>FlavaDave</r>there is a good example of what you wish to do in there</z><z id="t1661787910" t="Alexandre Gomes Hi! I&apos;m a Clojure newbie and found specter after googling for nested/complex data processing on Clojure. I am considering it for my learning journey and (hopefully) applying to some challenges I&apos;m currently facing, but I have a question regarding its functionality: Does specter allows flattening JSON data dynamically? And by that I mean: • Unnest each and every nested key without knowing their names or paths; • Explode each and every array key, also without knowing their names or paths; • Move all exploded/unnested keys to the top/root level; • Able to handle a moderate amount of JSON data at once (~2GB). The idea is to dynamically transform a deeply nested JSON into a flat data file (it can be CSV, JSON, Parquet, etc., anything works for me), that is, without knowing its keys beforehand. Currently, I have a Scala application that does this by recursively using ClassTag/reflective functions to check if each key is a Struct or an Array and then performing the necessary steps to make it flat. If this kind of task is not possible or recommended with specter, let me know if there are any other tools/libraries that you find to be better suited for this particular challenge."><y>#</y><d>2022-08-29</d><h>15:45</h><w>Alexandre Gomes</w>Hi! I&apos;m a Clojure newbie and found specter after googling for nested/complex data processing on Clojure. I am considering it for my learning journey and (hopefully) applying to some challenges I&apos;m currently facing, but I have a question regarding its functionality:

Does specter allows flattening JSON data dynamically? And by that I mean:
• Unnest each and every nested key without knowing their names or paths;
• Explode each and every array key, also without knowing their names or paths;
• Move all exploded/unnested keys to the top/root level;
• Able to handle a moderate amount of JSON data at once (~2GB).
The idea is to dynamically transform a deeply nested JSON into a flat data file (it can be CSV, JSON, Parquet, etc., anything works for me), that is, without knowing its keys beforehand.

Currently, I have a Scala application that does this by recursively using ClassTag/reflective functions to check if each key is a <code>Struct</code> or an <code>Array</code> and then performing the necessary steps to make it flat.

If this kind of task is not possible or recommended with specter, let me know if there are any other tools/libraries that you find to be better suited for this particular challenge.</z><z id="t1661788035" t="pppaul i&apos;ve done this with clojure/walk and merge-with"><y>#</y><d>2022-08-29</d><h>15:47</h><r>pppaul</r>i&apos;ve done this with clojure/walk and merge-with</z><z id="t1661791524" t="isak Probably possible with specter, but not sure. You may be interested in this, depending on your use case: https://github.com/cloojure/tupelo/blob/master/docs/forest.adoc"><y>#</y><d>2022-08-29</d><h>16:45</h><r>isak</r>Probably possible with specter, but not sure. You may be interested in this, depending on your use case: <a href="https://github.com/cloojure/tupelo/blob/master/docs/forest.adoc" target="_blank">https://github.com/cloojure/tupelo/blob/master/docs/forest.adoc</a></z><z id="t1661791607" t="pppaul always wanted to get around to learning forest"><y>#</y><d>2022-08-29</d><h>16:46</h><r>pppaul</r>always wanted to get around to learning forest</z><z id="t1661791724" t="isak Yea it seems like a great idea. I&apos;m not sure he mentions it on that page, but the way it works is by flattening the tree, which is what the OP was asking about."><y>#</y><d>2022-08-29</d><h>16:48</h><r>isak</r>Yea it seems like a great idea. I&apos;m not sure he mentions it on that page, but the way it works is by flattening the tree, which is what the OP was asking about.</z><z id="t1661793133" t="Alexandre Gomes Thanks for the suggestions [:attrs {:href &quot;/_/_/users/U0LAJQLQ1&quot;}] and [:attrs {:href &quot;/_/_/users/U08JKUHA9&quot;}] , much appreciated. I will take a good look on these alternatives!"><y>#</y><d>2022-08-29</d><h>17:12</h><r>Alexandre Gomes</r>Thanks for the suggestions <a>@U0LAJQLQ1</a> and <a>@U08JKUHA9</a>, much appreciated. I will take a good look on these alternatives!</z><z id="t1661793351" t="Alexandre Gomes Do you think I would be able to generate data in a tabular format using the tupelo.forest library? After flattening the structure, that is. I ask this because I also have JSON datasets that have similar structure, however those need to become tables after they are flattened."><y>#</y><d>2022-08-29</d><h>17:15</h><r>Alexandre Gomes</r>Do you think I would be able to generate data in a tabular format using the <code>tupelo.forest</code> library? After flattening the structure, that is.
I ask this because I also have JSON datasets that have similar structure, however those need to become tables after they are flattened.</z><z id="t1661793899" t="isak I think so, yea. But haven&apos;t looked very closely beyond the talk and article."><y>#</y><d>2022-08-29</d><h>17:24</h><r>isak</r>I think so, yea. But haven&apos;t looked very closely beyond the talk and article.</z><z id="t1661794520" t="Alexandre Gomes Great! Thanks for the reply, [:attrs {:href &quot;/_/_/users/U08JKUHA9&quot;}]"><y>#</y><d>2022-08-29</d><h>17:35</h><r>Alexandre Gomes</r>Great! Thanks for the reply, <a>@U08JKUHA9</a></z><z id="t1661795111" t="pppaul flatting nested objects is pretty easy, cept for how you want to name the keys that are are based on 10+ levels of aggregate keys"><y>#</y><d>2022-08-29</d><h>17:45</h><r>pppaul</r>flatting nested objects is pretty easy, cept for how you want to name the keys that are are based on 10+ levels of aggregate keys</z><z id="t1661795384" t="Alexandre Gomes [:attrs {:href &quot;/_/_/users/U0LAJQLQ1&quot;}] In my Scala application, I take the parent&apos;s key name and use it as a prefix for the &quot;child&quot; key. As you can imagine, the names get pretty big, but it works fine for my purpose. I honestly have no idea how to do that on Clojure yet, though 😂"><y>#</y><d>2022-08-29</d><h>17:49</h><r>Alexandre Gomes</r><a>@U0LAJQLQ1</a> In my Scala application, I take the parent&apos;s key name and use it as a prefix for the &quot;child&quot; key. As you can imagine, the names get pretty big, but it works fine for my purpose. I honestly have no idea how to do that on Clojure yet, though <b>😂</b></z><z id="t1661795948" t="pppaul when i did this i made my key names similar to what i would use for (get-in args for the original json (minus array indices)"><y>#</y><d>2022-08-29</d><h>17:59</h><r>pppaul</r>when i did this i made my key names similar to what i would use for <code>(get-in</code> args for the original json (minus array indices)</z><z id="t1661795994" t="pppaul if you do something like that, then you can have a name function that does something smart with that type of data"><y>#</y><d>2022-08-29</d><h>17:59</h><r>pppaul</r>if you do something like that, then you can have a name function that does something smart with that type of data</z><z id="t1664100436" t="Lidor Cohen Hi! I&apos;m looking for a way to do some kind of smart merge based on nodes / leaves properties. My intuition is to make a navigator that takes a vector of maps and traverse all of them and based on some predicate on the node pass all corresponding values (same path in each map) to a merging function. Anyone got any pointers?"><y>#</y><d>2022-09-25</d><h>10:07</h><w>Lidor Cohen</w>Hi! I&apos;m looking for  a way to do some kind of smart merge based on nodes / leaves properties.
My intuition is to make a navigator that takes a vector of maps and traverse all of them and based on some predicate on the node pass all corresponding values (same path in each map) to a merging function.
Anyone got any pointers?</z><z id="t1666730540" t="branch14 Is there a way to use (nthpath x) on a vector only if it has index x, and otherwise stop navigation?"><y>#</y><d>2022-10-25</d><h>20:42</h><w>branch14</w>Is there a way to use <code>(nthpath x)</code> on a vector only if it has index x, and otherwise stop navigation?</z><z id="t1666760501" t="nathanmarz [:attrs {:href &quot;/_/_/users/U170T0Y3H&quot;}] you can use must"><y>#</y><d>2022-10-26</d><h>05:01</h><w>nathanmarz</w><a>@branch14</a> you can use <code>must</code></z><z id="t1669218937" t="borkdude [:attrs {:href &quot;/_/_/users/U173SEFUN&quot;}] Some people have asked me about clj-kondo configuration for specter, which is documented here: https://github.com/redplanetlabs/specter#clj-kondo There is a way to package this config with the library so when people use clj-kondo or clojure-lsp and have specter on their project&apos;s classpath they will automatically receive this config and linting automatically works. Last time I asked about this your concern was that the artifact would become bigger. I&apos;m not sure if we understood each other well then, but it&apos;s just about including this one edn file in resources/... . It&apos;s now also possible to have this configuration in a third party library and all people have to do is to include that extra library. It&apos;s one extra step, which is less convenient, but doable. Is your preference still to keep the config out of the library? If so, we&apos;ll continue with the third party library. cc [:attrs {:href &quot;/_/_/users/UKFSJSM38&quot;}] (clojure-lsp). Thanks."><y>#</y><d>2022-11-23</d><h>15:55</h><w>borkdude</w><a>@nathanmarz</a> Some people have asked me about clj-kondo configuration for specter, which is documented here:
<a href="https://github.com/redplanetlabs/specter#clj-kondo" target="_blank">https://github.com/redplanetlabs/specter#clj-kondo</a>

There is a way to package this config with the library so when people use clj-kondo or clojure-lsp and have specter on their project&apos;s classpath they will automatically receive this config and linting automatically works.

Last time I asked about this your concern was that the artifact would become bigger. I&apos;m not sure if we understood each other well then, but it&apos;s just about including this one edn file in <code>resources/...</code> .

It&apos;s now also possible to have this configuration in a third party library and all people have to do is to include that extra library. It&apos;s one extra step, which is less convenient, but doable.

Is your preference still to keep the config out of the library? If so, we&apos;ll continue with the third party library.  cc <a>@ericdallo</a> (clojure-lsp). Thanks.</z><z id="t1669514581" t="nathanmarz [:attrs {:href &quot;/_/_/users/U04V15CAJ&quot;}] yea, would rather keep it in a 3rd party library"><y>#</y><d>2022-11-27</d><h>02:03</h><w>nathanmarz</w><a>@borkdude</a> yea, would rather keep it in a 3rd party library</z></g></div></body>